con
	_clkfreq = 340500000
	_clkmode = 27175163
	fbReadOnly = 1
	fbHidden = 2
	fbSystem = 4
	fbDirectory = 16
	fbArchive = 32
	fbNormal = 33
	HEAPSIZE = 96000
	ver = 49
	key_enter = 141
	key_escape = 155
	key_backspace = 136
	key_tab = 137
	key_f1 = 186
	key_f2 = 187
	key_f3 = 188
	key_f4 = 189
	key_f5 = 190
	key_f6 = 191
	key_f7 = 192
	key_f8 = 193
	key_f9 = 194
	key_f10 = 195
	key_f11 = 196
	key_f12 = 197
	key_rightarrow = 206
	key_leftarrow = 207
	key_downarrow = 208
	key_uparrow = 209
	token_plus = 1
	token_minus = 2
	token_or = 3
	token_xor = 4
	token_mul = 5
	token_fdiv = 6
	token_and = 7
	token_div = 8
	token_mod = 9
	token_shl = 10
	token_shr = 11
	token_power = 12
	token_not = 13
	token_at = 14
	token_gt = 15
	token_lt = 16
	token_comma = 17
	token_semicolon = 18
	token_ear = 19
	token_rpar = 20
	token_lpar = 21
	token_colon = 22
	fun_getvar = 17
	fun_getaddr = 18
	fun_getfvar = 19
	fun_getsvar = 20
	fun_negative = 21
	fun_converttoint = 22
	fun_assign = 23
	fun_assign_i = 23
	fun_assign_u = 24
	fun_assign_f = 25
	fun_assign_s = 26
	token_eq = 27
	fun_pushi = 28
	fun_pushu = 29
	fun_pushf = 30
	fun_pushs = 31
	print_mod_empty = 32
	print_mod_comma = 33
	print_mod_semicolon = 34
	token_linenum_major = 35
	token_linenum_minor = 36
	token_nextline_ptr = 37
	token_le = 38
	token_ge = 39
	token_inc = 40
	token_dec = 41
	token_ne = 42
	fun_pushs2 = 43
	token_channel = 44
	token_skip = 45
	token_cls = 64
	token_new = 65
	token_plot = 66
	token_draw = 67
	token_print = 68
	token_circle = 69
	token_fcircle = 70
	token_box = 71
	token_frame = 72
	token_color = 73
	token_for = 74
	token_next = 75
	token_list = 76
	token_run = 77
	token_fast_goto = 78
	token_slow_goto = 79
	token_save = 81
	token_load = 82
	token_find_goto = 83
	token_rnd = 84
	token_pinwrite = 85
	token_waitms = 86
	token_waitvbl = 87
	token_if = 88
	token_brun = 89
	token_else = 90
	token_then = 91
	token_beep = 92
	token_dir = 93
	token_paper = 94
	token_ink = 95
	token_font = 96
	token_mode = 97
	token_gettime = 98
	token_mouse = 99
	token_mousex = 100
	token_mousey = 101
	token_mousek = 102
	token_mousew = 103
	token_cursor = 104
	token_click = 105
	token_stick = 106
	token_sin = 107
	token_defsprite = 108
	token_sprite = 109
	token_strig = 110
	token_getpixel = 111
	token_waitclock = 112
	token_fill = 113
	token_dim = 114
	token_defsnd = 115
	token_defenv = 116
	token_play = 117
	token_rdpin = 118
	token_wxpin = 119
	token_wypin = 120
	token_wrpin = 121
	token_rqpin = 122
	token_pinread = 123
	token_pinfloat = 124
	token_pinlo = 125
	token_pinhi = 126
	token_pinstart = 127
	token_pintoggle = 128
	token_position = 129
	token_cos = 130
	token_tan = 131
	token_asin = 132
	token_acos = 133
	token_atn = 134
	token_sqr = 135
	token_rad = 136
	token_deg = 137
	token_int = 138
	token_setvol = 139
	token_setpan = 140
	token_setlen = 141
	token_setdelay = 142
	token_setwave = 143
	token_setenv = 144
	token_setsustain = 145
	token_release = 146
	token_getenvsustain = 147
	token_getnotevalue = 148
	token_poke = 149
	token_dpoke = 150
	token_lpoke = 151
	token_peek = 152
	token_dpeek = 153
	token_lpeek = 154
	token_adr = 155
	token_fre = 156
	token_inkey = 157
	token_abs = 158
	token_chr = 159
	token_val = 160
	token_str = 161
	token_bin = 162
	token_hex = 163
	token_left = 164
	token_right = 165
	token_mid = 166
	token_asc = 167
	token_len = 168
	token_gosub = 169
	token_return = 170
	token_progend = 171
	token_pop = 172
	token_log = 173
	token_changefreq = 174
	token_changevol = 175
	token_changewave = 176
	token_changepan = 177
	token_shutup = 178
	token_open = 179
	token_close = 180
	token_input = 181
	token_read = 182
	token_data = 183
	token_blit = 185
	token_get = 187
	token_put = 188
	token_enter = 189
	token_rem = 190
	token_round = 191
	token_coginit = 192
	token_on = 193
	token_delete = 194
	token_cd = 195
	token_copy = 196
	token_framebuf = 197
	token_mkdir = 198
	token_restore = 199
	token_padx = 200
	token_pady = 201
	token_padz = 202
	token_padh = 203
	token_padrx = 204
	token_padry = 205
	token_padrz = 206
	token_cogstop = 207
	token_memlo = 208
	token_memtop = 209
	token_setcolor = 210
	token_getcolor = 211
	token_restorepalette = 212
	token_pads = 213
	token_padw = 214
	token_findfirst = 215
	token_findnext = 216
	token_defchar = 217
	token_setamode = 218
	token_getrealfreq = 219
	token_error = 255
	token_end = 510
	token_space = 511
	token_decimal = 512
	token_integer = 513
	token_float = 514
	token_string = 515
	token_name = 516
	token_notename = 768
	result_int = 28
	result_uint = 29
	result_float = 30
	result_string = 31
	result_string2 = 43
	result_array = 114
	result_error = 255
	result_channel = 44
	array_no_type = 256
	array_byte = 257
	array_ubyte = 258
	array_short = 259
	array_ushort = 260
	array_long = 261
	array_ulong = 262
	array_int64 = 263
	array_uint64 = 264
	array_float = 265
	array_double = 266
	array_string = 267
	maxvars = 1024
	maxstack = 512
	maxfor = 64
	maxgosub = 64
	memlo = 524288
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 340500000
	long	0 ' clock mode: will default to $19ea8fb
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##27175160
	waitx	##200000
	mov	pa, ##27175163
	hubset	pa
	wrlong	pa, #24
	wrlong	##340500000, #20
	jmp	#skip_clock_set_
	orgf	192
skip_clock_set_
	call	#_program
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    mov	fcache_tmpb_,ptrb
    pop	ptrb
    altd	pa,ret_instr_
    mov	 0-0, ret_instr_
    setq	pa
    rdlong	$0, ptrb++
    push	ptrb
    mov ptrb,fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    _ret_ cmp inb,#0
fcache_tmpb_
    long 0
fcache_load_ptr_
    long FCACHE_LOAD_
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret
COUNT_
    long 0
RETADDR_
    long 0
fp
    long 0
pushregs_
    pop  pa
    pop  RETADDR_
    tjz  COUNT_, #pushregs_done_
    altd  COUNT_, #511
    setq #0-0
    wrlong local01, ptra++
pushregs_done_
    setq #2 ' push 3 registers starting at COUNT_
    wrlong COUNT_, ptra++
    mov    fp, ptra
    jmp  pa
 popregs_
    pop    pa
    setq   #2
    rdlong COUNT_, --ptra
    djf    COUNT_, #popregs__ret
    setq   COUNT_
    rdlong local01, --ptra
popregs__ret
    push   RETADDR_
    jmp    pa

divide_
       abs     muldivb_,muldivb_     wcz      'abs(y)
       wrc     itmp2_                         'store sign of y
       abs     muldiva_,muldiva_     wc       'abs(x)
       qdiv    muldiva_, muldivb_             'queue divide
 if_c  xor     itmp2_,#1                      'store sign of x
       getqx   muldivb_                       'get quotient
       getqy   muldiva_                       'get remainder
       negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
       testb   itmp2_,#0             wc       'restore sign, division result
 _ret_ negc    muldivb_,muldivb_     
__pc long 0
__setjmp
    pop __pc
    mov result1, #0
    mov result2, #0
    mov abortchain, arg01
    wrlong fp, arg01
    add arg01, #4
    wrlong ptra, arg01
    add arg01, #4
    wrlong objptr, arg01
    add arg01, #4
    wrlong __pc, arg01
    jmp __pc
__unwind_pc long 0
__unwind_stack
   pop  __unwind_pc
__unwind_loop
   cmp  arg01, arg02 wz
  if_z jmp #__unwind_stack_ret
   mov   ptra, arg01
   call  #popregs_
   mov   arg01, fp
   jmp   #__unwind_loop
__unwind_stack_ret
   jmp  __unwind_pc
__longjmp
    pop __pc
    cmp    arg01, #0 wz
 if_z jmp #nocatch
    mov result1, arg02
    mov result2, #1
    rdlong arg02, arg01
    add arg01, #4
    rdlong ptra, arg01
    add arg01, #4
    rdlong objptr, arg01
    add arg01, #4
    rdlong __pc, arg01
    mov arg01, fp
    call #__unwind_stack
__longjmp_ret
    jmp  __pc
nocatch
    cmp arg03, #0 wz
 if_z jmp #cogexit
    jmp #__longjmp_ret

__heap_ptr
	long	@__heap_base
__methods__
	long	@__methodtable__
abortchain
	long	0
entryptr__
	long	@entry
itmp1_
	long	0
itmp2_
	long	0
objptr
	long	@objmem
ptr__Audio2_004_spin2_dat__
	long	@_Audio2_004_spin2_dat_
ptr__Hg010b_4_spin2_dat__
	long	@_Hg010b_4_spin2_dat_
ptr___system__dat__
	long	@__system__dat_
ptr__dat__
	long	@_dat_
ptr__fatfs_cc_dat__
	long	@_fatfs_cc_dat_
ptr__housekeeper_
	long	@_housekeeper
ptr__psram4_spin2_dat__
	long	@_psram4_spin2_dat_
ptr__psram4drv_spin2_dat__
	long	@_psram4drv_spin2_dat_
ptr__usbnew_spin2_dat__
	long	@_usbnew_spin2_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
result2
	long	1
result3
	long	2
COG_BSS_START
	fit	480
	orgh
hubentry

' 
' '-------------------------------------------------------------------------------------------------------- 
' '------------------------------------ MAIN LOOP END -----------------------------------------------------
' '--------------------------------------------------------------------------------------------------------
' 
' ''-------------------------------------------------------------------------------------------------------
' '                     A full screen editor for programming and entering data
' ''-------------------------------------------------------------------------------------------------------
' 
' function edit() as string
_edit
	mov	COUNT_, #27
	call	#pushregs_
	mov	local01, #0
	mov	local02, #0
	mov	local03, #0
	mov	local04, #0
' rpt=0 : rptcnt=0 : key=0 : key2=0 : key3=0 : key4=0 
' do
LR__0001
	mov	arg01, #1
	call	#_Hg010b_4_spin2_waitvbl
	call	#_usbnew_spin2_get_key
	mov	local05, result1
'   return hkbd_led_rep
	add	ptr__usbnew_spin2_dat__, ##10208
	rdbyte	result1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10208
	add	objptr, ##43196
	wrlong	result1, objptr
	sub	objptr, ##43196
' if key>0 andalso key<4 andalso keyclick=1 then audio.play16(7,@atari2_spl,43,4096,1758,0,300) : audio.stop(7)
	cmp	local05, #1 wc
 if_b	jmp	#LR__0002
	cmp	local05, #4 wc
 if_ae	jmp	#LR__0002
	add	objptr, ##42208
	rdlong	local06, objptr
	sub	objptr, ##42208
	cmp	local06, #1 wz
 if_ne	jmp	#LR__0002
	mov	arg02, ptr__dat__
	add	arg02, ##2212
	mov	local07, #43
	decod	local08, #12
	mov	local09, ##1758
	mov	local10, #0
	mov	local11, #300
	mov	arg01, #7
	mov	arg03, #43
	decod	arg04, #12
	mov	arg05, ##1758
	mov	arg06, #0
	mov	arg07, #300
	add	objptr, ##5836
	call	#_Audio2_004_spin2_play16
	mov	local06, #7
' 
' base2:=@channel0[0]+64*channel
	mov	local12, objptr
' word[base2+32]:=0
	add	local12, #492
	wrword	#0, local12
	sub	objptr, ##5836
LR__0002
' if key>3 andalso key<$80000000 andalso (key and 255) <$E0 then key2=key : rpt=1 : key3=key2 
	cmp	local05, #4 wc
 if_b	jmp	#LR__0003
	cmp	local05, ##-2147483648 wc
 if_b	mov	local06, local05
 if_b	getbyte	local06, local06, #0
 if_b	cmp	local06, #224 wc
 if_b	mov	local03, local05
 if_b	mov	local01, #1
 if_b	mov	local04, local03
LR__0003
' if key>$80000000 then rptcnt=0 : rpt=0
	cmp	local05, ##-2147483647 wc
 if_ae	mov	local02, #0
 if_ae	mov	local01, #0
' if key=0 andalso rpt=1 then rptcnt+=1
	cmp	local05, #0 wz
 if_e	cmp	local01, #1 wz
 if_e	add	local02, #1
' if key<$80000000 then if rptcnt=25 then key3=key2 : rptcnt=21
	cmp	local05, ##-2147483648 wc
 if_b	cmp	local02, #25 wz
 if_c_and_z	mov	local04, local03
 if_c_and_z	mov	local02, #21
' 
' '' there is a key pressed and it needs to be processed
' 
' if key3<>0 then
	cmp	local04, #0 wz
 if_e	jmp	#LR__0001
'   if keyclick=1 then audio.play16(7,keyclick_spl,43,4096,spl_len,spl_len,0) ' make a click
	add	objptr, ##42208
	rdlong	local06, objptr
	sub	objptr, ##42208
	cmp	local06, #1 wz
 if_ne	jmp	#LR__0004
	add	objptr, ##43136
	rdlong	arg02, objptr
	mov	local07, #43
	decod	local08, #12
	sub	objptr, #4
	rdlong	local10, objptr
	mov	local09, local10
	mov	local11, #0
	mov	arg01, #7
	mov	arg03, #43
	decod	arg04, #12
	mov	arg05, local09
	mov	arg06, local10
	mov	arg07, #0
	sub	objptr, ##37296
	call	#_Audio2_004_spin2_play16
	sub	objptr, ##5836
LR__0004
	mov	arg01, local04
	call	#_scantochar
	mov	local13, result1
'   if leds and 2 = 2 then 						' caps lock
	add	objptr, ##43196
	rdlong	local14, objptr
	sub	objptr, ##43196
	mov	local06, local14 wz
 if_e	jmp	#LR__0012
'     if key4>96 andalso key4<123 then                 
	cmp	local13, #97 wc
 if_b	jmp	#LR__0005
	cmp	local13, #123 wc
 if_b	sub	local13, #32
 if_b	jmp	#LR__0011
LR__0005
	cmp	local13, #65 wc
 if_b	jmp	#LR__0006
	cmp	local13, #91 wc
 if_b	add	local13, #32
 if_b	jmp	#LR__0010
LR__0006
	cmp	local13, #23 wc
 if_b	jmp	#LR__0007
	cmp	local13, #32 wc
 if_b	sub	local13, #9
 if_b	jmp	#LR__0009
LR__0007
	cmp	local13, #14 wc
 if_b	jmp	#LR__0008
	cmp	local13, #23 wc
 if_b	add	local13, #39
LR__0008
LR__0009
LR__0010
LR__0011
LR__0012
'  
'   if key4>0 andalso key4<127 andalso v.cursor_x<254 then		' put the char on the screen 
	cmp	local13, #1 wc
 if_b	jmp	#LR__0017
	cmp	local13, #127 wc
 if_b	add	objptr, #60
 if_b	rdword	local06, objptr
 if_b	sub	objptr, #60
 if_b	cmp	local06, #254 wc
 if_ae	jmp	#LR__0017
'     if do_insert then							' move the characters right
	add	objptr, ##43172
	rdlong	local06, objptr wz
	sub	objptr, ##43172
 if_e	jmp	#LR__0016
'       for i=  v.textbuf_ptr+128*v.cursor_y+127 to v.textbuf_ptr+128*v.cursor_y+(v.cursor_x/2)+1 step -1 : pspoke i,pspeek(i-1) : next i 
	add	objptr, #62
	rdbyte	local07, objptr
	getbyte	local08, local07, #0
	shl	local08, #7
	sub	objptr, #58
	rdlong	local15, objptr
	mov	local16, local15
	add	local16, local08
	add	local16, #127
	getbyte	local07, local07, #0
	shl	local07, #7
	add	local15, local07
	add	objptr, #56
	rdword	local09, objptr
	sub	objptr, #60
	abs	local11, local09 wc
	shr	local11, #1
	sumc	local15, local11
	add	local15, #1
LR__0013
	mov	local17, local16
	sub	local17, #1
	mov	arg01, local17
	call	#_pspeek
	mov	local18, result1
	getbyte	local19, local18, #0
	mov	local20, local19
	mov	arg01, local16
	mov	arg02, local20
	call	#_pspoke
	sub	local16, #1
	cmps	local16, local15 wc
 if_ae	jmp	#LR__0013
	add	objptr, ##43204
	wrlong	#0, objptr
	sub	objptr, ##43142
	rdbyte	local07, objptr
	getbyte	local08, local07, #0
	shl	local08, #7
	sub	objptr, #58
	rdlong	local09, objptr
	mov	local16, local09
	add	local16, local08
	add	objptr, #56
	rdword	local11, objptr
	getword	local10, local11, #0
	abs	local21, local10 wc
	shr	local21, #1
	negc	local21, local21
	add	local16, local21
	getbyte	local07, local07, #0
	shl	local07, #7
	mov	local08, local09
	sub	objptr, #60
	mov	local22, local08
	add	local22, local07
	add	local22, #128
LR__0014
	cmps	local16, local22 wc
 if_ae	jmp	#LR__0015
	add	objptr, #60
	rdword	local06, objptr
	add	objptr, ##43144
	rdlong	local08, objptr
	shl	local08, #1
	add	local06, local08
	sub	objptr, ##43142
	rdbyte	local14, objptr
	sub	objptr, #62
	shl	local14, #4
	add	local14, #4
	mov	arg01, local16
	call	#_pspeek
	getbyte	local07, result1, #0
	add	objptr, #65
	rdlong	local08, objptr
	add	objptr, #4
	rdlong	local10, objptr
	sub	objptr, #69
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local14
	mov	arg03, local07
	mov	arg04, local08
	mov	arg05, local09
	call	#_Hg010b_4_spin2_putcharxycgf
	add	objptr, ##43204
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##43204
	add	local16, #1
	jmp	#LR__0014
LR__0015
LR__0016
	mov	arg01, local13
	call	#_Hg010b_4_spin2_putchar
LR__0017
'   if key4>0 andalso key4<127 andalso v.cursor_x=254 andalso keyclick=1 then
	cmp	local13, #1 wc
 if_b	jmp	#LR__0018
	cmp	local13, #127 wc
 if_ae	jmp	#LR__0018
	add	objptr, #60
	rdword	local06, objptr
	sub	objptr, #60
	cmp	local06, #254 wz
 if_e	add	objptr, ##42208
 if_e	rdlong	local08, objptr
 if_e	sub	objptr, ##42208
 if_e	mov	local07, local08
 if_e	cmp	local07, #1 wz
 if_ne	jmp	#LR__0018
	mov	arg02, ptr__dat__
	add	arg02, ##2212
	mov	local07, #43
	decod	local08, #12
	mov	local09, ##1758
	mov	local10, #0
	mov	local11, #300
	mov	arg01, #7
	mov	arg03, #43
	decod	arg04, #12
	mov	arg05, ##1758
	mov	arg06, #0
	mov	arg07, #300
	add	objptr, ##5836
	call	#_Audio2_004_spin2_play16
' 
' base2:=@channel0[0]+64*channel
	mov	local12, objptr
	mov	arg01, #448
' word[base2+32]:=0
	add	local12, #492
	wrword	#0, local12
	sub	objptr, ##5836
LR__0018
'     
'   if key4=key_enter then 						' get the line from the  screen and return it
	cmp	local13, #141 wz
 if_ne	jmp	#LR__0022
	mov	local23, ##@LR__5487
'     line$="" 
'     for i=editor_spaces to 127
	add	objptr, ##29144
	rdlong	local16, objptr
	sub	objptr, ##29144
LR__0019
	cmps	local16, #128 wc
 if_ae	jmp	#LR__0020
	add	objptr, #62
	rdbyte	local11, objptr
	shl	local11, #7
	sub	objptr, #58
	rdlong	arg01, objptr
	sub	objptr, #4
	add	arg01, local11
	add	arg01, local16
	call	#_pspeek
	getbyte	arg01, result1, #0
	call	#__system__Chr_S
	mov	arg02, result1
	mov	arg01, local23
	call	#__system___string_concat
	mov	local23, result1
	add	local16, #1
	jmp	#LR__0019
LR__0020
'     if do_insert andalso v.cursor_y<35 then v.scrolldown(v.cursor_y+1)
	add	objptr, ##43172
	rdlong	local06, objptr wz
	sub	objptr, ##43172
 if_e	jmp	#LR__0021
	add	objptr, #62
	rdbyte	local07, objptr
	sub	objptr, #62
	cmp	local07, #35 wc
 if_b	add	objptr, #62
 if_b	rdbyte	arg01, objptr
 if_b	sub	objptr, #62
 if_b	add	arg01, #1
 if_b	call	#_Hg010b_4_spin2_scrolldown
LR__0021
	call	#_Hg010b_4_spin2_crlf
'     v.crlf() 
'     return  line$
	mov	result1, local23
	jmp	#LR__0049
LR__0022
	getbyte	local13, local04, #0
'   
'   if key4 = 43 andalso v.cursor_x>=240 andalso keyclick=1 then audio.play16(7,@atari2_spl,43,4096,1758,0,300) : audio.stop(7)  			' tab
	cmp	local13, #43 wz
 if_ne	jmp	#LR__0023
	add	objptr, #60
	rdword	local06, objptr
	sub	objptr, #60
	cmp	local06, #240 wc
 if_b	jmp	#LR__0023
	add	objptr, ##42208
	rdlong	local08, objptr
	sub	objptr, ##42208
	mov	local07, local08
	cmp	local07, #1 wz
 if_ne	jmp	#LR__0023
	mov	arg02, ptr__dat__
	add	arg02, ##2212
	mov	local07, #43
	decod	local08, #12
	mov	local09, ##1758
	mov	local10, #0
	mov	local11, #300
	mov	arg01, #7
	mov	arg03, #43
	decod	arg04, #12
	mov	arg05, ##1758
	mov	arg06, #0
	mov	arg07, #300
	add	objptr, ##5836
	call	#_Audio2_004_spin2_play16
' 
' base2:=@channel0[0]+64*channel
	mov	local12, objptr
	mov	arg01, #448
' word[base2+32]:=0
	add	local12, #492
	wrword	#0, local12
	sub	objptr, ##5836
LR__0023
'   if key4=77 then i=127 : do: 															' end
	cmp	local13, #77 wz
 if_ne	jmp	#LR__0028
	mov	local16, #127
LR__0024
'     if pspeek(v.textbuf_ptr+128*v.cursor_y+i)<>32 then 
	add	objptr, #62
	rdbyte	local09, objptr
	getbyte	local08, local09, #0
	mov	local10, local08
	shl	local10, #7
	sub	objptr, #58
	rdlong	local11, objptr
	sub	objptr, #4
	mov	local07, local11
	add	local07, local10
	add	local07, local16
	mov	arg01, local07
	call	#_pspeek
	getbyte	local06, result1, #0
	cmp	local06, #32 wz
 if_e	jmp	#LR__0026
'       if i<127 then v.setcursorx(2*i+2) else v.setcursorx(254)
	cmps	local16, #127 wc
 if_ae	jmp	#LR__0025
	mov	local07, local16
	shl	local07, #1
	mov	arg01, local07
	add	arg01, #2
	call	#_Hg010b_4_spin2_setcursorx
	jmp	#LR__0027
LR__0025
	mov	arg01, #254
	call	#_Hg010b_4_spin2_setcursorx
	jmp	#LR__0027
LR__0026
	sub	local16, #1
	add	objptr, ##29144
	rdlong	local06, objptr
	sub	objptr, ##29144
	cmp	local16, local06 wz
 if_ne	jmp	#LR__0024
LR__0027
LR__0028
'   if i=editor_spaces then v.setcursorx(2*editor_spaces)
	add	objptr, ##29144
	rdlong	local14, objptr
	sub	objptr, ##29144
	mov	local06, local14
	cmp	local16, local06 wz
 if_ne	jmp	#LR__0029
	add	objptr, ##29144
	rdlong	local08, objptr
	sub	objptr, ##29144
	mov	local07, local08
	mov	local14, local07
	shl	local14, #1
	mov	local06, local14
	mov	arg01, local06
	call	#_Hg010b_4_spin2_setcursorx
LR__0029
'     
'   if key4=74 then v.setcursorx(editor_spaces*2)													' home
	cmp	local13, #74 wz
 if_ne	jmp	#LR__0030
	add	objptr, ##29144
	rdlong	local08, objptr
	sub	objptr, ##29144
	mov	local07, local08
	mov	local14, local07
	shl	local14, #1
	mov	local06, local14
	mov	arg01, local06
	call	#_Hg010b_4_spin2_setcursorx
LR__0030
'   if key4=75 then v.setcursory(0)														' pgup
	cmp	local13, #75 wz
 if_e	mov	local06, #0
 if_e	mov	arg01, #0
 if_e	call	#_Hg010b_4_spin2_setcursory
'   if key4=78 then v.setcursory(36) 														' pgdn, todo: parameter instead 36
	cmp	local13, #78 wz
 if_e	mov	local06, #36
 if_e	mov	arg01, #36
 if_e	call	#_Hg010b_4_spin2_setcursory
'   if key4=76 then 																' del
	cmp	local13, #76 wz
 if_ne	jmp	#LR__0035
'     for i=v.textbuf_ptr+128*v.cursor_y+(v.cursor_x/2) to v.textbuf_ptr+128*v.cursor_y+127 : pspoke i,pspeek(i+1) : next i : pspoke v.textbuf_ptr+128*v.cursor_y+127,32
	add	objptr, #62
	rdbyte	local07, objptr
	getbyte	local08, local07, #0
	shl	local08, #7
	sub	objptr, #58
	rdlong	local24, objptr
	mov	local16, local24
	add	local16, local08
	add	objptr, #56
	rdword	local10, objptr
	abs	local21, local10 wc
	shr	local21, #1
	sumc	local16, local21
	getbyte	local07, local07, #0
	shl	local07, #7
	sub	objptr, #60
	add	local24, local07
	add	local24, #128
LR__0031
	cmps	local16, local24 wc
 if_ae	jmp	#LR__0032
	mov	arg01, local16
	add	arg01, #1
	call	#_pspeek
	getbyte	arg02, result1, #0
	mov	arg01, local16
	call	#_pspoke
	add	local16, #1
	jmp	#LR__0031
LR__0032
	add	objptr, #62
	rdbyte	local09, objptr
	shl	local09, #7
	sub	objptr, #58
	rdlong	arg01, objptr
	sub	objptr, #4
	add	arg01, local09
	add	arg01, #127
	mov	arg02, #32
	call	#_pspoke
	add	objptr, ##43204
	wrlong	#0, objptr
	sub	objptr, ##43142
	rdbyte	local14, objptr
	getbyte	local08, local14, #0
	shl	local08, #7
	sub	objptr, #58
	rdlong	local09, objptr
	mov	local16, local09
	add	local16, local08
	add	objptr, #56
	rdword	local11, objptr
	getword	local10, local11, #0
	abs	local21, local10 wc
	shr	local21, #1
	negc	local21, local21
	add	local16, local21
	getbyte	local06, local14, #0
	mov	local07, local06
	shl	local07, #7
	mov	local08, local09
	sub	objptr, #60
	mov	local25, local08
	add	local25, local07
	add	local25, #128
LR__0033
	cmps	local16, local25 wc
 if_ae	jmp	#LR__0034
	add	objptr, #60
	rdword	local06, objptr
	add	objptr, ##43144
	rdlong	local08, objptr
	shl	local08, #1
	add	local06, local08
	sub	objptr, ##43142
	rdbyte	local14, objptr
	sub	objptr, #62
	shl	local14, #4
	add	local14, #4
	mov	arg01, local16
	call	#_pspeek
	getbyte	local07, result1, #0
	add	objptr, #65
	rdlong	local08, objptr
	add	objptr, #4
	rdlong	local10, objptr
	sub	objptr, #69
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local14
	mov	arg03, local07
	mov	arg04, local08
	mov	arg05, local09
	call	#_Hg010b_4_spin2_putcharxycgf
	add	objptr, ##43204
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##43204
	mov	local06, local16
	mov	local14, local16
	add	local14, #1
	mov	local16, local14
	jmp	#LR__0033
LR__0034
LR__0035
' 
'   if key4 = 42 then  'backspace
	cmp	local13, #42 wz
 if_ne	jmp	#LR__0041
'     if v.cursor_x>editor_spaces*2 then 
	add	objptr, #60
	rdword	local14, objptr
	getword	local06, local14, #0
	add	objptr, ##29084
	rdlong	local09, objptr
	sub	objptr, ##29144
	mov	local08, local09
	mov	local07, local08
	shl	local07, #1
	cmps	local06, local07 wcz
 if_be	jmp	#LR__0039
	add	objptr, #60
	rdword	arg01, objptr
	sub	arg01, #2
	add	objptr, #2
	rdbyte	arg02, objptr
	sub	objptr, #62
	call	#_Hg010b_4_spin2_setcursorpos
'       position v.cursor_x-2,v.cursor_y
'       for i=v.textbuf_ptr+128*v.cursor_y+(v.cursor_x/2) to v.textbuf_ptr+128*v.cursor_y+127 : pspoke i,pspeek(i+1) : next i : pspoke v.textbuf_ptr+128*v.cursor_y+127,32
	add	objptr, #62
	rdbyte	local07, objptr
	getbyte	local08, local07, #0
	shl	local08, #7
	sub	objptr, #58
	rdlong	local26, objptr
	mov	local16, local26
	add	local16, local08
	add	objptr, #56
	rdword	local10, objptr
	abs	local21, local10 wc
	shr	local21, #1
	sumc	local16, local21
	getbyte	local07, local07, #0
	shl	local07, #7
	sub	objptr, #60
	add	local26, local07
	add	local26, #128
LR__0036
	cmps	local16, local26 wc
 if_ae	jmp	#LR__0037
	mov	arg01, local16
	add	arg01, #1
	call	#_pspeek
	getbyte	arg02, result1, #0
	mov	arg01, local16
	call	#_pspoke
	add	local16, #1
	jmp	#LR__0036
LR__0037
	add	objptr, #62
	rdbyte	local09, objptr
	shl	local09, #7
	sub	objptr, #58
	rdlong	arg01, objptr
	sub	objptr, #4
	add	arg01, local09
	add	arg01, #127
	mov	arg02, #32
	call	#_pspoke
	add	objptr, ##43204
	wrlong	#0, objptr
	sub	objptr, ##43142
	rdbyte	local14, objptr
	getbyte	local08, local14, #0
	shl	local08, #7
	sub	objptr, #58
	rdlong	local09, objptr
	mov	local16, local09
	add	local16, local08
	add	objptr, #56
	rdword	local11, objptr
	getword	local10, local11, #0
	abs	local21, local10 wc
	shr	local21, #1
	negc	local21, local21
	add	local16, local21
	getbyte	local06, local14, #0
	mov	local07, local06
	shl	local07, #7
	mov	local08, local09
	sub	objptr, #60
	mov	local27, local08
	add	local27, local07
	add	local27, #128
LR__0038
	cmps	local16, local27 wc
 if_ae	jmp	#LR__0040
	add	objptr, #60
	rdword	local06, objptr
	add	objptr, ##43144
	rdlong	local08, objptr
	shl	local08, #1
	add	local06, local08
	sub	objptr, ##43142
	rdbyte	local14, objptr
	sub	objptr, #62
	shl	local14, #4
	add	local14, #4
	mov	arg01, local16
	call	#_pspeek
	getbyte	local07, result1, #0
	add	objptr, #65
	rdlong	local08, objptr
	add	objptr, #4
	rdlong	local10, objptr
	sub	objptr, #69
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local14
	mov	arg03, local07
	mov	arg04, local08
	mov	arg05, local09
	call	#_Hg010b_4_spin2_putcharxycgf
	add	objptr, ##43204
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##43204
	mov	local06, local16
	mov	local14, local16
	add	local14, #1
	mov	local16, local14
	jmp	#LR__0038
LR__0039
	mov	local23, ##@LR__5488
	mov	local06, #4
	add	objptr, #60
	wrword	#4, objptr
	sub	objptr, #60
LR__0040
LR__0041
' 
'   if key4=82 then 						' arrow up
	cmp	local13, #82 wz
 if_ne	jmp	#LR__0042
' return cursor_y
	add	objptr, #62
	rdbyte	result1, objptr
	sub	result1, #1
	add	objptr, ##43114
	wrlong	result1, objptr
'     cy=v.getcursory()-1 : if cy<0 then cy=0 
	sub	objptr, ##43176
	cmps	result1, #0 wc
 if_b	add	objptr, ##43176
 if_b	wrlong	#0, objptr
 if_b	sub	objptr, ##43176
	add	objptr, ##43176
	rdlong	local14, objptr
	sub	objptr, ##43176
	mov	local06, local14
	mov	arg01, local06
	call	#_Hg010b_4_spin2_setcursory
LR__0042
'   if key4=81 then						' arrow down,  todo: remove hardcoded 36
	cmp	local13, #81 wz
 if_ne	jmp	#LR__0043
' return cursor_y
	add	objptr, #62
	rdbyte	result1, objptr
	add	result1, #1
	add	objptr, ##43114
	wrlong	result1, objptr
'     cy=v.getcursory()+1 : if cy>36  then cy=36
	sub	objptr, ##43176
	cmps	result1, #37 wc
 if_ae	add	objptr, ##43176
 if_ae	wrlong	#36, objptr
 if_ae	sub	objptr, ##43176
	add	objptr, ##43176
	rdlong	local14, objptr
	sub	objptr, ##43176
	mov	local06, local14
	mov	arg01, local06
	call	#_Hg010b_4_spin2_setcursory
LR__0043
'   if key4=80 then
	cmp	local13, #80 wz
 if_ne	jmp	#LR__0044
' return cursor_x
	add	objptr, #60
	rdword	local06, objptr
	sub	local06, #2
	add	objptr, ##43120
	wrlong	local06, objptr
'     cx=v.getcursorx()-2 					' arrow left
'     if cx<editor_spaces then cx=editor_spaces			
	sub	objptr, ##14036
	rdlong	local08, objptr
	sub	objptr, ##29144
	mov	local07, local08
	cmps	local06, local07 wc
 if_b	add	objptr, ##29144
 if_b	rdlong	local06, objptr
 if_b	add	objptr, ##14036
 if_b	wrlong	local06, objptr
 if_b	sub	objptr, ##43180
	add	objptr, ##43180
	rdlong	local14, objptr
	sub	objptr, ##43180
	mov	local06, local14
	mov	arg01, local06
	call	#_Hg010b_4_spin2_setcursorx
LR__0044
'   if key4=79 then						' arrow right
	cmp	local13, #79 wz
 if_ne	jmp	#LR__0045
' return cursor_x
	add	objptr, #60
	rdword	result1, objptr
	add	result1, #2
	add	objptr, ##43120
	wrlong	result1, objptr
'     cx=v.getcursorx()+2 
'     if cx>254  then cx=254 
	sub	objptr, ##43180
	cmps	result1, #255 wc
 if_ae	add	objptr, ##43180
 if_ae	wrlong	#254, objptr
 if_ae	sub	objptr, ##43180
	add	objptr, ##43180
	rdlong	local06, objptr
	sub	objptr, ##43180
	mov	arg01, local06
	call	#_Hg010b_4_spin2_setcursorx
LR__0045
' 
'   if key4=73 then 						' ins
	cmp	local13, #73 wz
 if_ne	jmp	#LR__0048
	add	objptr, ##43172
	rdlong	local06, objptr
	not	local14, local06
	wrlong	local14, objptr
'     if do_insert then v.setcursorshape(14) else  v.setcursorshape(0)
	sub	objptr, ##43172
	cmp	local14, #0 wz
 if_e	jmp	#LR__0046
	mov	local06, #14
	mov	arg01, #14
	call	#_Hg010b_4_spin2_setcursorshape
	jmp	#LR__0047
LR__0046
	mov	local06, #0
	mov	arg01, #0
	call	#_Hg010b_4_spin2_setcursorshape
LR__0047
LR__0048
	mov	local04, #0
	jmp	#LR__0001
LR__0049
	mov	ptra, fp
	call	#popregs_
_edit_ret
	ret

' 
' ''-----------------------------------------------------------------------------------------------------------
' ' 					A housekeepeer.
' ' A dedicated cog that is intended to do things in the background, for example tracking GUI elements
' ' or playing audio tracks in  the background.  In the current version it reads the mouse pointer and
' ' a digital joystick position. It also implements a 200 Hz clock that's ticks are synchronized with vblanks 
' ''-----------------------------------------------------------------------------------------------------------
' 
' sub housekeeper
_housekeeper
' 
' do
LR__0050
'   do: loop until v.vblank=1 : hkcnt+=1 :gethdi
	add	objptr, #73
LR__0051
	rdlong	arg01, objptr
	cmp	arg01, #1 wz
 if_ne	jmp	#LR__0051
	add	objptr, ##43047
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##43120
	call	#_gethdi
	mov	arg01, #5
	call	#__system___waitms
	add	objptr, ##43120
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##43120
	call	#_gethdi
	mov	arg01, #5
	call	#__system___waitms
	add	objptr, ##43120
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##43120
	call	#_gethdi
	mov	arg01, #5
	call	#__system___waitms
	add	objptr, ##43120
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##43120
	call	#_gethdi
	jmp	#LR__0050
_housekeeper_ret
	ret

' 
' '----------------------------------------------------------------------------------------------------------
' ' gethdi is called from the houseekeeper to read HDI related values
' '----------------------------------------------------------------------------------------------------------
' 
' sub gethdi
_gethdi
	mov	COUNT_, #10
	call	#pushregs_
'   x := mouse_xacc
	add	ptr__usbnew_spin2_dat__, ##10465
	rdlong	arg02, ptr__usbnew_spin2_dat__
'   y := mouse_yacc
	add	ptr__usbnew_spin2_dat__, #4
	rdlong	arg01, ptr__usbnew_spin2_dat__
	add	objptr, ##42732
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg01, objptr
'   x := 0
'   y := mouse_zacc
	add	ptr__usbnew_spin2_dat__, #4
	rdlong	result1, ptr__usbnew_spin2_dat__
	add	objptr, #8
	wrlong	result1, objptr
'   return mouse_bstate
	add	ptr__usbnew_spin2_dat__, #4
	rdbyte	result1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10477
	sub	objptr, #4
	wrlong	result1, objptr
	sub	objptr, ##42740
	mov	local01, #0
' 
' mousex,mousey=kbm.mouse_xy()
' dummy,mousew=kbm.mouse_scroll()
' mousek=kbm.mouse_buttons()
' i=0
' for j=0 to 6
	mov	local02, #0
LR__0060
'   if kbm.hidpad_id(j)>0 then
	mov	arg01, local02
'   return long[@hidpad_report+dev*HIDPAD_REPORT_SIZE][0]
	mov	result1, ptr__usbnew_spin2_dat__
	add	result1, ##10232
	shl	arg01, #5
	add	result1, arg01
	rdlong	result1, result1
	cmps	result1, #1 wc
 if_b	jmp	#LR__0061
	mov	arg01, local02
	mov	arg02, #0
	call	#_usbnew_spin2_hidpad_axis
	mov	local03, result1
	mov	arg01, local02
	mov	arg02, #1
	call	#_usbnew_spin2_hidpad_axis
	mov	local04, result1
	mov	arg01, local02
	mov	arg02, #2
	call	#_usbnew_spin2_hidpad_axis
	mov	local05, result1
	mov	arg01, local02
	mov	arg02, #0
	call	#_usbnew_spin2_hidpad_hat
	mov	local06, result1
	mov	arg01, local02
	mov	arg02, #3
	call	#_usbnew_spin2_hidpad_axis
	mov	local07, result1
	mov	arg01, local02
	mov	arg02, #4
	call	#_usbnew_spin2_hidpad_axis
	mov	local08, result1
	mov	arg01, local02
	mov	arg02, #5
	call	#_usbnew_spin2_hidpad_axis
	mov	local09, result1
	mov	arg01, local02
	mov	arg02, #6
	call	#_usbnew_spin2_hidpad_axis
	mov	local10, result1
	mov	arg01, local02
	mov	arg02, #7
	call	#_usbnew_spin2_hidpad_axis
	mov	arg01, local01
	shl	arg01, #2
	add	objptr, ##42748
	add	arg01, objptr
	wrlong	local03, arg01
	mov	arg01, local01
	shl	arg01, #2
	add	objptr, #28
	add	arg01, objptr
	wrlong	local04, arg01
	mov	arg01, local01
	shl	arg01, #2
	add	objptr, #28
	add	arg01, objptr
	wrlong	local05, arg01
	mov	local05, local01
	shl	local05, #2
	add	objptr, #28
	add	local05, objptr
	wrlong	local06, local05
	mov	local06, local01
	shl	local06, #2
	add	objptr, #28
	add	local06, objptr
	wrlong	local07, local06
	mov	local07, local01
	shl	local07, #2
	add	objptr, #28
	add	local07, objptr
	wrlong	local08, local07
	mov	local08, local01
	shl	local08, #2
	add	objptr, #28
	add	local08, objptr
	wrlong	local09, local08
	mov	local09, local01
	shl	local09, #2
	add	objptr, #28
	add	local09, objptr
	wrlong	local10, local09
	mov	local10, local01
	shl	local10, #2
	add	objptr, #28
	add	local10, objptr
	wrlong	result1, local10
	add	local03, ##49152
	shr	local03, #15
	mov	local10, #1
	add	local10, local03
	add	local04, ##49152
	shr	local04, #15
	mov	local09, #1
	add	local09, local04
	mov	local08, local01
	shl	local08, #2
	add	objptr, #28
	add	local08, objptr
	shl	local09, #2
	add	local10, local09
	wrlong	local10, local08
	mov	local10, local01
	shl	local10, #2
	add	objptr, #28
	add	local10, objptr
	mov	arg01, local02
	sub	objptr, ##43028
'   return long[@hidpad_report+dev*HIDPAD_REPORT_SIZE][6]
	mov	result1, ptr__usbnew_spin2_dat__
	add	result1, ##10232
	shl	arg01, #5
	add	result1, arg01
	add	result1, #24
	rdlong	result1, result1
	wrlong	result1, local10
	add	local01, #1
LR__0061
	add	local02, #1
	cmp	local02, #7 wc
 if_b	jmp	#LR__0060
	callpa	#(@LR__0063-@LR__0062)>>2,fcache_load_ptr_
' for j=i to 6 : stick(j)=0 : strig(j)=0 : next j 
LR__0062
	cmp	local01, #7 wc
 if_ae	jmp	#LR__0064
	mov	local10, local01
	shl	local10, #2
	add	objptr, ##43000
	add	local10, objptr
	wrlong	#0, local10
	mov	local10, local01
	shl	local10, #2
	add	objptr, #28
	add	local10, objptr
	wrlong	#0, local10
	add	local01, #1
	sub	objptr, ##43028
	jmp	#LR__0062
LR__0063
LR__0064
	mov	ptra, fp
	call	#popregs_
_gethdi_ret
	ret

' 
' '-------------------------------------------------------------------------------------------------------------
' '---------------------------------- Housekeeper stuff ends here ----------------------------------------------
' '-------------------------------------------------------------------------------------------------------------
' 
' '-------------------------------------------------------------------------------------------------------------
' '
' '                                     LINE INTERPRETER/TOKENIZER
' '
' '-------------------------------------------------------------------------------------------------------------
' 
' 
' sub interpret
_interpret
	mov	COUNT_, #52
	call	#pushregs_
	add	ptra, ##640
	add	objptr, ##29120
	rdlong	arg01, objptr
	sub	objptr, ##29120
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##29124
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	add	objptr, ##14020
	wrlong	#0, objptr
	sub	objptr, ##4204
	wrlong	#0, objptr
	sub	objptr, ##38944
	mov	local01, #0
LR__0070
' 
' ' -------------------------    Pass 1: Split the line to parts, strip unneded spaces, lowercase parts, detect and concatenate strings
' 
' fullline$=trim$(line$): cont=-1  : linenum=0 : lineptr=0 : err=0
' 
' 108 
' for i=0 to 125: separators(i)=0 :next i
	mov	local02, #0
	add	fp, #56
	callpa	#(@LR__0072-@LR__0071)>>2,fcache_load_ptr_
LR__0071
	mov	local03, local02
	shl	local03, #2
	add	local03, fp
	wrlong	#0, local03
	add	local02, #1
	cmps	local02, #126 wc
 if_b	jmp	#LR__0071
LR__0072
	sub	fp, #56
' for i=0 to 125: lparts(i).part$="": lparts(i).token=0: next i
	mov	local02, #0
	add	objptr, ##28080
	callpa	#(@LR__0074-@LR__0073)>>2,fcache_load_ptr_
LR__0073
	mov	local04, local02
	shl	local04, #3
	add	local04, objptr
	mov	arg03, ##@LR__5489
	wrlong	arg03, local04
	mov	local04, local02
	shl	local04, #3
	mov	local05, objptr
	add	local04, objptr
	mov	local06, #0
	add	local04, #4
	wrlong	#0, local04
	add	local02, #1
	cmps	local02, #126 wc
 if_b	jmp	#LR__0073
LR__0074
	add	objptr, ##1040
	rdlong	arg01, objptr
	sub	objptr, ##29120
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##29120
	wrlong	result1, objptr
	mov	local04, ##@LR__5490
	add	objptr, ##14088
	wrlong	local04, objptr
	sub	objptr, ##14088
	rdlong	arg01, objptr
	sub	objptr, ##29120
	mov	local07, arg01
	callpa	#(@LR__0076-@LR__0075)>>2,fcache_load_ptr_
LR__0075
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0075
LR__0076
	sub	local07, arg01 wz
	add	objptr, ##43212
	wrlong	local07, objptr
' if l=0 then goto 101					' empty line,  nothing to do except print "ready"
	sub	objptr, ##43212
 if_e	jmp	#LR__0210
	mov	local08, #0
' d=0							' before we split the line, we have to find colons that are inside a string, 
' for i=1 to len(line$)
	mov	local02, #1
	add	objptr, ##29120
	rdlong	arg01, objptr
	sub	objptr, ##29120
	mov	local07, arg01
	callpa	#(@LR__0078-@LR__0077)>>2,fcache_load_ptr_
LR__0077
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0077
LR__0078
	sub	local07, arg01
	mov	local09, local07
	add	local09, #1
LR__0079
	cmps	local02, local09 wc
 if_ae	jmp	#LR__0081
'   if mid$(line$,i,1)="""" andalso d=0 then 		' they are inside a string if there is an odd number of " before :
	add	objptr, ##29120
	rdlong	arg01, objptr
	sub	objptr, ##29120
	mov	arg02, local02
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__5491
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	cmp	local08, #0 wz
 if_e	mov	local08, #1
 if_e	jmp	#LR__0080
	add	objptr, ##29120
	rdlong	arg01, objptr
	sub	objptr, ##29120
	mov	arg02, local02
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__5492
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	cmp	local08, #1 wz
 if_e	mov	local08, #0
LR__0080
	mov	local04, local02
	shl	local04, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local04, local05
	add	local04, #4
	wrlong	local08, local04
	add	local02, #1
	jmp	#LR__0079
LR__0081
	mov	local02, #1
' i=1: do until (mid$(line$,i,1)=":" andalso lparts(i).token=0)  orelse i>=l : i=i+1 : loop 		' find the first : that is not in a string
LR__0082
	add	objptr, ##29120
	rdlong	arg01, objptr
	sub	objptr, ##29120
	mov	arg02, local02
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	local10, ##@LR__5493
	mov	arg02, local10
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0083
	mov	local05, local02
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	add	local05, #4
	rdlong	local11, local05
	sub	local05, #4
	mov	local12, local11 wz
 if_e	jmp	#LR__0084
LR__0083
	add	objptr, ##43212
	rdlong	local13, objptr
	sub	objptr, ##43212
	mov	local14, local13
	cmps	local02, local14 wc
 if_b	add	local02, #1
 if_b	jmp	#LR__0082
LR__0084
' if i<l then let rest$=trim$(right$(line$,len(line$)-i)):line$=trim$(left$(line$,i-1)) else rest$="" 	' and separate the part of the line before the first : from the rest
	add	objptr, ##43212
	rdlong	local04, objptr
	sub	objptr, ##43212
	cmps	local02, local04 wc
 if_ae	jmp	#LR__0087
	add	objptr, ##29120
	rdlong	local06, objptr
	sub	objptr, ##29120
	mov	arg01, local06
	mov	local07, arg01
	callpa	#(@LR__0086-@LR__0085)>>2,fcache_load_ptr_
LR__0085
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0085
LR__0086
	sub	local07, arg01
	mov	local05, local07
	mov	arg02, local05
	sub	arg02, local02
	mov	arg01, local06
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##43216
	wrlong	result1, objptr
	sub	objptr, ##14096
	rdlong	arg01, objptr
	sub	objptr, ##29120
	sub	local02, #1
	mov	arg02, local02
	call	#__system__Left_S
	mov	arg01, result1
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##29120
	wrlong	result1, objptr
	sub	objptr, ##29120
	jmp	#LR__0088
LR__0087
	mov	local04, ##@LR__5494
	add	objptr, ##43216
	wrlong	local04, objptr
	sub	objptr, ##43216
LR__0088
' 
' if cont=-1 andalso rest$<>"" then cont=0 : goto 107       	' this is the first and not the last part
	add	objptr, ##29128
	rdlong	local04, objptr
	sub	objptr, ##29128
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0089
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	local06, ##@LR__5495
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	objptr, ##29128
 if_ne	wrlong	#0, objptr
 if_ne	sub	objptr, ##29128
 if_ne	jmp	#LR__0093
LR__0089
' if cont=-1 andalso rest$= "" then cont=3 : goto 107		' this is the first AND the last part
	add	objptr, ##29128
	rdlong	local04, objptr
	sub	objptr, ##29128
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0090
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	arg02, ##@LR__5496
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##29128
 if_e	wrlong	#3, objptr
 if_e	sub	objptr, ##29128
 if_e	jmp	#LR__0093
LR__0090
' if cont=4  andalso rest$<>"" then cont=1 : goto 107		' this is not the first and not the last part
	add	objptr, ##29128
	rdlong	local04, objptr
	sub	objptr, ##29128
	cmp	local04, #4 wz
 if_ne	jmp	#LR__0091
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	arg02, ##@LR__5497
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	objptr, ##29128
 if_ne	wrlong	#1, objptr
 if_ne	sub	objptr, ##29128
 if_ne	jmp	#LR__0093
LR__0091
' if cont=4  andalso rest$= "" then cont=2 : goto 107		' this is the last, and not the first, part
	add	objptr, ##29128
	rdlong	local04, objptr
	sub	objptr, ##29128
	cmp	local04, #4 wz
 if_ne	jmp	#LR__0092
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	arg02, ##@LR__5498
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##29128
 if_e	wrlong	#2, objptr
 if_e	sub	objptr, ##29128
LR__0092
LR__0093
	add	fp, #56
	wrlong	#0, fp
	sub	fp, #56
	mov	local02, #0
	mov	local15, #1
' 
' ' 1b: find separators
' 
' 107
' separators(0)=0
' i=0: j=1
' do: 
LR__0094
	add	local02, #1
	add	objptr, ##29120
	rdlong	arg01, objptr
	sub	objptr, ##29120
	mov	arg02, local02
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local16, result1
'   i+=1 : c$=mid$(line$,i,1) : if isseparator(c$) then separators(j)=i: j+=1 
	mov	arg01, local16
	call	#_isseparator
	cmp	result1, #0 wz
 if_e	jmp	#LR__0095
	mov	local03, local15
	shl	local03, #2
	mov	local10, fp
	add	local10, #56
	add	local03, local10
	wrlong	local02, local03
	add	local15, #1
LR__0095
	add	objptr, ##43212
	rdlong	local04, objptr
	sub	objptr, ##43212
	cmps	local02, local04 wcz
 if_be	jmp	#LR__0094
	mov	local03, local15
	shl	local03, #2
	mov	local10, fp
	add	local10, #56
	add	local03, local10
	wrlong	local02, local03
	mov	local17, #0
' for i=0 to j-1 
	mov	local02, #0
	mov	local18, local15
LR__0096
	cmps	local02, local18 wc
 if_ae	jmp	#LR__0100
	mov	local03, local02
	shl	local03, #2
	add	fp, #56
	add	local03, fp
	rdlong	local05, local03
	add	objptr, ##43224
	wrlong	local05, objptr
	mov	local03, local02
	add	local03, #1
	shl	local03, #2
	mov	local10, fp
	add	local03, fp
	rdlong	local05, local03
	add	objptr, #4
	wrlong	local05, objptr
'   if p1>0 then let p$=mid$(line$,p1,1) : if p$<>"" then lparts(k).part$=p$ : k+=1 
	sub	objptr, #4
	rdlong	local04, objptr
	sub	objptr, ##43224
	cmps	local04, #1 wc
	sub	fp, #56
 if_b	jmp	#LR__0098
	add	objptr, ##29120
	rdlong	arg01, objptr
	add	objptr, ##14104
	rdlong	arg02, objptr
	sub	objptr, ##43224
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local19, result1
	mov	arg02, ##@LR__5499
	mov	arg01, local19
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0097
	mov	local10, local17
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	wrlong	local19, local10
	add	local17, #1
LR__0097
LR__0098
	add	objptr, ##29120
	rdlong	arg01, objptr
	add	objptr, ##14104
	rdlong	arg02, objptr
	add	arg02, #1
	add	objptr, #4
	rdlong	arg03, objptr
	sub	objptr, #4
	rdlong	local11, objptr
	sub	objptr, ##43224
	mov	local12, local11
	sub	arg03, local12
	sub	arg03, #1
	call	#__system__Mid_S
	mov	local19, result1
'   p$=mid$(line$,p1+1,p2-p1-1) : if p$<>"" then lparts(k).part$=p$ : k+=1 
	mov	arg02, ##@LR__5500
	mov	arg01, local19
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0099
	mov	local10, local17
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	wrlong	local19, local10
	add	local17, #1
LR__0099
	add	local02, #1
	jmp	#LR__0096
LR__0100
' 
' ' 1d  : first part has to have a line number, if not, add 0 for the immediate line
' 
' if (cont=0 orelse cont=3) andalso (not isdec(lparts(0).part$))  then for i=k to 1 step -1: lparts(i)=lparts(i-1) : next i: lparts(0).part$="0" : k+=1
	add	objptr, ##29128
	rdlong	local04, objptr wz
	sub	objptr, ##29128
 if_ne	add	objptr, ##29128
 if_ne	rdlong	local10, objptr
 if_ne	sub	objptr, ##29128
 if_ne	cmp	local10, #3 wz
 if_ne	jmp	#LR__0103
	add	objptr, ##28080
	rdlong	local11, objptr
	sub	objptr, ##28080
	mov	arg01, local11
	call	#_isdec
	mov	local12, result1
	mov	local06, local12
	signx	local06, #7
	not	local06, local06
	cmp	local06, #0 wz
 if_e	jmp	#LR__0103
	mov	local02, local17
	add	objptr, ##28080
	callpa	#(@LR__0102-@LR__0101)>>2,fcache_load_ptr_
LR__0101
	mov	local05, local02
	sub	local05, #1
	shl	local05, #3
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local02
	sub	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local02
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local02
	mov	local13, local11
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local02, #1
	cmps	local02, #1 wc
 if_ae	jmp	#LR__0101
LR__0102
	mov	local04, ##@LR__5501
	wrlong	local04, objptr
	sub	objptr, ##28080
	add	local17, #1
LR__0103
	mov	local02, #0
' 
' ' 1e : find strings
' 
' i=0
' do
LR__0104
'   if lparts(i).part$<>"""" then i+=1 : goto 109
	mov	local05, local02
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5502
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0109
	mov	local20, local02
LR__0105
	mov	local10, local02
	add	local10, #1
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	rdlong	local19, local10
	mov	local10, local20
	shl	local10, #3
	add	local10, objptr
	mov	local11, local20
	mov	local14, local11
	shl	local14, #3
	add	local14, objptr
	rdlong	arg01, local14
	mov	local12, local19
	mov	arg02, local12
	sub	objptr, ##28080
	call	#__system___string_concat
	wrlong	result1, local10
	mov	local15, local02
	add	local15, #1
	mov	local21, local17
	add	local21, #1
	callpa	#(@LR__0107-@LR__0106)>>2,fcache_load_ptr_
LR__0106
	cmps	local15, local21 wc
 if_ae	jmp	#LR__0108
	mov	local05, local15
	add	local05, #1
	shl	local05, #3
	add	objptr, ##28080
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local15
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local15
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local15
	mov	local13, local11
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	add	local15, #1
	sub	objptr, ##28080
	jmp	#LR__0106
LR__0107
LR__0108
	sub	local17, #1
	mov	arg02, ##@LR__5503
	mov	arg01, local19
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	cmps	local02, local17 wc
 if_c_and_nz	jmp	#LR__0105
'   if p$<>"""" then k+=1:i+=1
	mov	arg02, ##@LR__5504
	mov	arg01, local19
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	local17, #1
 if_ne	add	local02, #1
LR__0109
	cmps	local02, local17 wc
 if_b	jmp	#LR__0104
	mov	local02, #0
' 
' ' 1f : concatenate strings if "" detected between
'  
' i=0
' do
LR__0110
'   if right$(lparts(i).part$,1)="""" andalso left$(lparts(i+1).part$,1)=""""  then 
	mov	local05, local02
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5505
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0116
	mov	local06, local02
	add	local06, #1
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	rdlong	arg01, local06
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5506
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0116
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local14, local02
	shl	local14, #3
	add	local14, objptr
	rdlong	local06, local14
	mov	local13, local02
	add	local13, #1
	shl	local13, #3
	add	local13, objptr
	rdlong	local12, local13
	mov	local22, local02
	add	local22, #1
	mov	local23, local22
	shl	local23, #3
	mov	local24, objptr
	add	local23, objptr
	rdlong	arg01, local23
	sub	objptr, ##28080
	mov	local07, arg01
	callpa	#(@LR__0112-@LR__0111)>>2,fcache_load_ptr_
LR__0111
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0111
LR__0112
	sub	local07, arg01
	mov	local11, local07
	sub	local11, #1
	mov	arg01, local12
	mov	arg02, local11
	call	#__system__Right_S
	mov	local12, result1
	mov	arg01, local06
	mov	arg02, local12
	call	#__system___string_concat
	mov	local06, result1
	wrlong	local06, local10
'     for j=i+1 to k: lparts(j)=lparts(j+1): next j  
	mov	local15, local02
	add	local15, #1
	mov	local25, local17
	add	local25, #1
	callpa	#(@LR__0114-@LR__0113)>>2,fcache_load_ptr_
LR__0113
	cmps	local15, local25 wc
 if_ae	jmp	#LR__0115
	mov	local05, local15
	add	local05, #1
	shl	local05, #3
	add	objptr, ##28080
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local15
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local15
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local15
	mov	local13, local11
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	add	local15, #1
	sub	objptr, ##28080
	jmp	#LR__0113
LR__0114
LR__0115
	sub	local02, #1
	sub	local17, #1
LR__0116
	add	local02, #1
	cmps	local02, local17 wc
 if_b	jmp	#LR__0110
	mov	local02, #0
'  
' ' 1g: concatenate >=, <=, ++, --, +=, *=, -=, /=, ^=, <>
'  
' i=0 
' do
LR__0117
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	rdlong	local26, local10
	mov	local10, local02
	add	local10, #1
	shl	local10, #3
	add	local10, objptr
	rdlong	local27, local10
'   s1$=lparts(i).part$ : s2$=lparts(i+1).part$
'   if ((s1$=">" orelse s1$="<" orelse s1$="+" orelse s1$="-" orelse s1$="*" orelse s1$="/" orelse s1$="^") andalso s2$="=") orelse (s1$="+" andalso s2$="+") orelse (s1$="-" andalso s2$="-") orelse (s1$="<" andalso s2$=">") then
	mov	arg02, ##@LR__5507
	mov	arg01, local26
	sub	objptr, ##28080
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0118
	mov	arg02, ##@LR__5508
	mov	arg01, local26
	call	#__system___string_cmp
	mov	local03, result1 wz
 if_e	jmp	#LR__0118
	mov	local06, ##@LR__5509
	mov	arg01, local26
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0118
	mov	local12, ##@LR__5510
	mov	arg01, local26
	mov	arg02, local12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0118
	mov	local11, ##@LR__5511
	mov	local12, local11
	mov	arg01, local26
	mov	arg02, local12
	call	#__system___string_cmp
	mov	local06, result1 wz
 if_e	jmp	#LR__0118
	mov	local11, ##@LR__5512
	mov	arg01, local26
	mov	arg02, local11
	call	#__system___string_cmp
	mov	local12, result1 wz
 if_e	jmp	#LR__0118
	mov	local14, ##@LR__5513
	mov	arg01, local26
	mov	arg02, local14
	call	#__system___string_cmp
	mov	local11, result1 wz
 if_ne	jmp	#LR__0119
LR__0118
	mov	local28, ##@LR__5514
	mov	local13, local28
	mov	arg01, local27
	mov	arg02, local13
	call	#__system___string_cmp
	mov	local14, result1 wz
 if_e	jmp	#LR__0122
LR__0119
	mov	local28, ##@LR__5515
	mov	arg01, local26
	mov	arg02, local28
	call	#__system___string_cmp
	mov	local13, result1 wz
 if_ne	jmp	#LR__0120
	mov	local23, ##@LR__5516
	mov	local22, local23
	mov	arg01, local27
	mov	arg02, local22
	call	#__system___string_cmp
	mov	local28, result1 wz
 if_e	jmp	#LR__0122
LR__0120
	mov	local23, ##@LR__5517
	mov	arg01, local26
	mov	arg02, local23
	call	#__system___string_cmp
	mov	local22, result1 wz
 if_ne	jmp	#LR__0121
	mov	local29, ##@LR__5518
	mov	local24, local29
	mov	arg01, local27
	mov	arg02, local24
	call	#__system___string_cmp
	mov	local23, result1 wz
 if_e	jmp	#LR__0122
LR__0121
	mov	local30, ##@LR__5519
	mov	local29, local30
	mov	arg01, local26
	mov	arg02, local29
	call	#__system___string_cmp
	mov	local24, result1 wz
 if_ne	jmp	#LR__0126
	mov	local31, ##@LR__5520
	mov	local30, local31
	mov	arg01, local27
	mov	arg02, local30
	call	#__system___string_cmp
	mov	local29, result1 wz
 if_ne	jmp	#LR__0126
LR__0122
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local12, local27
	mov	arg01, local26
	mov	arg02, local12
	call	#__system___string_concat
	wrlong	result1, local10
'     lparts(i).part$=s1$+s2$
'     for j=i+1 to k : lparts(j)=lparts(j+1) : next j
	mov	local15, local02
	add	local15, #1
	mov	local32, local17
	add	local32, #1
	callpa	#(@LR__0124-@LR__0123)>>2,fcache_load_ptr_
LR__0123
	cmps	local15, local32 wc
 if_ae	jmp	#LR__0125
	mov	local05, local15
	add	local05, #1
	shl	local05, #3
	add	objptr, ##28080
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local15
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local15
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local15
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	mov	local28, objptr
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local13, #4
	add	local15, #1
	sub	objptr, ##28080
	jmp	#LR__0123
LR__0124
LR__0125
	sub	local02, #1
	sub	local17, #1
LR__0126
	add	local02, #1
	cmps	local02, local17 wc
 if_b	jmp	#LR__0117
'  
' ' 1h : now remove parts that are spaces
' 
' for i=0 to k: lparts(i).part$=trim$(lparts(i).part$): next i
	mov	local02, #0
	mov	local33, local17
	add	local33, #1
LR__0127
	cmps	local02, local33 wc
 if_ae	jmp	#LR__0128
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local12, local02
	mov	local11, local12
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##28080
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	wrlong	result1, local10
	add	local02, #1
	jmp	#LR__0127
LR__0128
	mov	local02, #0
	callpa	#(@LR__0135-@LR__0129)>>2,fcache_load_ptr_
' i=0
' do 
LR__0129
'   if len(lparts(i).part$)=0 then 
	mov	local05, local02
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	local07, arg01
LR__0130
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0130
	sub	local07, arg01 wz
 if_ne	jmp	#LR__0134
'     if i=k-1 then k-=1  :  exit
	mov	local04, local17
	sub	local04, #1
	cmp	local02, local04 wz
 if_e	sub	local17, #1
 if_e	jmp	#LR__0136
'     if i<k-1 then 
	mov	local04, local17
	sub	local04, #1
	cmps	local02, local04 wc
 if_ae	jmp	#LR__0133
'       for j=i to k-2 : lparts(j)=lparts(j+1): next j: k-=1  
	mov	local15, local02
	mov	local34, local17
	sub	local34, #1
LR__0131
	cmps	local15, local34 wc
 if_ae	jmp	#LR__0132
	mov	local05, local15
	add	local05, #1
	shl	local05, #3
	add	objptr, ##28080
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local15
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local10, local15
	mov	local06, local10
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local15
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	mov	local28, objptr
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local13, #4
	add	local15, #1
	sub	objptr, ##28080
	jmp	#LR__0131
LR__0132
	sub	local17, #1
'       if i>0 then i-=1 
	cmps	local02, #1 wc
 if_ae	sub	local02, #1
LR__0133
LR__0134
	add	local02, #1
	mov	local04, local17
	sub	local04, #1
	cmps	local02, local04 wcz
 if_be	jmp	#LR__0129
LR__0135
LR__0136
' 
' ' 1i: lowercase all that is not a string
' 
' for j=0 to k-1
	mov	local15, #0
	mov	local35, local17
LR__0137
	cmps	local15, local35 wc
 if_ae	jmp	#LR__0140
'   if left$(lparts(j).part$,1)<>"""" orelse right$(lparts(j).part$,1)<>"""" then lparts(j).part$=lcase$(lparts(j).part$) 
	mov	local05, local15
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5521
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0138
	mov	local06, local15
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	rdlong	arg01, local06
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5522
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0139
LR__0138
	mov	local10, local15
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local12, local15
	mov	local11, local12
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##28080
	call	#__system__LCase_S
	wrlong	result1, local10
LR__0139
	add	local15, #1
	jmp	#LR__0137
LR__0140
' 
' '-------------------------------------------------------- Pass 2: Tokenize the line
' 
' for i=0 to k: lparts(i).token=-1: next i					' initialize all tokens to -1=invalid
	mov	local02, #0
	mov	local36, local17
	add	local36, #1
	callpa	#(@LR__0142-@LR__0141)>>2,fcache_load_ptr_
LR__0141
	cmps	local02, local36 wc
 if_ae	jmp	#LR__0143
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	wrlong	##-1, local10
	add	local02, #1
	jmp	#LR__0141
LR__0142
LR__0143
' 
' if isdec(lparts(0).part$) then addptr=1 else addptr=0				' check if the abbreviated command are on the line start, or after linenum, 'then' or 'else'
	add	objptr, ##28080
	rdlong	arg01, objptr
	sub	objptr, ##28080
	call	#_isdec
	cmp	result1, #0 wz
 if_ne	mov	local37, #1
 if_e	mov	local37, #0
' if lparts(0).part$="else" then addptr=1 					' else is always the first
	add	objptr, ##28080
	rdlong	arg01, objptr
	sub	objptr, ##28080
	mov	arg02, ##@LR__5523
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local37, #1
	mov	local02, #0
' i=0 : do 
LR__0144
'   if lparts(i).part$="then" then exit loop 					' try to find 'then'
	mov	local05, local02
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5524
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0145
	add	local02, #1
	cmps	local02, local17 wcz
 if_be	jmp	#LR__0144
LR__0145
' if i<k then addptr=i+1	 							' then found
	cmps	local02, local17 wc
 if_b	mov	local37, local02
 if_b	add	local37, #1
	add	objptr, ##28080
' lp$=lparts(addptr).part$ 
' 
' if left$(lparts(addptr).part$,1)="?" andalso len(lparts(addptr).part$)>1 then ' ? is abbreviation of print, but it has no dots, so it has to be treated here
	mov	local05, local37
	shl	local05, #3
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #1
	sub	objptr, ##28080
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5525
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0152
	mov	local06, local37
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	rdlong	arg01, local06
	mov	local07, arg01
	callpa	#(@LR__0147-@LR__0146)>>2,fcache_load_ptr_
LR__0146
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0146
LR__0147
	sub	local07, arg01
	cmps	local07, #2 wc
 if_b	jmp	#LR__0152
	add	local17, #1
'   k+=1
'   for i=k to addptr+1 step -1 : lparts(i)=lparts(i-1) : next i
	mov	local02, local17
	mov	local38, local37
	add	local38, #1
	add	objptr, ##28080
	callpa	#(@LR__0149-@LR__0148)>>2,fcache_load_ptr_
LR__0148
	mov	local05, local02
	sub	local05, #1
	shl	local05, #3
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local02
	sub	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local02
	shl	local06, #3
	add	local06, objptr
	wrlong	local04, local06
	mov	local13, local02
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local02, #1
	cmps	local02, local38 wc
 if_ae	jmp	#LR__0148
LR__0149
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	local10, objptr
	mov	local14, local37
	shl	local14, #3
	add	local14, objptr
	rdlong	local06, local14
	mov	local13, local37
	mov	local28, local13
	mov	local22, local28
	shl	local22, #3
	mov	local23, objptr
	add	local22, objptr
	rdlong	arg01, local22
	sub	objptr, ##28080
	mov	local07, arg01
	callpa	#(@LR__0151-@LR__0150)>>2,fcache_load_ptr_
LR__0150
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0150
LR__0151
	sub	local07, arg01
	mov	local14, local07
	mov	local11, local14
	sub	local11, #1
	mov	local12, local11
	mov	arg01, local06
	mov	arg02, local12
	call	#__system__Right_S
	wrlong	result1, local10
	mov	local10, local37
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##@LR__5526
	wrlong	local06, local10
	jmp	#LR__0160
LR__0152
	mov	local06, local37
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	rdlong	arg02, local06
	mov	arg03, ##@LR__5527
	mov	arg01, #1
	call	#__system__Instr
	mov	local39, result1
' 
' dot=instr(1,lparts(addptr).part$,".")						' find a dot	
' if dot>0 andalso dot<len(lparts(addptr).part$) then 				' split the part
	cmps	local39, #1 wc
 if_b	jmp	#LR__0159
	mov	local05, local37
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	local07, arg01
	callpa	#(@LR__0154-@LR__0153)>>2,fcache_load_ptr_
LR__0153
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0153
LR__0154
	sub	local07, arg01
	cmps	local39, local07 wc
 if_ae	jmp	#LR__0159
	add	local17, #1
'   k+=1
'   for i=k to addptr+1 step -1 : lparts(i)=lparts(i-1) : next i
	mov	local02, local17
	mov	local40, local37
	add	local40, #1
	add	objptr, ##28080
	callpa	#(@LR__0156-@LR__0155)>>2,fcache_load_ptr_
LR__0155
	mov	local05, local02
	sub	local05, #1
	shl	local05, #3
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local02
	sub	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local02
	shl	local06, #3
	add	local06, objptr
	wrlong	local04, local06
	mov	local13, local02
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local02, #1
	cmps	local02, local40 wc
 if_ae	jmp	#LR__0155
LR__0156
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	local10, objptr
	mov	local14, local37
	shl	local14, #3
	add	local14, objptr
	rdlong	local06, local14
	mov	local28, local37
	mov	local22, local28
	shl	local22, #3
	mov	local23, objptr
	add	local22, objptr
	rdlong	arg01, local22
	sub	objptr, ##28080
	mov	local07, arg01
	callpa	#(@LR__0158-@LR__0157)>>2,fcache_load_ptr_
LR__0157
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0157
LR__0158
	sub	local07, arg01
	mov	arg02, local07
	sub	arg02, local39
	mov	arg01, local06
	call	#__system__Right_S
	wrlong	result1, local10
	mov	local10, local37
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local11, local37
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	mov	local12, local39
	mov	arg02, local12
	sub	objptr, ##28080
	call	#__system__Left_S
	wrlong	result1, local10
LR__0159
LR__0160
	mov	local10, local37
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	rdlong	local41, local10
' 
' 825
' lp$=lparts(addptr).part$ 
' 
' ' process mouse/cursor/click on/off
' 
' if (lp$="mouse" orelse lp$="cursor" orelse lp$="click") then 
	mov	arg02, ##@LR__5528
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0161
	mov	arg02, ##@LR__5529
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0161
	mov	arg02, ##@LR__5530
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0164
LR__0161
'   if lparts(addptr+1).part$="on" then lparts(addptr+1).part$="1" :lparts(2).token=token_decimal
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5531
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0162
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local06, ##@LR__5532
	wrlong	local06, local10
	add	objptr, #20
	wrlong	##512, objptr
	sub	objptr, ##28100
LR__0162
'   if lparts(addptr+1).part$="off" then lparts(addptr+1).part$="0" :lparts(2).token=token_decimal
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5533
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0163
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local06, ##@LR__5534
	wrlong	local06, local10
	add	objptr, #20
	wrlong	##512, objptr
	sub	objptr, ##28100
LR__0163
LR__0164
' 		
' ' process text constant for 'mode' - TO DO all predefined constants should have # before				
' 
' if (lp$="mode" orelse lp$="m.") then 
	mov	arg02, ##@LR__5535
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0165
	mov	arg02, ##@LR__5536
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0172
LR__0165
'   if lparts(addptr+1).part$="atari" then lparts(addptr+1).part$="0"       
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5537
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0166
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##@LR__5538
	wrlong	local06, local10
LR__0166
'   if lparts(addptr+1).part$="pc_amber" then lparts(addptr+1).part$="1"  
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5539
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0167
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##@LR__5540
	wrlong	local06, local10
LR__0167
'   if lparts(addptr+1).part$="pc_green" then lparts(addptr+1).part$="2"  
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5541
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0168
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##@LR__5542
	wrlong	local06, local10
LR__0168
'   if lparts(addptr+1).part$="pc_white" then lparts(addptr+1).part$="3"  
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5543
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0169
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##@LR__5544
	wrlong	local06, local10
LR__0169
'   if lparts(addptr+1).part$="st" then lparts(addptr+1).part$="4"  
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5545
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0170
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##@LR__5546
	wrlong	local06, local10
LR__0170
'   if lparts(addptr+1).part$="amiga" then lparts(addptr+1).part$="5"  
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, ##@LR__5547
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0171
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##@LR__5548
	wrlong	local06, local10
LR__0171
LR__0172
' 
' ' find part types 
' 
' for i=0 to k-1
	mov	local02, #0
	mov	local42, local17
LR__0173
	cmps	local02, local42 wc
 if_ae	jmp	#LR__0185
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##28080
	call	#_isseparator
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isseparator(lparts(i).part$)	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
 if_ae	jmp	#LR__0184
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##28080
	call	#_isoperator
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isoperator(lparts(i).part$)	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
 if_ae	jmp	#LR__0184
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##28080
' 
' select case s
	mov	arg02, ##@LR__5639
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isassign(lparts(i).part$) 	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
 if_ae	jmp	#LR__0184
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##28080
	call	#_iscommand
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=iscommand(lparts(i).part$)	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
 if_ae	jmp	#LR__0184
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	mov	local28, objptr
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##28080
	call	#_isfunction
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isfunction(lparts(i).part$)	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
 if_ae	jmp	#LR__0184
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##28080
	call	#_isnotename
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isnotename(lparts(i).part$) 
' if lparts(i).token>0 then 
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	rdlong	local06, local10
	cmps	local06, #1 wc
 if_b	jmp	#LR__0174
	mov	local05, local02
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	add	local05, #4
	rdlong	local12, local05
	mov	arg01, local12
	call	#_getnoteval
	mov	local43, result1
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	arg01, local43
	call	#__system__str_S
	wrlong	result1, local10
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	wrlong	##514, local10
	jmp	#LR__0184
LR__0174
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local14, local02
	shl	local14, #3
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##28080
	call	#_ischannel
	add	local10, #4
	wrlong	result1, local10
' 
' ' if it is #channel, make it a number from 0 to 9 while setting a token_channel
' 
' lparts(i).token=ischannel(lparts(i).part$) : if lparts(i).token>0 then lparts(i).part$=right$(lparts(i).part$,1) : lparts(i).token=token_channel : goto 102
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	rdlong	local06, local10
	cmps	local06, #1 wc
 if_b	jmp	#LR__0175
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	mov	local12, #1
	mov	arg02, #1
	sub	objptr, ##28080
	call	#__system__Right_S
	wrlong	result1, local10
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	wrlong	#44, local10
	jmp	#LR__0184
LR__0175
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##28080
	call	#_isconstant
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isconstant(lparts(i).part$) : if lparts(i).token>0 then lparts(i).part$=str$(lparts(i).token) : lparts(i).token=token_integer : goto 102
	mov	local10, local02
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	rdlong	local06, local10
	cmps	local06, #1 wc
 if_b	jmp	#LR__0176
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	mov	local12, local02
	mov	local11, local12
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	add	local14, #4
	rdlong	arg01, local14
	sub	local14, #4
	sub	objptr, ##28080
	abs	arg01, arg01 wc
 if_b	decod	local44, #31
 if_ae	mov	local44, #0
	call	#__system___float_fromuns
	xor	result1, local44
	mov	arg01, result1
	call	#__system__str_S
	wrlong	result1, local10
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	wrlong	##513, local10
	jmp	#LR__0184
LR__0176
	mov	local06, local02
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	rdlong	arg01, local06
	call	#_isnum
	mov	local45, result1
	signx	local45, #7
	mov	local06, local02
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	rdlong	arg01, local06
	call	#_isint
	mov	local46, result1
	signx	local46, #7
	mov	local06, local02
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	rdlong	arg01, local06
	call	#_isdec
	signx	result1, #7
	mov	local47, result1
' 
' b1=isnum(lparts(i).part$) : b2=isint(lparts(i).part$) : b3=isdec(lparts(i).part$)
' if b1 andalso b2 andalso b3 then lparts(i).token=token_decimal 			: goto 102 	' pure decimal for line num
	cmp	local45, #0 wz
 if_ne	cmp	local46, #0 wz
 if_ne	cmp	local47, #0 wz
 if_e	jmp	#LR__0177
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	wrlong	##512, local10
	jmp	#LR__0184
LR__0177
' if b1 andalso b2 andalso (not b3) then lparts(i).token=token_integer 		: goto 102 	' integer
	cmp	local45, #0 wz
 if_ne	cmp	local46, #0 wz
 if_ne	not	local04, local47
 if_ne	cmp	local04, #0 wz
 if_e	jmp	#LR__0178
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	wrlong	##513, local10
	jmp	#LR__0184
LR__0178
' if b1 andalso (not b2) andalso (not b3) then lparts(i).token=token_float 	: goto 102 	' float
	cmp	local45, #0 wz
 if_ne	not	local04, local46
 if_ne	cmp	local04, #0 wz
 if_ne	not	local03, local47
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__0179
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	wrlong	##514, local10
	jmp	#LR__0184
LR__0179
' 
' if isstring(lparts(i).part$) then 
	mov	local05, local02
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	call	#_isstring
	cmp	result1, #0 wz
 if_e	jmp	#LR__0182
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	add	local10, #4
	wrlong	##515, local10
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	add	local10, objptr
	mov	local14, local02
	shl	local14, #3
	add	local14, objptr
	rdlong	local06, local14
	mov	local12, #2
	mov	local22, local02
	mov	local23, local22
	shl	local23, #3
	mov	local24, objptr
	add	local23, objptr
	rdlong	arg01, local23
	sub	objptr, ##28080
	mov	local07, arg01
	callpa	#(@LR__0181-@LR__0180)>>2,fcache_load_ptr_
LR__0180
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0180
LR__0181
	sub	local07, arg01
	mov	local13, local07
	mov	local14, local13
	sub	local14, #2
	mov	local11, local14
	mov	arg01, local06
	mov	arg02, local12
	mov	arg03, local11
	call	#__system__Mid_S
	wrlong	result1, local10
	jmp	#LR__0184
LR__0182
' if isname(lparts(i).part$) then lparts(i).token=token_name : goto 102						' name
	mov	local03, local02
	mov	local05, local03
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	rdlong	arg01, local05
	call	#_isname
	mov	local04, result1 wz
 if_e	jmp	#LR__0183
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	add	local10, #4
	wrlong	##516, local10
LR__0183
LR__0184
	add	local02, #1
	jmp	#LR__0173
LR__0185
	mov	local10, local17
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	add	local10, #4
	wrlong	#510, local10
	mov	local10, local17
	shl	local10, #3
	add	local10, objptr
	mov	local06, ##@LR__5549
	wrlong	local06, local10
	add	objptr, ##8276
	wrlong	local17, objptr
	sub	objptr, ##36356
' 
' lparts(k).token=token_end : lparts(k).part$="": tokennum=k
' 
' ' process the case when simple load or save is called without "". This cannot be done earlier, as tokens has to be known                                    					 
'  
' if (lp$="load" orelse lp$="save" orelse lp$="brun" orelse lp$="run" orelse lp$="lo." orelse lp$="s." orelse lp$="br." orelse lp$="enter" orelse lp$="e.") andalso lparts(addptr+1).token=token_name andalso right$(lparts(addptr+1).part$,1)<>"$" then lparts(addptr+1).token=token_string
	mov	arg02, ##@LR__5550
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0186
	mov	arg02, ##@LR__5551
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0186
	mov	local06, ##@LR__5552
	mov	arg01, local41
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0186
	mov	local12, ##@LR__5553
	mov	local06, local12
	mov	arg01, local41
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0186
	mov	local11, ##@LR__5554
	mov	local12, local11
	mov	arg01, local41
	mov	arg02, local12
	call	#__system___string_cmp
	mov	local06, result1 wz
 if_e	jmp	#LR__0186
	mov	local14, ##@LR__5555
	mov	local11, local14
	mov	arg01, local41
	mov	arg02, local11
	call	#__system___string_cmp
	mov	local12, result1 wz
 if_e	jmp	#LR__0186
	mov	local13, ##@LR__5556
	mov	local14, local13
	mov	arg01, local41
	mov	arg02, local14
	call	#__system___string_cmp
	mov	local11, result1 wz
 if_e	jmp	#LR__0186
	mov	local13, ##@LR__5557
	mov	arg01, local41
	mov	arg02, local13
	call	#__system___string_cmp
	mov	local14, result1 wz
 if_e	jmp	#LR__0186
	mov	local22, ##@LR__5558
	mov	local28, local22
	mov	arg01, local41
	mov	arg02, local28
	call	#__system___string_cmp
	mov	local13, result1 wz
 if_ne	jmp	#LR__0187
LR__0186
	mov	local28, local37
	add	local28, #1
	mov	local22, local28
	mov	local23, local22
	shl	local23, #3
	mov	local24, objptr
	add	local24, ##28080
	add	local23, local24
	add	local23, #4
	rdlong	local30, local23
	sub	local23, #4
	mov	local29, local30
	cmp	local29, ##516 wz
 if_ne	jmp	#LR__0187
	mov	local48, local37
	add	local48, #1
	shl	local48, #3
	mov	local49, objptr
	add	local49, ##28080
	add	local48, local49
	rdlong	arg01, local48
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	local50, ##@LR__5559
	mov	local51, local50
	mov	arg02, local51
	call	#__system___string_cmp
	mov	local31, result1 wz
 if_e	jmp	#LR__0187
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
LR__0187
' if (lp$="delete" orelse lp$="mkdir") andalso lparts(addptr+1).token=token_name andalso right$(lparts(addptr+1).part$,1)<>"$" then lparts(addptr+1).token=token_string
	mov	arg02, ##@LR__5560
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0188
	mov	local05, ##@LR__5561
	mov	arg01, local41
	mov	arg02, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0189
LR__0188
	mov	local05, local37
	add	local05, #1
	mov	local06, local05
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	add	local06, #4
	rdlong	local14, local06
	sub	local06, #4
	mov	local11, local14
	cmp	local11, ##516 wz
 if_ne	jmp	#LR__0189
	mov	local23, local37
	add	local23, #1
	shl	local23, #3
	mov	local24, objptr
	add	local24, ##28080
	add	local23, local24
	rdlong	arg01, local23
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	local22, ##@LR__5562
	mov	local28, local22
	mov	arg02, local28
	call	#__system___string_cmp
	mov	local13, result1 wz
 if_e	jmp	#LR__0189
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
LR__0189
' if (lp$="copy") andalso lparts(addptr+1).token=token_name andalso right$(lparts(addptr+1).part$,1)<>"$" then lparts(addptr+1).token=token_string
	mov	arg02, ##@LR__5563
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0190
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	add	local05, #4
	rdlong	local11, local05
	sub	local05, #4
	mov	local12, local11
	cmp	local12, ##516 wz
 if_ne	jmp	#LR__0190
	mov	local22, local37
	add	local22, #1
	shl	local22, #3
	mov	local23, objptr
	add	local23, ##28080
	add	local22, local23
	rdlong	arg01, local22
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	local28, ##@LR__5564
	mov	local13, local28
	mov	arg02, local13
	call	#__system___string_cmp
	mov	local14, result1 wz
 if_e	jmp	#LR__0190
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
LR__0190
' if (lp$="copy") andalso lparts(addptr+3).token=token_name andalso right$(lparts(addptr+3).part$,1)<>"$" then lparts(addptr+3).token=token_string
	mov	arg02, ##@LR__5565
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0191
	mov	local05, local37
	add	local05, #3
	shl	local05, #3
	mov	local06, objptr
	add	local06, ##28080
	add	local05, local06
	add	local05, #4
	rdlong	local11, local05
	sub	local05, #4
	mov	local12, local11
	cmp	local12, ##516 wz
 if_ne	jmp	#LR__0191
	mov	local22, local37
	add	local22, #3
	shl	local22, #3
	mov	local23, objptr
	add	local23, ##28080
	add	local22, local23
	rdlong	arg01, local22
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	local28, ##@LR__5566
	mov	local13, local28
	mov	arg02, local13
	call	#__system___string_cmp
	mov	local14, result1 wz
 if_e	jmp	#LR__0191
	mov	local10, local37
	add	local10, #3
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
LR__0191
' 
' ' cd needs special treatment..
' 
' if lp$="cd" then lparts(addptr+1).token=token_string
	mov	arg02, ##@LR__5567
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0192
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
LR__0192
' if lp$="cd." andalso lparts(addptr+1).part$="." then lparts(addptr+1).token=token_string : lparts(addptr+1).part$=".." : lparts(addptr).token=token_cd
	mov	arg02, ##@LR__5568
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0193
	mov	local06, local37
	add	local06, #1
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	rdlong	arg01, local06
	mov	local05, ##@LR__5569
	mov	arg02, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0193
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##28080
	add	local10, objptr
	add	local10, #4
	wrlong	##515, local10
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	local10, objptr
	mov	local06, ##@LR__5570
	wrlong	local06, local10
	mov	local10, local37
	shl	local10, #3
	mov	local05, objptr
	add	local10, objptr
	mov	local06, #195
	add	local10, #4
	wrlong	#195, local10
	sub	objptr, ##28080
LR__0193
' if lp$="cd" andalso lparts(addptr+1).part$="/" then lparts(addptr+1).token=token_string : for i=(addptr+2) to k: lparts(addptr+1).part$+=lparts(i).part$ : next i
	mov	local10, ##@LR__5571
	mov	arg01, local41
	mov	arg02, local10
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0196
	mov	local06, local37
	add	local06, #1
	shl	local06, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local06, local12
	rdlong	arg01, local06
	mov	local05, ##@LR__5572
	mov	local10, local05
	mov	arg02, local10
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0196
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local05, ##28080
	add	local10, local05
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
	sub	local10, #4
	mov	local02, local37
	add	local02, #2
	mov	local52, local17
	add	local52, #1
LR__0194
	cmps	local02, local52 wc
 if_ae	jmp	#LR__0195
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##28080
	mov	local05, objptr
	add	local10, objptr
	mov	local14, local37
	add	local14, #1
	shl	local14, #3
	add	local14, objptr
	rdlong	arg01, local14
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	mov	local28, objptr
	add	local13, objptr
	rdlong	local12, local13
	mov	arg02, local12
	sub	objptr, ##28080
	call	#__system___string_concat
	mov	local06, result1
	wrlong	local06, local10
	add	local02, #1
	jmp	#LR__0194
LR__0195
LR__0196
' 
' ' determine a type of the line and compile it
' 
' if isdec(lparts(0).part$) then linenum=val%(lparts(0).part$)
	add	objptr, ##28080
	rdlong	arg01, objptr
	sub	objptr, ##28080
	call	#_isdec
	cmp	result1, #0 wz
 if_e	jmp	#LR__0197
	add	objptr, ##28080
	rdlong	arg01, objptr
	sub	objptr, ##28080
	mov	arg02, #0
	call	#__system____builtin_atoi
	add	objptr, ##43148
	wrlong	result1, objptr
	sub	objptr, ##43148
LR__0197
' if linenum>0 andalso k=1 andalso cont=3 then deleteline(linenum) : goto 104   ' this was an empty numbered line, delete it
	add	objptr, ##43148
	rdlong	local04, objptr
	sub	objptr, ##43148
	cmp	local04, #1 wc
 if_b	jmp	#LR__0198
	cmp	local17, #1 wz
 if_e	add	objptr, ##29128
 if_e	rdlong	local05, objptr
 if_e	sub	objptr, ##29128
 if_e	mov	local10, local05
 if_e	cmp	local10, #3 wz
 if_ne	jmp	#LR__0198
	add	objptr, ##43148
	rdlong	arg01, objptr
	sub	objptr, ##43148
	call	#_deleteline
	jmp	#LR__0209
LR__0198
' 
' if (cont=0 orelse cont=3) andalso lparts(2).token<>token_eq  then  		' first part, commans
	add	objptr, ##29128
	rdlong	local04, objptr wz
	sub	objptr, ##29128
 if_e	jmp	#LR__0199
	add	objptr, ##29128
	rdlong	local05, objptr
	sub	objptr, ##29128
	mov	local10, local05
	cmp	local10, #3 wz
 if_ne	jmp	#LR__0201
LR__0199
	add	objptr, ##28100
	rdlong	local12, objptr
	sub	objptr, ##28100
	cmp	local12, #27 wz
 if_e	jmp	#LR__0201
	add	objptr, ##43148
	rdlong	arg01, objptr
	sub	objptr, ##14020
	rdlong	arg03, objptr
	sub	objptr, ##29128
	mov	arg02, #0
	call	#_compile
	mov	local01, result1 wz
'   err=compile(linenum,0,cont) 
'   if err<>0 then printerror(err,linenum): goto 101
 if_e	jmp	#LR__0200
	add	objptr, ##43148
	rdlong	arg02, objptr
	sub	objptr, ##43148
	mov	arg01, local01
	call	#_printerror
	jmp	#LR__0210
LR__0200
'   if rest$<>"" then  line$=rest$ : cont=4 : goto 108 else goto 104
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	arg02, ##@LR__5573
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0209
	add	objptr, ##43216
	rdlong	local04, objptr
	sub	objptr, ##14096
	wrlong	local04, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##29128
	jmp	#LR__0070
LR__0201
'       							
' if (cont=1 orelse cont=2) andalso lparts(1).token<>token_eq  then 		' not a first part, command
	add	objptr, ##29128
	rdlong	local04, objptr
	sub	objptr, ##29128
	cmp	local04, #1 wz
 if_ne	add	objptr, ##29128
 if_ne	rdlong	local10, objptr
 if_ne	sub	objptr, ##29128
 if_ne	cmp	local10, #2 wz
 if_ne	jmp	#LR__0203
	add	objptr, ##28092
	rdlong	local12, objptr
	sub	objptr, ##28092
	cmp	local12, #27 wz
 if_e	jmp	#LR__0203
	add	objptr, ##43148
	rdlong	arg01, objptr
	sub	objptr, ##14020
	rdlong	arg03, objptr
	sub	objptr, ##29128
	mov	arg02, #0
	call	#_compile
	mov	local01, result1 wz
'   err=compile(linenum,0,cont) 
'   if err<>0 then printerror(err,linenum): goto 101
 if_e	jmp	#LR__0202
	add	objptr, ##43148
	rdlong	arg02, objptr
	sub	objptr, ##43148
	mov	arg01, local01
	call	#_printerror
	jmp	#LR__0210
LR__0202
'   if rest$<>"" then line$=rest$: cont=4 : goto 108 else goto 104  	
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	arg02, ##@LR__5574
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0209
	add	objptr, ##43216
	rdlong	local04, objptr
	sub	objptr, ##14096
	wrlong	local04, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##29128
	jmp	#LR__0070
LR__0203
' 							 
' if (cont=0 orelse cont=3) andalso lparts(2).token=token_eq then  		' first part, assign
	add	objptr, ##29128
	rdlong	local04, objptr wz
	sub	objptr, ##29128
 if_ne	add	objptr, ##29128
 if_ne	rdlong	local10, objptr
 if_ne	sub	objptr, ##29128
 if_ne	cmp	local10, #3 wz
 if_e	add	objptr, ##28100
 if_e	rdlong	local12, objptr
 if_e	sub	objptr, ##28100
 if_e	cmp	local12, #27 wz
 if_ne	jmp	#LR__0205
	add	objptr, ##43148
	rdlong	arg01, objptr
	sub	objptr, ##14020
	rdlong	arg03, objptr
	sub	objptr, ##29128
	mov	arg02, #0
	call	#_compile_assign
	mov	local01, result1 wz
'   err=compile_assign(linenum,0,cont)
'   if err<>0 then printerror(err,linenum): goto 101
 if_e	jmp	#LR__0204
	add	objptr, ##43148
	rdlong	arg02, objptr
	sub	objptr, ##43148
	mov	arg01, local01
	call	#_printerror
	jmp	#LR__0210
LR__0204
'   if rest$<>"" then line$=rest$: cont=4 : goto 108 else goto 104
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	arg02, ##@LR__5575
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0209
	add	objptr, ##43216
	rdlong	local04, objptr
	sub	objptr, ##14096
	wrlong	local04, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##29128
	jmp	#LR__0070
LR__0205
'     							 
' if (cont=1 orelse cont=2) andalso lparts(1).token=token_eq then 		' not a first part, assign
	add	objptr, ##29128
	rdlong	local04, objptr
	sub	objptr, ##29128
	cmp	local04, #1 wz
 if_ne	add	objptr, ##29128
 if_ne	rdlong	local10, objptr
 if_ne	sub	objptr, ##29128
 if_ne	cmp	local10, #2 wz
 if_e	add	objptr, ##28092
 if_e	rdlong	local12, objptr
 if_e	sub	objptr, ##28092
 if_e	cmp	local12, #27 wz
 if_ne	jmp	#LR__0208
	add	objptr, ##43148
	rdlong	arg01, objptr
	sub	objptr, ##14020
	rdlong	arg03, objptr
	sub	objptr, ##29128
	mov	arg02, #0
	call	#_compile_assign
	mov	local01, result1 wz
'   err=compile_assign(linenum,0,cont) 
'   if err<>0 then printerror(err,linenum): goto 101
 if_e	jmp	#LR__0206
	add	objptr, ##43148
	rdlong	arg02, objptr
	sub	objptr, ##43148
	mov	arg01, local01
	call	#_printerror
	jmp	#LR__0210
LR__0206
'   if rest$<>"" then line$=rest$: cont=4 : goto 108 else goto 104  								 
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	arg02, ##@LR__5576
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	jmp	#LR__0207
	add	objptr, ##43216
	rdlong	local04, objptr
	sub	objptr, ##14096
	wrlong	local04, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##29128
	jmp	#LR__0070
LR__0207
LR__0208
LR__0209
' 
' 104 if linenum=0 then 								' line 0 is for immediate execution
	add	objptr, ##43148
	rdlong	local04, objptr wz
	sub	objptr, ##43148
 if_ne	jmp	#LR__0213
	mov	arg01, #2
	call	#_execute_line
LR__0210
'   execute_line(2)
' 101 if inload=0 then v.writeln("") : v.writeln("Ready") 
	add	objptr, ##43184
	rdlong	local04, objptr wz
	sub	objptr, ##43184
 if_ne	jmp	#LR__0211
	mov	arg01, ##@LR__5577
' 
' write(text)
	call	#_Hg010b_4_spin2_write
' crlf
	call	#_Hg010b_4_spin2_crlf
	mov	arg01, ##@LR__5578
' 
' write(text)
	call	#_Hg010b_4_spin2_write
' crlf
	call	#_Hg010b_4_spin2_crlf
LR__0211
'     if inload=1 andalso err>0 then print fullline$
	add	objptr, ##43184
	rdlong	local04, objptr
	sub	objptr, ##43184
	cmp	local04, #1 wz
 if_ne	jmp	#LR__0212
	cmps	local01, #1 wc
 if_b	jmp	#LR__0212
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	add	objptr, ##29124
	rdlong	arg02, objptr
	sub	objptr, ##29124
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__0212
LR__0213
	mov	ptra, fp
	call	#popregs_
_interpret_ret
	ret

' 
' '---------------------------------------------------------------------------------------------------------------------
' '
' '                          END OF TOKENIZER MAIN CODE
' '
' '---------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------
' '-------------------- Helper functions for the tokenizer -------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------
' 
' ' Check if the part is an operator, return a token or 0 if not found
' 
' function isoperator(s as string) as ubyte
_isoperator
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5579
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0220
	mov	arg02, ##@LR__5580
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0221
	mov	arg02, ##@LR__5581
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0222
	mov	arg02, ##@LR__5582
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0223
	mov	arg02, ##@LR__5583
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0224
	mov	arg02, ##@LR__5584
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0225
	mov	arg02, ##@LR__5585
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0226
	mov	arg02, ##@LR__5586
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0227
	mov	arg02, ##@LR__5587
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0228
	mov	arg02, ##@LR__5588
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0229
	mov	arg02, ##@LR__5589
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0230
	mov	arg02, ##@LR__5590
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0231
	mov	arg02, ##@LR__5591
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0232
	mov	arg02, ##@LR__5592
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0233
	mov	arg02, ##@LR__5593
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0234
	mov	arg02, ##@LR__5594
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0235
	mov	arg02, ##@LR__5595
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0236
	mov	arg02, ##@LR__5596
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0237
	mov	arg02, ##@LR__5597
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0238
	mov	arg02, ##@LR__5598
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0239
	mov	arg02, ##@LR__5599
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0240
	mov	arg02, ##@LR__5600
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0241
	jmp	#LR__0242
LR__0220
	mov	result1, #1
	jmp	#LR__0243
LR__0221
	mov	result1, #2
	jmp	#LR__0243
LR__0222
	mov	result1, #3
	jmp	#LR__0243
LR__0223
	mov	result1, #4
	jmp	#LR__0243
LR__0224
	mov	result1, #5
	jmp	#LR__0243
LR__0225
	mov	result1, #6
	jmp	#LR__0243
LR__0226
	mov	result1, #7
	jmp	#LR__0243
LR__0227
	mov	result1, #8
	jmp	#LR__0243
LR__0228
	mov	result1, #9
	jmp	#LR__0243
LR__0229
	mov	result1, #10
	jmp	#LR__0243
LR__0230
	mov	result1, #11
	jmp	#LR__0243
LR__0231
	mov	result1, #12
	jmp	#LR__0243
LR__0232
	mov	result1, #13
	jmp	#LR__0243
LR__0233
	mov	result1, #14
	jmp	#LR__0243
LR__0234
	mov	result1, #27
	jmp	#LR__0243
LR__0235
	mov	result1, #39
	jmp	#LR__0243
LR__0236
	mov	result1, #38
	jmp	#LR__0243
LR__0237
	mov	result1, #16
	jmp	#LR__0243
LR__0238
	mov	result1, #15
	jmp	#LR__0243
LR__0239
	mov	result1, #42
	jmp	#LR__0243
LR__0240
	mov	result1, #40
	jmp	#LR__0243
LR__0241
	mov	result1, #41
	jmp	#LR__0243
LR__0242
	mov	result1, #0
LR__0243
	mov	ptra, fp
	call	#popregs_
_isoperator_ret
	ret

' 
' ' Check if the part is a channel#, return a token or 0 if not found
' 
' function ischannel(s as string) as ulong
_ischannel
	mov	COUNT_, #2
	call	#pushregs_
' if left$(s,1)<>"#" then return 0
	mov	local01, arg01
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5601
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0254
' if len(s)<>2 then return 0
	mov	arg01, local01
	mov	local02, arg01
	callpa	#(@LR__0251-@LR__0250)>>2,fcache_load_ptr_
LR__0250
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0250
LR__0251
	sub	local02, arg01
	mov	result1, local02
	cmp	result1, #2 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0254
' if right$(s,1)<"0" orelse right$(s,1)>"9" then return 0
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5602
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0252
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5603
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0253
LR__0252
	mov	result1, #0
	jmp	#LR__0254
LR__0253
' return token_channel+val(right$(s,1))
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, ##1110441984
	call	#__system___float_add
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
LR__0254
	mov	ptra, fp
	call	#popregs_
_ischannel_ret
	ret

' 
' ' Check if the part is a predefined constant, return a constant or 0 if not found
' ' todo: add spin2/pasm constants for pin control
' 
' function isconstant(s as string) as integer
_isconstant
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5604
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0260
	mov	arg02, ##@LR__5605
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0261
	mov	arg02, ##@LR__5606
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0262
	jmp	#LR__0263
LR__0260
	mov	result1, #1
	jmp	#LR__0264
LR__0261
	mov	result1, #2
	jmp	#LR__0264
LR__0262
	mov	result1, #4
	jmp	#LR__0264
LR__0263
	mov	result1, #0
LR__0264
	mov	ptra, fp
	call	#popregs_
_isconstant_ret
	ret

' 
' ' Check if the part is a predefined music note name, return a token or 0 if not found
' 
' function isnotename(s as string) as ulong
_isnotename
	mov	COUNT_, #7
	call	#pushregs_
' if left$(s,1)<>"#" then return 0
	mov	local01, arg01
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5607
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0293
' if mid$(s,3,1)="#" then s1=mid$(s,2,2) else s1=mid$(s,2,1)
	mov	arg01, local01
	mov	arg02, #3
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__5608
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0270
	mov	arg01, local01
	mov	arg02, #2
	mov	arg03, #2
	call	#__system__Mid_S
	mov	local02, result1
	jmp	#LR__0271
LR__0270
	mov	arg01, local01
	mov	arg02, #2
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local02, result1
LR__0271
' if mid$(s,len(s)-1,1)<>"-" then nn=val(right$(s,1)) else nn=-1*val(right$(s,1))
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__0273-@LR__0272)>>2,fcache_load_ptr_
LR__0272
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__0272
LR__0273
	sub	local03, arg01
	mov	arg02, local03
	sub	arg02, #1
	mov	arg01, local01
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__5609
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0274
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local04, result1
	jmp	#LR__0275
LR__0274
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, ##-1082130432
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local04, result1
LR__0275
' 
' if nn=0 andalso right$(s,1)<>"0" then nn=4
	cmp	local04, #0 wz
 if_ne	jmp	#LR__0276
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5610
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	local04, #4
LR__0276
' 
' select case s1
	mov	local05, local02
	mov	arg02, ##@LR__5611
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0277
	mov	arg02, ##@LR__5612
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0278
	mov	arg02, ##@LR__5613
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0279
	mov	arg02, ##@LR__5614
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0280
	mov	arg02, ##@LR__5615
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0281
	mov	arg02, ##@LR__5616
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0282
	mov	arg02, ##@LR__5617
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0283
	mov	arg02, ##@LR__5618
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0284
	mov	arg02, ##@LR__5619
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0285
	mov	arg02, ##@LR__5620
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0286
	mov	arg02, ##@LR__5621
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0287
	mov	arg02, ##@LR__5622
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0288
	mov	arg02, ##@LR__5623
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0289
	jmp	#LR__0290
LR__0277
	mov	local06, ##768
	jmp	#LR__0291
LR__0278
	mov	local06, ##769
	jmp	#LR__0291
LR__0279
	mov	local06, ##770
	jmp	#LR__0291
LR__0280
	mov	local06, ##771
	jmp	#LR__0291
LR__0281
	mov	local06, ##772
	jmp	#LR__0291
LR__0282
	mov	local06, ##773
	jmp	#LR__0291
LR__0283
	mov	local06, ##774
	jmp	#LR__0291
LR__0284
	mov	local06, ##775
	jmp	#LR__0291
LR__0285
	mov	local06, ##776
	jmp	#LR__0291
LR__0286
	mov	local06, ##777
	jmp	#LR__0291
LR__0287
	mov	local06, ##778
	jmp	#LR__0291
LR__0288
	mov	local06, ##779
	jmp	#LR__0291
LR__0289
	mov	local06, ##779
	jmp	#LR__0291
LR__0290
	mov	result1, #0
	jmp	#LR__0293
LR__0291
' if nn>=-1 andalso nn<10 then token=token+12*nn
	cmps	local04, ##-1 wc
 if_b	jmp	#LR__0292
	cmps	local04, #10 wc
 if_b	mov	local07, local04
 if_b	shl	local07, #1
 if_b	add	local07, local04
 if_b	shl	local07, #2
 if_b	add	local06, local07
LR__0292
' return token
	mov	result1, local06
LR__0293
	mov	ptra, fp
	call	#popregs_
_isnotename_ret
	ret

' 
' ' Check if the part is a separator, return a token or 0 if not found
' 
' function isseparator(s as string) as ubyte
_isseparator
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5624
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0300
	mov	arg02, ##@LR__5625
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0301
	mov	arg02, ##@LR__5626
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0302
	mov	arg02, ##@LR__5627
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0303
	mov	arg02, ##@LR__5628
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0304
	mov	arg02, ##@LR__5629
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0305
	mov	arg02, ##@LR__5630
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0306
	mov	arg02, ##@LR__5631
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0307
	mov	arg02, ##@LR__5632
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0308
	mov	arg02, ##@LR__5633
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0309
	mov	arg02, ##@LR__5634
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0310
	mov	arg02, ##@LR__5635
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0311
	mov	arg02, ##@LR__5636
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0312
	mov	arg02, ##@LR__5637
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0313
	mov	arg02, ##@LR__5638
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0314
	jmp	#LR__0315
LR__0300
	mov	result1, #1
	jmp	#LR__0316
LR__0301
	mov	result1, #2
	jmp	#LR__0316
LR__0302
	mov	result1, #27
	jmp	#LR__0316
LR__0303
	mov	result1, #17
	jmp	#LR__0316
LR__0304
	mov	result1, #5
	jmp	#LR__0316
LR__0305
	mov	result1, #6
	jmp	#LR__0316
LR__0306
	mov	result1, #18
	jmp	#LR__0316
LR__0307
	mov	result1, #19
	jmp	#LR__0316
LR__0308
	mov	result1, #12
	jmp	#LR__0316
LR__0309
	mov	result1, #20
	jmp	#LR__0316
LR__0310
	mov	result1, #21
	jmp	#LR__0316
LR__0311
	mov	result1, #22
	jmp	#LR__0316
LR__0312
	mov	result1, #511
	jmp	#LR__0316
LR__0313
	mov	result1, #15
	jmp	#LR__0316
LR__0314
	mov	result1, #16
	jmp	#LR__0316
LR__0315
	mov	result1, #0
LR__0316
	mov	ptra, fp
	call	#popregs_
_isseparator_ret
	ret

' 
' ' Check if the part is a command than doesn't return a value, return a token or 0 if not found
' 
' function iscommand(s as string) as ubyte
_iscommand
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5640
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0320
	mov	arg02, ##@LR__5641
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0321
	mov	arg02, ##@LR__5642
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0322
	mov	arg02, ##@LR__5643
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0323
	mov	arg02, ##@LR__5644
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0324
	mov	arg02, ##@LR__5645
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0325
	mov	arg02, ##@LR__5646
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0326
	mov	arg02, ##@LR__5647
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0327
	mov	arg02, ##@LR__5648
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0328
	mov	arg02, ##@LR__5649
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0329
	mov	arg02, ##@LR__5650
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0330
	mov	arg02, ##@LR__5651
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0331
	mov	arg02, ##@LR__5652
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0332
	mov	arg02, ##@LR__5653
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0333
	mov	arg02, ##@LR__5654
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0334
	mov	arg02, ##@LR__5655
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0335
	mov	arg02, ##@LR__5656
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0336
	mov	arg02, ##@LR__5657
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0337
	mov	arg02, ##@LR__5658
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0338
	mov	arg02, ##@LR__5659
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0339
	mov	arg02, ##@LR__5660
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0340
	mov	arg02, ##@LR__5661
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0341
	mov	arg02, ##@LR__5662
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0342
	mov	arg02, ##@LR__5663
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0343
	mov	arg02, ##@LR__5664
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0344
	mov	arg02, ##@LR__5665
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0345
	mov	arg02, ##@LR__5666
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0346
	mov	arg02, ##@LR__5667
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0347
	mov	arg02, ##@LR__5668
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0348
	mov	arg02, ##@LR__5669
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0349
	mov	arg02, ##@LR__5670
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0350
	mov	arg02, ##@LR__5671
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0351
	mov	arg02, ##@LR__5672
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0352
	mov	arg02, ##@LR__5673
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0353
	mov	arg02, ##@LR__5674
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0354
	mov	arg02, ##@LR__5675
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0355
	mov	arg02, ##@LR__5676
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0356
	mov	arg02, ##@LR__5677
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0357
	mov	arg02, ##@LR__5678
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0358
	mov	arg02, ##@LR__5679
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0359
	mov	arg02, ##@LR__5680
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0360
	mov	arg02, ##@LR__5681
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0361
	mov	arg02, ##@LR__5682
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0362
	mov	arg02, ##@LR__5683
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0363
	mov	arg02, ##@LR__5684
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0364
	mov	arg02, ##@LR__5685
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0365
	mov	arg02, ##@LR__5686
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0366
	mov	arg02, ##@LR__5687
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0367
	mov	arg02, ##@LR__5688
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0368
	mov	arg02, ##@LR__5689
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0369
	mov	arg02, ##@LR__5690
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0370
	mov	arg02, ##@LR__5691
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0371
	mov	arg02, ##@LR__5692
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0372
	mov	arg02, ##@LR__5693
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0373
	mov	arg02, ##@LR__5694
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0374
	mov	arg02, ##@LR__5695
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0375
	mov	arg02, ##@LR__5696
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0376
	mov	arg02, ##@LR__5697
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0377
	mov	arg02, ##@LR__5698
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0378
	mov	arg02, ##@LR__5699
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0379
	mov	arg02, ##@LR__5700
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0380
	mov	arg02, ##@LR__5701
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0381
	mov	arg02, ##@LR__5702
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0382
	mov	arg02, ##@LR__5703
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0383
	mov	arg02, ##@LR__5704
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0384
	mov	arg02, ##@LR__5705
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0385
	mov	arg02, ##@LR__5706
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0386
	mov	arg02, ##@LR__5707
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0387
	mov	arg02, ##@LR__5708
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0388
	mov	arg02, ##@LR__5709
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0389
	mov	arg02, ##@LR__5710
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0390
	mov	arg02, ##@LR__5711
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0391
	mov	arg02, ##@LR__5712
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0392
	mov	arg02, ##@LR__5713
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0393
	mov	arg02, ##@LR__5714
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0394
	mov	arg02, ##@LR__5715
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0395
	mov	arg02, ##@LR__5716
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0396
	mov	arg02, ##@LR__5717
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0397
	mov	arg02, ##@LR__5718
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0398
	mov	arg02, ##@LR__5719
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0399
	mov	arg02, ##@LR__5720
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0400
	mov	arg02, ##@LR__5721
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0401
	mov	arg02, ##@LR__5722
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0402
	mov	arg02, ##@LR__5723
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0403
	mov	arg02, ##@LR__5724
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0404
	mov	arg02, ##@LR__5725
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0405
	mov	arg02, ##@LR__5726
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0406
	mov	arg02, ##@LR__5727
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0407
	mov	arg02, ##@LR__5728
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0408
	mov	arg02, ##@LR__5729
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0409
	mov	arg02, ##@LR__5730
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0410
	mov	arg02, ##@LR__5731
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0411
	mov	arg02, ##@LR__5732
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0412
	mov	arg02, ##@LR__5733
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0413
	mov	arg02, ##@LR__5734
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0414
	mov	arg02, ##@LR__5735
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0415
	mov	arg02, ##@LR__5736
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0416
	mov	arg02, ##@LR__5737
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0417
	mov	arg02, ##@LR__5738
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0418
	mov	arg02, ##@LR__5739
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0419
	mov	arg02, ##@LR__5740
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0420
	mov	arg02, ##@LR__5741
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0421
	mov	arg02, ##@LR__5742
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0422
	mov	arg02, ##@LR__5743
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0423
	mov	arg02, ##@LR__5744
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0424
	mov	arg02, ##@LR__5745
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0425
	mov	arg02, ##@LR__5746
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0426
	mov	arg02, ##@LR__5747
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0427
	mov	arg02, ##@LR__5748
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0428
	mov	arg02, ##@LR__5749
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0429
	mov	arg02, ##@LR__5750
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0430
	mov	arg02, ##@LR__5751
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0431
	mov	arg02, ##@LR__5752
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0432
	mov	arg02, ##@LR__5753
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0433
	mov	arg02, ##@LR__5754
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0434
	mov	arg02, ##@LR__5755
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0435
	mov	arg02, ##@LR__5756
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0436
	mov	arg02, ##@LR__5757
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0437
	mov	arg02, ##@LR__5758
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0438
	mov	arg02, ##@LR__5759
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0439
	mov	arg02, ##@LR__5760
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0440
	mov	arg02, ##@LR__5761
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0441
	mov	arg02, ##@LR__5762
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0442
	mov	arg02, ##@LR__5763
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0443
	mov	arg02, ##@LR__5764
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0444
	mov	arg02, ##@LR__5765
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0445
	mov	arg02, ##@LR__5766
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0446
	mov	arg02, ##@LR__5767
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0447
	mov	arg02, ##@LR__5768
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0448
	mov	arg02, ##@LR__5769
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0449
	mov	arg02, ##@LR__5770
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0450
	mov	arg02, ##@LR__5771
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0451
	mov	arg02, ##@LR__5772
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0452
	mov	arg02, ##@LR__5773
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0453
	mov	arg02, ##@LR__5774
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0454
	mov	arg02, ##@LR__5775
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0455
	mov	arg02, ##@LR__5776
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0456
	mov	arg02, ##@LR__5777
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0457
	mov	arg02, ##@LR__5778
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0458
	mov	arg02, ##@LR__5779
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0459
	mov	arg02, ##@LR__5780
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0460
	jmp	#LR__0461
LR__0320
	mov	result1, #92
	jmp	#LR__0462
LR__0321
	mov	result1, #92
	jmp	#LR__0462
LR__0322
	mov	result1, #185
	jmp	#LR__0462
LR__0323
	mov	result1, #71
	jmp	#LR__0462
LR__0324
	mov	result1, #89
	jmp	#LR__0462
LR__0325
	mov	result1, #89
	jmp	#LR__0462
LR__0326
	mov	result1, #195
	jmp	#LR__0462
LR__0327
	mov	result1, #174
	jmp	#LR__0462
LR__0328
	mov	result1, #174
	jmp	#LR__0462
LR__0329
	mov	result1, #177
	jmp	#LR__0462
LR__0330
	mov	result1, #177
	jmp	#LR__0462
LR__0331
	mov	result1, #175
	jmp	#LR__0462
LR__0332
	mov	result1, #175
	jmp	#LR__0462
LR__0333
	mov	result1, #176
	jmp	#LR__0462
LR__0334
	mov	result1, #176
	jmp	#LR__0462
LR__0335
	mov	result1, #69
	jmp	#LR__0462
LR__0336
	mov	result1, #69
	jmp	#LR__0462
LR__0337
	mov	result1, #105
	jmp	#LR__0462
LR__0338
	mov	result1, #180
	jmp	#LR__0462
LR__0339
	mov	result1, #64
	jmp	#LR__0462
LR__0340
	mov	result1, #207
	jmp	#LR__0462
LR__0341
	mov	result1, #73
	jmp	#LR__0462
LR__0342
	mov	result1, #73
	jmp	#LR__0462
LR__0343
	mov	result1, #196
	jmp	#LR__0462
LR__0344
	mov	result1, #104
	jmp	#LR__0462
LR__0345
	mov	result1, #183
	jmp	#LR__0462
LR__0346
	mov	result1, #217
	jmp	#LR__0462
LR__0347
	mov	result1, #115
	jmp	#LR__0462
LR__0348
	mov	result1, #116
	jmp	#LR__0462
LR__0349
	mov	result1, #108
	jmp	#LR__0462
LR__0350
	mov	result1, #108
	jmp	#LR__0462
LR__0351
	mov	result1, #137
	jmp	#LR__0462
LR__0352
	mov	result1, #194
	jmp	#LR__0462
LR__0353
	mov	result1, #114
	jmp	#LR__0462
LR__0354
	mov	result1, #93
	jmp	#LR__0462
LR__0355
	mov	result1, #150
	jmp	#LR__0462
LR__0356
	mov	result1, #67
	jmp	#LR__0462
LR__0357
	mov	result1, #67
	jmp	#LR__0462
LR__0358
	mov	result1, #67
	jmp	#LR__0462
LR__0359
	mov	result1, #90
	jmp	#LR__0462
LR__0360
	mov	result1, #171
	jmp	#LR__0462
LR__0361
	mov	result1, #189
	jmp	#LR__0462
LR__0362
	mov	result1, #189
	jmp	#LR__0462
LR__0363
	mov	result1, #70
	jmp	#LR__0462
LR__0364
	mov	result1, #70
	jmp	#LR__0462
LR__0365
	mov	result1, #113
	jmp	#LR__0462
LR__0366
	mov	result1, #113
	jmp	#LR__0462
LR__0367
	mov	result1, #96
	jmp	#LR__0462
LR__0368
	mov	result1, #74
	jmp	#LR__0462
LR__0369
	mov	result1, #74
	jmp	#LR__0462
LR__0370
	mov	result1, #72
	jmp	#LR__0462
LR__0371
	mov	result1, #72
	jmp	#LR__0462
LR__0372
	mov	result1, #187
	jmp	#LR__0462
LR__0373
	mov	result1, #169
	jmp	#LR__0462
LR__0374
	mov	result1, #78
	jmp	#LR__0462
LR__0375
	mov	result1, #78
	jmp	#LR__0462
LR__0376
	mov	result1, #88
	jmp	#LR__0462
LR__0377
	mov	result1, #95
	jmp	#LR__0462
LR__0378
	mov	result1, #95
	jmp	#LR__0462
LR__0379
	mov	result1, #181
	jmp	#LR__0462
LR__0380
	mov	result1, #76
	jmp	#LR__0462
LR__0381
	mov	result1, #76
	jmp	#LR__0462
LR__0382
	mov	result1, #82
	jmp	#LR__0462
LR__0383
	mov	result1, #82
	jmp	#LR__0462
LR__0384
	mov	result1, #151
	jmp	#LR__0462
LR__0385
	mov	result1, #198
	jmp	#LR__0462
LR__0386
	mov	result1, #97
	jmp	#LR__0462
LR__0387
	mov	result1, #97
	jmp	#LR__0462
LR__0388
	mov	result1, #99
	jmp	#LR__0462
LR__0389
	mov	result1, #65
	jmp	#LR__0462
LR__0390
	mov	result1, #75
	jmp	#LR__0462
LR__0391
	mov	result1, #75
	jmp	#LR__0462
LR__0392
	mov	result1, #193
	jmp	#LR__0462
LR__0393
	mov	result1, #179
	jmp	#LR__0462
LR__0394
	mov	result1, #94
	jmp	#LR__0462
LR__0395
	mov	result1, #94
	jmp	#LR__0462
LR__0396
	mov	result1, #124
	jmp	#LR__0462
LR__0397
	mov	result1, #126
	jmp	#LR__0462
LR__0398
	mov	result1, #125
	jmp	#LR__0462
LR__0399
	mov	result1, #127
	jmp	#LR__0462
LR__0400
	mov	result1, #128
	jmp	#LR__0462
LR__0401
	mov	result1, #85
	jmp	#LR__0462
LR__0402
	mov	result1, #117
	jmp	#LR__0462
LR__0403
	mov	result1, #117
	jmp	#LR__0462
LR__0404
	mov	result1, #66
	jmp	#LR__0462
LR__0405
	mov	result1, #66
	jmp	#LR__0462
LR__0406
	mov	result1, #149
	jmp	#LR__0462
LR__0407
	mov	result1, #172
	jmp	#LR__0462
LR__0408
	mov	result1, #129
	jmp	#LR__0462
LR__0409
	mov	result1, #129
	jmp	#LR__0462
LR__0410
	mov	result1, #68
	jmp	#LR__0462
LR__0411
	mov	result1, #68
	jmp	#LR__0462
LR__0412
	mov	result1, #188
	jmp	#LR__0462
LR__0413
	mov	result1, #136
	jmp	#LR__0462
LR__0414
	mov	result1, #182
	jmp	#LR__0462
LR__0415
	mov	result1, #146
	jmp	#LR__0462
LR__0416
	mov	result1, #190
	jmp	#LR__0462
LR__0417
	mov	result1, #190
	jmp	#LR__0462
LR__0418
	mov	result1, #199
	jmp	#LR__0462
LR__0419
	mov	result1, #212
	jmp	#LR__0462
LR__0420
	mov	result1, #212
	jmp	#LR__0462
LR__0421
	mov	result1, #170
	jmp	#LR__0462
LR__0422
	mov	result1, #77
	jmp	#LR__0462
LR__0423
	mov	result1, #77
	jmp	#LR__0462
LR__0424
	mov	result1, #81
	jmp	#LR__0462
LR__0425
	mov	result1, #81
	jmp	#LR__0462
LR__0426
	mov	result1, #210
	jmp	#LR__0462
LR__0427
	mov	result1, #210
	jmp	#LR__0462
LR__0428
	mov	result1, #218
	jmp	#LR__0462
LR__0429
	mov	result1, #218
	jmp	#LR__0462
LR__0430
	mov	result1, #142
	jmp	#LR__0462
LR__0431
	mov	result1, #142
	jmp	#LR__0462
LR__0432
	mov	result1, #144
	jmp	#LR__0462
LR__0433
	mov	result1, #144
	jmp	#LR__0462
LR__0434
	mov	result1, #141
	jmp	#LR__0462
LR__0435
	mov	result1, #141
	jmp	#LR__0462
LR__0436
	mov	result1, #140
	jmp	#LR__0462
LR__0437
	mov	result1, #140
	jmp	#LR__0462
LR__0438
	mov	result1, #145
	jmp	#LR__0462
LR__0439
	mov	result1, #145
	jmp	#LR__0462
LR__0440
	mov	result1, #139
	jmp	#LR__0462
LR__0441
	mov	result1, #139
	jmp	#LR__0462
LR__0442
	mov	result1, #143
	jmp	#LR__0462
LR__0443
	mov	result1, #143
	jmp	#LR__0462
LR__0444
	mov	result1, #143
	jmp	#LR__0462
LR__0445
	mov	result1, #178
	jmp	#LR__0462
LR__0446
	mov	result1, #178
	jmp	#LR__0462
LR__0447
	mov	result1, #117
	jmp	#LR__0462
LR__0448
	mov	result1, #117
	jmp	#LR__0462
LR__0449
	mov	result1, #109
	jmp	#LR__0462
LR__0450
	mov	result1, #109
	jmp	#LR__0462
LR__0451
	mov	result1, #91
	jmp	#LR__0462
LR__0452
	mov	result1, #86
	jmp	#LR__0462
LR__0453
	mov	result1, #86
	jmp	#LR__0462
LR__0454
	mov	result1, #112
	jmp	#LR__0462
LR__0455
	mov	result1, #112
	jmp	#LR__0462
LR__0456
	mov	result1, #87
	jmp	#LR__0462
LR__0457
	mov	result1, #87
	jmp	#LR__0462
LR__0458
	mov	result1, #121
	jmp	#LR__0462
LR__0459
	mov	result1, #119
	jmp	#LR__0462
LR__0460
	mov	result1, #120
	jmp	#LR__0462
LR__0461
	mov	result1, #0
LR__0462
	mov	ptra, fp
	call	#popregs_
_iscommand_ret
	ret

' 
' ' Check if the part is a function than returns a value, return a token or 0 if not found
' 
' function isfunction(s as string) as ubyte
_isfunction
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5781
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0470
	mov	arg02, ##@LR__5782
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0471
	mov	arg02, ##@LR__5783
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0472
	mov	arg02, ##@LR__5784
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0473
	mov	arg02, ##@LR__5785
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0474
	mov	arg02, ##@LR__5786
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0475
	mov	arg02, ##@LR__5787
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0476
	mov	arg02, ##@LR__5788
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0477
	mov	arg02, ##@LR__5789
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0478
	mov	arg02, ##@LR__5790
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0479
	mov	arg02, ##@LR__5791
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0480
	mov	arg02, ##@LR__5792
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0481
	mov	arg02, ##@LR__5793
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0482
	mov	arg02, ##@LR__5794
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0483
	mov	arg02, ##@LR__5795
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0484
	mov	arg02, ##@LR__5796
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0485
	mov	arg02, ##@LR__5797
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0486
	mov	arg02, ##@LR__5798
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0487
	mov	arg02, ##@LR__5799
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0488
	mov	arg02, ##@LR__5800
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0489
	mov	arg02, ##@LR__5801
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0490
	mov	arg02, ##@LR__5802
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0491
	mov	arg02, ##@LR__5803
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0492
	mov	arg02, ##@LR__5804
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0493
	mov	arg02, ##@LR__5805
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0494
	mov	arg02, ##@LR__5806
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0495
	mov	arg02, ##@LR__5807
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0496
	mov	arg02, ##@LR__5808
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0497
	mov	arg02, ##@LR__5809
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0498
	mov	arg02, ##@LR__5810
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0499
	mov	arg02, ##@LR__5811
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0500
	mov	arg02, ##@LR__5812
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0501
	mov	arg02, ##@LR__5813
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0502
	mov	arg02, ##@LR__5814
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0503
	mov	arg02, ##@LR__5815
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0504
	mov	arg02, ##@LR__5816
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0505
	mov	arg02, ##@LR__5817
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0506
	mov	arg02, ##@LR__5818
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0507
	mov	arg02, ##@LR__5819
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0508
	mov	arg02, ##@LR__5820
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0509
	mov	arg02, ##@LR__5821
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0510
	mov	arg02, ##@LR__5822
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0511
	mov	arg02, ##@LR__5823
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0512
	mov	arg02, ##@LR__5824
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0513
	mov	arg02, ##@LR__5825
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0514
	mov	arg02, ##@LR__5826
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0515
	mov	arg02, ##@LR__5827
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0516
	mov	arg02, ##@LR__5828
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0517
	mov	arg02, ##@LR__5829
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0518
	mov	arg02, ##@LR__5830
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0519
	mov	arg02, ##@LR__5831
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0520
	mov	arg02, ##@LR__5832
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0521
	mov	arg02, ##@LR__5833
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0522
	mov	arg02, ##@LR__5834
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0523
	mov	arg02, ##@LR__5835
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0524
	mov	arg02, ##@LR__5836
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0525
	mov	arg02, ##@LR__5837
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0526
	mov	arg02, ##@LR__5838
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0527
	mov	arg02, ##@LR__5839
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0528
	mov	arg02, ##@LR__5840
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0529
	mov	arg02, ##@LR__5841
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0530
	mov	arg02, ##@LR__5842
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0531
	mov	arg02, ##@LR__5843
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0532
	mov	arg02, ##@LR__5844
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0533
	jmp	#LR__0534
LR__0470
	mov	result1, #158
	jmp	#LR__0535
LR__0471
	mov	result1, #133
	jmp	#LR__0535
LR__0472
	mov	result1, #155
	jmp	#LR__0535
LR__0473
	mov	result1, #155
	jmp	#LR__0535
LR__0474
	mov	result1, #167
	jmp	#LR__0535
LR__0475
	mov	result1, #132
	jmp	#LR__0535
LR__0476
	mov	result1, #134
	jmp	#LR__0535
LR__0477
	mov	result1, #162
	jmp	#LR__0535
LR__0478
	mov	result1, #159
	jmp	#LR__0535
LR__0479
	mov	result1, #192
	jmp	#LR__0535
LR__0480
	mov	result1, #130
	jmp	#LR__0535
LR__0481
	mov	result1, #153
	jmp	#LR__0535
LR__0482
	mov	result1, #215
	jmp	#LR__0535
LR__0483
	mov	result1, #216
	jmp	#LR__0535
LR__0484
	mov	result1, #197
	jmp	#LR__0535
LR__0485
	mov	result1, #197
	jmp	#LR__0535
LR__0486
	mov	result1, #156
	jmp	#LR__0535
LR__0487
	mov	result1, #211
	jmp	#LR__0535
LR__0488
	mov	result1, #211
	jmp	#LR__0535
LR__0489
	mov	result1, #111
	jmp	#LR__0535
LR__0490
	mov	result1, #111
	jmp	#LR__0535
LR__0491
	mov	result1, #147
	jmp	#LR__0535
LR__0492
	mov	result1, #148
	jmp	#LR__0535
LR__0493
	mov	result1, #219
	jmp	#LR__0535
LR__0494
	mov	result1, #98
	jmp	#LR__0535
LR__0495
	mov	result1, #98
	jmp	#LR__0535
LR__0496
	mov	result1, #163
	jmp	#LR__0535
LR__0497
	mov	result1, #157
	jmp	#LR__0535
LR__0498
	mov	result1, #138
	jmp	#LR__0535
LR__0499
	mov	result1, #164
	jmp	#LR__0535
LR__0500
	mov	result1, #168
	jmp	#LR__0535
LR__0501
	mov	result1, #173
	jmp	#LR__0535
LR__0502
	mov	result1, #154
	jmp	#LR__0535
LR__0503
	mov	result1, #209
	jmp	#LR__0535
LR__0504
	mov	result1, #208
	jmp	#LR__0535
LR__0505
	mov	result1, #166
	jmp	#LR__0535
LR__0506
	mov	result1, #102
	jmp	#LR__0535
LR__0507
	mov	result1, #103
	jmp	#LR__0535
LR__0508
	mov	result1, #100
	jmp	#LR__0535
LR__0509
	mov	result1, #101
	jmp	#LR__0535
LR__0510
	mov	result1, #213
	jmp	#LR__0535
LR__0511
	mov	result1, #214
	jmp	#LR__0535
LR__0512
	mov	result1, #200
	jmp	#LR__0535
LR__0513
	mov	result1, #201
	jmp	#LR__0535
LR__0514
	mov	result1, #202
	jmp	#LR__0535
LR__0515
	mov	result1, #204
	jmp	#LR__0535
LR__0516
	mov	result1, #205
	jmp	#LR__0535
LR__0517
	mov	result1, #206
	jmp	#LR__0535
LR__0518
	mov	result1, #203
	jmp	#LR__0535
LR__0519
	mov	result1, #152
	jmp	#LR__0535
LR__0520
	mov	result1, #123
	jmp	#LR__0535
LR__0521
	mov	result1, #118
	jmp	#LR__0535
LR__0522
	mov	result1, #165
	jmp	#LR__0535
LR__0523
	mov	result1, #122
	jmp	#LR__0535
LR__0524
	mov	result1, #191
	jmp	#LR__0535
LR__0525
	mov	result1, #84
	jmp	#LR__0535
LR__0526
	mov	result1, #107
	jmp	#LR__0535
LR__0527
	mov	result1, #135
	jmp	#LR__0535
LR__0528
	mov	result1, #106
	jmp	#LR__0535
LR__0529
	mov	result1, #110
	jmp	#LR__0535
LR__0530
	mov	result1, #161
	jmp	#LR__0535
LR__0531
	mov	result1, #131
	jmp	#LR__0535
LR__0532
	mov	result1, #160
	jmp	#LR__0535
LR__0533
	mov	result1, #155
	jmp	#LR__0535
LR__0534
	mov	result1, #0
LR__0535
	mov	ptra, fp
	call	#popregs_
_isfunction_ret
	ret

' 
' ' Check if the part is a name
' 
' function isname(s as string) as boolean
_isname
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0541-@LR__0540)>>2,fcache_load_ptr_
LR__0540
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0540
LR__0541
	sub	local02, arg01
	mov	result1, local02
	mov	local03, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0553
	mov	arg01, local01
	mov	arg02, #1
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
' m$=mid$(s,1,1) : if (m$<"a" orelse m$>"z")  andalso m$<>"_" then return false
	mov	arg02, ##@LR__5845
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0542
	mov	arg02, ##@LR__5846
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0543
LR__0542
	mov	arg02, ##@LR__5847
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0553
LR__0543
' if l>2 then 
	cmps	local03, #3 wc
 if_b	jmp	#LR__0552
'   for i=2 to l
	mov	local05, #2
	mov	local06, local03
	add	local06, #1
LR__0544
	cmps	local05, local06 wc
 if_ae	jmp	#LR__0551
	mov	arg01, local01
	mov	arg02, local05
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
'     m$=mid$(s,i,1) : if (i<l) andalso (m$<"a" orelse m$>"z") andalso (m$<"0" orelse m$>"9") andalso m$<>"_" andalso m$<>"." then return false 
	cmps	local05, local03 wc
 if_ae	jmp	#LR__0547
	mov	arg02, ##@LR__5848
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0545
	mov	arg02, ##@LR__5849
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0547
LR__0545
	mov	arg02, ##@LR__5850
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0546
	mov	arg02, ##@LR__5851
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0547
LR__0546
	mov	local07, ##@LR__5852
	mov	arg01, local04
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0547
	mov	local08, ##@LR__5853
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local09, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0553
LR__0547
'     if (i=l) andalso (m$<"a" orelse m$>"z") andalso (m$<"0" orelse m$>"9") andalso m$<>"_" andalso m$<>"$" andalso m$<>"%" andalso m$<>"!" then return false
	cmp	local05, local03 wz
 if_ne	jmp	#LR__0550
	mov	local10, ##@LR__5854
	mov	arg01, local04
	mov	arg02, local10
	call	#__system___string_cmp
	mov	local11, result1
	cmps	local11, #0 wc
 if_b	jmp	#LR__0548
	mov	arg02, ##@LR__5855
	mov	arg01, local04
	call	#__system___string_cmp
	mov	local10, result1
	cmps	local10, #1 wc
 if_b	jmp	#LR__0550
LR__0548
	mov	arg02, ##@LR__5856
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0549
	mov	local09, ##@LR__5857
	mov	arg01, local04
	mov	arg02, local09
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0550
LR__0549
	mov	local09, ##@LR__5858
	mov	arg01, local04
	mov	arg02, local09
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	jmp	#LR__0550
	mov	local08, ##@LR__5859
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local09, result1 wz
 if_e	jmp	#LR__0550
	mov	local12, ##@LR__5860
	mov	local08, local12
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local07, result1 wz
 if_e	jmp	#LR__0550
	mov	local13, ##@LR__5861
	mov	local12, local13
	mov	arg01, local04
	mov	arg02, local12
	call	#__system___string_cmp
	mov	local08, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0553
LR__0550
	add	local05, #1
	jmp	#LR__0544
LR__0551
LR__0552
' return true
	neg	result1, #1
LR__0553
	mov	ptra, fp
	call	#popregs_
_isname_ret
	ret

' 
' ' Check if the part is a number.  
' 
' function isnum(s as string) as boolean 
_isnum
	mov	COUNT_, #19
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	mov	local03, #0
	mov	arg01, local01
	mov	local04, arg01
	callpa	#(@LR__0561-@LR__0560)>>2,fcache_load_ptr_
LR__0560
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0560
LR__0561
	sub	local04, arg01
	mov	result1, local04
	mov	local05, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0576
	mov	arg01, local01
	mov	arg02, #1
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local06, result1
' m$=mid$(s,1,1) : if (m$<"0" orelse m$>"9") andalso m$<>"." andalso m$<>"$" andalso m$<>"%" andalso m$<>"-" then return false
	mov	arg02, ##@LR__5862
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0562
	mov	local07, ##@LR__5863
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0563
LR__0562
	mov	local08, ##@LR__5864
	mov	local07, local08
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0563
	mov	local09, ##@LR__5865
	mov	local08, local09
	mov	arg01, local06
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local07, result1 wz
 if_e	jmp	#LR__0563
	mov	local10, ##@LR__5866
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local09
	call	#__system___string_cmp
	mov	local08, result1 wz
 if_e	jmp	#LR__0563
	mov	local11, ##@LR__5867
	mov	local10, local11
	mov	arg01, local06
	mov	arg02, local10
	call	#__system___string_cmp
	mov	local09, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0576
LR__0563
' if m$="." then ds=1
	mov	arg02, ##@LR__5868
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local02, #1
' if m$="$" then hex=1 else hex=0
	mov	arg02, ##@LR__5869
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local12, #1
 if_ne	mov	local12, #0
' if m$="%" then bin=1 else bin=0
	mov	arg02, ##@LR__5870
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local13, #1
 if_ne	mov	local13, #0
' if l>1 then 
	cmps	local05, #2 wc
 if_b	jmp	#LR__0575
'   for i=2 to l
	mov	local14, #2
	mov	local15, local05
	add	local15, #1
LR__0564
	cmps	local14, local15 wc
 if_ae	jmp	#LR__0574
	mov	arg01, local01
	mov	arg02, local14
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local06, result1
	mov	local16, #0
'     m$=mid$(s,i,1) : b=false
'     if m$>="0" andalso m$<="9" then b=true  
	mov	arg02, ##@LR__5871
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0565
	mov	local07, ##@LR__5872
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	neg	local16, #1
LR__0565
'     if m$="_" orelse m$="." orelse m$="E" orelse m$="e" orelse m$="-" then b=true 
	mov	arg02, ##@LR__5873
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0566
	mov	local07, ##@LR__5874
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0566
	mov	local08, ##@LR__5875
	mov	local07, local08
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0566
	mov	local09, ##@LR__5876
	mov	local08, local09
	mov	arg01, local06
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local07, result1 wz
 if_e	jmp	#LR__0566
	mov	local10, ##@LR__5877
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local09
	call	#__system___string_cmp
	mov	local08, result1 wz
 if_ne	jmp	#LR__0567
LR__0566
	neg	local16, #1
LR__0567
'     if hex=1 andalso m$>="a" andalso m$<="f" then b=true
	cmp	local12, #1 wz
 if_ne	jmp	#LR__0568
	mov	arg02, ##@LR__5878
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0568
	mov	local07, ##@LR__5879
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	neg	local16, #1
LR__0568
'     if bin=1 andalso (m$<"0" orelse m$>"1") andalso m$<>"_" then return false
	cmp	local13, #1 wz
 if_ne	jmp	#LR__0570
	mov	arg02, ##@LR__5880
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0569
	mov	local07, ##@LR__5881
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0570
LR__0569
	mov	local08, ##@LR__5882
	mov	local07, local08
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0576
LR__0570
'     if not b then return false
	not	local16, local16
	cmp	local16, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0576
'     if m$="-" andalso lcase$(mid$(s,i-1,1))<>"e" then return false
	mov	arg02, ##@LR__5883
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0571
	mov	arg02, local14
	sub	arg02, #1
	mov	arg01, local01
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	call	#__system__LCase_S
	mov	arg01, result1
	mov	local07, ##@LR__5884
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0576
LR__0571
'     if m$="." then ds+=1: if ds>1 then return false
	mov	arg02, ##@LR__5885
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	local02, #1
 if_e	cmps	local02, #2 wc
 if_nc_and_z	mov	result1, #0
 if_nc_and_z	jmp	#LR__0576
'     if m$="E" orelse m$="e" then es+=1: if hex=0 andalso es>1 then return false
	mov	local17, ##@LR__5886
	mov	local18, local17
	mov	arg01, local06
	mov	arg02, local18
	call	#__system___string_cmp
	mov	local19, result1 wz
 if_e	jmp	#LR__0572
	mov	local07, ##@LR__5887
	mov	local17, local07
	mov	arg01, local06
	mov	arg02, local17
	call	#__system___string_cmp
	mov	local18, result1 wz
 if_ne	jmp	#LR__0573
LR__0572
	add	local03, #1
	cmp	local12, #0 wz
 if_e	cmps	local03, #2 wc
 if_nc_and_z	mov	result1, #0
 if_nc_and_z	jmp	#LR__0576
LR__0573
	add	local14, #1
	jmp	#LR__0564
LR__0574
LR__0575
' return true
	neg	result1, #1
LR__0576
	mov	ptra, fp
	call	#popregs_
_isnum_ret
	ret

'   
' ' Check if the part is an integer number.    
'   
' function isint(s as string) as boolean
_isint
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0581-@LR__0580)>>2,fcache_load_ptr_
LR__0580
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0580
LR__0581
	sub	local02, arg01
	mov	result1, local02
	mov	local03, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0594
	mov	arg01, local01
	mov	arg02, #1
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
' m$=mid$(s,1,1) : if (m$<"0" orelse m$>"9") andalso m$<>"$" andalso m$<>"%" andalso m$<>"-" then return false
	mov	arg02, ##@LR__5888
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0582
	mov	local05, ##@LR__5889
	mov	arg01, local04
	mov	arg02, local05
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0583
LR__0582
	mov	local06, ##@LR__5890
	mov	local05, local06
	mov	arg01, local04
	mov	arg02, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0583
	mov	local07, ##@LR__5891
	mov	local06, local07
	mov	arg01, local04
	mov	arg02, local06
	call	#__system___string_cmp
	mov	local05, result1 wz
 if_e	jmp	#LR__0583
	mov	local08, ##@LR__5892
	mov	local07, local08
	mov	arg01, local04
	mov	arg02, local07
	call	#__system___string_cmp
	mov	local06, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0594
LR__0583
' if m$="$" then hex=1 else hex=0
	mov	arg02, ##@LR__5893
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local09, #1
 if_ne	mov	local09, #0
' if m$="%" then bin=1 else bin=0
	mov	arg02, ##@LR__5894
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local10, #1
 if_ne	mov	local10, #0
' if l>1 then 
	cmps	local03, #2 wc
 if_b	jmp	#LR__0593
'   for i=2 to l
	mov	local11, #2
	mov	local12, local03
	add	local12, #1
LR__0584
	cmps	local11, local12 wc
 if_ae	jmp	#LR__0592
	mov	arg01, local01
	mov	arg02, local11
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
'     m$=mid$(s,i,1) 
'     if hex=0 andalso (m$<"0" orelse m$>"9") andalso m$<>"_"  then return false
	cmp	local09, #0 wz
 if_ne	jmp	#LR__0586
	mov	arg02, ##@LR__5895
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0585
	mov	arg02, ##@LR__5896
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0586
LR__0585
	mov	local06, ##@LR__5897
	mov	arg01, local04
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0594
LR__0586
'     if hex=1 andalso (m$<"0" orelse m$>"9") andalso (m$<"a" orelse m$>"f") andalso m$<>"_"  then return false
	cmp	local09, #1 wz
 if_ne	jmp	#LR__0589
	mov	arg02, ##@LR__5898
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0587
	mov	arg02, ##@LR__5899
	mov	arg01, local04
	call	#__system___string_cmp
	mov	local13, result1
	cmps	local13, #1 wc
 if_b	jmp	#LR__0589
LR__0587
	mov	local05, ##@LR__5900
	mov	arg01, local04
	mov	arg02, local05
	call	#__system___string_cmp
	mov	local14, result1
	cmps	local14, #0 wc
 if_b	jmp	#LR__0588
	mov	local07, ##@LR__5901
	mov	arg01, local04
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0589
LR__0588
	mov	local08, ##@LR__5902
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0594
LR__0589
'     if bin=1 andalso (m$<"0" orelse m$>"1") andalso m$<>"_"  then return false
	cmp	local10, #1 wz
 if_ne	jmp	#LR__0591
	mov	arg02, ##@LR__5903
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0590
	mov	arg02, ##@LR__5904
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0591
LR__0590
	mov	arg02, ##@LR__5905
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0594
LR__0591
	add	local11, #1
	jmp	#LR__0584
LR__0592
LR__0593
' return true
	neg	result1, #1
LR__0594
	mov	ptra, fp
	call	#popregs_
_isint_ret
	ret

' 
' ' Check if the part is a positive decimal number.  
' 
' function isdec(s as string) as boolean
_isdec
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0601-@LR__0600)>>2,fcache_load_ptr_
LR__0600
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0600
LR__0601
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0606
' for i=1 to l
	mov	local03, #1
	mov	local04, local02
	add	local04, #1
LR__0602
	cmps	local03, local04 wc
 if_ae	jmp	#LR__0605
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local05, result1
'     m$=mid$(s,i,1) : if (m$<"0" orelse m$>"9") andalso m$<>"_"  then return false
	mov	arg02, ##@LR__5906
	mov	arg01, local05
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0603
	mov	arg02, ##@LR__5907
	mov	arg01, local05
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0604
LR__0603
	mov	arg02, ##@LR__5908
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0606
LR__0604
	add	local03, #1
	jmp	#LR__0602
LR__0605
' return true
	neg	result1, #1
LR__0606
	mov	ptra, fp
	call	#popregs_
_isdec_ret
	ret

' 
' ' Check if the part is a string.  
' 
' function isstring(s as string) as boolean
_isstring
	mov	COUNT_, #1
	call	#pushregs_
' if left$(s,1)="""" andalso right$(s,1)="""" then return true else return false
	mov	local01, arg01
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5909
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_ne	jmp	#LR__0610
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5910
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__0611
LR__0610
	mov	result1, #0
LR__0611
	mov	ptra, fp
	call	#popregs_
_isstring_ret
	ret

' 
' ' getnoteval. Returns the frequency of note token
' 
' function getnoteval(token) as single
_getnoteval
	mov	COUNT_, #2
	call	#pushregs_
	sub	arg01, ##768
	abs	arg02, arg01 wc
	qdiv	arg02, #12
	mov	arg02, objptr
	add	arg02, ##11320
	getqy	result1
	negc	result1, result1
	shl	result1, #2
	add	result1, arg02
	abs	arg02, arg01 wc
	qdiv	arg02, #12
	rdlong	local01, result1
	mov	arg01, #1
' noteexp=1+(note/12) 
' return (2.0^noteexp)*notebase
	getqx	arg02
	sumc	arg01, arg02
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg02, result1
	decod	arg01, #30
	call	#__system____builtin_powf
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_mul
	mov	ptra, fp
	call	#popregs_
_getnoteval_ret
	ret

' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '--------------------- The end of interpreter/tokenizer functions ----------------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '
' '               		REVERSE POLISH NOTATION PRECOMPILER
' '
' ' A precompiler gets the tokenized line at the input, and outputs the precompiled line that uses the reverse Polish notation.
' ' That means the operation is done by firs placing the arguments on the stack, and then do the operation on a top of this stack.
' ' The expression a=b*(c+d) is translated to push c, push d, add, push b, mul, push variable#, assign
' ' If the precompiled line has a number that is >0, then it is added to the program and saved in the PSRAM using the 2-way list structure
' ' If the line number=0, it is not saved, and instead it is immediately executed in the "interpret" function
' ' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' ' Helper functions to manage program lines
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '----- delete a line from a program
' 
' function deleteline(aline as ulong) as integer
_deleteline
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #44
	mov	local01, arg01
	add	objptr, ##38956
	rdlong	local02, objptr
' 
' searchptr=programstart
' do
	sub	objptr, ##33120
LR__0620
	mov	arg01, fp
	add	arg01, #20
	mov	arg02, local02
	mov	arg03, #24
	call	#_psram4_spin2_read1
	mov	arg03, local02
	add	fp, #40
	rdlong	local02, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	cmp	arg02, local01 wc
 if_b	add	fp, #40
 if_b	rdlong	local03, fp
 if_b	sub	fp, #40
 if_b	cmp	local03, ##2147483647 wz
 if_c_and_nz	jmp	#LR__0620
	sub	objptr, ##5836
' if header(0)<>aline then return -1						' if not =, then there is no line, return
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, local01 wz
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__0625
	mov	arg01, arg03
	neg	arg02, #1
	call	#_pslpoke
' pslpoke(lineptr2,$FFFF_FFFF) 							' flag the deleted line
' 
' if header(5)=$7FFF_FFFF andalso header(4)=$FFFF_FFFF then  			' this is one and only line in the program
	add	fp, #40
	rdlong	arg03, fp
	sub	fp, #40
	cmp	arg03, ##2147483647 wz
 if_e	add	fp, #36
 if_e	rdlong	local04, fp
 if_e	sub	fp, #36
 if_e	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0621
	add	objptr, ##38956
	wrlong	##524288, objptr
	sub	objptr, ##3628
	wrlong	##524288, objptr
	add	objptr, ##3632
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	sub	objptr, ##38964
	mov	arg01, #0
	neg	arg02, #1
	call	#_pslpoke
	mov	arg01, #16
	neg	arg02, #1
	call	#_pslpoke
	mov	arg01, #20
	bmask	arg02, #30
	call	#_pslpoke
	add	objptr, ##42076
	wrlong	##524288, objptr
	add	objptr, #4
	wrlong	##524288, objptr
	sub	objptr, ##42080
LR__0621
' 
' if header(5)=$7FFF_FFFF andalso header(4)<>$FFFF_FFFF then 			' this is the last, and not first, line of the program
	add	fp, #40
	rdlong	local05, fp
	sub	fp, #40
	cmp	local05, ##2147483647 wz
 if_ne	jmp	#LR__0622
	add	fp, #36
	rdlong	local04, fp
	sub	fp, #36
	cmp	local04, ##-1 wz
 if_e	jmp	#LR__0622
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #20
	bmask	arg02, #30
	call	#_pslpoke
	add	fp, #36
	rdlong	local05, fp
	add	objptr, ##38964
	wrlong	local05, objptr
	sub	objptr, ##38964
	rdlong	arg01, fp
	sub	fp, #36
	call	#_pslpeek
	add	objptr, ##38960
	wrlong	result1, objptr
	sub	objptr, ##38960
'   pslpoke(header(4)+20,$7FFF_FFFF) 						' unlink the previous line
'   lastlineptr=header(4)           						' keep the last line pointer to avoid searching while sequentially adding a new line
'   lastline=pslpeek(header(4))
'   return 0
	mov	result1, #0
	jmp	#LR__0625
LR__0622
' 
' if header(5)<>$7FFF_FFFF andalso header(4)=$FFFF_FFFF then 			' this is the first line, but not the last
	add	fp, #40
	rdlong	local05, fp
	sub	fp, #40
	cmp	local05, ##2147483647 wz
 if_e	jmp	#LR__0623
	add	fp, #36
	rdlong	local04, fp
	sub	fp, #36
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0623
	add	fp, #40
	rdlong	arg01, fp
	sub	fp, #40
	add	arg01, #16
	neg	arg02, #1
	call	#_pslpoke
	add	fp, #40
	rdlong	local05, fp
	sub	fp, #40
	add	objptr, ##38956
	wrlong	local05, objptr
	sub	objptr, ##38956
' '   print "deleted first line"
'   pslpoke(header(5)+16,$FFFF_FFFF) 
'   programstart=header(5) 							' adjust the program start to point on the first new line
'   return 0
	mov	result1, #0
	jmp	#LR__0625
LR__0623
' 
' if header(5)<>$7FFF_FFFF andalso header(4)<>$FFFF_FFFF then 			' the line is not first and not last
	add	fp, #40
	rdlong	local05, fp
	sub	fp, #40
	cmp	local05, ##2147483647 wz
 if_ne	add	fp, #36
 if_ne	rdlong	local04, fp
 if_ne	sub	fp, #36
 if_ne	cmp	local04, ##-1 wz
 if_e	jmp	#LR__0624
	add	fp, #40
	rdlong	arg01, fp
	add	arg01, #16
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #36
	call	#_pslpoke
	add	fp, #36
	rdlong	arg01, fp
	add	arg01, #20
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #40
	call	#_pslpoke
'    pslpoke(header(5)+16,header(4))  
'    pslpoke(header(4)+20, header(5))
'    return 0
	mov	result1, #0
	jmp	#LR__0625
LR__0624
	mov	result1, #0
LR__0625
	mov	ptra, fp
	call	#popregs_
_deleteline_ret
	ret

' 
' '----- Save a line to the PSRAM. Called from insertline and add_line_at_end
' 
' sub save_line
_save_line
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, ##38944
	rdlong	arg03, objptr
	add	arg03, #1
	sub	objptr, ##2584
	rdlong	arg02, objptr
	qmul	arg02, arg03
	sub	objptr, ##7236
	rdlong	arg01, objptr
	sub	objptr, ##29124
	mov	local01, arg01
	getqx	local02
	callpa	#(@LR__0631-@LR__0630)>>2,fcache_load_ptr_
LR__0630
	rdbyte	result1, local01 wz
 if_ne	add	local01, #1
 if_ne	jmp	#LR__0630
LR__0631
	sub	local01, arg01
	test	local01, #3 wz
 if_ne	shr	local01, #2
 if_ne	add	local01, #1
 if_ne	shl	local01, #2
	mov	local03, local02
	add	local03, local01
	add	objptr, ##35328
	rdlong	arg03, objptr
	add	arg03, local02
	add	objptr, ##2088
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	local01, objptr
	sub	objptr, #12
	mov	arg01, objptr
	sub	objptr, ##2080
	rdlong	arg02, objptr
	mov	arg03, local02
	sub	objptr, ##29492
	call	#_psram4_spin2_write
	add	objptr, ##23288
	rdlong	arg01, objptr
	add	objptr, ##6204
	rdlong	arg02, objptr
	add	arg02, local02
	mov	arg03, local01
	sub	objptr, ##29492
	call	#_psram4_spin2_write
	add	objptr, ##29492
	rdlong	local01, objptr
	add	local01, local03
	wrlong	local01, objptr
	sub	objptr, ##35328
	mov	ptra, fp
	call	#popregs_
_save_line_ret
	ret

' 
' '----- Insert a new line into the middle of the program
' 
' function insertline(aline as ulong) as integer
_insertline
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #40
	mov	local01, arg01
	add	objptr, ##38956
	rdlong	local02, objptr
' 
' do
	sub	objptr, ##33120
LR__0640
	mov	arg01, fp
	add	arg01, #16
	mov	arg02, local02
	mov	arg03, #24
	call	#_psram4_spin2_read1
	mov	local03, local02
	add	fp, #36
	rdlong	local02, fp
	sub	fp, #20
	rdlong	arg03, fp
	sub	fp, #16
	cmp	arg03, local01 wc
 if_b	add	fp, #36
 if_b	rdlong	local04, fp
 if_b	sub	fp, #36
 if_b	cmp	local04, ##2147483647 wz
 if_c_and_nz	jmp	#LR__0640
	sub	objptr, ##5836
' 
' if header(0)=aline then return -1 				' delete it first
	add	fp, #16
	rdlong	local04, fp
	sub	fp, #16
	cmp	local04, local01 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__0643
' if header(0)<aline then return -2 				' end of program reached
	add	fp, #16
	rdlong	local04, fp
	sub	fp, #16
	cmp	local04, local01 wc
 if_b	neg	result1, #2
 if_b	jmp	#LR__0643
' 
' if  header(4)=$FFFF_FFFF then 					' this is the first line in the program so the inserted line will be new first
	add	fp, #32
	rdlong	local04, fp
	sub	fp, #32
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0641
	add	objptr, ##35328
	rdlong	local04, objptr
	add	objptr, ##3628
	wrlong	local04, objptr
	mov	arg01, local03
	add	arg01, #16
	sub	objptr, ##3628
	rdlong	arg02, objptr
	sub	objptr, ##35328
	call	#_pslpoke
	add	objptr, ##37424
	wrlong	##-1, objptr
	add	objptr, #4
	wrlong	local03, objptr
	sub	objptr, ##37428
	call	#_save_line
'   programstart=programptr
'   pslpoke(lineptr2+16,programptr)
'   ucompiledline(4)=$FFFF_FFFF
'   ucompiledline(5)=lineptr2
'   save_line
'   return 0
	mov	result1, #0
	jmp	#LR__0643
LR__0641
' 
' if header(4)<>$FFFF_FFFF then 					' this is not first line of the program. It doesn't matter if it is last as we will insert a new line before
	add	fp, #32
	rdlong	local04, fp
	sub	fp, #32
	cmp	local04, ##-1 wz
 if_e	jmp	#LR__0642
	add	fp, #32
	rdlong	local04, fp
	sub	fp, #32
	add	objptr, ##37424
	wrlong	local04, objptr
	add	objptr, #4
	wrlong	local03, objptr
	add	local03, #16
	sub	objptr, ##2100
	rdlong	arg02, objptr
	sub	objptr, ##35328
	mov	arg01, local03
	call	#_pslpoke
	add	fp, #32
	rdlong	arg01, fp
	sub	fp, #32
	add	arg01, #20
	add	objptr, ##35328
	rdlong	arg02, objptr
	sub	objptr, ##35328
	call	#_pslpoke
	call	#_save_line
'   ucompiledline(4)=header(4)
'   ucompiledline(5)=lineptr2
'   pslpoke(lineptr2+16,programptr)
'   pslpoke(header(4)+20,programptr)
'   save_line
'   return 0
	mov	result1, #0
	jmp	#LR__0643
LR__0642
	mov	result1, #0
LR__0643
	mov	ptra, fp
	call	#popregs_
_insertline_ret
	ret

' 
' '----- Adds a new line at the end of the program
' 
' sub add_line_at_end(aline) 
_add_line_at_end
	add	objptr, ##38960
	wrlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##1540
	wrlong	arg02, objptr
	add	objptr, ##1540
	rdlong	arg01, objptr
	add	arg01, #20
	sub	objptr, ##3636
	rdlong	arg02, objptr
	sub	objptr, ##35328
	call	#_pslpoke
	add	objptr, ##35328
	rdlong	arg02, objptr
	add	objptr, ##3636
	wrlong	arg02, objptr
	sub	objptr, ##1536
	wrlong	##2147483647, objptr
' 
' lastline=aline: ucompiledline(4)=lastlineptr : pslpoke(lastlineptr+20,programptr) : lastlineptr=programptr : ucompiledline(5)=$7FFF_FFFF 
' if programptr=memlo then ucompiledline(4)=$FFFFFFFF ' that is the first line
	sub	objptr, ##2100
	rdlong	arg02, objptr
	sub	objptr, ##35328
	cmp	arg02, ##524288 wz
 if_e	add	objptr, ##37424
 if_e	wrlong	##-1, objptr
 if_e	sub	objptr, ##37424
	call	#_save_line
	add	objptr, ##35328
	rdlong	arg01, objptr
	sub	objptr, ##35328
	neg	arg02, #1
	call	#_pslpoke
_add_line_at_end_ret
	ret

' 
' '--------------------------------------------------------------------------------------------------------------------------
' '---------------------------------- End of line managing helper functions -------------------------------------------------
' '--------------------------------------------------------------------------------------------------------------------------
' 
' '--------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Compilers ------------------------------------------------------------------------
' '--------------------------------------------------------------------------------------------------------------------------
' 
' '--- Do a main compilation task for commands, called from compile(), returns an error code
' 
' function compile_immediate(linetype as ulong, aline as ulong) as integer
_compile_immediate
	mov	COUNT_, #10
	call	#pushregs_
_compile_immediate_enter
	mov	local04, arg01
	mov	local05, arg02
	mov	local06, #0
	mov	local07, #0
	mov	local08, #0
' 
' ' linetype=cont+1
' ' 1 : this is the first part of the line that will continue
' ' 2 - this is the continuation of the line
' ' 3 - this is the last continued line
' ' 4 - this is the one and only part
' ' 5 - continued after if/else
' 
' err=0
' cmd=0
' vars=0
' if linetype=2 orelse linetype=3 then cmd=lparts(0).token : ct=1 
	cmp	local04, #2 wz
 if_ne	cmp	local04, #3 wz
 if_e	add	objptr, ##28084
 if_e	rdlong	local07, objptr
 if_e	add	objptr, ##1076
 if_e	wrlong	#1, objptr
 if_e	sub	objptr, ##29160
' if linetype=4 orelse linetype=1 then cmd=lparts(1).token : ct=2 : lineptr=2
	cmp	local04, #4 wz
 if_ne	cmp	local04, #1 wz
 if_ne	jmp	#LR__0650
	add	objptr, ##28092
	rdlong	local07, objptr
	add	objptr, ##1068
	wrlong	#2, objptr
	add	objptr, ##9784
	wrlong	#2, objptr
	sub	objptr, ##38944
LR__0650
' if linetype=5 then cmd=lparts(ct).token : ct+=1 
	cmp	local04, #5 wz
 if_ne	jmp	#LR__0651
	add	objptr, ##29160
	rdlong	result2, objptr
	mov	local09, result2
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	add	local09, #4
	rdlong	local07, local09
	add	result2, #1
	add	objptr, ##1080
	wrlong	result2, objptr
	sub	objptr, ##29160
LR__0651
' 
' 'print  "In compile_immediate cmd=:", cmd
' 451 select case cmd
	cmp	local07, #92 wz
 if_e	jmp	#LR__0652
	cmp	local07, #185 wz
 if_e	jmp	#LR__0653
	cmp	local07, #71 wz
 if_e	jmp	#LR__0654
	cmp	local07, #89 wz
 if_e	jmp	#LR__0655
	cmp	local07, #195 wz
 if_e	jmp	#LR__0656
	cmp	local07, #69 wz
 if_e	jmp	#LR__0657
	cmp	local07, #105 wz
 if_e	jmp	#LR__0658
	cmp	local07, #64 wz
 if_e	jmp	#LR__0735
	cmp	local07, #180 wz
 if_e	jmp	#LR__0659
	cmp	local07, #73 wz
 if_e	jmp	#LR__0660
	cmp	local07, #196 wz
 if_e	jmp	#LR__0661
	cmp	local07, #174 wz
 if_e	jmp	#LR__0662
	cmp	local07, #176 wz
 if_e	jmp	#LR__0663
	cmp	local07, #175 wz
 if_e	jmp	#LR__0664
	cmp	local07, #177 wz
 if_e	jmp	#LR__0665
	cmp	local07, #207 wz
 if_e	jmp	#LR__0666
	cmp	local07, #104 wz
 if_e	jmp	#LR__0667
	cmp	local07, #183 wz
 if_e	jmp	#LR__0735
	cmp	local07, #217 wz
 if_e	jmp	#LR__0668
	cmp	local07, #116 wz
 if_e	jmp	#LR__0669
	cmp	local07, #115 wz
 if_e	jmp	#LR__0670
	cmp	local07, #108 wz
 if_e	jmp	#LR__0671
	cmp	local07, #137 wz
 if_e	jmp	#LR__0735
	cmp	local07, #194 wz
 if_e	jmp	#LR__0672
	cmp	local07, #114 wz
 if_e	jmp	#LR__0673
	cmp	local07, #93 wz
 if_e	jmp	#LR__0674
	cmp	local07, #150 wz
 if_e	jmp	#LR__0675
	cmp	local07, #67 wz
 if_e	jmp	#LR__0676
	cmp	local07, #90 wz
 if_e	jmp	#LR__0677
	cmp	local07, #171 wz
 if_e	jmp	#LR__0735
	cmp	local07, #189 wz
 if_e	jmp	#LR__0678
	cmp	local07, #187 wz
 if_e	jmp	#LR__0679
	cmp	local07, #78 wz
 if_e	jmp	#LR__0680
	cmp	local07, #169 wz
 if_e	jmp	#LR__0682
	cmp	local07, #70 wz
 if_e	jmp	#LR__0684
	cmp	local07, #113 wz
 if_e	jmp	#LR__0685
	cmp	local07, #96 wz
 if_e	jmp	#LR__0686
	cmp	local07, #74 wz
 if_e	jmp	#LR__0687
	cmp	local07, #72 wz
 if_e	jmp	#LR__0688
	cmp	local07, #88 wz
 if_e	jmp	#LR__0689
	cmp	local07, #95 wz
 if_e	jmp	#LR__0690
	cmp	local07, #181 wz
 if_e	jmp	#LR__0691
	cmp	local07, #138 wz
 if_e	jmp	#LR__0692
	cmp	local07, #76 wz
 if_e	jmp	#LR__0693
	cmp	local07, #82 wz
 if_e	jmp	#LR__0694
	cmp	local07, #151 wz
 if_e	jmp	#LR__0695
	cmp	local07, #198 wz
 if_e	jmp	#LR__0696
	cmp	local07, #97 wz
 if_e	jmp	#LR__0697
	cmp	local07, #99 wz
 if_e	jmp	#LR__0698
	cmp	local07, #65 wz
 if_e	jmp	#LR__0735
	cmp	local07, #75 wz
 if_e	jmp	#LR__0699
	cmp	local07, #193 wz
 if_e	jmp	#LR__0700
	cmp	local07, #179 wz
 if_e	jmp	#LR__0701
	cmp	local07, #94 wz
 if_e	jmp	#LR__0702
	cmp	local07, #124 wz
 if_e	jmp	#LR__0703
	cmp	local07, #125 wz
 if_e	jmp	#LR__0704
	cmp	local07, #126 wz
 if_e	jmp	#LR__0705
	cmp	local07, #127 wz
 if_e	jmp	#LR__0706
	cmp	local07, #128 wz
 if_e	jmp	#LR__0707
	cmp	local07, #85 wz
 if_e	jmp	#LR__0708
	cmp	local07, #117 wz
 if_e	jmp	#LR__0709
	cmp	local07, #66 wz
 if_e	jmp	#LR__0710
	cmp	local07, #149 wz
 if_e	jmp	#LR__0711
	cmp	local07, #172 wz
 if_e	jmp	#LR__0735
	cmp	local07, #129 wz
 if_e	jmp	#LR__0712
	cmp	local07, #68 wz
 if_e	jmp	#LR__0713
	cmp	local07, #188 wz
 if_e	jmp	#LR__0714
	cmp	local07, #136 wz
 if_e	jmp	#LR__0735
	cmp	local07, #182 wz
 if_e	jmp	#LR__0715
	cmp	local07, #146 wz
 if_e	jmp	#LR__0716
	cmp	local07, #190 wz
 if_e	jmp	#LR__0736
	cmp	local07, #199 wz
 if_ne	cmp	local07, #212 wz
 if_ne	cmp	local07, #170 wz
 if_e	jmp	#LR__0735
	cmp	local07, #77 wz
 if_e	jmp	#LR__0717
	cmp	local07, #81 wz
 if_e	jmp	#LR__0718
	cmp	local07, #218 wz
 if_e	jmp	#LR__0719
	cmp	local07, #210 wz
 if_e	jmp	#LR__0720
	cmp	local07, #142 wz
 if_e	jmp	#LR__0721
	cmp	local07, #144 wz
 if_e	jmp	#LR__0722
	cmp	local07, #141 wz
 if_e	jmp	#LR__0723
	cmp	local07, #140 wz
 if_e	jmp	#LR__0724
	cmp	local07, #145 wz
 if_e	jmp	#LR__0725
	cmp	local07, #139 wz
 if_e	jmp	#LR__0726
	cmp	local07, #143 wz
 if_e	jmp	#LR__0727
	cmp	local07, #178 wz
 if_e	jmp	#LR__0728
	cmp	local07, #109 wz
 if_e	jmp	#LR__0729
	cmp	local07, #112 wz
 if_e	jmp	#LR__0735
	cmp	local07, #86 wz
 if_e	jmp	#LR__0730
	cmp	local07, #87 wz
 if_e	jmp	#LR__0735
	cmp	local07, #121 wz
 if_e	jmp	#LR__0731
	cmp	local07, #119 wz
 if_e	jmp	#LR__0732
	cmp	local07, #120 wz
 if_e	jmp	#LR__0733
	cmp	local07, ##516 wz
 if_e	jmp	#LR__0734
	jmp	#LR__0736
LR__0652
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0653
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0654
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0655
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0656
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0657
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0658
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0659
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0660
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0661
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0662
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0663
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0664
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0665
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0666
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0667
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0668
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0669
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0670
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0671
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0672
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0673
	call	#_compile_dim
	mov	local06, result1
	jmp	#LR__0736
LR__0674
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0675
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0676
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0677
	mov	arg01, local05
	call	#_compile_else
	mov	local06, result1
	jmp	#LR__0736
LR__0678
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0679
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0680
	cmp	local05, #1 wc
 if_b	jmp	#LR__0681
	call	#_compile_goto
	jmp	#LR__0736
LR__0681
	mov	arg01, #25
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__0736
LR__0682
	cmp	local05, #1 wc
 if_b	jmp	#LR__0683
	call	#_compile_gosub
	jmp	#LR__0736
LR__0683
	mov	arg01, #25
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__0736
LR__0684
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0685
	call	#_compile_fun_4p
	mov	local06, result1
	jmp	#LR__0735
LR__0686
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0687
	call	#_compile_for
	mov	local06, result1
	jmp	#LR__0736
LR__0688
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0689
	mov	arg01, local05
	call	#_compile_if
	mov	local06, result1
	jmp	#LR__0736
LR__0690
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0691
	call	#_compile_input
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0692
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0693
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0694
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0695
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0696
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0697
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0698
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0699
	call	#_compile_next
	mov	local06, result1
	jmp	#LR__0736
LR__0700
	call	#_compile_on
	mov	local06, result1
	jmp	#LR__0736
LR__0701
	call	#_compile_fun_3p
	mov	local06, result1
	jmp	#LR__0735
LR__0702
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0703
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0704
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0705
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0706
	call	#_compile_fun_4p
	mov	local06, result1
	jmp	#LR__0735
LR__0707
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0708
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0709
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0710
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0711
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0712
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0713
	call	#_compile_print
	mov	local06, result1
	jmp	#LR__0736
LR__0714
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0715
	call	#_compile_read
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0716
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0717
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0718
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0719
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0720
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0721
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0722
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0723
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0724
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0725
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0726
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0727
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0728
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0735
LR__0729
	call	#_compile_fun_3p
	mov	local06, result1
	jmp	#LR__0735
LR__0730
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0735
LR__0731
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0732
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0733
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0735
LR__0734
	call	#_compile_array_assign
	mov	local06, result1
	cmp	local06, #14 wz
 if_ne	jmp	#LR__0736
' return 23
	mov	local06, #23
	jmp	#LR__0736
' return 23
LR__0735
	mov	local03, local07
	mov	local01, local08
	mov	local09, local01
	mov	local10, local02
	mov	local07, local03
	add	objptr, ##38944
	rdlong	local01, objptr
	mov	local08, local01
	shl	local08, #1
	add	local08, local01
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	wrlong	local09, local08
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local10, local09
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local10, local01
	shl	local10, #1
	add	local10, local01
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #8
	wrlong	local07, local10
	add	objptr, ##1536
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##38944
LR__0736
' 
' t3.result_type=cmd : t3.result.uresult=vars : compiledline(lineptr)=t3:  lineptr+=1
' 450 if linetype=3 orelse linetype=4 then compiledline(lineptr).result_type=token_end 				' the last part 
	cmp	local04, #3 wz
 if_ne	cmp	local04, #4 wz
 if_ne	jmp	#LR__0737
	add	objptr, ##38944
	rdlong	local10, objptr
	mov	local01, local10
	shl	local01, #1
	add	local01, local10
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	#510, local01
	sub	objptr, ##37408
LR__0737
' ' if there is token_adr somewhere, change fun_getvar to fun_getaddr
' for i=lineptr to 1 step -1: if compiledline(i).result_type=token_adr andalso compiledline(i-1).result_type=fun_getvar then compiledline(i-1).result_type=fun_getaddr
	add	objptr, ##38944
	rdlong	local01, objptr
	sub	objptr, ##38944
	callpa	#(@LR__0740-@LR__0738)>>2,fcache_load_ptr_
LR__0738
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	mov	local10, objptr
	add	local10, ##37408
	add	local09, local10
	add	local09, #8
	rdlong	local09, local09
	cmp	local09, #155 wz
 if_ne	jmp	#LR__0739
	mov	local09, local01
	sub	local09, #1
	mov	local10, local09
	shl	local10, #1
	add	local10, local09
	shl	local10, #2
	mov	local09, objptr
	add	local09, ##37408
	add	local10, local09
	add	local10, #8
	rdlong	local10, local10
	cmp	local10, #17 wz
 if_ne	jmp	#LR__0739
	mov	local09, local01
	sub	local09, #1
	mov	local10, local09
	shl	local10, #1
	add	local10, local09
	shl	local10, #2
	mov	local09, objptr
	add	local09, ##37408
	add	local10, local09
	add	local10, #8
	wrlong	#18, local10
LR__0739
	sub	local01, #1
	cmps	local01, #1 wc
 if_ae	jmp	#LR__0738
LR__0740
' ''''print "In compile_immediate:" : for i=0 to lineptr: print compiledline(i).result_type;" ";compiledline(i).result.uresult, compiledline(i).result.twowords(1) : next i
' return err
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
_compile_immediate_ret
	ret

' 
' '--- Do a main compilation task for assigns, called from compile_assign(), returns an error code
' 
' function compile_immediate_assign(linetype as ulong) as ulong
_compile_immediate_assign
	mov	COUNT_, #12
	call	#pushregs_
	mov	local04, arg01
	mov	local03, #255
	neg	local05, #1
	mov	local06, #0
' 
' t1.result_type=result_error : t1.result.uresult=0
' i=-1: j=-1 : err=0
' 
' if linetype=2 orelse linetype=3 then varname2$=lparts(0).part$ : ct=2 ' don't set lineptr
	cmp	local04, #2 wz
 if_ne	cmp	local04, #3 wz
 if_e	add	objptr, ##28080
 if_e	rdlong	local07, objptr
 if_e	add	objptr, ##1080
 if_e	wrlong	#2, objptr
 if_e	sub	objptr, ##29160
' if linetype=4 orelse linetype=1 then varname2$=lparts(1).part$ : ct=3 : lineptr=2
	cmp	local04, #4 wz
 if_ne	cmp	local04, #1 wz
 if_ne	jmp	#LR__0750
	add	objptr, ##28088
	rdlong	local07, objptr
	add	objptr, ##1072
	wrlong	#3, objptr
	add	objptr, ##9784
	wrlong	#2, objptr
	sub	objptr, ##38944
LR__0750
' if linetype=5 then varname2$=lparts(ct).part$ : ct+=2 ' continued after if/else
	cmp	local04, #5 wz
 if_ne	jmp	#LR__0751
	add	objptr, ##29160
	rdlong	result1, objptr
	mov	local07, result1
	shl	local07, #3
	sub	objptr, ##1080
	add	local07, objptr
	rdlong	local07, local07
	add	result1, #2
	add	objptr, ##1080
	wrlong	result1, objptr
	sub	objptr, ##29160
LR__0751
	mov	arg01, local07
	mov	arg02, #1
	call	#__system__Right_S
	mov	local08, result1
	call	#_expr
' 
' suffix2$=right$(varname2$,1)
' expr()
' if varnum>0 then					' try to find a variable
	add	objptr, ##28076
	rdlong	local09, objptr
	sub	objptr, ##28076
	cmps	local09, #1 wc
 if_b	jmp	#LR__0754
'   for i=0 to varnum-1
	mov	local10, #0
	add	objptr, ##28076
	rdlong	local11, objptr
	sub	objptr, ##28076
LR__0752
	cmps	local10, local11 wc
 if_ae	jmp	#LR__0753
'     if variables(i).name=varname2$ then j=i : exit
	mov	local09, local10
	shl	local09, #4
	mov	arg02, objptr
	add	arg02, ##11676
	add	local09, arg02
	rdlong	arg01, local09
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local05, local10
 if_ne	add	local10, #1
 if_ne	jmp	#LR__0752
LR__0753
LR__0754
' if  j=-1 andalso varnum<maxvars then   			' not found, add a new one
	cmp	local05, ##-1 wz
 if_ne	jmp	#LR__0755
	add	objptr, ##28076
	rdlong	local09, objptr
	sub	objptr, ##28076
	cmps	local09, ##1024 wc
 if_ae	jmp	#LR__0755
	add	objptr, ##28076
	rdlong	local11, objptr
	shl	local11, #4
	sub	objptr, ##16400
	add	local11, objptr
	wrlong	local07, local11
	add	objptr, ##16400
	rdlong	local09, objptr
	mov	local05, local09
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##28076
LR__0755
' if varnum>=maxvars then
	add	objptr, ##28076
	rdlong	local09, objptr
	sub	objptr, ##28076
	cmps	local09, ##1024 wc
 if_ae	mov	local06, #45
 if_ae	jmp	#LR__0760
	mov	local01, local05
	mov	local03, #23
	mov	local09, local01
	mov	local12, local02
	mov	local01, local03
	add	objptr, ##38944
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	wrlong	local09, local10
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local11, local09
	shl	local11, #1
	add	local11, local09
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #4
	wrlong	local12, local11
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local12, local09
	shl	local12, #1
	add	local12, local09
	shl	local12, #2
	sub	objptr, ##1536
	add	local12, objptr
	add	local12, #8
	wrlong	local01, local12
	add	objptr, ##1536
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##38944
'   t1.result.uresult=j: t1.result_type=fun_assign  
'   compiledline(lineptr)=t1:  lineptr+=1 
'   if linetype=3 orelse linetype=4 then compiledline(lineptr).result_type=token_end
	cmp	local04, #3 wz
 if_ne	cmp	local04, #4 wz
 if_ne	jmp	#LR__0756
	add	objptr, ##38944
	rdlong	local12, objptr
	mov	local01, local12
	shl	local01, #1
	add	local01, local12
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	#510, local01
	sub	objptr, ##37408
LR__0756
'   for i=lineptr to 1 step -1: if compiledline(i).result_type=token_adr andalso compiledline(i-1).result_type=fun_getvar then compiledline(i-1).result_type=fun_getaddr
	add	objptr, ##38944
	rdlong	local10, objptr
	sub	objptr, ##38944
	callpa	#(@LR__0759-@LR__0757)>>2,fcache_load_ptr_
LR__0757
	mov	local12, local10
	shl	local12, #1
	add	local12, local10
	shl	local12, #2
	mov	local01, objptr
	add	local01, ##37408
	add	local12, local01
	add	local12, #8
	rdlong	local12, local12
	cmp	local12, #155 wz
 if_ne	jmp	#LR__0758
	mov	local12, local10
	sub	local12, #1
	mov	local01, local12
	shl	local01, #1
	add	local01, local12
	shl	local01, #2
	mov	local12, objptr
	add	local12, ##37408
	add	local01, local12
	add	local01, #8
	rdlong	local01, local01
	cmp	local01, #17 wz
 if_ne	jmp	#LR__0758
	mov	local12, local10
	sub	local12, #1
	mov	local01, local12
	shl	local01, #1
	add	local01, local12
	shl	local01, #2
	mov	local12, objptr
	add	local12, ##37408
	add	local01, local12
	add	local01, #8
	wrlong	#18, local01
LR__0758
	sub	local10, #1
	cmps	local10, #1 wc
 if_ae	jmp	#LR__0757
LR__0759
LR__0760
' return err
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
_compile_immediate_assign_ret
	ret

' 
' ' ------------------ compile the line that is calling a command, and save it if linenum>0, called from the interpreter 
' 
' function compile (alinemajor as ulong, alineminor=0 as ulong, cont=0 as ulong) as ulong
_compile
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	add	objptr, ##37408
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, ##37412
	mov	arg01, local02
	add	arg01, #1
	mov	arg02, local01
	call	#_compile_immediate
	mov	local03, result1 wz
' 'line header: num major, num minor,list start, list length, prev, next. That implements 2-way list of program lines 
' ucompiledline(0)=alinemajor
' ucompiledline(1)=alineminor		' this is for the future when maybe linenums will be optional.
' 
' ' cont: 
' ' 0 - this is the first part of the line that will continue
' ' 1 - this is the continuation of the line
' ' 2 - this is the last continued line
' ' 3 - this is the one and only part
' 
' err=compile_immediate(cont+1,alinemajor) 
' if err=0 andalso alinemajor>0 then
 if_ne	jmp	#LR__0775
	cmp	local01, #1 wc
 if_b	jmp	#LR__0775
'   if cont=3 orelse cont=2 then 
	cmp	local02, #3 wz
 if_ne	cmp	local02, #2 wz
 if_ne	jmp	#LR__0774
'     if alinemajor >lastline then 
	add	objptr, ##38960
	rdlong	arg02, objptr
	sub	objptr, ##38960
	cmp	local01, arg02 wcz
 if_be	jmp	#LR__0770
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0773
LR__0770
	mov	arg01, local01
	call	#_deleteline
'       deleteline(alinemajor)  
'       if alinemajor>lastline then add_line_at_end(alinemajor)  else insertline(alinemajor)   ' TODO: that's not optimal    
	add	objptr, ##38960
	rdlong	arg02, objptr
	sub	objptr, ##38960
	cmp	local01, arg02 wcz
 if_be	jmp	#LR__0771
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0772
LR__0771
	mov	arg01, local01
	call	#_insertline
LR__0772
LR__0773
LR__0774
LR__0775
' return err
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_compile_ret
	ret

' 
' ' ------------------ compile the line that is assigning to a variable and save it if linenum>0, called from the interpreter 
' 
' function compile_assign (alinemajor as ulong, alineminor=0 as ulong, cont=0 as ulong)  as ulong
_compile_assign
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	add	objptr, ##37408
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, ##37412
	mov	arg01, local02
	add	arg01, #1
	call	#_compile_immediate_assign
	mov	local03, result1
' 
' ucompiledline(0)=alinemajor
' ucompiledline(1)=alineminor
' 
' err=compile_immediate_assign(cont+1) 
' if alinemajor>0 then
	cmp	local01, #1 wc
 if_b	jmp	#LR__0785
'   if cont=3 orelse cont=2 then 
	cmp	local02, #3 wz
 if_ne	cmp	local02, #2 wz
 if_ne	jmp	#LR__0784
'     if alinemajor >lastline then 
	add	objptr, ##38960
	rdlong	arg02, objptr
	sub	objptr, ##38960
	cmp	local01, arg02 wcz
 if_be	jmp	#LR__0780
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0783
LR__0780
	mov	arg01, local01
	call	#_deleteline
'       deleteline(alinemajor)  
'       if alinemajor>lastline then add_line_at_end(alinemajor) else insertline(alinemajor)   
	add	objptr, ##38960
	rdlong	arg02, objptr
	sub	objptr, ##38960
	cmp	local01, arg02 wcz
 if_be	jmp	#LR__0781
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0782
LR__0781
	mov	arg01, local01
	call	#_insertline
LR__0782
LR__0783
LR__0784
LR__0785
' return err
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_compile_assign_ret
	ret

' 
' '----- A function that prepares 2 parameters for a 2-parameter command
' 
' function compile_fun_2p() as ulong
_compile_fun_2p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0790
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##29160
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##28080
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0790
	add	objptr, ##29160
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##29160
	call	#_expr
' err=expr() : if err>0 then return err
	cmp	result1, #1 wc
' return 0
 if_b	mov	result1, #0
LR__0790
	mov	ptra, fp
	call	#popregs_
_compile_fun_2p_ret
	ret

' 
' '----- A function that prepares 3 parameters for a 3-parameter command
' 
' function compile_fun_3p() as ulong
_compile_fun_3p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0800
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##29160
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##28080
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0800
	add	objptr, ##29160
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##29160
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0800
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##29160
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##28080
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0800
	add	objptr, ##29160
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##29160
	call	#_expr
' err=expr() : if err>0 then return err
	cmp	result1, #1 wc
' return 0
 if_b	mov	result1, #0
LR__0800
	mov	ptra, fp
	call	#popregs_
_compile_fun_3p_ret
	ret

' 
' '----- A function that prepares 4 parameters for a 4-parameter command
' 
' function compile_fun_4p() as ulong
_compile_fun_4p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0810
' if lparts(ct).token<> token_comma then return 21 else ct+=1 
	add	objptr, ##29160
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##28080
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0810
	add	objptr, ##29160
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##29160
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0810
' if lparts(ct).token<> token_comma then return 21 else ct+=1 
	add	objptr, ##29160
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##28080
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0810
	add	objptr, ##29160
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##29160
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0810
' if lparts(ct).token<> token_comma then return 21 else ct+=1  
	add	objptr, ##29160
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##28080
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0810
	add	objptr, ##29160
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##29160
	call	#_expr
' err=expr() : if err>0 then return err
	cmp	result1, #1 wc
' return 0
 if_b	mov	result1, #0
LR__0810
	mov	ptra, fp
	call	#popregs_
_compile_fun_4p_ret
	ret

' 
' '----  Compile a command that can have variable number of parameters. Return num of params and error code
' 
' function compile_fun_varp() as ulong,ulong 
_compile_fun_varp
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, #0
' 
' i=0 : err=0
' if lparts(ct).token<>token_end then
	add	objptr, ##29160
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #510 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0821
'   do
LR__0820
	call	#_expr
	add	local01, #1
'     expr()
'     i+=1
'     if lparts(ct).token=token_comma then ct+=1
	add	objptr, ##29160
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #17 wz
	sub	objptr, ##28080
 if_e	add	objptr, ##29160
 if_e	rdlong	local03, objptr
 if_e	add	local03, #1
 if_e	wrlong	local03, objptr
 if_e	sub	objptr, ##29160
'     if lparts(ct).token=token_end then exit loop
	add	objptr, ##29160
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #510 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0820
LR__0821
' return i,err
	mov	result1, local01
	mov	result2, #0
	mov	ptra, fp
	call	#popregs_
_compile_fun_varp_ret
	ret

' 
' '----  Compile read. The same as compile_input() except printing a prompt
' 
' function compile_read() as ulong,ulong 
_compile_read
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, #0
' 
' i=0 : err=0
' if lparts(ct).token<>token_end then
	add	objptr, ##29160
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #510 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0831
'   do
LR__0830
	call	#_getaddr
	mov	local03, result1
	add	objptr, ##29160
	rdlong	local02, objptr
	add	local02, #1
	wrlong	local02, objptr
	add	local01, #1
'     err=getaddr() :ct+=1
'     i+=1 
'     if lparts(ct).token=token_comma then ct+=1 
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #17 wz
	sub	objptr, ##28080
 if_e	add	objptr, ##29160
 if_e	rdlong	local04, objptr
 if_e	add	local04, #1
 if_e	wrlong	local04, objptr
 if_e	sub	objptr, ##29160
'     if lparts(ct).token=token_end then exit loop
	add	objptr, ##29160
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #510 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0832
	jmp	#LR__0830
LR__0831
	mov	local03, #54
LR__0832
' return i,err
	mov	result1, local01
	mov	result2, local03
	mov	ptra, fp
	call	#popregs_
_compile_read_ret
	ret

' 
' '----  Compile input. The same as compile_varp() except these has to be variables, and not expressions, and also we need getaddr and not getvar
' 
' function compile_input() as ulong,ulong 
_compile_input
	mov	COUNT_, #15
	call	#pushregs_
' 
' if lparts(ct).token=token_string then
	add	objptr, ##29160
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	result2, arg03
	cmp	result2, ##515 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0847
	add	objptr, ##29160
	rdlong	arg02, objptr
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	sub	objptr, ##28080
	mov	local04, arg01
	callpa	#(@LR__0841-@LR__0840)>>2,fcache_load_ptr_
LR__0840
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0840
LR__0841
	sub	local04, arg01
	mov	result1, local04
	add	objptr, ##43212
	wrlong	result1, objptr
	sub	objptr, #88
	rdlong	arg01, objptr
	sub	arg01, result1
	sub	arg01, #4
	andn	arg01, #3
	wrlong	arg01, objptr
	add	objptr, #88
	rdlong	arg02, objptr
	sub	objptr, ##43212
	call	#_pslpoke
'   pslpoke memtop,l
'   for i=1 to l : pspoke memtop+3+i, asc(mid$(lparts(ct).part$,i,1)) : next i
	mov	local05, #1
	add	objptr, ##43212
	rdlong	local06, objptr
	sub	objptr, ##43212
	add	local06, #1
LR__0842
	cmps	local05, local06 wc
 if_ae	jmp	#LR__0843
	add	objptr, ##43124
	rdlong	local07, objptr
	add	local07, #3
	add	local07, local05
	sub	objptr, ##13964
	rdlong	arg02, objptr
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, local05
	mov	arg03, #1
	sub	objptr, ##28080
	call	#__system__Mid_S
	rdbyte	arg02, result1
	mov	arg01, local07
	call	#_pspoke
	add	local05, #1
	jmp	#LR__0842
LR__0843
	add	objptr, ##43124
	rdlong	local01, objptr
	mov	local03, #43
	mov	local08, local01
	mov	local07, local02
	mov	local09, local03
	sub	objptr, ##4180
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	wrlong	local08, local05
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local06, local08
	shl	local06, #1
	add	local06, local08
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #4
	wrlong	local07, local06
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local07, local08
	shl	local07, #1
	add	local07, local08
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	add	local07, #8
	wrlong	local09, local07
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##9784
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
'   t1.result.uresult=memtop
'   t1.result_type=result_string2  
'   compiledline(lineptr)=t1: lineptr+=1 :ct+=1
'   if lparts(ct).token=token_comma then t1.result_type=print_mod_comma : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local08, local08
	cmp	local08, #17 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0844
	mov	local03, #33
	mov	local08, local01
	mov	local07, local02
	mov	local10, local03
	add	objptr, ##38944
	rdlong	local11, objptr
	mov	local12, local11
	shl	local12, #1
	add	local12, local11
	shl	local12, #2
	sub	objptr, ##1536
	add	local12, objptr
	wrlong	local08, local12
	add	objptr, ##1536
	rdlong	local13, objptr
	mov	local08, local13
	shl	local08, #1
	add	local08, local13
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	add	local08, #4
	wrlong	local07, local08
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local14, local08
	shl	local14, #1
	add	local14, local08
	shl	local14, #2
	sub	objptr, ##1536
	add	local14, objptr
	add	local14, #8
	wrlong	local10, local14
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	mov	local03, #68
	mov	local08, local01
	mov	local07, local02
	mov	local10, local03
	rdlong	local14, objptr
	mov	local13, local14
	shl	local13, #1
	add	local13, local14
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	wrlong	local08, local13
	add	objptr, ##1536
	rdlong	local14, objptr
	mov	local13, local14
	shl	local13, #1
	add	local13, local14
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	add	local13, #4
	wrlong	local07, local13
	add	objptr, ##1536
	rdlong	local13, objptr
	mov	local14, local13
	shl	local14, #1
	add	local14, local13
	shl	local14, #2
	sub	objptr, ##1536
	add	local14, objptr
	add	local14, #8
	wrlong	local10, local14
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##38944
LR__0844
'   if lparts(ct).token=token_semicolon then t1.result_type=print_mod_semicolon : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##29160
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local14, local08
	cmp	local14, #18 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0845
	mov	local03, #34
	mov	local08, local01
	mov	local07, local02
	mov	local10, local03
	add	objptr, ##38944
	rdlong	local14, objptr
	mov	local13, local14
	shl	local13, #1
	add	local13, local14
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	wrlong	local08, local13
	add	objptr, ##1536
	rdlong	local14, objptr
	mov	local08, local14
	shl	local08, #1
	add	local08, local14
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	add	local08, #4
	wrlong	local07, local08
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local14, local08
	shl	local14, #1
	add	local14, local08
	shl	local14, #2
	sub	objptr, ##1536
	add	local14, objptr
	add	local14, #8
	wrlong	local10, local14
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	mov	local03, #68
	mov	local08, local01
	mov	local07, local02
	mov	local10, local03
	rdlong	local14, objptr
	mov	local13, local14
	shl	local13, #1
	add	local13, local14
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	wrlong	local08, local13
	add	objptr, ##1536
	rdlong	local14, objptr
	mov	local13, local14
	shl	local13, #1
	add	local13, local14
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	add	local13, #4
	wrlong	local07, local13
	add	objptr, ##1536
	rdlong	local13, objptr
	mov	local14, local13
	shl	local14, #1
	add	local14, local13
	shl	local14, #2
	sub	objptr, ##1536
	add	local14, objptr
	add	local14, #8
	wrlong	local10, local14
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##38944
LR__0845
'   if lparts(ct).token<>token_semicolon  andalso lparts(ct).token<>token_comma then t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1 : ct-=1
	add	objptr, ##29160
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local14, local08
	cmp	local14, #18 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0846
	add	objptr, ##29160
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local14, local08
	cmp	local14, #17 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0846
	mov	local03, #68
	mov	local08, local01
	mov	local07, local02
	mov	local10, local03
	add	objptr, ##38944
	rdlong	local14, objptr
	mov	local13, local14
	shl	local13, #1
	add	local13, local14
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	wrlong	local08, local13
	add	objptr, ##1536
	rdlong	local14, objptr
	mov	local13, local14
	shl	local13, #1
	add	local13, local14
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	add	local13, #4
	wrlong	local07, local13
	add	objptr, ##1536
	rdlong	local13, objptr
	mov	local14, local13
	shl	local14, #1
	add	local14, local13
	shl	local14, #2
	sub	objptr, ##1536
	add	local14, objptr
	add	local14, #8
	wrlong	local10, local14
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##9784
	rdlong	local08, objptr
	sub	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##29160
LR__0846
	add	objptr, ##29160
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##29160
LR__0847
	mov	local05, #0
' i=0 : err=0
' if lparts(ct).token<>token_end then
	add	objptr, ##29160
	rdlong	local14, objptr
	shl	local14, #3
	sub	objptr, ##1080
	add	local14, objptr
	add	local14, #4
	rdlong	local14, local14
	cmp	local14, #510 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0849
'   do
LR__0848
	call	#_getaddr
	mov	local15, result1
	add	objptr, ##29160
	rdlong	local14, objptr
	add	local14, #1
	wrlong	local14, objptr
	add	local05, #1
'     err=getaddr() :ct+=1
'     i+=1 
'     if lparts(ct).token=token_comma then ct+=1 
	shl	local14, #3
	sub	objptr, ##1080
	add	local14, objptr
	add	local14, #4
	rdlong	local14, local14
	cmp	local14, #17 wz
	sub	objptr, ##28080
 if_e	add	objptr, ##29160
 if_e	rdlong	local08, objptr
 if_e	add	local08, #1
 if_e	wrlong	local08, objptr
 if_e	sub	objptr, ##29160
'     if lparts(ct).token=token_end then exit loop
	add	objptr, ##29160
	rdlong	local14, objptr
	shl	local14, #3
	sub	objptr, ##1080
	add	local14, objptr
	add	local14, #4
	rdlong	local14, local14
	cmp	local14, #510 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0850
	jmp	#LR__0848
LR__0849
	mov	local15, #54
LR__0850
' return i,err
	mov	result1, local05
	mov	result2, local15
	mov	ptra, fp
	call	#popregs_
_compile_input_ret
	ret

' 
' '----- compile assign to an array element
' 
' function compile_array_assign() as ulong 
_compile_array_assign
	mov	COUNT_, #11
	call	#pushregs_
	mov	local04, #0
	mov	local05, #0
	add	objptr, ##29160
	rdlong	local06, objptr
	mov	result1, local06
	sub	result1, #1
	shl	result1, #3
	sub	objptr, ##1080
	add	result1, objptr
	rdlong	local07, result1
' numpar=0 : err=0
' varname$=lparts(ct-1).part$
' if lparts(ct).token=token_lpar then
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local06, local06
	cmp	local06, #21 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0864
	add	objptr, ##29160
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##29160
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__0860
	call	#_expr
	add	objptr, ##29160
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	add	local04, #1
	sub	local06, #1
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	add	local06, #4
	rdlong	local08, local06
	cmp	local08, #20 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0861
	add	objptr, ##29160
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local08, local08
	cmp	local08, #510 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0860
LR__0861
	add	objptr, ##29160
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##29160
	call	#_expr
	neg	local09, #1
	mov	local10, #0
'   ct+=1 : expr()
'   j=-1 : i=0 
'   do 
LR__0862
'     if variables(i).name=varname$ then j=i: exit loop
	mov	local06, local10
	shl	local06, #4
	mov	local08, objptr
	add	local08, ##11676
	add	local06, local08
	rdlong	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local09, local10
 if_e	jmp	#LR__0863
	add	local10, #1
	add	objptr, ##28076
	rdlong	local08, objptr
	sub	objptr, ##28076
	cmps	local10, local08 wcz
 if_be	jmp	#LR__0862
LR__0863
	mov	local01, local09
	mov	local02, local04
	mov	local03, #23
	mov	local08, local01
	mov	local11, local02
	mov	local07, local03
	add	objptr, ##38944
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local08, local09
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local11, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local01, local11
	shl	local01, #1
	add	local01, local11
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	local07, local01
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
'   t1.result.twowords(0)=j: t1.result.twowords(1)=numpar : t1.result_type=fun_assign : compiledline(lineptr)=t1: lineptr +=1 
'   if numpar>3 then err=45
	cmp	local04, #4 wc
 if_ae	mov	local05, #45
'   if i>varnum then err=20
	sub	objptr, ##10868
	rdlong	local08, objptr
	sub	objptr, ##28076
	cmps	local10, local08 wcz
 if_a	mov	local05, #20
	jmp	#LR__0865
LR__0864
	mov	local05, #14
LR__0865
' return err
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
_compile_array_assign_ret
	ret

' 
' '----- compile print command with its ";" and "," modifiers
' 
' function compile_print() as ulong ' todo reconfigurable editor start position
_compile_print
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, #0
	mov	local03, #29
' t1.result.uresult=0 : t1.result_type=result_uint
' if lparts(ct).token=token_end then t1.result_type=print_mod_empty: compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1 :return 0 	'print without parameters
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #510 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0870
	mov	local03, #32
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##38944
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local10, local05
	shl	local10, #1
	add	local10, local05
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local11, local05
	shl	local11, #1
	add	local11, local05
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##38944
	mov	result1, #0
	jmp	#LR__0877
LR__0870
' do
LR__0871
	call	#_expr
'   expr()  ': print "In compile_print token= "; lparts(ct).token; " part$= "; lparts(ct).part$ :
'   if lparts(ct).token=token_comma then t1.result_type=print_mod_comma : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #17 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0872
	mov	local03, #33
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##38944
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local11, local05
	shl	local11, #1
	add	local11, local05
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##38944
LR__0872
'   if lparts(ct).token=token_semicolon then  t1.result_type=print_mod_semicolon : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #18 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0873
	mov	local03, #34
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##38944
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local11, local05
	shl	local11, #1
	add	local11, local05
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##38944
LR__0873
'   if lparts(ct).token=token_end then t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #510 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0874
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##38944
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##38944
LR__0874
'   if lparts(ct).token <>token_comma andalso lparts(ct).token <>token_semicolon andalso lparts(ct).token <>token_end then return 22
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #17 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0875
	add	objptr, ##29160
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local08, local08
	cmp	local08, #18 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0875
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local11, local11
	cmp	local11, #510 wz
	sub	objptr, ##28080
 if_ne	mov	result1, #22
 if_ne	jmp	#LR__0877
LR__0875
	add	objptr, ##29160
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #510 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0876
	add	objptr, ##29160
	rdlong	local11, objptr
	add	objptr, ##7196
	rdlong	local10, objptr
	sub	objptr, ##36356
	cmps	local11, local10 wc
 if_b	jmp	#LR__0871
LR__0876
' return 0
	mov	result1, #0
LR__0877
	mov	ptra, fp
	call	#popregs_
_compile_print_ret
	ret

' 
' '----- compile 'if' command. Gets the linenum as it can call compile_immediate() and compile_immediate_assign()
' 
' function compile_if(aline as ulong) as ulong  
_compile_if
	mov	COUNT_, #9
	call	#pushregs_
_compile_if_enter
	mov	local04, arg01
' return expr()
	call	#_expr
	add	objptr, ##29160
	rdlong	arg02, objptr
	mov	local05, arg02
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local05, local05
	add	arg02, #1
	add	objptr, ##1080
	wrlong	arg02, objptr
	sub	objptr, ##29160
' 
' err=compile_fun_1p()
' cmd=lparts(ct).token : ct+=1 : if cmd<>token_then then return 52
	cmp	local05, #91 wz
 if_ne	mov	result1, #52
 if_ne	jmp	#LR__0882
	mov	local03, #88
	mov	local06, local01
	mov	local07, local02
	mov	arg02, local03
	add	objptr, ##38944
	rdlong	arg01, objptr
	mov	local08, arg01
	shl	local08, #1
	add	local08, arg01
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	wrlong	local06, local08
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	arg01, local06
	shl	arg01, #1
	add	arg01, local06
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	add	arg01, #4
	wrlong	local07, arg01
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	arg01, local06
	shl	arg01, #1
	add	arg01, local06
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	add	arg01, #8
	wrlong	arg02, arg01
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
' t1.result_type=token_if : compiledline(lineptr)=t1:  lineptr+=1
' if isassign(lparts(ct+1).part$) then err=compile_immediate_assign(5) else err=compile_immediate(5,aline)
	sub	objptr, ##9784
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	sub	objptr, ##28080
' 
' select case s
	mov	arg02, ##@LR__5639
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0880
	mov	arg01, #5
	call	#_compile_immediate_assign
	mov	local09, result1
	jmp	#LR__0881
LR__0880
	mov	arg01, #5
	mov	arg02, local04
	call	#_compile_immediate
	mov	local09, result1
LR__0881
' return err
	mov	result1, local09
LR__0882
	mov	ptra, fp
	call	#popregs_
_compile_if_ret
	ret

' 
' '----- compile 'else' command. Gets the linenum as it can call compile_immediate() and compile_immediate_assign()
' 
' function compile_else(aline as ulong) as ulong  
_compile_else
	mov	COUNT_, #7
	call	#pushregs_
_compile_else_enter
	mov	local04, arg01
	mov	local03, #90
	mov	local05, local01
	mov	local06, local02
	mov	local01, local03
	add	objptr, ##38944
	rdlong	arg02, objptr
	mov	arg01, arg02
	shl	arg01, #1
	add	arg01, arg02
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	wrlong	local05, arg01
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	arg02, local05
	shl	arg02, #1
	add	arg02, local05
	shl	arg02, #2
	sub	objptr, ##1536
	add	arg02, objptr
	add	arg02, #4
	wrlong	local06, arg02
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #8
	wrlong	local01, local05
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
' t1.result_type=token_else : compiledline(lineptr)=t1:  lineptr+=1
' if isassign(lparts(ct+1).part$) then err=compile_immediate_assign(5) else err=compile_immediate(5,aline)
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	rdlong	arg01, local06
	sub	objptr, ##28080
' 
' select case s
	mov	arg02, ##@LR__5639
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0890
	mov	arg01, #5
	call	#_compile_immediate_assign
	mov	local07, result1
	jmp	#LR__0891
LR__0890
	mov	arg01, #5
	mov	arg02, local04
	call	#_compile_immediate
	mov	local07, result1
LR__0891
' return err
	mov	result1, local07
	mov	ptra, fp
	call	#popregs_
_compile_else_ret
	ret

' 
' '----- compile 'dim' command. Also it allocates the psram for an aray from the top of the memory
' 
' function compile_dim() as ulong  
_compile_dim
	mov	COUNT_, #17
	call	#pushregs_
	mov	local01, #1
	mov	local02, #1
	mov	local03, #1
' 
' dims(0)=1: dims(1)=1: dims(2)=1
' if isname(lparts(ct).part$) then 
	add	objptr, ##29160
	rdlong	arg04, objptr
	shl	arg04, #3
	sub	objptr, ##1080
	add	arg04, objptr
	rdlong	arg01, arg04
	sub	objptr, ##28080
	call	#_isname
	cmp	result1, #0 wz
 if_e	jmp	#LR__0923
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	local05, local04
	neg	local06, #1
'   varname2$=lparts(ct).part$ 
'   j=-1
'   if varnum>0 then
	sub	objptr, #4
	rdlong	local07, objptr
	sub	objptr, ##28076
	cmps	local07, #1 wc
 if_b	jmp	#LR__0902
'     for i=0 to varnum-1
	mov	local08, #0
	add	objptr, ##28076
	rdlong	local09, objptr
	sub	objptr, ##28076
LR__0900
	cmps	local08, local09 wc
 if_ae	jmp	#LR__0901
'       if variables(i).name=varname2$ then j=i : exit
	mov	local04, local08
	shl	local04, #4
	mov	arg02, objptr
	add	arg02, ##11676
	add	local04, arg02
	rdlong	arg01, local04
	mov	arg02, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local06, local08
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0900
LR__0901
LR__0902
'   if j=-1 then j=varnum else print "Dim: at line ";linenum;": warning: the variable existed."
	cmp	local06, ##-1 wz
 if_e	add	objptr, ##28076
 if_e	rdlong	local06, objptr
 if_e	sub	objptr, ##28076
 if_e	jmp	#LR__0903
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5911
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##43148
	rdlong	arg02, objptr
	sub	objptr, ##43148
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg02, ##@LR__5912
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__0903
'   if lparts(ct+1).part$ <>"(" andalso lparts(ct+1).part$<>"as" then return 43
	add	objptr, ##29160
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, ##@LR__5913
	sub	objptr, ##28080
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0904
	add	objptr, ##29160
	rdlong	local09, objptr
	add	local09, #1
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	rdlong	arg01, local09
	mov	arg02, ##@LR__5914
	sub	objptr, ##28080
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #43
 if_ne	jmp	#LR__0925
LR__0904
'   if lparts(ct+1).part$ = "as" then l=ct+1: goto 1350	' allocate a typed array
	add	objptr, ##29160
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, ##@LR__5915
	sub	objptr, ##28080
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##29160
 if_e	rdlong	local10, objptr
 if_e	sub	objptr, ##29160
 if_e	add	local10, #1
 if_e	jmp	#LR__0909
	add	objptr, ##29160
	rdlong	local10, objptr
	sub	objptr, ##29160
	add	local10, #2
	mov	local11, #0
'   l=ct+2 : m=0 : do
LR__0905
'   if isdec(lparts(l).part$) then 
	mov	local04, local10
	shl	local04, #3
	mov	local09, objptr
	add	local09, ##28080
	add	local04, local09
	rdlong	arg01, local04
	call	#_isdec
	cmp	result1, #0 wz
 if_e	jmp	#LR__0906
	mov	local12, local11
	add	local12, #local01
	mov	local09, local10
	shl	local09, #3
	mov	local08, objptr
	add	local08, ##28080
	add	local09, local08
	rdlong	arg01, local09
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	local13, result1
	'.live	local13
	'.live	local12
	altd	local12, #0
	mov	local12, local13
	add	local11, #1
	jmp	#LR__0907
LR__0906
'     return(17)
	mov	result1, #17
	jmp	#LR__0925
LR__0907
'   if (lparts(l+1).part$<>"," andalso lparts(l+1).part$<>")" ) then return 44 
	mov	local04, local10
	add	local04, #1
	shl	local04, #3
	mov	local13, objptr
	add	local13, ##28080
	add	local04, local13
	rdlong	arg01, local04
	mov	arg02, ##@LR__5916
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0908
	mov	local13, local10
	add	local13, #1
	shl	local13, #3
	mov	local12, objptr
	add	local12, ##28080
	add	local13, local12
	rdlong	arg01, local13
	mov	arg02, ##@LR__5917
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #44
 if_ne	jmp	#LR__0925
LR__0908
	add	local10, #2
	mov	local04, local10
	sub	local04, #1
	shl	local04, #3
	mov	local13, objptr
	add	local13, ##28080
	add	local04, local13
	rdlong	arg01, local04
	mov	arg02, ##@LR__5918
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	cmps	local11, #3 wc
 if_c_and_nz	jmp	#LR__0905
'   if m>3 then return 45
	cmps	local11, #4 wc
 if_ae	mov	result1, #45
 if_ae	jmp	#LR__0925
	mov	local14, #256
	mov	local15, #12
LR__0909
'   arraytype=array_no_type : esize=12
' 1350 
'   if lparts(l).part$="as" then
	mov	local04, local10
	shl	local04, #3
	mov	local13, objptr
	add	local13, ##28080
	add	local04, local13
	rdlong	arg01, local04
	mov	arg02, ##@LR__5919
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0924
'     select case lparts(l+1).part$
	mov	local12, local10
	add	local12, #1
	shl	local12, #3
	mov	local04, objptr
	add	local04, ##28080
	add	local12, local04
	rdlong	local16, local12
	mov	arg02, ##@LR__5920
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0910
	mov	arg02, ##@LR__5921
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0911
	mov	arg02, ##@LR__5922
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0912
	mov	arg02, ##@LR__5923
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0913
	mov	arg02, ##@LR__5924
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0914
	mov	arg02, ##@LR__5925
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0915
	mov	arg02, ##@LR__5926
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0916
	mov	arg02, ##@LR__5927
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0917
	mov	arg02, ##@LR__5928
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0918
	mov	arg02, ##@LR__5929
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0919
	mov	arg02, ##@LR__5930
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0920
	mov	arg02, ##@LR__5931
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0921
	jmp	#LR__0922
LR__0910
	mov	local14, #257
	mov	local15, #1
	jmp	#LR__0924
LR__0911
	mov	local14, #258
	mov	local15, #1
	jmp	#LR__0924
LR__0912
	mov	local14, #259
	mov	local15, #2
	jmp	#LR__0924
LR__0913
	mov	local14, #260
	mov	local15, #2
	jmp	#LR__0924
LR__0914
	mov	local14, #261
	mov	local15, #4
	jmp	#LR__0924
LR__0915
	mov	local14, #261
	mov	local15, #4
	jmp	#LR__0924
LR__0916
	mov	local14, #262
	mov	local15, #4
	jmp	#LR__0924
LR__0917
	mov	local14, #263
	mov	local15, #8
	jmp	#LR__0924
LR__0918
	mov	local14, #264
	mov	local15, #8
	jmp	#LR__0924
LR__0919
	mov	local14, #265
	mov	local15, #4
	jmp	#LR__0924
LR__0920
	mov	local14, #266
	mov	local15, #8
	jmp	#LR__0924
LR__0921
	mov	local14, #267
	mov	local15, #4
	jmp	#LR__0924
LR__0922
	mov	result1, #47
	jmp	#LR__0925
LR__0923
'   return 46
	mov	result1, #46
	jmp	#LR__0925
LR__0924
	qmul	local15, local01
	getqx	local07
	qmul	local07, local02
	getqx	local16
	qmul	local16, local03
	add	objptr, ##43124
	rdlong	local17, objptr
	mov	arg02, local14
	getqx	local16
	sub	local17, local16
	sub	local17, #16
	andn	local17, #15
	wrlong	local17, objptr
	sub	objptr, ##43124
	mov	arg01, local17
	call	#_psdpoke
	mov	arg01, local17
	add	arg01, #2
	mov	arg02, local15
	call	#_psdpoke
	mov	arg01, local17
	add	arg01, #4
	mov	arg02, local01
	call	#_pslpoke
	mov	arg01, local17
	add	arg01, #8
	mov	arg02, local02
	call	#_pslpoke
	mov	arg01, local17
	add	arg01, #12
	mov	arg02, local03
	call	#_pslpoke
	mov	local12, local06
	shl	local12, #4
	add	objptr, ##11676
	add	local12, objptr
	wrlong	local05, local12
	mov	local12, local06
	shl	local12, #4
	add	local12, objptr
	add	local12, #4
	wrlong	local17, local12
	mov	local12, local06
	shl	local12, #4
	add	local12, objptr
	add	local12, #12
	wrlong	local14, local12
' memtop=arrayptr
' psdpoke arrayptr,arraytype 
' psdpoke arrayptr+2,esize 
' pslpoke arrayptr+4,dims(0)
' pslpoke arrayptr+8,dims(1)
' pslpoke arrayptr+12,dims(2)
' variables(j).name=varname2$
' variables(j).value.uresult=arrayptr
' variables(j).vartype=arraytype
' if j=varnum then varnum+=1
	add	objptr, ##16400
	rdlong	local07, objptr
	sub	objptr, ##28076
	cmp	local06, local07 wz
 if_e	add	objptr, ##28076
 if_e	rdlong	local07, objptr
 if_e	add	local07, #1
 if_e	wrlong	local07, objptr
 if_e	sub	objptr, ##28076
' return 0
	mov	result1, #0
LR__0925
	mov	ptra, fp
	call	#popregs_
_compile_dim_ret
	ret

' 
' '----- compile 'for' command. 
' 
' function compile_for() as ulong  
_compile_for
	mov	COUNT_, #15
	call	#pushregs_
' 
' if isassign(lparts(ct+1).part$) then compile_immediate_assign(5) else return 32
	add	objptr, ##29160
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	sub	objptr, ##28080
' 
' select case s
	mov	arg02, ##@LR__5639
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0930
	mov	arg01, #5
	call	#_compile_immediate_assign
	jmp	#LR__0931
LR__0930
	mov	result1, #32
	jmp	#LR__0947
LR__0931
	add	objptr, ##38944
	rdlong	arg02, objptr
	mov	arg01, arg02
	sub	arg01, #1
	mov	local04, arg01
	shl	local04, #1
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	rdlong	local01, local04
	add	local04, #4
	rdlong	local05, local04
	sub	arg02, #1
	mov	local06, arg02
	shl	local06, #1
	add	local06, arg02
	shl	local06, #2
	mov	local07, objptr
	add	local06, objptr
	add	local06, #8
	rdlong	local04, local06
	mov	local02, local05
	mov	local03, local04
' t1=compiledline(lineptr-1): if t1.result_type<>fun_assign  then  return 34'		' after this we should have fun_assign_i or fun_assign_u with var# as uresult.
	cmp	local03, #23 wz
	sub	objptr, ##37408
 if_ne	mov	result1, #34
 if_ne	jmp	#LR__0947
	mov	local08, local01
' varnum=t1.result.uresult
' if lparts(ct).part$<>"to" then return 33
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__5932
	sub	objptr, ##28080
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #33
 if_ne	jmp	#LR__0947
	add	objptr, ##29160
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##29160
	call	#_expr
' ct+=1
' expr()  										' there is "to" value pushed on the stack
' if lparts(ct).part$="step" orelse left$(lparts(ct).part$,2)="s." then
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__5933
	sub	objptr, ##28080
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0932
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, #2
	sub	objptr, ##28080
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5934
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0945
LR__0932
'   if left$(lparts(ct).part$,2)="s." andalso len(lparts(ct).part$)>2 then ' correct the part
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, #2
	sub	objptr, ##28080
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5935
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0944
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	sub	objptr, ##28080
	mov	local10, arg01
	callpa	#(@LR__0934-@LR__0933)>>2,fcache_load_ptr_
LR__0933
	rdbyte	result1, local10 wz
 if_ne	add	local10, #1
 if_ne	jmp	#LR__0933
LR__0934
	sub	local10, arg01
	cmps	local10, #3 wc
 if_b	jmp	#LR__0944
	add	objptr, ##29160
	rdlong	local04, objptr
	mov	local11, local04
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	shl	local04, #3
	add	local04, objptr
	rdlong	local04, local04
	add	objptr, ##1080
	rdlong	arg01, objptr
	shl	arg01, #3
	sub	objptr, ##1080
	add	arg01, objptr
	rdlong	arg01, arg01
	sub	objptr, ##28080
	mov	local10, arg01
	callpa	#(@LR__0936-@LR__0935)>>2,fcache_load_ptr_
LR__0935
	rdbyte	result1, local10 wz
 if_ne	add	local10, #1
 if_ne	jmp	#LR__0935
LR__0936
	sub	local10, arg01
	mov	arg02, local10
	sub	arg02, #2
	mov	arg01, local04
	call	#__system__Right_S
	wrlong	result1, local11
	add	objptr, ##29160
	rdlong	local04, objptr
	mov	local11, local04
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	shl	local04, #3
	add	local04, objptr
	rdlong	arg01, local04
	sub	objptr, ##28080
	call	#_isfunction
	getbyte	result1, result1, #0
	add	local11, #4
	wrlong	result1, local11
'     lparts(ct).token=isfunction(lparts(ct).part$) : if lparts(ct).token>0 then goto 2102
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local04, local11
	cmps	local04, #1 wc
	sub	objptr, ##28080
 if_ae	jmp	#LR__0943
	add	objptr, ##29160
	rdlong	local04, objptr
	mov	local11, local04
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	shl	local04, #3
	add	local04, objptr
	rdlong	arg01, local04
	sub	objptr, ##28080
	call	#_isnotename
	add	local11, #4
	wrlong	result1, local11
'     lparts(ct).token=isnotename(lparts(ct).part$) :
'     if lparts(ct).token>0 then 
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local04, local11
	cmps	local04, #1 wc
	sub	objptr, ##28080
 if_b	jmp	#LR__0937
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	arg01, local11
	sub	objptr, ##28080
	call	#_getnoteval
	mov	arg01, result1
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	sub	objptr, ##28080
	call	#__system__str_S
	wrlong	result1, local11
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	wrlong	##514, local11
	sub	objptr, ##28080
	jmp	#LR__0943
LR__0937
	add	objptr, ##29160
	rdlong	local04, objptr
	mov	local11, local04
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	shl	local04, #3
	add	local04, objptr
	rdlong	arg01, local04
	sub	objptr, ##28080
	call	#_isconstant
	add	local11, #4
	wrlong	result1, local11
'     lparts(ct).token=isconstant(lparts(ct).part$) : if lparts(ct).token>0 then lparts(ct).part$=str$(lparts(ct).token) : lparts(ct).token=token_integer : goto 2102
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local04, local11
	cmps	local04, #1 wc
	sub	objptr, ##28080
 if_b	jmp	#LR__0938
	add	objptr, ##29160
	rdlong	local09, objptr
	mov	local11, local09
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	shl	local09, #3
	add	local09, objptr
	add	local09, #4
	rdlong	arg01, local09
	sub	objptr, ##28080
	abs	arg01, arg01 wc
 if_b	decod	local12, #31
 if_ae	mov	local12, #0
	call	#__system___float_fromuns
	xor	result1, local12
	mov	arg01, result1
	call	#__system__str_S
	wrlong	result1, local11
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	wrlong	##513, local11
	sub	objptr, ##28080
	jmp	#LR__0943
LR__0938
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	sub	objptr, ##28080
	call	#_isnum
	mov	local13, result1
	signx	local13, #7
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	sub	objptr, ##28080
	call	#_isint
	mov	local14, result1
	signx	local14, #7
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	sub	objptr, ##28080
	call	#_isdec
	signx	result1, #7
	mov	local15, result1
'     b1=isnum(lparts(ct).part$) : b2=isint(lparts(ct).part$) : b3=isdec(lparts(ct).part$)
'     if b1 andalso b2 andalso b3 then lparts(ct).token=token_decimal 			: goto 2102 	' pure decimal for line num
	cmp	local13, #0 wz
 if_ne	cmp	local14, #0 wz
 if_ne	cmp	local15, #0 wz
 if_e	jmp	#LR__0939
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	wrlong	##512, local11
	sub	objptr, ##28080
	jmp	#LR__0943
LR__0939
'     if b1 andalso b2 andalso (not b3) then lparts(ct).token=token_integer 		: goto 2102 	' integer
	cmp	local13, #0 wz
 if_ne	cmp	local14, #0 wz
 if_ne	not	local09, local15
 if_ne	cmp	local09, #0 wz
 if_e	jmp	#LR__0940
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	wrlong	##513, local11
	sub	objptr, ##28080
	jmp	#LR__0943
LR__0940
'     if b1 andalso (not b2) andalso (not b3) then lparts(ct).token=token_float 		: goto 2102 	' float
	cmp	local13, #0 wz
 if_ne	not	local14, local14
 if_ne	cmp	local14, #0 wz
 if_ne	not	local15, local15
 if_ne	cmp	local15, #0 wz
 if_e	jmp	#LR__0941
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	wrlong	##514, local11
	sub	objptr, ##28080
	jmp	#LR__0943
LR__0941
'     if isname(lparts(ct).part$) then lparts(ct).token=token_name : goto 2102	
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	rdlong	arg01, local11
	sub	objptr, ##28080
	call	#_isname
	cmp	result1, #0 wz
 if_e	jmp	#LR__0942
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	wrlong	##516, local11
	sub	objptr, ##28080
LR__0942
LR__0943
	add	objptr, ##29160
	rdlong	local09, objptr
	sub	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##29160
LR__0944
	add	objptr, ##29160
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##29160
	call	#_expr
	jmp	#LR__0946
LR__0945
	add	objptr, ##38944
	rdlong	local15, objptr
	mov	local11, local15
	shl	local11, #1
	add	local11, local15
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	#28, local11
	add	objptr, ##1536
	rdlong	local15, objptr
	mov	local11, local15
	shl	local11, #1
	add	local11, local15
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	wrlong	#1, local11
	add	objptr, ##1536
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##38944
LR__0946
	add	objptr, ##38944
	rdlong	local15, objptr
	mov	local11, local15
	shl	local11, #1
	add	local11, local15
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	#28, local11
	add	objptr, ##1536
	rdlong	local15, objptr
	mov	local11, local15
	shl	local11, #1
	add	local11, local15
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	wrlong	local08, local11
	add	objptr, ##1536
	rdlong	local15, objptr
	add	local15, #1
	wrlong	local15, objptr
	mov	local11, local15
	shl	local11, #1
	add	local11, local15
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	#74, local11
	add	objptr, ##1536
	rdlong	local15, objptr
	mov	local11, local15
	shl	local11, #1
	add	local11, local15
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	wrlong	#0, local11
	add	objptr, ##1536
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##38944
' compiledline(lineptr).result_type=result_int : compiledline(lineptr).result.iresult=varnum :lineptr+=1
' compiledline(lineptr).result_type=token_for : compiledline(lineptr).result.iresult=0 :lineptr+=1
' return 0
	mov	result1, #0
LR__0947
	mov	ptra, fp
	call	#popregs_
_compile_for_ret
	ret

' 
' '----- compile 'next' command. 
' 
' function compile_next() as ulong
_compile_next
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, ##29160
	rdlong	arg01, objptr
	shl	arg01, #3
	sub	objptr, ##1080
	add	arg01, objptr
	rdlong	local01, arg01
' 
' varname$=lparts(ct).part$ 
' if varnum=0 then return 35
	sub	objptr, #4
	rdlong	arg01, objptr wz
	sub	objptr, ##28076
 if_e	mov	result1, #35
 if_e	jmp	#LR__0952
	neg	local02, #1
' j=-1
' for i=0 to varnum-1
	mov	local03, #0
	add	objptr, ##28076
	rdlong	local04, objptr
	sub	objptr, ##28076
LR__0950
	cmp	local03, local04 wc
 if_ae	jmp	#LR__0951
'   if variables(i).name=varname$ then j=i : exit
	mov	arg01, local03
	shl	arg01, #4
	mov	arg02, objptr
	add	arg02, ##11676
	add	arg01, arg02
	rdlong	arg01, arg01
	mov	arg02, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local02, local03
 if_ne	add	local03, #1
 if_ne	jmp	#LR__0950
LR__0951
' if j=-1 then return 35
	cmp	local02, ##-1 wz
 if_e	mov	result1, #35
 if_e	jmp	#LR__0952
	add	objptr, ##38944
	rdlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	add	local03, #8
	wrlong	#28, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	wrlong	local02, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	add	local03, #8
	wrlong	#75, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	wrlong	#0, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##38944
' compiledline(lineptr).result_type=result_int : compiledline(lineptr).result.iresult=j :lineptr+=1
' compiledline(lineptr).result_type=token_next : compiledline(lineptr).result.iresult=0 :lineptr+=1
' return 0
	mov	result1, #0
LR__0952
	mov	ptra, fp
	call	#popregs_
_compile_next_ret
	ret

' 
' '----- compile 'gosub' command. Gosub is "goto" that saves the return address, so add token_gosub, then compile goto
' 
' function compile_gosub() as ulong
_compile_gosub
	mov	COUNT_, #2
	call	#pushregs_
	add	objptr, ##38944
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	local02, #8
	wrlong	#169, local02
	add	objptr, ##1536
	rdlong	local02, objptr
	add	local02, #1
	wrlong	local02, objptr
	sub	objptr, ##38944
	call	#_compile_goto
' compiledline(lineptr).result_type=token_gosub
' lineptr+=1
' err=compile_goto()
' return err
	mov	ptra, fp
	call	#popregs_
_compile_gosub_ret
	ret

' 
' '----- compile 'goto' 
' 
' function compile_goto() as ulong
_compile_goto
	mov	COUNT_, #10
	call	#pushregs_
	add	ptra, #52
' if lparts(ct).token=token_decimal andalso lparts(ct+1).token=token_end then 	' we have a goto to a constant
	add	objptr, ##29160
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg03, arg03
	cmp	arg03, ##512 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0963
	add	objptr, ##29160
	rdlong	arg03, objptr
	add	arg03, #1
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg03, arg03
	cmp	arg03, #510 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0963
	add	objptr, ##29160
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	mov	arg02, #0
	sub	objptr, ##28080
	call	#__system____builtin_atoi
	mov	local04, result1
	add	objptr, ##38944
	rdlong	local05, objptr
	mov	local06, local05
	shl	local06, #1
	add	local06, local05
	shl	local06, #2
	sub	objptr, ##1536
	mov	local07, objptr
	add	local06, objptr
	add	local06, #8
	wrlong	#78, local06
	add	objptr, ##1548
	rdlong	local08, objptr
'   gotoline=val%(lparts(ct).part$) 
'   compiledline(lineptr).result_type=token_fast_goto
'   gotoptr=programstart 							    	' now try to find a pointer to goto
'   do
	sub	objptr, ##33120
LR__0960
	mov	arg01, fp
	add	arg01, #16
	mov	arg02, local08
	mov	arg03, #24
	call	#_psram4_spin2_read1
'     psram.read1(varptr(gotoheader),gotoptr,24)  : 
'     if gotoheader(0)<>$FFFFFFFF then
	add	fp, #16
	rdlong	local06, fp
	sub	fp, #16
	cmp	local06, ##-1 wz
 if_ne	mov	local09, local08
 if_ne	add	fp, #36
 if_ne	rdlong	local08, fp
 if_ne	sub	fp, #36
	add	fp, #36
	rdlong	local06, fp
	sub	fp, #36
	cmp	local06, ##2147483647 wz
 if_ne	add	fp, #16
 if_ne	rdlong	local05, fp
 if_ne	sub	fp, #16
 if_ne	cmp	local05, ##-1 wz
 if_ne	add	fp, #16
 if_ne	mov	local07, local05
 if_ne	sub	fp, #16
 if_ne	cmp	local07, local04 wz
 if_ne	jmp	#LR__0960
	sub	objptr, ##5836
'   if gotoheader(0)=gotoline then
	add	fp, #16
	rdlong	local06, fp
	sub	fp, #16
	cmp	local06, local04 wz
 if_ne	jmp	#LR__0961
	add	objptr, ##38944
	rdlong	local05, objptr
	mov	local06, local05
	shl	local06, #1
	add	local06, local05
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	wrlong	local09, local06
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local06, local05
	shl	local06, #1
	add	local06, local05
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #4
	wrlong	local04, local06
	sub	objptr, ##37408
	jmp	#LR__0962
LR__0961
	add	objptr, ##38944
	rdlong	local05, objptr
	mov	local06, local05
	shl	local06, #1
	add	local06, local05
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	wrlong	##-2147483648, local06
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local06, local05
	shl	local06, #1
	add	local06, local05
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #4
	wrlong	local04, local06
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local06, local05
	shl	local06, #1
	add	local06, local05
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	#83, local06
	sub	objptr, ##37408
LR__0962
	add	objptr, ##38944
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##38944
	jmp	#LR__0964
LR__0963
	call	#_expr
	mov	local03, #79
	mov	local01, #0
	mov	local10, local02
	mov	local05, local03
	add	objptr, ##38944
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	#0, local09
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local10, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local01, local10
	shl	local01, #1
	add	local01, local10
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	local05, local01
	add	objptr, ##1536
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##38944
LR__0964
' return 0
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_compile_goto_ret
	ret

' 
' '----- compile 'on' (on..goto, on..gosub) 
' 
' function compile_on() as ulong
_compile_on
	mov	COUNT_, #4
	call	#pushregs_
	call	#_expr
	mov	local01, #0
	add	objptr, ##38944
	rdlong	arg02, objptr
	mov	arg01, arg02
	shl	arg01, #1
	add	arg01, arg02
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	add	arg01, #8
	wrlong	#193, arg01
	add	objptr, ##1536
	rdlong	arg02, objptr
	mov	local02, arg02
	add	arg02, #1
	wrlong	arg02, objptr
' expr()
' 'print lparts(ct).part$ 'ok
' numpar=0
' compiledline(lineptr).result_type=token_on : onlineptr=lineptr : lineptr+=1' we need onlineptr to save param# there
' if lparts(ct).part$="goto" then
	sub	objptr, ##9784
	rdlong	arg02, objptr
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, ##@LR__5936
	sub	objptr, ##28080
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0975
	add	objptr, ##29160
	rdlong	local03, objptr
	sub	objptr, ##29160
	add	local03, #1
'   i=ct+1
'   do
LR__0970
'     if lparts(i).token=token_decimal then
	mov	result1, local03
	shl	result1, #3
	mov	arg02, objptr
	add	arg02, ##28080
	add	result1, arg02
	add	result1, #4
	rdlong	result1, result1
	cmp	result1, ##512 wz
 if_ne	jmp	#LR__0971
	add	objptr, ##38944
	rdlong	result1, objptr
	mov	arg02, result1
	shl	arg02, #1
	add	arg02, result1
	shl	arg02, #2
	sub	objptr, ##1536
	add	arg02, objptr
	wrlong	##-2147483648, arg02
	add	objptr, ##1536
	rdlong	arg02, objptr
	mov	local04, arg02
	shl	local04, #1
	add	local04, arg02
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	mov	arg02, local03
	shl	arg02, #3
	sub	objptr, ##9328
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, #0
	sub	objptr, ##28080
	call	#__system____builtin_atoi
	add	local04, #4
	wrlong	result1, local04
	add	objptr, ##38944
	rdlong	arg02, objptr
	mov	local04, arg02
	shl	local04, #1
	add	local04, arg02
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#83, local04
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##38944
	add	local01, #1
	jmp	#LR__0972
LR__0971
'       return 17
	mov	result1, #17
	jmp	#LR__0985
LR__0972
	add	local03, #1
'     i+=1
'     if lparts(i).token<>token_comma andalso lparts(i).token<>token_end then return 21
	mov	arg01, local03
	shl	arg01, #3
	mov	local04, objptr
	add	local04, ##28080
	add	arg01, local04
	add	arg01, #4
	rdlong	arg01, arg01
	cmp	arg01, #17 wz
 if_e	jmp	#LR__0973
	mov	arg01, local03
	shl	arg01, #3
	mov	local04, objptr
	add	local04, ##28080
	add	arg01, local04
	add	arg01, #4
	rdlong	local04, arg01
	cmp	local04, #510 wz
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0985
LR__0973
'     if lparts(i).token=token_end then exit loop
	mov	result1, local03
	shl	result1, #3
	mov	local04, objptr
	add	local04, ##28080
	add	result1, local04
	add	result1, #4
	rdlong	result1, result1
	cmp	result1, #510 wz
 if_e	jmp	#LR__0974
	add	local03, #1
	mov	result1, local03
	shl	result1, #3
	mov	local04, objptr
	add	local04, ##28080
	add	result1, local04
	add	result1, #4
	rdlong	result1, result1
	cmp	result1, #510 wz
 if_ne	jmp	#LR__0970
LR__0974
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #2
	mov	local04, objptr
	add	local04, ##37408
	add	local03, local04
	add	local03, #4
	wrlong	#1, local03
LR__0975
' 
' if lparts(ct).part$="gosub" then
	add	objptr, ##29160
	rdlong	local03, objptr
	shl	local03, #3
	sub	objptr, ##1080
	add	local03, objptr
	rdlong	arg01, local03
	mov	arg02, ##@LR__5937
	sub	objptr, ##28080
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0981
	add	objptr, ##29160
	rdlong	local03, objptr
	sub	objptr, ##29160
	add	local03, #1
'   i=ct+1
'   do
LR__0976
'     if lparts(i).token=token_decimal then
	mov	result1, local03
	shl	result1, #3
	mov	local04, objptr
	add	local04, ##28080
	add	result1, local04
	add	result1, #4
	rdlong	result1, result1
	cmp	result1, ##512 wz
 if_ne	jmp	#LR__0977
	add	objptr, ##38944
	rdlong	result1, objptr
	mov	local04, result1
	shl	local04, #1
	add	local04, result1
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#169, local04
	add	objptr, ##1536
	rdlong	result1, objptr
	add	result1, #1
	wrlong	result1, objptr
	mov	local04, result1
	shl	local04, #1
	add	local04, result1
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	##-2147483648, local04
	add	objptr, ##1536
	rdlong	result1, objptr
	mov	local04, result1
	shl	local04, #1
	add	local04, result1
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	mov	arg01, local03
	shl	arg01, #3
	sub	objptr, ##9328
	add	arg01, objptr
	rdlong	arg01, arg01
	mov	arg02, #0
	sub	objptr, ##28080
	call	#__system____builtin_atoi
	add	local04, #4
	wrlong	result1, local04
	add	objptr, ##38944
	rdlong	arg01, objptr
	mov	local04, arg01
	shl	local04, #1
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#83, local04
	add	objptr, ##1536
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	add	local01, #1
	mov	local04, arg01
	shl	local04, #1
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#45, local04
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##38944
	jmp	#LR__0978
LR__0977
'       return 17
	mov	result1, #17
	jmp	#LR__0985
LR__0978
	add	local03, #1
'     i+=1
'     if lparts(i).token<>token_comma andalso lparts(i).token<>token_end then return 21
	mov	arg01, local03
	shl	arg01, #3
	mov	local04, objptr
	add	local04, ##28080
	add	arg01, local04
	add	arg01, #4
	rdlong	arg01, arg01
	cmp	arg01, #17 wz
 if_e	jmp	#LR__0979
	mov	arg01, local03
	shl	arg01, #3
	mov	local04, objptr
	add	local04, ##28080
	add	arg01, local04
	add	arg01, #4
	rdlong	arg01, arg01
	cmp	arg01, #510 wz
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0985
LR__0979
'     if lparts(i).token=token_end then exit loop
	mov	result1, local03
	shl	result1, #3
	mov	local04, objptr
	add	local04, ##28080
	add	result1, local04
	add	result1, #4
	rdlong	result1, result1
	cmp	result1, #510 wz
 if_e	jmp	#LR__0980
	add	local03, #1
	mov	result1, local03
	shl	result1, #3
	mov	local04, objptr
	add	local04, ##28080
	add	result1, local04
	add	result1, #4
	rdlong	result1, result1
	cmp	result1, #510 wz
 if_ne	jmp	#LR__0976
LR__0980
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #2
	mov	local04, objptr
	add	local04, ##37408
	add	local03, local04
	add	local03, #4
	wrlong	#3, local03
LR__0981
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #2
	add	objptr, ##37408
	add	local03, objptr
	wrlong	local01, local03
' compiledline(onlineptr).result.uresult=numpar
' for i=lineptr to onlineptr step -1 : if compiledline(i).result_type=token_skip then compiledline(i).result.uresult=lineptr-2
	add	objptr, ##1536
	rdlong	local03, objptr
	sub	objptr, ##38944
	callpa	#(@LR__0984-@LR__0982)>>2,fcache_load_ptr_
LR__0982
	mov	local04, local03
	shl	local04, #1
	add	local04, local03
	shl	local04, #2
	mov	local01, objptr
	add	local01, ##37408
	add	local04, local01
	add	local04, #8
	rdlong	local04, local04
	cmp	local04, #45 wz
 if_ne	jmp	#LR__0983
	mov	local04, local03
	shl	local04, #1
	add	local04, local03
	shl	local04, #2
	add	objptr, ##37408
	add	local04, objptr
	add	objptr, ##1536
	rdlong	local01, objptr
	sub	objptr, ##38944
	sub	local01, #2
	wrlong	local01, local04
LR__0983
	sub	local03, #1
	cmps	local03, local02 wc
 if_ae	jmp	#LR__0982
LR__0984
' return 0
	mov	result1, #0
LR__0985
	mov	ptra, fp
	call	#popregs_
_compile_on_ret
	ret

' 
' '----- A helper for compile_input and compile_read
'  
' function getaddr() as ulong
_getaddr
	mov	COUNT_, #11
	call	#pushregs_
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	local05, local04
	neg	local06, #1
' 
' varname$=lparts(ct).part$
' j=-1
' 
' for i=0 to varnum-1
	mov	local07, #0
	sub	objptr, #4
	rdlong	local08, objptr
	sub	objptr, ##28076
LR__0990
	cmps	local07, local08 wc
 if_ae	jmp	#LR__0991
'   if variables(i).name=varname$ then j=i : exit
	mov	local04, local07
	shl	local04, #4
	mov	arg02, objptr
	add	arg02, ##11676
	add	local04, arg02
	rdlong	arg01, local04
	mov	arg02, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local06, local07
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0990
LR__0991
' if  j=-1 andalso varnum<maxvars then   
	cmp	local06, ##-1 wz
 if_ne	jmp	#LR__0992
	add	objptr, ##28076
	rdlong	local08, objptr
	sub	objptr, ##28076
	cmps	local08, ##1024 wc
 if_ae	jmp	#LR__0992
	add	objptr, ##28076
	rdlong	local04, objptr
	shl	local04, #4
	sub	objptr, ##16400
	add	local04, objptr
	wrlong	local05, local04
	add	objptr, ##16400
	rdlong	local04, objptr
	shl	local04, #4
	sub	objptr, ##16400
	add	local04, objptr
	add	local04, #4
	wrlong	#0, local04
	add	objptr, ##16400
	rdlong	local04, objptr
	shl	local04, #4
	sub	objptr, ##16400
	add	local04, objptr
	add	local04, #12
	wrlong	#28, local04
	add	objptr, ##16400
	rdlong	local08, objptr
	mov	local06, local08
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##28076
LR__0992
	mov	local07, #0
' numpar=0
' if lparts(ct+1).token=token_lpar then								' check if it is an array
	add	objptr, ##29160
	rdlong	local04, objptr
	add	local04, #1
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #21 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0997
	add	objptr, ##29160
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##29160
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__0993
	add	objptr, ##29160
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
'     ct+=1  											': print "In getfun, ct=",ct,"lparts(ct).token=",lparts(ct).token, "part$=",lparts(ct).part$
'     if lparts(ct).token=token_lpar then ct+=1 : err=expr() : ct+=1 else err=expr()
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local09, local04
	cmp	local09, #21 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0994
	add	objptr, ##29160
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##29160
	call	#_expr
	mov	local10, result1
	add	objptr, ##29160
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##29160
	jmp	#LR__0995
LR__0994
	call	#_expr
	mov	local10, result1
LR__0995
'     if err>0 then return err
	cmps	local10, #1 wc
 if_ae	mov	result1, local10
 if_ae	jmp	#LR__0998
	add	local07, #1
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local10, local04
	cmp	local10, #20 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__0996
	add	objptr, ##29160
	rdlong	local10, objptr
	shl	local10, #3
	sub	objptr, ##1080
	add	local10, objptr
	add	local10, #4
	rdlong	local10, local10
	cmp	local10, #510 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__0993
LR__0996
'     if lparts(ct).token=token_end then return 14
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local10, local04
	cmp	local10, #510 wz
	sub	objptr, ##28080
 if_e	mov	result1, #14
 if_e	jmp	#LR__0998
LR__0997
	mov	local02, local07
	mov	local03, #18
	mov	local01, local06
	mov	local09, local01
	mov	local11, local02
	mov	local01, local03
	add	objptr, ##38944
	rdlong	local10, objptr
	mov	local07, local10
	shl	local07, #1
	add	local07, local10
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	wrlong	local09, local07
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local11, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #8
	wrlong	local01, local10
	add	objptr, ##1536
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##38944
' t2.result.twowords(1)=numpar
' t2.result_type=fun_getaddr:t2.result.twowords(0)=j
' compiledline(lineptr)=t2: lineptr+=1   ' if t2.result.uresult=-1, generate error
' return 0
	mov	result1, #0
LR__0998
	mov	ptra, fp
	call	#popregs_
_getaddr_ret
	ret

' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------------- 
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '------------------------------------------ The end of the precompiler  ----------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '
' '     			   	    COMPILE TIME EXPRESSION DECODER/EVALUATOR
' '
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' function expr() as ulong 
_expr
	mov	COUNT_, #7
	call	#pushregs_
_expr_enter
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' 
' op=lparts(ct).token : if op=token_end then t3.result.uresult=29 : t3.result_type=result_error : compiledline(lineptr)=t3 : lineptr+=1: return 29
	cmp	local05, #510 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__1000
	mov	local01, #29
	mov	local03, #255
	mov	local06, local01
	mov	local07, local02
	mov	local01, local03
	add	objptr, ##38944
	rdlong	local05, objptr
	mov	local04, local05
	shl	local04, #1
	add	local04, local05
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	local06, local04
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #4
	wrlong	local07, local05
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local01, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##38944
	mov	result1, #29
	jmp	#LR__1003
LR__1000
	mov	local01, #0
	call	#_addsub
' t3.result.uresult=0
' err=addsub()             			' call higher priority operator check. It will itself call muldiv, which then calls getval/getvar 
' if err>0 then return err
	cmp	result1, #1 wc
 if_ae	jmp	#LR__1003
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' op = lparts(ct).token				' Lowest priority : comparison operators
' do while (op = token_eq orelse op = token_gt orelse op = token_lt orelse op=token_ge orelse op=token_le orelse op=token_ne)
	sub	objptr, ##28080
LR__1001
	cmp	local05, #27 wz
 if_ne	cmp	local05, #15 wz
 if_ne	cmp	local05, #16 wz
 if_ne	cmp	local05, #39 wz
 if_ne	cmp	local05, #38 wz
 if_ne	cmp	local05, #42 wz
 if_ne	jmp	#LR__1002
	add	objptr, ##29160
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
	call	#_addsub
'   ct+=1
'   err=addsub() : if err>0 then return err
	cmp	result1, #1 wc
 if_ae	jmp	#LR__1003
	mov	local03, local05
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38944
	rdlong	local04, objptr
	mov	result1, local04
	shl	result1, #1
	add	result1, local04
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local06, result1
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local04, local06
	shl	local04, #1
	add	local04, local06
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local07, local04
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
	sub	objptr, ##28080
	jmp	#LR__1001
LR__1002
' return 0  
	mov	result1, #0
LR__1003
	mov	ptra, fp
	call	#popregs_
_expr_ret
	ret

' 
' ' Second level operators : add, sub, logic
' 
' function addsub() as ulong
_addsub
	mov	COUNT_, #7
	call	#pushregs_
_addsub_enter
	mov	local01, #0
	call	#_muldiv
' 
' t3.result.uresult=0
' err=muldiv() : if err>0 then return err           			 
	cmp	result1, #1 wc
 if_ae	jmp	#LR__1012
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' op = lparts(ct).token				 
' do while (op = token_plus orelse op = token_minus orelse op = token_and orelse op=token_or)
	sub	objptr, ##28080
LR__1010
	cmp	local05, #1 wz
 if_ne	cmp	local05, #2 wz
 if_ne	cmp	local05, #7 wz
 if_ne	cmp	local05, #3 wz
 if_ne	jmp	#LR__1011
	add	objptr, ##29160
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##29160
	call	#_muldiv
'   ct+=1
'   err=muldiv() : if err>0 then return err   
	cmp	result1, #1 wc
 if_ae	jmp	#LR__1012
	mov	local03, local05
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38944
	rdlong	local04, objptr
	mov	result1, local04
	shl	result1, #1
	add	result1, local04
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local06, result1
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local04, local06
	shl	local04, #1
	add	local04, local06
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local07, local04
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
	sub	objptr, ##28080
	jmp	#LR__1010
LR__1011
' return 0
	mov	result1, #0
LR__1012
	mov	ptra, fp
	call	#popregs_
_addsub_ret
	ret

' 
' ' Third level operators : mul,div,shift,power
' 
' function muldiv() as ulong
_muldiv
	mov	COUNT_, #7
	call	#pushregs_
_muldiv_enter
	mov	local01, #0
	call	#_getvalue
' 
' t3.result.uresult=0
' err=getvalue() : if err>0 then return err     
	cmp	result1, #1 wc
 if_ae	jmp	#LR__1022
	add	objptr, ##29160
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' op = lparts(ct).token
' do while (op = token_mul orelse op = token_div orelse op = token_fdiv orelse op=token_mod orelse op=token_shl orelse op=token_shr orelse op=token_power)
	sub	objptr, ##28080
LR__1020
	cmp	local05, #5 wz
 if_ne	cmp	local05, #8 wz
 if_ne	cmp	local05, #6 wz
 if_ne	cmp	local05, #9 wz
 if_ne	cmp	local05, #10 wz
 if_ne	cmp	local05, #11 wz
 if_ne	cmp	local05, #12 wz
 if_ne	jmp	#LR__1021
	add	objptr, ##29160
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##29160
	call	#_getvalue
'   ct+=1
'   err=getvalue() :if err>0 then return err   
	cmp	result1, #1 wc
 if_ae	jmp	#LR__1022
	mov	local03, local05
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38944
	rdlong	local04, objptr
	mov	result1, local04
	shl	result1, #1
	add	result1, local04
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local06, result1
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local04, local06
	shl	local04, #1
	add	local04, local06
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local07, local04
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
	sub	objptr, ##28080
	jmp	#LR__1020
LR__1021
' return 0
	mov	result1, #0
LR__1022
	mov	ptra, fp
	call	#popregs_
_muldiv_ret
	ret

' 
' ' Get a value for operations
' 
' function getvalue()  as ulong
_getvalue
	mov	COUNT_, #11
	call	#pushregs_
_getvalue_enter
	mov	local04, #1
	mov	local01, #0
	mov	local03, #29
	add	objptr, ##29160
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	local05, arg03
' 
' m=1											' for negative numbers
' t1.result.uresult=0: t1.result_type=result_uint
' op=lparts(ct).token
' if op=token_minus then m=-1: ct+=1 : op=lparts(ct).token				' '-' operator found
	cmp	local05, #2 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__1030
	neg	local04, #1
	add	objptr, ##29160
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local05, local05
	sub	objptr, ##28080
LR__1030
' select case op
	cmp	local05, ##512 wz
 if_e	jmp	#LR__1031
	cmp	local05, ##513 wz
 if_e	jmp	#LR__1034
	cmp	local05, ##514 wz
 if_e	jmp	#LR__1041
	cmp	local05, ##515 wz
 if_e	jmp	#LR__1044
	cmp	local05, #44 wz
 if_e	jmp	#LR__1049
	cmp	local05, ##516 wz
 if_e	jmp	#LR__1050
	cmp	local05, #21 wz
 if_e	jmp	#LR__1051
	jmp	#LR__1052
LR__1031
'     if m=1 then t1.result.uresult=m*val%(lparts(ct).part$): t1.result_type=result_int  
	cmp	local04, #1 wz
 if_ne	jmp	#LR__1032
	add	objptr, ##29160
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #0
	sub	objptr, ##28080
	call	#__system____builtin_atoi
	qmul	local04, result1
	getqx	local01
	mov	local03, #28
LR__1032
'     if m=-1 then t1.result.iresult=m*val%(lparts(ct).part$): t1.result_type=result_int 	' todo token_int64?
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__1033
	add	objptr, ##29160
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #0
	sub	objptr, ##28080
	call	#__system____builtin_atoi
	qmul	local04, result1
	getqx	local01
	mov	local03, #28
LR__1033
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38944
	rdlong	local01, objptr
	mov	local04, local01
	shl	local04, #1
	add	local04, local01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	local06, local04
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local01, local06
	shl	local01, #1
	add	local01, local06
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #4
	wrlong	local07, local01
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
	jmp	#LR__1053
LR__1034
'     if left$(lparts(ct).part$,1)="$" then lparts(ct).part$="&h"+right$(lparts(ct).part$,len(lparts(ct).part$)-1)
	add	objptr, ##29160
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	mov	arg02, #1
	sub	objptr, ##28080
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5938
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1037
	add	objptr, ##29160
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	mov	local05, ##@LR__5939
	shl	local07, #3
	add	local07, objptr
	rdlong	local07, local07
	add	objptr, ##1080
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	rdlong	arg01, local01
	sub	objptr, ##28080
	mov	local08, arg01
	callpa	#(@LR__1036-@LR__1035)>>2,fcache_load_ptr_
LR__1035
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__1035
LR__1036
	sub	local08, arg01
	mov	arg02, local08
	sub	arg02, #1
	mov	arg01, local07
	call	#__system__Right_S
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___string_concat
	wrlong	result1, local06
LR__1037
'     if left$(lparts(ct).part$,1)="%" then lparts(ct).part$="&b"+right$(lparts(ct).part$,len(lparts(ct).part$)-1)
	add	objptr, ##29160
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	mov	arg02, #1
	sub	objptr, ##28080
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5940
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1040
	add	objptr, ##29160
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	mov	local05, ##@LR__5941
	shl	local07, #3
	add	local07, objptr
	rdlong	local07, local07
	add	objptr, ##1080
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	rdlong	arg01, local01
	sub	objptr, ##28080
	mov	local08, arg01
	callpa	#(@LR__1039-@LR__1038)>>2,fcache_load_ptr_
LR__1038
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__1038
LR__1039
	sub	local08, arg01
	mov	arg02, local08
	sub	arg02, #1
	mov	arg01, local07
	call	#__system__Right_S
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___string_concat
	wrlong	result1, local06
LR__1040
	add	objptr, ##29160
	rdlong	local06, objptr
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #0
	sub	objptr, ##28080
	call	#__system____builtin_atoi
	qmul	local04, result1
	add	objptr, ##38944
	rdlong	local06, objptr
	mov	local09, local06
	shl	local09, #1
	add	local09, local06
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	objptr, ##1536
	getqx	local01
	mov	local03, #28
	mov	local06, local01
	mov	local07, local02
	wrlong	local06, local09
	mov	local09, local03
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #4
	wrlong	local07, local05
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local09, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
	jmp	#LR__1053
LR__1041
'     if m=1 then t1.result.fresult=1.0*val(lparts(ct).part$): t1.result_type=result_float  
	cmp	local04, #1 wz
 if_ne	jmp	#LR__1042
	mov	local06, ##1065353216
	add	objptr, ##29160
	rdlong	local09, objptr
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	rdlong	arg01, local09
	sub	objptr, ##28080
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	mov	local01, result1
	mov	local03, #30
LR__1042
'     if m=-1 then t1.result.fresult=-1.0*val(lparts(ct).part$): t1.result_type=result_float
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__1043
	mov	local06, ##-1082130432
	add	objptr, ##29160
	rdlong	local09, objptr
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	rdlong	arg01, local09
	sub	objptr, ##28080
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	mov	local01, result1
	mov	local03, #30
LR__1043
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38944
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local06, local09
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local06, local09
	shl	local06, #1
	add	local06, local09
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #4
	wrlong	local07, local06
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local07, local09
	shl	local07, #1
	add	local07, local09
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	add	local07, #8
	wrlong	local05, local07
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
	jmp	#LR__1053
LR__1044
	add	objptr, ##29160
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	sub	objptr, ##28080
	mov	local08, arg01
	callpa	#(@LR__1046-@LR__1045)>>2,fcache_load_ptr_
LR__1045
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__1045
LR__1046
	sub	local08, arg01
	mov	result1, local08
	add	objptr, ##43212
	wrlong	result1, objptr
	sub	objptr, #88
	rdlong	arg01, objptr
	sub	arg01, result1
	sub	arg01, #4
	andn	arg01, #3
	wrlong	arg01, objptr
	add	objptr, #88
	rdlong	arg02, objptr
	sub	objptr, ##43212
	call	#_pslpoke
'     pslpoke memtop,l
'     for i=1 to l : pspoke memtop+3+i, asc(mid$(lparts(ct).part$,i,1)) : next i
	mov	local10, #1
	add	objptr, ##43212
	rdlong	local11, objptr
	sub	objptr, ##43212
	add	local11, #1
LR__1047
	cmps	local10, local11 wc
 if_ae	jmp	#LR__1048
	add	objptr, ##43124
	rdlong	local07, objptr
	add	local07, #3
	add	local07, local10
	sub	objptr, ##13964
	rdlong	local09, objptr
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	rdlong	arg01, local09
	mov	arg02, local10
	mov	arg03, #1
	sub	objptr, ##28080
	call	#__system__Mid_S
	rdbyte	arg02, result1
	mov	arg01, local07
	call	#_pspoke
	add	local10, #1
	jmp	#LR__1047
LR__1048
	add	objptr, ##43124
	rdlong	local01, objptr
	mov	local03, #43
	mov	local06, local01
	mov	local07, local02
	mov	local11, local03
	sub	objptr, ##4180
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local06, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local07, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #8
	wrlong	local11, local09
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
	jmp	#LR__1053
LR__1049
	mov	local03, #44
	add	objptr, ##29160
	rdlong	local06, objptr
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #0
	sub	objptr, ##28080
	call	#__system____builtin_atoi
	mov	local01, result1
	mov	local06, local01
	mov	local07, local02
	mov	local11, local03
	add	objptr, ##38944
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local06, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local07, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #8
	wrlong	local11, local09
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
	jmp	#LR__1053
LR__1050
	mov	arg01, local04
	call	#_getvar
	add	objptr, ##29160
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
'     err=getvar(m) : ct+=1 : if err>0 then return err 
	cmps	result1, #1 wc
 if_ae	jmp	#LR__1054
	jmp	#LR__1053
LR__1051
	add	objptr, ##29160
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
	call	#_expr
'     ct+=1
'     err=expr() : if err>0 then return err 
	cmps	result1, #1 wc
 if_ae	jmp	#LR__1054
'     if lparts(ct).token=token_rpar then ct+=1
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local11, local11
	cmp	local11, #20 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__1053
	add	objptr, ##29160
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
	jmp	#LR__1053
LR__1052
	mov	arg01, local04
	call	#_getfun
	add	objptr, ##29160
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##29160
'     err=getfun(m) : ct+=1 : if err>0 then return err 
	cmps	result1, #1 wc
 if_ae	jmp	#LR__1054
LR__1053
' return 0  
	mov	result1, #0
LR__1054
	mov	ptra, fp
	call	#popregs_
_getvalue_ret
	ret

' 
' ' Get a function result 
' 
' function getfun(m as integer) as ulong
_getfun
	mov	COUNT_, #15
	call	#pushregs_
_getfun_enter
	mov	local04, arg01
	add	objptr, ##29160
	rdlong	local05, objptr
	mov	local06, local05
	mov	local07, #0
' oldct=ct
' numpar=0
' if lparts(ct+1).token=token_lpar then
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local05, local05
	cmp	local05, #21 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__1064
	add	objptr, ##29160
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##29160
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__1060
	add	objptr, ##29160
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
'     ct+=1  											': print "In getfun, ct=",ct,"lparts(ct).token=",lparts(ct).token, "part$=",lparts(ct).part$
'     if lparts(ct).token=token_lpar then ct+=1 : err=expr() : ct+=1 else err=expr()
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local08, local05
	cmp	local08, #21 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__1061
	add	objptr, ##29160
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##29160
	call	#_expr
	mov	local09, result1
	add	objptr, ##29160
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##29160
	jmp	#LR__1062
LR__1061
	call	#_expr
	mov	local09, result1
LR__1062
'     if err>0 then return err
	cmp	local09, #1 wc
 if_ae	mov	result1, local09
 if_ae	jmp	#LR__1066
	add	local07, #1
	add	objptr, ##29160
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local09, local05
	cmp	local09, #20 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__1063
	add	objptr, ##29160
	rdlong	local09, objptr
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	add	local09, #4
	rdlong	local09, local09
	cmp	local09, #510 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__1060
LR__1063
'   if lparts(ct).token=token_end then return 14
	add	objptr, ##29160
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local09, local05
	cmp	local09, #510 wz
	sub	objptr, ##28080
 if_e	mov	result1, #14
 if_e	jmp	#LR__1066
LR__1064
	mov	local01, local07
	shl	local06, #3
	add	objptr, ##28080
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local08, local01
	mov	local10, local02
	mov	local11, local03
	add	objptr, ##10864
	rdlong	local12, objptr
	mov	local13, local12
	shl	local13, #1
	add	local13, local12
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	wrlong	local08, local13
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local14, local08
	shl	local14, #1
	add	local14, local08
	shl	local14, #2
	sub	objptr, ##1536
	add	local14, objptr
	add	local14, #4
	wrlong	local10, local14
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local15, local08
	shl	local15, #1
	add	local15, local08
	shl	local15, #2
	sub	objptr, ##1536
	add	local15, objptr
	add	local15, #8
	wrlong	local11, local15
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##38944
' t2.result.uresult=numpar
' t2.result_type=lparts(oldct).token  ' todo here: expression lists..... 
' compiledline(lineptr)=t2: lineptr+=1   ' if t2.result.uresult=-1, generate error
' if m=-1 then t2.result_type=fun_negative: compiledline(lineptr)=t2: lineptr+=1
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__1065
	mov	local03, #21
	mov	local08, local01
	mov	local10, local02
	mov	local11, local03
	add	objptr, ##38944
	rdlong	local12, objptr
	mov	local13, local12
	shl	local13, #1
	add	local13, local12
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	wrlong	local08, local13
	add	objptr, ##1536
	rdlong	local15, objptr
	mov	local14, local15
	shl	local14, #1
	add	local14, local15
	shl	local14, #2
	sub	objptr, ##1536
	add	local14, objptr
	add	local14, #4
	wrlong	local10, local14
	add	objptr, ##1536
	rdlong	local14, objptr
	mov	local15, local14
	shl	local15, #1
	add	local15, local14
	shl	local15, #2
	sub	objptr, ##1536
	add	local15, objptr
	add	local15, #8
	wrlong	local11, local15
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##38944
LR__1065
' return 0
	mov	result1, #0
LR__1066
	mov	ptra, fp
	call	#popregs_
_getfun_ret
	ret

'   
'   
' function getvar(m as integer) as ulong
_getvar
	mov	COUNT_, #17
	call	#pushregs_
_getvar_enter
	mov	local04, arg01
	add	objptr, ##29160
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	local06, local05
	neg	local07, #1
' 
' varname$=lparts(ct).part$
' j=-1
' 
' for i=0 to varnum-1
	mov	local08, #0
	sub	objptr, #4
	rdlong	local09, objptr
	sub	objptr, ##28076
LR__1070
	cmps	local08, local09 wc
 if_ae	jmp	#LR__1071
'   if variables(i).name=varname$ then j=i : exit
	mov	local05, local08
	shl	local05, #4
	mov	arg02, objptr
	add	arg02, ##11676
	add	local05, arg02
	rdlong	arg01, local05
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local07, local08
 if_ne	add	local08, #1
 if_ne	jmp	#LR__1070
LR__1071
' if  j=-1 andalso varnum<maxvars then   
	cmp	local07, ##-1 wz
 if_ne	jmp	#LR__1072
	add	objptr, ##28076
	rdlong	local09, objptr
	sub	objptr, ##28076
	cmps	local09, ##1024 wc
 if_ae	jmp	#LR__1072
	add	objptr, ##28076
	rdlong	local05, objptr
	shl	local05, #4
	sub	objptr, ##16400
	add	local05, objptr
	wrlong	local06, local05
	add	objptr, ##16400
	rdlong	local05, objptr
	shl	local05, #4
	sub	objptr, ##16400
	add	local05, objptr
	add	local05, #4
	wrlong	#0, local05
	add	objptr, ##16400
	rdlong	local05, objptr
	shl	local05, #4
	sub	objptr, ##16400
	add	local05, objptr
	add	local05, #12
	wrlong	#28, local05
	add	objptr, ##16400
	rdlong	local09, objptr
	mov	local07, local09
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##28076
LR__1072
	mov	local08, #0
' numpar=0
' if lparts(ct+1).token=token_lpar then								' check if it is an array
	add	objptr, ##29160
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local09, local05
	cmp	local09, #21 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__1077
	add	objptr, ##29160
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##29160
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__1073
	add	objptr, ##29160
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
'     ct+=1  											': print "In getfun, ct=",ct,"lparts(ct).token=",lparts(ct).token, "part$=",lparts(ct).part$
'     if lparts(ct).token=token_lpar then ct+=1 : err=expr() : ct+=1 else err=expr()
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local10, local05
	cmp	local10, #21 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__1074
	add	objptr, ##29160
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##29160
	call	#_expr
	mov	local11, result1
	add	objptr, ##29160
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##29160
	jmp	#LR__1075
LR__1074
	call	#_expr
	mov	local11, result1
LR__1075
'     if err>0 then return err
	cmps	local11, #1 wc
 if_ae	mov	result1, local11
 if_ae	jmp	#LR__1079
	add	local08, #1
	add	objptr, ##29160
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local11, local05
	cmp	local11, #20 wz
	sub	objptr, ##28080
 if_e	jmp	#LR__1076
	add	objptr, ##29160
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local11, local11
	cmp	local11, #510 wz
	sub	objptr, ##28080
 if_ne	jmp	#LR__1073
LR__1076
'     if lparts(ct).token=token_end then return 14
	add	objptr, ##29160
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local11, local05
	cmp	local11, #510 wz
	sub	objptr, ##28080
 if_e	mov	result1, #14
 if_e	jmp	#LR__1079
LR__1077
	mov	local02, local08
	mov	local03, #17
	mov	local01, local07
	mov	local10, local01
	mov	local12, local02
	mov	local13, local03
	add	objptr, ##38944
	rdlong	local14, objptr
	mov	local15, local14
	shl	local15, #1
	add	local15, local14
	shl	local15, #2
	sub	objptr, ##1536
	add	local15, objptr
	wrlong	local10, local15
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local16, local10
	shl	local16, #1
	add	local16, local10
	shl	local16, #2
	sub	objptr, ##1536
	add	local16, objptr
	add	local16, #4
	wrlong	local12, local16
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local17, local10
	shl	local17, #1
	add	local17, local10
	shl	local17, #2
	sub	objptr, ##1536
	add	local17, objptr
	add	local17, #8
	wrlong	local13, local17
	add	objptr, ##1536
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##38944
' t2.result.twowords(1)=numpar
' t2.result_type=fun_getvar:t2.result.twowords(0)=j
' compiledline(lineptr)=t2: lineptr+=1   ' if t2.result.uresult=-1, generate error
' if m=-1 then t2.result_type=fun_negative: compiledline(lineptr)=t2: lineptr+=1
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__1078
	mov	local03, #21
	mov	local10, local01
	mov	local12, local02
	mov	local13, local03
	add	objptr, ##38944
	rdlong	local14, objptr
	mov	local15, local14
	shl	local15, #1
	add	local15, local14
	shl	local15, #2
	sub	objptr, ##1536
	add	local15, objptr
	wrlong	local10, local15
	add	objptr, ##1536
	rdlong	local17, objptr
	mov	local16, local17
	shl	local16, #1
	add	local16, local17
	shl	local16, #2
	sub	objptr, ##1536
	add	local16, objptr
	add	local16, #4
	wrlong	local12, local16
	add	objptr, ##1536
	rdlong	local16, objptr
	mov	local17, local16
	shl	local17, #1
	add	local17, local16
	shl	local17, #2
	sub	objptr, ##1536
	add	local17, objptr
	add	local17, #8
	wrlong	local13, local17
	add	objptr, ##1536
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##38944
LR__1078
' return 0
	mov	result1, #0
LR__1079
	mov	ptra, fp
	call	#popregs_
_getvar_ret
	ret

' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------------- End of expression evaluator --------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '                                                                                                                                       -
' '                                              RUNTIME STARTS HERE                                                                      - 
' '                                                                                                                                       -
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '----------------------------------------- A main execute line function ----------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' function execute_line (astart=0 as integer) as integer
_execute_line
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, ##42080
	wrlong	#0, objptr
' 
' runptr2=0
' for lineptr_e=astart to lineptr-1
	sub	objptr, ##3132
	wrlong	arg01, objptr
	sub	objptr, #4
	rdlong	local01, objptr
	sub	objptr, ##38944
LR__1080
	add	objptr, ##38948
	rdlong	result1, objptr
	sub	objptr, ##38948
	cmps	result1, local01 wc
 if_ae	jmp	#LR__1081
	add	objptr, ##38948
	rdlong	result1, objptr
	mov	local02, result1
	shl	local02, #1
	add	local02, result1
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	local02, #8
	rdlong	local02, local02
	getbyte	local02, local02, #0
	shl	local02, #2
	sub	objptr, ##2076
	add	local02, objptr
	rdlong	local02, local02
	mov	local03, local02
	zerox	local02, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	sub	objptr, ##35332
	mov	local04, objptr
	mov	objptr, local02
	call	local03
	mov	objptr, local04
	add	objptr, ##38948
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##38948
	jmp	#LR__1080
LR__1081
' return runptr2
	add	objptr, ##42080
	rdlong	result1, objptr
	sub	objptr, ##42080
	mov	ptra, fp
	call	#popregs_
_execute_line_ret
	ret

' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Runtime helper functions -----------------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' ' ------------------- pop and push functions called by do_xxx functions to pop arguments and push results
' 
' function pop() as expr_result
_pop
' if stackpointer=0 then
	add	objptr, ##35324
	rdlong	result1, objptr wz
	sub	objptr, ##35324
 if_e	mov	_var03, #255
 if_e	mov	_var01, #24
 if_e	jmp	#LR__1090
	add	objptr, ##35324
	rdlong	result1, objptr
	sub	result1, #1
	wrlong	result1, objptr
	mov	result3, result1
	shl	result3, #1
	add	result3, result1
	shl	result3, #2
	sub	objptr, ##6156
	add	result3, objptr
	rdlong	_var01, result3
	add	result3, #4
	rdlong	_var02, result3
	mov	result2, result1
	shl	result2, #1
	add	result2, result1
	shl	result2, #2
	add	result2, objptr
	add	result2, #8
	rdlong	_var03, result2
	sub	objptr, ##29168
LR__1090
' return t1
	mov	result2, _var02
	mov	result3, _var03
	mov	result1, _var01
_pop_ret
	ret

' 
' sub push(t1 as expr_result )
_push
' if stackpointer<maxstack then 
	add	objptr, ##35324
	rdlong	_var01, objptr
	sub	objptr, ##35324
	cmps	_var01, ##512 wc
 if_ae	jmp	#LR__1100
	rdlong	_var01, arg01
	add	arg01, #4
	rdlong	_var02, arg01
	add	arg01, #4
	rdlong	arg01, arg01
	add	objptr, ##35324
	rdlong	_var03, objptr
	mov	_var04, _var03
	shl	_var04, #1
	add	_var04, _var03
	shl	_var04, #2
	sub	objptr, ##6156
	add	_var04, objptr
	wrlong	_var01, _var04
	add	objptr, ##6156
	rdlong	_var04, objptr
	mov	_var03, _var04
	shl	_var03, #1
	add	_var03, _var04
	shl	_var03, #2
	sub	objptr, ##6156
	add	_var03, objptr
	add	_var03, #4
	wrlong	_var02, _var03
	add	objptr, ##6156
	rdlong	_var04, objptr
	mov	_var03, _var04
	shl	_var03, #1
	add	_var03, _var04
	shl	_var03, #2
	sub	objptr, ##6156
	add	_var03, objptr
	add	_var03, #8
	wrlong	arg01, _var03
	add	objptr, ##6156
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##35324
LR__1100
_push_ret
	ret

' 
' ' -------------------------------- Runtime converting functions
' 
' ' converts the PSRAM based string to 'normal' string. A PSRAM pointer at input, a string at output
' 
' function  convertstring(psaddr as ulong) as string
_convertstring
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	call	#_pslpeek
	mov	local02, result1
	mov	local03, ##@LR__5942
' l=pslpeek(psaddr) 
' s="" 
' for i=1 to l : s+=chr$(pspeek(psaddr+3+i)) :next i
	mov	local04, #1
	add	local02, #1
LR__1110
	cmps	local04, local02 wc
 if_ae	jmp	#LR__1111
	mov	arg01, local01
	add	arg01, #3
	add	arg01, local04
	call	#_pspeek
	getbyte	arg01, result1, #0
	call	#__system__Chr_S
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___string_concat
	mov	local03, result1
	add	local04, #1
	jmp	#LR__1110
LR__1111
' return s
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_convertstring_ret
	ret

' 
' ' converts a variable to an integer
' 
' function converttoint (t1 as expr_result) as integer 
_converttoint
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' 
' select case t1.result_type
	add	local01, #8
	rdlong	local02, local01
	sub	local01, #8
	cmp	local02, #28 wz
 if_e	jmp	#LR__1120
	cmp	local02, #29 wz
 if_e	jmp	#LR__1121
	cmp	local02, #30 wz
 if_e	jmp	#LR__1122
	cmp	local02, #31 wz
 if_e	jmp	#LR__1123
	cmp	local02, #43 wz
 if_e	jmp	#LR__1124
	cmp	local02, #44 wz
 if_e	jmp	#LR__1125
	jmp	#LR__1126
LR__1120
	rdlong	result1, local01
	jmp	#LR__1127
LR__1121
	rdlong	result1, local01
	jmp	#LR__1127
LR__1122
	rdlong	arg01, local01
	mov	arg02, #1
	call	#__system___float_tointeger
	jmp	#LR__1127
LR__1123
	rdlong	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	jmp	#LR__1127
LR__1124
	rdlong	arg01, local01
	call	#_convertstring
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	jmp	#LR__1127
LR__1125
	rdlong	result1, local01
	jmp	#LR__1127
LR__1126
	mov	result1, #0
LR__1127
	mov	ptra, fp
	call	#popregs_
_converttoint_ret
	ret

' 
' ' converts a variable to float
' 
' function converttofloat (t1 as expr_result) as single
_converttofloat
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' select case t1.result_type
	add	local01, #8
	rdlong	local02, local01
	sub	local01, #8
	cmp	local02, #28 wz
 if_e	jmp	#LR__1130
	cmp	local02, #29 wz
 if_e	jmp	#LR__1131
	cmp	local02, #30 wz
 if_e	jmp	#LR__1132
	cmp	local02, #31 wz
 if_e	jmp	#LR__1133
	cmp	local02, #43 wz
 if_e	jmp	#LR__1134
	jmp	#LR__1135
LR__1130
	rdlong	arg01, local01
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	jmp	#LR__1136
LR__1131
	rdlong	arg01, local01
	call	#__system___float_fromuns
	jmp	#LR__1136
LR__1132
	rdlong	result1, local01
	jmp	#LR__1136
LR__1133
	rdlong	arg01, local01
	call	#__system____builtin_atof
	jmp	#LR__1136
LR__1134
	rdlong	arg01, local01
	call	#_convertstring
	mov	arg01, result1
	call	#__system____builtin_atof
	jmp	#LR__1136
LR__1135
	mov	result1, #0
LR__1136
	mov	ptra, fp
	call	#popregs_
_converttofloat_ret
	ret

' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '----- End of cassette procedures -------------------------------------------------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Runtime functions ------------------------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' '-------------------- abs
' 
' sub do_abs
_do_abs
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
' 
' t1=pop()
' if t1.result_type=result_int then 
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	rdlong	arg01, fp
 if_e	abs	local01, arg01
 if_e	wrlong	local01, fp
 if_e	jmp	#LR__1140
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	rdlong	result1, fp
 if_e	bitl	result1, #31
 if_e	wrlong	result1, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	wrlong	#40, fp
LR__1140
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_abs_ret
	ret

' 
' '-------------------- acos
' 
' sub do_acos
_do_acos
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "acos: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__1150
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5943
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1151
LR__1150
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	call	#__system____builtin_acosf
	mov	arg01, result1
	add	objptr, ##43144
	rdlong	arg02, objptr
	sub	objptr, ##43144
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1151
	mov	ptra, fp
	call	#popregs_
_do_acos_ret
	ret

' 
' '-------------------- asc
' 
' sub do_asc
_do_asc
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "asc: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__1160
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5944
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1163
LR__1160
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1161
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1161
' if t1.result_type<>result_string then print "asc: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1162
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5945
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1163
LR__1162
	rdlong	result2, fp
	rdbyte	result2, result2
	wrlong	result2, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1163
	mov	ptra, fp
	call	#popregs_
_do_asc_ret
	ret

' 
' '-------------------- asin
' 
' sub do_asin
_do_asin
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "asin: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__1170
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5946
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1171
LR__1170
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	call	#__system____builtin_asinf
	mov	arg01, result1
	add	objptr, ##43144
	rdlong	arg02, objptr
	sub	objptr, ##43144
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1171
	mov	ptra, fp
	call	#popregs_
_do_asin_ret
	ret

' 
' '-------------------- atn
' 
' sub do_atn
_do_atn
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "atn: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__1180
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5947
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1181
LR__1180
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	mov	arg02, ##1065353216
	call	#__system____builtin_atan2f
	mov	arg01, result1
	add	objptr, ##43144
	rdlong	arg02, objptr
	sub	objptr, ##43144
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1181
	mov	ptra, fp
	call	#popregs_
_do_atn_ret
	ret

' 
' '-------------------- beep
' 
' sub do_beep
_do_beep
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #28
	call	#_pop
	mov	arg07, result1
	mov	arg06, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg07, fp
	add	fp, #4
	wrlong	arg06, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' 
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) then freq=t1.result.iresult else freq=converttoint(t1)
	mov	arg07, result3
	sub	fp, #8
	cmp	arg07, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_e	rdlong	local02, fp
 if_e	jmp	#LR__1190
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
LR__1190
	mov	arg02, objptr
	add	arg02, ##11416
	mov	arg01, #7
	mov	arg03, local02
	decod	arg04, #12
	mov	arg05, #8
	mov	arg06, #0
	mov	arg07, #0
	add	objptr, ##5836
	call	#_Audio2_004_spin2_beep
	sub	objptr, ##5836
	mov	arg01, fp
	add	arg01, #12
	call	#_push
	call	#_do_waitms
	add	objptr, ##5836
' 
' base2:=@channel0[0]+64*channel
	mov	local02, objptr
' word[base2+32]:=0
	add	local02, #492
	wrword	#0, local02
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_do_beep_ret
	ret

' 
' '-------------------- blit
' 
' ' blit buf1,x1,y1,x2,y2,s1,buf2,x2,y2,s2
' sub do_blit
_do_blit
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #60
	add	objptr, ##38948
	rdlong	arg10, objptr
	mov	arg09, arg10
	shl	arg09, #1
	add	arg09, arg10
	shl	arg09, #2
	sub	objptr, ##1540
	add	arg09, objptr
	rdlong	local01, arg09
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>10 andalso numpar<>6 then print "blit: "; : printerror (39,runheader(0)) : return
	cmp	local01, #10 wz
	sub	objptr, ##37408
 if_ne	cmp	local01, #6 wz
 if_e	jmp	#LR__1200
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5948
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1205
LR__1200
' for i=numpar-1 to 0 step -1: t1=pop() : p(i)=converttoint(t1): next i
	mov	local02, local01
	sub	local02, #1
LR__1201
	mov	arg10, local01
	sub	arg10, #1
	cmp	local02, arg10 wcz
 if_a	jmp	#LR__1202
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	mov	local03, local02
	shl	local03, #2
	add	fp, #4
	add	local03, fp
	sub	fp, #12
	mov	arg01, fp
	call	#_converttoint
	wrlong	result1, local03
	sub	local02, #1
	jmp	#LR__1201
LR__1202
' if numpar=10 then 
	cmp	local01, #10 wz
 if_ne	jmp	#LR__1203
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg05, fp
	add	fp, #4
	rdlong	arg06, fp
	add	fp, #4
	rdlong	arg07, fp
	add	fp, #4
	rdlong	arg08, fp
	add	fp, #4
	rdlong	arg09, fp
	add	fp, #4
	rdlong	arg10, fp
	sub	fp, #48
	call	#_Hg010b_4_spin2_blit
	jmp	#LR__1204
LR__1203
	rdlong	arg07, objptr
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg05, fp
	add	fp, #4
	rdlong	arg08, fp
	add	fp, #4
	rdlong	arg09, fp
	sub	fp, #32
	mov	arg01, arg07
	decod	arg06, #10
	decod	arg10, #10
	call	#_Hg010b_4_spin2_blit
LR__1204
LR__1205
	mov	ptra, fp
	call	#popregs_
_do_blit_ret
	ret

' 
' 
' '-------------------- bin$
' 
' sub do_bin
_do_bin
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	local01, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>2 orelse numpar=0 then print "bin$: "; : printerror(39) : return
	cmp	local01, #3 wc
	sub	objptr, ##37408
 if_b	cmp	local01, #0 wz
 if_c_and_nz	jmp	#LR__1210
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5949
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1213
LR__1210
' if numpar=2 then t1=pop() : num=converttoint(t1) else num=0
	cmp	local01, #2 wz
 if_ne	jmp	#LR__1211
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
	jmp	#LR__1212
LR__1211
	mov	local02, #0
LR__1212
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
	mov	arg02, local02
	mov	arg03, #2
	call	#__system__Number_S
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1213
	mov	ptra, fp
	call	#popregs_
_do_bin_ret
	ret

' 
' '-------------------- box
' 
' sub do_box
_do_box
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #36
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #44
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #24
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #32
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t4=pop()
' t3=pop()
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) andalso (t2.result_type=result_int orelse t2.result_type=result_uint) andalso (t3.result_type=result_int orelse t3.result_type=result_uint) andalso (t4.result_type=result_int orelse t4.result_type=result_uint) then
	mov	arg05, result3
	sub	fp, #8
	cmp	arg05, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1220
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #28 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1220
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, #28 wz
 if_ne	add	fp, #32
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #32
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1220
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #44
	cmp	local01, #28 wz
 if_ne	add	fp, #44
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #44
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1220
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #12
	rdlong	arg03, fp
	add	fp, #12
	rdlong	arg04, fp
	sub	fp, #36
	add	objptr, ##29132
	rdlong	arg05, objptr
	sub	objptr, ##29132
	call	#_Hg010b_4_spin2_box
'    v.box(t1.result.iresult,t2.result.iresult,t3.result.iresult,t4.result.iresult,plot_color) : return
	jmp	#LR__1221
LR__1220
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	local03, result1
	mov	arg01, fp
	add	arg01, #24
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #36
	call	#_converttoint
	mov	arg04, result1
	add	objptr, ##29132
	rdlong	arg05, objptr
	sub	objptr, ##29132
	mov	arg01, local02
	mov	arg02, local03
	mov	arg03, local01
	call	#_Hg010b_4_spin2_box
LR__1221
	mov	ptra, fp
	call	#popregs_
_do_box_ret
	ret

' 
' '-------------------- brun
' 
' sub do_brun
_do_brun
	mov	COUNT_, #8
	call	#pushregs_
	call	#_pop
	mov	arg05, result2
	mov	arg04, result3
	mov	local01, result1
	mov	local02, arg05
	mov	local03, arg04
' 
' t1=pop() 
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult): t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1230
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1230
' if t1.result_type=result_string then
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1234
	mov	local04, local01
'   filename=t1.result.sresult
'   if left$(filename,1)="/" then 
	mov	arg01, local04
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5950
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local05, local04
 if_e	jmp	#LR__1231
	mov	arg01, ##@LR__5951
	mov	arg02, local04
	call	#__system___string_concat
	mov	local05, result1
LR__1231
'   open fullfilename for input as #9
	mov	arg01, #9
	mov	arg02, local05
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'   r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return
 if_e	jmp	#LR__1232
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5952
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5953
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, local06
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1235
LR__1232
	mov	local07, #1
	mov	local08, #0
'   do
LR__1233
'     get #9,pos,block(0),1024,r : pos+=r	
	mov	arg03, objptr
	add	arg03, ##41048
	mov	arg01, #9
	mov	arg02, local07
	decod	arg04, #10
	mov	arg05, #1
	call	#__system___basic_get
	mov	local06, result1
	add	local07, result1
	mov	arg01, objptr
	add	arg01, ##41048
	mov	arg02, local08
	decod	arg03, #10
	add	objptr, ##5836
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	add	local08, local06
	cmp	local06, ##1024 wz
 if_e	cmps	local08, ##507904 wc
 if_c_and_z	jmp	#LR__1233
	add	objptr, ##29088
	rdlong	arg01, objptr
	cogstop	arg01
	add	objptr, #4
	rdlong	arg01, objptr
	cogstop	arg01
	add	objptr, #4
	rdlong	arg01, objptr
	cogstop	arg01
	add	objptr, ##13116
	rdlong	arg01, objptr
	sub	objptr, ##42212
	cogstop	arg01
	mov	arg02, ptr__dat__
	add	arg02, ##12492
	mov	arg03, objptr
	add	arg03, ##29104
	mov	local08, #30
	setq	arg03
	coginit	local08, arg02 wc
 if_b	neg	local08, #1
	add	objptr, ##43252
	wrlong	local08, objptr
	sub	objptr, ##43252
	mov	arg01, #0
	cogid	arg01
	cogstop	arg01
LR__1234
LR__1235
	mov	ptra, fp
	call	#popregs_
_do_brun_ret
	ret

' 
' '-------------------- cd
' 
' sub do_cd
_do_cd
	mov	COUNT_, #6
	call	#pushregs_
	mov	arg01, ##@LR__5954
	mov	arg02, #49
	call	#__system___basic_dir
	call	#_pop
	mov	arg04, result2
	mov	arg03, result3
	mov	local01, result1
	mov	local02, arg04
	mov	local03, arg03
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1240
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1240
' if t1.result_type<>result_string then printerror(15): return
	cmp	local03, #31 wz
 if_e	jmp	#LR__1241
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1259
LR__1241
	mov	local04, local01
' newdir$=t1.result.sresult
' if newdir$=".." then 
	mov	arg02, ##@LR__5955
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1248
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	local05, arg01
	callpa	#(@LR__1243-@LR__1242)>>2,fcache_load_ptr_
LR__1242
	rdbyte	result1, local05 wz
 if_ne	add	local05, #1
 if_ne	jmp	#LR__1242
LR__1243
	subr	arg01, local05
	add	objptr, ##38968
	rdlong	arg02, objptr
	sub	objptr, ##38968
	mov	arg03, ##@LR__5956
	call	#__system__InstrRev
	mov	local04, result1
'   if slash>1 then newdir$=left$(currentdir$,slash-1) else newdir$="/"
	cmps	local04, #2 wc
 if_b	jmp	#LR__1244
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	sub	local04, #1
	mov	arg02, local04
	call	#__system__Left_S
	mov	local04, result1
	jmp	#LR__1245
LR__1244
	mov	local04, ##@LR__5957
LR__1245
	mov	arg01, local04
	call	#__system___chdir
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'   chdir newdir$
'   err=geterr() : if err<>0 andalso err<>5 then print "System error ";err;": " ;errors$(53) : chdir(currentdir$) else currentdir$=newdir$
 if_ne	cmp	local06, #5 wz
 if_e	jmp	#LR__1246
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5958
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5959
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##36596
	rdlong	arg02, objptr
	sub	objptr, ##36596
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	call	#__system___chdir
	jmp	#LR__1247
LR__1246
	add	objptr, ##38968
	wrlong	local04, objptr
	sub	objptr, ##38968
LR__1247
'   print "Current directory: ";currentdir$
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5960
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##38968
	rdlong	arg02, objptr
	sub	objptr, ##38968
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
'   return
	jmp	#LR__1259
LR__1248
' if left$(newdir$,1)="/" then 
	mov	arg01, local04
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5961
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1251
	mov	arg01, local04
	call	#__system___chdir
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'   chdir(newdir$)
'   err=geterr() : if err<>0 andalso err<>5 then print "System error ";err;": " ;errors$(53) : chdir(currentdir$) else currentdir$=newdir$
 if_ne	cmp	local06, #5 wz
 if_e	jmp	#LR__1249
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5962
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5963
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##36596
	rdlong	arg02, objptr
	sub	objptr, ##36596
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	call	#__system___chdir
	jmp	#LR__1250
LR__1249
	add	objptr, ##38968
	wrlong	local04, objptr
	sub	objptr, ##38968
LR__1250
'   print "Current directory: ";currentdir$
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5964
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##38968
	rdlong	arg02, objptr
	sub	objptr, ##38968
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
'   return
	jmp	#LR__1259
LR__1251
'   if currentdir$<>"/" then newdir$=currentdir$+"/"+newdir$ else newdir$=currentdir$+newdir$ 
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__5965
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1252
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__5966
	call	#__system___string_concat
	mov	arg01, result1
	mov	arg02, local04
	call	#__system___string_concat
	mov	local04, result1
	jmp	#LR__1253
LR__1252
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, local04
	call	#__system___string_concat
	mov	local04, result1
LR__1253
'   if right$(newdir$,1)="/" then newdir$=left$(newdir$,len(newdir$)-1)
	mov	arg01, local04
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5967
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1256
	mov	arg01, local04
	mov	local05, arg01
	callpa	#(@LR__1255-@LR__1254)>>2,fcache_load_ptr_
LR__1254
	rdbyte	result1, local05 wz
 if_ne	add	local05, #1
 if_ne	jmp	#LR__1254
LR__1255
	sub	local05, arg01
	mov	arg02, local05
	sub	arg02, #1
	mov	arg01, local04
	call	#__system__Left_S
	mov	local04, result1
LR__1256
	mov	arg01, local04
	call	#__system___chdir
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'   chdir(newdir$)
'   err=geterr() : if err<>0 andalso err<>5 then print "System error ";err;": " ;errors$(53) : chdir(currentdir$) else currentdir$=newdir$
 if_ne	cmp	local06, #5 wz
 if_e	jmp	#LR__1257
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5968
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5969
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##36596
	rdlong	arg02, objptr
	sub	objptr, ##36596
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	call	#__system___chdir
	jmp	#LR__1258
LR__1257
	add	objptr, ##38968
	wrlong	local04, objptr
	sub	objptr, ##38968
LR__1258
'   print "Current directory: ";currentdir$
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5970
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##38968
	rdlong	arg02, objptr
	sub	objptr, ##38968
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__1259
	mov	ptra, fp
	call	#popregs_
_do_cd_ret
	ret

' 
' '-------------------- changefreq
' 
' sub do_changefreq
_do_changefreq
	mov	COUNT_, #10
	call	#pushregs_
	add	ptra, #44
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	local01, result1
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	local02, result1 wc
	and	local02, #7
	negc	local02, local02
	mov	arg02, local02
	shl	arg02, #3
	sub	arg02, local02
	shl	arg02, #2
	mov	arg01, objptr
	add	arg01, ##11452
	add	arg02, arg01
	add	arg02, #22
	rdword	local03, arg02
' amode=channels(channel).amode
' if amode>0 then
	cmps	local03, #1 wc
 if_b	jmp	#LR__1262
	mov	arg02, local01
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	mov	local04, result1
	decod	arg02, #30
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local05, result1
	decod	local04, #30
	mov	arg01, local05
	add	arg01, local03
	abs	arg01, arg01 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	arg02, result1
	mov	arg01, local04
	call	#__system____builtin_powf
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local07, result1
'   skip=round(2^(lfreq+amode))                     '''' this const + const 2 lines lower=18
'   if skip>32768 then i=skip/32768: skip=32768 else i=1
	cmps	local07, ##32769 wc
 if_b	jmp	#LR__1260
	abs	local08, local07 wc
	shr	local08, #15
	negc	local08, local08
	decod	local07, #15
	jmp	#LR__1261
LR__1260
	mov	local08, #1
LR__1261
	mov	arg01, ##1247237376
	mov	arg02, local01
	call	#__system___float_div
	mov	local04, result1
	abs	arg01, local08 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	local08, result1
	decod	local09, #30
	mov	arg01, #18
	sub	arg01, local03
	sub	arg01, local05
	abs	arg01, arg01 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	arg02, result1
	mov	arg01, local09
	call	#__system____builtin_powf
	mov	arg02, result1
	mov	arg01, local08
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local10, result1
	mov	local09, local02
	shl	local09, #3
	sub	local09, local02
	shl	local09, #2
	mov	local08, objptr
	add	local08, ##11452
	add	local09, local08
	mov	local08, ##1247237376
	abs	arg01, local10 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	arg02, result1
	mov	arg01, local08
	call	#__system___float_div
	mov	local08, result1
	abs	arg01, local07 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	arg01, result1
	mov	arg02, ##1216348160
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local08
	call	#__system___float_mul
	add	local09, #24
	wrlong	result1, local09
	jmp	#LR__1263
LR__1262
	mov	local10, #24
	mov	local04, ##1216348160
	mov	arg01, local01
	mov	arg02, ##1208978944
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local07, result1
	mov	local09, local02
	shl	local09, #3
	sub	local09, local02
	shl	local09, #2
	mov	local08, objptr
	add	local08, ##11452
	add	local09, local08
	mov	local08, ##1247237376
	abs	arg01, local10 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	arg02, result1
	mov	arg01, local08
	call	#__system___float_div
	mov	local08, result1
	abs	arg01, local07 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	arg01, result1
	mov	arg02, ##1216348160
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local08
	call	#__system___float_mul
	add	local09, #24
	wrlong	result1, local09
LR__1263
	shl	local07, #16
	add	local07, local10
' if (lpeek(base+64*channel+8) and $0800_0000)=0 then 
	add	objptr, ##29108
	rdlong	arg01, objptr
	sub	objptr, ##29108
	mov	local10, local02
	shl	local10, #6
	add	arg01, local10
	add	arg01, #8
	rdlong	result1, arg01
	testbn	result1, #27 wz
 if_ne	jmp	#LR__1264
	add	objptr, ##29108
	rdlong	arg01, objptr
	sub	objptr, ##29108
	shl	local02, #6
	add	arg01, local02
	add	arg01, #24
	wrlong	local07, arg01
	jmp	#LR__1265
LR__1264
	add	objptr, ##29108
	rdlong	local04, objptr
	sub	objptr, ##29108
	mov	local10, local02
	shl	local10, #6
	add	local04, local10
	add	local04, #24
	mov	arg01, ##1247312956
	mov	arg02, local01
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local04
	add	objptr, ##29108
	rdlong	arg01, objptr
	sub	objptr, ##29108
	shl	local02, #6
	add	arg01, local02
	add	arg01, #26
	wrword	#256, arg01
LR__1265
	mov	ptra, fp
	call	#popregs_
_do_changefreq_ret
	ret

' 
' '-------------------- changepan
' 
' sub do_changepan
_do_changepan
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	local01, ##1174405120
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local01, result1
	decod	local02, #13
	add	local02, local01
' 
' t1=pop()
' pan=8192+round(8192*converttofloat(t1)) 
' if pan<0 then pan=0
	cmps	local02, #0 wc
 if_b	mov	local02, #0
' if pan>16384 then pan=16384
	cmps	local02, ##16385 wc
 if_ae	decod	local02, #14
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	local01, result1 wc
	and	local01, #7
	negc	local01, local01
	add	objptr, ##29108
	rdlong	arg01, objptr
	sub	objptr, ##29108
	shl	local01, #6
	add	arg01, local01
	add	arg01, #22
	wrword	local02, arg01
	mov	ptra, fp
	call	#popregs_
_do_changepan_ret
	ret

' 
' '-------------------- changevol
' 
' sub do_changevol
_do_changevol
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	mov	arg02, ##1148846080
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	abs	arg02, result1 wc
	zerox	arg02, #13
	negc	local01, arg02
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	arg02, result1 wc
	and	arg02, #7
	negc	arg02, arg02
	add	objptr, ##29108
	rdlong	arg01, objptr
	sub	objptr, ##29108
	shl	arg02, #6
	add	arg01, arg02
	add	arg01, #20
	wrword	local01, arg01
	mov	ptra, fp
	call	#popregs_
_do_changevol_ret
	ret

' 
' '-------------------- changewav
' 
' sub do_changewav
_do_changewav
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
' 
' t1=pop()
' wave=converttoint(t1)
' if wave<0 then wave=0
	cmps	local01, #0 wc
 if_b	mov	local01, #0
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	result2, result1 wc
	and	result2, #7
	negc	result2, result2
' if wave <32 then 
	cmps	local01, #32 wc
 if_ae	jmp	#LR__1270
	add	objptr, ##29108
	rdlong	arg01, objptr
	sub	objptr, ##29108
	shl	result2, #6
	add	arg01, result2
	add	arg01, #8
	shl	local01, #11
	add	local01, ##-2147483648
	wrlong	local01, arg01
	jmp	#LR__1271
LR__1270
	add	objptr, ##29108
	rdlong	arg01, objptr
	sub	objptr, ##29108
	shl	result2, #6
	add	arg01, result2
	add	arg01, #8
	wrlong	##-2013265920, arg01
LR__1271
	mov	ptra, fp
	call	#popregs_
_do_changewav_ret
	ret

' 
' '-------------------- chr$
' 
' sub do_chr
_do_chr
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "chr$: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__1280
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5971
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1281
LR__1280
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
	call	#__system__Chr_S
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1281
	mov	ptra, fp
	call	#popregs_
_do_chr_ret
	ret

' 
' '-------------------- circle
' 
' sub do_circle
_do_circle
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #36
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	arg02, result3
	add	fp, #24
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #32
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t3=pop()
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) andalso (t2.result_type=result_int orelse t2.result_type=result_uint) andalso (t3.result_type=result_int orelse t3.result_type=result_uint) then
	mov	arg04, result3
	sub	fp, #8
	cmp	arg04, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1290
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #28 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1290
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, #28 wz
 if_ne	add	fp, #32
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #32
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1290
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #12
	rdlong	arg03, fp
	sub	fp, #24
	add	objptr, ##29132
	rdlong	arg04, objptr
	sub	objptr, ##29132
	call	#_Hg010b_4_spin2_circle
'    v.circle(t1.result.iresult,t2.result.iresult,t3.result.iresult,plot_color) : return
	jmp	#LR__1291
LR__1290
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	local02, result1
	mov	arg01, fp
	add	arg01, #24
	call	#_converttoint
	mov	arg03, result1
	add	objptr, ##29132
	rdlong	arg04, objptr
	sub	objptr, ##29132
	mov	arg01, local01
	mov	arg02, local02
	call	#_Hg010b_4_spin2_circle
LR__1291
	mov	ptra, fp
	call	#popregs_
_do_circle_ret
	ret

' 
' '-------------------- click
' 
' sub do_click
_do_click
	call	#_pop
	cmps	result1, #0 wz
' 
' t1=pop()
' if t1.result.uresult=0 then keyclick=0 else keyclick=1
 if_e	add	objptr, ##42208
 if_e	wrlong	#0, objptr
	sumz	objptr, ##42208
 if_ne	wrlong	#1, objptr
 if_ne	sub	objptr, ##42208
_do_click_ret
	ret

' 
' '-------------------- close
' 
' sub do_close
_do_close
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	arg03, result3
	mov	local02, result2
	mov	local03, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' t1=pop()
' if t1.result_type<>result_channel then print "channel# expected" : return  
	cmp	local03, #44 wz
 if_e	jmp	#LR__1300
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5972
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	jmp	#LR__1301
LR__1300
' channel  = t1.result.iresult
' close #channel
	mov	arg01, local01
	call	#__system__close
LR__1301
	mov	ptra, fp
	call	#popregs_
_do_close_ret
	ret

' 
' '-------------------- cls
' 
' sub do_cls
_do_cls
	add	objptr, ##29152
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##29148
	call	#_Hg010b_4_spin2_cls
	add	objptr, ##29152
	rdlong	arg02, objptr
	sub	objptr, #20
	wrlong	arg02, objptr
	sub	objptr, ##29132
_do_cls_ret
	ret

' 
' sub do_coginit
_do_coginit
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, ##4124
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	rdlong	local02, local02
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<2 orelse numpar>3 then print "coginit: "; : printerror(39) : return
	cmps	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1310
	cmps	local02, #4 wc
 if_b	jmp	#LR__1311
LR__1310
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5973
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1315
LR__1311
	call	#_pop
	mov	local01, result3
	add	fp, ##4112
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, ##4112
	call	#_converttoint
	mov	local03, result1
	call	#_pop
	mov	local01, result3
	add	fp, ##4112
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, ##4112
	call	#_converttoint
	mov	local04, result1
' t1=pop()
' ptra_val=converttoint(t1)
' t1=pop()
' addrval=converttoint(t1)
' if numpar=3 then 
	cmp	local02, #3 wz
 if_ne	jmp	#LR__1312
	call	#_pop
	mov	local01, result3
	add	fp, ##4112
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, ##4112
	call	#_converttoint
	mov	local05, result1
	jmp	#LR__1313
LR__1312
	mov	local05, #16
LR__1313
'     
' if addrval>$80000 then psram.read1(varptr(tempbuf(0)),addrval,4096) : addrval=varptr(tempbuf(0))
	cmps	local04, ##524289 wc
 if_b	jmp	#LR__1314
	mov	arg01, fp
	add	arg01, #16
	mov	arg02, local04
	decod	arg03, #12
	add	objptr, ##5836
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
	mov	local04, fp
	add	local04, #16
LR__1314
' 
'  asm
	setq	local03
	coginit	local05, local04 wc
'  
' return cog 
	add	fp, ##4112
	wrlong	local05, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, ##4112
	call	#_push
LR__1315
	mov	ptra, fp
	call	#popregs_
_do_coginit_ret
	ret

' 
' '-------------------- cogstop
' 
' sub do_cogstop
_do_cogstop
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	cogstop	result1
	mov	ptra, fp
	call	#popregs_
_do_cogstop_ret
	ret

' 
' '-------------------- color
' 
' sub do_color
_do_color
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	objptr, ##29132
	wrlong	local01, objptr
	sub	objptr, ##29132
	mov	ptra, fp
	call	#popregs_
_do_color_ret
	ret

' 
' '-------------------- copy
' 
' sub do_copy
_do_copy
	mov	COUNT_, #8
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	arg05, result2
	mov	arg04, result3
	mov	local02, arg05
	mov	local03, arg04
	call	#_pop
	mov	arg05, result2
	mov	arg04, result3
	mov	local04, result1
	mov	local05, arg05
	mov	local06, arg04
' 
' t1=pop()
' t2=pop()
' if t2.result_type=result_string2 then 
	cmp	local06, #43 wz
 if_ne	jmp	#LR__1320
	mov	arg01, local04
	call	#_convertstring
	mov	local07, result1
	jmp	#LR__1322
LR__1320
	cmp	local06, #31 wz
 if_e	mov	local07, local04
 if_e	jmp	#LR__1321
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #15
	call	#_printerror
'   printerror(15,runheader(0)) : return
	jmp	#LR__1329
LR__1321
LR__1322
' if t1.result_type=result_string2 then 
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1323
	mov	arg01, local01
	call	#_convertstring
	mov	local08, result1
	jmp	#LR__1325
LR__1323
	cmp	local03, #31 wz
 if_e	mov	local08, local01
 if_e	jmp	#LR__1324
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #15
	call	#_printerror
'   printerror(15,runheader(0)) : return
	jmp	#LR__1329
LR__1324
LR__1325
' 
' open filename_1 for input as #9 : err=geterr(): if err<>0 then print "System error - ";err; " in line ";runheader(0);": ";strerror$(err);", file name: ";filename_1 : close #9 : return
	mov	arg01, #9
	mov	arg02, local07
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	add	objptr, ##43188
	wrlong	result1, objptr
	sub	objptr, ##43188
 if_e	jmp	#LR__1326
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5974
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##43188
	rdlong	arg02, objptr
	sub	objptr, ##43188
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5975
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg02, ##@LR__5976
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local08, #0
	add	objptr, ##43188
	rdlong	arg01, objptr
	sub	objptr, ##43188
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, local08
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg02, ##@LR__5977
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local07
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1329
LR__1326
' open filename_2 for output as #8 : err=geterr(): if err<>0 then print "System error - ";err; " in line ";runheader(0);": ";strerror$(err);", file name: ";filename_2  : close #8 : return
	mov	arg01, #8
	mov	arg02, local08
	mov	arg03, #13
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	add	objptr, ##43188
	wrlong	result1, objptr
	sub	objptr, ##43188
 if_e	jmp	#LR__1327
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5978
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##43188
	rdlong	arg02, objptr
	sub	objptr, ##43188
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5979
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg02, ##@LR__5980
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local07, #0
	add	objptr, ##43188
	rdlong	arg01, objptr
	sub	objptr, ##43188
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, local07
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg02, ##@LR__5981
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local08
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #8
	call	#__system__close
	jmp	#LR__1329
LR__1327
' 
' do
LR__1328
'   get #9,,block(0),1024,r
	mov	arg03, objptr
	add	arg03, ##41048
	mov	arg01, #9
	mov	arg02, #0
	decod	arg04, #10
	mov	arg05, #1
	call	#__system___basic_get
	add	objptr, ##43244
	wrlong	result1, objptr
'   put #8,,block(0),r
	sub	objptr, ##2196
	mov	arg03, objptr
	mov	arg04, result1
	sub	objptr, ##41048
	mov	arg01, #8
	mov	arg02, #0
	mov	arg05, #1
	call	#__system___basic_put
	add	objptr, ##43244
	rdlong	local08, objptr
	sub	objptr, ##43244
	cmp	local08, ##1024 wz
 if_e	jmp	#LR__1328
' close #8
	mov	arg01, #8
	call	#__system__close
' close #9
	mov	arg01, #9
	call	#__system__close
LR__1329
	mov	ptra, fp
	call	#popregs_
_do_copy_ret
	ret

' 
' '-------------------- cos
' 
' sub do_cos
_do_cos
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "cos: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__1330
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5982
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1331
LR__1330
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##43140
	rdlong	local01, objptr
	sub	objptr, ##43140
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, ##1070141403
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system____builtin_sinf
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1331
	mov	ptra, fp
	call	#popregs_
_do_cos_ret
	ret

' 
' '-------------------- cursor
' 
' sub do_cursor
_do_cursor
	call	#_pop
	cmps	result1, #0 wz
' t1=pop()
' if t1.result.uresult=0 then  v.setspritesize(17,0,0) else v.setspritesize(17,8,16) 
 if_ne	jmp	#LR__1340
	mov	arg01, #17
	mov	arg02, #0
	mov	arg03, #0
	call	#_Hg010b_4_spin2_setspritesize
	jmp	#LR__1341
LR__1340
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_Hg010b_4_spin2_setspritesize
LR__1341
_do_cursor_ret
	ret

' 
' '-------------------- defchar
' 
' sub do_defchar
_do_defchar
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #40
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
' 
' t1=pop() : cptr=converttoint(t1)
' t1=pop() : c=converttoint(t1)
' if cptr<$80000 then 
	cmp	local01, ##524288 wc
 if_ae	jmp	#LR__1350
	mov	arg01, local02
	mov	arg02, local01
	call	#_Hg010b_4_spin2_defchar
	jmp	#LR__1352
LR__1350
'   for i=0 to 15: buf(i)=pspeek(cptr+i): next i
	mov	local03, #0
LR__1351
	mov	local04, local03
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	mov	arg01, local01
	add	arg01, local03
	call	#_pspeek
	wrbyte	result1, local04
	add	local03, #1
	cmps	local03, #16 wc
 if_b	jmp	#LR__1351
	mov	arg02, fp
	add	arg02, #20
	mov	arg01, local02
	call	#_Hg010b_4_spin2_defchar
LR__1352
	mov	ptra, fp
	call	#popregs_
_do_defchar_ret
	ret

' 
' '-------------------- defenv
' 
' sub do_defenv
_do_defenv
	mov	COUNT_, #20
	call	#pushregs_
	add	ptra, #88
	add	objptr, ##38948
	rdlong	arg05, objptr
	mov	arg04, arg05
	shl	arg04, #1
	add	arg04, arg05
	shl	arg04, #2
	sub	objptr, ##1540
	add	arg04, objptr
	rdlong	local01, arg04
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>2 andalso numpar<>5 then return 			' TODO and print error
	cmp	local01, #2 wz
	sub	objptr, ##37408
 if_ne	cmp	local01, #5 wz
 if_ne	jmp	#LR__1380
' 
' if numpar=2 then						' env from .h2 or from a pointer
	cmp	local01, #2 wz
 if_ne	jmp	#LR__1372
	call	#_pop
	mov	arg05, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
'   t1=pop()
'   if t1.result_type=result_string2 then 
	sub	fp, #72
	cmp	arg05, #43 wz
 if_ne	jmp	#LR__1360
	add	fp, #64
	rdlong	arg01, fp
	sub	fp, #64
	call	#_convertstring
	mov	local02, result1
	jmp	#LR__1362
LR__1360
	add	fp, #72
	rdlong	arg05, fp
	sub	fp, #72
	cmp	arg05, #31 wz
 if_e	add	fp, #64
 if_e	rdlong	local02, fp
 if_e	sub	fp, #64
 if_e	jmp	#LR__1361
	mov	local02, ##@LR__5983
	mov	arg01, fp
	add	arg01, #64
	call	#_converttoint
	mov	local03, result1
LR__1361
LR__1362
'   if s1<>"" then 
	mov	arg02, ##@LR__5984
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1366
	call	#_pop
	mov	arg05, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttoint
	mov	local04, result1
'     t1=pop()
'     channel=converttoint(t1) 
'     close #9 : open "/sd/media/h/"+s1 for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local05, #9
	mov	arg01, ##@LR__5985
	mov	arg02, local02
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local05
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'     r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return   
 if_e	jmp	#LR__1363
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5986
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5987
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, local06
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1380
LR__1363
'     get #9,17,envbuf8(channel,0),256
	mov	arg03, local04
	shl	arg03, #9
	add	arg03, local04
	mov	arg05, objptr
	add	arg05, ##7224
	add	arg03, arg05
	mov	arg01, #9
	mov	arg02, #17
	mov	arg04, #256
	mov	arg05, #1
	call	#__system___basic_get
'     for i=255 to 0 step -1 : envbuf(channel,i)=envbuf8(channel,i)*256 : next i
	mov	local07, #255
	add	objptr, ##7224
	callpa	#(@LR__1365-@LR__1364)>>2,fcache_load_ptr_
LR__1364
	mov	local06, local04
	shl	local06, #9
	add	local06, objptr
	mov	local05, local07
	shl	local05, #1
	add	local05, local06
	mov	local03, local04
	shl	local03, #9
	add	local03, local04
	add	local03, objptr
	mov	local06, local07
	add	local06, local03
	rdbyte	local06, local06
	shl	local06, #8
	wrword	local06, local05
	sub	local07, #1
	cmps	local07, #0 wc
 if_ae	jmp	#LR__1364
LR__1365
	sub	objptr, ##7224
'     close #9
	mov	arg01, #9
	call	#__system__close
	shl	local04, #9
	mov	local07, objptr
	add	local07, ##7224
	add	local04, local07
	add	local04, #510
	wrword	#0, local04
'     envbuf(channel,255)=0                                                              
'     return
	jmp	#LR__1380
LR__1366
'     if wptr < $80000 then 
	cmps	local03, ##524288 wc
 if_ae	jmp	#LR__1369
'       for i=0 to 255: envbuf(channel,i)=dpeek(wptr+2*i): next i
	mov	local07, #0
	callpa	#(@LR__1368-@LR__1367)>>2,fcache_load_ptr_
LR__1367
	mov	local06, local04
	shl	local06, #9
	mov	local05, objptr
	add	local05, ##7224
	add	local06, local05
	mov	local05, local07
	shl	local05, #1
	add	local05, local06
	mov	arg01, local03
	mov	local06, local07
	shl	local06, #1
	add	arg01, local06
	rdword	result1, arg01
	wrword	result1, local05
	add	local07, #1
	cmps	local07, #256 wc
 if_b	jmp	#LR__1367
LR__1368
	jmp	#LR__1371
LR__1369
'       for i=0 to 255: envbuf(channel,i)=psdpeek(wptr+2*i) : next i
	mov	local07, #0
LR__1370
	mov	local06, local04
	shl	local06, #9
	mov	local05, objptr
	add	local05, ##7224
	add	local06, local05
	mov	local05, local07
	shl	local05, #1
	add	local05, local06
	mov	arg01, local03
	mov	local06, local07
	shl	local06, #1
	add	arg01, local06
	call	#_psdpeek
	wrword	result1, local05
	add	local07, #1
	cmps	local07, #256 wc
 if_b	jmp	#LR__1370
LR__1371
	shl	local04, #9
	mov	local07, objptr
	add	local07, ##7224
	add	local04, local07
	add	local04, #510
	wrword	#0, local04
'     envbuf(channel,255)=0
'     return   
	jmp	#LR__1380
LR__1372
' 
' if numpar=5 then   						 'simple adsr
	cmp	local01, #5 wz
 if_ne	jmp	#LR__1379
	call	#_pop
	mov	local07, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local07, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttofloat
	mov	local07, result1
	call	#_pop
	mov	local06, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local06, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttofloat
	mov	local08, result1
	call	#_pop
	mov	local06, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local06, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttofloat
	mov	local06, result1
	call	#_pop
	mov	local05, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttofloat
	mov	local05, result1
	call	#_pop
	mov	local04, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local04, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttoint
	mov	local04, result1
'   t1=pop() : rr=converttofloat(t1)
'   t1=pop() : ss=converttofloat(t1) 
'   t1=pop() : dd=converttofloat(t1)
'   t1=pop() : aa=converttofloat(t1)
'   t1=pop() : channel=converttoint(t1)
'   if ss<0.0 then ss=0.0 
	mov	arg01, local08
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local08, #0
'   if ss>1.0 then ss=1.0
	mov	arg01, local08
	mov	arg02, ##1065353216
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	mov	local08, ##1065353216
	mov	arg01, local05
	mov	arg02, local06
	call	#__system___float_add
	mov	arg01, result1
	mov	arg02, local07
	call	#__system___float_add
	mov	arg02, result1
	mov	arg01, ##1132462080
	call	#__system___float_div
	mov	local09, result1
	mov	arg01, local05
	mov	arg02, local09
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local10, result1
	mov	arg01, local06
	mov	arg02, local09
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local11, result1
	mov	arg01, local07
	mov	arg02, local09
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local06, result1
	mov	local05, ##1199566848
	abs	arg01, local10 wc
 if_b	decod	local12, #31
 if_ae	mov	local12, #0
	call	#__system___float_fromuns
	xor	result1, local12
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_div
	mov	local13, result1
	mov	local05, ##1199566848
	mov	arg01, ##1199566848
	mov	arg02, local08
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local05
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local05, result1
	abs	arg01, local11 wc
 if_b	decod	local12, #31
 if_ae	mov	local12, #0
	call	#__system___float_fromuns
	xor	result1, local12
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_div
	mov	local14, result1
	mov	arg01, ##1199566848
	mov	arg02, local08
	call	#__system___float_mul
	mov	local05, result1
	abs	arg01, local06 wc
 if_b	decod	local12, #31
 if_ae	mov	local12, #0
	call	#__system___float_fromuns
	xor	result1, local12
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_div
	mov	local15, result1
	mov	local07, local04
	shl	local07, #1
	mov	local16, objptr
	add	local16, ##43152
	add	local07, local16
	mov	local17, local10
	add	local17, local11
	wrword	local17, local07
	mov	local18, #0
'   fulltime=aa+dd+rr
'   timeunit=256/fulltime : a=round(aa*timeunit) : d=round(dd*timeunit) : r=round(rr*timeunit)  
'   da=65520.0/a : dd=(65520.0-65520.0*ss)/d : dr=(65520.0*ss)/r  
'   suspoints(channel)=a+d
'   aa=0.0 : for i=0 to a-1  : envbuf(channel,i)=round(aa): aa+=da : next i
	mov	local07, #0
	mov	local19, local10
LR__1373
	cmps	local07, local19 wc
 if_ae	jmp	#LR__1374
	mov	local17, local04
	shl	local17, #9
	mov	local16, objptr
	add	local16, ##7224
	add	local17, local16
	mov	local16, local07
	shl	local16, #1
	add	local16, local17
	mov	arg01, local18
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local16
	mov	arg02, local13
	mov	arg01, local18
	call	#__system___float_add
	mov	local18, result1
	add	local07, #1
	jmp	#LR__1373
LR__1374
'   for i=a to (a+d-1) : envbuf(channel,i)=round(aa) : aa=aa-dd : if aa<0.0 then aa=0.0
	mov	local07, local10
	mov	local20, local10
	add	local20, local11
LR__1375
	cmps	local07, local20 wc
 if_ae	jmp	#LR__1376
	mov	local19, local04
	shl	local19, #9
	mov	local16, objptr
	add	local16, ##7224
	add	local19, local16
	mov	local17, local07
	shl	local17, #1
	add	local17, local19
	mov	arg01, local18
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local17
	mov	arg01, local18
	mov	arg02, local14
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local18, result1
	mov	arg01, local18
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local18, #0
	add	local07, #1
	jmp	#LR__1375
LR__1376
'   for i=(a+d) to 255 : envbuf(channel,i)=round(aa): aa=aa-dr : if aa<0.0 then aa=0.0
	mov	local07, local10
	add	local07, local11
LR__1377
	cmps	local07, #256 wc
 if_ae	jmp	#LR__1378
	mov	local20, local04
	shl	local20, #9
	mov	local17, objptr
	add	local17, ##7224
	add	local20, local17
	mov	local19, local07
	shl	local19, #1
	add	local19, local20
	mov	arg01, local18
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local19
	mov	arg01, local18
	mov	arg02, local15
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local18, result1
	mov	arg01, local18
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local18, #0
	add	local07, #1
	jmp	#LR__1377
LR__1378
	mov	local20, local04
	shl	local20, #9
	mov	local16, objptr
	add	local16, ##7224
	add	local20, local16
	add	local20, #510
	wrword	#0, local20
LR__1379
	shl	local04, #9
	mov	local16, objptr
	add	local16, ##7224
	add	local04, local16
	add	local04, #510
	wrword	#0, local04
LR__1380
	mov	ptra, fp
	call	#popregs_
_do_defenv_ret
	ret

' 
' '-------------------- defsnd
' 
' sub do_defsnd
_do_defsnd
	mov	COUNT_, #13
	call	#pushregs_
	add	ptra, #128
	add	objptr, ##38948
	rdlong	arg05, objptr
	mov	arg04, arg05
	shl	arg04, #1
	add	arg04, arg05
	shl	arg04, #2
	sub	objptr, ##1540
	add	arg04, objptr
	rdlong	local01, arg04
' 
' numpar=compiledline(lineptr_e).result.uresult
' 
' ' defsnd channel, string - tries to load from /media/s an s2 file from PC-Softsynth
' ' defsnd channel, h1,h2.... h15 - defines harmonics
' ' defsnd channel, negfloat, negfloat - defines even and odd harmonics dampening
' ' defsnd channel, oneint - loads the wave from the pointer
' 
' if numpar<2 then return
	cmps	local01, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1411
'  
' if numpar=2 then
	cmp	local01, #2 wz
 if_ne	jmp	#LR__1399
	call	#_pop
	mov	arg05, result3
	add	fp, #44
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
'   t1=pop()
'   if t1.result_type=result_string2 then 
	sub	fp, #52
	cmp	arg05, #43 wz
 if_ne	jmp	#LR__1390
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #44
	call	#_convertstring
	mov	local02, result1
	jmp	#LR__1392
LR__1390
	add	fp, #52
	rdlong	arg05, fp
	sub	fp, #52
	cmp	arg05, #31 wz
 if_e	add	fp, #44
 if_e	rdlong	local02, fp
 if_e	sub	fp, #44
 if_e	jmp	#LR__1391
	mov	local02, ##@LR__5988
	mov	arg01, fp
	add	arg01, #44
	call	#_converttoint
	mov	local03, result1
LR__1391
LR__1392
'   if s<>"" then 
	mov	arg02, ##@LR__5989
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1395
	call	#_pop
	mov	arg05, result3
	add	fp, #44
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #44
	call	#_converttoint
	mov	local04, result1
'     t1=pop()
'     channel=converttoint(t1) : if channel>31 then return
	cmps	local04, #32 wc
 if_ae	jmp	#LR__1411
'     close #9 : open "/sd/media/s/"+s for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local03, #9
	mov	arg01, ##@LR__5990
	mov	arg02, local02
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local03
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	add	objptr, ##43244
	wrlong	result1, objptr
'     r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return   
	sub	objptr, ##43244
 if_e	jmp	#LR__1393
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5991
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##43244
	rdlong	arg02, objptr
	sub	objptr, ##43244
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5992
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local04, #0
	add	objptr, ##43244
	rdlong	arg01, objptr
	sub	objptr, ##43244
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1411
LR__1393
'     for i=0 to 1024 : get #9,17+2*i,sample,1 : psdpoke 2048*channel+2*i, sample : next i
	mov	local05, #0
LR__1394
	mov	local03, local05
	shl	local03, #1
	mov	arg02, #17
	add	arg02, local03
	mov	arg03, fp
	add	arg03, #124
	mov	arg01, #9
	mov	arg04, #1
	mov	arg05, #2
	call	#__system___basic_get
	mov	arg01, local04
	shl	arg01, #11
	mov	local03, local05
	shl	local03, #1
	add	arg01, local03
	add	fp, #124
	rdword	arg02, fp
	sub	fp, #124
	signx	arg02, #15
	call	#_psdpoke
	add	local05, #1
	cmps	local05, ##1025 wc
 if_b	jmp	#LR__1394
'     close #9
	mov	arg01, #9
	call	#__system__close
'     return
	jmp	#LR__1411
LR__1395
'     if wptr < ($80000 - 2048) then 
	cmps	local03, ##522240 wc
 if_ae	jmp	#LR__1397
'       for i=0 to 1023: psdpoke 2048*channel+2*i,dpeek(wptr+2*i): next i
	mov	local05, #0
LR__1396
	mov	local01, local04
	shl	local01, #11
	mov	local02, local05
	shl	local02, #1
	add	local01, local02
	mov	arg01, local03
	mov	local02, local05
	shl	local02, #1
	add	arg01, local02
	rdword	arg02, arg01
	mov	arg01, local01
	call	#_psdpoke
	add	local05, #1
	cmps	local05, ##1024 wc
 if_b	jmp	#LR__1396
	jmp	#LR__1411
LR__1397
'       for i=0 to 1023 : psdpoke 2048*channel+2*i,psdpeek(wptr+2*i) : next i
	mov	local05, #0
LR__1398
	mov	local01, local04
	shl	local01, #11
	mov	local02, local05
	shl	local02, #1
	add	local01, local02
	mov	arg01, local03
	mov	local02, local05
	shl	local02, #1
	add	arg01, local02
	call	#_psdpeek
	mov	arg02, result1
	mov	arg01, local01
	call	#_psdpoke
	add	local05, #1
	cmps	local05, ##1024 wc
 if_b	jmp	#LR__1398
'     return 
	jmp	#LR__1411
'   return
LR__1399
' for i=0 to 15 : harm(i)=0: next i  
	mov	local05, #0
	add	fp, #60
	callpa	#(@LR__1401-@LR__1400)>>2,fcache_load_ptr_
LR__1400
	mov	local06, local05
	shl	local06, #2
	add	local06, fp
	wrlong	#0, local06
	add	local05, #1
	cmps	local05, #16 wc
 if_b	jmp	#LR__1400
LR__1401
	sub	fp, #60
' for i=numpar to 2 step -1 
	mov	local05, local01
LR__1402
	call	#_pop
	add	fp, #44
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	mov	local06, local05
	sub	local06, #2
	shl	local06, #2
	add	fp, #8
	add	local06, fp
	sub	fp, #16
	mov	arg01, fp
	sub	fp, #44
	call	#_converttofloat
	wrlong	result1, local06
	sub	local05, #1
	cmps	local05, #2 wc
 if_ae	jmp	#LR__1402
	call	#_pop
	mov	local05, result3
	add	fp, #44
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #44
	call	#_converttoint
	mov	local04, result1
' t1=pop()
' channel=converttoint(t1) : : if channel>31 then return
	cmps	local04, #32 wc
 if_ae	jmp	#LR__1411
	mov	local07, #0
' max=0
' if harm(0)<0 then
	add	fp, #60
	rdlong	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__1405
	add	fp, #60
	rdlong	local08, fp
	bitl	local08, #31
	add	fp, #4
	rdlong	local09, fp
	bitl	local09, #31
	sub	fp, #4
	wrlong	##1065353216, fp
	add	fp, #4
	wrlong	local08, fp
	add	fp, #4
	wrlong	local09, fp
	sub	fp, #68
'   harm(0)=1
'   harm(1)=even
'   harm(2)=odd
'   for i=3 to 15 step 2 : harm(i)=harm(i-2)*even : next i
	mov	local05, #3
LR__1403
	mov	local06, local05
	shl	local06, #2
	add	fp, #60
	add	local06, fp
	mov	arg05, local05
	sub	arg05, #2
	shl	arg05, #2
	add	arg05, fp
	rdlong	arg01, arg05
	mov	arg02, local08
	sub	fp, #60
	call	#__system___float_mul
	wrlong	result1, local06
	add	local05, #2
	cmps	local05, #16 wc
 if_b	jmp	#LR__1403
'   for i=4 to 14 step 2 : harm(i)=harm(i-2)*odd : next i
	mov	local05, #4
LR__1404
	mov	local06, local05
	shl	local06, #2
	add	fp, #60
	add	local06, fp
	mov	local08, local05
	sub	local08, #2
	shl	local08, #2
	add	local08, fp
	rdlong	arg01, local08
	mov	arg02, local09
	sub	fp, #60
	call	#__system___float_mul
	wrlong	result1, local06
	add	local05, #2
	cmps	local05, #15 wc
 if_b	jmp	#LR__1404
LR__1405
' if harm(0)>=0 then ' synthesize with harmonics
	add	fp, #60
	rdlong	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1410
'   for i=0 to 1023
	mov	local05, #0
LR__1406
	mov	local10, #0
'     spl=0
'     for j=0 to 15 : spl+=harm(j)*sin((1.0/512)*3.14159265359*i*(j+1)) : next j 
	mov	local11, #0
LR__1407
	mov	local06, local11
	shl	local06, #2
	mov	arg05, fp
	add	arg05, #60
	add	local06, arg05
	rdlong	local06, local06
	mov	local09, ##1003032539
	abs	arg01, local05 wc
 if_b	decod	local12, #31
 if_ae	mov	local12, #0
	call	#__system___float_fromuns
	xor	result1, local12
	mov	arg02, result1
	mov	arg01, local09
	call	#__system___float_mul
	mov	local13, result1
	mov	arg01, local11
	add	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local12, #31
 if_ae	mov	local12, #0
	call	#__system___float_fromuns
	xor	result1, local12
	mov	arg02, result1
	mov	arg01, local13
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local10
	call	#__system___float_add
	mov	local10, result1
	add	local11, #1
	cmps	local11, #16 wc
 if_b	jmp	#LR__1407
'     if abs(spl)>max then max=abs(spl)  
	mov	arg01, local10
	bitl	arg01, #31
	mov	arg02, local07
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	bitl	local10, #31
 if_ae	mov	local07, local10
	add	local05, #1
	cmps	local05, ##1024 wc
 if_b	jmp	#LR__1406
'   for i=0 to 1023
	mov	local05, #0
LR__1408
	mov	local10, #0
'     spl=0
'     for j=0 to 15: spl+=harm(j)*(32600.0/max)*sin(1.0/512*3.14159265359*i*(j+1)) :next j 
	mov	local11, #0
LR__1409
	mov	local13, local11
	shl	local13, #2
	mov	local09, fp
	add	local09, #60
	add	local13, local09
	rdlong	local06, local13
	mov	arg01, ##1191096320
	mov	arg02, local07
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	mov	local06, result1
	mov	local13, ##1003032539
	abs	arg01, local05 wc
 if_b	decod	local12, #31
 if_ae	mov	local12, #0
	call	#__system___float_fromuns
	xor	result1, local12
	mov	arg02, result1
	mov	arg01, local13
	call	#__system___float_mul
	mov	local13, result1
	mov	arg01, local11
	add	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local12, #31
 if_ae	mov	local12, #0
	call	#__system___float_fromuns
	xor	result1, local12
	mov	arg02, result1
	mov	arg01, local13
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local10
	call	#__system___float_add
	mov	local10, result1
	add	local11, #1
	cmps	local11, #16 wc
 if_b	jmp	#LR__1409
	mov	local11, local04
	shl	local11, #11
	mov	local13, local05
	shl	local13, #1
	add	local11, local13
	mov	arg01, local10
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	arg02, result1
	mov	arg01, local11
	call	#_psdpoke
	add	local05, #1
	cmps	local05, ##1024 wc
 if_b	jmp	#LR__1408
LR__1410
LR__1411
	mov	ptra, fp
	call	#popregs_
_do_defsnd_ret
	ret

' 
' '-------------------- defsprite
' 
' sub do_defsprite
_do_defsprite
	mov	COUNT_, #11
	call	#pushregs_
	add	ptra, #96
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #48
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #56
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #36
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #44
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	local02, result1
	mov	arg01, fp
	add	arg01, #24
	call	#_converttoint
	mov	local03, result1
	mov	arg01, fp
	add	arg01, #36
	call	#_converttoint
	mov	local04, result1
	mov	arg01, fp
	add	arg01, #48
	call	#_converttoint
	mov	local05, result1
' 
' t5=pop()
' t4=pop()
' t3=pop()
' t2=pop()
' t1=pop()
' a1=converttoint(t1) : a2=converttoint(t2) : a3=converttoint(t3) : a4=converttoint(t4) : a5=converttoint(t5) ' do convert, defsprite is not a racing command
' if sprite(a1)<> nil then delete(sprite(a1))	' todo: check parameters for limits
	mov	arg03, local01
	shl	arg03, #2
	mov	arg02, objptr
	add	arg02, ##43056
	add	arg03, arg02
	rdlong	arg03, arg03 wz
 if_e	jmp	#LR__1420
	mov	arg03, local01
	shl	arg03, #2
	mov	arg02, objptr
	add	arg02, ##43056
	add	arg03, arg02
	rdlong	arg01, arg03
	call	#__system___gc_free
LR__1420
	qmul	local04, local05
	mov	local06, local01
	shl	local06, #2
	mov	arg03, objptr
	add	arg03, ##43056
	add	local06, arg03
	getqx	arg01
	call	#__system___gc_alloc_managed
	wrlong	result1, local06
' for y=a3 to a3+a5-1
	mov	local07, local03
	mov	local08, local03
	add	local08, local05
LR__1421
	cmps	local07, local08 wc
 if_ae	jmp	#LR__1424
'   for x=a2 to a4+a2-1
	mov	local09, local02
	mov	local10, local04
	add	local10, local02
LR__1422
	cmps	local09, local10 wc
 if_ae	jmp	#LR__1423
	mov	local06, local07
	sub	local06, local03
	qmul	local06, local04
	mov	local06, local01
	shl	local06, #2
	mov	arg03, objptr
	add	arg03, ##43056
	add	local06, arg03
	rdlong	local06, local06
	mov	local11, local09
	sub	local11, local02
	rdlong	arg01, objptr
	add	arg01, local09
	mov	arg03, local07
	shl	arg03, #10
	add	arg01, arg03
	getqx	arg03
	add	local11, arg03
	add	local11, local06
	call	#_pspeek
	wrbyte	result1, local11
	add	local09, #1
	jmp	#LR__1422
LR__1423
	add	local07, #1
	jmp	#LR__1421
LR__1424
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##43056
	add	local11, local10
	rdlong	arg02, local11
	mov	arg01, local01
	call	#_Hg010b_4_spin2_setspriteptr
	mov	arg01, local01
	mov	arg02, local04
	mov	arg03, local05
	call	#_Hg010b_4_spin2_setspritesize
	mov	ptra, fp
	call	#popregs_
_do_defsprite_ret
	ret

' 
' '-------------------- deg
' 
' sub do_deg
_do_deg
	add	objptr, ##43140
	wrlong	##1016003125, objptr
	add	objptr, #4
	wrlong	##1113927393, objptr
	sub	objptr, ##43144
_do_deg_ret
	ret

' 
' '-------------------- delete
' 
' sub do_delete
_do_delete
	mov	COUNT_, #5
	call	#pushregs_
	call	#_pop
	mov	arg04, result2
	mov	arg03, result3
	mov	local01, result1
	mov	local02, arg04
	mov	local03, arg03
' 
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1430
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1430
' if t1.result_type<>result_string then printerror(15): return
	cmp	local03, #31 wz
 if_e	jmp	#LR__1431
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1435
LR__1431
' if currentdir$<>"/" then filename$=currentdir$+"/"+t1.result.sresult else filename$="/"+t1.result.sresult
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__5993
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1432
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__5994
	call	#__system___string_concat
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_concat
	mov	local04, result1
	jmp	#LR__1433
LR__1432
	mov	arg01, ##@LR__5995
	mov	arg02, local01
	call	#__system___string_concat
	mov	local04, result1
LR__1433
	mov	arg01, local04
	call	#__system___remove
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local05, result1 wz
' kill filename$
' err=geterr() : if err<>0 then print "Cannot delete file or file doesn't exist: system error "; err
 if_e	jmp	#LR__1434
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5996
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local05
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__1434
LR__1435
	mov	ptra, fp
	call	#popregs_
_do_delete_ret
	ret

' 
' '-------------------- dir
' 
' sub do_dir
_do_dir
	mov	COUNT_, #19
	call	#pushregs_
	add	ptra, ##568
' 
' print "Current directory: "; currentdir$ 
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5997
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##38968
	rdlong	arg02, objptr
	sub	objptr, ##38968
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local01, #1
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	local02, #0
	mov	local03, #0
' px=0
' for i=0 to 127: filelist(i)="" : next i
	mov	local04, #0
	add	fp, #28
	callpa	#(@LR__1441-@LR__1440)>>2,fcache_load_ptr_
LR__1440
	mov	local05, local04
	shl	local05, #2
	add	local05, fp
	mov	local06, ##@LR__5998
	wrlong	local06, local05
	add	local04, #1
	cmps	local04, #128 wc
 if_b	jmp	#LR__1440
LR__1441
	sub	fp, #28
	mov	arg01, ##@LR__5999
	mov	arg02, #16
	call	#__system___basic_dir
	mov	local07, result1
	mov	local08, #0
' filename=dir$("*", fbDirectory)
' n=0
' while filename <> "" andalso filename <> nil andalso n<128
LR__1442
	mov	local09, ##@LR__6000
	mov	arg01, local07
	mov	arg02, local09
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1443
	mov	local09, #0
	mov	arg01, local07
	mov	arg02, #0
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1443
	cmps	local08, #128 wc
 if_ae	jmp	#LR__1443
	mov	arg01, ##@LR__6001
	mov	arg02, local07
	call	#__system___string_concat
	mov	local07, result1
	mov	local05, local08
	shl	local05, #2
	mov	local09, fp
	add	local09, #28
	add	local05, local09
	wrlong	local07, local05
	add	local08, #1
	mov	local05, #0
	mov	arg01, #0
	mov	arg02, #0
	call	#__system___basic_dir
	mov	local07, result1
	jmp	#LR__1442
LR__1443
' for i=0 to n-1			' now sort this
	mov	local04, #0
	mov	local10, local08
LR__1444
	cmps	local04, local10 wc
 if_ae	jmp	#LR__1448
	mov	local11, #0
'   swapped=false
'   for j=0 to n-i-2
	mov	local12, #0
	mov	local13, local08
	sub	local13, local04
	sub	local13, #1
LR__1445
	cmps	local12, local13 wc
 if_ae	jmp	#LR__1447
'     if filelist(j) > filelist(j+1) then
	mov	local09, local12
	shl	local09, #2
	add	fp, #28
	add	local09, fp
	rdlong	arg01, local09
	mov	local09, local12
	add	local09, #1
	mov	local06, local09
	shl	local06, #2
	mov	local01, fp
	add	local06, fp
	rdlong	local05, local06
	mov	arg02, local05
	sub	fp, #28
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1446
	mov	local09, local12
	add	local09, #1
	shl	local09, #2
	add	fp, #28
	add	local09, fp
	rdlong	local11, local09
	mov	local06, local12
	shl	local06, #2
	add	local06, fp
	rdlong	local05, local06
	mov	local09, local12
	mov	local06, local09
	shl	local06, #2
	mov	local01, fp
	add	local06, fp
	wrlong	local11, local06
	mov	local02, local12
	add	local02, #1
	mov	local14, local02
	shl	local14, #2
	mov	local15, fp
	add	local14, fp
	wrlong	local05, local14
	neg	local11, #1
	sub	fp, #28
LR__1446
	add	local12, #1
	jmp	#LR__1445
LR__1447
' if not swapped then exit for
	not	local16, local11
	cmp	local16, #0 wz
 if_e	add	local04, #1
 if_e	jmp	#LR__1444
LR__1448
' for i=0 to n-1
	mov	local04, #0
	mov	local17, local08
LR__1449
	cmps	local04, local17 wc
 if_ae	jmp	#LR__1451
'   print filelist(i); : px=px+64: v.setcursorx(px) : if px>255 then px=0: print
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	local02, local04
	shl	local02, #2
	mov	local14, fp
	add	local14, #28
	add	local02, local14
	rdlong	arg02, local02
	mov	local01, #0
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	local03, #64
	mov	arg01, local03
	call	#_Hg010b_4_spin2_setcursorx
	cmps	local03, #256 wc
 if_b	jmp	#LR__1450
	mov	local03, #0
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__1450
	add	local04, #1
	jmp	#LR__1449
LR__1451
' if n>=128  then print "More than 128 entries found: clean your directory"
	cmps	local08, #128 wc
 if_b	jmp	#LR__1452
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6002
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	local01, #0
LR__1452
' print
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	local06, #0
	mov	local08, #0
	mov	local03, #0
' return cursor_y
	add	objptr, #62
	rdbyte	local18, objptr
	sub	objptr, #62
	mov	arg01, ##@LR__6003
	mov	arg02, #33
	call	#__system___basic_dir
	mov	local07, result1
' n=0
' px=0: py=v.getcursory()
' filename = dir$("*", fbNormal )   
' do while filename <> "" andalso filename <> nil andalso n<128
LR__1453
	mov	local09, ##@LR__6004
	mov	arg01, local07
	mov	arg02, local09
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1454
	mov	local09, #0
	mov	arg01, local07
	mov	arg02, #0
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1454
	cmps	local08, #128 wc
 if_ae	jmp	#LR__1454
	mov	local05, local08
	shl	local05, #2
	mov	local09, fp
	add	local09, #28
	add	local05, local09
	wrlong	local07, local05
	add	local08, #1
	mov	local05, #0
	mov	arg01, #0
	mov	arg02, #0
	call	#__system___basic_dir
	mov	local07, result1
	jmp	#LR__1453
LR__1454
' for i =0 to n-1
	mov	local04, #0
LR__1455
	cmps	local04, local08 wc
 if_ae	jmp	#LR__1459
	mov	local11, #0
'   swapped=false
'   for j=0 to n-i-2
	mov	local12, #0
	mov	local19, local08
	sub	local19, local04
	sub	local19, #1
LR__1456
	cmps	local12, local19 wc
 if_ae	jmp	#LR__1458
'     if filelist(j) > filelist(j+1) then
	mov	local09, local12
	shl	local09, #2
	add	fp, #28
	add	local09, fp
	rdlong	arg01, local09
	mov	local09, local12
	add	local09, #1
	mov	local06, local09
	shl	local06, #2
	mov	local01, fp
	add	local06, fp
	rdlong	local05, local06
	mov	arg02, local05
	sub	fp, #28
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1457
	mov	local09, local12
	add	local09, #1
	shl	local09, #2
	add	fp, #28
	add	local09, fp
	rdlong	local16, local09
	mov	local06, local12
	shl	local06, #2
	add	local06, fp
	rdlong	local05, local06
	mov	local09, local12
	mov	local06, local09
	shl	local06, #2
	mov	local01, fp
	add	local06, fp
	wrlong	local16, local06
	mov	local14, local12
	add	local14, #1
	shl	local14, #2
	mov	local15, fp
	add	local14, fp
	wrlong	local05, local14
	neg	local11, #1
	sub	fp, #28
LR__1457
	add	local12, #1
	jmp	#LR__1456
LR__1458
' if not swapped then exit for
	not	local16, local11
	cmp	local16, #0 wz
 if_e	add	local04, #1
 if_e	jmp	#LR__1455
LR__1459
' for i=0 to n-1
	mov	local04, #0
LR__1460
	cmps	local04, local08 wc
 if_ae	jmp	#LR__1462
'   print filelist(i); : px=px+64: v.setcursorx(px) : if px>255 then px=0: print
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	local02, local04
	shl	local02, #2
	mov	local14, fp
	add	local14, #28
	add	local02, local14
	rdlong	arg02, local02
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	local03, #64
	mov	arg01, local03
	call	#_Hg010b_4_spin2_setcursorx
	cmps	local03, #256 wc
 if_b	jmp	#LR__1461
	mov	local03, #0
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__1461
	add	local04, #1
	jmp	#LR__1460
LR__1462
' if n>=128  then print "More than 128 entries found: clean your directory"
	cmps	local08, #128 wc
 if_b	jmp	#LR__1463
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6005
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__1463
' print
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	ptra, fp
	call	#popregs_
_do_dir_ret
	ret

' 
' '-------------------- dpeek
' 
' sub do_dpeek
_do_dpeek
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
' 
' t1=pop()
' a=converttoint(t1)
' if a<$80000 then r=dpeek(a) else r=psdpeek(a)
	cmp	arg01, ##524288 wc
 if_b	rdword	local01, arg01
 if_b	jmp	#LR__1470
	call	#_psdpeek
	mov	local01, result1
LR__1470
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	local01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_dpeek_ret
	ret

' 
' '-------------------- dpoke
' 
' sub do_dpoke
_do_dpoke
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
' 
' t1=pop() 'value
' t2=pop() 
' a=converttoint(t2) : v=converttoint(t1)
' if a<$80000 then dpoke a,v else psdpoke a,v
	cmp	local01, ##524288 wc
 if_b	wrword	local02, local01
 if_ae	mov	arg01, local01
 if_ae	mov	arg02, local02
 if_ae	call	#_psdpoke
	mov	ptra, fp
	call	#popregs_
_do_dpoke_ret
	ret

' '-------------------- draw
' 
' sub do_draw
_do_draw
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	arg05, result3
	add	fp, #12
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #20
	call	#_pop
	mov	arg04, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	local02, result1
	add	objptr, ##29136
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, #8
	rdlong	arg05, objptr
	sub	objptr, ##29132
	mov	arg03, local01
	mov	arg04, local02
	call	#_Hg010b_4_spin2_draw
	add	objptr, ##29136
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	local02, objptr
	sub	objptr, ##29140
	mov	ptra, fp
	call	#popregs_
_do_draw_ret
	ret

' 
' '-------------------- else
' 
' sub do_else
_do_else
	add	objptr, ##38944
	rdlong	_var01, objptr
	sub	_var01, #1
	add	objptr, #4
	wrlong	_var01, objptr
	sub	objptr, ##38948
_do_else_ret
	ret

' 
' '-------------------- end
' 
' sub do_end
_do_end
	add	objptr, ##38944
	rdlong	_var01, objptr
	sub	_var01, #1
	add	objptr, #4
	wrlong	_var01, objptr
	add	objptr, ##3128
	wrlong	##2147483647, objptr
	sub	objptr, ##42076
_do_end_ret
	ret

' 
' '-------------------- enter
' 
' sub do_enter
_do_enter
	mov	arg01, ##1234
	call	#_do_load
_do_enter_ret
	ret

' 
' '------------------- error processing
' 
' sub do_error
_do_error
	mov	COUNT_, #1
	call	#pushregs_
	add	objptr, ##38948
	rdlong	arg04, objptr
	mov	arg03, arg04
	shl	arg03, #1
	add	arg03, arg04
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local01, arg03
' r=compiledline(lineptr_e).result.uresult
' print "Error ";r;": ";errors$(r)
	mov	arg01, #0
	sub	objptr, ##37408
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6006
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg02, ##@LR__6007
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	shl	local01, #2
	mov	arg04, objptr
	add	arg04, ##36384
	add	local01, arg04
	rdlong	arg02, local01
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	ptra, fp
	call	#popregs_
_do_error_ret
	ret

' 
' '-------------------- fcircle
' 
' sub do_fcircle
_do_fcircle
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #36
	call	#_pop
	mov	arg02, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #24
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #32
	call	#_pop
	mov	arg02, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #12
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #20
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	local02, result1
	mov	arg01, fp
	add	arg01, #24
	call	#_converttoint
	mov	arg03, result1
	add	objptr, ##29132
	rdlong	arg04, objptr
	sub	objptr, ##29132
	mov	arg01, local01
	mov	arg02, local02
	call	#_Hg010b_4_spin2_fcircle
	mov	ptra, fp
	call	#popregs_
_do_fcircle_ret
	ret

' 
' '-------------------- fill
' 
' sub do_fill
_do_fill
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #36
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #44
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	local02, result1
	mov	arg01, fp
	add	arg01, #24
	call	#_converttoint
	mov	local03, result1
	mov	arg01, fp
	add	arg01, #36
	call	#_converttoint
	mov	arg04, result1
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local03
	call	#_Hg010b_4_spin2_fill
	mov	ptra, fp
	call	#popregs_
_do_fill_ret
	ret

' 
' '-------------------- findfirst
' 
' sub do_findfirst
_do_findfirst
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #28
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	local01, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=2 then
	cmp	local01, #2 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__1484
	call	#_pop
	mov	arg03, result3
	add	fp, #8
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
'   t1=pop()
'   if t1.result_type=result_string2 then 
	sub	fp, #16
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1480
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	call	#_convertstring
	mov	local02, result1
	jmp	#LR__1482
LR__1480
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #16
	cmp	arg03, #31 wz
 if_e	add	fp, #8
 if_e	rdlong	local02, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1481
'     print "findfirst: "; : printerror(30) : return  
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6008
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #30
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1492
LR__1481
LR__1482
	call	#_pop
	mov	arg03, result3
	add	fp, #8
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
'   t1=pop()
'   if t1.result_type=result_string2 then 
	sub	fp, #16
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1483
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	call	#_convertstring
	mov	local03, result1
	jmp	#LR__1490
LR__1483
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #31 wz
 if_e	add	fp, #8
 if_e	rdlong	local03, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1490
'     print "findfirst: "; : printerror(30) : return  
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6009
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #30
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1492
LR__1484
	cmp	local01, #1 wz
 if_ne	jmp	#LR__1488
	call	#_pop
	mov	arg03, result3
	add	fp, #8
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
'   t1=pop()
'   if t1.result_type=result_string2 then 
	sub	fp, #16
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1485
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	call	#_convertstring
	mov	local03, result1
	jmp	#LR__1487
LR__1485
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #16
	cmp	arg03, #31 wz
 if_e	add	fp, #8
 if_e	rdlong	local03, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1486
'     print "findfirst: "; : printerror(30) : return  
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6010
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #30
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1492
LR__1486
LR__1487
	mov	local02, ##@LR__6011
	jmp	#LR__1489
LR__1488
'   print "findfirst: "; : printerror(39) : return     
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6012
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1492
LR__1489
LR__1490
' 
' if s2="" then
	mov	arg02, ##@LR__6013
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local04, #49
 if_e	jmp	#LR__1491
	mov	arg01, local02
	call	#__system__LCase_S
	mov	arg01, result1
	mov	arg02, ##@LR__6014
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local04, #16
 if_ne	mov	local04, #33
LR__1491
	mov	arg01, local03
	mov	arg02, local04
	call	#__system___basic_dir
	mov	local02, result1
	add	fp, #16
	wrlong	#31, fp
	sub	fp, #8
	wrlong	local02, fp
	mov	arg01, fp
	sub	fp, #8
	call	#_push
LR__1492
	mov	ptra, fp
	call	#popregs_
_do_findfirst_ret
	ret

' 
' '-------------------- findnext
' 
' sub do_findnext
_do_findnext
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
' 
' if compiledline(lineptr_e).result.uresult>0 then print "findnext: "; : printerror(39) : return    
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	result1, arg02
	cmp	result1, #1 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1500
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6015
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1501
LR__1500
	mov	arg01, #0
	mov	arg02, #0
	call	#__system___basic_dir
	mov	arg03, result1
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	wrlong	arg03, fp
	mov	arg01, fp
	call	#_push
LR__1501
	mov	ptra, fp
	call	#popregs_
_do_findnext_ret
	ret

' 
' '-------------------- font
' 
' sub do_font
_do_font
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' 
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1510
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1510
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1511
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1511
	add	objptr, ##29156
	wrlong	local01, objptr
	sub	objptr, ##29156
	shl	local01, #2
	mov	arg01, local01
	call	#_Hg010b_4_spin2_setfontfamily
	mov	ptra, fp
	call	#popregs_
_do_font_ret
	ret

' 
' '-------------------- for
' 
' sub do_for()
_do_for
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##42196
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##42196
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##42196
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	rdlong	arg01, fp
	add	local01, #8
	wrlong	arg01, local01
	sub	objptr, ##38972
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##42196
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##38972
	call	#_converttoint
	mov	arg01, result1
	add	local01, #12
	wrlong	arg01, local01
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##42196
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##38972
	call	#_converttoint
	add	local01, #16
	wrlong	result1, local01
' fortop+=1
' t1=pop() : fortable(fortop).varnum=t1.result.iresult
' t1=pop() : fortable(fortop).stepval=converttoint(t1)
' t1=pop() : fortable(fortop).endval=converttoint(t1)
' if compiledline(lineptr_e).result_type=token_end then	' end of line after for, set the pointer to the start of the next line
	add	objptr, ##38948
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #1
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	add	local01, #8
	rdlong	local01, local01
	cmp	local01, #510 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__1520
	add	objptr, ##42196
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	add	objptr, ##3104
	rdlong	arg01, objptr
	wrlong	arg01, local01
	add	objptr, #120
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	add	local01, #4
	wrlong	#0, local01
	sub	objptr, ##38972
	jmp	#LR__1521
LR__1520
	add	objptr, ##42196
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	add	objptr, ##3112
	rdlong	arg01, objptr
	wrlong	arg01, local01
	add	objptr, #112
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	sub	objptr, #24
	rdlong	arg01, objptr
	sub	objptr, ##38948
	add	arg01, #1
	add	local01, #4
	wrlong	arg01, local01
LR__1521
	mov	ptra, fp
	call	#popregs_
_do_for_ret
	ret

' 
' '-------------------- frame
' 
' sub do_frame
_do_frame
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg05, result3
	add	fp, #36
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #44
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg05, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg05, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	local02, result1
	mov	arg01, fp
	add	arg01, #24
	call	#_converttoint
	mov	local03, result1
	mov	arg01, fp
	add	arg01, #36
	call	#_converttoint
	mov	arg04, result1
	add	objptr, ##29132
	rdlong	arg05, objptr
	sub	objptr, ##29132
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local03
	call	#_Hg010b_4_spin2_frame
	mov	ptra, fp
	call	#popregs_
_do_frame_ret
	ret

' 
' '-------------------- framebuf
' 
' sub do_framebuf
_do_framebuf
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	rdlong	arg01, objptr
	sub	fp, #8
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_framebuf_ret
	ret

' '-------------------- fre
' 
' sub do_fre
_do_fre
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #12
	add	objptr, ##43124
	rdlong	arg01, objptr
	sub	objptr, ##7796
	rdlong	local01, objptr
	sub	arg01, local01
	add	objptr, ##7916
	wrlong	arg01, objptr
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	rdlong	local01, objptr
	sub	objptr, ##43244
	wrlong	local01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_fre_ret
	ret

' 
' '-------------------- get
' 
' sub do_get		' get  #chn,addr,(amount,(pos))
_do_get
	mov	COUNT_, #16
	call	#pushregs_
	add	ptra, #64
	add	objptr, ##38948
	rdlong	arg05, objptr
	mov	local01, arg05
	shl	local01, #1
	add	local01, arg05
	shl	local01, #2
	sub	objptr, ##1540
	mov	local02, objptr
	add	local01, objptr
	rdlong	local03, local01
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=4  then t1=pop() : pos=converttoint(t1)   else pos=-1
	cmp	local03, #4 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__1530
	call	#_pop
	mov	arg05, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	objptr, ##43240
	wrlong	result1, objptr
	sub	objptr, ##43240
	jmp	#LR__1531
LR__1530
	add	objptr, ##43240
	wrlong	##-1, objptr
	sub	objptr, ##43240
LR__1531
' if numpar>=3  then t1=pop() : amount=converttoint(t1) else amount=1
	cmps	local03, #3 wc
 if_b	jmp	#LR__1532
	call	#_pop
	mov	local01, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	mov	local04, result1
	jmp	#LR__1533
LR__1532
	mov	local04, #1
LR__1533
' if numpar>=2  then t1=pop() : adr=converttoint(t1)
	cmps	local03, #2 wc
 if_b	jmp	#LR__1534
	call	#_pop
	mov	local02, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	mov	local05, result1
LR__1534
	call	#_pop
	mov	arg05, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	mov	local06, result1
	shl	local07, #2
	add	objptr, ##42088
	add	local07, objptr
	wrlong	#0, local07
' t1=pop() : channel=converttoint(t1)
' getres(j)=0
' if pos>=0 then
	add	objptr, ##1152
	rdlong	local08, objptr
	sub	objptr, ##43240
	cmps	local08, #0 wc
 if_b	jmp	#LR__1541
'   for i=0 to  amount/1024
	mov	local09, #0
	abs	local10, local04 wc
	shr	local10, #10
	negc	local10, local10
	add	local10, #1
LR__1535
	cmps	local09, local10 wc
 if_ae	jmp	#LR__1549
'     get #channel,pos+1,block(0),amount,r
	add	objptr, ##43240
	rdlong	arg02, objptr
	add	arg02, #1
	sub	objptr, ##2192
	mov	arg03, objptr
	sub	objptr, ##41048
	mov	arg04, local04
	mov	arg01, local06
	mov	arg05, #1
	call	#__system___basic_get
	mov	local11, result1
'     if adr<$80000 then for j=0 to r-1 : poke adr+1024*i+j,block(j):  next j else  for j=0 to r-1 : pspoke adr+1024*i+j,block(j):  next j  
	cmps	local05, ##524288 wc
 if_ae	jmp	#LR__1537
	mov	local07, #0
	mov	local12, local11
LR__1536
	cmps	local07, local12 wc
 if_ae	jmp	#LR__1540
	mov	arg01, local05
	mov	local08, local09
	shl	local08, #10
	add	arg01, local08
	add	arg01, local07
	mov	local02, local07
	mov	local08, objptr
	add	local08, ##41048
	add	local02, local08
	rdbyte	arg02, local02
	wrbyte	arg02, arg01
	add	local07, #1
	jmp	#LR__1536
LR__1537
	mov	local07, #0
	mov	local13, local11
LR__1538
	cmps	local07, local13 wc
 if_ae	jmp	#LR__1539
	mov	arg01, local05
	mov	local12, local09
	shl	local12, #10
	add	arg01, local12
	add	arg01, local07
	mov	local02, local07
	mov	local12, objptr
	add	local12, ##41048
	add	local02, local12
	rdbyte	arg02, local02
	call	#_pspoke
	add	local07, #1
	jmp	#LR__1538
LR__1539
LR__1540
	mov	local13, local07
	shl	local13, #2
	add	objptr, ##42088
	add	local13, objptr
	shl	local07, #2
	add	local07, objptr
	rdlong	local01, local07
	add	local01, local11
	wrlong	local01, local13
	add	local09, #1
	sub	objptr, ##42088
	jmp	#LR__1535
LR__1541
'   for i=0 to  amount/1024
	mov	local09, #0
	abs	local14, local04 wc
	shr	local14, #10
	negc	local14, local14
	add	local14, #1
LR__1542
	cmps	local09, local14 wc
 if_ae	jmp	#LR__1548
'     get #channel,,block(0),amount,r
	mov	arg03, objptr
	add	arg03, ##41048
	mov	arg04, local04
	mov	arg01, local06
	mov	arg02, #0
	mov	arg05, #1
	call	#__system___basic_get
	mov	local11, result1
'     if adr<$80000 then for j=0 to r-1 : poke adr+1024*i+j,block(j):  next j else  for j=0 to r-1 : pspoke adr+1024*i+j,block(j):  next j  
	cmps	local05, ##524288 wc
 if_ae	jmp	#LR__1544
	mov	local07, #0
	mov	local15, local11
LR__1543
	cmps	local07, local15 wc
 if_ae	jmp	#LR__1547
	mov	arg01, local05
	mov	local13, local09
	shl	local13, #10
	add	arg01, local13
	add	arg01, local07
	mov	local02, local07
	mov	local13, objptr
	add	local13, ##41048
	add	local02, local13
	rdbyte	arg02, local02
	wrbyte	arg02, arg01
	add	local07, #1
	jmp	#LR__1543
LR__1544
	mov	local07, #0
	mov	local16, local11
LR__1545
	cmps	local07, local16 wc
 if_ae	jmp	#LR__1546
	mov	arg01, local05
	mov	local15, local09
	shl	local15, #10
	add	arg01, local15
	add	arg01, local07
	mov	local02, local07
	mov	local15, objptr
	add	local15, ##41048
	add	local02, local15
	rdbyte	arg02, local02
	call	#_pspoke
	add	local07, #1
	jmp	#LR__1545
LR__1546
LR__1547
	mov	local16, local07
	shl	local16, #2
	add	objptr, ##42088
	add	local16, objptr
	shl	local07, #2
	add	local07, objptr
	rdlong	local01, local07
	add	local01, local11
	wrlong	local01, local16
	add	local09, #1
	sub	objptr, ##42088
	jmp	#LR__1542
LR__1548
LR__1549
	mov	ptra, fp
	call	#popregs_
_do_get_ret
	ret

' 
' '-------------------- getcolor
' 
' sub do_getcolor
_do_getcolor
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "getcolor "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__1550
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6016
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1551
LR__1550
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
' 
' return long[palette_ptr+4*color]
	add	objptr, #28
	rdlong	result1, objptr
	sub	objptr, #28
	shl	arg01, #2
	add	result1, arg01
	rdlong	result1, result1
	sar	result1, #8
	bitl	result1, #248
	wrlong	result1, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1551
	mov	ptra, fp
	call	#popregs_
_do_getcolor_ret
	ret

' 
' '-------------------- getenvsustain
' 
' sub do_getenvsustain
_do_getenvsustain
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "getenvsustain: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__1560
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6017
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1561
LR__1560
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg03, result1
	shl	arg03, #1
	mov	arg02, objptr
	add	arg02, ##43152
	add	arg03, arg02
	rdword	result3, arg03
	wrlong	result3, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1561
	mov	ptra, fp
	call	#popregs_
_do_getenvsustain_ret
	ret

' 
' '-------------------- getnotevalue
' 
' sub do_getnotevalue
_do_getnotevalue
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #28
	call	#_pop
	mov	arg02, result3
	add	fp, #16
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #16
	call	#_converttoint
	abs	arg01, result1 wc
	qdiv	arg01, #12
	mov	arg01, objptr
	add	arg01, ##11320
	getqy	result2
	negc	result2, result2
	abs	result1, result1 wc
	qdiv	result1, #12
	shl	result2, #2
	add	result2, arg01
	rdlong	local01, result2
	getqx	arg02
	negc	arg01, arg02
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg02, result1
	decod	arg01, #30
	call	#__system____builtin_powf
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_mul
	mov	local01, result1
	add	fp, #16
	wrlong	local01, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #16
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_getnotevalue_ret
	ret

' 
' '-------------------- getpixel
' 
' sub do_getpixel
_do_getpixel
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #36
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>2 then print "getpixel: "; : printerror(39) : return
	cmp	arg03, #2 wz
	sub	objptr, ##37408
 if_e	jmp	#LR__1570
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6018
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1571
LR__1570
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	arg03, result1
	rdlong	arg01, objptr
	add	arg01, local01
	shl	arg03, #10
	add	arg01, arg03
	call	#_pspeek
	getbyte	result1, result1, #0
	wrlong	result1, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1571
	mov	ptra, fp
	call	#popregs_
_do_getpixel_ret
	ret

' 
' 
' sub do_getrealfreq
_do_getrealfreq
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>1 then print "getrealfreq: "; : printerror(39) : return
	cmp	arg03, #1 wz
	sub	objptr, ##37408
 if_e	jmp	#LR__1580
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6019
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1581
LR__1580
	call	#_pop
	mov	arg03, result1
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #4
	call	#_converttoint
	mov	arg02, result1
	shl	arg02, #3
	sub	arg02, result1
	shl	arg02, #2
	mov	arg03, objptr
	add	arg03, ##11452
	add	arg02, arg03
	add	arg02, #24
	rdlong	arg03, arg02
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #4
	call	#_push
LR__1581
	mov	ptra, fp
	call	#popregs_
_do_getrealfreq_ret
	ret

' 
' 
' '-------------------- gettime
' 
' sub do_gettime
_do_gettime
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #20
' 
' const asm 
	getct	local01 wc
	getct	local02
' return hi1, lo1
	mov	result2, local02
	mov	result1, local01
	add	fp, #16
	wrlong	#29, fp
	sub	fp, #8
	wrlong	result2, fp
	add	fp, #4
	wrlong	result1, fp
	sub	fp, #4
	mov	arg01, fp
	sub	fp, #8
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_gettime_ret
	ret

' 
' '-------------------- gosub
' 
' sub do_gosub()
_do_gosub
	add	objptr, ##42200
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
' gosubtop+=1
' if compiledline(lineptr_e+1).result_type=token_end then
	sub	objptr, ##3252
	rdlong	_var01, objptr
	add	_var01, #1
	mov	_var02, _var01
	shl	_var02, #1
	add	_var02, _var01
	shl	_var02, #2
	sub	objptr, ##1540
	add	_var02, objptr
	add	_var02, #8
	rdlong	_var02, _var02
	cmp	_var02, #510 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__1590
	add	objptr, ##42200
	rdlong	_var02, objptr
	shl	_var02, #3
	sub	objptr, ##1928
	add	_var02, objptr
	add	objptr, ##1804
	rdlong	_var01, objptr
	wrlong	_var01, _var02
	add	objptr, #124
	rdlong	_var02, objptr
	shl	_var02, #3
	sub	objptr, ##1928
	add	_var02, objptr
	add	_var02, #4
	wrlong	#0, _var02
	sub	objptr, ##40272
	jmp	#LR__1591
LR__1590
	add	objptr, ##42200
	rdlong	_var02, objptr
	shl	_var02, #3
	sub	objptr, ##1928
	add	_var02, objptr
	add	objptr, ##1812
	rdlong	_var01, objptr
	wrlong	_var01, _var02
	add	objptr, #116
	rdlong	_var02, objptr
	shl	_var02, #3
	sub	objptr, ##1928
	add	_var02, objptr
	sub	objptr, ##1324
	rdlong	_var01, objptr
	sub	objptr, ##38948
	add	_var01, #2
	add	_var02, #4
	wrlong	_var01, _var02
LR__1591
_do_gosub_ret
	ret

' 
' '--------------------- goto
' 
' '------- fast goto
' 
' sub do_fast_goto
_do_fast_goto
	mov	COUNT_, #2
	call	#pushregs_
_do_fast_goto_enter
	add	objptr, ##38948
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #1
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	rdlong	local02, local01
	mov	arg01, local02
	sub	objptr, ##37408
	call	#_pslpeek
	mov	arg01, result1
' 
' testptr=compiledline(lineptr_e).result.uresult
' flag=pslpeek(testptr)' :print " In goto:",flag , testptr : waitms(1000)
' if flag=compiledline(lineptr_e).result.twowords(1) then
	add	objptr, ##38948
	rdlong	result1, objptr
	mov	local01, result1
	shl	local01, #1
	add	local01, result1
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	arg01, local01 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__1600
	add	objptr, ##42076
	wrlong	local02, objptr
	sub	objptr, ##3132
	rdlong	local02, objptr
	sub	local02, #1
	add	objptr, #4
	wrlong	local02, objptr
'   runptr=testptr
'   lineptr_e=lineptr-1
'   if runheader(5)=$7FFF_FFFF  then runheader(5)=0
	add	objptr, ##3204
	rdlong	local02, objptr
	sub	objptr, ##42152
	cmp	local02, ##2147483647 wz
 if_e	add	objptr, ##42152
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##42152
	jmp	#LR__1601
LR__1600
	call	#_do_find_goto
LR__1601
	mov	ptra, fp
	call	#popregs_
_do_fast_goto_ret
	ret

' 
' '------- find goto  
' 
' sub do_find_goto
_do_find_goto
	mov	COUNT_, #6
	call	#pushregs_
	add	ptra, #36
_do_find_goto_enter
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	mov	local03, objptr
	add	local02, objptr
	add	local02, #4
	rdlong	local04, local02
	add	objptr, ##1548
	rdlong	local05, objptr
' 
' gotoline=compiledline(lineptr_e).result.twowords(1)
' gotoptr=programstart
' do
	sub	objptr, ##33120
LR__1610
	mov	arg01, fp
	add	arg01, #12
	mov	arg02, local05
	mov	arg03, #24
	call	#_psram4_spin2_read1
'   psram.read1(varptr(gotoheader),gotoptr,24)  : 
'   if gotoheader(0)<>$FFFFFFFF then
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	cmp	local02, ##-1 wz
 if_ne	mov	local06, local05
 if_ne	add	fp, #32
 if_ne	rdlong	local05, fp
 if_ne	sub	fp, #32
	add	fp, #32
	rdlong	local02, fp
	sub	fp, #32
	cmp	local02, ##2147483647 wz
 if_ne	add	fp, #12
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #12
 if_ne	cmp	local01, ##-1 wz
 if_ne	add	fp, #12
 if_ne	mov	local03, local01
 if_ne	sub	fp, #12
 if_ne	cmp	local03, local04 wz
 if_ne	jmp	#LR__1610
	sub	objptr, ##5836
' 
' if gotoheader(0)=gotoline then
	add	fp, #12
	rdlong	local05, fp
	sub	fp, #12
	cmp	local05, local04 wz
 if_ne	jmp	#LR__1611
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	wrlong	local06, local02
	add	objptr, ##1540
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	local02, #8
	wrlong	#78, local02
	add	objptr, ##1540
	rdlong	local06, objptr
	mov	arg01, local06
	shl	arg01, #1
	add	arg01, local06
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	add	objptr, ##4676
	rdlong	arg02, objptr
	mov	local03, #2
	add	local03, local06
	sub	objptr, ##5724
	rdlong	arg03, objptr
	qmul	local03, arg03
	sub	objptr, ##30524
	getqx	local06
	add	arg02, local06
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	call	#_do_fast_goto
	jmp	#LR__1612
LR__1611
	mov	arg01, #38
	mov	arg02, #0
	call	#_printerror
LR__1612
	mov	ptra, fp
	call	#popregs_
_do_find_goto_ret
	ret

' 
' '------- slow goto  
' 
' sub do_slow_goto
_do_slow_goto
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	local01, result3
	add	fp, #36
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	local02, result1
	add	objptr, ##38956
	rdlong	local03, objptr
' 
' t1=pop() : gotoline=converttoint(t1)
' gotoptr=programstart
' do
	sub	objptr, ##33120
LR__1620
	mov	arg01, fp
	add	arg01, #12
	mov	arg02, local03
	mov	arg03, #24
	call	#_psram4_spin2_read1
'   psram.read1(varptr(gotoheader),gotoptr,24)  : 
'   if gotoheader(0)<>$FFFFFFFF then
	add	fp, #12
	rdlong	arg03, fp
	sub	fp, #12
	cmp	arg03, ##-1 wz
 if_ne	mov	local04, local03
 if_ne	add	fp, #32
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #32
	add	fp, #32
	rdlong	arg03, fp
	sub	fp, #32
	cmp	arg03, ##2147483647 wz
 if_ne	add	fp, #12
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #12
 if_ne	cmp	local01, ##-1 wz
 if_ne	add	fp, #12
 if_ne	mov	local05, local01
 if_ne	sub	fp, #12
 if_ne	cmp	local05, local02 wz
 if_ne	jmp	#LR__1620
	sub	objptr, ##5836
' if gotoheader(0)=gotoline then  
	add	fp, #12
	rdlong	local05, fp
	sub	fp, #12
	cmp	local05, local02 wz
 if_ne	jmp	#LR__1621
	add	objptr, ##42076
	wrlong	local04, objptr
	sub	objptr, ##3132
	rdlong	local05, objptr
	sub	local05, #1
	add	objptr, #4
	wrlong	local05, objptr
'    runptr=oldgotoptr
'    lineptr_e=lineptr-1
'   if runheader(5)=$7FFF_FFFF  then runheader(5)=0 
	add	objptr, ##3204
	rdlong	local05, objptr
	sub	objptr, ##42152
	cmp	local05, ##2147483647 wz
 if_e	add	objptr, ##42152
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##42152
LR__1621
	mov	ptra, fp
	call	#popregs_
_do_slow_goto_ret
	ret

' 
' ' ----------------  hex$
' 
' sub do_hex
_do_hex
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	local01, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>2 orelse numpar=0 then print "hex$: "; : printerror(39) : return
	cmp	local01, #3 wc
	sub	objptr, ##37408
 if_b	cmp	local01, #0 wz
 if_c_and_nz	jmp	#LR__1630
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6020
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1633
LR__1630
' if numpar=2 then t1=pop() : num=converttoint(t1) else num=8
	cmp	local01, #2 wz
 if_ne	jmp	#LR__1631
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
	jmp	#LR__1632
LR__1631
	mov	local02, #8
LR__1632
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
	mov	arg02, local02
	mov	arg03, #16
	call	#__system__Number_S
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1633
	mov	ptra, fp
	call	#popregs_
_do_hex_ret
	ret

' 
' ' ----------------  if
' 
' sub do_if
_do_if
	mov	COUNT_, #5
	call	#pushregs_
	call	#_pop
	mov	local01, result1 wz
	mov	local02, result2
	mov	local03, result3
' t1=pop()
' ' if uresult=0, jump over else
' if t1.result.uresult = 0 then 
 if_ne	jmp	#LR__1642
'   for i=lineptr_e to lineptr-1
	add	objptr, ##38948
	rdlong	local04, objptr
	sub	objptr, #4
	rdlong	local05, objptr
	sub	objptr, ##38944
LR__1640
	cmps	local04, local05 wc
 if_ae	jmp	#LR__1641
	mov	result3, local04
	shl	result3, #1
	add	result3, local04
	shl	result3, #2
	add	objptr, ##37408
	add	result3, objptr
	rdlong	local01, result3
	add	result3, #4
	rdlong	result2, result3
	mov	result3, local04
	shl	result3, #1
	add	result3, local04
	shl	result3, #2
	add	result3, objptr
	add	result3, #8
	rdlong	result3, result3
	mov	local02, result2
	mov	local03, result3
'     t1=compiledline(i)
'     if t1.result_type=token_else then lineptr_e=i : return
	cmp	local03, #90 wz
	sub	objptr, ##37408
 if_e	add	objptr, ##38948
 if_e	wrlong	local04, objptr
 if_e	sub	objptr, ##38948
 if_e	jmp	#LR__1643
	add	local04, #1
	jmp	#LR__1640
LR__1641
	add	objptr, ##38944
	rdlong	local05, objptr
	sub	local05, #1
	add	objptr, #4
	wrlong	local05, objptr
	sub	objptr, ##38948
LR__1642
LR__1643
	mov	ptra, fp
	call	#popregs_
_do_if_ret
	ret

' 
' ' ----------------  inkey$
' 
' sub do_inkey
_do_inkey
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #12
	call	#_usbnew_spin2_get_key
	add	objptr, ##36376
	wrlong	result1, objptr
' if key<>0 andalso key<$80000000 andalso (key and 255) <$E0 then  
	sub	objptr, ##36376
	cmp	result1, #0 wz
 if_e	jmp	#LR__1651
	add	objptr, ##36376
	rdlong	arg09, objptr
	sub	objptr, ##36376
	cmp	arg09, ##-2147483648 wc
 if_b	add	objptr, ##36376
 if_b	rdlong	local01, objptr
 if_b	sub	objptr, ##36376
 if_b	getbyte	local01, local01, #0
 if_b	cmp	local01, #224 wc
 if_ae	jmp	#LR__1651
'   if keyclick=1 then audio.play(7,keyclick_spl,44100,4096,spl_len) 
	add	objptr, ##42208
	rdlong	arg09, objptr
	sub	objptr, ##42208
	cmp	arg09, #1 wz
 if_ne	jmp	#LR__1650
	add	objptr, ##43136
	rdlong	arg02, objptr
	sub	objptr, #4
	rdlong	arg05, objptr
	mov	arg01, #7
	mov	arg03, ##44100
	decod	arg04, #12
	neg	arg06, #1
	neg	arg07, #1
	neg	arg08, #1
	neg	arg09, #1
	sub	objptr, ##37296
	call	#_Audio2_004_spin2_play
	sub	objptr, ##5836
LR__1650
LR__1651
' if key<>0 andalso key<$80000000 andalso (key and 255) <$E0 then
	add	objptr, ##36376
	rdlong	arg09, objptr wz
	sub	objptr, ##36376
 if_e	jmp	#LR__1660
	add	objptr, ##36376
	rdlong	arg09, objptr
	sub	objptr, ##36376
	cmp	arg09, ##-2147483648 wc
 if_b	add	objptr, ##36376
 if_b	rdlong	local01, objptr
 if_b	sub	objptr, ##36376
 if_b	getbyte	local01, local01, #0
 if_b	cmp	local01, #224 wc
 if_ae	jmp	#LR__1660
'   if leds and 2 = 2 then 
	add	objptr, ##43196
	rdlong	local01, objptr wz
	sub	objptr, ##43196
 if_e	jmp	#LR__1659
'     if key>96 andalso key<123 then
	add	objptr, ##36376
	rdlong	local01, objptr
	sub	objptr, ##36376
	cmp	local01, #97 wc
 if_b	jmp	#LR__1652
	add	objptr, ##36376
	rdlong	local01, objptr
	sub	objptr, ##36376
	cmp	local01, #123 wc
 if_ae	jmp	#LR__1652
	add	objptr, ##36376
	rdlong	local01, objptr
	sub	local01, #32
	wrlong	local01, objptr
	sub	objptr, ##36376
	jmp	#LR__1658
LR__1652
	add	objptr, ##36376
	rdlong	local01, objptr
	sub	objptr, ##36376
	cmp	local01, #65 wc
 if_b	jmp	#LR__1653
	add	objptr, ##36376
	rdlong	local01, objptr
	sub	objptr, ##36376
	cmp	local01, #91 wc
 if_ae	jmp	#LR__1653
	add	objptr, ##36376
	rdlong	local01, objptr
	add	local01, #32
	wrlong	local01, objptr
	sub	objptr, ##36376
	jmp	#LR__1657
LR__1653
	add	objptr, ##36376
	rdlong	local01, objptr
	sub	objptr, ##36376
	cmp	local01, #23 wc
 if_b	jmp	#LR__1654
	add	objptr, ##36376
	rdlong	local01, objptr
	sub	objptr, ##36376
	cmp	local01, #32 wc
 if_ae	jmp	#LR__1654
	add	objptr, ##36376
	rdlong	local01, objptr
	sub	local01, #9
	wrlong	local01, objptr
	sub	objptr, ##36376
	jmp	#LR__1656
LR__1654
	add	objptr, ##36376
	rdlong	local02, objptr
	sub	objptr, ##36376
	cmp	local02, #14 wc
 if_b	jmp	#LR__1655
	add	objptr, ##36376
	rdlong	local01, objptr
	sub	objptr, ##36376
	cmp	local01, #23 wc
 if_b	add	objptr, ##43200
 if_b	rdlong	local02, objptr
 if_b	add	local02, #39
 if_b	wrlong	local02, objptr
 if_b	sub	objptr, ##43200
LR__1655
LR__1656
LR__1657
LR__1658
LR__1659
	add	objptr, ##36376
	rdlong	arg01, objptr
	sub	objptr, ##36376
	call	#_scantochar
	mov	arg01, result1
	call	#__system__Chr_S
	wrlong	result1, fp
	jmp	#LR__1661
LR__1660
	mov	local02, ##@LR__6021
	wrlong	local02, fp
LR__1661
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_inkey_ret
	ret

' 
' ' ----------------  ink
' 
' sub do_ink
_do_ink
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	objptr, ##29152
	wrlong	result1, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##29083
	wrlong	result1, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	add	objptr, ##29083
	rdlong	arg01, objptr
	sub	objptr, ##29152
	call	#_Hg010b_4_spin2_setcursorcolor
	mov	ptra, fp
	call	#popregs_
_do_ink_ret
	ret

' 
' ' ----------------  int
' 
' sub do_int
_do_int
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #16
	call	#_pop
	mov	local01, result2
	mov	local02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
' 
' t1=pop()
' select case t1.result_type
	sub	fp, #8
	cmp	local02, #30 wz
 if_e	jmp	#LR__1670
	cmp	local02, #31 wz
 if_e	jmp	#LR__1671
	cmp	local02, #43 wz
 if_e	jmp	#LR__1672
	jmp	#LR__1673
LR__1670
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
	jmp	#LR__1673
LR__1671
	rdlong	arg01, fp
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
	jmp	#LR__1673
LR__1672
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
LR__1673
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_int_ret
	ret

' 
' ' ----------------  input
' 
' sub do_input
_do_input
	mov	COUNT_, #26
	call	#pushregs_
	add	ptra, #336
	add	objptr, ##38948
	rdlong	local04, objptr
	mov	local05, local04
	shl	local05, #1
	add	local05, local04
	shl	local05, #2
	sub	objptr, ##1540
	mov	local06, objptr
	add	local05, objptr
	rdlong	local07, local05
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<1 orelse numpar>64 then print "In input: ";: printerror(39,runheader(0)) : return
	cmp	local07, #1 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1680
	cmp	local07, #65 wc
 if_b	jmp	#LR__1681
LR__1680
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6022
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1727
LR__1681
	mov	local08, local07
	sub	local08, #1
	add	objptr, #60
	rdword	local04, objptr
	abs	local09, local04 wc
	shr	local09, #1
	negc	local09, local09
	add	objptr, #2
	rdbyte	local10, objptr
	sub	objptr, #62
' i=numpar-1
' cpx=v.cursor_x/2 : cpy=v.cursor_y
' do
LR__1682
	call	#_edit
	mov	local11, result1
' 
'   line$=edit()
' 
'   if v.cursor_y=cpy+1 then
	add	objptr, #62
	rdbyte	arg03, objptr
	sub	objptr, #62
	mov	local04, local10
	add	local04, #1
	cmp	arg03, local04 wz
 if_ne	jmp	#LR__1685
	mov	arg01, local11
	mov	local12, arg01
	callpa	#(@LR__1684-@LR__1683)>>2,fcache_load_ptr_
LR__1683
	rdbyte	result1, local12 wz
 if_ne	add	local12, #1
 if_ne	jmp	#LR__1683
LR__1684
	sub	local12, arg01
	mov	arg02, local12
	sub	arg02, local09
	add	objptr, ##29144
	rdlong	local04, objptr
	sub	objptr, ##29144
	add	arg02, local04
	mov	arg01, local11
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	mov	local11, result1
	jmp	#LR__1686
LR__1685
	mov	arg01, local11
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	mov	local11, result1
LR__1686
'   do
LR__1687
	mov	arg03, ##@LR__6023
	mov	arg01, #1
	mov	arg02, local11
	call	#__system__Instr
	mov	local13, result1
'    comma=instr(1,line$,",")  
'    if comma>0  then 
	cmp	local13, #1 wc
 if_b	jmp	#LR__1690
	mov	arg02, local13
	sub	arg02, #1
	mov	arg01, local11
	call	#__system__Left_S
	mov	local14, result1
	mov	arg01, local11
	mov	local12, arg01
	callpa	#(@LR__1689-@LR__1688)>>2,fcache_load_ptr_
LR__1688
	rdbyte	result1, local12 wz
 if_ne	add	local12, #1
 if_ne	jmp	#LR__1688
LR__1689
	sub	local12, arg01
	mov	arg02, local12
	sub	arg02, local13
	mov	arg01, local11
	call	#__system__Right_S
	mov	local11, result1
	jmp	#LR__1691
LR__1690
	mov	arg01, local11
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	mov	local14, result1
	mov	local11, ##@LR__6024
LR__1691
	mov	arg02, local08
	shl	arg02, #2
	mov	local04, fp
	add	local04, #44
	add	arg02, local04
	wrlong	local14, arg02
	sub	local08, #1
	cmps	local08, #0 wc
 if_b	jmp	#LR__1692
	mov	arg02, ##@LR__6025
	mov	arg01, local11
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1687
LR__1692
	cmps	local08, #0 wc
 if_ae	jmp	#LR__1682
' 
' for i=0 to numpar-1
	mov	local08, #0
	mov	local15, local07
LR__1693
	cmps	local08, local15 wc
 if_ae	jmp	#LR__1726
' 
'   if isnum(args(i)) and not isint(args(i)) then r=result_float 
	mov	local05, local08
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	call	#_isnum
	mov	local06, result1
	mov	local16, local08
	shl	local16, #2
	mov	local17, fp
	add	local17, #44
	add	local16, local17
	rdlong	arg01, local16
	call	#_isint
	signx	result1, #7
	andn	local06, result1 wz
 if_ne	add	objptr, ##43244
 if_ne	wrlong	#30, objptr
 if_ne	sub	objptr, ##43244
'   if isint(args(i)) then r=result_int 
	mov	local04, local08
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#_isint
	cmp	result1, #0 wz
 if_ne	add	objptr, ##43244
 if_ne	wrlong	#28, objptr
 if_ne	sub	objptr, ##43244
'   if isdec(args(i)) then r=result_uint 
	mov	local04, local08
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#_isdec
	cmp	result1, #0 wz
 if_ne	add	objptr, ##43244
 if_ne	wrlong	#29, objptr
 if_ne	sub	objptr, ##43244
'   if not isnum(args(i)) then 
	mov	local05, local08
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	call	#_isnum
	signx	result1, #7
	not	result1, result1
	cmp	result1, #0 wz
 if_e	jmp	#LR__1698
	add	objptr, ##43244
	wrlong	#43, objptr
	sub	objptr, ##43244
	mov	arg01, local14
	mov	local12, arg01
	callpa	#(@LR__1695-@LR__1694)>>2,fcache_load_ptr_
LR__1694
	rdbyte	result1, local12 wz
 if_ne	add	local12, #1
 if_ne	jmp	#LR__1694
LR__1695
	sub	local12, arg01
	mov	local18, local12
	add	objptr, ##43124
	rdlong	arg01, objptr
	sub	arg01, local18
	sub	arg01, #4
	andn	arg01, #3
	wrlong	arg01, objptr
	sub	objptr, ##43124
	mov	arg02, local18
	call	#_pslpoke
'     pslpoke memtop,l
'     for j=1 to l : pspoke memtop+3+j, asc(mid$(args(i),j,1)) : next j
	mov	local19, #1
	mov	local20, local18
	add	local20, #1
LR__1696
	cmps	local19, local20 wc
 if_ae	jmp	#LR__1697
	add	objptr, ##43124
	rdlong	local04, objptr
	sub	objptr, ##43124
	add	local04, #3
	add	local04, local19
	mov	local16, local08
	shl	local16, #2
	mov	local17, fp
	add	local17, #44
	add	local16, local17
	rdlong	arg01, local16
	mov	local06, local19
	mov	local16, #1
	mov	arg02, local06
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local05, result1
	rdbyte	arg02, local05
	mov	arg01, local04
	call	#_pspoke
	add	local19, #1
	jmp	#LR__1696
LR__1697
	add	objptr, ##43124
	rdlong	local21, objptr
	sub	objptr, ##43124
LR__1698
	call	#_pop
	mov	local22, result1
	mov	local23, result2
	mov	local04, result3
	mov	local01, local22
	mov	local02, local23
	mov	local03, local04
	mov	local24, local02
'   t1=pop() : vartype=t1.result.twowords(1)
'   select case vartype
	mov	local25, local24 wz
 if_e	jmp	#LR__1699
	cmp	local25, #256 wz
 if_e	jmp	#LR__1700
	cmp	local25, #257 wz
 if_e	jmp	#LR__1701
	cmp	local25, #258 wz
 if_e	jmp	#LR__1702
	cmp	local25, #259 wz
 if_e	jmp	#LR__1703
	cmp	local25, #260 wz
 if_e	jmp	#LR__1704
	cmp	local25, #261 wz
 if_e	jmp	#LR__1705
	cmp	local25, #262 wz
 if_e	jmp	#LR__1706
	cmp	local25, #263 wz
 if_e	jmp	#LR__1707
	cmp	local25, #264 wz
 if_e	jmp	#LR__1708
	cmp	local25, #265 wz
 if_e	jmp	#LR__1709
	cmp	local25, #266 wz
 if_e	jmp	#LR__1710
	cmp	local25, #267 wz
 if_e	jmp	#LR__1711
	jmp	#LR__1712
LR__1699
	mov	local26, #12
	jmp	#LR__1713
LR__1700
	mov	local26, #12
	jmp	#LR__1713
LR__1701
	mov	local26, #1
	jmp	#LR__1713
LR__1702
	mov	local26, #1
	jmp	#LR__1713
LR__1703
	mov	local26, #2
	jmp	#LR__1713
LR__1704
	mov	local26, #2
	jmp	#LR__1713
LR__1705
	mov	local26, #4
	jmp	#LR__1713
LR__1706
	mov	local26, #4
	jmp	#LR__1713
LR__1707
	mov	local26, #8
	jmp	#LR__1713
LR__1708
	mov	local26, #8
	jmp	#LR__1713
LR__1709
	mov	local26, #6
	jmp	#LR__1713
LR__1710
	mov	local26, #8
	jmp	#LR__1713
LR__1711
	mov	local26, #5
	jmp	#LR__1713
LR__1712
	mov	local26, #12
LR__1713
'   if esize=12 andalso t1.result.uresult<$80000 then
	cmp	local26, #12 wz
 if_ne	jmp	#LR__1717
	cmp	local01, ##524288 wc
 if_ae	jmp	#LR__1717
'     if r=result_int then lpoke t1.result.uresult, val%(args(i))
	add	objptr, ##43244
	rdlong	local22, objptr
	sub	objptr, ##43244
	cmp	local22, #28 wz
 if_ne	jmp	#LR__1714
	mov	local05, local08
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	wrlong	arg02, arg01
LR__1714
'     if r=result_uint then lpoke t1.result.uresult, val%(args(i))
	add	objptr, ##43244
	rdlong	local22, objptr
	sub	objptr, ##43244
	cmp	local22, #29 wz
 if_ne	jmp	#LR__1715
	mov	local05, local08
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	wrlong	arg02, arg01
LR__1715
'     if r=result_float then fval=val(args(i)): lpoke t1.result.uresult,lpeek(varptr(fval))
	add	objptr, ##43244
	rdlong	local22, objptr
	sub	objptr, ##43244
	cmp	local22, #30 wz
 if_ne	jmp	#LR__1716
	mov	local04, local08
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#__system____builtin_atof
	add	fp, #40
	wrlong	result1, fp
	mov	arg01, fp
	sub	fp, #40
	rdlong	result1, arg01
	mov	arg02, result1
	mov	arg01, local01
	wrlong	arg02, arg01
LR__1716
'     if r=result_string2 then lpoke t1.result.uresult,stringaddr
	add	objptr, ##43244
	rdlong	local22, objptr
	cmp	local22, #43 wz
 if_e	mov	arg01, local01
 if_e	mov	arg02, local21
 if_e	wrlong	arg02, arg01
	mov	local22, local01
	add	local22, #8
	rdlong	local04, objptr
	sub	objptr, ##43244
	mov	local23, local04
	mov	arg01, local22
	mov	arg02, local23
	wrlong	arg02, arg01
LR__1717
'   if esize=12 andalso t1.result.uresult>=$80000 then
	cmp	local26, #12 wz
 if_ne	jmp	#LR__1721
	cmp	local01, ##524288 wc
 if_b	jmp	#LR__1721
'     if r=result_int then pslpoke t1.result.uresult, val%(args(i))
	add	objptr, ##43244
	rdlong	local22, objptr
	sub	objptr, ##43244
	cmp	local22, #28 wz
 if_ne	jmp	#LR__1718
	mov	local05, local08
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_pslpoke
LR__1718
'     if r=result_uint then pslpoke t1.result.uresult, val%(args(i))
	add	objptr, ##43244
	rdlong	local22, objptr
	sub	objptr, ##43244
	cmp	local22, #29 wz
 if_ne	jmp	#LR__1719
	mov	local05, local08
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_pslpoke
LR__1719
'     if r=result_float then fval=val(args(i)): pslpoke t1.result.uresult,lpeek(varptr(fval))
	add	objptr, ##43244
	rdlong	local22, objptr
	sub	objptr, ##43244
	cmp	local22, #30 wz
 if_ne	jmp	#LR__1720
	mov	local04, local08
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#__system____builtin_atof
	add	fp, #40
	wrlong	result1, fp
	mov	arg01, fp
	sub	fp, #40
	rdlong	arg02, arg01
	mov	arg01, local01
	call	#_pslpoke
LR__1720
'     if r=result_string2 then pslpoke t1.result.uresult,stringaddr
	add	objptr, ##43244
	rdlong	local22, objptr
	sub	objptr, ##43244
	cmp	local22, #43 wz
 if_e	mov	arg01, local01
 if_e	mov	arg02, local21
 if_e	call	#_pslpoke
	mov	arg01, local01
	add	arg01, #8
	add	objptr, ##43244
	rdlong	local23, objptr
	sub	objptr, ##43244
	mov	arg02, local23
	call	#_pslpoke
LR__1721
'   if esize=5 andalso r=result_string2 then pslpoke t1.result.uresult,stringaddr
	cmp	local26, #5 wz
 if_e	add	objptr, ##43244
 if_e	rdlong	local23, objptr
 if_e	sub	objptr, ##43244
 if_e	cmp	local23, #43 wz
 if_e	mov	local23, local21
 if_e	mov	arg01, local01
 if_e	mov	arg02, local23
 if_e	call	#_pslpoke
'   if esize=4 andalso r<>result_string2 then pslpoke t1.result.uresult,val%(args(i))
	cmp	local26, #4 wz
 if_ne	jmp	#LR__1722
	add	objptr, ##43244
	rdlong	local23, objptr
	sub	objptr, ##43244
	cmp	local23, #43 wz
 if_e	jmp	#LR__1722
	mov	local05, local08
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_pslpoke
LR__1722
'   if esize=2 andalso r<>result_string2 then psdpoke t1.result.uresult,val%(args(i))
	cmp	local26, #2 wz
 if_ne	jmp	#LR__1723
	add	objptr, ##43244
	rdlong	local23, objptr
	sub	objptr, ##43244
	cmp	local23, #43 wz
 if_e	jmp	#LR__1723
	mov	local05, local08
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_psdpoke
LR__1723
'   if esize=1 andalso r<>result_string2 then pspoke t1.result.uresult,val%(args(i))
	cmp	local26, #1 wz
 if_ne	jmp	#LR__1724
	add	objptr, ##43244
	rdlong	local23, objptr
	sub	objptr, ##43244
	cmp	local23, #43 wz
 if_e	jmp	#LR__1724
	mov	local05, local08
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_pspoke
LR__1724
'   if esize=6 andalso r<>result_string2 then fval=val(args(i)): pslpoke t1.result.uresult,lpeek(varptr(fval))
	cmp	local26, #6 wz
 if_ne	jmp	#LR__1725
	add	objptr, ##43244
	rdlong	local23, objptr
	sub	objptr, ##43244
	cmp	local23, #43 wz
 if_e	jmp	#LR__1725
	mov	local04, local08
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#__system____builtin_atof
	add	fp, #40
	wrlong	result1, fp
	mov	arg01, fp
	sub	fp, #40
	rdlong	arg02, arg01
	mov	arg01, local01
	call	#_pslpoke
LR__1725
	add	local08, #1
	jmp	#LR__1693
LR__1726
LR__1727
	mov	ptra, fp
	call	#popregs_
_do_input_ret
	ret

' 
' ' ----------------  left$
' 
' sub do_left
_do_left
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>2  then print "left$: "; : printerror(39) : return
	cmp	arg03, #2 wz
	sub	objptr, ##37408
 if_e	jmp	#LR__1730
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6026
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1733
LR__1730
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : arg=converttoint(t1)
' t1=pop(): if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1731
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1731
' if t1.result_type<>result_string then print "left$: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1732
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6027
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1733
LR__1732
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system__Left_S
	wrlong	result1, fp
	mov	arg01, fp
	call	#_push
LR__1733
	mov	ptra, fp
	call	#popregs_
_do_left_ret
	ret

' 
' ' ----------------  len
' 
' sub do_len
_do_len
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "len: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__1740
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6028
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1745
LR__1740
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1741
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1741
' if t1.result_type<>result_string then print "len: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1742
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6029
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1745
LR__1742
	rdlong	arg01, fp
	mov	local01, arg01
	callpa	#(@LR__1744-@LR__1743)>>2,fcache_load_ptr_
LR__1743
	rdbyte	result1, local01 wz
 if_ne	add	local01, #1
 if_ne	jmp	#LR__1743
LR__1744
	sub	local01, arg01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1745
	mov	ptra, fp
	call	#popregs_
_do_len_ret
	ret

' 
' ' ----------------  list
' 
' sub do_list
_do_list
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #184
	mov	local01, #0
	bmask	local02, #30
	add	objptr, ##38948
	rdlong	local03, objptr
	mov	arg03, local03
	shl	arg03, #1
	add	arg03, local03
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local04, arg03
' 
' startline=0 : endline=$7FFFFFFF
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=1 then t1=pop() : startline=converttoint(t1)
	cmp	local04, #1 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__1750
	call	#_pop
	mov	local03, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
LR__1750
' if numpar=2 then t1=pop() : endline=converttoint(t1) : t1=pop() : startline=converttoint(t1)
	cmp	local04, #2 wz
 if_ne	jmp	#LR__1751
	call	#_pop
	mov	local03, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	call	#_pop
	mov	local03, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
LR__1751
' 
' 
' print
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##38956
	rdlong	local04, objptr
	add	objptr, ##4300
	wrlong	local04, objptr
	sub	objptr, ##43256
' do 
LR__1752
	mov	arg01, fp
	add	arg01, #32
	add	objptr, ##43256
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##37420
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
'   psram.read1(varptr(header),listptr,24) ': print header(0),header(1),header(2),header(3),header(4),header(5), programstart : waitms 7000 : waitms 7000 : waitms 7000
'   
'   if header(0)<> $FFFFFFFF then
	add	fp, #32
	rdlong	local04, fp
	sub	fp, #32
	cmp	local04, ##-1 wz
 if_e	jmp	#LR__1754
	mov	arg01, fp
	add	arg01, #56
	mov	arg03, #63
	setq	arg03
	wrlong	#0, arg01
	mov	arg01, fp
	add	arg01, #56
	add	fp, #40
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #44
	add	objptr, ##5836
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
'     longfill(linebuf,0,64)
'     psram.read1(varptr(linebuf),header(2),header(3))
'     if header(0)>=startline andalso header(0)<=endline then v.writeln(varptr(linebuf))  
	add	fp, #32
	rdlong	local04, fp
	sub	fp, #32
	cmps	local04, local01 wc
 if_b	jmp	#LR__1753
	add	fp, #32
	rdlong	local03, fp
	sub	fp, #32
	cmps	local03, local02 wcz
 if_a	jmp	#LR__1753
	mov	arg01, fp
	add	arg01, #56
' 
' write(text)
	call	#_Hg010b_4_spin2_write
' crlf
	call	#_Hg010b_4_spin2_crlf
LR__1753
	add	fp, #52
	rdlong	local04, fp
	sub	fp, #52
	add	objptr, ##43256
	wrlong	local04, objptr
	sub	objptr, ##43256
LR__1754
	add	fp, #52
	rdlong	local04, fp
	sub	fp, #52
	cmp	local04, ##2147483647 wz
 if_ne	add	fp, #32
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #32
 if_ne	cmp	local03, ##-1 wz
 if_ne	jmp	#LR__1752
	mov	ptra, fp
	call	#popregs_
_do_list_ret
	ret

' 
' '-------------------- load
' 
' sub do_load(amode=0 as integer)  
_do_load
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #172
	mov	local04, arg01
	add	objptr, ##43184
	wrlong	#1, objptr
	sub	objptr, ##4236
	rdlong	arg02, objptr
	mov	arg01, arg02
	shl	arg01, #1
	add	arg01, arg02
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	local05, arg01
	mov	arg01, fp
	add	arg01, #168
	sub	objptr, ##37408
	mov	arg02, fp
	add	arg02, #40
	wrlong	arg02, arg01
' 
' inload=1
' numpar=compiledline(lineptr_e).result.uresult
' lpoke varptr(line2$),varptr(line2)
' if numpar>0 then t1=pop() else t1.result.sresult=loadname : t1.result_type=result_string 
	cmps	local05, #1 wc
 if_b	jmp	#LR__1760
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	jmp	#LR__1761
LR__1760
	add	objptr, ##43168
	rdlong	local01, objptr
	sub	objptr, ##43168
	mov	local03, #31
LR__1761
' 'print "popped "; t1.result.uresult, t1.result_type
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult): t1.result_type=result_string ': print t1.result.sresult
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1762
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1762
' if t1.result_type=result_string then
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1766
'   if amode<>1234 then do_new
	cmp	local04, ##1234 wz
 if_ne	call	#_do_new
'   if t1.result.sresult="" then t1.result.sresult=loadname else loadname=t1.result.sresult
	mov	arg02, ##@LR__6030
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##43168
 if_e	rdlong	local01, objptr
	sumz	objptr, ##43168
 if_ne	wrlong	local01, objptr
 if_ne	sub	objptr, ##43168
'   close #9: open currentdir$+"/"+t1.result.sresult for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local05, #9
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__6031
	call	#__system___string_concat
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local05
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
'   r=geterr() 
'   if r then 
 if_e	jmp	#LR__1764
'     close #9: open currentdir$+"/"+t1.result.sresult+".bas" for input as #9 
	mov	arg01, #9
	call	#__system__close
	mov	local06, #9
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__6032
	call	#__system___string_concat
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_concat
	mov	arg01, result1
	mov	arg02, ##@LR__6033
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local06
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local07, result1 wz
'     r=geterr() 
'     if r then 
 if_e	jmp	#LR__1763
'       print "System error ";r;": ";strerror$(r) :close #9 : return
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6034
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local07
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__6035
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, local07
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1768
LR__1763
	add	objptr, ##43168
	rdlong	arg01, objptr
	sub	objptr, ##43168
	mov	arg02, ##@LR__6036
	call	#__system___string_concat
	add	objptr, ##43168
	wrlong	result1, objptr
	sub	objptr, ##43168
LR__1764
'   close #9: open currentdir$+"/"+loadname for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local06, #9
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__6037
	call	#__system___string_concat
	mov	arg01, result1
	add	objptr, ##43168
	rdlong	arg02, objptr
	sub	objptr, ##43168
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local06
	mov	arg03, #0
	call	#__system___basic_open_string
'   do
LR__1765
	mov	arg01, #9
	call	#__system___basic_read_line
	mov	local06, result1
	add	objptr, ##29120
	wrlong	local06, objptr
	sub	objptr, ##29120
	call	#_interpret
	add	objptr, ##29120
	rdlong	arg01, objptr
	sub	objptr, ##29120
	mov	arg02, ##@LR__6038
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1765
'   close #9   
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1767
LR__1766
	mov	arg01, #30
	mov	arg02, #0
	call	#_printerror
LR__1767
' print "Loaded ";currentdir$+"/"+loadname
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6039
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local07, #0
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__6040
	call	#__system___string_concat
	mov	arg01, result1
	add	objptr, ##43168
	rdlong	arg02, objptr
	sub	objptr, ##43168
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local07
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##43184
	wrlong	#0, objptr
	sub	objptr, ##43184
LR__1768
	mov	ptra, fp
	call	#popregs_
_do_load_ret
	ret

' 
' '-------------------- log
' 
' sub do_log
_do_log
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	local01, arg02 wz
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=0 orelse numpar>2 then print "log: "; : printerror(39) : return
	sub	objptr, ##37408
 if_ne	cmp	local01, #3 wc
 if_c_and_nz	jmp	#LR__1770
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6041
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1773
LR__1770
' if numpar=2 then 
	cmp	local01, #2 wz
 if_ne	jmp	#LR__1771
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	mov	local02, result1
	jmp	#LR__1772
LR__1771
	mov	local02, ##1065353216
LR__1772
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	mov	arg01, result1
	mov	arg02, local02
	call	#__system___float_div
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1773
	mov	ptra, fp
	call	#popregs_
_do_log_ret
	ret

' 
' '-------------------- lpeek
' 
' sub do_lpeek
_do_lpeek
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
' 
' t1=pop()
' a=converttoint(t1)
' if a<$80000 then r=lpeek(a) else r=pslpeek(a)
	cmp	arg01, ##524288 wc
 if_b	rdlong	local01, arg01
 if_b	jmp	#LR__1780
	call	#_pslpeek
	mov	local01, result1
LR__1780
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	local01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_lpeek_ret
	ret

' 
' '-------------------- lpoke
' 
' sub do_lpoke
_do_lpoke
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
' 
' t1=pop() 'value
' t2=pop() 
' a=converttoint(t2) : v=converttoint(t1)
' if a<$80000 then lpoke a,v else pslpoke a,v
	cmp	local01, ##524288 wc
 if_b	wrlong	local02, local01
 if_ae	mov	arg01, local01
 if_ae	mov	arg02, local02
 if_ae	call	#_pslpoke
	mov	ptra, fp
	call	#popregs_
_do_lpoke_ret
	ret

' 
' '-------------------- memlo
' 
' sub do_memlo
_do_memlo
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	objptr, ##35328
	rdlong	arg01, objptr
	sub	objptr, ##35328
	wrlong	arg01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_memlo_ret
	ret

' 
' '-------------------- memtop
' 
' sub do_memtop
_do_memtop
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	objptr, ##43124
	rdlong	arg01, objptr
	sub	objptr, ##43124
	wrlong	arg01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_memtop_ret
	ret

' 
' '-------------------- mid$
' 
' sub do_mid
_do_mid
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>3  then print "mid$: "; : printerror(39) : return
	cmp	arg03, #3 wz
	sub	objptr, ##37408
 if_e	jmp	#LR__1790
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6042
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1793
LR__1790
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : arg2=converttoint(t1)
' t1=pop() : arg1=converttoint(t1)
' t1=pop(): if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1791
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1791
' if t1.result_type<>result_string then print "mid$: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1792
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6043
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1793
LR__1792
	rdlong	arg01, fp
	mov	arg02, local02
	mov	arg03, local01
	call	#__system__Mid_S
	wrlong	result1, fp
	mov	arg01, fp
	call	#_push
LR__1793
	mov	ptra, fp
	call	#popregs_
_do_mid_ret
	ret

' 
' '-------------------- mkdir
' 
' sub do_mkdir
_do_mkdir
	mov	COUNT_, #4
	call	#pushregs_
	call	#_pop
	mov	arg04, result2
	mov	arg03, result3
	mov	local01, result1
	mov	local02, arg04
	mov	local03, arg03
' 
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1800
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1800
' if t1.result_type<>result_string then printerror(15): return
	cmp	local03, #31 wz
 if_e	jmp	#LR__1801
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1803
LR__1801
	mov	arg01, local01
	call	#__system___mkdir
	mov	local04, result1 wz
' filename$=t1.result.sresult
' err=mkdir(filename$)
' 'err=geterr() : 
' if err<>0 then print "Cannot create a directory: system error "; err
 if_e	jmp	#LR__1802
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6044
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local04
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__1802
LR__1803
	mov	ptra, fp
	call	#popregs_
_do_mkdir_ret
	ret

' 
' '-------------------- mode
' 
' sub do_mode
_do_mode
	mov	COUNT_, #5
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1810
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1810
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1811
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1811
' select case t1.result.iresult
	mov	local04, local01
	fle	local04, #6
	jmprel	local04
LR__1812
	jmp	#LR__1813
	jmp	#LR__1814
	jmp	#LR__1815
	jmp	#LR__1816
	jmp	#LR__1817
	jmp	#LR__1818
	jmp	#LR__1819
LR__1813
	add	objptr, ##29156
	wrlong	#1, objptr
	sub	objptr, #4
	wrlong	#154, objptr
	add	objptr, ##13056
	wrlong	#1, objptr
	sub	objptr, ##13060
	wrlong	#147, objptr
	sub	objptr, ##29148
	mov	arg01, #4
	call	#_Hg010b_4_spin2_setfontfamily
	add	objptr, ##29152
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##29083
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	mov	local04, ptr__dat__
	add	local04, ##512
	add	objptr, ##43067
	wrlong	local04, objptr
	sub	objptr, #4
	wrlong	##1688, objptr
	sub	objptr, ##43132
	jmp	#LR__1819
LR__1814
	add	objptr, ##29156
	wrlong	#0, objptr
	sub	objptr, #4
	wrlong	#23, objptr
	add	objptr, ##13056
	wrlong	#0, objptr
	sub	objptr, ##13060
	wrlong	#0, objptr
	sub	objptr, ##29148
	mov	arg01, #0
	call	#_Hg010b_4_spin2_setfontfamily
	add	objptr, ##29152
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##29083
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #69
	jmp	#LR__1819
LR__1815
	add	objptr, ##29156
	wrlong	#0, objptr
	sub	objptr, #4
	wrlong	#181, objptr
	add	objptr, ##13056
	wrlong	#0, objptr
	sub	objptr, ##13060
	wrlong	#0, objptr
	sub	objptr, ##29148
	mov	arg01, #0
	call	#_Hg010b_4_spin2_setfontfamily
	add	objptr, ##29152
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##29083
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #69
	jmp	#LR__1819
LR__1816
	add	objptr, ##29156
	wrlong	#0, objptr
	sub	objptr, #4
	wrlong	#15, objptr
	add	objptr, ##13056
	wrlong	#0, objptr
	sub	objptr, ##13060
	wrlong	#0, objptr
	sub	objptr, ##29148
	mov	arg01, #0
	call	#_Hg010b_4_spin2_setfontfamily
	add	objptr, ##29152
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##29083
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #69
	jmp	#LR__1819
LR__1817
	add	objptr, ##29156
	wrlong	#1, objptr
	sub	objptr, #4
	wrlong	#1, objptr
	add	objptr, ##13056
	wrlong	#1, objptr
	sub	objptr, ##13060
	wrlong	#14, objptr
	sub	objptr, ##29148
	mov	arg01, #4
	call	#_Hg010b_4_spin2_setfontfamily
	add	objptr, ##29152
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##29083
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	mov	local05, ptr__dat__
	add	local05, ##3970
	add	objptr, ##43067
	wrlong	local05, objptr
	sub	objptr, #4
	wrlong	##1688, objptr
	sub	objptr, ##43132
	jmp	#LR__1819
LR__1818
	add	objptr, ##29156
	wrlong	#2, objptr
	sub	objptr, #4
	wrlong	#1, objptr
	add	objptr, ##13056
	wrlong	#1, objptr
	sub	objptr, ##13060
	wrlong	#7, objptr
	sub	objptr, ##29148
	mov	arg01, #8
	call	#_Hg010b_4_spin2_setfontfamily
	add	objptr, ##29152
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##29083
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	mov	local05, ptr__dat__
	add	local05, ##3970
	add	objptr, ##43067
	wrlong	local05, objptr
	sub	objptr, #4
	wrlong	##1688, objptr
	sub	objptr, ##43132
LR__1819
	add	objptr, ##43128
	wrlong	local01, objptr
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, ##7796
	rdlong	local05, objptr
	sub	objptr, ##35328
	sub	arg01, local05
	mov	arg02, #0
	mov	arg03, #10
	call	#__system__Number_S
	mov	arg01, result1
	mov	arg02, ##@LR__6045
	call	#__system___string_concat
	add	objptr, ##42204
	wrlong	result1, objptr
	sub	objptr, ##13052
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##29148
	call	#_Hg010b_4_spin2_cls
	mov	arg01, ##@LR__6046
' 
' write(text)
	call	#_Hg010b_4_spin2_write
' crlf
	call	#_Hg010b_4_spin2_crlf
	add	ptr__dat__, ##12608
	rdlong	arg01, ptr__dat__
	sub	ptr__dat__, ##12608
' 
' write(text)
	call	#_Hg010b_4_spin2_write
' crlf
	call	#_Hg010b_4_spin2_crlf
	add	objptr, ##42204
	rdlong	arg01, objptr
	sub	objptr, ##42204
' 
' write(text)
	call	#_Hg010b_4_spin2_write
' crlf
	call	#_Hg010b_4_spin2_crlf
	mov	ptra, fp
	call	#popregs_
_do_mode_ret
	ret

' 
' '-------------------- mouse
' 
' sub do_mouse
_do_mouse
	call	#_pop
	cmps	result1, #0 wz
' 
' t1=pop()
' if t1.result.uresult=0 then v.setspritesize(16,0,0) else v.setspritesize(16,32,32)
 if_ne	jmp	#LR__1820
	mov	arg01, #16
	mov	arg02, #0
	mov	arg03, #0
	call	#_Hg010b_4_spin2_setspritesize
	jmp	#LR__1821
LR__1820
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_Hg010b_4_spin2_setspritesize
LR__1821
_do_mouse_ret
	ret

' 
' '-------------------- mousek
' 
' sub do_mousek
_do_mousek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	add	objptr, ##42740
	rdlong	arg01, objptr
	sub	objptr, ##42740
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousek_ret
	ret

' 
' '-------------------- mousew
' 
' sub do_mousew
_do_mousew
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	add	objptr, ##42744
	rdlong	arg01, objptr
	sub	objptr, ##42744
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousew_ret
	ret

' 
' '-------------------- mousex
' 
' sub do_mousex
_do_mousex
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	add	objptr, ##42732
	rdlong	arg01, objptr
	sub	objptr, ##42732
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousex_ret
	ret

' 
' '-------------------- mousey
' 
' sub do_mousey
_do_mousey
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	add	objptr, ##42736
	rdlong	arg01, objptr
	sub	objptr, ##42736
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousey_ret
	ret

' 
' '------------------ new
' 
' sub do_new
_do_new
	mov	COUNT_, #3
	call	#pushregs_
' 
' if inrun=1 then inrun=2
	add	objptr, ##42128
	rdlong	arg03, objptr
	sub	objptr, ##42128
	cmp	arg03, #1 wz
 if_e	add	objptr, ##42128
 if_e	wrlong	#2, objptr
 if_e	sub	objptr, ##42128
	decod	arg01, #19
	neg	arg02, #1
	call	#_pslpoke
	add	objptr, ##28076
	wrlong	#0, objptr
' pslpoke(memlo,$FFFFFFFF)
' varnum=0 : for i=0 to maxvars: variables(i).name="" : variables(i).vartype=0: next i
	mov	local01, #0
	sub	objptr, ##16400
	callpa	#(@LR__1831-@LR__1830)>>2,fcache_load_ptr_
LR__1830
	mov	arg03, local01
	shl	arg03, #4
	add	arg03, objptr
	mov	arg02, ##@LR__6047
	wrlong	arg02, arg03
	mov	local02, local01
	shl	local02, #4
	add	local02, objptr
	add	local02, #12
	wrlong	#0, local02
	add	local01, #1
	cmps	local01, ##1025 wc
 if_b	jmp	#LR__1830
LR__1831
	add	objptr, ##27280
	wrlong	##524288, objptr
	add	objptr, ##3120
	wrlong	##524288, objptr
	add	objptr, #4
	wrlong	##524288, objptr
	sub	objptr, ##6756
	wrlong	#0, objptr
	add	objptr, ##3620
	wrlong	#0, objptr
	sub	objptr, ##3616
	wrlong	##524288, objptr
	add	objptr, ##6864
	wrlong	#0, objptr
	mov	local03, ##@LR__6048
	add	objptr, ##1000
	wrlong	local03, objptr
	sub	objptr, ##4232
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	add	objptr, ##3232
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	#0, objptr
' programstart=memlo :runptr=memlo : runptr2=memlo
' stackpointer=0
' lineptr=0 
' programptr=memlo ': stringptr=0
' dataptr=0 : readline=""
' lastline=0 : lastlineptr=-1 :fortop=0 :gosubtop=0
' for i=0 to maxfor: fortable(i).varnum=-1 : next i
	mov	local01, #0
	sub	objptr, ##3228
	callpa	#(@LR__1833-@LR__1832)>>2,fcache_load_ptr_
LR__1832
	mov	local02, local01
	shl	local02, #2
	add	local02, local01
	shl	local02, #2
	add	local02, objptr
	add	local02, #8
	wrlong	##-1, local02
	add	local01, #1
	cmps	local01, #65 wc
 if_b	jmp	#LR__1832
LR__1833
	sub	objptr, ##38972
' for i=0 to 15: if sprite(i)<> nil then v.setspritesize(i,0,0) : delete(sprite(i)) 
	mov	local01, #0
LR__1834
	mov	arg03, local01
	shl	arg03, #2
	mov	local02, objptr
	add	local02, ##43056
	add	arg03, local02
	rdlong	local03, arg03 wz
 if_e	jmp	#LR__1835
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	call	#_Hg010b_4_spin2_setspritesize
	mov	local02, local01
	shl	local02, #2
	mov	local03, objptr
	add	local03, ##43056
	add	local02, local03
	rdlong	arg01, local02
	call	#__system___gc_free
LR__1835
	add	local01, #1
	cmps	local01, #16 wc
 if_b	jmp	#LR__1834
	add	objptr, ##43140
	wrlong	##1065353216, objptr
	add	objptr, #4
	wrlong	##1065353216, objptr
	sub	objptr, ##43140
	rdlong	local03, objptr
	add	objptr, ##43120
	wrlong	local03, objptr
	sub	objptr, ##43124
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_Hg010b_4_spin2_setspritesize
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_Hg010b_4_spin2_setspritesize
	mov	local03, ##@LR__6049
	add	objptr, ##43168
	wrlong	local03, objptr
	sub	objptr, ##43168
	call	#_init_audio
	mov	ptra, fp
	call	#popregs_
_do_new_ret
	ret

' 
' '-------------------- next
' 
' sub do_next()
_do_next
	mov	COUNT_, #4
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() :varnum=t1.result.uresult
' if fortable(fortop).varnum<>t1.result.uresult then printerror(37) : return
	add	objptr, ##42196
	rdlong	arg02, objptr
	mov	arg01, arg02
	shl	arg01, #2
	add	arg01, arg02
	shl	arg01, #2
	sub	objptr, ##3224
	add	arg01, objptr
	add	arg01, #8
	rdlong	arg02, arg01
	cmp	arg02, local01 wz
	sub	objptr, ##38972
 if_e	jmp	#LR__1840
	mov	arg01, #37
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1847
LR__1840
' if variables(varnum).vartype=result_float then variables(varnum).vartype=result_int : variables(varnum).value.iresult=round(variables(varnum).value.fresult)
	mov	arg02, local01
	shl	arg02, #4
	mov	arg01, objptr
	add	arg01, ##11676
	add	arg02, arg01
	add	arg02, #12
	rdlong	arg02, arg02
	cmp	arg02, #30 wz
 if_ne	jmp	#LR__1841
	mov	arg02, local01
	shl	arg02, #4
	add	objptr, ##11676
	add	arg02, objptr
	add	arg02, #12
	wrlong	#28, arg02
	mov	local04, local01
	shl	local04, #4
	add	local04, objptr
	mov	arg02, local01
	shl	arg02, #4
	add	arg02, objptr
	add	arg02, #4
	rdlong	arg01, arg02
	sub	objptr, ##11676
	mov	arg02, #1
	call	#__system___float_tointeger
	add	local04, #4
	wrlong	result1, local04
LR__1841
	mov	local04, local01
	shl	local04, #4
	add	objptr, ##11676
	add	local04, objptr
	mov	arg02, local01
	shl	arg02, #4
	add	arg02, objptr
	add	objptr, ##30520
	rdlong	arg01, objptr
	mov	result3, arg01
	shl	result3, #2
	add	result3, arg01
	shl	result3, #2
	sub	objptr, ##3224
	add	result3, objptr
	add	arg02, #4
	rdlong	arg01, arg02
	add	result3, #12
	rdlong	result3, result3
	add	arg01, result3
	add	local04, #4
	wrlong	arg01, local04
' variables(varnum).value.iresult+=fortable(fortop).stepval 
' if fortable(fortop).stepval>=0 then
	add	objptr, ##3224
	rdlong	local04, objptr
	mov	arg01, local04
	shl	arg01, #2
	add	arg01, local04
	shl	arg01, #2
	sub	objptr, ##3224
	add	arg01, objptr
	add	arg01, #12
	rdlong	arg01, arg01
	cmps	arg01, #0 wc
	sub	objptr, ##38972
 if_b	jmp	#LR__1842
'   if variables(varnum).value.iresult>fortable(fortop).endval then fortop-=1 : return ' do nothing 
	shl	local01, #4
	add	objptr, ##11676
	add	local01, objptr
	add	objptr, ##30520
	rdlong	arg01, objptr
	mov	local04, arg01
	shl	local04, #2
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##3224
	add	local04, objptr
	add	local01, #4
	rdlong	local01, local01
	add	local04, #16
	rdlong	local04, local04
	cmps	local01, local04 wcz
	sub	objptr, ##38972
 if_be	jmp	#LR__1844
	add	objptr, ##42196
	rdlong	local04, objptr
	sub	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##42196
	jmp	#LR__1847
LR__1842
'   if variables(varnum).value.iresult<fortable(fortop).endval then fortop -=1 : return ' do nothing 
	mov	local04, local01
	shl	local04, #4
	add	objptr, ##11676
	add	local04, objptr
	add	objptr, ##30520
	rdlong	local01, objptr
	mov	arg01, local01
	shl	arg01, #2
	add	arg01, local01
	shl	arg01, #2
	sub	objptr, ##3224
	add	arg01, objptr
	add	local04, #4
	rdlong	local04, local04
	add	arg01, #16
	rdlong	arg01, arg01
	cmps	local04, arg01 wc
	sub	objptr, ##38972
 if_ae	jmp	#LR__1843
	add	objptr, ##42196
	rdlong	local04, objptr
	sub	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##42196
	jmp	#LR__1847
LR__1843
LR__1844
' ' if not returned, goto pointer 
' if inrun>0 andalso runptr<>fortable(fortop).lineptr then
	add	objptr, ##42128
	rdlong	local04, objptr
	sub	objptr, ##42128
	cmp	local04, #1 wc
 if_b	jmp	#LR__1845
	add	objptr, ##42196
	rdlong	local04, objptr
	mov	local01, local04
	shl	local01, #2
	add	local01, local04
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	add	objptr, ##3104
	rdlong	local04, objptr
	sub	objptr, ##42076
	rdlong	local01, local01
	cmp	local04, local01 wz
 if_e	jmp	#LR__1845
	add	objptr, ##42196
	rdlong	local04, objptr
	mov	local01, local04
	shl	local01, #2
	add	local01, local04
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	rdlong	local01, local01
	add	objptr, ##3104
	wrlong	local01, objptr
	add	objptr, #120
	rdlong	local04, objptr
	mov	local01, local04
	shl	local01, #2
	add	local01, local04
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	add	objptr, ##3108
	wrlong	local01, objptr
	sub	objptr, ##3136
	rdlong	local04, objptr
	sub	local04, #1
	add	objptr, #4
	wrlong	local04, objptr
	sub	objptr, ##38948
	jmp	#LR__1846
LR__1845
	add	objptr, ##42196
	rdlong	local04, objptr
	mov	local01, local04
	shl	local01, #2
	add	local01, local04
	shl	local01, #2
	sub	objptr, ##3224
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	sub	local01, #1
	sub	objptr, #24
	wrlong	local01, objptr
	sub	objptr, ##38948
LR__1846
LR__1847
	mov	ptra, fp
	call	#popregs_
_do_next_ret
	ret

' 
' '-------------------- no command (print "Unknown command")
' 
' sub do_no_command
_do_no_command
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #23
	call	#_printerror
_do_no_command_ret
	ret

' 
' '-------------------- nothing
' 
' sub do_nothing					' a placeholder for tokens that don't do anything by themselves
_do_nothing
_do_nothing_ret
	ret

' 
' '-------------------- on
' 
' sub do_on
_do_on
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38948
	rdlong	arg01, objptr
	mov	result2, arg01
	shl	result2, #1
	add	result2, arg01
	shl	result2, #2
	sub	objptr, ##1540
	add	result2, objptr
	rdlong	local01, result2
	mov	local02, arg01
	shl	local02, #1
	add	local02, arg01
	shl	local02, #2
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	sub	objptr, ##37408
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
' 
' numpar=compiledline(lineptr_e).result.uresult
' skip=compiledline(lineptr_e).result.twowords(1)
' t1=pop()
' t=converttoint(t1)
' if t<1 orelse t>numpar then return
	cmps	result1, #1 wc
 if_b	jmp	#LR__1850
	cmps	result1, local01 wcz
 if_a	jmp	#LR__1850
	sub	result1, #1
	qmul	local02, result1
	add	objptr, ##38948
	rdlong	local01, objptr
	getqx	local02
	add	local01, local02
	wrlong	local01, objptr
	sub	objptr, ##38948
LR__1850
	mov	ptra, fp
	call	#popregs_
_do_on_ret
	ret

' 
' '-------------------- open
' 
' sub do_open
_do_open
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' 
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1860
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1860
' if t1.result_type<>result_string then  print "filename expected" : return  ' error here
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1861
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6050
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	jmp	#LR__1872
LR__1861
	rdlong	local01, fp
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' filename=t1.result.sresult
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1862
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1862
	mov	local02, #0
' mode=0
' if t1.result_type=result_string then
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #31 wz
 if_ne	jmp	#LR__1863
'   if t1.result.sresult="read" then mode=1
	rdlong	arg01, fp
	mov	arg02, ##@LR__6051
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local02, #1
'   if t1.result.sresult="write" then mode=2
	rdlong	arg01, fp
	mov	arg02, ##@LR__6052
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local02, #2
'   if t1.result.sresult="append" then mode=4
	rdlong	arg01, fp
	mov	arg02, ##@LR__6053
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local02, #4
	jmp	#LR__1864
LR__1863
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
LR__1864
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop()
' if t1.result_type<>result_channel then print "channel# expected" : return  
	sub	fp, #8
	cmp	arg03, #44 wz
 if_e	jmp	#LR__1865
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6054
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	jmp	#LR__1872
LR__1865
	rdlong	local03, fp
' channel  = t1.result.iresult
' select case  mode
	mov	local04, local02
	sub	local04, #1
	fle	local04, #4
	jmprel	local04
LR__1866
	jmp	#LR__1867
	jmp	#LR__1868
	jmp	#LR__1870
	jmp	#LR__1869
	jmp	#LR__1870
LR__1867
	mov	arg01, local03
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_open_string
	jmp	#LR__1871
LR__1868
	mov	arg01, local03
	mov	arg02, local01
	mov	arg03, #13
	call	#__system___basic_open_string
	jmp	#LR__1871
LR__1869
	mov	arg01, local03
	mov	arg02, local01
	mov	arg03, #37
	call	#__system___basic_open_string
	jmp	#LR__1871
LR__1870
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6055
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__1871
LR__1872
	mov	ptra, fp
	call	#popregs_
_do_open_ret
	ret

' 
' ' ------------------ padrx
' 
' sub do_padrx
_do_padrx
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "padrx: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1880
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6056
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1884
LR__1880
' if numpar=0 then 
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1881
	mov	local02, ##931135488
	add	objptr, ##42860
	rdlong	arg01, objptr
	sub	objptr, ##42860
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local04, result1
'   fpad=(1.0/65536.0)+padrx(0)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'   t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return
	jmp	#LR__1884
LR__1881
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1883
	rdlong	local04, fp
	add	objptr, ##43236
	wrlong	local04, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local04, #7 wc
 if_ae	jmp	#LR__1882
	mov	local04, ##931135488
	add	objptr, ##43236
	rdlong	local02, objptr
	shl	local02, #2
	sub	objptr, #376
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##42860
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_add
	mov	local04, result1
'     fpad=(1.0/65536.0)+padrx(q)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'     t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return 
	jmp	#LR__1884
LR__1882
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1884
LR__1883
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1884
	mov	ptra, fp
	call	#popregs_
_do_padrx_ret
	ret

' 
' ' ------------------ padry
' 
' sub do_padry
_do_padry
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "padry: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1890
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6057
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1894
LR__1890
' if numpar=0 then 
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1891
	mov	local02, ##931135488
	add	objptr, ##42888
	rdlong	arg01, objptr
	sub	objptr, ##42888
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local04, result1
'   fpad=(1.0/65536.0)+padry(0)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'   t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return
	jmp	#LR__1894
LR__1891
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1893
	rdlong	local04, fp
	add	objptr, ##43236
	wrlong	local04, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local04, #7 wc
 if_ae	jmp	#LR__1892
	mov	local04, ##931135488
	add	objptr, ##43236
	rdlong	local02, objptr
	shl	local02, #2
	sub	objptr, #348
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##42888
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_add
	mov	local04, result1
'     fpad=(1.0/65536.0)+padry(q)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'     t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return 
	jmp	#LR__1894
LR__1892
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1894
LR__1893
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1894
	mov	ptra, fp
	call	#popregs_
_do_padry_ret
	ret

' 
' ' ------------------ padrz
' 
' sub do_padrz
_do_padrz
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "padrz: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1900
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6058
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1904
LR__1900
' if numpar=0 then 
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1901
	mov	local02, ##931135488
	add	objptr, ##42916
	rdlong	arg01, objptr
	sub	objptr, ##42916
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local04, result1
'   fpad=(1.0/65536.0)+padrz(0)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'   t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return
	jmp	#LR__1904
LR__1901
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1903
	rdlong	local04, fp
	add	objptr, ##43236
	wrlong	local04, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local04, #7 wc
 if_ae	jmp	#LR__1902
	mov	local04, ##931135488
	add	objptr, ##43236
	rdlong	local02, objptr
	shl	local02, #2
	sub	objptr, #320
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##42916
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_add
	mov	local04, result1
'     fpad=(1.0/65536.0)+padrz(q)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'     t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return 
	jmp	#LR__1904
LR__1902
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1904
LR__1903
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1904
	mov	ptra, fp
	call	#popregs_
_do_padrz_ret
	ret

' 
' ' ------------------ pads
' 
' sub do_pads
_do_pads
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "pads: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1910
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6059
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1914
LR__1910
' if numpar=0 then 
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1911
	mov	local02, ##931135488
	add	objptr, ##42944
	rdlong	arg01, objptr
	sub	objptr, ##42944
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local04, result1
'   fpad=(1.0/65536.0)+pads(0)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'   t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return
	jmp	#LR__1914
LR__1911
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1913
	rdlong	local04, fp
	add	objptr, ##43236
	wrlong	local04, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local04, #7 wc
 if_ae	jmp	#LR__1912
	mov	local04, ##931135488
	add	objptr, ##43236
	rdlong	local02, objptr
	shl	local02, #2
	sub	objptr, #292
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##42944
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_add
	mov	local04, result1
'     fpad=(1.0/65536.0)+pads(q)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'     t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return 
	jmp	#LR__1914
LR__1912
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1914
LR__1913
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1914
	mov	ptra, fp
	call	#popregs_
_do_pads_ret
	ret

' 
' ' ------------------ padw
' 
' sub do_padw
_do_padw
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "padw: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1920
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6060
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1924
LR__1920
' if numpar=0 then 
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1921
	mov	local02, ##931135488
	add	objptr, ##42972
	rdlong	arg01, objptr
	sub	objptr, ##42972
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local04, result1
'   fpad=(1.0/65536.0)+padw(0)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'   t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return
	jmp	#LR__1924
LR__1921
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1923
	rdlong	local04, fp
	add	objptr, ##43236
	wrlong	local04, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local04, #7 wc
 if_ae	jmp	#LR__1922
	mov	local04, ##931135488
	add	objptr, ##43236
	rdlong	local02, objptr
	shl	local02, #2
	sub	objptr, #264
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##42972
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_add
	mov	local04, result1
'     fpad=(1.0/65536.0)+padw(q)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'     t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return 
	jmp	#LR__1924
LR__1922
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1924
LR__1923
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1924
	mov	ptra, fp
	call	#popregs_
_do_padw_ret
	ret

' 
' ' ------------------ padx
' 
' sub do_padx
_do_padx
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "padx: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1930
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6061
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1934
LR__1930
' if numpar=0 then 
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1931
	mov	local02, ##931135488
	add	objptr, ##42748
	rdlong	arg01, objptr
	sub	objptr, ##42748
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local04, result1
'   fpad=(1.0/65536.0)+padx(0)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'   t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return
	jmp	#LR__1934
LR__1931
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1933
	rdlong	local04, fp
	add	objptr, ##43236
	wrlong	local04, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local04, #7 wc
 if_ae	jmp	#LR__1932
	mov	local04, ##931135488
	add	objptr, ##43236
	rdlong	local02, objptr
	shl	local02, #2
	sub	objptr, #488
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##42748
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_add
	mov	local04, result1
'     fpad=(1.0/65536.0)+padx(q)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'     t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return 
	jmp	#LR__1934
LR__1932
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1934
LR__1933
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1934
	mov	ptra, fp
	call	#popregs_
_do_padx_ret
	ret

' 
' ' ------------------ pady
' 
' sub do_pady
_do_pady
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "pady: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1940
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6062
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1944
LR__1940
' if numpar=0 then 
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1941
	mov	local02, ##931135488
	add	objptr, ##42776
	rdlong	arg01, objptr
	sub	objptr, ##42776
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local04, result1
'   fpad=(1.0/65536.0)+pady(0)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'   t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return
	jmp	#LR__1944
LR__1941
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1943
	rdlong	local04, fp
	add	objptr, ##43236
	wrlong	local04, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local04, #7 wc
 if_ae	jmp	#LR__1942
	mov	local04, ##931135488
	add	objptr, ##43236
	rdlong	local02, objptr
	shl	local02, #2
	sub	objptr, #460
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##42776
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_add
	mov	local04, result1
'     fpad=(1.0/65536.0)+pady(q)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'     t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return 
	jmp	#LR__1944
LR__1942
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1944
LR__1943
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1944
	mov	ptra, fp
	call	#popregs_
_do_pady_ret
	ret

' 
' ' ------------------ padz
' 
' sub do_padz
_do_padz
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "padz: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__1950
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6063
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1954
LR__1950
' if numpar=0 then 
	cmp	local02, #0 wz
 if_ne	jmp	#LR__1951
	mov	local02, ##931135488
	add	objptr, ##42804
	rdlong	arg01, objptr
	sub	objptr, ##42804
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local04, result1
'   fpad=(1.0/65536.0)+padz(0)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'   t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return
	jmp	#LR__1954
LR__1951
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1953
	rdlong	local04, fp
	add	objptr, ##43236
	wrlong	local04, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local04, #7 wc
 if_ae	jmp	#LR__1952
	mov	local04, ##931135488
	add	objptr, ##43236
	rdlong	local02, objptr
	shl	local02, #2
	sub	objptr, #432
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##42804
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg01, result1
	mov	arg02, ##1191181824
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_add
	mov	local04, result1
'     fpad=(1.0/65536.0)+padz(q)/32767.0 : if abs(fpad) < 0.001 then fpad=0
	mov	arg01, local04
	bitl	arg01, #31
	mov	arg02, ##981668463
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local04, #0
	wrlong	local04, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'     t1.result.fresult=fpad: t1.result_type=result_float : push t1 : return 
	jmp	#LR__1954
LR__1952
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1954
LR__1953
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1954
	mov	ptra, fp
	call	#popregs_
_do_padz_ret
	ret

' 
' '-------------------- paper
' 
' sub do_paper
_do_paper
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1960
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1960
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1961
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1961
	add	objptr, ##29148
	wrlong	local01, objptr
	add	objptr, #4
	rdlong	arg01, objptr
' 
' write_color:=ff
	sub	objptr, ##29087
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	local01, objptr
	sub	objptr, #69
	mov	ptra, fp
	call	#popregs_
_do_paper_ret
	ret

' 
' '-------------------- peek
' 
' sub do_peek
_do_peek
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
' 
' t1=pop()
' a=converttoint(t1)
' if a<$80000 then r=peek(a) else r=pspeek(a)
	cmp	arg01, ##524288 wc
 if_b	rdbyte	local01, arg01
 if_b	jmp	#LR__1970
	call	#_pspeek
	getbyte	local01, result1, #0
LR__1970
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	local01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_peek_ret
	ret

' 
' '-------------------- pinfloat
' 
' sub do_pinfloat
_do_pinfloat
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	fltl	result1
	mov	ptra, fp
	call	#popregs_
_do_pinfloat_ret
	ret

' 
' '-------------------- pinhi
' 
' sub do_pinhi
_do_pinhi
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	drvh	result1
	mov	ptra, fp
	call	#popregs_
_do_pinhi_ret
	ret

' 
' '-------------------- pinlo
' 
' sub do_pinlo
_do_pinlo
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	drvl	result1
	mov	ptra, fp
	call	#popregs_
_do_pinlo_ret
	ret

' 
' '-------------------- pinread
' 
' sub do_pinread
_do_pinread
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
	test	arg01, #32 wz
 if_ne	mov	result1, inb
 if_e	mov	result1, ina
	shr	result1, arg01
	shr	arg01, #6
	zerox	result1, arg01
	add	objptr, ##43244
	wrlong	result1, objptr
	sub	objptr, ##43244
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	#4, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_pinread_ret
	ret

' 
' '-------------------- pinstart
' 
' sub do_pinstart
_do_pinstart
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result3
	add	fp, #36
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #24
	call	#_converttoint
	mov	local02, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	local03, result1
	mov	arg01, fp
	call	#_converttoint
	dirl	local01
	wrpin	local02, local01
	wxpin	local03, local01
	wypin	result1, local01
	dirh	local01
	mov	ptra, fp
	call	#popregs_
_do_pinstart_ret
	ret

' 
' '-------------------- pintoggle
' 
' sub do_pintoggle
_do_pintoggle
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	drvnot	result1
	mov	ptra, fp
	call	#popregs_
_do_pintoggle_ret
	ret

' 
' '-------------------- pinwrite
' 
' sub do_pinwrite
_do_pinwrite
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___pinwrite
	mov	ptra, fp
	call	#popregs_
_do_pinwrite_ret
	ret

' 
' '-------------------- play
' 
' sub do_play
_do_play
	mov	COUNT_, #16
	call	#pushregs_
	add	ptra, #136
	mov	local01, ##1134096318
' speed_coeff=305.873
' 
' for i=0 to 9 : params(i)=-2.0 : next i
	mov	local02, #0
	add	fp, #64
	callpa	#(@LR__1981-@LR__1980)>>2,fcache_load_ptr_
LR__1980
	mov	local03, local02
	shl	local03, #2
	add	local03, fp
	wrlong	##-1073741824, local03
	add	local02, #1
	cmps	local02, #10 wc
 if_b	jmp	#LR__1980
LR__1981
	sub	fp, #64
	add	objptr, ##38948
	rdlong	local02, objptr
	mov	local04, local02
	shl	local04, #1
	add	local04, local02
	shl	local04, #2
	sub	objptr, ##1540
	add	local04, objptr
	rdlong	local05, local04
' numpar=compiledline(lineptr_e).result.uresult
' for i=numpar to 1 step -1 
	mov	local02, local05
	sub	objptr, ##37408
LR__1982
	call	#_pop
	add	fp, #104
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	mov	local03, local02
	sub	local03, #1
	shl	local03, #2
	sub	fp, #48
	add	local03, fp
	add	fp, #40
	mov	local06, fp
	mov	arg01, local06
	sub	fp, #104
	call	#_converttofloat
	wrlong	result1, local03
	sub	local02, #1
	cmps	local02, #1 wc
 if_ae	jmp	#LR__1982
' 
' if params(0)<0 then channel=0 else channel=round(params(0)) mod 8
	add	fp, #64
	rdlong	arg01, fp
	sub	fp, #64
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	local07, #0
 if_b	jmp	#LR__1983
	add	fp, #64
	rdlong	arg01, fp
	sub	fp, #64
	mov	arg02, #1
	call	#__system___float_tointeger
	abs	local07, result1 wc
	and	local07, #7
	negc	local07, local07
LR__1983
' if params(1)<0 then freq=channels(channel).freq else freq=params(1) : channels(channel).freq=freq
	add	fp, #68
	rdlong	arg01, fp
	sub	fp, #68
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__1984
	mov	arg03, local07
	shl	arg03, #3
	sub	arg03, local07
	shl	arg03, #2
	mov	local04, objptr
	add	local04, ##11452
	add	arg03, local04
	rdlong	local08, arg03
	jmp	#LR__1985
LR__1984
	add	fp, #68
	rdlong	local08, fp
	sub	fp, #68
	mov	arg03, local07
	shl	arg03, #3
	sub	arg03, local07
	shl	arg03, #2
	mov	local04, objptr
	add	local04, ##11452
	add	arg03, local04
	wrlong	local08, arg03
LR__1985
' if params(2)<0 orelse params(2)>10000.0 then delay=channels(channel).delay else delay=round(params(2)) : channels(channel).delay=delay
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #72
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1986
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #72
	mov	arg02, ##1176256512
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1987
LR__1986
	mov	local04, local07
	shl	local04, #3
	sub	local04, local07
	shl	local04, #2
	mov	local06, objptr
	add	local06, ##11452
	add	local04, local06
	add	local04, #6
	rdword	local09, local04
	getword	local10, local09, #0
	jmp	#LR__1988
LR__1987
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #72
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local10, result1
	mov	arg03, local07
	shl	arg03, #3
	sub	arg03, local07
	shl	arg03, #2
	mov	local04, objptr
	add	local04, ##11452
	add	arg03, local04
	add	arg03, #6
	wrword	local10, arg03
LR__1988
' if params(3)<0 orelse params(3)>16.384 then vol=channels(channel).vol else vol=params(3) : channels(channel).vol=vol
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1989
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	mov	arg02, ##1099108975
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1990
LR__1989
	mov	local06, local07
	shl	local06, #3
	sub	local06, local07
	shl	local06, #2
	mov	local04, objptr
	add	local04, ##11452
	add	local06, local04
	add	local06, #12
	rdlong	local06, local06
	mov	local11, local06
	jmp	#LR__1991
LR__1990
	add	fp, #76
	rdlong	local11, fp
	sub	fp, #76
	mov	arg03, local07
	shl	arg03, #3
	sub	arg03, local07
	shl	arg03, #2
	mov	local04, objptr
	add	local04, ##11452
	add	arg03, local04
	add	arg03, #12
	wrlong	local11, arg03
LR__1991
' if params(4)<0 orelse params(4)>32 then wave=channels(channel).wave else wave=round(params(4)) : channels(channel).wave=wave
	add	fp, #80
	rdlong	arg01, fp
	sub	fp, #80
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1992
	add	fp, #80
	rdlong	arg01, fp
	sub	fp, #80
	mov	arg02, ##1107296256
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1993
LR__1992
	mov	local04, local07
	shl	local04, #3
	sub	local04, local07
	shl	local04, #2
	mov	local06, objptr
	add	local06, ##11452
	add	local04, local06
	add	local04, #4
	rdbyte	local09, local04
	getbyte	local12, local09, #0
	jmp	#LR__1994
LR__1993
	add	fp, #80
	rdlong	arg01, fp
	sub	fp, #80
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local12, result1
	mov	arg03, local07
	shl	arg03, #3
	sub	arg03, local07
	shl	arg03, #2
	mov	local04, objptr
	add	local04, ##11452
	add	arg03, local04
	add	arg03, #4
	wrbyte	local12, arg03
LR__1994
' if params(5)<0 orelse params(5)>8.0 then env=channels(channel).env else env=round(params(5)) : channels(channel).env=env
	add	fp, #84
	rdlong	arg01, fp
	sub	fp, #84
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1995
	add	fp, #84
	rdlong	arg01, fp
	sub	fp, #84
	mov	arg02, ##1090519040
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1996
LR__1995
	mov	local04, local07
	shl	local04, #3
	sub	local04, local07
	shl	local04, #2
	mov	local06, objptr
	add	local06, ##11452
	add	local04, local06
	add	local04, #5
	rdbyte	local09, local04
	getbyte	local13, local09, #0
	jmp	#LR__1997
LR__1996
	add	fp, #84
	rdlong	arg01, fp
	sub	fp, #84
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local13, result1
	mov	arg03, local07
	shl	arg03, #3
	sub	arg03, local07
	shl	arg03, #2
	mov	local04, objptr
	add	local04, ##11452
	add	arg03, local04
	add	arg03, #5
	wrbyte	local13, arg03
LR__1997
' if params(6)<0 orelse params(6)>1000.0 then slen=channels(channel).length else slen=params(6) : channels(channel).length=slen
	add	fp, #88
	rdlong	arg01, fp
	sub	fp, #88
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1998
	add	fp, #88
	rdlong	arg01, fp
	sub	fp, #88
	mov	arg02, ##1148846080
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1999
LR__1998
	mov	local06, local07
	shl	local06, #3
	sub	local06, local07
	shl	local06, #2
	mov	local04, objptr
	add	local04, ##11452
	add	local06, local04
	add	local06, #8
	rdlong	local14, local06
	jmp	#LR__2000
LR__1999
	add	fp, #88
	rdlong	local14, fp
	sub	fp, #88
	mov	local09, local07
	shl	local09, #3
	sub	local09, local07
	shl	local09, #2
	mov	local04, objptr
	add	local04, ##11452
	add	local09, local04
	add	local09, #8
	wrlong	local14, local09
LR__2000
' if params(7)<-1.0 orelse params(7)>1.0 then pan=channels(channel).pan else pan= params(7) : channels(channel).pan=pan
	add	fp, #92
	rdlong	arg01, fp
	sub	fp, #92
	mov	arg02, ##-1082130432
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__2001
	add	fp, #92
	rdlong	arg01, fp
	sub	fp, #92
	mov	arg02, ##1065353216
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__2002
LR__2001
	mov	local09, local07
	shl	local09, #3
	sub	local09, local07
	shl	local09, #2
	mov	local04, objptr
	add	local04, ##11452
	add	local09, local04
	add	local09, #16
	rdlong	local15, local09
	jmp	#LR__2003
LR__2002
	add	fp, #92
	rdlong	local15, fp
	sub	fp, #92
	mov	local09, local07
	shl	local09, #3
	sub	local09, local07
	shl	local09, #2
	mov	local04, objptr
	add	local04, ##11452
	add	local09, local04
	add	local09, #16
	wrlong	local15, local09
LR__2003
' if params(8)<0 orelse params(8)>255 then sus=channels(channel).sus else sus= round(params(8)) : channels(channel).sus=sus
	add	fp, #96
	rdlong	arg01, fp
	sub	fp, #96
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__2004
	add	fp, #96
	rdlong	arg01, fp
	sub	fp, #96
	mov	arg02, ##1132396544
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__2005
LR__2004
	mov	local04, local07
	shl	local04, #3
	sub	local04, local07
	shl	local04, #2
	mov	local06, objptr
	add	local06, ##11452
	add	local04, local06
	add	local04, #20
	rdword	local16, local04
	jmp	#LR__2006
LR__2005
	add	fp, #96
	rdlong	arg01, fp
	sub	fp, #96
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local16, result1
	mov	local09, local07
	shl	local09, #3
	sub	local09, local07
	shl	local09, #2
	mov	local04, objptr
	add	local04, ##11452
	add	local09, local04
	add	local09, #20
	wrword	local16, local09
LR__2006
' if params(9)<0 orelse params(9)>255 then amode=channels(channel).amode else amode= round(params(9)) : channels(channel).amode=amode
	add	fp, #100
	rdlong	arg01, fp
	sub	fp, #100
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__2007
	add	fp, #100
	rdlong	arg01, fp
	sub	fp, #100
	mov	arg02, ##1132396544
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	jmp	#LR__2007
	add	fp, #100
	rdlong	arg01, fp
	sub	fp, #100
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local09, local07
	shl	local09, #3
	sub	local09, local07
	shl	local09, #2
	mov	local04, objptr
	add	local04, ##11452
	add	local09, local04
	add	local09, #22
	wrword	result1, local09
LR__2007
	mov	arg01, local08
	mov	arg02, ##1148846080
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local09, result1
' 
' ifreq=round(freq*1000)
' if wave <32 then 
	cmps	local12, #32 wc
 if_b	shl	local12, #11
 if_b	add	local12, ##-1073741824
 if_ae	mov	local12, ##-939524096
' if env=8 then env=0 else env=varptr(envbuf(env,0))
	cmp	local13, #8 wz
 if_e	mov	local13, #0
 if_ne	shl	local13, #9
 if_ne	mov	local06, objptr
 if_ne	add	local06, ##7224
 if_ne	add	local13, local06
	mov	arg01, ##1134096318
	mov	arg02, local14
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	arg01, ##1174405120
	mov	arg02, local15
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	decod	local15, #13
	add	local15, result1
	mov	arg01, ##1148846080
	mov	arg02, local11
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local04, result1
	mov	arg01, local14
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	arg07, result1
	mov	arg01, local07
	mov	arg02, local09
	mov	arg03, local10
	mov	arg04, local04
	mov	arg05, local12
	mov	arg06, local13
	mov	arg08, local15
	mov	arg09, local16
	add	objptr, ##5836
	call	#_Audio2_004_spin2_play
	sub	objptr, ##5836
' speed=round(speed_coeff/slen)
' ipan=8192+round(8192*pan)
' ivol=round(1000.0*vol)
' 
' audio.play(channel,ifreq,delay,ivol,wave,env,round(slen),ipan,sus)
' 
' if delay>0 then waitms(delay) 
	cmps	local10, #1 wc
 if_ae	mov	arg01, local10
 if_ae	call	#__system___waitms
	mov	ptra, fp
	call	#popregs_
_do_play_ret
	ret

' 
' '-------------------- plot
' 
' sub do_plot
_do_plot
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	arg02, result1
	add	objptr, ##29136
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	objptr, ##29132
	call	#_Hg010b_4_spin2_putpixel
	mov	ptra, fp
	call	#popregs_
_do_plot_ret
	ret

' 
' '-------------------- poke
' 
' sub do_poke
_do_poke
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
' t1=pop() 'value
' t2=pop() 
' a=converttoint(t2) : v=converttoint(t1)
' if a<$80000 then poke a,v else pspoke a,v
	cmp	local01, ##524288 wc
 if_b	wrbyte	local02, local01
 if_ae	mov	arg01, local01
 if_ae	mov	arg02, local02
 if_ae	call	#_pspoke
	mov	ptra, fp
	call	#popregs_
_do_poke_ret
	ret

' 
' '-------------------- pop
' 
' sub do_pop()
_do_pop
' if gosubtop>0 then  gosubtop -=1 
	add	objptr, ##42200
	rdlong	_var01, objptr
	sub	objptr, ##42200
	cmps	_var01, #1 wc
 if_ae	add	objptr, ##42200
 if_ae	rdlong	_var01, objptr
 if_ae	sub	_var01, #1
 if_ae	wrlong	_var01, objptr
 if_ae	sub	objptr, ##42200
_do_pop_ret
	ret

' 
' '-------------------- position
' 
' sub do_position
_do_position
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	mov	arg02, result1
	mov	arg01, local01
	call	#_Hg010b_4_spin2_setcursorpos
	mov	ptra, fp
	call	#popregs_
_do_position_ret
	ret

' 
' '-------------------- print
' 
' sub do_print  
_do_print
	mov	COUNT_, #11
	call	#pushregs_
	mov	local04, #0
	call	#_pop
	mov	local05, result1
	mov	local06, result2
	mov	local07, result3
	mov	local01, local05
	mov	local02, local06
	mov	local03, local07
'  
' r=0
' t1=pop() 
' if t1.result_type=print_mod_comma orelse t1.result_type=print_mod_semicolon then r=t1.result_type :  t1=pop()
	cmp	local03, #33 wz
 if_ne	cmp	local03, #34 wz
 if_ne	jmp	#LR__2010
	mov	local04, local03
	call	#_pop
	mov	local05, result1
	mov	local06, result2
	mov	local07, result3
	mov	local01, local05
	mov	local02, local06
	mov	local03, local07
LR__2010
' if t1.result_type=print_mod_empty then r=t1.result_type 
	cmp	local03, #32 wz
 if_e	mov	local04, local03
' if t1.result_type=result_error then printerror(t1.result.uresult): goto 811
	cmp	local03, #255 wz
 if_ne	jmp	#LR__2011
	mov	arg01, local01
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2030
LR__2011
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult)  :  t1.result_type=result_string  
	cmp	local03, #43 wz
 if_ne	jmp	#LR__2012
	mov	arg01, local01
	call	#_convertstring
	mov	local05, result1
	mov	local01, local05
	mov	local03, #31
LR__2012
' 
' if t1.result_type=token_channel then print "Print to channel (not yet implemented)"; t1.result.iresult : t1=pop()
	cmp	local03, #44 wz
 if_ne	jmp	#LR__2013
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6064
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local08, #10
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	local09, result1
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local10, #1
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	local11, #0
	call	#_pop
	mov	local05, result1
	mov	local06, result2
	mov	local07, result3
	mov	local01, local05
	mov	local02, local06
	mov	local03, local07
LR__2013
' 
' if r=print_mod_comma  then
	cmp	local04, #33 wz
 if_ne	jmp	#LR__2018
'   if t1.result_type=result_int then print t1.result.iresult,
	cmp	local03, #28 wz
 if_ne	jmp	#LR__2014
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local11, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__2014
'   if t1.result_type=result_uint then print t1.result.uresult,
	cmp	local03, #29 wz
 if_ne	jmp	#LR__2015
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local11, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__2015
'   if t1.result_type=result_float then print t1.result.fresult,
	cmp	local03, #30 wz
 if_ne	jmp	#LR__2016
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local11, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__2016
'   if t1.result_type=result_string then print t1.result.sresult,
	cmp	local03, #31 wz
 if_ne	jmp	#LR__2017
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local11, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__2017
LR__2018
' if r=print_mod_semicolon then 
	cmp	local04, #34 wz
 if_ne	jmp	#LR__2023
'   if t1.result_type=result_int then print t1.result.iresult;
	cmp	local03, #28 wz
 if_ne	jmp	#LR__2019
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	local10, #0
	mov	local11, #10
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	result1, #0
	mov	local09, #0
LR__2019
'   if t1.result_type=result_uint then print t1.result.uresult;
	cmp	local03, #29 wz
 if_ne	jmp	#LR__2020
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	local10, #0
	mov	local11, #10
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	result1, #0
	mov	local09, #0
LR__2020
'   if t1.result_type=result_float then print t1.result.fresult;
	cmp	local03, #30 wz
 if_ne	jmp	#LR__2021
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__2021
'   if t1.result_type=result_string then print t1.result.sresult;
	cmp	local03, #31 wz
 if_ne	jmp	#LR__2022
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__2022
LR__2023
' if r=0 then 
	cmp	local04, #0 wz
 if_ne	jmp	#LR__2028
'   if t1.result_type=result_int then print t1.result.iresult
	cmp	local03, #28 wz
 if_ne	jmp	#LR__2024
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__2024
'   if t1.result_type=result_uint then print t1.result.uresult
	cmp	local03, #29 wz
 if_ne	jmp	#LR__2025
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__2025
'   if t1.result_type=result_float then print t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__2026
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__2026
'   if t1.result_type=result_string then print t1.result.sresult
	cmp	local03, #31 wz
 if_ne	jmp	#LR__2027
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__2027
LR__2028
' if r=print_mod_empty then print
	cmp	local04, #32 wz
 if_ne	jmp	#LR__2029
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__2029
LR__2030
	mov	ptra, fp
	call	#popregs_
_do_print_ret
	ret

' 
' ' ------------------- push a variable on the stack. No command for this, a variable is a command
' 
' sub do_push
_do_push
' if stackpointer<maxstack then 
	add	objptr, ##35324
	rdlong	_var01, objptr
	sub	objptr, ##35324
	cmps	_var01, ##512 wc
 if_ae	jmp	#LR__2040
	add	objptr, ##38948
	rdlong	_var02, objptr
	mov	_var03, _var02
	shl	_var03, #1
	add	_var03, _var02
	shl	_var03, #2
	sub	objptr, ##1540
	add	_var03, objptr
	rdlong	_var01, _var03
	add	_var03, #4
	rdlong	_var04, _var03
	mov	_var03, _var02
	shl	_var03, #1
	add	_var03, _var02
	shl	_var03, #2
	add	_var03, objptr
	add	_var03, #8
	rdlong	_var02, _var03
	sub	objptr, ##2084
	rdlong	_var03, objptr
	mov	_var05, _var03
	shl	_var05, #1
	add	_var05, _var03
	shl	_var05, #2
	sub	objptr, ##6156
	add	_var05, objptr
	wrlong	_var01, _var05
	add	objptr, ##6156
	rdlong	_var05, objptr
	mov	_var03, _var05
	shl	_var03, #1
	add	_var03, _var05
	shl	_var03, #2
	sub	objptr, ##6156
	add	_var03, objptr
	add	_var03, #4
	wrlong	_var04, _var03
	add	objptr, ##6156
	rdlong	_var05, objptr
	mov	_var04, _var05
	shl	_var04, #1
	add	_var04, _var05
	shl	_var04, #2
	sub	objptr, ##6156
	add	_var04, objptr
	add	_var04, #8
	wrlong	_var02, _var04
	add	objptr, ##6156
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##35324
LR__2040
_do_push_ret
	ret

' 
' '-------------------- put
' 
' sub do_put			' put  #chn,addr,(amount,(pos))
_do_put
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #40
	add	objptr, ##38948
	rdlong	arg05, objptr
	mov	arg04, arg05
	shl	arg04, #1
	add	arg04, arg05
	shl	arg04, #2
	sub	objptr, ##1540
	add	arg04, objptr
	rdlong	local01, arg04
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=4  then t1=pop() : pos=converttoint(t1)   else pos=-1
	cmp	local01, #4 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__2050
	call	#_pop
	mov	arg05, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	objptr, ##43240
	wrlong	result1, objptr
	sub	objptr, ##43240
	jmp	#LR__2051
LR__2050
	add	objptr, ##43240
	wrlong	##-1, objptr
	sub	objptr, ##43240
LR__2051
' if numpar>=3 then t1=pop() : amount=converttoint(t1) else amount=1
	cmps	local01, #3 wc
 if_b	jmp	#LR__2052
	call	#_pop
	mov	arg05, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	mov	local02, result1
	jmp	#LR__2053
LR__2052
	mov	local02, #1
LR__2053
' if numpar>=2 then t1=pop() : adr=converttoint(t1)
	cmps	local01, #2 wc
 if_b	jmp	#LR__2054
	call	#_pop
	mov	local01, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	mov	local03, result1
LR__2054
	call	#_pop
	mov	local01, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	mov	local04, result1
	shl	local05, #2
	add	objptr, ##42088
	add	local05, objptr
	wrlong	#0, local05
' t1=pop() : channel=converttoint(t1)
' getres(j)=0
' if pos>=0 then
	add	objptr, ##1152
	rdlong	local06, objptr
	sub	objptr, ##43240
	cmps	local06, #0 wc
 if_b	jmp	#LR__2060
	mov	local07, #0
'    i=0: do
LR__2055
	mov	local05, #0
'    j=0: do    
LR__2056
'    if adr<$80000 then block(j)=peek(adr+1024*i+j) else block(j)=pspeek(adr+1024*i+j)
	cmps	local03, ##524288 wc
 if_ae	jmp	#LR__2057
	mov	local06, local05
	mov	local01, objptr
	add	local01, ##41048
	add	local06, local01
	mov	arg01, local03
	mov	local01, local07
	shl	local01, #10
	add	arg01, local01
	add	arg01, local05
	rdbyte	result1, arg01
	wrbyte	result1, local06
	jmp	#LR__2058
LR__2057
	mov	local06, local05
	mov	local01, objptr
	add	local01, ##41048
	add	local06, local01
	mov	arg01, local03
	mov	local01, local07
	shl	local01, #10
	add	arg01, local01
	add	arg01, local05
	call	#_pspeek
	wrbyte	result1, local06
LR__2058
	add	local05, #1
	cmps	local05, ##1024 wc
 if_ae	jmp	#LR__2059
	mov	local06, local07
	shl	local06, #10
	add	local06, local05
	cmps	local06, local02 wcz
 if_be	jmp	#LR__2056
LR__2059
'    put #channel, pos+1,block(0),amount, r : getres(channel)=r
	add	objptr, ##43240
	rdlong	arg02, objptr
	add	arg02, #1
	sub	objptr, ##2192
	mov	arg03, objptr
	sub	objptr, ##41048
	mov	arg04, local02
	mov	arg01, local04
	mov	arg05, #1
	call	#__system___basic_put
	mov	local06, local04
	shl	local06, #2
	mov	local01, objptr
	add	local01, ##42088
	add	local06, local01
	wrlong	result1, local06
'    if 1024*i+j>amount then exit loop
	mov	local06, local07
	shl	local06, #10
	add	local06, local05
	cmps	local06, local02 wcz
 if_a	jmp	#LR__2066
	add	local07, #1
	jmp	#LR__2055
LR__2060
	mov	local07, #0
'    i=0: do
LR__2061
	mov	local05, #0
'    j=0: do  
LR__2062
'    if adr<$80000 then block(j)=peek(adr+1024*i+j) else block(j)=pspeek(adr+1024*i+j)
	cmps	local03, ##524288 wc
 if_ae	jmp	#LR__2063
	mov	local06, local05
	mov	local01, objptr
	add	local01, ##41048
	add	local06, local01
	mov	arg01, local03
	mov	local01, local07
	shl	local01, #10
	add	arg01, local01
	add	arg01, local05
	rdbyte	result1, arg01
	wrbyte	result1, local06
	jmp	#LR__2064
LR__2063
	mov	local06, local05
	mov	local01, objptr
	add	local01, ##41048
	add	local06, local01
	mov	arg01, local03
	mov	local01, local07
	shl	local01, #10
	add	arg01, local01
	add	arg01, local05
	call	#_pspeek
	wrbyte	result1, local06
LR__2064
	add	local05, #1
	cmps	local05, ##1024 wc
 if_ae	jmp	#LR__2065
	mov	local06, local07
	shl	local06, #10
	add	local06, local05
	cmps	local06, local02 wcz
 if_be	jmp	#LR__2062
LR__2065
'    put #channel,,block(0),amount, r : getres(channel)=r
	mov	arg03, objptr
	add	arg03, ##41048
	mov	arg04, local02
	mov	arg01, local04
	mov	arg02, #0
	mov	arg05, #1
	call	#__system___basic_put
	mov	local06, local04
	shl	local06, #2
	mov	local01, objptr
	add	local01, ##42088
	add	local06, local01
	wrlong	result1, local06
'    if 1024*i+j>amount then exit loop
	mov	local06, local07
	shl	local06, #10
	add	local06, local05
	cmps	local06, local02 wcz
 if_be	add	local07, #1
 if_be	jmp	#LR__2061
LR__2066
	mov	ptra, fp
	call	#popregs_
_do_put_ret
	ret

' 
' '-------------------- rad
' 
' sub do_rad
_do_rad
	add	objptr, ##43140
	wrlong	##1065353216, objptr
	add	objptr, #4
	wrlong	##1065353216, objptr
	sub	objptr, ##43144
_do_rad_ret
	ret

' 
' '-------------------- rdpin
' 
' sub do_rdpin
_do_rdpin
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	rdpin	result1, result1
	add	objptr, ##43244
	wrlong	result1, objptr
	sub	objptr, ##43244
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	#4, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_rdpin_ret
	ret

' 
' ' ----------------  read
' 
' function read_next_line() as string
_read_next_line
	mov	COUNT_, #7
	call	#pushregs_
' if dataptr=$7FFFFFFF then return("")
	add	objptr, ##42192
	rdlong	local01, objptr
	sub	objptr, ##42192
	cmp	local01, ##2147483647 wz
 if_e	mov	result1, ##@LR__6065
 if_e	jmp	#LR__2077
' do
LR__2070
	mov	arg01, objptr
	add	arg01, ##42156
	add	objptr, ##42192
	rdlong	arg02, objptr
	mov	arg03, #36
	sub	objptr, ##36356
	call	#_psram4_spin2_read1
'  ' print dataptr
'   psram.read1(varptr(dataheader),dataptr,36) 
'   if dataheader(0)<>$FFFFFFFF then dataptr=dataheader(5)
	add	objptr, ##36320
	rdlong	local01, objptr
	sub	objptr, ##42156
	cmp	local01, ##-1 wz
 if_ne	add	objptr, ##42176
 if_ne	rdlong	local01, objptr
 if_ne	add	objptr, #16
 if_ne	wrlong	local01, objptr
 if_ne	sub	objptr, ##42192
	add	objptr, ##42176
	rdlong	local01, objptr
	sub	objptr, ##42176
	cmp	local01, ##2147483647 wz
 if_ne	add	objptr, ##42156
 if_ne	rdlong	local02, objptr
 if_ne	sub	objptr, ##42156
 if_ne	cmp	local02, ##-1 wz
 if_ne	add	objptr, ##42188
 if_ne	rdlong	local03, objptr
 if_ne	sub	objptr, ##42188
 if_ne	cmp	local03, #183 wz
 if_ne	jmp	#LR__2070
' if dataheader(8)=token_data then 
	add	objptr, ##42188
	rdlong	local01, objptr
	sub	objptr, ##42188
	cmp	local01, #183 wz
 if_ne	jmp	#LR__2075
	add	objptr, ##42164
	rdlong	local01, objptr
	add	objptr, ##1048
	wrlong	local01, objptr
	sub	objptr, ##1044
	rdlong	local04, objptr
	add	objptr, ##1036
	wrlong	local04, objptr
'  'print "data found at line "; dataheader(0)
'   l=dataheader(2) : j=dataheader(3) : for i=0 to j-1: readline+=chr$(pspeek(l+i)): next i 
	mov	local05, #0
	sub	objptr, ##43204
LR__2071
	cmps	local05, local04 wc
 if_ae	jmp	#LR__2072
	add	objptr, ##43212
	rdlong	arg01, objptr
	sub	objptr, ##43212
	add	arg01, local05
	call	#_pspeek
	getbyte	arg01, result1, #0
	call	#__system__Chr_S
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___string_concat
	mov	local06, result1
	add	local05, #1
	jmp	#LR__2071
LR__2072
	mov	arg03, ##@LR__6066
	mov	arg01, #1
	mov	arg02, local06
	call	#__system__Instr
	mov	local05, result1
	mov	arg01, local06
	mov	local07, arg01
	callpa	#(@LR__2074-@LR__2073)>>2,fcache_load_ptr_
LR__2073
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__2073
LR__2074
	sub	local07, arg01
	mov	arg02, local07
	sub	arg02, local05
	sub	arg02, #4
	mov	arg01, local06
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	mov	local06, result1
	jmp	#LR__2076
LR__2075
'   return ("") 'todo proper err
	mov	result1, ##@LR__6067
	jmp	#LR__2077
LR__2076
' return readline
	mov	result1, local06
LR__2077
	mov	ptra, fp
	call	#popregs_
_read_next_line_ret
	ret

' 
' sub do_read
_do_read
	mov	COUNT_, #23
	call	#pushregs_
	add	ptra, #344
	add	objptr, ##38948
	rdlong	local04, objptr
	mov	local05, local04
	shl	local05, #1
	add	local05, local04
	shl	local05, #2
	sub	objptr, ##1540
	mov	local06, objptr
	add	local05, objptr
	rdlong	local07, local05
' 
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<1 orelse numpar>64 then print "In read: ";: printerror(39,runheader(0)) : return
	cmp	local07, #1 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__2080
	cmp	local07, #65 wc
 if_b	jmp	#LR__2081
LR__2080
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6068
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__2128
LR__2081
' i=numpar-1
' if readline="" then readline=read_next_line() ': print readline
	add	objptr, ##43192
	rdlong	arg01, objptr
	sub	objptr, ##43192
	mov	arg02, ##@LR__6069
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2082
	call	#_read_next_line
	add	objptr, ##43192
	wrlong	result1, objptr
	sub	objptr, ##43192
LR__2082
' if readline="" then printerror(55,runheader(0)) :return
	add	objptr, ##43192
	rdlong	arg01, objptr
	sub	objptr, ##43192
	mov	arg02, ##@LR__6070
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2083
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #55
	call	#_printerror
	jmp	#LR__2128
LR__2083
	mov	local08, #0
	mov	local09, local07
	sub	local09, #1
' j=0
' i=numpar-1
' do
LR__2084
'   do
LR__2085
	add	objptr, ##43192
	rdlong	arg02, objptr
	sub	objptr, ##43192
	mov	arg03, ##@LR__6071
	mov	arg01, #1
	call	#__system__Instr
	mov	arg03, result1
'     comma=instr(1,readline,"'") : if comma>0 then readline=left$(readline,comma-1) ' allows comments in data
	cmp	arg03, #1 wc
 if_b	jmp	#LR__2086
	add	objptr, ##43192
	rdlong	arg01, objptr
	sub	objptr, ##43192
	sub	arg03, #1
	mov	arg02, arg03
	call	#__system__Left_S
	add	objptr, ##43192
	wrlong	result1, objptr
	sub	objptr, ##43192
LR__2086
	add	objptr, ##43192
	rdlong	arg02, objptr
	sub	objptr, ##43192
	mov	arg03, ##@LR__6072
	mov	arg01, #1
	call	#__system__Instr
	mov	local10, result1
'     comma=instr(1,readline,",")  
'       if comma>0  then 
	cmp	local10, #1 wc
 if_b	jmp	#LR__2089
	add	objptr, ##43192
	rdlong	arg01, objptr
	sub	objptr, ##43192
	mov	arg02, local10
	sub	arg02, #1
	call	#__system__Left_S
	mov	local11, result1
	add	objptr, ##43192
	rdlong	local06, objptr
	sub	objptr, ##43192
	mov	arg01, local06
	mov	local12, arg01
	callpa	#(@LR__2088-@LR__2087)>>2,fcache_load_ptr_
LR__2087
	rdbyte	result1, local12 wz
 if_ne	add	local12, #1
 if_ne	jmp	#LR__2087
LR__2088
	sub	local12, arg01
	mov	arg02, local12
	sub	arg02, local10
	mov	arg01, local06
	call	#__system__Right_S
	add	objptr, ##43192
	wrlong	result1, objptr
	sub	objptr, ##43192
	jmp	#LR__2090
LR__2089
	add	objptr, ##43192
	rdlong	arg01, objptr
	sub	objptr, ##43192
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	mov	local11, result1
	mov	local13, ##@LR__6073
	add	objptr, ##43192
	wrlong	local13, objptr
	sub	objptr, ##43192
LR__2090
'      
'      if part$<>"" then j=j+1
	mov	arg02, ##@LR__6074
	mov	arg01, local11
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	local08, #1
	mov	arg03, local09
	shl	arg03, #2
	mov	local04, fp
	add	local04, #44
	add	arg03, local04
	wrlong	local11, arg03
	sub	local09, #1
'      args(i)=part$  
'      i=i-1
'     if readline="" then readline=read_next_line() 
	add	objptr, ##43192
	rdlong	arg01, objptr
	sub	objptr, ##43192
	mov	arg02, ##@LR__6075
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2091
	call	#_read_next_line
	add	objptr, ##43192
	wrlong	result1, objptr
	sub	objptr, ##43192
LR__2091
	cmps	local09, #0 wc
 if_b	jmp	#LR__2092
	add	objptr, ##43192
	rdlong	arg01, objptr
	sub	objptr, ##43192
	mov	arg02, ##@LR__6076
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2085
LR__2092
	cmps	local09, #0 wc
 if_ae	jmp	#LR__2084
' if j<numpar then printerror(55,runheader(0))
	cmps	local08, local07 wc
 if_b	add	objptr, ##42132
 if_b	rdlong	arg02, objptr
 if_b	sub	objptr, ##42132
 if_b	mov	arg01, #55
 if_b	call	#_printerror
' 
' for i=0 to numpar-1
	mov	local09, #0
	mov	local14, local07
LR__2093
	cmps	local09, local14 wc
 if_ae	jmp	#LR__2127
'   if isnum(args(i)) and not isint(args(i)) then r=result_float 
	mov	local05, local09
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	call	#_isnum
	mov	local13, result1
	mov	local15, local09
	shl	local15, #2
	mov	local16, fp
	add	local16, #44
	add	local15, local16
	rdlong	arg01, local15
	call	#_isint
	signx	result1, #7
	andn	local13, result1 wz
 if_ne	add	objptr, ##43244
 if_ne	wrlong	#30, objptr
 if_ne	sub	objptr, ##43244
'   if isint(args(i)) then r=result_int 
	mov	local04, local09
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#_isint
	cmp	result1, #0 wz
 if_ne	add	objptr, ##43244
 if_ne	wrlong	#28, objptr
 if_ne	sub	objptr, ##43244
'   if isdec(args(i)) then r=result_uint 
	mov	local04, local09
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#_isdec
	cmp	result1, #0 wz
 if_ne	add	objptr, ##43244
 if_ne	wrlong	#29, objptr
 if_ne	sub	objptr, ##43244
'   if not isnum(args(i)) then 
	mov	local05, local09
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	call	#_isnum
	signx	result1, #7
	not	result1, result1
	cmp	result1, #0 wz
 if_e	jmp	#LR__2098
	add	objptr, ##43244
	wrlong	#43, objptr
	sub	objptr, ##43244
	mov	local04, local09
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	mov	local12, arg01
	callpa	#(@LR__2095-@LR__2094)>>2,fcache_load_ptr_
LR__2094
	rdbyte	result1, local12 wz
 if_ne	add	local12, #1
 if_ne	jmp	#LR__2094
LR__2095
	sub	local12, arg01
	mov	local17, local12
	add	objptr, ##43124
	rdlong	arg01, objptr
	sub	arg01, local17
	sub	arg01, #4
	andn	arg01, #3
	wrlong	arg01, objptr
	sub	objptr, ##43124
	mov	arg02, local17
	call	#_pslpoke
'     pslpoke memtop,l
'     for j=1 to l : pspoke memtop+3+j, asc(mid$(args(i),j,1)) : next j
	mov	local08, #1
	mov	local18, local17
	add	local18, #1
LR__2096
	cmps	local08, local18 wc
 if_ae	jmp	#LR__2097
	add	objptr, ##43124
	rdlong	local13, objptr
	sub	objptr, ##43124
	add	local13, #3
	add	local13, local08
	mov	local15, local09
	shl	local15, #2
	mov	local16, fp
	add	local16, #44
	add	local15, local16
	rdlong	arg01, local15
	mov	local06, local08
	mov	local15, #1
	mov	arg02, local06
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local05, result1
	rdbyte	arg02, local05
	mov	arg01, local13
	call	#_pspoke
	add	local08, #1
	jmp	#LR__2096
LR__2097
	add	objptr, ##43124
	rdlong	local19, objptr
	sub	objptr, ##43124
LR__2098
	call	#_pop
	mov	local20, result2
	mov	local04, result3
	mov	local01, result1
	mov	local02, local20
	mov	local03, local04
'   t1=pop() 
'   if i>=numpar-j then
	mov	local13, local07
	sub	local13, local08
	cmps	local09, local13 wc
 if_b	jmp	#LR__2126
	mov	local21, local02
'     vartype=t1.result.twowords(1)
'     select case vartype
	mov	local22, local21 wz
 if_e	jmp	#LR__2099
	cmp	local22, #256 wz
 if_e	jmp	#LR__2100
	cmp	local22, #257 wz
 if_e	jmp	#LR__2101
	cmp	local22, #258 wz
 if_e	jmp	#LR__2102
	cmp	local22, #259 wz
 if_e	jmp	#LR__2103
	cmp	local22, #260 wz
 if_e	jmp	#LR__2104
	cmp	local22, #261 wz
 if_e	jmp	#LR__2105
	cmp	local22, #262 wz
 if_e	jmp	#LR__2106
	cmp	local22, #263 wz
 if_e	jmp	#LR__2107
	cmp	local22, #264 wz
 if_e	jmp	#LR__2108
	cmp	local22, #265 wz
 if_e	jmp	#LR__2109
	cmp	local22, #266 wz
 if_e	jmp	#LR__2110
	cmp	local22, #267 wz
 if_e	jmp	#LR__2111
	jmp	#LR__2112
LR__2099
	mov	local23, #12
	jmp	#LR__2113
LR__2100
	mov	local23, #12
	jmp	#LR__2113
LR__2101
	mov	local23, #1
	jmp	#LR__2113
LR__2102
	mov	local23, #1
	jmp	#LR__2113
LR__2103
	mov	local23, #2
	jmp	#LR__2113
LR__2104
	mov	local23, #2
	jmp	#LR__2113
LR__2105
	mov	local23, #4
	jmp	#LR__2113
LR__2106
	mov	local23, #4
	jmp	#LR__2113
LR__2107
	mov	local23, #8
	jmp	#LR__2113
LR__2108
	mov	local23, #8
	jmp	#LR__2113
LR__2109
	mov	local23, #6
	jmp	#LR__2113
LR__2110
	mov	local23, #8
	jmp	#LR__2113
LR__2111
	mov	local23, #5
	jmp	#LR__2113
LR__2112
	mov	local23, #12
LR__2113
'     if esize=12 andalso t1.result.uresult<$80000 then
	cmp	local23, #12 wz
 if_ne	jmp	#LR__2117
	cmp	local01, ##524288 wc
 if_ae	jmp	#LR__2117
'       if r=result_int then lpoke t1.result.uresult, val%(args(i))
	add	objptr, ##43244
	rdlong	local13, objptr
	sub	objptr, ##43244
	cmp	local13, #28 wz
 if_ne	jmp	#LR__2114
	mov	local05, local09
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	wrlong	arg02, arg01
LR__2114
'       if r=result_uint then lpoke t1.result.uresult, val%(args(i))
	add	objptr, ##43244
	rdlong	local13, objptr
	sub	objptr, ##43244
	cmp	local13, #29 wz
 if_ne	jmp	#LR__2115
	mov	local05, local09
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	wrlong	arg02, arg01
LR__2115
'       if r=result_float then fval=val(args(i)): lpoke t1.result.uresult,lpeek(varptr(fval))
	add	objptr, ##43244
	rdlong	local13, objptr
	sub	objptr, ##43244
	cmp	local13, #30 wz
 if_ne	jmp	#LR__2116
	mov	local04, local09
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#__system____builtin_atof
	add	fp, #40
	wrlong	result1, fp
	mov	arg01, fp
	sub	fp, #40
	rdlong	result1, arg01
	mov	arg02, result1
	mov	arg01, local01
	wrlong	arg02, arg01
LR__2116
'       if r=result_string2 then lpoke t1.result.uresult,stringaddr
	add	objptr, ##43244
	rdlong	local13, objptr
	cmp	local13, #43 wz
 if_e	mov	arg01, local01
 if_e	mov	arg02, local19
 if_e	wrlong	arg02, arg01
	mov	local13, local01
	add	local13, #8
	rdlong	local04, objptr
	sub	objptr, ##43244
	mov	local20, local04
	mov	arg01, local13
	mov	arg02, local20
	wrlong	arg02, arg01
LR__2117
'     if esize=12 andalso t1.result.uresult>=$80000 then
	cmp	local23, #12 wz
 if_ne	jmp	#LR__2121
	cmp	local01, ##524288 wc
 if_b	jmp	#LR__2121
'       if r=result_int then pslpoke t1.result.uresult, val%(args(i))
	add	objptr, ##43244
	rdlong	local13, objptr
	sub	objptr, ##43244
	cmp	local13, #28 wz
 if_ne	jmp	#LR__2118
	mov	local05, local09
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_pslpoke
LR__2118
'       if r=result_uint then pslpoke t1.result.uresult, val%(args(i))
	add	objptr, ##43244
	rdlong	local13, objptr
	sub	objptr, ##43244
	cmp	local13, #29 wz
 if_ne	jmp	#LR__2119
	mov	local05, local09
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_pslpoke
LR__2119
'       if r=result_float then fval=val(args(i)): pslpoke t1.result.uresult,lpeek(varptr(fval))
	add	objptr, ##43244
	rdlong	local13, objptr
	sub	objptr, ##43244
	cmp	local13, #30 wz
 if_ne	jmp	#LR__2120
	mov	local04, local09
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#__system____builtin_atof
	add	fp, #40
	wrlong	result1, fp
	mov	arg01, fp
	sub	fp, #40
	rdlong	arg02, arg01
	mov	arg01, local01
	call	#_pslpoke
LR__2120
'       if r=result_string2 then pslpoke t1.result.uresult,stringaddr
	add	objptr, ##43244
	rdlong	local13, objptr
	sub	objptr, ##43244
	cmp	local13, #43 wz
 if_e	mov	arg01, local01
 if_e	mov	arg02, local19
 if_e	call	#_pslpoke
	mov	arg01, local01
	add	arg01, #8
	add	objptr, ##43244
	rdlong	local20, objptr
	sub	objptr, ##43244
	mov	arg02, local20
	call	#_pslpoke
LR__2121
'     if esize=5 andalso r=result_string2 then pslpoke t1.result.uresult,stringaddr
	cmp	local23, #5 wz
 if_e	add	objptr, ##43244
 if_e	rdlong	local20, objptr
 if_e	sub	objptr, ##43244
 if_e	cmp	local20, #43 wz
 if_e	mov	local20, local19
 if_e	mov	arg01, local01
 if_e	mov	arg02, local20
 if_e	call	#_pslpoke
'     if esize=4 andalso r<>result_string2 then pslpoke t1.result.uresult,val%(args(i))
	cmp	local23, #4 wz
 if_ne	jmp	#LR__2122
	add	objptr, ##43244
	rdlong	local20, objptr
	sub	objptr, ##43244
	cmp	local20, #43 wz
 if_e	jmp	#LR__2122
	mov	local05, local09
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_pslpoke
LR__2122
'     if esize=2 andalso r<>result_string2 then psdpoke t1.result.uresult,val%(args(i))
	cmp	local23, #2 wz
 if_ne	jmp	#LR__2123
	add	objptr, ##43244
	rdlong	local20, objptr
	sub	objptr, ##43244
	cmp	local20, #43 wz
 if_e	jmp	#LR__2123
	mov	local05, local09
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_psdpoke
LR__2123
'     if esize=1 andalso r<>result_string2 then pspoke t1.result.uresult,val%(args(i))
	cmp	local23, #1 wz
 if_ne	jmp	#LR__2124
	add	objptr, ##43244
	rdlong	local20, objptr
	sub	objptr, ##43244
	cmp	local20, #43 wz
 if_e	jmp	#LR__2124
	mov	local05, local09
	shl	local05, #2
	mov	local06, fp
	add	local06, #44
	add	local05, local06
	rdlong	arg01, local05
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	arg02, result1
	mov	arg01, local01
	call	#_pspoke
LR__2124
'     if esize=6 andalso r<>result_string2 then fval=val(args(i)): pslpoke t1.result.uresult,lpeek(varptr(fval))
	cmp	local23, #6 wz
 if_ne	jmp	#LR__2125
	add	objptr, ##43244
	rdlong	local20, objptr
	sub	objptr, ##43244
	cmp	local20, #43 wz
 if_e	jmp	#LR__2125
	mov	local04, local09
	shl	local04, #2
	mov	local05, fp
	add	local05, #44
	add	local04, local05
	rdlong	arg01, local04
	call	#__system____builtin_atof
	add	fp, #40
	wrlong	result1, fp
	mov	arg01, fp
	sub	fp, #40
	rdlong	arg02, arg01
	mov	arg01, local01
	call	#_pslpoke
LR__2125
LR__2126
	add	local09, #1
	jmp	#LR__2093
LR__2127
LR__2128
	mov	ptra, fp
	call	#popregs_
_do_read_ret
	ret

' 
' '------------------- release
' 
' sub do_release
_do_release
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
' 
' t1=pop()
' channel=converttoint(t1)
' if channel>=0 andalso channel<=7 then lpoke base+64*channel+44,255  
	cmps	result1, #0 wc
 if_b	jmp	#LR__2130
	cmps	result1, #8 wc
 if_ae	jmp	#LR__2130
	add	objptr, ##29108
	rdlong	arg01, objptr
	sub	objptr, ##29108
	shl	result1, #6
	add	arg01, result1
	add	arg01, #44
	wrlong	#255, arg01
LR__2130
	mov	ptra, fp
	call	#popregs_
_do_release_ret
	ret

' 
' '------------------- restore
' 
' sub do_restore()
_do_restore
	add	objptr, ##38956
	rdlong	_var01, objptr
	add	objptr, ##3236
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6077
	add	objptr, ##1000
	wrlong	_var01, objptr
	sub	objptr, ##43192
_do_restore_ret
	ret

' 
' '------------------- restorepalette
' 
' sub do_restorepalette()
_do_restorepalette
	call	#_Hg010b_4_spin2_restorepalette
_do_restorepalette_ret
	ret

' '------------------- return
' 
' sub do_return()
_do_return
' if gosubtop>0 then
	add	objptr, ##42200
	rdlong	_var01, objptr
	sub	objptr, ##42200
	cmps	_var01, #1 wc
 if_b	jmp	#LR__2140
	add	objptr, ##42200
	rdlong	_var01, objptr
	shl	_var01, #3
	sub	objptr, ##1928
	add	_var01, objptr
	rdlong	_var01, _var01
	add	objptr, ##1804
	wrlong	_var01, objptr
	add	objptr, #124
	rdlong	_var01, objptr
	shl	_var01, #3
	sub	objptr, ##1928
	add	_var01, objptr
	add	_var01, #4
	rdlong	_var01, _var01
	add	objptr, ##1808
	wrlong	_var01, objptr
	sub	objptr, ##3136
	rdlong	_var01, objptr
	sub	_var01, #1
	add	objptr, #4
	wrlong	_var01, objptr
	add	objptr, ##3252
	rdlong	_var01, objptr
	sub	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##42200
LR__2140
_do_return_ret
	ret

' 
' '------------------- right$
' 
' sub do_right
_do_right
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>2  then print "right$: "; : printerror(39) : return
	cmp	arg03, #2 wz
	sub	objptr, ##37408
 if_e	jmp	#LR__2150
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6078
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2153
LR__2150
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : arg=converttoint(t1)
' t1=pop(): if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__2151
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__2151
' if t1.result_type<>result_string then print "right$: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__2152
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6079
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2153
LR__2152
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system__Right_S
	wrlong	result1, fp
	mov	arg01, fp
	call	#_push
LR__2153
	mov	ptra, fp
	call	#popregs_
_do_right_ret
	ret

' 
' '------------------- rnd
' 
' sub do_rnd
_do_rnd
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "rnd: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__2160
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6080
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2167
LR__2160
' if numpar=0 then
	cmp	local02, #0 wz
 if_ne	jmp	#LR__2161
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	getrnd	result1
	wrlong	result1, fp
	mov	arg01, fp
	call	#_push
	jmp	#LR__2166
LR__2161
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
'   t1=pop()
'   if t1.result_type=result_int orelse t1.result_type=result_uint then
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__2162
	getrnd	result1
	rdlong	local01, fp
	qdiv	result1, local01
	mov	arg01, fp
	getqy	local02
	wrlong	local02, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	call	#_push
	jmp	#LR__2165
LR__2162
	add	fp, #8
	rdlong	local02, fp
	sub	fp, #8
	cmp	local02, #30 wz
 if_ne	jmp	#LR__2163
	rdlong	arg01, fp
	mov	arg02, ##1233125376
	call	#__system___float_div
	mov	local02, result1
	getrnd	arg01
	bitl	arg01, #372
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	jmp	#LR__2164
LR__2163
'     print "rnd: "; : printerror(40) 
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6081
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #40
	mov	arg02, #0
	call	#_printerror
	mov	arg01, fp
	call	#_push
LR__2164
LR__2165
LR__2166
LR__2167
	mov	ptra, fp
	call	#popregs_
_do_rnd_ret
	ret

' 
' '-------------------- round
' 
' sub do_round
_do_round
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	wrlong	result1, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_round_ret
	ret

' 
' '-------------------- rqpin
' 
' sub do_rqpin
_do_rqpin
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
	mov	result1, #0
	rqpin	result1, arg01
	add	objptr, ##43244
	wrlong	result1, objptr
	sub	objptr, ##43244
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	#4, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_rqpin_ret
	ret

' 
' ' ------------------ run
' 
' sub do_run
_do_run
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, ##38948
	rdlong	local01, objptr
	add	objptr, ##3128
	rdlong	local02, objptr
	add	objptr, #4
	rdlong	local03, objptr
	mov	arg04, local01
	mov	arg03, arg04
	shl	arg03, #1
	add	arg03, arg04
	shl	arg03, #2
	sub	objptr, ##4672
	add	arg03, objptr
	rdlong	arg02, arg03
' 
' r_lineptr_e=lineptr_e
' r_runptr=runptr
' r_runptr2=runptr2
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=1 then do_load ' todo also run linenum so check the param
	cmp	arg02, #1 wz
	sub	objptr, ##37408
 if_e	mov	arg01, #0
 if_e	call	#_do_load
	add	objptr, ##38956
	rdlong	arg04, objptr
	add	objptr, ##3120
	wrlong	arg04, objptr
	add	objptr, #4
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	sub	objptr, ##3128
	rdlong	arg04, objptr
	add	objptr, ##3236
	wrlong	arg04, objptr
	mov	arg04, ##@LR__6082
	add	objptr, ##1000
	wrlong	arg04, objptr
' runptr=programstart : runptr2=0 : oldrunptr=-1 
' dataptr=programstart : readline="" ' reset the data pointer
' if inrun>0 then 
	sub	objptr, ##1064
	rdlong	arg04, objptr
	sub	objptr, ##42128
	cmp	arg04, #1 wc
 if_b	jmp	#LR__2170
	mov	arg01, objptr
	add	arg01, ##42132
	add	objptr, ##42076
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##36240
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
'   psram.read1(varptr(runheader),runptr,24)  
'   return
	jmp	#LR__2177
LR__2170
	add	objptr, ##42128
	wrlong	#1, objptr
	add	objptr, #4
	mov	arg01, objptr
	sub	objptr, #56
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##36240
	call	#_psram4_spin2_read1
' inrun=1
' psram.read1(varptr(runheader),runptr,24) 
' if runheader(0)=$FFFFFFFF then inrun=0: return 
	add	objptr, ##36296
	rdlong	local04, objptr
	sub	objptr, ##42132
	cmp	local04, ##-1 wz
 if_e	add	objptr, ##42128
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##42128
 if_e	jmp	#LR__2177
' do 
LR__2171
'   if runptr<>oldrunptr then
	add	objptr, ##42076
	rdlong	local04, objptr
	add	objptr, #8
	rdlong	arg04, objptr
	sub	objptr, ##42084
	cmp	local04, arg04 wz
 if_e	jmp	#LR__2172
	mov	arg01, objptr
	add	arg01, ##42132
	add	objptr, ##42076
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##36240
	call	#_psram4_spin2_read1
	add	objptr, ##31572
	mov	arg01, objptr
	add	objptr, ##4668
	rdlong	arg02, objptr
	sub	objptr, ##5716
	rdlong	local04, objptr
	shl	local04, #1
	add	arg02, local04
	add	objptr, ##5780
	rdlong	arg03, objptr
	sub	objptr, #64
	rdlong	local04, objptr
	sub	arg03, local04
	sub	objptr, ##36240
	call	#_psram4_spin2_read1
	add	objptr, ##36304
	rdlong	local04, objptr
	sub	objptr, #64
	rdlong	arg02, objptr
	sub	local04, arg02
	sub	objptr, ##5716
	rdlong	arg02, objptr
	qdiv	local04, arg02
	add	objptr, ##2584
	getqx	local04
	sub	local04, #3
	wrlong	local04, objptr
	add	objptr, ##3132
	rdlong	local04, objptr
	add	objptr, #8
	wrlong	local04, objptr
	sub	objptr, ##42084
LR__2172
	add	objptr, ##42152
	rdlong	local04, objptr
	sub	objptr, #76
	wrlong	local04, objptr
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, ##42080
	call	#_execute_line
	add	objptr, ##42080
	wrlong	result1, objptr
	sub	objptr, #4
	rdlong	local04, objptr
	sub	objptr, ##42076
	cmp	local04, ##2147483647 wz
 if_e	jmp	#LR__2175
	mov	arg01, #224
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2173
	mov	arg01, #228
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_e	jmp	#LR__2174
LR__2173
	mov	arg01, #6
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2175
LR__2174
	add	objptr, ##42128
	rdlong	local04, objptr
	sub	objptr, ##42128
	cmp	local04, #2 wz
 if_ne	jmp	#LR__2171
LR__2175
'   ''do whatever kbm.peek_latest_key()=$106 
' if runptr<>$7FFF_FFFF andalso inrun=1 then 
	add	objptr, ##42076
	rdlong	local04, objptr
	sub	objptr, ##42076
	cmp	local04, ##2147483647 wz
 if_e	jmp	#LR__2176
	add	objptr, ##42128
	rdlong	local04, objptr
	sub	objptr, ##42128
	cmp	local04, #1 wz
 if_ne	jmp	#LR__2176
'   print: print "Stopped at line ";runheader(0) 
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6083
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__2176
	add	objptr, ##42128
	wrlong	#0, objptr
	sub	objptr, ##3180
	wrlong	local01, objptr
	add	objptr, ##3128
	wrlong	local02, objptr
	add	objptr, #4
	wrlong	local03, objptr
	sub	objptr, ##42080
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_Hg010b_4_spin2_setspritesize
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_Hg010b_4_spin2_setspritesize
LR__2177
	mov	ptra, fp
	call	#popregs_
_do_run_ret
	ret

' 
' ' ------------------ save
' 
' sub do_save                        
_do_save
	mov	COUNT_, #10
	call	#pushregs_
	add	ptra, #184
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	local04, arg03
	shl	local04, #1
	add	local04, arg03
	shl	local04, #2
	sub	objptr, ##1540
	add	local04, objptr
	rdlong	local05, local04
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>0 then t1=pop() else t1.result.sresult=loadname : t1.result_type=result_string 
	cmps	local05, #1 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__2180
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	jmp	#LR__2181
LR__2180
	add	objptr, ##43168
	rdlong	local01, objptr
	sub	objptr, ##43168
	mov	local03, #31
LR__2181
' if pslpeek(programstart)=$FFFFFFFF then printerror(27): return
	add	objptr, ##38956
	rdlong	arg01, objptr
	sub	objptr, ##38956
	call	#_pslpeek
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__2182
	mov	arg01, #27
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2188
LR__2182
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult): t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__2183
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__2183
' if t1.result_type=result_string then
	cmp	local03, #31 wz
 if_ne	jmp	#LR__2187
'   if t1.result.sresult="" then t1.result.sresult=loadname else loadname=t1.result.sresult
	mov	arg02, ##@LR__6084
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##43168
 if_e	rdlong	local01, objptr
	sumz	objptr, ##43168
 if_ne	wrlong	local01, objptr
 if_ne	sub	objptr, ##43168
'   close #9: open currentdir$+"/"+t1.result.sresult for output as #9
	mov	arg01, #9
	call	#__system__close
	mov	local06, #9
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__6085
	call	#__system___string_concat
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local06
	mov	arg03, #13
	call	#__system___basic_open_string
	add	objptr, ##38956
	rdlong	local07, objptr
	sub	objptr, ##38956
'   saveptr=programstart
'   do
LR__2184
	mov	arg01, fp
	add	arg01, #20
	mov	arg02, local07
	mov	arg03, #24
	add	objptr, ##5836
	call	#_psram4_spin2_read1
	mov	arg01, fp
	add	arg01, #44
	add	fp, #28
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #32
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
	mov	local08, ##@LR__6086
'     psram.read1(varptr(header(0)),saveptr,24)
'     psram.read1(varptr(linebuf(0)),header(2),header(3)) 
'     saveline$="" : for i=1 to header(3) : saveline$=saveline$+chr$(linebuf(i-1)) : next i 
	mov	local09, #1
	add	fp, #32
	rdlong	local10, fp
	sub	fp, #32
	add	local10, #1
LR__2185
	cmps	local09, local10 wc
 if_ae	jmp	#LR__2186
	mov	local07, local09
	sub	local07, #1
	mov	local06, fp
	add	local06, #44
	add	local07, local06
	rdbyte	arg01, local07
	call	#__system__Chr_S
	mov	arg02, result1
	mov	arg01, local08
	call	#__system___string_concat
	mov	local08, result1
	add	local09, #1
	jmp	#LR__2185
LR__2186
'     print #9, saveline$
	mov	arg01, #9
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #9
	mov	arg02, local08
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #9
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #9
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	fp, #40
	rdlong	local06, fp
	mov	local07, local06
	sub	fp, #40
	cmp	local06, ##2147483647 wz
 if_ne	jmp	#LR__2184
'   close #9  
	mov	arg01, #9
	call	#__system__close
'   print "Saved as ";currentdir$+"/"+loadname
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6087
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local04, #0
	add	objptr, ##38968
	rdlong	arg01, objptr
	sub	objptr, ##38968
	mov	arg02, ##@LR__6088
	call	#__system___string_concat
	mov	arg01, result1
	add	objptr, ##43168
	rdlong	arg02, objptr
	sub	objptr, ##43168
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
LR__2187
LR__2188
	mov	ptra, fp
	call	#popregs_
_do_save_ret
	ret

' 
' ' ------------------ setamode
' 
' sub do_setamode
_do_setamode
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	shl	local01, #3
	sub	local01, result1
	shl	local01, #2
	mov	local02, objptr
	add	local02, ##11452
	add	local01, local02
	mov	arg01, fp
	call	#_converttoint
	add	local01, #22
	wrword	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setamode_ret
	ret

' 
' 
' ' ------------------ setcolor
' 
' sub do_setcolor
_do_setcolor
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #32
	add	objptr, ##38948
	rdlong	arg04, objptr
	mov	arg03, arg04
	shl	arg03, #1
	add	arg03, arg04
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local01, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' 
' if numpar=4 then
	cmp	local01, #4 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__2190
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local03, result1
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local04, result1
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local05, result1
	jmp	#LR__2193
LR__2190
	cmp	local01, #2 wz
 if_ne	jmp	#LR__2191
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local04, result1
	getbyte	local02, local04, #0
	getbyte	local03, local04, #1
	getbyte	local04, local04, #2
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local05, result1
	jmp	#LR__2192
LR__2191
'   print "setcolor: "; : printerror(39,runheader(0)) : return  
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6089
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##42132
	rdlong	arg02, objptr
	sub	objptr, ##42132
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__2194
LR__2192
LR__2193
	mov	arg01, local05
	mov	arg02, local04
	mov	arg03, local03
	mov	arg04, local02
	call	#_Hg010b_4_spin2_setcolor
LR__2194
	mov	ptra, fp
	call	#popregs_
_do_setcolor_ret
	ret

' 
' ' ------------------ setdelay
' 
' sub do_setdelay
_do_setdelay
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	shl	local01, #3
	sub	local01, result1
	shl	local01, #2
	mov	local02, objptr
	add	local02, ##11452
	add	local01, local02
	mov	arg01, fp
	call	#_converttoint
	add	local01, #6
	wrword	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setdelay_ret
	ret

' 
' ' ------------------ setenv
' 
' sub do_setenv
_do_setenv
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	shl	local01, #3
	sub	local01, result1
	shl	local01, #2
	mov	local02, objptr
	add	local02, ##11452
	add	local01, local02
	mov	arg01, fp
	call	#_converttoint
	add	local01, #5
	wrbyte	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setenv_ret
	ret

' 
' ' ------------------ setlen
' 
' sub do_setlen
_do_setlen
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	shl	local01, #3
	sub	local01, result1
	shl	local01, #2
	mov	local02, objptr
	add	local02, ##11452
	add	local01, local02
	mov	arg01, fp
	call	#_converttofloat
	add	local01, #8
	wrlong	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setlen_ret
	ret

' 
' ' ------------------ setpan
' 
' sub do_setpan
_do_setpan
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	shl	local01, #3
	sub	local01, result1
	shl	local01, #2
	mov	local02, objptr
	add	local02, ##11452
	add	local01, local02
	mov	arg01, fp
	call	#_converttofloat
	add	local01, #16
	wrlong	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setpan_ret
	ret

' 
' ' ------------------ setsustain
' 
' sub do_setsustain
_do_setsustain
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	shl	local01, #3
	sub	local01, result1
	shl	local01, #2
	mov	local02, objptr
	add	local02, ##11452
	add	local01, local02
	mov	arg01, fp
	call	#_converttoint
	add	local01, #20
	wrword	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setsustain_ret
	ret

' 
' ' ------------------ setvol
' 
' sub do_setvol
_do_setvol
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	shl	local01, #3
	sub	local01, result1
	shl	local01, #2
	mov	local02, objptr
	add	local02, ##11452
	add	local01, local02
	mov	arg01, fp
	call	#_converttofloat
	add	local01, #12
	wrlong	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setvol_ret
	ret

' 
' ' ------------------ setwave
' 
' sub do_setwave
_do_setwave
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	shl	local01, #3
	sub	local01, result1
	shl	local01, #2
	mov	local02, objptr
	add	local02, ##11452
	add	local01, local02
	mov	arg01, fp
	call	#_converttoint
	add	local01, #4
	wrbyte	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setwave_ret
	ret

' 
' ' ------------------ shutup
' 
' sub do_shutup
_do_shutup
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	rdlong	local02, local02 wz
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=0 then
	sub	objptr, ##37408
 if_ne	jmp	#LR__2202
'   for i=0 to 7 : dpoke base+64*i+20,0 : next i
	mov	local03, #0
	add	objptr, ##29108
	callpa	#(@LR__2201-@LR__2200)>>2,fcache_load_ptr_
LR__2200
	rdlong	arg01, objptr
	mov	local02, local03
	shl	local02, #6
	add	arg01, local02
	add	arg01, #20
	wrword	#0, arg01
	add	local03, #1
	cmps	local03, #8 wc
 if_b	jmp	#LR__2200
LR__2201
	sub	objptr, ##29108
	jmp	#LR__2203
LR__2202
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	local03, result1 wc
	and	local03, #7
	negc	local02, local03
	add	objptr, ##29108
	rdlong	arg01, objptr
	sub	objptr, ##29108
	shl	local02, #6
	add	arg01, local02
	add	arg01, #20
	wrword	#0, arg01
LR__2203
	mov	ptra, fp
	call	#popregs_
_do_shutup_ret
	ret

' 
' ' ------------------ sin
' 
' sub do_sin
_do_sin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "sin: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__2210
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6090
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2211
LR__2210
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##43140
	rdlong	local01, objptr
	sub	objptr, ##43140
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__2211
	mov	ptra, fp
	call	#popregs_
_do_sin_ret
	ret

' 
' ' ------------------ skip
' ' A helper token for on-gosub: skips the rest of gosubs
' 
' sub do_skip
_do_skip
	add	objptr, ##38948
	rdlong	_var01, objptr
	mov	_var02, _var01
	shl	_var02, #1
	add	_var02, _var01
	shl	_var02, #2
	sub	objptr, ##1540
	add	_var02, objptr
	rdlong	_var02, _var02
	sub	_var02, #1
	add	objptr, ##1540
	wrlong	_var02, objptr
	sub	objptr, ##38948
_do_skip_ret
	ret

' 
' ' ------------------ sprite
' 
' sub do_sprite
_do_sprite
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg02, result1
	mov	arg03, result2
	mov	arg01, result3
	add	fp, #24
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #32
	call	#_pop
	mov	arg02, result1
	mov	arg03, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	add	arg01, #12
	call	#_converttoint
	mov	local02, result1
	mov	arg01, fp
	add	arg01, #24
	call	#_converttoint
	mov	arg03, result1
	mov	arg01, local01
	mov	arg02, local02
	call	#_Hg010b_4_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_do_sprite_ret
	ret

' 
' ' ------------------ sqr
' 
' sub do_sqr
_do_sqr
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "sqr: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__2220
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6091
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2221
LR__2220
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	call	#__system___float_sqrt
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__2221
	mov	ptra, fp
	call	#popregs_
_do_sqr_ret
	ret

' 
' ' ------------------ stick
' 
' sub do_stick
_do_stick
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "stick: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__2230
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6092
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2234
LR__2230
' if numpar=0 then t1.result.uresult=stick(0) : t1.result_type=result_uint : push t1 : return
	cmp	local02, #0 wz
 if_ne	jmp	#LR__2231
	add	objptr, ##43000
	rdlong	local02, objptr
	sub	objptr, ##43000
	wrlong	local02, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	jmp	#LR__2234
LR__2231
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__2233
	rdlong	local01, fp
	add	objptr, ##43236
	wrlong	local01, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local01, #7 wc
 if_ae	jmp	#LR__2232
	add	objptr, ##43236
	rdlong	local01, objptr
	shl	local01, #2
	sub	objptr, #236
	add	local01, objptr
	rdlong	local02, local01
	wrlong	local02, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	sub	objptr, ##43000
	call	#_push
'     t1.result.uresult=stick(q) : t1.result_type=result_uint : push t1 : return 
	jmp	#LR__2234
LR__2232
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__2234
LR__2233
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__2234
	mov	ptra, fp
	call	#popregs_
_do_stick_ret
	ret

' 
' 
' sub do_str
_do_str
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>1 then print "str$: "; : printerror(39) : return
	cmp	arg03, #1 wz
	sub	objptr, ##37408
 if_e	jmp	#LR__2240
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6093
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2249
LR__2240
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' 
' t1=pop()
' if t1.result_type=result_int then 
	sub	fp, #8
	cmp	arg03, #28 wz
 if_ne	jmp	#LR__2241
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	mov	arg01, result1
	call	#__system__str_S
	mov	local02, result1
	jmp	#LR__2248
LR__2241
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #29 wz
 if_ne	jmp	#LR__2242
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	call	#__system__str_S
	mov	local02, result1
	jmp	#LR__2247
LR__2242
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #30 wz
 if_ne	jmp	#LR__2243
	rdlong	arg01, fp
	call	#__system__str_S
	mov	local02, result1
	jmp	#LR__2246
LR__2243
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__2244
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	jmp	#LR__2245
LR__2244
	add	fp, #8
	rdlong	result2, fp
	sub	fp, #8
	cmp	result2, #31 wz
 if_e	rdlong	local02, fp
LR__2245
LR__2246
LR__2247
LR__2248
	wrlong	local02, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'     t1.result.sresult=s : t1.result_type=result_string : push t1 : return 
LR__2249
	mov	ptra, fp
	call	#popregs_
_do_str_ret
	ret

' ' ------------------ strig
' 
' sub do_strig
_do_strig
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local02, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "strig: "; : printerror(39) : return
	cmp	local02, #2 wc
	sub	objptr, ##37408
 if_b	jmp	#LR__2250
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6094
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2254
LR__2250
' if numpar=0 then t1.result.uresult=strig(0) : t1.result_type=result_uint : push t1 : return
	cmp	local02, #0 wz
 if_ne	jmp	#LR__2251
	add	objptr, ##43028
	rdlong	local02, objptr
	sub	objptr, ##43028
	wrlong	local02, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	jmp	#LR__2254
LR__2251
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__2253
	rdlong	local01, fp
	add	objptr, ##43236
	wrlong	local01, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##43236
	cmps	local01, #7 wc
 if_ae	jmp	#LR__2252
	add	objptr, ##43236
	rdlong	local01, objptr
	shl	local01, #2
	sub	objptr, #208
	add	local01, objptr
	rdlong	local02, local01
	wrlong	local02, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	sub	objptr, ##43028
	call	#_push
'     t1.result.uresult=strig(q) : t1.result_type=result_uint : push t1 : return 
	jmp	#LR__2254
LR__2252
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__2254
LR__2253
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__2254
	mov	ptra, fp
	call	#popregs_
_do_strig_ret
	ret

' 
' ' ------------------ tan
' 
' sub do_tan
_do_tan
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "tan: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__2260
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6095
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2261
LR__2260
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##43140
	rdlong	local01, objptr
	sub	objptr, ##43140
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_tanf
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__2261
	mov	ptra, fp
	call	#popregs_
_do_tan_ret
	ret

' 
' ' ------------------ val
' 
' sub do_val
_do_val
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #32
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "val: "; : printerror(39) : return
	cmp	arg03, #2 wc
	sub	objptr, ##37408
 if_b	cmp	arg03, #0 wz
 if_c_and_nz	jmp	#LR__2270
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6096
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2282
LR__2270
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__2271
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__2271
' if t1.result_type<>result_string then print "val: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__2272
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6097
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2282
LR__2272
' if left$(t1.result.sresult,1)="$" then t1.result.sresult="&h"+right$(t1.result.sresult,len(t1.result.sresult)-1)
	rdlong	arg01, fp
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__6098
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2275
	mov	local01, ##@LR__6099
	rdlong	arg03, fp
	mov	arg01, arg03
	mov	local02, arg01
	callpa	#(@LR__2274-@LR__2273)>>2,fcache_load_ptr_
LR__2273
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__2273
LR__2274
	sub	local02, arg01
	mov	arg02, local02
	sub	arg02, #1
	mov	arg01, arg03
	call	#__system__Right_S
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	wrlong	result1, fp
LR__2275
' if left$(t1.result.sresult,1)="%" then t1.result.sresult="&b"+right$(t1.result.sresult,len(t1.result.sresult)-1)
	rdlong	arg01, fp
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__6100
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2278
	mov	local01, ##@LR__6101
	rdlong	arg03, fp
	mov	arg01, arg03
	mov	local02, arg01
	callpa	#(@LR__2277-@LR__2276)>>2,fcache_load_ptr_
LR__2276
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__2276
LR__2277
	sub	local02, arg01
	mov	arg02, local02
	sub	arg02, #1
	mov	arg01, arg03
	call	#__system__Right_S
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	wrlong	result1, fp
LR__2278
	rdlong	arg01, fp
	call	#__system____builtin_atof
	mov	local03, result1
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system____builtin_atoi
	mov	local04, result1
' fval=val(t1.result.sresult)
' ival=val%(t1.result.sresult)
' if fval=ival then
	abs	arg01, local04 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local03
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	wrlong	local04, fp
 if_e	add	fp, #8
 if_e	wrlong	#28, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2281
'   if fval=0 andalso ival<>0 then
	mov	arg01, local03
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2279
	cmp	local04, #0 wz
 if_ne	wrlong	local04, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#28, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__2280
LR__2279
	wrlong	local03, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
LR__2280
LR__2281
	mov	arg01, fp
	call	#_push
LR__2282
	mov	ptra, fp
	call	#popregs_
_do_val_ret
	ret

' 
' ' ------------------ waitclock
' 
' sub do_waitclock
_do_waitclock
	add	objptr, ##43120
	rdlong	_var01, objptr
' c=hkcnt
' do: loop until hkcnt<>c
LR__2290
	rdlong	_var02, objptr
	cmp	_var02, _var01 wz
 if_e	jmp	#LR__2290
	sub	objptr, ##43120
_do_waitclock_ret
	ret

' 
' ' ------------------ waitms
' 
' sub do_waitms
_do_waitms
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
' 
' t1=pop()  
' t=converttoint(t1)
' if t<0 then return
	cmps	local01, #0 wc
 if_b	jmp	#LR__2306
' if t < 1000 then 
	cmps	local01, ##1000 wc
 if_ae	jmp	#LR__2300
	mov	arg01, local01
	call	#__system___waitms
	jmp	#LR__2305
LR__2300
	abs	arg01, local01 wc
	qdiv	arg01, ##1000
'   for i=1 to t/1000
	mov	local02, #1
	getqx	local03
	negc	local03, local03
	add	local03, #1
LR__2301
	cmps	local02, local03 wc
 if_ae	jmp	#LR__2304
	mov	arg01, ##1000
	call	#__system___waitms
'     waitms(1000)
'     if ((kbm.keystate(kbm.KEY_LCTRL) orelse kbm.keystate(kbm.KEY_RCTRL)) andalso kbm.keystate(kbm.KEY_C)) then return
	mov	arg01, #224
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2302
	mov	arg01, #228
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_e	jmp	#LR__2303
LR__2302
	mov	arg01, #6
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2306
LR__2303
	add	local02, #1
	jmp	#LR__2301
LR__2304
	abs	local03, local01 wc
	qdiv	local03, ##1000
	getqy	local03
	negc	arg01, local03
	call	#__system___waitms
LR__2305
LR__2306
	mov	ptra, fp
	call	#popregs_
_do_waitms_ret
	ret

' 
' ' ------------------ waitvbl
' 
' sub do_waitvbl
_do_waitvbl
	mov	arg01, #1
	call	#_Hg010b_4_spin2_waitvbl
_do_waitvbl_ret
	ret

' 
' ' ------------------ wrpin
' 
' sub do_wrpin
_do_wrpin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	wrpin	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_wrpin_ret
	ret

' 
' ' ------------------ wxpin
' 
' sub do_wxpin
_do_wxpin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	wxpin	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_wxpin_ret
	ret

' 
' ' ------------------ wypin
' 
' sub do_wypin
_do_wypin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	wypin	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_wypin_ret
	ret

' 
' 
' 
' 
' 
' 
' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Runtime variable processing--------------------------------------------------------------------- 
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' 
' '------------------ Assign
' 
' sub do_assign
_do_assign
	mov	COUNT_, #14
	call	#pushregs_
	add	ptra, #68
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	local04, arg02
' 
' varnum=compiledline(lineptr_e).result.uresult ' numpar is in twowords(1), pop numpar 
' if variables(varnum).vartype<array_no_type then 
	mov	arg03, local04
	shl	arg03, #4
	sub	objptr, ##25732
	add	arg03, objptr
	add	arg03, #12
	rdlong	arg03, arg03
	cmp	arg03, #256 wc
	sub	objptr, ##11676
 if_ae	jmp	#LR__2310
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg02, fp
	mov	arg01, local04
	shl	arg01, #4
	add	objptr, ##11676
	add	arg01, objptr
	add	arg01, #4
	wrlong	arg03, arg01
	mov	arg03, local04
	shl	arg03, #4
	add	arg03, objptr
	add	arg03, #8
	wrlong	arg02, arg03
	mov	arg03, local04
	shl	arg03, #4
	add	arg03, objptr
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #8
	add	arg03, #12
	wrlong	arg02, arg03
'   t1=pop() 
'   variables(varnum).value=t1.result : variables(varnum).vartype=t1.result_type 
'   if variables(varnum).vartype<>result_string2 then return
	mov	arg03, local04
	shl	arg03, #4
	add	arg03, objptr
	add	arg03, #12
	rdlong	arg03, arg03
	cmp	arg03, #43 wz
	sub	objptr, ##11676
 if_ne	jmp	#LR__2332
	mov	local05, local04
	shl	local05, #4
	add	objptr, ##11676
	add	local05, objptr
	mov	arg03, local04
	shl	arg03, #4
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg01, arg03
	sub	objptr, ##11676
	call	#_convertstring
	add	local05, #4
	wrlong	result1, local05
	shl	local04, #4
	mov	local05, objptr
	add	local05, ##11676
	add	local04, local05
	add	local04, #12
	wrlong	#31, local04
'   variables(varnum).value.sresult=convertstring(variables(varnum).value.uresult)
'   variables(varnum).vartype=result_string
'   return
	jmp	#LR__2332
LR__2310
' for i=0 to 2 : arrid(i)=0 : next i
	mov	local06, #0
LR__2311
	mov	local05, local06
	add	local05, #local01
	mov	local07, #0
	'.live	local07
	'.live	local05
	altd	local05, #0
	mov	local05, local07
	add	local06, #1
	cmp	local06, #3 wc
 if_b	jmp	#LR__2311
	add	objptr, ##38948
	rdlong	local05, objptr
	mov	local06, local05
	shl	local06, #1
	add	local06, local05
	shl	local06, #2
	sub	objptr, ##1540
	add	local06, objptr
	add	local06, #4
	rdlong	local06, local06
	sub	objptr, ##37408
	call	#_pop
	mov	local08, result1
	mov	local09, result2
	mov	local05, result3
	wrlong	local08, fp
	add	fp, #4
	wrlong	local09, fp
	add	fp, #4
	wrlong	local05, fp
	sub	fp, #8
' numpar=compiledline(lineptr_e).result.twowords(1) 
' t1=pop() ' var value
' if numpar>0 then
	cmp	local06, #1 wc
 if_b	jmp	#LR__2314
'   for i=numpar to 1 step -1
	cmps	local06, #0 wz
 if_e	jmp	#LR__2313
LR__2312
	call	#_pop
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	mov	local05, local06
	sub	local05, #1
	add	local05, #local01
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local07, result1
	'.live	local07
	'.live	local05
	altd	local05, #0
	mov	local05, local07
	djnz	local06, #LR__2312
LR__2313
LR__2314
	shl	local04, #4
	mov	arg03, objptr
	add	arg03, ##11676
	add	local04, arg03
	add	local04, #4
	rdlong	local10, local04
	mov	arg01, local10
	call	#_pslpeek
	getword	local11, result1, #0
	mov	arg01, local10
	add	arg01, #2
	call	#_pspeek
	getbyte	local12, result1, #0
' esize=pspeek(arrptr+2)
' if arrid(0)>=pslpeek(arrptr+4) orelse arrid(1)>=pslpeek(arrptr+8) orelse arrid(2)>=pslpeek(arrptr+12) then printerror(49) : return
	mov	arg01, local10
	add	arg01, #4
	call	#_pslpeek
	cmp	local01, result1 wc
 if_ae	jmp	#LR__2315
	mov	arg01, local10
	add	arg01, #8
	call	#_pslpeek
	cmp	local02, result1 wc
 if_ae	jmp	#LR__2315
	mov	arg01, local10
	add	arg01, #12
	call	#_pslpeek
	cmp	local03, result1 wc
 if_b	jmp	#LR__2316
LR__2315
	mov	arg01, #49
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2332
LR__2316
	mov	local13, local10
	add	local13, #16
	mov	arg01, local10
	add	arg01, #4
	call	#_pslpeek
	qmul	result1, local02
	mov	local09, local01
	mov	arg01, local10
	add	arg01, #8
	getqx	local08
	add	local09, local08
	call	#_pslpeek
	mov	local07, result1
	add	local10, #4
	mov	arg01, local10
	call	#_pslpeek
	qmul	local07, result1
	getqx	local10
	qmul	local10, local03
	getqx	local01
	add	local09, local01
	qmul	local12, local09
' 
' arridx=arrptr+16+esize*(arrid(0)+pslpeek(arrptr+4)*arrid(1)+pslpeek(arrptr+8)*pslpeek(arrptr+4)*arrid(2))
' select case arrtype
	mov	local14, local11
	sub	local14, #256
	fle	local14, #12
	getqx	local01
	add	local13, local01
	jmprel	local14
LR__2317
	jmp	#LR__2318
	jmp	#LR__2319
	jmp	#LR__2320
	jmp	#LR__2321
	jmp	#LR__2322
	jmp	#LR__2323
	jmp	#LR__2324
	jmp	#LR__2325
	jmp	#LR__2326
	jmp	#LR__2327
	jmp	#LR__2328
	jmp	#LR__2329
	jmp	#LR__2330
LR__2318
	mov	arg01, fp
	mov	arg02, local13
	mov	arg03, #12
	add	objptr, ##5836
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	jmp	#LR__2331
LR__2319
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pspoke
	jmp	#LR__2331
LR__2320
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pspoke
	jmp	#LR__2331
LR__2321
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pspoke
	add	local13, #1
	rdlong	arg02, fp
	shr	arg02, #8
	mov	arg01, local13
	call	#_pspoke
	jmp	#LR__2331
LR__2322
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pspoke
	add	local13, #1
	rdlong	arg02, fp
	shr	arg02, #8
	mov	arg01, local13
	call	#_pspoke
	jmp	#LR__2331
LR__2323
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pslpoke
	jmp	#LR__2331
LR__2324
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pslpoke
	jmp	#LR__2331
LR__2325
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pslpoke
	jmp	#LR__2331
LR__2326
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pslpoke
	jmp	#LR__2331
LR__2327
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pslpoke
	jmp	#LR__2331
LR__2328
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pslpoke
	jmp	#LR__2331
LR__2329
	rdlong	arg02, fp
	mov	arg01, local13
	call	#_pslpoke
	jmp	#LR__2331
LR__2330
	mov	arg01, #50
	mov	arg02, #0
	call	#_printerror
LR__2331
LR__2332
	mov	ptra, fp
	call	#popregs_
_do_assign_ret
	ret

' 
' 
' '------------------ getvar.  Read a variable and push it to the RPN stack
' 
' sub do_getvar
_do_getvar
	mov	COUNT_, #13
	call	#pushregs_
	add	ptra, #60
' if compiledline(lineptr_e).result.twowords(1)=0 then
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg03, arg03 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__2341
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg01, local01
	shl	arg01, #1
	add	arg01, local01
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	local01, arg01
	shl	local01, #4
	sub	objptr, ##25732
	add	local01, objptr
	add	local01, #4
	rdlong	arg01, local01
	add	local01, #4
	rdlong	local01, local01
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	objptr, ##27272
	rdlong	local01, objptr
	mov	arg01, local01
	shl	arg01, #1
	add	arg01, local01
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	local01, arg01
	shl	local01, #4
	sub	objptr, ##25732
	add	local01, objptr
	add	local01, #12
	rdlong	local01, local01
	add	fp, #4
	wrlong	local01, fp
'   t1.result=variables(compiledline(lineptr_e).result.uresult).value
'   t1.result_type=variables(compiledline(lineptr_e).result.uresult).vartype
'   if t1.result_type<array_no_type then push t1 : return else goto 2100
	sub	fp, #8
	cmp	local01, #256 wc
	sub	objptr, ##11676
 if_ae	jmp	#LR__2340
	mov	arg01, fp
	call	#_push
	jmp	#LR__2362
LR__2340
LR__2341
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
	shl	arg03, #4
	sub	objptr, ##25732
	add	arg03, objptr
	add	arg03, #4
	rdlong	local02, arg03
	mov	arg01, local02
	sub	objptr, ##11676
	call	#_pslpeek
	getword	local03, result1, #0
	add	objptr, ##38948
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	add	arg02, #4
	rdlong	local04, arg02
	mov	arg01, local02
	add	arg01, #2
	sub	objptr, ##37408
	call	#_pspeek
	getbyte	local05, result1, #0
	mov	arg01, local02
	add	arg01, #4
	call	#_pslpeek
	mov	local06, result1
	mov	arg01, local02
	add	arg01, #8
	call	#_pslpeek
	mov	local07, result1
	mov	arg01, local02
	add	arg01, #12
	call	#_pslpeek
' numpar=compiledline(lineptr_e).result.twowords(1) ':print "in do_getvar numpar=",numpar
' esize=pspeek(arrptr+2)
' dim1=pslpeek(arrptr+4) ' todo :do one read from psram for speed
' dim2=pslpeek(arrptr+8) ' todo :do one read from psram for speed
' dim3=pslpeek(arrptr+12) ' todo :do one read from psram for speed
' if numpar>2 then t1=pop() : i3=converttoint(t1)   else i3=0 
	cmp	local04, #3 wc
 if_b	jmp	#LR__2342
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local08, result1
	jmp	#LR__2343
LR__2342
	mov	local08, #0
LR__2343
' if numpar>1 then t1=pop() : i2=converttoint(t1)   else i2=0 
	cmp	local04, #2 wc
 if_b	jmp	#LR__2344
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local09, result1
	jmp	#LR__2345
LR__2344
	mov	local09, #0
LR__2345
' if numpar>0 then t1=pop() : i1=converttoint(t1)   else i1=0 
	cmp	local04, #1 wc
 if_b	jmp	#LR__2346
	call	#_pop
	mov	local04, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local04, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local10, result1
	jmp	#LR__2347
LR__2346
	mov	local10, #0
LR__2347
	qmul	local09, local06
	mov	local11, local02
	add	local11, #16
	mov	local12, local10
	getqx	local10
	qmul	local08, local06
	add	local12, local10
	getqx	local10
	qmul	local10, local07
	getqx	local10
	add	local12, local10
	qmul	local12, local05
' 
' varidx=arrptr+16+(i1+i2*dim1+i3*dim1*dim2)*esize 
' 
' select case vartype
	mov	local13, local03
	sub	local13, #256
	fle	local13, #12
	getqx	local10
	add	local11, local10
	jmprel	local13
LR__2348
	jmp	#LR__2349
	jmp	#LR__2350
	jmp	#LR__2351
	jmp	#LR__2352
	jmp	#LR__2353
	jmp	#LR__2354
	jmp	#LR__2355
	jmp	#LR__2356
	jmp	#LR__2357
	jmp	#LR__2358
	jmp	#LR__2359
	jmp	#LR__2360
	jmp	#LR__2361
LR__2349
	mov	arg01, fp
	mov	arg02, local11
	mov	arg03, #12
	add	objptr, ##5836
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
	jmp	#LR__2361
LR__2350
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, local11
	call	#_pspeek
	getbyte	result1, result1, #0
	wrlong	result1, fp
	cmp	result1, #128 wc
 if_ae	neg	local01, #256
 if_ae	mov	local12, result1
 if_ae	or	local01, local12
 if_ae	wrlong	local01, fp
	jmp	#LR__2361
LR__2351
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, local11
	call	#_pspeek
	getbyte	result1, result1, #0
	wrlong	result1, fp
	jmp	#LR__2361
LR__2352
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, local11
	call	#_pslpeek
	getword	result1, result1, #0
	wrlong	result1, fp
	cmp	result1, ##32768 wc
 if_ae	mov	local01, ##16776960
 if_ae	mov	local12, result1
 if_ae	or	local01, local12
 if_ae	wrlong	local01, fp
	jmp	#LR__2361
LR__2353
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, local11
	call	#_pslpeek
	getword	result1, result1, #0
	wrlong	result1, fp
	jmp	#LR__2361
LR__2354
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, local11
	call	#_pslpeek
	wrlong	result1, fp
	jmp	#LR__2361
LR__2355
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, local11
	call	#_pslpeek
	wrlong	result1, fp
	jmp	#LR__2361
LR__2356
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
	wrlong	#48, fp
	jmp	#LR__2361
LR__2357
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
	wrlong	#48, fp
	jmp	#LR__2361
LR__2358
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, local11
	call	#_pslpeek
	wrlong	result1, fp
	jmp	#LR__2361
LR__2359
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
	wrlong	#48, fp
	jmp	#LR__2361
LR__2360
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, local11
	call	#_pslpeek
	wrlong	result1, fp
	cmp	result1, ##524288 wc
 if_ae	add	fp, #8
 if_ae	wrlong	#43, fp
 if_ae	sub	fp, #8
LR__2361
	mov	arg01, fp
	call	#_push
LR__2362
	mov	ptra, fp
	call	#popregs_
_do_getvar_ret
	ret

' 
' '------------------ getaddr.  Get a pointer to a variable and push it to the RPN stack
' 
' sub do_getaddr
_do_getaddr
	mov	COUNT_, #9
	call	#pushregs_
	add	ptra, #56
' 'print "in do_getvar, compiledline(lineptr_e) rt,ttw0,tw1="; compiledline(lineptr_e).result_type, compiledline(lineptr_e).result.twowords(0),compiledline(lineptr_e).result.twowords(1)
' if compiledline(lineptr_e).result.twowords(1)=0 then
	add	objptr, ##38948
	rdlong	arg01, objptr
	mov	result2, arg01
	shl	result2, #1
	add	result2, arg01
	shl	result2, #2
	sub	objptr, ##1540
	add	result2, objptr
	add	result2, #4
	rdlong	result2, result2 wz
	sub	objptr, ##37408
 if_ne	jmp	#LR__2370
	add	objptr, ##38948
	rdlong	arg01, objptr
	mov	result2, arg01
	shl	result2, #1
	add	result2, arg01
	shl	result2, #2
	sub	objptr, ##1540
	add	result2, objptr
	rdlong	arg01, result2
	shl	arg01, #4
	sub	objptr, ##25732
	add	arg01, objptr
	add	arg01, #12
	rdlong	arg01, arg01
	add	fp, #8
	wrlong	arg01, fp
'   t1.result_type=variables(compiledline(lineptr_e).result.uresult).vartype
'    if t1.result_type>=array_no_type then goto 2200
	sub	fp, #8
	cmp	arg01, #256 wc
	sub	objptr, ##11676
 if_ae	jmp	#LR__2371
	add	objptr, ##38948
	rdlong	arg01, objptr
	mov	result3, arg01
	shl	result3, #1
	add	result3, arg01
	shl	result3, #2
	sub	objptr, ##1540
	add	result3, objptr
	rdlong	result1, result3
	shl	result1, #4
	sub	objptr, ##25732
	add	result1, objptr
	add	result1, #4
	wrlong	result1, fp
	add	objptr, ##27272
	rdlong	result3, objptr
	mov	arg01, result3
	shl	arg01, #1
	add	arg01, result3
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	arg01, arg01
	shl	arg01, #4
	sub	objptr, ##25732
	add	arg01, objptr
	add	arg01, #12
	rdlong	arg01, arg01
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	sub	objptr, ##11676
	call	#_push
'   t1.result.uresult=varptr(variables(compiledline(lineptr_e).result.uresult).value)
'   t1.result.twowords(1)=variables(compiledline(lineptr_e).result.uresult).vartype
'   t1.result_type=result_uint
'   push t1 : return
	jmp	#LR__2380
LR__2370
LR__2371
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	result2, local01
	shl	result2, #1
	add	result2, local01
	shl	result2, #2
	sub	objptr, ##1540
	add	result2, objptr
	rdlong	result2, result2
	shl	result2, #4
	sub	objptr, ##25732
	add	result2, objptr
	add	result2, #4
	rdlong	local02, result2
	mov	arg01, local01
	shl	arg01, #1
	add	arg01, local01
	shl	arg01, #2
	add	objptr, ##25732
	add	arg01, objptr
	rdlong	arg01, arg01
	shl	arg01, #4
	sub	objptr, ##25732
	add	arg01, objptr
	add	arg01, #12
	rdlong	arg01, arg01
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #4
	mov	arg01, local02
	sub	objptr, ##11676
	call	#_pslpeek
	add	objptr, ##38948
	rdlong	local01, objptr
	mov	arg01, local01
	shl	arg01, #1
	add	arg01, local01
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	add	arg01, #4
	rdlong	local03, arg01
	mov	arg01, local02
	add	arg01, #2
	sub	objptr, ##37408
	call	#_pspeek
	getbyte	local04, result1, #0
	mov	arg01, local02
	add	arg01, #4
	call	#_pslpeek
	mov	local05, result1
	mov	arg01, local02
	add	arg01, #8
	call	#_pslpeek
	mov	local06, result1
	mov	arg01, local02
	add	arg01, #12
	call	#_pslpeek
' numpar=compiledline(lineptr_e).result.twowords(1) ':print "in do_getvar numpar=",numpar
' esize=pspeek(arrptr+2)
' dim1=pslpeek(arrptr+4) ' todo :do one read from psram for speed
' dim2=pslpeek(arrptr+8) ' todo :do one read from psram for speed
' dim3=pslpeek(arrptr+12) ' todo :do one read from psram for speed
' if numpar>2 then t1=pop() : i3=converttoint(t1)   else i3=0 
	cmp	local03, #3 wc
 if_b	jmp	#LR__2372
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local07, result1
	jmp	#LR__2373
LR__2372
	mov	local07, #0
LR__2373
' if numpar>1 then t1=pop() : i2=converttoint(t1)   else i2=0 
	cmp	local03, #2 wc
 if_b	jmp	#LR__2374
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local08, result1
	jmp	#LR__2375
LR__2374
	mov	local08, #0
LR__2375
' if numpar>0 then t1=pop() : i1=converttoint(t1)   else i1=0 
	cmp	local03, #1 wc
 if_b	jmp	#LR__2376
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local09, result1
	jmp	#LR__2377
LR__2376
	mov	local09, #0
LR__2377
' 'print "dim1=",dim1,"dim2=",dim2,"dim3=",dim3, "esize=",esize, "i1=", i1,"i2=", i2, "i3=", i3
' if numpar>0 then
	cmp	local03, #1 wc
 if_b	jmp	#LR__2378
	qmul	local08, local05
	add	local02, #16
	getqx	local08
	qmul	local07, local05
	add	local09, local08
	getqx	local08
	qmul	local08, local06
	getqx	local08
	add	local09, local08
	qmul	local09, local04
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	getqx	local01
	add	local02, local01
	wrlong	local02, fp
	jmp	#LR__2379
LR__2378
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	local02, fp
LR__2379
	mov	arg01, fp
	call	#_push
LR__2380
	mov	ptra, fp
	call	#popregs_
_do_getaddr_ret
	ret

' 
' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Operators ------------------------------------------------------------------------------------- 
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' '--------------------------------- AND 
' 
' sub do_and 
_do_and
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	arg01, result2
	mov	local04, result3
	mov	local02, arg01
	mov	local03, local04
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local05, #28 wz
 if_e	rdlong	local05, fp
 if_e	wrlong	local05, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	cmp	local03, #28 wz
 if_e	mov	local03, #29
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1060
	add	fp, #8
	rdlong	local05, fp
	sub	fp, #8
	cmp	local05, #31 wz
 if_ne	cmp	local03, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local04, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local04, #30 wz
 if_ne	cmp	local03, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	rdlong	local05, fp
 if_ne	and	local05, local01
 if_ne	wrlong	local05, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_and_ret
	ret

' 
' '--------------------------------- DIV (integer divide)
' 
' sub do_div 
_do_div
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	muldivb_, result2
	mov	muldiva_, result3
	mov	local02, muldivb_
	mov	local03, muldiva_
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=10: t1.result_type=result_error: goto 1090
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#10, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2395
' if t1.result_type=result_float then t1.result_type=result_int : t1.result.iresult=cast(integer,t1.result.fresult)
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__2390
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
LR__2390
' if t2.result_type=result_float then t2.result_type=result_int : t2.result.iresult=cast(integer,t2.result.fresult)
	cmp	local03, #30 wz
 if_ne	jmp	#LR__2391
	mov	local03, #28
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__2391
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	cmp	local04, #29 wz
 if_e	cmp	local03, #29 wz
 if_e	rdlong	local04, fp
 if_e	qdiv	local04, local01
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult/=t2.result.uresult :goto 1090
 if_e	getqx	local04
 if_e	wrlong	local04, fp
 if_e	jmp	#LR__2395
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult/t2.result.iresult: t1.result_type=result_int :goto 1090
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	cmp	local04, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2392
	rdlong	local04, fp
	qdiv	local04, local01
	getqx	local04
	wrlong	local04, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2395
LR__2392
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult/=t2.result.uresult :goto 1090
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	cmp	local04, #28 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2393
	rdlong	muldiva_, fp
	mov	muldivb_, local01
	call	#divide_
	wrlong	muldivb_, fp
	jmp	#LR__2395
LR__2393
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult=t1.result.iresult/t2.result.iresult: goto 1090
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	cmp	local04, #28 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2394
	rdlong	muldiva_, fp
	mov	muldivb_, local01
	call	#divide_
	wrlong	muldivb_, fp
	jmp	#LR__2395
LR__2394
	wrlong	#11, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2395
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_div_ret
	ret

' 
' '--------------------------------- equal (=)
' 
' sub do_eq
_do_eq
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local04, result2
	mov	local05, result3
	mov	local02, local04
	mov	local03, local05
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult=t2.result.sresult) : goto 1150
	sub	fp, #8
	cmp	local05, #31 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2400
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2413
LR__2400
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult=t2.result.fresult) : goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2401
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2413
LR__2401
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult=t2.result.iresult) : goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2402
	mov	local06, #0
	rdlong	local04, fp
	abs	arg01, local01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2413
LR__2402
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult=t2.result.uresult) : goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2403
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2413
LR__2403
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult=t2.result.fresult) : goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2404
	mov	local06, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg01, result1
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2413
LR__2404
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult=t2.result.iresult) : goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2405
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wz
 if_e	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2413
LR__2405
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult=t2.result.uresult) : goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2406
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wz
 if_e	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2413
LR__2406
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult=t2.result.fresult) : goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2407
	mov	local06, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2413
LR__2407
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult=t2.result.iresult) : goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2408
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wz
 if_e	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2413
LR__2408
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult=t2.result.uresult) : goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2409
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wz
 if_e	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2413
LR__2409
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)=t2.result.sresult):goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2410
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2413
LR__2410
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult=convertstring(t2.result.uresult)) :goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2411
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2413
LR__2411
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)=convertstring(t2.result.uresult)) :goto 1150
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2412
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local04, result1
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2413
LR__2412
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2413
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_eq_ret
	ret

' 
' '--------------------------------- fdiv (/) - float divide
' 
' sub do_fdiv 
_do_fdiv
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	arg02, result2
	mov	arg01, result3
	mov	local02, arg02
	mov	local03, arg01
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=10: t1.result_type=result_error: goto 1100
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#10, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2425
' if t1.result_type=result_int then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.iresult) 
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__2420
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	wrlong	result1, fp
LR__2420
' if t1.result_type=result_uint then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.uresult)
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__2421
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	call	#__system___float_fromuns
	wrlong	result1, fp
LR__2421
' if t2.result_type=result_int then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.iresult) 
	cmp	local03, #28 wz
 if_ne	jmp	#LR__2422
	mov	local03, #30
	abs	arg01, local01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	local01, result1
LR__2422
' if t2.result_type=result_uint then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.uresult) 
	cmp	local03, #29 wz
 if_ne	jmp	#LR__2423
	mov	local03, #30
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	local01, result1
LR__2423
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult/=t2.result.fresult: goto 1100
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2424
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___float_div
	wrlong	result1, fp
	jmp	#LR__2425
LR__2424
	wrlong	#11, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2425
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_fdiv_ret
	ret

' 
' '--------------------------------- greater or equal (>=)
' 
' sub do_ge
_do_ge
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local04, result2
	mov	local05, result3
	mov	local02, local04
	mov	local03, local05
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult>=t2.result.sresult) : goto 1180
	sub	fp, #8
	cmp	local05, #31 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2430
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2443
LR__2430
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult>=t2.result.fresult) : goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2431
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2443
LR__2431
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult>=t2.result.iresult) : goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2432
	mov	local06, #0
	rdlong	local04, fp
	abs	arg01, local01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg02, result1
	mov	arg01, local04
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2443
LR__2432
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult>=t2.result.uresult) : goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2433
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local04
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2443
LR__2433
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult>=t2.result.fresult) : goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2434
	mov	local06, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg01, result1
	mov	arg02, local01
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2443
LR__2434
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult>=t2.result.iresult) : goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2435
	mov	local06, #0
	rdlong	local04, fp
	cmps	local04, local01 wc
 if_ae	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2443
LR__2435
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult>=t2.result.uresult) : goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2436
	mov	local06, #0
	rdlong	local04, fp
	cmps	local04, local01 wc
 if_ae	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2443
LR__2436
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult>=t2.result.fresult) : goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2437
	mov	local06, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	mov	arg02, local01
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2443
LR__2437
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult>=t2.result.iresult) : goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2438
	mov	local06, #0
	rdlong	local04, fp
	cmps	local04, local01 wc
 if_ae	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2443
LR__2438
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult>=t2.result.uresult) : goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2439
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wc
 if_ae	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2443
LR__2439
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)>=t2.result.sresult):goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2440
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2443
LR__2440
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult>=convertstring(t2.result.uresult)) :goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2441
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2443
LR__2441
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)>=convertstring(t2.result.uresult)) :goto 1180
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2442
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local04, result1
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2443
LR__2442
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2443
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
' 1180 t1.result_type=result_int : if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
	rdlong	local06, fp wz
 if_ne	wrlong	#1, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_ge_ret
	ret

' 
' '--------------------------------- greater than (>)
' 
' sub do_gt
_do_gt
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local04, result2
	mov	local05, result3
	mov	local02, local04
	mov	local03, local05
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult>t2.result.sresult) : goto 1160
	sub	fp, #8
	cmp	local05, #31 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2450
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2463
LR__2450
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult>t2.result.fresult) : goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2451
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2463
LR__2451
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult>t2.result.iresult) : goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2452
	mov	local06, #0
	rdlong	local04, fp
	abs	arg01, local01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg02, result1
	mov	arg01, local04
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2463
LR__2452
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult>t2.result.uresult) : goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2453
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local04
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2463
LR__2453
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult>t2.result.fresult) : goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2454
	mov	local06, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg01, result1
	mov	arg02, local01
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2463
LR__2454
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult>t2.result.iresult) : goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2455
	mov	local06, #0
	rdlong	local04, fp
	cmps	local04, local01 wcz
 if_a	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2463
LR__2455
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult>t2.result.uresult) : goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2456
	mov	local06, #0
	rdlong	local04, fp
	cmps	local04, local01 wcz
 if_a	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2463
LR__2456
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult>t2.result.fresult) : goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2457
	mov	local06, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	mov	arg02, local01
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2463
LR__2457
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult>t2.result.iresult) : goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2458
	mov	local06, #0
	rdlong	local04, fp
	cmps	local04, local01 wcz
 if_a	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2463
LR__2458
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult>t2.result.uresult) : goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2459
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wcz
 if_a	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2463
LR__2459
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)>t2.result.sresult):goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2460
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2463
LR__2460
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult>convertstring(t2.result.uresult)) :goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2461
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2463
LR__2461
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)>convertstring(t2.result.uresult)) :goto 1160
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2462
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local04, result1
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2463
LR__2462
	wrlong	#0, fp
LR__2463
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
' t1.result.uresult=0
' 1160 t1.result_type=result_int : if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
	rdlong	local06, fp wz
 if_ne	wrlong	#1, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_gt_ret
	ret

' 
' '--------------------------------- less or equal (<=)
' 
' sub do_le
_do_le
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local04, result2
	mov	local05, result3
	mov	local02, local04
	mov	local03, local05
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult<=t2.result.sresult) : goto 1190
	sub	fp, #8
	cmp	local05, #31 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2470
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2483
LR__2470
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult<=t2.result.fresult) : goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2471
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2483
LR__2471
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult<=t2.result.iresult) : goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2472
	mov	local06, #0
	rdlong	local04, fp
	abs	arg01, local01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2483
LR__2472
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult<=t2.result.uresult) : goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2473
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2483
LR__2473
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult<=t2.result.fresult) : goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2474
	mov	local06, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg01, result1
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2483
LR__2474
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult<=t2.result.iresult) : goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2475
	mov	local06, #0
	rdlong	local04, fp
	cmps	local04, local01 wcz
 if_be	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2483
LR__2475
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult<=t2.result.uresult) : goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2476
	mov	local06, #0
	rdlong	local04, fp
	cmps	local04, local01 wcz
 if_be	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2483
LR__2476
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult<=t2.result.fresult) : goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2477
	mov	local06, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2483
LR__2477
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult<=t2.result.iresult) : goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2478
	mov	local06, #0
	rdlong	local04, fp
	cmps	local04, local01 wcz
 if_be	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2483
LR__2478
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult<=t2.result.uresult) : goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2479
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wcz
 if_be	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2483
LR__2479
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)<=t2.result.sresult):goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2480
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2483
LR__2480
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult<=convertstring(t2.result.uresult)) :goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2481
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2483
LR__2481
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)<=convertstring(t2.result.uresult)) :goto 1190
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2482
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local04, result1
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2483
LR__2482
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2483
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_le_ret
	ret

' 
' '--------------------------------- less than (<)
' 
' sub do_lt
_do_lt
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local04, result2
	mov	local05, result3
	mov	local02, local04
	mov	local03, local05
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult<t2.result.sresult) : goto 1170
	sub	fp, #8
	cmp	local05, #31 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2490
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2499
LR__2490
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult<t2.result.fresult) : goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2491
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2499
LR__2491
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult<t2.result.iresult) : goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2492
	mov	local06, #0
	rdlong	local04, fp
	abs	arg01, local01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2499
LR__2492
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult<t2.result.uresult) : goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2493
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2499
LR__2493
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult<t2.result.fresult) : goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2494
	mov	local06, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg01, result1
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2499
LR__2494
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult<t2.result.iresult) : goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #28 wz
 if_e	rdlong	local04, fp
 if_e	cmps	local04, local01 wc
 if_e	subx	local06, local06
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2499
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult<t2.result.uresult) : goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #29 wz
 if_e	rdlong	local04, fp
 if_e	cmps	local04, local01 wc
 if_e	subx	local06, local06
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2499
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult<t2.result.fresult) : goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2495
	mov	local06, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2499
LR__2495
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult<t2.result.iresult) : goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #28 wz
 if_e	rdlong	local04, fp
 if_e	cmps	local04, local01 wc
 if_e	subx	local06, local06
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2499
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult<t2.result.uresult) : goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #29 wz
 if_e	rdlong	local04, fp
 if_e	cmp	local04, local01 wc
 if_e	subx	local06, local06
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2499
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)<t2.result.sresult):goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2496
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2499
LR__2496
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult<convertstring(t2.result.uresult)) :goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2497
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2499
LR__2497
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)<convertstring(t2.result.uresult)) :goto 1170
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2498
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local04, result1
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2499
LR__2498
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2499
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_lt_ret
	ret

' 
' '--------------------------------- minus (-)
' 
' sub do_minus
_do_minus
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local04, result2
	mov	local05, result3
	mov	local02, local04
	mov	local03, local05
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_uint andalso t2.result_type=result_uint then 
	sub	fp, #8
	cmp	local05, #29 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2500
'     if t2.result.uresult<t1.result.uresult then  t1.result.uresult-=t2.result.uresult : goto 1050 else t1.result.iresult=t1.result.uresult-t2.result.uresult : t1.result_type=result_int : goto 1050
	rdlong	local06, fp
	cmp	local01, local06 wc
 if_b	sub	local06, local01
 if_b	wrlong	local06, fp
 if_b	jmp	#LR__2507
	rdlong	local06, fp
	sub	local06, local01
	wrlong	local06, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2507
LR__2500
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult-t2.result.iresult: t1.result_type=result_int :goto 1050
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2501
	rdlong	local06, fp
	sub	local06, local01
	wrlong	local06, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2507
LR__2501
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.uresult)-t2.result.fresult: t1.result_type=result_float :goto 1050
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2502
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	mov	arg02, local01
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2507
LR__2502
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult-=t2.result.uresult:goto 1050
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #29 wz
 if_e	rdlong	local06, fp
 if_e	sub	local06, local01
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2507
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult-=t2.result.iresult:goto 1050
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #28 wz
 if_e	rdlong	local06, fp
 if_e	sub	local06, local01
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2507
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.iresult)-t2.result.fresult: t1.result_type=result_float :goto 1050
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2503
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg01, result1
	mov	arg02, local01
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2507
LR__2503
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.fresult=t1.result.fresult-cast(single,t2.result.uresult) :goto 1050
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2504
	rdlong	local06, fp
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local06
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2507
LR__2504
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.fresult=t1.result.fresult-cast(single,t2.result.iresult) :goto 1050
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2505
	rdlong	local06, fp
	abs	arg01, local01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg02, result1
	mov	arg01, local06
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2507
LR__2505
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult-=t2.result.fresult:goto 1050
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2506
	rdlong	arg01, fp
	mov	arg02, local01
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2507
LR__2506
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=3: t1.result_type=result_error: goto 1050
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#3, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	wrlong	#5, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
LR__2507
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_minus_ret
	ret

' 
' '--------------------------------- negative (-), one argument negative
' 
' sub do_negative
_do_negative
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
' 
' t1=pop()
' if t1.result_type=result_int then 
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	rdlong	local02, fp
 if_e	neg	local01, local02
 if_e	wrlong	local01, fp
 if_e	jmp	#LR__2512
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_ne	jmp	#LR__2510
	rdlong	local02, fp
	neg	local01, local02
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2511
LR__2510
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	rdlong	result1, fp
 if_e	bitnot	result1, #31
 if_e	wrlong	result1, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	wrlong	#40, fp
LR__2511
LR__2512
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_negative_ret
	ret

' 
' '--------------------------------- MOD (modulo)
' 
' sub do_mod 
_do_mod
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	muldivb_, result2
	mov	muldiva_, result3
	mov	local02, muldivb_
	mov	local03, muldiva_
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=10: t1.result_type=result_error: goto 1110
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#10, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2525
' if t1.result_type=result_float then t1.result_type=result_int : t1.result.iresult=cast(integer,t1.result.fresult)
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__2520
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
LR__2520
' if t2.result_type=result_float then t2.result_type=result_int : t2.result.iresult=cast(integer,t2.result.fresult)
	cmp	local03, #30 wz
 if_ne	jmp	#LR__2521
	mov	local03, #28
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__2521
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	cmp	local04, #29 wz
 if_e	cmp	local03, #29 wz
 if_e	rdlong	local04, fp
 if_e	qdiv	local04, local01
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=t1.result.uresult mod t2.result.uresult :goto 1110
 if_e	getqy	local04
 if_e	wrlong	local04, fp
 if_e	jmp	#LR__2525
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult mod t2.result.iresult: t1.result_type=result_int :goto 1110
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	cmp	local04, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2522
	rdlong	local04, fp
	qdiv	local04, local01
	getqy	local04
	wrlong	local04, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2525
LR__2522
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult=t1.result.iresult mod t2.result.uresult :goto 1110
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	cmp	local04, #28 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2523
	rdlong	muldiva_, fp
	mov	muldivb_, local01
	call	#divide_
	wrlong	muldiva_, fp
	jmp	#LR__2525
LR__2523
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult=t1.result.iresult mod t2.result.iresult: goto 1110
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	cmp	local04, #28 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2524
	rdlong	muldiva_, fp
	mov	muldivb_, local01
	call	#divide_
	wrlong	muldiva_, fp
	jmp	#LR__2525
LR__2524
	wrlong	#11, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2525
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mod_ret
	ret

' 
' '--------------------------------- mul (*)
' 
' sub do_mul
_do_mul
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local04, result2
	mov	arg02, result3
	mov	local02, local04
	mov	local03, arg02
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
	sub	fp, #8
	cmp	local05, #29 wz
 if_e	cmp	local03, #29 wz
 if_e	rdlong	local04, fp
 if_e	qmul	local04, local01
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult*=t2.result.uresult :goto 1080
 if_e	getqx	local06
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2536
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult*t2.result.iresult: t1.result_type=result_int :goto 1080
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2530
	rdlong	local04, fp
	qmul	local04, local01
	getqx	local06
	wrlong	local06, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2536
LR__2530
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.uresult)*t2.result.fresult: t1.result_type=result_float :goto 1080
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2531
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2536
LR__2531
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #29 wz
 if_e	rdlong	local04, fp
 if_e	qmul	local04, local01
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult*=t2.result.uresult:goto 1080
 if_e	getqx	local06
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2536
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #28 wz
 if_e	rdlong	local04, fp
 if_e	qmul	local04, local01
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult*=t2.result.iresult:goto 1080
 if_e	getqx	local06
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2536
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.iresult)*t2.result.fresult: t1.result_type=result_float :goto 1080
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2532
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2536
LR__2532
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.fresult=t1.result.fresult*cast(single,t2.result.uresult) :goto 1080
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2533
	rdlong	local06, fp
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	wrlong	result1, fp
	jmp	#LR__2536
LR__2533
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.fresult=t1.result.fresult*cast(single,t2.result.iresult) :goto 1080
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2534
	rdlong	local06, fp
	abs	arg01, local01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	wrlong	result1, fp
	jmp	#LR__2536
LR__2534
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult*=t2.result.fresult:goto 1080
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2535
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___float_mul
	wrlong	result1, fp
	jmp	#LR__2536
LR__2535
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=8: t1.result_type=result_error: goto 1080
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#8, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	wrlong	#9, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
LR__2536
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mul_ret
	ret

' 
' '--------------------------------- not equal (<>)
' 
' sub do_ne
_do_ne
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local04, result2
	mov	local05, result3
	mov	local02, local04
	mov	local03, local05
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult<>t2.result.sresult) : goto 1192
	sub	fp, #8
	cmp	local05, #31 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2540
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2553
LR__2540
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult<>t2.result.fresult) : goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2541
	mov	local06, #0
	rdlong	arg01, fp
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2553
LR__2541
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult<>t2.result.iresult) : goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2542
	mov	local06, #0
	rdlong	local04, fp
	abs	arg01, local01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2553
LR__2542
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult<>t2.result.uresult) : goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2543
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local04
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2553
LR__2543
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult<>t2.result.fresult) : goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2544
	mov	local06, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg01, result1
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2553
LR__2544
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult<>t2.result.iresult) : goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2545
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wz
 if_ne	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2553
LR__2545
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult<>t2.result.uresult) : goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2546
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wz
 if_ne	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2553
LR__2546
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult<>t2.result.fresult) : goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2547
	mov	local06, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	mov	arg02, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2553
LR__2547
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult<>t2.result.iresult) : goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2548
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wz
 if_ne	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2553
LR__2548
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult<>t2.result.uresult) : goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2549
	mov	local06, #0
	rdlong	local04, fp
	cmp	local04, local01 wz
 if_ne	neg	local06, #1
	wrlong	local06, fp
	jmp	#LR__2553
LR__2549
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)<>t2.result.sresult):goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2550
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2553
LR__2550
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult<>convertstring(t2.result.uresult)) :goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2551
	mov	local06, #0
	rdlong	local04, fp
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2553
LR__2551
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)<>convertstring(t2.result.uresult)) :goto 1192
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2552
	mov	local06, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local04, result1
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local06, #0
	wrlong	local06, fp
	jmp	#LR__2553
LR__2552
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2553
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_ne_ret
	ret

' 
' '--------------------------------- OR
' 
' sub do_or 
_do_or
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	arg01, result2
	mov	local04, result3
	mov	local02, arg01
	mov	local03, local04
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local05, #28 wz
 if_e	rdlong	local05, fp
 if_e	wrlong	local05, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	cmp	local03, #28 wz
 if_e	mov	local03, #29
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1070
	add	fp, #8
	rdlong	local05, fp
	sub	fp, #8
	cmp	local05, #31 wz
 if_ne	cmp	local03, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local04, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local04, #30 wz
 if_ne	cmp	local03, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	rdlong	local05, fp
 if_ne	or	local05, local01
 if_ne	wrlong	local05, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_or_ret
	ret

' 
' '--------------------------------- plus (+)
' 
' sub do_plus 
_do_plus
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local04, result2
	mov	local05, result3
	mov	local02, local04
	mov	local03, local05
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult+=t2.result.uresult :goto 1040
	mov	local06, local05
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #29 wz
 if_e	rdlong	local06, fp
 if_e	add	local06, local01
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2572
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult+t2.result.iresult: t1.result_type=result_int :goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2560
	rdlong	local06, fp
	add	local06, local01
	wrlong	local06, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2572
LR__2560
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.uresult)+t2.result.fresult: t1.result_type=result_float :goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #29 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2561
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2572
LR__2561
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult+=t2.result.uresult: goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #29 wz
 if_e	rdlong	local06, fp
 if_e	add	local06, local01
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2572
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult+=t2.result.iresult:goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #28 wz
 if_e	rdlong	local06, fp
 if_e	add	local06, local01
 if_e	wrlong	local06, fp
 if_e	jmp	#LR__2572
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.iresult)+t2.result.fresult: t1.result_type=result_float :goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #28 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2562
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2572
LR__2562
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.fresult=t1.result.fresult+cast(single,t2.result.uresult) :goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2563
	rdlong	local06, fp
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2572
LR__2563
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.fresult=t1.result.fresult+cast(single,t2.result.iresult) :goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2564
	rdlong	local06, fp
	abs	arg01, local01 wc
 if_b	decod	local07, #31
 if_ae	mov	local07, #0
	call	#__system___float_fromuns
	xor	result1, local07
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2572
LR__2564
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult+=t2.result.fresult:goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2565
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2572
LR__2565
' if t1.result_type=result_string andalso t2.result_type<>result_string then t1.result.uresult=2 :t1.result_type=result_error:goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_ne	jmp	#LR__2566
	cmp	local03, #31 wz
 if_ne	wrlong	#2, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__2572
LR__2566
' if t2.result_type=result_string andalso t1.result_type<>result_string then t1.result.uresult=2 :t1.result_type=result_error:goto 1040
	cmp	local03, #31 wz
 if_ne	jmp	#LR__2567
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_ne	wrlong	#2, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__2572
LR__2567
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.sresult=t1.result.sresult+t2.result.sresult :goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2568
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system___string_concat
	wrlong	result1, fp
	jmp	#LR__2572
LR__2568
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.sresult=convertstring(t1.result.uresult)+t2.result.sresult : t1.result_type=result_string:goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2569
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_concat
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	jmp	#LR__2572
LR__2569
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.sresult=t1.result.sresult+convertstring(t2.result.uresult) :goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #31 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2570
	rdlong	local06, fp
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___string_concat
	wrlong	result1, fp
	jmp	#LR__2572
LR__2570
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult)+convertstring(t2.result.uresult) : t1.result_type=result_string :goto 1040
	add	fp, #8
	rdlong	local06, fp
	sub	fp, #8
	cmp	local06, #43 wz
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2571
	rdlong	arg01, fp
	call	#_convertstring
	mov	local06, result1
	mov	arg01, local01
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___string_concat
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	jmp	#LR__2572
LR__2571
	wrlong	#4, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2572
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_plus_ret
	ret

' 
' '--------------------------------- power (^)
' 
' sub do_power 
_do_power
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	arg02, result2
	mov	arg01, result3
	mov	local02, arg02
	mov	local03, arg01
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=12: t1.result_type=result_error: goto 1140
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#12, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2585
' if t1.result_type=result_int then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.iresult) 
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__2580
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	wrlong	result1, fp
LR__2580
' if t1.result_type=result_uint then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.uresult) 
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__2581
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	call	#__system___float_fromuns
	wrlong	result1, fp
LR__2581
' if t2.result_type=result_int then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.iresult) 
	cmp	local03, #28 wz
 if_ne	jmp	#LR__2582
	mov	local03, #30
	abs	arg01, local01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	local01, result1
LR__2582
' if t2.result_type=result_uint then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.uresult) 
	cmp	local03, #29 wz
 if_ne	jmp	#LR__2583
	mov	local03, #30
	mov	arg01, local01
	call	#__system___float_fromuns
	mov	local01, result1
LR__2583
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult=t1.result.fresult^t2.result.fresult: goto 1140
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #30 wz
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2584
	rdlong	arg01, fp
	mov	arg02, local01
	call	#__system____builtin_powf
	wrlong	result1, fp
	jmp	#LR__2585
LR__2584
	wrlong	#13, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2585
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_power_ret
	ret

' 
' '--------------------------------- SHL
' 
' sub do_shl 
_do_shl
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	arg01, result2
	mov	local04, result3
	mov	local02, arg01
	mov	local03, local04
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local05, #28 wz
 if_e	rdlong	local05, fp
 if_e	wrlong	local05, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	cmp	local03, #28 wz
 if_e	mov	local03, #29
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1120
	add	fp, #8
	rdlong	local05, fp
	sub	fp, #8
	cmp	local05, #31 wz
 if_ne	cmp	local03, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local04, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local04, #30 wz
 if_ne	cmp	local03, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	rdlong	local05, fp
 if_ne	shl	local05, local01
 if_ne	wrlong	local05, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_shl_ret
	ret

' 
' '--------------------------------- SHR
' 
' sub do_shr 
_do_shr
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	arg01, result2
	mov	local04, result3
	mov	local02, arg01
	mov	local03, local04
	call	#_pop
	mov	local05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local05, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local05, #28 wz
 if_e	rdlong	local05, fp
 if_e	wrlong	local05, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	cmp	local03, #28 wz
 if_e	mov	local03, #29
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1130
	add	fp, #8
	rdlong	local05, fp
	sub	fp, #8
	cmp	local05, #31 wz
 if_ne	cmp	local03, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local04, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local04, #30 wz
 if_ne	cmp	local03, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	rdlong	local05, fp
 if_ne	shr	local05, local01
 if_ne	wrlong	local05, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_shr_ret
	ret

' 
' '--------------------------- THE END OF THE MAIN PROGRAM ------------------------------------------------------
' 
' ''----------------------------------------------------------------------------------------------------
' ''------------------ Initialization procedures and helper procedures ---------------------------------
' ''----------------------------------------------------------------------------------------------------
' 
' ''--------------------------- Command function pointers
' 
' sub init_commands
_init_commands
' 
' for i=0 to 255 : commands(i)=@do_no_command : next i
	mov	_var01, #0
	callpa	#(@LR__2591-@LR__2590)>>2,fcache_load_ptr_
LR__2590
	mov	result1, _var01
	shl	result1, #2
	mov	arg02, objptr
	add	arg02, ##35332
	add	result1, arg02
	wrlong	objptr, result1
	add	_var01, #1
	cmps	_var01, #256 wc
 if_b	jmp	#LR__2590
LR__2591
	mov	result1, objptr
	bith	result1, #20
	add	objptr, ##35336
	wrlong	result1, objptr
	sub	objptr, ##35336
	mov	result1, objptr
	bith	result1, #21
	add	objptr, ##35340
	wrlong	result1, objptr
	sub	objptr, ##35340
	mov	result1, objptr
	bith	result1, #52
	add	objptr, ##35344
	wrlong	result1, objptr
	sub	objptr, ##35344
	mov	result1, objptr
	bith	result1, #22
	add	objptr, ##35352
	wrlong	result1, objptr
	sub	objptr, ##35352
	mov	result1, objptr
	or	result1, ##5242880
	add	objptr, ##35356
	wrlong	result1, objptr
	sub	objptr, ##35356
	mov	result1, objptr
	bith	result1, #53
	add	objptr, ##35360
	wrlong	result1, objptr
	sub	objptr, ##35360
	mov	result1, objptr
	bith	result1, #84
	add	objptr, ##35364
	wrlong	result1, objptr
	sub	objptr, ##35364
	mov	result1, objptr
	bith	result1, #23
	add	objptr, ##35368
	wrlong	result1, objptr
	sub	objptr, ##35368
	mov	result1, objptr
	or	result1, ##9437184
	add	objptr, ##35372
	wrlong	result1, objptr
	sub	objptr, ##35372
	mov	result1, objptr
	or	result1, ##10485760
	add	objptr, ##35376
	wrlong	result1, objptr
	sub	objptr, ##35376
	mov	result1, objptr
	or	result1, ##11534336
	add	objptr, ##35380
	wrlong	result1, objptr
	sub	objptr, ##35380
	mov	result1, objptr
	bith	result1, #54
	add	objptr, ##35400
	wrlong	result1, objptr
	sub	objptr, ##35400
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##35448
	wrlong	result1, objptr
	sub	objptr, ##35448
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##35444
	wrlong	result1, objptr
	sub	objptr, ##35444
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##35452
	wrlong	result1, objptr
	sub	objptr, ##35452
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##35456
	wrlong	result1, objptr
	sub	objptr, ##35456
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##35504
	wrlong	result1, objptr
	sub	objptr, ##35504
	mov	result1, objptr
	bith	result1, #85
	add	objptr, ##35424
	wrlong	result1, objptr
	sub	objptr, ##35424
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##35508
	wrlong	result1, objptr
	sub	objptr, ##35508
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##35460
	wrlong	result1, objptr
	sub	objptr, ##35460
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##35464
	wrlong	result1, objptr
	sub	objptr, ##35464
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##35468
	wrlong	result1, objptr
	sub	objptr, ##35468
	mov	result1, objptr
	bith	result1, #116
	add	objptr, ##35588
	wrlong	result1, objptr
	sub	objptr, ##35588
	mov	result1, objptr
	bith	result1, #24
	add	objptr, ##35592
	wrlong	result1, objptr
	sub	objptr, ##35592
	mov	result1, objptr
	or	result1, ##17825792
	add	objptr, ##35596
	wrlong	result1, objptr
	sub	objptr, ##35596
	mov	result1, objptr
	or	result1, ##18874368
	add	objptr, ##35600
	wrlong	result1, objptr
	sub	objptr, ##35600
	mov	result1, objptr
	or	result1, ##19922944
	add	objptr, ##35604
	wrlong	result1, objptr
	sub	objptr, ##35604
	mov	result1, objptr
	or	result1, ##20971520
	add	objptr, ##35608
	wrlong	result1, objptr
	sub	objptr, ##35608
	mov	result1, objptr
	or	result1, ##22020096
	add	objptr, ##35612
	wrlong	result1, objptr
	sub	objptr, ##35612
	mov	result1, objptr
	or	result1, ##23068672
	add	objptr, ##35616
	wrlong	result1, objptr
	sub	objptr, ##35616
	mov	result1, objptr
	or	result1, ##24117248
	add	objptr, ##35620
	wrlong	result1, objptr
	sub	objptr, ##35620
	mov	result1, objptr
	bith	result1, #55
	add	objptr, ##35624
	wrlong	result1, objptr
	sub	objptr, ##35624
	mov	result1, objptr
	or	result1, ##26214400
	add	objptr, ##35628
	wrlong	result1, objptr
	sub	objptr, ##35628
	mov	result1, objptr
	or	result1, ##27262976
	add	objptr, ##35632
	wrlong	result1, objptr
	sub	objptr, ##35632
	mov	result1, objptr
	or	result1, ##28311552
	add	objptr, ##35636
	wrlong	result1, objptr
	sub	objptr, ##35636
	mov	result1, objptr
	bith	result1, #86
	add	objptr, ##35640
	wrlong	result1, objptr
	sub	objptr, ##35640
	mov	result1, objptr
	or	result1, ##30408704
	add	objptr, ##36352
	wrlong	result1, objptr
	sub	objptr, ##36352
	mov	result1, objptr
	bith	result1, #117
	add	objptr, ##35644
	wrlong	result1, objptr
	sub	objptr, ##35644
	mov	result1, objptr
	bith	result1, #148
	add	objptr, ##35664
	wrlong	result1, objptr
	sub	objptr, ##35664
	mov	result1, objptr
	bith	result1, #25
	add	objptr, ##35648
	wrlong	result1, objptr
	sub	objptr, ##35648
	mov	result1, objptr
	or	result1, ##34603008
	add	objptr, ##35420
	wrlong	result1, objptr
	sub	objptr, ##35420
	mov	result1, objptr
	or	result1, ##35651584
	add	objptr, ##35656
	wrlong	result1, objptr
	sub	objptr, ##35656
	mov	result1, objptr
	or	result1, ##36700160
	add	objptr, ##35660
	wrlong	result1, objptr
	sub	objptr, ##35660
	mov	result1, objptr
	or	result1, ##37748736
	add	objptr, ##35672
	wrlong	result1, objptr
	sub	objptr, ##35672
	mov	result1, objptr
	or	result1, ##38797312
	add	objptr, ##35676
	wrlong	result1, objptr
	sub	objptr, ##35676
	mov	result1, objptr
	or	result1, ##39845888
	add	objptr, ##35680
	wrlong	result1, objptr
	sub	objptr, ##35680
	mov	result1, objptr
	or	result1, ##40894464
	add	objptr, ##35684
	wrlong	result1, objptr
	sub	objptr, ##35684
	mov	result1, objptr
	or	result1, ##41943040
	add	objptr, ##35692
	wrlong	result1, objptr
	sub	objptr, ##35692
	mov	result1, objptr
	or	result1, ##34603008
	add	objptr, ##35696
	wrlong	result1, objptr
	sub	objptr, ##35696
	mov	result1, objptr
	or	result1, ##42991616
	add	objptr, ##35440
	wrlong	result1, objptr
	sub	objptr, ##35440
	mov	result1, objptr
	or	result1, ##44040192
	add	objptr, ##35488
	wrlong	result1, objptr
	sub	objptr, ##35488
	mov	result1, objptr
	or	result1, ##45088768
	add	objptr, ##35484
	wrlong	result1, objptr
	sub	objptr, ##35484
	mov	result1, objptr
	or	result1, ##46137344
	add	objptr, ##35392
	wrlong	result1, objptr
	sub	objptr, ##35392
	mov	result1, objptr
	or	result1, ##47185920
	add	objptr, ##35396
	wrlong	result1, objptr
	sub	objptr, ##35396
	mov	result1, objptr
	or	result1, ##48234496
	add	objptr, ##35500
	wrlong	result1, objptr
	sub	objptr, ##35500
	mov	result1, objptr
	or	result1, ##49283072
	add	objptr, ##35668
	wrlong	result1, objptr
	sub	objptr, ##35668
	mov	result1, objptr
	bith	result1, #56
	add	objptr, ##35688
	wrlong	result1, objptr
	sub	objptr, ##35688
	mov	result1, objptr
	or	result1, ##51380224
	add	objptr, ##35700
	wrlong	result1, objptr
	sub	objptr, ##35700
	mov	result1, objptr
	or	result1, ##52428800
	add	objptr, ##35704
	wrlong	result1, objptr
	sub	objptr, ##35704
	mov	result1, objptr
	or	result1, ##53477376
	add	objptr, ##35708
	wrlong	result1, objptr
	sub	objptr, ##35708
	mov	result1, objptr
	or	result1, ##54525952
	add	objptr, ##35712
	wrlong	result1, objptr
	sub	objptr, ##35712
	mov	result1, objptr
	or	result1, ##55574528
	add	objptr, ##35716
	wrlong	result1, objptr
	sub	objptr, ##35716
	mov	result1, objptr
	or	result1, ##56623104
	add	objptr, ##35720
	wrlong	result1, objptr
	sub	objptr, ##35720
	mov	result1, objptr
	bith	result1, #148
	add	objptr, ##35664
	wrlong	result1, objptr
	sub	objptr, ##35664
	mov	result1, objptr
	or	result1, ##57671680
	add	objptr, ##35728
	wrlong	result1, objptr
	sub	objptr, ##35728
	mov	result1, objptr
	bith	result1, #87
	add	objptr, ##35724
	wrlong	result1, objptr
	sub	objptr, ##35724
	mov	result1, objptr
	or	result1, ##59768832
	add	objptr, ##35748
	wrlong	result1, objptr
	sub	objptr, ##35748
	mov	result1, objptr
	or	result1, ##60817408
	add	objptr, ##35752
	wrlong	result1, objptr
	sub	objptr, ##35752
	mov	result1, objptr
	or	result1, ##61865984
	add	objptr, ##35732
	wrlong	result1, objptr
	sub	objptr, ##35732
	mov	result1, objptr
	bith	result1, #118
	add	objptr, ##35736
	wrlong	result1, objptr
	sub	objptr, ##35736
	mov	result1, objptr
	or	result1, ##63963136
	add	objptr, ##35740
	wrlong	result1, objptr
	sub	objptr, ##35740
	mov	result1, objptr
	bith	result1, #149
	add	objptr, ##35744
	wrlong	result1, objptr
	sub	objptr, ##35744
	mov	result1, objptr
	bith	result1, #180
	add	objptr, ##35760
	wrlong	result1, objptr
	sub	objptr, ##35760
	mov	result1, objptr
	bith	result1, #26
	add	objptr, ##35756
	wrlong	result1, objptr
	sub	objptr, ##35756
	mov	result1, objptr
	or	result1, ##68157440
	add	objptr, ##35772
	wrlong	result1, objptr
	sub	objptr, ##35772
	mov	result1, objptr
	or	result1, ##69206016
	add	objptr, ##35768
	wrlong	result1, objptr
	sub	objptr, ##35768
	mov	result1, objptr
	or	result1, ##70254592
	add	objptr, ##35764
	wrlong	result1, objptr
	sub	objptr, ##35764
	mov	result1, objptr
	or	result1, ##71303168
	add	objptr, ##35776
	wrlong	result1, objptr
	sub	objptr, ##35776
	mov	result1, objptr
	or	result1, ##72351744
	add	objptr, ##35780
	wrlong	result1, objptr
	sub	objptr, ##35780
	mov	result1, objptr
	or	result1, ##73400320
	add	objptr, ##35416
	wrlong	result1, objptr
	sub	objptr, ##35416
	mov	result1, objptr
	or	result1, ##74448896
	add	objptr, ##35804
	wrlong	result1, objptr
	sub	objptr, ##35804
	mov	result1, objptr
	or	result1, ##75497472
	add	objptr, ##35820
	wrlong	result1, objptr
	sub	objptr, ##35820
	mov	result1, objptr
	or	result1, ##76546048
	add	objptr, ##35824
	wrlong	result1, objptr
	sub	objptr, ##35824
	mov	result1, objptr
	or	result1, ##77594624
	add	objptr, ##35816
	wrlong	result1, objptr
	sub	objptr, ##35816
	mov	result1, objptr
	or	result1, ##78643200
	add	objptr, ##35808
	wrlong	result1, objptr
	sub	objptr, ##35808
	mov	result1, objptr
	or	result1, ##79691776
	add	objptr, ##35812
	wrlong	result1, objptr
	sub	objptr, ##35812
	mov	result1, objptr
	or	result1, ##80740352
	add	objptr, ##35828
	wrlong	result1, objptr
	sub	objptr, ##35828
	mov	result1, objptr
	or	result1, ##81788928
	add	objptr, ##35832
	wrlong	result1, objptr
	sub	objptr, ##35832
	mov	result1, objptr
	or	result1, ##82837504
	add	objptr, ##35836
	wrlong	result1, objptr
	sub	objptr, ##35836
	mov	result1, objptr
	or	result1, ##83886080
	add	objptr, ##35840
	wrlong	result1, objptr
	sub	objptr, ##35840
	mov	result1, objptr
	or	result1, ##84934656
	add	objptr, ##35844
	wrlong	result1, objptr
	sub	objptr, ##35844
	mov	result1, objptr
	or	result1, ##85983232
	add	objptr, ##35848
	wrlong	result1, objptr
	sub	objptr, ##35848
	mov	result1, objptr
	or	result1, ##87031808
	add	objptr, ##35852
	wrlong	result1, objptr
	sub	objptr, ##35852
	mov	result1, objptr
	or	result1, ##88080384
	add	objptr, ##35856
	wrlong	result1, objptr
	sub	objptr, ##35856
	mov	result1, objptr
	or	result1, ##89128960
	add	objptr, ##35868
	wrlong	result1, objptr
	sub	objptr, ##35868
	mov	result1, objptr
	or	result1, ##90177536
	add	objptr, ##35860
	wrlong	result1, objptr
	sub	objptr, ##35860
	mov	result1, objptr
	or	result1, ##91226112
	add	objptr, ##35864
	wrlong	result1, objptr
	sub	objptr, ##35864
	mov	result1, objptr
	or	result1, ##92274688
	add	objptr, ##35872
	wrlong	result1, objptr
	sub	objptr, ##35872
	mov	result1, objptr
	or	result1, ##93323264
	add	objptr, ##35784
	wrlong	result1, objptr
	sub	objptr, ##35784
	mov	result1, objptr
	or	result1, ##94371840
	add	objptr, ##35792
	wrlong	result1, objptr
	sub	objptr, ##35792
	mov	result1, objptr
	or	result1, ##95420416
	add	objptr, ##35796
	wrlong	result1, objptr
	sub	objptr, ##35796
	mov	result1, objptr
	or	result1, ##96468992
	add	objptr, ##35876
	wrlong	result1, objptr
	sub	objptr, ##35876
	mov	result1, objptr
	or	result1, ##97517568
	add	objptr, ##35880
	wrlong	result1, objptr
	sub	objptr, ##35880
	mov	result1, objptr
	or	result1, ##98566144
	add	objptr, ##35884
	wrlong	result1, objptr
	sub	objptr, ##35884
	mov	result1, objptr
	or	result1, ##99614720
	add	objptr, ##35800
	wrlong	result1, objptr
	sub	objptr, ##35800
	mov	result1, objptr
	bith	result1, #57
	add	objptr, ##35900
	wrlong	result1, objptr
	sub	objptr, ##35900
	mov	result1, objptr
	or	result1, ##101711872
	add	objptr, ##35908
	wrlong	result1, objptr
	sub	objptr, ##35908
	mov	result1, objptr
	or	result1, ##102760448
	add	objptr, ##35896
	wrlong	result1, objptr
	sub	objptr, ##35896
	mov	result1, objptr
	or	result1, ##103809024
	add	objptr, ##35892
	wrlong	result1, objptr
	sub	objptr, ##35892
	mov	result1, objptr
	or	result1, ##104857600
	add	objptr, ##35888
	wrlong	result1, objptr
	sub	objptr, ##35888
	mov	result1, objptr
	or	result1, ##105906176
	add	objptr, ##35904
	wrlong	result1, objptr
	sub	objptr, ##35904
	mov	result1, objptr
	or	result1, ##106954752
	add	objptr, ##35912
	wrlong	result1, objptr
	sub	objptr, ##35912
	mov	result1, objptr
	or	result1, ##108003328
	add	objptr, ##35916
	wrlong	result1, objptr
	sub	objptr, ##35916
	mov	result1, objptr
	or	result1, ##109051904
	add	objptr, ##35920
	wrlong	result1, objptr
	sub	objptr, ##35920
	mov	result1, objptr
	or	result1, ##110100480
	add	objptr, ##35928
	wrlong	result1, objptr
	sub	objptr, ##35928
	mov	result1, objptr
	or	result1, ##111149056
	add	objptr, ##35932
	wrlong	result1, objptr
	sub	objptr, ##35932
	mov	result1, objptr
	or	result1, ##112197632
	add	objptr, ##35936
	wrlong	result1, objptr
	sub	objptr, ##35936
	mov	result1, objptr
	or	result1, ##113246208
	add	objptr, ##35940
	wrlong	result1, objptr
	sub	objptr, ##35940
	mov	result1, objptr
	or	result1, ##114294784
	add	objptr, ##35944
	wrlong	result1, objptr
	sub	objptr, ##35944
	mov	result1, objptr
	or	result1, ##115343360
	add	objptr, ##35948
	wrlong	result1, objptr
	sub	objptr, ##35948
	mov	result1, objptr
	or	result1, ##34603008
	add	objptr, ##35952
	wrlong	result1, objptr
	sub	objptr, ##35952
	mov	result1, objptr
	or	result1, ##116391936
	add	objptr, ##35956
	wrlong	result1, objptr
	sub	objptr, ##35956
	mov	result1, objptr
	bith	result1, #88
	add	objptr, ##35924
	wrlong	result1, objptr
	sub	objptr, ##35924
	mov	result1, objptr
	or	result1, ##118489088
	add	objptr, ##35404
	wrlong	result1, objptr
	sub	objptr, ##35404
	mov	result1, objptr
	or	result1, ##119537664
	add	objptr, ##35960
	wrlong	result1, objptr
	sub	objptr, ##35960
	mov	result1, objptr
	or	result1, ##120586240
	add	objptr, ##35964
	wrlong	result1, objptr
	sub	objptr, ##35964
	mov	result1, objptr
	or	result1, ##121634816
	add	objptr, ##35984
	wrlong	result1, objptr
	sub	objptr, ##35984
	mov	result1, objptr
	or	result1, ##122683392
	add	objptr, ##35980
	wrlong	result1, objptr
	sub	objptr, ##35980
	mov	result1, objptr
	or	result1, ##123731968
	add	objptr, ##35972
	wrlong	result1, objptr
	sub	objptr, ##35972
	mov	result1, objptr
	or	result1, ##124780544
	add	objptr, ##35968
	wrlong	result1, objptr
	sub	objptr, ##35968
	mov	result1, objptr
	bith	result1, #119
	add	objptr, ##36000
	wrlong	result1, objptr
	sub	objptr, ##36000
	mov	result1, objptr
	or	result1, ##126877696
	add	objptr, ##35988
	wrlong	result1, objptr
	sub	objptr, ##35988
	mov	result1, objptr
	or	result1, ##127926272
	add	objptr, ##35992
	wrlong	result1, objptr
	sub	objptr, ##35992
	mov	result1, objptr
	or	result1, ##128974848
	add	objptr, ##35996
	wrlong	result1, objptr
	sub	objptr, ##35996
	mov	result1, objptr
	bith	result1, #150
	add	objptr, ##36004
	wrlong	result1, objptr
	sub	objptr, ##36004
	mov	result1, objptr
	or	result1, ##131072000
	add	objptr, ##36008
	wrlong	result1, objptr
	sub	objptr, ##36008
	mov	result1, objptr
	bith	result1, #181
	add	objptr, ##36012
	wrlong	result1, objptr
	sub	objptr, ##36012
	mov	result1, objptr
	bith	result1, #212
	add	objptr, ##36016
	wrlong	result1, objptr
	sub	objptr, ##36016
	mov	result1, objptr
	bith	result1, #27
	add	objptr, ##36020
	wrlong	result1, objptr
	sub	objptr, ##36020
	mov	result1, objptr
	or	result1, ##135266304
	add	objptr, ##36024
	wrlong	result1, objptr
	sub	objptr, ##36024
	mov	result1, objptr
	or	result1, ##136314880
	add	objptr, ##36032
	wrlong	result1, objptr
	sub	objptr, ##36032
	mov	result1, objptr
	or	result1, ##137363456
	add	objptr, ##36036
	wrlong	result1, objptr
	sub	objptr, ##36036
	mov	result1, objptr
	or	result1, ##138412032
	add	objptr, ##36040
	wrlong	result1, objptr
	sub	objptr, ##36040
	mov	result1, objptr
	or	result1, ##139460608
	add	objptr, ##36028
	wrlong	result1, objptr
	sub	objptr, ##36028
	mov	result1, objptr
	or	result1, ##140509184
	add	objptr, ##36044
	wrlong	result1, objptr
	sub	objptr, ##36044
	mov	result1, objptr
	or	result1, ##141557760
	add	objptr, ##36096
	wrlong	result1, objptr
	sub	objptr, ##36096
	mov	result1, objptr
	or	result1, ##142606336
	add	objptr, ##36088
	wrlong	result1, objptr
	sub	objptr, ##36088
	mov	result1, objptr
	or	result1, ##143654912
	add	objptr, ##36048
	wrlong	result1, objptr
	sub	objptr, ##36048
	mov	result1, objptr
	or	result1, ##144703488
	add	objptr, ##36052
	wrlong	result1, objptr
	sub	objptr, ##36052
	mov	result1, objptr
	or	result1, ##145752064
	add	objptr, ##36080
	wrlong	result1, objptr
	sub	objptr, ##36080
	mov	result1, objptr
	or	result1, ##146800640
	add	objptr, ##36084
	wrlong	result1, objptr
	sub	objptr, ##36084
	mov	result1, objptr
	or	result1, ##147849216
	add	objptr, ##36112
	wrlong	result1, objptr
	sub	objptr, ##36112
	mov	result1, objptr
	or	result1, ##148897792
	add	objptr, ##36108
	wrlong	result1, objptr
	sub	objptr, ##36108
	mov	result1, objptr
	or	result1, ##149946368
	add	objptr, ##36124
	wrlong	result1, objptr
	sub	objptr, ##36124
	mov	result1, objptr
	or	result1, ##150994944
	add	objptr, ##36072
	wrlong	result1, objptr
	sub	objptr, ##36072
	mov	result1, objptr
	or	result1, ##152043520
	add	objptr, ##36120
	wrlong	result1, objptr
	sub	objptr, ##36120
	mov	result1, objptr
	or	result1, ##153092096
	add	objptr, ##36104
	wrlong	result1, objptr
	sub	objptr, ##36104
	mov	result1, objptr
	or	result1, ##154140672
	add	objptr, ##35512
	wrlong	result1, objptr
	sub	objptr, ##35512
	mov	result1, objptr
	or	result1, ##155189248
	add	objptr, ##36056
	wrlong	result1, objptr
	sub	objptr, ##36056
	mov	result1, objptr
	or	result1, ##34603008
	add	objptr, ##36064
	wrlong	result1, objptr
	sub	objptr, ##36064
	mov	result1, objptr
	or	result1, ##156237824
	add	objptr, ##36060
	wrlong	result1, objptr
	sub	objptr, ##36060
	mov	result1, objptr
	or	result1, ##157286400
	add	objptr, ##36128
	wrlong	result1, objptr
	sub	objptr, ##36128
	mov	result1, objptr
	or	result1, ##158334976
	add	objptr, ##36132
	wrlong	result1, objptr
	sub	objptr, ##36132
	mov	result1, objptr
	or	result1, ##159383552
	add	objptr, ##36136
	wrlong	result1, objptr
	sub	objptr, ##36136
	mov	result1, objptr
	or	result1, ##160432128
	add	objptr, ##36140
	wrlong	result1, objptr
	sub	objptr, ##36140
	mov	result1, objptr
	or	result1, ##161480704
	add	objptr, ##36148
	wrlong	result1, objptr
	sub	objptr, ##36148
	mov	result1, objptr
	or	result1, ##162529280
	add	objptr, ##36152
	wrlong	result1, objptr
	sub	objptr, ##36152
	mov	result1, objptr
	or	result1, ##163577856
	add	objptr, ##36156
	wrlong	result1, objptr
	sub	objptr, ##36156
	mov	result1, objptr
	or	result1, ##164626432
	add	objptr, ##36188
	wrlong	result1, objptr
	sub	objptr, ##36188
	mov	result1, objptr
	or	result1, ##165675008
	add	objptr, ##36184
	wrlong	result1, objptr
	sub	objptr, ##36184
	mov	result1, objptr
	or	result1, ##166723584
	add	objptr, ##36116
	wrlong	result1, objptr
	sub	objptr, ##36116
	mov	result1, objptr
	or	result1, ##167772160
	add	objptr, ##36100
	wrlong	result1, objptr
	sub	objptr, ##36100
	mov	result1, objptr
	or	result1, ##168820736
	add	objptr, ##36160
	wrlong	result1, objptr
	sub	objptr, ##36160
	mov	result1, objptr
	or	result1, ##169869312
	add	objptr, ##36164
	wrlong	result1, objptr
	sub	objptr, ##36164
	mov	result1, objptr
	or	result1, ##170917888
	add	objptr, ##36168
	wrlong	result1, objptr
	sub	objptr, ##36168
	mov	result1, objptr
	or	result1, ##171966464
	add	objptr, ##36172
	wrlong	result1, objptr
	sub	objptr, ##36172
	mov	result1, objptr
	or	result1, ##173015040
	add	objptr, ##36176
	wrlong	result1, objptr
	sub	objptr, ##36176
	mov	result1, objptr
	or	result1, ##174063616
	add	objptr, ##36200
	wrlong	result1, objptr
	sub	objptr, ##36200
	mov	result1, objptr
	or	result1, ##175112192
	add	objptr, ##36180
	wrlong	result1, objptr
	sub	objptr, ##36180
	mov	result1, objptr
	or	result1, ##176160768
	add	objptr, ##36192
	wrlong	result1, objptr
	sub	objptr, ##36192
	mov	result1, objptr
	or	result1, ##177209344
	add	objptr, ##36196
	wrlong	result1, objptr
	sub	objptr, ##36196
	mov	result1, objptr
	or	result1, ##178257920
	add	objptr, ##36204
	wrlong	result1, objptr
	sub	objptr, ##36204
	mov	result1, objptr
	or	result1, ##179306496
	add	objptr, ##36208
	wrlong	result1, objptr
	sub	objptr, ##36208
	mov	result1, objptr
	or	result1, ##180355072
	add	objptr, ##35976
	wrlong	result1, objptr
	sub	objptr, ##35976
_init_commands_ret
	ret

' 
' ''-------------------------------- Audio subsystem init  -------------------------------------
' 
' sub init_audio
_init_audio
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, ##1065353216
' 
' for i=0 to 1023 : psdpoke       2*i,round(32600*sin(i*3.1415926535/512.0)) : next i               		' 0 : sinewave  
	mov	local02, #0
LR__2600
	mov	local03, local02
	shl	local03, #1
	mov	local04, ##1191096320
	abs	arg01, local02 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	mov	arg02, ##1078530011
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, ##1140850688
	call	#__system___float_div
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	arg02, result1
	mov	arg01, local03
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__2600
' for i=0 to 511  : psdpoke  2048+2*i, -32512+127*i: psdpoke 2048+2*(512+i),32512-127*i : next i   		' 1 : triangle 
	mov	local02, #0
LR__2601
	mov	arg02, local02
	shl	arg02, #1
	decod	arg01, #11
	add	arg01, arg02
	mov	local04, local02
	shl	local04, #7
	sub	local04, local02
	mov	arg02, ##-32512
	add	arg02, local04
	call	#_psdpoke
	decod	local04, #9
	add	local04, local02
	shl	local04, #1
	decod	arg01, #11
	add	arg01, local04
	mov	local05, local02
	shl	local05, #7
	sub	local05, local02
	mov	arg02, ##32512
	sub	arg02, local05
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##512 wc
 if_b	jmp	#LR__2601
' for i=0 to 1023 : psdpoke  4096+2*i, -32256+63*i : next i 							' 2 saw 4 sqr 8 noise 3567 
	mov	local02, #0
LR__2602
	mov	local05, local02
	shl	local05, #1
	decod	arg01, #12
	add	arg01, local05
	mov	local05, local02
	shl	local05, #6
	sub	local05, local02
	mov	arg02, ##-32256
	add	arg02, local05
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__2602
' for i=0 to 127  : psdpoke  6144+2*i, -32600 : next i : for i=128 to 1023 :  psdpoke 6144+2*i, 32600 : next i 	' 3 pulse 12.5%
	mov	local02, #0
LR__2603
	mov	arg02, local02
	shl	arg02, #1
	mov	arg01, ##6144
	add	arg01, arg02
	mov	arg02, ##-32600
	call	#_psdpoke
	add	local02, #1
	cmps	local02, #128 wc
 if_b	jmp	#LR__2603
	mov	local02, #128
LR__2604
	mov	arg02, local02
	shl	arg02, #1
	mov	arg01, ##6144
	add	arg01, arg02
	mov	arg02, ##32600
	call	#_psdpoke
	add	local02, #1
	cmp	local02, ##1024 wc
 if_b	jmp	#LR__2604
' for i=0 to 511  : psdpoke  8192+2*i, -32600 : next i : for i=512 to 1023 :  psdpoke 8192+2*i, 32600 : next i 	' 4 square
	mov	local02, #0
LR__2605
	mov	arg02, local02
	shl	arg02, #1
	decod	arg01, #13
	add	arg01, arg02
	mov	arg02, ##-32600
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##512 wc
 if_b	jmp	#LR__2605
	decod	local02, #9
LR__2606
	mov	arg02, local02
	shl	arg02, #1
	decod	arg01, #13
	add	arg01, arg02
	mov	arg02, ##32600
	call	#_psdpoke
	add	local02, #1
	cmp	local02, ##1024 wc
 if_b	jmp	#LR__2606
' for i=0 to 255  : psdpoke 10240+2*i, -32600 : next i : for i=256 to 1023 : psdpoke 10240+2*i, 32600 : next i 	' 5 pulse 25%
	mov	local02, #0
LR__2607
	mov	arg02, local02
	shl	arg02, #1
	mov	arg01, ##10240
	add	arg01, arg02
	mov	arg02, ##-32600
	call	#_psdpoke
	add	local02, #1
	cmps	local02, #256 wc
 if_b	jmp	#LR__2607
	mov	local02, #256
LR__2608
	mov	arg02, local02
	shl	arg02, #1
	mov	arg01, ##10240
	add	arg01, arg02
	mov	arg02, ##32600
	call	#_psdpoke
	add	local02, #1
	cmp	local02, ##1024 wc
 if_b	jmp	#LR__2608
' for i=12288 to 61436 step 4 : pslpoke i,0 : next i 
	mov	local02, ##12288
LR__2609
	mov	arg01, local02
	mov	arg02, #0
	call	#_pslpoke
	add	local02, #4
	cmps	local02, ##61437 wc
 if_b	jmp	#LR__2609
' for i=0 to 1023 : psdpoke 61440+2*i, dpeek(varptr(atari12)+16+2*i) : next i 				' 6 pokey waveform 12	
	mov	local02, #0
LR__2610
	mov	arg02, local02
	shl	arg02, #1
	mov	local03, ##61440
	add	local03, arg02
	mov	arg01, ptr__dat__
	add	arg01, ##9418
	mov	arg02, local02
	shl	arg02, #1
	add	arg01, arg02
	rdword	arg02, arg01
	mov	arg01, local03
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__2610
' for i=0 to 1023 : psdpoke 63488+2*i, dpeek(varptr(atari2)+16+2*i) : next i 				' 7 pokey waveform 2	
	mov	local02, #0
LR__2611
	mov	arg02, local02
	shl	arg02, #1
	mov	local03, ##63488
	add	local03, arg02
	mov	arg01, ptr__dat__
	add	arg01, ##7354
	mov	arg02, local02
	shl	arg02, #1
	add	arg01, arg02
	rdword	arg02, arg01
	mov	arg01, local03
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__2611
' for i=0 to 255 : envbuf(0,i)=65280-256*i : next i							' instant attack, linear release	
	mov	local02, #0
	add	objptr, ##7224
	callpa	#(@LR__2613-@LR__2612)>>2,fcache_load_ptr_
LR__2612
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local06, local02
	shl	local06, #8
	mov	local07, ##65280
	sub	local07, local06
	wrword	local07, local03
	add	local02, #1
	cmps	local02, #256 wc
 if_b	jmp	#LR__2612
LR__2613
	sub	objptr, ##7224
' for i=0 to 255 : envbuf(1,i)=round(65280.0*k) : k=k*0.975 :  next i : envbuf(1,255)=0			' instant attack, log release
	mov	local02, #0
LR__2614
	mov	local03, local02
	shl	local03, #1
	mov	local05, objptr
	add	local05, ##7736
	add	local03, local05
	mov	arg01, ##1199505408
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local03
	mov	arg01, local01
	mov	arg02, ##1064933786
	call	#__system___float_mul
	mov	local01, result1
	add	local02, #1
	cmps	local02, #256 wc
 if_b	jmp	#LR__2614
	add	objptr, ##8246
	wrword	#0, objptr
' for i=0 to 254 : envbuf(2,i)=65280 : next i : envbuf(2,255)=0						' instant attack, instant release
	mov	local02, #0
	add	objptr, #2
	callpa	#(@LR__2616-@LR__2615)>>2,fcache_load_ptr_
LR__2615
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	wrword	##65280, local03
	add	local02, #1
	cmps	local02, #255 wc
 if_b	jmp	#LR__2615
LR__2616
	add	objptr, #510
	wrword	#0, objptr
' for i=0 to 15 :  envbuf(3,i)=4096*i : next i 
	mov	local02, #0
	add	objptr, #2
	callpa	#(@LR__2618-@LR__2617)>>2,fcache_load_ptr_
LR__2617
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local07, local02
	shl	local07, #12
	wrword	local07, local03
	add	local02, #1
	cmps	local02, #16 wc
 if_b	jmp	#LR__2617
LR__2618
' for i=16 to 239: envbuf(3,i)=65280 : next i
	mov	local02, #16
	callpa	#(@LR__2620-@LR__2619)>>2,fcache_load_ptr_
LR__2619
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	wrword	##65280, local03
	add	local02, #1
	cmp	local02, #240 wc
 if_b	jmp	#LR__2619
LR__2620
' for i=240 to 255 : envbuf(3,i)=4096*(255-i) : next i							' smooth attack, smooth release
	mov	local02, #240
	callpa	#(@LR__2622-@LR__2621)>>2,fcache_load_ptr_
LR__2621
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local06, #255
	sub	local06, local02
	shl	local06, #12
	wrword	local06, local03
	add	local02, #1
	cmp	local02, #256 wc
 if_b	jmp	#LR__2621
LR__2622
' for i=0 to 255 : envbuf(4,i)=256*i : next i : envbuf(4,255)=0						' slow attack, instant release
	mov	local02, #0
	add	objptr, ##512
	callpa	#(@LR__2624-@LR__2623)>>2,fcache_load_ptr_
LR__2623
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local07, local02
	shl	local07, #8
	wrword	local07, local03
	add	local02, #1
	cmps	local02, #256 wc
 if_b	jmp	#LR__2623
LR__2624
	add	objptr, #510
	wrword	#0, objptr
' for i=0 to 239 : envbuf(5,i)=272*i : next i : for i=240 to 255 : envbuf(5,i)=4096*(255-i) : next i	' slow attack, smooth release
	mov	local02, #0
	add	objptr, #2
	callpa	#(@LR__2626-@LR__2625)>>2,fcache_load_ptr_
LR__2625
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local07, local02
	shl	local07, #4
	add	local07, local02
	shl	local07, #4
	wrword	local07, local03
	add	local02, #1
	cmps	local02, #240 wc
 if_b	jmp	#LR__2625
LR__2626
	mov	local02, #240
	callpa	#(@LR__2628-@LR__2627)>>2,fcache_load_ptr_
LR__2627
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local06, #255
	sub	local06, local02
	shl	local06, #12
	wrword	local06, local03
	add	local02, #1
	cmp	local02, #256 wc
 if_b	jmp	#LR__2627
LR__2628
' for i=0 to 127 : envbuf(6,i)=512*i : envbuf(6,255-i)=512*i : next i 					' triangle
	mov	local02, #0
	add	objptr, ##512
	callpa	#(@LR__2630-@LR__2629)>>2,fcache_load_ptr_
LR__2629
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local07, local02
	shl	local07, #9
	wrword	local07, local03
	mov	local03, #255
	sub	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local07, local02
	shl	local07, #9
	wrword	local07, local03
	add	local02, #1
	cmps	local02, #128 wc
 if_b	jmp	#LR__2629
LR__2630
' for i=0 to 7: envbuf(7,i)=8192*i : next i
	mov	local02, #0
	add	objptr, ##512
	callpa	#(@LR__2632-@LR__2631)>>2,fcache_load_ptr_
LR__2631
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local07, local02
	shl	local07, #13
	wrword	local07, local03
	add	local02, #1
	cmps	local02, #8 wc
 if_b	jmp	#LR__2631
LR__2632
' for i=8 to 23 : envbuf(7,i)=65280-2048*(i-8) : next i 	
	mov	local02, #8
	callpa	#(@LR__2634-@LR__2633)>>2,fcache_load_ptr_
LR__2633
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local05, local02
	sub	local05, #8
	shl	local05, #11
	mov	local07, ##65280
	sub	local07, local05
	wrword	local07, local03
	add	local02, #1
	cmp	local02, #24 wc
 if_b	jmp	#LR__2633
LR__2634
' for i=24 to 128 : envbuf(7,i)=32768 : next i
	mov	local02, #24
	callpa	#(@LR__2636-@LR__2635)>>2,fcache_load_ptr_
LR__2635
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	wrword	##32768, local03
	add	local02, #1
	cmp	local02, #129 wc
 if_b	jmp	#LR__2635
LR__2636
' for i=129 to 255: envbuf(7,i)=256*(255-i) : next i : suspoints(7)=128							' classic adsr
	mov	local02, #129
	callpa	#(@LR__2638-@LR__2637)>>2,fcache_load_ptr_
LR__2637
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	mov	local06, #255
	sub	local06, local02
	shl	local06, #8
	wrword	local06, local03
	add	local02, #1
	cmp	local02, #256 wc
 if_b	jmp	#LR__2637
LR__2638
	add	objptr, ##32358
	wrword	#128, objptr
	sub	objptr, ##43166
' for i=0 to 7
	mov	local02, #0
	callpa	#(@LR__2640-@LR__2639)>>2,fcache_load_ptr_
LR__2639
	mov	local03, local02
	shl	local03, #3
	sub	local03, local02
	shl	local03, #2
	add	objptr, ##11452
	add	local03, objptr
	wrlong	##1138491392, local03
	mov	local03, local02
	shl	local03, #3
	sub	local03, local02
	shl	local03, #2
	add	local03, objptr
	add	local03, #4
	wrbyte	local02, local03
	mov	local03, local02
	shl	local03, #3
	sub	local03, local02
	shl	local03, #2
	add	local03, objptr
	add	local03, #5
	wrbyte	local02, local03
	mov	local03, local02
	shl	local03, #3
	sub	local03, local02
	shl	local03, #2
	add	local03, objptr
	add	local03, #6
	wrword	#0, local03
	mov	local03, local02
	shl	local03, #3
	sub	local03, local02
	shl	local03, #2
	add	local03, objptr
	add	local03, #8
	wrlong	##1065353216, local03
	mov	local03, local02
	shl	local03, #3
	sub	local03, local02
	shl	local03, #2
	add	local03, objptr
	add	local03, #12
	wrlong	##1082130432, local03
	mov	local03, local02
	shl	local03, #3
	sub	local03, local02
	shl	local03, #2
	add	local03, objptr
	add	local03, #16
	wrlong	#0, local03
	mov	local03, local02
	shl	local03, #3
	sub	local03, local02
	shl	local03, #2
	add	local03, objptr
	add	local03, #20
	wrword	#255, local03
	mov	local03, local02
	shl	local03, #3
	sub	local03, local02
	shl	local03, #2
	add	local03, objptr
	add	local03, #22
	wrword	#0, local03
	mov	local03, local02
	shl	local03, #1
	add	objptr, ##31700
	add	local03, objptr
	wrword	#255, local03
	add	local02, #1
	cmps	local02, #8 wc
	sub	objptr, ##43152
 if_b	jmp	#LR__2639
LR__2640
	mov	local07, ##1088159744
' a=6.875 : for i=1 to 3 : a=a*(2.0^(1.0/12.0)) : next i : for i=0 to 11 : notetable(i) = a : a=a*(2.0^(1.0/12.0)) : next i
	mov	local06, #3
LR__2641
	mov	arg01, local07
	mov	arg02, ##1065852029
	call	#__system___float_mul
	mov	local07, result1
	djnz	local06, #LR__2641
	mov	local02, #0
LR__2642
	mov	local04, local02
	shl	local04, #2
	mov	local03, objptr
	add	local03, ##11320
	add	local04, local03
	wrlong	local07, local04
	mov	arg01, local07
	mov	arg02, ##1065852029
	call	#__system___float_mul
	mov	local07, result1
	add	local02, #1
	cmps	local02, #12 wc
 if_b	jmp	#LR__2642
	add	objptr, ##11368
	wrlong	#424, objptr
	add	objptr, #4
	wrlong	#400, objptr
	add	objptr, #4
	wrlong	#377, objptr
	add	objptr, #4
	wrlong	#356, objptr
	add	objptr, #4
	wrlong	#336, objptr
	add	objptr, #4
	wrlong	#317, objptr
	add	objptr, #4
	wrlong	#300, objptr
	add	objptr, #4
	wrlong	#283, objptr
	add	objptr, #4
	wrlong	#267, objptr
	add	objptr, #4
	wrlong	#252, objptr
	add	objptr, #4
	wrlong	#238, objptr
	add	objptr, #4
	wrlong	#224, objptr
	add	objptr, ##31754
	wrword	#128, objptr
	sub	objptr, #2
	wrword	#128, objptr
	sub	objptr, ##43164
	mov	ptra, fp
	call	#popregs_
_init_audio_ret
	ret

' 
' '------------------- Error messages
' 
' sub init_error_strings
_init_error_strings
	mov	_var01, ##@LR__6102
	add	objptr, ##36384
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6103
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6104
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6105
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6106
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6107
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6108
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6109
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6110
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6111
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6112
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6113
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6114
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6115
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6116
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6117
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6118
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6119
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6120
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6121
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6122
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6123
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6124
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6125
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6126
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6127
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6128
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6129
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6130
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6131
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6132
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6133
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6134
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6135
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6136
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6137
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6138
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6139
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6140
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6141
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6142
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6143
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6144
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6145
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6146
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6147
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6148
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6149
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6150
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6151
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6152
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6153
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6154
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6155
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6156
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__6157
	add	objptr, #4
	wrlong	_var01, objptr
	sub	objptr, ##36604
_init_error_strings_ret
	ret

'         
' sub printerror(err as integer, linenum=0 as integer)
_printerror
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, ##@LR__6158
	call	#_Hg010b_4_spin2_write
	mov	arg01, local01
	call	#_Hg010b_4_spin2_inttostr
	mov	arg01, result1
	call	#_Hg010b_4_spin2_write
	mov	arg01, ##@LR__6159
	call	#_Hg010b_4_spin2_write
	shl	local01, #2
	mov	arg02, objptr
	add	arg02, ##36384
	add	local01, arg02
	rdlong	arg01, local01
	call	#_Hg010b_4_spin2_write
' v.write("Error " ): v.write(v.inttostr(err)) : v.write(" - ")  : v.write(errors$(err))
' if linenum>0 then v.write(" in line " ): v.writeln(v.inttostr(linenum)) else v.writeln("")
	cmps	local02, #1 wc
 if_b	jmp	#LR__2650
	mov	arg01, ##@LR__6160
	call	#_Hg010b_4_spin2_write
	mov	arg01, local02
	call	#_Hg010b_4_spin2_inttostr
	mov	arg01, result1
' 
' write(text)
	call	#_Hg010b_4_spin2_write
' crlf
	call	#_Hg010b_4_spin2_crlf
	jmp	#LR__2651
LR__2650
	mov	arg01, ##@LR__6161
' 
' write(text)
	call	#_Hg010b_4_spin2_write
' crlf
	call	#_Hg010b_4_spin2_crlf
LR__2651
	mov	ptra, fp
	call	#popregs_
_printerror_ret
	ret

' 
' '' ------------------------------- Hardware start/stop/initialization 
' 
' sub startpsram
_startpsram
	mov	arg01, #0
	decod	arg02, #10
	mov	arg03, #11
	mov	arg04, #7
	add	objptr, ##5836
	call	#_psram4_spin2_startx
	add	objptr, ##23264
	wrlong	result1, objptr
'     return $7FF00 + cog*12
	add	objptr, #12
	wrlong	##524032, objptr
	sub	objptr, ##29112
_startpsram_ret
	ret

' 
' function startvideo(mode=64, pin=0, mb=0) 'todo return a cog#
_startvideo
	mov	COUNT_, #1
	call	#pushregs_
	add	objptr, ##29112
	rdlong	arg04, objptr
	sub	objptr, ##29112
	mov	arg01, arg02
	mov	arg02, arg04
	call	#_Hg010b_4_spin2_start
	add	objptr, ##29092
	wrlong	result1, objptr
' 
' videocog=v.start(pin,mbox)
' for thecog=0 to 7:psram.setQos(thecog, 80 << 16) :next thecog
	mov	local01, #0
	sub	objptr, ##23256
LR__2660
	mov	arg01, local01
	mov	arg02, ##5242880
	call	#_psram4_spin2_setQos
	add	local01, #1
	cmps	local01, #8 wc
 if_b	jmp	#LR__2660
	add	objptr, ##23256
	rdlong	arg01, objptr
	mov	arg02, ##67171328
	sub	objptr, ##23256
	call	#_psram4_spin2_setQos
	sub	objptr, ##5836
' psram.setQoS(videocog, $0400f400) 
' open SendRecvDevice(@v.putchar, nil, nil) as #0
	mov	arg02, objptr
	or	arg02, ##181403648
	mov	arg03, #0
	mov	arg04, #0
	mov	arg01, #0
	call	#__system___basic_open
' return videocog
	add	objptr, ##29092
	rdlong	result1, objptr
	sub	objptr, ##29092
	mov	ptra, fp
	call	#popregs_
_startvideo_ret
	ret

' 
' 
' 
' '' ------------------------------- Convenient psram peek/poke
' 
' sub pslpoke(addr as ulong,value as ulong)
_pslpoke
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	mov	arg03, arg01
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, arg03
	mov	arg03, #4
	add	objptr, ##5836
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_pslpoke_ret
	ret

' 
' sub psdpoke(addr as ulong,value as ulong)
_psdpoke
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	mov	arg03, arg01
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, arg03
	mov	arg03, #2
	add	objptr, ##5836
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_psdpoke_ret
	ret

' 
' sub pspoke(addr as ulong,value as ulong)
_pspoke
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	mov	arg03, arg01
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, arg03
	mov	arg03, #1
	add	objptr, ##5836
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_pspoke_ret
	ret

' 
' function pspeek(adr as ulong) as ubyte
_pspeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	mov	arg02, arg01
	mov	arg01, fp
	add	arg01, #8
	mov	arg03, #1
	add	objptr, ##5836
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
' psram.read1(varptr(res),adr,1)
' return res
	add	fp, #8
	rdbyte	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_pspeek_ret
	ret

' 
' function pslpeek(adr as ulong) as ulong
_pslpeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	mov	arg02, arg01
	mov	arg01, fp
	add	arg01, #8
	mov	arg03, #4
	add	objptr, ##5836
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
' psram.read1(varptr(res),adr,4)
' return res
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_pslpeek_ret
	ret

' 
' function psdpeek(adr as ulong) as ulong
_psdpeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	mov	arg02, arg01
	mov	arg01, fp
	add	arg01, #8
	mov	arg03, #2
	add	objptr, ##5836
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
' psram.read1(varptr(res),adr,2)
' return res
	add	fp, #8
	rdword	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_psdpeek_ret
	ret

' 
' '' ------------------------------- USB keyboard scan to char translator
' 
' function scantochar(key)
_scantochar
' 
' select case (key shr 8) and 255
	mov	_var01, arg01
	sar	_var01, #8
	and	_var01, #255 wz
 if_e	jmp	#LR__2670
	cmp	_var01, #2 wz
 if_ne	cmp	_var01, #32 wz
 if_e	jmp	#LR__2671
	cmp	_var01, #64 wz
 if_e	jmp	#LR__2672
	cmp	_var01, #66 wz
 if_ne	cmp	_var01, #96 wz
 if_ne	jmp	#LR__2674
	jmp	#LR__2673
LR__2670
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__2671
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #1
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__2672
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #2
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__2673
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #3
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__2674
_scantochar_ret
	ret

_program
	mov	COUNT_, #3
	call	#pushregs_
	call	#_startpsram
	add	objptr, ##29112
	rdlong	arg01, objptr
	mov	arg02, #0
	mov	arg03, ##516096
	sub	objptr, ##23276
	call	#_Audio2_004_spin2_start
	mov	arg03, result2
	add	objptr, ##23252
	wrlong	result1, objptr
	add	objptr, #20
	wrlong	arg03, objptr
	sub	objptr, ##29108
	mov	arg01, #50
	call	#__system___waitms
	call	#_usbnew_spin2_start
	add	objptr, ##29096
	wrlong	result1, objptr
	sub	objptr, ##29096
	mov	arg01, #64
	mov	arg02, #0
	mov	arg03, #0
	call	#_startvideo
'   mouse_limits[0] := xlim
	add	ptr__usbnew_spin2_dat__, ##7880
	wrlong	##1023, ptr__usbnew_spin2_dat__
'   mouse_limits[1] := ylim
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	##599, ptr__usbnew_spin2_dat__
	mov	arg01, objptr
	add	arg01, #469
'   mouse_outptr := ptr
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	arg01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7888
	mov	arg02, ptr__dat__
	add	arg02, ##11466
	mov	arg01, #16
	call	#_Hg010b_4_spin2_setspriteptr
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_Hg010b_4_spin2_setspritesize
	decod	arg01, #9
	mov	arg02, #300
	call	#_usbnew_spin2_mouse_move
	mov	arg03, objptr
	add	objptr, ##42216
	mov	arg02, objptr
	wrlong	arg03, arg02
	add	arg02, #4
	wrlong	ptr__housekeeper_, arg02
	mov	arg02, entryptr__
	mov	result1, #30
	setq	objptr
	coginit	result1, arg02 wc
 if_b	neg	result1, #1
	sub	objptr, #4
	wrlong	result1, objptr
	add	objptr, ##908
	wrlong	#0, objptr
	sub	objptr, ##13976
	wrlong	#2, objptr
	add	objptr, #4
	wrlong	#147, objptr
	add	objptr, #4
	wrlong	#154, objptr
	add	objptr, #4
	wrlong	#4, objptr
	sub	objptr, #4
	rdlong	result1, objptr
	sub	objptr, #20
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	#0, objptr
	add	objptr, ##13068
	wrlong	#1, objptr
	add	objptr, ##920
	wrlong	#0, objptr
	mov	arg03, ptr__dat__
	add	arg03, ##512
	add	objptr, #8
	wrlong	arg03, objptr
	sub	objptr, #4
	wrlong	##1694, objptr
	sub	objptr, ##6772
	wrlong	#12, objptr
	sub	objptr, ##36360
	call	#_init_commands
	call	#_init_error_strings
	call	#_init_audio
	call	#_do_new
	add	objptr, ##29152
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##29148
	call	#_Hg010b_4_spin2_cls
	add	objptr, ##29156
	rdlong	arg01, objptr
	sub	objptr, ##29156
	call	#_Hg010b_4_spin2_setfontfamily
' 
' leading_spaces:=amount
	add	objptr, ##694
	wrlong	#2, objptr
	sub	objptr, ##694
	mov	local01, ##@LR__6162
	mov	arg01, #61
	mov	arg02, #60
	mov	arg03, #59
	mov	arg04, #58
	call	#__system___vfs_open_sdcardx
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___mount
	mov	arg01, ##@LR__6163
	call	#__system___chdir
	mov	local01, ##@LR__6164
	add	objptr, ##38968
	wrlong	local01, objptr
	sub	objptr, ##9824
	rdlong	arg01, objptr
	sub	objptr, ##29144
	shl	arg01, #1
	mov	arg02, #1
	call	#_Hg010b_4_spin2_setcursorpos
' init_commands
' init_error_strings
' init_audio
' do_new
' cls(ink, paper)
' v.setfontfamily(font) 				' use ST Mono font
' v.setleadingspaces(2)
' mount "/sd", _vfs_open_sdcard()
' chdir "/sd/bas"
' currentdir$="/sd/bas"
' position 2*editor_spaces,1 : print ver$
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	add	ptr__dat__, ##12608
	rdlong	arg02, ptr__dat__
	sub	ptr__dat__, ##12608
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##43124
	rdlong	arg01, objptr
	sub	objptr, ##7796
	rdlong	local01, objptr
	sub	objptr, ##35328
	sub	arg01, local01
	mov	arg02, #0
	mov	arg03, #10
	call	#__system__Number_S
	mov	arg01, result1
	mov	arg02, ##@LR__6165
	call	#__system___string_concat
	mov	local01, result1
	add	objptr, ##42204
	wrlong	local01, objptr
	sub	objptr, ##42204
' free$=decuns$(memtop-programptr)+" BASIC bytes free" : print free$
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	add	objptr, ##42204
	rdlong	arg02, objptr
	sub	objptr, ##42204
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	add	objptr, ##29144
	rdlong	arg01, objptr
	sub	objptr, ##29144
	shl	arg01, #1
	mov	arg02, #4
	call	#_Hg010b_4_spin2_setcursorpos
' position 2*editor_spaces,4 : print "Ready"
	mov	arg01, #0
	call	#__system___getiolock_0622
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__6166
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0622
	wrlong	#0, result1
	mov	arg02, #0
	test	arg02, #1 wc
	drvc	#38
	test	arg02, #1 wc
	drvc	#39
	mov	local01, ##@LR__6167
	add	objptr, ##43168
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	add	objptr, #12
	wrlong	#0, objptr
' pinwrite 38,0 : pinwrite 39,0 ' LEDs off
' loadname="noname.bas"
' do_insert=-1
' inload=0
' for i=0 to 1 : beepsample(i)=32767  : next i : for i=2 to 3: beepsample(i)=-32767 : next i
	mov	local02, #0
	sub	objptr, ##31768
	callpa	#(@LR__2681-@LR__2680)>>2,fcache_load_ptr_
LR__2680
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	wrword	##32767, local03
	add	local02, #1
	cmps	local02, #2 wc
 if_b	jmp	#LR__2680
LR__2681
	mov	local02, #2
	callpa	#(@LR__2683-@LR__2682)>>2,fcache_load_ptr_
LR__2682
	mov	local03, local02
	shl	local03, #1
	add	local03, objptr
	wrword	##32769, local03
	add	local02, #1
	cmp	local02, #4 wc
 if_b	jmp	#LR__2682
LR__2683
	sub	objptr, ##11416
' 
' open "/sd/bas/autorun.bas" for input as #9
	mov	arg02, ##@LR__6168
	mov	arg01, #9
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, #32
	add	objptr, ##43188
	wrlong	result1, objptr
	sub	objptr, ##43188
' err=geterr()
' close #9
	mov	arg01, #9
	call	#__system__close
' if err=0 then line$="run autorun.bas" : interpret
	add	objptr, ##43188
	rdlong	local01, objptr wz
	sub	objptr, ##43188
 if_e	mov	local01, ##@LR__6169
 if_e	add	objptr, ##29120
 if_e	wrlong	local01, objptr
 if_e	sub	objptr, ##29120
 if_e	call	#_interpret
' 
' 
' '-------------------------------------------------------------------------------------------------------- 
' '-------------------------------------- MAIN LOOP -------------------------------------------------------
' '--------------------------------------------------------------------------------------------------------
' 
' do
LR__2684
	call	#_edit
	mov	local01, result1
	add	objptr, ##29120
	wrlong	local01, objptr
	sub	objptr, ##29120
	call	#_interpret
	mov	local01, ##@LR__6170
	add	objptr, ##29120
	wrlong	local01, objptr
	sub	objptr, ##29120
	jmp	#LR__2684
	mov	ptra, fp
	call	#popregs_
_program_ret
	ret

' '' this is not a main program.
' 
' '****************************************************************************************************************
' '                                                                                                             	*
' 'Start the driver  at pins 'base'                            					rev 20230829 	*
' '                                                                                                            	*
' ' base - HDMI base pin												*
' ' mb - PSRAM mailbox pointer, 0 if no PSRAM									*
' '														*
' '														*
' '****************************************************************************************************************
' 
' pub start(base,mb):result |i
_Hg010b_4_spin2_start
' 
' '--------------------------- initialize pointers and variables
' 
' border_ptr:=@bordercolor					' Initial border color pointer, can be changed via DL
	add	objptr, #52
	mov	result1, objptr
	sub	objptr, #40
	wrlong	result1, objptr
' hdmibase:=base							' HDMI base pin, 8*n
	add	objptr, #24
	wrlong	arg01, objptr
' mailbox_ptr:=mb		
	add	objptr, #4
	wrlong	arg02, objptr
' mailbox0:=mb				' PSRAM mailbox pointer
	add	objptr, #449
	wrlong	arg02, objptr
' sprite_ptr:=@spr1ptr
	sub	objptr, #216
	mov	result1, objptr
	sub	objptr, #229
	wrlong	result1, objptr
' 		'
' word[spr1ptr+17*12+4]:=8				' spr18w
	add	objptr, #229
	rdlong	result1, objptr
	add	result1, #208
	wrword	#8, result1
' word[spr1ptr+17*12+6]:=16				' for a blinking cursor
	rdlong	arg03, objptr
	add	arg03, #210
	wrword	#16, arg03
' leading_spaces:=0				'
	add	objptr, #421
	wrlong	#0, objptr
' 
' emptydl[0]:=%0100_0000_0000_0000_0000_0000_0000_0111
	sub	objptr, #153
	wrlong	##1073741831, objptr
' emptydl[1]:=0
	add	objptr, #4
	wrlong	#0, objptr
' 
' '---------------------------- the mode has to be set here to enable computing the buffer length
' 
' s_debug:=debugger						' check if debug mode defined (eats 16 kB upper RAM so don't use it)					' 
	sub	objptr, #296
	wrlong	#1, objptr
' if s_debug<>0
'   s_debug:=16384						' the buffers adresses will be corrected to not interfere with the debugger
	wrlong	##16384, objptr
	sub	objptr, #249
' setmode()							' set the mode, see below
	call	#_Hg010b_4_spin2_setmode
' vblank_ptr:=@vblank						' set pointers before starting the driver
	add	objptr, #73
	mov	result1, objptr
	sub	objptr, #53
	wrlong	result1, objptr
' cursor_ptr:=@cursor_x						
	add	objptr, #40
	mov	arg03, objptr
	sub	objptr, #44
	wrlong	arg03, objptr
' fontnum:=0  							' start with a PC type font 
	add	objptr, #85
	wrlong	#0, objptr
' bytemove(@colors,@vgacolors,16)					' prepare standard DOS VGA colors
	add	objptr, #28
	mov	arg01, objptr
	sub	objptr, #129
	mov	arg02, ptr__Hg010b_4_spin2_dat__
	add	arg02, ##14464
	mov	arg03, #16
	call	#__system____builtin_memmove
' leading_spaces:=0
	add	objptr, ##694
	wrlong	#0, objptr
	sub	objptr, ##694
' '---------------------------- initialize a cursor (MSDOS type)
' 
' initcursor(154)
	mov	arg01, #154
	call	#_Hg010b_4_spin2_initcursor
' 
' '---------------------------- start the cog
' 
' cog:=coginit(16,@hdmi, @vblank_ptr)				' start the driver cog			
	mov	arg02, ptr__Hg010b_4_spin2_dat__
	add	arg02, ##14480
	mov	arg03, objptr
	add	arg03, #20
	mov	result1, #16
	setq	arg03
	coginit	result1, arg02 wc
 if_b	neg	result1, #1
	add	objptr, #48
	wrlong	result1, objptr
	sub	objptr, #48
' waitms(40)							' wait for stabilize
	mov	arg01, #40
	call	#__system___waitms
' return cog							' return the driver's cog #
	add	objptr, #48
	rdlong	result1, objptr
	sub	objptr, #48
_Hg010b_4_spin2_start_ret
	ret

' 
' 
' '**************************************************************************************************************** 
' '                                                                                                             	*
' '  Simple standard mode setting                                                             	rev. 20220319 	*
' '  Mode number - see start() above or bits below								*
' '                                                                                                             	*
' '****************************************************************************************************************
' 
' 
' pub restorepalette()
_Hg010b_4_spin2_restorepalette
' 
' longmove(@ataripalette,@ataripalette2,256)
	add	ptr__Hg010b_4_spin2_dat__, ##12352
	mov	arg01, ptr__Hg010b_4_spin2_dat__
	add	ptr__Hg010b_4_spin2_dat__, ##1024
	mov	arg02, ptr__Hg010b_4_spin2_dat__
	sub	ptr__Hg010b_4_spin2_dat__, ##13376
	mov	arg03, #256
	call	#__system__longmove
_Hg010b_4_spin2_restorepalette_ret
	ret

' 
' '---------------------------- initialize a cursor (MSDOS type)
' pub initcursor(color) |i
_Hg010b_4_spin2_initcursor
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' cursor_x:=0							' place the cursor at 0:0
	add	objptr, #60
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' repeat i from 0 to 111
	mov	local02, #0
	add	objptr, #504
	callpa	#(@LR__2691-@LR__2690)>>2,fcache_load_ptr_
LR__2690
'   cursor[i]:=0
	mov	local03, local02
	add	local03, objptr
	wrbyte	#0, local03
	add	local02, #1
	cmps	local02, #112 wc
 if_b	jmp	#LR__2690
LR__2691
' repeat i from 112 to 127
	mov	local02, #112
	callpa	#(@LR__2693-@LR__2692)>>2,fcache_load_ptr_
LR__2692
'   cursor[i]:=color  
	mov	local03, local02
	add	local03, objptr
	wrbyte	local01, local03
	add	local02, #1
	cmp	local02, #128 wc
 if_b	jmp	#LR__2692
LR__2693
	sub	objptr, ##566
' 'repeat i from 0 to 127
' '  if ((i/8)//2)
' '    cursor[i]:=15
' '  else
' '    cursor[i]:=0
' '  if i>=120    
' '    cursor[i]:=40
' setspriteptr(17,@cursor)
	mov	arg02, objptr
	add	arg02, ##566
	mov	arg01, #17
	call	#_Hg010b_4_spin2_setspriteptr
' setspritesize(17,8,16)
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_Hg010b_4_spin2_setspritesize
' setspritepos(17,0,0)
	mov	arg01, #17
	mov	arg02, #0
	mov	arg03, #0
	call	#_Hg010b_4_spin2_setspritepos
' cursorshape:=14
	add	objptr, ##5830
	wrlong	#14, objptr
' cursorcolor:=color
	sub	objptr, #4
	wrlong	local01, objptr
	sub	objptr, ##5826
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_initcursor_ret
	ret

' 
' pub setcursorshape(shape) | i
_Hg010b_4_spin2_setcursorshape
' 
' cursorshape:=shape
	add	objptr, ##5830
	wrlong	arg01, objptr
' repeat i from 0 to (8*cursorshape)-1
	mov	_var01, #0
	mov	_var02, arg01
	shl	_var02, #3
	sub	_var02, #1
	cmps	_var02, #0 wc
	negc	_var03, #1
	mov	_var04, _var03
	add	_var02, _var03
	sub	objptr, ##5264
	callpa	#(@LR__2701-@LR__2700)>>2,fcache_load_ptr_
LR__2700
'   cursor[i]:=0
	mov	_var03, _var01
	add	_var03, objptr
	wrbyte	#0, _var03
	add	_var01, _var04
	cmp	_var01, _var02 wz
 if_ne	jmp	#LR__2700
LR__2701
' repeat i from 8*cursorshape to 127
	add	objptr, ##5264
	rdlong	_var04, objptr
	mov	_var01, _var04
	shl	_var01, #3
	sub	objptr, ##5830
	shl	_var04, #3
	cmps	_var04, #128 wc
	negnc	_var03, #1
	mov	_var02, #127
	add	_var02, _var03
	callpa	#(@LR__2703-@LR__2702)>>2,fcache_load_ptr_
LR__2702
'   cursor[i]:=cursorcolor
	mov	_var04, _var01
	add	objptr, ##566
	add	_var04, objptr
	add	objptr, ##5260
	rdlong	arg01, objptr
	sub	objptr, ##5826
	wrbyte	arg01, _var04
	add	_var01, _var03
	cmp	_var01, _var02 wz
 if_ne	jmp	#LR__2702
LR__2703
_Hg010b_4_spin2_setcursorshape_ret
	ret

' 
' pub setcursorcolor(color) | i
_Hg010b_4_spin2_setcursorcolor
' 
' cursorcolor:=color
	add	objptr, ##5826
	wrlong	arg01, objptr
' repeat i from 0 to (8*cursorshape)-1
	mov	arg01, #0
	add	objptr, #4
	rdlong	_var01, objptr
	shl	_var01, #3
	sub	_var01, #1
	cmps	_var01, #0 wc
	negc	_var02, #1
	mov	_var03, _var02
	add	_var01, _var02
	sub	objptr, ##5264
	callpa	#(@LR__2711-@LR__2710)>>2,fcache_load_ptr_
LR__2710
'   cursor[i]:=0
	mov	_var02, arg01
	add	_var02, objptr
	wrbyte	#0, _var02
	add	arg01, _var03
	cmp	arg01, _var01 wz
 if_ne	jmp	#LR__2710
LR__2711
' repeat i from 8*cursorshape to 127
	add	objptr, ##5264
	rdlong	_var03, objptr
	mov	arg01, _var03
	shl	arg01, #3
	sub	objptr, ##5830
	shl	_var03, #3
	cmps	_var03, #128 wc
	negnc	_var02, #1
	mov	_var01, #127
	add	_var01, _var02
	callpa	#(@LR__2713-@LR__2712)>>2,fcache_load_ptr_
LR__2712
'   cursor[i]:=cursorcolor
	mov	_var03, arg01
	add	objptr, ##566
	add	_var03, objptr
	add	objptr, ##5260
	rdlong	_var04, objptr
	sub	objptr, ##5826
	wrbyte	_var04, _var03
	add	arg01, _var02
	cmp	arg01, _var01 wz
 if_ne	jmp	#LR__2712
LR__2713
_Hg010b_4_spin2_setcursorcolor_ret
	ret

'   
'   
'   
' pub setmode() | i', 'xzoom, yzoom, azoom
_Hg010b_4_spin2_setmode
	mov	COUNT_, #2
	call	#pushregs_
' 
' 
' dl_ptr:=@emptydl[0]
	add	objptr, ##541
	mov	arg05, objptr
	sub	objptr, #509
	wrlong	arg05, objptr
' 
' if cog>0 
	add	objptr, #16
	rdlong	arg05, objptr
	sub	objptr, #48
	cmps	arg05, #1 wc
'    waitvbl(1)						    	' if the driver is active, wait for vblank to set the new mode and DL	
 if_ae	mov	arg01, #1
 if_ae	call	#_Hg010b_4_spin2_waitvbl
' xres:=1024
	add	objptr, ##550
	wrlong	##1024, objptr
' yres:=600
	add	objptr, #4
	wrlong	##600, objptr
' ppl:=(timings[3])
	add	ptr__Hg010b_4_spin2_dat__, ##14412
	rdlong	arg05, ptr__Hg010b_4_spin2_dat__
	sub	objptr, #337
	wrlong	arg05, objptr
' cpl:=timings[7]<<1                                      	' now cpl is longs per line
	add	ptr__Hg010b_4_spin2_dat__, #16
	rdlong	local01, ptr__Hg010b_4_spin2_dat__
	shl	local01, #1
	sub	objptr, #128
	wrlong	local01, objptr
' cpl1:=cpl '' todo remove
	add	objptr, #4
	wrlong	local01, objptr
' palette_ptr:=@ataripalette				    	' use 256-colors palettr
	sub	ptr__Hg010b_4_spin2_dat__, ##2076
	sub	objptr, #65
	wrlong	ptr__Hg010b_4_spin2_dat__, objptr
' repeat i from 0 to 3
	mov	local02, #0
	add	ptr__Hg010b_4_spin2_dat__, ##2048
	add	objptr, #8
	callpa	#(@LR__2721-@LR__2720)>>2,fcache_load_ptr_
LR__2720
'   timings[i]:=timings[i]+hdmibase<<17+ timingsxxt          	' add a streamer config (imm->pins) to horizontal timings 
	mov	local01, local02
	shl	local01, #2
	add	local01, ptr__Hg010b_4_spin2_dat__
	rdlong	arg05, objptr
	shl	arg05, #17
	rdlong	local01, local01
	add	local01, arg05
	add	local01, ##1887502336
	mov	arg05, local02
	shl	arg05, #2
	add	arg05, ptr__Hg010b_4_spin2_dat__
	wrlong	local01, arg05
	add	local02, #1
	cmps	local02, #4 wc
 if_b	jmp	#LR__2720
LR__2721
	sub	objptr, #36
	sub	ptr__Hg010b_4_spin2_dat__, ##14400
' 'clkfreq:=timings[9]					    	' set the clock frequency for the mode
' 'hubset(timings[10])
' waitms(1)                                                   	' wait for stabilization
	mov	arg01, #1
	call	#__system___waitms
	add	ptr__Hg010b_4_spin2_dat__, ##14444
	rdlong	local02, ptr__Hg010b_4_spin2_dat__
	add	objptr, #97
	wrlong	local02, objptr
	abs	local01, local02 wc
	shr	local01, #4
	negc	local01, local01
	add	objptr, #156
	wrlong	local01, objptr
	sub	objptr, #164
	rdlong	local02, objptr
	add	objptr, #8
	rdlong	local01, objptr
	qmul	local02, local01
' lines:=timings[11]
' t_lines:=lines/16
' buflen:=cpl*lines						' framebuffer length in longs
	sub	objptr, #41
	decod	local01, #23
	sub	ptr__Hg010b_4_spin2_dat__, #16
	getqx	local02
	wrlong	local02, objptr
	sub	objptr, #56
	shl	local02, #2
	sub	local01, local02
	wrlong	local01, objptr
	add	objptr, #253
	rdlong	local02, objptr
	rdlong	arg05, ptr__Hg010b_4_spin2_dat__
	qmul	local02, arg05
' buf_ptr:=$800000-4*buflen                          	     	' todo: get a PSRAM real himem 
' textbuf_ptr:=buf_ptr-t_lines*timings[7]
	sub	objptr, #249
' mode_ptr:=@timings						' set pointers to timings
	sub	ptr__Hg010b_4_spin2_dat__, #28
' graphmode:=1024+512+192+48							' det global variable
' makedl(graphmode)							' make a DL for the mode
	mov	arg01, ##1776
	getqx	local02
	sub	local01, local02
	wrlong	local01, objptr
	add	objptr, #20
	wrlong	ptr__Hg010b_4_spin2_dat__, objptr
	add	objptr, #121
	wrlong	##1776, objptr
	sub	objptr, #145
	sub	ptr__Hg010b_4_spin2_dat__, ##14400
	call	#_Hg010b_4_spin2_makedl
' s_buf_ptr:=buf_ptr						' secondary copies of main framebuffer parameters 
	rdlong	local01, objptr
	add	objptr, #221
	wrlong	local01, objptr
' s_font_ptr:=font_ptr
	sub	objptr, #213
	rdlong	local01, objptr
	add	objptr, #217
	wrlong	local01, objptr
' s_lines:=lines
	sub	objptr, #128
	rdlong	local01, objptr
	add	objptr, #132
	wrlong	local01, objptr
' s_buflen:=buflen
	sub	objptr, #173
	rdlong	local01, objptr
	add	objptr, #181
	wrlong	local01, objptr
' s_cpl:=cpl
	sub	objptr, #148
	rdlong	local01, objptr
	add	objptr, #144
	wrlong	local01, objptr
' s_cpl1:=cpl
	sub	objptr, #144
	rdlong	local01, objptr
	add	objptr, #152
	wrlong	local01, objptr
' st_lines:=t_lines
	add	objptr, #12
	rdlong	local01, objptr
	add	objptr, #4
	wrlong	local01, objptr
' ppl:=ppl/xzoom  
	sub	objptr, #40
	rdlong	muldiva_, objptr
	add	objptr, #44
	rdlong	muldivb_, objptr
	sub	objptr, #261
	call	#divide_
	add	objptr, #217
	wrlong	muldivb_, objptr
' s_ppl:=ppl
	add	objptr, #28
	wrlong	muldivb_, objptr
	sub	objptr, #245
' waitms(20)							' wait 
	mov	arg01, #20
	call	#__system___waitms
' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	arg03, arg01
	mov	arg02, #32
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5836
	call	#_psram4_spin2_fill
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_setmode_ret
	ret

' 
' '****************************************************************************************************************
' '                                                                                                             	*
' '  Make a display list for simple standard modes                                             	rev.20220319    *
' '                                                                                                             	*
' '****************************************************************************************************************
' 
' pub makedl(mode) |i,vzoom,border,psbuf,lines2
_Hg010b_4_spin2_makedl
' 
' psbuf:=$80000-s_debug-1024                                                     ' HUB line buffer on the top of HUB RAM (-16 kB if debug enabled)
' vzoom:=1<<((mode>>2) & 3)                                                      ' real vzoom from mode#
' repeat i from 0 to 11                                                           ' clear DL
	mov	_var01, #0
	add	objptr, #493
	callpa	#(@LR__2731-@LR__2730)>>2,fcache_load_ptr_
LR__2730
'   displaylist[i]:=0 
	mov	_var02, _var01
	shl	_var02, #2
	add	_var02, objptr
	wrlong	#0, _var02
	add	_var01, #1
	cmps	_var01, #12 wc
 if_b	jmp	#LR__2730
LR__2731
'                         ' 
' displaylist[0]:=lines<<20+(0)<<16+%0001+ (0+(cpl1<<2)) <<4             
	sub	objptr, #396
	rdlong	_var02, objptr
	shl	_var02, #20
	add	_var02, #1
	sub	objptr, #4
	rdlong	_var01, objptr
	shl	_var01, #6
	add	_var02, _var01
	add	objptr, #400
	wrlong	_var02, objptr
	sub	objptr, #493
' displaylist[1]:=buf_ptr<<4+%10  
	rdlong	_var02, objptr
	shl	_var02, #4
	add	_var02, #2
	add	objptr, #497
	wrlong	_var02, objptr
' dl_ptr:=@displaylist[0] 						      ' tell the driver where to find the DL
	sub	objptr, #4
	mov	_var02, objptr
	sub	objptr, #461
	wrlong	_var02, objptr
	sub	objptr, #32
_Hg010b_4_spin2_makedl_ret
	ret

' 
' 
' '****************************************************************************************************************
' '                                                                        					*
' '  Graphic primitives                                                    					*
' '                                                                        					*
' '****************************************************************************************************************
' 
' pub setspriteptr(num,ptr)
_Hg010b_4_spin2_setspriteptr
' long[@spr1ptr+12*num]:=ptr
	mov	_var01, objptr
	add	_var01, #273
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	wrlong	arg02, _var01
_Hg010b_4_spin2_setspriteptr_ret
	ret

' 
' pub setspritepos(num,x,y)
_Hg010b_4_spin2_setspritepos
' if y>601
	cmps	arg03, ##602 wc
'   y:=601
 if_ae	mov	arg03, ##601
' if x>1024
	cmps	arg02, ##1025 wc
'   x:=1024
 if_ae	decod	arg02, #10
' word[@spr1ptr+12*num+4]:=x
	add	objptr, #273
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #4
	wrword	arg02, _var01
' word[@spr1ptr+12*num+6]:=y
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #6
	wrword	arg03, _var01
	sub	objptr, #273
_Hg010b_4_spin2_setspritepos_ret
	ret

' 
' pub setspritesize(num,w,h)
_Hg010b_4_spin2_setspritesize
' word[@spr1ptr+12*num+8]:=w
	add	objptr, #273
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #8
	wrword	arg02, _var01
' word[@spr1ptr+12*num+10]:=h
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #10
	wrword	arg03, _var01
	sub	objptr, #273
_Hg010b_4_spin2_setspritesize_ret
	ret

' 
' 
' ''---------- putpixel - put a pixel on the screen - a mother of all graphic functions ---------------------------
' 
' 
' pub putpixel(x,y,c)
_Hg010b_4_spin2_putpixel
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' if ((x>=0) & (x<4*s_cpl) & (y>=0) & (y<s_lines))
	mov	local02, #0
	cmps	local01, #0 wc
 if_ae	neg	local02, #1
	add	objptr, #233
	rdlong	arg05, objptr
	shl	arg05, #2
	cmps	local01, arg05 wc
	subx	local03, local03
	and	local02, local03
	mov	local03, #0
	cmps	arg02, #0 wc
 if_ae	neg	local03, #1
	and	local02, local03
	sub	objptr, #4
	rdlong	local03, objptr
	sub	objptr, #229
	cmps	arg02, local03 wc
	subx	local04, local04
	test	local02, local04 wz
 if_e	jmp	#LR__2740
	add	objptr, #221
	rdlong	arg01, objptr
	add	objptr, #20
	rdlong	local04, objptr
	shl	local04, #2
	qmul	local04, arg02
'   ram.fill(s_buf_ptr+(4*s_cpl1*y+x),c,1,0,1)
	mov	arg02, arg03
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5595
	getqx	local04
	add	local04, local01
	add	arg01, local04
	call	#_psram4_spin2_fill
	sub	objptr, ##5836
LR__2740
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_putpixel_ret
	ret

' 
' pub putpixel2(x,y,c)
_Hg010b_4_spin2_putpixel2
	mov	COUNT_, #2
	call	#pushregs_
	add	objptr, #221
	rdlong	local01, objptr
	add	objptr, #20
	rdlong	arg05, objptr
	shl	arg05, #2
	qmul	arg05, arg02
' ram.fill(s_buf_ptr+(4*s_cpl1*y+x),c,1,0,1)
	mov	arg02, arg03
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5595
	getqx	local02
	add	local02, arg01
	add	local01, local02
	mov	arg01, local01
	call	#_psram4_spin2_fill
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_putpixel2_ret
	ret

' 
' pub getpixel2(x,y): c 
_Hg010b_4_spin2_getpixel2
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	wrlong	#0, fp
	mov	arg01, fp
	add	objptr, #221
	rdlong	arg02, objptr
	add	objptr, #20
	rdlong	arg03, objptr
	shl	arg03, #2
	add	fp, #8
	rdlong	result1, fp
	qmul	arg03, result1
' 
' ram.read1(@c,s_buf_ptr+(4*s_cpl1*y+x),1)
	sub	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	mov	arg03, #1
	add	objptr, ##5595
	getqx	local02
	add	local02, local01
	add	arg02, local02
	call	#_psram4_spin2_read1
	sub	objptr, ##5836
' return c
	rdlong	result1, fp
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_getpixel2_ret
	ret

'   
' '----------- A line drawing family. BASIC doesn't like the name, so it is named "draw" and aliased  -----------------------------
' 
' pub fastline(x1,x2,y,c)									' a fast 8bpp horizontal line
_Hg010b_4_spin2_fastline
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' if y<0 || y>=yres || (x1<0 && x2<0) || (x1>xres && x2>xres)
	cmps	arg03, #0 wc
 if_b	jmp	#LR__2750
	add	objptr, ##554
	rdlong	arg05, objptr
	sub	objptr, ##554
	cmps	arg03, arg05 wc
 if_ae	jmp	#LR__2750
	cmps	local01, #0 wc
 if_b	cmps	local02, #0 wc
 if_b	jmp	#LR__2750
	add	objptr, ##550
	rdlong	arg05, objptr
	sub	objptr, ##550
	cmps	local01, arg05 wcz
 if_a	add	objptr, ##550
 if_a	rdlong	arg01, objptr
 if_a	sub	objptr, ##550
 if_a	cmps	local02, arg01 wcz
'   return
 if_a	jmp	#LR__2750
	cmps	local01, local02 wcz
 if_a	mov	arg05, local01
 if_a	mov	local01, local02
 if_a	mov	local02, arg05
	cmps	local01, #0 wc
 if_b	mov	local01, #0
	add	objptr, ##550
	rdlong	arg05, objptr
	sub	objptr, ##550
	cmps	local02, arg05 wc
 if_ae	add	objptr, ##550
 if_ae	rdlong	local02, objptr
 if_ae	sub	objptr, ##550
	add	objptr, #221
	rdlong	arg01, objptr
	add	objptr, #20
	rdlong	arg05, objptr
	shl	arg05, #2
	qmul	arg05, arg03
' if x1>x2
'   x1,x2:=x2,x1
' if x1<0 
'   x1:=0
' if x2>=xres
'   x2:=xres-1  
 if_ae	sub	local02, #1
' ram.fill(s_buf_ptr+(4*s_cpl1*y+x1),c,1+x2-x1,0,1)
	mov	arg03, #1
	add	arg03, local02
	sub	arg03, local01
	mov	arg02, arg04
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5595
	getqx	local02
	add	local02, local01
	add	arg01, local02
	call	#_psram4_spin2_fill
	sub	objptr, ##5836
LR__2750
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_fastline_ret
	ret

' 
' pub draw(x1,y1,x2,y2,c) | d,dx,dy,ai,bi,xi,yi,x,y					' I had to rename the function for BASIC	
_Hg010b_4_spin2_draw
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' if (y1==y2)
	cmp	local02, local04 wz
 if_ne	jmp	#LR__2760
'   fastline(x1,x2,y1,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local02
	mov	arg04, local05
	call	#_Hg010b_4_spin2_fastline
	jmp	#LR__2766
LR__2760
' else  
'   x:=x1
	mov	local06, local01
'   y:=y1
	mov	local07, local02
' 
'   if (x1<x2) 
	cmps	local01, local03 wc
'     xi:=1
 if_b	mov	local08, #1
'     dx:=x2-x1
 if_b	mov	local09, local03
 if_b	sub	local09, local01
'   else
'     xi:=-1
 if_ae	neg	local08, #1
'     dx:=x1-x2
 if_ae	sub	local01, local03
 if_ae	mov	local09, local01
'   
'   if (y1<y2) 
	cmps	local02, local04 wc
'     yi:=1
 if_b	mov	local10, #1
'     dy:=y2-y1
 if_b	mov	local11, local04
 if_b	sub	local11, local02
'   else
'     yi:=-1
 if_ae	neg	local10, #1
'     dy:=y1-y2
 if_ae	sub	local02, local04
 if_ae	mov	local11, local02
' 
'   putpixel(x,y,c)
	mov	arg03, local05
	mov	arg01, local06
	mov	arg02, local07
	call	#_Hg010b_4_spin2_putpixel
' 
'   if (dx>dy)
	cmps	local09, local11 wcz
 if_be	jmp	#LR__2762
'     ai:=(dy-dx)*2
	mov	local12, local11
	sub	local12, local09
	shl	local12, #1
'     bi:=dy*2
	shl	local11, #1
	mov	local13, local11
'     d:= bi-dx
	mov	local14, local13
	sub	local14, local09
'     repeat while (x<>x2) 
LR__2761
	cmp	local06, local03 wz
 if_e	jmp	#LR__2765
'       if (d>=0) 
	cmps	local14, #0 wc
'         x+=xi
 if_ae	add	local06, local08
'         y+=yi
 if_ae	add	local07, local10
'         d+=ai
 if_ae	add	local14, local12
'       else
'         d+=bi
 if_b	add	local14, local13
'         x+=xi
 if_b	add	local06, local08
'       putpixel(x,y,c)
	mov	arg01, local06
	mov	arg02, local07
	mov	arg03, local05
	call	#_Hg010b_4_spin2_putpixel
	jmp	#LR__2761
LR__2762
'   else
'     ai:=(dx-dy)*2
	mov	local12, local09
	sub	local12, local11
	shl	local12, #1
'     bi:=dx*2
	shl	local09, #1
	mov	local13, local09
'     d:=bi-dy
	mov	local14, local13
	sub	local14, local11
'     repeat while (y<>y2)
LR__2763
	cmp	local07, local04 wz
 if_e	jmp	#LR__2764
'       if (d>=0)
	cmps	local14, #0 wc
'         x+=xi
 if_ae	add	local06, local08
'         y+=yi
 if_ae	add	local07, local10
'         d+=ai
 if_ae	add	local14, local12
'       else
'         d+=bi
 if_b	add	local14, local13
'         y+=yi
 if_b	add	local07, local10
'       putpixel(x, y,c)
	mov	arg01, local06
	mov	arg02, local07
	mov	arg03, local05
	call	#_Hg010b_4_spin2_putpixel
	jmp	#LR__2763
LR__2764
LR__2765
LR__2766
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_draw_ret
	ret

'       
'       
'       
'       
'       
'       
'  
' pub fillpush(val) 
_Hg010b_4_spin2_fillpush
' fillstack[fillptr]:=val
	add	objptr, ##5818
	rdlong	_var01, objptr
	shl	_var01, #2
	sub	objptr, ##5120
	add	_var01, objptr
	wrlong	arg01, _var01
' fillptr+=1   
	add	objptr, ##5120
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##5818
_Hg010b_4_spin2_fillpush_ret
	ret

' 
'     
' pub fillpop() : val
_Hg010b_4_spin2_fillpop
' 
' fillptr-=1
	add	objptr, ##5818
	rdlong	result1, objptr
	sub	result1, #1
	wrlong	result1, objptr
' if fillptr<0
	sub	objptr, ##5818
	cmps	result1, #0 wc
'   fillptr:=0
 if_b	add	objptr, ##5818
 if_b	wrlong	#0, objptr
 if_b	sub	objptr, ##5818
'   val:=-12345
 if_b	mov	_var01, ##-12345
 if_b	jmp	#LR__2770
' else 
'   val:=fillstack[fillptr]
	add	objptr, ##5818
	rdlong	_var01, objptr
	shl	_var01, #2
	sub	objptr, ##5120
	add	_var01, objptr
	rdlong	_var01, _var01
	sub	objptr, ##698
LR__2770
' return val
	mov	result1, _var01
_Hg010b_4_spin2_fillpop_ret
	ret

' 
'       
' pub fill(x,y,newcolor,oldcolor) | x1, spanabove, spanbelow, ov
_Hg010b_4_spin2_fill
	mov	COUNT_, #11
	call	#pushregs_
' 
' newcolor:=newcolor & 255
	getbyte	local01, arg03, #0
' oldcolor:=oldcolor & 255
	getbyte	local02, arg04, #0
' 
' if (oldcolor == newcolor) 
	cmp	local02, local01 wz
'   return
 if_e	jmp	#LR__2789
' 
' fillptr:=0
	add	objptr, ##5818
	wrlong	#0, objptr
' fillmax:=0
	add	objptr, #4
	wrlong	#0, objptr
	sub	objptr, ##5822
' fillpush(x)
	call	#_Hg010b_4_spin2_fillpush
' fillpush(y)
	mov	arg01, arg02
	call	#_Hg010b_4_spin2_fillpush
' y:=fillpop()
	call	#_Hg010b_4_spin2_fillpop
	mov	local03, result1
' x:=fillpop()
	call	#_Hg010b_4_spin2_fillpop
	mov	local04, result1
' 'pinhigh(38)
' repeat while (x>-1)       
LR__2780
	cmps	local04, #0 wc
 if_b	jmp	#LR__2788
'  ' pintoggle(39)
'   x1 := x
	mov	local05, local04
'   repeat while((x1 >= 0) && (getpixel2(x1,y) == oldColor))
LR__2781
	mov	local06, #0
	mov	local07, #0
	cmps	local05, #0 wc
 if_ae	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	mov	arg01, local05
	call	#_Hg010b_4_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
'     x1--
 if_ne	sub	local05, #1
 if_ne	jmp	#LR__2781
'   x1++
	add	local05, #1
'   spanabove := 0
	mov	local10, #0
'   spanbelow := 0
	mov	local11, #0
'   repeat while ((x1 < 1024) && getpixel2(x1,y) == oldColor)
LR__2782
	mov	local06, #0
	cmps	local05, ##1024 wc
 if_b	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	mov	arg01, local05
	call	#_Hg010b_4_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
 if_e	jmp	#LR__2787
'     putpixel2 (x1,y, newcolor & 255)
	getbyte	arg03, local01, #0
	mov	arg01, local05
	mov	arg02, local03
	call	#_Hg010b_4_spin2_putpixel2
'     if ((spanabove == 0) && (y > 0) && (getpixel2(x1,y-1)== oldColor))
	mov	local06, #0
	mov	local07, #0
	cmp	local10, #0 wz
 if_e	cmps	local03, #1 wc
 if_nc_and_z	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	sub	arg02, #1
	mov	arg01, local05
	call	#_Hg010b_4_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
 if_e	jmp	#LR__2783
'       fillpush(x1)
	mov	arg01, local05
	call	#_Hg010b_4_spin2_fillpush
'       fillpush(y-1)
	mov	arg01, local03
	sub	arg01, #1
	call	#_Hg010b_4_spin2_fillpush
'       spanabove := 1 
	mov	local10, #1
	jmp	#LR__2784
LR__2783
'     elseif ((spanabove<>0) && (y > 0) && (getpixel2(x1,y-1)<> oldColor))
	mov	local06, #0
	mov	local07, #0
	cmp	local10, #0 wz
 if_ne	cmps	local03, #1 wc
 if_a	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	sub	arg02, #1
	mov	arg01, local05
	call	#_Hg010b_4_spin2_getpixel2
	cmp	result1, local02 wz
 if_ne	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
'       spanabove := 0 
 if_ne	mov	local10, #0
LR__2784
'     if((spanbelow == 0 ) && (y < 575) && getpixel2(x1,y+1) == oldColor)
	mov	local06, #0
	mov	local07, #0
	cmp	local11, #0 wz
 if_e	cmps	local03, ##575 wc
 if_c_and_z	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	add	arg02, #1
	mov	arg01, local05
	call	#_Hg010b_4_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
 if_e	jmp	#LR__2785
'       fillpush(x1)
	mov	arg01, local05
	call	#_Hg010b_4_spin2_fillpush
'       fillpush(y + 1)
	mov	arg01, local03
	add	arg01, #1
	call	#_Hg010b_4_spin2_fillpush
'       spanBelow := 1
	mov	local11, #1
	jmp	#LR__2786
LR__2785
'     elseif((spanbelow<>0) && (y < 575) && (getpixel2(x1,y + 1)<> oldColor))
	mov	local06, #0
	mov	local07, #0
	cmp	local11, #0 wz
 if_ne	cmps	local03, ##575 wc
 if_c_and_nz	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	add	arg02, #1
	mov	arg01, local05
	call	#_Hg010b_4_spin2_getpixel2
	cmp	result1, local02 wz
 if_ne	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
'       spanbelow := 0
 if_ne	mov	local11, #0
LR__2786
'     x1++
	add	local05, #1
	jmp	#LR__2782
LR__2787
'   y:=fillpop()
	call	#_Hg010b_4_spin2_fillpop
	mov	local03, result1
'   x:=fillpop()
	call	#_Hg010b_4_spin2_fillpop
	mov	local04, result1
	jmp	#LR__2780
LR__2788
LR__2789
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_fill_ret
	ret

' 'pinlow(38)    
' 
' '-- A filled circle -----------------------------------------------------
' 
' pub fcircle(x0,y0,r,c) | d,x,y,da,db
_Hg010b_4_spin2_fcircle
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg03
	qmul	local01, ##-2
	mov	local02, arg01
	mov	local03, arg02
	mov	local04, arg04
' 
' d:=5-4*r
	mov	arg04, local01
	shl	arg04, #2
	mov	local05, #5
	sub	local05, arg04
' x:=0
	mov	local06, #0
' y:=r
' da:=(-2*r+5)*4
' db:=3*4
	mov	local07, #12
' repeat while (x<=y) 
	getqx	local08
	add	local08, #5
	shl	local08, #2
LR__2790
	cmps	local06, local01 wcz
 if_a	jmp	#LR__2792
'   fastline(x0-x,x0+x,y0-y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local02
	add	arg02, local06
	mov	arg03, local03
	sub	arg03, local01
	mov	arg04, local04
	call	#_Hg010b_4_spin2_fastline
'   fastline(x0-x,x0+x,y0+y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local02
	add	arg02, local06
	mov	arg03, local03
	add	arg03, local01
	mov	arg04, local04
	call	#_Hg010b_4_spin2_fastline
'   fastline(x0-y,x0+y,y0-x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local02
	add	arg02, local01
	mov	arg03, local03
	sub	arg03, local06
	mov	arg04, local04
	call	#_Hg010b_4_spin2_fastline
'   fastline(x0-y,x0+y,y0+x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local02
	add	arg02, local01
	mov	arg03, local03
	add	arg03, local06
	mov	arg04, local04
	call	#_Hg010b_4_spin2_fastline
'   if d>0 
	cmps	local05, #1 wc
 if_b	jmp	#LR__2791
'     d+=da
	add	local05, local08
'     y-=1
	sub	local01, #1
'     x+=1
	add	local06, #1
'     da+=4*4
	add	local08, #16
'     db+=2*4
	add	local07, #8
	jmp	#LR__2790
LR__2791
'   else
'     d+=db
	add	local05, local07
'     x+=1
	add	local06, #1
'     da+=2*4
	add	local08, #8
'     db+=2*4
	add	local07, #8
	jmp	#LR__2790
LR__2792
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_fcircle_ret
	ret

'  
' '-- A circle ------------------------------------------------------------ 
'  
' pub circle(x0,y0,r,c) | d,x,y,da,db
_Hg010b_4_spin2_circle
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg03
	qmul	local01, ##-2
	mov	local02, arg01
	mov	local03, arg02
	mov	local04, arg04
' 
'  
' d:=5-4*r
	mov	arg04, local01
	shl	arg04, #2
	mov	local05, #5
	sub	local05, arg04
' x:=0
	mov	local06, #0
' y:=r
' da:=(-2*r+5)*4
' db:=3*4
	mov	local07, #12
' repeat while (x<=y) 
	getqx	local08
	add	local08, #5
	shl	local08, #2
LR__2800
	cmps	local06, local01 wcz
 if_a	jmp	#LR__2802
'   putpixel(x0-x,y0-y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local03
	sub	arg02, local01
	mov	arg03, local04
	call	#_Hg010b_4_spin2_putpixel
'   putpixel(x0-x,y0+y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local03
	add	arg02, local01
	mov	arg03, local04
	call	#_Hg010b_4_spin2_putpixel
'   putpixel(x0+x,y0-y,c)
	mov	arg01, local02
	add	arg01, local06
	mov	arg02, local03
	sub	arg02, local01
	mov	arg03, local04
	call	#_Hg010b_4_spin2_putpixel
'   putpixel(x0+x,y0+y,c)
	mov	arg01, local02
	add	arg01, local06
	mov	arg02, local03
	add	arg02, local01
	mov	arg03, local04
	call	#_Hg010b_4_spin2_putpixel
'   putpixel(x0-y,y0-x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local03
	sub	arg02, local06
	mov	arg03, local04
	call	#_Hg010b_4_spin2_putpixel
'   putpixel(x0-y,y0+x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local03
	add	arg02, local06
	mov	arg03, local04
	call	#_Hg010b_4_spin2_putpixel
'   putpixel(x0+y,y0-x,c)
	mov	arg01, local02
	add	arg01, local01
	mov	arg02, local03
	sub	arg02, local06
	mov	arg03, local04
	call	#_Hg010b_4_spin2_putpixel
'   putpixel(x0+y,y0+x,c)
	mov	arg01, local02
	add	arg01, local01
	mov	arg02, local03
	add	arg02, local06
	mov	arg03, local04
	call	#_Hg010b_4_spin2_putpixel
'   if d>0 
	cmps	local05, #1 wc
 if_b	jmp	#LR__2801
'     d+=da
	add	local05, local08
'     y-=1
	sub	local01, #1
'     x+=1
	add	local06, #1
'     da+=4*4
	add	local08, #16
'     db+=2*4
	add	local07, #8
	jmp	#LR__2800
LR__2801
'   else
'     d+=db
	add	local05, local07
'     x+=1
	add	local06, #1
'     da+=2*4
	add	local08, #8
'     db+=2*4
	add	local07, #8
	jmp	#LR__2800
LR__2802
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_circle_ret
	ret

'     
' '-- A frame (an empty rectangle) ---------------------------------------
' 
' pub frame(x1,y1,x2,y2,c)
_Hg010b_4_spin2_frame
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' fastline(x1,x2,y1,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local02
	mov	arg04, local05
	call	#_Hg010b_4_spin2_fastline
' fastline(x1,x2,y2,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local05
	call	#_Hg010b_4_spin2_fastline
' line(x1,y1,x1,y2,c)
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local01
	mov	arg04, local04
	mov	arg05, local05
' draw(x1,y1,x2,y2,c)
	call	#_Hg010b_4_spin2_draw
' line(x2,y1,x2,y2,c)
	mov	arg01, local03
	mov	arg02, local02
	mov	arg03, local03
	mov	arg04, local04
	mov	arg05, local05
' draw(x1,y1,x2,y2,c)
	call	#_Hg010b_4_spin2_draw
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_frame_ret
	ret

' 
' '-- A box (a filled rectangle) ----------------------------------------
' 
' pub box(x1,y1,x2,y2,c) |yy
_Hg010b_4_spin2_box
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' repeat yy from y1 to y2
	cmps	local04, local02 wc
	negc	local06, #1
	add	local04, local06
LR__2810
'   fastline(x1,x2,yy,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg04, local05
	mov	arg03, local02
	call	#_Hg010b_4_spin2_fastline
	add	local02, local06
	cmp	local02, local04 wz
 if_ne	jmp	#LR__2810
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_box_ret
	ret

'       
' pub putcharxycgf(x,y,achar,f,b) |xx, yy,bb,c1,c2
_Hg010b_4_spin2_putcharxycgf
' 
'  
' repeat yy from 0 to 15
	mov	_var01, #0
	callpa	#(@LR__2822-@LR__2820)>>2,fcache_load_ptr_
LR__2820
' 
'   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
	add	objptr, #149
	rdlong	_var02, objptr
	shl	_var02, #10
	mov	_var03, ptr__Hg010b_4_spin2_dat__
	add	_var03, _var02
	mov	_var02, arg03
	shl	_var02, #4
	add	_var03, _var02
	add	_var03, _var01
	rdbyte	_var03, _var03
'   asm
	testb	_var03, #0 wz
 if_e	setbyte	_var04, arg04, #0
 if_ne	setbyte	_var04, arg05, #0
	testb	_var03, #1 wz
 if_e	setbyte	_var04, arg04, #1
 if_ne	setbyte	_var04, arg05, #1
	testb	_var03, #2 wz
 if_e	setbyte	_var04, arg04, #2
 if_ne	setbyte	_var04, arg05, #2
	testb	_var03, #3 wz
 if_e	setbyte	_var04, arg04, #3
 if_ne	setbyte	_var04, arg05, #3
	testb	_var03, #4 wz
 if_e	setbyte	_var05, arg04, #0
 if_ne	setbyte	_var05, arg05, #0
	testb	_var03, #5 wz
 if_e	setbyte	_var05, arg04, #1
 if_ne	setbyte	_var05, arg05, #1
	testb	_var03, #6 wz
 if_e	setbyte	_var05, arg04, #2
 if_ne	setbyte	_var05, arg05, #2
	testb	_var03, #7 wz
 if_e	setbyte	_var05, arg04, #3
 if_ne	setbyte	_var05, arg05, #3
'   
'   ccc[0]:=c1
	add	objptr, #409
	wrlong	_var04, objptr
'   ccc[1]:=c2 
	add	objptr, #4
	wrlong	_var05, objptr
'   long[mailbox0][2]:=8
	sub	objptr, #73
	rdlong	_var03, objptr
	add	_var03, #8
	wrlong	#8, _var03
'   long[mailbox0][1]:=@ccc
	mov	_var03, objptr
	add	_var03, #69
	rdlong	_var02, objptr
	add	_var02, #4
	wrlong	_var03, _var02
'   long[mailbox0]:= s_buf_ptr+((y+yy)<<10+x<<2)+$f0000000   
	sub	objptr, #268
	rdlong	_var03, objptr
	mov	_var02, arg02
	add	_var02, _var01
	shl	_var02, #10
	mov	_var06, arg01
	shl	_var06, #2
	add	_var02, _var06
	add	_var03, _var02
	add	_var03, ##-268435456
	add	objptr, #268
	rdlong	_var06, objptr
	wrlong	_var03, _var06
'   repeat
LR__2821
	rdlong	_var03, objptr
	rdlong	_var02, _var03
	cmps	_var02, #0 wc
 if_b	jmp	#LR__2821
	sub	objptr, #489
	add	_var01, #1
	cmps	_var01, #16 wc
 if_b	jmp	#LR__2820
LR__2822
_Hg010b_4_spin2_putcharxycgf_ret
	ret

' 
' 
' '**********************************************************************r***
' '                                                                        *
' ' Font related functions                                                 *
' '                                                                        *
' '*************************************************************************
' 
' ''--------- Set a font offset. TODO: remove, use byte#1 instead
' 
' pub setfontfamily(afontnum)
_Hg010b_4_spin2_setfontfamily
' 
' font_family:=afontnum
	add	objptr, #149
	wrlong	arg01, objptr
	sub	objptr, #149
' 'if afontnum==8
' '  font_ptr:=@amiga_font
' 
' if afontnum==4
	cmp	arg01, #4 wz
'   font_ptr:=@st_font
 if_e	mov	_var01, ptr__Hg010b_4_spin2_dat__
 if_e	add	_var01, ##4096
 if_e	add	objptr, #8
 if_e	wrlong	_var01, objptr
 if_e	sub	objptr, #8
' if afontnum==0
	cmp	arg01, #0 wz
'   font_ptr:=@vga_font
 if_e	add	objptr, #8
 if_e	wrlong	ptr__Hg010b_4_spin2_dat__, objptr
 if_e	sub	objptr, #8
_Hg010b_4_spin2_setfontfamily_ret
	ret

' 
' ''--------- Redefine a character
' 
' pub defchar(ch,ptr) | s,i ' 
_Hg010b_4_spin2_defchar
' 
' s:=font_ptr+ch*16
	add	objptr, #8
	rdlong	_var01, objptr
	sub	objptr, #8
	shl	arg01, #4
	add	_var01, arg01
' repeat i from 0 to 15
	mov	_var02, #0
	callpa	#(@LR__2831-@LR__2830)>>2,fcache_load_ptr_
LR__2830
'   byte[s+i]:=byte[ptr+i]
	mov	arg01, arg02
	add	arg01, _var02
	mov	_var03, _var01
	rdbyte	arg01, arg01
	add	_var03, _var02
	wrbyte	arg01, _var03
	add	_var02, #1
	cmps	_var02, #16 wc
 if_b	jmp	#LR__2830
LR__2831
_Hg010b_4_spin2_defchar_ret
	ret

' 
' 
' '*************************************************************************
' '                                                                        *
' '  Cursor functions                                                      *
' '                                                                        *
' '*************************************************************************
' 
' 
' pub setcursorpos(x,y)
_Hg010b_4_spin2_setcursorpos
	mov	COUNT_, #1
	call	#pushregs_
' 
' ''---------- Set the (x,y) position of cursor
' 
' cursor_x:=x
	add	objptr, #60
	wrword	arg01, objptr
' cursor_y:=y
	add	objptr, #2
	wrbyte	arg02, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	sub	objptr, #2
	rdword	local01, objptr
	shl	local01, #2
	getbyte	arg03, arg02, #0
	sub	objptr, #60
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	mov	arg02, local01
	call	#_Hg010b_4_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_setcursorpos_ret
	ret

' 
' pub setcursorx(x)
_Hg010b_4_spin2_setcursorx
' cursor_x:=x
	add	objptr, #60
	wrword	arg01, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	getword	arg02, arg01, #0
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_Hg010b_4_spin2_setspritepos
_Hg010b_4_spin2_setcursorx_ret
	ret

' 
' pub setcursory(y) 
_Hg010b_4_spin2_setcursory
' cursor_y:=y
	add	objptr, #62
	wrbyte	arg01, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4)
	sub	objptr, #2
	rdword	arg02, objptr
	shl	arg02, #2
	getbyte	arg03, arg01, #0
	sub	objptr, #60
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_Hg010b_4_spin2_setspritepos
_Hg010b_4_spin2_setcursory_ret
	ret

' 
' '*************************************************************************
' '                                                                        *
' '  VBlank functions                                                      *
' '                                                                        *
' '*************************************************************************
' 
' pub waitvbl(amount) | i
_Hg010b_4_spin2_waitvbl
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' ''---------- Wait for start of vblank. Amount=delay in frames
' 
' repeat i from 1 to amount
	mov	local02, #1
	cmps	local01, #1 wc
	negc	local03, #1
	add	local01, local03
LR__2840
'   repeat until vblank==0
LR__2841
	add	objptr, #73
	rdlong	arg01, objptr wz
	sub	objptr, #73
 if_e	jmp	#LR__2842
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__2841
LR__2842
'   repeat until vblank==1
LR__2843
	add	objptr, #73
	rdlong	arg01, objptr
	sub	objptr, #73
	cmp	arg01, #1 wz
 if_e	jmp	#LR__2844
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__2843
LR__2844
	add	local02, local03
	cmp	local02, local01 wz
 if_ne	jmp	#LR__2840
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_waitvbl_ret
	ret

' 
' ''---------- Set color #c in palette to r,g,b
' 
' pub setcolor(c,r,g,b)  |cc
_Hg010b_4_spin2_setcolor
' 
' cc:=r<<24+g<<16+b<<8
	shl	arg02, #24
	shl	arg03, #16
	add	arg02, arg03
	shl	arg04, #8
	add	arg02, arg04
' long[palette_ptr+4*c]:=cc
	add	objptr, #28
	rdlong	arg04, objptr
	sub	objptr, #28
	shl	arg01, #2
	add	arg04, arg01
	wrlong	arg02, arg04
_Hg010b_4_spin2_setcolor_ret
	ret

' 
' 
' pub cls(fc,bc)   :c,i
_Hg010b_4_spin2_cls
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' c:=bc
' ram.fill(s_buf_ptr,c,4*buflen,0,1)  
	add	objptr, #221
	rdlong	arg01, objptr
	sub	objptr, #165
	rdlong	arg03, objptr
	shl	arg03, #2
	mov	arg02, local02
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5780
	call	#_psram4_spin2_fill
' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
	sub	objptr, ##5832
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	arg03, arg01
	mov	arg02, #32
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5836
	call	#_psram4_spin2_fill
' setwritecolors(fc,bc)
' 
' write_color:=ff
	sub	objptr, ##5771
	wrlong	local01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	local02, objptr
' cursor_x:=0
	sub	objptr, #9
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	sub	objptr, #2
	rdword	arg02, objptr
	shl	arg02, #2
	sub	objptr, #60
	mov	arg03, #4
	mov	arg01, #17
	call	#_Hg010b_4_spin2_setspritepos
' setcursorcolor(fc)
	mov	arg01, local01
	call	#_Hg010b_4_spin2_setcursorcolor
	mov	result1, local02
	mov	result2, #0
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_cls_ret
	ret

' 
' ''---------- Output a char at the cursor position, move the cursor 
' 
' pub putchar(achar) | c,x,y,l,newcpl
_Hg010b_4_spin2_putchar
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' 
' if achar==10
	cmp	local01, #10 wz
'   crlf()
 if_e	call	#_Hg010b_4_spin2_crlf
' if achar==9
	cmp	local01, #9 wz
 if_ne	jmp	#LR__2850
'   cursor_x:=(cursor_x& %11110000)+16
	add	objptr, #60
	rdword	arg03, objptr
	and	arg03, #240
	add	arg03, #16
	wrword	arg03, objptr
	sub	objptr, #60
LR__2850
'   
' if (achar<>9) && (achar<>10) 
	cmp	local01, #9 wz
 if_ne	cmp	local01, #10 wz
 if_e	jmp	#LR__2851
'   putcharxycgf(cursor_x,16*cursor_y+4,achar,write_color,write_background)
	add	objptr, #60
	rdword	arg01, objptr
	add	objptr, #2
	rdbyte	arg02, objptr
	shl	arg02, #4
	add	arg02, #4
	add	objptr, #3
	rdlong	arg04, objptr
	add	objptr, #4
	rdlong	arg05, objptr
	sub	objptr, #69
	mov	arg03, local01
	call	#_Hg010b_4_spin2_putcharxycgf
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__Hg010b_4_spin2_dat__, ##14428
	rdlong	arg03, ptr__Hg010b_4_spin2_dat__
	add	objptr, #58
	rdbyte	arg05, objptr
	qmul	arg03, arg05
'   ram.fill(textbuf_ptr+(timings[7]*cursor_y+(cursor_x>>1)),achar,1,0,1)
	sub	ptr__Hg010b_4_spin2_dat__, ##14428
	sub	objptr, #2
	rdword	local02, objptr
	shr	local02, #1
	mov	arg02, local01
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5776
	getqx	local01
	add	local01, local02
	add	arg01, local01
	call	#_psram4_spin2_fill
'   cursor_x+=2
	sub	objptr, ##5776
	rdword	local02, objptr
	add	local02, #2
	wrword	local02, objptr
	sub	objptr, #60
LR__2851
' 
' if cursor_x>=256
	add	objptr, #60
	rdword	local02, objptr
	sub	objptr, #60
	cmps	local02, #256 wc
 if_b	jmp	#LR__2853
'   cursor_x:=0
	add	objptr, #60
	wrword	#0, objptr
'   cursor_y+=1
	add	objptr, #2
	rdbyte	local02, objptr
	add	local02, #1
	wrbyte	local02, objptr
'   if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	rdbyte	arg03, objptr
	sub	objptr, #62
	cmps	arg03, local02 wcz
 if_be	jmp	#LR__2852
'     scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_Hg010b_4_spin2_scrollup2
'     cursor_y:=st_lines-1
	add	objptr, #257
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	wrbyte	local02, objptr
	sub	objptr, #62
LR__2852
LR__2853
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_Hg010b_4_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_putchar_ret
	ret

'     
' ''---------- Output a char at the cursor position, move the cursor, don't react for tab or lf 
' 
' pub putchar2(achar) | c,x,y,l,newcpl
_Hg010b_4_spin2_putchar2
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' 
' putcharxycgf(cursor_x,16*cursor_y+4,achar,write_color,write_background)
	add	objptr, #60
	rdword	arg01, objptr
	add	objptr, #2
	rdbyte	arg02, objptr
	shl	arg02, #4
	add	arg02, #4
	add	objptr, #3
	rdlong	arg04, objptr
	add	objptr, #4
	rdlong	arg05, objptr
	sub	objptr, #69
	mov	arg03, local01
	call	#_Hg010b_4_spin2_putcharxycgf
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__Hg010b_4_spin2_dat__, ##14428
	rdlong	arg03, ptr__Hg010b_4_spin2_dat__
	add	objptr, #58
	rdbyte	arg05, objptr
	qmul	arg03, arg05
' ram.fill(textbuf_ptr+(timings[7]*cursor_y+(cursor_x>>1)),achar,1,0,1)
	sub	ptr__Hg010b_4_spin2_dat__, ##14428
	sub	objptr, #2
	rdword	local02, objptr
	shr	local02, #1
	mov	arg02, local01
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5776
	getqx	local01
	add	local01, local02
	add	arg01, local01
	call	#_psram4_spin2_fill
' 
' cursor_x+=2
	sub	objptr, ##5776
	rdword	local02, objptr
	add	local02, #2
	wrword	local02, objptr
' if cursor_x>=256
	getword	local02, local02, #0
	sub	objptr, #60
	cmps	local02, #256 wc
 if_b	jmp	#LR__2861
'   cursor_x:=0
	add	objptr, #60
	wrword	#0, objptr
'   cursor_y+=1
	add	objptr, #2
	rdbyte	local02, objptr
	add	local02, #1
	wrbyte	local02, objptr
'   if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	rdbyte	arg03, objptr
	sub	objptr, #62
	cmps	arg03, local02 wcz
 if_be	jmp	#LR__2860
'     scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_Hg010b_4_spin2_scrollup2
'     cursor_y:=st_lines-1
	add	objptr, #257
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	wrbyte	local02, objptr
	sub	objptr, #62
LR__2860
LR__2861
' setspritepos(17,4*cursor_x,16*cursor_y+4 ) 
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_Hg010b_4_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_putchar2_ret
	ret

' ''--------- Output a string at the cursor position, move the cursor  
' 
' pub write(text) | iii,c,ncx,ncy
_Hg010b_4_spin2_write
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' repeat iii from 0 to strsize(text)-1
	mov	local02, #0
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__2871-@LR__2870)>>2,fcache_load_ptr_
LR__2870
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__2870
LR__2871
	sub	local03, arg01
	sub	local03, #1
	cmps	local03, #0 wc
	negc	local04, #1
	add	local03, local04
LR__2872
'   putchar2(byte[text+iii])
	mov	arg01, local01
	add	arg01, local02
	rdbyte	arg01, arg01
	call	#_Hg010b_4_spin2_putchar2
	add	local02, local04
	cmp	local02, local03 wz
 if_ne	jmp	#LR__2872
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_write_ret
	ret

'    
' ' a version for text scrolling in Basic shifted 4 lines down
' 
' pub scrollup2(start=0, end=600 , amount=16) | i
_Hg010b_4_spin2_scrollup2
	mov	COUNT_, #3
	call	#pushregs_
' 	
' repeat i from 4 to 579 
	mov	local01, #4
LR__2880
	add	objptr, #221
	rdlong	arg02, objptr
	mov	arg05, local01
	add	arg05, #16
	shl	arg05, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg05, arg03
'   ram.read1($7E800, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
	shl	arg03, #2
	mov	arg01, ##518144
	add	objptr, ##5595
	getqx	arg05
	add	arg02, arg05
	call	#_psram4_spin2_read1
	sub	objptr, ##5615
	rdlong	arg02, objptr
	mov	arg05, local01
	shl	arg05, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg05, arg03
'   ram.write($7E800, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
	shl	arg03, #2
	mov	arg01, ##518144
	add	objptr, ##5595
	getqx	arg05
	add	arg02, arg05
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	add	local01, #1
	cmp	local01, ##580 wc
 if_b	jmp	#LR__2880
' 
' repeat i from 580 to 599
	mov	local01, ##580
LR__2881
'    fastline(0,1023,i,write_background)   
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local01
	call	#_Hg010b_4_spin2_fastline
	add	local01, #1
	cmp	local01, ##600 wc
 if_b	jmp	#LR__2881
' repeat i from 0 to 3
	mov	local01, #0
LR__2882
'    fastline(0,1023,i,write_background)      
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local01
	call	#_Hg010b_4_spin2_fastline
	add	local01, #1
	cmps	local01, #4 wc
 if_b	jmp	#LR__2882
' 
' repeat i from 0 to 35
	mov	local01, #0
LR__2883
	mov	arg05, local01
	add	arg05, #1
	add	ptr__Hg010b_4_spin2_dat__, ##14428
	rdlong	arg03, ptr__Hg010b_4_spin2_dat__
	qmul	arg05, arg03
'   ram.read1($7E800, textbuf_ptr+(i+1)*timings[7], timings[7])
	add	objptr, #4
	rdlong	arg02, objptr
	sub	ptr__Hg010b_4_spin2_dat__, ##14428
	mov	arg01, ##518144
	add	objptr, ##5832
	getqx	arg05
	add	arg02, arg05
	call	#_psram4_spin2_read1
	add	ptr__Hg010b_4_spin2_dat__, ##14428
	rdlong	arg03, ptr__Hg010b_4_spin2_dat__
	qmul	local01, arg03
'   ram.write($7E800, textbuf_ptr+i*timings[7], timings[7])
	sub	objptr, ##5832
	rdlong	arg02, objptr
	sub	ptr__Hg010b_4_spin2_dat__, ##14428
	mov	arg01, ##518144
	add	objptr, ##5832
	getqx	arg05
	add	arg02, arg05
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	add	local01, #1
	cmps	local01, #36 wc
 if_b	jmp	#LR__2883
' repeat i from 0 to timings[7]-1
	mov	local01, #0
	add	ptr__Hg010b_4_spin2_dat__, ##14428
	rdlong	local02, ptr__Hg010b_4_spin2_dat__
	sub	ptr__Hg010b_4_spin2_dat__, ##14428
	sub	local02, #1
	cmps	local02, #0 wc
	negc	local03, #1
	add	local02, local03
LR__2884
'   ram.fill(textbuf_ptr+(36*timings[7]+i),32,1,0,1) 
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__Hg010b_4_spin2_dat__, ##14428
	rdlong	arg05, ptr__Hg010b_4_spin2_dat__
	sub	ptr__Hg010b_4_spin2_dat__, ##14428
	mov	arg04, arg05
	shl	arg04, #3
	add	arg04, arg05
	shl	arg04, #2
	add	arg04, local01
	add	arg01, arg04
	mov	arg02, #32
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5832
	call	#_psram4_spin2_fill
	sub	objptr, ##5836
	add	local01, local03
	cmp	local01, local02 wz
 if_ne	jmp	#LR__2884
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_scrollup2_ret
	ret

'  
' ''----------- Scroll the screen one line down 
' 
' pub scrolldown(start=0) | i
_Hg010b_4_spin2_scrolldown
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
' 
' repeat i from 579 to (start*16)+4
	mov	local02, ##579
	mov	local03, local01
	shl	local03, #4
	add	local03, #4
	cmps	local03, ##579 wc
	negc	local04, #1
	mov	local05, local04
	add	local03, local04
LR__2890
	add	objptr, #221
	rdlong	arg02, objptr
	mov	local04, local02
	shl	local04, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	local04, arg03
'   ram.read1($7E800, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
	shl	arg03, #2
	mov	arg01, ##518144
	add	objptr, ##5595
	getqx	local04
	add	arg02, local04
	call	#_psram4_spin2_read1
	sub	objptr, ##5615
	rdlong	arg02, objptr
	mov	local04, local02
	add	local04, #16
	shl	local04, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	local04, arg03
'   ram.write($7E800, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
	shl	arg03, #2
	mov	arg01, ##518144
	add	objptr, ##5595
	getqx	local04
	add	arg02, local04
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	add	local02, local05
	cmp	local02, local03 wz
 if_ne	jmp	#LR__2890
' 
' repeat i from (start*16)+4 to (start*16)+19
	mov	local02, local01
	shl	local02, #4
	add	local02, #4
	mov	local05, local01
	shl	local05, #4
	add	local05, #19
	mov	local04, local01
	shl	local04, #4
	add	local04, #4
	cmps	local05, local04 wc
	negc	local04, #1
	mov	local03, local04
	add	local05, local04
LR__2891
'    fastline(0,1023,i,write_background)    
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local02
	call	#_Hg010b_4_spin2_fastline
	add	local02, local03
	cmp	local02, local05 wz
 if_ne	jmp	#LR__2891
'    
' repeat i from 35 to start
	mov	local02, #35
	cmps	local01, #35 wc
	negc	local04, #1
	mov	local05, local01
	add	local05, local04
LR__2892
'   ram.read1($7E800, textbuf_ptr+(i*128), 128)
	add	objptr, #4
	rdlong	arg02, objptr
	mov	local03, local02
	shl	local03, #7
	add	arg02, local03
	mov	arg01, ##518144
	mov	arg03, #128
	add	objptr, ##5832
	call	#_psram4_spin2_read1
'   ram.write($7E800, textbuf_ptr+(i+1)*128,128)
	sub	objptr, ##5832
	rdlong	arg02, objptr
	mov	local03, local02
	add	local03, #1
	shl	local03, #7
	add	arg02, local03
	mov	arg01, ##518144
	mov	arg03, #128
	add	objptr, ##5832
	call	#_psram4_spin2_write
	sub	objptr, ##5836
	add	local02, local04
	cmp	local02, local05 wz
 if_ne	jmp	#LR__2892
' repeat i from 0 to 127
	mov	local02, #0
LR__2893
'   ram.fill((textbuf_ptr+start*128+i),32,1,0,1)      
	add	objptr, #4
	rdlong	arg01, objptr
	mov	local05, local01
	shl	local05, #7
	add	arg01, local05
	add	arg01, local02
	mov	arg02, #32
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5832
	call	#_psram4_spin2_fill
	sub	objptr, ##5836
	add	local02, #1
	cmps	local02, #128 wc
 if_b	jmp	#LR__2893
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_scrolldown_ret
	ret

' 
' ''----------- Set cursor at the first character in a new line, scroll if needed 
' 
' pub crlf()
_Hg010b_4_spin2_crlf
' 
' cursor_x:=leading_spaces*2
	add	objptr, ##694
	rdlong	arg03, objptr
	shl	arg03, #1
	sub	objptr, ##634
	wrword	arg03, objptr
' cursor_y+=1
	add	objptr, #2
	rdbyte	arg03, objptr
	add	arg03, #1
	wrbyte	arg03, objptr
' if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #195
	rdbyte	arg02, objptr
	sub	objptr, #62
	cmps	arg02, arg03 wcz
 if_be	jmp	#LR__2900
'   scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_Hg010b_4_spin2_scrollup2
'   cursor_y:=st_lines-1
	add	objptr, #257
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #195
	wrbyte	arg03, objptr
	sub	objptr, #62
LR__2900
' setspritepos(17,4*cursor_x,16*cursor_y+4 )  
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_Hg010b_4_spin2_setspritepos
_Hg010b_4_spin2_crlf_ret
	ret

' 
' 
' '*************************************************************************
' '                                                                        *
' '  Conversions                                                           *
' '                                                                        *
' '*************************************************************************
' 
' ''---------- Convert a integer to dec string, return a pointer
' 
' pub inttostr(i):result |q,pos,k,j
_Hg010b_4_spin2_inttostr
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01 wz
' 
' j:=i
' pos:=10
	mov	local02, #10
' k:=0
	mov	local03, #0
' 
' if (j==0)
 if_ne	jmp	#LR__2910
'   n_string[0]:=48
	add	objptr, #77
	wrbyte	#48, objptr
'   n_string[1]:=0
	add	objptr, #1
	wrbyte	#0, objptr
	sub	objptr, #78
	jmp	#LR__2917
LR__2910
' 
' else
'   if (j<0)
	abs	local01, local01 wc
'     j:=0-j
'     k:=45
 if_b	mov	local03, #45
' 
'   n_string[11]:=0
	add	objptr, #88
	wrbyte	#0, objptr
	sub	objptr, #88
	callpa	#(@LR__2912-@LR__2911)>>2,fcache_load_ptr_
'   repeat while (pos>-1)
LR__2911
	cmps	local02, #0 wc
 if_b	jmp	#LR__2913
	abs	result1, local01 wc
	qdiv	result1, #10
'     q:=j//10
	getqy	result1
	negc	result1, result1
	abs	local01, local01 wc
	qdiv	local01, #10
'     q:=48+q
	add	result1, #48
'     n_string[pos]:=q
	mov	local01, local02
	mov	arg03, objptr
	add	arg03, #77
	add	local01, arg03
	wrbyte	result1, local01
'     j:=j/10
'     pos-=1
	sub	local02, #1
	getqx	local01
	negc	local01, local01
	jmp	#LR__2911
LR__2912
LR__2913
'   repeat while n_string[0]==48
LR__2914
	add	objptr, #77
	rdbyte	arg03, objptr
	sub	objptr, #77
	cmp	arg03, #48 wz
 if_ne	jmp	#LR__2915
'     bytemove(@n_string,@n_string+1,12)
	add	objptr, #77
	mov	arg01, objptr
	mov	arg02, objptr
	sub	objptr, #77
	add	arg02, #1
	mov	arg03, #12
	call	#__system____builtin_memmove
	jmp	#LR__2914
LR__2915
' 
'   if k==45
	cmp	local03, #45 wz
 if_ne	jmp	#LR__2916
'      bytemove(@n_string+1,@n_string,12)
	add	objptr, #77
	mov	arg01, objptr
	add	arg01, #1
	mov	arg02, objptr
	sub	objptr, #77
	mov	arg03, #12
	call	#__system____builtin_memmove
'      n_string[0]:=k
	add	objptr, #77
	wrbyte	local03, objptr
	sub	objptr, #77
LR__2916
LR__2917
' 
' q:=@n_string
	mov	result1, objptr
	add	result1, #77
' return q
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_inttostr_ret
	ret

' 
' '**********************************************************************************
' '
' '        Blitting
' '
' '**********************************************************************************
' 
' pub blit(f,x1a,y1a,x2a,y2a,s1,t,x1b,y1b,s2) | y
_Hg010b_4_spin2_blit
	mov	COUNT_, #24
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
	mov	local06, arg06
	mov	local07, arg07
	mov	local08, arg08
	mov	local09, arg09
	mov	local10, arg10
' 
' if ((f>=$80000) && (t>=$80000)) ' todo: check if the fields overlap and reorder the move
	cmps	local01, ##524288 wc
 if_ae	cmps	local07, ##524288 wc
 if_b	jmp	#LR__2924
	cmps	local02, local04 wcz
 if_a	mov	local11, local02
 if_a	mov	local02, local04
 if_a	mov	local04, local11
	cmps	local03, local05 wcz
 if_a	mov	local11, local03
 if_a	mov	local03, local05
	qmul	local03, local06
'   if x1a>x2a
'     x1a,x2a:=x2a,x1a
'   if y1a>y2a
'     y1a,y2a:=y2a,y1a  
 if_a	mov	local05, local11
'   if x2a-x1a>1023 
	mov	local11, local04
	sub	local11, local02
	cmps	local11, ##1024 wc
'     x2a:=x1a+1023 ' limit the line to 1024
 if_ae	mov	local04, local02
 if_ae	add	local04, ##1023
'   if t+x1a+y1a*s1>f+x1b+y1b*s2
	mov	local12, local07
	add	local12, local02
	getqx	local11
	qmul	local09, local10
	add	local12, local11
	mov	local13, local01
	add	local13, local08
	getqx	local11
	add	local13, local11
	cmps	local12, local13 wcz
 if_be	jmp	#LR__2921
'     repeat y from y1a to y2a
	mov	local14, local03
	cmps	local05, local03 wc
	negc	local15, #1
	mov	local16, local05
	add	local16, local15
	add	objptr, ##5836
LR__2920
	qmul	local14, local06
'   '    writeln(string("I am here"))
'       ram.read1($7E800, f+(y)*s1+x1a, x2a-x1a+1)
	mov	arg02, local01
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	mov	arg01, ##518144
	getqx	local13
	add	arg02, local13
	add	arg02, local02
	call	#_psram4_spin2_read1
	mov	local13, local09
	sub	local13, local03
	add	local13, local14
	qmul	local13, local10
'       ram.write($7E800, t+(y1b-y1a+y)*s2+x1b, x2a-x1a+1)
	mov	arg02, local07
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	mov	arg01, ##518144
	getqx	local13
	add	arg02, local13
	add	arg02, local08
	call	#_psram4_spin2_write
	add	local14, local15
	cmp	local14, local16 wz
 if_ne	jmp	#LR__2920
	sub	objptr, ##5836
	jmp	#LR__2923
LR__2921
'   else
'     repeat y from y2a to y1a
	mov	local14, local05
	cmps	local03, local05 wc
	negc	local17, #1
	mov	local18, local03
	add	local18, local17
	add	objptr, ##5836
LR__2922
	qmul	local14, local06
'  '     writeln(string("I am there"))
'       ram.read1($7E800, f+(y)*s1+x1a, x2a-x1a+1)
	mov	arg02, local01
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	mov	arg01, ##518144
	getqx	local16
	add	arg02, local16
	add	arg02, local02
	call	#_psram4_spin2_read1
	mov	local16, local09
	sub	local16, local03
	add	local16, local14
	qmul	local16, local10
'       ram.write($7E800, t+(y1b-y1a+y)*s2+x1b, x2a-x1a+1)     
	mov	arg02, local07
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	mov	arg01, ##518144
	getqx	local16
	add	arg02, local16
	add	arg02, local08
	call	#_psram4_spin2_write
	add	local14, local17
	cmp	local14, local18 wz
 if_ne	jmp	#LR__2922
	sub	objptr, ##5836
LR__2923
LR__2924
'     
' if ((f>=$80000) && (t<$80000)) 
	cmps	local01, ##524288 wc
 if_b	jmp	#LR__2926
	cmps	local07, ##524288 wc
 if_ae	jmp	#LR__2926
'   repeat y from y1a to y2a
	mov	local14, local03
	cmps	local05, local03 wc
	negc	local19, #1
	mov	local20, local05
	add	local20, local19
	add	objptr, ##5836
LR__2925
	mov	local18, local09
	sub	local18, local03
	add	local18, local14
	qmul	local18, local10
'     ram.read1(t+(y1b-y1a+y)*s2+x1b,f+(y)*s1+x1a,x2a-x1a+1)
	mov	arg01, local07
	getqx	local18
	qmul	local14, local06
	add	arg01, local18
	add	arg01, local08
	mov	arg02, local01
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	getqx	local18
	add	arg02, local18
	add	arg02, local02
	call	#_psram4_spin2_read1
	add	local14, local19
	cmp	local14, local20 wz
 if_ne	jmp	#LR__2925
	sub	objptr, ##5836
LR__2926
'     
' if ((f<$80000) && (t>=$80000)) 
	cmps	local01, ##524288 wc
 if_ae	jmp	#LR__2928
	cmps	local07, ##524288 wc
 if_b	jmp	#LR__2928
'   t:=t & $FFFFFFF
	bitl	local07, #124
'   repeat y from y1a to y2a
	mov	local14, local03
	cmps	local05, local03 wc
	negc	local21, #1
	mov	local22, local05
	add	local22, local21
	add	objptr, ##5836
LR__2927
	qmul	local14, local06
'     ram.write(f+(y)*s1+x1a,t+(y1b-y1a+y)*s2+x1b,x2a-x1a+1)
	mov	arg01, local01
	mov	local20, local09
	sub	local20, local03
	add	local20, local14
	getqx	local19
	qmul	local20, local10
	add	arg01, local19
	add	arg01, local02
	mov	arg02, local07
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	getqx	local20
	add	arg02, local20
	add	arg02, local08
	call	#_psram4_spin2_write
	add	local14, local21
	cmp	local14, local22 wz
 if_ne	jmp	#LR__2927
	sub	objptr, ##5836
LR__2928
'     
' if ((f<$80000) && (t<$80000)) 
	cmps	local01, ##524288 wc
 if_b	cmps	local07, ##524288 wc
 if_ae	jmp	#LR__2930
'   repeat y from y1a to y2a
	mov	local14, local03
	cmps	local05, local03 wc
	negc	local23, #1
	mov	local24, local05
	add	local24, local23
LR__2929
	qmul	local14, local06
'     bytemove (f+(y)*s1+x1a,t+(y1b-y1a+y)*s2+x1b,x2a-x1a+1)
	mov	arg01, local01
	mov	local22, local09
	sub	local22, local03
	add	local22, local14
	getqx	local21
	qmul	local22, local10
	add	arg01, local21
	add	arg01, local02
	mov	arg02, local07
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	getqx	local22
	add	arg02, local22
	add	arg02, local08
	call	#__system____builtin_memmove
	add	local14, local23
	cmp	local14, local24 wz
 if_ne	jmp	#LR__2929
LR__2930
	mov	ptra, fp
	call	#popregs_
_Hg010b_4_spin2_blit_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB startx(freq, burst, delay, desiredcog) : result | driverAddr
_psram4_spin2_startx
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	mov	local03, arg04
'     stop() ' restart driver if required
	call	#_psram4_spin2_stop
	cmp	local01, #0 wz
 if_e	rdlong	local01, #20
	abs	arg02, local01 wc
	qdiv	arg02, ##4000000
' 
'     ' use current frequency if none specified
' 
'     if freq == 0 
'         freq := clkfreq 
' 
'     ' compute the device burst size including overheads to keep CS low time below 8us
' 
'     burst := (((MAX_CS_LOW_USEC*(freq/4000000)) - 132) >> 4) << 4  ' some sane rounded value
'     if burst < 0
'         return ERR_TOO_SLOW 'P2 frequency is too low for any 8us transfers
	getqx	arg02
	negc	arg04, arg02
	shl	arg04, #3
	sub	arg04, #132
	shr	arg04, #4
	shl	arg04, #4
	cmps	arg04, #0 wc
 if_b	neg	result1, #14
 if_b	jmp	#LR__2944
' 
'     ' compute the input delay
' 
'     if delay <= 0
	cmps	local02, #1 wc
 if_ae	jmp	#LR__2940
'         delay := lookupDelay(freq)
	mov	arg01, local01
	call	#_psram4_spin2_lookupDelay
	mov	local02, result1
	jmp	#LR__2941
LR__2940
'     else
'         delay <#= $f ' limit to 15
	fles	local02, #15
LR__2941
' 
'     ' create our lock
' 
'     driverlock := LOCKNEW()  
	mov	result1, #0
	locknew	result1
	add	ptr__psram4_spin2_dat__, #260
	wrlong	result1, ptr__psram4_spin2_dat__
'     if driverlock == -1
	sub	ptr__psram4_spin2_dat__, #260
	cmp	result1, ##-1 wz
'         return ERR_NO_LOCK
 if_e	neg	result1, #26
 if_e	jmp	#LR__2944
' 
'     ' patch in the proper data and HUB addresses to the startup structure
' 
'     long[@startupData][0]:=clkfreq
	rdlong	local01, #20
	add	ptr__psram4_spin2_dat__, #296
	wrlong	local01, ptr__psram4_spin2_dat__
'     long[@startupData][5]:=@deviceData
	mov	local01, ptr__psram4_spin2_dat__
	add	local01, #32
	mov	arg02, ptr__psram4_spin2_dat__
	add	arg02, #20
	wrlong	local01, arg02
'     long[@startupData][6]:=@qosData
	mov	local01, ptr__psram4_spin2_dat__
	add	local01, #160
	mov	arg02, ptr__psram4_spin2_dat__
	add	arg02, #24
	wrlong	local01, arg02
'     long[@startupData][7]:=$7FF00
	mov	local01, ptr__psram4_spin2_dat__
	add	local01, #28
	wrlong	##524032, local01
' 
'     ' setup some default bank and QoS parameter values
' 
'     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
	add	ptr__psram4_spin2_dat__, #32
	mov	arg01, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #328
	shl	arg04, #16
	shl	local02, #12
	or	arg04, local02
	or	arg04, #22
	mov	arg02, arg04
	mov	arg03, #2
	call	#\builtin_longfill_
'     longfill(@qosData, $7FFF0000, 8)
	mov	arg01, ptr__psram4_spin2_dat__
	add	arg01, #456
	mov	arg03, #7
	setq	arg03
	wrlong	##2147418112, arg01
' 
'     ' get the address of the PSRAM memory driver so we can start it
' 
'     driverAddr:= driver.getDriverAddr()
'     return @driver_start
	mov	arg02, ptr__psram4drv_spin2_dat__
' 
'     ' start the PSRAM memory driver and wait for it to complete initialization
' 
'     if desiredcog < 0
	cmps	local03, #0 wc
'         desiredcog := NEWCOG
 if_b	mov	local03, #16
'     drivercog := coginit(desiredcog, driverAddr, @startupData)
	mov	arg03, ptr__psram4_spin2_dat__
	add	arg03, #296
	mov	local04, local03
	setq	arg03
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
	add	ptr__psram4_spin2_dat__, #256
	wrlong	local04, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #256
	callpa	#(@LR__2943-@LR__2942)>>2,fcache_load_ptr_
'     repeat until long[@startupData] == 0 
LR__2942
	mov	local04, ptr__psram4_spin2_dat__
	add	local04, #296
	rdlong	local04, local04 wz
 if_ne	jmp	#LR__2942
LR__2943
' 
'     return drivercog 
	add	ptr__psram4_spin2_dat__, #256
	rdlong	result1, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #256
LR__2944
	mov	ptra, fp
	call	#popregs_
_psram4_spin2_startx_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB stop() : i
_psram4_spin2_stop
	mov	_var01, #0
'     if drivercog <> -1
	add	ptr__psram4_spin2_dat__, #256
	rdlong	arg01, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #256
	cmp	arg01, ##-1 wz
 if_e	jmp	#LR__2953
'         cogstop(drivercog) ' a rather brutal stop
	add	ptr__psram4_spin2_dat__, #256
	rdlong	arg01, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #256
	cogstop	arg01
	callpa	#(@LR__2952-@LR__2950)>>2,fcache_load_ptr_
'         repeat i from 0 to 7
LR__2950
'             if long[$7FF00+i*3] < 0
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	mov	arg01, ##524032
	add	arg01, result1
	rdlong	result1, arg01
	cmps	result1, #0 wc
 if_ae	jmp	#LR__2951
'                 long[$7FF00+i*3] := -ERR_ABORTED ' abort request
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	mov	arg01, ##524032
	add	arg01, result1
	wrlong	#16, arg01
LR__2951
	add	_var01, #1
	cmps	_var01, #8 wc
 if_b	jmp	#LR__2950
LR__2952
'         drivercog := -1
	add	ptr__psram4_spin2_dat__, #256
	wrlong	##-1, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #256
LR__2953
'     if driverlock <> -1
	add	ptr__psram4_spin2_dat__, #260
	rdlong	arg01, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #260
	cmp	arg01, ##-1 wz
'         LOCKRET(driverlock)
 if_ne	add	ptr__psram4_spin2_dat__, #260
 if_ne	rdlong	arg01, ptr__psram4_spin2_dat__
 if_ne	lockret	arg01
'         driverlock := -1
 if_ne	wrlong	##-1, ptr__psram4_spin2_dat__
 if_ne	sub	ptr__psram4_spin2_dat__, #260
	mov	result1, _var01
_psram4_spin2_stop_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB read1(dstHubAddr, srcAddr, count) : result | mailbox
_psram4_spin2_read1
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram4_spin2_dat__, #256
	rdlong	_var01, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__2961
'     if count == 0 ' don't even bother reading
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__2961
'     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	mov	_var02, ##524032
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__2961
'     long[mailbox][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox][1] := dstHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox] := driver.R_READBURST + (srcAddr & $0ffffff) ' trigger burst read operation
	mov	_var03, arg02
	bitl	_var03, #248
	mov	_var01, ##-1342177280
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__2960
'         result := long[mailbox]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__2960
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__2961
_psram4_spin2_read1_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB write(srcHubAddr, dstAddr, count) : result | mailbox
_psram4_spin2_write
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram4_spin2_dat__, #256
	rdlong	_var01, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__2971
'     if count == 0 ' don't even bother writing
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__2971
'     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	mov	_var02, ##524032
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__2971
'     long[mailbox][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox][1] := srcHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox] := driver.R_WRITEBURST + (dstAddr & $0ffffff) ' trigger burst write operation
	mov	_var03, arg02
	bitl	_var03, #248
	mov	_var01, ##-268435456
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__2970
'         result := long[mailbox]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__2970
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__2971
_psram4_spin2_write_ret
	ret

' 
' ' generalized fill
' PUB fill(addr, pattern, count, listPtr, datasize) : r | mailbox, req
_psram4_spin2_fill
	mov	_var01, arg01
	mov	_var02, arg02
	mov	_var03, arg03
	mov	_var04, arg05
'     case datasize 
	sub	_var04, #1
	fle	_var04, #4
	jmprel	_var04
LR__2980
	jmp	#LR__2981
	jmp	#LR__2982
	jmp	#LR__2984
	jmp	#LR__2983
	jmp	#LR__2984
LR__2981
'         1: req := driver.R_WRITEBYTE
	mov	_var05, ##-1073741824
	jmp	#LR__2985
LR__2982
'         2: req := driver.R_WRITEWORD
	mov	_var05, ##-805306368
	jmp	#LR__2985
LR__2983
'         4: req := driver.R_WRITELONG
	mov	_var05, ##-536870912
	jmp	#LR__2985
LR__2984
'         other : return ERR_INVALID
	neg	result1, #6
	jmp	#LR__2987
LR__2985
'     if count == 0   ' nothing to do
	cmp	_var03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__2987
'     if drivercog == -1
	add	ptr__psram4_spin2_dat__, #256
	rdlong	_var04, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #256
	cmp	_var04, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__2987
'     mailbox := $7FF00 + 12*cogid() ' get mailbox base address for this COG
	mov	result1, #0
	cogid	result1
	mov	_var04, result1
	shl	_var04, #1
	add	_var04, result1
	shl	_var04, #2
	mov	_var06, ##524032
	add	_var06, _var04
'     if long[mailbox] < 0
	rdlong	_var04, _var06
	cmps	_var04, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__2987
'     long[mailbox][2] := count
	add	_var06, #8
	wrlong	_var03, _var06
'     long[mailbox][1] := pattern
	sub	_var06, #4
	wrlong	_var02, _var06
	sub	_var06, #4
'     long[mailbox] := req + (addr & $0ffffff)
	mov	_var07, _var05
	mov	_var08, _var01
	bitl	_var08, #248
	add	_var07, _var08
	wrlong	_var07, _var06
'     repeat
LR__2986
'         r := long[mailbox]
	rdlong	_var08, _var06
	cmps	_var08, #0 wc
 if_b	jmp	#LR__2986
'     while r < 0
'     return -r                  ' return 0 for success or negated error code
	neg	result1, _var08
LR__2987
_psram4_spin2_fill_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB setQos(cog, qos) : result | mailbox
_psram4_spin2_setQos
	mov	_var01, arg01
'     if drivercog == -1 ' driver must be running
	add	ptr__psram4_spin2_dat__, #256
	rdlong	_var02, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #256
	cmp	_var02, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__2994
'     if cog < 0 or cog > 7 ' enforce cog id range
	cmps	_var01, #0 wc
 if_b	jmp	#LR__2990
	cmps	_var01, #8 wc
 if_b	jmp	#LR__2991
LR__2990
'         return ERR_INVALID
	neg	result1, #6
	jmp	#LR__2994
LR__2991
'     long[@qosData][cog] := qos & !$1ff
	andn	arg02, #511
	add	ptr__psram4_spin2_dat__, #456
	shl	_var01, #2
	add	_var01, ptr__psram4_spin2_dat__
	wrlong	arg02, _var01
'     mailbox := $7FF00 + drivercog*12
	sub	ptr__psram4_spin2_dat__, #200
	rdlong	_var03, ptr__psram4_spin2_dat__
	mov	_var04, _var03
	shl	_var04, #1
	add	_var04, _var03
	shl	_var04, #2
	mov	_var05, ##524032
	add	_var05, _var04
'     repeat until LOCKTRY(driverlock)
	add	ptr__psram4_spin2_dat__, #4
LR__2992
	rdlong	arg01, ptr__psram4_spin2_dat__
	locktry	arg01 wc
 if_ae	jmp	#LR__2992
	sub	ptr__psram4_spin2_dat__, #260
'     long[mailbox] := driver.R_CONFIG + cogid()
	mov	_var04, #0
	cogid	_var04
	mov	_var02, ##-268435456
	add	_var02, _var04
	wrlong	_var02, _var05
'     repeat while long[mailbox] < 0
LR__2993
	rdlong	_var02, _var05
	cmps	_var02, #0 wc
 if_b	jmp	#LR__2993
'     LOCKREL(driverlock)
	add	ptr__psram4_spin2_dat__, #260
	rdlong	arg01, ptr__psram4_spin2_dat__
	sub	ptr__psram4_spin2_dat__, #260
	lockrel	arg01 wc
	mov	result1, #0
LR__2994
_psram4_spin2_setQos_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PRI lookupDelay(freq) : delay | profile
_psram4_spin2_lookupDelay
'     profile := @delayTable
	mov	_var01, ptr__psram4_spin2_dat__
	add	_var01, #264
'     delay := long[profile][0]
	rdlong	_var02, _var01
	callpa	#(@LR__3001-@LR__3000)>>2,fcache_load_ptr_
'     repeat while long[profile][1] 
LR__3000
	add	_var01, #4
	rdlong	result1, _var01 wz
	sub	_var01, #4
 if_e	jmp	#LR__3002
'         if freq +< long[profile][1] 
	add	_var01, #4
	rdlong	result1, _var01
	sub	_var01, #4
	cmp	arg01, result1 wc
'             quit
'         profile += 4
 if_ae	add	_var01, #4
'         delay++
 if_ae	add	_var02, #1
 if_ae	jmp	#LR__3000
LR__3001
LR__3002
	mov	result1, _var02
_psram4_spin2_lookupDelay_ret
	ret

' 
' PUB start() : r
_usbnew_spin2_start
	mov	_var01, #0
'   ifnot driver_cog
	add	ptr__usbnew_spin2_dat__, ##10887
	rdbyte	_var02, ptr__usbnew_spin2_dat__ wz
	sub	ptr__usbnew_spin2_dat__, ##10887
 if_ne	jmp	#LR__3010
'     r := coginit(COGEXEC_NEW,@usb_host_start,0)
	mov	arg02, ptr__usbnew_spin2_dat__
	mov	_var01, #16
	mov	arg03, #0
	setq	arg03
	coginit	_var01, arg02 wc
 if_b	neg	_var01, #1
'     if r >= 0
	cmps	_var01, #0 wc
'       driver_cog := r+1
 if_ae	mov	_var02, _var01
 if_ae	add	_var02, #1
 if_ae	add	ptr__usbnew_spin2_dat__, ##10887
 if_ae	wrbyte	_var02, ptr__usbnew_spin2_dat__
 if_ae	sub	ptr__usbnew_spin2_dat__, ##10887
LR__3010
	mov	result1, _var01
_usbnew_spin2_start_ret
	ret

'     '' (Always enabled)
' 
' '' Get current pressed state of a keyboard key
' PUB keystate(key) : r | buf[2],tmp
_usbnew_spin2_keystate
	mov	_var03, #0
'   if key >= $E0 && key < $E8
	cmps	arg01, #224 wc
 if_b	jmp	#LR__3020
	cmps	arg01, #232 wc
 if_ae	jmp	#LR__3020
'     return not not (hkbd_report.byte[0] >> (key-$E0))
	mov	result1, #0
	mov	_var04, ptr__usbnew_spin2_dat__
	add	_var04, ##10200
	mov	_var05, arg01
	sub	_var05, #224
	rdbyte	_var06, _var04
	shr	_var06, _var05 wz
 if_ne	neg	result1, #1
	jmp	#_usbnew_spin2_keystate_ret
LR__3020
'   else
'     '' Do this in inline ASM to ensure atomicity
'     tmp := @hkbd_report
	mov	_var06, ptr__usbnew_spin2_dat__
	add	_var06, ##10200
'     org
	callpa	#(@LR__3022-@LR__3021)>>2,fcache_load_ptr_
LR__3021
	org	0
	setq	#1
	rdlong	_var01, _var06
	getbyte	_var07, _var01, #2
	cmp	_var07, arg01 wz
	getbyte	_var07, _var01, #3
 if_ne	cmp	_var07, arg01 wz
	getbyte	_var07, _var02, #0
 if_ne	cmp	_var07, arg01 wz
	getbyte	_var07, _var02, #1
 if_ne	cmp	_var07, arg01 wz
	getbyte	_var07, _var02, #2
 if_ne	cmp	_var07, arg01 wz
	getbyte	_var07, _var02, #3
 if_ne	cmp	_var07, arg01 wz
 if_e	neg	_var03, #1
	fit	192
LR__3022
	orgh
	mov	result1, _var03
_usbnew_spin2_keystate_ret
	ret

'     '' Set KEYQUEUE_SIZE to enable (recommended value: 32)
' 
' '' Return key event from buffer if there is one
' PUB get_key() : r | tail
_usbnew_spin2_get_key
'   tail := keyq_tail
	add	ptr__usbnew_spin2_dat__, ##7893
	rdbyte	_var01, ptr__usbnew_spin2_dat__
'   if keyq_head == tail
	sub	ptr__usbnew_spin2_dat__, #1
	rdbyte	_var02, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7892
	cmp	_var02, _var01 wz
'     return 0 ' No event
 if_e	mov	result1, #0
 if_e	jmp	#_usbnew_spin2_get_key_ret
'   r := keyq_data[tail]
	mov	_var02, _var01
	shl	_var02, #2
	mov	result1, ptr__usbnew_spin2_dat__
	add	result1, ##7894
	add	_var02, result1
	rdlong	result1, _var02
'   if ++tail == KEYQUEUE_SIZE
	add	_var01, #1
	cmp	_var01, #128 wz
'     tail := 0
 if_e	mov	_var01, #0
'   keyq_tail := tail
	add	ptr__usbnew_spin2_dat__, ##7893
	wrbyte	_var01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7893
_usbnew_spin2_get_key_ret
	ret

' 
' '' Emulate mouse movement
' PUB mouse_move(x,y)
_usbnew_spin2_mouse_move
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'   mouse_lock := 1
	add	ptr__usbnew_spin2_dat__, ##10481
	wrbyte	#1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10481
'   waitus(2) ' hope driver is now done
	mov	arg01, #2
	call	#__system___waitus
'   mouse_xacc := x
	add	ptr__usbnew_spin2_dat__, ##10465
	wrlong	local01, ptr__usbnew_spin2_dat__
'   mouse_yacc := y
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	local02, ptr__usbnew_spin2_dat__
'   if mouse_outptr
	sub	ptr__usbnew_spin2_dat__, ##2581
	rdlong	arg02, ptr__usbnew_spin2_dat__ wz
	sub	ptr__usbnew_spin2_dat__, ##7888
 if_e	jmp	#LR__3030
'     long[mouse_outptr] := y << 16 | x & $FFFF
	shl	local02, #16
	getword	local01, local01, #0
	or	local02, local01
	add	ptr__usbnew_spin2_dat__, ##7888
	rdlong	local01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7888
	wrlong	local02, local01
LR__3030
'   mouse_lock := 0
	add	ptr__usbnew_spin2_dat__, ##10481
	wrbyte	#0, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10481
	mov	ptra, fp
	call	#popregs_
_usbnew_spin2_mouse_move_ret
	ret

' 
' '' Get state of an axis (normalized between -32768 and 32767)
' PUB hidpad_axis(dev,axnum) : r
_usbnew_spin2_hidpad_axis
'   if axnum +>= 8
	cmp	arg02, #8 wc
'     return 0
 if_ae	mov	result1, #0
 if_ae	jmp	#_usbnew_spin2_hidpad_axis_ret
'   else 
'     return word[@hidpad_report+dev*HIDPAD_REPORT_SIZE][4+axnum] signx 15
	mov	result1, ptr__usbnew_spin2_dat__
	add	result1, ##10232
	shl	arg01, #5
	add	result1, arg01
	mov	arg01, #4
	add	arg01, arg02
	shl	arg01, #1
	add	arg01, result1
	rdword	result1, arg01
	signx	result1, #15
_usbnew_spin2_hidpad_axis_ret
	ret

' 
' '' Get state of a hat
' PUB hidpad_hat(dev,hatnum) : r
_usbnew_spin2_hidpad_hat
'   if hatnum +>= 4
	cmp	arg02, #4 wc
'     return 0
 if_ae	mov	result1, #0
 if_ae	jmp	#_usbnew_spin2_hidpad_hat_ret
'   else 
'     return byte[@hidpad_report+dev*HIDPAD_REPORT_SIZE][7*4+hatnum]
	mov	result1, ptr__usbnew_spin2_dat__
	add	result1, ##10232
	shl	arg01, #5
	add	result1, arg01
	mov	arg01, #28
	add	arg01, arg02
	add	arg01, result1
	rdbyte	result1, arg01
_usbnew_spin2_hidpad_hat_ret
	ret

' 
' '--------------------------------------------------------------
' '---------- Init the variables, start the cog. ----------------
' '--------------------------------------------------------------
' 
' pub start(mbox,scope,cache) :cog,base | iii
_Audio2_004_spin2_start
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' ' mbox: PSRAM mailbox or 0 if no PSRAM
' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
' 
' mailboxaddr:=mbox 
	wrlong	local01, objptr
' scope_ptr:=scope
	add	objptr, #4
	wrlong	arg02, objptr
' cache_ptr:=cache
	add	objptr, #4
	wrlong	arg03, objptr
' base:=@channel0[0]
	add	objptr, #4
	mov	local02, objptr
' 
' repeat iii from 0 to 15
	mov	local03, #0
	sub	objptr, #12
	callpa	#(@LR__3041-@LR__3040)>>2,fcache_load_ptr_
LR__3040
'   long[base+64*iii]:=0
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	wrlong	#0, local01
'   long[base+64*iii+4]:=0  		
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	add	local01, #4
	wrlong	#0, local01
'   long[base+64*iii+8]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #8
	wrlong	#0, local04
'   long[base+64*iii+12]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #12
	wrlong	#0, local04
'   long[base+64*iii+16]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #16
	wrlong	#0, local04
'   long[base+64*iii+20]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #20
	wrlong	#0, local04
'   long[base+64*iii+24]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #24
	wrlong	#0, local04
'   long[base+64*iii+28]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #28
	wrlong	#0, local04
'   word[base+64*iii+32]:=8192
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #32
	wrword	##8192, local04
'   word[base+64*iii+34]:=8192
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #34
	wrword	##8192, local04
'   long[base+64*iii+36]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #36
	wrlong	#0, local04
'   long[base+64*iii+40]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #40
	wrlong	#0, local04
'   long[base+64*iii+44]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #44
	wrlong	#0, local04
'   long[base+64*iii+48]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #48
	wrlong	#0, local04
'   long[base+64*iii+52]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #52
	wrlong	#0, local04
'   freqs[iii]:=440000
	mov	local04, local03
	shl	local04, #2
	add	objptr, ##1036
	add	local04, objptr
	wrlong	##440000, local04
'   delays[iii]:=0
	mov	local04, local03
	shl	local04, #1
	add	objptr, #64
	add	local04, objptr
	wrword	#0, local04
'   volumes[iii]:=4096
	mov	local04, local03
	shl	local04, #1
	add	objptr, #32
	add	local04, objptr
	wrword	##4096, local04
'   waveforms[iii]:=0
	mov	local04, local03
	shl	local04, #2
	add	objptr, #32
	add	local04, objptr
	wrlong	#0, local04
'   envelopes[iii]:=0
	mov	local04, local03
	shl	local04, #2
	add	objptr, #64
	add	local04, objptr
	wrlong	#0, local04
'   lengths[iii]:=1000
	mov	local04, local03
	shl	local04, #1
	add	objptr, #64
	add	local04, objptr
	wrword	##1000, local04
'   pans[iii]:=8192
	mov	local04, local03
	shl	local04, #1
	add	objptr, #32
	add	local04, objptr
	wrword	##8192, local04
'   sustains[iii]:=255
	mov	local04, local03
	shl	local04, #1
	add	objptr, #32
	add	local04, objptr
	wrword	#255, local04
	add	local03, #1
	cmps	local03, #16 wc
	sub	objptr, ##1356
 if_b	jmp	#LR__3040
LR__3041
'   
' cog:=coginit(16,@audio,@mailboxaddr)
	mov	arg02, ptr__Audio2_004_spin2_dat__
	mov	arg03, objptr
	mov	local04, #16
	setq	arg03
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
' waitms(10)
	mov	arg01, #10
	call	#__system___waitms
' return cog,base
	mov	result2, local02
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_Audio2_004_spin2_start_ret
	ret

' 
' pub play (channel, frequency=-1, delay=-1, volume=-1, waveform=-1, envelope=-1, length=-1, pan=-1, sustain=-1) | base2
_Audio2_004_spin2_play
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
	mov	local06, arg06
	mov	local07, arg07
	mov	local08, arg08
	mov	local09, arg09
' 
' if frequency==(-1)
	cmp	local02, ##-1 wz
 if_ne	jmp	#LR__3050
'   frequency:=freqs[channel]
	mov	local02, local01
	shl	local02, #2
	mov	local10, objptr
	add	local10, ##1036
	add	local02, local10
	rdlong	local02, local02
	jmp	#LR__3051
LR__3050
' else
'   freqs[channel]:=frequency
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1036
	add	local11, local10
	wrlong	local02, local11
LR__3051
'   
' if delay==(-1)
	cmp	local03, ##-1 wz
 if_ne	jmp	#LR__3052
'   delay:=delays[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1100
	add	local10, local11
	rdword	local03, local10
	jmp	#LR__3053
LR__3052
' else
'   delays[channel]:=delay
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1100
	add	local10, local11
	wrword	local03, local10
LR__3053
'   
' if volume==(-1)      
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__3054
'   volume:=volumes[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1132
	add	local10, local11
	rdword	local04, local10
	jmp	#LR__3055
LR__3054
' else
'   volumes[channel]:=volume
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1132
	add	local10, local11
	wrword	local04, local10
LR__3055
'   
' if waveform==(-1)
	cmp	local05, ##-1 wz
 if_ne	jmp	#LR__3056
'   waveform:=waveforms[channel]
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1164
	add	local11, local10
	rdlong	local05, local11
	jmp	#LR__3057
LR__3056
' else
'   waveforms[channel]:=waveform
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1164
	add	local11, local10
	wrlong	local05, local11
LR__3057
'   
' if envelope==(-1)
	cmp	local06, ##-1 wz
 if_ne	jmp	#LR__3058
'   envelope:=envelopes[channel]
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1228
	add	local11, local10
	rdlong	local06, local11
	jmp	#LR__3059
LR__3058
' else
'   envelopes[channel]:=envelope
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1228
	add	local11, local10
	wrlong	local06, local11
LR__3059
'   
' if length==(-1)
	cmp	local07, ##-1 wz
 if_ne	jmp	#LR__3060
'   length:=lengths[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1292
	add	local10, local11
	rdword	local07, local10
	jmp	#LR__3061
LR__3060
' else
'   lengths[channel]:=length
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1292
	add	local10, local11
	wrword	local07, local10
LR__3061
'   
' if pan==(-1)
	cmp	local08, ##-1 wz
 if_ne	jmp	#LR__3062
'   pan:=pans[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1324
	add	local10, local11
	rdword	local08, local10
	jmp	#LR__3063
LR__3062
' else
'   pans[channel]:=pan
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1324
	add	local10, local11
	wrword	local08, local10
LR__3063
'  
' if sustain==(-1)
	cmp	local09, ##-1 wz
 if_ne	jmp	#LR__3064
'   sustain:=sustains[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1356
	add	local10, local11
	rdword	local09, local10
	jmp	#LR__3065
LR__3064
' else
'   sustains[channel]:=sustain
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1356
	add	local10, local11
	wrword	local09, local10
LR__3065
	abs	local11, local07 wc
	qdiv	##24347887, local11
'                 
' length:=24347887/length  
	getqx	local11
	qmul	local02, #109
	negc	local07, local11
' debug(udec(sustain))
' base2:=@channel0[0]+64*channel
	mov	local02, objptr
	add	local02, #12
	shl	local01, #6
	add	local02, local01
' long[base2+20]:=waveform+$C0000000 
	add	local05, ##-1073741824
	mov	local10, local02
	add	local10, #20
	wrlong	local05, local10
' long[base2+28]:= 2048
	mov	local11, local02
	add	local11, #28
	wrlong	##2048, local11
' long[base2+24]:= 0
	mov	local11, local02
	add	local11, #24
	wrlong	#0, local11
' word[base2+32]:=volume
	mov	local11, local02
	add	local11, #32
	wrword	local04, local11
' word[base2+32]:=pan
	mov	local11, local02
	add	local11, #32
	wrword	local08, local11
' long[base2+36]:=((frequency*109)/1000)*3574 ' (frequency*389566)/1000  freq*3574*109/1000
	getqx	local11
	abs	local10, local11 wc
	qdiv	local10, ##1000
	getqx	local10
	negc	local10, local10
	qmul	local10, ##3574
	mov	local10, local02
	add	local10, #36
' long[base2+44]:=envelope
	mov	local11, local02
	add	local11, #44
' long[base2+48]:=length
' long[base2+52]:=sustain
' waitms(delay)
	mov	arg01, local03
	getqx	local08
	wrlong	local08, local10
	wrlong	local06, local11
	mov	local11, local02
	add	local11, #48
	wrlong	local07, local11
	add	local02, #52
	wrlong	local09, local02
	call	#__system___waitms
	mov	ptra, fp
	call	#popregs_
_Audio2_004_spin2_play_ret
	ret

' 
' 
' pub play16(channel,sample,splfreq,vol,len,loop,delay) | base2
_Audio2_004_spin2_play16
	qmul	arg03, ##389566
' 
' base2:=@channel0[0]+64*channel
	mov	arg03, objptr
	add	arg03, #12
	shl	arg01, #6
	add	arg03, arg01
' long[base2+20]:=sample+$C0000000 
	add	arg02, ##-1073741824
	mov	arg01, arg03
	add	arg01, #20
	wrlong	arg02, arg01
' long[base2+28]:= len
	mov	arg02, arg03
	add	arg02, #28
	wrlong	arg05, arg02
' long[base2+24]:= loop
	mov	arg05, arg03
	add	arg05, #24
	wrlong	arg06, arg05
' word[base2+32]:= vol
	mov	arg06, arg03
	add	arg06, #32
	wrword	arg04, arg06
' long[base2+36]:= splfreq*389566
	add	arg03, #36
' waitms(delay)
	mov	arg01, arg07
	getqx	arg07
	wrlong	arg07, arg03
	call	#__system___waitms
_Audio2_004_spin2_play16_ret
	ret

' 
' pub beep(channel,sample,splfreq,vol,len,loop,delay) | base2
_Audio2_004_spin2_beep
	qmul	arg03, ##1522
' 
' base2:=@channel0[0]+64*channel
	mov	arg03, objptr
	add	arg03, #12
	shl	arg01, #6
	add	arg03, arg01
' long[base2+20]:=sample+$C0000000 
	add	arg02, ##-1073741824
	mov	arg01, arg03
	add	arg01, #20
	wrlong	arg02, arg01
' long[base2+28]:= len
	mov	arg02, arg03
	add	arg02, #28
	wrlong	arg05, arg02
' long[base2+24]:= loop
	mov	arg05, arg03
	add	arg05, #24
	wrlong	arg06, arg05
' word[base2+32]:= vol
	mov	arg06, arg03
	add	arg06, #32
	wrword	arg04, arg06
' long[base2+36]:= splfreq*1522
	add	arg03, #36
' waitms(delay)
	mov	arg01, arg07
	getqx	arg07
	wrlong	arg07, arg03
	call	#__system___waitms
_Audio2_004_spin2_beep_ret
	ret
hubexit
	jmp	#cogexit

__system___setbaud
	rdlong	muldiva_, #20
	mov	muldivb_, arg01
	call	#divide_
	callpa	#(@LR__3071-@LR__3070)>>2,fcache_load_ptr_
LR__3070
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__3070
LR__3071
	dirl	#62
	dirl	#63
	wrlong	muldivb_, ptr___system__dat__
	shl	muldivb_, #16
	mov	arg02, #7
	add	arg02, muldivb_
	wrpin	#124, #62
	wxpin	arg02, #62
	wrpin	#62, #63
	add	arg02, #20
	wxpin	arg02, #63
	dirh	#62
	dirh	#63
__system___setbaud_ret
	ret

__system___txraw
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	callpa	#(@LR__3081-@LR__3080)>>2,fcache_load_ptr_
LR__3080
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__3080
LR__3081
	rdlong	result1, ptr___system__dat__ wz
 if_e	mov	arg01, ##2000000
 if_e	call	#__system___setbaud
	drvl	#62
	wypin	local01, #62
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___txraw_ret
	ret

__system___rxraw
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, ptr___system__dat__ wz
 if_e	mov	arg01, ##2000000
 if_e	call	#__system___setbaud
	cmp	local01, #0 wz
 if_e	jmp	#LR__3090
	rdlong	local03, #20
	shr	local03, #10
	qmul	local01, local03
	getct	result1
	getqx	local04
	add	result1, local04
	mov	local05, result1
	jmp	#LR__3091
LR__3090
	mov	local05, #0
LR__3091
	neg	local06, #1
	mov	local07, #63
	mov	local08, #0
	add	ptr___system__dat__, #4
	rdlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
LR__3092
	testb	local09, #8 wc
	testbn	local09, #9 andc
	shr	local09, #10
 if_b	mov	local08, #1
 if_ae	testp	#63 wz
 if_nc_and_z	mov	local08, #1
 if_nc_and_z	rdpin	local09, #63
 if_nc_and_z	shr	local09, #4
LR__3093
	mov	local02, #0
	cmp	local08, #0 wz
 if_ne	neg	local02, #1
	mov	local10, #0
	mov	local03, #0
	cmp	local01, #0 wz
 if_ne	neg	local03, #1
	mov	local04, #0
	mov	local11, #0
	mov	local12, local05
	getct	result1
	mov	local13, result1
	sub	local12, local13
	cmps	local12, #0 wc
 if_b	not	local11, #0
	cmp	local11, #0 wz
 if_ne	not	local04, #0
	test	local03, local04 wz
 if_ne	not	local10, #0
	or	local02, local10 wz
 if_e	jmp	#LR__3092
	cmp	local08, #0 wz
 if_ne	mov	local06, local09
 if_ne	getbyte	local06, local06, #0
	add	ptr___system__dat__, #4
	wrlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___rxraw_ret
	ret

__system___getus
	getct	result2 wc
	getct	_var01
	add	ptr___system__dat__, #16
	rdlong	_var02, ptr___system__dat__ wz
	sub	ptr___system__dat__, #16
 if_ne	jmp	#LR__3100
	rdlong	_var02, #20
	qdiv	_var02, ##1000000
	add	ptr___system__dat__, #16
	getqx	result1
	mov	_var02, result1
	wrlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #16
LR__3100
	qdiv	result2, _var02
	getqy	result2
	setq	result2
	qdiv	_var01, _var02
	getqx	result1
__system___getus_ret
	ret

__system____builtin_memmove
	mov	_var01, arg01
	cmps	arg01, arg02 wc
 if_b	jmp	#LR__3110
	mov	_var02, arg02
	add	_var02, arg03
	cmps	arg01, _var02 wc
 if_b	jmp	#LR__3116
LR__3110
	mov	_var03, arg03
	shr	_var03, #2 wz
 if_e	jmp	#LR__3115
	callpa	#(@LR__3113-@LR__3111)>>2,fcache_load_ptr_
LR__3111
	rep	@LR__3114, _var03
LR__3112
	rdlong	_var03, arg02
	wrlong	_var03, arg01
	add	arg01, #4
	add	arg02, #4
LR__3113
LR__3114
LR__3115
	test	arg03, #2 wz
 if_ne	rdword	_var02, arg02
 if_ne	wrword	_var02, arg01
 if_ne	add	arg01, #2
 if_ne	add	arg02, #2
	test	arg03, #1 wz
 if_ne	rdbyte	_var02, arg02
 if_ne	wrbyte	_var02, arg01
	jmp	#LR__3122
LR__3116
	add	arg01, arg03
	add	arg02, arg03
	mov	_var04, arg03 wz
 if_e	jmp	#LR__3121
	callpa	#(@LR__3119-@LR__3117)>>2,fcache_load_ptr_
LR__3117
	rep	@LR__3120, _var04
LR__3118
	sub	arg01, #1
	sub	arg02, #1
	rdbyte	_var02, arg02
	wrbyte	_var02, arg01
LR__3119
LR__3120
LR__3121
LR__3122
	mov	result1, _var01
__system____builtin_memmove_ret
	ret

__system__longmove
	mov	_var01, arg01
	cmps	arg01, arg02 wc
 if_ae	jmp	#LR__3134
	mov	_var02, arg03 wz
 if_e	jmp	#LR__3140
	callpa	#(@LR__3132-@LR__3130)>>2,fcache_load_ptr_
LR__3130
	rep	@LR__3133, _var02
LR__3131
	rdlong	_var02, arg02
	wrlong	_var02, arg01
	add	arg01, #4
	add	arg02, #4
LR__3132
LR__3133
	jmp	#LR__3140
LR__3134
	mov	_var02, arg03
	shl	_var02, #2
	add	arg01, _var02
	mov	_var03, arg03
	shl	_var03, #2
	add	arg02, _var03
	mov	_var04, arg03 wz
 if_e	jmp	#LR__3139
	callpa	#(@LR__3137-@LR__3135)>>2,fcache_load_ptr_
LR__3135
	rep	@LR__3138, _var04
LR__3136
	sub	arg01, #4
	sub	arg02, #4
	rdlong	_var04, arg02
	wrlong	_var04, arg01
LR__3137
LR__3138
LR__3139
LR__3140
	mov	result1, _var01
__system__longmove_ret
	ret

__system____builtin_strcpy
	mov	_var01, arg01
	callpa	#(@LR__3151-@LR__3150)>>2,fcache_load_ptr_
LR__3150
	rdbyte	result1, arg02 wz
	wrbyte	result1, arg01
	add	arg02, #1
	add	arg01, #1
 if_ne	jmp	#LR__3150
LR__3151
	mov	result1, _var01
__system____builtin_strcpy_ret
	ret

__system____topofstack
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	add	fp, #4
	wrlong	arg01, fp
	mov	result1, fp
	sub	fp, #4
	mov	ptra, fp
	call	#popregs_
__system____topofstack_ret
	ret

__system___lockmem
	mov	result1, #0
	cogid	result1
	add	result1, #256
LR__3160
	rdlong	_var01, arg01 wz
 if_e	wrlong	result1, arg01
 if_e	rdlong	_var01, arg01
 if_e	rdlong	_var01, arg01
	cmp	_var01, result1 wz
 if_ne	jmp	#LR__3160
__system___lockmem_ret
	ret

__system___string_cmp
	callpa	#(@LR__3171-@LR__3170)>>2,fcache_load_ptr_
LR__3170
	rdbyte	_var01, arg01
	rdbyte	_var02, arg02
	mov	_var03, _var01
	sub	_var03, _var02 wz
	add	arg01, #1
	add	arg02, #1
 if_ne	jmp	#LR__3172
	cmp	_var01, #0 wz
 if_ne	cmp	_var02, #0 wz
 if_ne	jmp	#LR__3170
LR__3171
LR__3172
	mov	result1, _var03
__system___string_cmp_ret
	ret

__system___string_concat
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__3181-@LR__3180)>>2,fcache_load_ptr_
LR__3180
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__3180
LR__3181
	sub	local03, arg01
	mov	local04, local03
	mov	arg01, local02
	mov	local03, arg01
	callpa	#(@LR__3183-@LR__3182)>>2,fcache_load_ptr_
LR__3182
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__3182
LR__3183
	sub	local03, arg01
	mov	arg01, local04
	add	arg01, local03
	add	arg01, #1
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__3184
	mov	arg01, local05
	mov	arg02, local01
	mov	arg03, local04
	call	#__system____builtin_memmove
	mov	arg01, local05
	add	arg01, local04
	add	local03, #1
	mov	arg02, local02
	mov	arg03, local03
	call	#__system____builtin_memmove
LR__3184
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
__system___string_concat_ret
	ret

__system___tx
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	cmp	local01, #10 wz
 if_ne	jmp	#LR__3190
	add	ptr___system__dat__, #8
	rdlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	local02, #2 wz
 if_ne	mov	arg01, #13
 if_ne	call	#__system___txraw
LR__3190
	mov	arg01, local01
	call	#__system___txraw
	mov	ptra, fp
	call	#popregs_
__system___tx_ret
	ret

__system___rx
	mov	COUNT_, #1
	call	#pushregs_
LR__3200
	mov	arg01, #0
	call	#__system___rxraw
	mov	local01, result1
	cmp	local01, ##-1 wz
 if_e	jmp	#LR__3200
	cmp	local01, #13 wz
 if_ne	jmp	#LR__3201
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	result1, #2 wz
 if_ne	mov	local01, #10
LR__3201
	add	ptr___system__dat__, #8
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	arg01, #1 wz
 if_e	jmp	#LR__3204
	cmp	local01, #127 wz
 if_ne	jmp	#LR__3202
	mov	arg01, #8
	call	#__system___tx
	jmp	#LR__3203
LR__3202
	mov	arg01, local01
	call	#__system___tx
LR__3203
LR__3204
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system___rx_ret
	ret

__system___pinwrite
	mov	_var01, arg01
	and	_var01, #31
	test	arg01, #32 wz
	shr	arg01, #6
	bmask	arg01, arg01
	shl	arg01, _var01
	shl	arg02, _var01
 if_e	jmp	#LR__3210
	or	dirb, arg01
	mov	_var01, outb
	andn	_var01, arg01
	and	arg02, arg01
	or	_var01, arg02
	mov	outb, _var01
	jmp	#LR__3211
LR__3210
	or	dira, arg01
	mov	_var01, outa
	andn	_var01, arg01
	and	arg02, arg01
	or	_var01, arg02
	mov	outa, _var01
LR__3211
__system___pinwrite_ret
	ret

__system___basic_read_line
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	mov	local03, #24
	mov	local04, #0
	mov	arg01, #24
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__3223
LR__3220
	mov	arg01, local01
	call	#__system___basic_get_char
	mov	local06, result1
	cmps	local06, #1 wc
 if_b	jmp	#LR__3222
	cmp	local06, #10 wz
 if_ne	jmp	#LR__3221
	cmp	local04, #0 wz
 if_ne	cmps	local02, #1 wc
 if_a	sub	local02, #1
	jmp	#LR__3222
LR__3221
	cmp	local06, #13 wz
 if_e	mov	local04, #1
 if_ne	mov	local04, #0
	cmp	local06, #8 wz
 if_ne	cmp	local06, #127 wz
 if_e	cmps	local02, #1 wc
 if_nc_and_z	sub	local02, #1
 if_e	jmp	#LR__3220
	mov	arg03, local05
	add	arg03, local02
	wrbyte	local06, arg03
	add	local02, #1
	cmp	local02, local03 wz
 if_ne	jmp	#LR__3220
	mov	arg01, local03
	add	arg01, #32
	call	#__system___gc_alloc_managed
	mov	local06, result1 wz
 if_e	mov	result1, local06
 if_e	jmp	#LR__3223
	mov	arg01, local06
	mov	arg02, local05
	mov	arg03, local03
	call	#__system____builtin_memmove
	add	local03, #32
	mov	arg01, local05
	call	#__system___gc_free
	mov	local05, local06
	jmp	#LR__3220
LR__3222
	mov	local06, local05
	add	local06, local02
	wrbyte	#0, local06
	mov	result1, local05
LR__3223
	mov	ptra, fp
	call	#popregs_
__system___basic_read_line_ret
	ret

__system___waitms
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__3231-@LR__3230)>>2,fcache_load_ptr_
LR__3230
	cmps	_var01, ##1000 wc
 if_b	jmp	#LR__3232
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000
	jmp	#LR__3230
LR__3231
LR__3232
	cmps	_var01, #1 wc
 if_b	jmp	#LR__3233
	qmul	_var01, _var03
	mov	arg03, ##1000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	arg01
	addct1	arg01, _var02
	waitct1
LR__3233
__system___waitms_ret
	ret

__system___waitus
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__3241-@LR__3240)>>2,fcache_load_ptr_
LR__3240
	cmps	_var01, ##1000000 wc
 if_b	jmp	#LR__3242
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000000
	jmp	#LR__3240
LR__3241
LR__3242
	cmps	_var01, #1 wc
 if_b	jmp	#LR__3243
	qmul	_var01, _var03
	mov	arg03, ##1000000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	result1
	addct1	_var02, result1
	waitct1
LR__3243
__system___waitus_ret
	ret

__system___mount
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	neg	local03, #1
 if_e	neg	result1, #1
 if_e	jmp	#LR__3265
	rdbyte	result1, local01
	cmp	result1, #47 wz
 if_ne	jmp	#LR__3252
	mov	arg01, local01
	mov	local04, arg01
	callpa	#(@LR__3251-@LR__3250)>>2,fcache_load_ptr_
LR__3250
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3250
LR__3251
	sub	local04, arg01
	mov	result1, local04
	cmps	result1, #16 wc
 if_b	jmp	#LR__3253
LR__3252
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__3265
LR__3253
	mov	local05, #0
LR__3254
	cmps	local05, #4 wc
 if_ae	jmp	#LR__3259
	mov	arg01, local05
	shl	arg01, #2
	mov	result1, ptr___system__dat__
	add	result1, #100
	add	arg01, result1
	rdlong	result1, arg01 wz
 if_e	cmps	local03, #0 wc
 if_c_and_z	mov	local03, local05
 if_c_and_z	jmp	#LR__3258
	mov	arg01, local05
	shl	arg01, #2
	mov	local04, ptr___system__dat__
	add	local04, #100
	add	arg01, local04
	rdlong	arg01, arg01
	mov	local04, arg01
	callpa	#(@LR__3256-@LR__3255)>>2,fcache_load_ptr_
LR__3255
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3255
LR__3256
	sub	local04, arg01
	mov	result1, local04
	mov	local06, result1
	mov	arg01, local06
	add	arg01, local01
	rdbyte	local04, arg01
	cmp	local04, #47 wz
 if_ne	mov	local07, local06
 if_ne	add	local07, local01
 if_ne	rdbyte	arg01, local07 wz
 if_ne	jmp	#LR__3257
	mov	local04, local05
	shl	local04, #2
	mov	arg03, ptr___system__dat__
	add	arg03, #100
	add	local04, arg03
	rdlong	arg02, local04
	mov	arg01, local01
	mov	arg03, local06
	call	#__system__strncmp
	cmp	result1, #0 wz
 if_e	mov	local03, local05
 if_e	jmp	#LR__3259
LR__3257
LR__3258
	add	local05, #1
	jmp	#LR__3254
LR__3259
	cmp	local03, ##-1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#11, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__3265
	mov	local05, local03
	mov	local07, local05
	shl	local07, #2
	mov	local06, ptr___system__dat__
	add	local06, #116
	add	local07, local06
	rdlong	local06, local07 wz
 if_e	jmp	#LR__3260
	add	local06, #76
	rdlong	local07, local06 wz
	sub	local06, #76
 if_e	jmp	#LR__3260
	add	local06, #76
	rdlong	local07, local06
	mov	local04, local07
	zerox	local07, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	local06, local05
	shl	local06, #2
	mov	local03, ptr___system__dat__
	add	local03, #100
	add	local06, local03
	rdlong	arg01, local06
	mov	local06, objptr
	mov	objptr, local07
	call	local04
	mov	objptr, local06
LR__3260
	mov	local06, local05
	shl	local06, #2
	mov	local07, ptr___system__dat__
	add	local07, #116
	add	local06, local07
	wrlong	local02, local06
	cmp	local02, #0 wz
 if_ne	jmp	#LR__3261
	shl	local05, #2
	mov	local07, ptr___system__dat__
	add	local07, #100
	add	local05, local07
	wrlong	#0, local05
	jmp	#LR__3264
LR__3261
	mov	local08, local05
	shl	local08, #4
	mov	local07, ptr___system__dat__
	add	local07, #36
	add	local08, local07
	mov	arg01, local08
	mov	arg02, local01
	mov	arg03, #16
	call	#__system__strncpy
	add	local02, #72
	rdlong	local07, local02 wz
	sub	local02, #72
 if_e	jmp	#LR__3263
	add	local02, #72
	rdlong	local07, local02
	mov	local09, local07
	zerox	local07, #19
	shr	local09, #20
	shl	local09, #2
	add	local09, __methods__
	rdlong	local09, local09
	mov	arg01, local08
	mov	local06, objptr
	mov	objptr, local07
	call	local09
	mov	objptr, local06
	mov	arg01, result1 wz
 if_e	jmp	#LR__3262
	mov	local08, local05
	shl	local08, #2
	add	ptr___system__dat__, #116
	add	local08, ptr___system__dat__
	wrlong	#0, local08
	shl	local05, #2
	sub	ptr___system__dat__, #16
	add	local05, ptr___system__dat__
	wrlong	#0, local05
	neg	arg01, arg01 wz
	sub	ptr___system__dat__, #68
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__3265
LR__3262
LR__3263
	shl	local05, #2
	mov	local07, ptr___system__dat__
	add	local07, #100
	add	local05, local07
	wrlong	local08, local05
LR__3264
	mov	result1, #0
LR__3265
	mov	ptra, fp
	call	#popregs_
__system___mount_ret
	ret

__system___chdir
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #68
	mov	local01, arg01
	mov	arg02, fp
	add	arg02, #8
	mov	arg01, local01
	call	#__system__stat
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3272
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	and	arg01, ##61440
	cmp	arg01, ##4096 wz
 if_ne	add	ptr___system__dat__, #32
 if_ne	wrlong	#13, ptr___system__dat__
 if_ne	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__3272
	rdbyte	arg03, local01
	cmp	arg03, #47 wz
 if_ne	jmp	#LR__3270
	mov	arg01, ptr___system__dat__
	add	arg01, #132
	mov	arg02, local01
	mov	arg03, #256
	call	#__system__strncpy
	jmp	#LR__3271
LR__3270
	mov	local02, ptr___system__dat__
	add	local02, #388
	mov	arg02, ptr___system__dat__
	add	arg02, #132
	mov	arg01, local02
	mov	arg03, #256
	call	#__system__strncpy
	mov	arg03, ptr___system__dat__
	add	arg03, #132
	mov	arg01, local02
	mov	arg02, local01
	call	#__system____getvfsforfile
LR__3271
	mov	result1, #0
LR__3272
	mov	ptra, fp
	call	#popregs_
__system___chdir_ret
	ret

__system____getvfsforfile
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	callpa	#(@LR__3281-@LR__3280)>>2,fcache_load_ptr_
LR__3280
	rdbyte	result1, local02
	cmp	result1, #47 wz
 if_e	add	local02, #1
 if_e	rdbyte	local04, local02
 if_e	sub	local02, #1
 if_e	cmp	local04, #47 wz
 if_e	add	local02, #1
 if_e	jmp	#LR__3280
LR__3281
	rdbyte	local04, local02
	cmp	local04, #47 wz
 if_ne	jmp	#LR__3282
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncpy
	jmp	#LR__3284
LR__3282
	mov	arg02, ptr___system__dat__
	add	arg02, #132
	mov	arg01, local01
	mov	arg03, #256
	call	#__system__strncpy
	rdbyte	local04, local02 wz
 if_e	jmp	#LR__3283
	rdbyte	local04, local02
	cmp	local04, #46 wz
 if_e	add	local02, #1
 if_e	rdbyte	local05, local02
 if_e	sub	local02, #1
 if_e	mov	local06, local05
 if_e	zerox	local06, #7 wz
 if_e	jmp	#LR__3283
	rdbyte	local05, local01
	cmp	local05, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local04, local01
 if_e	sub	local01, #1
 if_e	cmps	local04, #0 wz
 if_ne	mov	arg02, ##@LR__5460
 if_ne	mov	arg01, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncat
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncat
LR__3283
LR__3284
	mov	arg01, local01
	call	#__system___normalizeName
	rdbyte	local04, local01 wz
 if_e	jmp	#LR__3285
	rdbyte	local04, local01
	cmp	local04, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local06, local01
 if_e	sub	local01, #1
 if_e	cmps	local06, #0 wz
 if_ne	jmp	#LR__3286
LR__3285
	mov	result1, ptr___system__dat__
	add	result1, ##644
	jmp	#LR__3300
LR__3286
	mov	local07, #0
LR__3287
	cmps	local07, #4 wc
 if_ae	jmp	#LR__3299
	mov	local06, local07
	shl	local06, #2
	mov	local04, ptr___system__dat__
	add	local04, #100
	add	local06, local04
	rdlong	local06, local06 wz
 if_e	jmp	#LR__3298
	mov	local04, local07
	shl	local04, #2
	mov	local06, ptr___system__dat__
	add	local06, #100
	add	local04, local06
	rdlong	arg01, local04
	mov	local08, arg01
	callpa	#(@LR__3289-@LR__3288)>>2,fcache_load_ptr_
LR__3288
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__3288
LR__3289
	sub	local08, arg01
	mov	local09, local08
	mov	local04, local09
	add	local04, local01
	rdbyte	local06, local04
	cmp	local06, #47 wz
 if_ne	mov	local10, local09
 if_ne	add	local10, local01
 if_ne	rdbyte	local05, local10 wz
 if_ne	jmp	#LR__3297
	mov	local04, local07
	shl	local04, #2
	mov	arg03, ptr___system__dat__
	add	arg03, #100
	add	local04, arg03
	rdlong	arg02, local04
	mov	arg03, local09
	mov	arg01, local01
	call	#__system__strncmp
	cmps	result1, #0 wz
 if_ne	jmp	#LR__3297
	mov	local11, local07
	shl	local11, #2
	mov	local04, ptr___system__dat__
	add	local04, #116
	add	local11, local04
	rdlong	local12, local11
	callpa	#(@LR__3291-@LR__3290)>>2,fcache_load_ptr_
LR__3290
	mov	local06, local09
	add	local06, #1
	add	local06, local01
	rdbyte	local11, local06
	cmp	local11, #46 wz
 if_ne	jmp	#LR__3292
	mov	local11, local09
	add	local11, #2
	add	local11, local01
	rdbyte	local10, local11
	cmp	local10, #47 wz
 if_ne	mov	local13, local09
 if_ne	add	local13, #2
 if_ne	add	local13, local01
 if_ne	rdbyte	local14, local13 wz
 if_e	add	local09, #1
 if_e	jmp	#LR__3290
LR__3291
LR__3292
	cmp	local03, #0 wz
 if_ne	mov	arg01, local03
 if_ne	mov	arg02, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncpy
	mov	arg02, local01
	add	arg02, local09
	add	arg02, #1
	mov	arg01, local01
	call	#__system____builtin_strcpy
	mov	arg01, local01
	mov	local08, arg01
	callpa	#(@LR__3294-@LR__3293)>>2,fcache_load_ptr_
LR__3293
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__3293
LR__3294
	sub	local08, arg01
	mov	local09, local08
LR__3295
	cmps	local09, #1 wc
 if_b	jmp	#LR__3296
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #47 wz
 if_e	mov	local11, local09
 if_e	add	local11, local01
 if_e	wrbyte	#0, local11
 if_e	sub	local09, #1
 if_e	jmp	#LR__3295
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #46 wz
 if_ne	jmp	#LR__3296
	cmps	local09, #2 wc
 if_b	jmp	#LR__3296
	mov	local14, local09
	sub	local14, #1
	add	local14, local01
	rdbyte	local05, local14
	cmp	local05, #47 wz
 if_ne	jmp	#LR__3296
	mov	local04, local09
	sub	local04, #1
	add	local04, local01
	wrbyte	#0, local04
	sub	local09, #2
	jmp	#LR__3295
LR__3296
	mov	result1, local12
	jmp	#LR__3300
LR__3297
LR__3298
	add	local07, #1
	jmp	#LR__3287
LR__3299
	add	ptr___system__dat__, ##1320
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, ##1320
LR__3300
	mov	ptra, fp
	call	#popregs_
__system____getvfsforfile_ret
	ret

__system___basic_open
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	mov	local04, #0
	call	#__system____getftab
	mov	local05, result1 wz
 if_ne	jmp	#LR__3310
	mov	arg01, abortchain
	mov	arg02, #12
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__3319
LR__3310
	add	local05, #8
	rdlong	result1, local05 wz
	sub	local05, #8
 if_ne	mov	arg01, local05
 if_ne	call	#__system___closeraw
	cmp	local01, #0 wz
 if_e	cmp	local02, #0 wz
 if_e	cmp	local03, #0 wz
 if_e	jmp	#LR__3312
	mov	arg01, #12
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_ne	jmp	#LR__3311
	mov	arg01, abortchain
	mov	arg02, #7
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__3319
LR__3311
	wrlong	#0, local04
	add	local04, #4
	wrlong	#0, local04
	sub	local04, #4
	wrlong	local04, local05
LR__3312
	cmp	local01, #0 wz
 if_e	jmp	#LR__3313
	wrlong	local01, local04
	mov	result1, local04
	or	result1, ##182452224
	add	local05, #28
	wrlong	result1, local05
	sub	local05, #28
	jmp	#LR__3314
LR__3313
	add	local05, #28
	wrlong	#0, local05
	sub	local05, #28
LR__3314
	cmp	local02, #0 wz
 if_e	jmp	#LR__3315
	add	local04, #4
	wrlong	local02, local04
	sub	local04, #4
	mov	result1, local04
	or	result1, ##183500800
	add	local05, #32
	wrlong	result1, local05
	sub	local05, #32
	jmp	#LR__3316
LR__3315
	add	local05, #32
	wrlong	#0, local05
	sub	local05, #32
LR__3316
	cmp	local03, #0 wz
 if_e	jmp	#LR__3317
	add	local04, #8
	wrlong	local03, local04
	sub	local04, #8
	or	local04, ##184549376
	add	local05, #36
	wrlong	local04, local05
	sub	local05, #36
	jmp	#LR__3318
LR__3317
	add	local05, #36
	wrlong	#0, local05
	sub	local05, #36
LR__3318
	add	local05, #8
	wrlong	##32771, local05
	mov	result1, #0
LR__3319
	mov	ptra, fp
	call	#popregs_
__system___basic_open_ret
	ret

__system___basic_open_string
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	call	#__system____getftab
	mov	local03, result1 wz
 if_ne	jmp	#LR__3320
	mov	arg01, abortchain
	mov	arg02, #12
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__3322
LR__3320
	add	local03, #8
	rdlong	arg04, local03 wz
	sub	local03, #8
 if_ne	mov	arg01, local03
 if_ne	call	#__system___closeraw
	mov	arg02, local01
	mov	arg03, local02
	mov	arg01, local03
	mov	arg04, #438
	call	#__system___openraw
	mov	local04, result1
	cmps	local04, #0 wc
 if_ae	jmp	#LR__3321
	mov	result1, ptr___system__dat__
	add	result1, #32
	mov	arg01, abortchain
	rdlong	arg02, result1
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__3322
LR__3321
	mov	result1, local04
LR__3322
	mov	ptra, fp
	call	#popregs_
__system___basic_open_string_ret
	ret

__system___find_free_file
	mov	_var01, ptr___system__dat__
	add	_var01, ##1324
	mov	_var02, #0
	callpa	#(@LR__3331-@LR__3330)>>2,fcache_load_ptr_
LR__3330
	cmps	_var02, #10 wc
 if_ae	jmp	#LR__3332
	qmul	_var02, #52
	getqx	result1
	add	result1, _var01
	add	result1, #8
	rdlong	result1, result1 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__3330
LR__3331
LR__3332
	cmp	_var02, #10 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#11, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_ne	mov	result1, _var02
__system___find_free_file_ret
	ret

__system___basic_print_char
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	call	#__system___gettxfunc
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3340
	mov	local03, local02
	zerox	local02, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local02
	call	local03
	mov	objptr, local01
	mov	result1, #1
LR__3340
	mov	ptra, fp
	call	#popregs_
__system___basic_print_char_ret
	ret

__system___basic_print_string
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	call	#__system___gettxfunc
	mov	local03, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3350
	cmp	local01, #0 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local03
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	call	#__system___fmtstr
LR__3350
	mov	ptra, fp
	call	#popregs_
__system___basic_print_string_ret
	ret

__system___basic_print_integer
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	call	#__system___gettxfunc
	mov	local04, result1 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local04
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	mov	arg04, local03
 if_ne	call	#__system___fmtnum
	mov	ptra, fp
	call	#popregs_
__system___basic_print_integer_ret
	ret

__system___basic_print_unsigned
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	call	#__system___gettxfunc
	mov	arg01, result1 wz
 if_e	mov	result1, #0
 if_ne	bith	local02, #58
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	mov	arg04, local03
 if_ne	call	#__system___fmtnum
	mov	ptra, fp
	call	#popregs_
__system___basic_print_unsigned_ret
	ret

__system___basic_get_char
	mov	COUNT_, #3
	call	#pushregs_
	call	#__system___getrxfunc
	mov	local01, result1 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__3360
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
LR__3360
	mov	ptra, fp
	call	#popregs_
__system___basic_get_char_ret
	ret

__system___basic_put
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg05
	qmul	arg04, local01
	mov	local02, arg01
	mov	local03, arg03
	cmp	arg02, #0 wz
	getqx	local04
 if_e	jmp	#LR__3370
	sub	arg02, #1
	mov	arg03, arg02
	sar	arg03, #31
	mov	arg01, local02
	mov	arg04, #0
	call	#__system__lseek
LR__3370
	mov	arg02, local03
	mov	arg03, local04
	mov	arg01, local02
	call	#__system__write
	mov	local04, result1
	cmps	local04, #1 wc
 if_b	jmp	#LR__3371
	mov	muldiva_, local04
	mov	muldivb_, local01
	call	#divide_
	mov	local04, muldivb_
LR__3371
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
__system___basic_put_ret
	ret

__system___basic_get
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg05
	qmul	arg04, local01
	mov	local02, arg01
	mov	local03, arg03
	cmp	arg02, #0 wz
	getqx	local04
 if_e	jmp	#LR__3380
	sub	arg02, #1
	mov	arg03, arg02
	sar	arg03, #31
	mov	arg01, local02
	mov	arg04, #0
	call	#__system__lseek
LR__3380
	mov	arg02, local03
	mov	arg03, local04
	mov	arg01, local02
	call	#__system__read
	mov	local04, result1
	cmps	local04, #1 wc
 if_b	jmp	#LR__3381
	mov	muldiva_, local04
	mov	muldivb_, local01
	call	#divide_
	mov	local04, muldivb_
LR__3381
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
__system___basic_get_ret
	ret

__system___fmtchar
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #12
	wrlong	arg03, fp
	getbyte	arg03, arg03, #0
	wrlong	arg03, fp
	mov	arg03, fp
	sub	fp, #12
	call	#__system___fmtstr
	mov	ptra, fp
	call	#popregs_
__system___fmtchar_ret
	ret

__system___fmtstr
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg04, local02, #0
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__3391-@LR__3390)>>2,fcache_load_ptr_
LR__3390
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3390
LR__3391
	sub	local04, arg01
	cmp	arg04, #0 wz
 if_ne	fles	local04, arg04 wcz
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #2
	call	#__system___fmtpad
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	mov	result1, local05
 if_b	jmp	#LR__3394
	cmps	local04, #1 wc
 if_b	jmp	#LR__3393
	mov	local06, local04
LR__3392
	mov	local07, local01
	mov	local08, local01
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	rdbyte	arg01, local03
	mov	local09, objptr
	mov	objptr, local07
	add	local03, #1
	call	local08
	mov	objptr, local09
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_b	jmp	#LR__3394
	add	local05, local09
	djnz	local06, #LR__3392
LR__3393
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #1
	call	#__system___fmtpad
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_ae	add	local05, local09
 if_ae	mov	result1, local05
LR__3394
	mov	ptra, fp
	call	#popregs_
__system___fmtstr_ret
	ret

__system___fmtnum
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, ptra
	mov	local06, local05
	mov	local07, #0
	mov	local08, local02
	shr	local08, #16
	and	local08, #63
	getbyte	local09, local02, #0
	mov	local10, local02
	shr	local10, #26
	and	local10, #3
	mov	local11, local10
	cmps	local08, #1 wc
	add	ptra, #68
 if_ae	sub	local08, #1
	cmps	local09, #65 wc
 if_b	cmp	local09, #0 wz
 if_nc_or_z	mov	local09, #64
	cmp	local11, #3 wz
 if_e	mov	local11, #0
 if_ne	cmps	local03, #0 wc
 if_c_and_nz	mov	local11, #4
 if_c_and_nz	neg	local03, local03
	cmp	local11, #0 wz
 if_e	jmp	#LR__3403
	mov	local07, #1
	cmp	local08, local09 wz
 if_ne	jmp	#LR__3401
	djnz	local08, #LR__3400
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #35
	call	#__system___fmtchar
	jmp	#LR__3407
LR__3400
LR__3401
	cmp	local11, #2 wz
 if_e	mov	local10, local06
 if_e	add	local06, #1
 if_e	wrbyte	#32, local10
 if_e	jmp	#LR__3402
	cmp	local11, #4 wz
 if_e	wrbyte	#45, local06
 if_e	add	local06, #1
 if_ne	wrbyte	#43, local06
 if_ne	add	local06, #1
LR__3402
LR__3403
	mov	local10, local07
	mov	arg01, local06
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local08
	mov	arg05, #0
	testbn	local02, #29 wz
 if_ne	mov	arg05, #1
	call	#__system___uitoa
	add	local10, result1
	cmps	local10, local09 wcz
 if_be	jmp	#LR__3406
	callpa	#(@LR__3405-@LR__3404)>>2,fcache_load_ptr_
LR__3404
	mov	local10, local09
	cmps	local10, #1 wc
	sub	local09, #1
 if_ae	mov	local10, local06
 if_ae	add	local06, #1
 if_ae	wrbyte	#35, local10
 if_ae	jmp	#LR__3404
LR__3405
	wrbyte	#0, local06
LR__3406
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local05
	call	#__system___fmtstr
LR__3407
	mov	ptra, fp
	call	#popregs_
__system___fmtnum_ret
	ret

__system___fmtfloat
	mov	COUNT_, #41
	call	#pushregs_
	add	ptra, #292
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, #10
	mov	local06, #0
	mov	local07, #0
	mov	local08, #2
	mov	local09, #0
	mov	local10, #0
	mov	local11, #0
	mov	local12, fp
	add	local12, #200
	mov	local13, local12
	mov	local14, local02
	shr	local14, #16
	and	local14, #63 wz
	mov	local15, local02
	shr	local15, #28
	and	local15, #1
 if_ne	jmp	#LR__3410
	cmp	local04, #97 wz
 if_e	mov	local14, #13
 if_e	mov	local07, #1
 if_e	jmp	#LR__3411
	mov	local14, #6
	jmp	#LR__3411
LR__3410
	sub	local14, #1
LR__3411
	mov	local16, local02
	shr	local16, #22
	and	local16, #3
	mov	local17, local02
	shr	local17, #29
	and	local17, #1
	getbyte	local18, local02, #1
	getbyte	local19, local02, #0
	cmp	local04, #101 wz
	wrz	local20
	mov	local21, local20
	cmp	local17, #0 wz
 if_ne	mov	local20, #69
 if_e	mov	local20, #101
	mov	local22, local20
	cmp	local04, #97 wz
 if_ne	jmp	#LR__3412
	mov	local21, #1
	cmp	local17, #0 wz
 if_ne	mov	local20, #80
 if_e	mov	local20, #112
	mov	local22, local20
	mov	local05, #2
	mov	local08, #1
	cmp	local17, #0 wz
 if_ne	mov	local20, #88
 if_e	mov	local20, #120
	mov	local09, local20
LR__3412
	cmp	local04, #35 wz
 if_ne	jmp	#LR__3413
	mov	local10, #1
	cmp	local15, #0 wz
 if_ne	mov	local04, #102
 if_ne	mov	local15, #0
 if_e	mov	local15, #1
LR__3413
	mov	local23, local02
	shr	local23, #26
	and	local23, #3
	mov	result1, local03
	shr	result1, #31 wz
 if_ne	mov	local06, #45
 if_ne	bitnot	local03, #31
 if_ne	jmp	#LR__3415
	cmp	local23, #1 wz
 if_e	mov	local06, #43
 if_e	jmp	#LR__3414
	cmp	local23, #2 wz
 if_e	mov	local06, #32
LR__3414
LR__3415
	mov	local24, local02
	shr	local24, #24
	and	local24, #3
	mov	local20, #0
	cmp	local06, #0 wz
 if_e	cmp	local05, #10 wz
 if_ne	mov	local20, #1
	mov	local25, local20 wz
 if_e	jmp	#LR__3417
	cmp	local24, #2 wz
 if_ne	jmp	#LR__3417
	cmp	local16, #2 wz
 if_e	jmp	#LR__3417
	mov	arg02, local06
	mov	local26, local09
	mov	arg01, local12
	mov	arg03, local26
	call	#__system__emitsign_0584
	mov	local27, result1
	cmps	local27, #0 wc
 if_b	mov	result1, local27
 if_b	jmp	#LR__3460
	mov	local28, local27
	add	local12, local27
	cmp	local18, #0 wz
 if_e	jmp	#LR__3416
	sub	local18, local27
	fges	local18, #0 wc
	bitl	local02, #232
	mov	local28, local18
	shl	local28, #8
	or	local02, local28
LR__3416
	mov	local25, #0
LR__3417
	mov	arg01, local03
	call	#__system____builtin_ilogb
	cmp	result1, ##2147483647 wz
 if_ne	jmp	#LR__3418
	cmp	local06, #0 wz
 if_ne	mov	local20, local12
 if_ne	add	local12, #1
 if_ne	wrbyte	local06, local20
	mov	arg02, ##@LR__5461
	mov	arg01, local12
	call	#__system____builtin_strcpy
	jmp	#LR__3450
LR__3418
	mov	arg01, local03
	call	#__system____builtin_ilogb
	mov	local20, result1
	cmp	local20, ##-2147483648 wz
 if_ne	jmp	#LR__3419
	cmp	local06, #0 wz
 if_ne	mov	local20, local12
 if_ne	add	local12, #1
 if_ne	wrbyte	local06, local20
	mov	arg01, local12
	mov	arg02, ##@LR__5462
	call	#__system____builtin_strcpy
	jmp	#LR__3450
LR__3419
	cmp	local04, #103 wz
 if_ne	cmp	local04, #35 wz
 if_ne	jmp	#LR__3424
	add	fp, #20
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	sub	fp, #32
	mov	arg04, local14
	mov	arg05, local05
	mov	arg01, local03
	call	#__system__disassemble_0582
	cmp	local04, #35 wz
 if_ne	jmp	#LR__3421
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, local14 wcz
 if_a	mov	local21, #1
 if_a	jmp	#LR__3427
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, #0 wc
 if_ae	jmp	#LR__3420
	neg	local20, local14
	add	fp, #32
	rdlong	local28, fp
	sub	fp, #32
	cmps	local28, local20 wcz
 if_be	mov	local21, #1
	jmp	#LR__3427
LR__3420
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, #1 wc
 if_ae	add	fp, #32
 if_ae	rdlong	local28, fp
 if_ae	sub	fp, #32
 if_ae	sub	local14, local28
	jmp	#LR__3427
LR__3421
	mov	local07, #0
	testbn	local02, #28 wz
 if_e	mov	local07, #1
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, local14 wc
 if_ae	jmp	#LR__3422
	add	fp, #32
	rdlong	local26, fp
	sub	fp, #32
	cmps	local26, ##-4 wc
 if_ae	jmp	#LR__3423
LR__3422
	mov	local21, #1
	jmp	#LR__3427
LR__3423
	add	fp, #32
	rdlong	local28, fp
	sub	local14, local28
	sub	fp, #12
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	sub	fp, #32
	neg	arg04, local14
	mov	arg01, local03
	mov	arg05, local05
	call	#__system__disassemble_0582
	jmp	#LR__3427
LR__3424
	cmp	local21, #0 wz
 if_e	jmp	#LR__3425
	add	fp, #20
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	sub	fp, #32
	mov	arg01, local03
	mov	arg04, local14
	mov	arg05, local05
	call	#__system__disassemble_0582
	jmp	#LR__3426
LR__3425
	add	fp, #20
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	sub	fp, #32
	mov	local28, local14
	add	local28, #1
	neg	arg04, local28
	mov	arg01, local03
	mov	arg05, local05
	call	#__system__disassemble_0582
LR__3426
LR__3427
	cmp	local05, #2 wz
 if_ne	jmp	#LR__3430
	mov	local05, #16
LR__3428
	add	fp, #20
	rdlong	local20, fp wz
	sub	fp, #20
 if_e	jmp	#LR__3429
	add	fp, #20
	rdlong	local26, fp
	sub	fp, #20
	cmp	local26, ##16777216 wc
 if_ae	jmp	#LR__3429
	add	fp, #20
	rdlong	local20, fp
	shl	local20, #1
	wrlong	local20, fp
	sub	fp, #20
	jmp	#LR__3428
LR__3429
LR__3430
	add	fp, #112
	mov	arg01, fp
	sub	fp, #92
	rdlong	arg02, fp
	sub	fp, #20
	mov	arg03, local05
	mov	arg04, #1
	mov	arg05, local17
	call	#__system___uitoa
	mov	local29, result1
	add	fp, #32
	rdlong	local20, fp
	sub	fp, #32
	cmps	local20, #0 wc
 if_ae	jmp	#LR__3431
	mov	local11, #45
	add	fp, #176
	mov	arg01, fp
	sub	fp, #144
	rdlong	local26, fp
	sub	fp, #32
	neg	local28, local26
	mov	local26, #10
	mov	local30, local08
	mov	local31, local17
	mov	arg02, local28
	mov	arg03, #10
	mov	arg04, local30
	mov	arg05, local31
	call	#__system___uitoa
	mov	local32, result1
	jmp	#LR__3432
LR__3431
	mov	local11, #43
	add	fp, #176
	mov	arg01, fp
	sub	fp, #144
	rdlong	local28, fp
	sub	fp, #32
	mov	local26, #10
	mov	local30, local08
	mov	local31, local17
	mov	arg02, local28
	mov	arg03, #10
	mov	arg04, local30
	mov	arg05, local31
	call	#__system___uitoa
	mov	local32, result1
LR__3432
	cmp	local21, #0 wz
 if_ne	mov	local33, #0
 if_ne	mov	local34, #0
 if_ne	mov	local35, local14
 if_ne	add	local35, #1
 if_ne	jmp	#LR__3435
	add	fp, #32
	rdlong	local28, fp
	sub	fp, #32
	cmps	local28, #0 wc
 if_ae	jmp	#LR__3433
	add	fp, #32
	rdlong	local28, fp
	mov	local33, local28
	mov	local34, local33
	sub	fp, #32
	mov	local35, local28
	add	local35, local14
	add	local35, #1
	jmp	#LR__3434
LR__3433
	mov	local34, #0
	add	fp, #32
	rdlong	local33, fp
	sub	fp, #32
	mov	local35, local33
	add	local35, local14
	add	local35, #1
LR__3434
LR__3435
	mov	local20, local35
	sub	local20, local34
	add	local20, #1
	mov	local36, local20
	cmp	local06, #0 wz
 if_ne	mov	local20, local36
 if_ne	mov	local28, local36
 if_ne	add	local28, #1
 if_ne	mov	local36, local28
	cmp	local05, #16 wz
 if_e	add	local36, #2
	cmp	local21, #0 wz
 if_ne	mov	local28, #2
 if_ne	add	local28, local32
 if_ne	add	local36, local28
	cmps	local36, #65 wc
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__3460
	cmp	local25, #0 wz
 if_e	jmp	#LR__3436
	mov	arg02, local06
	mov	arg01, local12
	mov	arg03, local09
	call	#__system__emitsign_0584
	mov	local37, result1
	cmps	local37, #0 wc
 if_b	mov	result1, local37
 if_b	jmp	#LR__3460
	mov	local28, local37
	add	local12, local37
LR__3436
	mov	local38, local34
	callpa	#(@LR__3441-@LR__3437)>>2,fcache_load_ptr_
LR__3437
	cmps	local38, local35 wc
 if_ae	jmp	#LR__3442
	cmps	local38, #0 wc
 if_b	jmp	#LR__3438
	cmps	local38, local29 wc
 if_ae	jmp	#LR__3438
	mov	local20, local12
	mov	local26, local38
	mov	local30, fp
	add	local30, #112
	add	local26, local30
	rdbyte	local31, local26
	wrbyte	local31, local20
	add	local12, #1
	jmp	#LR__3439
LR__3438
	mov	local20, local12
	mov	local26, #48
	wrbyte	#48, local20
	add	local12, #1
LR__3439
	cmp	local38, local33 wz
 if_ne	jmp	#LR__3440
	cmp	local15, #0 wz
 if_e	mov	local20, local35
 if_e	sub	local20, #1
 if_e	cmps	local38, local20 wc
 if_c_or_nz	mov	local20, local12
 if_c_or_nz	mov	local26, #46
 if_c_or_nz	wrbyte	#46, local20
 if_c_or_nz	add	local12, #1
LR__3440
	mov	local28, local38
	add	local28, #1
	mov	local38, local28
	jmp	#LR__3437
LR__3441
LR__3442
	cmp	local07, #0 wz
 if_e	jmp	#LR__3446
	sub	local12, #1
	callpa	#(@LR__3444-@LR__3443)>>2,fcache_load_ptr_
LR__3443
	cmps	local12, local13 wcz
 if_be	jmp	#LR__3445
	rdbyte	local20, local12
	cmp	local20, #48 wz
 if_e	sub	local12, #1
 if_e	jmp	#LR__3443
LR__3444
LR__3445
	rdbyte	local20, local12
	cmp	local20, #46 wz
 if_e	sub	local12, #1
	add	local12, #1
LR__3446
	cmp	local21, #0 wz
 if_e	jmp	#LR__3449
	wrbyte	local22, local12
	add	local12, #1
	wrbyte	local11, local12
	mov	local38, #0
	add	local12, #1
LR__3447
	cmps	local38, local32 wc
 if_ae	jmp	#LR__3448
	mov	local26, local38
	mov	local30, fp
	add	local30, #176
	add	local26, local30
	rdbyte	local31, local26
	wrbyte	local31, local12
	add	local38, #1
	add	local12, #1
	jmp	#LR__3447
LR__3448
LR__3449
	wrbyte	#0, local12
LR__3450
	cmp	local19, #0 wz
 if_ne	cmp	local10, #0 wz
 if_e	jmp	#LR__3459
	mov	arg01, local13
	mov	local39, arg01
	callpa	#(@LR__3452-@LR__3451)>>2,fcache_load_ptr_
LR__3451
	rdbyte	result1, local39 wz
 if_ne	add	local39, #1
 if_ne	jmp	#LR__3451
LR__3452
	sub	local39, arg01
	cmps	local39, local19 wcz
 if_be	jmp	#LR__3459
	mov	local40, local13
	cmp	local21, #0 wz
 if_ne	mov	local14, #0
 if_ne	mov	local41, local19
 if_e	sub	local19, #1
 if_e	sub	local19, local14
 if_e	mov	local41, local19
	cmp	local41, #0 wz
 if_e	jmp	#LR__3455
	callpa	#(@LR__3454-@LR__3453)>>2,fcache_load_ptr_
LR__3453
	wrbyte	#42, local40
	sub	local41, #1 wz
	add	local40, #1
 if_ne	jmp	#LR__3453
LR__3454
LR__3455
	cmp	local14, #0 wz
 if_e	jmp	#LR__3458
	mov	local20, local40
	wrbyte	#46, local20
	mov	local41, #0
	add	local40, #1
	callpa	#(@LR__3457-@LR__3456)>>2,fcache_load_ptr_
LR__3456
	cmps	local41, local14 wc
 if_b	mov	local20, local40
 if_b	add	local40, #1
 if_b	wrbyte	#42, local20
 if_b	add	local41, #1
 if_b	jmp	#LR__3456
LR__3457
LR__3458
	wrbyte	#0, local40
LR__3459
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local13
	call	#__system___fmtstr
LR__3460
	mov	ptra, fp
	call	#popregs_
__system___fmtfloat_ret
	ret

__system__Left_S
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	cmps	local02, #1 wc
 if_b	mov	result1, ##@LR__5463
 if_b	jmp	#LR__3473
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__3471-@LR__3470)>>2,fcache_load_ptr_
LR__3470
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__3470
LR__3471
	sub	local03, arg01
	mov	result1, local03
	cmps	result1, local02 wcz
 if_be	mov	result1, local01
 if_be	jmp	#LR__3473
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_e	jmp	#LR__3472
	mov	arg01, local04
	mov	arg02, local01
	mov	arg03, local02
	call	#__system____builtin_memmove
	add	local02, local04
	wrbyte	#0, local02
LR__3472
	mov	result1, local04
LR__3473
	mov	ptra, fp
	call	#popregs_
__system__Left_S_ret
	ret

__system__Right_S
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	cmps	local02, #1 wc
 if_b	mov	result1, ##@LR__5464
 if_b	jmp	#LR__3483
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__3481-@LR__3480)>>2,fcache_load_ptr_
LR__3480
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__3480
LR__3481
	sub	local03, arg01
	mov	result1, local03
	mov	local04, result1
	cmps	local04, local02 wcz
 if_be	mov	result1, local01
 if_be	jmp	#LR__3483
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__3482
	sub	local04, local02
	add	local04, local01
	add	local02, #1
	mov	arg01, local05
	mov	arg02, local04
	mov	arg03, local02
	call	#__system____builtin_memmove
LR__3482
	mov	result1, local05
LR__3483
	mov	ptra, fp
	call	#popregs_
__system__Right_S_ret
	ret

__system__Mid_S
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	cmps	arg03, #1 wc
 if_b	mov	result1, ##@LR__5465
 if_b	jmp	#LR__3493
	sub	local02, #1
	fges	local02, #0 wc
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__3491-@LR__3490)>>2,fcache_load_ptr_
LR__3490
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__3490
LR__3491
	sub	local03, arg01
	mov	result1, local03
	mov	arg02, result1
	cmps	arg02, local02 wc
 if_b	mov	result1, ##@LR__5466
 if_b	jmp	#LR__3493
	mov	local04, arg02
	sub	local04, local02
	cmps	local04, arg03 wcz
 if_a	mov	local04, arg03
	mov	arg01, local04
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__3492
	add	local02, local01
	mov	arg01, local05
	mov	arg02, local02
	mov	arg03, local04
	call	#__system____builtin_memmove
	add	local04, local05
	wrbyte	#0, local04
LR__3492
	mov	result1, local05
LR__3493
	mov	ptra, fp
	call	#popregs_
__system__Mid_S_ret
	ret

__system__Chr_S
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #3
	call	#__system___gc_alloc_managed
	cmps	result1, #0 wz
 if_ne	wrbyte	local01, result1
 if_ne	add	result1, #1
 if_ne	wrbyte	#0, result1
 if_ne	sub	result1, #1
	mov	ptra, fp
	call	#popregs_
__system__Chr_S_ret
	ret

__system__str_S
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #16
	call	#__system___gc_alloc_managed
	mov	local02, result1 wz
 if_e	jmp	#LR__3500
	mov	arg01, ptra
	add	ptra, #8
	wrlong	local02, arg01
	add	arg01, #4
	wrlong	#0, arg01
	sub	arg01, #4
	or	arg01, ##187695104
	mov	arg02, #0
	mov	arg03, local01
	mov	arg04, #103
	call	#__system___fmtfloat
LR__3500
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
__system__str_S_ret
	ret

__system__Number_S
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	mov	local03, arg03
 if_ne	jmp	#LR__3512
	mov	local02, #1
	mov	local04, local03
	mov	local05, #1
	callpa	#(@LR__3511-@LR__3510)>>2,fcache_load_ptr_
LR__3510
	mov	local06, #0
	cmp	local04, local01 wcz
 if_be	neg	local06, #1
	cmp	local05, local04 wc
	subx	local07, local07
	test	local06, local07 wz
 if_ne	qmul	local04, local03
 if_ne	mov	local05, local04
 if_ne	add	local02, #1
 if_ne	getqx	local04
 if_ne	jmp	#LR__3510
LR__3511
LR__3512
	fle	local02, #32 wc
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local06, result1
	mov	local07, local02
	add	local07, local06
	wrbyte	#0, local07
	callpa	#(@LR__3514-@LR__3513)>>2,fcache_load_ptr_
LR__3513
	cmp	local02, #1 wc
 if_b	jmp	#LR__3515
	qdiv	local01, local03
	sub	local02, #1
	mov	local07, local02
	add	local07, local06
	getqy	local08
	cmp	local08, #10 wc
 if_b	add	local08, #48
 if_ae	add	local08, #55
	wrbyte	local08, local07
	getqx	local01
	jmp	#LR__3513
LR__3514
LR__3515
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system__Number_S_ret
	ret

__system__LCase_S
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__3521-@LR__3520)>>2,fcache_load_ptr_
LR__3520
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__3520
LR__3521
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, ##@LR__5467
 if_e	jmp	#LR__3527
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local03, result1 wz
 if_e	jmp	#LR__3526
	neg	local04, #1
	callpa	#(@LR__3525-@LR__3522)>>2,fcache_load_ptr_
LR__3522
	add	local04, #1
	mov	local05, local04
	add	local05, local01
	rdbyte	local06, local05
	cmps	local06, #65 wc
 if_b	jmp	#LR__3523
	cmps	local06, #91 wc
 if_b	mov	local07, local04
 if_b	add	local07, local03
 if_b	add	local06, #32
 if_b	wrbyte	local06, local07
 if_b	jmp	#LR__3524
LR__3523
	mov	local07, local04
	add	local07, local03
	wrbyte	local06, local07
LR__3524
	mov	local06, local02
	sub	local06, #1
	cmp	local04, local06 wz
 if_ne	jmp	#LR__3522
LR__3525
	add	local02, local03
	wrbyte	#0, local02
	mov	result1, local03
	jmp	#LR__3527
LR__3526
	mov	result1, local03
LR__3527
	mov	ptra, fp
	call	#popregs_
__system__LCase_S_ret
	ret

__system__LTrim_S
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__3531-@LR__3530)>>2,fcache_load_ptr_
LR__3530
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__3530
LR__3531
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, ##@LR__5468
 if_e	jmp	#LR__3536
	mov	local03, #0
	mov	local04, local02
LR__3532
	cmps	local03, local04 wc
 if_ae	jmp	#LR__3535
	mov	arg03, local03
	add	arg03, local01
	rdbyte	arg03, arg03
	cmp	arg03, #32 wz
 if_e	jmp	#LR__3534
	mov	arg01, local02
	sub	arg01, local03
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__3533
	mov	arg02, local03
	add	arg02, local01
	mov	arg03, local02
	sub	arg03, local03
	mov	arg01, local05
	call	#__system____builtin_memmove
	sub	local02, local03
	add	local02, local05
	wrbyte	#0, local02
	mov	result1, local05
	jmp	#LR__3536
LR__3533
	mov	result1, local05
	jmp	#LR__3536
LR__3534
	add	local03, #1
	jmp	#LR__3532
LR__3535
	mov	result1, local01
LR__3536
	mov	ptra, fp
	call	#popregs_
__system__LTrim_S_ret
	ret

__system__RTrim_S
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__3541-@LR__3540)>>2,fcache_load_ptr_
LR__3540
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__3540
LR__3541
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, ##@LR__5469
 if_e	jmp	#LR__3545
	mov	local03, local02
	sub	local03, #1
LR__3542
	mov	arg02, local03
	add	arg02, local01
	rdbyte	local02, arg02
	cmp	local02, #32 wz
 if_e	jmp	#LR__3544
	mov	arg01, local03
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_e	jmp	#LR__3543
	mov	arg03, local03
	add	arg03, #1
	mov	arg01, local04
	mov	arg02, local01
	call	#__system____builtin_memmove
	add	local03, #1
	add	local03, local04
	wrbyte	#0, local03
	mov	result1, local04
	jmp	#LR__3545
LR__3543
	mov	result1, local04
	jmp	#LR__3545
LR__3544
	sub	local03, #1
	cmps	local03, #0 wc
 if_ae	jmp	#LR__3542
	mov	result1, ##@LR__5470
LR__3545
	mov	ptra, fp
	call	#popregs_
__system__RTrim_S_ret
	ret

__system__Instr
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__3551-@LR__3550)>>2,fcache_load_ptr_
LR__3550
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3550
LR__3551
	sub	local04, arg01
	mov	local05, local04
	mov	arg01, local02
	mov	local04, arg01
	callpa	#(@LR__3553-@LR__3552)>>2,fcache_load_ptr_
LR__3552
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3552
LR__3553
	sub	local04, arg01
	mov	result1, local04
	mov	arg04, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3557
	cmp	local05, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3557
	cmps	local01, arg04 wcz
 if_a	mov	result1, #0
 if_a	jmp	#LR__3557
	cmps	local01, #1 wc
 if_b	mov	local01, #1
	rdbyte	local06, local03
	cmp	local05, #1 wz
 if_ne	jmp	#LR__3554
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local01
	mov	arg04, #0
	call	#__system____ScanForChar
	jmp	#LR__3557
LR__3554
	mov	local07, local01
LR__3555
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local07
	mov	arg04, #0
	call	#__system____ScanForChar
	mov	local07, result1 wz
 if_e	jmp	#LR__3556
	mov	arg03, local05
	mov	arg01, local02
	mov	arg02, local07
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, local03
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__3557
	add	local07, local05
	jmp	#LR__3555
LR__3556
	mov	result1, #0
LR__3557
	mov	ptra, fp
	call	#popregs_
__system__Instr_ret
	ret

__system__InstrRev
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__3561-@LR__3560)>>2,fcache_load_ptr_
LR__3560
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3560
LR__3561
	sub	local04, arg01
	mov	local05, local04
	mov	arg01, local02
	mov	local04, arg01
	callpa	#(@LR__3563-@LR__3562)>>2,fcache_load_ptr_
LR__3562
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3562
LR__3563
	sub	local04, arg01
	mov	result1, local04
	mov	arg04, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3567
	cmp	local05, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3567
	cmps	local01, arg04 wcz
 if_a	mov	local01, arg04
	cmps	local01, #1 wc
 if_b	mov	local01, #1
	rdbyte	local06, local03
	cmp	local05, #1 wz
 if_ne	jmp	#LR__3564
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local01
	mov	arg04, #1
	call	#__system____ScanForChar
	jmp	#LR__3567
LR__3564
	mov	local07, local05
	sub	local07, #1
LR__3565
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local07
	mov	arg04, #1
	call	#__system____ScanForChar
	mov	local07, result1 wz
 if_e	jmp	#LR__3566
	mov	arg03, local05
	mov	arg01, local02
	mov	arg02, local07
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, local03
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__3567
	sub	local07, local05
	jmp	#LR__3565
LR__3566
	mov	result1, #0
LR__3567
	mov	ptra, fp
	call	#popregs_
__system__InstrRev_ret
	ret

__system___remove
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, ptr___system__dat__
	add	local01, #388
	mov	arg02, arg01
	mov	arg01, local01
	mov	arg03, #0
	call	#__system____getvfsforfile
	mov	local02, result1 wz
 if_e	jmp	#LR__3570
	add	local02, #32
	rdlong	arg01, local02 wz
	sub	local02, #32
 if_ne	jmp	#LR__3571
LR__3570
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__3574
LR__3571
	add	local02, #64
	rdlong	local03, local02
	mov	local04, local03
	sub	local02, #64
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local06, result1
	cmp	local06, ##-14 wz
 if_ne	jmp	#LR__3572
	add	local02, #60
	rdlong	local06, local02
	mov	local03, local06
	zerox	local06, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local06
	call	local03
	mov	objptr, local05
	mov	local06, result1
LR__3572
	cmp	local06, #0 wz
 if_e	jmp	#LR__3573
	neg	arg01, local06 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__3574
LR__3573
	mov	result1, #0
LR__3574
	mov	ptra, fp
	call	#popregs_
__system___remove_ret
	ret

__system___mkdir
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, ptr___system__dat__
	add	local01, #388
	mov	arg02, arg01
	mov	arg01, local01
	mov	arg03, #0
	call	#__system____getvfsforfile
	mov	local02, result1 wz
 if_e	jmp	#LR__3580
	add	local02, #32
	rdlong	arg02, local02 wz
	sub	local02, #32
 if_ne	jmp	#LR__3581
LR__3580
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__3583
LR__3581
	add	local02, #56
	rdlong	local03, local02
	mov	local04, local03
	zerox	local03, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #511
	mov	local05, objptr
	mov	objptr, local03
	call	local04
	mov	objptr, local05
	mov	arg01, result1 wz
 if_e	jmp	#LR__3582
	neg	arg01, arg01 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__3583
LR__3582
	mov	result1, #0
LR__3583
	mov	ptra, fp
	call	#popregs_
__system___mkdir_ret
	ret

__system___strerror
	cmps	arg01, #0 wc
 if_b	jmp	#LR__3590
	cmps	arg01, #26 wc
 if_b	jmp	#LR__3591
LR__3590
	mov	arg01, #25
LR__3591
	shl	arg01, #2
	mov	result1, ptr___system__dat__
	add	result1, ##736
	add	arg01, result1
	rdlong	result1, arg01
__system___strerror_ret
	ret

__system___int64_shl
	test	arg03, #32 wz
 if_ne	mov	arg02, arg01
 if_ne	mov	arg01, #0
	test	arg03, #31 wz
 if_e	jmp	#LR__3600
	shl	arg02, arg03
	mov	result1, arg01
	neg	result2, arg03
	shr	result1, result2
	or	arg02, result1
	shl	arg01, arg03
LR__3600
	mov	result2, arg02
	mov	result1, arg01
__system___int64_shl_ret
	ret

__system___int64_sar
	test	arg03, #32 wz
 if_ne	mov	arg01, arg02
 if_ne	sar	arg02, #31
	test	arg03, #31 wz
 if_e	jmp	#LR__3610
	shr	arg01, arg03
	mov	result1, arg02
	neg	result2, arg03
	shl	result1, result2
	or	arg01, result1
	sar	arg02, arg03
LR__3610
	mov	result2, arg02
	mov	result1, arg01
__system___int64_sar_ret
	ret

__system___usepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #20
	test	arg01, _var01 wz
 if_e	add	ptr___system__dat__, #24
 if_e	rdlong	_var02, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #24
 if_e	test	arg02, _var02 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___usepins_ret
	add	ptr___system__dat__, #20
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg01
	wrlong	_var02, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg02
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #24
	neg	result1, #1
__system___usepins_ret
	ret

__system___freepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg01
	wrlong	_var01, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg02
	wrlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #24
__system___freepins_ret
	ret

__system___float_fromuns
	mov	arg03, arg01 wz
 if_e	mov	result1, arg03
 if_e	jmp	#LR__3620
	encod	arg02, arg03 wc
 if_b	add	arg02, #1
	sub	arg02, #1
	mov	arg01, #31
	sub	arg01, arg02
	shl	arg03, arg01
	shr	arg03, #2
	mov	arg01, #0
	call	#__system___float_Pack
LR__3620
__system___float_fromuns_ret
	ret

__system___float_add
	mov	COUNT_, #15
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	mov	local04, local01
	mov	local05, local04
	zerox	local05, #22
	mov	local06, local04
	shl	local06, #1
	shr	local06, #24
	shr	local04, #31
	mov	arg01, local02
	mov	result1, arg01
	mov	local07, result1
	mov	local08, local07
	zerox	local08, #22
	mov	local09, local07
	shl	local09, #1
	shr	local09, #24
	mov	local10, local09
	shr	local07, #31
	mov	local11, #0
	mov	local12, #0
	cmp	local06, local10 wc
 if_ae	cmp	local06, local10 wz
 if_a	jmp	#LR__3630
 if_ae	cmp	local05, local08 wc
 if_ae	jmp	#LR__3630
	mov	local13, local05
	mov	local05, local08
	mov	local08, local13
	mov	local13, local06
	mov	local06, local10
	mov	local10, local13
	mov	local13, local04
	mov	local04, local07
	mov	local07, local13
LR__3630
	cmp	local06, #255 wz
 if_e	jmp	#LR__3645
	cmp	local06, #0 wz
 if_e	jmp	#LR__3647
	bith	local05, #23
LR__3631
	cmp	local10, #0 wz
 if_e	jmp	#LR__3651
	bith	local08, #23
LR__3632
	sub	local06, #127
	sub	local10, #127
	mov	local14, local06
	sub	local14, local10
	callpa	#(@LR__3634-@LR__3633)>>2,fcache_load_ptr_
LR__3633
	cmps	local14, #32 wc
 if_b	jmp	#LR__3635
	mov	local09, local08
	cmp	local11, #0 wz
	wrnz	local11
	or	local09, local11
	mov	local11, local09
	mov	local08, #0
	sub	local14, #32
	jmp	#LR__3633
LR__3634
LR__3635
	cmp	local14, #0 wz
 if_e	jmp	#LR__3636
	mov	local13, local08
	mov	local10, #32
	sub	local10, local14
	shl	local13, local10
	mov	local10, local11
	mov	local09, #32
	sub	local09, local14
	shl	local10, local09 wz
	shr	local11, local14
	shr	local08, local14
	or	local11, local13
	mov	local15, #0
 if_ne	mov	local15, #1
	or	local11, local15
LR__3636
	mov	local15, local04
	xor	local15, local07
	test	local15, #1 wz
 if_e	jmp	#LR__3637
	not	local08, local08
	not	local11, local11
	add	local11, #1 wz
	mov	local15, #0
 if_e	mov	local15, #1
	add	local08, local15
LR__3637
	add	local12, local11 wc
	addx	local05, local08
	cmps	local05, #0 wc
 if_ae	jmp	#LR__3638
	xor	local04, #1
	not	local05, local05
	not	local12, local12
	add	local12, #1 wz
	mov	local15, #0
 if_e	mov	local15, #1
	add	local05, local15
LR__3638
	cmp	local05, ##16777216 wc
 if_b	jmp	#LR__3639
	add	local06, #1
	mov	local14, local12
	and	local14, #1
	shr	local12, #1
	mov	local15, local05
	shl	local15, #31
	or	local12, local15
	or	local12, local14
	shr	local05, #1
	jmp	#LR__3644
LR__3639
	cmp	local05, ##8388608 wc
 if_ae	jmp	#LR__3643
	cmp	local05, #0 wz
 if_e	cmp	local12, #0 wz
 if_e	or	local04, #8
 if_e	andn	local04, #1
 if_e	jmp	#LR__3642
LR__3640
	cmp	local05, ##8388608 wc
 if_ae	jmp	#LR__3641
	add	local12, local12 wc
	addx	local05, local05
	sub	local06, #1
	jmp	#LR__3640
LR__3641
LR__3642
LR__3643
LR__3644
	mov	arg01, local05
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	call	#__system__pack_0698
	jmp	#LR__3655
LR__3645
	cmp	local10, #255 wz
 if_ne	jmp	#LR__3646
	cmp	local07, local04 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__3655
LR__3646
	cmp	local05, #0 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__3655
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	or	arg04, #2
	mov	arg01, local05
	call	#__system__pack_0698
	jmp	#LR__3655
LR__3647
	cmp	local05, #0 wz
 if_e	jmp	#LR__3650
	shl	local05, #1
	callpa	#(@LR__3649-@LR__3648)>>2,fcache_load_ptr_
LR__3648
	cmp	local05, ##8388608 wc
 if_b	mov	local15, local06
 if_b	sub	local15, #1
 if_b	mov	local06, local15
 if_b	shl	local05, #1
 if_b	jmp	#LR__3648
LR__3649
	jmp	#LR__3631
LR__3650
	and	local04, local07
	mov	arg04, local04
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0698
	jmp	#LR__3655
LR__3651
	cmp	local08, #0 wz
 if_e	jmp	#LR__3654
	shl	local08, #1
	callpa	#(@LR__3653-@LR__3652)>>2,fcache_load_ptr_
LR__3652
	cmp	local08, ##8388608 wc
 if_b	mov	local15, local10
 if_b	sub	local15, #1
 if_b	mov	local10, local15
 if_b	shl	local08, #1
 if_b	jmp	#LR__3652
LR__3653
	jmp	#LR__3632
LR__3654
	sub	local06, #127
	mov	arg01, local05
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	call	#__system__pack_0698
LR__3655
	mov	ptra, fp
	call	#popregs_
__system___float_add_ret
	ret

__system___float_sqrt
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	result1, arg01
	mov	local02, result1
	mov	local03, local02
	zerox	local03, #22
	mov	local04, local02
	shl	local04, #1
	shr	local04, #24 wz
	shr	local02, #31
 if_e	jmp	#LR__3661
	bith	local03, #23
LR__3660
	cmp	local02, #0 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__3664
	cmp	local04, #255 wz
 if_e	mov	result1, local01
 if_e	jmp	#LR__3664
	sub	local04, #127
	test	local04, #1 wz
 if_ne	shl	local03, #1
	shl	local03, #5
	qsqrt	#0, local03
 if_ne	sub	local04, #1
	abs	local04, local04 wc
	shr	local04, #1
	negc	arg03, local04
	mov	arg04, local02
	getqx	arg01
	mov	arg02, arg01
	shl	arg02, #25
	shr	arg01, #7
	cmp	arg01, ##16777217 wc
 if_ae	add	arg03, #1
 if_ae	shr	arg01, #1
	call	#__system__pack_0698
	jmp	#LR__3664
LR__3661
	cmp	local03, #0 wz
 if_e	mov	result1, local01
 if_e	jmp	#LR__3664
	shl	local03, #1
	callpa	#(@LR__3663-@LR__3662)>>2,fcache_load_ptr_
LR__3662
	cmp	local03, ##8388608 wc
 if_b	sub	local04, #1
 if_b	shl	local03, #1
 if_b	jmp	#LR__3662
LR__3663
	jmp	#LR__3660
LR__3664
	mov	ptra, fp
	call	#popregs_
__system___float_sqrt_ret
	ret

__system___float_mul
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, local01
	mov	local04, local03
	zerox	local04, #22
	mov	local05, local03
	shl	local05, #1
	shr	local05, #24
	shr	local03, #31
	mov	result1, local02
	mov	local06, result1
	mov	local07, local06
	zerox	local07, #22
	mov	local08, local06
	shl	local08, #1
	shr	local08, #24
	shr	local06, #31
	xor	local03, local06
	cmp	local05, #255 wz
 if_e	jmp	#LR__3673
	cmp	local08, #255 wz
 if_e	jmp	#LR__3675
	cmp	local05, #0 wz
 if_e	jmp	#LR__3676
	bith	local04, #23
LR__3670
	cmp	local08, #0 wz
 if_e	jmp	#LR__3680
	bith	local07, #23
LR__3671
	mov	local02, local04
	shl	local02, #4
	mov	local06, local07
	shl	local06, #5
	qmul	local02, local06
	add	local05, local08
	sub	local05, #254
	mov	local09, local05
	shl	local04, #4
	shl	local07, #5
	getqx	local10
	qmul	local04, local07
	getqy	local11
	cmp	local11, ##16777216 wc
 if_b	jmp	#LR__3672
	add	local09, #1
	shr	local10, #1
	mov	local08, local11
	shl	local08, #31
	or	local10, local08
	shr	local11, #1
LR__3672
	mov	arg01, local11
	mov	arg02, local10
	mov	arg03, local09
	mov	arg04, local03
	call	#__system__pack_0698
	jmp	#LR__3684
LR__3673
	cmp	local04, #0 wz
 if_ne	mov	result1, local01
 if_ne	jmp	#LR__3684
	cmps	local08, #255 wc
 if_b	cmp	local08, #0 wz
 if_c_and_z	cmp	local07, #0 wz
 if_c_and_nz	jmp	#LR__3674
 if_b	mov	result1, ##2146435072
 if_b	jmp	#LR__3684
	cmp	local07, #0 wz
 if_ne	mov	result1, local02
 if_ne	jmp	#LR__3684
LR__3674
	or	local03, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, local05
	mov	arg04, local03
	call	#__system__pack_0698
	jmp	#LR__3684
LR__3675
	cmp	local05, #0 wz
 if_e	cmp	local04, #0 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__3684
	cmp	local07, #0 wz
 if_ne	mov	result1, local02
 if_ne	jmp	#LR__3684
	mov	arg03, local08
	mov	arg04, local03
	or	arg04, #2
	mov	arg01, #0
	mov	arg02, #0
	call	#__system__pack_0698
	jmp	#LR__3684
LR__3676
	cmp	local04, #0 wz
 if_e	jmp	#LR__3679
	shl	local04, #1
	callpa	#(@LR__3678-@LR__3677)>>2,fcache_load_ptr_
LR__3677
	cmp	local04, ##8388608 wc
 if_b	sub	local05, #1
 if_b	shl	local04, #1
 if_b	jmp	#LR__3677
LR__3678
	jmp	#LR__3670
LR__3679
	or	local03, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local03
	call	#__system__pack_0698
	jmp	#LR__3684
LR__3680
	cmp	local07, #0 wz
 if_e	jmp	#LR__3683
	shl	local07, #1
	callpa	#(@LR__3682-@LR__3681)>>2,fcache_load_ptr_
LR__3681
	cmp	local07, ##8388608 wc
 if_b	sub	local08, #1
 if_b	shl	local07, #1
 if_b	jmp	#LR__3681
LR__3682
	jmp	#LR__3671
LR__3683
	or	local03, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local03
	call	#__system__pack_0698
LR__3684
	mov	ptra, fp
	call	#popregs_
__system___float_mul_ret
	ret

__system___float_div
	mov	COUNT_, #14
	call	#pushregs_
	mov	local03, arg01
	mov	local04, arg02
	mov	local05, local03
	mov	local06, local05
	zerox	local06, #22
	mov	local07, local05
	shl	local07, #1
	shr	local07, #24
	shr	local05, #31
	mov	result1, local04
	mov	local08, result1
	mov	local09, local08
	zerox	local09, #22
	mov	local10, local08
	shl	local10, #1
	shr	local10, #24
	shr	local08, #31
	xor	local05, local08
	cmp	local07, #255 wz
 if_e	jmp	#LR__3695
	cmp	local10, #255 wz
 if_e	jmp	#LR__3696
	cmp	local07, #0 wz
 if_e	jmp	#LR__3697
	bith	local06, #23
LR__3690
	cmp	local10, #0 wz
 if_e	jmp	#LR__3701
	bith	local09, #23
LR__3691
	sub	local07, local10
	mov	local11, local07
	mov	arg01, local06
	shr	arg01, #2
	shl	local06, #30
	mov	arg02, local06
	mov	arg03, local09
	setq	arg01
	qdiv	arg02, arg03
	mov	local12, #0
	getqx	local01
	getqy	result2
	mov	local02, result2
	mov	local13, local01
	cmps	local02, #0 wz
	mov	local14, local13
	shl	local14, #25
 if_ne	mov	local12, #1
	or	local14, local12
	shr	local13, #7
	cmp	local13, ##16777216 wc
 if_b	jmp	#LR__3692
	add	local11, #1
	shr	local14, #1
	mov	local12, local13
	shl	local12, #31
	or	local14, local12
	shr	local13, #1
	jmp	#LR__3694
LR__3692
	cmp	local13, ##8388608 wc
 if_ae	jmp	#LR__3693
	sub	local11, #1
	shl	local13, #1
	mov	local12, local14
	shr	local12, #31
	or	local13, local12
	shl	local14, #1
LR__3693
LR__3694
	mov	arg01, local13
	mov	arg02, local14
	mov	arg03, local11
	mov	arg04, local05
	call	#__system__pack_0698
	jmp	#LR__3705
LR__3695
	cmp	local06, #0 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__3705
	cmp	local10, #255 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__3705
	or	local05, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, local07
	mov	arg04, local05
	call	#__system__pack_0698
	jmp	#LR__3705
LR__3696
	cmp	local09, #0 wz
 if_ne	mov	result1, local04
 if_ne	jmp	#LR__3705
	mov	arg04, local05
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0698
	jmp	#LR__3705
LR__3697
	cmp	local06, #0 wz
 if_e	jmp	#LR__3700
	shl	local06, #1
	callpa	#(@LR__3699-@LR__3698)>>2,fcache_load_ptr_
LR__3698
	cmp	local06, ##8388608 wc
 if_b	sub	local07, #1
 if_b	shl	local06, #1
 if_b	jmp	#LR__3698
LR__3699
	jmp	#LR__3690
LR__3700
	cmp	local10, #0 wz
 if_e	cmp	local09, #0 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__3705
	mov	arg04, local05
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0698
	jmp	#LR__3705
LR__3701
	cmp	local09, #0 wz
 if_e	jmp	#LR__3704
	shl	local09, #1
	callpa	#(@LR__3703-@LR__3702)>>2,fcache_load_ptr_
LR__3702
	cmp	local09, ##8388608 wc
 if_b	sub	local10, #1
 if_b	shl	local09, #1
 if_b	jmp	#LR__3702
LR__3703
	jmp	#LR__3691
LR__3704
	or	local05, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local05
	call	#__system__pack_0698
LR__3705
	mov	ptra, fp
	call	#popregs_
__system___float_div_ret
	ret

__system___float_cmp
	cmps	arg01, ##2139095041 wc
 if_b	cmps	arg02, ##2139095041 wc
 if_ae	mov	result1, arg03
 if_ae	jmp	#__system___float_cmp_ret
	cmp	arg01, ##-8388607 wc
 if_b	cmp	arg01, ##-8388607 wc
 if_ae	mov	result1, arg03
 if_ae	jmp	#__system___float_cmp_ret
	cmps	arg01, #0 wc
 if_ae	jmp	#LR__3710
	cmps	arg02, #0 wc
 if_b	mov	result1, arg02
 if_b	sub	result1, arg01
 if_b	jmp	#__system___float_cmp_ret
	cmp	arg02, #0 wz
 if_e	cmp	arg01, ##-2147483648 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system___float_cmp_ret
	neg	result1, #1
	jmp	#__system___float_cmp_ret
LR__3710
	cmps	arg02, #0 wc
 if_ae	jmp	#LR__3711
	cmp	arg01, #0 wz
 if_e	cmp	arg02, ##-2147483648 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system___float_cmp_ret
	mov	result1, #1
	jmp	#__system___float_cmp_ret
LR__3711
	sub	arg01, arg02
	mov	result1, arg01
__system___float_cmp_ret
	ret

__system___float_tointeger
	mov	COUNT_, #2
	call	#pushregs_
	call	#__system___float_Unpack
	mov	local01, result1
	cmps	result2, #31 wc
 if_ae	cmp	local01, #0 wz
 if_a	decod	local02, #31
 if_nc_and_z	bmask	local02, #30
 if_ae	mov	result3, local02
 if_ae	jmp	#LR__3721
	cmps	result2, ##-1 wc
 if_b	mov	result3, #0
 if_b	jmp	#LR__3720
	shl	result3, #2
	mov	local02, #30
	sub	local02, result2
	shr	result3, local02
	add	result3, arg02
	shr	result3, #1
	cmp	local01, #0 wz
 if_ne	neg	result3, result3
LR__3720
LR__3721
	mov	result1, result3
	mov	ptra, fp
	call	#popregs_
__system___float_tointeger_ret
	ret

__system___float_Unpack
	mov	_var01, arg01
	shr	_var01, #31
	mov	_var02, arg01
	shl	_var02, #1
	shr	_var02, #24 wz
	bitl	arg01, #279
 if_ne	shl	arg01, #6
 if_ne	bith	arg01, #29
 if_ne	jmp	#LR__3730
	encod	_var03, arg01 wc
 if_b	add	_var03, #1
	sub	_var03, #23
	mov	_var02, _var03
	mov	result2, #7
	sub	result2, _var03
	shl	arg01, result2
LR__3730
	sub	_var02, #127
	mov	result3, arg01
	mov	result1, _var01
	mov	result2, _var02
__system___float_Unpack_ret
	ret

__system___float_Pack
	mov	_var01, #0
	cmp	arg03, #0 wz
 if_e	jmp	#LR__3741
	encod	_var02, arg03 wc
 if_b	add	_var02, #1
	mov	_var01, #33
	sub	_var01, _var02
	shl	arg03, _var01
	mov	_var02, #3
	sub	_var02, _var01
	add	arg02, _var02
	mov	_var03, arg02
	add	arg03, #256
	mov	_var02, arg03
	andn	_var02, #255 wz
 if_e	add	_var03, #1
	add	_var03, #127
	fges	_var03, ##-23
	fles	_var03, #255
	cmps	_var03, #1 wc
 if_ae	jmp	#LR__3740
	shr	arg03, #1
	decod	_var02, #31
	add	_var02, arg03
	neg	_var03, _var03
	shr	_var02, _var03
	mov	arg03, _var02
	mov	_var03, #0
LR__3740
	mov	result1, arg01
	shl	result1, #31
	mov	_var02, _var03
	shl	_var02, #23
	or	result1, _var02
	mov	_var04, arg03
	shr	_var04, #9
	or	result1, _var04
	jmp	#__system___float_Pack_ret
LR__3741
	mov	result1, _var01
__system___float_Pack_ret
	ret

__system___basic_print_float
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03 wz
	mov	local04, arg04
 if_ne	jmp	#LR__3750
	cmp	local04, #35 wz
 if_e	mov	local05, ##537198592
 if_ne	decod	local05, #29
	mov	local03, local05
LR__3750
	mov	arg01, local01
	call	#__system___gettxfunc
	mov	local05, result1 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local05
 if_ne	mov	arg02, local03
 if_ne	mov	arg03, local02
 if_ne	mov	arg04, local04
 if_ne	call	#__system___fmtfloat
	mov	ptra, fp
	call	#popregs_
__system___basic_print_float_ret
	ret

__system____builtin_atoi
	mov	COUNT_, #7
	call	#pushregs_
__system____builtin_atoi_enter
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	mov	local04, #0
	mov	local05, #0
	callpa	#(@LR__3761-@LR__3760)>>2,fcache_load_ptr_
LR__3760
	rdbyte	local06, local01
	cmp	local06, #32 wz
 if_e	add	local01, #1
 if_e	jmp	#LR__3760
LR__3761
	rdbyte	local07, local01
	callpa	#(@LR__3763-@LR__3762)>>2,fcache_load_ptr_
LR__3762
	cmp	local07, #45 wz
 if_ne	cmp	local07, #43 wz
 if_ne	jmp	#LR__3764
	add	local01, #1
	cmp	local07, #45 wz
 if_e	mov	local06, #1
 if_e	subr	local05, local06
	rdbyte	local07, local01
	jmp	#LR__3762
LR__3763
LR__3764
	cmp	local02, #0 wz
 if_ne	jmp	#LR__3766
	cmp	local07, #36 wz
 if_e	mov	local02, #16
 if_e	add	local01, #1
 if_e	jmp	#LR__3765
	cmp	local07, #37 wz
 if_e	mov	local02, #2
 if_e	add	local01, #1
LR__3765
LR__3766
	callpa	#(@LR__3774-@LR__3767)>>2,fcache_load_ptr_
LR__3767
LR__3768
	rdbyte	local07, local01
	cmp	local07, #95 wz
	add	local01, #1
 if_e	jmp	#LR__3768
	cmp	local07, #48 wz
 if_ne	cmp	local07, #38 wz
 if_e	mov	local04, #0
 if_e	jmp	#LR__3773
	cmps	local07, #49 wc
 if_b	jmp	#LR__3769
	cmps	local07, #58 wc
 if_b	mov	local04, local07
 if_b	sub	local04, #48
 if_b	cmp	local02, #0 wz
 if_c_and_z	mov	local02, #10
 if_b	jmp	#LR__3772
LR__3769
	cmps	local02, #11 wc
 if_ae	cmps	local07, #97 wc
 if_b	jmp	#LR__3770
	cmps	local07, #103 wc
 if_b	sub	local07, #97
 if_b	mov	local04, #10
 if_b	add	local04, local07
 if_b	jmp	#LR__3771
LR__3770
	cmps	local02, #11 wc
 if_ae	cmps	local07, #65 wc
 if_b	jmp	#LR__3775
	cmps	local07, #71 wc
 if_b	sub	local07, #65
 if_b	mov	local04, #10
 if_b	add	local04, local07
 if_ae	jmp	#LR__3775
LR__3771
LR__3772
LR__3773
	qmul	local02, local03
	getqx	local03
	add	local03, local04
	jmp	#LR__3767
LR__3774
LR__3775
	cmp	local02, #0 wz
 if_ne	jmp	#LR__3781
	cmp	local07, #120 wz
 if_ne	cmp	local07, #104 wz
 if_ne	cmp	local07, #88 wz
 if_ne	cmp	local07, #72 wz
 if_ne	jmp	#LR__3776
	mov	arg01, local01
	mov	arg02, #16
	call	#__system____builtin_atoi
	mov	local03, result1
	jmp	#LR__3780
LR__3776
	cmp	local07, #98 wz
 if_ne	cmp	local07, #66 wz
 if_ne	jmp	#LR__3777
	mov	arg01, local01
	mov	arg02, #2
	call	#__system____builtin_atoi
	mov	local03, result1
	jmp	#LR__3779
LR__3777
	cmp	local07, #111 wz
 if_ne	cmp	local07, #79 wz
 if_ne	jmp	#LR__3778
	mov	arg01, local01
	mov	arg02, #8
	call	#__system____builtin_atoi
	mov	local03, result1
LR__3778
LR__3779
LR__3780
LR__3781
	cmp	local05, #0 wz
 if_ne	neg	local03, local03
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
__system____builtin_atoi_ret
	ret

__system____builtin_atof
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	mov	local03, #0
	mov	local04, #0
	mov	local05, #0
	callpa	#(@LR__3791-@LR__3790)>>2,fcache_load_ptr_
LR__3790
	rdbyte	arg03, local01
	cmp	arg03, #32 wz
 if_e	add	local01, #1
 if_e	jmp	#LR__3790
LR__3791
	rdbyte	local06, local01
LR__3792
	cmp	local06, #43 wz
 if_ne	cmp	local06, #45 wz
 if_ne	jmp	#LR__3793
	cmp	local06, #45 wz
 if_e	bitnot	local04, #31
	add	local01, #1
	rdbyte	local06, local01
	jmp	#LR__3792
LR__3793
LR__3794
	callpa	#(@LR__3796-@LR__3795)>>2,fcache_load_ptr_
LR__3795
	rdbyte	local06, local01
	cmp	local06, #95 wz
	add	local01, #1
 if_e	jmp	#LR__3795
LR__3796
	cmp	local06, #0 wz
 if_e	jmp	#LR__3798
	cmps	local06, #48 wc
 if_b	jmp	#LR__3797
	cmps	local06, #58 wc
 if_ae	jmp	#LR__3797
	mov	arg01, local02
	mov	arg02, ##1092616192
	call	#__system___float_mul
	mov	local02, result1
	sub	local06, #48
	mov	arg01, local06
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local02, result1
	cmp	local05, #0 wz
 if_ne	sub	local03, #1
	jmp	#LR__3794
LR__3797
	cmp	local06, #46 wz
 if_e	cmp	local05, #0 wz
 if_e	mov	local05, #1
 if_e	jmp	#LR__3794
LR__3798
	cmp	local06, #69 wz
 if_ne	cmp	local06, #101 wz
 if_ne	jmp	#LR__3799
	mov	arg01, local01
	mov	arg02, #0
	call	#__system____builtin_atoi
	add	result1, local03
	mov	local07, result1
	jmp	#LR__3800
LR__3799
	mov	local07, local03
LR__3800
	mov	arg03, local07
	mov	arg01, local02
	mov	arg02, ##1092616192
	call	#__system___float_pow_n
	xor	result1, local04
	mov	ptra, fp
	call	#popregs_
__system____builtin_atof_ret
	ret

__system____builtin_ilogb
	call	#__system___float_Unpack
	cmp	result3, #0 wz
 if_e	mov	result1, ##-2147483647
 if_e	jmp	#LR__3811
	cmp	result2, #128 wz
 if_ne	jmp	#LR__3810
	cmp	result3, ##536870912 wz
 if_e	bmask	result1, #30
 if_e	jmp	#LR__3811
	decod	result1, #31
	jmp	#LR__3811
LR__3810
	mov	result1, result2
LR__3811
__system____builtin_ilogb_ret
	ret

__system____builtin_sinf
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, ##1086918619
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	arg03, result1 wz
 if_e	jmp	#LR__3820
	abs	arg01, arg03 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg01, result1
	decod	arg02, #30
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, ##1078530011
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local01, result1
LR__3820
	mov	arg01, local01
	mov	arg02, ##1036831949
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__3821
	mov	arg01, local01
	mov	arg02, ##-1110651699
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__3821
	mov	arg01, local01
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, ##1086324736
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local03, result1
	jmp	#LR__3822
LR__3821
	mov	arg01, local01
	mov	arg02, ##1294137731
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	shl	result1, #2
	qrotate	##1073741824, result1
	getqy	arg01
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg01, result1
	mov	arg02, ##1317011456
	call	#__system___float_div
	mov	local03, result1
LR__3822
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
__system____builtin_sinf_ret
	ret

__system____builtin_tanf
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	call	#__system____builtin_sinf
	mov	local02, result1
	mov	arg02, local01
	mov	arg01, ##1070141403
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	mov	ptra, fp
	call	#popregs_
__system____builtin_tanf_ret
	ret

__system____builtin_asinf
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, local01
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, ##1065353216
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system___float_sqrt
	mov	arg02, result1
	mov	arg01, local01
	call	#__system____builtin_atan2f
	mov	ptra, fp
	call	#popregs_
__system____builtin_asinf_ret
	ret

__system____builtin_acosf
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, local01
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, ##1065353216
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system___float_sqrt
	mov	arg01, result1
	mov	arg02, local01
	call	#__system____builtin_atan2f
	mov	ptra, fp
	call	#popregs_
__system____builtin_acosf_ret
	ret

__system____builtin_atan2f
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3830
	mov	arg01, local02
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	result1, ##-1068953637
 if_b	jmp	#LR__3831
	mov	result1, #0
	jmp	#LR__3831
LR__3830
	mov	arg01, local02
	mov	arg02, local02
	call	#__system___float_mul
	mov	local03, result1
	mov	arg01, local01
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_add
	mov	arg01, result1
	call	#__system___float_sqrt
	mov	local03, result1
	mov	arg01, local02
	mov	arg02, local03
	call	#__system___float_div
	mov	local02, result1
	mov	arg01, local01
	mov	arg02, local03
	call	#__system___float_div
	mov	local01, result1
	mov	arg01, ##1317011456
	mov	arg02, local02
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local03, result1
	mov	arg01, ##1317011456
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	qvector	local03, result1
	mov	local03, ##1078530011
	getqy	arg01
	sar	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg01, result1
	mov	arg02, ##1317011456
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_mul
LR__3831
	mov	ptra, fp
	call	#popregs_
__system____builtin_atan2f_ret
	ret

__system____builtin_exp2f
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, ##1123942400
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	mov	result1, ##2139095040
 if_ae	jmp	#LR__3841
	mov	arg01, local01
	mov	arg02, ##-1023541248
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__3841
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local02, result1
	abs	arg01, local02 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local04, result1
	mov	arg01, local04
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__3840
	mov	arg01, local04
	mov	arg02, ##1065353216
	call	#__system___float_add
	mov	local04, result1
	sub	local02, #1
LR__3840
	add	local02, #127
	shl	local02, #23
	mov	arg01, local04
	mov	arg02, ##1291845632
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local04, result1 wz
 if_e	mov	result1, local02
 if_e	jmp	#LR__3841
	bith	local04, #62
	qexp	local04
	mov	arg01, local02
	getqx	arg02
	add	arg02, #1
	shr	arg02, #1
	add	arg02, ##1056964608
	call	#__system___float_mul
LR__3841
	mov	ptra, fp
	call	#popregs_
__system____builtin_exp2f_ret
	ret

__system____builtin_log2f
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01 wz
 if_ne	cmp	local02, ##-2147483648 wz
 if_e	neg	result1, ##8388608
 if_e	jmp	#LR__3854
	cmps	local02, #0 wc
 if_b	mov	result1, ##2143289344
 if_b	jmp	#LR__3854
	mov	arg01, local01
	mov	arg02, ##1092616192
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, ##1079286392
 if_e	jmp	#LR__3854
	mov	arg01, local01
	mov	arg02, ##1076754516
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, ##1069066811
 if_e	jmp	#LR__3854
	mov	local03, local02
	shr	local03, #23
	getbyte	local03, local03, #0
	bitl	local02, #279
	mov	local04, local02
	cmp	local03, #255 wz
 if_ne	jmp	#LR__3850
	cmp	local04, #0 wz
 if_ne	mov	local05, ##2139095040
 if_e	mov	local05, ##2143289344
	mov	result1, local05
	jmp	#LR__3854
LR__3850
	cmp	local03, #0 wz
 if_ne	bith	local04, #23
 if_ne	sub	local03, #127
 if_ne	jmp	#LR__3853
	cmp	local04, #0 wz
 if_e	neg	result1, ##8388608
 if_e	jmp	#LR__3854
	neg	local03, #126
	callpa	#(@LR__3852-@LR__3851)>>2,fcache_load_ptr_
LR__3851
	testbn	local04, #23 wz
 if_e	shl	local04, #1
 if_e	add	local03, #1
 if_e	jmp	#LR__3851
LR__3852
LR__3853
	qlog	local04
	sub	local03, #1
	abs	arg01, local03 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	getqx	local05
	bitl	local05, #155
	add	local05, #8
	shr	local05, #4
	add	local05, ##1065353216
	call	#__system___float_fromuns
	xor	result1, local06
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_add
LR__3854
	mov	ptra, fp
	call	#popregs_
__system____builtin_log2f_ret
	ret

__system____builtin_powf
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local02
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local03, result1
	abs	arg01, local03 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg01, result1
	mov	arg02, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3860
	mov	arg01, ##1065353216
	mov	arg02, local01
	mov	arg03, local03
	call	#__system___float_pow_n
	jmp	#LR__3861
LR__3860
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	result1, ##2143289344
 if_b	jmp	#LR__3861
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3861
	mov	arg01, local01
	call	#__system____builtin_log2f
	mov	arg01, result1
	mov	arg02, local02
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_exp2f
LR__3861
	mov	ptra, fp
	call	#popregs_
__system____builtin_powf_ret
	ret

__system____builtin_logbase
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, arg02
	call	#__system____builtin_log2f
	mov	local02, result1
	mov	arg01, local01
	call	#__system____builtin_log2f
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	mov	ptra, fp
	call	#popregs_
__system____builtin_logbase_ret
	ret

__system___float_pow_n
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	cmps	local03, #0 wc
 if_ae	jmp	#LR__3870
	mov	local04, #1
	neg	local03, local03
	cmps	local03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__3878
	jmp	#LR__3871
LR__3870
	mov	local04, #0
LR__3871
	mov	local05, ##1065353216
LR__3872
	cmps	local03, #1 wc
 if_b	jmp	#LR__3874
	test	local03, #1 wz
 if_e	jmp	#LR__3873
	mov	arg01, local05
	mov	arg02, local02
	call	#__system___float_mul
	mov	local05, result1
LR__3873
	sar	local03, #1
	mov	arg01, local02
	mov	arg02, local02
	call	#__system___float_mul
	mov	local02, result1
	jmp	#LR__3872
LR__3874
	cmp	local04, #0 wz
 if_e	jmp	#LR__3875
	mov	arg01, local01
	mov	arg02, local05
	call	#__system___float_div
	mov	local05, result1
	jmp	#LR__3877
LR__3875
	mov	arg01, local01
	mov	arg02, ##1065353216
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__3876
	mov	arg01, local01
	mov	arg02, local05
	call	#__system___float_mul
	mov	local05, result1
LR__3876
LR__3877
	mov	result1, local05
LR__3878
	mov	ptra, fp
	call	#popregs_
__system___float_pow_n_ret
	ret

__system___gc_ptrs
	mov	_var01, __heap_ptr
	mov	_var02, _var01
	add	_var02, ##95992
	rdlong	result2, _var01 wz
 if_ne	jmp	#LR__3880
	mov	result2, _var02
	sub	result2, _var01
	wrword	#1, _var01
	mov	result1, _var01
	add	result1, #2
	wrword	##27792, result1
	mov	result1, _var01
	add	result1, #4
	wrword	#0, result1
	mov	result1, _var01
	add	result1, #6
	wrword	#1, result1
	add	_var01, #16
	abs	result2, result2 wc
	shr	result2, #4
	negc	result2, result2
	wrword	result2, _var01
	mov	result2, _var01
	add	result2, #2
	wrword	##27791, result2
	mov	result2, _var01
	add	result2, #4
	wrword	#0, result2
	mov	result2, _var01
	add	result2, #6
	wrword	#0, result2
	sub	_var01, #16
LR__3880
	mov	result1, _var01
	mov	result2, _var02
__system___gc_ptrs_ret
	ret

__system___gc_tryalloc
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
	mov	local05, local03
	mov	local06, #0
	callpa	#(@LR__3891-@LR__3890)>>2,fcache_load_ptr_
LR__3890
	mov	local07, local05
	add	local05, #6
	rdword	arg02, local05 wz
	mov	arg01, local03
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local05, result1 wz
 if_ne	rdword	local06, local05
	cmp	local05, #0 wz
 if_ne	cmps	local05, local04 wc
 if_a	jmp	#LR__3892
 if_ne	cmps	local01, local06 wcz
 if_a	jmp	#LR__3890
LR__3891
LR__3892
	cmp	local05, #0 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__3895
	mov	result2, local05
	add	result2, #6
	rdword	local08, result2
	cmps	local01, local06 wc
 if_ae	jmp	#LR__3894
	wrword	local01, local05
	mov	arg01, local05
	mov	local08, local01
	shl	local08, #4
	add	arg01, local08
	sub	local06, local01
	wrword	local06, arg01
	mov	local08, arg01
	add	local08, #2
	wrword	##27791, local08
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, arg01
	add	local08, #4
	wrword	result1, local08
	mov	local08, local05
	add	local08, #6
	mov	arg02, arg01
	rdword	local08, local08
	add	arg02, #6
	wrword	local08, arg02
	mov	local09, arg01
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, result1
	rdword	local10, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local10, #4
 if_ne	add	arg01, local10
 if_ne	mov	result1, arg01
	mov	local11, result1 wz
 if_e	jmp	#LR__3893
	cmps	local11, local04 wc
 if_ae	jmp	#LR__3893
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local11, #4
	wrword	result1, local11
LR__3893
LR__3894
	add	local07, #6
	wrword	local08, local07
	mov	local09, ##27776
	or	local09, local02
	mov	result1, #0
	cogid	result1
	or	local09, result1
	mov	local11, local05
	add	local11, #2
	wrword	local09, local11
	mov	local09, local03
	add	local09, #8
	mov	local11, local05
	rdword	local09, local09
	add	local11, #6
	wrword	local09, local11
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local03, #8
	wrword	result1, local03
	add	local05, #8
	mov	result1, local05
LR__3895
	mov	ptra, fp
	call	#popregs_
__system___gc_tryalloc_ret
	ret

__system___gc_alloc_managed
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, #0
	call	#__system___gc_doalloc
	mov	arg02, result1 wz
 if_e	cmps	local01, #1 wc
 if_nc_and_z	mov	result1, #0
 if_c_or_nz	mov	result1, arg02
	mov	ptra, fp
	call	#popregs_
__system___gc_alloc_managed_ret
	ret

__system___gc_doalloc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, arg02
 if_e	mov	result1, #0
 if_e	jmp	#LR__3907
	add	local01, #23
	andn	local01, #15
	shr	local01, #4
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	call	#__system___lockmem
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1 wz
 if_ne	jmp	#LR__3900
	call	#__system___gc_docollect
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1
LR__3900
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	wrlong	#0, arg01
	cmp	local03, #0 wz
 if_e	jmp	#LR__3906
	shl	local01, #4
	sub	local01, #8
	abs	local04, local01 wc
	shr	local04, #2
	negc	local05, local04 wz
	mov	local06, local03
 if_e	jmp	#LR__3905
	callpa	#(@LR__3903-@LR__3901)>>2,fcache_load_ptr_
LR__3901
	rep	@LR__3904, local05
LR__3902
	wrlong	#0, local06
	add	local06, #4
LR__3903
LR__3904
LR__3905
LR__3906
	mov	result1, local03
LR__3907
	mov	ptra, fp
	call	#popregs_
__system___gc_doalloc_ret
	ret

__system___gc_isvalidptr
	bitl	arg03, #248
	sub	arg03, #8
	cmps	arg03, arg01 wc
 if_b	jmp	#LR__3910
	cmps	arg03, arg02 wc
 if_b	jmp	#LR__3911
LR__3910
	mov	result1, #0
	jmp	#__system___gc_isvalidptr_ret
LR__3911
	mov	_var01, arg03
	xor	_var01, arg01
	test	_var01, #15 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___gc_isvalidptr_ret
	mov	_var01, arg03
	add	_var01, #2
	rdword	_var01, _var01
	and	_var01, ##65472
	cmp	_var01, ##27776 wz
 if_ne	mov	result1, #0
 if_e	mov	result1, arg03
__system___gc_isvalidptr_ret
	ret

__system___gc_free
	mov	arg03, arg01
	call	#__system___gc_ptrs
	mov	arg01, result1
	mov	arg02, result2
	call	#__system___gc_isvalidptr
	mov	arg02, result1 wz
 if_e	jmp	#LR__3920
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	call	#__system___lockmem
	mov	arg01, arg02
	call	#__system___gc_dofree
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	wrlong	#0, arg01
LR__3920
__system___gc_free_ret
	ret

__system___gc_dofree
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	call	#__system___gc_ptrs
	mov	local02, result1
	mov	local03, result2
	mov	arg02, local01
	add	arg02, #2
	wrword	##27791, arg02
	mov	local04, local01
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	callpa	#(@LR__3931-@LR__3930)>>2,fcache_load_ptr_
LR__3930
	add	local04, #4
	rdword	arg02, local04 wz
	mov	arg01, local02
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_e	jmp	#LR__3932
	mov	arg01, local04
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__3930
LR__3931
LR__3932
	cmp	local04, #0 wz
 if_e	mov	local04, local02
	mov	arg02, local04
	add	arg02, #6
	mov	arg01, local01
	rdword	arg02, arg02
	add	arg01, #6
	wrword	arg02, arg01
	mov	arg02, local01 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local04
	add	arg02, #6
	wrword	result1, arg02
	cmp	local04, local02 wz
 if_e	jmp	#LR__3935
	mov	arg01, local04
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	cmp	result1, local01 wz
 if_ne	jmp	#LR__3934
	rdword	local06, local04
	rdword	arg02, local01
	add	local06, arg02
	wrword	local06, local04
	mov	local06, local01
	add	local06, #2
	wrword	#0, local06
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	cmps	local06, local03 wc
 if_ae	jmp	#LR__3933
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local06
	add	arg02, #4
	wrword	result1, arg02
LR__3933
	mov	arg02, local01
	add	arg02, #6
	mov	result2, local04
	rdword	arg02, arg02
	add	result2, #6
	wrword	arg02, result2
	add	local01, #6
	wrword	#0, local01
	mov	local01, local04
LR__3934
LR__3935
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	arg02, result1 wz
 if_e	jmp	#LR__3937
	cmps	arg02, local03 wc
 if_ae	jmp	#LR__3937
	mov	arg01, arg02
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__3937
	mov	local04, local01
	rdword	local06, local04
	mov	arg01, arg02
	rdword	local01, arg01
	add	local06, local01
	wrword	local06, local04
	mov	local06, arg01
	add	local06, #6
	mov	local01, local04
	rdword	local06, local06
	add	local01, #6
	wrword	local06, local01
	mov	local06, arg01
	add	local06, #2
	wrword	#170, local06
	mov	local06, arg01
	add	local06, #6
	wrword	#0, local06
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1 wz
 if_e	jmp	#LR__3936
	cmps	local06, local03 wc
 if_ae	jmp	#LR__3936
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local04, local06
	add	local04, #4
	wrword	result1, local04
LR__3936
LR__3937
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___gc_dofree_ret
	ret

__system___gc_docollect
	mov	COUNT_, #5
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result2
	mov	local02, result1
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
	mov	result1, #0
	cogid	result1
	mov	local05, result1
 if_e	jmp	#LR__3942
	callpa	#(@LR__3941-@LR__3940)>>2,fcache_load_ptr_
LR__3940
	cmps	local04, local01 wc
 if_ae	jmp	#LR__3942
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	andn	arg02, #32
	mov	arg01, local04
	add	arg01, #2
	wrword	arg02, arg01
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_ne	jmp	#LR__3940
LR__3941
LR__3942
	mov	local03, #0
	mov	arg01, #0
	call	#__system____topofstack
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___gc_markhub
	call	#__system___gc_markcog
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1 wz
 if_e	jmp	#LR__3946
LR__3943
	mov	local04, local02
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	test	arg02, #32 wz
 if_e	test	arg02, #16 wz
 if_ne	jmp	#LR__3945
	getnib	arg02, arg02, #0
	cmp	arg02, local05 wz
 if_ne	cmp	arg02, #14 wz
 if_ne	jmp	#LR__3944
	mov	arg01, local04
	call	#__system___gc_dofree
	mov	local02, result1
LR__3944
LR__3945
	cmp	local02, #0 wz
 if_ne	cmps	local02, local01 wc
 if_c_and_nz	jmp	#LR__3943
LR__3946
	mov	ptra, fp
	call	#popregs_
__system___gc_docollect_ret
	ret

__system___gc_markhub
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
LR__3950
	cmps	local01, local02 wc
 if_ae	jmp	#LR__3951
	rdlong	arg03, local01
	add	local01, #4
	mov	arg02, local04
	mov	arg01, local03
	call	#__system___gc_isvalidptr
	mov	arg03, result1 wz
 if_e	jmp	#LR__3950
	mov	arg01, arg03
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3950
	mov	result2, arg03
	add	result2, #2
	rdword	result2, result2
	andn	result2, #15
	or	result2, #46
	add	arg03, #2
	wrword	result2, arg03
	jmp	#LR__3950
LR__3951
	mov	ptra, fp
	call	#popregs_
__system___gc_markhub_ret
	ret

__system___gc_markcog
	mov	COUNT_, #4
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result1
	mov	local02, result2
	mov	local03, #495
LR__3960
	'.live	local03
	alts	local03, #0
	mov	local04, local03
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local04
	call	#__system___gc_isvalidptr
	cmp	result1, #0 wz
 if_e	jmp	#LR__3961
	mov	local04, result1
	add	local04, #2
	rdword	local04, local04
	or	local04, #32
	add	result1, #2
	wrword	local04, result1
LR__3961
	sub	local03, #1
	cmps	local03, #0 wc
 if_ae	jmp	#LR__3960
	mov	ptra, fp
	call	#popregs_
__system___gc_markcog_ret
	ret

__system___get_vfs_file_handle
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system___find_free_file
	mov	local01, result1
	cmps	local01, #0 wc
 if_ae	qmul	local01, #52
 if_b	mov	result1, #0
 if_ae	mov	local01, ptr___system__dat__
 if_ae	add	local01, ##1324
 if_ae	getqx	result1
 if_ae	add	result1, local01
	mov	ptra, fp
	call	#popregs_
__system___get_vfs_file_handle_ret
	ret

__system__opendir
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, ptr___system__dat__
	add	local01, #388
	mov	arg02, arg01
	mov	arg01, local01
	mov	arg03, #0
	call	#__system____getvfsforfile
	mov	local02, result1 wz
 if_e	jmp	#LR__3970
	add	local02, #40
	rdlong	arg03, local02 wz
	sub	local02, #40
 if_ne	jmp	#LR__3971
LR__3970
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__3973
LR__3971
	mov	arg01, #92
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	mov	result1, #0
 if_e	jmp	#LR__3973
	add	local02, #40
	rdlong	local04, local02
	mov	local05, local04
	sub	local02, #40
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local03
	mov	arg02, local01
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	mov	arg03, result1 wz
 if_e	jmp	#LR__3972
	cmps	arg03, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg03, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	arg01, local03
	call	#__system___gc_free
	mov	result1, #0
	jmp	#LR__3973
LR__3972
	wrlong	local02, local03
	mov	result1, local03
LR__3973
	mov	ptra, fp
	call	#popregs_
__system__opendir_ret
	ret

__system__closedir
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	rdlong	arg01, local01
	add	arg01, #44
	rdlong	local02, arg01
	mov	local03, local02
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg01, local01
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
	mov	local04, result1
	mov	arg01, local01
	call	#__system___gc_free
	cmps	local04, #0 wz
	add	ptr___system__dat__, #32
	wrlong	local04, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system__closedir_ret
	ret

__system__readdir
	mov	COUNT_, #4
	call	#pushregs_
	rdlong	arg02, arg01 wz
	mov	local01, arg01
	add	local01, #8
 if_e	mov	result1, #0
 if_e	jmp	#LR__3981
	add	arg02, #48
	rdlong	local02, arg02
	mov	local03, local02
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg02, local01
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
	cmps	result1, #0 wz
 if_e	jmp	#LR__3980
	cmps	result1, #1 wc
 if_ae	cmps	result1, #0 wz
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	result1, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__3981
LR__3980
	mov	result1, local01
LR__3981
	mov	ptra, fp
	call	#popregs_
__system__readdir_ret
	ret

__system___openraw
	mov	COUNT_, #21
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	decod	local05, #15
	mov	local06, local01
	mov	local07, #0
	mov	local08, ptr___system__dat__
	add	local08, #388
	mov	arg01, local08
	mov	arg02, local02
	mov	arg03, #0
	call	#__system____getvfsforfile
	mov	local09, result1 wz
 if_e	jmp	#LR__3990
	add	local09, #32
	rdlong	result1, local09 wz
	sub	local09, #32
 if_ne	jmp	#LR__3991
LR__3990
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__4006
LR__3991
	mov	arg01, local06
	mov	arg02, #0
	mov	arg03, #52
	mov	local10, arg01
	call	#\builtin_bytefill_
	add	local09, #32
	rdlong	local11, local09
	mov	local12, local11
	mov	local13, local11
	sub	local09, #32
	mov	local14, local13
	zerox	local12, #19
	shr	local14, #20
	shl	local14, #2
	add	local14, __methods__
	rdlong	local14, local14
	mov	local15, local06
	mov	local16, local08
	mov	local17, local03
	mov	arg01, local15
	mov	arg02, local16
	mov	arg03, local17
	mov	local18, objptr
	mov	objptr, local12
	call	local14
	mov	objptr, local18
	mov	local19, result1 wz
 if_ne	test	local03, #4 wz
 if_e	jmp	#LR__3992
	add	local09, #36
	rdlong	local11, local09
	mov	local12, local11
	mov	local13, local11
	sub	local09, #36
	mov	local14, local13
	zerox	local12, #19
	shr	local14, #20
	shl	local14, #2
	add	local14, __methods__
	rdlong	local14, local14
	mov	local15, local06
	mov	local16, local08
	mov	local17, local04
	mov	arg01, local15
	mov	arg02, local16
	mov	arg03, local17
	mov	local18, objptr
	mov	objptr, local12
	call	local14
	mov	objptr, local18
	mov	local19, result1
LR__3992
	cmp	local19, #0 wz
 if_ne	jmp	#LR__4004
	mov	local20, local03
	and	local20, #3 wz
 if_ne	or	local05, #2
	cmp	local20, #1 wz
 if_ne	or	local05, #1
	test	local03, #32 wz
 if_ne	or	local05, #384
	add	local06, #8
	wrlong	local05, local06
	add	local06, #12
	rdlong	local21, local06 wz
	sub	local06, #20
 if_ne	jmp	#LR__3993
	add	local09, #4
	rdlong	local21, local09
	sub	local09, #4
	add	local06, #20
	wrlong	local21, local06
	sub	local06, #20
LR__3993
	add	local06, #24
	rdlong	local21, local06 wz
	sub	local06, #24
 if_ne	jmp	#LR__3994
	add	local09, #8
	rdlong	local21, local09
	sub	local09, #8
	add	local06, #24
	wrlong	local21, local06
	sub	local06, #24
LR__3994
	add	local06, #36
	rdlong	local21, local06 wz
	sub	local06, #36
 if_e	rdlong	local21, local09
 if_e	add	local06, #36
 if_e	wrlong	local21, local06
 if_e	sub	local06, #36
	add	local06, #40
	rdlong	local21, local06 wz
	sub	local06, #40
 if_ne	jmp	#LR__3995
	add	local09, #16
	rdlong	local21, local09
	sub	local09, #16
	add	local06, #40
	wrlong	local21, local06
	sub	local06, #40
LR__3995
	add	local06, #48
	rdlong	local21, local06 wz
	sub	local06, #48
 if_ne	jmp	#LR__3996
	add	local09, #12
	rdlong	local21, local09
	sub	local09, #12
	add	local06, #48
	wrlong	local21, local06
	sub	local06, #48
LR__3996
	add	local06, #32
	rdlong	local21, local06 wz
	sub	local06, #32
 if_ne	jmp	#LR__3997
	add	local09, #80
	rdlong	local21, local09
	sub	local09, #80
	add	local06, #32
	wrlong	local21, local06
	sub	local06, #32
LR__3997
	add	local06, #28
	rdlong	local21, local06 wz
	sub	local06, #28
 if_ne	jmp	#LR__3998
	add	local09, #84
	rdlong	local21, local09
	sub	local09, #84
	add	local06, #28
	wrlong	local21, local06
	sub	local06, #28
LR__3998
	add	local06, #28
	rdlong	local21, local06 wz
	sub	local06, #28
 if_ne	jmp	#LR__3999
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##192937984
	add	local06, #28
	wrlong	arg01, local06
	sub	local06, #28
LR__3999
	add	local06, #32
	rdlong	local21, local06 wz
	sub	local06, #32
 if_ne	jmp	#LR__4000
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##193986560
	add	local06, #32
	wrlong	arg01, local06
	sub	local06, #32
LR__4000
	add	local06, #44
	rdlong	local21, local06 wz
	sub	local06, #44
 if_ne	jmp	#LR__4003
	add	local09, #20
	rdlong	local21, local09 wz
	sub	local09, #20
 if_e	jmp	#LR__4001
	add	local09, #20
	rdlong	local21, local09
	add	local06, #44
	wrlong	local21, local06
	sub	local06, #44
	jmp	#LR__4002
LR__4001
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##195035136
	add	local06, #44
	wrlong	arg01, local06
	sub	local06, #44
LR__4002
LR__4003
LR__4004
	cmp	local07, #0 wz
 if_ne	mov	arg01, local06
 if_ne	call	#__system____default_buffer_init
	cmp	local19, #0 wz
 if_e	mov	arg01, #0
 if_ne	jmp	#LR__4005
	cmps	arg01, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
LR__4005
	mov	result1, local19
LR__4006
	mov	ptra, fp
	call	#popregs_
__system___openraw_ret
	ret

__system___closeraw
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4012
	add	local01, #44
	rdlong	result1, local01 wz
	sub	local01, #44
 if_e	jmp	#LR__4010
	add	local01, #44
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #44
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
LR__4010
	add	local01, #36
	rdlong	local05, local01 wz
	sub	local01, #36
 if_e	jmp	#LR__4011
	add	local01, #36
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #36
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local02, result1
LR__4011
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
	mov	result1, local02
LR__4012
	mov	ptra, fp
	call	#popregs_
__system___closeraw_ret
	ret

__system___vfs_open_fat_handle
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4021
	mov	arg01, ##532
	call	#__system___gc_alloc_managed
	mov	local02, result1
	mov	arg01, ##564
	call	#__system___gc_alloc_managed
	mov	local03, objptr
	mov	objptr, local02
	add	objptr, ##528
	wrlong	local01, objptr
' #line 4 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/diskio.cc"
' 
' 
' vfs_file_t *fh;
' 
' DRESULT disk_sethandle(BYTE pdrv, vfs_file_t *fhandle) {
'     fh = fhandle;
'     return RES_OK;
	mov	arg02, ##@LR__5477
	mov	arg01, result1
	mov	arg03, #0
	mov	objptr, local02
	call	#_fatfs_cc_f_mount
	mov	objptr, local03
	mov	arg01, result1 wz
 if_e	jmp	#LR__4020
	neg	arg01, arg01 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__4021
LR__4020
	mov	arg01, local02
	mov	local03, objptr
	mov	objptr, local02
	call	#_fatfs_cc_get_vfs
	mov	objptr, local03
LR__4021
	mov	ptra, fp
	call	#popregs_
__system___vfs_open_fat_handle_ret
	ret

__system___vfs_open_sdcardx
	mov	COUNT_, #4
	call	#pushregs_
	call	#__system___sdmm_open
	mov	local01, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4031
	mov	arg01, local01
	call	#__system___vfs_open_fat_handle
	mov	local02, result1 wz
 if_ne	jmp	#LR__4030
	add	local01, #36
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #36
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local01
LR__4030
	mov	result1, local02
LR__4031
	mov	ptra, fp
	call	#popregs_
__system___vfs_open_sdcardx_ret
	ret

__system____default_getc
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #8
	rdlong	local03, local01
	sub	local01, #8
	test	local03, #8 wz
 if_ne	mov	arg01, local01
 if_ne	call	#__system____default_flush
	add	local01, #8
	rdlong	local03, local01
	or	local03, #4
	wrlong	local03, local01
	sub	local01, #8
	rdlong	local03, local02 wz
 if_ne	jmp	#LR__4040
	mov	arg01, local01
	call	#__system____default_filbuf
	mov	local03, result1
LR__4040
	cmps	local03, #1 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__4041
	sub	local03, #1
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	rdbyte	result1, local03
	add	local03, #1
	wrlong	local03, local02
LR__4041
	mov	ptra, fp
	call	#popregs_
__system____default_getc_ret
	ret

__system____default_putc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local02
	add	local02, #8
	rdlong	arg02, local02
	sub	local02, #8
	test	arg02, #4 wz
 if_ne	mov	arg01, local02
 if_ne	call	#__system____default_flush
	add	local02, #8
	rdlong	local04, local02
	or	local04, #8
	wrlong	local04, local02
	rdlong	local05, local03
	add	local03, #12
	rdlong	arg02, local03
	sub	local03, #12
	mov	result1, local05
	add	result1, arg02
	wrbyte	local01, result1
	getbyte	local01, local01, #0
	add	local05, #1
	wrlong	local05, local03
	sub	local02, #2
	rdword	local06, local02 wz
	sub	local02, #6
 if_ne	add	local03, #8
 if_ne	rdlong	local04, local03
 if_ne	cmp	local05, local04 wz
 if_e	jmp	#LR__4050
	cmp	local01, #10 wz
 if_e	cmp	local06, #1 wz
 if_ne	jmp	#LR__4051
LR__4050
	mov	arg01, local02
	call	#__system____default_flush
	cmp	result1, #0 wz
 if_ne	neg	local01, #1
LR__4051
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system____default_putc_ret
	ret

__system____default_flush
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	rdlong	local03, local02
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #8 wz
 if_e	jmp	#LR__4062
	cmps	local03, #1 wc
 if_b	jmp	#LR__4064
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #128 wz
 if_e	jmp	#LR__4061
	add	local01, #8
	rdlong	arg03, local01
	sub	local01, #8
	test	arg03, #256 wz
 if_e	jmp	#LR__4060
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #2
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	add	local01, #8
	rdlong	local06, local01
	andn	local06, #256
	wrlong	local06, local01
	sub	local01, #8
LR__4060
LR__4061
	add	local01, #24
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #24
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	add	local02, #12
	rdlong	arg02, local02
	sub	local02, #12
	mov	arg01, local01
	mov	arg03, local03
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	jmp	#LR__4064
LR__4062
	add	local01, #8
	rdlong	local06, local01
	sub	local01, #8
	test	local06, #4 wz
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__4063
	neg	arg02, local03
	mov	arg03, arg02
	sar	arg03, #31
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg04, #1
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
LR__4063
LR__4064
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local01, #8
	rdlong	local07, local01
	andn	local07, #12
	wrlong	local07, local01
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system____default_flush_ret
	ret

__system____default_buffer_init
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	call	#__system___isatty
	cmp	result1, #0 wz
 if_ne	add	local01, #6
 if_ne	wrword	#5, local01
 if_e	add	local01, #6
 if_e	wrword	#6, local01
	add	local02, #16
	mov	local01, local02
	sub	local02, #4
	wrlong	local01, local02
	sub	local02, #4
	wrlong	##1024, local02
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system____default_buffer_init_ret
	ret

__system__stat
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, ptr___system__dat__
	add	local02, #388
	mov	arg02, arg01
	mov	arg01, local02
	mov	arg03, #0
	call	#__system____getvfsforfile
	mov	local03, result1 wz
 if_e	jmp	#LR__4070
	add	local03, #52
	rdlong	arg03, local03 wz
	sub	local03, #52
 if_ne	jmp	#LR__4071
LR__4070
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__4072
LR__4071
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #52
	mov	local04, arg01
	call	#\builtin_bytefill_
	mov	result1, local04
	rdbyte	arg01, local02 wz
 if_e	add	local01, #8
 if_e	wrlong	##4607, local01
 if_e	mov	result1, #0
 if_e	jmp	#LR__4072
	add	local03, #52
	rdlong	local03, local03
	mov	local04, local03
	zerox	local03, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local02
	mov	arg02, local01
	mov	local02, objptr
	mov	objptr, local03
	call	local04
	mov	objptr, local02
LR__4072
	mov	ptra, fp
	call	#popregs_
__system__stat_ret
	ret

__system__write
	mov	COUNT_, #1
	call	#pushregs_
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__4080
	qmul	arg01, #52
	mov	local01, ptr___system__dat__
	add	local01, ##1324
	getqx	arg01
	add	arg01, local01
	call	#__system___vfswrite
LR__4080
	mov	ptra, fp
	call	#popregs_
__system__write_ret
	ret

__system__read
	mov	COUNT_, #1
	call	#pushregs_
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__4090
	qmul	arg01, #52
	mov	local01, ptr___system__dat__
	add	local01, ##1324
	getqx	arg01
	add	arg01, local01
	call	#__system___vfsread
LR__4090
	mov	ptra, fp
	call	#popregs_
__system__read_ret
	ret

__system__close
	mov	COUNT_, #1
	call	#pushregs_
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__4100
	qmul	arg01, #52
	mov	local01, ptr___system__dat__
	add	local01, ##1324
	getqx	arg01
	add	arg01, local01
	call	#__system___closeraw
LR__4100
	mov	ptra, fp
	call	#popregs_
__system__close_ret
	ret

__system__lseek
	mov	COUNT_, #11
	call	#pushregs_
	mov	local05, arg01
	mov	local01, arg02
	mov	local02, arg03
	mov	local06, arg04
	cmp	local05, #10 wc
 if_b	jmp	#LR__4110
	add	ptr___system__dat__, #32
	wrlong	#5, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result2, #1
	neg	result1, #1
	jmp	#LR__4113
LR__4110
	qmul	local05, #52
	mov	arg01, ptr___system__dat__
	add	arg01, ##1324
	getqx	local07
	add	local07, arg01
	add	local07, #48
	rdlong	local05, local07 wz
	sub	local07, #48
 if_ne	jmp	#LR__4111
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result2, #1
	neg	result1, #1
	jmp	#LR__4113
LR__4111
	add	local07, #8
	rdlong	local08, local07
	sub	local07, #8
	test	local08, #128 wz
 if_ne	add	local07, #8
 if_ne	rdlong	local08, local07
 if_ne	or	local08, #256
 if_ne	wrlong	local08, local07
 if_ne	sub	local07, #8
	mov	arg02, local01
	mov	arg03, local02
	add	local07, #48
	rdlong	local09, local07
	mov	local10, local09
	sub	local07, #48
	zerox	local10, #19
	shr	local09, #20
	shl	local09, #2
	add	local09, __methods__
	rdlong	local09, local09
	mov	arg01, local07
	mov	arg04, local06
	mov	local11, objptr
	mov	objptr, local10
	call	local09
	mov	objptr, local11
	mov	local03, result1
	mov	local04, result2
	mov	arg01, local03
	mov	arg02, local04
	mov	result1, #0
	cmp	arg01, #0 wcz
	cmpsx	arg02, #0 wcz
 if_ne	negc	result1, #1
	cmps	result1, #0 wc
 if_ae	jmp	#LR__4112
	neg	arg01, local03 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	mov	result2, result1
	sar	result2, #31
	jmp	#LR__4113
LR__4112
	mov	result1, local03
	mov	result2, local04
LR__4113
	mov	ptra, fp
	call	#popregs_
__system__lseek_ret
	ret

__system___ioctl
	mov	COUNT_, #3
	call	#pushregs_
	cmps	arg01, #0 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4121
	add	arg01, #40
	rdlong	local01, arg01
	mov	local02, local01
	sub	arg01, #40
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	arg01, result1 wz
 if_e	jmp	#LR__4120
	cmps	arg01, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__4121
LR__4120
	mov	result1, #0
LR__4121
	mov	ptra, fp
	call	#popregs_
__system___ioctl_ret
	ret

__system___isatty
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	mov	arg03, fp
	add	arg03, #8
	mov	arg02, #256
	call	#__system___ioctl
	cmp	result1, #0 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system___isatty_ret
	ret

__system____getftab
	cmp	arg01, #10 wc
 if_b	qmul	arg01, #52
 if_ae	mov	result1, #0
 if_b	mov	arg01, ptr___system__dat__
 if_b	add	arg01, ##1324
 if_b	getqx	result1
 if_b	add	result1, arg01
__system____getftab_ret
	ret

__system__strncpy
	mov	_var01, arg01
LR__4130
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_b	jmp	#LR__4131
	mov	result1, arg02
	add	result1, #1
	rdbyte	_var02, arg02
	mov	arg02, result1
	wrbyte	_var02, _var01
	getbyte	_var02, _var02, #0
	zerox	_var02, #7 wz
	add	_var01, #1
 if_ne	jmp	#LR__4130
LR__4131
	callpa	#(@LR__4133-@LR__4132)>>2,fcache_load_ptr_
LR__4132
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_ae	mov	_var03, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	#0, _var03
 if_ae	jmp	#LR__4132
LR__4133
	mov	result1, arg01
__system__strncpy_ret
	ret

__system__strncat
	cmps	arg02, #0 wz
 if_e	jmp	#LR__4145
	cmp	arg03, #1 wc
 if_b	jmp	#LR__4145
	mov	_var01, arg01
	callpa	#(@LR__4141-@LR__4140)>>2,fcache_load_ptr_
LR__4140
	rdbyte	result1, _var01 wz
 if_ne	add	_var01, #1
 if_ne	jmp	#LR__4140
LR__4141
	mov	_var02, arg03
	callpa	#(@LR__4143-@LR__4142)>>2,fcache_load_ptr_
LR__4142
	rdbyte	_var03, arg02
	mov	_var04, _var03
	zerox	_var04, #7 wz
	add	arg02, #1
 if_e	jmp	#LR__4144
	sub	_var02, #1
	cmps	_var02, #0 wc
 if_ae	mov	_var04, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	_var03, _var04
 if_ae	jmp	#LR__4142
LR__4143
LR__4144
	wrbyte	#0, _var01
LR__4145
	mov	result1, arg01
__system__strncat_ret
	ret

__system__strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__4150
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#__system__strncmp_ret
LR__4150
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#__system__strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__4152-@LR__4151)>>2,fcache_load_ptr_
LR__4151
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__4153
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__4151
LR__4152
LR__4153
	cmps	_var03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#__system__strncmp_ret
	cmp	_var04, _var06 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system__strncmp_ret
	cmp	_var04, #0 wz
 if_e	neg	result1, #1
 if_e	jmp	#__system__strncmp_ret
	cmp	_var06, #0 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
__system__strncmp_ret
	ret

__system____root_opendir
	mov	result1, ptr___system__dat__
	add	result1, #100
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, #0
__system____root_opendir_ret
	ret

__system____root_readdir
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	add	local01, #4
	rdlong	local03, local01
	sub	local01, #4
LR__4160
	mov	arg03, ptr___system__dat__
	add	arg03, #116
	cmp	local03, arg03 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__4161
	rdlong	arg03, local03 wz
 if_e	add	local03, #4
 if_e	jmp	#LR__4160
	rdlong	arg02, local03
	add	arg02, #1
	mov	arg01, local02
	mov	arg03, #64
	call	#__system__strncpy
	add	local02, #80
	wrbyte	#1, local02
	sub	local02, #8
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local03, #4
	add	local01, #4
	wrlong	local03, local01
	mov	result1, #0
LR__4161
	mov	ptra, fp
	call	#popregs_
__system____root_readdir_ret
	ret

__system____root_closedir
	mov	result1, #0
__system____root_closedir_ret
	ret

__system____root_stat
	mov	_var01, arg02
	mov	arg01, _var01
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
	add	_var01, #8
	wrlong	##4607, _var01
	mov	result1, #0
__system____root_stat_ret
	ret

__system___normalizeName
	mov	_var01, #0
	mov	_var02, arg01
	mov	_var03, _var02
LR__4170
	rdbyte	_var04, _var02 wz
 if_e	jmp	#LR__4189
	cmp	_var01, #0 wz
 if_ne	mov	_var04, _var03
 if_ne	add	_var03, #1
 if_ne	wrbyte	#47, _var04
 if_ne	mov	_var01, #0
	rdbyte	_var04, _var02
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__4182
	add	_var02, #1
	rdbyte	_var04, _var02
	sub	_var02, #1
	cmp	_var04, #47 wz
 if_e	jmp	#LR__4171
	add	_var02, #1
	rdbyte	_var05, _var02
	sub	_var02, #1
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__4172
LR__4171
	mov	_var07, _var02
	add	_var07, #1
	mov	_var02, _var07
	jmp	#LR__4186
LR__4172
	add	_var02, #1
	rdbyte	_var07, _var02
	sub	_var02, #1
	getbyte	_var04, _var07, #0
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__4181
	add	_var02, #2
	rdbyte	_var07, _var02
	sub	_var02, #2
	getbyte	_var04, _var07, #0
	cmp	_var04, #47 wz
 if_e	jmp	#LR__4173
	add	_var02, #2
	rdbyte	_var05, _var02
	sub	_var02, #2
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__4180
LR__4173
	add	_var02, #2
	cmps	_var03, arg01 wcz
 if_be	jmp	#LR__4179
	mov	_var08, _var03
	sub	_var08, #1
LR__4174
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__4175
	cmps	_var08, arg01 wcz
 if_a	sub	_var08, #1
 if_a	jmp	#LR__4174
LR__4175
	callpa	#(@LR__4177-@LR__4176)>>2,fcache_load_ptr_
LR__4176
	cmps	_var08, arg01 wcz
 if_be	jmp	#LR__4178
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	sub	_var08, #1
 if_ne	jmp	#LR__4176
LR__4177
LR__4178
	mov	_var03, _var08
LR__4179
	mov	_var01, #1
	jmp	#LR__4186
LR__4180
LR__4181
LR__4182
	callpa	#(@LR__4184-@LR__4183)>>2,fcache_load_ptr_
LR__4183
	rdbyte	_var04, _var02 wz
 if_ne	mov	_var07, _var04
 if_ne	cmp	_var07, #47 wz
 if_e	jmp	#LR__4185
	mov	_var06, _var02
	mov	_var05, _var02
	add	_var05, #1
	rdbyte	_var09, _var06
	mov	_var02, _var05
	wrbyte	_var09, _var03
	add	_var03, #1
	jmp	#LR__4183
LR__4184
LR__4185
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__4170
	mov	_var01, #1
LR__4186
	callpa	#(@LR__4188-@LR__4187)>>2,fcache_load_ptr_
LR__4187
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_e	mov	_var07, _var02
 if_e	add	_var07, #1
 if_e	mov	_var02, _var07
 if_e	jmp	#LR__4187
LR__4188
	jmp	#LR__4170
LR__4189
	wrbyte	#0, _var03
__system___normalizeName_ret
	ret

__system___strrev
	rdbyte	_var01, arg01 wz
 if_e	jmp	#__system___strrev_ret
	mov	_var02, arg01
	callpa	#(@LR__4191-@LR__4190)>>2,fcache_load_ptr_
LR__4190
	rdbyte	_var01, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__4190
LR__4191
	sub	_var02, #1
	callpa	#(@LR__4193-@LR__4192)>>2,fcache_load_ptr_
LR__4192
	cmps	_var02, arg01 wcz
 if_be	jmp	#LR__4194
	rdbyte	_var01, arg01
	rdbyte	_var03, _var02
	wrbyte	_var03, arg01
	wrbyte	_var01, _var02
	add	arg01, #1
	sub	_var02, #1
	jmp	#LR__4192
LR__4193
LR__4194
__system___strrev_ret
	ret

__system___fmtpad
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg01, local02, #1
	shr	local02, #22
	and	local02, #3 wz
	mov	local04, #0
 if_e	mov	local02, #1
	test	local02, arg04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4203
	subr	local03, arg01
	cmps	local03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__4203
	cmp	local02, #3 wz
 if_ne	jmp	#LR__4200
	cmp	arg04, #1 wz
	wrz	local02
	add	local03, local02
	abs	local03, local03 wc
	shr	local03, #1
	negc	local03, local03
LR__4200
	cmps	local03, #1 wc
 if_b	jmp	#LR__4202
	mov	local05, local03
LR__4201
	mov	local02, local01
	mov	local06, local01
	zerox	local02, #19
	shr	local06, #20
	shl	local06, #2
	add	local06, __methods__
	rdlong	local06, local06
	mov	arg01, #32
	mov	local03, objptr
	mov	objptr, local02
	call	local06
	mov	objptr, local03
	mov	local06, result1
	cmps	local06, #0 wc
 if_b	mov	result1, local06
 if_b	jmp	#LR__4203
	add	local04, local06
	djnz	local05, #LR__4201
LR__4202
	mov	result1, local04
LR__4203
	mov	ptra, fp
	call	#popregs_
__system___fmtpad_ret
	ret

__system___uitoa
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	cmps	arg05, #0 wz
	mov	arg05, local01
	mov	local02, #0
 if_ne	mov	local03, #55
 if_e	mov	local03, #87
LR__4210
	qdiv	arg02, arg03
	getqy	local04
	qdiv	arg02, arg03
	cmp	local04, #10 wc
 if_b	add	local04, #48
 if_ae	add	local04, local03
	wrbyte	local04, arg05
	add	arg05, #1
	add	local02, #1
	getqx	arg02
	cmp	arg02, #0 wz
 if_ne	jmp	#LR__4210
	cmp	local02, arg04 wc
 if_b	jmp	#LR__4210
	wrbyte	#0, arg05
	mov	arg01, local01
	call	#__system___strrev
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
__system___uitoa_ret
	ret

__system__disassemble_0582
	mov	COUNT_, #16
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
	abs	arg01, local05 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	local07, result1
	mov	local08, #0
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	local09, #0
 if_e	wrlong	#0, local02
 if_e	wrlong	local09, local03
 if_e	jmp	#LR__4232
	mov	arg01, local01
	call	#__system____builtin_ilogb
	mov	local10, result1
	cmp	local05, #10 wz
 if_ne	jmp	#LR__4220
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	abs	local10, local09 wc
	qdiv	local10, #10
	mov	local11, #9
	getqx	local10
	negc	local10, local10
	jmp	#LR__4221
LR__4220
	mov	local11, #24
LR__4221
LR__4222
	cmps	local08, #8 wc
	add	local08, #1
 if_ae	jmp	#LR__4223
	mov	arg01, ##1065353216
	mov	arg02, local07
	mov	arg03, local10
	call	#__system___float_pow_n
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_div
	mov	local12, result1
	mov	arg01, local12
	mov	arg02, ##1065353216
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	sub	local10, #1
 if_b	jmp	#LR__4222
	mov	arg02, local07
	mov	arg01, local12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	add	local10, #1
 if_ae	jmp	#LR__4222
LR__4223
	mov	arg01, local12
	call	#__system____builtin_ilogb
	mov	local13, result1
	mov	local14, local12
	bitl	local14, #279
	bith	local14, #23
	shl	local14, local13
	cmp	local05, #2 wz
 if_e	shl	local04, #2
	mov	local15, #0
	cmps	local04, #0 wc
 if_ae	jmp	#LR__4224
	subr	local04, local10
	cmps	local04, #0 wc
 if_b	jmp	#LR__4231
	jmp	#LR__4225
LR__4224
	add	local04, #1
LR__4225
	fles	local04, local11 wcz
	mov	local16, #1
	callpa	#(@LR__4227-@LR__4226)>>2,fcache_load_ptr_
LR__4226
	cmp	local15, ##8388608 wc
 if_ae	jmp	#LR__4228
	cmps	local04, #1 wc
	sub	local04, #1
 if_b	jmp	#LR__4228
	qmul	local15, local05
	mov	local13, local14
	shr	local13, #23
	bitl	local14, #279
	getqx	local15
	qmul	local16, local05
	getqx	local16
	qmul	local14, local05
	add	local15, local13
	getqx	local14
	jmp	#LR__4226
LR__4227
LR__4228
	mov	local09, local05
	shl	local09, #23
	abs	local13, local09 wc
	shr	local13, #1
	negc	local13, local13
	cmp	local14, local13 wcz
 if_a	jmp	#LR__4229
	shl	local05, #23
	abs	local13, local05 wc
	shr	local13, #1
	negc	local13, local13
	cmp	local14, local13 wz
 if_ne	jmp	#LR__4230
	test	local15, #1 wz
 if_e	jmp	#LR__4230
LR__4229
	add	local15, #1
	cmp	local15, local16 wz
 if_e	add	local10, #1
LR__4230
LR__4231
	wrlong	local15, local02
	wrlong	local10, local03
LR__4232
	mov	ptra, fp
	call	#popregs_
__system__disassemble_0582_ret
	ret

__system__emitsign_0584
	mov	result1, #0
	cmp	arg02, #0 wz
 if_ne	mov	_var01, arg01
 if_ne	add	arg01, #1
 if_ne	wrbyte	arg02, _var01
 if_ne	mov	result1, #1
	cmp	arg03, #0 wz
 if_ne	wrbyte	#48, arg01
 if_ne	add	arg01, #1
 if_ne	wrbyte	arg03, arg01
 if_ne	add	result1, #2
__system__emitsign_0584_ret
	ret

__system___getiolock_0622
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__4240
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__4241
LR__4240
	mov	result1, ptr___system__dat__
	add	result1, ##732
	jmp	#LR__4242
LR__4241
	add	local01, #12
	mov	result1, local01
LR__4242
	mov	ptra, fp
	call	#popregs_
__system___getiolock_0622_ret
	ret

__system___gettxfunc
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__4250
	add	local01, #8
	rdlong	arg02, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__4251
LR__4250
	mov	result1, #0
	jmp	#LR__4252
LR__4251
	or	local01, ##185597952
	mov	result1, local01
LR__4252
	mov	ptra, fp
	call	#popregs_
__system___gettxfunc_ret
	ret

__system___getrxfunc
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__4260
	add	local01, #8
	rdlong	arg02, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__4261
LR__4260
	mov	result1, #0
	jmp	#LR__4262
LR__4261
	or	local01, ##186646528
	mov	result1, local01
LR__4262
	mov	ptra, fp
	call	#popregs_
__system___getrxfunc_ret
	ret

__system____ScanForChar
	mov	_var01, arg01
	mov	_var02, arg01
	callpa	#(@LR__4271-@LR__4270)>>2,fcache_load_ptr_
LR__4270
	rdbyte	result1, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__4270
LR__4271
	sub	_var02, arg01
	mov	result1, _var02
	mov	arg01, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4278
	mov	_var03, arg02
	zerox	_var03, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4278
	cmp	arg03, #1 wc
 if_b	cmp	arg04, #0 wz
 if_c_and_z	mov	arg03, #1
 if_c_and_nz	mov	result1, #0
 if_c_and_nz	jmp	#LR__4278
	cmp	arg03, arg01 wcz
 if_be	jmp	#LR__4272
	cmp	arg04, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4278
	mov	arg03, arg01
LR__4272
	sub	arg03, #1
	cmp	arg04, #0 wz
 if_ne	jmp	#LR__4274
	mov	_var04, arg03
	mov	_var05, arg01
LR__4273
	cmp	_var04, _var05 wc
 if_ae	jmp	#LR__4277
	mov	_var03, _var04
	add	_var03, _var01
	rdbyte	_var03, _var03
	getbyte	arg04, arg02, #0
	cmp	_var03, arg04 wz
 if_e	add	_var04, #1
 if_e	mov	result1, _var04
 if_e	jmp	#LR__4278
	add	_var04, #1
	jmp	#LR__4273
LR__4274
	mov	_var04, arg03
LR__4275
	cmp	_var04, arg03 wcz
 if_a	jmp	#LR__4276
	mov	_var05, _var04
	add	_var05, _var01
	rdbyte	_var03, _var05
	getbyte	_var05, arg02, #0
	cmp	_var03, _var05 wz
 if_e	add	_var04, #1
 if_e	mov	result1, _var04
 if_e	jmp	#LR__4278
	sub	_var04, #1
	jmp	#LR__4275
LR__4276
LR__4277
	mov	result1, #0
LR__4278
__system____ScanForChar_ret
	ret

__system___basic_dir
	mov	COUNT_, #6
	call	#pushregs_
	add	ptra, #80
	mov	local01, arg01 wz
	mov	local02, arg02
 if_ne	rdbyte	local03, local01 wz
 if_e	jmp	#LR__4280
	add	ptr___system__dat__, ##1844
	rdlong	local03, ptr___system__dat__ wz
	sub	ptr___system__dat__, ##1844
 if_ne	add	ptr___system__dat__, ##1844
 if_ne	rdlong	arg01, ptr___system__dat__
 if_ne	sub	ptr___system__dat__, ##1844
 if_ne	call	#__system__closedir
	mov	arg01, ##@LR__5478
	call	#__system__opendir
	add	ptr___system__dat__, ##1844
	wrlong	result1, ptr___system__dat__
	add	ptr___system__dat__, #4
	wrlong	local02, ptr___system__dat__
	add	ptr___system__dat__, #4
	wrlong	local01, ptr___system__dat__
	sub	ptr___system__dat__, ##1852
LR__4280
	add	ptr___system__dat__, ##1844
	rdlong	local03, ptr___system__dat__ wz
	sub	ptr___system__dat__, ##1844
 if_e	mov	result1, ##@LR__5479
 if_e	jmp	#LR__4288
LR__4281
	add	ptr___system__dat__, ##1844
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1844
	call	#__system__readdir
	mov	local04, result1 wz
 if_ne	jmp	#LR__4282
	add	ptr___system__dat__, ##1844
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1844
	call	#__system__closedir
	add	ptr___system__dat__, ##1844
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, ##1844
	mov	result1, ##@LR__5480
	jmp	#LR__4288
LR__4282
	add	ptr___system__dat__, ##1852
	rdlong	arg02, ptr___system__dat__
	sub	ptr___system__dat__, ##1852
	mov	arg01, local04
	call	#__system___pat_match
	cmp	result1, #0 wz
 if_e	jmp	#LR__4281
	add	ptr___system__dat__, ##1848
	rdlong	local03, ptr___system__dat__ wz
	sub	ptr___system__dat__, ##1848
 if_e	jmp	#LR__4285
	mov	arg02, fp
	add	arg02, #16
	mov	arg01, local04
	call	#__system__stat
	cmps	result1, #0 wz
 if_ne	mov	result1, ##@LR__5481
 if_ne	jmp	#LR__4288
	add	fp, #24
	rdlong	local05, fp
	sub	fp, #24
	and	local05, ##61440
	rdbyte	local03, local04
	cmp	local03, #46 wz
 if_e	mov	local02, #2
 if_ne	mov	local02, #0
	cmp	local05, ##4096 wz
 if_e	or	local02, #16
 if_e	jmp	#LR__4284
	cmp	local05, ##8192 wz
 if_ne	cmp	local05, ##12288 wz
 if_ne	cmp	local05, ##16384 wz
 if_e	or	local02, #4
 if_e	jmp	#LR__4283
	add	fp, #24
	rdlong	local03, fp
	sub	fp, #24
	test	local03, #146 wz
 if_e	or	local02, #1
 if_ne	cmp	local05, ##4096 wz
 if_ne	or	local02, #32
LR__4283
LR__4284
	add	ptr___system__dat__, ##1848
	rdlong	local05, ptr___system__dat__
	sub	ptr___system__dat__, ##1848
	test	local02, local05 wz
 if_e	jmp	#LR__4281
LR__4285
	mov	arg01, local04
	mov	local06, arg01
	callpa	#(@LR__4287-@LR__4286)>>2,fcache_load_ptr_
LR__4286
	rdbyte	result1, local06 wz
 if_ne	add	local06, #1
 if_ne	jmp	#LR__4286
LR__4287
	subr	arg01, local06
	add	arg01, #1
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_ne	mov	arg01, local05
 if_ne	mov	arg02, local04
 if_ne	call	#__system____builtin_strcpy
	mov	result1, local05
LR__4288
	mov	ptra, fp
	call	#popregs_
__system___basic_dir_ret
	ret

__system__pack_0698
	mov	_var01, arg01
	add	arg03, #127
	test	arg04, #4 wz
 if_e	jmp	#LR__4290
	cmp	_var01, #0 wz
 if_e	decod	_var01, #22
	bith	_var01, #247
	jmp	#LR__4299
LR__4290
	test	arg04, #2 wz
 if_ne	mov	_var01, ##2139095040
 if_ne	mov	arg02, #0
 if_ne	jmp	#LR__4298
	test	arg04, #8 wz
 if_ne	mov	_var01, #0
 if_ne	jmp	#LR__4297
	cmps	arg03, #255 wc
 if_ae	mov	_var01, ##2139095040
 if_ae	mov	arg02, #0
 if_ae	jmp	#LR__4296
	cmps	arg03, #1 wc
 if_ae	jmp	#LR__4294
	shr	arg02, #1
	mov	_var02, _var01
	and	_var02, #1
	shl	_var02, #31
	or	arg02, _var02
	shr	_var01, #1
	callpa	#(@LR__4292-@LR__4291)>>2,fcache_load_ptr_
LR__4291
	cmps	arg03, #0 wc
 if_ae	jmp	#LR__4293
	cmp	_var01, #0 wz
 if_e	jmp	#LR__4293
	mov	arg01, arg02
	and	arg01, #1
	add	arg03, #1
	shr	arg02, #1
	mov	_var02, _var01
	and	_var02, #1
	shl	_var02, #31
	or	arg02, _var02
	or	arg02, arg01
	shr	_var01, #1
	jmp	#LR__4291
LR__4292
LR__4293
	cmps	arg03, #0 wc
 if_ae	jmp	#LR__4295
	cmp	arg02, #0 wz
	wrnz	arg02
	jmp	#LR__4295
LR__4294
	bitl	_var01, #279
	shl	arg03, #23
	or	_var01, arg03
LR__4295
LR__4296
LR__4297
LR__4298
LR__4299
	test	_var01, #1 wz
 if_ne	or	arg02, #1
	mov	arg03, arg02
	mov	_var02, #0
	add	arg02, ##2147483647
	cmp	arg02, arg03 wc
 if_b	mov	_var02, #1
	add	_var01, _var02
	test	arg04, #1 wz
 if_ne	bith	_var01, #31
	mov	result1, _var01
__system__pack_0698_ret
	ret

__system___rxtxioctl_0788
	cmp	arg02, #256 wz
 if_e	jmp	#LR__4300
	cmp	arg02, #257 wz
 if_e	jmp	#LR__4301
	jmp	#LR__4302
LR__4300
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	wrlong	result1, arg03
	mov	result1, #0
	jmp	#LR__4303
LR__4301
	rdlong	arg01, arg03
	add	ptr___system__dat__, #8
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	mov	result1, #0
	jmp	#LR__4303
LR__4302
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
LR__4303
__system___rxtxioctl_0788_ret
	ret

__system____dummy_flush_0789
	mov	result1, #0
__system____dummy_flush_0789_ret
	ret

__system___vfswrite
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, local02
	add	local01, #8
	rdlong	arg01, local01
	sub	local01, #8
	test	arg01, #2 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4316
	add	local01, #8
	rdlong	result1, local01
	sub	local01, #8
	test	result1, #128 wz
 if_e	jmp	#LR__4311
	add	local01, #8
	rdlong	arg02, local01
	sub	local01, #8
	test	arg02, #256 wz
 if_e	jmp	#LR__4310
	add	local01, #48
	rdlong	local05, local01
	mov	local06, local05
	sub	local01, #48
	zerox	local06, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #2
	mov	local07, objptr
	mov	objptr, local06
	call	local05
	mov	objptr, local07
	add	local01, #8
	rdlong	local07, local01
	andn	local07, #256
	wrlong	local07, local01
	sub	local01, #8
LR__4310
LR__4311
	add	local01, #24
	rdlong	local07, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__4313
	add	local01, #24
	rdlong	local05, local01
	mov	local06, local05
	sub	local01, #24
	zerox	local06, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg02, local02
	mov	arg03, local03
	mov	arg01, local01
	mov	local07, objptr
	mov	objptr, local06
	call	local05
	mov	objptr, local07
	mov	local08, result1
	cmps	local08, #0 wc
 if_ae	jmp	#LR__4312
	add	local01, #8
	rdlong	local07, local01
	or	local07, #32
	wrlong	local07, local01
	cmps	local08, #0 wz
	add	ptr___system__dat__, #32
	wrlong	local08, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__4316
LR__4312
	mov	result1, local08
	jmp	#LR__4316
LR__4313
	add	local01, #28
	rdlong	local09, local01 wz
	sub	local01, #28
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4316
	mov	local08, #0
LR__4314
	cmp	local03, #1 wc
 if_b	jmp	#LR__4315
	mov	local05, local09
	mov	local06, local09
	zerox	local05, #19
	shr	local06, #20
	shl	local06, #2
	add	local06, __methods__
	rdlong	local06, local06
	rdbyte	arg01, local04
	mov	arg02, local01
	mov	local07, objptr
	mov	objptr, local05
	add	local04, #1
	call	local06
	mov	objptr, local07
	add	local08, result1
	sub	local03, #1
	jmp	#LR__4314
LR__4315
	mov	result1, local08
LR__4316
	mov	ptra, fp
	call	#popregs_
__system___vfswrite_ret
	ret

__system___vfsread
	mov	COUNT_, #9
	call	#pushregs_
	add	ptra, #40
	mov	local01, arg01
	mov	local02, arg03
	mov	local03, arg02
	mov	local04, #0
	add	local01, #8
	rdlong	arg01, local01
	sub	local01, #8
	test	arg01, #1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4326
	add	local01, #20
	rdlong	result1, local01 wz
	sub	local01, #20
 if_e	jmp	#LR__4321
	add	local01, #20
	rdlong	local05, local01
	mov	local03, local05
	sub	local01, #20
	zerox	local03, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg03, local02
	mov	arg01, local01
	mov	local04, objptr
	mov	objptr, local03
	call	local05
	mov	objptr, local04
	mov	local06, result1
	cmps	local06, #0 wc
 if_ae	jmp	#LR__4320
	add	local01, #8
	rdlong	local05, local01
	or	local05, #32
	wrlong	local05, local01
	cmps	local06, #0 wz
	add	ptr___system__dat__, #32
	wrlong	local06, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__4326
LR__4320
	mov	result1, local06
	jmp	#LR__4326
LR__4321
	add	local01, #32
	rdlong	local07, local01 wz
	sub	local01, #32
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4326
	add	local01, #40
	rdlong	local06, local01 wz
	sub	local01, #40
 if_e	jmp	#LR__4323
	add	local01, #40
	rdlong	local05, local01
	mov	local08, local05
	sub	local01, #40
	zerox	local08, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg01, local01
	mov	arg03, fp
	add	arg03, #36
	mov	arg02, #256
	mov	local06, objptr
	mov	objptr, local08
	call	local05
	mov	objptr, local06
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4322
	add	fp, #36
	rdlong	local06, fp
	sub	fp, #36
	test	local06, #2 wz
 if_ne	mov	local04, #1
LR__4322
LR__4323
	mov	local06, #0
LR__4324
	cmp	local02, #1 wc
 if_b	jmp	#LR__4325
	mov	local08, local07
	mov	local05, local07
	zerox	local08, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg01, local01
	mov	local09, objptr
	mov	objptr, local08
	call	local05
	mov	objptr, local09
	cmps	result1, #0 wc
 if_b	jmp	#LR__4325
	wrbyte	result1, local03
	add	local06, #1
	sub	local02, #1
	cmp	local04, #0 wz
	add	local03, #1
 if_e	jmp	#LR__4324
	cmp	result1, #10 wz
 if_ne	jmp	#LR__4324
LR__4325
	mov	result1, local06
LR__4326
	mov	ptra, fp
	call	#popregs_
__system___vfsread_ret
	ret

__system___sdmm_open
	mov	COUNT_, #11
	call	#pushregs_
	mov	local03, arg01
	mov	local04, arg02
	mov	local05, arg03
	mov	local06, arg04
	mov	arg01, #40
	call	#__system___gc_alloc_managed
	mov	local07, result1
	mov	arg04, local03
	sar	arg04, #31
	mov	arg03, local03
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	local01, result1
	mov	local08, result2
	mov	arg04, local04
	sar	arg04, #31
	mov	arg03, local04
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local08, result2
	mov	arg04, local05
	sar	arg04, #31
	mov	arg03, local05
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local08, result2
	mov	arg04, local06
	sar	arg04, #31
	mov	arg03, local06
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	arg02, local08
	or	local01, result1
	or	result2, arg02
	mov	local02, result2
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___usepins
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4330
	mov	arg01, local07
	call	#__system___gc_free
	add	ptr___system__dat__, #32
	wrlong	#22, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__4333
LR__4330
	mov	local09, local01
	mov	arg05, local02
	add	local07, #32
	wrlong	local09, local07
	add	local07, #4
	wrlong	arg05, local07
	sub	local07, #36
	mov	arg04, local05
	mov	arg05, local06
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, local04
	mov	local10, objptr
	mov	objptr, local07
	call	#_sdmm_cc_disk_setpins
	mov	objptr, local10
	mov	local11, result1 wz
 if_ne	jmp	#LR__4331
	mov	arg01, #0
	mov	local11, objptr
	mov	objptr, local07
	call	#_sdmm_cc_disk_initialize
	mov	objptr, local11
	getbyte	local11, result1, #0
LR__4331
	cmp	local11, #0 wz
 if_ne	jmp	#LR__4332
	call	#__system___get_vfs_file_handle
	mov	local11, result1 wz
 if_e	jmp	#LR__4332
	add	local11, #4
	wrword	#2, local11
	add	local11, #2
	wrword	#0, local11
	add	local11, #2
	wrlong	##32771, local11
	mov	result1, local07
	or	result1, ##214958080
	add	local11, #12
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##216006656
	add	local11, #4
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##217055232
	add	local11, #12
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##218103808
	add	local11, #4
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##219152384
	add	local11, #4
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##220200960
	add	local11, #4
	wrlong	result1, local11
	mov	result1, local07
	or	result1, ##221249536
	sub	local11, #20
	wrlong	result1, local11
	or	local07, ##222298112
	add	local11, #4
	wrlong	local07, local11
	sub	local11, #32
	mov	result1, local11
	jmp	#LR__4333
LR__4332
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___freepins
	mov	arg01, local07
	call	#__system___gc_free
	add	ptr___system__dat__, #32
	wrlong	#12, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
LR__4333
	mov	ptra, fp
	call	#popregs_
__system___sdmm_open_ret
	ret

__system____default_filbuf
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #8
	rdlong	result1, local02 wz
	sub	local02, #8
 if_ne	jmp	#LR__4340
	add	local02, #16
	mov	result1, local02
	sub	local02, #4
	wrlong	result1, local02
	sub	local02, #4
	wrlong	##1024, local02
	sub	local02, #8
LR__4340
	add	local01, #20
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #20
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	add	local02, #12
	rdlong	arg02, local02
	sub	local02, #4
	rdlong	arg03, local02
	sub	local02, #8
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__4341
	wrlong	local05, local02
	add	local02, #12
	rdlong	local03, local02
	sub	local02, #8
	wrlong	local03, local02
	add	local01, #8
	rdlong	local04, local01
	or	local04, #4
	wrlong	local04, local01
	mov	result1, local05
LR__4341
	mov	ptra, fp
	call	#popregs_
__system____default_filbuf_ret
	ret

__system__getlower_1283
	cmps	arg01, #65 wc
 if_b	jmp	#LR__4350
	cmps	arg01, #91 wc
 if_b	mov	result1, arg01
 if_b	add	result1, #32
 if_b	jmp	#__system__getlower_1283_ret
LR__4350
	mov	result1, arg01
__system__getlower_1283_ret
	ret

__system___pat_match
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
LR__4360
	rdbyte	arg01, arg02 wz
 if_ne	rdbyte	local02, local01 wz
 if_ne	mov	local03, arg01
 if_ne	cmp	local03, #42 wz
 if_e	jmp	#LR__4361
	rdbyte	arg01, arg02
	call	#__system__getlower_1283
	mov	local02, result1
	rdbyte	arg01, local01
	call	#__system__getlower_1283
	cmp	result1, local02 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4370
	add	local01, #1
	add	arg02, #1
	jmp	#LR__4360
LR__4361
	rdbyte	local03, arg02
	cmp	local03, #42 wz
 if_ne	jmp	#LR__4369
	add	arg02, #1
	rdbyte	local03, arg02
	sub	arg02, #1
	cmp	local03, #46 wz
 if_ne	jmp	#LR__4362
	add	arg02, #2
	rdbyte	local03, arg02
	sub	arg02, #2
	cmp	local03, #42 wz
 if_e	add	arg02, #3
 if_e	rdbyte	local04, arg02
 if_e	sub	arg02, #3
 if_e	mov	local05, local04 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4370
LR__4362
	add	arg02, #1
	mov	local06, #0
	callpa	#(@LR__4364-@LR__4363)>>2,fcache_load_ptr_
LR__4363
	mov	local02, local06
	add	local02, arg02
	rdbyte	local04, local02 wz
 if_ne	mov	local05, local06
 if_ne	add	local05, #1
 if_ne	mov	local06, local05
 if_ne	jmp	#LR__4363
LR__4364
	mov	local07, #0
	callpa	#(@LR__4366-@LR__4365)>>2,fcache_load_ptr_
LR__4365
	mov	local02, local07
	add	local02, local01
	rdbyte	local04, local02 wz
 if_ne	mov	local05, local07
 if_ne	add	local05, #1
 if_ne	mov	local07, local05
 if_ne	jmp	#LR__4365
LR__4366
	cmps	local07, local06 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__4370
	mov	local03, local07
	sub	local03, local06
	add	local01, local03
LR__4367
	cmps	local06, #1 wc
 if_b	jmp	#LR__4368
	rdbyte	arg01, local01
	call	#__system__getlower_1283
	mov	local07, result1
	rdbyte	arg01, arg02
	call	#__system__getlower_1283
	cmp	local07, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4370
	add	local01, #1
	add	arg02, #1
	sub	local06, #1
	jmp	#LR__4367
LR__4368
LR__4369
	rdbyte	local07, arg02 wz
 if_e	rdbyte	local02, local01 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, #0
LR__4370
	mov	ptra, fp
	call	#popregs_
__system___pat_match_ret
	ret

_sdmm_cc_disk_initialize
	mov	COUNT_, #15
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, ptra
	rdlong	local03, objptr
	add	objptr, #4
	rdlong	local04, objptr
	add	objptr, #4
	rdlong	local05, objptr
	add	objptr, #4
	rdlong	local06, objptr
	add	objptr, #8
	wrbyte	#1, objptr
	sub	objptr, #20
' #line 539 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
' 		return RES_NOTRDY;
	add	ptra, #12
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4400
	mov	arg01, ##10000
	call	#__system___waitus
	mov	arg04, local03
	sub	arg04, local05
	abs	arg04, arg04
	cmps	arg04, #4 wc
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__4400
	mov	local07, local03
	sub	local07, local06
	abs	local07, local07
	cmps	local07, #4 wc
 if_ae	jmp	#LR__4380
	mov	local08, local03
	sub	local08, local06
	and	local08, #7
	shl	local08, #24
	or	local08, ##21114
	mov	local09, local06
	add	objptr, #12
	wrlong	local09, objptr
	add	objptr, #4
	wrlong	local09, objptr
	sub	objptr, #16
	jmp	#LR__4383
LR__4380
	cmps	local03, local06 wcz
 if_be	jmp	#LR__4381
	mov	local09, local03
	sub	local09, #3
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_e	add	local09, #1
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_ne	jmp	#LR__4382
	add	local09, #1
	jmp	#LR__4382
LR__4381
	mov	local09, local03
	add	local09, #3
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_e	sub	local09, #1
	cmp	local09, local05 wz
 if_ne	cmp	local09, local04 wz
 if_e	sub	local09, #1
LR__4382
	mov	local07, local06
	sub	local07, local09
	abs	local07, local07
	cmps	local07, #4 wc
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__4400
	mov	local08, local06
	sub	local08, local09
	and	local08, #7
	shl	local08, #28
	mov	local07, local03
	sub	local07, local09
	and	local07, #7
	shl	local07, #24
	or	local08, local07
	or	local08, #58
	add	objptr, #16
	wrlong	local06, objptr
	sub	objptr, #4
	wrlong	local09, objptr
	sub	objptr, #12
LR__4383
	wrpin	#0, local04
	drvh	local04
	mov	local10, ##1048608
	dirl	local03
	wrpin	##475208, local03
	wxpin	##1048608, local03
	wypin	#0, local03
	dirh	local03
	mov	local07, local03
	sub	local07, local05
	and	local07, #7
	shl	local07, #24
	mov	local11, #120
	or	local11, local07
	mov	arg02, local11
	bith	arg02, #16
	dirl	local05
	wrpin	arg02, local05
	wxpin	#31, local05
	wypin	##-1, local05
	dirh	local05
	wrpin	##20992, local06
	dirl	local09
	wrpin	local08, local09
	wxpin	#39, local09
	wypin	#0, local09
	dirh	local09
	mov	arg01, local02
	mov	arg02, #10
	call	#_sdmm_cc_rcvr_mmc_0848
	mov	arg01, #0
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0871
	call	#_sdmm_cc_deselect_0858
	mov	arg01, #100
	call	#__system___waitus
	mov	arg01, local02
	mov	arg02, #10
	call	#_sdmm_cc_rcvr_mmc_0848
	mov	local12, #0
	mov	arg01, #0
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0871
	getbyte	local07, result1, #0
	cmp	local07, #1 wz
 if_ne	jmp	#LR__4399
	mov	arg01, #8
	mov	arg02, #426
	call	#_sdmm_cc_send_cmd_0871
	getbyte	result1, result1, #0
	cmp	result1, #1 wz
 if_ne	jmp	#LR__4388
	mov	arg01, local02
	mov	arg02, #4
	call	#_sdmm_cc_rcvr_mmc_0848
	add	local02, #2
	rdbyte	local07, local02
	sub	local02, #2
	cmp	local07, #1 wz
 if_e	add	local02, #3
 if_e	rdbyte	local13, local02
 if_e	sub	local02, #3
 if_e	cmp	local13, #170 wz
 if_ne	jmp	#LR__4398
' 				for (tmr = 1000; tmr; tmr--) {
	mov	local14, ##1000
LR__4384
	mov	arg01, #169
	decod	arg02, #30
	call	#_sdmm_cc_send_cmd_0871
	mov	local07, result1
	zerox	local07, #7 wz
 if_e	jmp	#LR__4385
	mov	arg01, ##1000
	call	#__system___waitus
	mov	local07, local14
	sub	local14, #1 wz
 if_ne	jmp	#LR__4384
LR__4385
	cmp	local14, #0 wz
 if_e	jmp	#LR__4386
	mov	arg01, #58
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0871
	mov	local07, result1
	zerox	local07, #7 wz
 if_ne	jmp	#LR__4386
	mov	arg01, local02
	mov	arg02, #4
	call	#_sdmm_cc_rcvr_mmc_0848
	rdbyte	local14, local02
	test	local14, #64 wz
 if_ne	mov	local07, #12
 if_e	mov	local07, #4
	mov	local12, local07
LR__4386
	rdlong	local14, #20
	cmp	local14, ##100000001 wc
 if_b	mov	local07, local11
 if_b	bith	local07, #27
 if_b	mov	local11, local07
 if_b	jmp	#LR__4387
	cmp	local14, ##200000001 wc
 if_b	or	local11, ##134283264
LR__4387
	cmp	local14, ##100000001 wc
 if_b	mov	local10, ##131076
 if_b	jmp	#LR__4398
	cmp	local14, ##150000001 wc
 if_b	mov	local10, ##196614
 if_b	jmp	#LR__4398
	cmp	local14, ##200000001 wc
 if_b	mov	local10, ##262152
 if_b	jmp	#LR__4398
	cmp	local14, ##250000001 wc
 if_b	mov	local10, ##327690
 if_b	jmp	#LR__4398
	mov	local10, ##393228
	jmp	#LR__4398
LR__4388
	mov	arg01, #169
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0871
	getbyte	local07, result1, #0
	cmp	local07, #2 wc
 if_b	mov	local12, #2
 if_b	mov	local15, #169
 if_ae	mov	local12, #1
 if_ae	mov	local15, #1
' 				ty =  0x01 ; cmd =  (1) ;
' 			}
' 			for (tmr = 1000; tmr; tmr--) {
	mov	local14, ##1000
LR__4389
	mov	arg01, local15
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0871
	mov	local07, result1
	zerox	local07, #7 wz
 if_e	jmp	#LR__4390
	mov	arg01, ##1000
	call	#__system___waitus
	mov	local07, local14
	sub	local14, #1 wz
 if_ne	jmp	#LR__4389
LR__4390
	cmp	local14, #0 wz
 if_e	jmp	#LR__4391
	mov	arg01, #16
	decod	arg02, #9
	call	#_sdmm_cc_send_cmd_0871
	mov	local07, result1
	zerox	local07, #7 wz
 if_e	jmp	#LR__4392
LR__4391
	mov	local12, #0
LR__4392
	rdlong	local14, #20
	cmp	local14, ##100000001 wc
 if_b	mov	local07, local11
 if_b	bith	local07, #27
 if_b	mov	local11, local07
 if_b	jmp	#LR__4393
	cmp	local14, ##200000001 wc
 if_b	or	local11, ##134283264
LR__4393
	cmp	local14, ##100000001 wc
 if_b	mov	local10, ##131076
 if_b	jmp	#LR__4397
	cmp	local14, ##150000001 wc
 if_b	mov	local10, ##196614
 if_b	jmp	#LR__4396
	cmp	local14, ##200000001 wc
 if_b	mov	local10, ##262152
 if_b	jmp	#LR__4395
	cmp	local14, ##250000001 wc
 if_b	mov	local10, ##327690
 if_b	jmp	#LR__4394
	cmp	local14, ##300000001 wc
 if_b	mov	local10, ##393228
 if_ae	mov	local10, ##458766
LR__4394
LR__4395
LR__4396
LR__4397
LR__4398
LR__4399
	add	objptr, #21
	wrbyte	local12, objptr
	cmp	local12, #0 wz
 if_ne	mov	local07, #0
 if_e	mov	local07, #1
	sub	objptr, #1
	wrbyte	local07, objptr
	sub	objptr, #20
	call	#_sdmm_cc_deselect_0858
	wxpin	local10, local03
	wrpin	local11, local05
' #line 682 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
' 		}
' 	}
' #line 687 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
' 	CardType = ty;
' 	s = ty ? 0 :  0x01 ;
' 	Stat = s;
' 
' 	deselect();
' 
' 
' 	_wxpin( PIN_CLK, ck_div );
' 	_wrpin( PIN_DI, spm_tx );
' #line 700 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
' 	return s;
	mov	result1, local07
LR__4400
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_initialize_ret
	ret

_sdmm_cc_disk_read
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #20
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #20
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4412
	add	objptr, #21
	rdbyte	local04, objptr
	sub	objptr, #21
	test	local04, #8 wz
 if_e	shl	local02, #9
	cmp	local03, #2 wc
 if_ae	mov	local04, #18
 if_b	mov	local04, #17
	mov	arg02, local02
	mov	arg01, local04
	call	#_sdmm_cc_send_cmd_0871
	mov	local05, result1
	zerox	local05, #7 wz
 if_ne	jmp	#LR__4411
' 		do {
LR__4410
	mov	arg01, local01
	decod	arg02, #9
	call	#_sdmm_cc_rcvr_datablock_0866
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local03, #LR__4410
	getbyte	local04, local04, #0
	cmp	local04, #18 wz
 if_e	mov	arg01, #12
 if_e	mov	arg02, #0
 if_e	call	#_sdmm_cc_send_cmd_0871
LR__4411
	call	#_sdmm_cc_deselect_0858
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local03, #0 wz
 if_ne	mov	local05, #1
 if_e	mov	local05, #0
	mov	result1, local05
LR__4412
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_read_ret
	ret

_sdmm_cc_disk_write
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg04
	mov	local03, arg03
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #20
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #20
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4424
	add	objptr, #21
	rdbyte	arg03, objptr
	sub	objptr, #21
	test	arg03, #8 wz
 if_e	shl	local03, #9
	cmp	local02, #1 wz
 if_ne	jmp	#LR__4420
	mov	arg01, #24
	mov	arg02, local03
	call	#_sdmm_cc_send_cmd_0871
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__4423
	mov	arg01, local01
	mov	arg02, #254
	call	#_sdmm_cc_xmit_datablock_0868
	cmp	result1, #0 wz
 if_ne	mov	local02, #0
	jmp	#LR__4423
LR__4420
	add	objptr, #21
	rdbyte	local04, objptr
	sub	objptr, #21
	test	local04, #6 wz
 if_ne	mov	arg01, #151
 if_ne	mov	arg02, local02
 if_ne	call	#_sdmm_cc_send_cmd_0871
	mov	arg02, local03
	mov	arg01, #25
	call	#_sdmm_cc_send_cmd_0871
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__4422
' 			do {
LR__4421
	mov	arg01, local01
	mov	arg02, #252
	call	#_sdmm_cc_xmit_datablock_0868
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local02, #LR__4421
	mov	arg01, #0
	mov	arg02, #253
	call	#_sdmm_cc_xmit_datablock_0868
	cmp	result1, #0 wz
 if_e	mov	local02, #1
LR__4422
LR__4423
	call	#_sdmm_cc_deselect_0858
' 				count = 1;
' 		}
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local02, #0 wz
 if_ne	mov	local04, #1
 if_e	mov	local04, #0
	mov	result1, local04
LR__4424
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_write_ret
	ret

_sdmm_cc_disk_ioctl
	mov	COUNT_, #6
	call	#pushregs_
	add	ptra, #48
	mov	local01, arg02
	mov	local02, arg03
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, #20
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, #20
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4437
	mov	local03, #1
' 
' 	res = RES_ERROR;
' 	switch (ctrl) {
	getbyte	local04, local01, #0
	fle	local04, #4
	jmprel	local04
LR__4430
	jmp	#LR__4431
	jmp	#LR__4432
	jmp	#LR__4435
	jmp	#LR__4434
	jmp	#LR__4435
LR__4431
	call	#_sdmm_cc_select_0862
	cmp	result1, #0 wz
 if_ne	mov	local03, #0
' 			break;
	jmp	#LR__4436
LR__4432
	mov	arg01, #9
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0871
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__4436
	mov	arg01, fp
	add	arg01, #24
	mov	arg02, #16
	call	#_sdmm_cc_rcvr_datablock_0866
	cmp	result1, #0 wz
 if_e	jmp	#LR__4436
	mov	arg01, fp
	add	arg01, #24
	mov	result1, arg01
	add	arg01, #6
	rdlong	local05, arg01
	movbyts	local05, #27
	rdbyte	arg01, result1
	shr	arg01, #6
	cmp	arg01, #1 wz
 if_e	bitl	local05, #310
 if_e	add	local05, #1
 if_e	mov	local06, #10
 if_e	jmp	#LR__4433
	shr	local05, #14
	zerox	local05, #11
	add	local05, #1
	add	result1, #5
	rdbyte	local06, result1
	getnib	local06, local06, #0
	add	result1, #4
	rdword	result1, result1
	movbyts	result1, #27
	shr	result1, #23
	and	result1, #7
	add	local06, result1
	sub	local06, #7
LR__4433
'         cs = (LBA_t)(cs>>14 & 0xfff)+1;
'         n = (csd[5] & 15) + (__builtin_bswap32(*(uint16_t*)(&csd[9]))>>23 & 0x7)+(2-9);
'     }
'     return (LBA_t)cs << n;
	shl	local05, local06
	wrlong	local05, local02
	mov	local03, #0
'                			*(LBA_t*)buff = disc_size(csd);
' 				res = RES_OK;
' 			}
' 			break;
	jmp	#LR__4436
LR__4434
	wrlong	#128, local02
	mov	local03, #0
' 			*(DWORD*)buff = 128;
' 			res = RES_OK;
' 			break;
	jmp	#LR__4436
LR__4435
	mov	local03, #4
LR__4436
	call	#_sdmm_cc_deselect_0858
' 			res = RES_PARERR;
' 	}
' 
' 	deselect();
' 
' 	return res;
	mov	result1, local03
LR__4437
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_ioctl_ret
	ret

_sdmm_cc_xmit_mmc_0841
	rdlong	_var01, objptr
	add	objptr, #8
	rdlong	_var02, objptr
	sub	objptr, #8
	dirl	_var02
	setq	#1
	rdlong	_var03, arg01
	rev	_var03
	movbyts	_var03, #27
	wypin	_var03, _var02
	mov	_var03, arg02
	shr	arg02, #2 wz
	shl	_var03, #3
	wypin	_var03, _var01
	dirh	_var02
	add	arg01, #8
	rev	_var04
	movbyts	_var04, #27
LR__4440
 if_ne	wypin	_var04, _var02
 if_ne	rdlong	_var04, arg01
 if_ne	add	arg01, #4
 if_ne	rev	_var04
 if_ne	movbyts	_var04, #27
LR__4441
 if_ne	testp	_var02 wc
 if_a	jmp	#LR__4441
 if_ne	djnz	arg02, #LR__4440
LR__4442
	testp	_var01 wc
 if_ae	jmp	#LR__4442
	dirl	_var02
	wypin	##-1, _var02
	dirh	_var02
_sdmm_cc_xmit_mmc_0841_ret
	ret

_sdmm_cc_rcvr_mmc_0848
	rdlong	_var01, objptr
	add	objptr, #12
	rdlong	_var02, objptr
	sub	objptr, #12
	akpin	_var02
	mov	_var03, arg02 wz
	shr	_var03, #2 wz
 if_e	jmp	#LR__4452
	mov	_var04, _var03
	shl	_var04, #5
	wypin	_var04, _var01
	wxpin	#63, _var02
LR__4450
LR__4451
	testp	_var02 wc
 if_ae	jmp	#LR__4451
	rdpin	_var04, _var02
	rev	_var04
	movbyts	_var04, #27
	wrlong	_var04, arg01
	add	arg01, #4
	djnz	_var03, #LR__4450
LR__4452
	and	arg02, #3 wz
 if_e	jmp	#LR__4455
	wxpin	#39, _var02
LR__4453
	wypin	#8, _var01
LR__4454
	testp	_var02 wc
 if_ae	jmp	#LR__4454
	rdpin	_var04, _var02
	rev	_var04
	wrbyte	_var04, arg01
	add	arg01, #1
	djnz	arg02, #LR__4453
LR__4455
_sdmm_cc_rcvr_mmc_0848_ret
	ret

_sdmm_cc_wait_ready_0852
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, ptra
	getct	local02
	rdlong	local03, #20
	shr	local03, #1
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 1;
' 	for(;;) {
	add	ptra, #4
LR__4460
	mov	arg01, local01
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0848
	rdbyte	arg02, local01
	cmp	arg02, #255 wz
 if_e	mov	result1, #1
 if_ne	getct	result1
 if_ne	sub	result1, local02
 if_ne	cmp	result1, local03 wc
 if_a	mov	result1, #0
 if_c_and_nz	jmp	#LR__4460
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_wait_ready_0852_ret
	ret

_sdmm_cc_deselect_0858
	mov	COUNT_, #0
	call	#pushregs_
	mov	arg02, ptra
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	add	ptra, #4
	drvh	arg01
	waitx	#16
	mov	arg01, arg02
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0848
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_deselect_0858_ret
	ret

_sdmm_cc_select_0862
	mov	COUNT_, #1
	call	#pushregs_
	mov	arg02, ptra
	add	objptr, #4
	rdlong	arg01, objptr
	add	objptr, #8
	rdlong	local01, objptr
	sub	objptr, #12
	add	ptra, #4
	fltl	local01
	drvl	arg01
	waitx	#16
	dirh	local01
	mov	arg01, arg02
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0848
	call	#_sdmm_cc_wait_ready_0852
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__4470
	call	#_sdmm_cc_deselect_0858
' 
' 	deselect();
' 	return 0;
	mov	result1, #0
LR__4470
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_select_0862_ret
	ret

_sdmm_cc_rcvr_datablock_0866
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, ptra
	getct	local04
	rdlong	local05, #20
	shr	local05, #3
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 3;
' 	for(;;) {
	add	ptra, #4
LR__4480
	mov	arg01, local03
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0848
	rdbyte	arg02, local03
	cmp	arg02, #255 wz
 if_e	getct	result1
 if_e	mov	arg02, result1
 if_e	sub	arg02, local04
 if_e	cmp	arg02, local05 wc
 if_c_and_z	jmp	#LR__4480
	rdbyte	local05, local03
	cmp	local05, #254 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4481
	mov	arg01, local01
	mov	arg02, local02
	call	#_sdmm_cc_rcvr_mmc_0848
	mov	arg01, local03
	mov	arg02, #2
	call	#_sdmm_cc_rcvr_mmc_0848
' 
' 	rcvr_mmc(buff, btr);
' 	rcvr_mmc(d, 2);
' 
' 	return 1;
	mov	result1, #1
LR__4481
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_rcvr_datablock_0866_ret
	ret

_sdmm_cc_xmit_datablock_0868
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, ptra
	add	ptra, #4
	call	#_sdmm_cc_wait_ready_0852
	cmp	result1, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4491
	wrbyte	local02, local03
	mov	arg01, local03
	mov	arg02, #1
	call	#_sdmm_cc_xmit_mmc_0841
	getbyte	local02, local02, #0
	cmp	local02, #253 wz
 if_e	jmp	#LR__4490
	mov	arg01, local01
	decod	arg02, #9
	call	#_sdmm_cc_xmit_mmc_0841
	mov	arg01, local03
	mov	arg02, #2
	call	#_sdmm_cc_rcvr_mmc_0848
	mov	arg01, local03
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0848
	rdbyte	local03, local03
	and	local03, #31
	cmp	local03, #5 wz
' 			return 0;
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4491
LR__4490
' 	}
' 
' 	return 1;
	mov	result1, #1
LR__4491
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_xmit_datablock_0868_ret
	ret

_sdmm_cc_send_cmd_0871
	mov	COUNT_, #4
	call	#pushregs_
_sdmm_cc_send_cmd_0871_enter
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, ptra
	getbyte	result1, local01, #0
	test	result1, #128 wz
	add	ptra, #8
 if_e	jmp	#LR__4500
	getbyte	local01, local01, #0
	and	local01, #127
	mov	arg01, #55
	mov	arg02, #0
	call	#_sdmm_cc_send_cmd_0871
	getbyte	arg02, result1, #0
	cmp	arg02, #2 wc
 if_ae	jmp	#LR__4503
LR__4500
	getbyte	result1, local01, #0
	cmp	result1, #12 wz
 if_e	jmp	#LR__4501
	call	#_sdmm_cc_deselect_0858
	call	#_sdmm_cc_select_0862
	cmp	result1, #0 wz
 if_e	mov	result1, #255
 if_e	jmp	#LR__4503
LR__4501
	getbyte	arg02, local01, #0
	mov	result1, #64
	or	result1, arg02
	wrbyte	result1, local03
	mov	arg02, local03
	add	arg02, #1
	movbyts	local02, #27
	wrlong	local02, arg02
	mov	local04, #1
	mov	local02, local01
	zerox	local02, #7 wz
 if_e	mov	local04, #149
	getbyte	local02, local01, #0
	cmp	local02, #8 wz
 if_e	mov	local04, #135
	add	local03, #5
	wrbyte	local04, local03
	sub	local03, #5
	mov	arg01, local03
	mov	arg02, #6
	call	#_sdmm_cc_xmit_mmc_0841
	getbyte	local01, local01, #0
	cmp	local01, #12 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #6
 if_e	mov	arg02, #1
 if_e	call	#_sdmm_cc_rcvr_mmc_0848
	mov	local04, #10
' 	n = 10;
' 	do
LR__4502
	mov	arg01, local03
	add	arg01, #6
	mov	arg02, #1
	call	#_sdmm_cc_rcvr_mmc_0848
	add	local03, #6
	rdbyte	local02, local03
	sub	local03, #6
	test	local02, #128 wz
 if_ne	djnz	local04, #LR__4502
' 
' 	return buf[6];
	add	local03, #6
	rdbyte	result1, local03
LR__4503
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_send_cmd_0871_ret
	ret

_sdmm_cc_disk_setpins
	cmp	arg01, #0 wz
 if_ne	neg	result1, #1
 if_ne	jmp	#_sdmm_cc_disk_setpins_ret
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	arg04, objptr
	add	objptr, #4
	wrlong	arg05, objptr
	sub	objptr, #12
'     _pin_clk = pclk;
'     _pin_ss = pss;
'     _pin_di = pdi;
'     _pin_do = pdo;
' #line 848 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
'     return 0;
	mov	result1, #0
_sdmm_cc_disk_setpins_ret
	ret

_sdmm_cc_disk_deinitialize
	mov	COUNT_, #4
	call	#pushregs_
	cmps	arg01, #0 wz
	rdlong	local01, objptr
	add	objptr, #4
	rdlong	local02, objptr
	add	objptr, #4
	rdlong	local03, objptr
	add	objptr, #8
	rdlong	local04, objptr
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #12
' #line 865 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
'         return RES_NOTRDY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4510
	fltl	arg01
	wrpin	#0, arg01
	fltl	local04
	wrpin	#0, local04
	fltl	local03
	wrpin	#0, local03
	fltl	local01
	wrpin	#0, local01
	fltl	local02
	wrpin	#0, local02
	mov	arg01, #10
	call	#__system___waitms
'     }
' #line 871 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
'     _pinclear(SMPIN_DO);
'     _pinclear(PIN_DO);
'     _pinclear(PIN_DI);
'     _pinclear(PIN_CLK);
'     _pinclear(PIN_SS);
' 
'     _waitms(10);
' 
'     return 0;
	mov	result1, #0
LR__4510
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_disk_deinitialize_ret
	ret

_sdmm_cc_v_do_io
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg03
	mov	local02, arg04
	mov	local03, arg02
	add	objptr, #24
	rdlong	local04, objptr
	mov	arg04, #0
	and	local04, #511
	mov	local05, #0
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, #28
	mov	arg03, #9
	call	#__system___int64_sar
	mov	local06, result1
	cmp	local04, #0 wz
' 
' 
'         return -1;
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__4523
	mov	local07, local01
	shr	local07, #9
	cmp	local02, #0 wz
 if_e	jmp	#LR__4520
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, local06
	mov	arg04, local07
	call	#_sdmm_cc_disk_write
	mov	local08, result1
	jmp	#LR__4521
LR__4520
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, local06
	mov	arg04, local07
	call	#_sdmm_cc_disk_read
	mov	local08, result1
LR__4521
	cmp	local08, #0 wz
 if_ne	jmp	#LR__4522
	shl	local07, #9
	add	local05, local07
	add	objptr, #24
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	result2, objptr
	add	result1, local07 wc
	addx	result2, #0
	sub	objptr, #4
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	result2, objptr
	sub	objptr, #28
LR__4522
' 
' 
'     }
'     return bytes_io;
	mov	result1, local05
LR__4523
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_v_do_io_ret
	ret

_sdmm_cc_v_read
' {
'     return v_do_io(fil, buf, count,  (0) );
	mov	arg04, #0
	call	#_sdmm_cc_v_do_io
_sdmm_cc_v_read_ret
	ret

_sdmm_cc_v_write
' {
'     return v_do_io(fil, buf, count,  (1) );
	mov	arg04, #1
	call	#_sdmm_cc_v_do_io
_sdmm_cc_v_write_ret
	ret

_sdmm_cc_v_ioctl
	mov	arg01, #0
	call	#_sdmm_cc_disk_ioctl
	cmp	result1, #0 wz
'         return _seterror( 10 );
 if_ne	add	ptr___system__dat__, #32
 if_ne	wrlong	#10, ptr___system__dat__
 if_ne	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
'     return 0;
 if_e	mov	result1, #0
_sdmm_cc_v_ioctl_ret
	ret

_sdmm_cc_v_lseek
	mov	_var01, arg02
	mov	_var03, arg04 wz
 if_ne	jmp	#LR__4530
	mov	_var03, arg03
	add	objptr, #24
	wrlong	_var01, objptr
	add	objptr, #4
	wrlong	_var03, objptr
	sub	objptr, #28
	jmp	#LR__4533
LR__4530
	cmp	_var03, #1 wz
 if_ne	jmp	#LR__4531
	add	objptr, #24
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	result2, objptr
	add	result1, _var01 wc
	addx	result2, arg03
	sub	objptr, #4
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	result2, objptr
	sub	objptr, #28
	jmp	#LR__4532
LR__4531
	not	result1, _var01
	add	result1, #1 wz
	not	result2, arg03
	mov	arg02, #0
 if_e	neg	arg02, #1
	sub	result2, arg02
	add	objptr, #24
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	result2, objptr
	sub	objptr, #28
LR__4532
LR__4533
'         curpos = -off;
'     }
'     return curpos;
	add	objptr, #24
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	result2, objptr
	sub	objptr, #28
_sdmm_cc_v_lseek_ret
	ret

_sdmm_cc_v_flush
' {
'     return 0;
	mov	result1, #0
_sdmm_cc_v_flush_ret
	ret

_sdmm_cc_v_close
	mov	arg01, #0
	call	#_sdmm_cc_disk_deinitialize
	add	objptr, #32
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, #36
	call	#__system___freepins
' {
'     disk_deinitialize(0);
'     _freepins(f_pinmask);
'     return 0;
	mov	result1, #0
_sdmm_cc_v_close_ret
	ret

_sdmm_cc_v_putc
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	mov	arg01, arg02
	mov	arg02, fp
	mov	arg03, #1
	sub	fp, #4
' {
'     return v_do_io(fil, buf, count,  (1) );
	mov	arg04, #1
	call	#_sdmm_cc_v_do_io
	cmp	result1, #1 wz
 if_e	add	fp, #4
 if_e	rdlong	result1, fp
 if_e	sub	fp, #4
'     return -1;
 if_ne	neg	result1, #1
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_v_putc_ret
	ret

_sdmm_cc_v_getc
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#0, fp
	mov	arg02, fp
	sub	fp, #8
	mov	arg03, #1
' {
'     return v_do_io(fil, buf, count,  (0) );
	mov	arg04, #0
	call	#_sdmm_cc_v_do_io
	cmp	result1, #1 wz
 if_e	add	fp, #8
 if_e	rdlong	result1, fp
 if_e	sub	fp, #8
'     return -1;
 if_ne	neg	result1, #1
	mov	ptra, fp
	call	#popregs_
_sdmm_cc_v_getc_ret
	ret

_fatfs_cc_ff_uni2oem
	mov	_var01, #0
	cmp	arg01, #128 wc
 if_b	mov	_var01, arg01
 if_b	jmp	#LR__4544
	cmp	arg01, ##65536 wc
 if_ae	jmp	#LR__4543
	getword	result1, arg02, #0
	cmp	result1, ##850 wz
 if_ne	jmp	#LR__4543
' 			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
	mov	_var01, #0
	callpa	#(@LR__4541-@LR__4540)>>2,fcache_load_ptr_
LR__4540
	getword	result1, _var01, #0
	cmp	result1, #128 wc
 if_ae	jmp	#LR__4542
	getword	result1, _var01, #0
	shl	result1, #1
	add	result1, ptr__fatfs_cc_dat__
	rdword	result1, result1
	cmp	arg01, result1 wz
 if_ne	add	_var01, #1
 if_ne	jmp	#LR__4540
LR__4541
LR__4542
	getword	_var01, _var01, #0
	add	_var01, #128
	getbyte	_var01, _var01, #0
LR__4543
LR__4544
' 			c = (c + 0x80) & 0xFF;
' 		}
' 	}
' 
' 	return c;
	mov	result1, _var01
_fatfs_cc_ff_uni2oem_ret
	ret

_fatfs_cc_ff_oem2uni
	mov	_var01, #0
	getword	result1, arg01, #0
	cmp	result1, #128 wc
 if_b	mov	_var01, arg01
 if_b	jmp	#LR__4551
	getword	arg02, arg02, #0
	cmp	arg02, ##850 wz
 if_ne	jmp	#LR__4550
	getword	result1, arg01, #0
	cmp	result1, #256 wc
 if_b	getword	arg01, arg01, #0
 if_b	sub	arg01, #128
 if_b	shl	arg01, #1
 if_b	add	arg01, ptr__fatfs_cc_dat__
 if_b	rdword	_var01, arg01
LR__4550
LR__4551
' 		}
' 	}
' 
' 	return c;
	mov	result1, _var01
_fatfs_cc_ff_oem2uni_ret
	ret

_fatfs_cc_ff_wtoupper
	mov	_var01, arg01
	cmp	_var01, ##65536 wc
 if_ae	jmp	#LR__4573
	mov	_var02, _var01
	getword	_var01, _var02, #0
	cmp	_var01, ##4096 wc
 if_b	mov	_var03, ptr__fatfs_cc_dat__
 if_b	add	_var03, #256
 if_ae	mov	_var03, ptr__fatfs_cc_dat__
 if_ae	add	_var03, ##754
	mov	_var04, _var03
' 		uc = (WORD)uni;
' 		p = uc < 0x1000 ? (WORD*) cvt1 : (WORD *) cvt2;
' 		for (;;) {
LR__4560
	rdword	_var05, _var04
	mov	_var03, _var05
	zerox	_var03, #15 wz
	add	_var04, #2
 if_e	jmp	#LR__4572
	getword	_var03, _var02, #0
	getword	_var01, _var05, #0
	cmp	_var03, _var01 wc
 if_b	jmp	#LR__4572
	rdword	_var06, _var04
	getword	_var07, _var06, #0
	shr	_var07, #8
	getword	_var06, _var06, #0
	getbyte	_var06, _var06, #0
	getword	_var03, _var02, #0
	getword	_var08, _var05, #0
	getword	_var01, _var06, #0
	add	_var08, _var01
	cmps	_var03, _var08 wc
	add	_var04, #2
 if_ae	jmp	#LR__4571
' 				switch (cmd) {
	getword	_var09, _var07, #0
	fle	_var09, #9
	jmprel	_var09
LR__4561
	jmp	#LR__4562
	jmp	#LR__4563
	jmp	#LR__4564
	jmp	#LR__4565
	jmp	#LR__4566
	jmp	#LR__4567
	jmp	#LR__4568
	jmp	#LR__4569
	jmp	#LR__4570
	jmp	#LR__4572
LR__4562
	getword	_var02, _var02, #0
	getword	_var05, _var05, #0
	sub	_var02, _var05
	shl	_var02, #1
	add	_var02, _var04
	rdword	_var02, _var02
	jmp	#LR__4572
LR__4563
	getword	_var03, _var02, #0
	getword	_var02, _var02, #0
	getword	_var05, _var05, #0
	sub	_var02, _var05
	and	_var02, #1
	subr	_var02, _var03
	jmp	#LR__4572
LR__4564
	getword	_var02, _var02, #0
	sub	_var02, #16
	jmp	#LR__4572
LR__4565
	getword	_var02, _var02, #0
	sub	_var02, #32
	jmp	#LR__4572
LR__4566
	getword	_var02, _var02, #0
	sub	_var02, #48
	jmp	#LR__4572
LR__4567
	getword	_var02, _var02, #0
	sub	_var02, #26
	jmp	#LR__4572
LR__4568
	getword	_var02, _var02, #0
	add	_var02, #8
	jmp	#LR__4572
LR__4569
	getword	_var02, _var02, #0
	sub	_var02, #80
	jmp	#LR__4572
LR__4570
	getword	_var02, _var02, #0
	sub	_var02, ##7264
' 				}
' 				break;
	jmp	#LR__4572
LR__4571
	zerox	_var07, #15 wz
 if_e	getword	_var06, _var06, #0
 if_e	shl	_var06, #1
 if_e	add	_var04, _var06
	jmp	#LR__4560
LR__4572
	getword	_var01, _var02, #0
LR__4573
' 		}
' 		uni = uc;
' 	}
' 
' 	return uni;
	mov	result1, _var01
_fatfs_cc_ff_wtoupper_ret
	ret

_fatfs_cc_strncpy
	mov	_var01, arg01
	callpa	#(@LR__4581-@LR__4580)>>2,fcache_load_ptr_
' 
' 	dscan = dst;
' 	sscan = src;
' 	count = n;
' 	while (--count >= 0 && (*dscan++ = *sscan++) != '\0')
LR__4580
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_b	jmp	#LR__4582
	mov	result1, arg02
	add	result1, #1
	rdbyte	_var02, arg02
	mov	arg02, result1
	wrbyte	_var02, _var01
	getbyte	_var02, _var02, #0
	zerox	_var02, #7 wz
' 		continue;
	add	_var01, #1
 if_ne	jmp	#LR__4580
LR__4581
LR__4582
	callpa	#(@LR__4584-@LR__4583)>>2,fcache_load_ptr_
' 	while (--count >= 0)
LR__4583
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_ae	mov	_var03, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	#0, _var03
 if_ae	jmp	#LR__4583
LR__4584
' 		*dscan++ = '\0';
' 	return(dst);
	mov	result1, arg01
_fatfs_cc_strncpy_ret
	ret

_fatfs_cc_memcmp
' 	for (n = size; n > 0; n--)
	cmp	arg03, #0 wz
 if_e	jmp	#LR__4591
LR__4590
	rdbyte	_var01, arg01
	rdbyte	_var02, arg02
	cmp	_var01, _var02 wz
 if_e	add	arg01, #1
 if_e	add	arg02, #1
' 			return( ((unsigned char)(*scan1))  -  ((unsigned char)(*scan2)) );
 if_ne	rdbyte	result1, arg01
 if_ne	rdbyte	_var02, arg02
 if_ne	sub	result1, _var02
 if_ne	jmp	#_fatfs_cc_memcmp_ret
	djnz	arg03, #LR__4590
LR__4591
' 
' 	return(0);
	mov	result1, #0
_fatfs_cc_memcmp_ret
	ret

_fatfs_cc_strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__4600
' 		return scan2 ? -1 : 0;
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#_fatfs_cc_strncmp_ret
LR__4600
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__4602-@LR__4601)>>2,fcache_load_ptr_
' 	count = n;
' 	do {
LR__4601
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__4603
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__4601
LR__4602
LR__4603
	cmps	_var03, #0 wc
' 		return(0);
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, _var06 wz
' 		return(0);
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, #0 wz
' 		return(-1);
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var06, #0 wz
' 		return(1);
 if_e	mov	result1, #1
' 		return(c1 - c2);
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
_fatfs_cc_strncmp_ret
	ret

_fatfs_cc_strchr
' #line 16 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/libc/string/strchr.c"
' 	while ((c = *s++) != (char) charwanted)
LR__4610
	mov	_var01, arg01
	rdbyte	_var02, _var01
	getbyte	_var03, _var02, #0
	getbyte	_var04, arg02, #0
	cmp	_var03, _var04 wz
	add	arg01, #1
 if_e	jmp	#LR__4611
	mov	_var03, _var02
	zerox	_var03, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strchr_ret
	jmp	#LR__4610
LR__4611
' 	return((char *)--s);
	sub	arg01, #1
	mov	result1, arg01
_fatfs_cc_strchr_ret
	ret

_fatfs_cc_time
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	mov	local01, arg01
	mov	arg01, fp
	add	arg01, #8
	mov	arg02, #0
	call	#_fatfs_cc_gettimeofday
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	cmp	local01, #0 wz
 if_ne	wrlong	result1, local01
'         *tp = now;
'     return now;
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_time_ret
	ret

_fatfs_cc_mktime
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	add	local01, #20
	rdlong	arg01, local01
	sub	local01, #20
	cmps	arg01, #70 wc
'                 return (time_t) -1;
 if_b	neg	result1, #1
 if_b	jmp	#LR__4624
	mov	local02, ##1900
	add	local01, #20
	rdlong	result1, local01
	add	local02, result1
	sub	local01, #8
	rdlong	local03, local01
	sub	local03, #1
	add	local01, #4
	rdlong	arg01, local01
	sub	local01, #16
	shl	arg01, #2
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1144
	add	arg01, result1
	rdlong	result1, arg01
	add	local03, result1
	mov	arg01, local02
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_e	jmp	#LR__4620
	mov	local04, #0
	add	local01, #16
	rdlong	result1, local01
	sub	local01, #16
	cmps	result1, #2 wc
 if_ae	mov	local04, #1
	jmp	#LR__4621
LR__4620
	mov	local04, #0
LR__4621
	add	local01, #4
	rdlong	arg01, local01
	sub	local01, #4
	rdlong	local05, local01
	add	local01, #8
	rdlong	result1, local01
	qmul	result1, ##3600
	add	local03, local04
	mov	local04, arg01
	shl	local04, #4
	sub	local04, arg01
	shl	local04, #2
	add	local05, local04
	sub	local01, #8
	getqx	local04
	qmul	local03, ##86400
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1970
	getqx	local04
	qmul	local03, ##31536000
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1969
	abs	local06, local03 wc
	shr	local06, #2
	negc	local06, local06
	cmps	local02, ##2001 wc
	getqx	local04
	add	local05, local04
 if_b	jmp	#LR__4622
	sub	local02, ##2000
	abs	local04, local02 wc
	qdiv	local04, #100
	getqx	local04
	sumnc	local06, local04
LR__4622
	qmul	local06, ##86400
	getqx	local06
	add	local05, local06
	call	#_fatfs_cc__tzset
	add	ptr__fatfs_cc_dat__, ##1092
	rdlong	local06, ptr__fatfs_cc_dat__
	add	local05, local06
	add	ptr__fatfs_cc_dat__, #104
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1196
	cmp	local03, #1 wz
 if_ne	jmp	#LR__4623
	mov	arg01, local01
	call	#_fatfs_cc___indst
	cmp	result1, #0 wz
 if_ne	sub	local05, ##3600
LR__4623
'                 s -=  (3600L) ;
' 
'         return s;
	mov	result1, local05
LR__4624
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mktime_ret
	ret

_fatfs_cc__gmtime_r
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, arg01
	qdiv	local01, ##86400
	getqx	result1
	add	result1, #4
	qdiv	result1, #7
	add	arg02, #24
	cmp	local01, ##1325376000 wc
 if_ae	sub	local01, ##1325376000
 if_ae	mov	local02, ##2012
 if_b	mov	local02, ##1970
' 	  year = 1970;
' 	}
' 
' 	for(;;) {
	getqy	result1
	wrlong	result1, arg02
	sub	arg02, #24
LR__4630
	mov	arg01, local02
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, ##31622400
 if_e	mov	local03, ##31536000
	cmp	local01, local03 wc
' 	    break;
 if_ae	add	local02, #1
 if_ae	sub	local01, local03
 if_ae	jmp	#LR__4630
	qdiv	local01, ##86400
	mov	local03, local02
	sub	local03, ##1900
	add	arg02, #20
	wrlong	local03, arg02
	add	arg02, #8
	mov	arg01, local02
	getqx	local02
	wrlong	local02, arg02
	sub	arg02, #28
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, #29
 if_e	mov	local03, #28
	add	ptr__fatfs_cc_dat__, ##1100
	wrlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1100
' 
'         days_per_mth[1] = _is_leap_year(year) ? 29 : 28;
'         for (i = 0; mday >= days_per_mth[i]; i++)
	mov	arg01, #0
	callpa	#(@LR__4632-@LR__4631)>>2,fcache_load_ptr_
LR__4631
	mov	local03, arg01
	shl	local03, #2
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1096
	add	local03, result1
	rdlong	local03, local03
	cmps	local02, local03 wc
 if_b	jmp	#LR__4633
	mov	result1, arg01
	shl	result1, #2
	mov	local03, ptr__fatfs_cc_dat__
	add	local03, ##1096
	add	result1, local03
	rdlong	result1, result1
	sub	local02, result1
	add	arg01, #1
	jmp	#LR__4631
LR__4632
LR__4633
	qdiv	local01, ##86400
	add	arg02, #16
	wrlong	arg01, arg02
	add	local02, #1
	sub	arg02, #4
	wrlong	local02, arg02
	getqy	local01
	qdiv	local01, ##3600
	getqx	local03
	qdiv	local01, ##3600
	sub	arg02, #4
	wrlong	local03, arg02
	getqy	local01
	qdiv	local01, #60
	getqx	local03
	qdiv	local01, #60
	sub	arg02, #4
	wrlong	local03, arg02
	sub	arg02, #4
'         stm->tm_isdst = 0;
' 
' ;
'         return stm;
	mov	result1, arg02
	getqy	local03
	wrlong	local03, arg02
	add	arg02, #32
	wrlong	#0, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__gmtime_r_ret
	ret

_fatfs_cc__tzset
	mov	arg01, ##@LR__5482
	call	#_fatfs_cc_getenv
	mov	arg01, result1
	mov	arg02, ptr__fatfs_cc_dat__
	add	arg02, ##1196
	call	#_fatfs_cc___tzoffset
	add	ptr__fatfs_cc_dat__, ##1092
	wrlong	result1, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1092
_fatfs_cc__tzset_ret
	ret

_fatfs_cc_disk_read
	mov	COUNT_, #9
	call	#pushregs_
	mov	local05, arg02
	mov	local06, arg04
	mov	arg01, arg03
	mov	arg02, #0
	mov	arg03, #9
	mov	arg04, #0
	call	#__system___int64_shl
	mov	local01, result1
	mov	local02, result2
	add	objptr, ##528
	rdlong	result2, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
 if_e	jmp	#LR__4640
	mov	arg02, local01
	mov	arg03, local02
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	arg04, arg01
	add	arg04, #48
	rdlong	local07, arg04
	mov	local08, local07
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	sub	objptr, ##528
	mov	arg04, #0
	mov	local09, objptr
	mov	objptr, local07
	call	local08
	mov	objptr, local09
	mov	local03, result1
	mov	local04, result2
	mov	arg01, local03
	mov	arg02, local04
	mov	arg03, local01
	mov	arg04, local02
	mov	result1, #0
	cmp	arg01, arg03 wcz
	cmpsx	arg02, arg04 wcz
 if_ne	negc	result1, #1
	cmp	result1, #0 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__4640
	shl	local06, #9
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	local03, arg01
	add	local03, #20
	rdlong	local03, local03
	mov	local09, local03
	zerox	local09, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	sub	objptr, ##528
	mov	arg02, local05
	mov	arg03, local06
	mov	local08, objptr
	mov	objptr, local09
	call	local03
	mov	objptr, local08
	cmp	result1, local06 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
'     }
'     return RES_OK;
 if_e	mov	result1, #0
LR__4640
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_read_ret
	ret

_fatfs_cc_disk_write
	mov	COUNT_, #9
	call	#pushregs_
	mov	local05, arg02
	mov	local06, arg04
	mov	arg01, arg03
	mov	arg02, #0
	mov	arg03, #9
	mov	arg04, #0
	call	#__system___int64_shl
	mov	local01, result1
	mov	local02, result2
	add	objptr, ##528
	rdlong	result2, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
 if_e	jmp	#LR__4650
	mov	arg02, local01
	mov	arg03, local02
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	arg04, arg01
	add	arg04, #48
	rdlong	local07, arg04
	mov	local08, local07
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	sub	objptr, ##528
	mov	arg04, #0
	mov	local09, objptr
	mov	objptr, local07
	call	local08
	mov	objptr, local09
	mov	local03, result1
	mov	local04, result2
	mov	arg01, local03
	mov	arg02, local04
	mov	arg03, local01
	mov	arg04, local02
	mov	result1, #0
	cmp	arg01, arg03 wcz
	cmpsx	arg02, arg04 wcz
 if_ne	negc	result1, #1
	cmp	result1, #0 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__4650
	shl	local06, #9
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	local03, arg01
	add	local03, #24
	rdlong	local03, local03
	mov	local09, local03
	zerox	local09, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	sub	objptr, ##528
	mov	arg02, local05
	mov	arg03, local06
	mov	local08, objptr
	mov	objptr, local09
	call	local03
	mov	objptr, local08
	cmp	result1, local06 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
'     }
'     return RES_OK;
 if_e	mov	result1, #0
LR__4650
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_write_ret
	ret

_fatfs_cc_disk_ioctl
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, ##528
	rdlong	arg01, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
 if_e	jmp	#LR__4660
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	local01, arg01
	add	local01, #40
	rdlong	local01, local01
	mov	local02, local01
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	sub	objptr, ##528
	getbyte	arg02, arg02, #0
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	cmp	result1, #0 wz
'         return RES_ERROR;
 if_ne	mov	result1, #1
'     return RES_OK;
 if_e	mov	result1, #0
LR__4660
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_ioctl_ret
	ret

_fatfs_cc_tchar2uni
	rdlong	_var01, arg01
	mov	_var02, _var01
	add	_var01, #1
	mov	_var03, _var01
	rdbyte	_var04, _var02
	test	_var04, #128 wz
 if_e	jmp	#LR__4677
	mov	_var05, _var04
	and	_var05, #224
	cmp	_var05, #192 wz
 if_e	and	_var04, #31
 if_e	mov	_var06, #1
 if_e	jmp	#LR__4671
	mov	_var05, _var04
	and	_var05, #240
	cmp	_var05, #224 wz
 if_e	getnib	_var04, _var04, #0
 if_e	mov	_var06, #2
 if_e	jmp	#LR__4670
	mov	_var05, _var04
	and	_var05, #248
	cmp	_var05, #240 wz
 if_e	and	_var04, #7
 if_e	mov	_var06, #3
' 			return 0xFFFFFFFF;
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_tchar2uni_ret
LR__4670
LR__4671
' 		}
' 		do {
LR__4672
	rdbyte	_var07, _var03
	getbyte	_var05, _var07, #0
	and	_var05, #192
	cmp	_var05, #128 wz
	add	_var03, #1
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_tchar2uni_ret
	shl	_var04, #6
	getbyte	_var02, _var07, #0
	and	_var02, #63
	or	_var04, _var02
	djnz	_var06, #LR__4672
	cmp	_var04, #128 wc
 if_b	jmp	#LR__4674
	cmp	_var04, ##55296 wc
 if_b	jmp	#LR__4673
	cmp	_var04, ##57344 wc
 if_b	jmp	#LR__4674
LR__4673
	cmp	_var04, ##1114112 wc
 if_b	jmp	#LR__4675
LR__4674
	neg	result1, #1
	jmp	#_fatfs_cc_tchar2uni_ret
LR__4675
	cmp	_var04, ##65536 wc
 if_b	jmp	#LR__4676
	mov	_var02, _var04
	sub	_var02, ##65536
	shl	_var02, #6
	and	_var02, ##67043328
	mov	_var05, ##-671032320
	or	_var05, _var02
	zerox	_var04, #9
	or	_var04, _var05
LR__4676
LR__4677
	wrlong	_var03, arg01
' 	}
' #line 811 "ff.c"
' 	*str = p;
' 	return uc;
	mov	result1, _var04
_fatfs_cc_tchar2uni_ret
	ret

_fatfs_cc_put_utf
	cmp	arg01, #128 wc
 if_ae	jmp	#LR__4680
	cmp	arg03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	wrbyte	arg01, arg02
' 		*buf = (TCHAR)chr;
' 		return 1;
	mov	result1, #1
	jmp	#_fatfs_cc_put_utf_ret
LR__4680
	cmp	arg01, ##2048 wc
 if_ae	jmp	#LR__4681
	cmp	arg03, #2 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	mov	result1, arg01
	shr	result1, #6
	and	result1, #31
	mov	arg03, #192
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	arg01, #63
	mov	result1, #128
	or	result1, arg01
	wrbyte	result1, arg02
' 		*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 		return 2;
	mov	result1, #2
	jmp	#_fatfs_cc_put_utf_ret
LR__4681
	cmp	arg01, ##65536 wc
 if_ae	jmp	#LR__4684
	cmp	arg03, #3 wc
 if_b	jmp	#LR__4682
	cmp	arg01, ##55296 wc
 if_b	jmp	#LR__4683
	cmp	arg01, ##57344 wc
 if_ae	jmp	#LR__4683
LR__4682
	mov	result1, #0
	jmp	#_fatfs_cc_put_utf_ret
LR__4683
	getnib	result1, arg01, #3
	mov	arg03, #224
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, arg01
	shr	result1, #6
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	arg01, #63
	mov	result1, #128
	or	result1, arg01
	wrbyte	result1, arg02
' 		*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 		return 3;
	mov	result1, #3
	jmp	#_fatfs_cc_put_utf_ret
LR__4684
	cmp	arg03, #4 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	mov	_var01, arg01
	bitl	_var01, #480
	sub	_var01, ##-671088640
	shr	_var01, #6
	getword	arg01, arg01, #0
	sub	arg01, ##56320
	cmp	_var01, ##1048576 wc
 if_b	cmp	arg01, ##1024 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#_fatfs_cc_put_utf_ret
	or	_var01, arg01
	add	_var01, ##65536
	mov	result1, _var01
	shr	result1, #18
	and	result1, #7
	mov	arg03, #240
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, _var01
	shr	result1, #12
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, _var01
	shr	result1, #6
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	_var01, #63
	mov	result1, #128
	or	result1, _var01
	wrbyte	result1, arg02
' 	chr = (hc | chr) + 0x10000;
' 	*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 	return 4;
	mov	result1, #4
_fatfs_cc_put_utf_ret
	ret

_fatfs_cc_sync_window
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #3
	rdbyte	result1, local01 wz
	sub	local01, #3
 if_e	jmp	#LR__4692
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #48
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4690
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #45
	rdlong	result1, local01
	sub	local01, #12
	rdlong	arg04, local01
	sub	result1, arg04
	sub	local01, #8
	rdlong	arg04, local01
	sub	local01, #28
	cmp	result1, arg04 wc
 if_ae	jmp	#LR__4691
	add	local01, #2
	rdbyte	arg04, local01
	sub	local01, #2
	cmp	arg04, #2 wz
 if_ne	jmp	#LR__4691
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #20
	rdlong	local01, local01
	add	arg03, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	jmp	#LR__4691
LR__4690
	mov	local02, #1
LR__4691
LR__4692
' 			res = FR_DISK_ERR;
' 		}
' 	}
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_window_ret
	ret

_fatfs_cc_move_window
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	add	local01, #48
	rdlong	arg04, local01
	sub	local01, #48
	cmp	local02, arg04 wz
 if_e	jmp	#LR__4701
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__4700
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	mov	arg03, local02
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	neg	local02, #1
 if_ne	mov	local03, #1
	sub	local01, #4
	wrlong	local02, local01
LR__4700
LR__4701
' 				sect = (LBA_t)0 - 1;
' 				res = FR_DISK_ERR;
' 			}
' 			fs->winsect = sect;
' 		}
' 	}
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_move_window_ret
	ret

_fatfs_cc_sync_fs
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	call	#_fatfs_cc_sync_window
	mov	local02, result1 wz
 if_ne	jmp	#LR__4711
	rdbyte	arg04, local01
	cmp	arg04, #3 wz
 if_e	add	local01, #4
 if_e	rdbyte	arg04, local01
 if_e	sub	local01, #4
 if_e	cmp	arg04, #1 wz
 if_ne	jmp	#LR__4710
	add	local01, #52
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	arg01, local01
	add	arg01, #510
	wrword	##43605, arg01
	wrlong	##1096897106, local01
	mov	arg01, local01
	add	arg01, #484
	wrlong	##1631679090, arg01
	mov	arg01, local01
	add	arg01, #488
	sub	local01, #32
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #32
	mov	arg01, local01
	add	arg01, #492
	sub	local01, #36
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #16
	rdlong	arg03, local01
	add	arg03, #1
	add	local01, #16
	wrlong	arg03, local01
	sub	local01, #47
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	sub	local01, #48
	wrbyte	#0, local01
	sub	local01, #4
LR__4710
	add	local01, #1
	rdbyte	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	call	#_fatfs_cc_disk_ioctl
	cmp	result1, #0 wz
 if_ne	mov	local02, #1
LR__4711
' 	}
' 
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_fs_ret
	ret

_fatfs_cc_clst2sect
	sub	arg02, #2
	add	arg01, #24
	rdlong	_var01, arg01
	sub	arg01, #24
	sub	_var01, #2
	cmp	arg02, _var01 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#_fatfs_cc_clst2sect_ret
	add	arg01, #10
	rdword	_var01, arg01
	qmul	_var01, arg02
' 	return fs->database + (LBA_t)fs->csize * clst;
	add	arg01, #34
	rdlong	result1, arg01
	getqx	_var01
	add	result1, _var01
_fatfs_cc_clst2sect_ret
	ret

_fatfs_cc_get_fat
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg02
	rdlong	local02, arg01
	cmp	local01, #2 wc
 if_b	jmp	#LR__4720
	add	local02, #24
	rdlong	local03, local02
	sub	local02, #24
	cmp	local01, local03 wc
 if_b	jmp	#LR__4721
LR__4720
	mov	local04, #1
	jmp	#LR__4728
LR__4721
	neg	local04, #1
' 		val = 0xFFFFFFFF;
' 
' 		switch (fs->fs_type) {
	rdbyte	local05, local02
	sub	local05, #1
	fle	local05, #3
	jmprel	local05
LR__4722
	jmp	#LR__4723
	jmp	#LR__4724
	jmp	#LR__4725
	jmp	#LR__4726
LR__4723
	mov	local05, local01
	mov	arg01, local01
	shr	arg01, #1
	add	local05, arg01
	mov	arg01, local02
	mov	local06, local05
	shr	local06, #9
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4727
	mov	local06, local05
	and	local06, #511
	mov	arg01, local02
	add	arg01, #52
	add	local06, arg01
	rdbyte	local07, local06
	mov	arg01, local02
	add	local05, #1
	mov	local06, local05
	shr	local06, #9
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4727
	and	local05, #511
	add	local02, #52
	add	local05, local02
	rdbyte	local06, local05
	shl	local06, #8
	or	local07, local06
	test	local01, #1 wz
 if_ne	shr	local07, #4
 if_ne	mov	local03, local07
 if_e	zerox	local07, #11
 if_e	mov	local03, local07
	mov	local04, local03
' 			wc |= fs->win[bc %  ((UINT) 512 ) ] << 8;
' 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
' 			break;
	jmp	#LR__4727
LR__4724
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #8
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4727
	add	local02, #52
	shl	local01, #1
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, local02
	getword	local04, result1, #0
' 			val = ld_word(fs->win + clst * 2 %  ((UINT) 512 ) );
' 			break;
	jmp	#LR__4727
LR__4725
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #7
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4727
	add	local02, #52
	shl	local01, #2
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local04, local02
	bitl	local04, #124
' 			val = ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0x0FFFFFFF;
' 			break;
	jmp	#LR__4727
LR__4726
	mov	local04, #1
LR__4727
LR__4728
' 			val = 1;
' 		}
' 	}
' 
' 	return val;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_fat_ret
	ret

_fatfs_cc_put_fat
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, #2
	cmp	local02, #2 wc
 if_b	jmp	#LR__4737
	add	local01, #24
	rdlong	local05, local01
	sub	local01, #24
	cmp	local02, local05 wc
 if_ae	jmp	#LR__4737
' 		switch (fs->fs_type) {
	rdbyte	local06, local01
	sub	local06, #1
	fle	local06, #3
	jmprel	local06
LR__4730
	jmp	#LR__4731
	jmp	#LR__4734
	jmp	#LR__4735
	jmp	#LR__4736
LR__4731
	mov	local07, local02
	mov	local05, local02
	shr	local05, #1
	add	local07, local05
	mov	arg01, local01
	mov	local06, local07
	shr	local06, #9
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4736
	mov	local08, local01
	add	local08, #52
	mov	local05, local07
	and	local05, #511
	add	local08, local05
	test	local02, #1 wz
	add	local07, #1
 if_e	jmp	#LR__4732
	rdbyte	local05, local08
	getnib	local05, local05, #0
	getbyte	local06, local03, #0
	shl	local06, #4
	or	local05, local06
	jmp	#LR__4733
LR__4732
	mov	local05, local03
LR__4733
	wrbyte	local05, local08
	add	local01, #3
	wrbyte	#1, local01
	sub	local01, #3
	mov	arg01, local01
	mov	local08, local07
	shr	local08, #9
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4736
	mov	local08, local01
	add	local08, #52
	and	local07, #511
	add	local08, local07
	test	local02, #1 wz
 if_ne	shr	local03, #4
 if_ne	mov	local05, local03
 if_e	rdbyte	local05, local08
 if_e	and	local05, #240
 if_e	getbyte	local03, local03, #1
 if_e	getnib	local03, local03, #0
 if_e	or	local05, local03
	wrbyte	local05, local08
	add	local01, #3
	wrbyte	#1, local01
' 			p = fs->win + bc %  ((UINT) 512 ) ;
' 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__4736
LR__4734
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #8
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4736
	add	local01, #52
	mov	arg01, local01
	shl	local02, #1
	and	local02, #511
	add	arg01, local02
	wrword	local03, arg01
	sub	local01, #49
	wrbyte	#1, local01
' 			st_word(fs->win + clst * 2 %  ((UINT) 512 ) , (WORD)val);
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__4736
LR__4735
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #7
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4736
	bitl	local03, #124
	mov	arg01, local01
	add	arg01, #52
	mov	local08, local02
	shl	local08, #2
	and	local08, #511
	add	arg01, local08
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local08, arg01
	and	local08, ##-268435456
	or	local03, local08
	add	local01, #52
	mov	arg01, local01
	shl	local02, #2
	and	local02, #511
	add	arg01, local02
	wrlong	local03, arg01
	sub	local01, #49
	wrbyte	#1, local01
' 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0xF0000000);
' 			}
' 			st_dword(fs->win + clst * 4 %  ((UINT) 512 ) , val);
' 			fs->wflag = 1;
' 			break;
LR__4736
LR__4737
' 		}
' 	}
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_put_fat_ret
	ret

_fatfs_cc_remove_chain
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	rdlong	local04, local01
	cmp	local02, #2 wc
 if_b	jmp	#LR__4740
	add	local04, #24
	rdlong	result1, local04
	sub	local04, #24
	cmp	local02, result1 wc
 if_b	jmp	#LR__4741
LR__4740
	mov	result1, #2
	jmp	#LR__4746
LR__4741
	cmp	local03, #0 wz
 if_e	jmp	#LR__4742
	mov	arg02, local03
	mov	arg01, local04
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4746
LR__4742
' 	}
' 
' 
' 	do {
LR__4743
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1 wz
 if_e	jmp	#LR__4745
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__4746
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4746
	mov	arg02, local02
	mov	arg01, local04
	mov	arg03, #0
	call	#_fatfs_cc_put_fat
	mov	local03, result1 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__4746
	add	local04, #24
	rdlong	local03, local04
	sub	local03, #2
	sub	local04, #4
	rdlong	local02, local04
	sub	local04, #20
	cmp	local02, local03 wc
 if_ae	jmp	#LR__4744
	add	local04, #20
	rdlong	local03, local04
	add	local03, #1
	wrlong	local03, local04
	sub	local04, #16
	rdbyte	local03, local04
	or	local03, #1
	wrbyte	local03, local04
	sub	local04, #4
LR__4744
	mov	local02, local05
	add	local04, #24
	rdlong	local05, local04
	sub	local04, #24
	cmp	local02, local05 wc
 if_b	jmp	#LR__4743
LR__4745
' #line 1500 "ff.c"
' 	return FR_OK;
	mov	result1, #0
LR__4746
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_remove_chain_ret
	ret

_fatfs_cc_create_chain
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	rdlong	local03, local01
 if_ne	jmp	#LR__4750
	add	local03, #16
	rdlong	local04, local03 wz
	sub	local03, #16
 if_ne	add	local03, #24
 if_ne	rdlong	local05, local03
 if_ne	sub	local03, #24
 if_ne	cmp	local04, local05 wc
 if_c_and_nz	jmp	#LR__4751
	mov	local04, #1
	jmp	#LR__4751
LR__4750
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, #2 wc
 if_b	mov	result1, #1
 if_b	jmp	#LR__4761
	cmp	local04, ##-1 wz
 if_e	mov	result1, local04
 if_e	jmp	#LR__4761
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local04, local05 wc
 if_b	mov	result1, local04
 if_b	jmp	#LR__4761
	mov	local04, local02
LR__4751
	add	local03, #20
	rdlong	local05, local03 wz
	sub	local03, #20
 if_e	mov	result1, #0
 if_e	jmp	#LR__4761
	mov	local06, #0
	cmp	local04, local02 wz
 if_ne	jmp	#LR__4754
	mov	local06, local04
	add	local06, #1
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #1 wz
 if_ne	cmp	local05, ##-1 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__4761
	cmp	local05, #0 wz
 if_e	jmp	#LR__4753
	add	local03, #16
	rdlong	local07, local03
	sub	local03, #16
	cmp	local07, #2 wc
 if_b	jmp	#LR__4752
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local07, local05 wc
 if_b	mov	local04, local07
LR__4752
	mov	local06, #0
LR__4753
LR__4754
	cmp	local06, #0 wz
 if_ne	jmp	#LR__4757
	mov	local06, local04
' 			ncl = scl;
' 			for (;;) {
LR__4755
	add	local06, #1
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
 if_ae	cmp	local06, local04 wcz
 if_a	mov	result1, #0
 if_a	jmp	#LR__4761
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local07, result1 wz
 if_e	jmp	#LR__4756
	cmp	local07, #1 wz
 if_ne	cmp	local07, ##-1 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__4761
	cmp	local06, local04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4761
	jmp	#LR__4755
LR__4756
LR__4757
	mov	arg01, local03
	mov	arg02, local06
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	mov	local08, result1 wz
 if_ne	jmp	#LR__4758
	cmp	local02, #0 wz
 if_e	jmp	#LR__4758
	mov	arg01, local03
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_put_fat
	mov	local08, result1
LR__4758
	cmp	local08, #0 wz
 if_ne	jmp	#LR__4759
	add	local03, #16
	wrlong	local06, local03
	add	local03, #8
	rdlong	local05, local03
	sub	local05, #2
	sub	local03, #4
	rdlong	local09, local03
	sub	local03, #20
	cmp	local09, local05 wcz
 if_be	add	local03, #20
 if_be	rdlong	local09, local03
 if_be	sub	local09, #1
 if_be	wrlong	local09, local03
 if_be	sub	local03, #20
	add	local03, #4
	rdbyte	local05, local03
	or	local05, #1
	wrbyte	local05, local03
	jmp	#LR__4760
LR__4759
	cmp	local08, #1 wz
	negz	local06, #1
LR__4760
' 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
' 	}
' 
' 	return ncl;
	mov	result1, local06
LR__4761
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_chain_ret
	ret

_fatfs_cc_dir_clear
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__4772
	mov	arg01, local01
	mov	arg02, local02
	call	#_fatfs_cc_clst2sect
	mov	local03, result1
	add	local01, #48
	wrlong	local03, local01
	add	local01, #4
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	local04, local01
' #line 1667 "ff.c"
' 	{
' 		ibuf = fs->win; szb = 1;
' 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
	mov	local05, #0
	sub	local01, #52
LR__4770
	add	local01, #10
	rdword	local06, local01
	sub	local01, #10
	cmp	local05, local06 wc
 if_ae	jmp	#LR__4771
	add	local01, #1
	rdbyte	arg01, local01
	sub	local01, #1
	mov	arg02, local04
	mov	arg03, local03
	add	arg03, local05
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	add	local05, #1
 if_e	jmp	#LR__4770
LR__4771
' 	}
' 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
	add	local01, #10
	rdword	local04, local01
	cmp	local05, local04 wz
 if_e	mov	local06, #0
 if_ne	mov	local06, #1
	mov	result1, local06
LR__4772
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_clear_ret
	ret

_fatfs_cc_dir_sdi
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	cmp	local02, ##2097152 wc
 if_b	test	local02, #31 wz
' 		return FR_INT_ERR;
 if_nc_or_nz	mov	result1, #2
 if_nc_or_nz	jmp	#LR__4786
	add	local01, #16
	wrlong	local02, local01
	sub	local01, #8
	rdlong	local04, local01 wz
	sub	local01, #8
 if_e	rdbyte	local05, local03
 if_e	cmp	local05, #3 wc
 if_nc_and_z	add	local03, #40
 if_nc_and_z	rdlong	local04, local03
 if_nc_and_z	sub	local03, #40
	cmp	local04, #0 wz
 if_ne	jmp	#LR__4780
	mov	local05, local02
	shr	local05, #5
	add	local03, #8
	rdword	arg02, local03
	sub	local03, #8
	cmp	local05, arg02 wc
 if_ae	mov	result1, #2
 if_ae	jmp	#LR__4786
	add	local03, #40
	rdlong	local05, local03
	sub	local03, #40
	add	local01, #24
	wrlong	local05, local01
	sub	local01, #24
	jmp	#LR__4785
LR__4780
	add	local03, #10
	rdword	local06, local03
	sub	local03, #10
	shl	local06, #9
' 		csz = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 		while (ofs >= csz) {
LR__4781
	cmp	local02, local06 wc
 if_b	jmp	#LR__4784
	mov	arg01, local01
	mov	arg02, local04
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4786
	cmp	local04, #2 wc
 if_b	jmp	#LR__4782
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local04, local05 wc
 if_b	jmp	#LR__4783
LR__4782
	mov	result1, #2
	jmp	#LR__4786
LR__4783
	sub	local02, local06
	jmp	#LR__4781
LR__4784
	mov	arg01, local03
	mov	arg02, local04
	call	#_fatfs_cc_clst2sect
	add	local01, #24
	wrlong	result1, local01
	sub	local01, #24
LR__4785
	add	local01, #20
	wrlong	local04, local01
	add	local01, #4
	rdlong	local05, local01 wz
	sub	local01, #24
 if_e	mov	result1, #2
 if_e	jmp	#LR__4786
	mov	local06, local02
	shr	local06, #9
	add	local01, #24
	rdlong	local05, local01
	add	local05, local06
	wrlong	local05, local01
	add	local03, #52
	and	local02, #511
	add	local03, local02
	add	local01, #4
	wrlong	local03, local01
' 	dp->sect += ofs /  ((UINT) 512 ) ;
' 	dp->dir = fs->win + (ofs %  ((UINT) 512 ) );
' 
' 	return FR_OK;
	mov	result1, #0
LR__4786
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_sdi_ret
	ret

_fatfs_cc_dir_next
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	add	local01, #16
	rdlong	local04, local01
	sub	local01, #16
	add	local04, #32
	cmp	local04, ##2097152 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
 if_ae	sub	local01, #24
	add	local01, #24
	rdlong	arg02, local01 wz
	sub	local01, #24
 if_e	mov	result1, #4
 if_e	jmp	#LR__4795
	test	local04, #511 wz
 if_ne	jmp	#LR__4794
	add	local01, #24
	rdlong	arg02, local01
	add	arg02, #1
	wrlong	arg02, local01
	sub	local01, #4
	rdlong	arg02, local01 wz
	sub	local01, #20
 if_ne	jmp	#LR__4790
	mov	arg02, local04
	shr	arg02, #5
	add	local03, #8
	rdword	local02, local03
	sub	local03, #8
	cmp	arg02, local02 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
' 				dp->sect = 0; return FR_NO_FILE;
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__4795
	jmp	#LR__4793
LR__4790
	mov	arg01, local04
	shr	arg01, #9
	add	local03, #10
	rdword	arg02, local03
	sub	local03, #10
	sub	arg02, #1
	test	arg01, arg02 wz
 if_ne	jmp	#LR__4792
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #2 wc
 if_b	mov	result1, #2
 if_b	jmp	#LR__4795
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4795
	add	local03, #24
	rdlong	arg02, local03
	sub	local03, #24
	cmp	local05, arg02 wc
 if_b	jmp	#LR__4791
	cmp	local02, #0 wz
 if_e	add	local01, #24
 if_e	wrlong	#0, local01
' 						dp->sect = 0; return FR_NO_FILE;
 if_e	mov	result1, #4
 if_e	jmp	#LR__4795
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_create_chain
	mov	local05, result1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__4795
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__4795
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4795
	mov	arg02, local05
	mov	arg01, local03
	call	#_fatfs_cc_dir_clear
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__4795
LR__4791
	add	local01, #20
	wrlong	local05, local01
	mov	arg01, local03
	mov	arg02, local05
	call	#_fatfs_cc_clst2sect
	add	local01, #4
	wrlong	result1, local01
	sub	local01, #24
LR__4792
LR__4793
LR__4794
	add	local01, #16
	wrlong	local04, local01
	add	local03, #52
	and	local04, #511
	add	local03, local04
	add	local01, #12
	wrlong	local03, local01
' #line 1771 "ff.c"
' 				}
' 				dp->clust = clst;
' 				dp->sect = clst2sect(fs, clst);
' 			}
' 		}
' 	}
' 	dp->dptr = ofs;
' 	dp->dir = fs->win + ofs %  ((UINT) 512 ) ;
' 
' 	return FR_OK;
	mov	result1, #0
LR__4795
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_next_ret
	ret

_fatfs_cc_dir_alloc
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local04, result1 wz
 if_ne	jmp	#LR__4804
	mov	local05, #0
' 		n = 0;
' 		do {
LR__4800
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local03
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4803
	add	local01, #28
	rdlong	local06, local01
	sub	local01, #28
	rdbyte	local06, local06
	cmp	local06, #229 wz
 if_ne	add	local01, #28
 if_ne	rdlong	local07, local01
 if_ne	sub	local01, #28
 if_ne	rdbyte	local08, local07 wz
 if_ne	jmp	#LR__4801
	add	local05, #1
	cmp	local05, local02 wz
 if_e	jmp	#LR__4803
	jmp	#LR__4802
LR__4801
	mov	local05, #0
LR__4802
	mov	arg01, local01
	mov	arg02, #1
	call	#_fatfs_cc_dir_next
	mov	local04, result1 wz
 if_e	jmp	#LR__4800
LR__4803
LR__4804
	cmp	local04, #4 wz
 if_e	mov	local04, #7
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_alloc_ret
	ret

_fatfs_cc_ld_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	arg01, result1, #0
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
' {
' 
' 	return *((WORD*)ptr);
 if_e	rdword	result1, arg02
 if_e	shl	result1, #16
 if_e	or	arg01, result1
' 		cl |= (DWORD)ld_word(dir +  20 ) << 16;
' 	}
' 
' 	return cl;
	mov	result1, arg01
_fatfs_cc_ld_clust_ret
	ret

_fatfs_cc_st_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
	wrword	arg03, arg01
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
 if_e	shr	arg03, #16
 if_e	wrword	arg03, arg02
_fatfs_cc_st_clust_ret
	ret

_fatfs_cc_cmp_lfn
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4816
	rdbyte	local02, arg02
	and	local02, #63
	sub	local02, #1
	qmul	local02, #13
' 
' 	i = ((dir[ 0 ] & 0x3F) - 1) * 13;
' 
' 	for (wc = 1, s = 0; s < 13; s++) {
	mov	local03, #1
	mov	local04, #0
	getqx	local05
LR__4810
	cmp	local04, #13 wc
 if_ae	jmp	#LR__4815
	mov	arg01, arg02
	mov	local02, local04
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##942
	add	local02, result1
	rdbyte	local02, local02
	add	arg01, local02
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local06, result1
	mov	local02, local03
	zerox	local02, #15 wz
 if_e	jmp	#LR__4813
	cmp	local05, #256 wc
 if_ae	jmp	#LR__4811
	getword	arg01, local06, #0
	call	#_fatfs_cc_ff_wtoupper
	mov	local02, result1
	mov	local03, local05
	shl	local03, #1
	add	local03, local01
	rdword	arg01, local03
	add	local05, #1
	call	#_fatfs_cc_ff_wtoupper
	cmp	local02, result1 wz
 if_e	jmp	#LR__4812
LR__4811
' 				return 0;
	mov	result1, #0
	jmp	#LR__4816
LR__4812
	mov	local03, local06
	jmp	#LR__4814
LR__4813
	getword	local06, local06, #0
	cmp	local06, ##65535 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4816
LR__4814
	add	local04, #1
	jmp	#LR__4810
LR__4815
	rdbyte	local02, arg02
	test	local02, #64 wz
 if_ne	cmp	local03, #0 wz
 if_ne	shl	local05, #1
 if_ne	add	local05, local01
 if_ne	rdword	local07, local05 wz
 if_ne	mov	result1, #0
' 
' 	return 1;
 if_e	mov	result1, #1
LR__4816
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_cmp_lfn_ret
	ret

_fatfs_cc_pick_lfn
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4825
	rdbyte	_var02, arg02
	andn	_var02, #64
	sub	_var02, #1
	qmul	_var02, #13
' 
' 	i = ((dir[ 0 ] & ~ 0x40 ) - 1) * 13;
' 
' 	for (wc = 1, s = 0; s < 13; s++) {
	mov	_var03, #1
	mov	_var04, #0
	getqx	_var05
LR__4820
	cmp	_var04, #13 wc
 if_ae	jmp	#LR__4823
	mov	arg01, arg02
	mov	_var02, _var04
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##942
	add	_var02, result1
	rdbyte	_var02, _var02
	add	arg01, _var02
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	_var06, result1
	mov	_var02, _var03
	zerox	_var02, #15 wz
 if_e	jmp	#LR__4821
	cmp	_var05, #256 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#LR__4825
	mov	_var02, _var05
	shl	_var02, #1
	add	_var02, _var01
	mov	_var03, _var06
	wrword	_var03, _var02
	add	_var05, #1
	jmp	#LR__4822
LR__4821
	getword	_var06, _var06, #0
	cmp	_var06, ##65535 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4825
LR__4822
	add	_var04, #1
	jmp	#LR__4820
LR__4823
	rdbyte	_var02, arg02
	test	_var02, #64 wz
 if_ne	mov	_var07, _var03
 if_ne	zerox	_var07, #15 wz
 if_e	jmp	#LR__4824
	cmp	_var05, #256 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#LR__4825
	shl	_var05, #1
	add	_var05, _var01
	wrword	#0, _var05
LR__4824
' 		lfnbuf[i] = 0;
' 	}
' 
' 	return 1;
	mov	result1, #1
LR__4825
_fatfs_cc_pick_lfn_ret
	ret

_fatfs_cc_put_lfn
	mov	_var01, arg02
	add	_var01, #13
	wrbyte	arg04, _var01
	getbyte	arg04, arg03, #0
	sub	arg04, #1
	qmul	arg04, #13
	mov	_var02, arg01
	sub	_var01, #2
	wrbyte	#15, _var01
	add	_var01, #1
	wrbyte	#0, _var01
	sub	_var01, #12
	mov	arg01, _var01
	add	arg01, #26
	wrword	#0, arg01
	mov	_var03, #0
	mov	_var04, #0
' 	BYTE* dir,
' 	BYTE ord,
' 	BYTE sum
' )
' {
' 	UINT i, s;
' 	WCHAR wc;
' 
' 
' 	dir[ 13 ] = sum;
' 	dir[ 11 ] =  0x0F ;
' 	dir[ 12 ] = 0;
' 	st_word(dir +  26 , 0);
' 
' 	i = (ord - 1) * 13;
' 	s = wc = 0;
' 	do {
	getqx	_var05
	callpa	#(@LR__4831-@LR__4830)>>2,fcache_load_ptr_
LR__4830
	getword	arg04, _var03, #0
	cmp	arg04, ##65535 wz
 if_ne	mov	arg01, _var05
 if_ne	add	_var05, #1
 if_ne	shl	arg01, #1
 if_ne	add	arg01, _var02
 if_ne	rdword	_var03, arg01
	mov	arg01, _var01
	mov	arg04, _var04
	mov	arg02, ptr__fatfs_cc_dat__
	add	arg02, ##942
	add	arg04, arg02
	rdbyte	arg04, arg04
	add	arg01, arg04
	wrword	_var03, arg01
	mov	arg04, _var03
	zerox	arg04, #15 wz
 if_e	bmask	_var03, #15
	add	_var04, #1
	cmp	_var04, #13 wc
 if_b	jmp	#LR__4830
LR__4831
	getword	_var03, _var03, #0
	cmp	_var03, ##65535 wz
 if_ne	shl	_var05, #1
 if_ne	add	_var05, _var02
 if_ne	rdword	_var05, _var05 wz
 if_e	getbyte	arg03, arg03, #0
 if_e	or	arg03, #64
	wrbyte	arg03, _var01
_fatfs_cc_put_lfn_ret
	ret

_fatfs_cc_gen_numname
	mov	COUNT_, #8
	call	#pushregs_
	add	ptra, #44
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #11
	call	#__system____builtin_memmove
	cmp	local04, #6 wc
 if_b	jmp	#LR__4845
	mov	local05, local04
	callpa	#(@LR__4843-@LR__4840)>>2,fcache_load_ptr_
' 		sreg = seq;
' 		while (*lfn) {
LR__4840
	rdword	local06, local03 wz
 if_e	jmp	#LR__4844
	rdword	local07, local03
' 			wc = *lfn++;
' 			for (i = 0; i < 16; i++) {
	add	local03, #2
	rep	@LR__4842, #16
LR__4841
	shl	local05, #1
	getword	local06, local07, #0
	and	local06, #1
	add	local05, local06
	getword	local07, local07, #0
	shr	local07, #1
	testbn	local05, #16 wz
 if_ne	xor	local05, ##69665
LR__4842
	jmp	#LR__4840
LR__4843
LR__4844
	mov	local04, local05
LR__4845
	mov	local07, #7
	callpa	#(@LR__4847-@LR__4846)>>2,fcache_load_ptr_
' 			}
' 		}
' 		seq = (UINT)sreg;
' 	}
' 
' 
' 	i = 7;
' 	do {
LR__4846
	getnib	local05, local04, #0
	add	local05, #48
	shr	local04, #4
	getbyte	local06, local05, #0
	cmp	local06, #58 wc
 if_ae	getbyte	local05, local05, #0
 if_ae	add	local05, #7
	mov	local06, local07
	sub	local07, #1 wz
	mov	local03, fp
	add	local03, #16
	add	local06, local03
	wrbyte	local05, local06
 if_ne	cmp	local04, #0 wz
 if_ne	jmp	#LR__4846
LR__4847
	mov	local06, local07
	mov	local05, fp
	add	local05, #16
	add	local06, local05
	wrbyte	#126, local06
' 	ns[i] = '~';
' 
' 
' 	for (j = 0; j < i && dst[j] != ' '; j++) {
	mov	local04, #0
	callpa	#(@LR__4850-@LR__4848)>>2,fcache_load_ptr_
LR__4848
	cmp	local04, local07 wc
 if_ae	jmp	#LR__4851
	mov	local05, local04
	add	local05, local01
	rdbyte	local06, local05
	cmp	local06, #32 wz
 if_e	jmp	#LR__4851
	mov	local03, local04
	add	local03, local01
	rdbyte	arg01, local03 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__4849
	mov	local03, local07
	sub	local03, #1
	cmp	local04, local03 wz
 if_e	jmp	#LR__4851
	add	local04, #1
LR__4849
	add	local04, #1
	jmp	#LR__4848
LR__4850
LR__4851
	callpa	#(@LR__4855-@LR__4852)>>2,fcache_load_ptr_
' 			j++;
' 		}
' 	}
' 	do {
LR__4852
	mov	local06, local04
	add	local06, local01
	cmp	local07, #8 wc
	add	local04, #1
 if_ae	jmp	#LR__4853
	mov	local05, local07
	mov	local03, fp
	add	local03, #16
	add	local05, local03
	rdbyte	local08, local05
	add	local07, #1
	jmp	#LR__4854
LR__4853
	mov	local08, #32
LR__4854
	wrbyte	local08, local06
	cmp	local04, #8 wc
 if_b	jmp	#LR__4852
LR__4855
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_gen_numname_ret
	ret

_fatfs_cc_sum_sfn
	mov	_var01, #0
' )
' {
' 	BYTE sum = 0;
' 	UINT n = 11;
' 
' 	do {
	callpa	#(@LR__4862-@LR__4860)>>2,fcache_load_ptr_
LR__4860
	rep	@LR__4863, #11
LR__4861
	getbyte	result1, _var01, #0
	shr	result1, #1
	getbyte	_var01, _var01, #0
	shl	_var01, #7
	add	result1, _var01
	rdbyte	_var01, arg01
	add	_var01, result1
	add	arg01, #1
LR__4862
LR__4863
' 	return sum;
	mov	result1, _var01
_fatfs_cc_sum_sfn_ret
	ret

_fatfs_cc_dir_read
	mov	COUNT_, #12
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #4
	rdlong	local04, local01
	mov	local05, #255
	mov	local06, #255
' )
' {
' 	FRESULT res = FR_NO_FILE;
' 	FATFS *fs = dp->obj.fs;
' 	BYTE attr, b;
' 
' 	BYTE ord = 0xFF, sum = 0xFF;
' 
' 
' 	while (dp->sect) {
LR__4870
	add	local01, #24
	rdlong	result1, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__4880
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local04
	call	#_fatfs_cc_move_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__4880
	add	local01, #28
	rdlong	result1, local01
	sub	local01, #28
	rdbyte	local07, result1
	mov	result1, local07
	zerox	result1, #7 wz
 if_e	mov	local03, #4
' 			res = FR_NO_FILE; break;
 if_e	jmp	#LR__4880
	add	local01, #28
	rdlong	local08, local01
	add	local08, #11
	rdbyte	local09, local08
	and	local09, #63
	sub	local01, #22
	wrbyte	local09, local01
	sub	local01, #6
	getbyte	result1, local07, #0
	cmp	result1, #229 wz
 if_ne	mov	local08, local07
 if_ne	getbyte	local08, local08, #0
 if_ne	cmp	local08, #46 wz
 if_e	jmp	#LR__4871
	mov	local10, #0
	getbyte	local08, local09, #0
	andn	local08, #32
	cmp	local08, #8 wz
 if_e	mov	local10, #1
	cmp	local10, local02 wz
 if_e	jmp	#LR__4872
LR__4871
	mov	local05, #255
	jmp	#LR__4879
LR__4872
	getbyte	local09, local09, #0
	cmp	local09, #15 wz
 if_ne	jmp	#LR__4876
	getbyte	local11, local07, #0
	test	local11, #64 wz
 if_e	jmp	#LR__4873
	add	local01, #28
	rdlong	local11, local01
	add	local11, #13
	rdbyte	local06, local11
	getbyte	local07, local07, #0
	and	local07, #191
	mov	local05, local07
	sub	local01, #12
	rdlong	local11, local01
	add	local01, #28
	wrlong	local11, local01
	sub	local01, #44
LR__4873
	getbyte	local08, local07, #0
	getbyte	local10, local05, #0
	cmp	local08, local10 wz
 if_ne	jmp	#LR__4874
	getbyte	local10, local06, #0
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	add	local09, #13
	rdbyte	local08, local09
	getbyte	local09, local08, #0
	cmp	local10, local09 wz
 if_ne	jmp	#LR__4874
	add	local04, #12
	rdlong	arg01, local04
	sub	local04, #12
	add	local01, #28
	rdlong	local12, local01
	sub	local01, #28
	mov	arg02, local12
	call	#_fatfs_cc_pick_lfn
	cmps	result1, #0 wz
 if_ne	mov	local12, local05
 if_ne	getbyte	local12, local12, #0
 if_ne	sub	local12, #1
 if_ne	mov	local11, local12
 if_ne	jmp	#LR__4875
LR__4874
	mov	local11, #255
LR__4875
	mov	local05, local11
	jmp	#LR__4878
LR__4876
	mov	local11, local05
	zerox	local11, #7 wz
 if_ne	jmp	#LR__4877
	getbyte	local06, local06, #0
	add	local01, #28
	rdlong	arg01, local01
	sub	local01, #28
	call	#_fatfs_cc_sum_sfn
	getbyte	result1, result1, #0
	cmp	local06, result1 wz
 if_e	jmp	#LR__4880
LR__4877
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
' 						dp->blk_ofs = 0xFFFFFFFF;
' 					}
' 					break;
	jmp	#LR__4880
LR__4878
LR__4879
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local03, result1 wz
 if_e	jmp	#LR__4870
LR__4880
	cmp	local03, #0 wz
 if_ne	add	local01, #24
 if_ne	wrlong	#0, local01
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_read_ret
	ret

_fatfs_cc_dir_find
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4902
	mov	local03, #255
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
' #line 2404 "ff.c"
' 	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;
' 
' 	do {
LR__4890
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local05, result1 wz
 if_ne	jmp	#LR__4901
	add	local01, #28
	rdlong	arg03, local01
	sub	local01, #28
	rdbyte	local06, arg03
	mov	arg03, local06
	zerox	arg03, #7 wz
 if_e	mov	local05, #4
 if_e	jmp	#LR__4901
	add	local01, #28
	rdlong	local07, local01
	mov	arg03, local07
	add	arg03, #11
	rdbyte	local08, arg03
	and	local08, #63
	sub	local01, #22
	wrbyte	local08, local01
	sub	local01, #6
	getbyte	arg03, local06, #0
	cmp	arg03, #229 wz
 if_e	jmp	#LR__4891
	getbyte	arg03, local08, #0
	test	arg03, #8 wz
 if_ne	mov	local07, local08
 if_ne	getbyte	local07, local07, #0
 if_ne	cmp	local07, #15 wz
 if_e	jmp	#LR__4892
LR__4891
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
	jmp	#LR__4900
LR__4892
	getbyte	local08, local08, #0
	cmp	local08, #15 wz
 if_ne	jmp	#LR__4896
	add	local01, #43
	rdbyte	local08, local01
	sub	local01, #43
	test	local08, #64 wz
 if_ne	jmp	#LR__4899
	getbyte	local09, local06, #0
	test	local09, #64 wz
 if_e	jmp	#LR__4893
	add	local01, #28
	rdlong	local09, local01
	add	local09, #13
	rdbyte	local03, local09
	getbyte	local06, local06, #0
	and	local06, #191
	mov	local04, local06
	sub	local01, #12
	rdlong	local09, local01
	add	local01, #28
	wrlong	local09, local01
	sub	local01, #44
LR__4893
	getbyte	local10, local06, #0
	getbyte	local07, local04, #0
	cmp	local10, local07 wz
 if_ne	jmp	#LR__4894
	getbyte	local08, local03, #0
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	add	local07, #13
	rdbyte	local06, local07
	getbyte	local07, local06, #0
	cmp	local08, local07 wz
 if_ne	jmp	#LR__4894
	add	local02, #12
	rdlong	arg01, local02
	sub	local02, #12
	add	local01, #28
	rdlong	local11, local01
	sub	local01, #28
	mov	arg02, local11
	call	#_fatfs_cc_cmp_lfn
	cmps	result1, #0 wz
 if_ne	mov	local11, local04
 if_ne	getbyte	local11, local11, #0
 if_ne	sub	local11, #1
 if_ne	mov	local09, local11
 if_ne	jmp	#LR__4895
LR__4894
	mov	local09, #255
LR__4895
	mov	local04, local09
	jmp	#LR__4899
LR__4896
	mov	local09, local04
	zerox	local09, #7 wz
 if_ne	jmp	#LR__4897
	getbyte	local10, local03, #0
	add	local01, #28
	rdlong	arg01, local01
	sub	local01, #28
	call	#_fatfs_cc_sum_sfn
	getbyte	result1, result1, #0
	cmp	local10, result1 wz
 if_e	jmp	#LR__4901
LR__4897
	add	local01, #43
	rdbyte	local09, local01
	sub	local01, #43
	test	local09, #1 wz
 if_ne	jmp	#LR__4898
	add	local01, #28
	rdlong	arg01, local01
	add	local01, #4
	mov	arg02, local01
	sub	local01, #32
	mov	arg03, #11
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__4901
LR__4898
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
LR__4899
LR__4900
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local05, result1 wz
 if_e	jmp	#LR__4890
LR__4901
' 
' 	return res;
	mov	result1, local05
LR__4902
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_find_ret
	ret

_fatfs_cc_dir_register
	mov	COUNT_, #9
	call	#pushregs_
	add	ptra, #44
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #43
	rdbyte	local03, local01
	sub	local01, #43
	test	local03, #160 wz
 if_ne	mov	result1, #6
 if_ne	jmp	#LR__4921
' 	for (len = 0; fs->lfnbuf[len]; len++) ;
	mov	local04, #0
	add	local02, #12
	callpa	#(@LR__4911-@LR__4910)>>2,fcache_load_ptr_
LR__4910
	rdlong	local03, local02
	mov	arg04, local04
	shl	arg04, #1
	add	arg04, local03
	rdword	local03, arg04 wz
 if_ne	mov	local05, local04
 if_ne	add	local05, #1
 if_ne	mov	local04, local05
 if_ne	jmp	#LR__4910
LR__4911
	sub	local02, #12
	mov	arg01, fp
	add	arg01, #28
	mov	arg02, local01
	add	arg02, #32
	mov	arg03, #12
	call	#__system____builtin_memmove
	add	fp, #39
	rdbyte	local03, fp
	sub	fp, #39
	test	local03, #1 wz
 if_e	jmp	#LR__4914
	add	local01, #43
	wrbyte	#64, local01
	sub	local01, #43
' 		dp->fn[ 11 ] =  0x40 ;
' 		for (n = 1; n < 100; n++) {
	mov	local06, #1
LR__4912
	cmp	local06, #100 wc
 if_ae	jmp	#LR__4913
	mov	arg01, local01
	add	arg01, #32
	mov	arg02, fp
	add	arg02, #28
	add	local02, #12
	rdlong	arg03, local02
	sub	local02, #12
	mov	arg04, local06
	call	#_fatfs_cc_gen_numname
	mov	arg01, local01
	call	#_fatfs_cc_dir_find
	mov	local07, result1 wz
 if_e	add	local06, #1
 if_e	jmp	#LR__4912
LR__4913
	cmp	local06, #100 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__4921
	cmp	local07, #4 wz
 if_ne	mov	result1, local07
 if_ne	jmp	#LR__4921
	add	fp, #39
	rdbyte	local03, fp
	sub	fp, #39
	add	local01, #43
	wrbyte	local03, local01
	sub	local01, #43
LR__4914
	add	fp, #39
	rdbyte	local07, fp
	test	local07, #2 wz
 if_ne	add	local04, #12
 if_ne	qdiv	local04, #13
	sub	fp, #39
	mov	arg01, local01
 if_ne	getqx	local03
 if_ne	add	local03, #1
 if_e	mov	local03, #1
	mov	local08, local03
	mov	arg02, local08
	call	#_fatfs_cc_dir_alloc
	mov	local07, result1 wz
 if_ne	jmp	#LR__4918
	sub	local08, #1 wz
 if_e	jmp	#LR__4918
	mov	arg01, local01
	mov	local07, local08
	shl	local07, #5
	add	local01, #16
	rdlong	arg02, local01
	sub	local01, #16
	sub	arg02, local07
	call	#_fatfs_cc_dir_sdi
	mov	local07, result1 wz
 if_ne	jmp	#LR__4917
	mov	arg01, local01
	add	arg01, #32
	call	#_fatfs_cc_sum_sfn
	mov	local09, result1
' 			sum = sum_sfn(dp->fn);
' 			do {
LR__4915
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local07, result1 wz
 if_ne	jmp	#LR__4916
	add	local02, #12
	rdlong	arg01, local02
	add	local01, #28
	rdlong	arg02, local01
	sub	local01, #28
	mov	arg04, local09
	mov	arg03, local08
	call	#_fatfs_cc_put_lfn
	sub	local02, #9
	wrbyte	#1, local02
	sub	local02, #3
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local07, result1 wz
 if_e	djnz	local08, #LR__4915
LR__4916
LR__4917
LR__4918
	cmp	local07, #0 wz
 if_ne	jmp	#LR__4920
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local07, result1 wz
 if_ne	jmp	#LR__4919
	add	local01, #28
	rdlong	arg01, local01
	mov	arg02, #0
	mov	arg03, #32
	call	#\builtin_bytefill_
	rdlong	arg01, local01
	add	local01, #4
	mov	arg02, local01
	mov	arg03, #11
	call	#__system____builtin_memmove
	sub	local01, #4
	rdlong	local03, local01
	add	local01, #15
	rdbyte	local09, local01
	and	local09, #24
	add	local03, #12
	wrbyte	local09, local03
	add	local02, #3
	wrbyte	#1, local02
LR__4919
LR__4920
' 			__builtin_memset(dp->dir, 0, 32 ) ;
' 			__builtin_memcpy(dp->dir + 0 , dp->fn, 11) ;
' 
' 			dp->dir[ 12 ] = dp->fn[ 11 ] & ( 0x08  |  0x10 );
' 
' 			fs->wflag = 1;
' 		}
' 	}
' 
' 	return res;
	mov	result1, local07
LR__4921
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_register_ret
	ret

_fatfs_cc_dir_remove
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #16
	rdlong	local03, local01
	add	local01, #28
	rdlong	arg02, local01
	sub	local01, #44
	cmp	arg02, ##-1 wz
 if_e	mov	local04, #0
 if_e	jmp	#LR__4930
	mov	arg01, local01
	add	local01, #44
	rdlong	arg02, local01
	sub	local01, #44
	call	#_fatfs_cc_dir_sdi
	mov	local04, result1
LR__4930
	mov	local05, local04 wz
 if_ne	jmp	#LR__4933
' 		do {
LR__4931
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local05, result1 wz
 if_ne	jmp	#LR__4932
	add	local01, #28
	rdlong	local04, local01
	wrbyte	#229, local04
	add	local02, #3
	wrbyte	#1, local02
	sub	local02, #3
	sub	local01, #12
	rdlong	local04, local01
	sub	local01, #16
	cmp	local04, local03 wc
 if_ae	jmp	#LR__4932
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local05, result1 wz
 if_e	jmp	#LR__4931
LR__4932
	cmp	local05, #4 wz
 if_e	mov	local05, #2
LR__4933
' 	}
' #line 2590 "ff.c"
' 	return res;
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_remove_ret
	ret

_fatfs_cc_get_fileinfo
	mov	COUNT_, #12
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	add	local02, #28
	wrbyte	#0, local02
	sub	local02, #28
	add	local01, #24
	rdlong	local04, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__4954
	add	local01, #44
	rdlong	local04, local01
	sub	local01, #44
	cmp	local04, ##-1 wz
 if_e	jmp	#LR__4943
	mov	local05, #0
	mov	local06, #0
	mov	local07, #0
' 			si = di = 0;
' 			hs = 0;
' 			while (fs->lfnbuf[si] != 0) {
LR__4940
	add	local03, #12
	rdlong	local04, local03
	sub	local03, #12
	mov	local08, local06
	shl	local08, #1
	add	local08, local04
	rdword	local04, local08 wz
 if_e	jmp	#LR__4942
	add	local03, #12
	rdlong	local09, local03
	sub	local03, #12
	mov	local04, local06
	shl	local04, #1
	add	local04, local09
	rdword	local10, local04
	mov	local04, local07
	zerox	local04, #15 wz
	add	local06, #1
 if_ne	jmp	#LR__4941
	getword	local04, local10, #0
	cmp	local04, ##55296 wc
 if_b	jmp	#LR__4941
	getword	local11, local10, #0
	cmp	local11, ##57344 wc
 if_b	mov	local07, local10
' 					hs = wc; continue;
 if_b	jmp	#LR__4940
LR__4941
	getword	arg01, local07, #0
	shl	arg01, #16
	getword	local10, local10, #0
	or	arg01, local10
	mov	arg02, local05
	mov	local10, local02
	add	local10, #28
	add	arg02, local10
	mov	arg03, #255
	sub	arg03, local05
	call	#_fatfs_cc_put_utf
	mov	local10, result1 wz
 if_e	mov	local05, #0
 if_ne	add	local05, local10
 if_ne	mov	local07, #0
 if_ne	jmp	#LR__4940
LR__4942
	mov	local04, local07
	zerox	local04, #15 wz
 if_ne	mov	local05, #0
	mov	local10, local02
	add	local10, #28
	add	local05, local10
	wrbyte	#0, local05
LR__4943
	mov	local05, #0
	mov	local06, #0
' 			fno->fname[di] = 0;
' 		}
' 	}
' 
' 	si = di = 0;
' 	while (si < 11) {
LR__4944
	cmp	local06, #11 wc
 if_ae	jmp	#LR__4947
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	mov	local10, local06
	add	local10, local09
	rdbyte	local10, local10
	getword	local04, local10, #0
	cmp	local04, #32 wz
	add	local06, #1
 if_e	jmp	#LR__4944
	getword	local04, local10, #0
	cmp	local04, #5 wz
 if_e	mov	local10, #229
	cmp	local06, #9 wz
 if_ne	jmp	#LR__4945
	cmp	local05, #12 wc
 if_ae	jmp	#LR__4945
	mov	local11, local05
	mov	local08, local02
	add	local08, #12
	add	local11, local08
	wrbyte	#46, local11
	add	local05, #1
LR__4945
	getword	arg01, local10, #0
	zerox	arg01, #7 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_ne	cmp	local06, #8 wz
 if_ne	cmp	local06, #11 wz
 if_e	jmp	#LR__4946
	add	local01, #28
	rdlong	local11, local01
	sub	local01, #28
	mov	local08, local06
	add	local08, local11
	rdbyte	arg01, local08 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__4946
	getword	local10, local10, #0
	shl	local10, #8
	add	local01, #28
	rdlong	local11, local01
	sub	local01, #28
	mov	local09, local06
	add	local09, local11
	rdbyte	local11, local09
	or	local10, local11
	add	local06, #1
LR__4946
	mov	arg01, local10
	mov	arg02, ##850
	call	#_fatfs_cc_ff_oem2uni
	mov	local10, result1
	mov	local04, local10
	zerox	local04, #15 wz
 if_e	mov	local05, #0
 if_e	jmp	#LR__4947
	getword	arg01, local10, #0
	mov	arg02, local05
	mov	local11, local02
	add	local11, #12
	add	arg02, local11
	mov	arg03, #12
	sub	arg03, local05
	call	#_fatfs_cc_put_utf
	mov	local11, result1 wz
 if_e	mov	local05, #0
 if_ne	add	local05, local11
 if_ne	jmp	#LR__4944
LR__4947
	mov	local04, local05
	add	local02, #12
	add	local04, local02
	wrbyte	#0, local04
	add	local02, #16
	rdbyte	local04, local02 wz
	sub	local02, #28
 if_ne	jmp	#LR__4953
	cmp	local05, #0 wz
 if_ne	jmp	#LR__4948
	mov	local11, local05
	mov	local10, local02
	add	local10, #28
	add	local11, local10
	wrbyte	#63, local11
	add	local05, #1
	jmp	#LR__4952
LR__4948
' 			for (si = di = 0, lcf =  0x08 ; fno->altname[si]; si++, di++) {
	mov	local05, #0
	mov	local06, #0
	mov	local12, #8
LR__4949
	mov	local04, local06
	mov	local11, local02
	add	local11, #12
	add	local04, local11
	rdbyte	local11, local04 wz
 if_e	jmp	#LR__4951
	mov	local08, local06
	mov	local11, local02
	add	local11, #12
	add	local08, local11
	rdbyte	local10, local08
	getword	local11, local10, #0
	cmp	local11, #46 wz
 if_e	mov	local12, #16
	getword	local11, local10, #0
	cmp	local11, #65 wc
 if_b	jmp	#LR__4950
	getword	local08, local10, #0
	cmp	local08, #91 wc
 if_ae	jmp	#LR__4950
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	add	local09, #12
	rdbyte	local09, local09
	getbyte	local11, local12, #0
	test	local09, local11 wz
 if_ne	getword	local10, local10, #0
 if_ne	add	local10, #32
LR__4950
	mov	local11, local05
	mov	local08, local02
	add	local08, #28
	add	local11, local08
	getword	local10, local10, #0
	wrbyte	local10, local11
	add	local06, #1
	add	local05, #1
	jmp	#LR__4949
LR__4951
LR__4952
	mov	local12, local02
	add	local12, #28
	add	local05, local12
	wrbyte	#0, local05
	add	local01, #28
	rdlong	local04, local01
	sub	local01, #28
	add	local04, #12
	rdbyte	local11, local04 wz
 if_e	add	local02, #12
 if_e	wrbyte	#0, local02
 if_e	sub	local02, #12
LR__4953
	add	local01, #28
	rdlong	local12, local01
	add	local12, #11
	rdbyte	local04, local12
	and	local04, #63
	add	local02, #8
	wrbyte	local04, local02
	sub	local02, #8
	rdlong	arg01, local01
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	wrlong	result1, local02
	rdlong	arg01, local01
	add	arg01, #22
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	local02, #6
	wrword	result1, local02
	rdlong	arg01, local01
	add	arg01, #24
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	local02, #2
	wrword	result1, local02
LR__4954
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_fileinfo_ret
	ret

_fatfs_cc_create_name
	mov	COUNT_, #18
	call	#pushregs_
	add	ptra, #52
	mov	local01, arg01
	mov	local02, arg02
	rdlong	result1, local02
	add	fp, #48
	wrlong	result1, fp
	sub	fp, #48
	rdlong	local03, local01
	add	local03, #12
	rdlong	local04, local03
	mov	local05, #0
' 
' 
' 
' 	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
' 	for (;;) {
LR__4960
	mov	arg01, fp
	add	arg01, #48
	call	#_fatfs_cc_tchar2uni
	mov	local06, result1
	cmp	local06, ##-1 wz
 if_e	mov	result1, #6
 if_e	jmp	#LR__4994
	cmp	local06, ##65536 wc
 if_b	jmp	#LR__4961
	mov	local03, local05
	shl	local03, #1
	mov	local07, local04
	add	local03, local04
	mov	local08, local06
	shr	local08, #16
	wrword	local08, local03
	add	local05, #1
LR__4961
	mov	local09, local06
	getword	local03, local09, #0
	cmp	local03, #32 wc
 if_b	jmp	#LR__4963
	getword	local10, local09, #0
	cmp	local10, #47 wz
 if_ne	mov	local03, local09
 if_ne	getword	local03, local03, #0
 if_ne	cmp	local03, #92 wz
 if_e	jmp	#LR__4963
	getword	local03, local09, #0
	cmp	local03, #128 wc
 if_ae	jmp	#LR__4962
	mov	arg01, ##@LR__5483
	getword	arg02, local09, #0
	call	#_fatfs_cc_strchr
	mov	local10, result1 wz
 if_ne	mov	result1, #6
 if_ne	jmp	#LR__4994
LR__4962
	cmp	local05, #255 wc
 if_ae	mov	result1, #6
 if_ae	jmp	#LR__4994
	mov	local06, local05
	shl	local06, #1
	mov	local07, local04
	add	local06, local04
	wrword	local09, local06
	add	local05, #1
	jmp	#LR__4960
LR__4963
	getword	local03, local09, #0
	cmp	local03, #32 wc
 if_b	mov	local11, #4
 if_b	jmp	#LR__4968
	callpa	#(@LR__4966-@LR__4964)>>2,fcache_load_ptr_
' 		while ( ((*p) == '/' || (*p) == '\\') ) p++;
LR__4964
	add	fp, #48
	rdlong	local10, fp
	sub	fp, #48
	rdbyte	local03, local10
	cmp	local03, #47 wz
 if_e	jmp	#LR__4965
	add	fp, #48
	rdlong	local08, fp
	sub	fp, #48
	rdbyte	local11, local08
	cmp	local11, #92 wz
 if_ne	jmp	#LR__4967
LR__4965
	add	fp, #48
	rdlong	local11, fp
	add	local11, #1
	wrlong	local11, fp
	sub	fp, #48
	jmp	#LR__4964
LR__4966
LR__4967
	mov	local11, #0
	add	fp, #48
	rdlong	local10, fp
	sub	fp, #48
	rdbyte	local03, local10
	cmp	local03, #32 wc
 if_b	mov	local11, #4
LR__4968
	add	fp, #48
	rdlong	local03, fp
	sub	fp, #48
	wrlong	local03, local02
' 	}
' 	*path = p;
' #line 2862 "ff.c"
' 	while (di) {
	cmp	local05, #0 wz
 if_e	jmp	#LR__4971
	callpa	#(@LR__4970-@LR__4969)>>2,fcache_load_ptr_
LR__4969
	mov	local09, local05
	sub	local09, #1
	shl	local09, #1
	add	local09, local04
	rdword	local09, local09
	getword	local03, local09, #0
	cmp	local03, #32 wz
 if_ne	mov	local10, local09
 if_ne	getword	local10, local10, #0
 if_ne	cmp	local10, #46 wz
 if_e	djnz	local05, #LR__4969
LR__4970
LR__4971
	mov	local10, local05
	shl	local10, #1
	add	local10, local04
	wrword	#0, local10
	cmp	local05, #0 wz
 if_e	mov	result1, #6
 if_e	jmp	#LR__4994
' 
' 
' 	for (si = 0; lfn[si] == ' '; si++) ;
	mov	local12, #0
	callpa	#(@LR__4973-@LR__4972)>>2,fcache_load_ptr_
LR__4972
	mov	local09, local12
	shl	local09, #1
	add	local09, local04
	rdword	local03, local09
	cmp	local03, #32 wz
 if_e	mov	local08, local12
 if_e	add	local08, #1
 if_e	mov	local12, local08
 if_e	jmp	#LR__4972
LR__4973
	cmp	local12, #1 wc
 if_ae	jmp	#LR__4974
	mov	local09, local12
	shl	local09, #1
	add	local09, local04
	rdword	local03, local09
	cmp	local03, #46 wz
 if_ne	jmp	#LR__4975
LR__4974
	getbyte	local11, local11, #0
	or	local11, #3
LR__4975
	callpa	#(@LR__4977-@LR__4976)>>2,fcache_load_ptr_
' 	while (di > 0 && lfn[di - 1] != '.') di--;
LR__4976
	cmp	local05, #1 wc
 if_b	jmp	#LR__4978
	mov	local09, local05
	sub	local09, #1
	shl	local09, #1
	add	local09, local04
	rdword	local03, local09
	cmp	local03, #46 wz
 if_ne	sub	local05, #1
 if_ne	jmp	#LR__4976
LR__4977
LR__4978
	mov	arg01, local01
	add	arg01, #32
	mov	arg02, #32
	mov	arg03, #11
	mov	local13, arg01
	call	#\builtin_bytefill_
	mov	result1, local13
	mov	local14, #0
	mov	local15, #0
	mov	local16, #8
' 
' 	__builtin_memset(dp->fn, ' ', 11) ;
' 	i = b = 0; ni = 8;
' 	for (;;) {
LR__4979
	mov	local17, local12
	mov	local18, local17
	shl	local18, #1
	mov	local07, local04
	add	local18, local04
	rdword	local09, local18
	mov	local03, local09
	zerox	local03, #15 wz
	add	local12, #1
 if_e	jmp	#LR__4992
	getword	local03, local09, #0
	cmp	local03, #32 wz
 if_e	jmp	#LR__4980
	getword	local10, local09, #0
	cmp	local10, #46 wz
 if_ne	jmp	#LR__4981
	cmp	local12, local05 wz
 if_e	jmp	#LR__4981
LR__4980
	getbyte	local11, local11, #0
	or	local11, #3
' 			cf |=  0x01  |  0x02 ;
' 			continue;
	jmp	#LR__4979
LR__4981
	cmp	local15, local16 wc
 if_b	cmp	local12, local05 wz
 if_c_and_nz	jmp	#LR__4982
	cmp	local16, #11 wz
 if_e	getbyte	local11, local11, #0
 if_e	or	local11, #3
' 				cf |=  0x01  |  0x02 ;
' 				break;
 if_e	jmp	#LR__4992
	cmp	local12, local05 wz
 if_ne	getbyte	local11, local11, #0
 if_ne	or	local11, #3
	cmp	local12, local05 wcz
 if_a	jmp	#LR__4992
	mov	local12, local05
	mov	local15, #8
	mov	local16, #11
	getbyte	local14, local14, #0
	shl	local14, #2
' 			si = di; i = 8; ni = 11; b <<= 2;
' 			continue;
	jmp	#LR__4979
LR__4982
	getword	local03, local09, #0
	cmp	local03, #128 wc
 if_b	jmp	#LR__4984
	getbyte	local11, local11, #0
	or	local11, #2
	getword	arg01, local09, #0
	mov	local10, ##850
	mov	arg02, ##850
	call	#_fatfs_cc_ff_uni2oem
	mov	local09, result1
	getword	local03, local09, #0
	test	local03, #128 wz
 if_e	jmp	#LR__4983
	getword	local10, local09, #0
	and	local10, #127
	mov	local17, local10
	mov	local18, ptr__fatfs_cc_dat__
	add	local18, ##955
	add	local17, local18
	rdbyte	local09, local17
LR__4983
LR__4984
	getword	local03, local09, #0
	cmp	local03, #256 wc
 if_b	jmp	#LR__4985
	mov	local03, local16
	sub	local03, #1
	cmp	local15, local03 wc
 if_ae	getbyte	local11, local11, #0
 if_ae	or	local11, #3
 if_ae	mov	local15, local16
' 				cf |=  0x01  |  0x02 ;
' 				i = ni; continue;
 if_ae	jmp	#LR__4979
	mov	local17, local15
	mov	local18, local01
	add	local18, #32
	add	local17, local18
	getword	local07, local09, #0
	shr	local07, #8
	wrbyte	local07, local17
	add	local15, #1
	jmp	#LR__4991
LR__4985
	mov	local03, local09
	zerox	local03, #15 wz
 if_e	jmp	#LR__4986
	mov	arg01, ##@LR__5484
	getword	arg02, local09, #0
	call	#_fatfs_cc_strchr
	cmp	result1, #0 wz
 if_e	jmp	#LR__4987
LR__4986
	mov	local09, #95
	getbyte	local11, local11, #0
	or	local11, #3
	jmp	#LR__4990
LR__4987
	getword	local03, local09, #0
	cmp	local03, #65 wc
 if_b	jmp	#LR__4988
	getword	local10, local09, #0
	cmp	local10, #91 wc
 if_b	getbyte	local14, local14, #0
 if_b	or	local14, #2
LR__4988
	getword	local03, local09, #0
	cmp	local03, #97 wc
 if_b	jmp	#LR__4989
	getword	local10, local09, #0
	cmp	local10, #123 wc
 if_b	getbyte	local14, local14, #0
 if_b	or	local14, #1
 if_b	getword	local09, local09, #0
 if_b	sub	local09, #32
LR__4989
LR__4990
LR__4991
	mov	local17, local15
	mov	local18, local01
	add	local18, #32
	add	local17, local18
	getword	local09, local09, #0
	wrbyte	local09, local17
	add	local15, #1
	jmp	#LR__4979
LR__4992
	add	local01, #32
	rdbyte	local03, local01
	sub	local01, #32
	cmp	local03, #229 wz
 if_e	add	local01, #32
 if_e	wrbyte	#5, local01
 if_e	sub	local01, #32
	cmp	local16, #8 wz
 if_e	getbyte	local14, local14, #0
 if_e	shl	local14, #2
	getbyte	local03, local14, #0
	and	local03, #12
	cmp	local03, #12 wz
 if_ne	mov	local10, local14
 if_ne	getbyte	local10, local10, #0
 if_ne	and	local10, #3
 if_ne	cmp	local10, #3 wz
 if_e	getbyte	local11, local11, #0
 if_e	or	local11, #2
	getbyte	local03, local11, #0
	test	local03, #2 wz
 if_ne	jmp	#LR__4993
	getbyte	local03, local14, #0
	test	local03, #1 wz
 if_ne	getbyte	local11, local11, #0
 if_ne	or	local11, #16
	getbyte	local14, local14, #0
	test	local14, #4 wz
 if_ne	getbyte	local11, local11, #0
 if_ne	or	local11, #8
LR__4993
	add	local01, #43
	wrbyte	local11, local01
' 	}
' 
' 	dp->fn[ 11 ] = cf;
' 
' 	return FR_OK;
	mov	result1, #0
LR__4994
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_name_ret
	ret

_fatfs_cc_follow_path
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #24
	mov	local01, arg01
	add	fp, #8
	wrlong	arg02, fp
	sub	fp, #8
	rdlong	local02, local01
	callpa	#(@LR__5002-@LR__5000)>>2,fcache_load_ptr_
' )
' {
' 	FRESULT res;
' 	BYTE ns;
' 	FATFS *fs = dp->obj.fs;
' #line 3034 "ff.c"
' 	{
' 		while ( ((*path) == '/' || (*path) == '\\') ) path++;
LR__5000
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	rdbyte	result1, result1
	cmp	result1, #47 wz
 if_e	jmp	#LR__5001
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	rdbyte	result1, result1
	cmp	result1, #92 wz
 if_ne	jmp	#LR__5003
LR__5001
	add	fp, #8
	rdlong	result1, fp
	add	result1, #1
	wrlong	result1, fp
	sub	fp, #8
	jmp	#LR__5000
LR__5002
LR__5003
	add	local01, #8
	wrlong	#0, local01
	sub	local01, #8
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	rdbyte	arg02, arg02
	cmp	arg02, #32 wc
 if_ae	jmp	#LR__5004
	add	local01, #43
	wrbyte	#128, local01
	sub	local01, #43
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local03, result1
	jmp	#LR__5008
LR__5004
' 		for (;;) {
LR__5005
	mov	arg02, fp
	add	arg02, #8
	mov	arg01, local01
	call	#_fatfs_cc_create_name
	mov	local03, result1 wz
 if_ne	jmp	#LR__5007
	mov	arg01, local01
	call	#_fatfs_cc_dir_find
	mov	local03, result1 wz
	add	local01, #43
	rdbyte	local04, local01
	sub	local01, #43
 if_e	jmp	#LR__5006
	cmp	local03, #4 wz
 if_ne	jmp	#LR__5007
	getbyte	local04, local04, #0
	test	local04, #4 wz
 if_e	mov	local03, #5
' 					}
' 				}
' 				break;
	jmp	#LR__5007
LR__5006
	getbyte	local04, local04, #0
	test	local04, #4 wz
 if_ne	jmp	#LR__5007
	add	local01, #6
	rdbyte	local04, local01
	sub	local01, #6
	test	local04, #16 wz
 if_e	mov	local03, #5
' 				res = FR_NO_PATH; break;
 if_e	jmp	#LR__5007
	mov	arg01, local02
	mov	arg02, local02
	add	arg02, #52
	add	local01, #16
	rdlong	local04, local01
	and	local04, #511
	add	arg02, local04
	call	#_fatfs_cc_ld_clust
	sub	local01, #8
	wrlong	result1, local01
	sub	local01, #8
	jmp	#LR__5005
LR__5007
LR__5008
' 			}
' #line 3090 "ff.c"
' 			{
' 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr %  ((UINT) 512 ) );
' 			}
' 		}
' 	}
' 
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_follow_path_ret
	ret

_fatfs_cc_get_ldnumber
	neg	_var01, #1
	rdlong	_var02, arg01 wz
	mov	_var03, _var02
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_get_ldnumber_ret
	callpa	#(@LR__5011-@LR__5010)>>2,fcache_load_ptr_
' 	do tc = *tt++; while (! ((UINT)(tc) < ( 1 ? ' ' : '!'))  && tc != ':');
LR__5010
	rdbyte	_var04, _var03
	getbyte	result1, _var04, #0
	cmp	result1, #32 wc
	add	_var03, #1
 if_ae	mov	_var05, _var04
 if_ae	getbyte	_var05, _var05, #0
 if_ae	cmp	_var05, #58 wz
 if_a	jmp	#LR__5010
LR__5011
	getbyte	_var04, _var04, #0
	cmp	_var04, #58 wz
 if_ne	jmp	#LR__5013
	mov	_var06, #1
	rdbyte	_var05, _var02
	cmp	_var05, #48 wc
 if_b	jmp	#LR__5012
	rdbyte	_var05, _var02
	cmp	_var05, #58 wc
 if_b	mov	_var07, _var02
 if_b	add	_var07, #2
 if_b	cmp	_var07, _var03 wz
 if_c_and_z	mov	_var06, _var05
 if_c_and_z	sub	_var06, #48
LR__5012
	cmps	_var06, #1 wc
 if_b	mov	_var01, _var06
 if_b	wrlong	_var03, arg01
' 			vol = i;
' 			*path = tt;
' 		}
' 		return vol;
	mov	result1, _var01
	jmp	#_fatfs_cc_get_ldnumber_ret
LR__5013
' 	}
' #line 3170 "ff.c"
' 	vol = 0;
' 
' 	return vol;
	mov	result1, #0
_fatfs_cc_get_ldnumber_ret
	ret

_fatfs_cc_check_fs
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #45
	wrlong	##-1, local01
	sub	local01, #48
	mov	arg01, local01
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #4
 if_ne	jmp	#LR__5023
	add	local01, #52
	mov	arg01, local01
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	local02, arg01
	rdbyte	local03, local01
	sub	local01, #52
	getbyte	local04, local03, #0
	cmp	local04, #235 wz
 if_ne	mov	arg03, local03
 if_ne	getbyte	arg03, arg03, #0
 if_ne	cmp	arg03, #233 wz
 if_ne	getbyte	local03, local03, #0
 if_ne	cmp	local03, #232 wz
 if_ne	jmp	#LR__5022
	getword	local04, local02, #0
	cmp	local04, ##43605 wz
 if_ne	jmp	#LR__5020
	mov	arg01, local01
	add	arg01, #134
	mov	arg02, ##@LR__5485
	mov	arg03, #8
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
' 			return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__5023
LR__5020
	add	local01, #52
	mov	arg01, local01
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	local01, #13
	rdbyte	local03, local01
	sub	local01, #65
	getword	local04, result1, #0
	getword	arg02, result1, #0
	sub	arg02, #1
	test	local04, arg02 wz
 if_ne	jmp	#LR__5021
	getword	arg02, result1, #0
	cmp	arg02, ##512 wc
 if_b	jmp	#LR__5021
	getword	arg02, result1, #0
	cmp	arg02, ##513 wc
 if_ae	jmp	#LR__5021
	mov	arg01, local03
	zerox	arg01, #7 wz
 if_e	jmp	#LR__5021
	getbyte	arg01, local03, #0
	getbyte	local03, local03, #0
	sub	local03, #1
	test	arg01, local03 wz
 if_ne	jmp	#LR__5021
	mov	arg01, local01
	add	arg01, #66
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__5021
	add	local01, #68
	rdbyte	arg01, local01
	sub	local01, #68
	sub	arg01, #1
	cmp	arg01, #2 wc
 if_ae	jmp	#LR__5021
	mov	arg01, local01
	add	arg01, #69
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__5021
	mov	arg01, local01
	add	arg01, #71
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local03, result1, #0
	cmp	local03, #128 wc
 if_b	mov	arg01, local01
 if_b	add	arg01, #84
' {
' 
' 	return *((DWORD*)ptr);
 if_b	rdlong	result1, arg01
 if_b	cmp	result1, ##65536 wc
 if_ae	add	local01, #74
' {
' 
' 	return *((WORD*)ptr);
 if_ae	rdword	result1, local01 wz
' 			&& b != 0 && (b & (b - 1)) == 0
' 			&& ld_word(fs->win +  14 ) != 0
' 			&& (UINT)fs->win[ 16 ] - 1 <= 1
' 			&& ld_word(fs->win +  17 ) != 0
' 			&& (ld_word(fs->win +  19 ) >= 128 || ld_dword(fs->win +  32 ) >= 0x10000)
' 			&& ld_word(fs->win +  22 ) != 0) {
' 				return 0;
 if_a	mov	result1, #0
 if_a	jmp	#LR__5023
LR__5021
LR__5022
' 		}
' 	}
' 	return sign == 0xAA55 ? 2 : 3;
	getword	local03, local02, #0
	cmp	local03, ##43605 wz
 if_e	mov	local04, #2
 if_ne	mov	local04, #3
	mov	result1, local04
LR__5023
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_check_fs_ret
	ret

_fatfs_cc_find_volume
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #36
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_check_fs
	cmp	result1, #2 wz
 if_e	jmp	#LR__5030
	cmp	result1, #3 wc
 if_b	cmp	local02, #0 wz
 if_nc_or_z	jmp	#LR__5038
LR__5030
' 	for (i = 0; i < 4; i++) {
	mov	local03, #0
	callpa	#(@LR__5032-@LR__5031)>>2,fcache_load_ptr_
LR__5031
	cmp	local03, #4 wc
 if_ae	jmp	#LR__5033
	mov	local04, local03
	shl	local04, #2
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	mov	arg01, local01
	add	arg01, #498
	mov	arg02, local03
	shl	arg02, #4
	add	arg01, arg02
	add	arg01, #8
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	wrlong	result1, local04
	add	local03, #1
	jmp	#LR__5031
LR__5032
LR__5033
	cmp	local02, #0 wz
 if_ne	mov	local04, local02
 if_ne	sub	local04, #1
 if_e	mov	local04, #0
	mov	local03, local04
' 		mbr_pt[i] = ld_dword(fs->win +  446  + i *  16  +  8 );
' 	}
' 	i = part ? part - 1 : 0;
' 	do {
LR__5034
	mov	local04, local03
	shl	local04, #2
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	rdlong	local04, local04 wz
 if_e	jmp	#LR__5035
	mov	local04, local03
	shl	local04, #2
	mov	arg02, fp
	add	arg02, #20
	add	local04, arg02
	rdlong	arg02, local04
	mov	arg01, local01
	call	#_fatfs_cc_check_fs
	mov	local04, result1
	jmp	#LR__5036
LR__5035
	mov	local04, #3
LR__5036
	mov	local05, local04
	cmp	local02, #0 wz
 if_e	cmp	local05, #2 wc
 if_c_and_z	jmp	#LR__5037
 if_e	add	local03, #1
 if_e	cmp	local03, #4 wc
 if_c_and_z	jmp	#LR__5034
LR__5037
' 	return fmt;
	mov	result1, local05
LR__5038
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_find_volume_ret
	ret

_fatfs_cc_mount_volume
	mov	COUNT_, #10
	call	#pushregs_
	mov	local01, arg03
	wrlong	#0, arg02
	call	#_fatfs_cc_get_ldnumber
	mov	local02, result1
	cmps	local02, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__5049
	mov	arg03, local02
	shl	arg03, #2
	add	arg03, objptr
	rdlong	local03, arg03 wz
 if_e	mov	result1, #12
 if_e	jmp	#LR__5049
	wrlong	local03, arg02
	getbyte	local01, local01, #0
	and	local01, #254
	rdbyte	arg03, local03 wz
 if_e	jmp	#LR__5041
	add	objptr, ##528
	rdlong	arg01, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
'     }
'     return RES_OK;
 if_ne	mov	result1, #0
	getbyte	arg03, result1, #0
	test	arg03, #1 wz
 if_ne	jmp	#LR__5040
	cmp	local01, #0 wz
 if_ne	getbyte	result1, result1, #0
 if_ne	test	result1, #4 wz
' 				return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__5049
' 			}
' 			return FR_OK;
	mov	result1, #0
	jmp	#LR__5049
LR__5040
LR__5041
	wrbyte	#0, local03
	add	local03, #1
	wrbyte	local02, local03
	sub	local03, #1
	add	objptr, ##528
	rdlong	local02, objptr wz
	sub	objptr, ##528
' 
'         return RES_NOTRDY;
 if_e	mov	result1, #3
'     }
'     return RES_OK;
 if_ne	mov	result1, #0
	mov	arg03, result1
	getbyte	local04, arg03, #0
	test	local04, #1 wz
' 		return FR_NOT_READY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__5049
	cmp	local01, #0 wz
 if_ne	mov	local04, arg03
 if_ne	getbyte	local04, local04, #0
 if_ne	test	local04, #4 wz
' 		return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__5049
	mov	arg01, local03
	mov	arg02, #0
	call	#_fatfs_cc_find_volume
	mov	arg01, result1
	cmp	arg01, #4 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__5049
	cmp	arg01, #2 wc
 if_ae	mov	result1, #13
 if_ae	jmp	#LR__5049
	add	local03, #48
	rdlong	local05, local03
	add	local03, #4
	mov	arg01, local03
	sub	local03, #52
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	cmp	result1, ##512 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__5049
	mov	arg01, local03
	add	arg01, #74
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local06, result1 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #88
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	mov	local06, result1
	add	local03, #28
	wrlong	local06, local03
	add	local03, #40
	rdbyte	local04, local03
	sub	local03, #66
	wrbyte	local04, local03
	getbyte	local04, local04, #0
	sub	local03, #2
	cmp	local04, #1 wz
 if_ne	add	local03, #2
 if_ne	rdbyte	local04, local03
 if_ne	sub	local03, #2
 if_ne	cmp	local04, #2 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__5049
	add	local03, #2
	rdbyte	local04, local03
	qmul	local06, local04
	add	local03, #63
	rdbyte	local04, local03
	sub	local03, #55
	wrword	local04, local03
	getword	local04, local04, #0
	sub	local03, #10
	zerox	local04, #15 wz
	getqx	local06
 if_e	jmp	#LR__5042
	add	local03, #10
	rdword	local04, local03
	getword	local02, local04, #0
	sub	local03, #10
	getword	local04, local04, #0
	sub	local04, #1
	test	local02, local04 wz
 if_e	jmp	#LR__5043
LR__5042
	mov	result1, #13
	jmp	#LR__5049
LR__5043
	add	local03, #52
	mov	arg01, local03
	add	arg01, #17
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	local03, #44
	wrword	result1, local03
	getword	local04, result1, #0
	sub	local03, #8
	abs	arg01, local04 wc
	getnib	arg01, arg01, #0
	negc	arg01, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__5049
	mov	arg01, local03
	add	arg01, #71
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local07, result1 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #84
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	local07, arg01
	mov	arg01, local03
	add	arg01, #66
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	arg01, result1
	mov	local04, arg01
	zerox	local04, #15 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__5049
	getword	local08, arg01, #0
	add	local08, local06
	add	local03, #8
	rdword	local04, local03
	sub	local03, #8
	abs	local04, local04 wc
	shr	local04, #4
	sumc	local08, local04
	cmp	local07, local08 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__5049
	sub	local07, local08
	add	local03, #10
	rdword	local04, local03
	qdiv	local07, local04
	sub	local03, #10
	getqx	local04
	cmp	local04, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__5049
	mov	local09, #0
	cmp	local04, ##268435446 wc
 if_b	mov	local09, #3
	cmp	local04, ##65526 wc
 if_b	mov	local09, #2
	cmp	local04, ##4086 wc
 if_b	mov	local09, #1
	cmp	local09, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__5049
	add	local04, #2
	add	local03, #24
	wrlong	local04, local03
	add	local03, #8
	wrlong	local05, local03
	mov	local04, local05
	getword	arg01, arg01, #0
	add	local04, arg01
	add	local03, #4
	wrlong	local04, local03
	mov	local04, local05
	add	local04, local08
	add	local03, #8
	wrlong	local04, local03
	sub	local03, #44
	cmp	local09, #3 wz
 if_ne	jmp	#LR__5044
	mov	arg01, local03
	add	arg01, #94
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__5049
	add	local03, #8
	rdword	local04, local03 wz
	sub	local03, #8
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__5049
	add	local03, #52
	mov	arg01, local03
	add	arg01, #44
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local03, #12
	wrlong	result1, local03
	sub	local03, #16
	rdlong	local10, local03
	sub	local03, #24
	shl	local10, #2
	jmp	#LR__5046
LR__5044
	add	local03, #8
	rdword	local04, local03 wz
	sub	local03, #8
 if_e	mov	result1, #13
 if_e	jmp	#LR__5049
	add	local03, #36
	rdlong	local04, local03
	add	local04, local06
	add	local03, #4
	wrlong	local04, local03
	sub	local03, #40
	cmp	local09, #2 wz
 if_e	add	local03, #24
 if_e	rdlong	local04, local03
 if_e	sub	local03, #24
 if_e	shl	local04, #1
 if_e	jmp	#LR__5045
	add	local03, #24
	rdlong	local10, local03
	mov	local04, local10
	shl	local04, #1
	add	local04, local10
	shr	local04, #1
	sub	local03, #24
	and	local10, #1
	add	local04, local10
LR__5045
	mov	local10, local04
LR__5046
	add	local10, #511
	shr	local10, #9
	add	local03, #28
	rdlong	arg03, local03
	sub	local03, #28
	cmp	arg03, local10 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__5049
	add	local03, #20
	wrlong	##-1, local03
	sub	local03, #4
	wrlong	##-1, local03
	sub	local03, #12
	wrbyte	#128, local03
	sub	local03, #4
	cmp	local09, #3 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #100
' {
' 
' 	return *((WORD*)ptr);
 if_e	rdword	result1, arg01
 if_e	getword	local04, result1, #0
 if_e	cmp	local04, #1 wz
 if_ne	jmp	#LR__5048
	add	local05, #1
	mov	arg01, local03
	mov	arg02, local05
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__5048
	add	local03, #4
	wrbyte	#0, local03
	add	local03, #48
	mov	arg01, local03
	sub	local03, #52
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local04, result1, #0
	cmp	local04, ##43605 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, #52
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	cmp	result1, ##1096897106 wz
 if_e	mov	arg01, local03
 if_e	add	arg01, ##536
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	cmp	result1, ##1631679090 wz
 if_ne	jmp	#LR__5047
	add	local03, #52
	mov	arg01, local03
	add	arg01, #488
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local03, #32
	wrlong	result1, local03
	add	local03, #32
	mov	arg01, local03
	add	arg01, #492
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local03, #36
	wrlong	result1, local03
	sub	local03, #16
LR__5047
LR__5048
	wrbyte	local09, local03
	add	objptr, #4
	rdword	local04, objptr
	add	local04, #1
	wrword	local04, objptr
	getword	local10, local04, #0
	add	local03, #6
	wrword	local10, local03
	add	objptr, #4
	add	local03, #6
	wrlong	objptr, local03
' 				&& ld_dword(fs->win +  0 ) == 0x41615252
' 				&& ld_dword(fs->win +  484 ) == 0x61417272)
' 			{
' 
' 				fs->free_clst = ld_dword(fs->win +  488 );
' 
' 
' 				fs->last_clst = ld_dword(fs->win +  492 );
' 
' 			}
' 		}
' 
' 
' 	}
' 
' 	fs->fs_type = (BYTE)fmt;
' 	fs->id = ++Fsid;
' 
' 	fs->lfnbuf = LfnBuf;
' #line 3567 "ff.c"
' 	return FR_OK;
	mov	result1, #0
	sub	objptr, #8
LR__5049
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mount_volume_ret
	ret

_fatfs_cc_validate
	mov	_var01, arg01 wz
	mov	_var02, #9
 if_ne	rdlong	_var03, _var01 wz
 if_ne	rdbyte	_var04, _var03 wz
 if_e	jmp	#LR__5050
	add	_var01, #4
	rdword	_var04, _var01
	sub	_var01, #4
	rdlong	arg01, _var01
	add	arg01, #6
	rdword	result1, arg01
	cmp	_var04, result1 wz
 if_ne	jmp	#LR__5050
	add	objptr, ##528
	rdlong	_var04, objptr wz
	sub	objptr, ##528
'         return RES_NOTRDY;
 if_e	mov	result1, #3
'     }
'     return RES_OK;
 if_ne	mov	result1, #0
	getbyte	_var03, result1, #0
	test	_var03, #1 wz
 if_e	mov	_var02, #0
LR__5050
	cmp	_var02, #0 wz
 if_e	rdlong	_var03, _var01
 if_ne	mov	_var03, #0
	wrlong	_var03, arg02
' 			res = FR_OK;
' 		}
' 
' 	}
' 	*rfs = (res == FR_OK) ? obj->fs : 0;
' 	return res;
	mov	result1, _var02
_fatfs_cc_validate_ret
	ret

_fatfs_cc_f_mount
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #32
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	local01, arg03
	add	fp, #20
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #28
	call	#_fatfs_cc_get_ldnumber
	mov	local02, result1
	cmps	local02, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__5061
	mov	arg03, local02
	shl	arg03, #2
	add	arg03, objptr
	rdlong	local03, arg03 wz
 if_e	jmp	#LR__5060
	add	local03, #1
	rdbyte	arg01, local03
	sub	local03, #1
	call	#_fatfs_cc_disk_deinitialize
	wrbyte	#0, local03
LR__5060
	add	fp, #4
	rdlong	local04, fp wz
	sub	fp, #4
 if_ne	add	fp, #4
 if_ne	rdlong	local04, fp
 if_ne	sub	fp, #4
 if_ne	wrbyte	#0, local04
	shl	local02, #2
	add	local02, objptr
	add	fp, #4
	rdlong	local04, fp
	sub	fp, #4
	wrlong	local04, local02
	zerox	local01, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__5061
	add	fp, #8
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, fp
	sub	fp, #4
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
' 
' 	res = mount_volume(&path, &fs, 0);
' 	return res ;
LR__5061
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mount_ret
	ret

_fatfs_cc_f_open
	mov	COUNT_, #8
	call	#pushregs_
	add	ptra, #96
	mov	local01, arg01 wz
	add	fp, #8
	wrlong	arg02, fp
	sub	fp, #8
	mov	local02, arg03
 if_e	mov	result1, #9
 if_e	jmp	#LR__5087
	getbyte	local02, local02, #0
	and	local02, #63
	add	fp, #8
	mov	arg01, fp
	add	fp, #60
	mov	arg02, fp
	sub	fp, #68
	mov	arg03, local02
	call	#_fatfs_cc_mount_volume
	mov	local03, result1 wz
 if_ne	jmp	#LR__5086
	add	fp, #68
	rdlong	local03, fp
	sub	fp, #48
	wrlong	local03, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	local04, fp
	sub	fp, #8
	mov	arg02, local04
	call	#_fatfs_cc_follow_path
	mov	local03, result1 wz
 if_ne	jmp	#LR__5070
	add	fp, #63
	rdbyte	local04, fp
	sub	fp, #63
	getbyte	arg04, local04, #0
	test	arg04, #128 wz
 if_ne	mov	local03, #6
LR__5070
	getbyte	arg04, local02, #0
	test	arg04, #28 wz
 if_e	jmp	#LR__5075
	cmp	local03, #0 wz
 if_e	jmp	#LR__5072
	cmp	local03, #4 wz
 if_ne	jmp	#LR__5071
	mov	arg01, fp
	add	arg01, #20
	call	#_fatfs_cc_dir_register
	mov	local03, result1
LR__5071
	getbyte	local02, local02, #0
	or	local02, #8
	jmp	#LR__5074
LR__5072
	add	fp, #26
	rdbyte	local04, fp
	sub	fp, #26
	test	local04, #17 wz
 if_ne	mov	local03, #7
 if_ne	jmp	#LR__5073
	getbyte	local04, local02, #0
	test	local04, #4 wz
 if_ne	mov	local03, #8
LR__5073
LR__5074
	cmp	local03, #0 wz
 if_ne	jmp	#LR__5078
	getbyte	local04, local02, #0
	test	local04, #8 wz
 if_e	jmp	#LR__5078
	call	#_fatfs_cc__get_fattime
	add	fp, #48
	rdlong	arg01, fp
	add	arg01, #14
	wrlong	result1, arg01
	rdlong	arg01, fp
	add	arg01, #22
	wrlong	result1, arg01
	add	fp, #20
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	mov	local04, result1
	add	fp, #48
	rdlong	arg04, fp
	add	arg04, #11
	wrbyte	#32, arg04
	add	fp, #20
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	mov	arg03, #0
	call	#_fatfs_cc_st_clust
	add	fp, #48
	rdlong	arg01, fp
	add	arg01, #28
	wrlong	#0, arg01
	add	fp, #20
	rdlong	arg04, fp
	sub	fp, #68
	add	arg04, #3
	wrbyte	#1, arg04
	cmp	local04, #0 wz
 if_e	jmp	#LR__5078
	add	fp, #68
	rdlong	local03, fp
	add	local03, #48
	rdlong	local05, local03
	sub	fp, #48
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, local04
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	mov	local03, result1 wz
 if_ne	jmp	#LR__5078
	add	fp, #68
	rdlong	arg01, fp
	sub	fp, #68
	mov	arg02, local05
	call	#_fatfs_cc_move_window
	mov	local03, result1
	add	fp, #68
	rdlong	local05, fp
	sub	fp, #68
	sub	local04, #1
	add	local05, #16
	wrlong	local04, local05
	jmp	#LR__5078
LR__5075
	cmp	local03, #0 wz
 if_ne	jmp	#LR__5077
	add	fp, #26
	rdbyte	local05, fp
	sub	fp, #26
	test	local05, #16 wz
 if_ne	mov	local03, #4
 if_ne	jmp	#LR__5076
	getbyte	local05, local02, #0
	test	local05, #2 wz
 if_ne	add	fp, #26
 if_ne	rdbyte	local04, fp
 if_ne	sub	fp, #26
 if_ne	test	local04, #1 wz
 if_ne	mov	local03, #7
LR__5076
LR__5077
LR__5078
	cmp	local03, #0 wz
 if_ne	jmp	#LR__5079
	getbyte	local05, local02, #0
	test	local05, #8 wz
 if_ne	getbyte	local02, local02, #0
 if_ne	or	local02, #64
	add	fp, #68
	rdlong	local05, fp
	add	local05, #48
	rdlong	local05, local05
	add	local01, #32
	wrlong	local05, local01
	sub	fp, #20
	rdlong	local05, fp
	sub	fp, #48
	add	local01, #4
	wrlong	local05, local01
	sub	local01, #36
LR__5079
	cmp	local03, #0 wz
 if_ne	jmp	#LR__5085
	add	fp, #68
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	add	local01, #8
	wrlong	result1, local01
	add	fp, #48
	rdlong	arg01, fp
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	add	local01, #4
	wrlong	result1, local01
	sub	local01, #12
	add	fp, #20
	rdlong	local05, fp
	wrlong	local05, local01
	rdlong	local05, fp
	sub	fp, #68
	add	local05, #6
	rdword	local04, local05
	add	local01, #4
	wrword	local04, local01
	add	local01, #12
	wrbyte	local02, local01
	add	local01, #1
	wrbyte	#0, local01
	add	local01, #11
	wrlong	#0, local01
	sub	local01, #8
	wrlong	#0, local01
	add	local01, #20
	mov	arg01, local01
	sub	local01, #40
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	getbyte	local02, local02, #0
	test	local02, #32 wz
 if_e	jmp	#LR__5084
	add	local01, #12
	rdlong	local04, local01
	sub	local01, #12
	cmp	local04, #1 wc
 if_b	jmp	#LR__5084
	add	local01, #12
	rdlong	local04, local01
	add	local01, #8
	wrlong	local04, local01
	add	fp, #68
	rdlong	local04, fp
	sub	fp, #68
	add	local04, #10
	rdword	local06, local04
	shl	local06, #9
	sub	local01, #12
	rdlong	local07, local01
' 				fp->fptr = fp->obj.objsize;
' 				bcs = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 				clst = fp->obj.sclust;
' 				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
	add	local01, #4
	rdlong	local08, local01
	sub	local01, #12
LR__5080
	cmp	local03, #0 wz
 if_ne	jmp	#LR__5081
	cmp	local08, local06 wcz
 if_be	jmp	#LR__5081
	mov	arg01, local01
	mov	arg02, local07
	call	#_fatfs_cc_get_fat
	mov	local07, result1
	cmp	local07, #2 wc
 if_b	mov	local03, #2
	cmp	local07, ##-1 wz
 if_e	mov	local03, #1
	sub	local08, local06
	jmp	#LR__5080
LR__5081
	add	local01, #24
	wrlong	local07, local01
	sub	local01, #24
	cmp	local03, #0 wz
 if_ne	jmp	#LR__5083
	test	local08, #511 wz
 if_e	jmp	#LR__5083
	add	fp, #68
	rdlong	arg01, fp
	sub	fp, #68
	mov	arg02, local07
	call	#_fatfs_cc_clst2sect
	mov	local05, result1 wz
 if_e	mov	local03, #2
 if_e	jmp	#LR__5082
	shr	local08, #9
	add	local05, local08
	add	local01, #28
	wrlong	local05, local01
	add	fp, #68
	rdlong	local04, fp
	sub	fp, #68
	add	local04, #1
	rdbyte	arg01, local04
	mov	arg02, local01
	add	arg02, #12
	mov	arg03, local05
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	mov	local03, #1
LR__5082
LR__5083
LR__5084
LR__5085
LR__5086
	cmp	local03, #0 wz
 if_ne	wrlong	#0, local01
' 
' 	return res ;
	mov	result1, local03
LR__5087
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_open_ret
	ret

_fatfs_cc_f_read
	mov	COUNT_, #14
	call	#pushregs_
	add	ptra, #56
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, local02
	wrlong	#0, local04
	mov	arg02, fp
	add	arg02, #24
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local06, result1 wz
 if_e	add	local01, #17
 if_e	rdbyte	local06, local01
 if_e	sub	local01, #17
 if_e	cmps	local06, #0 wz
 if_ne	mov	result1, local06
 if_ne	jmp	#LR__5101
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__5101
	add	local01, #12
	rdlong	local08, local01
	add	local01, #8
	rdlong	local09, local01
	sub	local01, #20
	sub	local08, local09
	fle	local03, local08 wcz
' 
' 	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
LR__5090
	cmp	local03, #1 wc
 if_b	jmp	#LR__5100
	add	local01, #20
	rdlong	local07, local01
	sub	local01, #20
	test	local07, #511 wz
 if_ne	jmp	#LR__5098
	add	local01, #20
	rdlong	local10, local01
	sub	local01, #20
	shr	local10, #9
	add	fp, #24
	rdlong	local07, fp
	sub	fp, #24
	add	local07, #10
	rdword	local07, local07
	sub	local07, #1
	and	local10, local07 wz
 if_ne	jmp	#LR__5092
	add	local01, #20
	rdlong	local07, local01 wz
	sub	local01, #20
 if_e	add	local01, #8
 if_e	rdlong	local11, local01
 if_e	sub	local01, #8
 if_e	jmp	#LR__5091
	mov	arg01, local01
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	call	#_fatfs_cc_get_fat
	mov	local11, result1
LR__5091
	cmp	local11, #2 wc
 if_b	add	local01, #17
 if_b	wrbyte	#2, local01
 if_b	mov	result1, #2
 if_b	jmp	#LR__5101
	cmp	local11, ##-1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#1, local01
 if_e	mov	result1, #1
 if_e	jmp	#LR__5101
	add	local01, #24
	wrlong	local11, local01
	sub	local01, #24
LR__5092
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #24
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	call	#_fatfs_cc_clst2sect
	mov	local12, result1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__5101
	add	local12, local10
	mov	local13, local03
	shr	local13, #9
	cmp	local13, #1 wc
 if_b	jmp	#LR__5095
	mov	local07, local10
	add	local07, local13
	add	fp, #24
	rdlong	local09, fp
	sub	fp, #24
	add	local09, #10
	rdword	result1, local09
	cmp	local07, result1 wcz
 if_be	jmp	#LR__5093
	add	fp, #24
	rdlong	local13, fp
	sub	fp, #24
	add	local13, #10
	rdword	local13, local13
	sub	local13, local10
LR__5093
	add	fp, #24
	rdlong	local07, fp
	sub	fp, #24
	add	local07, #1
	rdbyte	arg01, local07
	mov	arg02, local05
	mov	arg04, local13
	mov	arg03, local12
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5101
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #128 wz
 if_e	jmp	#LR__5094
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	sub	local09, local12
	cmp	local09, local13 wc
 if_ae	jmp	#LR__5094
	mov	arg01, local05
	add	local01, #28
	rdlong	local10, local01
	sub	local10, local12
	shl	local10, #9
	add	arg01, local10
	add	local01, #12
	mov	arg02, local01
	sub	local01, #40
	decod	arg03, #9
	call	#__system____builtin_memmove
LR__5094
	shl	local13, #9
	mov	local14, local13
' 					__builtin_memcpy(rbuff + ((fp->sect - sect) * ((UINT) 512 ) ), fp->buf, ((UINT) 512 ) ) ;
' 				}
' 
' 
' 				rcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__5099
LR__5095
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	cmp	local07, local12 wz
 if_e	jmp	#LR__5097
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #128 wz
 if_e	jmp	#LR__5096
	add	fp, #24
	rdlong	local14, fp
	sub	fp, #24
	add	local14, #1
	rdbyte	arg01, local14
	add	local01, #40
	mov	arg02, local01
	sub	local01, #12
	rdlong	arg03, local01
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5101
	add	local01, #16
	rdbyte	local07, local01
	and	local07, #127
	wrbyte	local07, local01
	sub	local01, #16
LR__5096
	add	fp, #24
	rdlong	local14, fp
	sub	fp, #24
	add	local14, #1
	rdbyte	arg01, local14
	mov	arg02, local01
	add	arg02, #40
	mov	arg03, local12
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5101
LR__5097
	add	local01, #28
	wrlong	local12, local01
	sub	local01, #28
LR__5098
	add	local01, #20
	rdlong	local13, local01
	and	local13, #511
	decod	local14, #9
	sub	local14, local13
	fle	local14, local03 wcz
	mov	arg02, local01
	add	arg02, #20
	rdlong	local13, local01
	sub	local01, #20
	and	local13, #511
	add	arg02, local13
	mov	arg01, local05
	mov	arg03, local14
	call	#__system____builtin_memmove
LR__5099
	sub	local03, local14
	rdlong	local07, local04
	add	local07, local14
	wrlong	local07, local04
	add	local05, local14
	add	local01, #20
	rdlong	local07, local01
	add	local07, local14
	wrlong	local07, local01
	sub	local01, #20
	jmp	#LR__5090
LR__5100
' 
' 
' 
' 
' 		__builtin_memcpy(rbuff, fp->buf + fp->fptr % ((UINT) 512 ) , rcnt) ;
' 
' 	}
' 
' 	return FR_OK ;
	mov	result1, #0
LR__5101
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_read_ret
	ret

_fatfs_cc_f_write
	mov	COUNT_, #18
	call	#pushregs_
	add	ptra, #52
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, local02
	wrlong	#0, local04
	mov	arg02, fp
	add	arg02, #24
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local06, result1 wz
 if_e	add	local01, #17
 if_e	rdbyte	local06, local01
 if_e	sub	local01, #17
 if_e	cmps	local06, #0 wz
 if_ne	mov	result1, local06
 if_ne	jmp	#LR__5122
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #2 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__5122
	add	local01, #20
	rdlong	local08, local01
	mov	local09, local08
	add	local09, local03
	sub	local01, #20
	cmp	local09, local08 wc
 if_b	neg	local03, #1
 if_b	add	local01, #20
 if_b	rdlong	local10, local01
 if_b	sub	local01, #20
 if_b	sub	local03, local10
' 		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
' 	}
' 
' 	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
LR__5110
	cmp	local03, #1 wc
 if_b	jmp	#LR__5121
	add	local01, #20
	rdlong	local07, local01
	sub	local01, #20
	test	local07, #511 wz
 if_ne	jmp	#LR__5119
	add	local01, #20
	rdlong	local11, local01
	sub	local01, #20
	shr	local11, #9
	add	fp, #24
	rdlong	local08, fp
	sub	fp, #24
	mov	local12, local08
	add	local12, #10
	rdword	local13, local12
	sub	local12, #10
	getword	local09, local13, #0
	sub	local09, #1
	and	local11, local09 wz
 if_ne	jmp	#LR__5113
	add	local01, #20
	rdlong	local07, local01 wz
	sub	local01, #20
 if_ne	jmp	#LR__5111
	add	local01, #8
	rdlong	local14, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__5112
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	mov	local14, result1
	jmp	#LR__5112
LR__5111
	mov	arg01, local01
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	call	#_fatfs_cc_create_chain
	mov	local14, result1
LR__5112
	cmp	local14, #0 wz
 if_e	jmp	#LR__5121
	cmp	local14, #1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__5122
	cmp	local14, ##-1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#1, local01
 if_e	mov	result1, #1
 if_e	jmp	#LR__5122
	add	local01, #24
	wrlong	local14, local01
	sub	local01, #16
	rdlong	local07, local01 wz
	sub	local01, #8
 if_e	add	local01, #8
 if_e	wrlong	local14, local01
 if_e	sub	local01, #8
LR__5113
	add	local01, #16
	rdbyte	local07, local01
	sub	local01, #16
	test	local07, #128 wz
 if_e	jmp	#LR__5114
	add	fp, #24
	rdlong	local10, fp
	sub	fp, #24
	add	local10, #1
	rdbyte	arg01, local10
	add	local01, #40
	mov	arg02, local01
	sub	local01, #12
	rdlong	arg03, local01
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5122
	add	local01, #16
	rdbyte	local07, local01
	and	local07, #127
	wrbyte	local07, local01
	sub	local01, #16
LR__5114
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #24
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	call	#_fatfs_cc_clst2sect
	mov	local15, result1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__5122
	add	local15, local11
	mov	local16, local03
	shr	local16, #9
	cmp	local16, #1 wc
 if_b	jmp	#LR__5117
	mov	local07, local11
	add	local07, local16
	add	fp, #24
	rdlong	local17, fp
	sub	fp, #24
	add	local17, #10
	rdword	local10, local17
	cmp	local07, local10 wcz
 if_be	jmp	#LR__5115
	add	fp, #24
	rdlong	local10, fp
	sub	fp, #24
	add	local10, #10
	rdword	local16, local10
	sub	local16, local11
LR__5115
	add	fp, #24
	rdlong	local10, fp
	sub	fp, #24
	add	local10, #1
	rdbyte	arg01, local10
	mov	arg02, local05
	mov	arg03, local15
	mov	arg04, local16
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5122
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	sub	local07, local15
	cmp	local07, local16 wc
 if_ae	jmp	#LR__5116
	add	local01, #40
	mov	arg01, local01
	mov	arg02, local05
	sub	local01, #12
	rdlong	local13, local01
	sub	local13, local15
	shl	local13, #9
	add	arg02, local13
	decod	arg03, #9
	call	#__system____builtin_memmove
	sub	local01, #12
	rdbyte	local07, local01
	and	local07, #127
	wrbyte	local07, local01
	sub	local01, #16
LR__5116
	mov	local18, local16
	shl	local18, #9
' 					__builtin_memcpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT) 512 ) ), ((UINT) 512 ) ) ;
' 					fp->flag &= (BYTE)~ 0x80 ;
' 				}
' 
' 
' 				wcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__5120
LR__5117
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	cmp	local07, local15 wz
 if_e	jmp	#LR__5118
	add	local01, #20
	rdlong	local17, local01
	sub	local01, #8
	rdlong	local12, local01
	sub	local01, #12
	cmp	local17, local12 wc
 if_ae	jmp	#LR__5118
	add	fp, #24
	rdlong	local18, fp
	sub	fp, #24
	add	local18, #1
	rdbyte	arg01, local18
	mov	arg02, local01
	add	arg02, #40
	mov	arg03, local15
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
' 				fp->fptr < fp->obj.objsize &&
' 				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
' 					{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR ; } ;
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5122
LR__5118
	add	local01, #28
	wrlong	local15, local01
	sub	local01, #28
LR__5119
	add	local01, #20
	rdlong	local10, local01
	and	local10, #511
	decod	local18, #9
	sub	local18, local10
	fle	local18, local03 wcz
	mov	arg01, local01
	add	arg01, #20
	rdlong	local13, local01
	and	local13, #511
	add	arg01, local13
	mov	arg02, local05
	mov	arg03, local18
	call	#__system____builtin_memmove
	sub	local01, #4
	rdbyte	local07, local01
	or	local07, #128
	wrbyte	local07, local01
	sub	local01, #16
LR__5120
	sub	local03, local18
	rdlong	local07, local04
	add	local07, local18
	wrlong	local07, local04
	add	local05, local18
	add	local01, #20
	rdlong	local10, local01
	add	local10, local18
	wrlong	local10, local01
	sub	local01, #8
	rdlong	local09, local01
	sub	local01, #12
	cmp	local10, local09 wcz
 if_a	add	local01, #20
 if_a	rdlong	local07, local01
 if_a	sub	local01, #20
 if_be	add	local01, #12
 if_be	rdlong	local07, local01
 if_be	sub	local01, #12
	add	local01, #12
	wrlong	local07, local01
	sub	local01, #12
	jmp	#LR__5110
LR__5121
	add	local01, #16
	rdbyte	local07, local01
	or	local07, #64
	wrbyte	local07, local01
' 
' 
' 
' 
' 
' 		__builtin_memcpy(fp->buf + fp->fptr % ((UINT) 512 ) , wbuff, wcnt) ;
' 		fp->flag |=  0x80 ;
' 
' 	}
' 
' 	fp->flag |=  0x40 ;
' 
' 	return FR_OK ;
	mov	result1, #0
LR__5122
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_write_ret
	ret

_fatfs_cc_f_sync
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	mov	local01, arg01
	mov	arg02, fp
	add	arg02, #12
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local02, result1 wz
 if_ne	jmp	#LR__5133
	add	local01, #16
	rdbyte	arg04, local01
	sub	local01, #16
	test	arg04, #64 wz
 if_e	jmp	#LR__5132
	add	local01, #16
	rdbyte	local02, local01
	sub	local01, #16
	test	local02, #128 wz
 if_e	jmp	#LR__5130
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local02, #1
	rdbyte	arg01, local02
	add	local01, #40
	mov	arg02, local01
	sub	local01, #12
	rdlong	arg03, local01
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5134
	add	local01, #16
	rdbyte	local02, local01
	and	local02, #127
	wrbyte	local02, local01
	sub	local01, #16
LR__5130
	call	#_fatfs_cc__get_fattime
	mov	local03, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	add	local01, #32
	rdlong	arg02, local01
	sub	local01, #32
	call	#_fatfs_cc_move_window
	mov	local02, result1 wz
 if_ne	jmp	#LR__5131
	add	local01, #36
	rdlong	local02, local01
	sub	local01, #36
	add	local02, #11
	rdbyte	arg04, local02
	or	arg04, #32
	wrbyte	arg04, local02
	sub	local02, #11
	rdlong	arg01, local01
	add	local01, #8
	rdlong	arg03, local01
	mov	arg02, local02
	call	#_fatfs_cc_st_clust
	mov	arg01, local02
	add	arg01, #28
	add	local01, #4
	rdlong	arg02, local01
	wrlong	arg02, arg01
	mov	arg01, local02
	add	arg01, #22
	wrlong	local03, arg01
	add	local02, #18
	wrword	#0, local02
	add	fp, #12
	rdlong	local03, fp
	add	local03, #3
	wrbyte	#1, local03
	rdlong	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc_sync_fs
	mov	local02, result1
	add	local01, #4
	rdbyte	local03, local01
	and	local03, #191
	wrbyte	local03, local01
LR__5131
LR__5132
LR__5133
' 					dir = fp->dir_ptr;
' 					dir[ 11 ] |=  0x20 ;
' 					st_clust(fp->obj.fs, dir, fp->obj.sclust);
' 					st_dword(dir +  28 , (DWORD)fp->obj.objsize);
' 					st_dword(dir +  22 , tm);
' 					st_word(dir +  18 , 0);
' 					fs->wflag = 1;
' 					res = sync_fs(fs);
' 					fp->flag &= (BYTE)~ 0x40 ;
' 				}
' 			}
' 		}
' 	}
' 
' 	return res ;
	mov	result1, local02
LR__5134
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_sync_ret
	ret

_fatfs_cc_f_close
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #16
	mov	local01, arg01
	call	#_fatfs_cc_f_sync
	mov	local02, result1 wz
 if_ne	jmp	#LR__5140
	mov	arg02, fp
	add	arg02, #12
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local02, result1 wz
 if_e	wrlong	#0, local01
LR__5140
' 
' 
' 
' 
' 			fp->obj.fs = 0;
' #line 4192 "ff.c"
' 		}
' 	}
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_close_ret
	ret

_fatfs_cc_f_lseek
	mov	COUNT_, #13
	call	#pushregs_
	add	ptra, #36
	mov	local01, arg01
	mov	local02, arg02
	mov	arg02, fp
	add	arg02, #16
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local03, result1 wz
 if_e	add	local01, #17
 if_e	rdbyte	local03, local01
 if_e	sub	local01, #17
	cmp	local03, #0 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__5166
	add	local01, #12
	rdlong	local04, local01
	sub	local01, #12
	cmp	local02, local04 wcz
 if_be	jmp	#LR__5150
	add	local01, #16
	rdbyte	local05, local01
	sub	local01, #16
	getbyte	local06, local05, #0
	test	local06, #2 wz
 if_e	add	local01, #12
 if_e	rdlong	local02, local01
 if_e	sub	local01, #12
LR__5150
	add	local01, #20
	rdlong	local07, local01
	mov	local08, #0
	wrlong	#0, local01
	sub	local01, #20
	cmp	local02, #1 wc
 if_b	jmp	#LR__5162
	add	fp, #16
	rdlong	local09, fp
	sub	fp, #16
	add	local09, #10
	rdword	local05, local09
	getword	local10, local05, #0
	shl	local10, #9
	mov	local11, local10
	cmp	local07, #1 wc
 if_b	jmp	#LR__5151
	mov	local09, local02
	sub	local09, #1
	qdiv	local09, local11
	mov	local05, local07
	sub	local05, #1
	mov	local12, local11
	getqx	local09
	qdiv	local05, local12
	getqx	local10
	cmp	local09, local10 wc
 if_b	jmp	#LR__5151
	mov	local06, local07
	sub	local06, #1
	mov	local09, local11
	sub	local09, #1
	andn	local06, local09
	add	local01, #20
	wrlong	local06, local01
	sub	local02, local06
	add	local01, #4
	rdlong	local13, local01
	sub	local01, #24
	jmp	#LR__5153
LR__5151
	add	local01, #8
	rdlong	local13, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__5152
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	mov	local13, result1
	cmp	local13, #1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__5166
	cmp	local13, ##-1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#1, local01
 if_e	mov	result1, #1
 if_e	jmp	#LR__5166
	add	local01, #8
	wrlong	local13, local01
	sub	local01, #8
LR__5152
	add	local01, #24
	wrlong	local13, local01
	sub	local01, #24
LR__5153
	cmp	local13, #0 wz
 if_e	jmp	#LR__5161
' 				while (ofs > bcs) {
LR__5154
	cmp	local02, local11 wcz
 if_be	jmp	#LR__5159
	sub	local02, local11
	add	local01, #20
	rdlong	local04, local01
	add	local04, local11
	wrlong	local04, local01
	sub	local01, #4
	rdbyte	local04, local01
	sub	local01, #16
	test	local04, #2 wz
 if_e	jmp	#LR__5155
	mov	arg01, local01
	mov	arg02, local13
	call	#_fatfs_cc_create_chain
	mov	local13, result1 wz
 if_e	mov	local02, #0
' 							ofs = 0; break;
 if_e	jmp	#LR__5159
	jmp	#LR__5156
LR__5155
	mov	arg01, local01
	mov	arg02, local13
	call	#_fatfs_cc_get_fat
	mov	local13, result1
LR__5156
	cmp	local13, ##-1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#1, local01
 if_e	mov	result1, #1
 if_e	jmp	#LR__5166
	cmp	local13, #2 wc
 if_b	jmp	#LR__5157
	add	fp, #16
	rdlong	local04, fp
	sub	fp, #16
	add	local04, #24
	rdlong	local05, local04
	cmp	local13, local05 wc
 if_b	jmp	#LR__5158
LR__5157
	add	local01, #17
	wrbyte	#2, local01
	mov	result1, #2
	jmp	#LR__5166
LR__5158
	add	local01, #24
	wrlong	local13, local01
	sub	local01, #24
	jmp	#LR__5154
LR__5159
	add	local01, #20
	rdlong	local04, local01
	add	local04, local02
	wrlong	local04, local01
	sub	local01, #20
	test	local02, #511 wz
 if_e	jmp	#LR__5160
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	mov	arg02, local13
	call	#_fatfs_cc_clst2sect
	mov	local08, result1 wz
 if_e	add	local01, #17
 if_e	wrbyte	#2, local01
 if_e	mov	result1, #2
 if_e	jmp	#LR__5166
	shr	local02, #9
	add	local08, local02
LR__5160
LR__5161
LR__5162
	add	local01, #20
	rdlong	local04, local01
	sub	local01, #8
	rdlong	local06, local01
	sub	local01, #12
	cmp	local04, local06 wcz
 if_be	jmp	#LR__5163
	add	local01, #20
	rdlong	local04, local01
	sub	local01, #8
	wrlong	local04, local01
	add	local01, #4
	rdbyte	local04, local01
	or	local04, #64
	wrbyte	local04, local01
	sub	local01, #16
LR__5163
	add	local01, #20
	rdlong	local04, local01
	sub	local01, #20
	test	local04, #511 wz
 if_ne	add	local01, #28
 if_ne	rdlong	local05, local01
 if_ne	sub	local01, #28
 if_ne	cmp	local08, local05 wz
 if_e	jmp	#LR__5165
	add	local01, #16
	rdbyte	local04, local01
	sub	local01, #16
	test	local04, #128 wz
 if_e	jmp	#LR__5164
	add	fp, #16
	rdlong	local09, fp
	sub	fp, #16
	add	local09, #1
	rdbyte	arg01, local09
	add	local01, #40
	mov	arg02, local01
	sub	local01, #12
	rdlong	arg03, local01
	sub	local01, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5166
	add	local01, #16
	rdbyte	local04, local01
	and	local04, #127
	wrbyte	local04, local01
	sub	local01, #16
LR__5164
	add	fp, #16
	rdlong	local09, fp
	sub	fp, #16
	add	local09, #1
	rdbyte	arg01, local09
	mov	arg02, local01
	add	arg02, #40
	mov	arg03, local08
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	local01, #17
 if_ne	wrbyte	#1, local01
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5166
	add	local01, #28
	wrlong	local08, local01
LR__5165
' 
' 			fp->sect = nsect;
' 		}
' 	}
' 
' 	return res ;
	mov	result1, local03
LR__5166
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_lseek_ret
	ret

_fatfs_cc_f_opendir
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #20
	mov	local01, arg01 wz
	add	fp, #8
	wrlong	arg02, fp
	sub	fp, #8
 if_e	mov	result1, #9
 if_e	jmp	#LR__5176
	add	fp, #8
	mov	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	mov	local02, result1 wz
 if_ne	jmp	#LR__5175
	add	fp, #16
	rdlong	local02, fp
	wrlong	local02, local01
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	mov	arg01, local01
	call	#_fatfs_cc_follow_path
	mov	local02, result1 wz
 if_ne	jmp	#LR__5174
	add	local01, #43
	rdbyte	arg03, local01
	sub	local01, #43
	test	arg03, #128 wz
 if_ne	jmp	#LR__5172
	add	local01, #6
	rdbyte	arg03, local01
	sub	local01, #6
	test	arg03, #16 wz
 if_e	jmp	#LR__5170
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	add	local01, #28
	rdlong	arg02, local01
	call	#_fatfs_cc_ld_clust
	sub	local01, #20
	wrlong	result1, local01
	sub	local01, #8
	jmp	#LR__5171
LR__5170
	mov	local02, #5
LR__5171
LR__5172
	cmp	local02, #0 wz
 if_ne	jmp	#LR__5173
	add	fp, #16
	rdlong	local02, fp
	sub	fp, #16
	add	local02, #6
	rdword	local02, local02
	add	local01, #4
	wrword	local02, local01
	sub	local01, #4
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local02, result1
LR__5173
LR__5174
	cmp	local02, #4 wz
 if_e	mov	local02, #5
LR__5175
	cmp	local02, #0 wz
 if_ne	wrlong	#0, local01
' 
' 	return res ;
	mov	result1, local02
LR__5176
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_opendir_ret
	ret

_fatfs_cc_f_closedir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	mov	local01, arg01
	mov	arg02, fp
	add	arg02, #12
	mov	arg01, local01
	call	#_fatfs_cc_validate
	cmps	result1, #0 wz
 if_e	wrlong	#0, local01
' 
' 
' 
' 
' 		dp->obj.fs = 0;
' #line 4633 "ff.c"
' 	}
' 	return res;
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_closedir_ret
	ret

_fatfs_cc_f_readdir
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #20
	mov	local01, arg01
	mov	local02, arg02
	mov	arg02, fp
	add	arg02, #16
	mov	arg01, local01
	call	#_fatfs_cc_validate
	mov	local03, result1 wz
 if_ne	jmp	#LR__5183
	cmp	local02, #0 wz
 if_ne	jmp	#LR__5180
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local03, result1
	jmp	#LR__5182
LR__5180
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	mov	local03, result1
	cmp	local03, #4 wz
 if_e	mov	local03, #0
	cmp	local03, #0 wz
 if_ne	jmp	#LR__5181
	mov	arg01, local01
	mov	arg02, local02
	call	#_fatfs_cc_get_fileinfo
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local03, result1
	cmp	local03, #4 wz
 if_e	mov	local03, #0
LR__5181
LR__5182
LR__5183
' 			}
' 			;
' 		}
' 	}
' 	return res ;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_readdir_ret
	ret

_fatfs_cc_f_stat
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #64
	add	fp, #4
	wrlong	arg01, fp
	mov	local01, arg02
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	mov	local02, result1 wz
 if_ne	jmp	#LR__5192
	add	fp, #16
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	mov	local02, result1 wz
 if_ne	jmp	#LR__5191
	add	fp, #59
	rdbyte	arg03, fp
	sub	fp, #59
	test	arg03, #128 wz
 if_ne	mov	local02, #6
 if_ne	jmp	#LR__5190
	cmp	local01, #0 wz
 if_ne	mov	arg01, fp
 if_ne	add	arg01, #16
 if_ne	mov	arg02, local01
 if_ne	call	#_fatfs_cc_get_fileinfo
LR__5190
LR__5191
LR__5192
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_stat_ret
	ret

_fatfs_cc_f_unlink
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #116
	add	fp, #4
	wrlong	arg01, fp
	mov	local01, #0
	mov	arg01, fp
	add	fp, #108
	mov	arg02, fp
	sub	fp, #112
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	mov	local02, result1 wz
 if_ne	jmp	#LR__5208
	add	fp, #112
	rdlong	local02, fp
	sub	fp, #100
	wrlong	local02, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	mov	local02, result1 wz
 if_ne	jmp	#LR__5207
	add	fp, #55
	rdbyte	result1, fp
	sub	fp, #55
	test	result1, #128 wz
 if_ne	mov	local02, #6
 if_ne	jmp	#LR__5200
	add	fp, #18
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #1 wz
 if_ne	mov	local02, #7
LR__5200
	cmp	local02, #0 wz
 if_ne	jmp	#LR__5203
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #72
	rdlong	arg02, fp
	sub	fp, #40
	call	#_fatfs_cc_ld_clust
	mov	local01, result1
	add	fp, #18
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #16 wz
 if_e	jmp	#LR__5202
	add	fp, #112
	rdlong	local02, fp
	sub	fp, #52
	wrlong	local02, fp
	add	fp, #8
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local02, result1 wz
 if_ne	jmp	#LR__5201
	mov	arg01, fp
	add	arg01, #60
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	mov	local02, result1 wz
 if_e	mov	local02, #7
	cmp	local02, #4 wz
 if_e	mov	local02, #0
LR__5201
LR__5202
LR__5203
	cmp	local02, #0 wz
 if_ne	jmp	#LR__5206
	mov	arg01, fp
	add	arg01, #12
	call	#_fatfs_cc_dir_remove
	mov	local02, result1 wz
 if_ne	jmp	#LR__5204
	cmp	local01, #0 wz
 if_e	jmp	#LR__5204
	mov	arg01, fp
	add	arg01, #12
	mov	arg02, local01
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	mov	local02, result1
LR__5204
	cmp	local02, #0 wz
 if_ne	jmp	#LR__5205
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	call	#_fatfs_cc_sync_fs
	mov	local02, result1
LR__5205
LR__5206
LR__5207
LR__5208
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_unlink_ret
	ret

_fatfs_cc_f_mkdir
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #92
	add	fp, #4
	wrlong	arg01, fp
	mov	arg01, fp
	add	fp, #72
	mov	arg02, fp
	sub	fp, #76
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	mov	local01, result1 wz
 if_ne	jmp	#LR__5215
	add	fp, #76
	rdlong	local01, fp
	sub	fp, #64
	wrlong	local01, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	mov	local01, result1 wz
 if_e	mov	local01, #8
	cmp	local01, #4 wz
 if_ne	jmp	#LR__5214
	add	fp, #76
	rdlong	local01, fp
	sub	fp, #16
	wrlong	local01, fp
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	mov	local02, result1 wz
	mov	local01, #0
 if_e	mov	local01, #7
	cmp	local02, #1 wz
 if_e	mov	local01, #2
	cmp	local02, ##-1 wz
 if_e	mov	local01, #1
	call	#_fatfs_cc__get_fattime
	mov	local03, result1
	cmp	local01, #0 wz
 if_ne	jmp	#LR__5211
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	mov	arg02, local02
	call	#_fatfs_cc_dir_clear
	mov	local01, result1 wz
 if_ne	jmp	#LR__5210
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	add	arg01, #52
	mov	arg02, #32
	mov	arg03, #11
	call	#\builtin_bytefill_
	add	fp, #76
	rdlong	local01, fp
	add	local01, #52
	wrbyte	#46, local01
	rdlong	local01, fp
	add	local01, #63
	wrbyte	#16, local01
	rdlong	arg01, fp
	add	arg01, #74
	wrlong	local03, arg01
	rdlong	arg02, fp
	mov	arg01, arg02
	sub	fp, #76
	add	arg02, #52
	mov	arg03, local02
	call	#_fatfs_cc_st_clust
	add	fp, #76
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg01, #84
	sub	fp, #76
	add	arg02, #52
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #76
	rdlong	local01, fp
	add	local01, #85
	wrbyte	#46, local01
	sub	fp, #56
	rdlong	arg03, fp
	add	fp, #56
	rdlong	arg02, fp
	mov	arg01, arg02
	sub	fp, #76
	add	arg02, #84
	call	#_fatfs_cc_st_clust
	add	fp, #76
	rdlong	local01, fp
	sub	fp, #76
	add	local01, #3
	wrbyte	#1, local01
	mov	arg01, fp
	add	arg01, #12
	call	#_fatfs_cc_dir_register
	mov	local01, result1
LR__5210
LR__5211
	cmp	local01, #0 wz
 if_ne	jmp	#LR__5212
	add	fp, #40
	rdlong	arg01, fp
	add	arg01, #22
	wrlong	local03, arg01
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	rdlong	arg02, fp
	sub	fp, #40
	mov	arg03, local02
	call	#_fatfs_cc_st_clust
	add	fp, #40
	rdlong	local03, fp
	add	local03, #11
	wrbyte	#16, local03
	add	fp, #36
	rdlong	local03, fp
	sub	fp, #76
	add	local03, #3
	wrbyte	#1, local03
	cmp	local01, #0 wz
 if_ne	jmp	#LR__5213
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	call	#_fatfs_cc_sync_fs
	mov	local01, result1
	jmp	#LR__5213
LR__5212
	mov	arg01, fp
	add	arg01, #60
	mov	arg02, local02
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
LR__5213
LR__5214
LR__5215
' 				remove_chain(&sobj, dcl, 0);
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mkdir_ret
	ret

_fatfs_cc_f_rename
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #156
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #8
	call	#_fatfs_cc_get_ldnumber
	add	fp, #4
	mov	arg01, fp
	add	fp, #108
	mov	arg02, fp
	sub	fp, #112
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	mov	local01, result1 wz
 if_ne	jmp	#LR__5232
	add	fp, #112
	rdlong	local02, fp
	sub	fp, #96
	wrlong	local02, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	mov	local01, result1 wz
 if_ne	jmp	#LR__5220
	add	fp, #59
	rdbyte	local02, fp
	sub	fp, #59
	test	local02, #160 wz
 if_ne	mov	local01, #6
LR__5220
	cmp	local01, #0 wz
 if_ne	jmp	#LR__5231
	add	fp, #116
	mov	arg01, fp
	sub	fp, #72
	rdlong	arg02, fp
	sub	fp, #44
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #64
	mov	arg01, fp
	sub	fp, #48
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #48
	call	#__system____builtin_memmove
	add	fp, #64
	mov	arg01, fp
	sub	fp, #56
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_follow_path
	mov	local01, result1 wz
 if_ne	jmp	#LR__5223
	add	fp, #72
	rdlong	local01, fp
	sub	fp, #48
	rdlong	result1, fp
	sub	fp, #24
	cmp	local01, result1 wz
 if_ne	jmp	#LR__5221
	add	fp, #80
	rdlong	local01, fp
	sub	fp, #48
	rdlong	result1, fp
	sub	fp, #32
	cmp	local01, result1 wz
 if_e	mov	local02, #4
 if_e	jmp	#LR__5222
LR__5221
	mov	local02, #8
LR__5222
	mov	local01, local02
LR__5223
	cmp	local01, #4 wz
 if_ne	jmp	#LR__5228
	mov	arg01, fp
	add	arg01, #64
	call	#_fatfs_cc_dir_register
	mov	local01, result1 wz
 if_ne	jmp	#LR__5227
	add	fp, #92
	rdlong	local03, fp
	mov	arg01, local03
	add	arg01, #13
	add	fp, #24
	mov	arg02, fp
	sub	fp, #116
	add	arg02, #13
	mov	arg03, #19
	call	#__system____builtin_memmove
	add	fp, #127
	rdbyte	local02, fp
	add	local03, #11
	wrbyte	local02, local03
	getbyte	local02, local02, #0
	sub	local03, #11
	test	local02, #16 wz
 if_e	add	local03, #11
 if_e	rdbyte	local02, local03
 if_e	or	local02, #32
 if_e	wrbyte	local02, local03
 if_e	sub	local03, #11
	sub	fp, #15
	rdlong	local02, fp
	sub	fp, #112
	add	local02, #3
	wrbyte	#1, local02
	add	local03, #11
	rdbyte	local02, local03
	sub	local03, #11
	test	local02, #16 wz
 if_e	jmp	#LR__5226
	add	fp, #24
	rdlong	local02, fp
	add	fp, #48
	rdlong	arg03, fp
	sub	fp, #72
	cmp	local02, arg03 wz
 if_e	jmp	#LR__5226
	add	fp, #112
	rdlong	arg01, fp
	mov	local02, arg01
	sub	fp, #112
	mov	arg02, local03
	call	#_fatfs_cc_ld_clust
	mov	arg02, result1
	mov	arg01, local02
	call	#_fatfs_cc_clst2sect
	mov	local03, result1 wz
 if_e	mov	local01, #2
 if_e	jmp	#LR__5225
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	mov	arg02, local03
	call	#_fatfs_cc_move_window
	mov	local01, result1 wz
	add	fp, #112
	rdlong	local03, fp
	sub	fp, #112
	add	local03, #84
 if_e	add	local03, #1
 if_e	rdbyte	local02, local03
 if_e	sub	local03, #1
 if_e	cmp	local02, #46 wz
 if_ne	jmp	#LR__5224
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #40
	rdlong	arg03, fp
	sub	fp, #72
	mov	arg02, local03
	call	#_fatfs_cc_st_clust
	add	fp, #112
	rdlong	local02, fp
	sub	fp, #112
	add	local02, #3
	wrbyte	#1, local02
LR__5224
LR__5225
LR__5226
LR__5227
LR__5228
	cmp	local01, #0 wz
 if_ne	jmp	#LR__5230
	mov	arg01, fp
	add	arg01, #16
	call	#_fatfs_cc_dir_remove
	mov	local01, result1 wz
 if_ne	jmp	#LR__5229
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	call	#_fatfs_cc_sync_fs
	mov	local01, result1
LR__5229
LR__5230
LR__5231
LR__5232
' 					res = sync_fs(fs);
' 				}
' 			}
' 
' 		}
' 		;
' 	}
' 
' 	return res ;
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_rename_ret
	ret

_fatfs_cc___default_flush
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	rdlong	local03, local02
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #8 wz
 if_e	jmp	#LR__5242
	cmps	local03, #1 wc
 if_b	jmp	#LR__5244
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #128 wz
 if_e	jmp	#LR__5241
	add	local01, #8
	rdlong	arg03, local01
	sub	local01, #8
	test	arg03, #256 wz
 if_e	jmp	#LR__5240
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #2
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	add	local01, #8
	rdlong	local06, local01
	andn	local06, #256
	wrlong	local06, local01
	sub	local01, #8
LR__5240
LR__5241
	add	local01, #24
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #24
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	add	local02, #12
	rdlong	arg02, local02
	sub	local02, #12
	mov	arg01, local01
	mov	arg03, local03
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	jmp	#LR__5244
LR__5242
	add	local01, #8
	rdlong	local06, local01
	sub	local01, #8
	test	local06, #4 wz
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__5243
	neg	arg02, local03
	mov	arg03, arg02
	sar	arg03, #31
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg04, #1
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
LR__5243
LR__5244
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local01, #8
	rdlong	local07, local01
	andn	local07, #12
	wrlong	local07, local01
'     }
'     b->cnt = 0;
'     b->ptr = 0;
'     f->state &= ~( (0x08) | (0x04) );
'     return 0;
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_fatfs_cc___default_flush_ret
	ret

_fatfs_cc_getenv
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__5251-@LR__5250)>>2,fcache_load_ptr_
LR__5250
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__5250
LR__5251
	sub	local02, arg01
	mov	result1, local02
	add	ptr__fatfs_cc_dat__, ##1276
	rdlong	arg03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1276
'             return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__5254
' 
' 	for (var = _environ_ptr; (name = *var) != 0; var++) {
	add	ptr__fatfs_cc_dat__, ##1276
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1276
LR__5252
	rdlong	local04, local03 wz
 if_e	jmp	#LR__5253
	mov	arg01, local04
	mov	arg02, local01
	mov	arg03, local02
	call	#_fatfs_cc_strncmp
	cmp	result1, #0 wz
 if_e	mov	local05, local02
 if_e	add	local05, local04
 if_e	rdbyte	local06, local05
 if_e	cmp	local06, #61 wz
' 			return name+len+1;
 if_e	add	local04, local02
 if_e	add	local04, #1
 if_e	mov	result1, local04
 if_e	jmp	#LR__5254
	add	local03, #4
	jmp	#LR__5252
LR__5253
' 	}
' 	return 0;
	mov	result1, #0
LR__5254
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_getenv_ret
	ret

_fatfs_cc__get_fattime
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #52
	mov	arg01, #0
	call	#_fatfs_cc_time
	add	fp, #4
	wrlong	result1, fp
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc__gmtime_r
	add	fp, #36
	rdlong	result1, fp
	sub	result1, #80
	shl	result1, #9
	sub	fp, #4
	rdlong	arg02, fp
	add	arg02, #1
	shl	arg02, #5
	or	result1, arg02
	sub	fp, #4
	rdlong	arg02, fp
	or	result1, arg02
	sub	fp, #4
	rdlong	arg02, fp
	shl	arg02, #11
	sub	fp, #4
	rdlong	arg01, fp
	shl	arg01, #5
	or	arg02, arg01
	sub	fp, #4
	rdlong	arg01, fp
	sub	fp, #16
	or	arg02, arg01
' 
'     now = time(0);
'     _gmtime_r (&now, &date);
'     ffdate = ((date.tm_year - 80) << 9) | ((date.tm_mon + 1) << 5) | ((date.tm_mday));
'     fftime = (date.tm_hour << 11) | (date.tm_min << 5) | (date.tm_sec);
'     return (ffdate << 16) | fftime;
	shl	result1, #16
	or	result1, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__get_fattime_ret
	ret

_fatfs_cc_unixtime_1154
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #52
	mov	local01, arg01
	shr	local01, #9
	and	local01, #127
	mov	local02, #80
	add	local02, local01
	add	fp, #36
	wrlong	local02, fp
	mov	local02, arg01
	shr	local02, #5
	getnib	local02, local02, #0
	sub	local02, #1
	sub	fp, #4
	wrlong	local02, fp
	and	arg01, #31
	sub	fp, #4
	wrlong	arg01, fp
	mov	local02, arg02
	shr	local02, #11
	and	local02, #31
	sub	fp, #4
	wrlong	local02, fp
	mov	local02, arg02
	shr	local02, #5
	and	local02, #63
	sub	fp, #4
	wrlong	local02, fp
	and	arg02, #31
	shl	arg02, #1
	sub	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #16
	call	#_fatfs_cc_mktime
' 
'     date.tm_year = 80 + ((dosdate >> 9) & 0x7f);
'     date.tm_mon = ((dosdate >> 5) & 0xf) - 1;
'     date.tm_mday = (dosdate & 0x1f);
'     date.tm_hour = (dostime >> 11) & 0x1f;
'     date.tm_min = (dostime >> 5) & 0x3f;
'     date.tm_sec = (dostime & 0x1f) << 1;
' 
'     t = mktime(&date);
' #line 66 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return t;
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_unixtime_1154_ret
	ret

_fatfs_cc__set_dos_error_1156
	mov	_var01, arg01
' #line 82 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     switch (derr) {
	fle	_var01, #20
	jmprel	_var01
LR__5260
	jmp	#LR__5261
	jmp	#LR__5275
	jmp	#LR__5276
	jmp	#LR__5277
	jmp	#LR__5262
	jmp	#LR__5263
	jmp	#LR__5264
	jmp	#LR__5265
	jmp	#LR__5267
	jmp	#LR__5270
	jmp	#LR__5266
	jmp	#LR__5271
	jmp	#LR__5272
	jmp	#LR__5273
	jmp	#LR__5278
	jmp	#LR__5278
	jmp	#LR__5278
	jmp	#LR__5268
	jmp	#LR__5274
	jmp	#LR__5269
	jmp	#LR__5278
LR__5261
	mov	_var02, #0
'         r = 0;
'         break;
	jmp	#LR__5279
LR__5262
LR__5263
LR__5264
	mov	_var02, #4
'         r =  4 ;
'         break;
	jmp	#LR__5279
LR__5265
LR__5266
	mov	_var02, #6
'         r =  6 ;
'         break;
	jmp	#LR__5279
LR__5267
	mov	_var02, #9
'         r =  9 ;
'         break;
	jmp	#LR__5279
LR__5268
	mov	_var02, #7
'         r =  7 ;
'         break;
	jmp	#LR__5279
LR__5269
LR__5270
LR__5271
LR__5272
LR__5273
	mov	_var02, #10
'         r =  10 ;
'         break;
	jmp	#LR__5279
LR__5274
	mov	_var02, #11
'         r =  11 ;
'         break;
	jmp	#LR__5279
LR__5275
LR__5276
LR__5277
LR__5278
	mov	_var02, #12
'         r =  12 ;
'         break;
LR__5279
'     }
'     return _seterror(r);
	cmps	_var02, #0 wz
	add	ptr___system__dat__, #32
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
_fatfs_cc__set_dos_error_1156_ret
	ret

_fatfs_cc_v_creat
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, ##1592
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__5281
	mov	arg01, local03
	mov	arg02, #0
	mov	arg03, ##1592
	call	#\builtin_bytefill_
	mov	arg01, local03
	add	arg01, ##1040
	mov	arg02, local02
	mov	arg03, #7
	call	#_fatfs_cc_f_open
	mov	local04, result1 wz
 if_e	jmp	#LR__5280
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_1156
	jmp	#LR__5281
LR__5280
	wrlong	local03, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__5281
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_creat_ret
	ret

_fatfs_cc_v_close
	mov	COUNT_, #2
	call	#pushregs_
	rdlong	local01, arg01
	mov	arg01, local01
	add	arg01, ##1040
	call	#_fatfs_cc_f_close
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
'     FAT_FIL *f = fil->vfsdata;
'     r=f_close(&f->fil);
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local02
	call	#_fatfs_cc__set_dos_error_1156
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_close_ret
	ret

_fatfs_cc_v_opendir
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, #48
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
' #line 166 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__5291
	mov	arg02, local02
	mov	arg01, local03
	call	#_fatfs_cc_f_opendir
	mov	local04, result1 wz
 if_e	jmp	#LR__5290
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'         free(f);
'         return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_1156
	jmp	#LR__5291
LR__5290
	add	local01, #4
	wrlong	local03, local01
'     }
'     dir->vfsdata = f;
'     return 0;
	mov	result1, #0
LR__5291
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_opendir_ret
	ret

_fatfs_cc_v_closedir
	mov	COUNT_, #2
	call	#pushregs_
	add	arg01, #4
	rdlong	local01, arg01
	mov	arg01, local01
	call	#_fatfs_cc_f_closedir
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
	cmp	local02, #0 wz
 if_ne	mov	arg01, local02
 if_ne	call	#_fatfs_cc__set_dos_error_1156
'     return r;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_closedir_ret
	ret

_fatfs_cc_v_readdir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #300
	mov	local01, arg02
	add	arg01, #4
	rdlong	arg01, arg01
	mov	arg02, fp
	add	arg02, #12
	call	#_fatfs_cc_f_readdir
	mov	arg03, result1 wz
 if_e	jmp	#LR__5300
'         return _set_dos_error(r);
	mov	arg01, arg03
	call	#_fatfs_cc__set_dos_error_1156
	jmp	#LR__5301
LR__5300
	add	fp, #40
	rdbyte	arg03, fp wz
	sub	fp, #40
'         return -1;
 if_e	neg	result1, #1
 if_e	jmp	#LR__5301
	mov	arg02, fp
	add	arg02, #40
	mov	arg01, local01
	mov	arg03, #63
	call	#_fatfs_cc_strncpy
	add	local01, #63
	wrbyte	#0, local01
	sub	local01, #63
	add	fp, #20
	rdbyte	arg03, fp
	test	arg03, #16 wz
 if_ne	add	local01, #80
 if_ne	wrbyte	#1, local01
	sumnz	local01, #80
 if_e	wrbyte	#0, local01
 if_e	sub	local01, #80
	sub	fp, #8
	rdlong	arg03, fp
	add	local01, #72
	wrlong	arg03, local01
	add	fp, #4
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #18
	call	#_fatfs_cc_unixtime_1154
	add	local01, #4
	wrlong	result1, local01
'         ent->d_type =  (0) ;
'     }
'     ent->d_size = finfo.fsize;
'     ent->d_mtime = unixtime(finfo.fdate, finfo.ftime);
'     return 0;
	mov	result1, #0
LR__5301
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_readdir_ret
	ret

_fatfs_cc_v_stat
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #304
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local02
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
	rdbyte	result2, local01 wz
 if_e	jmp	#LR__5310
	rdbyte	result2, local01
	cmp	result2, #46 wz
 if_e	add	local01, #1
 if_e	rdbyte	local03, local01
 if_e	sub	local01, #1
 if_e	cmps	local03, #0 wz
 if_ne	jmp	#LR__5311
LR__5310
	add	fp, #24
	wrbyte	#16, fp
	sub	fp, #24
	mov	local04, #0
	jmp	#LR__5312
LR__5311
	mov	arg02, fp
	add	arg02, #16
	mov	arg01, local01
	call	#_fatfs_cc_f_stat
	mov	local04, result1
LR__5312
	cmp	local04, #0 wz
 if_e	jmp	#LR__5313
'         return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_1156
	jmp	#LR__5314
LR__5313
	mov	local05, #292
	add	fp, #24
	rdbyte	local03, fp
	test	local03, #1 wz
 if_e	mov	local05, #438
	test	local03, #16 wz
 if_ne	or	local05, ##4169
	add	local02, #8
	wrlong	local05, local02
	add	local02, #4
	wrlong	#1, local02
	sub	fp, #8
	rdlong	result1, fp
	add	local02, #12
	wrlong	result1, local02
	add	local02, #4
	wrlong	#0, local02
	add	local02, #4
	wrlong	##512, local02
	rdlong	local03, fp
	add	local03, #511
	shr	local03, #9
	add	local02, #4
	wrlong	local03, local02
	add	fp, #4
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #22
	call	#_fatfs_cc_unixtime_1154
	add	local02, #12
	wrlong	result1, local02
	sub	local02, #4
	wrlong	result1, local02
	sub	local02, #4
	wrlong	result1, local02
'         mode |=  0010000  |  0100  |  0010  |  0001 ;
'     }
'     buf->st_mode = mode;
'     buf->st_nlink = 1;
'     buf->st_size = finfo.fsize;
'     buf->st_blksize = 512;
'     buf->st_blocks = (finfo.fsize + 511) / 512;
'     buf->st_atime = buf->st_mtime = buf->st_ctime = unixtime(finfo.fdate, finfo.ftime);
' #line 257 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return r;
	mov	result1, local04
LR__5314
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_stat_ret
	ret

_fatfs_cc_v_read
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #28
	mov	local01, arg01
	rdlong	arg01, local01 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__5321
	add	arg01, ##1040
	mov	arg04, fp
	add	arg04, #24
	call	#_fatfs_cc_f_read
	mov	arg04, result1 wz
 if_e	jmp	#LR__5320
	add	local01, #8
	rdlong	arg01, local01
	or	arg01, #32
	wrlong	arg01, local01
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	mov	arg01, arg04
	call	#_fatfs_cc__set_dos_error_1156
	jmp	#LR__5321
LR__5320
	add	fp, #24
	rdlong	local02, fp wz
 if_e	add	local01, #8
 if_e	rdlong	local02, local01
 if_e	or	local02, #16
 if_e	wrlong	local02, local01
'         fil->state |=  (0x10) ;
'     }
'     return x;
	rdlong	result1, fp
	sub	fp, #24
LR__5321
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_read_ret
	ret

_fatfs_cc_v_write
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #28
	mov	local01, arg01
	rdlong	arg01, local01 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__5331
	add	arg01, ##1040
	mov	arg04, fp
	add	arg04, #24
	call	#_fatfs_cc_f_write
	mov	arg04, result1 wz
 if_e	jmp	#LR__5330
	add	local01, #8
	rdlong	arg01, local01
	or	arg01, #32
	wrlong	arg01, local01
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	mov	arg01, arg04
	call	#_fatfs_cc__set_dos_error_1156
	jmp	#LR__5331
LR__5330
'     }
'     return x;
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #24
LR__5331
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_write_ret
	ret

_fatfs_cc_v_lseek
	mov	COUNT_, #6
	call	#pushregs_
	mov	local03, arg02
	mov	local04, arg04
	rdlong	local05, arg01
	add	local05, ##1040 wz
 if_ne	jmp	#LR__5340
'         return _seterror( 5 );
	add	ptr___system__dat__, #32
	wrlong	#5, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result2, #1
	neg	result1, #1
	jmp	#LR__5343
LR__5340
	cmp	local04, #0 wz
 if_e	jmp	#LR__5341
	cmp	local04, #1 wz
 if_e	add	local05, #20
 if_e	rdlong	local06, local05
 if_e	sub	local05, #20
 if_e	add	local03, local06
 if_ne	add	local05, #12
 if_ne	rdlong	local06, local05
 if_ne	sub	local05, #12
 if_ne	add	local03, local06
LR__5341
	mov	arg01, local05
	mov	arg02, local03
	call	#_fatfs_cc_f_lseek
	mov	arg01, result1 wz
 if_e	jmp	#LR__5342
'         return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_1156
	mov	result2, result1
	sar	result2, #31
	jmp	#LR__5343
LR__5342
'     }
'     return (off_t)offset;
	mov	result1, local03
	mov	result2, local02
LR__5343
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_lseek_ret
	ret

_fatfs_cc_v_ioctl
' {
'     return _seterror( 10 );
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
_fatfs_cc_v_ioctl_ret
	ret

_fatfs_cc_v_mkdir
	call	#_fatfs_cc_f_mkdir
	mov	arg01, result1
' 
'     r = f_mkdir(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_1156
_fatfs_cc_v_mkdir_ret
	ret

_fatfs_cc_v_remove
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_1156
_fatfs_cc_v_remove_ret
	ret

_fatfs_cc_v_rmdir
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_1156
_fatfs_cc_v_rmdir_ret
	ret

_fatfs_cc_v_rename
	call	#_fatfs_cc_f_rename
	mov	arg01, result1
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_1156
_fatfs_cc_v_rename_ret
	ret

_fatfs_cc_v_open
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, ##1592
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local04, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__5356
	mov	arg01, local04
	mov	arg02, #0
	mov	arg03, ##1592
	call	#\builtin_bytefill_
'   switch (flags & 3) {
	mov	local05, local03
	and	local05, #3 wz
 if_e	jmp	#LR__5350
	cmp	local05, #1 wz
 if_e	jmp	#LR__5351
	jmp	#LR__5352
LR__5350
	mov	local06, #1
'       fs_flags =  0x01 ;
'       break;
	jmp	#LR__5353
LR__5351
	mov	local06, #2
'       fs_flags =  0x02 ;
'       break;
	jmp	#LR__5353
LR__5352
	mov	local06, #3
'       fs_flags =  0x01  |  0x02 ;
'       break;
LR__5353
	test	local03, #8 wz
 if_ne	or	local06, #24
 if_ne	jmp	#LR__5354
	test	local03, #32 wz
 if_ne	or	local06, #48
LR__5354
	mov	arg01, local04
	add	arg01, ##1040
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_f_open
	mov	local07, result1 wz
 if_e	jmp	#LR__5355
	mov	arg01, local04
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
' #line 426 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(r);
	mov	arg01, local07
	call	#_fatfs_cc__set_dos_error_1156
	jmp	#LR__5356
LR__5355
	wrlong	local04, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__5356
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_open_ret
	ret

_fatfs_cc_v_flush
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	call	#_fatfs_cc___default_flush
	rdlong	local01, local01
	add	local01, ##1040 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__5360
	mov	arg01, local01
	call	#_fatfs_cc_f_sync
	mov	arg01, result1
'     }
' #line 449 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     result = f_sync(f);
' #line 453 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_1156
LR__5360
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_flush_ret
	ret

_fatfs_cc_v_init
' {
'     return 0;
	mov	result1, #0
_fatfs_cc_v_init_ret
	ret

_fatfs_cc_v_deinit
	mov	arg02, ##@LR__5486
	mov	arg01, #0
	mov	arg03, #0
	call	#_fatfs_cc_f_mount
	add	objptr, ##520
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##524
	call	#__system___freepins
' #line 474 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     _freepins(f_pinmask);
'     return 0;
	mov	result1, #0
_fatfs_cc_v_deinit_ret
	ret

_fatfs_cc_get_vfs
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #88
	call	#__system___gc_alloc_managed
	mov	arg01, result1
	mov	result1, objptr
	or	result1, ##196083712
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##197132288
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##198180864
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##199229440
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##200278016
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #58
	add	arg01, #4
	wrlong	result1, arg01
	add	arg01, #4
	wrlong	local01, arg01
	add	arg01, #4
	wrlong	#0, arg01
	mov	result1, objptr
	or	result1, ##202375168
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##203423744
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##204472320
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##205520896
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##206569472
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##207618048
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##208666624
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##209715200
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##210763776
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##211812352
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##212860928
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##213909504
	add	arg01, #4
	wrlong	result1, arg01
	add	arg01, #4
	wrlong	#0, arg01
	add	arg01, #4
	wrlong	#0, arg01
	sub	arg01, #84
' 
'     v->close = &v_close;
'     v->read = &v_read;
'     v->write = &v_write;
'     v->lseek = &v_lseek;
'     v->ioctl = &v_ioctl;
'     v->flush = &v_flush;
'     v->vfs_data = ptr;
'     v->reserved = 0;
' 
'     v->open = &v_open;
'     v->creat = &v_creat;
'     v->opendir = &v_opendir;
'     v->closedir = &v_closedir;
'     v->readdir = &v_readdir;
'     v->stat = &v_stat;
' 
'     v->mkdir = &v_mkdir;
'     v->rmdir = &v_rmdir;
' 
'     v->remove = &v_remove;
'     v->rename = &v_rename;
' 
'     v->init = &v_init;
'     v->deinit = &v_deinit;
' 
' 
'     v->getcf = 0;
'     v->putcf = 0;
' #line 532 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return v;
	mov	result1, arg01
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_vfs_ret
	ret

_fatfs_cc_gettimeofday
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	call	#__system___getus
	mov	arg01, result1
	add	ptr__fatfs_cc_dat__, ##1288
	rdlong	local02, ptr__fatfs_cc_dat__
	mov	result1, arg01
	sub	result1, local02
	qdiv	result1, ##1000000
	sub	ptr__fatfs_cc_dat__, ##1288
	getqx	local02
	qdiv	result1, ##1000000
	cmp	local02, #0 wz
	getqy	local03
 if_e	jmp	#LR__5370
	add	ptr__fatfs_cc_dat__, ##1284
	rdlong	local04, ptr__fatfs_cc_dat__
	add	local04, local02
	wrlong	local04, ptr__fatfs_cc_dat__
	sub	arg01, local03
	add	ptr__fatfs_cc_dat__, #4
	wrlong	arg01, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1288
LR__5370
	add	ptr__fatfs_cc_dat__, ##1284
	rdlong	local04, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1284
	wrlong	local04, local01
	add	local01, #4
	wrlong	local03, local01
'         lastsec += secs;
'         lastus = now - leftover;
'     }
'     tv->tv_sec = lastsec;
'     tv->tv_usec = leftover;
'     return 0;
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_gettimeofday_ret
	ret

_fatfs_cc__is_leap_year
	abs	result1, arg01 wc
	and	result1, #3
	negc	result1, result1 wz
 if_ne	jmp	#LR__5381
	abs	result1, arg01 wc
	qdiv	result1, #100
	getqy	result1
	negc	result1, result1 wz
 if_ne	jmp	#LR__5380
	abs	result1, arg01 wc
	qdiv	result1, #400
'       return (0 == y % 400);
	mov	result1, #0
	getqy	_var01
	negc	_var01, _var01 wz
 if_e	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__5380
'     return 1;
	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__5381
'   }
'   return 0;
	mov	result1, #0
_fatfs_cc__is_leap_year_ret
	ret

_fatfs_cc___tzoffset
	mov	_var01, arg01 wz
	wrlong	##-1, arg02
	mov	_var02, #1
 if_ne	rdbyte	_var03, _var01 wz
'                 return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__5407
	wrlong	#0, arg02
	mov	_var04, ptr__fatfs_cc_dat__
	add	_var04, ##1244
	callpa	#(@LR__5391-@LR__5390)>>2,fcache_load_ptr_
' 
'        *hasdst = 0;
' 
' 	n = stdname;
'         while (*s && isalpha(*s)) {
LR__5390
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__5392
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #12 wz
 if_e	jmp	#LR__5392
	mov	_var05, _var01
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var05
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__5390
LR__5391
LR__5392
	wrbyte	#0, _var04
	mov	_var08, #0
	rdbyte	_var03, _var01
	cmp	_var03, #45 wz
 if_e	neg	_var02, #1
 if_e	add	_var01, #1
	callpa	#(@LR__5394-@LR__5393)>>2,fcache_load_ptr_
'                 sgn = -1;
'                 s++;
'         }
'         while (isdigit(*s)) {
LR__5393
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #2 wz
 if_e	jmp	#LR__5395
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__5393
LR__5394
LR__5395
	qmul	_var08, ##3600
	rdbyte	_var03, _var01
	cmp	_var03, #58 wz
	getqx	_var09
 if_ne	jmp	#LR__5399
	mov	_var08, #0
	add	_var01, #1
	callpa	#(@LR__5397-@LR__5396)>>2,fcache_load_ptr_
'                 x = 0;
'                 s++;
'                 while (isdigit(*s)) {
LR__5396
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #2 wz
 if_e	jmp	#LR__5398
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__5396
LR__5397
LR__5398
	mov	_var07, _var08
	shl	_var07, #4
	sub	_var07, _var08
	shl	_var07, #2
	add	_var09, _var07
LR__5399
	mov	_var04, ptr__fatfs_cc_dat__
	add	_var04, ##1253
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #12 wz
 if_e	jmp	#LR__5402
	wrlong	#1, arg02
'                 *hasdst = 1;
' 		while (*s && isalpha(*s)) *n++ = *s++;
LR__5400
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__5401
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	mov	result1, ptr__fatfs_cc_dat__
	add	result1, ##1292
	add	arg01, result1
	rdbyte	result1, arg01
	test	result1, #12 wz
 if_e	jmp	#LR__5401
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var01
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__5400
LR__5401
LR__5402
	wrbyte	#0, _var04
	add	ptr__fatfs_cc_dat__, ##1244
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1244
 if_e	jmp	#LR__5403
	add	ptr__fatfs_cc_dat__, ##1244
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #8
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1236
	jmp	#LR__5404
LR__5403
	add	ptr__fatfs_cc_dat__, ##1262
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #26
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1236
LR__5404
	add	ptr__fatfs_cc_dat__, ##1253
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1253
 if_e	jmp	#LR__5405
	add	ptr__fatfs_cc_dat__, ##1253
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #13
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1240
	jmp	#LR__5406
LR__5405
	add	ptr__fatfs_cc_dat__, ##1244
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #4
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1240
LR__5406
	qmul	_var02, _var09
' 		_tzname[1] = stdname;
' 
'         return sgn * off;
	getqx	result1
LR__5407
_fatfs_cc___tzoffset_ret
	ret

_fatfs_cc___indst
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #2 wz
 if_ne	jmp	#LR__5410
	mov	_var01, #7
	add	arg01, #24
	rdlong	_var02, arg01
	add	_var01, _var02
	sub	arg01, #12
	rdlong	_var03, arg01
	sub	_var01, _var03
	cmps	_var01, #0 wc
'                         return 1;
 if_b	mov	result1, #1
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 0;
	mov	result1, #0
	jmp	#_fatfs_cc___indst_ret
LR__5410
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #10 wz
 if_ne	jmp	#LR__5411
	add	arg01, #24
	rdlong	_var01, arg01
	sub	arg01, #12
	rdlong	_var04, arg01
	sub	_var01, _var04
	cmps	_var01, #0 wc
'                         return 0;
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 1;
	mov	result1, #1
	jmp	#_fatfs_cc___indst_ret
LR__5411
'         }
' 
'         return (t->tm_mon > 2 && t->tm_mon < 10);
	mov	_var01, #0
	add	arg01, #16
	rdlong	_var02, arg01
	sub	arg01, #16
	cmps	_var02, #3 wc
 if_b	jmp	#LR__5412
	add	arg01, #16
	rdlong	_var03, arg01
	cmps	_var03, #10 wc
 if_b	mov	_var01, #1
LR__5412
	mov	result1, _var01
_fatfs_cc___indst_ret
	ret

_fatfs_cc_disk_deinitialize
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, ##528
	rdlong	arg01, objptr wz
	sub	objptr, ##528
' 
'         return RES_NOTRDY;
 if_e	mov	result1, #3
 if_e	jmp	#LR__5420
	add	objptr, ##528
	rdlong	arg01, objptr
	mov	local01, arg01
	add	local01, #36
	rdlong	local01, local01
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	sub	objptr, ##528
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
'     }
'     fh->close(fh);
'     return RES_OK;
	mov	result1, #0
LR__5420
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_deinitialize_ret
	ret

' 	
' 	FUNCTION pfunc(c as integer) as integer
__system____strs_cl_pfunc_
' 		if (i < 16) then
	add	objptr, #4
	rdlong	result1, objptr
	sub	objptr, #4
	cmps	result1, #16 wc
 if_ae	jmp	#LR__5430
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	_var01, objptr
	add	_var01, result1
	wrbyte	arg01, _var01
	rdlong	result1, objptr
	add	result1, #1
	wrlong	result1, objptr
	sub	objptr, #4
' 			p(i) = c
' 			i = i+1
' 			return 1
	mov	result1, #1
	jmp	#__system____strs_cl_pfunc__ret
LR__5430
' 			return -1
	neg	result1, #1
__system____strs_cl_pfunc__ret
	ret

__system___struct__s_vfs_file_t_putchar_
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, #28
	rdlong	local01, objptr wz
	sub	objptr, #28
 if_e	mov	result1, #0
 if_e	jmp	#LR__5440
	add	objptr, #28
	rdlong	local02, objptr
	mov	local03, local02
	sub	objptr, #28
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg02, objptr
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
'     return (i < 0) ? 0 : 1;
	cmps	result1, #0 wc
 if_b	mov	local01, #0
 if_ae	mov	local01, #1
	mov	result1, local01
LR__5440
	mov	ptra, fp
	call	#popregs_
__system___struct__s_vfs_file_t_putchar__ret
	ret

__system___struct__s_vfs_file_t_getchar_
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #32
	rdlong	arg01, objptr wz
	sub	objptr, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__5450
'     return getcf(__this);
	add	objptr, #32
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #32
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	arg01, objptr
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
LR__5450
	mov	ptra, fp
	call	#popregs_
__system___struct__s_vfs_file_t_getchar__ret
	ret

__system___struct___bas_wrap_sender_tx_
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, objptr
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___struct___bas_wrap_sender_tx__ret
	ret

__system___struct___bas_wrap_sender_rx_
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #4
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #4
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__system___struct___bas_wrap_sender_rx__ret
	ret

__system___struct___bas_wrap_sender_close_
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #8
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #8
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__system___struct___bas_wrap_sender_close__ret
	ret

LR__5460
	byte	"/"
	byte	0
LR__5461
	byte	"inf"
	byte	0
LR__5462
	byte	"nan"
	byte	0
LR__5463
	byte	
	byte	0
LR__5464
	byte	
	byte	0
LR__5465
	byte	
	byte	0
LR__5466
	byte	
	byte	0
LR__5467
	byte	
	byte	0
LR__5468
	byte	
	byte	0
LR__5469
	byte	
	byte	0
LR__5470
	byte	
	byte	0
LR__5471
	byte	0
	byte	0
LR__5472
	byte	0
	byte	0
LR__5473
	byte	0
	byte	0
LR__5474
	byte	" !!! corrupted heap??? !!! "
	byte	0
LR__5475
	byte	" !!! out of heap memory !!! "
	byte	0
LR__5476
	byte	" !!! corrupted heap !!! "
	byte	0
LR__5477
	byte	0
	byte	0
LR__5478
	byte	"."
	byte	0
LR__5479
	byte	0
	byte	0
LR__5480
	byte	0
	byte	0
LR__5481
	byte	0
	byte	0
LR__5482
	byte	"TZ"
	byte	0
LR__5483
	byte	"*:<>|",34,"?",127
	byte	0
LR__5484
	byte	"+,;=[]"
	byte	0
LR__5485
	byte	"FAT32   "
	byte	0
LR__5486
	byte	0
	byte	0
LR__5487
	byte	
	byte	0
LR__5488
	byte	
	byte	0
LR__5489
	byte	
	byte	0
LR__5490
	byte	
	byte	0
LR__5491
	byte	34
	byte	0
LR__5492
	byte	34
	byte	0
LR__5493
	byte	":"
	byte	0
LR__5494
	byte	
	byte	0
LR__5495
	byte	
	byte	0
LR__5496
	byte	
	byte	0
LR__5497
	byte	
	byte	0
LR__5498
	byte	
	byte	0
LR__5499
	byte	
	byte	0
LR__5500
	byte	
	byte	0
LR__5501
	byte	"0"
	byte	0
LR__5502
	byte	34
	byte	0
LR__5503
	byte	34
	byte	0
LR__5504
	byte	34
	byte	0
LR__5505
	byte	34
	byte	0
LR__5506
	byte	34
	byte	0
LR__5507
	byte	">"
	byte	0
LR__5508
	byte	"<"
	byte	0
LR__5509
	byte	"+"
	byte	0
LR__5510
	byte	"-"
	byte	0
LR__5511
	byte	"*"
	byte	0
LR__5512
	byte	"/"
	byte	0
LR__5513
	byte	"^"
	byte	0
LR__5514
	byte	"="
	byte	0
LR__5515
	byte	"+"
	byte	0
LR__5516
	byte	"+"
	byte	0
LR__5517
	byte	"-"
	byte	0
LR__5518
	byte	"-"
	byte	0
LR__5519
	byte	"<"
	byte	0
LR__5520
	byte	">"
	byte	0
LR__5521
	byte	34
	byte	0
LR__5522
	byte	34
	byte	0
LR__5523
	byte	"else"
	byte	0
LR__5524
	byte	"then"
	byte	0
LR__5525
	byte	"?"
	byte	0
LR__5526
	byte	"?"
	byte	0
LR__5527
	byte	"."
	byte	0
LR__5528
	byte	"mouse"
	byte	0
LR__5529
	byte	"cursor"
	byte	0
LR__5530
	byte	"click"
	byte	0
LR__5531
	byte	"on"
	byte	0
LR__5532
	byte	"1"
	byte	0
LR__5533
	byte	"off"
	byte	0
LR__5534
	byte	"0"
	byte	0
LR__5535
	byte	"mode"
	byte	0
LR__5536
	byte	"m."
	byte	0
LR__5537
	byte	"atari"
	byte	0
LR__5538
	byte	"0"
	byte	0
LR__5539
	byte	"pc_amber"
	byte	0
LR__5540
	byte	"1"
	byte	0
LR__5541
	byte	"pc_green"
	byte	0
LR__5542
	byte	"2"
	byte	0
LR__5543
	byte	"pc_white"
	byte	0
LR__5544
	byte	"3"
	byte	0
LR__5545
	byte	"st"
	byte	0
LR__5546
	byte	"4"
	byte	0
LR__5547
	byte	"amiga"
	byte	0
LR__5548
	byte	"5"
	byte	0
LR__5549
	byte	
	byte	0
LR__5550
	byte	"load"
	byte	0
LR__5551
	byte	"save"
	byte	0
LR__5552
	byte	"brun"
	byte	0
LR__5553
	byte	"run"
	byte	0
LR__5554
	byte	"lo."
	byte	0
LR__5555
	byte	"s."
	byte	0
LR__5556
	byte	"br."
	byte	0
LR__5557
	byte	"enter"
	byte	0
LR__5558
	byte	"e."
	byte	0
LR__5559
	byte	"$"
	byte	0
LR__5560
	byte	"delete"
	byte	0
LR__5561
	byte	"mkdir"
	byte	0
LR__5562
	byte	"$"
	byte	0
LR__5563
	byte	"copy"
	byte	0
LR__5564
	byte	"$"
	byte	0
LR__5565
	byte	"copy"
	byte	0
LR__5566
	byte	"$"
	byte	0
LR__5567
	byte	"cd"
	byte	0
LR__5568
	byte	"cd."
	byte	0
LR__5569
	byte	"."
	byte	0
LR__5570
	byte	".."
	byte	0
LR__5571
	byte	"cd"
	byte	0
LR__5572
	byte	"/"
	byte	0
LR__5573
	byte	
	byte	0
LR__5574
	byte	
	byte	0
LR__5575
	byte	
	byte	0
LR__5576
	byte	
	byte	0
LR__5577
	byte	
	byte	0
LR__5578
	byte	"Ready"
	byte	0
LR__5579
	byte	"+"
	byte	0
LR__5580
	byte	"-"
	byte	0
LR__5581
	byte	"or"
	byte	0
LR__5582
	byte	"xor"
	byte	0
LR__5583
	byte	"*"
	byte	0
LR__5584
	byte	"/"
	byte	0
LR__5585
	byte	"and"
	byte	0
LR__5586
	byte	"div"
	byte	0
LR__5587
	byte	"mod"
	byte	0
LR__5588
	byte	"shl"
	byte	0
LR__5589
	byte	"shr"
	byte	0
LR__5590
	byte	"^"
	byte	0
LR__5591
	byte	"not"
	byte	0
LR__5592
	byte	"@"
	byte	0
LR__5593
	byte	"="
	byte	0
LR__5594
	byte	">="
	byte	0
LR__5595
	byte	"<="
	byte	0
LR__5596
	byte	"<"
	byte	0
LR__5597
	byte	">"
	byte	0
LR__5598
	byte	"<>"
	byte	0
LR__5599
	byte	"++"
	byte	0
LR__5600
	byte	"--"
	byte	0
LR__5601
	byte	"#"
	byte	0
LR__5602
	byte	"0"
	byte	0
LR__5603
	byte	"9"
	byte	0
LR__5604
	byte	"#read"
	byte	0
LR__5605
	byte	"#write"
	byte	0
LR__5606
	byte	"#append"
	byte	0
LR__5607
	byte	"#"
	byte	0
LR__5608
	byte	"#"
	byte	0
LR__5609
	byte	"-"
	byte	0
LR__5610
	byte	"0"
	byte	0
LR__5611
	byte	"c"
	byte	0
LR__5612
	byte	"c#"
	byte	0
LR__5613
	byte	"d"
	byte	0
LR__5614
	byte	"d#"
	byte	0
LR__5615
	byte	"e"
	byte	0
LR__5616
	byte	"f"
	byte	0
LR__5617
	byte	"f#"
	byte	0
LR__5618
	byte	"g"
	byte	0
LR__5619
	byte	"g#"
	byte	0
LR__5620
	byte	"a"
	byte	0
LR__5621
	byte	"a#"
	byte	0
LR__5622
	byte	"h"
	byte	0
LR__5623
	byte	"b"
	byte	0
LR__5624
	byte	"+"
	byte	0
LR__5625
	byte	"-"
	byte	0
LR__5626
	byte	"="
	byte	0
LR__5627
	byte	","
	byte	0
LR__5628
	byte	"*"
	byte	0
LR__5629
	byte	"/"
	byte	0
LR__5630
	byte	";"
	byte	0
LR__5631
	byte	34
	byte	0
LR__5632
	byte	"^"
	byte	0
LR__5633
	byte	")"
	byte	0
LR__5634
	byte	"("
	byte	0
LR__5635
	byte	":"
	byte	0
LR__5636
	byte	" "
	byte	0
LR__5637
	byte	">"
	byte	0
LR__5638
	byte	"<"
	byte	0
LR__5639
	byte	"="
	byte	0
LR__5640
	byte	"beep"
	byte	0
LR__5641
	byte	"b."
	byte	0
LR__5642
	byte	"blit"
	byte	0
LR__5643
	byte	"box"
	byte	0
LR__5644
	byte	"brun"
	byte	0
LR__5645
	byte	"br."
	byte	0
LR__5646
	byte	"cd"
	byte	0
LR__5647
	byte	"changefreq"
	byte	0
LR__5648
	byte	"cf."
	byte	0
LR__5649
	byte	"changepan"
	byte	0
LR__5650
	byte	"cp."
	byte	0
LR__5651
	byte	"changevol"
	byte	0
LR__5652
	byte	"cv."
	byte	0
LR__5653
	byte	"changewave"
	byte	0
LR__5654
	byte	"cw."
	byte	0
LR__5655
	byte	"circle"
	byte	0
LR__5656
	byte	"ci."
	byte	0
LR__5657
	byte	"click"
	byte	0
LR__5658
	byte	"close"
	byte	0
LR__5659
	byte	"cls"
	byte	0
LR__5660
	byte	"cogstop"
	byte	0
LR__5661
	byte	"color"
	byte	0
LR__5662
	byte	"c."
	byte	0
LR__5663
	byte	"copy"
	byte	0
LR__5664
	byte	"cursor"
	byte	0
LR__5665
	byte	"data"
	byte	0
LR__5666
	byte	"defchar"
	byte	0
LR__5667
	byte	"defsnd"
	byte	0
LR__5668
	byte	"defenv"
	byte	0
LR__5669
	byte	"defsprite"
	byte	0
LR__5670
	byte	"ds."
	byte	0
LR__5671
	byte	"deg"
	byte	0
LR__5672
	byte	"delete"
	byte	0
LR__5673
	byte	"dim"
	byte	0
LR__5674
	byte	"dir"
	byte	0
LR__5675
	byte	"dpoke"
	byte	0
LR__5676
	byte	"draw"
	byte	0
LR__5677
	byte	"drawto"
	byte	0
LR__5678
	byte	"dr."
	byte	0
LR__5679
	byte	"else"
	byte	0
LR__5680
	byte	"end"
	byte	0
LR__5681
	byte	"enter"
	byte	0
LR__5682
	byte	"e."
	byte	0
LR__5683
	byte	"fcircle"
	byte	0
LR__5684
	byte	"fc."
	byte	0
LR__5685
	byte	"fill"
	byte	0
LR__5686
	byte	"fi."
	byte	0
LR__5687
	byte	"font"
	byte	0
LR__5688
	byte	"for"
	byte	0
LR__5689
	byte	"f."
	byte	0
LR__5690
	byte	"frame"
	byte	0
LR__5691
	byte	"fr."
	byte	0
LR__5692
	byte	"get"
	byte	0
LR__5693
	byte	"gosub"
	byte	0
LR__5694
	byte	"goto"
	byte	0
LR__5695
	byte	"g."
	byte	0
LR__5696
	byte	"if"
	byte	0
LR__5697
	byte	"ink"
	byte	0
LR__5698
	byte	"i."
	byte	0
LR__5699
	byte	"input"
	byte	0
LR__5700
	byte	"list"
	byte	0
LR__5701
	byte	"l."
	byte	0
LR__5702
	byte	"load"
	byte	0
LR__5703
	byte	"lo."
	byte	0
LR__5704
	byte	"lpoke"
	byte	0
LR__5705
	byte	"mkdir"
	byte	0
LR__5706
	byte	"mode"
	byte	0
LR__5707
	byte	"m."
	byte	0
LR__5708
	byte	"mouse"
	byte	0
LR__5709
	byte	"new"
	byte	0
LR__5710
	byte	"next"
	byte	0
LR__5711
	byte	"n."
	byte	0
LR__5712
	byte	"on"
	byte	0
LR__5713
	byte	"open"
	byte	0
LR__5714
	byte	"paper"
	byte	0
LR__5715
	byte	"pa."
	byte	0
LR__5716
	byte	"pinfloat"
	byte	0
LR__5717
	byte	"pinhi"
	byte	0
LR__5718
	byte	"pinlo"
	byte	0
LR__5719
	byte	"pinstart"
	byte	0
LR__5720
	byte	"pintoggle"
	byte	0
LR__5721
	byte	"pinwrite"
	byte	0
LR__5722
	byte	"play"
	byte	0
LR__5723
	byte	"p."
	byte	0
LR__5724
	byte	"plot"
	byte	0
LR__5725
	byte	"pl."
	byte	0
LR__5726
	byte	"poke"
	byte	0
LR__5727
	byte	"pop"
	byte	0
LR__5728
	byte	"position"
	byte	0
LR__5729
	byte	"pos."
	byte	0
LR__5730
	byte	"print"
	byte	0
LR__5731
	byte	"?"
	byte	0
LR__5732
	byte	"put"
	byte	0
LR__5733
	byte	"rad"
	byte	0
LR__5734
	byte	"read"
	byte	0
LR__5735
	byte	"release"
	byte	0
LR__5736
	byte	"rem"
	byte	0
LR__5737
	byte	"'"
	byte	0
LR__5738
	byte	"restore"
	byte	0
LR__5739
	byte	"restorepalette"
	byte	0
LR__5740
	byte	"rp."
	byte	0
LR__5741
	byte	"return"
	byte	0
LR__5742
	byte	"run"
	byte	0
LR__5743
	byte	"r."
	byte	0
LR__5744
	byte	"save"
	byte	0
LR__5745
	byte	"s."
	byte	0
LR__5746
	byte	"setcolor"
	byte	0
LR__5747
	byte	"sc."
	byte	0
LR__5748
	byte	"setamode"
	byte	0
LR__5749
	byte	"sa."
	byte	0
LR__5750
	byte	"setdelay"
	byte	0
LR__5751
	byte	"sd."
	byte	0
LR__5752
	byte	"setenv"
	byte	0
LR__5753
	byte	"se."
	byte	0
LR__5754
	byte	"setlen"
	byte	0
LR__5755
	byte	"sl."
	byte	0
LR__5756
	byte	"setpan"
	byte	0
LR__5757
	byte	"sp."
	byte	0
LR__5758
	byte	"setsustain"
	byte	0
LR__5759
	byte	"ss."
	byte	0
LR__5760
	byte	"setvol"
	byte	0
LR__5761
	byte	"sv."
	byte	0
LR__5762
	byte	"setwave"
	byte	0
LR__5763
	byte	"sw."
	byte	0
LR__5764
	byte	"setwav"
	byte	0
LR__5765
	byte	"shutup"
	byte	0
LR__5766
	byte	"sh."
	byte	0
LR__5767
	byte	"sound"
	byte	0
LR__5768
	byte	"so."
	byte	0
LR__5769
	byte	"sprite"
	byte	0
LR__5770
	byte	"spr."
	byte	0
LR__5771
	byte	"then"
	byte	0
LR__5772
	byte	"waitms"
	byte	0
LR__5773
	byte	"w."
	byte	0
LR__5774
	byte	"waitclock"
	byte	0
LR__5775
	byte	"wc."
	byte	0
LR__5776
	byte	"waitvbl"
	byte	0
LR__5777
	byte	"wv."
	byte	0
LR__5778
	byte	"wrpin"
	byte	0
LR__5779
	byte	"wxpin"
	byte	0
LR__5780
	byte	"wypin"
	byte	0
LR__5781
	byte	"abs"
	byte	0
LR__5782
	byte	"acos"
	byte	0
LR__5783
	byte	"adr"
	byte	0
LR__5784
	byte	"addr"
	byte	0
LR__5785
	byte	"asc"
	byte	0
LR__5786
	byte	"asin"
	byte	0
LR__5787
	byte	"atn"
	byte	0
LR__5788
	byte	"bin$"
	byte	0
LR__5789
	byte	"chr$"
	byte	0
LR__5790
	byte	"coginit"
	byte	0
LR__5791
	byte	"cos"
	byte	0
LR__5792
	byte	"dpeek"
	byte	0
LR__5793
	byte	"findfirst"
	byte	0
LR__5794
	byte	"findnext"
	byte	0
LR__5795
	byte	"framebuf"
	byte	0
LR__5796
	byte	"fb."
	byte	0
LR__5797
	byte	"fre"
	byte	0
LR__5798
	byte	"gc."
	byte	0
LR__5799
	byte	"getcolor"
	byte	0
LR__5800
	byte	"getpixel"
	byte	0
LR__5801
	byte	"ge."
	byte	0
LR__5802
	byte	"getenvsustain"
	byte	0
LR__5803
	byte	"getnotevalue"
	byte	0
LR__5804
	byte	"getrealfreq"
	byte	0
LR__5805
	byte	"gettime"
	byte	0
LR__5806
	byte	"gt."
	byte	0
LR__5807
	byte	"hex$"
	byte	0
LR__5808
	byte	"inkey$"
	byte	0
LR__5809
	byte	"int"
	byte	0
LR__5810
	byte	"left$"
	byte	0
LR__5811
	byte	"len"
	byte	0
LR__5812
	byte	"log"
	byte	0
LR__5813
	byte	"lpeek"
	byte	0
LR__5814
	byte	"memtop"
	byte	0
LR__5815
	byte	"memlo"
	byte	0
LR__5816
	byte	"mid$"
	byte	0
LR__5817
	byte	"mousek"
	byte	0
LR__5818
	byte	"mousew"
	byte	0
LR__5819
	byte	"mousex"
	byte	0
LR__5820
	byte	"mousey"
	byte	0
LR__5821
	byte	"pads"
	byte	0
LR__5822
	byte	"padw"
	byte	0
LR__5823
	byte	"padx"
	byte	0
LR__5824
	byte	"pady"
	byte	0
LR__5825
	byte	"padz"
	byte	0
LR__5826
	byte	"padrx"
	byte	0
LR__5827
	byte	"padry"
	byte	0
LR__5828
	byte	"padrz"
	byte	0
LR__5829
	byte	"padh"
	byte	0
LR__5830
	byte	"peek"
	byte	0
LR__5831
	byte	"pinread"
	byte	0
LR__5832
	byte	"rdpin"
	byte	0
LR__5833
	byte	"right$"
	byte	0
LR__5834
	byte	"rqpin"
	byte	0
LR__5835
	byte	"round"
	byte	0
LR__5836
	byte	"rnd"
	byte	0
LR__5837
	byte	"sin"
	byte	0
LR__5838
	byte	"sqr"
	byte	0
LR__5839
	byte	"stick"
	byte	0
LR__5840
	byte	"strig"
	byte	0
LR__5841
	byte	"str$"
	byte	0
LR__5842
	byte	"tan"
	byte	0
LR__5843
	byte	"val"
	byte	0
LR__5844
	byte	"varptr"
	byte	0
LR__5845
	byte	"a"
	byte	0
LR__5846
	byte	"z"
	byte	0
LR__5847
	byte	"_"
	byte	0
LR__5848
	byte	"a"
	byte	0
LR__5849
	byte	"z"
	byte	0
LR__5850
	byte	"0"
	byte	0
LR__5851
	byte	"9"
	byte	0
LR__5852
	byte	"_"
	byte	0
LR__5853
	byte	"."
	byte	0
LR__5854
	byte	"a"
	byte	0
LR__5855
	byte	"z"
	byte	0
LR__5856
	byte	"0"
	byte	0
LR__5857
	byte	"9"
	byte	0
LR__5858
	byte	"_"
	byte	0
LR__5859
	byte	"$"
	byte	0
LR__5860
	byte	"%"
	byte	0
LR__5861
	byte	"!"
	byte	0
LR__5862
	byte	"0"
	byte	0
LR__5863
	byte	"9"
	byte	0
LR__5864
	byte	"."
	byte	0
LR__5865
	byte	"$"
	byte	0
LR__5866
	byte	"%"
	byte	0
LR__5867
	byte	"-"
	byte	0
LR__5868
	byte	"."
	byte	0
LR__5869
	byte	"$"
	byte	0
LR__5870
	byte	"%"
	byte	0
LR__5871
	byte	"0"
	byte	0
LR__5872
	byte	"9"
	byte	0
LR__5873
	byte	"_"
	byte	0
LR__5874
	byte	"."
	byte	0
LR__5875
	byte	"E"
	byte	0
LR__5876
	byte	"e"
	byte	0
LR__5877
	byte	"-"
	byte	0
LR__5878
	byte	"a"
	byte	0
LR__5879
	byte	"f"
	byte	0
LR__5880
	byte	"0"
	byte	0
LR__5881
	byte	"1"
	byte	0
LR__5882
	byte	"_"
	byte	0
LR__5883
	byte	"-"
	byte	0
LR__5884
	byte	"e"
	byte	0
LR__5885
	byte	"."
	byte	0
LR__5886
	byte	"E"
	byte	0
LR__5887
	byte	"e"
	byte	0
LR__5888
	byte	"0"
	byte	0
LR__5889
	byte	"9"
	byte	0
LR__5890
	byte	"$"
	byte	0
LR__5891
	byte	"%"
	byte	0
LR__5892
	byte	"-"
	byte	0
LR__5893
	byte	"$"
	byte	0
LR__5894
	byte	"%"
	byte	0
LR__5895
	byte	"0"
	byte	0
LR__5896
	byte	"9"
	byte	0
LR__5897
	byte	"_"
	byte	0
LR__5898
	byte	"0"
	byte	0
LR__5899
	byte	"9"
	byte	0
LR__5900
	byte	"a"
	byte	0
LR__5901
	byte	"f"
	byte	0
LR__5902
	byte	"_"
	byte	0
LR__5903
	byte	"0"
	byte	0
LR__5904
	byte	"1"
	byte	0
LR__5905
	byte	"_"
	byte	0
LR__5906
	byte	"0"
	byte	0
LR__5907
	byte	"9"
	byte	0
LR__5908
	byte	"_"
	byte	0
LR__5909
	byte	34
	byte	0
LR__5910
	byte	34
	byte	0
LR__5911
	byte	"Dim: at line "
	byte	0
LR__5912
	byte	": warning: the variable existed."
	byte	0
LR__5913
	byte	"("
	byte	0
LR__5914
	byte	"as"
	byte	0
LR__5915
	byte	"as"
	byte	0
LR__5916
	byte	","
	byte	0
LR__5917
	byte	")"
	byte	0
LR__5918
	byte	")"
	byte	0
LR__5919
	byte	"as"
	byte	0
LR__5920
	byte	"byte"
	byte	0
LR__5921
	byte	"ubyte"
	byte	0
LR__5922
	byte	"short"
	byte	0
LR__5923
	byte	"ushort"
	byte	0
LR__5924
	byte	"long"
	byte	0
LR__5925
	byte	"integer"
	byte	0
LR__5926
	byte	"ulong"
	byte	0
LR__5927
	byte	"int64"
	byte	0
LR__5928
	byte	"uint64"
	byte	0
LR__5929
	byte	"single"
	byte	0
LR__5930
	byte	"double"
	byte	0
LR__5931
	byte	"string"
	byte	0
LR__5932
	byte	"to"
	byte	0
LR__5933
	byte	"step"
	byte	0
LR__5934
	byte	"s."
	byte	0
LR__5935
	byte	"s."
	byte	0
LR__5936
	byte	"goto"
	byte	0
LR__5937
	byte	"gosub"
	byte	0
LR__5938
	byte	"$"
	byte	0
LR__5939
	byte	"&h"
	byte	0
LR__5940
	byte	"%"
	byte	0
LR__5941
	byte	"&b"
	byte	0
LR__5942
	byte	
	byte	0
LR__5943
	byte	"acos: "
	byte	0
LR__5944
	byte	"asc: "
	byte	0
LR__5945
	byte	"asc: "
	byte	0
LR__5946
	byte	"asin: "
	byte	0
LR__5947
	byte	"atn: "
	byte	0
LR__5948
	byte	"blit: "
	byte	0
LR__5949
	byte	"bin$: "
	byte	0
LR__5950
	byte	"/"
	byte	0
LR__5951
	byte	"/sd/bin/"
	byte	0
LR__5952
	byte	"System error "
	byte	0
LR__5953
	byte	": "
	byte	0
LR__5954
	byte	"*"
	byte	0
LR__5955
	byte	".."
	byte	0
LR__5956
	byte	"/"
	byte	0
LR__5957
	byte	"/"
	byte	0
LR__5958
	byte	"System error "
	byte	0
LR__5959
	byte	": "
	byte	0
LR__5960
	byte	"Current directory: "
	byte	0
LR__5961
	byte	"/"
	byte	0
LR__5962
	byte	"System error "
	byte	0
LR__5963
	byte	": "
	byte	0
LR__5964
	byte	"Current directory: "
	byte	0
LR__5965
	byte	"/"
	byte	0
LR__5966
	byte	"/"
	byte	0
LR__5967
	byte	"/"
	byte	0
LR__5968
	byte	"System error "
	byte	0
LR__5969
	byte	": "
	byte	0
LR__5970
	byte	"Current directory: "
	byte	0
LR__5971
	byte	"chr$: "
	byte	0
LR__5972
	byte	"channel# expected"
	byte	0
LR__5973
	byte	"coginit: "
	byte	0
LR__5974
	byte	"System error - "
	byte	0
LR__5975
	byte	" in line "
	byte	0
LR__5976
	byte	": "
	byte	0
LR__5977
	byte	", file name: "
	byte	0
LR__5978
	byte	"System error - "
	byte	0
LR__5979
	byte	" in line "
	byte	0
LR__5980
	byte	": "
	byte	0
LR__5981
	byte	", file name: "
	byte	0
LR__5982
	byte	"cos: "
	byte	0
LR__5983
	byte	
	byte	0
LR__5984
	byte	
	byte	0
LR__5985
	byte	"/sd/media/h/"
	byte	0
LR__5986
	byte	"System error "
	byte	0
LR__5987
	byte	": "
	byte	0
LR__5988
	byte	
	byte	0
LR__5989
	byte	
	byte	0
LR__5990
	byte	"/sd/media/s/"
	byte	0
LR__5991
	byte	"System error "
	byte	0
LR__5992
	byte	": "
	byte	0
LR__5993
	byte	"/"
	byte	0
LR__5994
	byte	"/"
	byte	0
LR__5995
	byte	"/"
	byte	0
LR__5996
	byte	"Cannot delete file or file doesn't exist: system error "
	byte	0
LR__5997
	byte	"Current directory: "
	byte	0
LR__5998
	byte	
	byte	0
LR__5999
	byte	"*"
	byte	0
LR__6000
	byte	
	byte	0
LR__6001
	byte	"[dir] "
	byte	0
LR__6002
	byte	"More than 128 entries found: clean your directory"
	byte	0
LR__6003
	byte	"*"
	byte	0
LR__6004
	byte	
	byte	0
LR__6005
	byte	"More than 128 entries found: clean your directory"
	byte	0
LR__6006
	byte	"Error "
	byte	0
LR__6007
	byte	": "
	byte	0
LR__6008
	byte	"findfirst: "
	byte	0
LR__6009
	byte	"findfirst: "
	byte	0
LR__6010
	byte	"findfirst: "
	byte	0
LR__6011
	byte	
	byte	0
LR__6012
	byte	"findfirst: "
	byte	0
LR__6013
	byte	
	byte	0
LR__6014
	byte	"dir"
	byte	0
LR__6015
	byte	"findnext: "
	byte	0
LR__6016
	byte	"getcolor "
	byte	0
LR__6017
	byte	"getenvsustain: "
	byte	0
LR__6018
	byte	"getpixel: "
	byte	0
LR__6019
	byte	"getrealfreq: "
	byte	0
LR__6020
	byte	"hex$: "
	byte	0
LR__6021
	byte	
	byte	0
LR__6022
	byte	"In input: "
	byte	0
LR__6023
	byte	","
	byte	0
LR__6024
	byte	
	byte	0
LR__6025
	byte	
	byte	0
LR__6026
	byte	"left$: "
	byte	0
LR__6027
	byte	"left$: "
	byte	0
LR__6028
	byte	"len: "
	byte	0
LR__6029
	byte	"len: "
	byte	0
LR__6030
	byte	
	byte	0
LR__6031
	byte	"/"
	byte	0
LR__6032
	byte	"/"
	byte	0
LR__6033
	byte	".bas"
	byte	0
LR__6034
	byte	"System error "
	byte	0
LR__6035
	byte	": "
	byte	0
LR__6036
	byte	".bas"
	byte	0
LR__6037
	byte	"/"
	byte	0
LR__6038
	byte	
	byte	0
LR__6039
	byte	"Loaded "
	byte	0
LR__6040
	byte	"/"
	byte	0
LR__6041
	byte	"log: "
	byte	0
LR__6042
	byte	"mid$: "
	byte	0
LR__6043
	byte	"mid$: "
	byte	0
LR__6044
	byte	"Cannot create a directory: system error "
	byte	0
LR__6045
	byte	" BASIC bytes free"
	byte	0
LR__6046
	byte	
	byte	0
LR__6047
	byte	
	byte	0
LR__6048
	byte	
	byte	0
LR__6049
	byte	"noname.bas"
	byte	0
LR__6050
	byte	"filename expected"
	byte	0
LR__6051
	byte	"read"
	byte	0
LR__6052
	byte	"write"
	byte	0
LR__6053
	byte	"append"
	byte	0
LR__6054
	byte	"channel# expected"
	byte	0
LR__6055
	byte	"Open: invalid mode"
	byte	0
LR__6056
	byte	"padrx: "
	byte	0
LR__6057
	byte	"padry: "
	byte	0
LR__6058
	byte	"padrz: "
	byte	0
LR__6059
	byte	"pads: "
	byte	0
LR__6060
	byte	"padw: "
	byte	0
LR__6061
	byte	"padx: "
	byte	0
LR__6062
	byte	"pady: "
	byte	0
LR__6063
	byte	"padz: "
	byte	0
LR__6064
	byte	"Print to channel (not yet implemented)"
	byte	0
LR__6065
	byte	
	byte	0
LR__6066
	byte	"data"
	byte	0
LR__6067
	byte	
	byte	0
LR__6068
	byte	"In read: "
	byte	0
LR__6069
	byte	
	byte	0
LR__6070
	byte	
	byte	0
LR__6071
	byte	"'"
	byte	0
LR__6072
	byte	","
	byte	0
LR__6073
	byte	
	byte	0
LR__6074
	byte	
	byte	0
LR__6075
	byte	
	byte	0
LR__6076
	byte	
	byte	0
LR__6077
	byte	
	byte	0
LR__6078
	byte	"right$: "
	byte	0
LR__6079
	byte	"right$: "
	byte	0
LR__6080
	byte	"rnd: "
	byte	0
LR__6081
	byte	"rnd: "
	byte	0
LR__6082
	byte	
	byte	0
LR__6083
	byte	"Stopped at line "
	byte	0
LR__6084
	byte	
	byte	0
LR__6085
	byte	"/"
	byte	0
LR__6086
	byte	
	byte	0
LR__6087
	byte	"Saved as "
	byte	0
LR__6088
	byte	"/"
	byte	0
LR__6089
	byte	"setcolor: "
	byte	0
LR__6090
	byte	"sin: "
	byte	0
LR__6091
	byte	"sqr: "
	byte	0
LR__6092
	byte	"stick: "
	byte	0
LR__6093
	byte	"str$: "
	byte	0
LR__6094
	byte	"strig: "
	byte	0
LR__6095
	byte	"tan: "
	byte	0
LR__6096
	byte	"val: "
	byte	0
LR__6097
	byte	"val: "
	byte	0
LR__6098
	byte	"$"
	byte	0
LR__6099
	byte	"&h"
	byte	0
LR__6100
	byte	"%"
	byte	0
LR__6101
	byte	"&b"
	byte	0
LR__6102
	byte	
	byte	0
LR__6103
	byte	"Expected number, got something else"
	byte	0
LR__6104
	byte	"Cannot add a number to a string"
	byte	0
LR__6105
	byte	"Cannot substract strings"
	byte	0
LR__6106
	byte	"Unknown error while adding"
	byte	0
LR__6107
	byte	"Unknown error while substracting"
	byte	0
LR__6108
	byte	"Cannot do logic operation on string or float"
	byte	0
LR__6109
	byte	"Unknown error while doing logic operation"
	byte	0
LR__6110
	byte	"Cannot multiply strings"
	byte	0
LR__6111
	byte	"Unknown error while multiplying"
	byte	0
LR__6112
	byte	"Cannot divide strings"
	byte	0
LR__6113
	byte	"Unknown error while dividing"
	byte	0
LR__6114
	byte	"Cannot compute a power of a string"
	byte	0
LR__6115
	byte	"Unknown error while computing a power"
	byte	0
LR__6116
	byte	"Right parenthesis expected"
	byte	0
LR__6117
	byte	"Expected string"
	byte	0
LR__6118
	byte	"Expected float"
	byte	0
LR__6119
	byte	"Expected unsigned integer"
	byte	0
LR__6120
	byte	"Expected integer"
	byte	0
LR__6121
	byte	"No more variable slots"
	byte	0
LR__6122
	byte	"Variable not found"
	byte	0
LR__6123
	byte	"Comma expected"
	byte	0
LR__6124
	byte	"Comma or semicolon expected"
	byte	0
LR__6125
	byte	"Unknown command"
	byte	0
LR__6126
	byte	"Stack underflow"
	byte	0
LR__6127
	byte	"Cannot execute goto or gosub in the immediate mode"
	byte	0
LR__6128
	byte	"Cannot load from this file"
	byte	0
LR__6129
	byte	"The program is empty"
	byte	0
LR__6130
	byte	"If after if"
	byte	0
LR__6131
	byte	"Empty expression"
	byte	0
LR__6132
	byte	"String expected"
	byte	0
LR__6133
	byte	"Interpreter internal error"
	byte	0
LR__6134
	byte	"Expected assign"
	byte	0
LR__6135
	byte	"Expected 'to'"
	byte	0
LR__6136
	byte	"Expected integer variable"
	byte	0
LR__6137
	byte	"Uninitialized variable in 'next', use 'for' before"
	byte	0
LR__6138
	byte	"No more slots for 'for'"
	byte	0
LR__6139
	byte	"'Next' doesn't match 'for'"
	byte	0
LR__6140
	byte	"'Goto' target line not found"
	byte	0
LR__6141
	byte	"Bad number of parameters"
	byte	0
LR__6142
	byte	"Function undefined for strings"
	byte	0
LR__6143
	byte	"Bad parameter"
	byte	0
LR__6144
	byte	"Cannot declare an array: the variable exists"
	byte	0
LR__6145
	byte	"Expected '('"
	byte	0
LR__6146
	byte	"Expected ')' or ','"
	byte	0
LR__6147
	byte	"No more than 3 dimensions supported"
	byte	0
LR__6148
	byte	"Variable name expected"
	byte	0
LR__6149
	byte	"Type name expected"
	byte	0
LR__6150
	byte	"Type not supported yet"
	byte	0
LR__6151
	byte	"Array index out of range"
	byte	0
LR__6152
	byte	"Bad type while assigning to array"
	byte	0
LR__6153
	byte	"Too many variables"
	byte	0
LR__6154
	byte	"'Then' expected"
	byte	0
LR__6155
	byte	"Directory doesn't exist"
	byte	0
LR__6156
	byte	"Unexpected end of line"
	byte	0
LR__6157
	byte	"No more data"
	byte	0
LR__6158
	byte	"Error "
	byte	0
LR__6159
	byte	" - "
	byte	0
LR__6160
	byte	" in line "
	byte	0
LR__6161
	byte	
	byte	0
LR__6162
	byte	"/sd"
	byte	0
LR__6163
	byte	"/sd/bas"
	byte	0
LR__6164
	byte	"/sd/bas"
	byte	0
LR__6165
	byte	" BASIC bytes free"
	byte	0
LR__6166
	byte	"Ready"
	byte	0
LR__6167
	byte	"noname.bas"
	byte	0
LR__6168
	byte	"/sd/bas/autorun.bas"
	byte	0
LR__6169
	byte	"run autorun.bas"
	byte	0
LR__6170
	byte	
	byte	0
	alignl
_dat_
	byte	$00[16]
	byte	$61, $41, $17, $0e, $62, $42, $00, $00, $63, $43, $19, $10, $64, $44, $00, $00
	byte	$65, $45, $18, $0f, $66, $46, $00, $00, $67, $47, $00, $00, $68, $48, $00, $00
	byte	$69, $49, $00, $00, $6a, $4a, $00, $00, $6b, $4b, $00, $00, $6c, $4c, $1f, $16
	byte	$6d, $4d, $00, $00, $6e, $4e, $1a, $11, $6f, $4f, $1e, $15, $70, $50, $00, $00
	byte	$71, $51, $00, $00, $72, $52, $00, $00, $73, $53, $1b, $12, $74, $54, $00, $00
	byte	$75, $55, $00, $00, $76, $56, $00, $00, $77, $57, $00, $00, $78, $58, $1c, $13
	byte	$79, $59, $00, $00, $7a, $5a, $1d, $14, $31, $21, $04, $00, $32, $40, $05, $00
	byte	$33, $23, $06, $00, $34, $24, $07, $00, $35, $25, $08, $00, $36, $5e, $09, $00
	byte	$37, $26, $0a, $00, $38, $2a, $0b, $00, $39, $28, $0c, $00, $30, $29, $0d, $00
	byte	$8d, $8d, $00, $00, $9b, $9b, $00, $00, $88, $88, $00, $00, $89, $89, $00, $00
	byte	$20, $20, $00, $00, $2d, $5f, $00, $00, $3d, $2b, $00, $00, $5b, $7b, $00, $00
	byte	$5d, $7d, $00, $00, $5c, $7c, $00, $00, $23, $7e, $00, $00, $3b, $3a, $00, $00
	byte	$27, $22, $00, $00, $60, $7e, $03, $00, $2c, $3c, $00, $00, $2e, $3e, $00, $00
	byte	$2f, $3f, $00, $00, $b9, $b9, $00, $00, $ba, $00, $00, $00, $bb, $00, $00, $00
	byte	$bc, $00, $00, $00, $bd, $00, $00, $00, $be, $00, $00, $00, $bf, $00, $00, $00
	byte	$c0, $00, $00, $00, $c1, $00, $00, $00, $c2, $00, $00, $00, $c3, $00, $00, $00
	byte	$c4, $00, $00, $00, $c5, $00, $00, $00, $c6, $00, $00, $00, $c7, $00, $00, $00
	byte	$c8, $00, $00, $00, $c9, $00, $00, $00, $ca, $00, $00, $00, $cb, $00, $00, $00
	byte	$7f, $7f, $00, $00, $cc, $00, $00, $00, $cd, $00, $00, $00, $ce, $00, $00, $00
	byte	$cf, $00, $00, $00, $d0, $00, $00, $00, $d1, $00, $00, $00, $d2, $00, $00, $00
	byte	$2f, $2f, $00, $00, $2a, $2a, $00, $00, $2d, $2d, $00, $00, $2b, $2b, $00, $00
	byte	$8d, $8d, $00, $00, $31, $31, $00, $00, $32, $32, $00, $00, $33, $33, $00, $00
	byte	$34, $34, $00, $00, $35, $35, $00, $00, $36, $36, $00, $00, $37, $37, $00, $00
	byte	$38, $38, $00, $00, $39, $39, $00, $00, $30, $30, $00, $00, $2e, $7f, $00, $00
	byte	$5c, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3d, $3d, $00, $00
	byte	$00[96]
'-' atari_spl file "atari.spl"
	byte	$2b, $00, $a6, $f2, $24, $a7, $09, $80, $5b, $88, $4d, $89, $80, $88, $a5, $88
	byte	$6d, $88, $b8, $88, $80, $88, $cb, $88, $92, $88, $a5, $88, $a5, $88, $b8, $88
	byte	$a5, $88, $ca, $88, $a6, $88, $dd, $88, $b8, $88, $ab, $89, $42, $87, $32, $84
	byte	$c8, $ad, $c6, $f1, $91, $06, $b6, $ff, $13, $00, $4a, $00, $71, $00, $5e, $00
	byte	$5d, $00, $5e, $00, $5d, $00, $5e, $00, $5e, $00, $5d, $00, $5e, $00, $71, $00
	byte	$38, $00, $83, $00, $25, $00, $83, $00, $c3, $fe, $d1, $04, $96, $00, $27, $c3
	byte	$48, $88, $38, $85, $41, $8a, $cb, $88, $28, $89, $b8, $88, $28, $89, $f0, $88
	byte	$15, $89, $03, $89, $02, $89, $15, $89, $16, $89, $15, $89, $15, $89, $28, $89
	byte	$15, $89, $3a, $89, $72, $89, $e3, $89, $52, $83, $ad, $97, $c3, $dc, $a3, $06
	byte	$0c, $02, $b6, $ff, $e1, $00, $a8, $00, $f3, $00, $a8, $00, $e0, $00, $bb, $00
	byte	$ce, $00, $cd, $00, $cd, $00, $ba, $00, $e1, $00, $bb, $00, $f2, $00, $a8, $00
	byte	$df, $00, $c9, $ff, $e6, $01, $b6, $06, $ee, $dd, $8d, $98, $53, $83, $f5, $89
	byte	$97, $89, $73, $89, $3b, $89, $60, $89, $60, $89, $60, $89, $73, $89, $72, $89
	byte	$73, $89, $72, $89, $85, $89, $73, $89, $aa, $89, $60, $89, $bd, $89, $72, $89
	byte	$e8, $8a, $18, $86, $92, $88, $a5, $c2, $e0, $00, $c3, $05, $7d, $ff, $50, $01
	byte	$f2, $00, $64, $01, $06, $01, $3e, $01, $2b, $01, $2b, $01, $2b, $01, $2b, $01
	byte	$2b, $01, $2a, $01, $2b, $01, $2b, $01, $2b, $01, $18, $01, $cd, $00, $5d, $00
	byte	$39, $07, $61, $f3, $c0, $af, $37, $85, $0f, $88, $8b, $8a, $ab, $89, $d0, $89
	byte	$ab, $89, $d0, $89, $ab, $89, $d0, $89, $d0, $89, $cf, $89, $d0, $89, $e3, $89
	byte	$d0, $89, $f5, $89, $bd, $89, $08, $8a, $cf, $89, $e8, $8a, $5a, $88, $82, $85
	byte	$53, $b3, $0d, $f8, $f4, $07, $38, $00, $63, $01, $63, $01, $9a, $01, $75, $01
	byte	$88, $01, $88, $01, $76, $01, $88, $01, $88, $01, $89, $01, $89, $01, $88, $01
	byte	$75, $01, $ae, $01, $76, $01, $88, $01, $4a, $00, $46, $06, $d0, $fd, $bf, $c0
	byte	$08, $8a, $9a, $86, $33, $8b, $08, $8a, $2d, $8a, $f5, $89, $2e, $8a, $08, $8a
	byte	$2d, $8a, $2d, $8a, $2e, $8a, $1b, $8a, $40, $8a, $2d, $8a, $53, $8a, $40, $8a
	byte	$2e, $8a, $79, $8a, $66, $8a, $c8, $8b, $72, $82, $2b, $97, $9a, $e2, $49, $0a
	byte	$1d, $02, $05, $01, $f8, $01, $c0, $01, $0b, $02, $c0, $01, $0b, $02, $d3, $01
	byte	$f9, $01, $d3, $01, $f8, $01, $d3, $01, $f8, $01, $d2, $01, $f8, $01, $d2, $01
	byte	$e6, $01, $2b, $01, $8e, $02, $5f, $07, $f7, $e2, $ed, $9c, $9c, $83, $d6, $8a
	byte	$e8, $8a, $78, $8a, $78, $8a, $65, $8a, $8b, $8a, $78, $8a, $9e, $8a, $8b, $8a
	byte	$8b, $8a, $9d, $8a, $9d, $8a, $8b, $8a, $c2, $8a, $78, $8a, $e8, $8a, $78, $8a
	byte	$70, $8c, $18, $86, $8b, $8a, $23, $c9, $cb, $03, $c4, $05, $e0, $00, $68, $02
	byte	$0b, $02, $7b, $02, $1e, $02, $55, $02, $30, $02, $43, $02, $43, $02, $43, $02
	byte	$43, $02, $44, $02, $43, $02, $30, $02, $68, $02, $31, $02, $31, $02, $3e, $01
	byte	$07, $08, $3f, $f7, $73, $b2, $13, $85, $15, $89, $ed, $8b, $9d, $8a, $fb, $8a
	byte	$b0, $8a, $fb, $8a, $d5, $8a, $fa, $8a, $e8, $8a, $fb, $8a, $fb, $8a, $0e, $8b
	byte	$e8, $8a, $21, $8b, $e7, $8a, $33, $8b, $e8, $8a, $26, $8c, $be, $89, $ff, $84
	byte	$8d, $b0, $27, $f6, $9c, $08, $ad, $01, $7b, $02, $8d, $02, $c6, $02, $8e, $02
	byte	$a1, $02, $a0, $02, $a1, $02, $a0, $02, $a0, $02, $a0, $02, $8e, $02, $b4, $02
	byte	$7b, $02, $d8, $02, $7b, $02, $c6, $02, $3e, $01, $c3, $05, $f6, $04, $0f, $cc
	byte	$00, $8c, $2a, $86, $e0, $8c, $fa, $8a, $6a, $8b, $fb, $8a, $58, $8b, $33, $8b
	byte	$45, $8b, $45, $8b, $45, $8b, $6b, $8b, $46, $8b, $59, $8b, $58, $8b, $6b, $8b
	byte	$6b, $8b, $6b, $8b, $6b, $8b, $6b, $8b, $7d, $8b, $7d, $8b, $7d, $8b, $7d, $8b
	byte	$90, $8b, $91, $8b, $90, $8b, $90, $8b, $a3, $8b, $a3, $8b, $a3, $8b, $a3, $8b
	byte	$b5, $8b, $b6, $8b, $b5, $8b, $b5, $8b, $b6, $8b, $c8, $8b, $c9, $8b, $c8, $8b
	byte	$c8, $8b, $da, $8b, $db, $8b, $db, $8b, $db, $8b, $dc, $8b, $ee, $8b, $ee, $8b
	byte	$ee, $8b, $ee, $8b, $00, $8c, $01, $8c, $00, $8c, $01, $8c, $00, $8c, $13, $8c
	byte	$12, $8c, $13, $8c, $13, $8c, $26, $8c, $26, $8c, $26, $8c, $26, $8c, $39, $8c
	byte	$38, $8c, $38, $8c, $38, $8c, $38, $8c, $4b, $8c, $4b, $8c, $4b, $8c, $4c, $8c
	byte	$5e, $8c, $5e, $8c, $5e, $8c, $5e, $8c, $70, $8c, $70, $8c, $71, $8c, $70, $8c
	byte	$70, $8c, $83, $8c, $83, $8c, $83, $8c, $83, $8c, $96, $8c, $95, $8c, $96, $8c
	byte	$95, $8c, $a9, $8c, $a9, $8c, $a8, $8c, $a8, $8c, $a8, $8c, $bb, $8c, $bb, $8c
	byte	$bb, $8c, $bb, $8c, $bb, $8c, $ce, $8c, $ce, $8c, $ce, $8c, $ce, $8c, $e0, $8c
	byte	$e0, $8c, $e1, $8c, $e1, $8c, $e0, $8c, $f4, $8c, $f2, $8c, $f2, $8c, $f3, $8c
	byte	$05, $8d, $05, $8d, $06, $8d, $06, $8d, $19, $8d, $19, $8d, $18, $8d, $18, $8d
	byte	$18, $8d, $2b, $8d, $2b, $8d, $2b, $8d, $2a, $8d, $3e, $8d, $3e, $8d, $3f, $8d
	byte	$3e, $8d, $51, $8d, $50, $8d, $50, $8d, $50, $8d, $51, $8d, $62, $8d, $62, $8d
	byte	$63, $8d, $64, $8d, $76, $8d, $75, $8d, $75, $8d, $76, $8d, $89, $8d, $89, $8d
	byte	$88, $8d, $88, $8d, $89, $8d, $9b, $8d, $9a, $8d, $9b, $8d, $9b, $8d, $af, $8d
	byte	$ad, $8d, $ae, $8d, $ad, $8d, $ae, $8d, $c1, $8d, $c1, $8d, $c0, $8d, $c1, $8d
	byte	$d3, $8d, $d3, $8d, $d3, $8d, $d3, $8d, $d3, $8d, $e6, $8d, $e6, $8d, $e6, $8d
	byte	$e6, $8d, $e6, $8d, $f9, $8d, $f9, $8d, $f9, $8d, $f8, $8d, $0b, $8e, $0b, $8e
	byte	$0b, $8e, $0b, $8e, $1d, $8e, $1d, $8e, $1e, $8e, $1e, $8e, $1e, $8e, $30, $8e
	byte	$31, $8e, $31, $8e, $31, $8e, $42, $8e, $43, $8e, $43, $8e, $43, $8e, $43, $8e
	byte	$56, $8e, $56, $8e, $55, $8e, $56, $8e, $68, $8e, $69, $8e, $68, $8e, $68, $8e
	byte	$69, $8e, $7b, $8e, $7c, $8e, $7b, $8e, $7b, $8e, $8d, $8e, $8e, $8e, $8e, $8e
	byte	$8d, $8e, $a1, $8e, $a0, $8e, $a1, $8e, $a1, $8e, $a0, $8e, $b3, $8e, $b3, $8e
	byte	$b3, $8e, $b3, $8e, $c6, $8e, $c5, $8e, $c6, $8e, $c6, $8e, $c6, $8e, $d8, $8e
	byte	$d8, $8e, $d9, $8e, $d8, $8e, $ec, $8e, $eb, $8e, $ec, $8e, $eb, $8e, $eb, $8e
	byte	$fe, $8e, $fe, $8e, $fe, $8e, $fe, $8e, $10, $8f, $10, $8f, $11, $8f, $11, $8f
	byte	$11, $8f, $23, $8f, $24, $8f, $23, $8f, $24, $8f, $37, $8f, $37, $8f, $36, $8f
	byte	$36, $8f, $36, $8f, $48, $8f, $49, $8f, $49, $8f, $49, $8f, $5b, $8f, $5b, $8f
	byte	$5b, $8f, $5c, $8f, $5b, $8f, $6e, $8f, $6e, $8f, $6e, $8f, $6e, $8f, $6e, $8f
	byte	$81, $8f, $81, $8f, $81, $8f, $81, $8f, $93, $8f, $93, $8f, $94, $8f, $93, $8f
	byte	$93, $8f, $a6, $8f, $a6, $8f, $a6, $8f, $a6, $8f, $b9, $8f, $b9, $8f, $b9, $8f
	byte	$b9, $8f, $b9, $8f, $cc, $8f, $cb, $8f, $cb, $8f, $cc, $8f, $de, $8f, $de, $8f
	byte	$df, $8f, $de, $8f, $de, $8f, $f1, $8f, $f1, $8f, $f1, $8f, $f0, $8f, $04, $90
	byte	$03, $90, $04, $90, $04, $90, $04, $90, $16, $90, $17, $90, $16, $90, $16, $90
	byte	$29, $90, $28, $90, $29, $90, $28, $90, $29, $90, $3c, $90, $3c, $90, $3b, $90
	byte	$3c, $90, $4f, $90, $4e, $90, $4e, $90, $4e, $90, $4e, $90, $61, $90, $60, $90
	byte	$61, $90, $61, $90, $73, $90, $74, $90, $74, $90, $74, $90, $74, $90, $86, $90
	byte	$87, $90, $86, $90, $87, $90, $86, $90, $99, $90, $99, $90, $99, $90, $99, $90
	byte	$ab, $90, $ab, $90, $ac, $90, $ab, $90, $ab, $90, $bf, $90, $be, $90, $be, $90
	byte	$be, $90, $d1, $90, $d0, $90, $d1, $90, $d1, $90, $d1, $90, $e3, $90, $e3, $90
	byte	$e3, $90, $e4, $90, $f6, $90, $f6, $90, $f6, $90, $f6, $90, $f6, $90, $08, $91
	byte	$09, $91, $0a, $91, $0a, $91, $1c, $91, $1c, $91, $1c, $91, $1b, $91, $1c, $91
	byte	$2f, $91, $2e, $91, $2f, $91, $2f, $91, $2e, $91, $41, $91, $41, $91, $41, $91
	byte	$41, $91, $53, $91, $54, $91, $54, $91, $53, $91, $54, $91, $67, $91, $66, $91
	byte	$67, $91, $67, $91, $79, $91, $7a, $91, $79, $91, $78, $91, $7a, $91, $8b, $91
	byte	$8c, $91, $8b, $91, $8c, $91, $8c, $91, $9e, $91, $9e, $91, $9e, $91, $9e, $91
	byte	$b1, $91, $b1, $91, $b2, $91, $b1, $91, $b1, $91, $c4, $91, $c4, $91, $c5, $91
	byte	$c4, $91, $d6, $91, $d7, $91, $d7, $91, $d7, $91, $d6, $91, $e9, $91, $ea, $91
	byte	$ea, $91, $ea, $91, $ea, $91, $fc, $91, $fc, $91, $fb, $91, $fc, $91, $0e, $92
	byte	$0e, $92, $0f, $92, $0f, $92, $0e, $92, $21, $92, $21, $92, $22, $92, $21, $92
	byte	$21, $92, $34, $92, $33, $92, $34, $92, $34, $92, $47, $92, $47, $92, $46, $92
	byte	$46, $92, $47, $92, $59, $92, $59, $92, $59, $92, $59, $92, $59, $92, $6c, $92
	byte	$6c, $92, $6c, $92, $6b, $92, $7e, $92, $7e, $92, $7e, $92, $7f, $92, $7e, $92
	byte	$92, $92, $91, $92, $91, $92, $90, $92, $91, $92, $a4, $92, $a4, $92, $a4, $92
	byte	$a3, $92, $b6, $92, $b6, $92, $b7, $92, $b7, $92, $b6, $92, $c9, $92, $c9, $92
	byte	$ca, $92, $c9, $92, $ca, $92, $dc, $92, $dc, $92, $dc, $92, $db, $92, $ee, $92
	byte	$ef, $92, $ef, $92, $ef, $92, $ef, $92, $01, $93, $01, $93, $01, $93, $02, $93
	byte	$15, $93, $14, $93, $14, $93, $14, $93, $14, $93, $27, $93, $26, $93, $27, $93
	byte	$27, $93, $39, $93, $3a, $93, $39, $93, $39, $93, $39, $93, $4c, $93, $4c, $93
	byte	$4b, $93, $4c, $93, $5f, $93, $5f, $93, $5f, $93, $5e, $93, $5e, $93, $71, $93
	byte	$5f, $93, $84, $93, $4c, $93, $96, $93, $5f, $93, $ae, $94, $e4, $90, $29, $90
	byte	$7b, $c1, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
'-' atari2_spl file "atari2.spl" '1758
	byte	$7a, $d7, $00, $80, $87, $8a, $48, $8f, $ec, $8c, $76, $8d, $f2, $8c, $c0, $8d
	byte	$3c, $8d, $82, $8d, $42, $8d, $88, $8d, $8c, $8d, $8e, $8d, $92, $8d, $d8, $8d
	byte	$97, $8d, $de, $8d, $e1, $8d, $f1, $8e, $d8, $8c, $a3, $83, $45, $c0, $be, $3d
	byte	$65, $71, $c9, $65, $fc, $64, $c4, $65, $c1, $65, $bf, $65, $bc, $65, $fc, $65
	byte	$b6, $65, $b4, $65, $b2, $65, $ae, $65, $ac, $65, $ed, $65, $64, $65, $e7, $65
	byte	$5e, $65, $25, $66, $fa, $62, $23, $6b, $b5, $6c, $61, $0a, $d2, $94, $04, $85
	byte	$5d, $90, $be, $8d, $47, $8e, $c3, $8d, $09, $8e, $c9, $8d, $10, $8e, $13, $8e
	byte	$15, $8e, $19, $8e, $1b, $8e, $62, $8e, $64, $8e, $68, $8e, $28, $8e, $b2, $8e
	byte	$b5, $8e, $4c, $90, $fa, $84, $3c, $9d, $98, $13, $79, $6d, $18, $6b, $3a, $64
	byte	$d9, $66, $50, $66, $d4, $66, $4b, $66, $8c, $66, $46, $66, $86, $66, $84, $66
	byte	$81, $66, $3a, $66, $7c, $66, $36, $66, $76, $66, $30, $66, $71, $66, $1d, $65
	byte	$6b, $66, $88, $72, $bf, $37, $e7, $b7, $75, $83, $8b, $8e, $57, $8f, $90, $8e
	byte	$94, $8e, $96, $8e, $dd, $8e, $9c, $8e, $e2, $8e, $a2, $8e, $e9, $8e, $ec, $8e
	byte	$ee, $8e, $ae, $8e, $38, $8f, $b5, $8e, $3f, $8f, $fd, $8e, $1c, $91, $0f, $8b
	byte	$a5, $87, $1e, $e3, $6d, $5d, $fa, $71, $41, $64, $25, $67, $de, $66, $63, $67
	byte	$d9, $66, $1a, $67, $18, $67, $15, $67, $12, $67, $0f, $67, $0c, $67, $0a, $67
	byte	$07, $67, $c0, $66, $01, $67, $bc, $66, $b8, $66, $de, $64, $b8, $70, $40, $59
	byte	$43, $e5, $1f, $8b, $14, $8a, $f1, $90, $1c, $8f, $63, $8f, $df, $8e, $69, $8f
	byte	$29, $8f, $6e, $8f, $72, $8f, $75, $8f, $34, $8f, $be, $8f, $7e, $8f, $c3, $8f
	byte	$84, $8f, $87, $8f, $cc, $8f, $56, $90, $67, $91, $49, $80, $f5, $b3, $59, $3e
	byte	$46, $77, $a6, $66, $e8, $66, $b0, $67, $ad, $67, $ed, $67, $64, $67, $e9, $67
	byte	$a2, $67, $e3, $67, $9d, $67, $9a, $67, $98, $67, $94, $67, $92, $67, $d2, $67
	byte	$49, $67, $cd, $67, $28, $65, $5f, $6e, $82, $67, $3a, $01, $6c, $95, $fd, $87
	byte	$c2, $91, $a9, $8f, $ef, $8f, $ae, $8f, $f4, $8f, $b5, $8f, $f9, $8f, $fd, $8f
	byte	$01, $90, $03, $90, $07, $90, $09, $90, $0c, $90, $53, $90, $12, $90, $9c, $90
	byte	$18, $90, $44, $93, $85, $84, $d6, $9d, $87, $1f, $2f, $75, $e5, $6a, $23, $66
	byte	$c4, $68, $f6, $67, $be, $68, $f1, $67, $76, $68, $2e, $68, $6f, $68, $29, $68
	byte	$27, $68, $24, $68, $64, $68, $1e, $68, $5f, $68, $19, $68, $5a, $68, $06, $67
	byte	$dc, $68, $56, $72, $7e, $36, $c2, $b8, $d7, $84, $73, $90, $41, $91, $79, $90
	byte	$7b, $90, $7f, $90, $82, $90, $84, $90, $cb, $90, $8b, $90, $8e, $90, $90, $90
	byte	$d7, $90, $96, $90, $20, $91, $59, $90, $25, $91, $a2, $90, $8c, $93, $62, $8b
	byte	$d0, $89, $40, $ee, $12, $64, $c4, $71, $29, $66, $0c, $69, $82, $68, $4a, $69
	byte	$c0, $68, $02, $69, $fe, $68, $fb, $68, $f9, $68, $f6, $68, $f2, $68, $f1, $68
	byte	$ee, $68, $a8, $68, $2c, $69, $5f, $68, $e2, $68, $81, $66, $4c, $71, $5e, $5f
	byte	$1e, $eb, $a6, $8a, $73, $8b, $5e, $93, $7b, $90, $48, $91, $81, $90, $4e, $91
	byte	$0d, $91, $11, $91, $14, $91, $16, $91, $5c, $91, $1c, $91, $63, $91, $66, $91
	byte	$68, $91, $af, $91, $2a, $91, $b5, $91, $75, $91, $1a, $94, $ba, $87, $b7, $9a
	byte	$70, $0e, $cb, $6c, $5d, $6e, $c4, $67, $99, $69, $54, $69, $d8, $69, $4e, $69
	byte	$d2, $69, $49, $69, $89, $69, $86, $69, $40, $69, $c4, $69, $3b, $69, $bf, $69
	byte	$35, $69, $76, $69, $58, $67, $eb, $6d, $e9, $6d, $89, $0f, $73, $99, $46, $87
	byte	$33, $94, $94, $91, $d9, $91, $56, $91, $e0, $91, $9f, $91, $e5, $91, $e8, $91
	byte	$ec, $91, $ee, $91, $f1, $91, $f4, $91, $f7, $91, $3d, $92, $fc, $91, $42, $92
	byte	$46, $92, $21, $94, $11, $89, $a4, $9d, $fd, $0e, $8f, $6c, $73, $6f, $0e, $68
	byte	$28, $6a, $e1, $69, $65, $6a, $1f, $6a, $5f, $6a, $1a, $6a, $17, $6a, $13, $6a
	byte	$54, $6a, $0f, $6a, $4f, $6a, $09, $6a, $06, $6a, $03, $6a, $00, $6a, $76, $69
	byte	$23, $68, $69, $77, $3a, $4d, $38, $ca, $38, $86, $4e, $91, $6d, $93, $1e, $92
	byte	$64, $92, $24, $92, $6a, $92, $2a, $92, $70, $92, $30, $92, $76, $92, $79, $92
	byte	$7b, $92, $7e, $92, $c5, $92, $84, $92, $cb, $92, $8a, $92, $a9, $94, $9b, $8e
	byte	$4d, $8d, $f9, $e2, $97, $59, $fe, $74, $db, $68, $6d, $6a, $ae, $6a, $ef, $6a
	byte	$a8, $6a, $a5, $6a, $a3, $6a, $9f, $6a, $9d, $6a, $9b, $6a, $98, $6a, $95, $6a
	byte	$d6, $6a, $8f, $6a, $cf, $6a, $46, $6a, $ca, $6a, $e1, $67, $34, $73, $10, $67
	byte	$d3, $f7, $15, $92, $90, $8c, $bf, $94, $a6, $92, $eb, $92, $68, $92, $36, $93
	byte	$b1, $92, $f7, $92, $fa, $92, $fd, $92, $00, $93, $02, $93, $06, $93, $4c, $93
	byte	$4f, $93, $52, $93, $54, $93, $22, $94, $5a, $93, $8f, $88, $e9, $ba, $f7, $39
	byte	$1c, $77, $07, $6c, $e8, $69, $7a, $6b, $34, $6b, $75, $6b, $2e, $6b, $6f, $6b
	byte	$29, $6b, $26, $6b, $24, $6b, $21, $6b, $1d, $6b, $5e, $6b, $18, $6b, $59, $6b
	byte	$12, $6b, $52, $6b, $34, $69, $34, $6e, $ba, $73, $a4, $24, $99, $aa, $de, $88
	byte	$7a, $94, $b3, $93, $72, $93, $31, $93, $78, $93, $7a, $93, $7e, $93, $81, $93
	byte	$83, $93, $86, $93, $89, $93, $d0, $93, $d2, $93, $d5, $93, $94, $93, $1e, $94
	byte	$dd, $93, $40, $96, $30, $8b, $99, $9c, $52, $10, $94, $71, $91, $71, $63, $69
	byte	$46, $6c, $79, $6b, $40, $6c, $b7, $6b, $f7, $6b, $b1, $6b, $f1, $6b, $ef, $6b
	byte	$ec, $6b, $a5, $6b, $a2, $6b, $9f, $6b, $9d, $6b, $9a, $6b, $97, $6b, $0d, $6b
	byte	$c8, $6a, $e4, $76, $20, $4b, $f9, $ce, $2e, $8a, $1a, $92, $46, $95, $b5, $93
	byte	$fb, $93, $ba, $93, $01, $94, $03, $94, $4a, $94, $09, $94, $0c, $94, $0e, $94
	byte	$55, $94, $14, $94, $9e, $94, $1a, $94, $61, $94, $20, $94, $fa, $95, $5b, $93
	byte	$3e, $87, $e5, $cd, $5f, $50, $6c, $78, $b5, $6a, $04, $6c, $45, $6c, $85, $6c
	byte	$83, $6c, $7f, $6c, $7c, $6c, $36, $6c, $76, $6c, $74, $6c, $71, $6c, $6f, $6c
	byte	$6b, $6c, $25, $6c, $66, $6c, $1f, $6c, $1d, $6c, $41, $6a, $ff, $73, $48, $66
	byte	$ba, $fa, $fc, $94, $5b, $8d, $97, $96, $3b, $94, $c5, $94, $40, $94, $ca, $94
	byte	$89, $94, $8c, $94, $8f, $94, $92, $94, $94, $94, $db, $94, $9b, $94, $e1, $94
	byte	$e4, $94, $e7, $94, $2d, $95, $74, $95, $c8, $96, $15, $89, $e4, $ab, $5c, $29
	byte	$cb, $75, $31, $6f, $7e, $6b, $10, $6d, $c9, $6c, $0a, $6d, $c3, $6c, $05, $6d
	byte	$bd, $6c, $ff, $6c, $fb, $6c, $f9, $6c, $b2, $6c, $f3, $6c, $ac, $6c, $ed, $6c
	byte	$a7, $6c, $e8, $6c, $0d, $6b, $85, $6f, $c7, $74, $10, $28, $2e, $ac, $21, $89
	byte	$96, $96, $47, $95, $06, $95, $0a, $95, $0c, $95, $0f, $95, $12, $95, $14, $95
	byte	$17, $95, $5e, $95, $61, $95, $63, $95, $22, $95, $ac, $95, $28, $95, $b1, $95
	byte	$72, $95, $17, $98, $59, $8e, $01, $96, $cf, $fc, $5a, $68, $fe, $74, $7e, $6b
	byte	$96, $6d, $50, $6d, $d5, $6d, $4a, $6d, $8c, $6d, $89, $6d, $85, $6d, $82, $6d
	byte	$80, $6d, $3a, $6d, $7a, $6d, $77, $6d, $75, $6d, $71, $6d, $2b, $6d, $e5, $6c
	byte	$18, $6c, $bc, $78, $9a, $4f, $7e, $cf, $1f, $89, $f1, $93, $1e, $97, $48, $95
	byte	$d2, $95, $4e, $95, $d7, $95, $53, $95, $dd, $95, $e0, $95, $e3, $95, $e5, $95
	byte	$a5, $95, $eb, $95, $ee, $95, $f0, $95, $37, $96, $b3, $95, $3c, $96, $3f, $96
	byte	$1a, $98, $d5, $8d, $c5, $9f, $cd, $0f, $0f, $71, $f3, $73, $c3, $6b, $63, $6e
	byte	$d9, $6d, $5e, $6e, $d3, $6d, $58, $6e, $12, $6e, $0f, $6e, $0c, $6e, $08, $6e
	byte	$49, $6e, $bf, $6d, $87, $6e, $76, $6d, $81, $6e, $11, $6b, $48, $74, $01, $74
	byte	$3f, $09, $44, $95, $e5, $8d, $3f, $99, $d4, $95, $a2, $96, $da, $95, $64, $96
	byte	$23, $96, $69, $96, $6b, $96, $6e, $96, $71, $96, $74, $96, $77, $96, $7a, $96
	byte	$bf, $96, $3c, $96, $c6, $96, $c8, $96, $a3, $98, $51, $8d, $51, $a5, $ee, $1b
	byte	$cf, $75, $29, $73, $90, $6c, $ec, $6e, $62, $6e, $e7, $6e, $5c, $6e, $e0, $6e
	byte	$9a, $6e, $98, $6e, $95, $6e, $91, $6e, $8e, $6e, $cf, $6e, $45, $6e, $c9, $6e
	byte	$40, $6e, $c3, $6e, $e8, $6c, $45, $6f, $a5, $7b, $c9, $35, $4e, $b3, $76, $8a
	byte	$2d, $98, $23, $97, $e1, $96, $a0, $96, $a4, $96, $ea, $96, $a9, $96, $ef, $96
	byte	$af, $96, $f4, $96, $f8, $96, $3e, $97, $fd, $96, $43, $97, $bf, $96, $8c, $97
	byte	$08, $97, $6b, $99, $d6, $92, $88, $91, $d8, $ee, $84, $66, $be, $79, $8e, $6c
	byte	$2e, $6f, $e7, $6e, $6c, $6f, $24, $6f, $21, $6f, $1f, $6f, $1c, $6f, $1a, $6f
	byte	$17, $6f, $13, $6f, $54, $6f, $0e, $6f, $0b, $6f, $4b, $6f, $c0, $6e, $bf, $6e
	byte	$27, $6d, $1c, $7b, $19, $59, $9f, $db, $66, $8e, $bc, $94, $b3, $98, $20, $97
	byte	$67, $97, $26, $97, $6d, $97, $2b, $97, $72, $97, $32, $97, $78, $97, $7a, $97
	byte	$c1, $97, $7f, $97, $c6, $97, $85, $97, $cb, $97, $ce, $97, $df, $98, $17, $98
	byte	$ec, $8a, $c4, $c6, $68, $4c, $f4, $7d, $63, $6e, $e8, $6e, $b0, $6f, $ac, $6f
	byte	$ed, $6f, $a7, $6f, $e7, $6f, $a0, $6f, $e1, $6f, $9b, $6f, $97, $6f, $94, $6f
	byte	$d5, $6f, $8f, $6f, $ce, $6f, $45, $6f, $86, $6f, $68, $6d, $09, $75, $dc, $71
	byte	$c0, $13, $ad, $a2, $a7, $8e, $79, $99, $e6, $97, $e8, $97, $a8, $97, $ee, $97
	byte	$f1, $97, $f3, $97, $f6, $97, $f9, $97, $fb, $97, $fe, $97, $01, $98, $04, $98
	byte	$4a, $98, $0a, $98, $93, $98, $0f, $98, $7f, $9b, $bf, $8c, $d8, $a1, $6d, $21
	byte	$91, $7b, $62, $73, $1a, $6e, $b9, $70, $eb, $6f, $b3, $70, $e6, $6f, $6a, $70
	byte	$25, $70, $20, $70, $1e, $70, $1b, $70, $18, $70, $15, $70, $12, $70, $0f, $70
	byte	$0d, $70, $09, $70, $07, $70, $03, $70, $01, $70, $fd, $6f, $fa, $6f, $f7, $6f
	byte	$f6, $6f, $f2, $6f, $ef, $6f, $ec, $6f, $2c, $70, $e6, $6f, $27, $70, $9d, $6f
	byte	$dd, $6f, $97, $6f, $d7, $6f, $84, $6e, $8f, $6f, $3f, $7d, $b7, $3d
'-' atarist_spl file "atarist.spl" '512
	byte	$ff[6]
	byte	$00[10]
	byte	$17, $7f, $f2, $7f, $b2, $7f, $72, $7f, $33, $7f, $f4, $7e, $b4, $7e, $75, $7e
	byte	$36, $7e, $f5, $7d, $e9, $51, $f2, $0d, $8e, $00, $f3, $fd, $72, $fd, $5a, $fd
	byte	$57, $fd, $58, $fd, $5b, $fd, $5c, $fd, $5c, $fd, $60, $7d, $52, $7d, $14, $7d
	byte	$d6, $7c, $98, $7c, $59, $7c, $1a, $7c, $dc, $7b, $9e, $7b, $61, $7b, $72, $34
	byte	$f3, $05, $00, $fd, $41, $fb, $ea, $fa, $d9, $fa, $db, $fa, $de, $fa, $e1, $fa
	byte	$e4, $fa, $9b, $36, $f8, $7a, $c0, $7a, $84, $7a, $45, $7a, $08, $7a, $cd, $79
	byte	$8e, $79, $51, $79, $15, $79, $d7, $78, $3c, $1f, $eb, $ff, $cf, $f9, $a5, $f8
	byte	$6d, $f8, $65, $f8, $68, $f8, $6d, $f8, $70, $f8, $74, $f8, $84, $57, $db, $60
	byte	$ab, $60, $79, $60, $4b, $60, $1a, $60, $e9, $5f, $b9, $5f, $89, $5f, $5a, $5f
	byte	$fb, $59, $b2, $0b, $92, $fa, $3a, $f7, $96, $f6, $79, $f6, $79, $f6, $7c, $f6
	byte	$82, $f6, $86, $f6, $8c, $f6, $db, $5d, $f1, $5e, $c1, $5e, $92, $5e, $63, $5e
	byte	$34, $5e, $04, $5e, $d6, $5d, $a6, $5d, $78, $5d, $d4, $3e, $11, $03, $63, $f7
	byte	$27, $f5, $ba, $f4, $ab, $f4, $ad, $f4, $b2, $f4, $b8, $f4, $be, $f4, $c3, $f4
	byte	$26, $5d, $2b, $5d, $fc, $5c, $cd, $5c, $9f, $5c, $70, $5c, $42, $5c, $15, $5c
	byte	$e5, $5b, $b8, $5b, $db, $24, $a7, $fc, $d1, $f4, $4d, $f3, $05, $f3, $fd, $f2
	byte	$04, $f3, $0b, $f3, $11, $f3, $16, $f3, $de, $18, $98, $5b, $73, $5b, $99, $54
	byte	$4e, $4a, $29, $48, $a0, $47, $6a, $47, $43, $47, $20, $47, $fd, $46, $35, $0d
	byte	$e2, $f6, $98, $f2, $c5, $f1, $a3, $f1, $a3, $f1, $a8, $f1, $b0, $f1, $b8, $f1
	byte	$bf, $f1, $00, $3d, $ef, $46, $cd, $46, $aa, $46, $86, $46, $63, $46, $3f, $46
	byte	$1c, $46, $f9, $45, $d7, $45, $ee, $43, $de, $02, $e8, $f3, $01, $f1, $76, $f0
	byte	$61, $f0, $65, $f0, $6d, $f0, $74, $f0, $7c, $f0, $84, $f0, $39, $44, $b1, $45
	byte	$8e, $45, $6d, $45, $49, $45, $27, $45, $05, $45, $e1, $44, $bf, $44, $9d, $44
	byte	$f1, $2f, $a9, $fb, $8b, $f1, $9b, $ef, $40, $ef, $36, $ef, $3d, $ef, $46, $ef
	byte	$4d, $ef, $56, $ef, $5e, $ef, $7b, $44, $8c, $44, $69, $44, $47, $44, $26, $44
	byte	$03, $44, $e1, $43, $c0, $43, $f5, $37, $69, $33, $0f, $11, $f0, $f4, $70, $ef
	byte	$66, $ee, $37, $ee, $38, $ee, $40, $ee, $48, $ee, $51, $ee, $5b, $ee, $18, $01
	byte	$7d, $32, $6a, $32, $51, $32, $37, $32, $1f, $32, $05, $32, $eb, $31, $d2, $31
	byte	$b9, $31, $a1, $31, $f1, $04, $f4, $f1, $50, $ee, $a0, $ed, $85, $ed, $88, $ed
	byte	$93, $ed, $9a, $ed, $a4, $ed, $ad, $ed, $f4, $27, $c1, $31, $a9, $31, $90, $31
	byte	$78, $31, $5f, $31, $46, $31, $2e, $31, $15, $31, $fc, $30, $e4, $30, $9b, $fc
	byte	$c4, $ef, $4a, $ed, $dc, $ec, $cb, $ec, $d2, $ec, $da, $ec, $e6, $ec, $ef, $ec
	byte	$f9, $ec, $64, $2f, $0a, $31, $f1, $30, $d9, $30, $c0, $30, $a7, $30, $91, $30
	byte	$78, $30, $5f, $30, $46, $30, $38, $23, $a6, $f6, $19, $ee, $70, $ec, $25, $ec
	byte	$20, $ec, $28, $ec, $32, $ec, $3c, $ec, $47, $ec, $51, $ec, $93, $22, $b5, $22
	byte	$a3, $22, $93, $22, $7f, $22, $6e, $22, $5d, $22, $4c, $22, $3c, $22, $2b, $22
	byte	$77, $09, $76, $f1, $cc, $ec, $f0, $eb, $cd, $eb, $ce, $eb, $d7, $eb, $e3, $eb
	byte	$ed, $eb, $f5, $eb, $3e, $f6, $6b, $22, $5f, $22, $4e, $22, $3d, $22, $2c, $22
	byte	$1b, $22, $0b, $22, $fa, $21, $e9, $21, $d8, $21, $4d, $ff, $44, $ef, $25, $ec
	byte	$92, $eb, $7b, $eb, $82, $eb, $8c, $eb, $97, $eb, $a1, $eb, $ab, $eb, $2e, $16
	byte	$15, $22, $04, $22, $f3, $21, $e3, $21, $d2, $21, $c0, $21, $af, $21, $9e, $21
	byte	$8e, $21, $7d, $21, $9a, $f8, $a4, $ed, $8e, $eb, $2f, $eb, $24, $eb, $2d, $eb
	byte	$37, $eb, $42, $eb, $4c, $eb, $57, $eb, $b2, $17, $22, $19, $15, $19, $0a, $19
	byte	$fd, $18, $ef, $18, $e3, $18, $d6, $18, $ca, $18, $bd, $18, $49, $12, $92, $f2
	byte	$60, $ec, $35, $eb, $01, $eb, $01, $eb, $0c, $eb, $16, $eb, $20, $eb, $2b, $eb
	byte	$34, $eb, $d0, $18, $00, $19, $f4, $18, $e8, $18, $da, $18, $cf, $18, $c2, $18
	byte	$b6, $18, $a9, $18, $9d, $18, $91, $05, $f0, $ef, $ca, $eb, $02, $eb, $e6, $ea
	byte	$e8, $ea, $f2, $ea, $fe, $ea, $07, $eb, $12, $eb, $c2, $ef, $e9, $18, $e6, $18
	byte	$d9, $18, $cd, $18, $c0, $18, $b3, $18, $a7, $18, $9b, $18, $8e, $18, $83, $18
	byte	$b8, $fc, $30, $ee, $61, $eb, $dc, $ea, $cd, $ea, $d2, $ea, $de, $ea, $e7, $ea
	byte	$f3, $ea, $fe, $ea, $d2, $09, $d1, $18, $c3, $18, $17, $18, $c7, $12, $a5, $11
	byte	$66, $11, $52, $11, $49, $11, $41, $11, $38, $11, $e0, $f4, $a5, $ec, $13, $eb
	byte	$c9, $ea, $c5, $ea, $cf, $ea, $db, $ea, $e6, $ea, $ef, $ea, $fb, $ea, $0e, $10
	byte	$89, $11, $80, $11, $78, $11, $6e, $11, $67, $11, $5d, $11, $54, $11, $4c, $11
	byte	$43, $11, $32, $0d, $9c, $f1, $07, $ec, $f8, $ea, $cd, $ea, $cc, $ea, $d8, $ea
	byte	$e4, $ea, $ed, $ea, $f8, $ea, $02, $eb, $55, $11, $91, $11, $89, $11, $80, $11
	byte	$75, $11, $6e, $11, $64, $11, $5e, $11, $54, $11, $4a, $11, $bc, $02, $5e, $ef
	byte	$a8, $eb, $f1, $ea, $d9, $ea, $dc, $ea, $e8, $ea, $f1, $ea, $fc, $ea, $06, $eb
	byte	$a6, $eb, $9e, $11, $a0, $11, $96, $11, $8d, $11, $85, $11, $7b, $11, $72, $11
	byte	$6a, $11, $ca, $0d, $36, $0b, $57, $f8, $6c, $ed, $57, $eb, $f8, $ea, $ee, $ea
	byte	$f4, $ea, $ff, $ea, $09, $eb, $15, $eb, $1e, $eb, $1a, $fd, $f9, $0a, $f2, $0a
	byte	$ed, $0a, $e8, $0a, $e2, $0a, $dc, $0a, $d6, $0a, $d1, $0a, $cd, $0a, $c7, $0a
	byte	$f8, $f3, $bc, $ec, $57, $eb, $1e, $eb, $18, $eb, $24, $eb, $2d, $eb, $39, $eb
	byte	$42, $eb, $4d, $eb, $08, $09, $20, $0b, $1a, $0b, $14, $0b, $0f, $0b, $09, $0b
	byte	$04, $0b, $fe, $0a, $f9, $0a, $f2, $0a, $84, $08, $3a, $f1, $4f, $ec, $66, $eb
	byte	$42, $eb, $42, $eb, $4e, $eb, $57, $eb, $62, $eb, $6b, $eb, $77, $eb, $06, $0b
	byte	$48, $0b, $43, $0b, $3c, $0b, $36, $0b, $31, $0b, $2c, $0b, $26, $0b, $20, $0b
	byte	$1b, $0b, $5c, $00, $6a, $ef, $1b, $ec, $81, $eb, $6a, $eb, $6f, $eb, $79, $eb
	byte	$85, $eb, $8e, $eb, $99, $eb, $a3, $eb, $dd, $05, $e5, $05, $e1, $05, $df, $05
	byte	$db, $05, $d8, $05, $d5, $05, $d1, $05, $d0, $05, $cb, $05, $63, $f7, $da, $ed
	byte	$0c, $ec, $bb, $eb, $b3, $eb, $bb, $eb, $c5, $eb, $d0, $eb, $d9, $eb, $e3, $eb
	byte	$e4, $f7, $2c, $06, $28, $06, $24, $06, $22, $06, $1f, $06, $1c, $06, $1a, $06
	byte	$16, $06, $14, $06, $0f, $06, $d0, $f3, $65, $ed, $2d, $ec, $f9, $eb, $f6, $eb
	byte	$01, $ec, $0a, $ec, $14, $ec, $1e, $ec, $29, $ec, $fb, $03, $6a, $06, $67, $06
	byte	$63, $06, $60, $06, $5e, $06, $59, $06, $58, $06, $54, $06, $50, $06, $12, $05
	byte	$69, $f1, $21, $ed, $55, $ec, $33, $ec, $36, $ec, $40, $ec, $49, $ec, $53, $ec
	byte	$5c, $ec, $68, $ec, $92, $02, $d9, $02, $d7, $02, $d7, $02, $d5, $02, $d3, $02
	byte	$d1, $02, $d1, $02, $ce, $02, $cd, $02, $5d, $fc, $80, $ef, $07, $ed, $90, $ec
	byte	$83, $ec, $8a, $ec, $93, $ec, $9c, $ec, $a5, $ec, $b1, $ec, $ba, $ec, $24, $03
	byte	$2b, $03, $2a, $03, $29, $03, $26, $03, $25, $03, $24, $03, $22, $03, $20, $03
	byte	$1f, $03, $70, $f7, $d0, $ee, $27, $ed, $db, $ec, $d4, $ec, $dd, $ec, $e7, $ec
	byte	$f0, $ec, $fa, $ec, $02, $ed, $f9, $f4, $7b, $03, $7c, $03, $7a, $03, $78, $03
	byte	$75, $03, $73, $03, $72, $03, $70, $03, $6d, $03, $6c, $03, $4f, $f4, $70, $ee
	byte	$54, $ed, $22, $ed, $22, $ed, $2c, $ed, $35, $ed, $3f, $ed, $48, $ed, $52, $ed
	byte	$14, $01, $c3, $03, $c1, $03, $c0, $03, $5f, $01, $a5, $00, $82, $00, $7b, $00
	byte	$7b, $00, $7c, $00, $20, $00, $85, $f1, $2a, $ee, $89, $ed, $73, $ed, $76, $ed
	byte	$80, $ed, $87, $ed, $90, $ed, $9a, $ed, $a3, $ed, $73, $00, $d2, $00, $d2, $00
	byte	$d0, $00, $d0, $00, $d0, $00, $d0, $00, $d0, $00, $cf, $00, $ce, $00, $48, $fc
	byte	$80, $f0, $3d, $ee, $d5, $ed, $c7, $ed, $cd, $ed, $d6, $ed, $df, $ed, $e9, $ed
	byte	$f2, $ed, $fa, $ed, $1d, $01, $29, $01, $27, $01, $27, $01, $27, $01, $25, $01
	byte	$25, $01, $26, $01, $26, $01, $23, $01, $d0, $f7, $ec, $ef, $65, $ee, $23, $ee
	byte	$1c, $ee, $24, $ee, $2d, $ee, $37, $ee, $40, $ee, $47, $ee, $6e, $f3, $7a, $01
	byte	$7d, $01, $7b, $01, $7a, $01, $7a, $01, $79, $01, $78, $01, $79, $01, $62, $00
	byte	$84, $fe, $de, $f3, $6c, $ef, $93, $ee, $72, $ee, $72, $ee, $7a, $ee, $85, $ee
	byte	$8b, $ee, $95, $ee, $9e, $ee, $15, $fc, $67, $fe, $67, $fe, $69, $fe, $69, $fe
	byte	$6b, $fe, $6b, $fe, $6d, $fe, $6d, $fe, $6d, $fe, $6f, $fe, $63, $f2, $6d, $ef
	byte	$df, $ee, $cc, $ee, $cf, $ee, $d9, $ee, $e1, $ee, $ea, $ee, $f2, $ee, $fc, $ee
	byte	$5a, $fe, $c4, $fe, $c3, $fe, $c5, $fe, $c6, $fe, $c6, $fe, $c6, $fe, $c7, $fe
	byte	$c8, $fe, $c7, $fe, $da, $fb, $85, $f1, $8d, $ef, $31, $ef, $25, $ef, $2d, $ef
	byte	$34, $ef, $3e, $ef, $46, $ef, $4f, $ef, $57, $ef, $0d, $ff, $1f, $ff, $1f, $ff
	byte	$1f, $ff, $1f, $ff, $21, $ff, $21, $ff, $21, $ff, $21, $ff, $23, $ff, $10, $f8
	byte	$15, $f1, $be, $ef, $84, $ef, $7e, $ef, $88, $ef, $8f, $ef, $97, $ef, $a0, $ef
	byte	$a9, $ef, $06, $f2, $a6, $fc, $ab, $fc, $ad, $fc, $ae, $fc, $b0, $fc, $b2, $fc
	byte	$b2, $fc, $b4, $fc, $b6, $fc, $b7, $fc, $8b, $f4, $bd, $f0, $01, $f0, $e3, $ef
	byte	$e4, $ef, $ee, $ef, $f6, $ef, $fd, $ef, $04, $f0, $0e, $f0, $11, $fa, $09, $fd
	byte	$0b, $fd, $0d, $fd, $0f, $fd, $11, $fd, $11, $fd, $13, $fd, $14, $fd, $17, $fd
	byte	$17, $fd, $64, $f3, $cd, $f0, $52, $f0, $41, $f0, $45, $f0, $4c, $f0, $55, $f0
	byte	$5b, $f0, $64, $f0, $6d, $f0, $fb, $fc, $65, $fd, $68, $fd, $69, $fd, $6c, $fd
	byte	$6c, $fd, $6d, $fd, $6f, $fd, $70, $fd, $72, $fd, $b3, $fb, $b1, $f2, $f4, $f0
	byte	$a4, $f0, $99, $f0, $a0, $f0, $a8, $f0, $ae, $f0, $b9, $f0, $c1, $f0, $c8, $f0
	byte	$cb, $fb, $dd, $fb, $de, $fb, $e0, $fb, $e3, $fb, $e3, $fb, $e5, $fb, $e8, $fb
	byte	$e9, $fb, $ec, $fb, $62, $f7, $27, $f2, $2a, $f1, $ff, $f0, $fd, $f0, $05, $f1
	byte	$0c, $f1, $13, $f1, $1b, $f1, $23, $f1, $33, $f2, $3c, $fc, $3e, $fc, $40, $fc
	byte	$42, $fc, $45, $fc, $47, $fc, $48, $fc, $4a, $fc, $4c, $fc, $4e, $fc, $a5, $f5
	byte	$20, $f2, $77, $f1, $5c, $f1, $5f, $f1, $64, $f1, $6c, $f1, $73, $f1, $7c, $f1
	byte	$83, $f1, $dc, $f8, $9a, $fc, $9a, $fc, $9b, $fc, $9e, $fc, $9f, $fc, $a1, $fc
	byte	$a3, $fc, $a4, $fc, $a6, $fc, $a9, $fc, $90, $f4, $33, $f2, $c5, $f1, $b6, $f1
	byte	$ba, $f1, $bf, $f1, $c7, $f1, $ce, $f1, $d6, $f1, $dc, $f1, $79, $fc, $f0, $fc
	byte	$f3, $fc, $f5, $fc, $fe, $fb, $79, $fb, $62, $fb, $5f, $fb, $61, $fb, $63, $fb
	byte	$6f, $fa, $af, $f3, $53, $f2, $12, $f2, $0f, $f2, $15, $f2, $1d, $f2, $24, $f2
	byte	$2a, $f2, $32, $f2, $38, $f2, $9a, $fb, $af, $fb, $b1, $fb, $b3, $fb, $b4, $fb
	byte	$b7, $fb, $b8, $fb, $ba, $fb, $bc, $fb, $c1, $fb, $3b, $f8, $7e, $f3, $96, $f2
	byte	$6e, $f2, $6c, $f2, $74, $f2, $7a, $f2, $81, $f2, $87, $f2, $8e, $f2, $a7, $f2
	byte	$06, $fc, $09, $fc, $0c, $fc, $0e, $fc, $0f, $fc, $12, $fc, $13, $fc, $16, $fc
	byte	$17, $fc, $1a, $fc, $b2, $f6, $7b, $f3, $dd, $f2, $c5, $f2, $c7, $f2, $cf, $f2
	byte	$d4, $f2, $db, $f2, $e0, $f2, $e8, $f2, $28, $f8, $60, $fc, $61, $fc, $62, $fc
	byte	$64, $fc, $66, $fc, $68, $fc, $6a, $fc, $6d, $fc, $52, $fc, $19, $fb, $4a, $f5
	byte	$78, $f3, $24, $f3, $1a, $f3, $1e, $f3, $24, $f3, $2a, $f3, $31, $f3, $38, $f3
	byte	$3d, $f3, $80, $fa, $0c, $fb, $0f, $fb, $10, $fb, $14, $fb, $15, $fb, $17, $fb
	byte	$1b, $fb, $1d, $fb, $1f, $fb, $92, $fa, $de, $f4, $ae, $f3, $79, $f3, $72, $f3
	byte	$79, $f3, $7e, $f3, $84, $f3, $8c, $f3, $92, $f3, $97, $f3, $52, $fb, $65, $fb
	byte	$67, $fb, $69, $fb, $6b, $fb, $6f, $fb, $71, $fb, $72, $fb, $74, $fb, $76, $fb
	byte	$e3, $f8, $ba, $f4, $ee, $f3, $cc, $f3, $ca, $f3, $cf, $f3, $d5, $f3, $dd, $f3
	byte	$e2, $f3, $e8, $f3, $ed, $f3, $b7, $fb, $bc, $fb, $be, $fb, $c0, $fb, $c1, $fb
	byte	$c4, $fb, $c6, $fb, $c8, $fb, $c9, $fb, $cc, $fb, $8f, $f7, $b9, $f4, $33, $f4
	byte	$1e, $f4, $1e, $f4, $24, $f4, $2a, $f4, $30, $f4, $38, $f4, $3e, $f4, $1f, $f7
	byte	$ad, $fa, $b1, $fa, $b4, $fa, $b6, $fa, $ba, $fa, $bb, $fa, $be, $fa, $c1, $fa
	byte	$c2, $fa, $c6, $fa, $55, $f6, $c6, $f4, $7d, $f4, $72, $f4, $78, $f4, $7e, $f4
	byte	$83, $f4, $89, $f4, $8f, $f4, $94, $f4, $66, $fa, $03, $fb, $07, $fb, $08, $fb
	byte	$0a, $fb, $0e, $fb, $10, $fb, $11, $fb, $16, $fb, $18, $fb, $d0, $fa, $02, $f6
	byte	$f9, $f4, $ca, $f4, $c5, $f4, $cb, $f4, $d1, $f4, $d7, $f4, $dc, $f4, $e1, $f4
	byte	$e8, $f4, $3f, $fb, $56, $fb, $58, $fb, $5a, $fb, $5e, $fb, $5f, $fb, $61, $fb
	byte	$64, $fb, $64, $fb, $69, $fb, $99, $f9, $e9, $f5, $33, $f5, $17, $f5, $17, $f5
	byte	$1d, $f5, $22, $f5, $27, $f5, $2e, $f5, $32, $f5, $37, $f5, $b3, $fa, $b6, $fa
	byte	$bc, $fa, $bc, $fa, $c1, $fa, $c2, $fa, $c4, $fa, $c8, $fa, $ca, $fa, $ce, $fa
	byte	$f9, $f7, $db, $f5, $78, $f5, $69, $f5, $6a, $f5, $70, $f5, $75, $f5, $7b, $f5
	byte	$7f, $f5, $85, $f5, $6e, $f7, $06, $fb, $0a, $fb, $0b, $fb, $0d, $fb, $12, $fb
	byte	$14, $fb, $15, $fb, $18, $fb, $1b, $fb, $1d, $fb, $70, $f7, $01, $f6, $c0, $f5
	byte	$b6, $f5, $bb, $f5, $c0, $f5, $c6, $f5, $ca, $f5, $cf, $f5, $d4, $f5, $a8, $fa
	byte	$54, $fb, $56, $fb, $5a, $fb, $5b, $fb, $5e, $fb, $5f, $fb, $63, $fb, $65, $fb
	byte	$67, $fb, $52, $fb, $29, $f7, $33, $f6, $06, $f6, $02, $f6, $08, $f6, $0b, $f6
	byte	$10, $f6, $16, $f6, $1a, $f6, $1f, $f6, $81, $fb, $9f, $fb, $a2, $fb, $a4, $fb
	byte	$51, $fb, $f2, $fa, $e3, $fa, $e3, $fa, $e5, $fa, $e9, $fa, $d2, $f9, $f0, $f6
	byte	$64, $f6, $4d, $f6, $4d, $f6, $53, $f6, $57, $f6, $5c, $f6, $60, $f6, $66, $f6
	byte	$6a, $f6, $19, $fb, $1e, $fb, $22, $fb, $23, $fb, $24, $fb, $26, $fb, $2a, $fb
	byte	$2c, $fb, $2e, $fb, $32, $fb, $f0, $f8, $01, $f7, $a5, $f6, $98, $f6, $9a, $f6
	byte	$9f, $f6, $a3, $f6, $a6, $f6, $ac, $f6, $b0, $f6, $eb, $f7, $65, $fb, $68, $fb
	byte	$68, $fb, $6c, $fb, $6e, $fb, $71, $fb, $72, $fb, $74, $fb, $78, $fb, $7a, $fb
	byte	$71, $f8, $21, $f7, $e5, $f6, $dd, $f6, $e1, $f6, $e6, $f6, $ea, $f6, $ef, $f6
	byte	$f5, $f6, $f7, $f6, $f7, $fa, $ab, $fb, $ad, $fb, $af, $fb, $b0, $fb, $b5, $fb
	byte	$b6, $fb, $b9, $fb, $bb, $fb, $bc, $fb, $21, $fb, $07, $f8, $46, $f7, $23, $f7
	byte	$22, $f7, $26, $f7, $2b, $f7, $2e, $f7, $34, $f7, $38, $f7, $3c, $f7, $f7, $fa
	byte	$13, $fb, $16, $fb, $17, $fb, $1b, $fb, $1e, $fb, $20, $fb, $23, $fb, $25, $fb
	byte	$26, $fb, $77, $fa, $f3, $f7, $7c, $f7, $67, $f7, $6a, $f7, $6d, $f7, $70, $f7
	byte	$74, $f7, $7a, $f7, $7e, $f7, $82, $f7, $53, $fb, $5a, $fb, $5b, $fb, $5d, $fb
	byte	$5f, $fb, $63, $fb, $65, $fb, $67, $fb, $69, $fb, $6a, $fb, $b9, $f9, $03, $f8
	byte	$b5, $f7, $a9, $f7, $ad, $f7, $b0, $f7, $b5, $f7, $b8, $f7, $be, $f7, $c3, $f7
	byte	$6e, $f8, $99, $fb, $9c, $fb, $9d, $fb, $9f, $fb, $a4, $fb, $a5, $fb, $a8, $fb
	byte	$a9, $fb, $ab, $fb, $ad, $fb, $46, $f9, $26, $f8, $f0, $f7, $ea, $f7, $f0, $f7
	byte	$f4, $f7, $f8, $f7, $fb, $f7, $ff, $f7, $03, $f8, $65, $fa, $26, $fb, $29, $fb
	byte	$2b, $fb, $2f, $fb, $30, $fb, $32, $fb, $34, $fb, $38, $fb, $39, $fb, $3b, $fb
	byte	$e9, $f8, $4a, $f8, $2e, $f8, $2c, $f8, $2f, $f8, $36, $f8, $3a, $f8, $3e, $f8
	byte	$41, $f8, $44, $f8, $4a, $fb, $67, $fb, $68, $fb, $6b, $fb, $6f, $fb, $70, $fb
	byte	$73, $fb, $74, $fb, $78, $fb, $7a, $fb, $14, $fb, $e7, $f8, $7d, $f8, $6d, $f8
	byte	$6d, $f8, $70, $f8, $73, $f8, $78, $f8, $7c, $f8, $80, $f8, $84, $f8, $9f, $fb
	byte	$a6, $fb, $a7, $fb, $a9, $fb, $ac, $fb, $af, $fb, $b1, $fb, $b3, $fb, $b4, $fb
	byte	$b7, $fb, $73, $fa, $f8, $f8, $b4, $f8, $a9, $f8, $ab, $f8, $af, $f8, $b1, $f8
	byte	$b4, $f8, $b8, $f8, $bb, $f8, $fa, $f8, $64, $fb, $65, $fb, $67, $fb, $6b, $fb
	byte	$6d, $fb, $6f, $fb, $70, $fb, $74, $fb, $77, $fb, $77, $fb, $e4, $f9, $0f, $f9
	byte	$e9, $f8, $e4, $f8, $e8, $f8, $eb, $f8, $ee, $f8, $f2, $f8, $f7, $f8, $fb, $f8
	byte	$b5, $fa, $9f, $fb, $a1, $fb, $a4, $fb, $a5, $fb, $a9, $fb, $ab, $fb, $ae, $fb
	byte	$ae, $fb, $b1, $fb, $b2, $fb, $c7, $f9, $39, $f9, $22, $f9, $20, $f9, $22, $f9
	byte	$26, $f9, $2a, $f9, $2e, $f9, $32, $f9, $33, $f9, $ba, $fb, $d8, $fb, $db, $fb
	byte	$de, $fb, $e1, $fb, $e2, $fb, $e4, $fb, $e5, $fb, $e7, $fb, $e9, $fb, $a7, $fb
	byte	$c5, $f9, $67, $f9, $57, $f9, $56, $f9, $5b, $f9, $5f, $f9, $62, $f9, $66, $f9
	byte	$68, $f9, $6c, $f9, $0b, $fc, $11, $fc, $14, $fc, $15, $fc, $07, $fc, $c2, $fb
	byte	$b5, $fb, $b5, $fb, $b6, $fb, $b8, $fb, $e9, $fa, $c8, $f9, $94, $f9, $8d, $f9
	byte	$90, $f9, $94, $f9, $95, $f9, $99, $f9, $9d, $f9, $9f, $f9, $a3, $f9, $dd, $fb
	byte	$de, $fb, $df, $fb, $e2, $fb, $e4, $fb, $e6, $fb, $e8, $fb, $e9, $fb, $ed, $fb
	byte	$ef, $fb, $ac, $fa, $e9, $f9, $c7, $f9, $c3, $f9, $c8, $f9, $ca, $f9, $cc, $f9
	byte	$d0, $f9, $d4, $f9, $d6, $f9, $0e, $fb, $11, $fc, $13, $fc, $16, $fc, $17, $fc
	byte	$19, $fc, $1b, $fc, $1d, $fc, $1e, $fc, $21, $fc, $22, $fc, $8d, $fa, $0f, $fa
	byte	$f7, $f9, $f7, $f9, $fb, $f9, $fe, $f9, $00, $fa, $03, $fa, $07, $fa, $0b, $fa
	byte	$1b, $fc, $45, $fc, $46, $fc, $48, $fc, $4a, $fc, $4b, $fc, $4e, $fc, $50, $fc
	byte	$52, $fc, $54, $fc, $f3, $fb, $82, $fa, $35, $fa, $28, $fa, $2a, $fa, $2d, $fa
	byte	$31, $fa, $32, $fa, $37, $fa, $37, $fa, $3c, $fa, $00, $fc, $06, $fc, $09, $fc
	byte	$09, $fc, $0b, $fc, $0f, $fc, $12, $fc, $12, $fc, $15, $fc, $17, $fc, $84, $fb
	byte	$8d, $fa, $60, $fa, $5b, $fa, $5c, $fa, $60, $fa, $61, $fa, $66, $fa, $67, $fa
	byte	$6c, $fa, $6d, $fa, $37, $fc, $3a, $fc, $3b, $fc, $3d, $fc, $3e, $fc, $41, $fc
	byte	$43, $fc, $44, $fc, $45, $fc, $47, $fc, $51, $fb, $ab, $fa, $8e, $fa, $8b, $fa
	byte	$8e, $fa, $91, $fa, $93, $fa, $95, $fa, $98, $fa, $9b, $fa, $64, $fb, $67, $fc
	byte	$68, $fc, $6a, $fc, $6c, $fc, $6e, $fc, $70, $fc, $72, $fc, $74, $fc, $74, $fc
	byte	$76, $fc, $3b, $fb, $d0, $fa, $bb, $fa, $b9, $fa, $bd, $fa, $bf, $fa, $c2, $fa
	byte	$c4, $fa, $c6, $fa, $ca, $fa, $13, $fc, $3a, $fc, $3a, $fc, $3e, $fc, $3e, $fc
	byte	$41, $fc, $43, $fc, $44, $fc, $47, $fc, $48, $fc, $3c, $fc, $2b, $fb, $f0, $fa
	byte	$e6, $fa, $e8, $fa, $eb, $fa, $ee, $fa, $f0, $fa, $f2, $fa, $f6, $fa, $f7, $fa
	byte	$61, $fc, $66, $fc, $68, $fc, $6b, $fc, $6c, $fc, $6e, $fc, $70, $fc, $72, $fc
	byte	$73, $fc, $75, $fc, $13, $fc, $3f, $fb, $17, $fb, $12, $fb, $16, $fb, $18, $fb
	byte	$1a, $fb, $1d, $fb, $1f, $fb, $20, $fb, $23, $fb, $92, $fc, $94, $fc, $96, $fc
	byte	$96, $fc, $97, $fc, $9a, $fc, $9c, $fc, $9e, $fc, $9f, $fc, $a1, $fc, $e7, $fb
	byte	$5a, $fb, $41, $fb, $3e, $fb, $41, $fb
'-' atari2 file "atari2.s2"
	byte	$73, $32, $00, $04, $00, $00, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $44, $87, $44, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $42, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87
	byte	$44, $87, $44, $87, $43, $87, $44, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$44, $87, $43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87
	byte	$42, $87, $43, $87, $44, $87, $42, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $5c, $87, $ee, $86, $ac, $87, $4c, $7c, $a3, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bd, $78, $bc, $78, $bb, $78, $bd, $78, $bb, $78, $bc, $78
	byte	$bb, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $a0, $78, $4c, $7c, $11, $7a, $29, $89, $5f, $87, $44, $87
	byte	$44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $42, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $ed, $85, $71, $85, $52, $79, $43, $7a, $b9, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $a0, $78, $cf, $7a, $b9, $81, $9d, $80, $5f, $87
	byte	$44, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $5a, $87, $39, $81, $f4, $83, $52, $79
	byte	$a5, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bd, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $8f, $79, $17, $77, $ac, $87
	byte	$09, $85, $47, $87, $43, $87, $43, $87, $42, $87, $42, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $43, $87, $42, $87, $43, $87, $43, $87, $43, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $fd, $85, $2f, $86
	byte	$94, $78, $55, $7a, $b9, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bd, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $2f, $79
	byte	$94, $78, $b3, $84, $36, $84, $4a, $87, $43, $87, $43, $87, $44, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $45, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $44, $87, $44, $87, $43, $87, $43, $87, $44, $87, $43, $87
	byte	$43, $87, $42, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87
	byte	$54, $87, $3c, $82, $36, $83, $52, $79, $c6, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bd, $78, $ed, $78, $1b, $79, $f4, $83, $4d, $83, $4e, $87, $42, $87, $44, $87
	byte	$44, $87, $43, $87, $42, $87, $44, $87, $43, $87, $42, $87, $44, $87, $43, $87
	byte	$43, $87, $54, $87, $26, $82, $b3, $84, $d6, $77, $bb, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bb, $78, $bb, $78, $bb, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $26, $79, $18, $75, $36, $83, $1f, $84, $4a, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $42, $87, $44, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87, $44, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$44, $87, $44, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $19, $87, $7d, $86, $ac, $87, $cb, $7c
	byte	$b1, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bd, $78, $bc, $78, $b7, $78, $3b, $7b, $cf, $7a, $6a, $88
	byte	$96, $86, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$44, $87, $44, $87, $43, $87, $44, $87, $43, $87, $44, $87, $44, $87, $44, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $40, $87, $76, $83
	byte	$36, $83, $cf, $7a, $ab, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bd, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bd, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bd, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bd, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $9f, $78, $52, $79, $b3, $84, $2f, $86, $60, $87, $44, $87, $43, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$44, $87, $44, $87, $5e, $87, $bc, $80, $fb, $80, $94, $78, $a2, $78, $bb, $78
	byte	$bd, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $6b, $79, $d6, $77, $ac, $87, $c6, $84, $48, $87
	byte	$43, $87, $44, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87
	byte	$43, $87, $44, $87, $43, $87, $5c, $87, $e7, $80, $00, $80, $52, $79, $a1, $78
	byte	$bc, $78, $bd, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $a0, $78, $8d, $7b, $11, $7a, $29, $89
	byte	$60, $87, $43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $44, $87, $73, $86, $0e, $91, $11, $7a
	byte	$51, $7b, $b6, $78, $bc, $78, $bd, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bd, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $60, $79, $51, $71
	byte	$22, $8c, $af, $84, $48, $87, $43, $87, $44, $87, $43, $87, $44, $87, $44, $87
	byte	$43, $87, $42, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $c8, $86
	byte	$9f, $8b, $d6, $77, $16, $7c, $b3, $78, $bc, $78, $bb, $78, $bb, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78
	byte	$bb, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bd, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bd, $78, $bb, $78, $bc, $78, $bb, $78, $ba, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$a8, $78, $54, $7e, $f4, $83, $17, $82, $50, $87, $43, $87, $43, $87, $43, $87
	byte	$44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$43, $87, $28, $87, $20, $85, $cf, $7a, $70, $7d, $ad, $78, $bd, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bb, $78, $bb, $78, $bd, $78
	byte	$bb, $78, $b2, $78, $9a, $7c, $cf, $7a, $4a, $87, $0d, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $42, $87
	byte	$44, $87, $43, $87, $28, $87, $51, $85, $11, $7a, $1e, $7d, $af, $78, $bb, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bd, $78, $bb, $78, $bb, $78, $bb, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bd, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bb, $78, $bb, $78, $bc, $78, $b6, $78, $48, $7d, $78, $82, $f7, $81
	byte	$56, $87, $43, $87, $42, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $4c, $87, $7e, $83, $f4, $83, $47, $78
	byte	$f7, $78, $bc, $78, $bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $b0, $78, $c1, $7b
'-' atari12 file "atari12.s2"
	byte	$73, $32, $00, $04, $00, $00, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6a, $00, $9d, $00, $9d, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $6e, $00, $6e
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a1, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6c, $00, $a0, $00, $9f, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $6e, $00, $6e, $00, $6e, $00, $6e
	byte	$00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e
	byte	$00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e
	byte	$00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e
	byte	$00, $6e, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $9d, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
'-' mouse  file "mouse2.def"
	byte	$01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0b, $01, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0c, $0d, $0d, $03, $01, $01, $01, $01, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0c, $01, $09, $0d, $03, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0c, $01, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0c, $01, $00, $00, $01, $0a, $0d, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $01, $00, $00, $00, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00
	byte	$00[22]
	byte	$01, $0b, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[425]
'-' 
'-'              	org
	byte	$00, $00
'-' loadcog      	cogid   t11              		' get a cogid
	byte	$01, $2c, $60, $fd
'-'                 mul     t11, #12                        ' compute the offset to PSRAM mailbox 
	byte	$0c, $2c, $04, $fa
'-'                 add     mailbox, t11                     ' add offset to find this COG's mailbox
	byte	$16, $2e, $00, $f1
'-' 
'-'                 mov     psramaddr,#0
	byte	$00, $30, $04, $f6
'-' 
'-' p101            mov     buf1,psramaddr			' psramaddr=hubaddr
	byte	$18, $36, $00, $f6
'-'                 mov     buf2,##16384			' loading size
	byte	$20, $00, $00, $ff, $00, $38, $04, $f6
'-'                 mov     cmd,psramaddr                   ' set the address for reading
	byte	$18, $34, $00, $f6
'-'                 setnib  cmd, #%1011, #7                 ' attach the command - read burst
	byte	$0b, $34, $3c, $f8
'-'                 setq    #2			 	' write 3 longs to the mailbox
	byte	$28, $04, $64, $fd
'-'                 wrlong  cmd, mailbox			' read the PSRAM
	byte	$17, $34, $60, $fc
'-' p102            rdlong  cmd, mailbox                	' poll mailbox for result
	byte	$17, $34, $00, $fb
'-'                 tjs     cmd, #p102                 	' retry until valid 
	byte	$fe, $35, $b4, $fb
'-' 
'-'                 add 	psramaddr,##16384
	byte	$20, $00, $00, $ff, $00, $30, $04, $f1
'-' 		cmp 	psramaddr,##$7C000 wcz
	byte	$e0, $03, $00, $ff, $00, $30, $1c, $f2
'-' 	if_lt	jmp 	#p101				' loop until full hub loaded
	byte	$c8, $ff, $9f, $cd
'-' 
'-'                 
'-'                 cogstop #7				' stop psram driver
	byte	$03, $0e, $64, $fd
'-'     
'-'                 cogid 	t11				' get id
	byte	$01, $2c, $60, $fd
'-'                 coginit #0,#0				' start the new program
	byte	$00, $00, $ec, $fc
'-'                 cogstop t11				' stop the loader
	byte	$03, $2c, $60, $fd
'-' 
'-' t11 		long 	0
	byte	$00, $00, $00, $00
'-' mailbox 	long 	$7FF00
	byte	$00, $ff, $07, $00
'-' psramaddr 	long 	0
	byte	$00, $00, $00, $00
'-' pslockval	long 	0
	byte	$00, $00, $00, $00
'-' cmd             long    0
	byte	$00, $00, $00, $00
'-' buf1            long    0
	byte	$00, $00, $00, $00
'-' buf2            long    16384
	byte	$00, $40, $00, $00
	long	@@@_dat_ + 12612
	byte	$50, $32, $20, $52, $65, $74, $72, $6f, $6d, $61, $63, $68, $69, $6e, $65, $20
	byte	$42, $41, $53, $49, $43, $20, $76, $65, $72, $73, $69, $6f, $6e, $20, $30, $2e
	byte	$35, $31, $00, $00
	alignl
_Hg010b_4_spin2_dat_
'-' 
'-' vga_font       file "vgafont.def"
	byte	$00[19]
	byte	$7e, $81, $a5, $81, $81, $bd, $99, $81, $81, $7e, $00, $00, $00, $00, $00, $00
	byte	$7e, $ff, $db, $ff, $ff, $c3, $e7, $ff, $ff, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $7f, $7f, $7f, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $3e, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $3c, $e7, $e7, $e7, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $ff, $ff, $7e, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $3c, $3c, $18, $00, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $ff, $e7, $c3, $c3, $e7, $ff, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$00, $00, $3c, $66, $42, $42, $66, $3c, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $c3, $99, $bd, $bd, $99, $c3, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$78, $70, $58, $4c, $1e, $33, $33, $33, $33, $1e, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$fc, $cc, $fc, $0c, $0c, $0c, $0c, $0e, $0f, $07, $00, $00, $00, $00, $00, $00
	byte	$fe, $c6, $fe, $c6, $c6, $c6, $c6, $e6, $e7, $67, $03, $00, $00, $00, $00, $00
	byte	$18, $18, $db, $3c, $e7, $3c, $db, $18, $18, $00, $00, $00, $00, $00, $00, $01
	byte	$03, $07, $0f, $1f, $7f, $1f, $0f, $07, $03, $01, $00, $00, $00, $00, $00, $40
	byte	$60, $70, $78, $7c, $7f, $7c, $78, $70, $60, $40, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $18, $18, $18, $7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$00, $66, $66, $00, $00, $00, $00, $00, $00, $fe, $db, $db, $db, $de, $d8, $d8
	byte	$d8, $d8, $d8, $00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c
	byte	$30, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $7f, $7f, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $7e
	byte	$3c, $18, $7e, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $18
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $18, $30, $7f, $30, $18
	byte	$00[11]
	byte	$0c, $06, $7f, $06, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $03, $03, $03, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$14, $36, $7f, $36, $14, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $1c, $3e, $3e, $7f, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $3e, $3e, $1c, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[14]
	byte	$18, $3c, $3c, $3c, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $66, $66
	byte	$66, $24, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $18, $18
	byte	$3e, $63, $43, $03, $3e, $60, $60, $61, $63, $3e, $18, $18, $00, $00, $00, $00
	byte	$00, $00, $43, $63, $30, $18, $0c, $06, $63, $61, $00, $00, $00, $00, $00, $00
	byte	$1c, $36, $36, $1c, $6e, $3b, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00
	byte	$0c, $0c, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $30, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f, $00, $00
	byte	$00[16]
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $40, $60, $30, $18, $0c, $06
	byte	$03, $01, $00, $00, $00, $00, $00, $00, $1c, $36, $63, $63, $6b, $6b, $63, $63
	byte	$36, $1c, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18, $18
	byte	$18, $7e, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $30, $18, $0c, $06, $03
	byte	$63, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $60, $3c, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30, $30
	byte	$30, $78, $00, $00, $00, $00, $00, $00, $7f, $03, $03, $03, $3f, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $1c, $06, $03, $03, $3f, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $7f, $63, $60, $60, $30, $18, $0c, $0c
	byte	$0c, $0c, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $3e, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $7e, $60, $60, $60
	byte	$30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $60, $30, $18, $0c, $06, $0c, $18
	byte	$30, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00, $7e, $00
	byte	$00[9]
	byte	$06, $0c, $18, $30, $60, $30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $3e
	byte	$63, $63, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $63, $7b, $7b, $7b, $3b, $03, $3e, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3f
	byte	$66, $66, $66, $3e, $66, $66, $66, $66, $3f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00, $00, $1f
	byte	$36, $66, $66, $66, $66, $66, $66, $36, $1f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $7b, $63, $63, $66, $5c, $00, $00, $00, $00, $00, $00, $63
	byte	$63, $63, $63, $7f, $63, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3c
	byte	$18[8]
	byte	$3c, $00, $00, $00, $00, $00, $00, $78, $30, $30, $30, $30, $30, $33, $33, $33
	byte	$1e, $00, $00, $00, $00, $00, $00, $67, $66, $66, $36, $1e, $1e, $36, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $7f, $6b, $63, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $06, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $6b, $7b
	byte	$3e, $30, $70, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $36, $1c
	byte	$08, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $6b, $6b, $6b, $7f, $77
	byte	$36, $00, $00, $00, $00, $00, $00, $63, $63, $36, $3e, $1c, $1c, $3e, $36, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $01, $03, $07, $0e, $1c, $38, $70, $60
	byte	$40, $00, $00, $00, $00, $00, $00, $3c, $30, $30, $30, $30, $30, $30, $30, $30
	byte	$3c, $00, $00, $00, $1c, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$ff, $00, $00, $0c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $07, $06, $06
	byte	$1e, $36, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $30, $30
	byte	$3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $7f, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $6c, $4c
	byte	$0c, $1e, $0c, $0c, $0c, $0c, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$6e, $33, $33, $33, $33, $33, $3e, $30, $33, $1e, $00, $00, $00, $07, $06, $06
	byte	$36, $6e, $66, $66, $66, $66, $67, $00, $00, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $60, $60, $00
	byte	$70, $60, $60, $60, $60, $60, $60, $66, $66, $3c, $00, $00, $00, $07, $06, $06
	byte	$66, $36, $1e, $1e, $36, $66, $67, $00, $00, $00, $00, $00, $00, $1c, $18, $18
	byte	$18[6]
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $6b, $6b, $6b
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$3e, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $6e, $33, $33, $33, $33, $33
	byte	$3e, $30, $30, $78, $00, $00, $00, $00, $00, $00, $3b, $6e, $66, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36
	byte	$1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $6b, $6b, $6b, $7f
	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $1c, $36
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63
	byte	$7e, $60, $30, $1f, $00, $00, $00, $00, $00, $00, $7f, $33, $18, $0c, $06, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18, $18
	byte	$70, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18, $18
	byte	$0e, $00, $00, $00, $6e, $3b, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[10]
	byte	$08, $1c, $36, $63, $63, $63, $7f, $00, $00, $00, $00, $00, $00, $3c, $66, $43
	byte	$03, $03, $03, $03, $43, $66, $3c, $18, $30, $1e, $00, $00, $00, $00, $33, $00
	byte	$33[6]
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $33, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $1c, $36, $1c, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $18, $30, $1e, $00, $00, $00, $1c, $58, $78, $38, $18, $1c, $1e, $1a, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $66, $33, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $cc, $66, $33, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $18, $3c, $66, $00, $1c, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $63, $00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63
	byte	$63, $00, $00, $00, $30, $18, $00, $3c, $66, $43, $03, $03, $03, $03, $43, $66
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66
	byte	$7f, $00, $00, $00, $0c, $06, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $6f, $46, $26, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $6e, $4c, $2c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$1e, $00, $00, $00, $30, $18, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $6c, $38, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $60, $48, $2c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $0f, $26, $36, $1e, $0e, $07, $07, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36, $63, $00
	byte	$00[6]
	byte	$36, $1c, $08, $00, $3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63, $63, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $1e, $30, $3e, $33, $33, $33, $6e, $18, $0c, $78, $36, $1c
	byte	$00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00
	byte	$00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66, $7f, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $7f, $03, $03, $63, $3e, $18, $0c, $78, $00, $00
	byte	$00, $3c, $66, $03, $1f, $03, $0f, $03, $03, $66, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $6c, $38
	byte	$00, $3c, $66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63, $3e, $18, $30, $1e, $00, $00
	byte	$00[6]
	byte	$6c, $36, $1b, $36, $6c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$1b, $36, $6c, $36, $1b, $00, $00, $00, $88, $22, $88, $22, $88, $22, $88, $22
	byte	$88, $22, $88, $22, $88, $22, $88, $22, $aa, $55, $aa, $55, $aa, $55, $aa, $55
	byte	$aa, $55, $aa, $55, $aa, $55, $aa, $55, $bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee
	byte	$bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18[15]
	byte	$1f, $18, $18, $18, $18, $18, $18, $18, $18, $30, $18, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $1c, $36, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $36, $1c, $00, $7f, $66, $46, $16
	byte	$1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06
	byte	$1c, $30, $60, $63, $63, $3e, $18, $30, $1e, $6c, $6c, $6c, $6c, $6c, $6f, $60
	byte	$6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6c[9]
	byte	$00[5]
	byte	$7f, $60, $6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6f, $60, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $7f, $63
	byte	$61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00, $00, $18, $18
	byte	$00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $63, $3e, $00, $08, $1c
	byte	$36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $63, $3e
	byte	$00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $fc, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$fc, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$63, $3e, $63, $63, $63, $63, $3e, $63, $00, $00, $00, $00, $00, $00, $30, $7e
	byte	$30, $3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $1f, $36
	byte	$66, $66, $6f, $66, $66, $66, $36, $1f, $00, $00, $00, $36, $1c, $00, $1f, $36
	byte	$66[6]
	byte	$36, $1f, $00, $00, $00, $00, $63, $00, $7f, $66, $46, $16, $1e, $16, $06, $46
	byte	$66, $7f, $00, $00, $00, $6c, $38, $00, $38, $30, $30, $3c, $36, $33, $33, $33
	byte	$33, $6e, $00, $00, $00, $36, $1c, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63
	byte	$63, $63, $00, $00, $00, $30, $18, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $3c, $66, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $00, $00, $36, $1c, $08, $00, $3e, $63, $7f, $03, $03
	byte	$63, $3e, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $1f, $00, $00, $00
	byte	$00[12]
	byte	$f8, $18, $18, $18, $18, $18, $18, $18, $18, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	byte	$ff[9]
	byte	$00[7]
	byte	$ff[9]
	byte	$00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18, $3c, $18, $30, $1e
	byte	$1c, $36, $1c, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$ff[7]
	byte	$00[9]
	byte	$30, $18, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $00, $1e, $33, $33, $33, $1b, $33, $63, $63, $63, $33, $00, $00, $00
	byte	$1c, $36, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63, $63, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$36, $1c, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3e, $63, $06, $1c, $30, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00
	byte	$30, $18, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00
	byte	$66, $33, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $63, $63, $63, $63, $63, $63, $7e, $60, $30, $1f
	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18, $3c, $00, $00, $00
	byte	$00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c, $38, $18, $30, $1e
	byte	$30, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $66, $33, $00, $00, $00, $00, $00, $00
	byte	$00[21]
	byte	$0c, $06, $3c, $36, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c, $30, $63, $3e
	byte	$00[8]
	byte	$18, $00, $7e, $00, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $30, $1e, $00, $00, $00, $1c, $36, $36, $1c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[5]
	byte	$cc, $66, $33, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $36, $1c
	byte	$00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $7e, $7e, $7e, $7e, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' st_font        file "st4font.def"
	byte	$00[55]
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$18[9]
	byte	$00[7]
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $00, $00, $18, $3c, $7e, $66, $66
	byte	$66, $7e, $7e, $66, $66, $66, $66, $30, $18, $00, $00, $7e, $7e, $06, $06, $3e
	byte	$3e, $06, $06, $06, $06, $7e, $7e, $18, $0c, $30, $18, $3c, $7e, $66, $66, $06
	byte	$06, $06, $06, $66, $66, $7e, $3c, $00, $00, $30, $18, $66, $66, $66, $6e, $6e
	byte	$7e, $7e, $76, $76, $66, $66, $66, $00, $00, $30, $18, $7c, $7e, $06, $06, $0e
	byte	$1c, $38, $70, $60, $60, $7e, $3e, $00, $00, $30, $18, $7e, $7e, $30, $30, $18
	byte	$18, $0c, $0c, $06, $06, $7e, $7e, $00, $00, $18, $18, $00, $7e, $7e, $30, $30
	byte	$18, $18, $0c, $0c, $06, $7e, $7e, $00, $00, $30, $18, $3c, $7e, $66, $66, $66
	byte	$66[5]
	byte	$7e, $3c, $00, $00, $00, $00, $06, $06, $06, $06, $16, $1e, $0e, $06, $06, $06
	byte	$7e, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $7c, $60, $7c, $7e, $66, $66
	byte	$7e, $7c, $30, $18, $00, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $06, $06
	byte	$7e, $7c, $18, $0c, $00, $00, $30, $18, $00, $3c, $3e, $06, $06, $06, $06, $06
	byte	$7e, $7c, $00, $00, $00, $00, $30, $18, $00, $3e, $7e, $66, $66, $66, $66, $66
	byte	$66, $66, $00, $00, $00, $00, $30, $18, $00, $7c, $7e, $06, $0e, $3c, $70, $60
	byte	$7e, $3e, $00, $00, $00, $00, $30, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $18, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $00, $3c, $7e, $66, $66, $66, $66, $66
	byte	$7e, $3c, $00, $00, $00, $00, $1c, $1c, $18, $18, $38, $3c, $1c, $18, $18, $18
	byte	$3c, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[8]
	byte	$00, $00, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $00, $00, $00, $00
	byte	$00[9]
	byte	$66, $66, $ff, $ff, $66, $66, $ff, $ff, $66, $66, $00, $00, $00, $00, $18, $18
	byte	$7c, $7e, $06, $06, $3e, $7c, $60, $60, $7e, $3e, $18, $18, $00, $00, $00, $66
	byte	$66, $30, $30, $18, $18, $0c, $0c, $66, $66, $00, $00, $00, $00, $00, $3c, $7e
	byte	$66, $66, $3c, $1c, $1c, $fc, $fe, $66, $66, $fe, $fc, $00, $00, $00, $00, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $30
	byte	$18, $1c, $0c, $0c, $0c, $0c, $0c, $0c, $1c, $18, $30, $00, $00, $00, $00, $0c
	byte	$18, $38, $30, $30, $30, $30, $30, $30, $38, $18, $0c, $00, $00, $00, $00, $00
	byte	$66, $66, $3c, $3c, $ff, $ff, $3c, $3c, $66, $66, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $18, $7e, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[5]
	byte	$0c, $04, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00[13]
	byte	$18, $18, $18, $00, $00, $00, $00, $60, $60, $60, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $76, $6e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $18, $18, $1c, $1c, $18, $18, $18, $18, $18
	byte	$18, $7e, $7e, $00, $00, $00, $00, $3c, $7e, $66, $66, $30, $30, $18, $18, $0c
	byte	$0c, $7e, $7e, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $30, $30, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $30, $30, $38, $38, $3c, $3c, $36, $36, $7e
	byte	$7e, $30, $30, $00, $00, $00, $00, $7e, $7e, $06, $06, $3e, $7e, $60, $60, $60
	byte	$66, $7e, $3c, $00, $00, $00, $00, $38, $3c, $0e, $06, $06, $3e, $7e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $7e, $7e, $60, $60, $30, $30, $18, $18, $0c
	byte	$0c, $0c, $0c, $00, $00, $00, $00, $3c, $7e, $66, $66, $3c, $3c, $66, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $7c, $60, $60, $60
	byte	$70, $3c, $1c, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $18
	byte	$18, $18, $18, $0c, $04, $00, $00, $00, $70, $38, $1c, $0e, $07, $0e, $1c, $38
	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $7e, $7e
	byte	$00[8]
	byte	$0e, $1c, $38, $70, $e0, $70, $38, $1c, $0e, $00, $00, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $30, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $66, $66, $36, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $18
	byte	$3c, $7e, $66, $66, $66, $7e, $7e, $66, $66, $66, $66, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $7e, $3e, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $06, $06, $06, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $66, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $7e, $7e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $7c
	byte	$7e, $06, $06, $76, $76, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $66
	byte	$66, $66, $66, $7e, $7e, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $7e
	byte	$7e, $18, $18, $18, $18, $18, $18, $18, $18, $7e, $7e, $00, $00, $00, $00, $60
	byte	$60[7]
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $36, $36, $1e, $1e, $36, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $06, $06, $06, $06, $06, $06, $06, $06
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $c6, $c6, $ee, $ee, $fe, $d6, $d6, $c6
	byte	$c6, $c6, $c6, $c6, $00, $00, $00, $00, $66, $66, $66, $6e, $6e, $7e, $7e, $76
	byte	$76, $66, $66, $66, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $66, $7e, $3e
	byte	$06, $06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $56, $3e, $6c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $7e, $3e, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $7c, $7e, $06, $06, $0e, $1c, $38, $70
	byte	$60, $60, $7e, $3e, $00, $00, $00, $00, $7e, $7e, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$3c, $3c, $18, $18, $00, $00, $00, $00, $c6, $c6, $c6, $c6, $c6, $d6, $d6, $fe
	byte	$fe, $ee, $c6, $82, $00, $00, $00, $00, $66, $66, $66, $3c, $3c, $18, $18, $3c
	byte	$3c, $66, $66, $66, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $3c, $3c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$0c, $0c, $3c, $3c, $00, $00, $00, $00, $06, $06, $0c, $0c, $18, $18, $30, $30
	byte	$60, $60, $c0, $c0, $00, $00, $00, $00, $3c, $3c, $30, $30, $30, $30, $30, $30
	byte	$30, $30, $3c, $3c, $00, $00, $00, $00, $18, $18, $3c, $3c, $66, $66, $00, $00
	byte	$00[18]
	byte	$fe, $fe, $00, $00, $00, $00, $0c, $0c, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$3c, $7c, $60, $7c, $7e, $66, $66, $7e, $7c, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $3e, $06, $06, $06, $06, $06, $7e, $7c, $00, $00, $00, $00, $60, $60, $60
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $7e, $06, $06, $7e, $7c, $00, $00, $00, $00, $70, $78, $18
	byte	$18, $7e, $7e, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $7e, $7c, $60, $7e, $3e, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $1c, $18, $18, $18, $18, $18, $3c, $3c, $00, $00, $00, $00, $30, $30, $00
	byte	$30[9]
	byte	$3e, $1e, $00, $00, $06, $06, $06, $36, $36, $1e, $1e, $1e, $36, $36, $66, $66
	byte	$00, $00, $00, $00, $1c, $1c, $18, $18, $18, $18, $18, $18, $18, $18, $3c, $3c
	byte	$00[7]
	byte	$6c, $fe, $fe, $d6, $d6, $c6, $c6, $c6, $c6, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $06, $06, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $60, $60, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $06, $0e, $3c, $70, $60, $7e, $3e, $00, $00, $00, $00, $00, $18, $18
	byte	$7e, $7e, $18, $18, $18, $18, $18, $78, $70, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$7e, $7c, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $c6, $c6, $d6, $d6, $fe, $fe, $ee
	byte	$c6, $82, $00, $00, $00, $00, $00, $00, $00, $66, $66, $3c, $3c, $18, $3c, $3c
	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $7e
	byte	$7c, $60, $7e, $3e, $00, $00, $00, $00, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $18, $18, $18, $0c, $0c, $18, $18, $18
	byte	$18, $30, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $0c, $18, $18, $18, $18, $30, $30, $18, $18, $18
	byte	$18, $0c, $00, $00, $00, $00, $6c, $7e, $36, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
'-' a8_font        file "atari8.fnt"
	byte	$00, $6c, $fe, $fe, $7c, $38, $10, $00, $18, $18, $18, $f8, $f8, $18, $18, $18
	byte	$c0[8]
	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
	byte	$0f[8]
	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
	byte	$66[5]
	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
	byte	$08, $00
'-' a8_font2       file "atari8.fnt"
	byte	$00, $6c, $fe, $fe, $7c, $38, $10, $00, $18, $18, $18, $f8, $f8, $18, $18, $18
	byte	$c0[8]
	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
	byte	$0f[8]
	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
	byte	$66[5]
	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
	byte	$08, $00
'-' amiga_font     file "amigafont.def"
	byte	$00[530]
	byte	$18[6]
	byte	$00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $00, $00, $00
	byte	$00[10]
	byte	$36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $7c, $06, $06, $3c, $60, $60, $3e, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $c6, $69, $36, $18, $6c, $96, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$1c, $36, $36, $1e, $6e, $3b, $33, $73, $de, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $66, $3c, $ff, $3c, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[7]
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00
	byte	$00[16]
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $c0, $60, $30, $18, $0c, $06
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $76, $7e, $6e, $66
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $30, $18, $0c
	byte	$06, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $38, $60, $60
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30
	byte	$30, $30, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06, $3e, $60, $60, $60
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $06, $06, $3e, $66, $66
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $7e, $60, $60, $60, $30, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $3c, $66, $66
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $7c, $60, $60
	byte	$30, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $60, $18, $06, $18, $60
	byte	$00[12]
	byte	$7e, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06
	byte	$18, $60, $18, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60
	byte	$60, $30, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
	byte	$7b, $6b, $7b, $03, $03, $1e, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66
	byte	$66, $3e, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $78, $0c, $06
	byte	$06, $06, $06, $06, $0c, $78, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $63
	byte	$63, $63, $63, $63, $33, $1f, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
	byte	$06, $1e, $06, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
	byte	$06, $1e, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06
	byte	$06, $76, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3c, $18, $18
	byte	$18[5]
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60, $60, $60, $60, $60, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $c3, $63, $33, $1b, $0f, $1b, $33, $63
	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $6b, $63, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7b, $73, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e, $06, $06, $06
	byte	$06, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $7b
	byte	$fe, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $33, $33, $1f, $1b, $33, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06, $0c, $18, $30, $60, $66
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $7e, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36, $36, $1c
	byte	$08, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $c3, $c3, $c3, $db, $ff, $e7
	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $3c, $66, $c3
	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $7f, $60, $60, $30, $18, $0c, $06, $03
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $03, $06, $0c, $18, $30, $60, $c0
	byte	$00[8]
	byte	$3c, $30, $30, $30, $30, $30, $30, $30, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$08, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$7f, $00, $00, $00, $00, $00, $00, $18, $18, $30, $00, $00, $00, $00, $00, $00
	byte	$00[10]
	byte	$3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $06, $06, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60
	byte	$7c, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $0c
	byte	$3e, $0c, $0c, $0c, $0c, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $66, $66, $66, $7c, $60, $60, $3c, $00, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $18, $00
	byte	$18[5]
	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $30, $00, $30, $30, $30, $30, $30
	byte	$30, $30, $1e, $00, $00, $00, $00, $00, $03, $03, $03, $33, $1b, $0f, $1b, $33
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $66
	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $66
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e
	byte	$06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7c, $66, $66, $66, $7c
	byte	$60, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $06, $06, $06
	byte	$06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $06, $0c, $30, $60
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $0c, $0c, $3e, $0c, $0c, $0c, $0c
	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $6b, $3e
	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
	byte	$18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $30, $18, $0c, $06
	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18
	byte	$70, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18
	byte	$0e, $00, $00, $00, $00, $00, $00, $00, $46, $5d, $31, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$c0, $f0, $3c, $0f, $c3, $f0, $3c, $0f, $03, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $00, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $7e, $1b, $1b, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$78, $cc, $0c, $0c, $1e, $0c, $0c, $06, $7f, $00, $00, $00, $00, $00, $00, $00
	byte	$66, $3c, $66, $66, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$c3, $c3, $66, $3c, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $18, $18, $00, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $06, $06, $3c, $66, $66, $66, $3c, $60, $60, $3c, $00, $00, $00, $00, $00
	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $81, $b9, $85, $85, $b9, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $33, $33, $7e, $00, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $cc, $66, $33, $66, $cc, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $81, $9d, $a5, $9d, $a5, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $18, $7e, $18, $18, $18, $00, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$1e, $30, $30, $18, $0c, $06, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$1e, $30, $30, $1c, $30, $30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $66, $66, $66, $66, $66, $fe, $06, $06, $00, $00, $00, $00, $00
	byte	$7c, $5e, $5e, $5e, $5c, $50, $50, $50, $50, $50, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$30, $18, $00, $00, $00, $00, $00, $18, $1c, $18, $18, $18, $18, $18, $00, $00
	byte	$00[7]
	byte	$3c, $66, $66, $3c, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $33, $66, $cc, $66, $33, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$02, $63, $32, $1a, $4e, $66, $f3, $40, $40, $00, $00, $00, $00, $00, $00, $00
	byte	$04, $c6, $64, $34, $7c, $8c, $46, $23, $f0, $00, $00, $00, $00, $00, $00, $00
	byte	$03, $c4, $66, $34, $5b, $6c, $f6, $43, $40, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $00, $18, $0c, $06, $06, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$06, $0c, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $33, $3e, $63, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$4e, $39, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$63, $00, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$1c, $22, $1c, $36, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$f8, $3c, $3c, $36, $f6, $3f, $33, $33, $f3, $00, $00, $00, $00, $00, $00, $00
	byte	$78, $0c, $06, $06, $06, $06, $06, $0c, $78, $30, $18, $00, $00, $00, $00, $00
	byte	$0c, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$66, $00, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$66, $00, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$1e, $36, $66, $66, $6f, $66, $66, $36, $1e, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $73, $67, $6f, $7b, $73, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$06, $0c, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $33, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$63, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $63, $36, $1c, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$be, $63, $73, $7b, $6b, $6f, $67, $63, $3f, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $0c, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$08, $36, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$63, $00, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $c3, $66, $3c, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$03, $03, $3f, $63, $63, $3f, $03, $03, $03, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $66, $36, $66, $66, $66, $36, $06, $06, $00, $00, $00, $00, $00
	byte	$06, $0c, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$60, $30, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $24, $18, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $d8, $fe, $1b, $1b, $ee, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $3c, $06, $06, $06, $06, $3c, $18, $0c, $00, $00, $00, $00, $00
	byte	$06, $0c, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$60, $30, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $0c, $00, $0c, $0c, $0c, $0c, $0c, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$03, $06, $3f, $18, $3c, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $00, $3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
	byte	$06, $0c, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$60, $30, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $00, $7e, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $73, $7b, $6f, $67, $3f, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
	byte	$06, $06, $06, $3e, $66, $66, $66, $3e, $06, $06, $06, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
	byte	$00, $7e, $66, $66, $66, $66, $66, $66, $66, $7e, $00, $00, $00, $00, $00, $00
	byte	$00[526]
'-' vga16          long  $00000000,$00008000,$00800000,$00808000,$80000000,$80008000,$80400000,$AAAAAA00,$55555500,$0000FF00,$00FF0000,$00FFFF00,$FF000000,$FF00FF00,$FFFF0000,$FFFFFF00
	byte	$00[5]
	byte	$80, $00, $00, $00, $00, $80, $00, $00, $80, $80, $00, $00, $00, $00, $80, $00
	byte	$80, $00, $80, $00, $00, $40, $80, $00, $aa, $aa, $aa, $00, $55, $55, $55, $00
	byte	$ff, $00, $00, $00, $00, $ff, $00, $00, $ff, $ff, $00, $00, $00, $00, $ff, $00
	byte	$ff, $00, $ff, $00, $00, $ff, $ff, $00, $ff, $ff, $ff
'-' ataripalette   file "ataripalettep2.def"
	byte	$00[5]
	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
'-' ataripalette2  file "ataripalettep2.def"
	byte	$00[5]
	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
'-' 
'-' '**********************************************************************************
'-' '
'-' '        Timings and colors definitions
'-' '
'-' '**********************************************************************************
'-' 
'-' '                      bf.hs, hs,  bf.vis  visible, up p., vsync, down p.,  cpl, total lines, clock,       hubset                                scanlines  ud bord mode reserved
'-' timings         long   8,     60,  8,       1024,   7,     4,     1,        128, 600,         340500000,   %1_100111__10_1010_1000__1111_1011,   600,        0,     192, 0, 0
	byte	$08, $00, $00, $00, $3c, $00, $00, $00, $08, $00, $00, $00, $00, $04, $00, $00
	byte	$07, $00, $00, $00, $04, $00, $00, $00, $01, $00, $00, $00, $80, $00, $00, $00
	byte	$58, $02, $00, $00, $20, $9e, $4b, $14, $fb, $a8, $9e, $01, $58, $02, $00, $00
	byte	$00, $00, $00, $00, $c0, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' 'timings        long   16,    80,  12,      1024,   8,     4,     8,        128, 576,         336956522,   %1_101101__11_0000_0110__1111_1011,   576,        0,     192, 0, 0
'-' vgacolors       byte   0, 117, 199, 151, 39, 71, 246, 10, 5, 121, 203, 155, 43, 75, 234, 15
	byte	$00, $75, $c7, $97, $27, $47, $f6, $0a, $05, $79, $cb, $9b, $2b, $4b, $ea, $0f
'-' 
'-' ''--------  Initialization  ----------------------------------------------------------------
'-' 
'-' hdmi            setq    #6
	byte	$28, $0c, $64, $fd
'-'                 rdlong  vblankptr,  ptra                   ' read pointers
	byte	$00, $a5, $05, $fb
'-'                 setq    #8
	byte	$28, $10, $64, $fd
'-'                 rdlong  m_bs,modeptr                       ' read timings
	byte	$d3, $8a, $01, $fb
'-' 
'-'                 bitl    hbase, #31 wcz                     ' if pin 31 is set, use full strength for Adafruit Pico HDMI board
	byte	$1f, $ac, $1d, $f4
'-'                 setcmod #$100                              ' enable HDMI mode
	byte	$3c, $00, $66, $fd
'-'                 mov     t1,#448                            ' 7 << 6          
	byte	$c0, $c7, $05, $f6
'-'                 add     t1,hbase
	byte	$d6, $c6, $01, $f1
'-'                 drvl    t1                                 ' #7<<6 + hdmi_base      ' enable HDMI pins
	byte	$58, $c6, $61, $fd
'-'         if_z    wrpin   #0, t1  '#7<<6 + hdmi_base         ' for Adafruit breakout board - full logic as in Pico, the board has 220 Ohm resistors on it
	byte	$e3, $00, $08, $ac
'-' 	if_nz   wrpin   ##%10110_1111_0111_10_00000_0, t1  ' #7<<6 + hdmi_base      ' a '123 ohm BITDAC for Parallax breakout board
	byte	$7b, $0b, $80, $5f, $e3, $00, $0b, $5c
'-'                 setxfrq ##$0CCCCCCC+1                      ' set streamer freq to 1/10th clk
	byte	$66, $66, $86, $ff, $1d, $9a, $65, $fd
'-' '
'-'                 mov 	t1,hbase			   '
	byte	$d6, $c6, $01, $f6
'-'                 shl 	t1,#17                             '
	byte	$11, $c6, $65, $f0
'-'                 add 	lutg8,t1                           ' add the pin base to he streamer constant
	byte	$e3, $a2, $01, $f1
'-'                 sub 	i_upporch,#2			   ' the driver will call 2 blank lines itself to preload the buffer, so sub #2 from up porch time
	byte	$02, $92, $85, $f1
'-' 
'-'                 cogid   t1              		   ' get a cogid
	byte	$01, $c6, $61, $fd
'-'                 mul     t1, #12                            ' compute the offset to PSRAM mailbox 
	byte	$0c, $c6, $05, $fa
'-'                 add     mailbox, t1                        ' add offset to find this COG's mailbox
	byte	$e3, $ae, $01, $f1
'-' 
'-' ''--------  frame rendering main loop  ---------------------------------------------------
'-' 
'-' p101            setq 	#3
	byte	$28, $06, $64, $fd
'-' 		rdlong  vblankptr,ptra
	byte	$00, $a5, $05, $fb
'-'                 setq    #47+6				   ' read sprite data
	byte	$28, $6a, $64, $fd
'-' 	 	rdlong  sprite1pointer,spriteptr
	byte	$d8, $dc, $01, $fb
'-' 		mov     spriteline,#0                      ' init the sprite line variable
	byte	$00, $4a, $06, $f6
'-'                 mov     dlinum, #0
	byte	$00, $a0, $05, $f6
'-'                 add     frames,#1			   ' increment the frame counter
	byte	$01, $9e, $05, $f1
'-'                 mov     dlptr2,dlptr			   ' init the temporary DL pointer
	byte	$d5, $b8, $01, $f6
'-' 
'-' 
'-'                 mov     linenum,#0			   ' init the current line #
	byte	$00, $9c, $05, $f6
'-'                 mov     rcnt,#0			   	   ' init the DL repeat counter
	byte	$00, $ce, $05, $f6
'-'                 mov     rcnt2a,affffffff 		   ' why?!                
	byte	$ed, $d2, $01, $f6
'-'                 
'-' 
'-' 
'-' '' ------- reload the palette. If bit31 set, don't reload, to prevent blinking while modifying the palette
'-'   
'-'                 testb   paletteptr,#31 wc
	byte	$1f, $a8, $15, $f4
'-'          if_nc  setq2   #255
	byte	$29, $fe, $65, $3d
'-'          if_nc  rdlong  $000, paletteptr                   'read palette
	byte	$d4, $00, $00, $3b
'-' 
'-' '' -----   up porch (before the picture)
'-' 
'-'                 mov     hsync0,sync_000      	           ' init constants for sync
	byte	$c0, $c2, $01, $f6
'-'                 mov     hsync1,sync_001	
	byte	$c1, $c4, $01, $f6
'-'                 callpa  i_upporch ,#blank                  ' call the porch line i_upporch (-2) times
	byte	$40, $92, $45, $fb
'-'                 wrlong  #0,vblankptr                       ' the vblank time ends here
	byte	$d2, $00, $68, $fc
'-'  
'-'    
'-'  
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'          	     call    #dli	                  ' call DL interpreter for line #0 at line #(-2) - 2 lines earlier, so it can start preloading data from PSRAM
	byte	$60, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                          rdfast  #64,buf1d                          ' prepare the HUB buffer for 4 scanlines
	byte	$df, $80, $78, $fc
'-' 
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-' 		call    #dli
	byte	$48, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                  call    #sprite				   ' sprites for line #0
	byte	$20, $01, $b0, $fd
'-'                 	
'-'                 
'-' 
'-'  
'-' '' ------- the main screen drawing starts here
'-' 
'-' p301            xcont   m_bs,hsync0   			  ' make a right porch
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1                       ' make hsync
	byte	$e2, $8c, $b1, $fc
'-'                 call    #dli                              ' process the DL for line+2                
	byte	$30, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   lutg8,#0			  ' display the line 
	byte	$00, $a2, $c5, $fc
'-'                  add     linenum,#1                        ' increment the current line number 
	byte	$01, $9c, $05, $f1
'-'                  call    #sprite                           ' process sprites for line+1             
	byte	$04, $01, $b0, $fd
'-'               
'-' 
'-'                 cmp     linenum,i_totalvis  wz            ' check if all lines displayed
	byte	$cd, $9c, $09, $f2
'-'     if_nz       jmp     #p301                             ' if not, display the next line
	byte	$dc, $ff, $9f, $5d
'-' 
'-' ' ---------------- All visible lines displayed now, start vblank  
'-' 
'-' p112            wrlong  #1,vblankptr                       ' tell the system that the vblank started
	byte	$d2, $02, $68, $fc
'-'                 callpa  i_downporch ,#blank                ' bottom blanks
	byte	$28, $96, $45, $fb
'-'                 mov     hsync0,sync_222                    ' vsync on
	byte	$c2, $c2, $01, $f6
'-'                 mov     hsync1,sync_223
	byte	$c3, $c4, $01, $f6
'-'                 callpa  i_vsync,#blank                     ' vertical sync blanks
	byte	$25, $94, $45, $fb
'-'                 jmp     #p101                              ' return to the main loop
	byte	$4c, $ff, $9f, $fd
'-' 
'-' '' --------------- END of frame rendering loop ---------------------------------------------------------------------------
'-' 
'-' '' --------------- Display list interpreter ---------------------------------------------------------------------------
'-' 
'-' dli             cmp     rcnt,#0 wz			   ' check the DL repeat counter 
	byte	$00, $ce, $0d, $f2
'-' 
'-'     if_z        rdlong  dl,dlptr2				
	byte	$dc, $ba, $01, $ab
'-'     if_z        add     dlptr2,#4
	byte	$04, $b8, $05, $a1
'-'     if_z        jmp     #p307                              ' no repeat, goto read and interpret the next DL entry
	byte	$14, $00, $90, $ad
'-' 
'-'                 sub     rcnt,#1 wz                         ' decrement the repeat counter
	byte	$01, $ce, $8d, $f1
'-'     if_nz       mov     dl,rdl                             ' restore repeating DL entry from temporary buffer
	byte	$eb, $ba, $01, $56
'-'                 incmod  rcnt2a,rcnt2 wcz                   ' address update counter
	byte	$e8, $d2, $19, $f7
'-'     if_c        add     dl,roffset                         ' if it rollovers, add the offset to the data address
	byte	$ea, $ba, $01, $c1
'-'                 mov     rdl,dl                             ' save the result
	byte	$dd, $d6, $01, $f6
'-' 
'-' p307	        mov     framebuf2,dl wcz                   ' move this to framebuf2. If normal DL entry, the frame buffer start will be extracted from this
	byte	$dd, $c0, $19, $f6
'-'                 getnib  t1,dl,#0
	byte	$dd, $c6, $41, $f8
'-'                 cmp     t1,#%0010 wz			   ' 0010 - display a normal graphics line, preload it from the PSRAM
	byte	$02, $c6, $0d, $f2
'-'     if_z        jmp     #preload
	byte	$70, $00, $90, $ad
'-'     		cmp     t1,#%0000 wz			   ' 0000 - display a line from a PSRAM list
	byte	$00, $c6, $0d, $f2
'-'     if_z        jmp     #preload2
	byte	$94, $00, $90, $ad
'-'                 cmp     t1,#%0001 wz			   ' 0001 - repeat
	byte	$01, $c6, $0d, $f2
'-'     if_z        jmp     #p390
	byte	$0c, $00, $90, $ad
'-'                 cmp     t1,#%0011 wz			   ' 0011 - palette reload
	byte	$03, $c6, $0d, $f2
'-'     if_z        jmp     #p391  
	byte	$28, $00, $90, $ad
'-' 
'-' p308            ret
	byte	$2d, $00, $64, $fd
'-'    
'-' p390            rdlong  rdl,dlptr2                         ' read the next DL entry to repeat
	byte	$dc, $d6, $01, $fb
'-'                 getword rcnt,framebuf2,#1                  ' read the repeat count
	byte	$e0, $ce, $39, $f9
'-'                 shr     rcnt,#4                            ' from 12 upper bits
	byte	$04, $ce, $45, $f0
'-'                 mov     rcnt2a,affffffff                   ' I still don't know why?
	byte	$ed, $d2, $01, $f6
'-'                 getnib  rcnt2,framebuf2,#4                 ' read the pointer update counter
	byte	$e0, $d0, $61, $f8
'-'                 getword roffset,framebuf2,#0               ' read the offset to add
	byte	$e0, $d4, $31, $f9
'-'                 shr     roffset,#4                         ' clean the command field from offset
	byte	$04, $d4, $45, $f0
'-'                 shl     roffset,#4                         ' and make it ready to add to the DL entry (address=20 upper bits)
	byte	$04, $d4, $65, $f0
'-'                 jmp     #dli                               ' now start repeating 
	byte	$8c, $ff, $9f, $fd
'-'  
'-' '' --------  Reload palette. To do 
'-' 
'-' p391           	getnib  t1,framebuf2,#2			   ' get a bank (0..15) of 16 colors
	byte	$e0, $c6, $51, $f8
'-'          	shl     t1,#4				   ' compute the LUT address
	byte	$04, $c6, $65, $f0
'-'         	shr     framebuf2,#12			   ' compute the HUB address of 16 new colors
	byte	$0c, $c0, $45, $f0
'-'          	setq2   #15				   ' load 16 entries
	byte	$29, $1e, $64, $fd
'-'          	altd    t1                                 ' from t1 LUT address
	byte	$00, $c6, $8d, $f9
'-'         	rdlong  $000, framebuf2         	
	byte	$e0, $00, $00, $fb
'-'         	jmp     #dli                
	byte	$70, $ff, $9f, $fd
'-'       
'-' '' --------------- A display list interpreter end ------------------------------------------------------------------------    
'-' 
'-' 
'-' '' --------------- Blank and vsync procedures called via callpa have to be in the middle of the code ---------------------
'-' 
'-' blank           xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'         _ret_   djnz    pa,#blank
	byte	$fb, $ed, $6f, $0b
'-'         
'-' '' -------------- Preload a line from PSRAM        
'-'         
'-' preload         mov     buf1c,dlinum			   ' preload a line buffer #dlinum (0..3)
	byte	$d0, $bc, $01, $f6
'-'                 shl     buf1c,#10		           ' 1024 bytes per line
	byte	$0a, $bc, $65, $f0
'-'                 add     buf1c,buf1d			   ' add the start address (himem-debug-4096) : Todo: debug variable!
	byte	$df, $bc, $01, $f1
'-'                 mov     buf1,buf1c
	byte	$de, $b4, $01, $f6
'-'                 incmod  dlinum,#3
	byte	$03, $a0, $05, $f7
'-' 
'-'                 shr     framebuf2,#4                      ' get the PSRAM start address from DL - Todo: use new DL format
	byte	$04, $c0, $45, $f0
'-'                 mov     buf2,a1024
	byte	$32, $b7, $01, $f6
'-'                 mov     cmd,framebuf2                      ' set the address
	byte	$e0, $b2, $01, $f6
'-'                 setnib  cmd, #%1011, #7                    ' attach the command - read burst from the external memory
	byte	$0b, $b2, $3d, $f8
'-'                 setq    #2				   ' write 3 longs to the mailbox
	byte	$28, $04, $64, $fd
'-'     _ret_       wrlong  cmd,mailbox			   ' read the PSRAM
	byte	$d7, $b2, $61, $0c
'-'  
'-'  
'-' preload2      '  incmod  dlinum,#3
'-'                 shr 	framebuf2,#4
	byte	$04, $c0, $45, $f0
'-'                 mov 	cmd,affffffff
	byte	$ed, $b2, $01, $f6
'-'                 mov 	buf1,framebuf2
	byte	$e0, $b4, $01, $f6
'-'                 setq	#1
	byte	$28, $02, $64, $fd
'-'     _ret_	wrlong  cmd,mailbox
	byte	$d7, $b2, $61, $0c
'-'                 
'-' 
'-' '' -------------- Draw sprites
'-' 
'-' sprite          mov t8,frames
	byte	$cf, $5c, $02, $f6
'-' 		and t8,#16 wz
	byte	$10, $5c, $0e, $f5
'-'                 mov spritenum, #17			' 16 +2 sprites. Todo: this should be a parameter
	byte	$11, $48, $06, $f6
'-' 	if_z    mov spritenum, #16	
	byte	$10, $48, $06, $a6
'-' 		
'-' 
'-' p802            mov     t5,spritenum		   	' prepare a pointer to load sprite data
	byte	$24, $57, $02, $f6
'-'                 mul     t5,#3          			' one sprite data set needs 3 longs
	byte	$03, $56, $06, $fa
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_y,0-0,#1		        ' get a sprite y
	byte	$00, $4e, $3a, $f9
'-'                 signx	sprite_y,#15			' they can be negative
	byte	$0f, $4e, $66, $f7
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_x,0-0,#0                 ' and x
	byte	$00, $4c, $32, $f9
'-'                 signx	sprite_x,#15
	byte	$0f, $4c, $66, $f7
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_h,0-0,#1		       	' get a sprite height
	byte	$00, $52, $3a, $f9
'-'                 sub     sprite_h,#1
	byte	$01, $52, $86, $f1
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_w,0-0,#0                 ' and width
	byte	$00, $50, $32, $f9
'-' 
'-' 
'-'                	cmps	sprite_x,a1024 wcz	         
	byte	$32, $4d, $5a, $f2
'-'      if_ge	jmp 	#p801                           ' go out if >1023
	byte	$bc, $00, $90, $3d
'-'               	cmps	sprite_w,#0 wcz	         
	byte	$00, $50, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if w=0
	byte	$b4, $00, $90, $ad
'-'               	cmps	sprite_h,#0 wcz	         
	byte	$00, $52, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if h=0
	byte	$ac, $00, $90, $ad
'-'                 mov 	t9,#0
	byte	$00, $5e, $06, $f6
'-'                 sub 	t9,sprite_w                      	
	byte	$28, $5f, $82, $f1
'-'      		cmps  	sprite_x,t9 wcz   		'
	byte	$2f, $4d, $5a, $f2
'-'      if_le	jmp 	#p801	                        ' go out if sprite out of screen at right
	byte	$9c, $00, $90, $ed
'-'      
'-'   		mov     t2,linenum			' display line # to check if sprite has to be displayed
	byte	$ce, $c8, $01, $f6
'-'   		subs    t2,sprite_y wcz                 ' check if the sprite has to be displayed
	byte	$27, $c9, $d9, $f1
'-'      if_c       jmp     #p801				' if not, go out
	byte	$90, $00, $90, $cd
'-'                 cmp     t2,sprite_h wcz		    	' we have now the sprite line #, check, if it is not >= sprite height
	byte	$29, $c9, $19, $f2
'-'      if_gt      jmp     #p801				' if yes, go out
	byte	$88, $00, $90, $1d
'-'                 
'-'                 mov     t3,spriteline			' compute the line buffer addres where to put the sprite line
	byte	$25, $cb, $01, $f6
'-'                 shl     t3,#10			       	' =1024*spriteline where spriteline=0..3		' 
	byte	$0a, $ca, $65, $f0
'-'                 add     t3,buf1d			' line buffer addr
	byte	$df, $ca, $01, $f1
'-'   		
'-'   		testb	sprite_x,#31 wc 		' check if sprite pos <0
	byte	$1f, $4c, $16, $f4
'-'      if_nc      add     t3,sprite_x   			' if >=0 add xpos. If <0, the address is the start of the line  - now we have the address to where wmlong the sprite
	byte	$26, $cb, $01, $31
'-' 
'-'                 mul 	t2,sprite_w			' compute the offset to the sprite line data
	byte	$28, $c9, $01, $fa
'-'      if_c	add     sprite_w,sprite_x		' if sprite_x negative, shorten the width
	byte	$26, $51, $02, $c1
'-'      if_c	sub 	t2,sprite_x			' and add the offset (sub negative) to the sprite data offset
	byte	$26, $c9, $81, $c1
'-'  
'-'                 alts    t5,#sprite1pointer		' get the pointer to the sprite (3 longs per sprite data)
	byte	$ee, $56, $96, $f9
'-'                 add     t2,0-0				' then add the offset
	byte	$00, $c8, $01, $f1
'-'      if_c 	jmp     #p899		
	byte	$10, $00, $90, $cd
'-' 	
'-' 	
'-' 		mov 	t4,sprite_x	'
	byte	$26, $cd, $01, $f6
'-' 		add	t4,sprite_w
	byte	$28, $cd, $01, $f1
'-' 		sub     t4,a1024 wcz			' check if the sprite goes right off the screen
	byte	$32, $cd, $99, $f1
'-' 
'-' 	if_nc	sub	sprite_w,t4			' if yes, make it narrower
	byte	$e6, $50, $82, $31
'-' 
'-' p899		mov 	t6,sprite_w
	byte	$28, $59, $02, $f6
'-' 	 	sub     t6,#1
	byte	$01, $58, $86, $f1
'-' 	 	shr	t6,#2				' bytes to longs
	byte	$02, $58, $46, $f0
'-' 
'-'                 setq   	t6
	byte	$28, $58, $62, $fd
'-'                 rdlong 368,t2				' read sprite data to the cog
	byte	$e4, $e0, $02, $fb
'-'                 mov t8,sprite_w
	byte	$28, $5d, $02, $f6
'-'                 and t8,#3 wz				' if width mod 4=0 we have full longs, nothing to do
	byte	$03, $5c, $0e, $f5
'-'         if_z    jmp #p898
	byte	$24, $00, $90, $ad
'-'          
'-'         
'-'                 mov  t9,#368
	byte	$70, $5f, $06, $f6
'-'                 add t9,t6				' find the last long of the sprite
	byte	$2c, $5f, $02, $f1
'-' 
'-'                 subr t8,#4				' if modulo4=1, mask 3 bytes, if 2, mask 2, if 1, mask 3
	byte	$04, $5c, $c6, $f2
'-'                 mul t8,#8				' bits to shr
	byte	$08, $5c, $06, $fa
'-'                 mov t7,##-1				' full of 1s
	byte	$ff, $ff, $7f, $ff, $ff, $5b, $06, $f6
'-'                 shr t7,t8				' SHR to make 0s for masking
	byte	$2e, $5b, $42, $f0
'-'                 altd t9,#0				' and mask 
	byte	$00, $5e, $8e, $f9
'-'                 and 0-0, t7
	byte	$2d, $01, $00, $f5
'-'                
'-' 
'-' p898            setq   t6				' write the sprite data to the line buffer
	byte	$28, $58, $62, $fd
'-'                 wmlong 368,t3				
	byte	$e5, $e0, $7a, $fa
'-'                 
'-' p801            djnf spritenum,#p802			' get the next sprite
	byte	$c1, $49, $7e, $fb
'-'                 incmod spriteline,#3			' prepare to fill the next line
	byte	$03, $4a, $06, $f7
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 	
'-' 	
'-'                
'-'  
'-' '' -------------- Graphics line ------------------------------------------------------------
'-'  
'-' 
'-' '' consts and vars
'-' 
'-' sync_000        long    %1101010100_1101010100_1101010100_10    '
	byte	$52, $4d, $35, $d5
'-' sync_001        long    %1101010100_1101010100_0010101011_10    '        hsync
	byte	$ae, $42, $35, $d5
'-' sync_222        long    %0101010100_0101010100_0101010100_10    'vsync
	byte	$52, $45, $15, $55
'-' sync_223        long    %0101010100_0101010100_1010101011_10    'vsync + hsync
	byte	$ae, $4a, $15, $55
'-' 
'-' border          long    %00000000_00011010_00101100_00000000
	byte	$00, $2c, $1a, $00
'-' 
'-' '------ these longs will be set by setmode function
'-' 
'-' m_bs            long    0        'blanks before sync
	byte	$00, $00, $00, $00
'-' m_sn            long    0        'sync
	byte	$00, $00, $00, $00
'-' m_bv            long    0        'blanks before visible
	byte	$00, $00, $00, $00
'-' m_vi            long    0        'visible pixels #
	byte	$00, $00, $00, $00
'-' 'm_border        long    0        'left/right borders
'-' i_upporch       long    0        'up porch lines
	byte	$00, $00, $00, $00
'-' i_vsync         long    0        'vsync lines
	byte	$00, $00, $00, $00
'-' i_downporch     long    0        'down porch lines
	byte	$00, $00, $00, $00
'-' i_cpl           long    0        'chars/longs per line
	byte	$00, $00, $00, $00
'-' i_totalvis      long    0
	byte	$00, $00, $00, $00
'-' 
'-' '-------------------------------------
'-'  
'-' linenum         long    0
	byte	$00, $00, $00, $00
'-' frames          long    0
	byte	$00, $00, $00, $00
'-' dlinum long 0
	byte	$00, $00, $00, $00
'-' lutg8           long    $70880400 ' 0111_0000_1000_1000
	byte	$00, $04, $88, $70
'-' 
'-' vblankptr       long    0
	byte	$00, $00, $00, $00
'-' modeptr         long    0
	byte	$00, $00, $00, $00
'-' paletteptr      long    0
	byte	$00, $00, $00, $00
'-' dlptr           long    0
	byte	$00, $00, $00, $00
'-' hbase           long    1
	byte	$01, $00, $00, $00
'-' mailbox         long    0
	byte	$00, $00, $00, $00
'-' spriteptr          long 0
	byte	$00, $00, $00, $00
'-' 
'-' cmd             long    0
	byte	$00, $00, $00, $00
'-' buf1            long    $80000-1024-4096
	byte	$00, $ec, $07, $00
'-' buf2            long    1024
	byte	$00, $04, $00, $00
'-' dlptr2          long    1
	byte	$01, $00, $00, $00
'-' dl              long    1
	byte	$01, $00, $00, $00
'-' 
'-' buf1c long 0
	byte	$00, $00, $00, $00
'-' buf1d            long    $80000-1024-4096
	byte	$00, $ec, $07, $00
'-' framebuf2       long    1
	byte	$01, $00, $00, $00
'-' hsync0          long    1
	byte	$01, $00, $00, $00
'-' hsync1          long    1
	byte	$01, $00, $00, $00
'-' 
'-' t1              long    1
	byte	$01, $00, $00, $00
'-' t2 long 0
	byte	$00, $00, $00, $00
'-' t3 long 0
	byte	$00, $00, $00, $00
'-' t4 long 0
	byte	$00, $00, $00, $00
'-' 
'-' rcnt            long    0  'dl repeat count
	byte	$00, $00, $00, $00
'-' rcnt2           long    0
	byte	$00, $00, $00, $00
'-' rcnt2a          long    0
	byte	$00, $00, $00, $00
'-' roffset         long    0
	byte	$00, $00, $00, $00
'-' rdl             long    0  'dl repeat line
	byte	$00, $00, $00, $00
'-' dlc             long    0  'dl command
	byte	$00, $00, $00, $00
'-' 
'-' affffffff       long    $ffffffff
	byte	$ff, $ff, $ff, $ff
'-' sprite1pointer long 0
	byte	$00, $00, $00, $00
'-' sprite1xy      long 0
	byte	$00, $00, $00, $00
'-' sprite1wh      long 0
	byte	$00, $00, $00, $00
'-' sprite2pointer long 0
	byte	$00, $00, $00, $00
'-' sprite2xy      long 0
	byte	$00, $00, $00, $00
'-' sprite2wh      long 0
	byte	$00, $00, $00, $00
'-' sprite3pointer long 0
	byte	$00, $00, $00, $00
'-' sprite3xy      long 0
	byte	$00, $00, $00, $00
'-' sprite3wh      long 0
	byte	$00, $00, $00, $00
'-' sprite4pointer long 0
	byte	$00, $00, $00, $00
'-' sprite4xy      long 0
	byte	$00, $00, $00, $00
'-' sprite4wh      long 0
	byte	$00, $00, $00, $00
'-' sprite5pointer long 0
	byte	$00, $00, $00, $00
'-' sprite5xy      long 0
	byte	$00, $00, $00, $00
'-' sprite5wh      long 0
	byte	$00, $00, $00, $00
'-' sprite6pointer long 0
	byte	$00, $00, $00, $00
'-' sprite6xy      long 0
	byte	$00, $00, $00, $00
'-' sprite6wh      long 0
	byte	$00, $00, $00, $00
'-' sprite7pointer long 0
	byte	$00, $00, $00, $00
'-' sprite7xy      long 0
	byte	$00, $00, $00, $00
'-' sprite7wh      long 0
	byte	$00, $00, $00, $00
'-' sprite8pointer long 0
	byte	$00, $00, $00, $00
'-' sprite8xy      long 0
	byte	$00, $00, $00, $00
'-' sprite8wh      long 0
	byte	$00, $00, $00, $00
'-' sprite9pointer long 0
	byte	$00, $00, $00, $00
'-' sprite9xy      long 0
	byte	$00, $00, $00, $00
'-' sprite9wh      long 0
	byte	$00, $00, $00, $00
'-' sprite10pointer long 0
	byte	$00, $00, $00, $00
'-' sprite10xy      long 0
	byte	$00, $00, $00, $00
'-' sprite10wh      long 0
	byte	$00, $00, $00, $00
'-' sprite11pointer long 0
	byte	$00, $00, $00, $00
'-' sprite11xy      long 0
	byte	$00, $00, $00, $00
'-' sprite11wh      long 0
	byte	$00, $00, $00, $00
'-' sprite12pointer long 0
	byte	$00, $00, $00, $00
'-' sprite12xy      long 0
	byte	$00, $00, $00, $00
'-' sprite12wh      long 0
	byte	$00, $00, $00, $00
'-' sprite13pointer long 0
	byte	$00, $00, $00, $00
'-' sprite13xy      long 0
	byte	$00, $00, $00, $00
'-' sprite13wh      long 0
	byte	$00, $00, $00, $00
'-' sprite14pointer long 0
	byte	$00, $00, $00, $00
'-' sprite14xy      long 0
	byte	$00, $00, $00, $00
'-' sprite14wh      long 0
	byte	$00, $00, $00, $00
'-' sprite15pointer long 0
	byte	$00, $00, $00, $00
'-' sprite15xy      long 0
	byte	$00, $00, $00, $00
'-' sprite15wh      long 0
	byte	$00, $00, $00, $00
'-' sprite16pointer long 0
	byte	$00, $00, $00, $00
'-' sprite16xy      long 0
	byte	$00, $00, $00, $00
'-' sprite16wh      long 0
	byte	$00, $00, $00, $00
'-' sprite17pointer long 0
	byte	$00, $00, $00, $00
'-' sprite17xy      long 0
	byte	$00, $00, $00, $00
'-' sprite17wh      long 0
	byte	$00, $00, $00, $00
'-' sprite18pointer long 0
	byte	$00, $00, $00, $00
'-' sprite18xy      long 0
	byte	$00, $00, $00, $00
'-' sprite18wh      long 0
	byte	$00, $00, $00, $00
'-' spritenum long 0
	byte	$00, $00, $00, $00
'-' 
'-' spriteline long 0
	byte	$00, $00, $00, $00
'-' sprite_x long 900
	byte	$84, $03, $00, $00
'-' sprite_y long 0
	byte	$00, $00, $00, $00
'-' sprite_w long 16
	byte	$10, $00, $00, $00
'-' sprite_h long 64
	byte	$40, $00, $00, $00
'-' l2 long 0
	byte	$00, $00, $00, $00
'-' t5 long 0
	byte	$00, $00, $00, $00
'-' t6 long 0
	byte	$00, $00, $00, $00
'-' t7 long 0
	byte	$00, $00, $00, $00
'-' t8 long 0
	byte	$00, $00, $00, $00
'-' t9 long 0
	byte	$00, $00, $00, $00
'-' preloadaddr long 0
	byte	$00, $00, $00, $00
'-' preloadlineaddr long 0
	byte	$00, $00, $00, $00
'-' a1024 long 1024
	byte	$00, $04, $00, $00
'-' 
'-' aa long 992
	byte	$e0, $03, $00, $00
'-' a1023 long 1023
	byte	$ff, $03, $00, $00
'-' a4096 long 4096
	byte	$00, $10, $00, $00
'-'  fit 368
'-'  fit 368
	alignl
_psram4_spin2_dat_
'-'     listdata long 0[8*8]
	byte	$00[256]
'-'             orgh
'-' 
'-' ' driver state
'-' drivercog   long    -1  ' COG id of driver
	byte	$ff, $ff, $ff, $ff
'-' driverlock  long    -1  ' LOCK id of driver
	byte	$ff, $ff, $ff, $ff
'-' 
'-' ' delay profile
'-' delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
	byte	$07, $00, $00, $00, $00, $cf, $7b, $05, $80, $d1, $f0, $08, $80, $4f, $47, $0c
	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
'-' 
'-' ' data to be passed to driver when starting it
'-' startupData
'-'     long    0           ' current frequency
	byte	$00, $00, $00, $00
'-'     long    FLAGS       ' optional flags for driver
	byte	$00, $00, $00, $10
'-'     long    0           ' reset pin mask on port A for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port B for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    DATABUS     ' PSRAM data bus start pin
	byte	$30, $00, $00, $00
'-'     long    deviceData  ' address of devices data structure in HUBRAM
	long	@@@_psram4_spin2_dat_ + 328
'-'     long    qosData     ' address of QoS data structure in HUBRAM
	long	@@@_psram4_spin2_dat_ + 456
'-'     long    $7FF00   ' address of mailbox structure in HUBRAM
	byte	$00, $ff, $07, $00
'-' 
'-' ' data for memory
'-' deviceData
'-'     ' 16 bank parameters follow (16MB per bank)
'-'     long    0[16]                               ' banks 0-15
	byte	$00[64]
'-'     ' 16 banks of pin parameters follow
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
	byte	$36, $37, $00, $00
'-'     long    -1[15]                              ' banks 1-15
	byte	$ff[60]
'-' 
'-' ' data for COG polling
'-' qosData 
'-'     long    $7FFF0000[8]    ' cog 0-7 default QoS parameters
	byte	$00, $00, $ff, $7f, $00, $00, $ff, $7f, $00, $00, $ff, $7f, $00, $00, $ff, $7f
	byte	$00, $00, $ff, $7f, $00, $00, $ff, $7f, $00, $00, $ff, $7f, $00, $00, $ff, $7f
	alignl
_psram4drv_spin2_dat_
'-'                             orgh
'-' 
'-' driver_start
'-'                             org
'-' '..................................................................................................
'-' ' Memory layout for COG RAM once operational:
'-' '
'-' '  COG RAM address      Usage
'-' '  ---------------      ----
'-' '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
'-' '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
'-' '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
'-' '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
'-' '   $100-$197           Mailbox poller, error handlers, and all driver management code
'-' '  ~$198-$1F3           State and register variables
'-' '
'-' ' Also during driver COG startup:
'-' '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
'-' ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
'-' '..................................................................................................
'-'                             
'-' ' Mailbox storage after vector initialization
'-' 
'-' req0                        call    #init                   'do HW setup/initialization
	byte	$fc, $01, $b0, $fd
'-' data0                       rdlut   c, b wz                 'read bank info          
	byte	$ec, $db, $ab, $fa
'-' count0                      mov     a, b                    'set COGRAM address low nibble
	byte	$ec, $d7, $03, $f6
'-' req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
	byte	$68, $f0, $07, $a6
'-' data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
	byte	$0a, $da, $17, $f4
'-' count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
	byte	$50, $f0, $07, $16
'-' req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
	byte	$58, $f0, $07, $46
'-' data2                       mov     c, #$8                  'setup vector base to $80
	byte	$08, $da, $07, $f6
'-' count2                      setnib  a, c, #1                'prepare vector base address for bank
	byte	$ed, $d7, $0b, $f8
'-' req3                        altd    a, #0                   'prepare COG destination read address
	byte	$00, $d6, $8f, $f9
'-' data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
	byte	$61, $01, $a4, $fa
'-' count3                      incmod  c, #15 wz               'next vector
	byte	$0f, $da, $0f, $f7
'-' req4        if_nz           jmp     #count2                 'repeat
	byte	$ec, $ff, $9f, $5d
'-' data4                       incmod  b, #15 wz               'next bank
	byte	$0f, $d8, $0f, $f7
'-' count4      if_nz           jmp     #data0                  'repeat
	byte	$c8, $ff, $9f, $5d
'-' req5                        mov     ptra, #$20              'setup base LUT address to clear
	byte	$20, $f0, $07, $f6
'-' data5                       rep     #5, #80                 'update next 80 longs      
	byte	$50, $0a, $dc, $fc
'-' count5                      cmp     ptra, header wc         'check if LUT address range 
	byte	$df, $f1, $13, $f2
'-' req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
	byte	$e0, $f1, $93, $32
'-' data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
	byte	$61, $01, $3c, $cc
'-' count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
	byte	$61, $ab, $37, $3c
'-' req7        if_nc           add     $-1, const512           'increment source of LUT write data
	byte	$a3, $29, $00, $31
'-' data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
	byte	$ff, $ba, $03, $f6
'-' count7      _ret_           mov     255, #dolist            'setup list address, return to notify
	byte	$26, $ff, $05, $06
'-' 
'-' ' Mailbox parameter addresses per COG once patched
'-'                             
'-' cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
	byte	$04, $00, $00, $00
'-' cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
	byte	$10, $00, $00, $00
'-' cog2mboxdata                long    2*12+4                  '...
	byte	$1c, $00, $00, $00
'-' cog3mboxdata                long    3*12+4
	byte	$28, $00, $00, $00
'-' cog4mboxdata                long    4*12+4
	byte	$34, $00, $00, $00
'-' cog5mboxdata                long    5*12+4
	byte	$40, $00, $00, $00
'-' cog6mboxdata                long    6*12+4
	byte	$4c, $00, $00, $00
'-' cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
	byte	$58, $00, $00, $00
'-' 
'-' '..................................................................................................
'-' ' Per COG request and state setup and service branching
'-'         
'-' cog0                 
'-'                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
	byte	$20, $f0, $07, $f6
'-'                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
	byte	$18, $f2, $03, $f6
'-'                             mov     id, id0                 'get COG0 state
	byte	$cd, $bd, $03, $f6
'-'                             getword limit, id, #1           'get COG0 burst limit
	byte	$de, $43, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $cd, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$30, $04, $90, $5d
'-'                             mov     addr1, req0             'get mailbox request parameter for COG0
	byte	$00, $aa, $03, $f6
'-'                             mov     hubdata, data0          'get COG0 mailbox data parameter
	byte	$01, $ac, $03, $f6
'-'                             mov     count, count0           'get COG0 mailbox count parameter
	byte	$02, $ae, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d5, $c5, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $c4, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $c4, $63, $fd
'-' cog1                        
'-'                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
	byte	$2a, $f0, $07, $f6
'-'                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
	byte	$19, $f2, $03, $f6
'-'                             mov     id, id1                 'get COG1 state
	byte	$ce, $bd, $03, $f6
'-'                             getword limit, id, #1           'get COG1 burst limit
	byte	$de, $43, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $cd, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$00, $04, $90, $5d
'-'                             mov     addr1, req1             'get mailbox request parameter for COG1
	byte	$03, $aa, $03, $f6
'-'                             mov     hubdata, data1          'get COG1 mailbox data parameter
	byte	$04, $ac, $03, $f6
'-'                             mov     count, count1           'get COG1 mailbox count parameter
	byte	$05, $ae, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d5, $c5, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $c4, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $c4, $63, $fd
'-' cog2                         
'-'                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
	byte	$34, $f0, $07, $f6
'-'                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
	byte	$1a, $f2, $03, $f6
'-'                             mov     id, id2                 'get COG2 state
	byte	$cf, $bd, $03, $f6
'-'                             getword limit, id, #1           'get COG2 burst limit
	byte	$de, $43, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $cd, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$d0, $03, $90, $5d
'-'                             mov     addr1, req2             'get mailbox request parameter for COG2
	byte	$06, $aa, $03, $f6
'-'                             mov     hubdata, data2          'get COG2 mailbox data parameter
	byte	$07, $ac, $03, $f6
'-'                             mov     count, count2           'get COG2 mailbox count parameter
	byte	$08, $ae, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d5, $c5, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $c4, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $c4, $63, $fd
'-' cog3                        
'-'                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
	byte	$3e, $f0, $07, $f6
'-'                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
	byte	$1b, $f2, $03, $f6
'-'                             mov     id, id3                 'get COG3 state
	byte	$d0, $bd, $03, $f6
'-'                             getword limit, id, #1           'get COG3 burst limit
	byte	$de, $43, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $cd, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$a0, $03, $90, $5d
'-'                             mov     addr1, req3             'get mailbox request parameter for COG3
	byte	$09, $aa, $03, $f6
'-'                             mov     hubdata, data3          'get COG3 mailbox data parameter
	byte	$0a, $ac, $03, $f6
'-'                             mov     count, count3           'get COG3 mailbox count parameter
	byte	$0b, $ae, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d5, $c5, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $c4, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $c4, $63, $fd
'-' cog4                        
'-'                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
	byte	$48, $f0, $07, $f6
'-'                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
	byte	$1c, $f2, $03, $f6
'-'                             mov     id, id4                 'get COG4 state
	byte	$d1, $bd, $03, $f6
'-'                             getword limit, id, #1           'get COG4 burst limit
	byte	$de, $43, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $cd, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$70, $03, $90, $5d
'-'                             mov     addr1, req4             'get mailbox request parameter for COG4
	byte	$0c, $aa, $03, $f6
'-'                             mov     hubdata, data4          'get COG4 mailbox data parameter
	byte	$0d, $ac, $03, $f6
'-'                             mov     count, count4           'get COG4 mailbox count parameter
	byte	$0e, $ae, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d5, $c5, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $c4, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $c4, $63, $fd
'-' cog5                        
'-'                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
	byte	$52, $f0, $07, $f6
'-'                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
	byte	$1d, $f2, $03, $f6
'-'                             mov     id, id5                 'get COG5 state
	byte	$d2, $bd, $03, $f6
'-'                             getword limit, id, #1           'get COG5 burst limit
	byte	$de, $43, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $cd, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$40, $03, $90, $5d
'-'                             mov     addr1, req5             'get mailbox request parameter for COG5
	byte	$0f, $aa, $03, $f6
'-'                             mov     hubdata, data5          'get COG5 mailbox data parameter
	byte	$10, $ac, $03, $f6
'-'                             mov     count, count5           'get COG5 mailbox count parameter
	byte	$11, $ae, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d5, $c5, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $c4, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $c4, $63, $fd
'-' cog6                        
'-'                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
	byte	$5c, $f0, $07, $f6
'-'                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
	byte	$1e, $f2, $03, $f6
'-'                             mov     id, id6                 'get COG6 state
	byte	$d3, $bd, $03, $f6
'-'                             getword limit, id, #1           'get COG6 burst limit
	byte	$de, $43, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $cd, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$10, $03, $90, $5d
'-'                             mov     addr1, req6             'get mailbox request parameter for COG6
	byte	$12, $aa, $03, $f6
'-'                             mov     hubdata, data6          'get COG6 mailbox data parameter
	byte	$13, $ac, $03, $f6
'-'                             mov     count, count6           'get COG6 mailbox count parameter
	byte	$14, $ae, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d5, $c5, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $c4, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $c4, $63, $fd
'-' cog7                        
'-'                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
	byte	$66, $f0, $07, $f6
'-'                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
	byte	$1f, $f2, $03, $f6
'-'                             mov     id, id7                 'get COG7 state
	byte	$d4, $bd, $03, $f6
'-'                             getword limit, id, #1           'get COG7 burst limit
	byte	$de, $43, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $cd, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$e0, $02, $90, $5d
'-'                             mov     addr1, req7             'get mailbox request parameter for COG7
	byte	$15, $aa, $03, $f6
'-'                             mov     hubdata, data7          'get COG7 mailbox data parameter
	byte	$16, $ac, $03, $f6
'-'                             mov     count, count7           'get COG7 mailbox count parameter
	byte	$17, $ae, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d5, $c5, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $c4, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $c4, $63, $fd
'-' 
'-'                             fit     128
'-'                             fit     128
'-' pad                         long    0[128-$]                'align init code to $80
'-' 
'-' '..................................................................................................
'-' 
'-' ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
'-' 
'-' init                        
'-'                             ' read in the additional LUT RAM code
'-'                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
	byte	$f9, $3d, $03, $f1
'-'                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
	byte	$29, $9e, $67, $fd
'-'                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
	byte	$9e, $61, $00, $fb
'-' 
'-'                             ' read the startup parameters
'-'                             setq    #8-1                    'read 8 longs from hub
	byte	$28, $0e, $64, $fd
'-'                             rdlong  startupparams, ptra     '.. as the startup parameters 
	byte	$00, $3d, $07, $fb
'-' 
'-'                             ' setup some of the config flag dependent state and patch LUTRAM
'-'                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
	byte	$1c, $3e, $0f, $f4
'-' 
'-'             if_z            add     expansion, ptrb         'compensate for HUB address
	byte	$f9, $6d, $03, $a1
'-'             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
	byte	$01, $00, $00, $5f, $e1, $6c, $07, $56
'-'                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
	byte	$1d, $3e, $17, $f4
'-'             if_nc           or      clkconfig, registered   'enable this if so
	byte	$a8, $53, $43, $35
'-'             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
	byte	$00, $54, $07, $36
'-' 
'-'                             ' setup data pin modes and data bus pin group in streamer commands
'-'                             and     datapins, #%111000      'compute base pin
	byte	$38, $44, $07, $f5
'-'                             or      datapins, ##(3<<6)      'configure 4 pins total
	byte	$00, $00, $00, $ff, $c0, $44, $47, $f5
'-'                             mov     a, datapins             'get data pin base
	byte	$a2, $d7, $03, $f6
'-'                             wrpin   registered, datapins    'prepare data pins for address phase transfer
	byte	$a2, $51, $03, $fc
'-'                             shr     a, #3 wc                'determine data pin group
	byte	$03, $d6, $57, $f0
'-'                             or      a, #8
	byte	$08, $d6, $47, $f5
'-'                             setnib  ximm8, a, #5            'setup bus group in streamer
	byte	$eb, $2f, $2b, $f8
'-'                             bitc    ximm8, #19
	byte	$13, $2e, $47, $f4
'-'                             setnib  xrecvdata, a, #5
	byte	$eb, $31, $2b, $f8
'-'                             bitc    xrecvdata, #19
	byte	$13, $30, $47, $f4
'-'                             setnib  xsenddata, a, #5
	byte	$eb, $33, $2b, $f8
'-'                             bitc    xsenddata, #19
	byte	$13, $32, $47, $f4
'-'                             setnib  xsendimm, a, #5
	byte	$eb, $35, $2b, $f8
'-'                             bitc    xsendimm, #19
	byte	$13, $34, $47, $f4
'-'  
'-'                             ' setup device control pin states
'-'                             setq2   #32-1                   'read 32 longs to LUTRAM
	byte	$29, $3e, $64, $fd
'-'                             rdlong  $000, devicelist        'read bank/pin data for all banks    
	byte	$a3, $01, $00, $fb
'-'                             mov     const512, ##512         'prepare constant
	byte	$01, $00, $00, $ff, $00, $46, $07, $f6
'-' 
'-'                             mov     ptrb, #16               'point to bank pin config data
	byte	$10, $f2, $07, $f6
'-'                             rep     @pinloop, #16           'iterate through 16 banks
	byte	$10, $14, $dc, $fc
'-'                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
	byte	$e1, $c9, $b7, $fa
'-'                             and     pinconfig, pinmask      'save us from invalid bits in args
	byte	$ad, $c9, $03, $f5
'-'             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
	byte	$e4, $4f, $e3, $38
'-'             if_nc           wrpin   #0, cspin               'clear smart pin mode
	byte	$a7, $01, $08, $3c
'-'             if_nc           drvh    cspin                   'setup pins for all banks
	byte	$59, $4e, $63, $3d
'-'             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
	byte	$e4, $4d, $eb, $38
'-'             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
	byte	$50, $4c, $63, $3d
'-'             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
	byte	$a6, $53, $03, $3c
'-'             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
	byte	$a6, $03, $18, $3c
'-' '            if_nc           wxpin   #2, clkpin              'configure for 1 clocks between transitions
'-'             if_nc           drvl    clkpin                  'set clk state low
	byte	$58, $4c, $63, $3d
'-' pinloop
'-'                             ' generate minimum CE high time before access
'-'                             qdiv    frequency, ##1000000    'convert from Hz to MHz
	byte	$a1, $07, $00, $ff, $40, $3c, $17, $fd
'-'                             getqx   c                       'get P2 clocks per microsecond
	byte	$18, $da, $63, $fd
'-'                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
	byte	$96, $d6, $07, $f6
'-'                             mul     a, c                    'convert microseconds to clocks
	byte	$ed, $d7, $03, $fa
'-'                             waitx   a                       'delay
	byte	$1f, $d6, $63, $fd
'-'                             call    #hwinit                 'setup HW into QSPI mode
	byte	$f8, $05, $b0, $fd
'-' 
'-'                             ' setup the COG mailboxes and addresses 
'-'                             rep     #2, #8                  'setup loop to patch mailbox addresses
	byte	$08, $04, $dc, $fc
'-'                             alti    $+1, #%111_000          'increase D field
	byte	$38, $68, $a5, $f9
'-'                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
	byte	$a5, $31, $00, $f1
'-' 
'-'                             setq    #24-1
	byte	$28, $2e, $64, $fd
'-'                             wrlong  #0, mbox                'clear out mailboxes ????
	byte	$a5, $01, $68, $fc
'-' 
'-'                             ' setup the polling loop for active COGs 
'-'                             cogid   id
	byte	$01, $bc, $63, $fd
'-'                             alts    id, #id0                'determine id register of control COG
	byte	$cd, $bd, $97, $f9
'-'                             setd    patchid, #0             'patch into destination address
	byte	$00, $90, $b6, $f9
'-'                             push    ptra                    'save ptra before we lose it
	byte	$2a, $f0, $63, $fd
'-'                             mov     ptra, #10
	byte	$0a, $f0, $07, $f6
'-'                             mul     ptra, id
	byte	$de, $f1, $03, $fa
'-'                             add     ptra, #$20              'prep ptra for reloadcogs
	byte	$20, $f0, $07, $f1
'-'                             alts    id, #cog0_handler       'add to handler base
	byte	$ae, $bd, $97, $f9
'-'                             sets    ctrlpollinst, #0-0      'patch into jump instruction
	byte	$00, $48, $be, $f9
'-'                             mul     id, #3
	byte	$03, $bc, $07, $fa
'-'                             setd    ctrlpollinst, id
	byte	$de, $49, $b2, $f9
'-'                             rdlut   id, ptra[9]             'save original value
	byte	$09, $bd, $a7, $fa
'-'                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
	byte	$09, $bb, $37, $fc
'-'                             call    #reloadcogs
	byte	$e8, $01, $b0, $fd
'-'                             wrlut   id, ptra[9]             'restore original value
	byte	$09, $bd, $37, $fc
'-'                             pop     ptra                    'restore original ptra
	byte	$2b, $f0, $63, $fd
'-'                             ' move LUT control vectors into temporary location to avoid clobbering them later
'-'                             setd    d, #addr1
	byte	$d5, $dd, $b7, $f9
'-'                             sets    d, #(ctrl_vect & $1ff)
	byte	$60, $dc, $bf, $f9
'-'                             rep     #2, #8
	byte	$08, $04, $dc, $fc
'-'                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
	byte	$3f, $dc, $a7, $f9
'-'                             rdlut   addr1-0, #$60-0
	byte	$60, $aa, $a7, $fa
'-' 
'-'                             'setup control COG service handling, we need to patch 5 instructions
'-'                             'one existing instruction is moved earlier and four instructions get replaced
'-'                             cogid   id
	byte	$01, $bc, $63, $fd
'-'                             mov     a, #(cog1-cog0)         'get code separation of handlers
	byte	$0c, $d6, $07, $f6
'-'                             mul     a, id                   'scale ID by separation
	byte	$de, $d7, $03, $fa
'-'                             add     a, #cog0+4              'add to base for COG0 and offset
	byte	$24, $d6, $07, $f1
'-'                             setd    d, a                    'set this as the destination
	byte	$eb, $dd, $b3, $f9
'-'                             add     a, #2                   'increment COG address
	byte	$02, $d6, $07, $f1
'-'                             sets    d, a                    'set this as the source
	byte	$eb, $dd, $bb, $f9
'-'                             alti    d, #%111_100             
	byte	$3c, $dc, $a7, $f9
'-'                             mov     0-0, 0-0                'move instruction
	byte	$00, $00, $00, $f6
'-'                             sets    d, #controlpatch        'set source of patched instructions
	byte	$ea, $dc, $bf, $f9
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $dc, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             add     d, const512             'skip two instructions
	byte	$a3, $dd, $03, $f1
'-'                             add     d, const512
	byte	$a3, $dd, $03, $f1
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $dc, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             
'-'                             ' setup register values for control vector loop setup after we return
'-'                             mov     header, id              'get cog ID
	byte	$de, $bf, $03, $f6
'-'                             mul     header, #10             'multiply by size of state memory per COG
	byte	$0a, $be, $07, $fa
'-'                             add     header, #$20            'add to COG state base address in LUT
	byte	$20, $be, $07, $f1
'-'                             mov     trailer, header         'determine start/end LUT address
	byte	$df, $c1, $03, $f6
'-'                             add     trailer, #9             '...for control region
	byte	$09, $c0, $07, $f1
'-'                             or      id, initctrl            'set id field for control COG
	byte	$dd, $bd, $43, $f5
'-'                             altd    id, #id0
	byte	$cd, $bd, $8f, $f9
'-'                             mov     0-0, id                 'setup id field for notification
	byte	$de, $01, $00, $f6
'-'                             mov     ptrb, ptra              'get startup parameter address
	byte	$f8, $f3, $03, $f6
'-'                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
	byte	$04, $f2, $07, $f1
'-'                             mov     b, #0                   'prepare b for upcoming loop
	byte	$00, $d8, $07, $f6
'-'                 _ret_       push    #notify                 'continue init in mailbox area
	byte	$2a, $14, $66, $0d
'-'  
'-' controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
	byte	$d5, $c5, $7b, $f8
'-'                             and     request, #7
	byte	$07, $c4, $07, $f5
'-'                             add     request, ptra           'add request vector offset
	byte	$f8, $c5, $03, $f1
'-'                             rdlut   request, request        'lookup jump vector service table 
	byte	$e2, $c5, $a3, $fa
'-' 
'-'                             fit     $100                    'ensure all init code fits this space
'-'                             fit     $100                    'ensure all init code fits this space
'-' 
'-'                             long    0[$100-$]               'pad more if required until table ends
	byte	$00[72]
'-' 
'-' '..................................................................................................
'-' ' Error result handling and COG notification of request completion
'-' 
'-' unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
	byte	$04, $04, $4c, $fb
'-' invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
	byte	$03, $02, $4c, $fb
'-' invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
	byte	$02, $06, $4c, $fb
'-' alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
	byte	$01, $08, $4c, $fb
'-' busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
	byte	$05, $ec, $07, $f6
'-' err                         altd    id, #id0                'adjust for the running COG
	byte	$cd, $bd, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
	byte	$09, $00, $04, $f4
'-'                             wrlut   #0, ptra[8]             'cancel any resume state
	byte	$08, $01, $3c, $fc
'-'                             skipf   #%10                    'dont notify with success code 0 below
	byte	$32, $04, $64, $fd
'-'                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
	byte	$bf, $ed, $67, $fc
'-' notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
	byte	$bf, $01, $6c, $fc
'-'                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
	byte	$0b, $bc, $0f, $f4
'-'                             decod   a, id                   'convert COG ID to bitmask
	byte	$de, $d7, $c3, $f9
'-'             if_z            cogatn  a                       'notify COG via ATN
	byte	$3f, $d6, $63, $ad
'-' ' Poller re-starts here after a COG is serviced
'-' poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
	byte	$0f, $bc, $0f, $f4
'-'             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
	byte	$e3, $5b, $03, $57
'-'                             bmask   mask, rrcounter         'generate a RR skip mask from the count
	byte	$ad, $41, $cb, $f9
'-' ' Main dynamic polling loop repeats until a request arrives
'-' polling_loop                rep     #0-0, #0                'repeat until we get a request for something
	byte	$00, $00, $dc, $fc
'-'                             setq    #24-1                   'read 24 longs
	byte	$28, $2e, $64, $fd
'-'                             rdlong  req0, mbox              'get all mailbox requests and data longs
	byte	$a5, $01, $00, $fb
'-' 
'-' polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
	byte	$ae, $01, $b0, $fb
'-'                             skipf   mask                    ']after all priority COG handlers if present
	byte	$32, $40, $63, $fd
'-'                     	    tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
	byte	$af, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
	byte	$b0, $0d, $b0, $fb
'-'                      	    tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
	byte	$b1, $13, $b0, $fb
'-'                     	    tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
	byte	$b2, $19, $b0, $fb
'-'                     	    tjs     req5, cog5_handler      ']This loop is recreated at init time 
	byte	$b3, $1f, $b0, $fb
'-'                     	    tjs     req6, cog6_handler      ']based on the active COGs being polled
	byte	$b4, $25, $b0, $fb
'-'                    	    tjs     req7, cog7_handler      ']and whether priority or round robin.
	byte	$b5, $2b, $b0, $fb
'-'                     	    tjs     req1, cog1_handler      ']Any update of COG parameters would also
	byte	$af, $07, $b0, $fb
'-'                   	    tjs     req2, cog2_handler      ']regenerate this code, in case priorities
	byte	$b0, $0d, $b0, $fb
'-'                      	    tjs     req3, cog3_handler      ']have changed.
	byte	$b1, $13, $b0, $fb
'-'                     	    tjs     req4, cog4_handler      ']A skip pattern that is continually 
	byte	$b2, $19, $b0, $fb
'-'                   	    tjs     req5, cog5_handler      ']changed selects which RR COG is the
	byte	$b3, $1f, $b0, $fb
'-'                     	    tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
	byte	$b4, $25, $b0, $fb
'-' pollinst            	    tjs     req7, cog7_handler      'instruction template for RR COGs
	byte	$b5, $2b, $b0, $fb
'-' 
'-' ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
	byte	$ae, $01, $b0, $fb
'-' skipfinst                   skipf   mask                    'instruction template for skipf
	byte	$32, $40, $63, $fd
'-'  
'-' '..................................................................................................
'-' ' List handler                               
'-' 
'-' dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
	byte	$01, $aa, $a7, $fb
'-'                             execf   burstwrite              'otherwise do a burst write to this bank
	byte	$33, $ba, $63, $fd
'-' real_list                   setq    #8-1                    'read 8 longs (largest request size)
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, hubdata          '..to update the request state
	byte	$d6, $ab, $03, $fb
'-'                             tjns    addr1, #invalidlist     'error if request list item not valid
	byte	$d7, $ab, $bf, $fb
'-'                             altd    id, #id0                'get COG state
	byte	$cd, $bd, $8f, $f9
'-'                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
	byte	$09, $00, $3c, $f4
'-'                             bith    id, #LIST_BIT           'retain fact that we are in a list
	byte	$09, $bc, $27, $f4
'-'             if_z            jmp     #unsupported            'no list recursion is allowed!
	byte	$44, $ff, $9f, $ad
'-' list_test                   getbyte request, addr1, #3      'get upper byte of this request
	byte	$d5, $c5, $fb, $f8
'-' service_request             altd    request, #0             'get request address in COG RAM
	byte	$00, $c4, $8f, $f9
'-'                             execf   0-0                     'process the request 
	byte	$33, $00, $60, $fd
'-' 
'-' '..................................................................................................
'-' ' Restoring per COG state and resuming where we left off
'-' 
'-' restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
	byte	$00, $ab, $a7, $fa
'-'                             rdlut   hubdata, ptra[1]
	byte	$01, $ad, $a7, $fa
'-'                             rdlut   count, ptra[2]
	byte	$02, $af, $a7, $fa
'-'                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
	byte	$03, $b1, $b7, $fa
'-'                             getbyte request, addr1, #3
	byte	$d5, $c5, $fb, $f8
'-'             if_nc           execf   resume                  'if not extended then resume immediately
	byte	$33, $cc, $63, $3d
'-'                             rdlut   total, ptra[4]          'we need to read the extended parameters
	byte	$04, $b3, $a7, $fa
'-'                             rdlut   offset1, ptra[5]
	byte	$05, $b5, $a7, $fa
'-'                             rdlut   offset2, ptra[6]
	byte	$06, $b7, $a7, $fa
'-'                             rdlut   link, ptra[7]
	byte	$07, $b9, $a7, $fa
'-'                             rdlut   orighubsize, ptra[9]
	byte	$09, $cf, $a7, $fa
'-'                             execf   resume                  'then resume what we were doing last time
	byte	$33, $cc, $63, $fd
'-'                    
'-' '..................................................................................................
'-' ' Re-configuration of QoS settings and custom polling loop sequence generator
'-' 
'-' reconfig                    push    #notify                 'setup return addr, then reload 
	byte	$2a, $14, $66, $fd
'-' reloadcogs                  setq    #8-1                    'reload all per COG QoS params
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
	byte	$a4, $ab, $03, $fb
'-'                             setd    a, #id0
	byte	$cd, $d7, $b7, $f9
'-'                             sets    a, #addr1
	byte	$d5, $d7, $bf, $f9
'-'                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
	byte	$fe, $ff, $ff, $ff, $28, $00, $66, $fd
'-'                             rep     #2, #8                  'repeat for 8 COGs
	byte	$08, $04, $dc, $fc
'-'                             alti    a, #%111_111 
	byte	$3f, $d6, $a7, $f9
'-'                             muxq    0-0, 0-0
	byte	$00, $00, $f0, $f9
'-' patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
	byte	$09, $01, $a4, $fa
'-'                             cogid   c
	byte	$01, $da, $63, $fd
'-'                             decod   excludedcogs, c         'exclude driver cog initially
	byte	$ed, $3d, $c3, $f9
'-'                             mov     a, #$8                  'a iterates through prio levels 8=lowest
	byte	$08, $d6, $07, $f6
'-'                             neg     pa, #1                  'start with all ones
	byte	$01, $ec, $67, $f6
'-' fillprio                    mov     c, #7                   'c iterates through cogs
	byte	$07, $da, $07, $f6
'-' prioloop                    alts    c, #id0
	byte	$cd, $db, $97, $f9
'-'                             mov     b, 0-0
	byte	$00, $d8, $03, $f6
'-'                             getword d, b, #1                'get burst field
	byte	$ec, $dd, $3b, $f9
'-'                             test    d wz                    'if burst=0 
	byte	$ee, $dd, $cb, $f7
'-'             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
	byte	$ed, $3d, $23, $a4
'-'             if_z            jmp     #excluded               
	byte	$0c, $00, $90, $ad
'-'                             getnib  d, b, #3                'get RR/PRI flag & priority
	byte	$ec, $dd, $5b, $f8
'-'                             cmp     d, a wz                 'compare against current priority level
	byte	$eb, $dd, $0b, $f2
'-'             if_z            rolnib  pa, c, #0               'if matches include COG at this level
	byte	$ed, $ed, $83, $a8
'-' excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
	byte	$f6, $db, $7f, $fb
'-'                             incmod  a, #15 wz               'next level
	byte	$0f, $d6, $0f, $f7
'-'             if_nz           jmp     #fillprio 
	byte	$cc, $ff, $9f, $5d
'-' 
'-' 'determine priority cogs and build instructions for the polling sequence
'-'                             mov     pb, #0                  'clear out set of priority COGs
	byte	$00, $ee, $07, $f6
'-'                             mov     a, #3                   'start with no COGs being polled + 3 instructions
	byte	$03, $d6, $07, $f6
'-'                             setd    d, #polling_code        'initialize COGRAM write position
	byte	$14, $dd, $b7, $f9
'-' 
'-'                             rep     @endprioloop, #8        'test all 8 priority slots
	byte	$08, $18, $dc, $fc
'-'                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
	byte	$03, $ec, $17, $f4
'-'                             getnib  c, pa, #0               'get cogid ID at this priority level
	byte	$f6, $db, $43, $f8
'-'             if_nc           testb   pb, c wz                'check if already exists as priority COG
	byte	$ed, $ef, $0b, $34
'-'             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
	byte	$ed, $ef, $23, $14
'-'             if_nc_and_nz    add     a, #1                   'add another COG to poll 
	byte	$01, $d6, $07, $11
'-'             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
	byte	$ae, $db, $97, $19
'-'             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $19
'-'             if_nc_and_nz    mul     c, #3
	byte	$03, $da, $07, $1a
'-'             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
	byte	$ed, $47, $b2, $19
'-'             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $dc, $a7, $19
'-'             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $16
'-'                             ror     pa, #4                  'advance to next priority
	byte	$04, $ec, $07, $f0
'-' endprioloop
'-'                             xor     pb, #$ff                'invert to find all the non-priority COGs
	byte	$ff, $ee, $67, $f5
'-'                             andn    pb, excludedcogs        'and remove any other excluded COGs
	byte	$9e, $ef, $23, $f5
'-'                             ones    rrlimit, pb wz          'count the number of RR COGs
	byte	$f7, $c7, $ab, $f7
'-'                             add     a, rrlimit              'account for this number of RR COGs to poll
	byte	$e3, $d7, $03, $f1
'-'                             sub     rrlimit, #1             'setup last RR count value for incmod
	byte	$01, $c6, $87, $f1
'-'                             alti    d, #%111_000            'generate the control polling instruction
	byte	$38, $dc, $a7, $f9
'-'                             mov     0-0, ctrlpollinst       'write the instruction
	byte	$24, $01, $00, $f6
'-'             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
	byte	$38, $dc, $a7, $59
'-'             if_nz           mov     0-0, skipfinst          'add the skipf instruction
	byte	$25, $01, $00, $56
'-'             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
	byte	$02, $d6, $07, $51
'-'                             setd    polling_loop, a         'save it as the repeat count
	byte	$eb, $23, $b2, $f9
'-'             if_z            ret                             'we are done now, if no round robin COGs
	byte	$2d, $00, $64, $ad
'-' 
'-' ' populate the round robin COG polling instructions
'-'                             mov     rrcounter, #2           'fill the RR poll instruction list twice
	byte	$02, $5a, $07, $f6
'-' rrloop                      mov     b, pb                   'get the set of RR COGs
	byte	$f7, $d9, $03, $f6
'-'                             mov     c, #0                   'start at COG ID = 0
	byte	$00, $da, $07, $f6
'-'                             mov     a, #0                   'req mailbox COGRAM address for COG 0
	byte	$00, $d6, $07, $f6
'-' nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
	byte	$01, $d8, $5f, $f0
'-'             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
	byte	$eb, $47, $b2, $c9
'-'             if_c            alts    c, #cog0_handler        'determine jump address
	byte	$ae, $db, $97, $c9
'-'             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $c9
'-'             if_c            alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $dc, $a7, $c9
'-'             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $c6
'-'                             add     c, #1                   'increment the COG ID
	byte	$01, $da, $07, $f1
'-'                             add     a, #3                   'increase the request address
	byte	$03, $d6, $07, $f1
'-'             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
	byte	$dc, $ff, $9f, $5d
'-'             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
	byte	$f3, $5b, $6f, $0b
'-' '..................................................................................................
'-' ' Code to get/set driver settings per bank or to dump COG/LUT state
'-' 
'-' set_latency                                                 '            (a) set latency
'-' get_latency                                                 '            (b) get latency
'-' set_burst                                                   '            (c) set burst size of bank
'-' get_burst                                                   '            (d) get burst size of bank
'-'                                                             '            (e) dump state
'-'                             getnib  b, addr1, #6            ' a b c d    get bank address
	byte	$d5, $d9, $73, $f8
'-' dump_state                  setq    #511                    ' | | | | e  prepare burst write
	byte	$28, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
	byte	$d6, $01, $60, $fc
'-'                                                             ' | | | | e  account for following AUGS
'-'                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
	byte	$04, $00, $00, $ff, $00, $ac, $07, $f1
'-'                             setq2   #511                    ' | | | | e  prepare burst write
	byte	$29, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
	byte	$d6, $01, $60, $fc
'-'                             add     b, #16                  ' a b | | |  point to latency params
	byte	$10, $d8, $07, $f1
'-'                             rdlut   a, b                    ' a b c d |  read data for bank
	byte	$ec, $d7, $a3, $fa
'-'                             setbyte a, hubdata, #3          ' a | | | |  patch latency
	byte	$d6, $d7, $db, $f8
'-'                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
	byte	$d6, $d7, $03, $f6
'-'                             wrlut   a, b                    ' a | c | |  if setting, save bank data
	byte	$ec, $d7, $33, $fc
'-'                             getbyte a, a, #3                ' | b | | |  extract latency field only
	byte	$eb, $d7, $fb, $f8
'-'                             wrlong  a, ptrb                 ' | b | d |  write result          
	byte	$80, $d7, $67, $fc
'-'                             jmp     #notify                 ' a b c d e  return success
	byte	$dc, $fd, $9f, $fd
'-' 
'-' '..................................................................................................
'-' ' Misc EXECF code
'-' 
'-' start_read_exec             execf   newburstr
	byte	$33, $6e, $63, $fd
'-' start_write_exec            execf   resumewrites
	byte	$33, $78, $63, $fd
'-' continue_read_exec          execf   lockedreads
	byte	$33, $74, $63, $fd
'-' continue_write_exec         execf   lockedwrites
	byte	$33, $76, $63, $fd
'-' 
'-' '..................................................................................................
'-' ' Variables
'-' 
'-' ximm8           long    $6000_0008              '8 nibble transfers to pins
	byte	$08, $00, $00, $60
'-' xrecvdata       long    $E000_0000              'arbitrary 4 bit reads from 4 bit bus pins
	byte	$00, $00, $00, $e0
'-' xsenddata       long    $A000_0000              'arbitrary 4 bit writes from hub to pins
	byte	$00, $00, $00, $a0
'-' xsendimm        long    $6000_0002              'arbitrary nx4 bit immediate writes from imm to pins
	byte	$02, $00, $00, $60
'-' 
'-' xfreq1          long    $80000000
	byte	$00, $00, $00, $80
'-' xfreq2          long    $40000000
	byte	$00, $00, $00, $40
'-' 'xfreq2          long    $20000000
'-' 
'-' delay           long    3
	byte	$03, $00, $00, $00
'-' 
'-' lutcodeaddr                 
'-' startupparams
'-' excludedcogs                                    'careful: shared register use!
'-' frequency       long    lut_code - driver_start 'determine offset of LUT code from base
	byte	$bc, $07, $00, $00
'-' flags           long    0
	byte	$00, $00, $00, $00
'-' mask                                            'careful: shared register use!
'-' resetmaskA      long    0
	byte	$00, $00, $00, $00
'-' limit                                           'careful: shared register use!
'-' resetmaskB      long    0
	byte	$00, $00, $00, $00
'-' datapins        long    0
	byte	$00, $00, $00, $00
'-' const512                                        'careful: shared register use!
'-' devicelist      long    0
	byte	$00, $00, $00, $00
'-' coglist         long    0
	byte	$00, $00, $00, $00
'-' mbox            long    0 
	byte	$00, $00, $00, $00
'-' 
'-' clkpin                                          'shared with code patched during init
'-' clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
	byte	$a6, $03, $18, $fc
'-' cspin                                           'shared with code patched during init
'-' speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
	byte	$1d, $36, $63, $fd
'-' registered      long    %100_000_000_00_00000_0 'config pin for clocked input
	byte	$00, $00, $01, $00
'-' clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
	byte	$4a, $00, $00, $00
'-' clkdelay        long    1
	byte	$01, $00, $00, $00
'-' regdatabus      long    0
	byte	$00, $00, $00, $00
'-' 
'-' deviceaddr      long    $10
	byte	$10, $00, $00, $00
'-' rrcounter
'-' pinmask         long    $ff3f7f7f
	byte	$7f, $7f, $3f, $ff
'-' 
'-' ' jump addresses for the per COG handlers
'-' cog0_handler    long    cog0
	byte	$20, $00, $00, $00
'-' cog1_handler    long    cog1
	byte	$2c, $00, $00, $00
'-' cog2_handler    long    cog2
	byte	$38, $00, $00, $00
'-' cog3_handler    long    cog3
	byte	$44, $00, $00, $00
'-' cog4_handler    long    cog4
	byte	$50, $00, $00, $00
'-' cog5_handler    long    cog5
	byte	$5c, $00, $00, $00
'-' cog6_handler    long    cog6
	byte	$68, $00, $00, $00
'-' cog7_handler    long    cog7
	byte	$74, $00, $00, $00
'-' expansion       long    gfxexpansion - driver_start
	byte	$0c, $0d, $00, $00
'-' 
'-' ' EXECF sequences
'-' newburstr       long    (%1111000000000011111100 << 10) + r_burst
	byte	$70, $f2, $03, $f0
'-' lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
	byte	$2c, $9b, $ef, $00
'-' restorefill     long    (%0001110100000001011100 << 10) + w_fill_cont
	byte	$27, $73, $01, $1d
'-' lockedreads     long    (%0000000001111000111100 << 10) + r_locked_burst
	byte	$80, $f2, $78, $00
'-' lockedwrites    long    (%0000000111100000111100 << 10) + w_resume_burst
	byte	$2f, $f3, $e0, $01
'-' resumewrites    long    (%0000000111100000000000 << 10) + w_resume_burst
	byte	$2f, $03, $e0, $01
'-' resumereads     long    (%0000000011110000000000 << 10) + r_resume_burst
	byte	$78, $02, $f0, $00
'-' 
'-' 
'-' ' SKIPF sequences
'-' skiptable       long    %110110000 ' read modify write byte
	byte	$b0, $01, $00, $00
'-'                 long    %101101000 ' read modify write word
	byte	$68, $01, $00, $00
'-'                 long    %011011000 ' read modify write long
	byte	$d8, $00, $00, $00
'-' read_skip       long    %11111110000110      ' extended single read skip sequence
	byte	$86, $3f, $00, $00
'-' write_skip      long    %1100011100011111110 ' extended single write skip sequence
	byte	$fe, $38, $06, $00
'-' fill_skip       long    %11000001000000010   ' extended fill skip sequence
	byte	$02, $82, $01, $00
'-' burst_skip      long    %001111100000000     ' extended burst skip sequence
	byte	$00, $1f, $00, $00
'-' 
'-' skipcase_a      long    %01101111100000000001000011111101
	byte	$fd, $10, $80, $6f
'-' skipcase_b      long    %00000000010100000001100000010000
	byte	$10, $18, $50, $00
'-' skipcase_c      long    %00000000011000000011111000010001
	byte	$11, $3e, $60, $00
'-' skipseq_write   long    %00000000000000000000111100000010
	byte	$02, $0f, $00, $00
'-' 
'-' ' LUT RAM address values
'-' complete_rw     long    complete_rw_lut
	byte	$e5, $02, $00, $00
'-' continue_read   long    continue_read_lut
	byte	$c3, $02, $00, $00
'-' continue_write  long    continue_write_lut
	byte	$c1, $02, $00, $00
'-' noread          long    noread_lut
	byte	$dc, $02, $00, $00
'-' 
'-' id0             long    0
	byte	$00, $00, $00, $00
'-' id1             long    1
	byte	$01, $00, $00, $00
'-' id2             long    2
	byte	$02, $00, $00, $00
'-' id3             long    3
	byte	$03, $00, $00, $00
'-' id4             long    4
	byte	$04, $00, $00, $00
'-' id5             long    5
	byte	$05, $00, $00, $00
'-' id6             long    6
	byte	$06, $00, $00, $00
'-' id7             long    7
	byte	$07, $00, $00, $00
'-' 
'-' 'These next 10 request registers below are also temporarily reused during init 
'-' 'and COG updates and need to follow immediately after id0-id7
'-' addr1           long    0
	byte	$00, $00, $00, $00
'-' hubdata         long    0
	byte	$00, $00, $00, $00
'-' count           long    0
	byte	$00, $00, $00, $00
'-' addr2           long    0
	byte	$00, $00, $00, $00
'-' total           long    0
	byte	$00, $00, $00, $00
'-' offset1         long    0
	byte	$00, $00, $00, $00
'-' offset2         long    0
	byte	$00, $00, $00, $00
'-' link            long    0
	byte	$00, $00, $00, $00
'-' 
'-' burstwrite                                      'note shared register use during init
'-' initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
	byte	$00, $10, $f0, $fe
'-' id              long    0
	byte	$00, $00, $00, $00
'-' 
'-' header          long    0
	byte	$00, $00, $00, $00
'-' trailer         long    0
	byte	$00, $00, $00, $00
'-' cmdaddr         long    0
	byte	$00, $00, $00, $00
'-' request         long    0
	byte	$00, $00, $00, $00
'-' rrlimit         long    0
	byte	$00, $00, $00, $00
'-' pinconfig       long    0
	byte	$00, $00, $00, $00
'-' clks            long    0
	byte	$00, $00, $00, $00
'-' resume          long    0
	byte	$00, $00, $00, $00
'-' orighubsize     long    0
	byte	$00, $00, $00, $00
'-' wrclks          long    0
	byte	$00, $00, $00, $00
'-' 
'-' pattern         long    0
	byte	$00, $00, $00, $00
'-' pagesize        long    PAGE_SIZE
	byte	$00, $04, $00, $00
'-' 
'-' ' temporary general purpose regs
'-' a               long    0
	byte	$00, $00, $00, $00
'-' b               long    0
	byte	$00, $00, $00, $00
'-' c               long    0
	byte	$00, $00, $00, $00
'-' d               long    0
	byte	$00, $00, $00, $00
'-' 
'-'                 fit     502
'-'                 fit     502
'-' 
'-' '..................................................................................................
'-' 
'-'             orgh
'-' 
'-' lut_code
'-' 'HW init code up to 80 longs
'-' 
'-' '..................................................................................................
'-' ' Memory layout for LUT RAM once operational:
'-' '
'-' '  LUT RAM address      Usage
'-' '  ---------------      ----
'-' '    $200-$20F          Bank parameters: burst + type + size per bank (16)
'-' '    $210-$21F          Pin parameters : latency + control pins per bank (16)
'-' '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
'-' '    $270-$3FF          Main PSRAM access code in LUTRAM 
'-' '
'-' ' Also during driver COG startup:
'-' ' $230-$24F is used for HW init setup
'-' ' $250-$26F is used as temporary vector storage 
'-' '..................................................................................................
'-' 
'-'                 org $230    
'-' 
'-' ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
'-' hwinit                      setxfrq xfreq2
	byte	$1d, $38, $63, $fd
'-'                             pollxfi
	byte	$24, $16, $60, $fd
'-'                             mov     pa, #$5F                '$F5 - exit QSPI mode if we were in this mode
	byte	$5f, $ec, $07, $f6
'-'                             call    #sendqspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$0FF00FF0         '$66 - reset enable
	byte	$07, $f8, $07, $ff, $f0, $ed, $07, $f6
'-'                             call    #sendspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$F00FF00F         '$99 - reset
	byte	$f8, $07, $78, $ff, $0f, $ec, $07, $f6
'-'                             call    #sendspi
	byte	$1c, $00, $b0, $fd
'-'                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
	byte	$7f, $78, $78, $ff, $00, $ed, $07, $f6
'-'                             call    #sendspi 
	byte	$10, $00, $b0, $fd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-' 
'-' sendqspi                    mov     clks,#4
	byte	$04, $ca, $07, $f6
'-'                             skipf   #%110
	byte	$32, $0c, $64, $fd
'-'                             mov     pb, xsendimm
	byte	$9a, $ef, $03, $f6
'-' 
'-' sendspi                     mov     clks, #16
	byte	$10, $ca, $07, $f6
'-'                             mov     pb, ximm8
	byte	$97, $ef, $03, $f6
'-'                             drvl    cspin                   'active low chip select
	byte	$58, $4e, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $44, $63, $fd
'-'                             xinit   pb, pa                  'send 32 bit immediate data
	byte	$f6, $ef, $a3, $fc
'-'                             wypin   clks, clkpin            'start memory clock output 
	byte	$a6, $cb, $23, $fc
'-'                             waitxfi                         'wait for the completion
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                'float data bus
	byte	$50, $44, $63, $fd
'-'                             drvh    cspin                   'raise chip select
	byte	$59, $4e, $63, $fd
'-'             _ret_           waitx   #200                    'delay before return to ensure CS delay
	byte	$1f, $90, $65, $0d
'-' 
'-'                 long    0[$270-32-$]
	byte	$00[20]
'-'     
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-' ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
'-' rw_vect ' PSRAM jump vectors
'-'                 long    (%0001101100110100001100 << 10) + r_single
	byte	$72, $32, $34, $1b
'-'                 long    (%0001011100110100001000 << 10) + r_single
	byte	$72, $22, $34, $17
'-'                 long    (%0000111100110100010100 << 10) + r_single
	byte	$72, $52, $34, $0f
'-'                 long    (%1111000000000011111100 << 10) + r_burst
	byte	$70, $f2, $03, $f0
'-'                 long    (%0001110100000000001100 << 10) + w_single
	byte	$27, $33, $00, $1d
'-'                 long    (%0001110100000000001000 << 10) + w_single
	byte	$27, $23, $00, $1d
'-'                 long    (%0001110100000000000100 << 10) + w_single
	byte	$27, $13, $00, $1d
'-'                 long    (%0001111000000000000110 << 10) + w_burst
	byte	$2b, $1b, $00, $1e
'-' ro_vect ' R/O PSRAM jump vectors
'-'                 long    (%0001101100110100001100 << 10) + r_single
	byte	$72, $32, $34, $1b
'-'                 long    (%0001011100110100001000 << 10) + r_single
	byte	$72, $22, $34, $17
'-'                 long    (%0000111100110100010100 << 10) + r_single
	byte	$72, $52, $34, $0f
'-'                 long    (%1111000000000011111100 << 10) + r_burst
	byte	$70, $f2, $03, $f0
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-' ctrl_vect ' Control jump vectors
'-'                 long    (%0000000000111001111110 << 10) + get_latency
	byte	$84, $f9, $39, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000001111011111110 << 10) + get_burst
	byte	$84, $f9, $7b, $00
'-'                 long    (%0000000001111111000000 << 10) + dump_state
	byte	$85, $01, $7f, $00
'-'                 long    (%0000000011010001111110 << 10) + set_latency
	byte	$84, $f9, $d1, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000011001011111110 << 10) + set_burst
	byte	$84, $f9, $cb, $00
'-'                 long    reconfig 
	byte	$3e, $01, $00, $00
'-' no_vect ' Invalid bank jump vectors
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-' 
'-'                 fit     $270
'-'                 fit     $270
'-' '..................................................................................................
'-' ' PSRAM READS
'-'                                                             ' a b c d e f
'-'                                                             ' B W L B R L  (a) byte read
'-'                                                             ' Y O O U E O  (b) word read
'-'                                                             ' T R N R S C  (c) long read
'-'                                                             ' E D G S U K  (d) new burst read
'-'                                                             '       T M E  (e) resumed sub-burst
'-'                                                             '         E D  (f) locked sub-burst
'-' 
'-' 
'-' r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
	byte	$d7, $cf, $03, $f6
'-'                             tjz     count, #noread_lut      '       d      check for any bytes to send
	byte	$6a, $ae, $97, $fb
'-' r_single                    test    count wz                ' a b c |      test for RMW (z=0 if RMW)
	byte	$d7, $af, $cb, $f7
'-'                             modz    5 wz                    ' a b c |      test for RMW (z=1 if RMW) 
	byte	$6f, $0a, $6c, $fd
'-'                             andn    addr1, #1               ' | b | |      align to word boundary to prevent page issues
	byte	$01, $aa, $27, $f5
'-'                             andn    addr1, #3               ' | | c |      align to long boundary to prevent page issues
	byte	$03, $aa, $27, $f5
'-'                             wrlong  #0, ptrb                ' a b | |      clear upper bits of byte/word mailbox result
	byte	$80, $01, $6c, $fc
'-'                             wrfast  xfreq1, ptrb            ' a b c |      setup streamer hub address for singles
	byte	$f9, $37, $83, $fc
'-' r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
	byte	$e2, $d9, $43, $f8
'-'                             rdlut   b, b                    ' a b c d e    get bank limit/mask
	byte	$ec, $d9, $a3, $fa
'-'                             bmask   mask, b                 ' | | | d e    build mask for addr
	byte	$ec, $41, $cb, $f9
'-'                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
	byte	$ec, $3b, $eb, $f8
'-'                             shr     b, #17                  ' | | | d e    scale burst size based on bus rate
	byte	$11, $d8, $47, $f0
'-'                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
	byte	$ec, $43, $23, $f3
'-'                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
	byte	$05, $3a, $57, $f0
'-'                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
	byte	$10, $56, $67, $f4
'-' r_locked_burst              mov     c, count wz             ' | | | d e f  get count of bytes left to read
	byte	$d7, $db, $0b, $f6
'-'                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
	byte	$a1, $db, $33, $f3
'-'                             mov     clks, #2 wc             ' a | | | | |  2 clock transitions per byte
	byte	$02, $ca, $17, $f6
'-'                             mov     clks, #4 wc             ' | b | | | |  4 clock transitions per word
	byte	$04, $ca, $17, $f6
'-'                             mov     clks, #8 wc             ' | | c | | |  8 clock transitions per long
	byte	$08, $ca, $17, $f6
'-'                             skipf   read_skip               ' a b c | | |  extend skipf sequence for single reads
	byte	$32, $82, $63, $fd
'-'             if_nc           mov     resume, complete_rw     ' a b c d e f  burst/single read will complete
	byte	$c9, $cd, $03, $36
'-'             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
	byte	$ca, $cd, $03, $c6
'-'                             wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
	byte	$d6, $37, $83, $fc
'-'                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
	byte	$e2, $59, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
	byte	$ac, $c9, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
	byte	$e4, $4f, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
	byte	$e4, $4d, $eb, $f8
'-'                             ' handle the page boundary by splitting any read bursts that cross it 
'-'                             mov     d, addr1                ' | | | d e f  get start address
	byte	$d5, $dd, $03, $f6
'-'                             zerox   d, #(PAGE_BITS-1)       ' | | | d e f  only keep page LSBs
	byte	$09, $dc, $47, $f7
'-'                             subr    d, pagesize             ' | | | d e f  figure out how many bytes remain before we hit the boundary
	byte	$ea, $dd, $c3, $f2
'-'                             fle     c, d wc                 ' | | | d e f  compare this size to our transfer size and limit it
	byte	$ee, $db, $33, $f3
'-'             if_c            mov     resume, continue_read   ' | | | d e f  and we will continue with a sub-burst again
	byte	$ca, $cd, $03, $c6
'-'                             mov     clks, c                 ' | | | d e f  get count of bytes to be read into HUB
	byte	$ed, $cb, $03, $f6
'-'                             shl     clks, #1                ' | | | d e f  multiply by two to work out nibble count
	byte	$01, $ca, $67, $f0
'-' 
'-'                             setword xrecvdata, clks, #0     'set the nibble transfers needed in streamer
	byte	$e5, $31, $23, $f9
'-'                             add     clks, #14               'include 14 address+delay clocks
	byte	$0e, $ca, $07, $f1
'-'                             add     clks, clks              'compute clock transitions by doubling
	byte	$e5, $cb, $03, $f1
'-'                             mov     cmdaddr, addr1          'get start address of transfer
	byte	$d5, $c3, $03, $f6
'-'                             setbyte cmdaddr, #$EB, #3       'add quad read command
	byte	$eb, $c2, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c2, $63, $fd
'-'                             rev     cmdaddr
	byte	$69, $c2, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c2, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c2, $63, $fd
'-' 
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $4e, $63, $fd
'-'                             drvl    datapins                'enable data bus
	byte	$58, $44, $63, $fd
'-'             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
'-'                             xinit   ximm8, cmdaddr          'stream out command+address
	byte	$e1, $2f, $a3, $fc
'-'                             wypin   clks, clkpin            'start clock output
	byte	$a6, $cb, $23, $fc
'-'                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
	byte	$00, $00, $cc, $fc
'-'                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
	byte	$00, $0c, $cc, $fc
'-'                             drvh    datapins                'enable this only if validating actual tri-state time on a scope
	byte	$59, $44, $63, $fd
'-'                             fltl    datapins                'safe to float the data bus, address has been sent by now
	byte	$50, $44, $63, $fd
'-'                       
'-'                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
	byte	$a2, $57, $03, $fc
'-'                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
	byte	$28, $36, $63, $fd
'-'                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
	byte	$00, $3a, $c7, $fc
'-'                             xcont   #6, #0                  'fixed delay offset to expand delay range
	byte	$00, $0c, $cc, $fc
'-'             if_z            skipf   #%0100100               'special skip case for read-modify-write(RWM)
	byte	$32, $48, $64, $ad
'-'                                                             'Bursts Bytes Words Longs  RMW
'-'                             setq    xfreq2                  '   a     b     c     d     e
	byte	$28, $38, $63, $fd
'-'                             xcont   xrecvdata, #0           '   a     b     c     d     e     transfer data as nibbles
	byte	$00, $30, $c7, $fc
'-'                             call    resume                  '   a     b     c     d     |    
	byte	$2d, $cc, $63, $fd
'-'                             waitxfi                         '   a     b     c     d     e     wait for streaming to finish
	byte	$24, $36, $60, $fd
'-'                             wrpin   registered, datapins    '   a     b     c     d     e     restore data pins for next transfer
	byte	$a2, $51, $03, $fc
'-'             _ret_           drvh    cspin                   '   a     b     c     d     |     de-assert chip select and return
	byte	$59, $4e, $63, $0d
'-'                             drvh    cspin                   '                           e     deassert chip select and continue
	byte	$59, $4e, $63, $fd
'-' 
'-'                             getnib  d, request, #1          'get request code value
	byte	$e2, $dd, $4b, $f8
'-'                             altd    d, #skiptable-8         'patch next instruction
	byte	$b6, $dd, $8f, $f9
'-'                             skipf   0-0                     'generate skip sequence for byte, word or long
	byte	$32, $00, $60, $fd
'-'                                                             ' RMWB RMWW RMLL 
'-'                             rdlong  a, ptrb                 '  c    d    e   read back data written to mailbox
	byte	$80, $d7, $07, $fb
'-'                             setq    count                   '  c    d    e   setup bit mux mask
	byte	$28, $ae, $63, $fd
'-'                             muxq    a, hubdata              '  c    d    e   apply bit mux
	byte	$d6, $d7, $f3, $f9
'-'                             mov     wrclks, #20             '  c    |    |   setup clks for byte write
	byte	$14, $d0, $07, $f6
'-'                             mov     wrclks, #24             '  |    d    |   setup clks for word write
	byte	$18, $d0, $07, $f6
'-'                             mov     wrclks, #32             '  |    |    e   setup clks for long write
	byte	$20, $d0, $07, $f6
'-'                             setword xsendimm, #2, #0        '  c    |    |
	byte	$02, $34, $27, $f9
'-'                             setword xsendimm, #4, #0        '  |    d    |
	byte	$04, $34, $27, $f9
'-'                             setword xsendimm, #8, #0        '  |    |    e
	byte	$08, $34, $27, $f9
'-'                             mov     hubdata, a              'write a to PSRAM
	byte	$eb, $ad, $03, $f6
'-'                             mov     pattern, #%001101       'setup next skip pattern to send a single item and resume
	byte	$0d, $d2, $07, $f6
'-'                             mov     resume, complete_rw     'we'll complete the operation after this
	byte	$c9, $cd, $03, $f6
'-'                             jmp     #writecommon
	byte	$34, $02, $90, $fd
'-' 
'-' '..................................................................................................
'-' ' Burst continuation testing
'-' 
'-' continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
	byte	$32, $90, $63, $fd
'-'                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
	byte	$bc, $cd, $03, $f6
'-' continue_read_lut          
'-'                             mov     resume, resumereads     ' | setup resume address to execf
	byte	$bd, $cd, $03, $f6
'-'                             add     hubdata, c              ' a compute the next hub addr to use
	byte	$ed, $ad, $03, $f1
'-'                             sub     count, c                ' a account for the bytes already sent
	byte	$ed, $af, $83, $f1
'-'                             add     c, addr1                ' a compute next external mem address
	byte	$d5, $db, $03, $f1
'-'                             setq    mask                    ' a configure mask for bit muxing
	byte	$28, $40, $63, $fd
'-'                             muxq    addr1, c                ' a perform address bit muxing
	byte	$ed, $ab, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
	byte	$0a, $bc, $0f, $f4
'-'             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
	byte	$14, $00, $90, $5d
'-'                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
	byte	$de, $43, $3b, $f9
'-'                             fle     limit, b                ' | also re-apply per bank limit
	byte	$ec, $43, $23, $f3
'-'             _ret_           push    #continue_read_exec     ' | 
	byte	$2a, $2a, $67, $0d
'-'             if_nz           jmp     #yield                  ' a
	byte	$04, $00, $90, $5d
'-'             _ret_           push    #continue_write_exec    ' a
	byte	$2a, $2c, $67, $0d
'-' 
'-' yield                       wrlut   total, ptra[4]          'save context for next time
	byte	$04, $b3, $37, $fc
'-'                             wrlut   offset1, ptra[5]        'save context for next time
	byte	$05, $b5, $37, $fc
'-'                             wrlut   offset2, ptra[6]        'save context for next time
	byte	$06, $b7, $37, $fc
'-'                             wrlut   link, ptra[7]           'save context for next time
	byte	$07, $b9, $37, $fc
'-' yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
	byte	$00, $ab, $37, $fc
'-'                             wrlut   hubdata, ptra[1]        'save context for next time
	byte	$01, $ad, $37, $fc
'-'                             wrlut   count, ptra[2]          'save context for next time
	byte	$02, $af, $37, $fc
'-'                             wrlut   addr2, ptra[3]          'save context for next time
	byte	$03, $b1, $37, $fc
'-'                             wrlut   resume, ptra[8]         'save next resume address
	byte	$08, $cd, $37, $fc
'-'                             wrlut   orighubsize, ptra[9]    'save original hub size
	byte	$09, $cf, $37, $fc
'-'             _ret_           push    #poller
	byte	$2a, $1c, $66, $0d
'-' 
'-' 
'-' notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
	byte	$32, $be, $65, $fd
'-' nowrite_lut                                                 '  (a) new skip sequence 
'-' noread_lut                  skipf   #0                      ' | cancel skipping
	byte	$32, $00, $64, $fd
'-'                             wrlut   #0, ptra[8]             ' | clear resume
	byte	$08, $01, $3c, $fc
'-'                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
	byte	$09, $bc, $0f, $f4
'-'             if_nz           jmp     #notify                 ' | if not a request list then we are done
	byte	$a8, $f8, $9f, $5d
'-'                             testb   addr2, #31 wz           ' | check if extended list item
	byte	$1f, $b0, $0f, $f4
'-' donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
	byte	$dc, $b1, $03, $a6
'-' checklist                   call    #checknext              ' | handle running from list
	byte	$1c, $00, $b0, $fd
'-'                             ret                             ' | continue processing
	byte	$2d, $00, $64, $fd
'-'             _ret_           push    noread                  'continue end of transfer
	byte	$2a, $98, $63, $0d
'-' '..................................................................................................
'-' ' Completion of requests
'-' 
'-' complete_rw_lut             
'-'                             testb   id, #LIST_BIT wz        'test for running from a request list   
	byte	$09, $bc, $0f, $f4
'-'             if_z            skipf   #%10                    'if a request list then skip notification
	byte	$32, $04, $64, $ad
'-'                             wrlut   #0, ptra[8]             ' a   default is not to resume
	byte	$08, $01, $3c, $fc
'-'             _ret_           push    #notify                 ' |   if not a request list then we are done
	byte	$2a, $14, $66, $0d
'-'                             tjs     addr2, #extendedreq     '     test for special extended request  
	byte	$0d, $b0, $b7, $fb
'-' 'checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
'-' '                            rdlong  pa, ptrb[-1]            'check if list has been aborted by client
'-' '                            tjns    pa, #listcomplete       'exit if it has
'-' '                            skipf   #%1000                  'do not notify if list is continuing
'-' '                            wrlong  addr2, ptrb             ' a  write back next list address
'-' 'listcomplete                altd    id, #id0                ' a  compute COG's state address
'-' '                            bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
'-' '            _ret_           push    #notify                 ' |  we are done with the list
'-' '            _ret_           push    #poller                 ' a  we are still continuing the list
'-' 
'-' 
'-' checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
	byte	$07, $b0, $97, $fb
'-'                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
	byte	$bf, $ed, $07, $fb
'-'                             tjns    pa, #listcomplete       'exit if it has
	byte	$05, $ec, $bf, $fb
'-'                             testb   id, #LOCKED_BIT wz
	byte	$0a, $bc, $0f, $f4
'-'             if_z            mov     hubdata, addr2
	byte	$d8, $ad, $03, $a6
'-'             if_z            skipf   #%110001
	byte	$32, $62, $64, $ad
'-'             if_nz           skipf   #%1000                  'do not notify if list is continuing
	byte	$32, $10, $64, $5d
'-'                             wrlong  addr2, ptrb             ' a  write back next list address
	byte	$80, $b1, $67, $fc
'-' listcomplete                altd    id, #id0                ' a  compute COG's state address
	byte	$cd, $bd, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
	byte	$09, $00, $04, $f4
'-'             _ret_           push    #notify                 ' |  we are done with the list
	byte	$2a, $14, $66, $0d
'-'             _ret_           push    #poller                 ' a  we are still continuing the list
	byte	$2a, $1c, $66, $0d
'-'             _ret_           push    #real_list
	byte	$2a, $50, $66, $0d
'-' 
'-' 
'-' 
'-' extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
	byte	$e3, $af, $97, $fb
'-'                             getnib  a, addr2, #7            'check the request type
	byte	$d8, $d7, $7b, $f8
'-'                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
	byte	$0f, $d6, $0f, $f2
'-'                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
	byte	$d5, $d7, $73, $f8
'-'             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
	byte	$32, $8a, $63, $5d
'-'                                                             ' skipcase (a) gfx copy to/from hub
'-'                                                             ' skipcase (b) gfx copy extmem bank to bank
'-'                                                             ' skipcase (c) linear copy extmem bank to bank
'-'                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
	byte	$d8, $d7, $73, $f8
'-'                             rdlut   d, a wz                 ' a      load bank information and check if valid
	byte	$eb, $dd, $ab, $fa
'-'             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
	byte	$31, $02, $64, $5d
'-'             _ret_           push    #invalidbank            ' |      otherwise bail out after this
	byte	$2a, $02, $66, $0d
'-'                             test    offset1 wz              ' |      check for first offset being zero
	byte	$da, $b5, $cb, $f7
'-'             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
	byte	$db, $b7, $cb, $a7
'-'             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
	byte	$32, $8e, $63, $ad
'-'                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
	byte	$32, $8c, $63, $fd
'-'                             add     hubdata, c              ' a b c  add bytes just sent to hub address
	byte	$ed, $ad, $03, $f1
'-'                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
	byte	$e7, $ad, $83, $f1
'-'                             add     c, addr1                ' a b c  compute next address to use
	byte	$d5, $db, $03, $f1
'-'                             test    total wz                ' a b |  check for zero tranfers
	byte	$d9, $b3, $cb, $f7
'-'                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
	byte	$d9, $cf, $2b, $f3
'-'             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
	byte	$44, $ff, $9f, $ad
'-'                             testb   addr1, #30 wz           ' a b c  check if reading/writing
	byte	$1e, $aa, $0f, $f4
'-'                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
	byte	$e7, $af, $03, $f6
'-'                             sub     c, orighubsize          ' a b |  rewind to original position
	byte	$e7, $db, $83, $f1
'-'             if_z            add     c, offset1              ' a b |  add any dst scanline offset
	byte	$da, $db, $03, $a1
'-'             if_nz           add     c, offset2              ' a b |  add any src scanline offset
	byte	$db, $db, $03, $51
'-'             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
	byte	$db, $ad, $03, $a1
'-'             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
	byte	$da, $ad, $03, $51
'-'                             setq    mask                    ' a b c  configure mask for bit muxing
	byte	$28, $40, $63, $fd
'-'                             muxq    addr1, c                ' a b c  perform address bit muxing
	byte	$ed, $ab, $f3, $f9
'-'                             mov     a, addr1                ' | b c  ]
	byte	$d5, $d7, $03, $f6
'-'                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
	byte	$d8, $ab, $03, $f6
'-'                             mov     addr2, a                ' | b c  ]
	byte	$eb, $b1, $03, $f6
'-'                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
	byte	$1e, $aa, $a7, $f4
'-'                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
	byte	$0f, $b0, $3f, $f8
'-'                             sub     total, #1 wz            ' a | |  decrement scanline count
	byte	$01, $b2, $8f, $f1
'-'             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
	byte	$01, $b2, $8f, $a1
'-'             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
	byte	$e7, $b3, $8b, $a1
'-' '            if_nz           jmp     #moretransfers          ' a b c  more transfers still to go
'-' '                            tjz     link, #listcomplete     ' a b c  test link for next request
'-' '                            rdlong  pa, ptrb[-1]            'check if list has been aborted by client
'-' '                            tjns    pa, #listcomplete       'will exit if it has
'-' '                            wrlong  link, ptrb              'setup list next pointer
'-' '                            altd    id, #id0                'compute COG's state address
'-' '                            bitl    0-0, #LIST_BIT          'clear list flag for this COG
'-' '            _ret_           push    #poller                 'we will return to polling
'-'             if_z            mov addr2,link
	byte	$dc, $b1, $03, $a6
'-'             if_z            jmp #checknext
	byte	$34, $ff, $9f, $ad
'-' moretransfers               getbyte request, addr1, #3      'prepare next request
	byte	$d5, $c5, $fb, $f8
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $bc, $0f, $f4
'-'             if_z            skipf   #%1110                  '     skip some code if we are locked
	byte	$32, $1c, $64, $ad
'-'                             testb   addr1, #30 wz           ' a   test if will be reading or writing
	byte	$1e, $aa, $0f, $f4
'-'             if_z            mov     resume, resumewrites    ' |   resume burst writing
	byte	$bc, $cd, $03, $a6
'-'             if_nz           mov     resume, newburstr       ' |   resume burst reading
	byte	$b7, $cd, $03, $56
'-'                             jmp     #yield                  ' |   yield to poller
	byte	$b0, $fe, $9f, $fd
'-'             if_z            skip    #%1                     '     skip next instruction for writing case
	byte	$31, $02, $64, $ad
'-'             _ret_           push    #start_read_exec        '(|)  do new read burst next 
	byte	$2a, $26, $67, $0d
'-'             _ret_           push    #start_write_exec       'do new write burst next
	byte	$2a, $28, $67, $0d
'-' 
'-' '..................................................................................................
'-' ' PSRAM WRITES
'-'                                                             '  a b c d e f g h
'-' 
'-'                                                             '  B W L F B R L L (a) byte write(s)
'-'                                                             '  Y O O I U E O O (b) word write(s)
'-'                                                             '  T R N L R S C C (c) long write(s)
'-'                                                             '  E D G L S U K K (d) resumed fill
'-'                                                             '          T M E E (e) new burst write
'-'                                                             '            E D D (f) resumed burst
'-'                                                             '              F B (g) locked fill
'-'                                                             '              I U (h) locked burst write
'-'                                                             '              L R 
'-'                                                             '              L S 
'-'                                                             '                T 
'-' 
'-'                 
'-' w_single                   
'-' w_fill_cont           
'-'                             getnib  a, addr1, #7            '  a b c d          obtain request
	byte	$d5, $d7, $7b, $f8
'-'                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
	byte	$03, $d6, $07, $f5
'-'                             andn    addr1, #1               '  | b | |          align word addresses to stop page crossing issues
	byte	$01, $aa, $27, $f5
'-'                             andn    addr1, #3               '  | | c |          align long addresses to stop page crossing issues
	byte	$03, $aa, $27, $f5
'-' w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
	byte	$d7, $cf, $03, $f6
'-' w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
	byte	$01, $ae, $0f, $f2
'-'                             shl     count, a                '  a b c | |   |    scale into bytes
	byte	$eb, $af, $63, $f0
'-'                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
	byte	$ad, $af, $97, $fb
'-' w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
	byte	$d7, $db, $03, $f6
'-'                             call    #\w_get_bankdelay       '  a b c d e f g h  get per bank limit and read delay info
	byte	$7c, $03, $a0, $fd
'-'                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
	byte	$e2, $59, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
	byte	$ac, $c9, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
	byte	$e4, $4f, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
	byte	$e4, $4d, $eb, $f8
'-'                             mov     pattern, #%111 wz       '  | | | | e f | h  setup base skip pattern for bursts
	byte	$07, $d2, $0f, $f6
'-'                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
	byte	$a1, $db, $33, $f3
'-'             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
	byte	$cb, $cd, $03, $c6
'-'             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
	byte	$c9, $cd, $03, $36
'-'                             rdfast  xfreq1, hubdata         '  | | | | e f | h  setup streamer hub addr
	byte	$d6, $37, $73, $fc
'-'             if_z            skipf   write_skip              '  a b c d | | g |  extend single write skip pattern (optimization)
	byte	$32, $84, $63, $ad
'-'             if_z            mov     pattern, #%10011101     '  a b c d | | g |  setup pattern for single writes
	byte	$9d, $d2, $07, $a6
'-'                             skipf   fill_skip               '  ? ? ? d | | g |  extend fill skip pattern
	byte	$32, $86, $63, $fd
'-'                             mov     pattern, #0             '  ? ? ? d | | g |  setup pattern for fill writes
	byte	$00, $d2, $07, $f6
'-'                             skipf   burst_skip              '  | | | | e f | h  extend burst writes skip pattern
	byte	$32, $88, $63, $fd
'-'                             'if not just a single transfer we need to work out how many bytes are left to the page boundary
'-'                             mov     d, addr1                '  | | | d e f g h  get start address
	byte	$d5, $dd, $03, $f6
'-'                             zerox   d, #(PAGE_BITS-1)       '  | | | d e f g h  only keep page LSBs
	byte	$09, $dc, $47, $f7
'-'                             subr    d, pagesize             '  | | | d e f g h  figure out how many bytes remain before we hit the boundary
	byte	$ea, $dd, $c3, $f2
'-'                             fle     c, d wc                 '  | | | d e f g h  compare this size to our transfer size and limit it
	byte	$ee, $db, $33, $f3
'-'                             mov     wrclks, c               '  a b c d e f g h  number of bytes to be sent
	byte	$ed, $d1, $03, $f6
'-'                             mul     wrclks, #4              '  a b c d e f g h  convert to clock transitions (2 transitions/nibble)
	byte	$04, $d0, $07, $fa
'-'                             add     wrclks, #16             '  a b c d e f g h  add header clock transitions
	byte	$10, $d0, $07, $f1
'-'             if_c            mov     resume, continue_write  '  | | | | e f | h  and we will continue with a sub-burst again
	byte	$cb, $cd, $03, $c6
'-'                             mov     pb, c                   '  | | | d | | g |  get number of bytes to be filled
	byte	$ed, $ef, $03, $f6
'-'                             shr     pb, a                   '  | | | d | | g |  scale into number of items to fill
	byte	$eb, $ef, $43, $f0
'-'                             decod   d, a                    '  a b c d | | g |  get write item size in bytes
	byte	$eb, $dd, $c3, $f9
'-'                             shl     d, #1                   '  a b c d | | g |  convert to nibbles
	byte	$01, $dc, $67, $f0
'-'                             setword xsendimm, d, #0         '  a b c d | | g |  setup streamer count
	byte	$ee, $35, $23, $f9
'-'                             setword xsenddata, c, #0        '  | | | | e f | h  setup write burst bytes to be streamed
	byte	$ed, $33, $23, $f9
'-'                             add     xsenddata, c            '  | | | | e f | h  convert to nibbles
	byte	$ed, $33, $03, $f1
'-' 
'-' writecommon                 mov     cmdaddr, addr1          'get start address of transfer
	byte	$d5, $c3, $03, $f6
'-'                             setbyte cmdaddr, #$02, #3       'add quad write command
	byte	$02, $c2, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c2, $63, $fd
'-'                             rev     cmdaddr                 
	byte	$69, $c2, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c2, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c2, $63, $fd
'-'                             
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $4e, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $44, $63, $fd
'-'                             xinit   ximm8, cmdaddr          'send 8 nibbles of address and command via LUT translation
	byte	$e1, $2f, $a3, $fc
'-'                             wypin   wrclks, clkpin          'start memory clock output 
	byte	$a6, $d1, $23, $fc
'-'                                                          
'-'                             skipf   pattern                 '   B W L Burst FB FW FL RMW
	byte	$32, $d2, $63, $fd
'-'                             rep     #1, pb                  '   | | |   |    e  f  g  | ' repeat for bursts
	byte	$f7, $03, $d8, $fc
'-'                             xcont   xsendimm, hubdata       '   a b c   |    e  f  g  h ' send immediate data as nibbles
	byte	$d6, $35, $c3, $fc
'-'                             skipf   #%10011                 '   | | |   |    e  f  g  | '
	byte	$32, $26, $64, $fd
'-'                             xcont   xsenddata, #0           '   | | |   d    |  |  |  | ' send data from hub for bursts as nibbles
	byte	$00, $32, $c7, $fc
'-'                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
	byte	$2d, $cc, $63, $fd
'-'                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
	byte	$50, $44, $63, $fd
'-'             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
	byte	$59, $4e, $63, $0d
'-' 
'-'                             drvh    cspin
	byte	$59, $4e, $63, $fd
'-' check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
	byte	$09, $bc, $17, $f4
'-'                             sub     count, c wz             'account for bytes written
	byte	$ed, $af, $8b, $f1
'-'             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
	byte	$34, $00, $90, $5d
'-'                             wrlut   #0, ptra[8]             'default is not to resume
	byte	$08, $01, $3c, $fc
'-'             if_nc           jmp     #notify                 'if not a request list then we are done
	byte	$8c, $f6, $9f, $3d
'-'                             tjns    addr2, #checklist       'if not extended, check next list entry
	byte	$7a, $b1, $bf, $fb
'-'                             djz     total, #donerepeats     'check for repeats remaining
	byte	$78, $b3, $67, $fb
'-'                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
	byte	$b6, $b3, $b3, $fb
'-'                             mov     d, orighubsize
	byte	$e7, $dd, $03, $f6
'-'                             shl     d, a
	byte	$eb, $dd, $63, $f0
'-'                             sub     c, d
	byte	$ee, $db, $83, $f1
'-'                             add     c, offset1
	byte	$da, $db, $03, $f1
'-'                             mov     count, d                'restore original count
	byte	$ee, $af, $03, $f6
'-' readmask                    getnib  b, request, #0          'get bank parameter LUT address
	byte	$e2, $d9, $43, $f8
'-'                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
	byte	$ec, $d9, $a3, $fa
'-'                             bmask   mask, b                 'build mask for addr (in case count=1)
	byte	$ec, $41, $cb, $f9
'-' continue_fill               add     c, addr1                'add bytes to destination address
	byte	$d5, $db, $03, $f1
'-'                             setq    mask                    'setup bit mask
	byte	$28, $40, $63, $fd
'-'                             muxq    addr1, c                'setup new external memory address
	byte	$ed, $ab, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $bc, $0f, $f4
'-'             if_z            execf   lockedfill              'continue next fill operation
	byte	$33, $70, $63, $ad
'-'                             mov     resume, restorefill
	byte	$b9, $cd, $03, $f6
'-'             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
	byte	$00, $b0, $07, $36
'-'             if_nc           call    #yieldfill              'we have to yield now to other COGs
	byte	$68, $fd, $bf, $3d
'-'             if_c            call    #yield
	byte	$54, $fd, $bf, $cd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-'                            
'-' w_get_bankdelay             getnib  b, request, #0          'get bank parameter LUT address
	byte	$e2, $d9, $43, $f8
'-'                             rdlut   b, b                    'get bank limit/mask
	byte	$ec, $d9, $a3, $fa
'-'                             bmask   mask, b                 'build mask for addr
	byte	$ec, $41, $cb, $f9
'-'                             getbyte delay, b, #1            'get input delay of bank + flags
	byte	$ec, $3b, $eb, $f8
'-'                             shr     b, #17                  'scale burst size based on bus rate
	byte	$11, $d8, $47, $f0
'-'                             fle     limit, b                'apply any per bank limit to cog limit
	byte	$ec, $43, $23, $f3
'-'                             shr     delay, #5 wc            'prep delay and test for registered inputs
	byte	$05, $3a, $57, $f0
'-'             _ret_           bitnc   regdatabus, #16         'setup if data bus is registered or not
	byte	$10, $56, $67, $04
'-' 
'-' '..................................................................................................
'-' 
'-'         fit 1024
'-'         fit 1024
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-'         orgh
'-' 
'-' gfxexpansion
'-'                             'simple line drawing graphics expansion of memory driver
'-'                             'jmp     #donerepeats                'just return for now
'-' 
'-'                             cmp     addr1, addr2 wz         'see if we've reached the end
	byte	$d8, $ab, $0b, $f2
'-'             if_z            jmp     #donerepeats            'nothing more to draw
	byte	$e1, $02, $80, $ad
'-'                             add     total, #1               'restore total after decrement
	byte	$01, $b2, $07, $f1
'-'                             mov     b, offset1              'get error term
	byte	$da, $d9, $03, $f6
'-'                             shl     b, #1                   'compute e2 = 2 x error
	byte	$01, $d8, $67, $f0
'-'                             getword d, offset2, #0          'get dx = abs(x0-x1)
	byte	$db, $dd, $33, $f9
'-'                             sar     offset2, #16            'get dy = -abs(y0-y1)
	byte	$10, $b6, $c7, $f0
'-'                             cmps    b, offset2 wc           'compare if e2 >= dy
	byte	$db, $d9, $53, $f2
'-'                             mov     c, #0                   'clear accumulator reg
	byte	$00, $da, $07, $f6
'-'             if_c            skip    #%1110                  'if not, skip
	byte	$31, $1c, $64, $cd
'-'                             decod   a                       'decode as 1,2,or 4 byte size
	byte	$eb, $d7, $c3, $f9
'-'                             add     offset1, offset2        'err+=dy 
	byte	$db, $b5, $03, $f1
'-'                             testb   total, #16 wz           'check sign sx   
	byte	$10, $b2, $0f, $f4
'-'                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
	byte	$eb, $db, $c3, $f3
'-'                             cmps    d, b wc                 'compare if e2 <= dx
	byte	$ec, $dd, $53, $f2
'-'             if_c            skip    #%11110                 'if not, skip
	byte	$31, $3c, $64, $cd
'-'                             rolword offset2, d, #0          'restore offset
	byte	$ee, $b7, $43, $f9
'-'                             add     offset1, d              'err+=dx
	byte	$ee, $b5, $03, $f1
'-'                             testb   total, #17 wz           'check sign sy
	byte	$11, $b2, $0f, $f4
'-'                             getword d, total, #0            'get line width
	byte	$d9, $dd, $33, $f9
'-'                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
	byte	$ee, $db, $c3, $f3
'-'                             encod   a wc                    'restore size and set carry
	byte	$eb, $d7, $93, $f7
'-'                             mov     count, orighubsize      'reset the fill width
	byte	$e7, $af, $03, $f6
'-'                             shl     count, a                '..for the type of transfer
	byte	$eb, $af, $63, $f0
'-'                             jmp     #readmask               'continue filling
	byte	$6f, $03, $80, $fd
	alignl
_usbnew_spin2_dat_
'-'                 org     $000
'-' 
'-' usb_host_start
'-'                 mov     hcog_base_addr, ptrb
	byte	$f9, $8f, $02, $f6
'-' 
'-'                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
	byte	$03, $00, $00, $ff, $d0, $72, $07, $f6
'-'                 shr     htmp, #2                        ' so byte->long for the lut cell count
	byte	$02, $72, $47, $f0
'-'                 loc     pb, #@hlut_start - @usb_host_start
	byte	$b4, $04, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq2   htmp
	byte	$29, $72, $63, $fd
'-'                 rdlong  0, pb                           ' Do the hub->lut copy
	byte	$f7, $01, $00, $fb
'-' 
'-'                 loc     pb, #@usb_host_init - @usb_host_start
	byte	$88, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 jmp     pb                              ' Initialize host and enter main processing loop
	byte	$2c, $ee, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
'-' ' special because the receiving function must not respond with either STALL or
'-' ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
'-' ' non-control endpoint receives a SETUP token, or the function receives a
'-' ' corrupt packet, it must ignore the transaction
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data struct.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error code.
'-' '------------------------------------------------------------------------------
'-' txn_setup
'-'                 setbyte ep_addr_pid, #PID_SETUP, #0
	byte	$2d, $bc, $c6, $f8
'-'                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
	byte	$08, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
	byte	$03, $96, $06, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
	byte	$0c, $a2, $06, $f6
'-'                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
	byte	$f8, $ed, $03, $f6
'-' .setup
'-'                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
	byte	$24, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait
	byte	$7c, $0b, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
	byte	$f6, $f1, $03, $f6
'-'                 jmp     #.setup
	byte	$e0, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' IN/INTERRUPT transaction.
'-' ' Possible function response: STALL or NAK handshake, or DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_in
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$90, $03, $b0, $fd
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #utx_token                      ' Put IN request on the bus
	byte	$bc, $00, $b0, $fd
'-' 
'-'                 ' Fall through to urx_packet
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a packet from a device/function. As host, the only two packet types
'-' ' received are handshakes and IN DATAx.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'-' '     returned.
'-' '------------------------------------------------------------------------------
'-' urx_packet
'-'                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #urx_packet
	byte	$f4, $ff, $9f, $cd
'-'                 getct   hct2
	byte	$1a, $94, $63, $fd
'-'                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
	byte	$4e, $95, $6b, $fa
'-'                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
	byte	$05, $96, $06, $f4
'-'                 mov     newb_flg, #0                    ' Initialize for multi-byte read
	byte	$00, $a8, $06, $f6
'-' .wait_sop
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #.get_pid
	byte	$08, $00, $90, $cd
'-'                 jnct2   #.wait_sop
	byte	$fc, $25, $cc, $fb
'-'         _ret_   mov     retval, #ERR_TAT
	byte	$05, $be, $06, $06
'-' .get_pid
'-'                 call    #urx_next
	byte	$28, $02, $b0, $fd
'-'                 testb   urx, #BUS_ERRB          wc
	byte	$06, $a6, $16, $f4
'-'         if_nc   jmp     #.chk_pid
	byte	$04, $00, $90, $3d
'-'         _ret_   mov     retval, #ERR_URX
	byte	$02, $be, $06, $06
'-' .chk_pid
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $52
'-'         if_nz   cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
	byte	$38, $00, $90, $ad
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
	byte	$03, $96, $16, $f4
'-'                 cmp     retval, #PID_DATA0      wz
	byte	$c3, $be, $0e, $f2
'-'    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
	byte	$28, $01, $90, $2d
'-'    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
	byte	$10, $00, $90, $8d
'-'                 cmp     retval, #PID_DATA1      wz
	byte	$4b, $be, $0e, $f2
'-'    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
	byte	$1c, $01, $90, $8d
'-'    if_z_and_nc  jmp     #.ack_resend
	byte	$04, $00, $90, $2d
'-'         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
	byte	$04, $be, $06, $06
'-' .ack_resend
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.ack_resend
	byte	$f4, $ff, $9f, $3d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 call    #utx_handshake                  ' Send handshake PID and return to caller
	byte	$98, $01, $b0, $fd
'-'         _ret_   mov     retval, #ERR_DATAX_SYNC
	byte	$09, $be, $06, $06
'-' .chk_eop
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
	byte	$1c, $00, $90, $3d
'-'                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
	byte	$c8, $01, $b0, $fd
'-'                 testb   hstatus, #EOPB          wc
	byte	$05, $96, $16, $f4
'-'         if_c    jmp     #.idle                          ' Low-speed EOP seen
	byte	$10, $00, $90, $cd
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
	byte	$04, $be, $06, $36
'-'         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
	byte	$02, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
	byte	$f4, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send a token packet with CRC5 checksum of address and endpoint. It is the
'-' ' responsibility of the caller to append the appropriate inter-packet delay,
'-' ' if one is required.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - packed with the PID, address and endpoint.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_token
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #utx_token
	byte	$f4, $ff, $9f, $3d
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$34, $0d, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync byte
	byte	$70, $01, $b0, $fd
'-'                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
	byte	$5e, $73, $03, $f6
'-'                 mov     pkt_cnt, #3
	byte	$03, $b8, $06, $f6
'-' .next_byte
'-'                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
	byte	$b9, $a5, $e2, $f8
'-'                 shr     htmp, #8                        ' Shift to next byte to send
	byte	$08, $72, $47, $f0
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   utx, dm
	byte	$22, $a5, $22, $fc
'-'         _ret_   djnz    pkt_cnt, #.next_byte
	byte	$f9, $b9, $6e, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP/OUT/INTERRUPT transaction.
'-' ' Possible function response in order of precedence: STALL, ACK, NAK.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' '   PTRA - start address of the data buff/struct that has the bytes to send.
'-' '   pkt_data - count of DATAx payload bytes to send.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_out
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$88, $02, $b0, $fd
'-'                 call    #utx_token                      ' Put SETUP/OUT token on the bus
	byte	$b8, $ff, $bf, $fd
'-'                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
	byte	$00, $00, $c0, $ff, $f8, $01, $78, $fc
'-'                 mov     pkt_cnt, pkt_data
	byte	$58, $b9, $02, $f6
'-' 
'-'                 ' Fall through to utx_data
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
'-' ' calculated while the data byte is being shifted out. Since data stage
'-' ' success/fail is not determined until the status stage of the transaction,
'-' ' this routine is only concerned about the current DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - hub start address of the data to read.
'-' '   pkt_cnt - data payload size.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_data
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #utx_data
	byte	$f4, $ff, $9f, $cd
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
	byte	$2c, $0a, $b0, $fd
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$d8, $0c, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$14, $01, $b0, $fd
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
	byte	$03, $96, $16, $f4
'-'         if_nc   mov     utx, #PID_DATA0
	byte	$c3, $a4, $06, $36
'-'         if_c    mov     utx, #PID_DATA1
	byte	$4b, $a4, $06, $c6
'-'                 call    #utx_byte                       ' No CRC calc done on PID
	byte	$00, $01, $b0, $fd
'-'                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
	byte	$1c, $00, $90, $ad
'-' .read_byte
'-'                 rfbyte  utx                             ' Fetch data byte
	byte	$10, $a4, $62, $fd
'-'                 call    #utx_byte
	byte	$f0, $00, $b0, $fd
'-'                 rev     utx                             ' Calculate CRC while the data is shifting out
	byte	$69, $a4, $62, $fd
'-'                 setq    utx                             ' SETQ left-justifies the reflected data byte
	byte	$28, $a4, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-'                 djnz    pkt_cnt, #.read_byte
	byte	$f9, $b9, $6e, $fb
'-' .send_crc
'-'                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
	byte	$e0, $bb, $e6, $f4
'-'                 getbyte utx, crc, #0
	byte	$5d, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$d0, $00, $b0, $fd
'-'                 getbyte utx, crc, #1
	byte	$5d, $a5, $ea, $f8
'-'                 call    #utx_byte                       ' Last CRC byte out
	byte	$c8, $00, $b0, $fd
'-'                 jmp     #urx_packet                     ' Handle function response/error and back to caller
	byte	$7c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
'-' ' payload bytes are received. The routine reads bytes until EOP is detected and
'-' ' expects that the packet includes at least the CRC word.
'-' '
'-' ' In control transfers, it's possible to recieve fewer data bytes than what
'-' ' was requested, which makes it difficult to determine where the data stops
'-' ' and the CRC word begins. So the CRC calculation is done on every byte of the
'-' ' packet, including the CRC word. The CRC value should then be equal to the
'-' ' USB-16 expected residual value of 0xB001.
'-' '
'-' ' The routine writes the IN packet data to a static max_packet_size buffer
'-' ' so the caller can verify IN success before writing the data to its final
'-' ' destination.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   pkt_data - max byte count expected to be in the packet.
'-' '   newb_flg - signals new byte ready when toggled.
'-' ' On exit:
'-' '   pkt_cnt - actual number of bytes read.
'-' '------------------------------------------------------------------------------
'-' urx_data
'-'                 mov     htmp2, pb
	byte	$f7, $77, $03, $f6
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
	byte	$00, $00, $c0, $ff, $f7, $01, $88, $fc
'-'                 mov     pb, htmp2
	byte	$bb, $ef, $03, $f6
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
	byte	$00, $b8, $06, $f6
'-'                 mov     pkt_tmp, pkt_data
	byte	$58, $85, $03, $f6
'-'                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
	byte	$02, $84, $07, $f1
'-' .wait_byte
'-' ' In-line rx for max speed
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   jmp     #.get_byte                      ' New byte!
	byte	$0c, $00, $90, $5d
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_c    jmp     #.chk_crc                       ' At end-of-packet
	byte	$38, $00, $90, $cd
'-'                 jmp     #.wait_byte
	byte	$dc, $ff, $9f, $fd
'-' .get_byte
'-'                 getbyte retval, urx, #1                 ' New byte from smart pins
	byte	$53, $bf, $ea, $f8
'-'                 wfbyte  retval                          ' Add it to the data buffer
	byte	$15, $be, $62, $fd
'-'                 rev     retval                          ' Calculate CRC while next byte is shifting in
	byte	$69, $be, $62, $fd
'-'                 setq    retval                          ' SETQ left-justifies the reflected data byte
	byte	$28, $be, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-' .end_crc
'-'                 add     pkt_cnt, #1
	byte	$01, $b8, $06, $f1
'-'                 cmp     pkt_cnt, pkt_tmp        wcz
	byte	$c2, $b9, $1a, $f2
'-'         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
	byte	$04, $be, $06, $16
'-'         if_a    ret
	byte	$2d, $00, $64, $1d
'-' ' For full-speed at 80MHz, the time it takes to do the final byte write and
'-' ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
'-' ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
'-' ' to miss it, so cheat a bit and look for SOP clear here.
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
	byte	$a8, $ff, $9f, $3d
'-' ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
'-' .chk_crc
'-'                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
	byte	$02, $b8, $86, $f1
'-'                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
	byte	$58, $00, $00, $ff, $01, $ba, $6e, $f5
'-'         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
	byte	$f0, $fd, $9f, $5d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$34, $09, $b0, $fd
'-' 
'-'                 ' Fall through to utx_handshake
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
'-' ' the appropriate IP delay has been inserted.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - handshake PID to send.
'-' ' On exit:
'-' '   retval unchanged.
'-' '------------------------------------------------------------------------------
'-' utx_handshake
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$e0, $0b, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$1c, $00, $b0, $fd
'-'                 mov     utx, retval
	byte	$5f, $a5, $02, $f6
'-'                 call    #utx_byte                       ' Send handshake PID
	byte	$14, $00, $b0, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
	byte	$f4, $ff, $9f, $3d
'-'                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
	byte	$4e, $99, $02, $f6
'-'                 jmp     #poll_waitx
	byte	$08, $09, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for the USB tx buffer to empty and feed it a new byte.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   utx - byte to transmit.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_byte
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #utx_byte
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
	byte	$1f, $94, $62, $fd
'-'         _ret_   wypin   utx, dm
	byte	$22, $a5, $22, $0c
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Fetch the next data byte of a packet. Always check receiver status for EOP.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the byte read.
'-' '   urx - the receiver status. The caller must check the hstatus reg EOP flag
'-' '     on return. If EOP is set, the byte in reg retval remains as the last byte
'-' '     received.
'-' '------------------------------------------------------------------------------
'-' urx_next
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
	byte	$53, $bf, $ea, $58
'-'         if_nz   ret                                     ' New byte is priority, so return now
	byte	$2d, $00, $64, $5d
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
	byte	$d8, $ff, $9f, $4d
'-'         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
	byte	$05, $96, $26, $34
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
'-' ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
'-' ' length, and the PID is not included in the CRC calculation:
'-' '  CRC5  FRAME_NUMBER SOF (full-speed)
'-' '  CRC5  ENDP ADDRESS PID
'-' ' %00000_1111_1111111_xxxxxxxx
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - stuffed with the function endpoint, address and
'-' '     SETUP/IN/OUT/SOF PID according to the USB standard.
'-' ' On exit:
'-' '   ep_addr_pid - CRC value appended to the packet.
'-' '------------------------------------------------------------------------------
'-' calc_crc5
'-'                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
	byte	$ff, $03, $00, $ff, $ff, $bd, $06, $f5
'-'                 mov     htmp, ep_addr_pid
	byte	$5e, $73, $03, $f6
'-'                 shr     htmp, #8                        ' PID not included in CRC calc
	byte	$08, $72, $47, $f0
'-'                 mov     crc, #$1f                       ' Initial CRC5 value
	byte	$1f, $ba, $06, $f6
'-'                 rev     htmp                            ' Input data reflected
	byte	$69, $72, $63, $fd
'-'                 setq    htmp                            ' CRCNIB setup for data bits 0..7
	byte	$28, $72, $63, $fd
'-'                 crcnib  crc, #USB5_POLY
	byte	$14, $ba, $de, $f9
'-'                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
	byte	$14, $ba, $de, $f9
'-'                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
	byte	$09, $72, $77, $f0
'-'                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $72, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $72, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 xor     crc, #$1f                       ' Final XOR value
	byte	$1f, $ba, $66, $f5
'-'                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
	byte	$13, $ba, $66, $f0
'-'         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
	byte	$5d, $bd, $42, $05
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed/low-speed frame timing interrupt service routine.
'-' '------------------------------------------------------------------------------
'-' isr1_fsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6f, $13, $fc
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 mov     utx, #PID_SOF
	byte	$a5, $a4, $06, $f6
'-'                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
	byte	$22, $01, $29, $fc
'-'                 call    #utx_byte                       ' Send token PID byte
	byte	$4c, $ff, $bf, $fd
'-'                 mov     icrc, #$1f                      ' Prime the CRC5 pump
	byte	$1f, $b6, $06, $f6
'-'                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
	byte	$59, $b5, $02, $f6
'-'                 rev     sof_pkt                         ' Input data reflected
	byte	$69, $b4, $62, $fd
'-'                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
	byte	$28, $b4, $62, $fd
'-'                 crcnib  icrc, #USB5_POLY
	byte	$14, $b6, $de, $f9
'-'                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
	byte	$14, $b6, $de, $f9
'-'                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
	byte	$59, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$2c, $ff, $bf, $fd
'-'                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
	byte	$08, $b4, $66, $f0
'-'                 rep     #2, #3                          ' Three data bits left to process
	byte	$03, $04, $dc, $fc
'-'                 shl     sof_pkt, #1             wc
	byte	$01, $b4, $76, $f0
'-'                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
	byte	$14, $b6, $d6, $f9
'-'                 xor     icrc, #$1f                      ' Final XOR value
	byte	$1f, $b6, $66, $f5
'-'                 getbyte utx, frame, #1                  ' Send remaining frame number bits
	byte	$59, $a5, $ea, $f8
'-'                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
	byte	$03, $b6, $66, $f0
'-'                 or      utx, icrc
	byte	$5b, $a5, $42, $f5
'-'                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
	byte	$08, $ff, $bf, $fd
'-'                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
	byte	$a4, $83, $03, $f6
'-'                 jmp     #isr1_wait
	byte	$20, $00, $90, $fd
'-' isr1_lsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
	byte	$22, $09, $28, $fc
'-'                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
	byte	$a3, $83, $03, $f6
'-' isr1_wait
'-'                 rqpin   utx, dm
	byte	$22, $a5, $82, $fa
'-'                 testb   utx, #SOPB                 wc
	byte	$04, $a4, $16, $f4
'-'         if_c    jmp     #isr1_wait
	byte	$f4, $ff, $9f, $cd
'-'                 add     frame, #1                       ' Next frame# and check for wrap around
	byte	$01, $b2, $06, $f1
'-'                 and     frame, ##$7ff
	byte	$03, $00, $00, $ff, $ff, $b3, $06, $f5
'-'                 waitx   isrtmp1                         ' Make sure bus is idle
	byte	$1f, $82, $63, $fd
'-'                 reti1
	byte	$f5, $ff, $3b, $fb
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a window within the 1ms frame boundary that will ensure that a
'-' ' transaction will complete before the next frame is triggered.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' wait_txn_ok
'-'                 getct   htmp2
	byte	$1a, $76, $63, $fd
'-'                 sub     htmp2, iframe_ct_base
	byte	$49, $77, $83, $f1
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    cmp     htmp2, _txn_ok_ls_      wcz
	byte	$a1, $77, $1b, $c2
'-'         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
	byte	$a2, $77, $1b, $32
'-'         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
	byte	$e8, $ff, $9f, $1d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A device connection was detected, or a bus reset was requested by the USB
'-' ' client. Set the appropriate smart pin FS/LS speed mode to match the device
'-' ' and perform a reset sequence prior to device enumeration.
'-' '------------------------------------------------------------------------------
'-' dev_reset
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
	byte	$01, $a6, $16, $f4
'-'         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
	byte	$f4, $03, $b0, $cd
'-'         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
	byte	$e0, $03, $b0, $3d
'-' reset
'-'                 setint1 #0                              ' Don't want frame interrupt while in reset
	byte	$25, $00, $64, $fd
'-'                 wypin   #OUT_SE0, dm                    ' Assert bus reset
	byte	$22, $03, $28, $fc
'-'                 waitx   _reset_hold_                    ' Spec is >= 10ms
	byte	$1f, $5c, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 mov     frame, #0                       ' Reset the frame timespan count
	byte	$00, $b2, $06, $f6
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-'                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
	byte	$59, $73, $03, $f6
'-'                 add     htmp, #36
	byte	$24, $72, $07, $f1
'-'                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
	byte	$25, $02, $64, $fd
'-' .framewait
'-'                 cmp     frame, htmp             wcz
	byte	$b9, $b3, $1a, $f2
'-'         if_b    jmp     #.framewait
	byte	$f8, $ff, $9f, $cd
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - source address.
'-' '   PB - destination address.
'-' '   hr0 - length of copy, in bytes.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hmemcpy
'-'                 rdbyte  htmp, ptra++
	byte	$61, $73, $c7, $fa
'-'                 wrbyte  htmp, pb
	byte	$f7, $73, $43, $fc
'-'                 add     pb, #1
	byte	$01, $ee, $07, $f1
'-'         _ret_   djnz    hr0, #hmemcpy
	byte	$fc, $87, $6f, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
'-' ' loop until the errant device is disconnected.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' host_error
'-'           if ERROR_LED >= 0
'-'           end
'-'                 jmp     #host_reset                     ' See if it works...
	byte	$a0, $07, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get HID descriptor buffer for current port
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   PB - HID descriptor buffer pointer
'-' '------------------------------------------------------------------------------
'-' get_hid_descr_buffer
'-'                 mov     pb, hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb, #1
	byte	$01, $ee, $e7, $f2
'-'                 mul     pb, #HID_DESCR_LEN
	byte	$00, $ef, $07, $fa
'-'         _ret_   add     pb, hid_descr_p
	byte	$25, $ef, $03, $01
'-' 
'-' 
'-' usb16_poly_r    long    USB16_POLY
	byte	$01, $a0, $00, $00
'-' 
'-' ' USB commands and error codes
'-' cmd_data        long    0
	byte	$00, $00, $00, $00
'-' usb_err_code    long    ERR_NONE
	byte	$00, $00, $00, $00
'-' 
'-' ' Parameters block assigned at cog startup
'-' dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
	byte	$12, $00, $00, $00
'-' dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
	byte	$13, $00, $00, $00
'-' usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
	byte	$11, $00, $00, $00
'-' if ACTIVITY_LED >= 0
'-' host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
'-' end
'-' if ERROR_LED >= 0
'-' host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
'-' end
'-' hid_descr_p     long    0
	byte	$00, $00, $00, $00
'-' 'hid_report_p    long    0, 0[MAX_DEVICES]
'-' 'hkbd_report_p   long    0
'-' hub_descr_p     long    0
	byte	$00, $00, $00, $00
'-' urx_buff_p      long    0
	byte	$00, $00, $00, $00
'-' dev_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' con_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' cache_start_p   long    0
	byte	$00, $00, $00, $00
'-' cache_end_p     long    0
	byte	$00, $00, $00, $00
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_out_ptr  long    0
'-' end
'-' save_sysclk     long    0         ' Save the current sysclock as the client may change it
	byte	$00, $00, $00, $00
'-' 
'-' hdev_init_start
'-' hdev_port       res     1
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' kbm_next_datax  res     1
'-' hub_intf_num    res     1
'-' hub_next_datax  res     1
'-' hub_status_chg  res     1
'-' hub_port_status res     1
'-' if HAVE_MOUSE
'-' ms_intf_num     res     1
'-' ms_in_max_pkt   res     1
'-' end
'-' kb_intf_num     res     1
'-' kb_interval     res     1
'-' kb_in_max_pkt   res     1
'-' kb_max_index    res     1
'-' kb_led_states   res     1
'-' gp_intf_num     res     1
'-' gp_interval     res     1
'-' gp_max_index    res     1
'-' gp_descr_len    res     1+MAX_DEVICES
'-' hdev_init_end
'-' 
'-' ' Initialized at cog startup:
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' iframe_ct_new   res     1
'-' iframe_ct_base  res     1
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' 
'-' ' This register block is reset to zero when a USB device connects
'-' hreg_init_start
'-' hstatus         res     1         ' Host status flags
'-' hctwait         res     1         ' Poll-based wait clocks
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' xfer_retry      res     1         ' Control transfer retry count
'-' retry           res     1         ' Transaction retry count
'-' utx             res     1         ' Byte to transmit on USB
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' frame           res     1         ' USB 1ms frame counter value
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' crc             res     1         ' Used for CRC16 calculation
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' retval          res     1         ' Global success/fail return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' ' Device stuff
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_bcd        res     1
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' ' Keyboard/mouse stuff
'-' hctrl_ep_addr   res     1
'-' hctrl_max_pkt   res     1
'-' hconfig_base    res     1
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_class      res     1
'-' hdev_subclass   res     1
'-' hdev_protocol   res     1
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' if HAVE_MOUSE
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' end
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_out_addr   res     1
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
'-' end
'-' 
'-' hreg_init_end
'-' 
'-' hidr_start
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_flags      res     1
'-' hidr_axis       res     4
'-' hidr_buttons    res     1
'-' hidr_hats       res     1
'-' '' Above are actually useful values, 6 longs
'-' hidr_type       res     1
'-' hidr_id         res     1
'-' hidr_offset     res     1
'-' hidr_usage_idx  res     1
'-' ' below need to be push/pop'd
'-' hidr_state      res     1
'-' hidr_size       res     1
'-' hidr_count      res     1
'-' hidr_lminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_end
'-' 
'-' ' Variables dependent on the system freqency
'-' _var_64_lower_  res     1
'-' _var_64_upper_  res     1
'-' _12Mbps_        res     1
'-' _1_5Mbps_       res     1
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1us_           res     1         ' 1us
'-' _10us_          res     1         ' 10us
'-' _33us_          res     1         ' 33us
'-' _txn_err_       res     1         ' 250us
'-' _500us_         res     1         ' 500us
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _preamble_wait_ res     1
'-' _1ms_           res     1         ' 1ms
'-' _2ms_           res     1         ' 2ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _4ms_           res     1         ' 4ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _reset_hold_    res     1         ' 15ms
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _21ms_          res     1         ' 21ms
'-' _100ms_         res     1         ' 100ms
'-' _500ms_         res     1         ' 500ms
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' '------------------------------------------------------------------------------
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_d_ls_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' '------------------------------------------------------------------------------
'-' ' Scratch registers
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp1           res     1
'-' htmp2           res     1
'-' htmp3           res     1
'-' hrep            res     1         ' Repeat count
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave1          res     1
'-' hsave2          res     1
'-' isrtmp1         res     1
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' hr0             res     1         ' Multi-purpose registers
'-' hr1             res     1
'-' hr2             res     1
'-' hr3             res     1
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar2           res     1
'-' hpar3           res     1
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' mod_cnt         res     1         ' Used in idle loops
'-' 
'-'                 fit     $1F0
'-'                 fit     $1F0
'-'                 org     $200
'-' hlut_start
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed is the host's native speed, so all that is needed is to set the FS
'-' ' settings to startup defaults.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: Save/restore caller C flag state if C is changed in this routine!
'-' '------------------------------------------------------------------------------
'-' set_speed_full
'-'                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$d0, $e8, $07, $f6
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
	byte	$a6, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
	byte	$a4, $9b, $02, $06
'-' '                ret                             wcz     ' Restore caller flags on exit
'-' 
'-' '------------------------------------------------------------------------------
'-' ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
'-' ' is a downstream hub connected (not yet implemented), the baud generator
'-' ' remains set at the full-speed rate, but signaling is switched to low-speed,
'-' ' which reverses the D-/D+ polarity. The polarity can be changed without
'-' ' putting the smart pins into reset.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: CZ flags restored to caller states
'-' '------------------------------------------------------------------------------
'-' set_speed_low
'-'                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
	byte	$80, $96, $ce, $f7
'-'         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$ed, $e8, $07, $a6
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
	byte	$22, $6b, $13, $fc
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $f6
'-'                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
	byte	$02, $96, $26, $f4
'-'                 ret                             wcz     ' Restore caller flags on exit
	byte	$2d, $00, $7c, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform configuration stuff required when a device intitially connects.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' on_connect
'-'                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$02, $86, $07, $f6
'-'                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
	byte	$d8, $fb, $bf, $fd
'-' .retry
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
	byte	$01, $8e, $07, $c6
'-'         if_nc   mov     hpar1, #USB_SPEED_FULL
	byte	$02, $8e, $07, $36
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$20, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$f4, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.get_dev_desc
	byte	$18, $00, $90, $ad
'-'                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
	byte	$b2, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$4c, $03, $b0, $fd
'-'                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$01, $86, $8f, $f1
'-'         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
	byte	$f0, $fb, $9f, $ad
'-'                 call    #reset                          ' Try another reset to see if the device responds
	byte	$a4, $fb, $bf, $fd
'-'                 jmp     #.retry
	byte	$b8, $ff, $9f, $fd
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 mov     hctwait, _1ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
	byte	$28, $03, $b0, $fd
'-'                 call    #reset
	byte	$88, $fb, $bf, $fd
'-'                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
	byte	$38, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
	byte	$01, $11, $5c, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$d8, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ad, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$04, $03, $b0, $fd
'-'                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
	byte	$04, $00, $00, $ff, $00, $bc, $06, $f6
'-'                 call    #calc_crc5
	byte	$34, $fa, $bf, $fd
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
	byte	$20, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$78, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
	byte	$07, $db, $c6, $fa
'-'                 mov     hctwait, _500us_
	byte	$a0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $02, $b0, $fd
'-'                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$28, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$48, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $87, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $89, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $73, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $86, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $88, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $73, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #host_error
	byte	$2c, $fb, $9f, $cd
'-'                 loc     pa, #@init_kbdm_data - @usb_host_start
	byte	$24, $13, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-'                 loc     pa, #@hparse_con_desc - @usb_host_start
	byte	$b8, $0d, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 jmp     pa
	byte	$2c, $ec, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
'-' ' Status reporting is always in the function-to-host direction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data in hub.
'-' '   PB - start address of the buffer/struct to be written to during the IN data
'-' '     stage.
'-' '   ep_addr_pid - device address, endpoint and CRC5.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'-' '     contains the count of data stage bytes actually received, which must
'-' '     always be <= the count requested.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_read
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8f, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $91, $03, $f6
'-'                 mov     hpar3, pb                       ' Save dest buffer pointer
	byte	$f7, $93, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$c0, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to caller to handle error
	byte	$2d, $00, $64, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$90, $01, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 mov     nak_retry, ##IN_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
	byte	$55, $b1, $02, $16
'-' .nak_retry
'-'                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
	byte	$0c, $a2, $06, $f6
'-' .in_retry
'-'                 call    #txn_in
	byte	$bc, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$28, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$a8, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$14, $02, $b0, $fd
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak_retry                     ' Function not ready to send data
	byte	$dc, $ff, $9f, $ad
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$94, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.in_retry                      ' Bus error retry
	byte	$d0, $ff, $9f, $5d
'-'                 ret                                     ' The transfer has failed
	byte	$2d, $00, $64, $fd
'-' .commit
'-'                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.pre_status                    ' and also end-of-data
	byte	$38, $00, $90, $ad
'-'                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
	byte	$27, $f1, $03, $f6
'-'                 mov     hr0, pkt_cnt
	byte	$5c, $87, $03, $f6
'-'                 cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $f2
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$6c, $fa, $bf, $5d
'-'                 add     stage_data, pkt_cnt             ' Update bytes received on commit
	byte	$5c, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
	byte	$56, $af, $0a, $f2
'-'         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
	byte	$1c, $00, $90, $ad
'-'                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
	byte	$58, $b9, $1a, $f2
'-'         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
	byte	$14, $00, $90, $cd
'-'         if_a    mov     retval, #ERR_PACKET
	byte	$04, $be, $06, $16
'-'         if_a    mov     context_retval, retval          ' In this case overall and context are the same
	byte	$5f, $c1, $02, $16
'-'         if_a    ret                                     ' Caller must handle ERR_PACKET
	byte	$2d, $00, $64, $1d
'-'                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $f4
'-'                 jmp     #.data                          ' Start next IN transaction
	byte	$78, $ff, $9f, $fd
'-' .pre_status
'-'                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
	byte	$57, $ad, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $f8
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-'                 mov     nak_retry, ##OUT_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-' .out_retry
'-'                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
	byte	$34, $f7, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret                                     ' All is good when ACK
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$18, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$84, $01, $b0, $fd
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
	byte	$d8, $ff, $9f, $5d
'-'                 ret                                     ' Caller must handle transfer retirement
	byte	$2d, $00, $64, $fd
'-' ' I've encountered transfer STALL, even though the data looks correct, and
'-' ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
'-' ' ControlRead() transfer gets things unstuck most of the time...
'-' .xfer_retry
'-'                 mov     hctwait, _xfer_wait_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$58, $01, $b0, $fd
'-'                 call    #wait_txn_ok
	byte	$8c, $f9, $bf, $fd
'-'                 mov     ep_addr_pid, hpar1
	byte	$c7, $bd, $02, $f6
'-'                 mov     ptra, hpar2
	byte	$c8, $f1, $03, $f6
'-'                 mov     pb, hpar3
	byte	$c9, $ef, $03, $f6
'-'                 djnz    xfer_retry, #.xfer_start
	byte	$bb, $a1, $6e, $fb
'-'                 mov     context_retval, retval          ' Preserve the USB error code
	byte	$5f, $c1, $02, $f6
'-'         _ret_   mov     retval, #ERR_XFER_RETRY
	byte	$07, $be, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
'-' ' reporting is always in the function-to-host direction. It is assumed that
'-' ' the SETUP data struct is filled with the required values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - points to the start of the struct for the SETUP data.
'-' '   PB - the start address of the struct/buffer to be read for the OUT data
'-' '     stage.
'-' '   ep_addr_pid - the proper CRC'd address and endpoint to use.
'-' ' On exit:
'-' '   retval - used to convey the success/failure of each stage.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_write
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $27, $c4
'-' 
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8f, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $91, $03, $f6
'-'                 mov     hpar3, pb
	byte	$f7, $93, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
	byte	$00, $9e, $06, $f6
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$84, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
	byte	$ec, $00, $90, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$54, $00, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
	byte	$e1, $bc, $c6, $f8
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
	byte	$55, $b1, $02, $16
'-' .out_retry
'-'                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
	byte	$f7, $f1, $03, $f6
'-'                 call    #txn_out
	byte	$88, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit                        ' Function got the data
	byte	$10, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$e0, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry
	byte	$e4, $ff, $9f, $5d
'-'                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
	byte	$a4, $00, $90, $fd
'-' .commit
'-'                 mov     pb, ptra                        ' Save the current buffer/struct location
	byte	$f8, $ef, $03, $f6
'-'                 add     stage_data, pkt_data
	byte	$58, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz
	byte	$56, $af, $0a, $f2
'-'         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $54
'-'         if_nz   jmp     #.data                          ' More data to send
	byte	$bc, $ff, $9f, $5d
'-' pre_status_in
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .status_retry
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 call    #txn_in
	byte	$44, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
	byte	$d2, $be, $0e, $f2
'-'         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
	byte	$00, $b0, $0e, $a2
'-'         if_z    jmp     #dwnstream_reset                ' Control Write finished
	byte	$74, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait                     ' NAK or bus error, so delay a bit
	byte	$98, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.status_retry
	byte	$d8, $ff, $9f, $5d
'-' '               ret                                     ' Caller must handle transfer retirement
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - The function address and endpoint for the IN request.
'-' '   hpar2 - Address of the IN data buffer
'-' '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
'-' ' On exit:
'-' '   retval - the result of the operation.
'-' '   hpar3 - the count of IN data bytes actually received.
'-' '------------------------------------------------------------------------------
'-' do_int_in
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $27, $c4
'-' 
'-'                 getword htmp, hpar3, #0
	byte	$c9, $73, $33, $f9
'-'                 cmp     htmp, #PID_DATA0        wz
	byte	$c3, $72, $0f, $f2
'-'                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
	byte	$03, $96, $a6, $f4
'-'                 mov     retry, #TXN_RETRIES
	byte	$0c, $a2, $06, $f6
'-' .retry
'-'                 getword pkt_data, hpar3, #1             ' IN max packet length
	byte	$c9, $b1, $3a, $f9
'-'                 call    #txn_in
	byte	$00, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK if data received
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$1c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
	byte	$5a, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.post_ret                      ' The caller must handle either
	byte	$24, $00, $90, $ad
'-'                 call    #retry_wait
	byte	$54, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    jmp     #.post_ret
	byte	$18, $00, $90, $ad
'-'                 jmp     #.retry
	byte	$d4, $ff, $9f, $fd
'-' .commit
'-'                 mov     ptra, urx_buff_p                ' Copy the rx buffer
	byte	$27, $f1, $03, $f6
'-'                 mov     pb, hpar2                       ' to the destination buffer
	byte	$c8, $ef, $03, $f6
'-'                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
	byte	$5c, $87, $0b, $f6
'-'         if_nz   cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $52
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$c0, $f8, $bf, $5d
'-' .post_ret
'-'                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
	byte	$5c, $93, $03, $f6
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Resets the downstream hub port to FS
'-' '------------------------------------------------------------------------------
'-' dwnstream_reset
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_nc   ret                                     ' No LS device, reset not needed
	byte	$2d, $00, $64, $3d
'-' 
'-'                 bitl    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $07, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6f, $13, $fc
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a6, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a4, $9b, $02, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The one millisecond frame timer is implemented as an interrupt service
'-' ' routine. Since this timing is critical, care must be taken to avoid any
'-' ' instructions that can delay the interrupt branch, which will likely upset
'-' ' the timer. WAITX is among those instructions, so any time you're inside
'-' ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hctwait - wait interval in sysclocks.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' poll_waitx
'-'                 getct   hct2
	byte	$1a, $94, $63, $fd
'-'                 addct2  hct2, hctwait
	byte	$4c, $95, $6b, $fa
'-' .wait
'-'                 jnct2   #.wait
	byte	$ff, $25, $cc, $fb
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transaction retry handling for NAK/STALL or bus error.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - transaction response PID or error code.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' retry_wait
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret                                     ' STALL is special case
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak
	byte	$14, $00, $90, $ad
'-'                 mov     hctwait, _txn_err_              ' Transaction error wait...
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$d8, $ff, $bf, $fd
'-' .dec
'-'                 sub     retry, #1               wz
	byte	$01, $a2, $8e, $f1
'-'         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
	byte	$06, $be, $06, $a6
'-'                 ret                                     ' Retry result to caller
	byte	$2d, $00, $64, $fd
'-' .nak
'-'                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
	byte	$9e, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $ff, $bf, $fd
'-'                 cmp     nak_retry, #NAK_NOLIMIT wz
	byte	$00, $9e, $0e, $f2
'-'         if_z    ret                                     ' Indefinite NAK retries
	byte	$2d, $00, $64, $ad
'-'                 sub     nak_retry, #1           wz
	byte	$01, $9e, $8e, $f1
'-'         if_z    mov     retval, #ERR_NAK
	byte	$08, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' host_reset
'-'                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
	byte	$25, $00, $64, $fd
'-'                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
	byte	$14, $72, $07, $fb
'-' ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
'-'                 cmp     htmp, ##168_000_000     wcz
	byte	$bd, $01, $05, $ff, $00, $72, $1f, $f2
'-'         if_be   mov     utx_tweak, #0
	byte	$00, $94, $06, $e6
'-'         if_a    mov     utx_tweak, #3   '#20
	byte	$03, $94, $06, $16
'-' ' Check to see if the system clock has been changed.
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $73, $0b, $f2
'-'         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $5e
'-'         if_nz   add     pb, hcog_base_addr
	byte	$47, $ef, $03, $51
'-'         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $5d
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-' 
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
	byte	$22, $6f, $13, $fc
'-' .enable
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 waitx   _1us_
	byte	$1f, $38, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 ' Handle Port protection enable and startup delay
'-'                 cmps    usb_enable_pin, #0      wc
	byte	$00, $48, $56, $f2
'-'         if_ae   drvl    usb_enable_pin                 ' disable port
	byte	$58, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Wait a while for everything to turn off
	byte	$1f, $60, $63, $fd
'-'         if_ae   drvh    usb_enable_pin                  ' Enable the port
	byte	$59, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Hold to let the idle state get settled
	byte	$1f, $60, $63, $fd
'-' 
'-'                 'call #dev_reset ' TODO THINK ABOUT THIS
'-' 
'-' discon_entry
'-'                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
	byte	$03, $98, $07, $f6
'-' 
'-'                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
	byte	$4b, $ed, $b7, $f9
'-'                 rep     @.regloop,#hreg_init_end - hreg_init_start
	byte	$3b, $04, $dc, $fc
'-'                 alti    pa, #%000_111_000
	byte	$38, $ec, $a7, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' .regloop
'-'               
'-'         if HAVE_HIDPAD
'-'                 loc     pb, #@hidpad_report - @usb_host_start
	byte	$f8, $27, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
	byte	$28, $6e, $64, $fd
'-'                 wrlong  #0,pb
	byte	$f7, $01, $68, $fc
'-'         end
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-'                 ' Fall through to disconnected loop
'-' 
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' Device connect handling (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
'-' ' device to connect (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' disconnected
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
	byte	$14, $88, $07, $fb
'-'                 cmp     hr1, save_sysclk        wz
	byte	$2c, $89, $0b, $f2
'-'         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
	byte	$6c, $ff, $9f, $5d
'-'                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
	byte	$03, $88, $47, $f0
'-'                 waitx   hr1                             ' it down to smaller wait chunks
	byte	$1f, $88, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
	byte	$e0, $ff, $9f, $ad
'-'         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
	byte	$28, $00, $90, $5d
'-' .se1_test
'-'                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$fc, $fe, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
	byte	$00, $be, $06, $56
'-'         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
	byte	$a0, $ff, $9f, $5d
'-' .se1            'SE1 is a fatal error condition
'-'                 mov     hctwait, _100ms_
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$e4, $fe, $bf, $fd
'-'                 mov     retval, #ERR_SE1
	byte	$03, $be, $06, $f6
'-'                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
	byte	$88, $f7, $bf, $fd
'-' .connect_test                                           ' Test lines until stable J/K state seen
'-'                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
	byte	$1f, $62, $63, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #discon_entry                   ' D+ and D- low
	byte	$80, $ff, $9f, $ad
'-'         if_e    jmp     #.se1_test                      ' D+ and D- high
	byte	$c4, $ff, $9f, $ad
'-' connected
'-'                 bith    hstatus, #CONNECTEDB            ' Device plugged in
	byte	$01, $96, $26, $f4
'-'                 call    #on_connect                     ' Initial device configuration
	byte	$34, $fb, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #discon_entry
	byte	$6c, $ff, $9f, $5d
'-' .set_pulse
'-'                 getct   _pulse_time_
	byte	$1a, $66, $63, $fd
'-'                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
	byte	$b2, $67, $03, $f1
'-' ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
'-' ' of 1ms and make a correction, if necessary.
'-' '                mov     htmp, _1ms_
'-' '                subs    htmp, iframe_delta
'-' '                adds    _frame1ms_clks_, htmp
'-' '                debug(udec(_frame1ms_clks_))
'-' 
'-'                 ' Fall through to idle/processing loop
'-'                 cmp     hdev_port, #MAX_DEVICES wcz
	byte	$07, $5a, $1e, $f2
'-'         if_a    mov     hdev_port, #0 
	byte	$00, $5a, $06, $16
'-' 
'-' hidle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_c    jmp     #.se0_test
	byte	$98, $00, $90, $cd
'-'                 pollct3                         wc
	byte	$24, $06, $70, $fd
'-'         if_nc   jmp     #.nopoll
	byte	$68, $00, $90, $3d
'-'                 getct   hct3
	byte	$1a, $96, $63, $fd
'-'                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
	byte	$a8, $97, $73, $fa
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $72, $e3, $f8
'-' 
'-'                 cmp     htmp, #HUB_READY        wz
	byte	$09, $72, $0f, $f2
'-'         if_z    loc     pa, #@hget_hub_status - @usb_host_start
	byte	$8c, $1b, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$40, $00, $90, $ad
'-' 
'-'         if _HAVE_GAMEPAD
'-'                 cmp     htmp, #HID_READY        wz
	byte	$06, $72, $0f, $f2
'-'         if_nz   cmp     htmp, #PS3_READY        wz
	byte	$08, $72, $0f, $52
'-'         if_nz   cmp     htmp, #XINPUT_READY     wz
	byte	$07, $72, $0f, $52
'-'         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
	byte	$f4, $15, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$2c, $00, $90, $ad
'-'         end
'-' 
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $72, $0f, $f2
'-'         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$44, $15, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$20, $00, $90, $ad
'-'         end
'-' 
'-'                 cmp     htmp, #KB_READY         wz
	byte	$03, $72, $0f, $f2
'-'         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$ac, $13, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$14, $00, $90, $ad
'-' 
'-'                 cmp     htmp, #KBM_READY        wz
	byte	$05, $72, $0f, $f2
'-'         if_nz   jmp     #.skip_poll
	byte	$14, $00, $90, $5d
'-'                 bitnot  hstatus, #KBM_TOGGLEB   wcz
	byte	$09, $96, $fe, $f4
'-'         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$ac, $13, $80, $3e
'-'         if HAVE_MOUSE
'-'         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$44, $15, $80, $ce
'-'         else
'-'         end
'-' 
'-' .poll
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-' .skip_poll
'-' 
'-'                 incmod  hdev_port, #MAX_DEVICES
	byte	$07, $5a, $06, $f7
'-' 
'-' .nopoll
'-'                 cmp     cmd_data, #CMD_SUSPEND  wz
	byte	$0e, $40, $0e, $f2
'-'         if_z    jmp     #hsuspend
	byte	$44, $00, $90, $ad
'-'                 cmp     cmd_data, #CMD_RESET    wz
	byte	$10, $40, $0e, $f2
'-'         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
	byte	$00, $40, $06, $a6
'-'         if_z    jmp     #host_reset                     ' See if it works...
	byte	$68, $fe, $9f, $ad
'-'                 getct   hr0
	byte	$1a, $86, $63, $fd
'-'                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
	byte	$b3, $87, $1b, $f2
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'         if_ae   getct   _pulse_time_
	byte	$1a, $66, $63, $3d
'-'         if_ae   add     _pulse_time_, _500ms_
	byte	$b2, $67, $03, $31
'-'                 jmp     #hidle
	byte	$5c, $ff, $9f, $fd
'-' ' Check for extended SE0 state on the bus
'-' .se0_test
'-'                 mov     hctwait, _1ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
	byte	$fc, $fd, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_nc   jmp     #hidle                          ' Bus still IDLE
	byte	$48, $ff, $9f, $3d
'-'                 call    #wait_txn_ok
	byte	$24, $f6, $bf, $fd
'-'                 wypin   ##OUT_IDLE, dm                  ' Float USB
	byte	$00, $00, $80, $ff, $22, $01, $28, $fc
'-'                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
'-'                 jmp     #discon_entry                   ' Device disconnected
	byte	$94, $fe, $9f, $fd
'-' 
'-' hsuspend
'-'                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
	byte	$14, $f6, $bf, $fd
'-'                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
	byte	$25, $00, $64, $fd
'-'                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
	byte	$1f, $54, $63, $fd
'-'                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
	byte	$22, $01, $28, $fc
'-'                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
	byte	$00, $40, $06, $f6
'-'                 mov     mod_cnt, #0
	byte	$00, $98, $07, $f6
'-' 
'-'                 ' Fall through to resume wait loop
'-' 
'-' hwait_resume
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
	byte	$14, $88, $07, $fb
'-'                 shr     hr1, #2
	byte	$02, $88, $47, $f0
'-'                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
	byte	$1f, $88, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 cmp     cmd_data, #CMD_RESUME   wz
	byte	$0f, $40, $0e, $f2
'-'         if_nz   jmp     #hwait_resume
	byte	$ec, $ff, $9f, $5d
'-'                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
	byte	$14, $72, $07, $fb
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $73, $0b, $f2
'-'         if_z    jmp     #.resume
	byte	$18, $00, $90, $ad
'-'                 loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $fd
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
	byte	$22, $6f, $13, $3c
'-'         if_c    wxpin   _usb_h_ls_nco_, dm
	byte	$22, $6b, $13, $cc
'-' .resume
'-'                 wypin   #OUT_K, dm
	byte	$22, $05, $28, $fc
'-'                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
	byte	$1f, $5e, $63, $fd
'-'                 wypin   #OUT_SE0, dm
	byte	$22, $03, $28, $fc
'-'                 mov     htmp, _ip_delay_ls_
	byte	$a3, $73, $03, $f6
'-'                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
	byte	$01, $72, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $72, $63, $fd
'-'                 wypin   #OUT_J, dm
	byte	$22, $07, $28, $fc
'-'                 shr     htmp, #1
	byte	$01, $72, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $72, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-'                 setint1 #1                              ' Enable the 1ms frame ISR
	byte	$25, $02, $64, $fd
'-'                 mov     hctwait, _4ms_
	byte	$ab, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
	byte	$50, $fd, $bf, $fd
'-'         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
	byte	$00, $40, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send preamble to enable low-speed HUB ports
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   USB baud rate set to low-speed
'-' '------------------------------------------------------------------------------
'-' utx_pre
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   #0, dm                          ' Disable smartpin mode
	byte	$22, $01, $08, $fc
'-'                 drvl    dm
	byte	$58, $44, $62, $fd
'-'                 drvh    dp
	byte	$59, $46, $62, $fd
'-' 
'-'                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
	byte	$1e, $00, $00, $ff, $80, $72, $07, $f6
'-' 
'-'                 rep     @.l1, #16 + 1
	byte	$11, $08, $dc, $fc
'-'                 shr     htmp, #1        wc
	byte	$01, $72, $57, $f0
'-'         if_nc   setq    #1
	byte	$28, $02, $64, $3d
'-'         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
	byte	$4f, $44, $62, $3d
'-'                 waitx   _preamble_wait_
	byte	$1f, $4e, $63, $fd
'-' .l1
'-' 
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
	byte	$22, $6b, $13, $fc
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $06
'-' 
'-' hlut_end
'-'                 fit     $400
'-'                 fit     $400
'-'                 orgh
'-' if OVERLAP_MEMORY
'-'                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
'-' end
'-' '------------------------------------------------------------------------------
'-' ' Routines called from cog space.
'-' '------------------------------------------------------------------------------
'-' ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'-' '------------------------------------------------------------------------------
'-' 
'-' '------------------------------------------------------------------------------
'-' ' USB host cog initialization.
'-' '------------------------------------------------------------------------------
'-' usb_host_init
'-'                 ' Initialize buffer pointers
'-'         if OVERLAP_MEMORY
'-'         else
'-'                 loc     pb, #hid_descr
	byte	$4c, $15, $b0, $fe
'-'         end
'-'                 mov     hid_descr_p, pb
	byte	$f7, $4b, $02, $f6
'-'                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
'-'                 {
'-'                 }
'-'         
'-'                 {
'-'                 }
'-'                 'loc     pb,#hkbd_report
'-'                 'mov     hkbd_report_p,pb
'-' 
'-'                 loc     pb, #hub_descr
	byte	$44, $1d, $b0, $fe
'-'                 mov     hub_descr_p, pb
	byte	$f7, $4d, $02, $f6
'-'                 loc     pb, #urx_buff
	byte	$59, $1d, $b0, $fe
'-'                 mov     urx_buff_p, pb
	byte	$f7, $4f, $02, $f6
'-'                 loc     pb, #dev_desc_buff
	byte	$d1, $1d, $b0, $fe
'-'                 mov     dev_desc_buff_p, pb
	byte	$f7, $51, $02, $f6
'-'                 loc     pb, #con_desc_buff
	byte	$db, $1d, $b0, $fe
'-'                 mov     con_desc_buff_p, pb
	byte	$f7, $53, $02, $f6
'-'                 loc     pb, #usb_cache_start
	byte	$24, $15, $b0, $fe
'-'                 mov     cache_start_p, pb
	byte	$f7, $55, $02, $f6
'-'                 loc     pb, #usb_cache_end
	byte	$25, $1d, $b0, $fe
'-'                 mov     cache_end_p, pb
	byte	$f7, $57, $02, $f6
'-' 
'-'         if ERROR_LED >= 0
'-'         end
'-' 
'-'                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
'-'                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
'-'                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
'-' ' Configure and enable the Serial Host USB port.
'-'                 jmp     #host_reset                     ' Initialize host and enter main processing loop
	byte	$03, $03, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Timing calculations happen before any interrupt(s) are enabled.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   htmp - current CLKFREQ value.
'-' '------------------------------------------------------------------------------
'-' hinit_usb_timings
'-' '                getct   htmp2
'-'                 mov     save_sysclk, htmp
	byte	$b9, $59, $02, $f6
'-'                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
	byte	$8d, $5b, $80, $ff, $2c, $01, $2a, $fd
'-'                 getqx   _12Mbps_
	byte	$18, $32, $63, $fd
'-'                 shr     _12Mbps_, #16           wc
	byte	$10, $32, $57, $f0
'-'                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
	byte	$00, $32, $27, $f1
'-'                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
	byte	$03, $6e, $07, $f6
'-'                 shl     _usb_h_fs_nco_, #14
	byte	$0e, $6e, $67, $f0
'-'                 add     _usb_h_fs_nco_, _12Mbps_
	byte	$99, $6f, $03, $f1
'-'                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
	byte	$01, $70, $07, $f6
'-'                 shl     _usb_d_fs_nco_, #14
	byte	$0e, $70, $67, $f0
'-'                 add     _usb_d_fs_nco_, _12Mbps_
	byte	$99, $71, $03, $f1
'-'                 mov     _1_5Mbps_, _12Mbps_
	byte	$99, $35, $03, $f6
'-'                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
	byte	$03, $34, $47, $f0
'-'                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
	byte	$02, $6a, $07, $f6
'-'                 shl     _usb_h_ls_nco_, #14
	byte	$0e, $6a, $67, $f0
'-'                 add     _usb_h_ls_nco_, _1_5Mbps_
	byte	$9a, $6b, $03, $f1
'-'                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
	byte	$9a, $6d, $03, $f6
'-'                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
	byte	$80, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2e, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $30, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2e, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1b
	byte	$65, $cd, $1d, $ff, $00, $30, $27, $fd
'-'                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
	byte	$18, $36, $63, $fd
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2e, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $30, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2e, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1m
	byte	$a1, $07, $00, $ff, $40, $30, $27, $fd
'-'                 getqx   _1us_                           ' 1us as 32,9 fixed point
	byte	$18, $38, $63, $fd
'-'                 mov     hsave0, _1us_                   ' Save it to compute other us values
	byte	$9c, $7d, $03, $f6
'-'                 shr     _1us_, #9               wc
	byte	$09, $38, $57, $f0
'-'                 addx    _1us_, #0                       ' Round to final value
	byte	$00, $38, $27, $f1
'-'                 qmul    hsave0, #10                     ' Calc 10us
	byte	$0a, $7c, $07, $fd
'-'                 getqx   _10us_
	byte	$18, $3a, $63, $fd
'-'                 shr     _10us_, #9              wc
	byte	$09, $3a, $57, $f0
'-'                 addx    _10us_, #0                      ' 10us
	byte	$00, $3a, $27, $f1
'-'                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
	byte	$21, $7c, $07, $fd
'-'                 getqx   _33us_
	byte	$18, $3c, $63, $fd
'-'                 shr     _33us_, #9              wc
	byte	$09, $3c, $57, $f0
'-'                 addx    _33us_, #0                      ' 33us
	byte	$00, $3c, $27, $f1
'-'                 qmul    hsave0, #250                    ' Calc 250us
	byte	$fa, $7c, $07, $fd
'-'                 getqx   _txn_err_
	byte	$18, $3e, $63, $fd
'-'                 shr     _txn_err_, #9           wc
	byte	$09, $3e, $57, $f0
'-'                 addx    _txn_err_, #0                   ' 250us
	byte	$00, $3e, $27, $f1
'-'                 qmul    hsave0, #500                    ' Calc 500us
	byte	$f4, $7d, $07, $fd
'-'                 getqx   _500us_
	byte	$18, $40, $63, $fd
'-'                 shr     _500us_, #9             wc
	byte	$09, $40, $57, $f0
'-'                 addx    _500us_, #0                     ' 500us
	byte	$00, $40, $27, $f1
'-'                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
	byte	$01, $00, $00, $ff, $9a, $7c, $07, $fd
'-'                 getqx   _txn_ok_ls_
	byte	$18, $42, $63, $fd
'-'                 shr     _txn_ok_ls_, #9         wc
	byte	$09, $42, $57, $f0
'-'                 addx    _txn_ok_ls_, #0                 ' 666us
	byte	$00, $42, $27, $f1
'-'                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
	byte	$01, $00, $00, $ff, $52, $7d, $07, $fd
'-'                 getqx   _txn_ok_fs_
	byte	$18, $44, $63, $fd
'-'                 shr     _txn_ok_fs_, #9         wc
	byte	$09, $44, $57, $f0
'-'                 addx    _txn_ok_fs_, #0                 ' 850us
	byte	$00, $44, $27, $f1
'-'                 mov     _ip_delay_ls_, _1ns16fp_
	byte	$9b, $47, $03, $f6
'-'                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
	byte	$05, $00, $00, $ff, $80, $46, $07, $fa
'-'                 shr     _ip_delay_ls_, #16      wc
	byte	$10, $46, $57, $f0
'-'                 addx    _ip_delay_ls_, #0
	byte	$00, $46, $27, $f1
'-'                 mov     _tat_wait_ls_, _1ns16fp_
	byte	$9b, $4b, $03, $f6
'-'                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
	byte	$1c, $00, $00, $ff, $c0, $4b, $07, $fa
'-'                 shr     _tat_wait_ls_, #16      wc
	byte	$10, $4a, $57, $f0
'-'                 addx    _tat_wait_ls_, #0
	byte	$00, $4a, $27, $f1
'-'                 mov     _ip_delay_fs_, _1ns16fp_
	byte	$9b, $49, $03, $f6
'-'                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
	byte	$00, $00, $00, $ff, $4e, $49, $07, $fa
'-'                 shr     _ip_delay_fs_, #16      wc
	byte	$10, $48, $57, $f0
'-'                 addx    _ip_delay_fs_, #0
	byte	$00, $48, $27, $f1
'-'                 mov     _tat_wait_fs_, _1ns16fp_
	byte	$9b, $4d, $03, $f6
'-'                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
	byte	$04, $00, $00, $ff, $23, $4d, $07, $fa
'-'                 shr     _tat_wait_fs_, #16      wc
	byte	$10, $4c, $57, $f0
'-'                 addx    _tat_wait_fs_, #0
	byte	$00, $4c, $27, $f1
'-'                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
	byte	$8d, $5b, $00, $ff, $00, $59, $16, $fd
'-'                 getqx   _preamble_wait_
	byte	$18, $4e, $63, $fd
'-'                 sub     _preamble_wait_,# 9 - 1
	byte	$08, $4e, $87, $f1
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2e, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $30, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2e, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1thou
	byte	$01, $00, $00, $ff, $e8, $31, $27, $fd
'-'                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
	byte	$18, $50, $63, $fd
'-'                 shr     _1ms_, #9               wc
	byte	$09, $50, $57, $f0
'-'                 addx    _1ms_, #0                       ' 1ms
	byte	$00, $50, $27, $f1
'-'                 mov     _frame1ms_clks_, ##-14
	byte	$ff, $ff, $7f, $ff, $f2, $69, $07, $f6
'-'                 adds    _frame1ms_clks_, _1ms_
	byte	$a8, $69, $43, $f1
'-'                 mov     _2ms_, _1ms_
	byte	$a8, $53, $03, $f6
'-'                 shl     _2ms_, #1                       ' 2ms
	byte	$01, $52, $67, $f0
'-'                 mov     _suspend_wait_, _1ms_
	byte	$a8, $55, $03, $f6
'-'                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
	byte	$a8, $55, $03, $f1
'-'                 mov     _4ms_, _1ms_
	byte	$a8, $57, $03, $f6
'-'                 shl     _4ms_, #2                       ' 4ms
	byte	$02, $56, $67, $f0
'-'                 mov     _xfer_wait_, _4ms_
	byte	$ab, $59, $03, $f6
'-'                 add     _xfer_wait_, _1ms_              ' 5ms
	byte	$a8, $59, $03, $f1
'-'                 mov     _reset_hold_, _xfer_wait_       ' 5ms
	byte	$ac, $5d, $03, $f6
'-'                 mov     _resume_hold_, _reset_hold_
	byte	$ae, $5f, $03, $f6
'-'                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
	byte	$02, $5e, $67, $f0
'-'                 mov     _100ms_, _resume_hold_          ' 20ms
	byte	$af, $63, $03, $f6
'-'                 shl     _100ms_, #1                     ' 40ms
	byte	$01, $62, $67, $f0
'-'                 mov     _8ms_, _1ms_
	byte	$a8, $5b, $03, $f6
'-'                 shl     _8ms_, #3                       ' 8ms
	byte	$03, $5a, $67, $f0
'-'                 shl     _reset_hold_, #1                ' 10ms
	byte	$01, $5c, $67, $f0
'-'                 add     _100ms_, _reset_hold_           ' 50ms
	byte	$ae, $63, $03, $f1
'-'                 add     _reset_hold_, _xfer_wait_       ' 15ms
	byte	$ac, $5d, $03, $f1
'-'                 mov     _21ms_, _xfer_wait_             ' 5ms
	byte	$ac, $61, $03, $f6
'-'                 shl     _21ms_, #2                      ' 20ms
	byte	$02, $60, $67, $f0
'-'                 add     _21ms_, _1ms_                   ' 21ms
	byte	$a8, $61, $03, $f1
'-'                 mov     _500ms_, _100ms_                ' 50ms
	byte	$b1, $65, $03, $f6
'-'                 shl     _100ms_, #1                     ' 100ms
	byte	$01, $62, $67, $f0
'-'                 shl     _500ms_, #3                     ' 400ms
	byte	$03, $64, $67, $f0
'-'         _ret_   add     _500ms_, _100ms_                ' 500ms
	byte	$b1, $65, $03, $01
'-' '        _ret_   mov     _1sec_, save_sysclk
'-' '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'-' '                ret
'-' {
'-' }
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Parse a configuration descriptor chain to see if the device is a recognized
'-' ' one. If it is, start the task progression that will configure the device for
'-' ' use.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hconfig_base - start address of the cached config descriptor chain.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hparse_con_desc
'-'                 mov     ptrb, dev_desc_buff_p
	byte	$28, $f3, $03, $f6
'-'                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
	byte	$82, $73, $07, $fb
'-'                 altr    hdev_port,#hdev_id
	byte	$61, $5b, $86, $f9
'-'                 movbyts htmp,#%%1032
	byte	$4e, $72, $ff, $f9
'-'                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
	byte	$86, $d3, $e6, $fa
'-'                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
'-' 
'-'                 mov     pa, #CON_wTotalLen
	byte	$02, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
	byte	$f6, $df, $e2, $fa
'-'                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
'-' ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
'-' ' that defines a keyboard and/or mouse.
'-'                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
	byte	$6e, $eb, $c2, $fa
'-' .next_intf
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #hset_config
	byte	$b8, $01, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $73, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $72, $0f, $f2
'-'         if_z    jmp     #.intf
	byte	$0c, $00, $90, $ad
'-'                 rdbyte  htmp, ptrb
	byte	$80, $73, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b9, $eb, $02, $f1
'-'                 jmp     #.next_intf
	byte	$d8, $ff, $9f, $fd
'-' .intf
'-'                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
	byte	$00, $90, $07, $f6
'-'                 mov     hpar3, #0
	byte	$00, $92, $07, $f6
'-'                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
	byte	$82, $e1, $c6, $fa
'-'                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
	byte	$85, $e3, $c6, $fa
'-'                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
	byte	$86, $e5, $c6, $fa
'-'                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
	byte	$87, $e7, $c6, $fa
'-'                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
'-' 
'-' .endp
'-'                 rdbyte  htmp, ptrb
	byte	$80, $73, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b9, $eb, $02, $f1
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #.get_device
	byte	$78, $00, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $73, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $72, $0f, $f2
'-'         if_z    jmp     #.get_device
	byte	$64, $00, $90, $ad
'-'                 cmp     htmp, #TYPE_ENDPOINT    wz
	byte	$05, $72, $0f, $f2
'-'         if_z    jmp     #.get_ep
	byte	$04, $00, $90, $ad
'-'                 jmp     #.endp
	byte	$d0, $ff, $9f, $fd
'-' .get_ep
'-'                 rdbyte  hr1, ptrb[ENDP_bAddress]
	byte	$82, $89, $c7, $fa
'-'                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
	byte	$07, $88, $17, $f4
'-'                 shl     hr1, #8 + 7
	byte	$0f, $88, $67, $f0
'-'                 mov     htmp, hctrl_ep_addr
	byte	$6c, $73, $03, $f6
'-'                 and     htmp, ##ADDR_MASK
	byte	$3f, $00, $00, $ff, $00, $73, $07, $f5
'-'                 or      htmp, hr1                       ' endpoint address
	byte	$c4, $73, $43, $f5
'-'                 cmp     hpar2, #0               wz
	byte	$00, $90, $0f, $f2
'-'  if_z_and_c     jmp     #.in_ep
	byte	$0c, $00, $90, $8d
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'  if_z_and_nc    jmp     #.out_ep
	byte	$18, $00, $90, $2d
'-'                 jmp     #.endp
	byte	$a0, $ff, $9f, $fd
'-' .in_ep
'-'                 mov     hpar2, htmp                     ' IN endpoint
	byte	$b9, $91, $03, $f6
'-'                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8b, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $87, $c7, $fa
'-'                 setbyte hr2, hr0, #3
	byte	$c3, $8b, $db, $f8
'-'                 jmp     #.endp
	byte	$8c, $ff, $9f, $fd
'-' .out_ep
'-'                 mov     hpar3, htmp                     ' OUT endpoint
	byte	$b9, $93, $03, $f6
'-'                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8d, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $87, $c7, $fa
'-'                 setbyte hr3, hr0, #3
	byte	$c3, $8d, $db, $f8
'-'                 jmp     #.endp
	byte	$78, $ff, $9f, $fd
'-' 
'-' .get_device
'-'                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
	byte	$ff, $e2, $0e, $f2
'-'         if_z    cmp     hdev_subclass, #$5D     wz
	byte	$5d, $e4, $0e, $a2
'-'         if_z    cmp     hdev_protocol, #$01     wz
	byte	$01, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$64, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HUB  wz
	byte	$09, $e2, $0e, $f2
'-'         if_z    jmp     #.hub
	byte	$a8, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HID              wz
	byte	$03, $e2, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No HID class, ignore
	byte	$18, $ff, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_z    jmp     #.gamepad
	byte	$4c, $00, $90, $ad
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
	byte	$01, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
	byte	$08, $ff, $9f, $5d
'-' .keyboard
'-'                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
	byte	$01, $e6, $0e, $f2
'-'         if HAVE_MOUSE
'-'         if_nz  jmp      #.mouse                         ' No Keyboard
	byte	$1c, $00, $90, $5d
'-'         else
'-'         end
'-'                 cmp     hkbd_ep_addr, #0    wz
	byte	$00, $f2, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$f8, $fe, $9f, $5d
'-'                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6f, $e2, $f8
'-'                 getbyte kb_interval, hr2, #3
	byte	$c5, $71, $fa, $f8
'-'                 getbyte kb_in_max_pkt, hr2, #0
	byte	$c5, $73, $e2, $f8
'-'                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
	byte	$c8, $f3, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$e4, $fe, $9f, $fd
'-' if HAVE_MOUSE
'-' .mouse
'-'                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
	byte	$02, $e6, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No Mouse
	byte	$dc, $fe, $9f, $5d
'-'                 cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$d4, $fe, $9f, $5d
'-'                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6b, $e2, $f8
'-'                 'getbyte ms_interval, hr2, #3
'-'                 getbyte ms_in_max_pkt, hr2, #0
	byte	$c5, $6d, $e2, $f8
'-'                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
	byte	$c8, $f5, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$c4, $fe, $9f, $fd
'-' end
'-' .gamepad
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $73, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c8, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$b0, $fe, $9f, $ad
'-'         if HAVE_MOUSE
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $73, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c8, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$9c, $fe, $9f, $ad
'-'         end
'-'                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz      ' |
	byte	$00, $00, $0c, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$90, $fe, $9f, $5d
'-' 
'-'                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $79, $e2, $f8
'-'                 getbyte gp_interval, hr2, #3
	byte	$c5, $7b, $fa, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, hpar2                      ' IN endpoint address
	byte	$c8, $01, $00, $f6
'-'                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
	byte	$c9, $0b, $03, $f6
'-'                 'debug(udec(gp_intf_num))
'-'                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
'-'                 jmp     #.next_intf
	byte	$78, $fe, $9f, $fd
'-' .hub
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$70, $fe, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_nz   cmp     hdev_protocol, #2                   wz
	byte	$02, $e6, $0e, $52
'-'         if_nz   jmp     #.next_intf
	byte	$64, $fe, $9f, $5d
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$5c, $fe, $9f, $5d
'-'                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
	byte	$70, $63, $e2, $f8
'-'                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $ed, $02, $f6
'-'                 mov     ep_addr_pid, hpar2              ' IN endpoint address
	byte	$c8, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 mov     hhub_ep_addr, ep_addr_pid
	byte	$5e, $ef, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
	byte	$6c, $bd, $02, $f6
'-'                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
'-'                 jmp     #.next_intf
	byte	$40, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' If a newly-connected device is recognized, do whatever is needed to configure
'-' ' it according to its function, or functions. In the case of this boot protocol
'-' ' keyboard/mouse class driver:
'-' ' - SetConfiguration(config_num)
'-' ' - SetProtocol(boot)
'-' ' - SetIdle(indefinite)
'-' ' - Enter the device interrupt IN polling task stage.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_config
'-' '                mov     hkbd_ep_addr, #0                ' DEBUG
'-' '                mov     hmouse_ep_addr, #0              ' DEBUG
'-'                 mov     htmp2, #DEV_UNKNOWN
	byte	$02, $76, $07, $f6
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $a2
'-'         if HAVE_MOUSE
'-'         if_z    cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $a2
'-'         end
'-'         if_z    cmp     hhub_ep_addr, #0        wz
	byte	$00, $ee, $0e, $a2
'-'         if_z    jmp     #.notify_client                 ' No known device
	byte	$60, $03, $90, $ad
'-' .set_config
'-'                 loc     ptra, #set_config
	byte	$74, $0e, $d0, $fe
'-'                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
	byte	$05, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdbyte  hpar1, pa
	byte	$f6, $8f, $c3, $fa
'-'                 debug("SetConfiguration: ",udec_(hpar1))
'-'                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
	byte	$01, $8f, $57, $fc
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
	byte	$6c, $bd, $02, $f6
'-'                 mov     pb, #0                          ' SetConfiguration() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-' .kbd_config
'-'                 cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $f2
'-'         if_z    jmp     #.mouse_config                  ' No keyboard
	byte	$98, $00, $90, $ad
'-' 
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $73, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.mouse_config                  ' No keyboard
	byte	$84, $00, $90, $5d
'-' 
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $73, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$3c, $0e, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$f8, $02, $90, $5d
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8e, $07, $f6
'-'                 getbyte hpar2, kb_intf_num, #0
	byte	$37, $91, $e3, $f8
'-'                 call    #hset_idle
	byte	$44, $03, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hkbd_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 mov     hctwait, _2ms_
	byte	$a9, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
	byte	$00, $76, $06, $f6
'-'         if NUMLOCK_DEFAULT_STATE && RPI_KEYBOARD_NUMLOCK_HACK
'-'         end
'-'                 mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $f6
'-'                 loc     pa, #hkbd_led_rep
	byte	$a0, $17, $90, $fe
'-'                 wrbyte  hkbd_ledstates,pa
	byte	$f6, $f9, $42, $fc
'-'                 call    #hset_kbdled_report
	byte	$40, $03, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$c4, $02, $90, $5d
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hkbd_ep_addr, ep_addr_pid
	byte	$5e, $f3, $02, $f6
'-'                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $f1, $02, $f6
'-'                 bitc    hkbd_ctrl_ep, #31
	byte	$1f, $f0, $46, $f4
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
	byte	$00, $f6, $06, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $c6, $f8
'-'                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
	byte	$03, $76, $07, $f6
'-'         if !!HAVE_MOUSE
'-'         end
'-' 
'-' .mouse_config
'-' if HAVE_MOUSE
'-'                 cmp     hmouse_ep_addr, #0        wz
	byte	$00, $f4, $0e, $f2
'-'         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$ac, $00, $90, $ad
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $73, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$98, $00, $90, $5d
'-' 
'-'                 debug("mouse passed addr check")
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$b8, $0d, $d0, $fe
'-'                 wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $ff, $03, $01, $5e, $fc
'-'                 wrword  ms_intf_num,ptra[wIndex]
	byte	$02, $6b, $56, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$58, $02, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),uhex_byte_array(pb,total_data))
'-' 
'-'                 getbyte htmp, ms_intf_num, #0
	byte	$35, $73, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$6c, $0d, $d0, $fe
'-'                 wrword  #MOUSE_FULL_PROTOCOL ? REPORT_PROTOCOL : BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $03, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$28, $02, $90, $5d
'-'                 debug("mouse passed SetProtocol")
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8e, $07, $f6
'-'                 getbyte hpar2, ms_intf_num, #0
	byte	$35, $91, $e3, $f8
'-'                 call    #hset_idle
	byte	$74, $02, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hmouse_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 debug("mouse passed SetIdle")
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hmouse_ep_addr, ep_addr_pid
	byte	$5e, $f5, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $ce, $f8
'-'                 mov     htmp2, hkbd_ep_addr
	byte	$79, $77, $03, $f6
'-'                 xor     htmp2, hmouse_ep_addr
	byte	$7a, $77, $63, $f5
'-'                 and     htmp2, ##ADDR_MASK              wz
	byte	$3f, $00, $00, $ff, $00, $77, $0f, $f5
'-'         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
	byte	$05, $76, $07, $a6
'-'         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
	byte	$04, $76, $07, $56
'-'                 jmp     #.notify_client
	byte	$e4, $01, $90, $fd
'-' end
'-' .gamepad_config
'-' if _HAVE_GAMEPAD
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    jmp     #.hub_config                    ' No gamepad
	byte	$6c, $01, $90, $ad
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     htmp, 0-0
	byte	$00, $72, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.hub_config                    ' No gamepad
	byte	$54, $01, $90, $5d
'-' 
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, ep_addr_pid
	byte	$5e, $01, $00, $f6
'-'                 mov     ep_addr_pid, hdev_out_addr  wz
	byte	$85, $bd, $0a, $f6
'-'         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $58
'-'         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $5d
'-'         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $54
'-'         if_nz   bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $54
'-'         if_nz   mov     hdev_out_addr, ep_addr_pid
	byte	$5e, $0b, $03, $56
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 if EMUPAD_MAX_PLAYER > 0
'-'                 
'-' .rule_loop           
'-'                 end
'-' 
'-'                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
	byte	$ff, $e2, $0e, $f2
'-'         if_e    jmp     #.xinput
	byte	$5c, $00, $90, $ad
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     htmp,0-0
	byte	$00, $72, $03, $f6
'-'                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
	byte	$01, $a6, $02, $ff, $68, $72, $0f, $f2
'-'         if_e    jmp     #.ps3
	byte	$8c, $00, $90, $ad
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$a4, $0c, $d0, $fe
'-'                 cmp     hdev_port,#0            wz
	byte	$00, $5a, $0e, $f2
'-'         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $5f, $03, $01, $5e, $5c
'-'         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
	byte	$03, $00, $80, $af, $03, $01, $5e, $ac
'-'                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
	byte	$02, $01, $5c, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $01, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),udec(total_data),uhex_byte_array(pb,total_data))
'-' 
'-'                 mov     htmp2, #HID_READY               ' Standard gamepad
	byte	$06, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$20, $01, $90, $fd
'-' .xinput
'-'                 loc     ptra, #xinp_led_cmd             ' Turn on LED
	byte	$b8, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb,#1 ' root device is also player 1
	byte	$01, $ee, $e7, $f2
'-'                 fle     pb,#3
	byte	$03, $ee, $27, $f3
'-'                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
	byte	$06, $ee, $07, $f1
'-'                 wrbyte  pb, ptra[2]
	byte	$02, $ef, $47, $fc
'-' 
'-'                 mov     pkt_data, #3
	byte	$03, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB
	byte	$03, $96, $06, $f4
'-'                 mov     ep_addr_pid, hdev_out_addr
	byte	$85, $bd, $02, $f6
'-'                 debug("XInput LED set ",uhex_long(ep_addr_pid),uhex_byte(pb))
'-'                 call    #txn_out
	byte	$5a, $00, $a0, $fd
'-'                 mov     ep_addr_pid, hctrl_ep_addr
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 loc     ptra, #xinp_fix_8bitdo
	byte	$97, $0c, $d0, $fe
'-'                 mov     pb, urx_buff_p          ' We don't actually care where it goes
	byte	$27, $ef, $03, $f6
'-'                 call    #control_read           ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 debug("8bitdo weird fix... ",uhex(retval))
'-'                 mov retval,#PID_ACK             ' If we don't do this something else becomes sad (TODO fix?)
	byte	$d2, $be, $06, $f6
'-' 
'-' 
'-'                 mov     htmp2, #XINPUT_READY
	byte	$07, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$dc, $00, $90, $fd
'-' .ps3
'-'                 loc     ptra, #ps3_command_buff         ' Turn on LED
	byte	$44, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 fge     pb,#1 ' root device is also player 1
	byte	$01, $ee, $07, $f3
'-'                 fle     pb,#4
	byte	$04, $ee, $27, $f3
'-'                 decod   pb
	byte	$f7, $ef, $c3, $f9
'-'                 wrbyte  pb, ptra[9]
	byte	$09, $ef, $47, $fc
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $73, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$f4, $0b, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $03, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 wrword  #48, ptra[wLength]
	byte	$03, $61, $5c, $fc
'-'                 loc     pb, #ps3_command_buff
	byte	$14, $0c, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $73, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$d4, $0b, $d0, $fe
'-'                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $e9, $5f, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 wrword  #4, ptra[wLength]
	byte	$03, $09, $5c, $fc
'-'                 loc     pb, #ps3_enable_cmd             ' Enable PS3
	byte	$f0, $0b, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK    wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$74, $00, $90, $5d
'-' 
'-'                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
	byte	$08, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$6c, $00, $90, $fd
'-' end
'-' 
'-' .hub_config
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_z    jmp     #.notify_client                 ' No HUB
	byte	$64, $00, $90, $ad
'-'                 mov     htmp, hhub_ep_addr
	byte	$77, $73, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.notify_client                 ' No HUB
	byte	$50, $00, $90, $5d
'-' 
'-'                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
	byte	$94, $0b, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, hub_descr_p
	byte	$26, $ef, $03, $f6
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hhub_ep_addr, #0
	byte	$00, $ee, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $00, $90, $5d
'-'                 debug(uhex_byte_array(hub_descr_p,total_data))
'-' 
'-'                 mov     ptra, hub_descr_p
	byte	$26, $f1, $03, $f6
'-'                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
	byte	$02, $79, $c7, $fa
'-'                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
	byte	$07, $78, $27, $f3
'-'                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
'-' .pwr_loop
'-'                 loc     ptra, #set_port_feat            ' Power on ports
	byte	$74, $0b, $d0, $fe
'-'                 wrword  #HUB_PORT_POWER, ptra[wValue]
	byte	$01, $11, $5c, $fc
'-'                 wrword  htmp3, ptra[wIndex]
	byte	$02, $79, $57, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 djnz    htmp3, #.pwr_loop
	byte	$fb, $79, $6f, $fb
'-' 
'-'                 mov     hctwait, _500ms_
	byte	$b2, $99, $02, $f6
'-'                 add     hctwait, _100ms_
	byte	$b1, $99, $02, $f1
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 mov     htmp2, #HUB_READY               ' Hub ready
	byte	$09, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$00, $00, $90, $fd
'-' 
'-' .notify_client
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte htmp2                           ' Save device ready
	byte	$bb, $01, $c0, $f8
'-'                 debug(uhex_long(hdev_type,hdev_type+1))
'-'         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Initialize the keyboard/mouse data area to start-up values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' init_kbdm_data
'-'                 mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $f6
'-'                 mov     hdev_ep_addr, #0
	byte	$00, $fa, $06, $f6
'-' 
'-'                 mov     ptra, cache_start_p         ' Clear cached data buffers
	byte	$2a, $f1, $03, $f6
'-'                 mov     pa, cache_end_p
	byte	$2b, $ed, $03, $f6
'-' .loop
'-'                 wrbyte  #0, ptra++
	byte	$61, $01, $4c, $fc
'-'                 cmp     ptra, pa                wcz
	byte	$f6, $f1, $1b, $f2
'-'         if_b    jmp     #.loop
	byte	$f4, $ff, $9f, $cd
'-'         
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' 
'-'                 mov     pa, #hdev_init_start        ' Clear device data registers
	byte	$2d, $ed, $07, $f6
'-' .regloop
'-'                 altd    pa
	byte	$00, $ec, $8f, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-'                 add     pa, #1
	byte	$01, $ec, $07, $f1
'-'                 cmp     pa, #hdev_init_end      wz
	byte	$47, $ed, $0f, $f2
'-'         if_nz   jmp     #.regloop
	byte	$ec, $ff, $9f, $5d
'-' 
'-'                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
	byte	$e1, $e1, $61, $ff, $c3, $5d, $06, $f6
'-'                 mov     hdev_next_datax + 1,hdev_next_datax
	byte	$2e, $5f, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0
	byte	$c3, $60, $c6, $f8
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1
	byte	$c3, $60, $ce, $f8
'-' 
'-'         _ret_   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
'-' ' function.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'-' '   hpar2 - index number of the target interface.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_idle
'-'                 mov     hctwait, _2ms_
	byte	$a9, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #set_idle
	byte	$cc, $0a, $d0, $fe
'-'                 wrword  hpar1, ptra[wValue]
	byte	$01, $8f, $57, $fc
'-'                 wrword  hpar2, ptra[wIndex]
	byte	$02, $91, $57, $fc
'-'                 jmp     #control_write
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
'-' ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - device address and enpoint for the request.
'-' ' On exit:
'-' '   retval - transaction result.
'-' '------------------------------------------------------------------------------
'-' hset_kbdled_report
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $73, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$c0, $0a, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
	byte	$01, $00, $80, $ff, $01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
	byte	$03, $03, $5c, $fc
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrbyte  kb_led_states, pb
	byte	$f7, $77, $42, $fc
'-'                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for keyboard activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_kbd_in_report
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #0
	byte	$30, $93, $e3, $f8
'-'                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
	byte	$39, $93, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
	byte	$30, $73, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $72, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
	byte	$4b, $60, $c6, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
	byte	$c3, $60, $c6, $58
'-' 
'-'                 mov     kb_max_index, hpar3             ' Save actual bytes read
	byte	$c9, $75, $02, $f6
'-'                 call    #hkbd_compare
	byte	$18, $00, $b0, $fd
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' .led_check
'-'                 mov     htmp, kb_led_states
	byte	$3b, $73, $03, $f6
'-'                 cmp     hkbd_ledstates, htmp    wz
	byte	$b9, $f9, $0a, $f2
'-'         if_z    ret                                     ' No toggle key indicator changes, so we're done
	byte	$2d, $00, $64, $ad
'-'                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
	byte	$7c, $77, $02, $f6
'-'                 mov     ep_addr_pid, hkbd_ctrl_ep
	byte	$78, $bd, $02, $f6
'-'                 jmp     #hset_kbdled_report             ' Set report and ignore errors
	byte	$88, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Compare current and previous keyboard data buffers for keypress changes.
'-' '------------------------------------------------------------------------------
'-' hkbd_compare
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$d0, $13, $f0, $fe
'-'                 rdlong  htmp1, ptra++
	byte	$61, $75, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $77, $07, $fb
'-'                 cmp     htmp1, htmp2    wz
	byte	$bb, $75, $0b, $f2
'-'                 rdlong  htmp1, ptra++
	byte	$61, $75, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $77, $07, $fb
'-'         if_z    cmp     htmp1, htmp2    wz
	byte	$bb, $75, $0b, $a2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-' 
'-'                 loc     ptra, #hkbd_report
	byte	$b0, $13, $d0, $fe
'-' 
'-'                 ' Handle modifiers
'-'                 rdbyte  hpar2, urx_buff_p
	byte	$27, $91, $c3, $fa
'-'                 rdbyte  hr1, ptra
	byte	$00, $89, $c7, $fa
'-'                 rolword hr1,hpar2,#0
	byte	$c8, $89, $43, $f9
'-'                 mergew  hr1
	byte	$63, $88, $63, $fd
'-'                 mov     pa,#8
	byte	$08, $ec, $07, $f6
'-' .modloop
'-'                 rczr    hr1     wcz ' New value in C, old value in Z
	byte	$6a, $88, $7b, $fd
'-'                 mov     hpar1,#$E8
	byte	$e8, $8e, $07, $f6
'-'                 sub     hpar1,pa
	byte	$f6, $8f, $83, $f1
'-'       if_c_ne_z call    #hkbd_translate
	byte	$a0, $00, $b0, $6d
'-'                 djnz    pa,#.modloop
	byte	$fb, $ed, $6f, $fb
'-' 
'-' .release        modc    _set    wc
	byte	$6f, $e0, $75, $fd
'-'                 'alts    hdev_port, #hid_report_p
'-'                 'mov     ptra, hid_report_p
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .rl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8f, $cf, $fa
'-'         if_z    jmp     #.rl3
	byte	$20, $00, $90, $ad
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .rl2            rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b9, $8f, $0b, $f2
'-'         if_z    jmp     #.rl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.rl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$68, $00, $b0, $fd
'-' .rl3            djnz    pa, #.rl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-'                 mov     hpar3, #0
	byte	$00, $92, $07, $f6
'-'                 bith    hpar3, #31
	byte	$1f, $92, $27, $f4
'-' 
'-' .press          modc    _clr    wc
	byte	$6f, $00, $74, $fd
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .pl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8f, $cf, $fa
'-'         if_z    jmp     #.pl3
	byte	$20, $00, $90, $ad
'-'                 loc     ptrb, #hkbd_report
	byte	$2c, $13, $f0, $fe
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .pl2            rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b9, $8f, $0b, $f2
'-'         if_z    jmp     #.pl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.pl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$24, $00, $b0, $fd
'-' .pl3            djnz    pa, #.pl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-' .copy           mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$04, $13, $f0, $fe
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 rdlong  htmp1, ptra++
	byte	$61, $75, $07, $fb
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 wrlong  htmp1, ptrb++
	byte	$e1, $75, $67, $fc
'-'                 wrbyte  hkbd_ledstates,ptrb++
	byte	$e1, $f9, $46, $fc
'-' 
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Translate keyboard scancode to ASCII
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - scancode
'-' '   hpar2 - key modifiers state
'-' '       c - pressed (0) or released (1) flag
'-' ' On exit:
'-' '   hpar1 - bit     31 = 0 pressed, 1 released
'-' '               30..17 = unused
'-' '                   18 = scroll-lock state 
'-' '                   17 = caps-lock state
'-' '                   16 = num-lock state 
'-' '                15..8 = key modifiers state
'-' '                 7..0 = scancode
'-' '------------------------------------------------------------------------------
'-' hkbd_translate
'-'                 cmp     hpar1, #KEY_CAPSLOCK    wz
	byte	$39, $8e, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
	byte	$01, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_NUMLOCK     wz
	byte	$53, $8e, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
	byte	$00, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_SCROLLLOCK  wz
	byte	$47, $8e, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
	byte	$02, $f8, $e6, $24
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' 
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' 
'-'         end
'-'                 setbyte hpar1, hpar2, #1
	byte	$c8, $8f, $cb, $f8
'-'                 setbyte hpar1, hkbd_ledstates,#2
	byte	$7c, $8f, $d3, $f8
'-'                 bitc    hpar1, #31
	byte	$1f, $8e, $47, $f4
'-'         if KEYQUEUE_SIZE > 0
'-'                 loc pb,#keyq_head
	byte	$c0, $09, $b0, $fe
'-'                 rdword htmp,pb
	byte	$f7, $73, $e3, $fa
'-'                 getbyte htmp1,htmp,#1 ' tail
	byte	$b9, $75, $eb, $f8
'-'                 getbyte htmp,htmp,#0 ' head
	byte	$b9, $73, $e3, $f8
'-'                 mov htmp2,htmp
	byte	$b9, $77, $03, $f6
'-'                 mul htmp2,#4
	byte	$04, $76, $07, $fa
'-'                 add htmp2,pb
	byte	$f7, $77, $03, $f1
'-'                 add htmp2,#2
	byte	$02, $76, $07, $f1
'-'                 incmod htmp,#KEYQUEUE_SIZE - 1
	byte	$7f, $72, $07, $f7
'-'                 cmp htmp1,htmp wz ' check buffer overflow
	byte	$b9, $75, $0b, $f2
'-'         if_nz   wrlong hpar1,htmp2
	byte	$bb, $8f, $63, $5c
'-'         if_nz   wrbyte htmp,pb
	byte	$f7, $73, $43, $5c
'-'         end
'-'                 ret wcz
	byte	$2d, $00, $7c, $fd
'-' 
'-' if HAVE_MOUSE
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for mouse activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_mouse_in_report
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #1
	byte	$30, $93, $eb, $f8
'-'                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
	byte	$36, $93, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
	byte	$30, $73, $eb, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $72, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
	byte	$4b, $60, $ce, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
	byte	$c3, $60, $ce, $58
'-' 
'-'         'debug(uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 call #hid_decode
	byte	$c8, $00, $b0, $fd
'-'         else
'-'         end
'-' 
'-'                 loc     pa, #mouse_limits
	byte	$48, $09, $90, $fe
'-'                 loc     ptrb, #mouse_xacc
	byte	$5d, $13, $f0, $fe
'-' 
'-'                 ' load xacc,yacc,zacc
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  hr1,ptrb
	byte	$80, $89, $07, $fb
'-'                 ' load limits and outptr
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  htmp1,pa
	byte	$f6, $75, $03, $fb
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 wrbyte  hidr_buttons, ptrb[12]
	byte	$8c, $19, $47, $fc
'-'         else
'-'                 { ' Currently not used
'-'                 '}
'-'         end
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 getword htmp, hidr_axis+0, #0
	byte	$88, $73, $33, $f9
'-'                 signx   htmp, #15
	byte	$0f, $72, $67, $f7
'-'         else
'-'         end
'-'                 add     hr1,htmp
	byte	$b9, $89, $03, $f1
'-'                 cmp     htmp1,#0 wz
	byte	$00, $74, $0f, $f2
'-'         if_ne   fles    hr1,htmp1
	byte	$ba, $89, $63, $53
'-'         if_ne   fges    hr1,#0
	byte	$00, $88, $47, $53
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 getword htmp, hidr_axis+0, #1
	byte	$88, $73, $3b, $f9
'-'                 signx   htmp, #15
	byte	$0f, $72, $67, $f7
'-'         else
'-'         end
'-'                 add     hr2,htmp
	byte	$b9, $8b, $03, $f1
'-'                 cmp     htmp2,#0 wz
	byte	$00, $76, $0f, $f2
'-'         if_ne   fles    hr2,htmp2
	byte	$bb, $8b, $63, $53
'-'         if_ne   fges    hr2,#0
	byte	$00, $8a, $47, $53
'-'                 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 getword htmp, hidr_axis+3, #1           ' Mouse wheel is actually on the "wheel axis"
	byte	$8b, $73, $3b, $f9
'-'                 signx   htmp, #15
	byte	$0f, $72, $67, $f7
'-'                 add     hr3, htmp
	byte	$b9, $8d, $03, $f1
'-'         else    
'-'         end
'-' 
'-'                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
	byte	$90, $73, $cf, $fa
'-'         if_nz   ret                                     ' If so, don't write results
	byte	$2d, $00, $64, $5d
'-' 
'-'                 ' write back accumulators
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 wrlong  hr1,ptrb
	byte	$80, $89, $67, $fc
'-'                 ' if outptr set, write X/Y words
'-'                 cmp htmp3,#0                    wz
	byte	$00, $78, $0f, $f2
'-'         if_nz   setword hr1,hr2,#1
	byte	$c5, $89, $2b, $59
'-'         if_nz   wrlong hr1,htmp3
	byte	$bc, $89, $63, $5c
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' hget_gp_in_report
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-' 
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 altgb   hdev_port, #hdev_next_datax
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte hpar3
	byte	$00, $92, $e3, $f8
'-'                 setword hpar3, #255, #1                 ' Always ask for max report size
	byte	$ff, $92, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-'                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte htmp                            ' |
	byte	$00, $72, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $72, $0f, $f2
'-'         if_z    mov     htmp, #PID_DATA1                ' |
	byte	$4b, $72, $07, $a6
'-'         if_nz   mov     htmp, #PID_DATA0                ' |
	byte	$c3, $72, $07, $56
'-'                 altsb   hdev_port, #hdev_next_datax     ' |
	byte	$2e, $5b, $66, $f9
'-'                 setbyte htmp                            ' |
	byte	$b9, $01, $c0, $f8
'-' 
'-' ' Note: the following code compares the current and previous reports
'-' ' and process the data if there are changes to ease the debug output.
'-' ' Actual implementations should remove this block, along with hid_pre_rpt_p and
'-' ' gpPreReport buffer.
'-' 
'-'                 ' ----- start of block to remove
'-'                 {
'-'                 }
'-'                 ' ----- end of block to remove
'-'                 loc pa,#hpad_translate
	byte	$14, $05, $90, $fe
'-'                 push pa
	byte	$2a, $ec, $63, $fd
'-' 
'-'                 ' FALL THROUGH !!!!
'-' end
'-' if _HAVE_GAMEPAD || MOUSE_FULL_PROTOCOL
'-' '------------------------------------------------------------------------------
'-' ' Decode controller report
'-' '------------------------------------------------------------------------------
'-' hid_decode
'-'                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
'-'                 setq #(hidr_end-hidr_start)-1
	byte	$28, $20, $64, $fd
'-'                 rdlong  hidr_start,##$8_0000
	byte	$00, $04, $00, $ff, $00, $0c, $07, $fb
'-' 
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte hidr_type
	byte	$00, $1c, $e3, $f8
'-'         if _HAVE_GAMEPAD
'-'                 cmp     hidr_type, #XINPUT_READY        wz
	byte	$07, $1c, $0f, $f2
'-'         if_z    jmp     #hpad_xinput
	byte	$08, $03, $90, $ad
'-'                 cmp     hidr_type, #PS3_READY           wz
	byte	$08, $1c, $0f, $f2
'-'         if_z    jmp     #hpad_ps3
	byte	$ec, $03, $90, $ad
'-'         end
'-'                 cmp     hidr_type, #KBM_READY           wz
	byte	$05, $1c, $0f, $f2
'-'         if_z    mov     hidr_type,#M_READY
	byte	$04, $1c, $07, $a6
'-'                 cmp     hidr_type, #M_READY             wz
	byte	$04, $1c, $0f, $f2
'-'                 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle HID controller (or mouse now
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' hpad_hid
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 mov     ptra, pb
	byte	$f7, $f1, $03, $f6
'-'                 alts    hdev_port, #gp_descr_len
	byte	$3f, $5b, $96, $f9
'-'                 mov     pa, 0-0
	byte	$00, $ec, $03, $f6
'-'                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
'-'                 mov     hidr_usage, ##$76543210
	byte	$19, $2a, $3b, $ff, $10, $0c, $07, $f6
'-' 
'-' .next
'-'                 cmps    pa, #0      wcz
	byte	$00, $ec, $5f, $f2
'-'         if_be   ret     wcz
	byte	$2d, $00, $7c, $ed
'-' 
'-'                 rdbyte  hpar1, ptra++
	byte	$61, $8f, $c7, $fa
'-'                 sub     pa, #1
	byte	$01, $ec, $87, $f1
'-'                 mov     hpar2, #0
	byte	$00, $90, $07, $f6
'-' 
'-'                 mov     htmp, hpar1
	byte	$c7, $73, $03, $f6
'-'                 and     htmp, #$03
	byte	$03, $72, $07, $f5
'-'                 cmp     htmp, #1    wz
	byte	$01, $72, $0f, $f2
'-'         if_z    rdbyte  hpar2, ptra++
	byte	$61, $91, $c7, $aa
'-'         if_z    signx   hpar2,#7
	byte	$07, $90, $67, $a7
'-'         if_z    sub     pa, #1
	byte	$01, $ec, $87, $a1
'-'                 cmp     htmp, #2    wz
	byte	$02, $72, $0f, $f2
'-'         if_z    rdword  hpar2, ptra++
	byte	$61, $91, $e7, $aa
'-'         if_z    signx   hpar2,#15
	byte	$0f, $90, $67, $a7
'-'         if_z    sub     pa, #2
	byte	$02, $ec, $87, $a1
'-'                 cmp     htmp, #3    wz
	byte	$03, $72, $0f, $f2
'-'         if_z    rdlong  hpar2, ptra++
	byte	$61, $91, $07, $ab
'-'         if_z    sub     pa, #4
	byte	$04, $ec, $87, $a1
'-' 
'-'                 and     hpar1, #$FC
	byte	$fc, $8e, $07, $f5
'-'                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
'-' 
'-'                 cmp     hpar1, #HID_REPORT_ID   wz
	byte	$84, $8e, $0f, $f2
'-'         if_z    jmp     #.report_id
	byte	$18, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE_PAGE  wz
	byte	$04, $8e, $0f, $f2
'-'         if_z    jmp     #.usage_page
	byte	$30, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE       wz
	byte	$08, $8e, $0f, $f2
'-'         if_z    jmp     #.usage
	byte	$38, $01, $90, $ad
'-'                 cmp     hpar1, #HID_LOGICAL_MIN wz
	byte	$14, $8e, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #1
	byte	$c8, $2b, $2b, $a9
'-'                 cmp     hpar1, #HID_LOGICAL_MAX wz
	byte	$24, $8e, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #0
	byte	$c8, $2b, $23, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MIN wz
	byte	$34, $8e, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #1
	byte	$c8, $2d, $2b, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MAX wz
	byte	$44, $8e, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #0
	byte	$c8, $2d, $23, $a9
'-'                 cmp     hpar1, #HID_REPORT_SIZE wz
	byte	$74, $8e, $0f, $f2
'-'         if_z    mov     hidr_size, hpar2
	byte	$c8, $27, $03, $a6
'-'                 cmp     hpar1, #HID_REPORT_COUNT wz
	byte	$94, $8e, $0f, $f2
'-'         if_z    mov     hidr_count, hpar2
	byte	$c8, $29, $03, $a6
'-'                 cmp     hpar1, #HID_POP wcz
	byte	$b4, $8e, $1f, $f2
'-'         if_nz   cmp     hpar1, #HID_PUSH wz
	byte	$a4, $8e, $0f, $52
'-'         if_z    jmp     #.pushpop ' Entering with C set if PUSH  
	byte	$64, $01, $90, $ad
'-'                 cmp     hpar1, #HID_INPUT       wz
	byte	$80, $8e, $0f, $f2
'-'         if_nz   jmp     #.next
	byte	$58, $ff, $9f, $5d
'-' 
'-'                 tjf     hidr_state,#.next
	byte	$d5, $25, $a7, $fb
'-' 
'-'                 and     hpar2, #$03
	byte	$03, $90, $07, $f5
'-'                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
	byte	$02, $90, $0f, $f2
'-'         if_nz   jmp     #.skip
	byte	$18, $00, $90, $5d
'-' 
'-'                 cmp     hidr_state, #2  wz
	byte	$02, $24, $0f, $f2
'-'         if_z    jmp     #.axes
	byte	$20, $00, $90, $ad
'-'                 cmp     hidr_state, #3  wz
	byte	$03, $24, $0f, $f2
'-'         if_z    jmp     #.hats
	byte	$5c, $00, $90, $ad
'-'                 cmp     hidr_state, #4  wz
	byte	$04, $24, $0f, $f2
'-'         if_z    jmp     #.buttons
	byte	$70, $00, $90, $ad
'-' .skip
'-'                 mov     htmp, hidr_size
	byte	$93, $73, $03, $f6
'-'                 mul     htmp, hidr_count
	byte	$94, $73, $03, $fa
'-'                 add     hidr_offset, htmp
	byte	$b9, $21, $03, $f1
'-'                 jmp     #.next
	byte	$20, $ff, $9f, $fd
'-' .axes
'-'                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count),uhex_long(hidr_flags))
'-'                 getnib  hr0, hidr_flags, #2
	byte	$87, $87, $53, $f8
'-'                 mov     hr1, hidr_count
	byte	$94, $89, $03, $f6
'-' .l1
'-'                 mov     hpar1, hidr_offset
	byte	$90, $8f, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$93, $91, $03, $f6
'-'                 call    #hpad_getbits
	byte	$28, $01, $b0, $fd
'-'                 call    #hpad_normalize
	byte	$88, $01, $b0, $fd
'-'                 cmp     hr0, #8         wcz
	byte	$08, $86, $1f, $f2
'-'         if_b    altgn   hr0, #hidr_usage
	byte	$86, $87, $5f, $c9
'-'         if_b    getnib  hr2
	byte	$00, $8a, $43, $c8
'-'         if_b    altsw   hr2, #hidr_axis
	byte	$88, $8b, $77, $c9
'-'         if_b    setword retval
	byte	$5f, $01, $20, $c9
'-'         if_b    add     hr0, #1
	byte	$01, $86, $07, $c1
'-'                 add     hidr_offset, hidr_size
	byte	$93, $21, $03, $f1
'-'                 djnz    hr1, #.l1
	byte	$f4, $89, $6f, $fb
'-' 
'-'                 setnib  hidr_flags, hr0, #2
	byte	$c3, $0f, $13, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $24, $07, $f6
'-'                 jmp     #.next
	byte	$dc, $fe, $9f, $fd
'-' .hats
'-'                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$90, $8f, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$93, $91, $03, $f6
'-'                 call    #hpad_getbits
	byte	$ec, $00, $b0, $fd
'-'                 setbyte hidr_hats, retval, #0
	byte	$5f, $1b, $c3, $f8
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $24, $07, $f6
'-'                 jmp     #.skip
	byte	$90, $ff, $9f, $fd
'-' .buttons
'-'                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$90, $8f, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$93, $91, $03, $f6
'-'                 mul     hpar2, hidr_count
	byte	$94, $91, $03, $fa
'-'                 call    #hpad_getbits
	byte	$cc, $00, $b0, $fd
'-'                 getbyte htmp, hidr_flags, #0
	byte	$87, $73, $e3, $f8
'-'                 shl     retval, htmp
	byte	$b9, $bf, $62, $f0
'-'                 or      hidr_buttons, retval
	byte	$5f, $19, $43, $f5
'-'                 add     htmp, hidr_count
	byte	$94, $73, $03, $f1
'-'                 setbyte hidr_flags, htmp, #0
	byte	$b9, $0f, $c3, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $24, $07, $f6
'-'                 jmp     #.skip
	byte	$64, $ff, $9f, $fd
'-' .report_id
'-'                 cmp     hidr_id, #0     wz
	byte	$00, $1e, $0f, $f2
'-'         if_nz   ret     wcz
	byte	$2d, $00, $7c, $5d
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 'debug(".report_id",udec(htmp,hpar2))
'-'                 cmp     htmp, hpar2     wz
	byte	$c8, $73, $0b, $f2
'-'         if_z    mov     hidr_id, htmp
	byte	$b9, $1f, $03, $a6
'-'         if_nz   neg     hidr_state,#1
	byte	$01, $24, $67, $56
'-'         if_nz   sub     ptrb,#1
	byte	$01, $f2, $87, $51
'-'                 jmp     #.next
	byte	$74, $fe, $9f, $fd
'-' .usage_page
'-'                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
	byte	$09, $90, $0f, $f2
'-'         if_z    cmp     hidr_state, #1  wz
	byte	$01, $24, $0f, $a2
'-'         if_z    mov     hidr_state, #4
	byte	$04, $24, $07, $a6
'-'                 jmp     #.next
	byte	$64, $fe, $9f, $fd
'-' .usage
'-'                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
	byte	$04, $90, $0f, $f2
'-'         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
	byte	$05, $90, $0f, $52
'-'         if_z    cmp     hidr_type,#HID_READY        wz
	byte	$06, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $24, $07, $a6
'-'         if_z    jmp     #.next
	byte	$50, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_MOUSE     wz
	byte	$02, $90, $0f, $f2
'-'         if_z    cmp     hidr_type,#M_READY          wz
	byte	$04, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $24, $07, $a6
'-'         if_z    jmp     #.next
	byte	$40, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_X     wc
	byte	$30, $90, $17, $f2
'-'         if_nc   cmpr    hpar2, #HID_USAGE_WHEEL wc   
	byte	$38, $90, $97, $32
'-'         if_nc   jmp     #.usage_axis
	byte	$10, $00, $90, $3d
'-'                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
	byte	$39, $90, $0f, $f2
'-'         if_z    cmp     hidr_state, #1      wz
	byte	$01, $24, $0f, $a2
'-'         if_z    mov     hidr_state, #3
	byte	$03, $24, $07, $a6
'-'                 jmp     #.next
	byte	$24, $fe, $9f, $fd
'-' .usage_axis
'-'                 cmps    hidr_state, #1          wc
	byte	$01, $24, $57, $f2
'-'         if_b    jmp     #.next
	byte	$1c, $fe, $9f, $cd
'-'                 fle     hpar2, #HID_USAGE_DIAL   ' Let's just say wheel and dial are the same to keep sane
	byte	$37, $90, $27, $f3
'-'                 altsn   hidr_usage_idx, #hidr_usage
	byte	$86, $23, $57, $f9
'-'                 setnib  hpar2
	byte	$c8, $01, $00, $f8
'-' 
'-'                 sub     hpar2, #HID_USAGE_X - 16
	byte	$20, $90, $87, $f1
'-'                 bith    hidr_flags, hpar2
	byte	$c8, $0f, $23, $f4
'-' 
'-'                 add     hidr_usage_idx, #1
	byte	$01, $22, $07, $f1
'-'                 mov     hidr_state, #2
	byte	$02, $24, $07, $f6
'-'                 jmp     #.next
	byte	$fc, $fd, $9f, $fd
'-' .pushpop
'-'                 ' Entering with C set if PUSH  
'-'                 loc     pb, #hid_stack
	byte	$4c, $0f, $b0, $fe
'-'         if_c    setq    #(hidr_end-hidr_state)-1
	byte	$28, $08, $64, $cd
'-'         if_c    wrlong  hidr_state, pb
	byte	$f7, $25, $63, $cc
'-'         if_nc   setq    #(hidr_end-hidr_state)-1
	byte	$28, $08, $64, $3d
'-'         if_nc   rdlong  hidr_state, pb
	byte	$f7, $25, $03, $3b
'-'                 jmp     #.next
	byte	$e4, $fd, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Read bits from report data buffer
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRB - report buffer
'-' '   hpar1 - start bit
'-' '   hpar2 - number of bits
'-' ' On exit:
'-' '   retval - bits
'-' '------------------------------------------------------------------------------
'-' hpad_getbits
'-'                 mov     htmp, hpar1
	byte	$c7, $73, $03, $f6
'-'                 shr     htmp, #3        ' byte offset
	byte	$03, $72, $47, $f0
'-'                 add     htmp, ptrb
	byte	$f9, $73, $03, $f1
'-'                 rdlong  retval, htmp
	byte	$b9, $bf, $02, $fb
'-' 
'-'                 mov     htmp1, hpar1
	byte	$c7, $75, $03, $f6
'-'                 and     htmp1, #$07     ' shift
	byte	$07, $74, $07, $f5
'-'                 shr     retval, htmp1
	byte	$ba, $bf, $42, $f0
'-' 
'-'                 cmp     hpar2, #24      wcz
	byte	$18, $90, $1f, $f2
'-'         if_a    jmp     #.l1
	byte	$10, $00, $90, $1d
'-' 
'-'                 decod   hpar2
	byte	$c8, $91, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $90, $87, $f1
'-'                 and     retval, hpar2
	byte	$c8, $bf, $02, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .l1
'-'                 and     retval, ##$00_FFFFFF
	byte	$ff, $7f, $00, $ff, $ff, $bf, $06, $f5
'-'                 add     htmp, #3
	byte	$03, $72, $07, $f1
'-'                 rdlong  htmp2, htmp
	byte	$b9, $77, $03, $fb
'-'                 sub     hpar2, #24
	byte	$18, $90, $87, $f1
'-'                 decod   hpar2
	byte	$c8, $91, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $90, $87, $f1
'-'                 shr     htmp2, htmp1
	byte	$ba, $77, $43, $f0
'-'                 and     htmp2, hpar2
	byte	$c8, $77, $03, $f5
'-'                 shl     htmp2, #24
	byte	$18, $76, $67, $f0
'-'                 or      retval, htmp2
	byte	$bb, $bf, $42, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Normalize value to signed word (-32768 / 32767)
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - value to normalize
'-' '   hidr_lminmax - min (word 1) max (word 0) value range
'-' '   - or -
'-' '   hidr_pminmax - min (word 1) max (word 0) value range
'-' '   hidr_size - value bits length
'-' ' On exit:
'-' '   retval - normalized value
'-' '------------------------------------------------------------------------------
'-' hpad_normalize
'-'                 mov     htmp, hidr_lminmax  wz
	byte	$95, $73, $0b, $f6
'-'         if_z    mov     htmp, hidr_pminmax  wz
	byte	$96, $73, $0b, $a6
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 getword htmp1, htmp, #1     ' htmp1 = min
	byte	$b9, $75, $3b, $f9
'-'                 getword htmp, htmp, #0      ' htmp = max
	byte	$b9, $73, $33, $f9
'-'                 signx   htmp1, #15      wc
	byte	$0f, $74, $77, $f7
'-'         if_c    alts    hidr_size, #511
	byte	$ff, $27, $97, $c9
'-'         if_c    signx   retval, #0-0
	byte	$00, $be, $66, $c7
'-'                 ' slightly crappy hack: if in mouse mode, don't normalize
'-'                 cmp     hidr_type, #M_READY wz
	byte	$04, $1c, $0f, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 subs    htmp, htmp1         ' htmp = (max - min)
	byte	$ba, $73, $c3, $f1
'-'                 subs    retval, htmp1       ' retval = (retval - min)
	byte	$ba, $bf, $c2, $f1
'-'                 shl     retval, #16         ' retval = (retval - min) << 16
	byte	$10, $be, $66, $f0
'-'                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
	byte	$01, $be, $c6, $f1
'-'                 abs     htmp            wc
	byte	$b9, $73, $53, $f6
'-'                 testb   retval, #31     wz
	byte	$1f, $be, $0e, $f4
'-'                 abs     retval
	byte	$5f, $bf, $42, $f6
'-'                 qdiv    retval, htmp
	byte	$b9, $bf, $12, $fd
'-'                 getqx   retval
	byte	$18, $be, $62, $fd
'-'     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
	byte	$5f, $bf, $62, $66
'-'                 adds    retval, ##$8000 signx 15
	byte	$c0, $ff, $7f, $ff, $00, $be, $46, $f1
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' if _HAVE_GAMEPAD
'-' '------------------------------------------------------------------------------
'-' ' Handle XInput controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_xinput
'-'                 rdbyte  htmp, ptrb      wz
	byte	$80, $73, $cf, $fa
'-'         if_nz   ret                         ' Ignore message type <> $00
	byte	$2d, $00, $64, $5d
'-'                 rdbyte  htmp, ptrb[1]
	byte	$81, $73, $c7, $fa
'-'                 cmp     htmp, #$14      wz
	byte	$14, $72, $0f, $f2
'-'         if_nz   ret                         ' Ignore report length <> $14 (20)
	byte	$2d, $00, $64, $5d
'-' 
'-'                 'debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
	byte	$b0, $0e, $27, $f4
'-'                 setnib  hidr_flags, #6, #2
	byte	$06, $0e, $17, $f8
'-' 
'-'                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
	byte	$83, $11, $e7, $fa
'-'                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
	byte	$84, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
	byte	$85, $13, $e7, $fa
'-'                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
	byte	$86, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $2a, $07, $f6
'-'                 rdbyte  retval, ptrb[4]     ' left analog trigger
	byte	$84, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
	byte	$06, $18, $27, $34
'-'                 call    #hpad_normalize
	byte	$54, $ff, $bf, $fd
'-'                 setword hidr_axis+1, retval, #1
	byte	$5f, $13, $2b, $f9
'-'                 rdbyte  retval, ptrb[5]     ' right analog trigger
	byte	$85, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
	byte	$07, $18, $27, $34
'-'                 call    #hpad_normalize
	byte	$40, $ff, $bf, $fd
'-'                 setword hidr_axis+2, retval, #0
	byte	$5f, $15, $23, $f9
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 rdword  retval, ptrb[1]
	byte	$81, $bf, $e6, $fa
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $18, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $18, $47, $f4
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $18, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $18, $47, $f4
'-'                 testb   retval, #8      wc  ' LB
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $18, $47, $f4
'-'                 testb   retval, #9      wc  ' RB
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $18, $47, $f4
'-'                 testb   retval, #5      wc  ' SELECT
	byte	$05, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $18, $47, $f4
'-'                 testb   retval, #4      wc  ' START
	byte	$04, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $18, $47, $f4
'-'                 testb   retval, #6      wc  ' L3
	byte	$06, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $18, $47, $f4
'-'                 testb   retval, #7      wc  ' R3
	byte	$07, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $18, $47, $f4
'-'                 testb   retval, #10     wc  ' XBOX
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $18, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
	byte	$5f, $73, $43, $f8
'-'                 mov     htmp1, ##$F576_F40F
	byte	$7a, $bb, $7a, $ff, $0f, $74, $07, $f6
'-'                 mov     htmp2, ##$FFFF_F312
	byte	$f9, $ff, $7f, $ff, $12, $77, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$ba, $73, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $72, $43, $f8
'-'         _ret_   setbyte hidr_hats, htmp, #0
	byte	$b9, $1b, $c3, $08
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle PS3 controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_ps3
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 cmp     htmp, #$01      wz
	byte	$01, $72, $0f, $f2
'-'         if_nz   ret                         ' Ignore report ID <> $01
	byte	$2d, $00, $64, $5d
'-' 
'-'                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
	byte	$b0, $0e, $27, $f4
'-'                 setnib  hidr_flags, #6, #2
	byte	$06, $0e, $17, $f8
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $2a, $07, $f6
'-'                 rdbyte  retval, ptrb[5]         ' X = left stick X
	byte	$85, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$98, $fe, $bf, $fd
'-'                 setword hidr_axis, retval, #0
	byte	$5f, $11, $23, $f9
'-'                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
	byte	$86, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$8c, $fe, $bf, $fd
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 rdbyte  retval, ptrb[7]         ' Z = right stick X
	byte	$87, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$80, $fe, $bf, $fd
'-'                 setword hidr_axis+1, retval, #0
	byte	$5f, $13, $23, $f9
'-'                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
	byte	$88, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$74, $fe, $bf, $fd
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-'                 rdbyte  retval, ptrb[17]        ' RX = L2 analog
	byte	$91, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$68, $fe, $bf, $fd
'-'                 setword hidr_axis+1, retval, #1
	byte	$5f, $13, $2b, $f9
'-'                 rdbyte  retval, ptrb[18]        ' RY = R2 analog
	byte	$92, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$5c, $fe, $bf, $fd
'-'                 setword hidr_axis+2, retval, #0
	byte	$5f, $15, $23, $f9
'-' 
'-'                 mov     hpar1, #8
	byte	$08, $8e, $07, $f6
'-'                 mov     hpar2, #19
	byte	$13, $90, $07, $f6
'-'                 call    #hpad_getbits
	byte	$e8, $fd, $bf, $fd
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $18, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $18, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $18, $47, $f4
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $18, $47, $f4
'-'                 testb   retval, #10     wc  ' L1
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $18, $47, $f4
'-'                 testb   retval, #11     wc  ' R1
	byte	$0b, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $18, $47, $f4
'-'                 testb   retval, #8      wc  ' L2
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #6
	byte	$06, $18, $47, $f4
'-'                 testb   retval, #9      wc  ' R2
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #7
	byte	$07, $18, $47, $f4
'-'                 testb   retval, #0      wc  ' SELECT
	byte	$00, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $18, $47, $f4
'-'                 testb   retval, #3      wc  ' START
	byte	$03, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $18, $47, $f4
'-'                 testb   retval, #1      wc  ' LEFT STICK
	byte	$01, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $18, $47, $f4
'-'                 testb   retval, #2      wc  ' RIGHT STICK
	byte	$02, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $18, $47, $f4
'-'                 testb   retval, #16     wc  ' HOME
	byte	$10, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $18, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
	byte	$5f, $73, $4b, $f8
'-'                 mov     htmp1, ##$F3F4_120F
	byte	$09, $fa, $79, $ff, $0f, $74, $07, $f6
'-'                 mov     htmp2, ##$FFF5_FF76
	byte	$ff, $fa, $7f, $ff, $76, $77, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$ba, $73, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $72, $43, $f8
'-'         _ret_   setbyte hidr_hats, htmp, #0
	byte	$b9, $1b, $c3, $08
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform controller actions
'-' ' On entry:
'-' '    hidr_id        report id
'-' '    hidr_axis      axis value (signed word, 2 axes per long)
'-' '                      X = hidr_axis+0, #0
'-' '                      Y = hidr_axis+0, #1
'-' '                      Z = hidr_axis+1, #0
'-' '                     RX = hidr_axis+1, #1
'-' '                     RY = hidr_axis+2, #0
'-' '                     RZ = hidr_axis+2, #1
'-' '                     Sl = hidr_axis+3, #0
'-' '                     Wh = hidr_axis+3, #1
'-' '    hidr_buttons   buttons state (bits 0 to 31)
'-' '    hidr_hats      hats state (byte 0, 1, 2, 3)
'-' '
'-' '                     -------3 -------2 -------1 -------0 byte
'-' '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
'-' '    hidr_flags       xxxxxxxx_wsrrrzyx_hhhhaaaa_bbbbbbbb
'-' '                              hlzyx||| |||||||| ++++++++ n. buttons
'-' '                              |||||||| ||||++++--------- n. axes
'-' '                              |||||||| ++++------------- n. hats
'-' '                              ++++++++------------------ valid axes
'-' '------------------------------------------------------------------------------
'-' hpad_translate
'-' 
'-' 
'-'         if HAVE_HIDPAD
'-'                 loc     ptrb,#hidpad_report
	byte	$a0, $0c, $f0, $fe
'-'                 mov     htmp,hdev_port          wz
	byte	$2d, $73, $0b, $f6
'-'         if_z    mov     htmp,hidr_id
	byte	$8f, $73, $03, $a6
'-'                 cmpsub  htmp,#1
	byte	$01, $72, $e7, $f2
'-'         if_z    cmp     hidr_id, #MAX_DEVICES   wc
	byte	$07, $1e, $17, $a2
'-'         if_nz   cmp     hidr_id, #2             wc
	byte	$02, $1e, $17, $52
'-'         if_ae   ret     wcz
	byte	$2d, $00, $7c, $3d
'-'                 mul     htmp, #HIDPAD_REPORT_SIZE
	byte	$20, $72, $07, $fa
'-'                 add     ptrb,htmp
	byte	$b9, $f3, $03, $f1
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
	byte	$00, $0c, $03, $f6
'-'                 setq    #8-1
	byte	$28, $0e, $64, $fd
'-'                 wrlong  hidr_usage,ptrb
	byte	$80, $0d, $67, $fc
'-'         end
'-' 
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' .emupad_no_hat
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' .emupad_slot_over
'-'         end
'-' 
'-'         if 0
'-'                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
'-' 
'-'                 debug("    btn: ", ubin_long_(hidr_buttons))
'-' 
'-'         end
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' '------------------------------------------------------------------------------
'-' ' Clear EmuPad state
'-' '------------------------------------------------------------------------------
'-' emupad_reset
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get EmuPad Player number for current device (into retval)
'-' ' Z flag is also set if current device is valid
'-' ' (Value may be larger than EMUPAD_MAX_PLAYER !)
'-' '------------------------------------------------------------------------------
'-' emupad_getnum
'-' .loop
'-' '------------------------------------------------------------------------------
'-' ' Handle disconnect of device (call after emupad_getnum returns with Z set)
'-' '------------------------------------------------------------------------------
'-' emupad_discon
'-' .loop         
'-'         
'-'         ' FALL THROUGH!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Update EmuPad reports (all of them...)
'-' '------------------------------------------------------------------------------
'-' emupad_write_reports
'-' .devloop
'-' 
'-' end
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_hub_status
'-'                 mov     ep_addr_pid, hhub_ep_addr
	byte	$77, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 setword hpar3, hub_next_datax, #0
	byte	$32, $93, $23, $f9
'-'                 setword hpar3, #1, #1
	byte	$01, $92, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.data
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
	byte	$1a, $01, $80, $5d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .data
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 cmp     hub_next_datax, #PID_DATA0  wz
	byte	$c3, $64, $0e, $f2
'-'         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
	byte	$4b, $64, $06, $a6
'-'         if_nz   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $56
'-'                 rdlong  hub_status_chg, urx_buff_p
	byte	$27, $67, $02, $fb
'-'                 debug(ubin_long(hub_status_chg))
'-' 
'-'                 mov     hdev_port, #1
	byte	$01, $5a, $06, $f6
'-' .loop
'-'                 testb   hub_status_chg, hdev_port wz
	byte	$2d, $67, $0a, $f4
'-'         if_x1   call    #hub_port_handler
	byte	$0c, $00, $b0, $ad
'-'                 incmod  hdev_port, #7           wcz
	byte	$07, $5a, $1e, $f7
'-'         if_nc   jmp     #.loop
	byte	$f0, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' hub_port_handler
'-'                 mov     ep_addr_pid, hhub_ctrl_ep
	byte	$76, $bd, $02, $f6
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$8c, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-' 
'-'                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
	byte	$10, $68, $0e, $f4
'-'         if_x0   jmp     #.other
	byte	$50, $01, $90, $5d
'-'                 loc     ptra, #clr_port_feat
	byte	$68, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
	byte	$01, $21, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
	byte	$00, $68, $0e, $f4
'-'         if_x0   jmp     #.disconnect
	byte	$7c, $01, $90, $5d
'-'                 mov     hctwait, _100ms_
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 loc     ptra, #set_port_feat            ' reset port
	byte	$40, $02, $d0, $fe
'-'                 wrword  #HUB_PORT_RESET, ptra[wValue]
	byte	$01, $09, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp3, #2
	byte	$02, $78, $07, $f6
'-' .wait_reset
'-'                 mov     hctwait, _8ms_
	byte	$ad, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$34, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
	byte	$14, $68, $0e, $f4
'-'         if_x0   djnz    htmp3, #.wait_reset
	byte	$f7, $79, $6f, $5b
'-' 
'-'                 loc     ptra, #clr_port_feat
	byte	$10, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
	byte	$24, $72, $07, $f6
'-' .wait_recover
'-'                 mov     hctwait, _1ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 djnz    htmp,#.wait_recover
	byte	$fd, $73, $6f, $fb
'-' 
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $27, $c4
'-' 
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$8c, $01, $d0, $fe
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$48, $01, $90, $5d
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
	byte	$80, $01, $d0, $fe
'-'                 mov     htmp, hdev_port             ' Address is hub port number
	byte	$2d, $73, $03, $f6
'-'                 wrword  htmp, ptra[wValue]
	byte	$01, $73, $57, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$24, $01, $90, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ad, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$ef, $02, $a0, $fd
'-'                 mov     ep_addr_pid, hdev_port
	byte	$2d, $bd, $02, $f6
'-'                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
	byte	$08, $bc, $66, $f0
'-'                 call    #calc_crc5
	byte	$be, $00, $a0, $fd
'-'                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
	byte	$3c, $01, $d0, $fe
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$f4, $00, $90, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
'-'                 mov     hctwait, _500us_
	byte	$a0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$18, $01, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$cc, $00, $90, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $87, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $89, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $73, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $86, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $88, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $73, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #.done
	byte	$a4, $00, $90, $cd
'-'                 call    #hparse_con_desc
	byte	$68, $f0, $bf, $fd
'-'                 jmp     #.done
	byte	$9c, $00, $90, $fd
'-' 
'-' .other
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz
	byte	$14, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$28, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
	byte	$11, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
	byte	$01, $23, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$1c, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
	byte	$12, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
	byte	$01, $25, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$10, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
	byte	$13, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
	byte	$01, $27, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$04, $00, $90, $ad
'-'                 jmp     #.done
	byte	$68, $00, $90, $fd
'-' .reset_feature
'-'                 loc     ptra, #clr_port_feat
	byte	$e4, $00, $d0, $fe
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 jmp     #.done
	byte	$58, $00, $90, $fd
'-' .disconnect
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $72, $e3, $f8
'-'                 cmp     htmp,#KB_READY wz
	byte	$03, $72, $0f, $f2
'-'         if_nz   cmp     htmp,#KBM_READY wz
	byte	$05, $72, $0f, $52
'-'         if_z    mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $a6
'-'         if_z    mov     hkbd_ctrl_ep, #0
	byte	$00, $f0, $06, $a6
'-'         if_z    mov     kb_led_states, #0
	byte	$00, $76, $06, $a6
'-'         if_z    mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $a6
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $72, $0f, $f2
'-'         if_nz   cmp     htmp, #KBM_READY        wz
	byte	$05, $72, $0f, $52
'-'         if_z    mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $a6
'-'         end
'-'         if HAVE_HIDPAD
'-'                 loc ptrb,#hidpad_report
	byte	$30, $0a, $f0, $fe
'-'                 mov htmp,hdev_port
	byte	$2d, $73, $03, $f6
'-'                 cmpsub htmp,#1
	byte	$01, $72, $e7, $f2
'-'                 mul htmp,#HIDPAD_REPORT_SIZE
	byte	$20, $72, $07, $fa
'-'                 add ptrb,htmp
	byte	$b9, $f3, $03, $f1
'-'                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
	byte	$28, $0e, $64, $fd
'-'                 wrlong #0,ptrb
	byte	$80, $01, $6c, $fc
'-'         end
'-' 
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte #0
	byte	$00, $00, $c4, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' 
'-' .done
'-'                 bitl    _usb_h_ls_nco_, #14     wcz
	byte	$0e, $6a, $1f, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6f, $13, $cc
'-'                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a6, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a4, $9b, $02, $f6
'-' 
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$6c, $00, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, ptra
	byte	$00, $69, $06, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Partially populated SETUP packets
'-' '------------------------------------------------------------------------------
'-' get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_DEVICE << 8
	byte	$00, $01
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_CONFIG << 8
	byte	$00, $02
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_CONFIG
	byte	$09
'-'                 word    0       ' Configuration value
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
	byte	$00, $00
'-' set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_ADDR
	byte	$05
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
'-' ' wValue field dictates which protocol should be used.
'-' '
'-' ' When initialized, all devices default to report protocol. However the host
'-' ' should not make any assumptions about the device state and should set the
'-' ' desired protocol whenever initializing a device.
'-' '------------------------------------------------------------------------------
'-' set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_PROTO
	byte	$0b
'-'                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
	byte	$00, $00
'-'                                                 ' (HID 1.11 Section 7.2.6).
'-'                 word    0               ' Interface index number.
	byte	$00, $00
'-'                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_IDLE
	byte	$0a
'-'                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
	byte	$00, $00
'-'                                         ' reporting until a change is detected in the report data
'-' 
'-'                                         ' (HID 1.11 Section 7.2.4).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
	byte	$00, $00
'-' set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_REPORT
	byte	$09
'-'                 word    0       ' Byte1 = report type, byte0 = ReportID.
	byte	$00, $00
'-'                                         ' (HID 1.11 Section 7.2.2).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Size of the report, in bytes.
	byte	$00, $00
'-' get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
	byte	$81
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_REPORT << 8
	byte	$00, $22
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
	byte	$a0
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_HUB << 8
	byte	$00, $29
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_SET_FEATURE
	byte	$03
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_CLEAR_FEATURE
	byte	$01
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
	byte	$a3
'-'                 byte    REQ_GET_STATUS
	byte	$00
'-'                 word    0
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    4       ' Number of bytes to transfer if there is a data stage
	byte	$04, $00
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' ps3_enable_cmd  byte    $42, $0C, $00, $00
	byte	$42, $0c, $00, $00
'-' ps3_command_buff
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
	byte	$00, $00, $00, $00, $02
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' '------------------------------------------------------------------------------
'-' xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
	byte	$01, $03, $06
'-'                                         ' 0x01 All blinking
'-'                                         ' 0x02 1 flashes, then on
'-'                                         ' 0x03 2 flashes, then on
'-'                                         ' 0x04 3 flashes, then on
'-'                                         ' 0x05 4 flashes, then on
'-'                                         ' 0x06 1 on
'-'                                         ' 0x07 2 on
'-'                                         ' 0x08 3 on
'-'                                         ' 0x09 4 on
'-'                                         ' 0x0A Rotating (e.g. 1-2-4-3)
'-'                                         ' 0x0B Blinking*
'-'                                         ' 0x0C Slow blinking*
'-'                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
'-' xinp_rumble_cmd byte    $00, $08, $00
	byte	$00, $08, $00
'-'                 byte    $00             ' Left rumble
	byte	$00
'-'                 byte    $00             ' Right rumble
	byte	$00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' 
'-' xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
'-'                 '' of certain wired 8bitdo gamepads.
'-'                 byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_STRING << 8 + 4
	byte	$04, $03
'-'                 word    $0409   ' Zero or Language ID (Section 9.6.7)
	byte	$09, $04
'-'                 word    2       ' Number of bytes to transfer if there is a data stage
	byte	$02, $00
'-' end
	byte	$00
'-' alignl
'-' 
'-' if HAVE_MOUSE
'-' mouse_limits long 0[2]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' mouse_outptr long 0
	byte	$00, $00, $00, $00
'-' end
'-' 
'-' if KEYQUEUE_SIZE > 0
'-' keyq_head byte 0
	byte	$00
'-' keyq_tail byte 0
	byte	$00
'-' keyq_data long 0[KEYQUEUE_SIZE]
	byte	$00[514]
'-' alignl
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_rule_buffer
'-' if EMUPAD_BUILTIN_RULES
'-' file "padmap_builtin.dat"
'-' end
'-' byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
'-' '' Default rule directly follows!
'-' byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The USB data cache area gets zero-filled at every device disconnect
'-' '------------------------------------------------------------------------------
'-' usb_cache_start
'-' 
'-' ' HID descriptor and report buffers
'-' if !!OVERLAP_MEMORY
'-' hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
	byte	$00[1792]
'-' end
'-' hkbd_report     byte    0[8]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' hkbd_led_rep    byte    0
	byte	$00, $00, $00, $00
'-' alignl
'-' 
'-' hid_stack       long 0[(hidr_end - hidr_state) * 1]
	byte	$00[20]
'-' 
'-' if HAVE_HIDPAD
'-' hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
	byte	$00[224]
'-' end
'-' 
'-' ' HUB descriptor
'-' hub_descr       byte    0   ' bDescLength
	byte	$00
'-'                 byte    0   ' bDescriptorType
	byte	$00
'-'                 byte    0   ' bNbrPorts
	byte	$00
'-'                 word    0   ' wHubCharacteristics
	byte	$00, $00
'-'                 byte    0   ' bPwrOn2PwrGood
	byte	$00
'-'                 byte    0   ' bHubContrCurrent
	byte	$00
'-'                 byte    0   ' DeviceRemoveable
	byte	$00
'-'                 byte    0   ' PortPwrCtrlMask
	byte	$00
'-' 
'-' usb_cache_end
'-' 
'-' if HAVE_MOUSE
'-' mouse_xacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_yacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_zacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_bstate    byte 0
	byte	$00
'-' mouse_lpending  byte 0
	byte	$00
'-' mouse_rpending  byte 0
	byte	$00
'-' mouse_mpending  byte 0
	byte	$00
'-' mouse_lock      byte 0
	byte	$00
'-'                 byte 0[3] ' padding
	byte	$00, $00, $00
'-' end
'-' 
'-' urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
	byte	$00[128]
'-' dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
	byte	$00[18]
'-' con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
	byte	$00[256]
'-' 
'-' driver_cog      byte    0                       ' Current driver cog + 1
	byte	$00
	alignl
_Audio2_004_spin2_dat_
'-' 
'-' audio       	org     0
'-' 
'-'             	rdlong  mailbox2, ptra++     	' get start address of all mailboxes
	byte	$61, $6f, $05, $fb
'-'             	rdlong  scbase, ptra++       	' get start address of scope buffer
	byte	$61, $a7, $05, $fb
'-'             	rdlong  hubptr, ptra++       	' get start address of PSRAM cache
	byte	$61, $b3, $05, $fb
'-' 
'-'             	cogid   pa                   	' compute cogid
	byte	$01, $ec, $63, $fd
'-'             	mul     pa, #12              	' and mailbox spacing
	byte	$0c, $ec, $07, $fa
'-'             	add     mailbox2, pa         	' add offset to find this COG's mailbox
	byte	$f6, $6f, $01, $f1
'-'             	mov     mailbox, mailbox2     	' we need 2 copies of this to enable switching between hub and psram
	byte	$b7, $6c, $01, $f6
'-' 
'-'             	wrpin   dac2,#left           	' PWM DACs at 44100@339 MHz
	byte	$0e, $b0, $05, $fc
'-'             	wxpin   sr44100,#left      	' 30*256
	byte	$0e, $b4, $15, $fc
'-'             	wrpin   dac2,#right
	byte	$0f, $b0, $05, $fc
'-'             	wxpin   sr44100,#right    
	byte	$0f, $b4, $15, $fc
'-'             	dirh    #left addpins 1
	byte	$41, $9c, $64, $fd
'-'             	setse1  #%001<<6 + left      	' Set the event - DAC empty
	byte	$20, $9c, $64, $fd
'-'  
'-'             
'-' '---------------------------------------------------------------------------------        
'-' '----------------- The main loop -------------------------------------------------
'-' '---------------------------------------------------------------------------------
'-' 
'-' loop       	mov 	    cn,#15 '7
	byte	$0f, $9e, $05, $f6
'-'               					'   waitx ##3300000  		'for debug
'-'             
'-' '----------------------------------------------------------------------------------
'-' '------------- Get parameters and execute commands if any -------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' 
'-' p401        	mov     channeladd,cn             	' compute the pointer to channel parameters block
	byte	$cf, $66, $01, $f6
'-'             	shl     channeladd,#6
	byte	$06, $66, $65, $f0
'-'             	add     ptra,channeladd
	byte	$b3, $f0, $03, $f1
'-' 
'-'             	setq    #13                       	' read parameters
	byte	$28, $1a, $64, $fd
'-'             	rdlong  pointer0,ptra
	byte	$00, $75, $05, $fb
'-' p408        	bitl    command0,#31 wcz	      	' bit #31 command - set the DAC sample rate
	byte	$1f, $88, $1d, $f4
'-'     	if_nc   jmp     #p404                     	' if not set, proceed
	byte	$2c, $00, $90, $3d
'-'             	mov     qq,command0             	' get the new rate
	byte	$c4, $68, $01, $f6
'-'             	wxpin   qq,#left addpins 1        	' and program the pins
	byte	$4e, $68, $15, $fc
'-'             	getbyte qq,qq,#0 		      	' check if the rate is n*256
	byte	$b4, $68, $e1, $f8
'-'             	cmp     qq,#0 wz                         
	byte	$00, $68, $0d, $f2
'-'     	if_z    wrpin   dac2,#left addpins 1      	' if yes, set PWM DAC mode
	byte	$4e, $b0, $05, $ac
'-'     	if_nz   wrpin   dac,#left addpins 1       	' else set noise DAC mode
	byte	$4e, $ae, $05, $5c
'-'                 
'-'                	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
	byte	$1e, $7e, $1d, $f4
'-'     	if_z    mov     pointer0, #0  
	byte	$00, $74, $05, $a6
'-'     	if_z    mov     pointer0h, #0  
	byte	$00, $76, $05, $a6
'-'     	if_z    mov     envph0, #0  
	byte	$00, $7c, $05, $a6
'-'     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
	byte	$05, $7f, $65, $ac
'-'     	
'-' p404        	mov     qq,sstart0		     	' check if start>$80000
	byte	$bf, $68, $01, $f6
'-' 		and 	qq,##$7FFFFFF 
	byte	$ff, $ff, $03, $ff, $ff, $69, $05, $f5
'-'                 cmp 	qq,##$80000 wcz
	byte	$00, $04, $00, $ff, $00, $68, $1d, $f2
'-'     	if_ge   mov     mailbox,mailbox2          	' if yes, use PSRAM
	byte	$b7, $6c, $01, $36
'-'     	if_lt   mov     mailbox,#0                	' if not, use HUB 
	byte	$00, $6c, $05, $c6
'-' 
'-' p405           	getword apan0,volpan0,#1          	' extract vol,pan from longs 
	byte	$c2, $9a, $39, $f9
'-'     	    	getword avol0,volpan0,#0
	byte	$c2, $98, $31, $f9
'-'     	    	
'-' '----------------------------------------------------------------------------------
'-' '------------- Compute the envelope, if exists ------------------------------------
'-' '----------------------------------------------------------------------------------
'-'             
'-'             	cmp     envptr0,#0 wcz     		' read the pointer
	byte	$00, $8a, $1d, $f2
'-'     	if_z    mov     envs1,##$4000			' if 0, no envelope, load $4000=1 for scas
	byte	$20, $00, $00, $af, $00, $e6, $05, $a6
'-'     	if_z    jmp     #p410				' and run away	
	byte	$54, $00, $90, $ad
'-' 
'-'            	add     envph0,envspd0			' envelope PA update
	byte	$c6, $7c, $01, $f1
'-'            	           
'-'       	    	mov     envhi, envph0			' move phase acc to high part of env pointer
	byte	$be, $e2, $01, $f6
'-' 		shr     envhi,#6			' leave 10 bits in hi
	byte	$06, $e2, $45, $f0
'-' 	   	getword envlo,envhi,#0              	' and 16 bit in lo
	byte	$f1, $e4, $31, $f9
'-' 	    	shr     envhi,#16			' move 10 bits of hi to the lower word
	byte	$10, $e2, $45, $f0
'-' 	    	cmp     envhi,envlen0 wcz		' compare this to envelope length
	byte	$c7, $e2, $19, $f2
'-' 	    											'debug(udec(envhi,envlen0))
'-'     	if_ge  	mov     envhi,envlen0			' if greater than, set it at envlen
	byte	$c7, $e2, $01, $36
'-'     	if_ge   mov     envlo,#0
	byte	$00, $e4, $05, $36
'-'     	if_ge   mov     envph0,envlen0             	' and set envph0 at the end of the envelope
	byte	$c7, $7c, $01, $36
'-'     	if_ge   shl     envph0,#22
	byte	$16, $7c, $65, $30
'-' 
'-'             	mov 	envs1,envhi			' 10 high bits of PA is the offset to the envelope entry
	byte	$f1, $e6, $01, $f6
'-'             	shl 	envs1,#1                        ' these entries are 16 bit so multiply the offset by 2
	byte	$01, $e6, $65, $f0
'-'             	add 	envs1,envptr0                   ' and add it to the pointer
	byte	$c5, $e6, $01, $f1
'-'             	rdlong 	envs1,envs1			' and then read 2 entries in one rdlong
	byte	$f3, $e6, $01, $fb
'-'             	getword envs2,envs1,#1			' then separate them		
	byte	$f3, $e8, $39, $f9
'-'            	getword envs1,envs1,#0
	byte	$f3, $e6, $31, $f9
'-'             	mul     envs2,envlo                     ' and do linear interpolation based on lower bits of the offset
	byte	$f2, $e8, $01, $fa
'-'             	not     envlo
	byte	$f2, $e4, $21, $f6
'-'             	mul     envs1,envlo
	byte	$f2, $e6, $01, $fa
'-'             	add     envs1,envs2
	byte	$f4, $e6, $01, $f1
'-'             	shr     envs1,#18			' we need only 14 bits for scas
	byte	$12, $e6, $45, $f0
'-'               
'-' '----------------------------------------------------------------------------------
'-' '------------- Generate the noise if bit 27 of the pointer is set -----------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' 
'-'     	
'-' '----------------------------------------------------------------------------------
'-' '------------- Get the sample -----------------------------------------------------
'-' '----------------------------------------------------------------------------------    	
'-'  
'-' p410  		mov	oldptrh,pointer0h
	byte	$bb, $9c, $01, $f6
'-'            	getbyte	afreq0,freqskip0,#3         	' the frequency is in 8:24 format, so get integer in afreq0
	byte	$c3, $96, $f9, $f8
'-'            	shl	freqskip0,#8                	' and keep the fractional in freqskip0
	byte	$08, $86, $65, $f0
'-'            	add     pointer0,freqskip0 wcz      	' compute the pointer to the next sample   
	byte	$c3, $74, $19, $f1
'-'            	addx	pointer0h,afreq0  
	byte	$cb, $76, $21, $f1
'-'           	
'-'    	   	testb   sstart0, #27 wz
	byte	$1b, $7e, $0d, $f4
'-'     	if_nz	jmp #p412   	
	byte	$10, $00, $90, $5d
'-'    	if_c  	getrnd  spl
	byte	$1b, $6a, $61, $cd
'-'    	if_c	rolword rawspl0,spl,#0	
	byte	$b5, $7a, $41, $c9
'-'    		getword spl,rawspl0,#0
	byte	$bd, $6a, $31, $f9
'-'       	        jmp     #p406          	
	byte	$88, $00, $90, $fd
'-'            	
'-'            	
'-' p412 		cmp	pointer0h,oldptrh wcz
	byte	$ce, $76, $19, $f2
'-'  	if_e 	jmp 	#p411				' if the pointer didn't change, no sample has to be read
	byte	$50, $00, $90, $ad
'-'      	
'-'             	testb   sstart0,#31 wz       	   	' bit 31 : 16 bit sample  
	byte	$1f, $7e, $0d, $f4
'-'      	if_z    shl     pointer0h,#1        
	byte	$01, $76, $65, $a0
'-'             	testb   sstart0,#28 wz  		' bit 28 : interleaved sample         
	byte	$1c, $7e, $0d, $f4
'-'      	if_z    shl     pointer0h,#1        
	byte	$01, $76, $65, $a0
'-' 												
'-'             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
	byte	$c1, $76, $19, $f2
'-'    	if_ge   sub     pointer0h,lend0       
	byte	$c1, $76, $81, $31
'-'         if_ge   add     pointer0h,lstart0
	byte	$c0, $76, $01, $31
'-'             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
	byte	$c1, $76, $19, $f2
'-'         if_ge   mov	pointer0h,lend0	
	byte	$c1, $76, $01, $36
'-'  
'-'              	mov     qq,pointer0h              	' compute place in the memory from where the sample will be loaded
	byte	$bb, $68, $01, $f6
'-'            	add     qq,sstart0            
	byte	$bf, $68, $01, $f1
'-'            	cmps    mailbox,#$1FF wcz          	' the mailbox has to point somewhere not at the start of HUB RAM
	byte	$ff, $6d, $5d, $f2
'-'     	if_le   rdword  spl,qq                      	' if not, use HUB RAM for samples
	byte	$b4, $6a, $e1, $ea
'-'     	if_gt   call    #cache_read
	byte	$f8, $00, $b0, $1d
'-'                 testb   sstart0,#31 wz 
	byte	$1f, $7e, $0d, $f4
'-'     	if_nz   shl     spl,#8				' convert 8 to 16 bit if needed
	byte	$08, $6a, $65, $50
'-'         if_z    shr     pointer0h,#1
	byte	$01, $76, $45, $a0
'-'                 testb   sstart0,#28 wz            
	byte	$1c, $7e, $0d, $f4
'-'     	if_z    shr     pointer0h,#1    
	byte	$01, $76, $45, $a0
'-'                 rolword rawspl0,spl,#0			' now rawspl0 has oldsample:newsample in it
	byte	$b5, $7a, $41, $f9
'-'               
'-' p411	      	getword spl,rawspl0,#0
	byte	$bd, $6a, $31, $f9
'-' 		getword oldspl,rawspl0,#1		' then separate them		
	byte	$bd, $94, $39, $f9
'-' 
'-'          '    debug(uhex(pointer0h,pointer0,spl,oldspl))
'-' 
'-' 
'-' 		mov	envlo,pointer0
	byte	$ba, $e4, $01, $f6
'-' 		shr 	envlo,#18
	byte	$12, $e4, $45, $f0
'-' 	
'-'             	scas    spl,envlo                   	' and do linear interpolation
	byte	$f2, $6a, $31, $fa
'-'             	mov 	spl,0-0
	byte	$00, $6a, $01, $f6
'-'             	not     envlo
	byte	$f2, $e4, $21, $f6
'-'           	and     envlo,##$3FFF
	byte	$1f, $00, $00, $ff, $ff, $e5, $05, $f5
'-'            	scas    oldspl,envlo
	byte	$f2, $94, $31, $fa
'-'             	mov     oldspl,0-0
	byte	$00, $94, $01, $f6
'-'                 add     spl, oldspl
	byte	$ca, $6a, $01, $f1
'-' 	 
'-' p406        	scas    spl, envs1
	byte	$f3, $6a, $31, $fa
'-'             	mov     spl,0-0
	byte	$00, $6a, $01, $f6
'-'             	scas    spl,avol0                 	' apply volume
	byte	$cc, $6a, $31, $fa
'-'             	mov     spl,0-0
	byte	$00, $6a, $01, $f6
'-'  
'-'             	scas    spl,apan0                 	' apply pan
	byte	$cd, $6a, $31, $fa
'-'             	mov     ls0,0-0
	byte	$00, $a0, $01, $f6
'-'             	mov     qq,##16384
	byte	$20, $00, $00, $ff, $00, $68, $05, $f6
'-'             	sub     qq,apan0
	byte	$cd, $68, $81, $f1
'-'             	scas    spl,qq
	byte	$b4, $6a, $31, $fa
'-'             	mov     rs0, 0-0
	byte	$00, $a2, $01, $f6
'-'       
'-'                 setword sample0,rs0,#1           	' pack samples into long
	byte	$d1, $78, $29, $f9
'-'                 setword sample0,ls0,#0
	byte	$d0, $78, $21, $f9
'-'                 
'-'                 add  lsample,ls0
	byte	$d0, $70, $01, $f1
'-'                 add  rsample,rs0
	byte	$d1, $72, $01, $f1
'-'              
'-'             	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
	byte	$1e, $7e, $1d, $f4
'-'     	if_z    mov     pointer0, #0  
	byte	$00, $74, $05, $a6
'-'     	if_z    mov     pointer0h, #0  
	byte	$00, $76, $05, $a6
'-'     	if_z    mov     envph0, #0  
	byte	$00, $7c, $05, $a6
'-'     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
	byte	$05, $7f, $65, $ac
'-'             
'-' p403        	setq #4                          	' write new pointer, sample values and env pointer to the hub
	byte	$28, $08, $64, $fd
'-' 	       	wrlong  pointer0,ptra
	byte	$00, $75, $65, $fc
'-'             	sub     ptra, channeladd         	' reset the pointer to channel parameters
	byte	$b3, $f0, $83, $f1
'-' 
'-'             	djnf    cn, #p401
	byte	$87, $9f, $7d, $fb
'-' 
'-'             	bitnot rsample, #15
	byte	$0f, $72, $e5, $f4
'-'             	bitnot lsample, #15
	byte	$0f, $70, $e5, $f4
'-'   							'           	getct ct2  	'debug
'-'   							'          	sub ct2,ct1
'-'   							'          	debug(udec(ct2))
'-'             	waitse1
	byte	$24, $28, $60, $fd
'-'           
'-'            	wypin   lsample, #left              
	byte	$0e, $70, $25, $fc
'-'                 wypin   rsample, #right        
	byte	$0f, $72, $25, $fc
'-' 
'-' 		setword oldsample, lsample,#0		' for oscilloscope
	byte	$b8, $a4, $21, $f9
'-' 		setword oldsample, rsample,#1
	byte	$b9, $a4, $29, $f9
'-' 		
'-'             	mov rsample, #0
	byte	$00, $72, $05, $f6
'-'             	mov lsample, #0
	byte	$00, $70, $05, $f6
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- Oscilloscope  -----------------------------------------------------
'-' '----------------------------------------------------------------------------------   
'-' 		
'-' 	    	cmp     scbase,#0 wz
	byte	$00, $a6, $0d, $f2
'-'     	if_z    jmp #p302	   
	byte	$20, $00, $90, $ad
'-'  
'-'             	incmod  scope,#1 wc            		'  todo: scope speed instead of const  
	byte	$01, $ac, $15, $f7
'-'     	if_c    mov scptr2,scptr
	byte	$d4, $aa, $01, $c6
'-'     	if_c    shl scptr2,#2
	byte	$02, $aa, $65, $c0
'-'     	if_c    add scptr2,scbase     
	byte	$d3, $aa, $01, $c1
'-'             	wrlong scptr2,#$60
	byte	$60, $aa, $65, $fc
'-'     	if_c    wrlong oldsample,scptr2
	byte	$d5, $a4, $61, $cc
'-'     	if_c    incmod scptr,##639
	byte	$01, $00, $00, $cf, $7f, $a8, $05, $c7
'-'             
'-'  p302           jmp     #loop            'loop
	byte	$c8, $fd, $9f, $fd
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- This is the end of the main loop -----------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- PSRAM cache ----------- --------------------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' ' There are 16 cache pointers for 16 channels
'-' ' if 24 higher bits of address=cache, then get a word from the cache
'-' ' else load the cache from PSRAM, update the pointer, then read a sample
'-' 
'-' 
'-' cache_read  	getbyte addrlo,qq,#0 			' when this is called, qq is the addres of the sample			
	byte	$b4, $dc, $e1, $f8
'-'             
'-' 	   	mov     addrhi,qq		
	byte	$b4, $de, $01, $f6
'-' 	    	shr     addrhi,#8		        ' get 24 upper bits
	byte	$08, $de, $45, $f0
'-' 	    	alts    cn,#cache1            
	byte	$db, $9e, $95, $f9
'-' 	    	cmp	addrhi,0-0 wz               	' and compare with the cache pointer for the channel
	byte	$00, $de, $09, $f2
'-'     	if_z    jmp     #p701	    			' if equal, cache hit, read the sample from it
	byte	$34, $00, $90, $ad
'-' 	
'-' p702	    	altd    cn,#cache1			' cache miss. 
	byte	$db, $9e, $8d, $f9
'-' 	    	mov     0-0,addrhi                  	' update the pointer
	byte	$ef, $00, $00, $f6
'-' 	    	mov     cmd,addrhi			' prepare the mailbox
	byte	$ef, $d6, $01, $f6
'-' 	    	shl     cmd,#8
	byte	$08, $d6, $65, $f0
'-'             	setnib  cmd, #%1011, #7             	' read burst from the external memory
	byte	$0b, $d6, $3d, $f8
'-'             	mov     hubaddr,cn                  	' to the channel cache
	byte	$cf, $d8, $01, $f6
'-'             	shl     hubaddr,#8                  	'
	byte	$08, $d8, $65, $f0
'-'             	add     hubaddr,hubptr 
	byte	$d9, $d8, $01, $f1
'-'             	mov     count,#256                  	' 256 bytes
	byte	$00, $db, $05, $f6
'-'             	setq    #2                          	' write 3 longs
	byte	$28, $04, $64, $fd
'-'             	wrlong  cmd, mailbox                	' run it
	byte	$b6, $d6, $61, $fc
'-' poll1       	rdlong  cmd, mailbox                	' poll mailbox for result
	byte	$b6, $d6, $01, $fb
'-'             	tjs     cmd, #poll1                 	' retry until valid 
	byte	$fe, $d7, $b5, $fb
'-'             
'-' 	
'-' p701	    	mov     qq,cn				' cache hit
	byte	$cf, $68, $01, $f6
'-' 	    	shl     qq,#8				' compute the cache start
	byte	$08, $68, $65, $f0
'-' 	    	add     qq,hubptr
	byte	$d9, $68, $01, $f1
'-' 	    	add	qq,addrlo			' add 8 lower bits to the cache addredd
	byte	$ee, $68, $01, $f1
'-'     	_ret_   rdword  spl,qq                      	' read a long from the cache
	byte	$b4, $6a, $e1, $0a
'-'           
'-'   
'-' 
'-' 
'-' '---------------------------------------------------------------------------
'-' '------- Variables ---------------------------------------------------------
'-' '---------------------------------------------------------------------------
'-' 
'-' ' constants
'-' 
'-' channeladd 	long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' temporary variables 
'-' 
'-' qq          	long 0
	byte	$00, $00, $00, $00
'-' spl         	long 0
	byte	$00, $00, $00, $00
'-' mailbox     	long 0
	byte	$00, $00, $00, $00
'-' mailbox2    	long 0
	byte	$00, $00, $00, $00
'-' lsample     	long 0
	byte	$00, $00, $00, $00
'-' rsample     	long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' channel parameter block
'-' 
'-' pointer0    	long 0   
	byte	$00, $00, $00, $00
'-' pointer0h   	long 0  
	byte	$00, $00, $00, $00
'-' sample0     	long 0
	byte	$00, $00, $00, $00
'-' rawspl0	    	long 0
	byte	$00, $00, $00, $00
'-' envph0	    	long 0
	byte	$00, $00, $00, $00
'-' sstart0     	long 0     ' start pointer and type at bit 31
	byte	$00, $00, $00, $00
'-' lstart0     	long 0
	byte	$00, $00, $00, $00
'-' lend0       	long 0
	byte	$00, $00, $00, $00
'-' volpan0     	long 0
	byte	$00, $00, $00, $00
'-' freqskip0   	long 0
	byte	$00, $00, $00, $00
'-' command0    	long 0
	byte	$00, $00, $00, $00
'-' envptr0	    	long 0
	byte	$00, $00, $00, $00
'-' envspd0	    	long 0
	byte	$00, $00, $00, $00
'-' envlen0	    	long 0
	byte	$00, $00, $00, $00
'-' res5	    	long 0
	byte	$00, $00, $00, $00
'-' res6	    	long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldspl		long 0
	byte	$00, $00, $00, $00
'-' afreq0      	long 0
	byte	$00, $00, $00, $00
'-' 
'-' avol0       	long 0
	byte	$00, $00, $00, $00
'-' apan0       	long 0
	byte	$00, $00, $00, $00
'-' oldptrh	    	long 0
	byte	$00, $00, $00, $00
'-' cn          	long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' Samples
'-' 
'-' ls0         	long 0
	byte	$00, $00, $00, $00
'-' rs0         	long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldsample   	long 0
	byte	$00, $00, $00, $00
'-' 
'-' scbase 		long 0
	byte	$00, $00, $00, $00
'-' scptr 		long 0
	byte	$00, $00, $00, $00
'-' scptr2		long 0
	byte	$00, $00, $00, $00
'-' scope 		long 0
	byte	$00, $00, $00, $00
'-' 
'-' dac         	long %10111_00000000_01_00010_0     	'random dither
	byte	$44, $00, $17, $00
'-' dac2        	long %10111_00000000_01_00011_0     	'pwm
	byte	$46, $00, $17, $00
'-' 
'-' hubptr      	long $71800
	byte	$00, $18, $07, $00
'-' sr44100     	long 30*256
	byte	$00, $1e, $00, $00
'-' 
'-' cache1      	long 0
	byte	$00, $00, $00, $00
'-' cache2      	long 0
	byte	$00, $00, $00, $00
'-' cache3      	long 0
	byte	$00, $00, $00, $00
'-' cache4      	long 0
	byte	$00, $00, $00, $00
'-' cache5      	long 0
	byte	$00, $00, $00, $00
'-' cache6      	long 0
	byte	$00, $00, $00, $00
'-' cache7      	long 0
	byte	$00, $00, $00, $00
'-' cache8      	long 0
	byte	$00, $00, $00, $00
'-' cache9      	long 0
	byte	$00, $00, $00, $00
'-' cachea      	long 0
	byte	$00, $00, $00, $00
'-' cacheb      	long 0
	byte	$00, $00, $00, $00
'-' cachec      	long 0
	byte	$00, $00, $00, $00
'-' cached      	long 0
	byte	$00, $00, $00, $00
'-' cachee      	long 0
	byte	$00, $00, $00, $00
'-' cachef      	long 0
	byte	$00, $00, $00, $00
'-' cache0      	long 0
	byte	$00, $00, $00, $00
'-' 
'-' cmd         	long 0
	byte	$00, $00, $00, $00
'-' hubaddr    	long 0
	byte	$00, $00, $00, $00
'-' count       	long 256
	byte	$00, $01, $00, $00
'-' 
'-' addrlo 		long 0
	byte	$00, $00, $00, $00
'-' addrhi 		long 0
	byte	$00, $00, $00, $00
'-' pointer00 	long 0
	byte	$00, $00, $00, $00
'-' envhi 		long 0
	byte	$00, $00, $00, $00
'-' envlo 		long 0
	byte	$00, $00, $00, $00
'-' envs1 		long 0
	byte	$00, $00, $00, $00
'-' envs2 		long 0
	byte	$00, $00, $00, $00
'-' noise0 		long 0
	byte	$00, $00, $00, $00
'-' 
'-' 'ct1 		long 0
'-' 'ct2 		long 0
'-' 
'-' 		fit 256		'todo: maybe the better interpolation. Or all params in cog
'-' 		fit 256		'todo: maybe the better interpolation. Or all params in cog
'-' null  			long 	0,0           ' for channel reset
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	alignl
__system__dat_
	byte	$00[8]
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[660]
	long	(180 {__system____root_opendir})<<20
	long	(181 {__system____root_closedir})<<20
	long	(182 {__system____root_readdir})<<20
	long	(183 {__system____root_stat})<<20
	byte	$00[36]
	long	@@@__system__dat_ + 840
	long	@@@__system__dat_ + 843
	long	@@@__system__dat_ + 876
	long	@@@__system__dat_ + 901
	long	@@@__system__dat_ + 928
	long	@@@__system__dat_ + 954
	long	@@@__system__dat_ + 970
	long	@@@__system__dat_ + 988
	long	@@@__system__dat_ + 1006
	long	@@@__system__dat_ + 1024
	long	@@@__system__dat_ + 1036
	long	@@@__system__dat_ + 1053
	long	@@@__system__dat_ + 1073
	long	@@@__system__dat_ + 1083
	long	@@@__system__dat_ + 1099
	long	@@@__system__dat_ + 1114
	long	@@@__system__dat_ + 1136
	long	@@@__system__dat_ + 1161
	long	@@@__system__dat_ + 1181
	long	@@@__system__dat_ + 1195
	long	@@@__system__dat_ + 1215
	long	@@@__system__dat_ + 1227
	long	@@@__system__dat_ + 1245
	long	@@@__system__dat_ + 1269
	long	@@@__system__dat_ + 1287
	long	@@@__system__dat_ + 1306
	byte	$4f, $4b, $00, $4e, $75, $6d, $65, $72, $69, $63, $61, $6c, $20, $61, $72, $67
	byte	$75, $6d, $65, $6e, $74, $20, $6f, $75, $74, $20, $6f, $66, $20, $64, $6f, $6d
	byte	$61, $69, $6e, $00, $52, $65, $73, $75, $6c, $74, $20, $6e, $6f, $74, $20, $72
	byte	$65, $70, $72, $65, $73, $65, $6e, $74, $61, $62, $6c, $65, $00, $49, $6c, $6c
	byte	$65, $67, $61, $6c, $20, $6d, $75, $6c, $74, $69, $62, $79, $74, $65, $20, $73
	byte	$65, $71, $75, $65, $6e, $63, $65, $00, $4e, $6f, $20, $73, $75, $63, $68, $20
	byte	$66, $69, $6c, $65, $20, $6f, $72, $20, $64, $69, $72, $65, $63, $74, $6f, $72
	byte	$79, $00, $42, $61, $64, $20, $66, $69, $6c, $65, $20, $6e, $75, $6d, $62, $65
	byte	$72, $00, $50, $65, $72, $6d, $69, $73, $73, $69, $6f, $6e, $20, $64, $65, $6e
	byte	$69, $65, $64, $00, $4e, $6f, $74, $20, $65, $6e, $6f, $75, $67, $68, $20, $6d
	byte	$65, $6d, $6f, $72, $79, $00, $54, $65, $6d, $70, $6f, $72, $61, $72, $79, $20
	byte	$66, $61, $69, $6c, $75, $72, $65, $00, $46, $69, $6c, $65, $20, $65, $78, $69
	byte	$73, $74, $73, $00, $49, $6e, $76, $61, $6c, $69, $64, $20, $61, $72, $67, $75
	byte	$6d, $65, $6e, $74, $00, $54, $6f, $6f, $20, $6d, $61, $6e, $79, $20, $6f, $70
	byte	$65, $6e, $20, $66, $69, $6c, $65, $73, $00, $49, $2f, $4f, $20, $65, $72, $72
	byte	$6f, $72, $00, $4e, $6f, $74, $20, $61, $20, $64, $69, $72, $65, $63, $74, $6f
	byte	$72, $79, $00, $49, $73, $20, $61, $20, $64, $69, $72, $65, $63, $74, $6f, $72
	byte	$79, $00, $52, $65, $61, $64, $20, $6f, $6e, $6c, $79, $20, $66, $69, $6c, $65
	byte	$20, $73, $79, $73, $74, $65, $6d, $00, $46, $75, $6e, $63, $74, $69, $6f, $6e
	byte	$20, $6e, $6f, $74, $20, $69, $6d, $70, $6c, $65, $6d, $65, $6e, $74, $65, $64
	byte	$00, $44, $69, $72, $65, $63, $74, $6f, $72, $79, $20, $6e, $6f, $74, $20, $65
	byte	$6d, $70, $74, $79, $00, $4e, $61, $6d, $65, $20, $74, $6f, $6f, $20, $6c, $6f
	byte	$6e, $67, $00, $44, $65, $76, $69, $63, $65, $20, $6e, $6f, $74, $20, $73, $65
	byte	$65, $6b, $61, $62, $6c, $65, $00, $42, $61, $64, $20, $61, $64, $64, $72, $65
	byte	$73, $73, $00, $42, $72, $6f, $6b, $65, $6e, $20, $63, $6f, $6e, $6e, $65, $63
	byte	$74, $69, $6f, $6e, $00, $44, $65, $76, $69, $63, $65, $20, $6f, $72, $20, $72
	byte	$65, $73, $6f, $75, $72, $63, $65, $20, $62, $75, $73, $79, $00, $43, $72, $6f
	byte	$73, $73, $20, $64, $65, $76, $69, $63, $65, $20, $6c, $69, $6e, $6b, $00, $4e
	byte	$6f, $20, $73, $70, $61, $63, $65, $20, $6f, $6e, $20, $64, $65, $76, $69, $63
	byte	$65, $00, $55, $6e, $6b, $6e, $6f, $77, $6e, $20, $65, $72, $72, $6f, $72, $00
	byte	$00[12]
	byte	$01, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
	long	(213 {__system___tx})<<20
	long	(214 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(215 {__system___rxtxioctl_0788})<<20
	long	(216 {__system____dummy_flush_0789})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(213 {__system___tx})<<20
	long	(214 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(215 {__system___rxtxioctl_0788})<<20
	long	(216 {__system____dummy_flush_0789})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(213 {__system___tx})<<20
	long	(214 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(215 {__system___rxtxioctl_0788})<<20
	long	(216 {__system____dummy_flush_0789})<<20
	byte	$00[376]
	long	@@@__system__dat_ + 1856
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	alignl
_fatfs_cc_dat_
	byte	$c7, $00, $fc, $00, $e9, $00, $e2, $00, $e4, $00, $e0, $00, $e5, $00, $e7, $00
	byte	$ea, $00, $eb, $00, $e8, $00, $ef, $00, $ee, $00, $ec, $00, $c4, $00, $c5, $00
	byte	$c9, $00, $e6, $00, $c6, $00, $f4, $00, $f6, $00, $f2, $00, $fb, $00, $f9, $00
	byte	$ff, $00, $d6, $00, $dc, $00, $f8, $00, $a3, $00, $d8, $00, $d7, $00, $92, $01
	byte	$e1, $00, $ed, $00, $f3, $00, $fa, $00, $f1, $00, $d1, $00, $aa, $00, $ba, $00
	byte	$bf, $00, $ae, $00, $ac, $00, $bd, $00, $bc, $00, $a1, $00, $ab, $00, $bb, $00
	byte	$91, $25, $92, $25, $93, $25, $02, $25, $24, $25, $c1, $00, $c2, $00, $c0, $00
	byte	$a9, $00, $63, $25, $51, $25, $57, $25, $5d, $25, $a2, $00, $a5, $00, $10, $25
	byte	$14, $25, $34, $25, $2c, $25, $1c, $25, $00, $25, $3c, $25, $e3, $00, $c3, $00
	byte	$5a, $25, $54, $25, $69, $25, $66, $25, $60, $25, $50, $25, $6c, $25, $a4, $00
	byte	$f0, $00, $d0, $00, $ca, $00, $cb, $00, $c8, $00, $31, $01, $cd, $00, $ce, $00
	byte	$cf, $00, $18, $25, $0c, $25, $88, $25, $84, $25, $a6, $00, $cc, $00, $80, $25
	byte	$d3, $00, $df, $00, $d4, $00, $d2, $00, $f5, $00, $d5, $00, $b5, $00, $fe, $00
	byte	$de, $00, $da, $00, $db, $00, $d9, $00, $fd, $00, $dd, $00, $af, $00, $b4, $00
	byte	$ad, $00, $b1, $00, $17, $20, $be, $00, $b6, $00, $a7, $00, $f7, $00, $b8, $00
	byte	$b0, $00, $a8, $00, $b7, $00, $b9, $00, $b3, $00, $b2, $00, $a0, $25, $a0, $00
	byte	$61, $00, $1a, $03, $e0, $00, $17, $03, $f8, $00, $07, $03, $ff, $00, $01, $00
	byte	$78, $01, $00, $01, $30, $01, $32, $01, $06, $01, $39, $01, $10, $01, $4a, $01
	byte	$2e, $01, $79, $01, $06, $01, $80, $01, $4d, $00, $43, $02, $81, $01, $82, $01
	byte	$82, $01, $84, $01, $84, $01, $86, $01, $87, $01, $87, $01, $89, $01, $8a, $01
	byte	$8b, $01, $8b, $01, $8d, $01, $8e, $01, $8f, $01, $90, $01, $91, $01, $91, $01
	byte	$93, $01, $94, $01, $f6, $01, $96, $01, $97, $01, $98, $01, $98, $01, $3d, $02
	byte	$9b, $01, $9c, $01, $9d, $01, $20, $02, $9f, $01, $a0, $01, $a0, $01, $a2, $01
	byte	$a2, $01, $a4, $01, $a4, $01, $a6, $01, $a7, $01, $a7, $01, $a9, $01, $aa, $01
	byte	$ab, $01, $ac, $01, $ac, $01, $ae, $01, $af, $01, $af, $01, $b1, $01, $b2, $01
	byte	$b3, $01, $b3, $01, $b5, $01, $b5, $01, $b7, $01, $b8, $01, $b8, $01, $ba, $01
	byte	$bb, $01, $bc, $01, $bc, $01, $be, $01, $f7, $01, $c0, $01, $c1, $01, $c2, $01
	byte	$c3, $01, $c4, $01, $c5, $01, $c4, $01, $c7, $01, $c8, $01, $c7, $01, $ca, $01
	byte	$cb, $01, $ca, $01, $cd, $01, $10, $01, $dd, $01, $01, $00, $8e, $01, $de, $01
	byte	$12, $01, $f3, $01, $03, $00, $f1, $01, $f4, $01, $f4, $01, $f8, $01, $28, $01
	byte	$22, $02, $12, $01, $3a, $02, $09, $00, $65, $2c, $3b, $02, $3b, $02, $3d, $02
	byte	$66, $2c, $3f, $02, $40, $02, $41, $02, $41, $02, $46, $02, $0a, $01, $53, $02
	byte	$40, $00, $81, $01, $86, $01, $55, $02, $89, $01, $8a, $01, $58, $02, $8f, $01
	byte	$5a, $02, $90, $01, $5c, $02, $5d, $02, $5e, $02, $5f, $02, $93, $01, $61, $02
	byte	$62, $02, $94, $01, $64, $02, $65, $02, $66, $02, $67, $02, $97, $01, $96, $01
	byte	$6a, $02, $62, $2c, $6c, $02, $6d, $02, $6e, $02, $9c, $01, $70, $02, $71, $02
	byte	$9d, $01, $73, $02, $74, $02, $9f, $01, $76, $02, $77, $02, $78, $02, $79, $02
	byte	$7a, $02, $7b, $02, $7c, $02, $64, $2c, $7e, $02, $7f, $02, $a6, $01, $81, $02
	byte	$82, $02, $a9, $01, $84, $02, $85, $02, $86, $02, $87, $02, $ae, $01, $44, $02
	byte	$b1, $01, $b2, $01, $45, $02, $8d, $02, $8e, $02, $8f, $02, $90, $02, $91, $02
	byte	$b7, $01, $7b, $03, $03, $00, $fd, $03, $fe, $03, $ff, $03, $ac, $03, $04, $00
	byte	$86, $03, $88, $03, $89, $03, $8a, $03, $b1, $03, $11, $03, $c2, $03, $02, $00
	byte	$a3, $03, $a3, $03, $c4, $03, $08, $03, $cc, $03, $03, $00, $8c, $03, $8e, $03
	byte	$8f, $03, $d8, $03, $18, $01, $f2, $03, $0a, $00, $f9, $03, $f3, $03, $f4, $03
	byte	$f5, $03, $f6, $03, $f7, $03, $f7, $03, $f9, $03, $fa, $03, $fa, $03, $30, $04
	byte	$20, $03, $50, $04, $10, $07, $60, $04, $22, $01, $8a, $04, $36, $01, $c1, $04
	byte	$0e, $01, $cf, $04, $01, $00, $c0, $04, $d0, $04, $44, $01, $61, $05, $26, $04
	byte	$00, $00, $7d, $1d, $01, $00, $63, $2c, $00, $1e, $96, $01, $a0, $1e, $5a, $01
	byte	$00, $1f, $08, $06, $10, $1f, $06, $06, $20, $1f, $08, $06, $30, $1f, $08, $06
	byte	$40, $1f, $06, $06, $51, $1f, $07, $00, $59, $1f, $52, $1f, $5b, $1f, $54, $1f
	byte	$5d, $1f, $56, $1f, $5f, $1f, $60, $1f, $08, $06, $70, $1f, $0e, $00, $ba, $1f
	byte	$bb, $1f, $c8, $1f, $c9, $1f, $ca, $1f, $cb, $1f, $da, $1f, $db, $1f, $f8, $1f
	byte	$f9, $1f, $ea, $1f, $eb, $1f, $fa, $1f, $fb, $1f, $80, $1f, $08, $06, $90, $1f
	byte	$08, $06, $a0, $1f, $08, $06, $b0, $1f, $04, $00, $b8, $1f, $b9, $1f, $b2, $1f
	byte	$bc, $1f, $cc, $1f, $01, $00, $c3, $1f, $d0, $1f, $02, $06, $e0, $1f, $02, $06
	byte	$e5, $1f, $01, $00, $ec, $1f, $f3, $1f, $01, $00, $fc, $1f, $4e, $21, $01, $00
	byte	$32, $21, $70, $21, $10, $02, $84, $21, $01, $00, $83, $21, $d0, $24, $1a, $05
	byte	$30, $2c, $2f, $04, $60, $2c, $02, $01, $67, $2c, $06, $01, $75, $2c, $02, $01
	byte	$80, $2c, $64, $01, $00, $2d, $26, $08, $41, $ff, $1a, $03, $00, $00, $01, $03
	byte	$05, $07, $09, $0e, $10, $12, $14, $16, $18, $1c, $1e, $43, $55, $45, $41, $41
	byte	$41, $41, $43, $45, $45, $45, $49, $49, $49, $41, $41, $45, $92, $92, $4f, $4f
	byte	$4f, $55, $55, $59, $4f, $55, $4f, $9c, $4f, $9e, $9f, $41, $49, $4f, $55, $a5
	byte	$a5, $a6, $a7, $a8, $a9, $aa, $ab, $ac, $ad, $ae, $af, $b0, $b1, $b2, $b3, $b4
	byte	$41, $41, $41, $b8, $b9, $ba, $bb, $bc, $bd, $be, $bf, $c0, $c1, $c2, $c3, $c4
	byte	$c5, $41, $41, $c8, $c9, $ca, $cb, $cc, $cd, $ce, $cf, $d1, $d1, $45, $45, $45
	byte	$49, $49, $49, $49, $d9, $da, $db, $dc, $dd, $49, $df, $4f, $e1, $4f, $4f, $4f
	byte	$4f, $e6, $e8, $e8, $55, $55, $55, $59, $59, $ee, $ef, $f0, $f1, $f2, $f3, $f4
	byte	$f5, $f6, $f7, $f8, $f9, $fa, $fb, $fc, $fd, $fe, $ff, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $1f, $00, $00, $00, $1c, $00, $00, $00
	byte	$1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00
	byte	$1f, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00
	byte	$1e, $00, $00, $00, $1f, $00, $00, $00, $00, $00, $00, $00, $1f, $00, $00, $00
	byte	$3b, $00, $00, $00, $5a, $00, $00, $00, $78, $00, $00, $00, $97, $00, $00, $00
	byte	$b5, $00, $00, $00, $d4, $00, $00, $00, $f3, $00, $00, $00, $11, $01, $00, $00
	byte	$30, $01, $00, $00, $4e, $01, $00, $00, $6d, $01, $00, $00, $ff, $ff, $ff, $ff
	byte	$00[36]
	long	@@@_fatfs_cc_dat_ + 1266
	long	@@@_fatfs_cc_dat_ + 1270
	byte	$00[18]
	byte	$3f, $3f, $3f, $00, $55, $43, $54, $00, $55, $43, $54, $00, $00, $00, $00, $00
	byte	$00[7]
	byte	$ca, $9a, $3b, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$91, $11, $11, $11, $11, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$01[7]
	byte	$90, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
	byte	$42[10]
	byte	$20[7]
	byte	$44[6]
	byte	$04[20]
	byte	$20[6]
	byte	$48[6]
	byte	$08[20]
	byte	$20, $20, $20, $20, $01, $00, $00, $00, $00
__methodtable__
	long	@_do_no_command
	long	@_do_plus
	long	@_do_minus
	long	@_do_or
	long	@_do_mul
	long	@_do_fdiv
	long	@_do_and
	long	@_do_div
	long	@_do_mod
	long	@_do_shl
	long	@_do_shr
	long	@_do_power
	long	@_do_getvar
	long	@_do_push
	long	@_do_assign
	long	@_do_cls
	long	@_do_new
	long	@_do_plot
	long	@_do_draw
	long	@_do_print
	long	@_do_circle
	long	@_do_fcircle
	long	@_do_box
	long	@_do_frame
	long	@_do_color
	long	@_do_for
	long	@_do_next
	long	@_do_list
	long	@_do_run
	long	@_do_error
	long	@_do_fast_goto
	long	@_do_find_goto
	long	@_do_slow_goto
	long	@_do_nothing
	long	@_do_save
	long	@_do_load
	long	@_do_pinwrite
	long	@_do_waitms
	long	@_do_waitvbl
	long	@_do_if
	long	@_do_else
	long	@_do_eq
	long	@_do_ge
	long	@_do_le
	long	@_do_gt
	long	@_do_lt
	long	@_do_ne
	long	@_do_rnd
	long	@_do_brun
	long	@_do_beep
	long	@_do_dir
	long	@_do_paper
	long	@_do_ink
	long	@_do_font
	long	@_do_mode
	long	@_do_mouse
	long	@_do_gettime
	long	@_do_cursor
	long	@_do_click
	long	@_do_mousex
	long	@_do_mousey
	long	@_do_mousek
	long	@_do_mousew
	long	@_do_sin
	long	@_do_stick
	long	@_do_strig
	long	@_do_sprite
	long	@_do_defsprite
	long	@_do_getpixel
	long	@_do_waitclock
	long	@_do_negative
	long	@_do_rdpin
	long	@_do_rqpin
	long	@_do_pinread
	long	@_do_wrpin
	long	@_do_wxpin
	long	@_do_wypin
	long	@_do_pinfloat
	long	@_do_pinlo
	long	@_do_pinhi
	long	@_do_pinstart
	long	@_do_pintoggle
	long	@_do_position
	long	@_do_cos
	long	@_do_tan
	long	@_do_atn
	long	@_do_asin
	long	@_do_acos
	long	@_do_sqr
	long	@_do_fill
	long	@_do_defsnd
	long	@_do_defenv
	long	@_do_rad
	long	@_do_deg
	long	@_do_int
	long	@_do_play
	long	@_do_setdelay
	long	@_do_setenv
	long	@_do_setlen
	long	@_do_setpan
	long	@_do_setvol
	long	@_do_setwave
	long	@_do_setsustain
	long	@_do_release
	long	@_do_getenvsustain
	long	@_do_poke
	long	@_do_dpoke
	long	@_do_lpoke
	long	@_do_peek
	long	@_do_dpeek
	long	@_do_lpeek
	long	@_do_fre
	long	@_do_getnotevalue
	long	@_do_getaddr
	long	@_do_inkey
	long	@_do_abs
	long	@_do_hex
	long	@_do_bin
	long	@_do_val
	long	@_do_chr
	long	@_do_asc
	long	@_do_left
	long	@_do_right
	long	@_do_mid
	long	@_do_len
	long	@_do_gosub
	long	@_do_return
	long	@_do_end
	long	@_do_pop
	long	@_do_log
	long	@_do_changevol
	long	@_do_changewav
	long	@_do_changepan
	long	@_do_changefreq
	long	@_do_shutup
	long	@_do_round
	long	@_do_enter
	long	@_do_open
	long	@_do_close
	long	@_do_get
	long	@_do_put
	long	@_do_cd
	long	@_do_delete
	long	@_do_mkdir
	long	@_do_blit
	long	@_do_framebuf
	long	@_do_on
	long	@_do_skip
	long	@_do_input
	long	@_do_read
	long	@_do_restore
	long	@_do_padx
	long	@_do_pady
	long	@_do_padz
	long	@_do_padrx
	long	@_do_padry
	long	@_do_padrz
	long	@_do_padw
	long	@_do_pads
	long	@_do_copy
	long	@_do_coginit
	long	@_do_cogstop
	long	@_do_memlo
	long	@_do_memtop
	long	@_do_setcolor
	long	@_do_getcolor
	long	@_do_defchar
	long	@_do_restorepalette
	long	@_do_findfirst
	long	@_do_findnext
	long	@_do_setamode
	long	@_do_getrealfreq
	long	@_do_str
	long	@_Hg010b_4_spin2_putchar
	long	@__system___struct___bas_wrap_sender_tx_
	long	@__system___struct___bas_wrap_sender_rx_
	long	@__system___struct___bas_wrap_sender_close_
	long	@__system___struct__s_vfs_file_t_putchar_
	long	@__system___struct__s_vfs_file_t_getchar_
	long	@__system____strs_cl_pfunc_
	long	@__system____root_opendir
	long	@__system____root_closedir
	long	@__system____root_readdir
	long	@__system____root_stat
	long	@__system____default_putc
	long	@__system____default_getc
	long	@__system____default_flush
	long	@_fatfs_cc_v_close
	long	@_fatfs_cc_v_read
	long	@_fatfs_cc_v_write
	long	@_fatfs_cc_v_lseek
	long	@_fatfs_cc_v_ioctl
	long	@_fatfs_cc_v_flush
	long	@_fatfs_cc_v_open
	long	@_fatfs_cc_v_creat
	long	@_fatfs_cc_v_opendir
	long	@_fatfs_cc_v_closedir
	long	@_fatfs_cc_v_readdir
	long	@_fatfs_cc_v_stat
	long	@_fatfs_cc_v_mkdir
	long	@_fatfs_cc_v_rmdir
	long	@_fatfs_cc_v_remove
	long	@_fatfs_cc_v_rename
	long	@_fatfs_cc_v_init
	long	@_fatfs_cc_v_deinit
	long	@_sdmm_cc_v_read
	long	@_sdmm_cc_v_write
	long	@_sdmm_cc_v_close
	long	@_sdmm_cc_v_ioctl
	long	@_sdmm_cc_v_flush
	long	@_sdmm_cc_v_lseek
	long	@_sdmm_cc_v_putc
	long	@_sdmm_cc_v_getc
	long	@__system___tx
	long	@__system___rx
	long	@__system___rxtxioctl_0788
	long	@__system____dummy_flush_0789
__heap_base
	long	0[24002]
objmem
	long	0[10815]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
_var03
	res	1
_var04
	res	1
_var05
	res	1
_var06
	res	1
_var07
	res	1
_var08
	res	1
_var09
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
arg05
	res	1
arg06
	res	1
arg07
	res	1
arg08
	res	1
arg09
	res	1
arg10
	res	1
local01
	res	1
local02
	res	1
local03
	res	1
local04
	res	1
local05
	res	1
local06
	res	1
local07
	res	1
local08
	res	1
local09
	res	1
local10
	res	1
local11
	res	1
local12
	res	1
local13
	res	1
local14
	res	1
local15
	res	1
local16
	res	1
local17
	res	1
local18
	res	1
local19
	res	1
local20
	res	1
local21
	res	1
local22
	res	1
local23
	res	1
local24
	res	1
local25
	res	1
local26
	res	1
local27
	res	1
local28
	res	1
local29
	res	1
local30
	res	1
local31
	res	1
local32
	res	1
local33
	res	1
local34
	res	1
local35
	res	1
local36
	res	1
local37
	res	1
local38
	res	1
local39
	res	1
local40
	res	1
local41
	res	1
local42
	res	1
local43
	res	1
local44
	res	1
local45
	res	1
local46
	res	1
local47
	res	1
local48
	res	1
local49
	res	1
local50
	res	1
local51
	res	1
local52
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	480
