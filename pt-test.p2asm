con
	_clkfreq = 338695652
	_clkmode = 28773115
' _clkfreq=338688000
' c4=262
	c4 = 262
' d4=294
	d4 = 294
' e4=330
	e4 = 330
' f4=349
	f4 = 349
' g4=392
	g4 = 392
' a4=440
	a4 = 440
' h4=494
	h4 = 494
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 338695652
	long	0 ' clock mode: will default to $1b70afb
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##28773112
	waitx	##200000
	mov	pa, ##28773115
	hubset	pa
	wrlong	pa, #24
	wrlong	##338695652, #20
	jmp	#skip_clock_set_
	orgf	192
skip_clock_set_
	call	#_drivertest
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    mov	fcache_tmpb_,ptrb
    pop	ptrb
    altd	pa,ret_instr_
    mov	 0-0, ret_instr_
    setq	pa
    rdlong	$0, ptrb++
    push	ptrb
    mov ptrb,fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    _ret_ cmp inb,#0
fcache_tmpb_
    long 0
fcache_load_ptr_
    long FCACHE_LOAD_
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret
COUNT_
    long 0
RETADDR_
    long 0
fp
    long 0
pushregs_
    pop  pa
    pop  RETADDR_
    tjz  COUNT_, #pushregs_done_
    altd  COUNT_, #511
    setq #0-0
    wrlong local01, ptra++
pushregs_done_
    setq #2 ' push 3 registers starting at COUNT_
    wrlong COUNT_, ptra++
    mov    fp, ptra
    jmp  pa
 popregs_
    pop    pa
    setq   #2
    rdlong COUNT_, --ptra
    djf    COUNT_, #popregs__ret
    setq   COUNT_
    rdlong local01, --ptra
popregs__ret
    push   RETADDR_
    jmp    pa

objptr
	long	@objmem
ptr__Audio2_004_dat__
	long	@_Audio2_004_dat_
ptr__dat__
	long	@_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
result2
	long	1
result3
	long	2
result4
	long	3
COG_BSS_START
	fit	480
	orgh
hubentry

' 
' pub drivertest()   : cog,base,i,j
_drivertest
	mov	COUNT_, #2
	call	#pushregs_
' ' prepare 8-bit saw wave
' repeat i from $40000 to $407FF step 2
	decod	local01, #18
	callpa	#(@LR__0002-@LR__0001)>>2,fcache_load_ptr_
LR__0001
'   j:=@waveform+i-$40000+16
	mov	local02, ptr__dat__
	add	local02, local01
	sub	local02, ##262128
'   word[i]:=word[j]
	rdword	local02, local02
	wrword	local02, local01
	add	local01, #2
	cmps	local01, ##264192 wc
 if_b	jmp	#LR__0001
LR__0002
'  ' debug(sdec(word[i]))
' ' start the driver. It will generate scope data at $60000. It will not use any PSRAM
' repeat i from $41000 to $411FF step 2
	mov	local01, ##266240
	add	ptr__dat__, ##2064
	callpa	#(@LR__0004-@LR__0003)>>2,fcache_load_ptr_
LR__0003
'   j:=@envelope+((i-$41000)>>1)+16
	mov	local02, ptr__dat__
	mov	arg09, local01
	sub	arg09, ##266240
	shr	arg09, #1
	add	local02, arg09
	add	local02, #16
'   word[i]:=byte[j]<<8
	rdbyte	local02, local02
	shl	local02, #8
	wrword	local02, local01
	add	local01, #2
	cmps	local01, ##266752 wc
 if_b	jmp	#LR__0003
LR__0004
	sub	ptr__dat__, ##2064
'   
' cog, base:=audio.start(0,$60000,$61000)
	mov	arg01, #0
	mov	arg02, ##393216
	mov	arg03, ##397312
	add	objptr, #4
	call	#_Audio2_004_start
	sub	objptr, #4
' 'debug(udec(cog,base))
' 
' {{Channel registers:
' }}
' 
' ' tell it to play
' 
' {{repeat i from 0 to 15 
' }}
' 
' sample[0]:=-32767
	wrword	##32769, objptr
' sample[1]:=32767
	add	objptr, #2
	wrword	##32767, objptr
	sub	objptr, #2
' audio.beep(0,@sample ,4408,4096,4,0,0) 
	mov	arg01, #0
	mov	arg02, objptr
	mov	arg03, ##4408
	decod	arg04, #12
	mov	arg05, #4
	mov	arg06, #0
	mov	arg07, #0
	add	objptr, #4
	call	#_Audio2_004_beep
' 
' repeat
LR__0005
	jmp	#LR__0005
' 
' 
' repeat
LR__0006
'    audio.play(0,c4*1000,200,4096,$40000,$41000,600) ' (channel, frequency, delay, volume, waveform, envelope, length, pan, sustain) 
	mov	arg01, #0
	mov	arg02, ##262000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(1,d4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #1
	mov	arg02, ##294000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(2,e4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #2
	mov	arg02, ##330000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(3,f4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #3
	mov	arg02, ##349000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(4,g4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #4
	mov	arg02, ##392000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(5,a4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #5
	mov	arg02, ##440000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(6,h4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #6
	mov	arg02, ##494000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(7,c4*2000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #7
	mov	arg02, ##524000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(8,c4*2000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #8
	mov	arg02, ##524000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(9,h4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #9
	mov	arg02, ##494000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(10,a4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #10
	mov	arg02, ##440000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(11,g4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #11
	mov	arg02, ##392000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(12,f4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #12
	mov	arg02, ##349000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(13,e4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #13
	mov	arg02, ##330000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(14,d4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #14
	mov	arg02, ##294000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
'    audio.play(15,c4*1000,200,4096,$40000,$41000,600) '16(channel,sample,splfreq,vol,len,loop,delay) 
	mov	arg01, #15
	mov	arg02, ##262000
	mov	arg03, #200
	decod	arg04, #12
	decod	arg05, #18
	mov	arg06, ##266240
	mov	arg07, ##600
	neg	arg08, #1
	neg	arg09, #1
	call	#_Audio2_004_play
	jmp	#LR__0006
	mov	ptra, fp
	call	#popregs_
_drivertest_ret
	ret

' 
' '--------------------------------------------------------------
' '---------- Init the variables, start the cog. ----------------
' '--------------------------------------------------------------
' 
' pub start(mbox,scope,cache) :cog,base | iii
_Audio2_004_start
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' ' mbox: PSRAM mailbox or 0 if no PSRAM
' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
' 
' mailboxaddr:=mbox 
	wrlong	local01, objptr
' scope_ptr:=scope
	add	objptr, #4
	wrlong	arg02, objptr
' cache_ptr:=cache
	add	objptr, #4
	wrlong	arg03, objptr
' base:=@channel0[0]
	add	objptr, #4
	mov	local02, objptr
' 
' repeat iii from 0 to 15
	mov	local03, #0
	sub	objptr, #12
	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
LR__0010
'   long[base+64*iii]:=0
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	wrlong	#0, local01
'   long[base+64*iii+4]:=0  		
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	add	local01, #4
	wrlong	#0, local01
'   long[base+64*iii+8]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #8
	wrlong	#0, local04
'   long[base+64*iii+12]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #12
	wrlong	#0, local04
'   long[base+64*iii+16]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #16
	wrlong	#0, local04
'   long[base+64*iii+20]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #20
	wrlong	#0, local04
'   long[base+64*iii+24]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #24
	wrlong	#0, local04
'   long[base+64*iii+28]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #28
	wrlong	#0, local04
'   word[base+64*iii+32]:=8192
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #32
	wrword	##8192, local04
'   word[base+64*iii+34]:=8192
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #34
	wrword	##8192, local04
'   long[base+64*iii+36]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #36
	wrlong	#0, local04
'   long[base+64*iii+40]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #40
	wrlong	#0, local04
'   long[base+64*iii+44]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #44
	wrlong	#0, local04
'   long[base+64*iii+48]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #48
	wrlong	#0, local04
'   long[base+64*iii+52]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #52
	wrlong	#0, local04
'   freqs[iii]:=440000
	mov	local04, local03
	shl	local04, #2
	add	objptr, ##1036
	add	local04, objptr
	wrlong	##440000, local04
'   delays[iii]:=0
	mov	local04, local03
	shl	local04, #1
	add	objptr, #64
	add	local04, objptr
	wrword	#0, local04
'   volumes[iii]:=4096
	mov	local04, local03
	shl	local04, #1
	add	objptr, #32
	add	local04, objptr
	wrword	##4096, local04
'   waveforms[iii]:=0
	mov	local04, local03
	shl	local04, #2
	add	objptr, #32
	add	local04, objptr
	wrlong	#0, local04
'   envelopes[iii]:=0
	mov	local04, local03
	shl	local04, #2
	add	objptr, #64
	add	local04, objptr
	wrlong	#0, local04
'   lengths[iii]:=1000
	mov	local04, local03
	shl	local04, #1
	add	objptr, #64
	add	local04, objptr
	wrword	##1000, local04
'   pans[iii]:=8192
	mov	local04, local03
	shl	local04, #1
	add	objptr, #32
	add	local04, objptr
	wrword	##8192, local04
'   sustains[iii]:=255
	mov	local04, local03
	shl	local04, #1
	add	objptr, #32
	add	local04, objptr
	wrword	#255, local04
	add	local03, #1
	cmps	local03, #16 wc
	sub	objptr, ##1356
 if_b	jmp	#LR__0010
LR__0011
'   
' cog:=coginit(16,@audio,@mailboxaddr)
	mov	arg02, ptr__Audio2_004_dat__
	mov	arg03, objptr
	mov	local04, #16
	setq	arg03
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
' waitms(10)
	mov	arg01, #10
	call	#__system___waitms
' return cog,base
	mov	result2, local02
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_Audio2_004_start_ret
	ret

' 
' pub play (channel, frequency=-1, delay=-1, volume=-1, waveform=-1, envelope=-1, length=-1, pan=-1, sustain=-1) | base2
_Audio2_004_play
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
	mov	local06, arg06
	mov	local07, arg07
	mov	local08, arg08
	mov	local09, arg09
' 
' if frequency==(-1)
	cmp	local02, ##-1 wz
 if_ne	jmp	#LR__0020
'   frequency:=freqs[channel]
	mov	local02, local01
	shl	local02, #2
	mov	local10, objptr
	add	local10, ##1036
	add	local02, local10
	rdlong	local02, local02
	jmp	#LR__0021
LR__0020
' else
'   freqs[channel]:=frequency
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1036
	add	local11, local10
	wrlong	local02, local11
LR__0021
'   
' if delay==(-1)
	cmp	local03, ##-1 wz
 if_ne	jmp	#LR__0022
'   delay:=delays[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1100
	add	local10, local11
	rdword	local03, local10
	jmp	#LR__0023
LR__0022
' else
'   delays[channel]:=delay
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1100
	add	local10, local11
	wrword	local03, local10
LR__0023
'   
' if volume==(-1)      
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0024
'   volume:=volumes[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1132
	add	local10, local11
	rdword	local04, local10
	jmp	#LR__0025
LR__0024
' else
'   volumes[channel]:=volume
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1132
	add	local10, local11
	wrword	local04, local10
LR__0025
'   
' if waveform==(-1)
	cmp	local05, ##-1 wz
 if_ne	jmp	#LR__0026
'   waveform:=waveforms[channel]
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1164
	add	local11, local10
	rdlong	local05, local11
	jmp	#LR__0027
LR__0026
' else
'   waveforms[channel]:=waveform
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1164
	add	local11, local10
	wrlong	local05, local11
LR__0027
'   
' if envelope==(-1)
	cmp	local06, ##-1 wz
 if_ne	jmp	#LR__0028
'   envelope:=envelopes[channel]
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1228
	add	local11, local10
	rdlong	local06, local11
	jmp	#LR__0029
LR__0028
' else
'   envelopes[channel]:=envelope
	mov	local11, local01
	shl	local11, #2
	mov	local10, objptr
	add	local10, ##1228
	add	local11, local10
	wrlong	local06, local11
LR__0029
'   
' if length==(-1)
	cmp	local07, ##-1 wz
 if_ne	jmp	#LR__0030
'   length:=lengths[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1292
	add	local10, local11
	rdword	local07, local10
	jmp	#LR__0031
LR__0030
' else
'   lengths[channel]:=length
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1292
	add	local10, local11
	wrword	local07, local10
LR__0031
'   
' if pan==(-1)
	cmp	local08, ##-1 wz
 if_ne	jmp	#LR__0032
'   pan:=pans[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1324
	add	local10, local11
	rdword	local08, local10
	jmp	#LR__0033
LR__0032
' else
'   pans[channel]:=pan
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1324
	add	local10, local11
	wrword	local08, local10
LR__0033
'  
' if sustain==(-1)
	cmp	local09, ##-1 wz
 if_ne	jmp	#LR__0034
'   sustain:=sustains[channel]
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1356
	add	local10, local11
	rdword	local09, local10
	jmp	#LR__0035
LR__0034
' else
'   sustains[channel]:=sustain
	mov	local10, local01
	shl	local10, #1
	mov	local11, objptr
	add	local11, ##1356
	add	local10, local11
	wrword	local09, local10
LR__0035
	abs	local11, local07 wc
	qdiv	##24347887, local11
'                 
' length:=24347887/length  
	getqx	local11
	qmul	local02, #109
	negc	local07, local11
' debug(udec(sustain))
' base2:=@channel0[0]+64*channel
	mov	local02, objptr
	add	local02, #12
	shl	local01, #6
	add	local02, local01
' long[base2+20]:=waveform+$C0000000 
	add	local05, ##-1073741824
	mov	local10, local02
	add	local10, #20
	wrlong	local05, local10
' long[base2+28]:= 2048
	mov	local11, local02
	add	local11, #28
	wrlong	##2048, local11
' long[base2+24]:= 0
	mov	local11, local02
	add	local11, #24
	wrlong	#0, local11
' word[base2+32]:=volume
	mov	local11, local02
	add	local11, #32
	wrword	local04, local11
' word[base2+32]:=pan
	mov	local11, local02
	add	local11, #32
	wrword	local08, local11
' long[base2+36]:=((frequency*109)/1000)*3574 ' (frequency*389566)/1000  freq*3574*109/1000
	getqx	local11
	abs	local10, local11 wc
	qdiv	local10, ##1000
	getqx	local10
	negc	local10, local10
	qmul	local10, ##3574
	mov	local10, local02
	add	local10, #36
' long[base2+44]:=envelope
	mov	local11, local02
	add	local11, #44
' long[base2+48]:=length
' long[base2+52]:=sustain
' waitms(delay)
	mov	arg01, local03
	getqx	local08
	wrlong	local08, local10
	wrlong	local06, local11
	mov	local11, local02
	add	local11, #48
	wrlong	local07, local11
	add	local02, #52
	wrlong	local09, local02
	call	#__system___waitms
	mov	ptra, fp
	call	#popregs_
_Audio2_004_play_ret
	ret

' 
' pub beep(channel,sample,splfreq,vol,len,loop,delay) | base2
_Audio2_004_beep
	qmul	arg03, ##761
' 
' base2:=@channel0[0]+64*channel
	mov	arg03, objptr
	add	arg03, #12
	shl	arg01, #6
	add	arg03, arg01
' long[base2+20]:=sample+$C0000000 
	add	arg02, ##-1073741824
	mov	arg01, arg03
	add	arg01, #20
	wrlong	arg02, arg01
' long[base2+28]:= len
	mov	arg02, arg03
	add	arg02, #28
	wrlong	arg05, arg02
' long[base2+24]:= loop
	mov	arg05, arg03
	add	arg05, #24
	wrlong	arg06, arg05
' word[base2+32]:= vol
	mov	arg06, arg03
	add	arg06, #32
	wrword	arg04, arg06
' long[base2+36]:= splfreq*761
	add	arg03, #36
' waitms(delay)
	mov	arg01, arg07
	getqx	arg07
	wrlong	arg07, arg03
	call	#__system___waitms
_Audio2_004_beep_ret
	ret
hubexit
	jmp	#cogexit

__system___waitms
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__0041-@LR__0040)>>2,fcache_load_ptr_
LR__0040
	cmps	_var01, ##1000 wc
 if_b	jmp	#LR__0042
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000
	jmp	#LR__0040
LR__0041
LR__0042
	cmps	_var01, #1 wc
 if_b	jmp	#LR__0043
	qmul	_var01, _var03
	mov	arg03, ##1000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	arg01
	addct1	arg01, _var02
	waitct1
LR__0043
__system___waitms_ret
	ret
	alignl
_dat_
'-' waveform file "glocke.s2"
	byte	$73, $32, $00, $04, $00, $00, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $ab, $04, $52, $09, $f4, $0d, $8c, $12, $19, $17, $97, $1b, $03, $20
	byte	$5b, $24, $9c, $28, $c3, $2c, $ce, $30, $ba, $34, $86, $38, $2f, $3c, $b3, $3f
	byte	$10, $43, $45, $46, $51, $49, $31, $4c, $e5, $4e, $6b, $51, $c3, $53, $ed, $55
	byte	$e7, $57, $b2, $59, $4d, $5b, $b8, $5c, $f4, $5d, $00, $5f, $df, $5f, $8f, $60
	byte	$13, $61, $6a, $61, $97, $61, $9a, $61, $76, $61, $2b, $61, $bb, $60, $28, $60
	byte	$74, $5f, $a1, $5e, $b0, $5d, $a4, $5c, $7f, $5b, $43, $5a, $f3, $58, $90, $57
	byte	$1c, $56, $9b, $54, $0e, $53, $77, $51, $d8, $4f, $34, $4e, $8d, $4c, $e5, $4a
	byte	$3d, $49, $97, $47, $f6, $45, $5a, $44, $c7, $42, $3c, $41, $bc, $3f, $47, $3e
	byte	$e0, $3c, $86, $3b, $3c, $3a, $01, $39, $d6, $37, $bd, $36, $b5, $35, $bf, $34
	byte	$db, $33, $09, $33, $49, $32, $9a, $31, $fe, $30, $73, $30, $f8, $2f, $8e, $2f
	byte	$34, $2f, $e8, $2e, $aa, $2e, $79, $2e, $55, $2e, $3b, $2e, $2c, $2e, $25, $2e
	byte	$26, $2e, $2d, $2e, $39, $2e, $49, $2e, $5c, $2e, $70, $2e, $84, $2e, $96, $2e
	byte	$a6, $2e, $b2, $2e, $b8, $2e, $b9, $2e, $b2, $2e, $a2, $2e, $88, $2e, $64, $2e
	byte	$34, $2e, $f7, $2d, $ae, $2d, $55, $2d, $ef, $2c, $78, $2c, $f2, $2b, $5c, $2b
	byte	$b5, $2a, $fd, $29, $34, $29, $5a, $28, $6e, $27, $72, $26, $65, $25, $47, $24
	byte	$19, $23, $dc, $21, $8f, $20, $34, $1f, $cb, $1d, $54, $1c, $d2, $1a, $44, $19
	byte	$ac, $17, $0b, $16, $61, $14, $b0, $12, $fa, $10, $3f, $0f, $80, $0d, $c0, $0b
	byte	$ff, $09, $3e, $08, $80, $06, $c5, $04, $0f, $03, $5f, $01, $b6, $ff, $16, $fe
	byte	$81, $fc, $f7, $fa, $7a, $f9, $0b, $f8, $ab, $f6, $5c, $f5, $1e, $f4, $f2, $f2
	byte	$db, $f1, $d7, $f0, $e9, $ef, $11, $ef, $4f, $ee, $a5, $ed, $13, $ed, $98, $ec
	byte	$36, $ec, $ed, $eb, $bd, $eb, $a5, $eb, $a7, $eb, $c1, $eb, $f3, $eb, $3d, $ec
	byte	$9f, $ec, $17, $ed, $a6, $ed, $4a, $ee, $03, $ef, $d0, $ef, $ae, $f0, $9f, $f1
	byte	$a0, $f2, $af, $f3, $cd, $f4, $f6, $f5, $2a, $f7, $68, $f8, $ad, $f9, $f8, $fa
	byte	$47, $fc, $99, $fd, $ec, $fe, $3f, $00, $8f, $01, $da, $02, $21, $04, $5f, $05
	byte	$95, $06, $c0, $07, $de, $08, $ef, $09, $f1, $0a, $e2, $0b, $c1, $0c, $8d, $0d
	byte	$45, $0e, $e8, $0e, $75, $0f, $ea, $0f, $48, $10, $8e, $10, $bb, $10, $cf, $10
	byte	$ca, $10, $ab, $10, $73, $10, $22, $10, $b9, $0f, $36, $0f, $9d, $0e, $ec, $0d
	byte	$25, $0d, $49, $0c, $59, $0b, $56, $0a, $42, $09, $1d, $08, $eb, $06, $ab, $05
	byte	$61, $04, $0e, $03, $b4, $01, $54, $00, $f2, $fe, $8f, $fd, $2d, $fc, $ce, $fa
	byte	$75, $f9, $24, $f8, $de, $f6, $a3, $f5, $78, $f4, $5d, $f3, $55, $f2, $63, $f1
	byte	$87, $f0, $c5, $ef, $1e, $ef, $93, $ee, $27, $ee, $db, $ed, $b1, $ed, $aa, $ed
	byte	$c7, $ed, $09, $ee, $71, $ee, $01, $ef, $b8, $ef, $98, $f0, $a0, $f1, $d1, $f2
	byte	$2b, $f4, $ad, $f5, $58, $f7, $2b, $f9, $25, $fb, $45, $fd, $8b, $ff, $f5, $01
	byte	$82, $04, $31, $07, $01, $0a, $ee, $0c, $f9, $0f, $1e, $13, $5c, $16, $b1, $19
	byte	$1a, $1d, $95, $20, $20, $24, $b8, $27, $5a, $2b, $05, $2f, $b6, $32, $6a, $36
	byte	$1e, $3a, $d0, $3d, $7d, $41, $22, $45, $be, $48, $4d, $4c, $cd, $4f, $3c, $53
	byte	$98, $56, $dd, $59, $0b, $5d, $1e, $60, $15, $63, $ee, $65, $a8, $68, $40, $6b
	byte	$b5, $6d, $07, $70, $32, $72, $38, $74, $16, $76, $cc, $77, $59, $79, $bd, $7a
	byte	$f7, $7b, $07, $7d, $ee, $7d, $aa, $7e, $3d, $7f, $a6, $7f, $e7, $7f, $ff, $7f
	byte	$f0, $7f, $ba, $7f, $5f, $7f, $df, $7e, $3b, $7e, $75, $7d, $8f, $7c, $89, $7b
	byte	$65, $7a, $25, $79, $ca, $77, $57, $76, $cb, $74, $2b, $73, $76, $71, $b0, $6f
	byte	$d9, $6d, $f3, $6b, $01, $6a, $04, $68, $fd, $65, $ef, $63, $dc, $61, $c4, $5f
	byte	$a9, $5d, $8d, $5b, $71, $59, $57, $57, $40, $55, $2d, $53, $20, $51, $19, $4f
	byte	$19, $4d, $22, $4b, $34, $49, $50, $47, $76, $45, $a8, $43, $e5, $41, $2e, $40
	byte	$83, $3e, $e4, $3c, $51, $3b, $cb, $39, $51, $38, $e3, $36, $81, $35, $2a, $34
	byte	$de, $32, $9d, $31, $65, $30, $37, $2f, $11, $2e, $f4, $2c, $dd, $2b, $cc, $2a
	byte	$c1, $29, $bb, $28, $b7, $27, $b7, $26, $b7, $25, $b9, $24, $ba, $23, $ba, $22
	byte	$b7, $21, $b1, $20, $a6, $1f, $97, $1e, $81, $1d, $64, $1c, $3f, $1b, $12, $1a
	byte	$db, $18, $9a, $17, $4f, $16, $f8, $14, $95, $13, $27, $12, $ab, $10, $23, $0f
	byte	$8e, $0d, $ec, $0b, $3c, $0a, $7f, $08, $b6, $06, $df, $04, $fc, $02, $0d, $01
	byte	$12, $ff, $0c, $fd, $fb, $fa, $e1, $f8, $be, $f6, $94, $f4, $62, $f2, $2a, $f0
	byte	$ed, $ed, $ad, $eb, $6b, $e9, $27, $e7, $e4, $e4, $a3, $e2, $65, $e0, $2c, $de
	byte	$fa, $db, $cf, $d9, $ae, $d7, $98, $d5, $8f, $d3, $95, $d1, $aa, $cf, $d1, $cd
	byte	$0c, $cc, $5b, $ca, $c1, $c8, $3e, $c7, $d5, $c5, $86, $c4, $53, $c3, $3e, $c2
	byte	$46, $c1, $6e, $c0, $b7, $bf, $20, $bf, $ac, $be, $5a, $be, $2c, $be, $21, $be
	byte	$3a, $be, $77, $be, $d8, $be, $5d, $bf, $07, $c0, $d4, $c0, $c4, $c1, $d6, $c2
	byte	$0a, $c4, $5f, $c5, $d4, $c6, $67, $c8, $18, $ca, $e5, $cb, $cd, $cd, $cd, $cf
	byte	$e5, $d1, $12, $d4, $53, $d6, $a5, $d8, $06, $db, $75, $dd, $ef, $df, $71, $e2
	byte	$fa, $e4, $88, $e7, $16, $ea, $a5, $ec, $30, $ef, $b6, $f1, $34, $f4, $a8, $f6
	byte	$10, $f9, $69, $fb, $b2, $fd, $e7, $ff, $08, $02, $12, $04, $03, $06, $da, $07
	byte	$95, $09, $32, $0b, $b1, $0c, $0f, $0e, $4c, $0f, $68, $10, $60, $11, $35, $12
	byte	$e6, $12, $73, $13, $dc, $13, $21, $14, $41, $14, $3e, $14, $18, $14, $d0, $13
	byte	$66, $13, $dc, $12, $33, $12, $6c, $11, $89, $10, $8b, $0f, $75, $0e, $47, $0d
	byte	$04, $0c, $ae, $0a, $47, $09, $d2, $07, $50, $06, $c5, $04, $32, $03, $9a, $01
	byte	$00, $00, $66, $fe, $ce, $fc, $3b, $fb, $b0, $f9, $2e, $f8, $b9, $f6, $52, $f5
	byte	$fc, $f3, $b9, $f2, $8b, $f1, $75, $f0, $77, $ef, $94, $ee, $cd, $ed, $24, $ed
	byte	$9a, $ec, $30, $ec, $e8, $eb, $c2, $eb, $bf, $eb, $df, $eb, $24, $ec, $8d, $ec
	byte	$1a, $ed, $cb, $ed, $a0, $ee, $98, $ef, $b4, $f0, $f1, $f1, $4f, $f3, $ce, $f4
	byte	$6b, $f6, $26, $f8, $fd, $f9, $ee, $fb, $f8, $fd, $19, $00, $4e, $02, $97, $04
	byte	$f0, $06, $58, $09, $cc, $0b, $4a, $0e, $d0, $10, $5b, $13, $ea, $15, $78, $18
	byte	$06, $1b, $8f, $1d, $11, $20, $8b, $22, $fa, $24, $5b, $27, $ad, $29, $ee, $2b
	byte	$1b, $2e, $33, $30, $33, $32, $1b, $34, $e8, $35, $99, $37, $2c, $39, $a1, $3a
	byte	$f6, $3b, $2a, $3d, $3c, $3e, $2c, $3f, $f9, $3f, $a3, $40, $28, $41, $89, $41
	byte	$c6, $41, $df, $41, $d4, $41, $a6, $41, $54, $41, $e0, $40, $49, $40, $92, $3f
	byte	$ba, $3e, $c2, $3d, $ad, $3c, $7a, $3b, $2b, $3a, $c2, $38, $3f, $37, $a5, $35
	byte	$f4, $33, $2f, $32, $56, $30, $6b, $2e, $71, $2c, $68, $2a, $52, $28, $31, $26
	byte	$06, $24, $d4, $21, $9b, $1f, $5d, $1d, $1c, $1b, $d9, $18, $95, $16, $53, $14
	byte	$13, $12, $d6, $0f, $9e, $0d, $6c, $0b, $42, $09, $1f, $07, $05, $05, $f4, $02
	byte	$ee, $00, $f3, $fe, $04, $fd, $21, $fb, $4a, $f9, $81, $f7, $c4, $f5, $14, $f4
	byte	$72, $f2, $dd, $f0, $55, $ef, $d9, $ed, $6b, $ec, $08, $eb, $b1, $e9, $66, $e8
	byte	$25, $e7, $ee, $e5, $c1, $e4, $9c, $e3, $7f, $e2, $69, $e1, $5a, $e0, $4f, $df
	byte	$49, $de, $46, $dd, $46, $dc, $47, $db, $49, $da, $49, $d9, $49, $d8, $45, $d7
	byte	$3f, $d6, $34, $d5, $23, $d4, $0c, $d3, $ef, $d1, $c9, $d0, $9b, $cf, $63, $ce
	byte	$22, $cd, $d6, $cb, $7f, $ca, $1d, $c9, $af, $c7, $35, $c6, $af, $c4, $1c, $c3
	byte	$7d, $c1, $d2, $bf, $1b, $be, $58, $bc, $8a, $ba, $b0, $b8, $cc, $b6, $de, $b4
	byte	$e7, $b2, $e7, $b0, $e0, $ae, $d3, $ac, $c0, $aa, $a9, $a8, $8f, $a6, $73, $a4
	byte	$57, $a2, $3c, $a0, $24, $9e, $11, $9c, $03, $9a, $fc, $97, $ff, $95, $0d, $94
	byte	$27, $92, $50, $90, $8a, $8e, $d5, $8c, $35, $8b, $a9, $89, $36, $88, $db, $86
	byte	$9b, $85, $77, $84, $71, $83, $8b, $82, $c5, $81, $21, $81, $a1, $80, $46, $80
	byte	$10, $80, $01, $80, $19, $80, $5a, $80, $c3, $80, $56, $81, $12, $82, $f9, $82
	byte	$09, $84, $43, $85, $a7, $86, $34, $88, $ea, $89, $c8, $8b, $ce, $8d, $f9, $8f
	byte	$4b, $92, $c0, $94, $58, $97, $12, $9a, $eb, $9c, $e2, $9f, $f5, $a2, $23, $a6
	byte	$68, $a9, $c4, $ac, $33, $b0, $b3, $b3, $42, $b7, $de, $ba, $83, $be, $30, $c2
	byte	$e2, $c5, $96, $c9, $4a, $cd, $fb, $d0, $a6, $d4, $48, $d8, $e0, $db, $6b, $df
	byte	$e6, $e2, $4f, $e6, $a4, $e9, $e2, $ec, $07, $f0, $12, $f3, $ff, $f5, $cf, $f8
	byte	$7e, $fb, $0b, $fe, $75, $00, $bb, $02, $db, $04, $d5, $06, $a8, $08, $53, $0a
	byte	$d5, $0b, $2f, $0d, $60, $0e, $68, $0f, $48, $10, $ff, $10, $8f, $11, $f7, $11
	byte	$39, $12, $56, $12, $4f, $12, $25, $12, $d9, $11, $6d, $11, $e2, $10, $3b, $10
	byte	$79, $0f, $9d, $0e, $ab, $0d, $a3, $0c, $88, $0b, $5d, $0a, $22, $09, $dc, $07
	byte	$8b, $06, $32, $05, $d3, $03, $71, $02, $0e, $01, $ac, $ff, $4c, $fe, $f2, $fc
	byte	$9f, $fb, $55, $fa, $15, $f9, $e3, $f7, $be, $f6, $aa, $f5, $a7, $f4, $b7, $f3
	byte	$db, $f2, $14, $f2, $63, $f1, $ca, $f0, $47, $f0, $de, $ef, $8d, $ef, $55, $ef
	byte	$36, $ef, $31, $ef, $45, $ef, $72, $ef, $b8, $ef, $16, $f0, $8b, $f0, $18, $f1
	byte	$bb, $f1, $73, $f2, $3f, $f3, $1e, $f4, $0f, $f5, $11, $f6, $22, $f7, $40, $f8
	byte	$6b, $f9, $a1, $fa, $df, $fb, $26, $fd, $71, $fe, $c1, $ff, $14, $01, $67, $02
	byte	$b9, $03, $08, $05, $53, $06, $98, $07, $d6, $08, $0a, $0a, $33, $0b, $51, $0c
	byte	$60, $0d, $61, $0e, $52, $0f, $30, $10, $fd, $10, $b6, $11, $5a, $12, $e9, $12
	byte	$61, $13, $c3, $13, $0d, $14, $3f, $14, $59, $14, $5b, $14, $43, $14, $13, $14
	byte	$ca, $13, $68, $13, $ed, $12, $5b, $12, $b1, $11, $ef, $10, $17, $10, $29, $0f
	byte	$25, $0e, $0e, $0d, $e2, $0b, $a4, $0a, $55, $09, $f5, $07, $86, $06, $09, $05
	byte	$7f, $03, $ea, $01, $4a, $00, $a1, $fe, $f1, $fc, $3b, $fb, $80, $f9, $c2, $f7
	byte	$01, $f6, $40, $f4, $80, $f2, $c1, $f0, $06, $ef, $50, $ed, $9f, $eb, $f5, $e9
	byte	$54, $e8, $bc, $e6, $2e, $e5, $ac, $e3, $35, $e2, $cc, $e0, $71, $df, $24, $de
	byte	$e7, $dc, $b9, $db, $9b, $da, $8e, $d9, $92, $d8, $a6, $d7, $cc, $d6, $03, $d6
	byte	$4b, $d5, $a4, $d4, $0e, $d4, $88, $d3, $11, $d3, $ab, $d2, $52, $d2, $09, $d2
	byte	$cc, $d1, $9c, $d1, $78, $d1, $5e, $d1, $4e, $d1, $47, $d1, $48, $d1, $4e, $d1
	byte	$5a, $d1, $6a, $d1, $7c, $d1, $90, $d1, $a4, $d1, $b7, $d1, $c7, $d1, $d3, $d1
	byte	$da, $d1, $db, $d1, $d4, $d1, $c5, $d1, $ab, $d1, $87, $d1, $56, $d1, $18, $d1
	byte	$cc, $d0, $72, $d0, $08, $d0, $8d, $cf, $02, $cf, $66, $ce, $b7, $cd, $f7, $cc
	byte	$25, $cc, $41, $cb, $4b, $ca, $43, $c9, $2a, $c8, $ff, $c6, $c4, $c5, $7a, $c4
	byte	$20, $c3, $b9, $c1, $44, $c0, $c4, $be, $39, $bd, $a6, $bb, $0a, $ba, $69, $b8
	byte	$c3, $b6, $1b, $b5, $73, $b3, $cc, $b1, $28, $b0, $89, $ae, $f2, $ac, $65, $ab
	byte	$e4, $a9, $70, $a8, $0d, $a7, $bd, $a5, $81, $a4, $5c, $a3, $50, $a2, $5f, $a1
	byte	$8c, $a0, $d8, $9f, $45, $9f, $d5, $9e, $8a, $9e, $66, $9e, $69, $9e, $96, $9e
	byte	$ed, $9e, $71, $9f, $21, $a0, $00, $a1, $0c, $a2, $48, $a3, $b3, $a4, $4e, $a6
	byte	$19, $a8, $13, $aa, $3d, $ac, $95, $ae, $1b, $b1, $cf, $b3, $af, $b6, $bb, $b9
	byte	$f0, $bc, $4d, $c0, $d1, $c3, $7a, $c7, $46, $cb, $32, $cf, $3d, $d3, $64, $d7
	byte	$a5, $db, $fd, $df, $69, $e4, $e7, $e8, $74, $ed, $0c, $f2, $ae, $f6, $55, $fb
'-' envelope file "percus.h2"
	byte	$68, $32, $00, $01, $00, $00, $08, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $fd, $fc, $fa, $f8, $f6, $f4, $f2, $f0, $ee, $ec, $ea, $e8, $e6, $e4, $e1
	byte	$df, $dd, $db, $d8, $d6, $d4, $d1, $cf, $cc, $ca, $c7, $c5, $c2, $bf, $bd, $ba
	byte	$b7, $b5, $b2, $b0, $ad, $aa, $a7, $a5, $a2, $a0, $9d, $9b, $99, $97, $95, $93
	byte	$91, $8f, $8d, $8c, $8a, $88, $86, $84, $82, $80, $7e, $7d, $7b, $79, $78, $76
	byte	$75, $73, $72, $70, $6f, $6e, $6d, $6b, $6a, $68, $67, $66, $64, $63, $62, $60
	byte	$5f, $5e, $5c, $5b, $5a, $59, $58, $57, $56, $55, $54, $53, $52, $51, $50, $4f
	byte	$4e, $4d, $4c, $4c, $4b, $4a, $49, $48, $47, $46, $45, $44, $43, $42, $41, $40
	byte	$3f, $3e, $3d, $3d, $3c, $3c, $3b, $3a, $3a, $39, $38, $38, $37, $36, $36, $35
	byte	$34, $34, $33, $32, $31, $31, $30, $2f, $2f, $2e, $2d, $2d, $2c, $2b, $2b, $2a
	byte	$29, $29, $28, $27, $27, $26, $25, $25, $24, $24, $23, $22, $22, $21, $20, $20
	byte	$1f, $1e, $1e, $1e, $1d, $1d, $1d, $1c, $1c, $1b, $1b, $1a, $19, $19, $18, $17
	byte	$17, $16, $15, $15, $14, $13, $13, $12, $11, $11, $10, $0f, $0f, $0e, $0d, $0d
	byte	$0c, $0c, $0b, $0b, $0b, $0a, $0a, $0a, $09, $09, $09, $08, $08, $08, $07, $07
	byte	$07, $06, $06, $06, $05, $05, $05, $04, $04, $04, $03, $03, $03, $02, $02, $02
	byte	$01, $01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	alignl
_Audio2_004_dat_
'-' 
'-' audio       	org     0
'-' 
'-'             	rdlong  mailbox2, ptra++     	' get start address of all mailboxes
	byte	$61, $69, $05, $fb
'-'             	rdlong  scbase, ptra++       	' get start address of scope buffer
	byte	$61, $a1, $05, $fb
'-'             	rdlong  hubptr, ptra++       	' get start address of PSRAM cache
	byte	$61, $ad, $05, $fb
'-' 
'-'             	cogid   pa                   	' compute cogid
	byte	$01, $ec, $63, $fd
'-'             	mul     pa, #12              	' and mailbox spacing
	byte	$0c, $ec, $07, $fa
'-'             	add     mailbox2, pa         	' add offset to find this COG's mailbox
	byte	$f6, $69, $01, $f1
'-'             	mov     mailbox, mailbox2     	' we need 2 copies of this to enable switching between hub and psram
	byte	$b4, $66, $01, $f6
'-' 
'-'             	wrpin   dac2,#left           	' PWM DACs at 44100@339 MHz
	byte	$0e, $aa, $05, $fc
'-'             	wxpin   sr44100,#left      	' 30*256
	byte	$0e, $ae, $15, $fc
'-'             	wrpin   dac2,#right
	byte	$0f, $aa, $05, $fc
'-'             	wxpin   sr44100,#right    
	byte	$0f, $ae, $15, $fc
'-'             	dirh    #left addpins 1
	byte	$41, $9c, $64, $fd
'-'             	setse1  #%001<<6 + left      	' Set the event - DAC empty
	byte	$20, $9c, $64, $fd
'-'  
'-'             
'-' '---------------------------------------------------------------------------------        
'-' '----------------- The main loop -------------------------------------------------
'-' '---------------------------------------------------------------------------------
'-' 
'-' loop       	mov 	    cn,#0 '7
	byte	$00, $98, $05, $f6
'-'               					'   waitx ##3300000  		'for debug
'-'             
'-' '----------------------------------------------------------------------------------
'-' '------------- Get parameters and execute commands if any -------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' 
'-' p401        	mov     channeladd,cn             	' compute the pointer to channel parameters block
	byte	$cc, $60, $01, $f6
'-'             	shl     channeladd,#6
	byte	$06, $60, $65, $f0
'-'             	add     ptra,channeladd
	byte	$b0, $f0, $03, $f1
'-' 
'-'             	setq    #13                       	' read parameters
	byte	$28, $1a, $64, $fd
'-'             	rdlong  pointer0,ptra
	byte	$00, $6f, $05, $fb
'-' p408        	bitl    command0,#31 wcz	      	' bit #31 command - set the DAC sample rate
	byte	$1f, $82, $1d, $f4
'-'     	if_nc   jmp     #p404                     	' if not set, proceed
	byte	$2c, $00, $90, $3d
'-'             	mov     qq,command0             	' get the new rate
	byte	$c1, $62, $01, $f6
'-'             	wxpin   qq,#left addpins 1        	' and program the pins
	byte	$4e, $62, $15, $fc
'-'             	getbyte qq,qq,#0 		      	' check if the rate is n*256
	byte	$b1, $62, $e1, $f8
'-'             	cmp     qq,#0 wz                         
	byte	$00, $62, $0d, $f2
'-'     	if_z    wrpin   dac2,#left addpins 1      	' if yes, set PWM DAC mode
	byte	$4e, $aa, $05, $ac
'-'     	if_nz   wrpin   dac,#left addpins 1       	' else set noise DAC mode
	byte	$4e, $a8, $05, $5c
'-'                 
'-'                	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
	byte	$1e, $78, $1d, $f4
'-'     	if_z    mov     pointer0, #0  
	byte	$00, $6e, $05, $a6
'-'     	if_z    mov     pointer0h, #0  
	byte	$00, $70, $05, $a6
'-'     	if_z    mov     envph0, #0  
	byte	$00, $76, $05, $a6
'-'     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
	byte	$05, $79, $65, $ac
'-'     	
'-' p404        	mov     qq,sstart0		     	' check if start>$80000
	byte	$bc, $62, $01, $f6
'-' 		and 	qq,##$7FFFFFF 
	byte	$ff, $ff, $03, $ff, $ff, $63, $05, $f5
'-'                 cmp 	qq,##$80000 wcz
	byte	$00, $04, $00, $ff, $00, $62, $1d, $f2
'-'     	if_ge   mov     mailbox,mailbox2          	' if yes, use PSRAM
	byte	$b4, $66, $01, $36
'-'     	if_lt   mov     mailbox,#0                	' if not, use HUB 
	byte	$00, $66, $05, $c6
'-' 
'-' p405           	getword apan0,volpan0,#1          	' extract vol,pan from longs 
	byte	$bf, $94, $39, $f9
'-'     	    	getword avol0,volpan0,#0
	byte	$bf, $92, $31, $f9
'-'     	    	
'-' '----------------------------------------------------------------------------------
'-' '------------- Compute the envelope, if exists ------------------------------------
'-' '----------------------------------------------------------------------------------
'-'             
'-'             	cmp     envptr0,#0 wcz     		' read the pointer
	byte	$00, $84, $1d, $f2
'-'     	if_z    mov     envs1,##$4000			' if 0, no envelope, load $4000=1 for scas
	byte	$20, $00, $00, $af, $00, $e0, $05, $a6
'-'     	if_z    jmp     #p410				' and run away	
	byte	$54, $00, $90, $ad
'-' 
'-'            	add     envph0,envspd0			' envelope PA update
	byte	$c3, $76, $01, $f1
'-'            	           
'-'       	    	mov     envhi, envph0			' move phase acc to high part of env pointer
	byte	$bb, $dc, $01, $f6
'-' 		shr     envhi,#6			' leave 10 bits in hi
	byte	$06, $dc, $45, $f0
'-' 	   	getword envlo,envhi,#0              	' and 16 bit in lo
	byte	$ee, $de, $31, $f9
'-' 	    	shr     envhi,#16			' move 10 bits of hi to the lower word
	byte	$10, $dc, $45, $f0
'-' 	    	cmp     envhi,envlen0 wcz		' compare this to envelope length
	byte	$c4, $dc, $19, $f2
'-' 	    											'debug(udec(envhi,envlen0))
'-'     	if_ge  	mov     envhi,envlen0			' if greater than, set it at envlen
	byte	$c4, $dc, $01, $36
'-'     	if_ge   mov     envlo,#0
	byte	$00, $de, $05, $36
'-'     	if_ge   mov     envph0,envlen0             	' and set envph0 at the end of the envelope
	byte	$c4, $76, $01, $36
'-'     	if_ge   shl     envph0,#22
	byte	$16, $76, $65, $30
'-' 
'-'             	mov 	envs1,envhi			' 10 high bits of PA is the offset to the envelope entry
	byte	$ee, $e0, $01, $f6
'-'             	shl 	envs1,#1                        ' these entries are 16 bit so multiply the offset by 2
	byte	$01, $e0, $65, $f0
'-'             	add 	envs1,envptr0                   ' and add it to the pointer
	byte	$c2, $e0, $01, $f1
'-'             	rdlong 	envs1,envs1			' and then read 2 entries in one rdlong
	byte	$f0, $e0, $01, $fb
'-'             	getword envs2,envs1,#1			' then separate them		
	byte	$f0, $e2, $39, $f9
'-'            	getword envs1,envs1,#0
	byte	$f0, $e0, $31, $f9
'-'             	mul     envs2,envlo                     ' and do linear interpolation based on lower bits of the offset
	byte	$ef, $e2, $01, $fa
'-'             	not     envlo
	byte	$ef, $de, $21, $f6
'-'             	mul     envs1,envlo
	byte	$ef, $e0, $01, $fa
'-'             	add     envs1,envs2
	byte	$f1, $e0, $01, $f1
'-'             	shr     envs1,#18			' we need only 14 bits for scas
	byte	$12, $e0, $45, $f0
'-'               
'-' '----------------------------------------------------------------------------------
'-' '------------- Generate the noise if bit 27 of the pointer is set -----------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' p410        	testb   sstart0, #27 wz
	byte	$1b, $78, $0d, $f4
'-'     	if_z    getrnd  spl
	byte	$1b, $64, $61, $ad
'-'     	if_z    jmp     #p406
	byte	$9c, $00, $90, $ad
'-'     	
'-' '----------------------------------------------------------------------------------
'-' '------------- Get the sample -----------------------------------------------------
'-' '----------------------------------------------------------------------------------    	
'-'  
'-' 		mov	oldptrh,pointer0h
	byte	$b8, $96, $01, $f6
'-'            	getbyte	afreq0,freqskip0,#3         	' the frequency is in 8:24 format, so get integer in afreq0
	byte	$c0, $90, $f9, $f8
'-'            	shl	freqskip0,#8                	' and keep the fractional in freqskip0
	byte	$08, $80, $65, $f0
'-'            	add     pointer0,freqskip0 wcz      	' compute the pointer to the next sample   
	byte	$c0, $6e, $19, $f1
'-'            	addx	pointer0h,afreq0  
	byte	$c8, $70, $21, $f1
'-'  		cmp	pointer0h,oldptrh wcz
	byte	$cb, $70, $19, $f2
'-'  	if_e 	jmp 	#p411				' if the pointer didn't change, no sample has to be read
	byte	$50, $00, $90, $ad
'-'      	
'-'             	testb   sstart0,#31 wz       	   	' bit 31 : 16 bit sample  
	byte	$1f, $78, $0d, $f4
'-'      	if_z    shl     pointer0h,#1        
	byte	$01, $70, $65, $a0
'-'             	testb   sstart0,#28 wz  		' bit 28 : interleaved sample         
	byte	$1c, $78, $0d, $f4
'-'      	if_z    shl     pointer0h,#1        
	byte	$01, $70, $65, $a0
'-' 												
'-'             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
	byte	$be, $70, $19, $f2
'-'    	if_ge   sub     pointer0h,lend0       
	byte	$be, $70, $81, $31
'-'         if_ge   add     pointer0h,lstart0
	byte	$bd, $70, $01, $31
'-'             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
	byte	$be, $70, $19, $f2
'-'         if_ge   mov	pointer0h,lend0	
	byte	$be, $70, $01, $36
'-'  
'-'              	mov     qq,pointer0h              	' compute place in the memory from where the sample will be loaded
	byte	$b8, $62, $01, $f6
'-'            	add     qq,sstart0            
	byte	$bc, $62, $01, $f1
'-'            	cmps    mailbox,#$1FF wcz          	' the mailbox has to point somewhere not at the start of HUB RAM
	byte	$ff, $67, $5d, $f2
'-'     	if_le   rdword  spl,qq                      	' if not, use HUB RAM for samples
	byte	$b1, $64, $e1, $ea
'-'     	if_gt   call    #cache_read
	byte	$f8, $00, $b0, $1d
'-'                 testb   sstart0,#31 wz 
	byte	$1f, $78, $0d, $f4
'-'     	if_nz   shl     spl,#8				' convert 8 to 16 bit if needed
	byte	$08, $64, $65, $50
'-'         if_z    shr     pointer0h,#1
	byte	$01, $70, $45, $a0
'-'                 testb   sstart0,#28 wz            
	byte	$1c, $78, $0d, $f4
'-'     	if_z    shr     pointer0h,#1    
	byte	$01, $70, $45, $a0
'-'                 rolword rawspl0,spl,#0			' now rawspl0 has oldsample:newsample in it
	byte	$b2, $74, $41, $f9
'-'              
'-'              
'-' 
'-'              
'-'                   
'-' p411	      	getword spl,rawspl0,#0
	byte	$ba, $64, $31, $f9
'-' 		getword oldspl,rawspl0,#1		' then separate them		
	byte	$ba, $8e, $39, $f9
'-' 
'-'          '    debug(uhex(pointer0h,pointer0,spl,oldspl))
'-' 
'-' 
'-' 		mov	envlo,pointer0
	byte	$b7, $de, $01, $f6
'-' 		shr 	envlo,#18
	byte	$12, $de, $45, $f0
'-' 	
'-'             	scas    oldspl,envlo                   	' and do linear interpolation
	byte	$ef, $8e, $31, $fa
'-'             	mov 	oldspl,0-0
	byte	$00, $8e, $01, $f6
'-'             	not     envlo
	byte	$ef, $de, $21, $f6
'-'           	and     envlo,##$3FFF
	byte	$1f, $00, $00, $ff, $ff, $df, $05, $f5
'-'            	scas    spl,envlo
	byte	$ef, $64, $31, $fa
'-'             	mov     spl,0-0
	byte	$00, $64, $01, $f6
'-'                 add     spl, oldspl
	byte	$c7, $64, $01, $f1
'-' 	 
'-' p406        	scas    spl, envs1
	byte	$f0, $64, $31, $fa
'-'             	mov     spl,0-0
	byte	$00, $64, $01, $f6
'-'             	scas    spl,avol0                 	' apply volume
	byte	$c9, $64, $31, $fa
'-'             	mov     spl,0-0
	byte	$00, $64, $01, $f6
'-'  
'-'             	scas    spl,apan0                 	' apply pan
	byte	$ca, $64, $31, $fa
'-'             	mov     ls0,0-0
	byte	$00, $9a, $01, $f6
'-'             	mov     qq,##16384
	byte	$20, $00, $00, $ff, $00, $62, $05, $f6
'-'             	sub     qq,apan0
	byte	$ca, $62, $81, $f1
'-'             	scas    spl,qq
	byte	$b1, $64, $31, $fa
'-'             	mov     rs0, 0-0
	byte	$00, $9c, $01, $f6
'-'       
'-'                 setword sample0,rs0,#1           	' pack samples into long
	byte	$ce, $72, $29, $f9
'-'                 setword sample0,ls0,#0
	byte	$cd, $72, $21, $f9
'-'                 
'-'                 add  lsample,ls0
	byte	$cd, $6a, $01, $f1
'-'                 add  rsample,rs0
	byte	$ce, $6c, $01, $f1
'-'              
'-'             	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
	byte	$1e, $78, $1d, $f4
'-'     	if_z    mov     pointer0, #0  
	byte	$00, $6e, $05, $a6
'-'     	if_z    mov     pointer0h, #0  
	byte	$00, $70, $05, $a6
'-'     	if_z    mov     envph0, #0  
	byte	$00, $76, $05, $a6
'-'     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
	byte	$05, $79, $65, $ac
'-'             
'-' p403        	setq #4                          	' write new pointer, sample values and env pointer to the hub
	byte	$28, $08, $64, $fd
'-' 	       	wrlong  pointer0,ptra
	byte	$00, $6f, $65, $fc
'-'             	sub     ptra, channeladd         	' reset the pointer to channel parameters
	byte	$b0, $f0, $83, $f1
'-' 
'-'             	djnf    cn, #p401
	byte	$8a, $99, $7d, $fb
'-' 
'-'             	bitnot rsample, #15
	byte	$0f, $6c, $e5, $f4
'-'             	bitnot lsample, #15
	byte	$0f, $6a, $e5, $f4
'-'   							'           	getct ct2  	'debug
'-'   							'          	sub ct2,ct1
'-'   							'          	debug(udec(ct2))
'-'             	waitse1
	byte	$24, $28, $60, $fd
'-'           
'-'            	wypin   lsample, #left              
	byte	$0e, $6a, $25, $fc
'-'                 wypin   rsample, #right        
	byte	$0f, $6c, $25, $fc
'-' 
'-' 		setword oldsample, lsample,#0		' for oscilloscope
	byte	$b5, $9e, $21, $f9
'-' 		setword oldsample, rsample,#1
	byte	$b6, $9e, $29, $f9
'-' 		
'-'             	mov rsample, #0
	byte	$00, $6c, $05, $f6
'-'             	mov lsample, #0
	byte	$00, $6a, $05, $f6
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- Oscilloscope  -----------------------------------------------------
'-' '----------------------------------------------------------------------------------   
'-' 		
'-' 	    	cmp     scbase,#0 wz
	byte	$00, $a0, $0d, $f2
'-'     	if_z    jmp #p302	   
	byte	$20, $00, $90, $ad
'-'  
'-'             	incmod  scope,#1 wc            		'  todo: scope speed instead of const  
	byte	$01, $a6, $15, $f7
'-'     	if_c    mov scptr2,scptr
	byte	$d1, $a4, $01, $c6
'-'     	if_c    shl scptr2,#2
	byte	$02, $a4, $65, $c0
'-'     	if_c    add scptr2,scbase     
	byte	$d0, $a4, $01, $c1
'-'             	wrlong scptr2,#$60
	byte	$60, $a4, $65, $fc
'-'     	if_c    wrlong oldsample,scptr2
	byte	$d2, $9e, $61, $cc
'-'     	if_c    incmod scptr,##639
	byte	$01, $00, $00, $cf, $7f, $a2, $05, $c7
'-'             
'-'  p302           jmp     #loop            'loop
	byte	$d4, $fd, $9f, $fd
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- This is the end of the main loop -----------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- PSRAM cache ----------- --------------------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' ' There are 16 cache pointers for 16 channels
'-' ' if 24 higher bits of address=cache, then get a word from the cache
'-' ' else load the cache from PSRAM, update the pointer, then read a sample
'-' 
'-' 
'-' cache_read  	getbyte addrlo,qq,#0 			' when this is called, qq is the addres of the sample			
	byte	$b1, $d6, $e1, $f8
'-'             
'-' 	   	mov     addrhi,qq		
	byte	$b1, $d8, $01, $f6
'-' 	    	shr     addrhi,#8		        ' get 24 upper bits
	byte	$08, $d8, $45, $f0
'-' 	    	alts    cn,#cache1            
	byte	$d8, $98, $95, $f9
'-' 	    	cmp	addrhi,0-0 wz               	' and compare with the cache pointer for the channel
	byte	$00, $d8, $09, $f2
'-'     	if_z    jmp     #p701	    			' if equal, cache hit, read the sample from it
	byte	$34, $00, $90, $ad
'-' 	
'-' p702	    	altd    cn,#cache1			' cache miss. 
	byte	$d8, $98, $8d, $f9
'-' 	    	mov     0-0,addrhi                  	' update the pointer
	byte	$ec, $00, $00, $f6
'-' 	    	mov     cmd,addrhi			' prepare the mailbox
	byte	$ec, $d0, $01, $f6
'-' 	    	shl     cmd,#8
	byte	$08, $d0, $65, $f0
'-'             	setnib  cmd, #%1011, #7             	' read burst from the external memory
	byte	$0b, $d0, $3d, $f8
'-'             	mov     hubaddr,cn                  	' to the channel cache
	byte	$cc, $d2, $01, $f6
'-'             	shl     hubaddr,#8                  	'
	byte	$08, $d2, $65, $f0
'-'             	add     hubaddr,hubptr 
	byte	$d6, $d2, $01, $f1
'-'             	mov     count,#256                  	' 256 bytes
	byte	$00, $d5, $05, $f6
'-'             	setq    #2                          	' write 3 longs
	byte	$28, $04, $64, $fd
'-'             	wrlong  cmd, mailbox                	' run it
	byte	$b3, $d0, $61, $fc
'-' poll1       	rdlong  cmd, mailbox                	' poll mailbox for result
	byte	$b3, $d0, $01, $fb
'-'             	tjs     cmd, #poll1                 	' retry until valid 
	byte	$fe, $d1, $b5, $fb
'-'             
'-' 	
'-' p701	    	mov     qq,cn				' cache hit
	byte	$cc, $62, $01, $f6
'-' 	    	shl     qq,#8				' compute the cache start
	byte	$08, $62, $65, $f0
'-' 	    	add     qq,hubptr
	byte	$d6, $62, $01, $f1
'-' 	    	add	qq,addrlo			' add 8 lower bits to the cache addredd
	byte	$eb, $62, $01, $f1
'-'     	_ret_   rdword  spl,qq                      	' read a long from the cache
	byte	$b1, $64, $e1, $0a
'-'           
'-'   
'-' 
'-' 
'-' '---------------------------------------------------------------------------
'-' '------- Variables ---------------------------------------------------------
'-' '---------------------------------------------------------------------------
'-' 
'-' ' constants
'-' 
'-' channeladd 	long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' temporary variables 
'-' 
'-' qq          	long 0
	byte	$00, $00, $00, $00
'-' spl         	long 0
	byte	$00, $00, $00, $00
'-' mailbox     	long 0
	byte	$00, $00, $00, $00
'-' mailbox2    	long 0
	byte	$00, $00, $00, $00
'-' lsample     	long 0
	byte	$00, $00, $00, $00
'-' rsample     	long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' channel parameter block
'-' 
'-' pointer0    	long 0   
	byte	$00, $00, $00, $00
'-' pointer0h   	long 0  
	byte	$00, $00, $00, $00
'-' sample0     	long 0
	byte	$00, $00, $00, $00
'-' rawspl0	    	long 0
	byte	$00, $00, $00, $00
'-' envph0	    	long 0
	byte	$00, $00, $00, $00
'-' sstart0     	long 0     ' start pointer and type at bit 31
	byte	$00, $00, $00, $00
'-' lstart0     	long 0
	byte	$00, $00, $00, $00
'-' lend0       	long 0
	byte	$00, $00, $00, $00
'-' volpan0     	long 0
	byte	$00, $00, $00, $00
'-' freqskip0   	long 0
	byte	$00, $00, $00, $00
'-' command0    	long 0
	byte	$00, $00, $00, $00
'-' envptr0	    	long 0
	byte	$00, $00, $00, $00
'-' envspd0	    	long 0
	byte	$00, $00, $00, $00
'-' envlen0	    	long 0
	byte	$00, $00, $00, $00
'-' res5	    	long 0
	byte	$00, $00, $00, $00
'-' res6	    	long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldspl		long 0
	byte	$00, $00, $00, $00
'-' afreq0      	long 0
	byte	$00, $00, $00, $00
'-' 
'-' avol0       	long 0
	byte	$00, $00, $00, $00
'-' apan0       	long 0
	byte	$00, $00, $00, $00
'-' oldptrh	    	long 0
	byte	$00, $00, $00, $00
'-' cn          	long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' Samples
'-' 
'-' ls0         	long 0
	byte	$00, $00, $00, $00
'-' rs0         	long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldsample   	long 0
	byte	$00, $00, $00, $00
'-' 
'-' scbase 		long 0
	byte	$00, $00, $00, $00
'-' scptr 		long 0
	byte	$00, $00, $00, $00
'-' scptr2		long 0
	byte	$00, $00, $00, $00
'-' scope 		long 0
	byte	$00, $00, $00, $00
'-' 
'-' dac         	long %10111_00000000_01_00010_0     	'random dither
	byte	$44, $00, $17, $00
'-' dac2        	long %10111_00000000_01_00011_0     	'pwm
	byte	$46, $00, $17, $00
'-' 
'-' hubptr      	long $71800
	byte	$00, $18, $07, $00
'-' sr44100     	long 30*256
	byte	$00, $1e, $00, $00
'-' 
'-' cache1      	long 0
	byte	$00, $00, $00, $00
'-' cache2      	long 0
	byte	$00, $00, $00, $00
'-' cache3      	long 0
	byte	$00, $00, $00, $00
'-' cache4      	long 0
	byte	$00, $00, $00, $00
'-' cache5      	long 0
	byte	$00, $00, $00, $00
'-' cache6      	long 0
	byte	$00, $00, $00, $00
'-' cache7      	long 0
	byte	$00, $00, $00, $00
'-' cache8      	long 0
	byte	$00, $00, $00, $00
'-' cache9      	long 0
	byte	$00, $00, $00, $00
'-' cachea      	long 0
	byte	$00, $00, $00, $00
'-' cacheb      	long 0
	byte	$00, $00, $00, $00
'-' cachec      	long 0
	byte	$00, $00, $00, $00
'-' cached      	long 0
	byte	$00, $00, $00, $00
'-' cachee      	long 0
	byte	$00, $00, $00, $00
'-' cachef      	long 0
	byte	$00, $00, $00, $00
'-' cache0      	long 0
	byte	$00, $00, $00, $00
'-' 
'-' cmd         	long 0
	byte	$00, $00, $00, $00
'-' hubaddr    	long 0
	byte	$00, $00, $00, $00
'-' count       	long 256
	byte	$00, $01, $00, $00
'-' 
'-' addrlo 		long 0
	byte	$00, $00, $00, $00
'-' addrhi 		long 0
	byte	$00, $00, $00, $00
'-' pointer00 	long 0
	byte	$00, $00, $00, $00
'-' envhi 		long 0
	byte	$00, $00, $00, $00
'-' envlo 		long 0
	byte	$00, $00, $00, $00
'-' envs1 		long 0
	byte	$00, $00, $00, $00
'-' envs2 		long 0
	byte	$00, $00, $00, $00
'-' noise0 		long 0
	byte	$00, $00, $00, $00
'-' 
'-' 'ct1 		long 0
'-' 'ct2 		long 0
'-' 
'-' 		fit 256		'todo: maybe the better interpolation. Or all params in cog
'-' 		fit 256		'todo: maybe the better interpolation. Or all params in cog
'-' null  			long 	0,0           ' for channel reset
	byte	$00, $00, $00, $00, $00, $00, $00, $00
objmem
	long	0[348]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
_var03
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
arg05
	res	1
arg06
	res	1
arg07
	res	1
arg08
	res	1
arg09
	res	1
local01
	res	1
local02
	res	1
local03
	res	1
local04
	res	1
local05
	res	1
local06
	res	1
local07
	res	1
local08
	res	1
local09
	res	1
local10
	res	1
local11
	res	1
	fit	480
