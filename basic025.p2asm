con
	_clkfreq = 337000000
	_clkmode = 21844219
	HEAPSIZE = 192000
	fbReadOnly = 1
	fbHidden = 2
	fbSystem = 4
	fbDirectory = 16
	fbArchive = 32
	fbNormal = 33
	ver = 25
	key_enter = 141
	key_escape = 155
	key_backspace = 136
	key_tab = 137
	key_f1 = 186
	key_f2 = 187
	key_f3 = 188
	key_f4 = 189
	key_f5 = 190
	key_f6 = 191
	key_f7 = 192
	key_f8 = 193
	key_f9 = 194
	key_f10 = 195
	key_f11 = 196
	key_f12 = 197
	key_rightarrow = 206
	key_leftarrow = 207
	key_downarrow = 208
	key_uparrow = 209
	token_plus = 1
	token_minus = 2
	token_or = 3
	token_xor = 4
	token_mul = 5
	token_fdiv = 6
	token_and = 7
	token_div = 8
	token_mod = 9
	token_shl = 10
	token_shr = 11
	token_power = 12
	token_not = 13
	token_at = 14
	token_gt = 15
	token_lt = 16
	token_comma = 17
	token_semicolon = 18
	token_ear = 19
	token_rpar = 20
	token_lpar = 21
	token_colon = 22
	fun_getvar = 17
	fun_getivar = 17
	fun_getuvar = 18
	fun_getfvar = 19
	fun_getsvar = 20
	fun_negative = 21
	fun_converttoint = 22
	fun_assign = 23
	fun_assign_i = 23
	fun_assign_u = 24
	fun_assign_f = 25
	fun_assign_s = 26
	token_eq = 27
	fun_pushi = 28
	fun_pushu = 29
	fun_pushf = 30
	fun_pushs = 31
	print_mod_empty = 32
	print_mod_comma = 33
	print_mod_semicolon = 34
	token_linenum_major = 35
	token_linenum_minor = 36
	token_nextline_ptr = 37
	token_le = 38
	token_ge = 39
	token_inc = 40
	token_dec = 41
	token_ne = 42
	fun_pushs2 = 43
	token_cls = 64
	token_new = 65
	token_plot = 66
	token_draw = 67
	token_print = 68
	token_circle = 69
	token_fcircle = 70
	token_box = 71
	token_frame = 72
	token_color = 73
	token_for = 74
	token_next = 75
	token_list = 76
	token_run = 77
	token_fast_goto = 78
	token_slow_goto = 79
	token_csave = 80
	token_save = 81
	token_load = 82
	token_find_goto = 83
	token_rnd = 84
	token_pinwrite = 85
	token_waitms = 86
	token_waitvbl = 87
	token_if = 88
	token_brun = 89
	token_else = 90
	token_then = 91
	token_beep = 92
	token_dir = 93
	token_paper = 94
	token_ink = 95
	token_font = 96
	token_mode = 97
	token_gettime = 98
	token_mouse = 99
	token_mousex = 100
	token_mousey = 101
	token_mousek = 102
	token_mousew = 103
	token_cursor = 104
	token_click = 105
	token_stick = 106
	token_sin = 107
	token_defsprite = 108
	token_sprite = 109
	token_strig = 110
	token_getpixel = 111
	token_waitclock = 112
	token_fill = 113
	token_dim = 114
	token_defsnd = 115
	token_defenv = 116
	token_play = 117
	token_rdpin = 118
	token_wxpin = 119
	token_wypin = 120
	token_wrpin = 121
	token_rqpin = 122
	token_pinread = 123
	token_pinfloat = 124
	token_pinlo = 125
	token_pinhi = 126
	token_pinstart = 127
	token_pintoggle = 128
	token_position = 129
	token_cos = 130
	token_tan = 131
	token_asin = 132
	token_acos = 133
	token_atn = 134
	token_sqr = 135
	token_rad = 136
	token_deg = 137
	token_int = 138
	token_error = 255
	token_end = 510
	token_space = 511
	token_decimal = 512
	token_integer = 513
	token_float = 514
	token_string = 515
	token_name = 516
	result_int = 28
	result_uint = 29
	result_float = 30
	result_string = 31
	result_string2 = 43
	result_array = 114
	result_error = 255
	array_no_type = 256
	array_byte = 257
	array_ubyte = 258
	array_short = 259
	array_ushort = 260
	array_long = 261
	array_ulong = 262
	array_int64 = 263
	array_uint64 = 264
	array_float = 265
	array_double = 266
	array_string = 267
	maxvars = 1023
	maxstack = 512
	maxfor = 128
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 337000000
	long	0 ' clock mode: will default to $14d50fb
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##21844216
	waitx	##200000
	mov	pa, ##21844219
	hubset	pa
	wrlong	pa, #24
	wrlong	##337000000, #20
	jmp	#skip_clock_set_
	orgf	128
skip_clock_set_
	call	#_program
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    mov	fcache_tmpb_,ptrb
    pop	ptrb
    altd	pa,ret_instr_
    mov	 0-0, ret_instr_
    setq	pa
    rdlong	$0, ptrb++
    push	ptrb
    mov ptrb,fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    _ret_ cmp inb,#0
fcache_tmpb_
    long 0
fcache_load_ptr_
    long FCACHE_LOAD_
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret
COUNT_
    long 0
RETADDR_
    long 0
fp
    long 0
pushregs_
    pop  pa
    pop  RETADDR_
    tjz  COUNT_, #pushregs_done_
    altd  COUNT_, #511
    setq #0-0
    wrlong local01, ptra++
pushregs_done_
    setq #2 ' push 3 registers starting at COUNT_
    wrlong COUNT_, ptra++
    mov    fp, ptra
    jmp  pa
 popregs_
    pop    pa
    setq   #2
    rdlong COUNT_, --ptra
    djf    COUNT_, #popregs__ret
    setq   COUNT_
    rdlong local01, --ptra
popregs__ret
    push   RETADDR_
    jmp    pa

divide_
       abs     muldivb_,muldivb_     wcz      'abs(y)
       wrc     itmp2_                         'store sign of y
       abs     muldiva_,muldiva_     wc       'abs(x)
       qdiv    muldiva_, muldivb_             'queue divide
 if_c  xor     itmp2_,#1                      'store sign of x
       getqx   muldivb_                       'get quotient
       getqy   muldiva_                       'get remainder
       negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
       testb   itmp2_,#0             wc       'restore sign, division result
 _ret_ negc    muldivb_,muldivb_     
__pc long 0
__setjmp
    pop __pc
    mov result1, #0
    mov result2, #0
    mov abortchain, arg01
    wrlong fp, arg01
    add arg01, #4
    wrlong ptra, arg01
    add arg01, #4
    wrlong objptr, arg01
    add arg01, #4
    wrlong __pc, arg01
    jmp __pc
__unwind_pc long 0
__unwind_stack
   pop  __unwind_pc
__unwind_loop
   cmp  arg01, arg02 wz
  if_z jmp #__unwind_stack_ret
   mov   ptra, arg01
   call  #popregs_
   mov   arg01, fp
   jmp   #__unwind_loop
__unwind_stack_ret
   jmp  __unwind_pc
__longjmp
    pop __pc
    cmp    arg01, #0 wz
 if_z jmp #nocatch
    mov result1, arg02
    mov result2, #1
    rdlong arg02, arg01
    add arg01, #4
    rdlong ptra, arg01
    add arg01, #4
    rdlong objptr, arg01
    add arg01, #4
    rdlong __pc, arg01
    mov arg01, fp
    call #__unwind_stack
__longjmp_ret
    jmp  __pc
nocatch
    cmp arg03, #0 wz
 if_z jmp #cogexit
    jmp #__longjmp_ret

__heap_ptr
	long	@__heap_base
__methods__
	long	@__methodtable__
abortchain
	long	0
entryptr__
	long	@entry
itmp1_
	long	0
itmp2_
	long	0
objptr
	long	@objmem
ptr__Audio093b_8_sc_spin2_dat__
	long	@_Audio093b_8_sc_spin2_dat_
ptr___system__dat__
	long	@__system__dat_
ptr__dat__
	long	@_dat_
ptr__fatfs_cc_dat__
	long	@_fatfs_cc_dat_
ptr__hg010b_spin2_dat__
	long	@_hg010b_spin2_dat_
ptr__housekeeper_
	long	@_housekeeper
ptr__psram16drv_spin2_dat__
	long	@_psram16drv_spin2_dat_
ptr__psram_spin2_dat__
	long	@_psram_spin2_dat_
ptr__usbnew_spin2_dat__
	long	@_usbnew_spin2_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
result2
	long	1
result3
	long	2
COG_BSS_START
	fit	480
	orgh
hubentry

' 
' 
' 
' '----------------------------------- this is the end of the main loop ------------------------------------------------------------------
' 
' sub housekeeper
_housekeeper
' 
' do
LR__0001
'   do: loop until v.vblank=1 : hkcnt+=1 :gethdi
	add	objptr, #69
LR__0002
	rdlong	arg01, objptr
	cmp	arg01, #1 wz
 if_ne	jmp	#LR__0002
	add	objptr, ##62707
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##62776
	call	#_gethdi
	mov	arg01, #5
	call	#__system___waitms
	add	objptr, ##62776
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##62776
	call	#_gethdi
	mov	arg01, #5
	call	#__system___waitms
	add	objptr, ##62776
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##62776
	call	#_gethdi
	mov	arg01, #5
	call	#__system___waitms
	add	objptr, ##62776
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##62776
	call	#_gethdi
	jmp	#LR__0001
_housekeeper_ret
	ret

' 
' 
' sub gethdi
_gethdi
	mov	COUNT_, #3
	call	#pushregs_
'   x := mouse_xacc
	add	ptr__usbnew_spin2_dat__, ##10405
	rdlong	arg02, ptr__usbnew_spin2_dat__
'   y := mouse_yacc
	add	ptr__usbnew_spin2_dat__, #4
	rdlong	arg01, ptr__usbnew_spin2_dat__
	add	objptr, ##62640
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg01, objptr
'   x := 0
'   y := mouse_zacc
	add	ptr__usbnew_spin2_dat__, #4
	rdlong	result1, ptr__usbnew_spin2_dat__
	add	objptr, #8
	wrlong	result1, objptr
'   return mouse_bstate&7
	add	ptr__usbnew_spin2_dat__, #4
	rdbyte	result1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10417
	and	result1, #7
	sub	objptr, #4
	wrlong	result1, objptr
	sub	objptr, ##62648
	mov	local01, #0
' 
'   mousex,mousey=kbm.mouse_xy()
'   dummy,mousew=kbm.mouse_scroll()
'   mousek=kbm.mouse_buttons()
'   
'   i=0:
'   for j=0 to 6
	mov	local02, #0
LR__0010
'     if kbm.hidpad_id(j)>0 then
	mov	arg01, local02
	call	#_usbnew_spin2_hidpad_id
	cmps	result1, #1 wc
 if_b	jmp	#LR__0011
	mov	arg01, local02
	mov	arg02, #0
	call	#_usbnew_spin2_hidpad_axis
	mov	local03, result1
	mov	arg01, local02
	mov	arg02, #1
	call	#_usbnew_spin2_hidpad_axis
	add	local03, ##49152
	shr	local03, #15
	mov	arg02, #1
	add	arg02, local03
	add	result1, ##49152
	shr	result1, #15
	mov	arg01, #1
	add	arg01, result1
	mov	local03, local01
	shl	local03, #2
	add	objptr, ##62656
	add	local03, objptr
	shl	arg01, #2
	add	arg02, arg01
	wrlong	arg02, local03
	mov	local03, local01
	shl	local03, #2
	add	objptr, #28
	add	local03, objptr
	mov	arg01, local02
	sub	objptr, ##62684
	call	#_usbnew_spin2_hidpad_buttons
	wrlong	result1, local03
	add	local01, #1
LR__0011
	add	local02, #1
	cmp	local02, #7 wc
 if_b	jmp	#LR__0010
	callpa	#(@LR__0013-@LR__0012)>>2,fcache_load_ptr_
' for j=i to 6 : stick(j)=0 : strig(j)=0 : next j 
LR__0012
	cmp	local01, #7 wc
 if_ae	jmp	#LR__0014
	mov	local03, local01
	shl	local03, #2
	add	objptr, ##62656
	add	local03, objptr
	wrlong	#0, local03
	mov	local03, local01
	shl	local03, #2
	add	objptr, #28
	add	local03, objptr
	wrlong	#0, local03
	add	local01, #1
	sub	objptr, ##62684
	jmp	#LR__0012
LR__0013
LR__0014
	mov	ptra, fp
	call	#popregs_
_gethdi_ret
	ret

' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '----------------------------------- The line interpreter/tokenizer --------------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' sub interpret
_interpret
	mov	COUNT_, #34
	call	#pushregs_
	add	ptra, ##588
	add	objptr, ##44256
	rdlong	local01, objptr
	add	objptr, #4
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	add	objptr, ##18540
	wrlong	#0, objptr
	sub	objptr, ##8724
	wrlong	#0, objptr
	sub	objptr, ##54080
	mov	local02, #0
LR__0020
' 
' ' ---------------------------------------------------  Pass 1: Split the line to parts, detect and concatenate strings
' 
' fullline$=line$: cont=-1  : linenum=0 : lineptr=0 : err=0
' 
' 108 for i=0 to 125: separators(i)=0 :next i
	mov	local03, #0
	add	fp, #32
	callpa	#(@LR__0022-@LR__0021)>>2,fcache_load_ptr_
LR__0021
	mov	local04, local03
	shl	local04, #2
	add	local04, fp
	wrlong	#0, local04
	add	local03, #1
	cmps	local03, #126 wc
 if_b	jmp	#LR__0021
LR__0022
	sub	fp, #32
' for i=0 to 125: lparts(i).part$="": lparts(i).token=0: next i
	mov	local03, #0
	add	objptr, ##43216
	callpa	#(@LR__0024-@LR__0023)>>2,fcache_load_ptr_
LR__0023
	mov	local01, local03
	shl	local01, #3
	add	local01, objptr
	mov	arg03, ##@LR__4307
	wrlong	arg03, local01
	mov	local01, local03
	shl	local01, #3
	mov	local05, objptr
	add	local01, objptr
	mov	local06, #0
	add	local01, #4
	wrlong	#0, local01
	add	local03, #1
	cmps	local03, #126 wc
 if_b	jmp	#LR__0023
LR__0024
	add	objptr, ##1040
	rdlong	arg01, objptr
	sub	objptr, ##44256
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##44256
	wrlong	result1, objptr
	mov	local01, ##@LR__4308
	add	objptr, ##18580
	wrlong	local01, objptr
	sub	objptr, ##18580
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	local07, arg01
	callpa	#(@LR__0026-@LR__0025)>>2,fcache_load_ptr_
LR__0025
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0025
LR__0026
	sub	local07, arg01 wz
	add	objptr, ##62840
	wrlong	local07, objptr
' if l=0 then goto 101
	sub	objptr, ##62840
 if_e	jmp	#LR__0148
	add	objptr, ##62844
	wrlong	#0, objptr
' ' before we split the line, we have to find colons that are inside a string,,,,
' for i=1 to len(line$)
	mov	local03, #1
	sub	objptr, ##18588
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	local07, arg01
	callpa	#(@LR__0028-@LR__0027)>>2,fcache_load_ptr_
LR__0027
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0027
LR__0028
	sub	local07, arg01
	mov	local08, local07
	add	local08, #1
LR__0029
	cmps	local03, local08 wc
 if_ae	jmp	#LR__0032
' 
'   if mid$(line$,i,1)="""" andalso d=0 then 
	add	objptr, ##44256
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	arg02, local03
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__4309
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0030
	add	objptr, ##62844
	rdlong	local04, objptr wz
	sub	objptr, ##62844
 if_e	add	objptr, ##62844
 if_e	wrlong	#1, objptr
 if_e	sub	objptr, ##62844
 if_e	jmp	#LR__0031
LR__0030
	add	objptr, ##44256
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	arg02, local03
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__4310
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##62844
 if_e	rdlong	local04, objptr
 if_e	sub	objptr, ##62844
 if_e	cmp	local04, #1 wz
 if_e	add	objptr, ##62844
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##62844
LR__0031
	mov	local01, local03
	shl	local01, #3
	add	objptr, ##43216
	mov	local05, objptr
	add	local01, objptr
	add	objptr, ##19628
	rdlong	local06, objptr
	sub	objptr, ##62844
	add	local01, #4
	wrlong	local06, local01
	add	local03, #1
	jmp	#LR__0029
LR__0032
	mov	local03, #1
' i=1: do until (mid$(line$,i,1)=":" andalso lparts(i).token=0)  orelse i>=l : i=i+1 : loop
LR__0033
	add	objptr, ##44256
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	arg02, local03
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	local09, ##@LR__4311
	mov	arg02, local09
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0034
	mov	local05, local03
	shl	local05, #3
	add	objptr, ##43216
	mov	local06, objptr
	add	local05, objptr
	add	local05, #4
	rdlong	local10, local05
	sub	local05, #4
	mov	local11, local10 wz
	sub	objptr, ##43216
 if_e	jmp	#LR__0035
LR__0034
	add	objptr, ##62840
	rdlong	local12, objptr
	sub	objptr, ##62840
	mov	local13, local12
	cmps	local03, local13 wc
 if_b	add	local03, #1
 if_b	jmp	#LR__0033
LR__0035
' 
' 'let d=instr(1,line$,":"): if d>0 andalso d<len(line$) andalso lparts(d).token=0  then let rest$=trim$(right$(line$,len(line$)-d)):line$=trim$(left$(line$,d-1)) else rest$=""  
' if i<l then let rest$=trim$(right$(line$,len(line$)-i)):line$=trim$(left$(line$,i-1)) else rest$="" 
	add	objptr, ##62840
	rdlong	local01, objptr
	sub	objptr, ##62840
	cmps	local03, local01 wc
 if_ae	jmp	#LR__0038
	add	objptr, ##44256
	rdlong	local06, objptr
	sub	objptr, ##44256
	mov	arg01, local06
	mov	local07, arg01
	callpa	#(@LR__0037-@LR__0036)>>2,fcache_load_ptr_
LR__0036
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0036
LR__0037
	sub	local07, arg01
	mov	arg02, local07
	sub	arg02, local03
	mov	arg01, local06
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##62848
	wrlong	result1, objptr
	sub	objptr, ##18592
	rdlong	arg01, objptr
	sub	objptr, ##44256
	sub	local03, #1
	mov	arg02, local03
	call	#__system__Left_S
	mov	arg01, result1
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##44256
	wrlong	result1, objptr
	sub	objptr, ##44256
	jmp	#LR__0039
LR__0038
	mov	local01, ##@LR__4312
	add	objptr, ##62848
	wrlong	local01, objptr
	sub	objptr, ##62848
LR__0039
' 'print "line$=";line$
' 'print "rest$=";rest$
' 
' 
' if cont=-1 andalso rest$<>"" then cont=0 : goto 107       	' this is the first and not last part
	add	objptr, ##44264
	rdlong	local01, objptr
	sub	objptr, ##44264
	cmp	local01, ##-1 wz
 if_ne	jmp	#LR__0040
	add	objptr, ##62848
	rdlong	arg01, objptr
	sub	objptr, ##62848
	mov	arg02, ##@LR__4313
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	objptr, ##44264
 if_ne	wrlong	#0, objptr
 if_ne	sub	objptr, ##44264
 if_ne	jmp	#LR__0044
LR__0040
' if cont=-1 andalso rest$="" then cont=3 : goto 107		' this is the first AND last part
	add	objptr, ##44264
	rdlong	local01, objptr
	sub	objptr, ##44264
	cmp	local01, ##-1 wz
 if_ne	jmp	#LR__0041
	add	objptr, ##62848
	rdlong	arg01, objptr
	sub	objptr, ##62848
	mov	arg02, ##@LR__4314
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##44264
 if_e	wrlong	#3, objptr
 if_e	sub	objptr, ##44264
 if_e	jmp	#LR__0044
LR__0041
' if cont=4 andalso rest$<>"" then cont=1 : goto 107		' this is not the first and not the last part
	add	objptr, ##44264
	rdlong	local01, objptr
	sub	objptr, ##44264
	cmp	local01, #4 wz
 if_ne	jmp	#LR__0042
	add	objptr, ##62848
	rdlong	arg01, objptr
	sub	objptr, ##62848
	mov	arg02, ##@LR__4315
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	objptr, ##44264
 if_ne	wrlong	#1, objptr
 if_ne	sub	objptr, ##44264
 if_ne	jmp	#LR__0044
LR__0042
' if cont=4 andalso rest$="" then cont=2 :goto 107		' this is the last, and not the first, part
	add	objptr, ##44264
	rdlong	local01, objptr
	sub	objptr, ##44264
	cmp	local01, #4 wz
 if_ne	jmp	#LR__0043
	add	objptr, ##62848
	rdlong	arg01, objptr
	sub	objptr, ##62848
	mov	arg02, ##@LR__4316
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##44264
 if_e	wrlong	#2, objptr
 if_e	sub	objptr, ##44264
LR__0043
LR__0044
	add	fp, #32
	wrlong	#0, fp
	sub	fp, #32
	mov	local03, #0
	mov	local14, #1
' 
' ' 1b: find separators
' 
' 107
' separators(0)=0
' i=0: j=1 : do: i+=1 : let c$=mid$(line$,i,1) 
LR__0045
	add	local03, #1
	add	objptr, ##44256
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	arg02, local03
	mov	arg03, #1
	call	#__system__Mid_S
	add	objptr, ##62852
	wrlong	result1, objptr
' if isseparator(c$) then separators(j)=i: j+=1 
	mov	arg01, result1
	sub	objptr, ##62852
	call	#_isseparator
	cmp	result1, #0 wz
 if_e	jmp	#LR__0046
	mov	local04, local14
	shl	local04, #2
	add	fp, #32
	add	local04, fp
	wrlong	local03, local04
	add	local14, #1
	sub	fp, #32
LR__0046
	add	objptr, ##62840
	rdlong	local01, objptr
	sub	objptr, ##62840
	cmps	local03, local01 wcz
 if_be	jmp	#LR__0045
	mov	local04, local14
	shl	local04, #2
	add	fp, #32
	add	local04, fp
	wrlong	local03, local04
	mov	local15, #0
' for i=0 to j-1 
	mov	local03, #0
	mov	local16, local14
	sub	fp, #32
LR__0047
	cmps	local03, local16 wc
 if_ae	jmp	#LR__0051
	mov	local04, local03
	shl	local04, #2
	add	fp, #32
	add	local04, fp
	rdlong	local05, local04
	add	objptr, ##62860
	wrlong	local05, objptr
	mov	local04, local03
	add	local04, #1
	shl	local04, #2
	mov	local09, fp
	add	local04, fp
	rdlong	local05, local04
	add	objptr, #4
	wrlong	local05, objptr
'   if p1>0 then let p$=mid$(line$,p1,1):  if   p$<>"" then lparts(k).part$=p$ : k+=1 
	sub	objptr, #4
	rdlong	local01, objptr
	sub	objptr, ##62860
	cmps	local01, #1 wc
	sub	fp, #32
 if_b	jmp	#LR__0049
	add	objptr, ##44256
	rdlong	arg01, objptr
	add	objptr, ##18604
	rdlong	arg02, objptr
	sub	objptr, ##62860
	mov	arg03, #1
	call	#__system__Mid_S
	add	objptr, ##62868
	wrlong	result1, objptr
	sub	objptr, ##62868
	mov	arg01, result1
	mov	arg02, ##@LR__4317
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0048
	mov	local09, local15
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	objptr, ##19652
	rdlong	local06, objptr
	sub	objptr, ##62868
	wrlong	local06, local09
	add	local15, #1
LR__0048
LR__0049
	add	objptr, ##44256
	rdlong	arg01, objptr
	add	objptr, ##18604
	rdlong	arg02, objptr
	add	arg02, #1
	add	objptr, #4
	rdlong	arg03, objptr
	sub	objptr, #4
	rdlong	local10, objptr
	sub	objptr, ##62860
	mov	local11, local10
	sub	arg03, local11
	sub	arg03, #1
	call	#__system__Mid_S
	add	objptr, ##62868
	wrlong	result1, objptr
	sub	objptr, ##62868
	mov	arg01, result1
	mov	arg02, ##@LR__4318
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0050
	mov	local09, local15
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	objptr, ##19652
	rdlong	local06, objptr
	sub	objptr, ##62868
	wrlong	local06, local09
	add	local15, #1
LR__0050
	add	local03, #1
	jmp	#LR__0047
LR__0051
	mov	local03, #0
' 
' ' 1d : find strings
' 
' i=0
' do
LR__0052
'   if lparts(i).part$<>"""" then i+=1 : goto 109
	mov	local05, local03
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__4319
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__0057
	mov	local17, local03
LR__0053
	mov	local09, local03
	add	local09, #1
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	rdlong	local10, local09
	add	objptr, ##19652
	wrlong	local10, objptr
	mov	local09, local17
	shl	local09, #3
	sub	objptr, ##19652
	add	local09, objptr
	mov	local13, local17
	shl	local13, #3
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##43216
	mov	local11, local10
	mov	arg02, local11
	call	#__system___string_concat
	wrlong	result1, local09
	mov	local14, local03
	add	local14, #1
	mov	local18, local15
	add	local18, #1
	callpa	#(@LR__0055-@LR__0054)>>2,fcache_load_ptr_
LR__0054
	cmps	local14, local18 wc
 if_ae	jmp	#LR__0056
	mov	local05, local14
	add	local05, #1
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	local01, local05
	mov	local06, local14
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local04, local06
	mov	local06, local14
	shl	local06, #3
	mov	local11, objptr
	add	local06, objptr
	wrlong	local01, local06
	mov	local10, local14
	mov	local12, local10
	shl	local12, #3
	add	local12, objptr
	add	local12, #4
	wrlong	local04, local12
	add	local14, #1
	sub	objptr, ##43216
	jmp	#LR__0054
LR__0055
LR__0056
	sub	local15, #1
	add	objptr, ##62868
	rdlong	arg01, objptr
	sub	objptr, ##62868
	mov	arg02, ##@LR__4320
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	cmps	local03, local15 wc
 if_c_and_nz	jmp	#LR__0053
'   if p$<>"""" then k+=1:i+=1
	add	objptr, ##62868
	rdlong	arg01, objptr
	sub	objptr, ##62868
	mov	arg02, ##@LR__4321
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	local15, #1
 if_ne	add	local03, #1
LR__0057
	cmps	local03, local15 wc
 if_b	jmp	#LR__0052
	mov	local03, #0
' 
' ' 1e : concatenate strings if "" detected between
'  
' i=0 : do
LR__0058
'  if right$(lparts(i).part$,1)="""" andalso left$(lparts(i+1).part$,1)=""""  then 
	mov	local05, local03
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #1
	sub	objptr, ##43216
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__4322
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0064
	mov	local06, local03
	add	local06, #1
	shl	local06, #3
	add	objptr, ##43216
	mov	local11, objptr
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #1
	sub	objptr, ##43216
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__4323
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0064
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	mov	local13, local03
	shl	local13, #3
	add	local13, objptr
	rdlong	local06, local13
	mov	local12, local03
	add	local12, #1
	shl	local12, #3
	add	local12, objptr
	rdlong	local11, local12
	mov	local19, local03
	add	local19, #1
	mov	local20, local19
	shl	local20, #3
	mov	local21, objptr
	add	local20, objptr
	rdlong	arg01, local20
	sub	objptr, ##43216
	mov	local07, arg01
	callpa	#(@LR__0060-@LR__0059)>>2,fcache_load_ptr_
LR__0059
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0059
LR__0060
	sub	local07, arg01
	mov	local10, local07
	sub	local10, #1
	mov	arg01, local11
	mov	arg02, local10
	call	#__system__Right_S
	mov	local11, result1
	mov	arg01, local06
	mov	arg02, local11
	call	#__system___string_concat
	wrlong	result1, local09
'    for j=i+1 to k: lparts(j)=lparts(j+1): next j  
	mov	local14, local03
	add	local14, #1
	mov	local22, local15
	add	local22, #1
	callpa	#(@LR__0062-@LR__0061)>>2,fcache_load_ptr_
LR__0061
	cmps	local14, local22 wc
 if_ae	jmp	#LR__0063
	mov	local05, local14
	add	local05, #1
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	local01, local05
	mov	local06, local14
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local04, local06
	mov	local06, local14
	shl	local06, #3
	mov	local11, objptr
	add	local06, objptr
	wrlong	local01, local06
	mov	local10, local14
	mov	local12, local10
	shl	local12, #3
	add	local12, objptr
	add	local12, #4
	wrlong	local04, local12
	add	local14, #1
	sub	objptr, ##43216
	jmp	#LR__0061
LR__0062
LR__0063
	sub	local03, #1
	sub	local15, #1
LR__0064
	add	local03, #1
	cmps	local03, local15 wc
 if_b	jmp	#LR__0058
	mov	local03, #0
'  
' ' 1e2: concatenate >=, <=, ++, --, +=, *=, -=, /=, ^=, <>
'  
' i=0 : do
LR__0065
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	rdlong	local06, local09
	add	objptr, ##19660
	wrlong	local06, objptr
	mov	local09, local03
	add	local09, #1
	shl	local09, #3
	sub	objptr, ##19660
	add	local09, objptr
	rdlong	local06, local09
	add	objptr, ##19664
	wrlong	local06, objptr
'   if ((s1$=">" orelse s1$=">" orelse s1$="+" orelse s1$="-" orelse s1$="*" orelse s1$="/" orelse s1$="^") andalso s2$="=") orelse (s1$="+" andalso s2$="+") orelse (s1$="-" andalso s2$="-") orelse (s1$="<" andalso s2$=">") then
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	arg02, ##@LR__4324
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0066
	add	objptr, ##62876
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	arg02, ##@LR__4325
	call	#__system___string_cmp
	mov	local04, result1 wz
 if_e	jmp	#LR__0066
	add	objptr, ##62876
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	arg02, ##@LR__4326
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0066
	add	objptr, ##62876
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	local11, ##@LR__4327
	mov	arg02, local11
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0066
	add	objptr, ##62876
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	local10, ##@LR__4328
	mov	local11, local10
	mov	arg02, local11
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0066
	add	objptr, ##62876
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	local10, ##@LR__4329
	mov	arg02, local10
	call	#__system___string_cmp
	mov	local11, result1 wz
 if_e	jmp	#LR__0066
	add	objptr, ##62876
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	local13, ##@LR__4330
	mov	arg02, local13
	call	#__system___string_cmp
	mov	local10, result1 wz
 if_ne	jmp	#LR__0067
LR__0066
	add	objptr, ##62880
	rdlong	arg01, objptr
	sub	objptr, ##62880
	mov	local23, ##@LR__4331
	mov	local12, local23
	mov	arg02, local12
	call	#__system___string_cmp
	mov	local13, result1 wz
 if_e	jmp	#LR__0070
LR__0067
	add	objptr, ##62876
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	local23, ##@LR__4332
	mov	arg02, local23
	call	#__system___string_cmp
	mov	local12, result1 wz
 if_ne	jmp	#LR__0068
	add	objptr, ##62880
	rdlong	arg01, objptr
	sub	objptr, ##62880
	mov	local20, ##@LR__4333
	mov	local19, local20
	mov	arg02, local19
	call	#__system___string_cmp
	mov	local23, result1 wz
 if_e	jmp	#LR__0070
LR__0068
	add	objptr, ##62876
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	local20, ##@LR__4334
	mov	arg02, local20
	call	#__system___string_cmp
	mov	local19, result1 wz
 if_ne	jmp	#LR__0069
	add	objptr, ##62880
	rdlong	arg01, objptr
	sub	objptr, ##62880
	mov	local24, ##@LR__4335
	mov	local21, local24
	mov	arg02, local21
	call	#__system___string_cmp
	mov	local20, result1 wz
 if_e	jmp	#LR__0070
LR__0069
	add	objptr, ##62876
	rdlong	arg01, objptr
	sub	objptr, ##62876
	mov	local25, ##@LR__4336
	mov	local24, local25
	mov	arg02, local24
	call	#__system___string_cmp
	mov	local21, result1 wz
 if_ne	jmp	#LR__0074
	add	objptr, ##62880
	rdlong	arg01, objptr
	sub	objptr, ##62880
	mov	local26, ##@LR__4337
	mov	local25, local26
	mov	arg02, local25
	call	#__system___string_cmp
	mov	local24, result1 wz
 if_ne	jmp	#LR__0074
LR__0070
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	objptr, ##19660
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	local10, objptr
	sub	objptr, ##62880
	mov	local11, local10
	mov	arg02, local11
	call	#__system___string_concat
	wrlong	result1, local09
'     lparts(i).part$=s1$+s2$
'     for j=i+1 to k : lparts(j)=lparts(j+1) : next j
	mov	local14, local03
	add	local14, #1
	mov	local27, local15
	add	local27, #1
	callpa	#(@LR__0072-@LR__0071)>>2,fcache_load_ptr_
LR__0071
	cmps	local14, local27 wc
 if_ae	jmp	#LR__0073
	mov	local05, local14
	add	local05, #1
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	local01, local05
	mov	local06, local14
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local04, local06
	mov	local06, local14
	shl	local06, #3
	mov	local11, objptr
	add	local06, objptr
	wrlong	local01, local06
	mov	local10, local14
	mov	local13, local10
	mov	local12, local13
	shl	local12, #3
	mov	local23, objptr
	add	local12, objptr
	add	local12, #4
	wrlong	local04, local12
	sub	local12, #4
	add	local14, #1
	sub	objptr, ##43216
	jmp	#LR__0071
LR__0072
LR__0073
	sub	local03, #1
	sub	local15, #1
LR__0074
	add	local03, #1
	cmps	local03, local15 wc
 if_b	jmp	#LR__0065
'  
' ' 1f : now remove parts that are spaces
' 
' for i=0 to k: lparts(i).part$=trim$(lparts(i).part$): next i
	mov	local03, #0
	mov	local28, local15
	add	local28, #1
LR__0075
	cmps	local03, local28 wc
 if_ae	jmp	#LR__0076
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	mov	local11, local03
	mov	local10, local11
	mov	local13, local10
	shl	local13, #3
	mov	local12, objptr
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##43216
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	wrlong	result1, local09
	add	local03, #1
	jmp	#LR__0075
LR__0076
	mov	local03, #0
	callpa	#(@LR__0083-@LR__0077)>>2,fcache_load_ptr_
' 
' i=0
' do 
LR__0077
'   if len(lparts(i).part$)=0 then 
	mov	local09, local03
	mov	local05, local09
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##43216
	mov	local07, arg01
LR__0078
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0078
	sub	local07, arg01 wz
 if_ne	jmp	#LR__0082
'     if i=k-1 then k-=1  :  exit
	mov	local01, local15
	sub	local01, #1
	cmp	local03, local01 wz
 if_e	sub	local15, #1
 if_e	jmp	#LR__0084
'     if i<k-1 then 
	mov	local01, local15
	sub	local01, #1
	cmps	local03, local01 wc
 if_ae	jmp	#LR__0081
'       for j=i to k-2 : lparts(j)=lparts(j+1): next j: k-=1  
	mov	local14, local03
	mov	local29, local15
	sub	local29, #1
LR__0079
	cmps	local14, local29 wc
 if_ae	jmp	#LR__0080
	mov	local05, local14
	add	local05, #1
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	local01, local05
	mov	local06, local14
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local04, local06
	mov	local09, local14
	mov	local06, local09
	shl	local06, #3
	mov	local11, objptr
	add	local06, objptr
	wrlong	local01, local06
	mov	local10, local14
	mov	local13, local10
	mov	local12, local13
	shl	local12, #3
	mov	local23, objptr
	add	local12, objptr
	add	local12, #4
	wrlong	local04, local12
	sub	local12, #4
	add	local14, #1
	sub	objptr, ##43216
	jmp	#LR__0079
LR__0080
	sub	local15, #1
'       if i>0 then i-=1 
	cmps	local03, #1 wc
 if_ae	sub	local03, #1
LR__0081
LR__0082
	add	local03, #1
	mov	local01, local15
	sub	local01, #1
	cmps	local03, local01 wcz
 if_be	jmp	#LR__0077
LR__0083
LR__0084
' 
' ' 1g: lowercase all that is not a string
' 
' for j=0 to k-1
	mov	local14, #0
	mov	local30, local15
LR__0085
	cmps	local14, local30 wc
 if_ae	jmp	#LR__0088
'   if left$(lparts(j).part$,1)<>"""" orelse right$(lparts(j).part$,1)<>"""" then lparts(j).part$=lcase$(lparts(j).part$) 
	mov	local05, local14
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #1
	sub	objptr, ##43216
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__4338
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0086
	mov	local06, local14
	shl	local06, #3
	add	objptr, ##43216
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #1
	sub	objptr, ##43216
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__4339
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0087
LR__0086
	mov	local09, local14
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	mov	local13, local14
	shl	local13, #3
	mov	local12, objptr
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##43216
	call	#__system__LCase_S
	wrlong	result1, local09
LR__0087
	add	local14, #1
	jmp	#LR__0085
LR__0088
' 
' '                                                         for i=0 to k-1 : print lparts(i).part$,: next i : print
' 
' for i=0 to k: lparts(i).token=-1: next i
	mov	local03, #0
	mov	local31, local15
	add	local31, #1
	callpa	#(@LR__0090-@LR__0089)>>2,fcache_load_ptr_
LR__0089
	cmps	local03, local31 wc
 if_ae	jmp	#LR__0091
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	wrlong	##-1, local09
	add	local03, #1
	sub	objptr, ##43216
	jmp	#LR__0089
LR__0090
LR__0091
' 
' '-------------------------------------------------------- Pass 2: Tokenize the line
' 
' if len(lparts(0).part$)=0 then goto 101				' empty line, nothing to do
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	local07, arg01
	callpa	#(@LR__0093-@LR__0092)>>2,fcache_load_ptr_
LR__0092
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0092
LR__0093
	sub	local07, arg01 wz
 if_e	jmp	#LR__0148
' 
' 
' if isdec(lparts(0).part$) then let addptr=1 else let addptr=0
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	call	#_isdec
	cmp	result1, #0 wz
 if_ne	add	objptr, ##62884
 if_ne	wrlong	#1, objptr
	sumnz	objptr, ##62884
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##62884
	add	objptr, ##62884
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	rdlong	local11, local05
	add	objptr, ##19672
	wrlong	local11, objptr
	sub	objptr, #4
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##19668
	mov	local10, objptr
	add	local11, objptr
	rdlong	arg02, local11
	mov	arg03, ##@LR__4340
	mov	arg01, #1
	sub	objptr, ##43216
	call	#__system__Instr
	add	objptr, ##62892
	wrlong	result1, objptr
' if dot>0 andalso dot<len(lparts(addptr).part$) then 
	mov	local01, result1
	sub	objptr, ##62892
	cmps	local01, #1 wc
 if_b	jmp	#LR__0100
	add	objptr, ##62884
	rdlong	local10, objptr
	shl	local10, #3
	sub	objptr, ##19668
	mov	local13, objptr
	add	local10, objptr
	rdlong	arg01, local10
	sub	objptr, ##43216
	mov	local07, arg01
	callpa	#(@LR__0095-@LR__0094)>>2,fcache_load_ptr_
LR__0094
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0094
LR__0095
	sub	local07, arg01
	mov	local09, local07
	add	objptr, ##62892
	rdlong	local05, objptr
	sub	objptr, ##62892
	cmps	local05, local09 wc
 if_ae	jmp	#LR__0100
	add	local15, #1
'   k+=1
'   for i=k to addptr+1 step -1 : lparts(i)=lparts(i-1) : next i
	mov	local03, local15
	add	objptr, ##62884
	rdlong	local32, objptr
	add	local32, #1
	sub	objptr, ##19668
	callpa	#(@LR__0097-@LR__0096)>>2,fcache_load_ptr_
LR__0096
	mov	local06, local03
	sub	local06, #1
	shl	local06, #3
	add	local06, objptr
	rdlong	local04, local06
	mov	local11, local03
	sub	local11, #1
	shl	local11, #3
	add	local11, objptr
	add	local11, #4
	rdlong	local09, local11
	mov	local11, local03
	shl	local11, #3
	add	local11, objptr
	wrlong	local04, local11
	mov	local23, local03
	shl	local23, #3
	add	local23, objptr
	add	local23, #4
	wrlong	local09, local23
	sub	local03, #1
	cmps	local03, local32 wc
 if_ae	jmp	#LR__0096
LR__0097
	add	objptr, ##19668
	rdlong	local23, objptr
	mov	local05, local23
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	shl	local23, #3
	add	local23, objptr
	rdlong	local11, local23
	add	objptr, ##19668
	rdlong	local20, objptr
	mov	local21, local20
	shl	local21, #3
	sub	objptr, ##19668
	mov	local24, objptr
	add	local21, objptr
	rdlong	arg01, local21
	sub	objptr, ##43216
	mov	local07, arg01
	callpa	#(@LR__0099-@LR__0098)>>2,fcache_load_ptr_
LR__0098
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0098
LR__0099
	sub	local07, arg01
	mov	arg02, local07
	add	objptr, ##62892
	rdlong	local23, objptr
	sub	objptr, ##62892
	sub	arg02, local23
	mov	arg01, local11
	call	#__system__Right_S
	wrlong	result1, local05
	add	objptr, ##62884
	rdlong	local12, objptr
	mov	local05, local12
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	mov	local23, local12
	shl	local23, #3
	mov	local19, objptr
	add	local23, objptr
	rdlong	arg01, local23
	add	objptr, ##19676
	rdlong	local13, objptr
	sub	objptr, ##62892
	mov	local10, local13
	mov	arg02, local10
	call	#__system__Left_S
	wrlong	result1, local05
LR__0100
' if left$(lparts(addptr).part$,1)="?" andalso len(lparts(addptr).part$)>1 then
	add	objptr, ##62884
	rdlong	local06, objptr
	shl	local06, #3
	sub	objptr, ##19668
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #1
	sub	objptr, ##43216
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__4341
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0107
	add	objptr, ##62884
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##19668
	mov	local10, objptr
	add	local11, objptr
	rdlong	arg01, local11
	sub	objptr, ##43216
	mov	local07, arg01
	callpa	#(@LR__0102-@LR__0101)>>2,fcache_load_ptr_
LR__0101
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0101
LR__0102
	sub	local07, arg01
	cmps	local07, #2 wc
 if_b	jmp	#LR__0107
	add	local15, #1
'   k+=1
'   for i=k to addptr+1 step -1 : lparts(i)=lparts(i-1) : next i
	mov	local03, local15
	add	objptr, ##62884
	rdlong	local33, objptr
	add	local33, #1
	sub	objptr, ##19668
	callpa	#(@LR__0104-@LR__0103)>>2,fcache_load_ptr_
LR__0103
	mov	local06, local03
	sub	local06, #1
	shl	local06, #3
	add	local06, objptr
	rdlong	local04, local06
	mov	local11, local03
	sub	local11, #1
	shl	local11, #3
	add	local11, objptr
	add	local11, #4
	rdlong	local09, local11
	mov	local11, local03
	shl	local11, #3
	add	local11, objptr
	wrlong	local04, local11
	mov	local23, local03
	shl	local23, #3
	add	local23, objptr
	add	local23, #4
	wrlong	local09, local23
	sub	local03, #1
	cmps	local03, local33 wc
 if_ae	jmp	#LR__0103
LR__0104
	add	objptr, ##19668
	rdlong	local23, objptr
	mov	local05, local23
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	shl	local23, #3
	add	local23, objptr
	rdlong	local11, local23
	add	objptr, ##19668
	rdlong	local19, objptr
	mov	local23, local19
	mov	local20, local23
	mov	local21, local20
	shl	local21, #3
	sub	objptr, ##19668
	mov	local24, objptr
	add	local21, objptr
	rdlong	arg01, local21
	sub	objptr, ##43216
	mov	local07, arg01
	callpa	#(@LR__0106-@LR__0105)>>2,fcache_load_ptr_
LR__0105
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0105
LR__0106
	sub	local07, arg01
	mov	local12, local07
	mov	local13, local12
	sub	local13, #1
	mov	local10, local13
	mov	arg01, local11
	mov	arg02, local10
	call	#__system__Right_S
	wrlong	result1, local05
	add	objptr, ##62884
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	mov	local11, ##@LR__4342
	wrlong	local11, local05
	sub	objptr, ##43216
LR__0107
	add	objptr, ##62884
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	rdlong	local11, local05
	add	objptr, ##19672
	wrlong	local11, objptr
' 
' ' process the case when simple load or save is called without ""
' 
' if (lp$="mouse" orelse lp$="cursor" orelse lp$="click") andalso lparts(addptr+1).token=token_name then 
	sub	objptr, ##62888
	mov	arg02, ##@LR__4343
	mov	arg01, local11
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0108
	add	objptr, ##62888
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	arg02, ##@LR__4344
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0108
	add	objptr, ##62888
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	arg02, ##@LR__4345
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0111
LR__0108
	add	objptr, ##62884
	rdlong	local11, objptr
	add	local11, #1
	mov	local10, local11
	shl	local10, #3
	sub	objptr, ##19668
	mov	local13, objptr
	add	local10, objptr
	add	local10, #4
	rdlong	local23, local10
	sub	local10, #4
	mov	local12, local23
	cmp	local12, ##516 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0111
'   if lparts(addptr+1).part$="on" then lparts(addptr+1).part$="1" :lparts(addptr+1).token=token_decimal
	add	objptr, ##62884
	rdlong	local06, objptr
	add	local06, #1
	shl	local06, #3
	sub	objptr, ##19668
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, ##@LR__4346
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0109
	add	objptr, ##62884
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	mov	local11, ##@LR__4347
	wrlong	local11, local05
	add	objptr, ##19668
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	add	local05, #4
	wrlong	##512, local05
	sub	objptr, ##43216
LR__0109
'   if lparts(addptr+1).part$="off" then lparts(addptr+1).part$="0" :lparts(addptr+1).token=token_decimal
	add	objptr, ##62884
	rdlong	local06, objptr
	add	local06, #1
	shl	local06, #3
	sub	objptr, ##19668
	mov	local11, objptr
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, ##@LR__4348
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0110
	add	objptr, ##62884
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	mov	local11, ##@LR__4349
	wrlong	local11, local05
	add	objptr, ##19668
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	decod	local11, #9
	add	local05, #4
	wrlong	##512, local05
	sub	objptr, ##43216
LR__0110
LR__0111
' if (lp$="mode" orelse lp$="m.") then 
	add	objptr, ##62888
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	arg02, ##@LR__4350
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0112
	add	objptr, ##62888
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	arg02, ##@LR__4351
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0118
LR__0112
'   if lparts(addptr+1).part$="atari" then lparts(addptr+1).part$="0"  
	add	objptr, ##62884
	rdlong	local06, objptr
	add	local06, #1
	shl	local06, #3
	sub	objptr, ##19668
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, ##@LR__4352
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0113
	add	objptr, ##62884
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	mov	local11, ##@LR__4353
	wrlong	local11, local05
	sub	objptr, ##43216
LR__0113
'   if lparts(addptr+1).part$="pc_amber" then lparts(addptr+1).part$="1"  
	add	objptr, ##62884
	rdlong	local06, objptr
	add	local06, #1
	shl	local06, #3
	sub	objptr, ##19668
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, ##@LR__4354
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0114
	add	objptr, ##62884
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	mov	local11, ##@LR__4355
	wrlong	local11, local05
	sub	objptr, ##43216
LR__0114
'   if lparts(addptr+1).part$="pc_green" then lparts(addptr+1).part$="2"  
	add	objptr, ##62884
	rdlong	local06, objptr
	add	local06, #1
	shl	local06, #3
	sub	objptr, ##19668
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, ##@LR__4356
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0115
	add	objptr, ##62884
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	mov	local11, ##@LR__4357
	wrlong	local11, local05
	sub	objptr, ##43216
LR__0115
'   if lparts(addptr+1).part$="pc_white" then lparts(addptr+1).part$="3"  
	add	objptr, ##62884
	rdlong	local06, objptr
	add	local06, #1
	shl	local06, #3
	sub	objptr, ##19668
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, ##@LR__4358
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0116
	add	objptr, ##62884
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	mov	local11, ##@LR__4359
	wrlong	local11, local05
	sub	objptr, ##43216
LR__0116
'   if lparts(addptr+1).part$="st" then lparts(addptr+1).part$="4"  
	add	objptr, ##62884
	rdlong	local06, objptr
	add	local06, #1
	shl	local06, #3
	sub	objptr, ##19668
	mov	local11, objptr
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, ##@LR__4360
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0117
	add	objptr, ##62884
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##19668
	add	local05, objptr
	mov	local11, ##@LR__4361
	wrlong	local11, local05
	sub	objptr, ##43216
LR__0117
LR__0118
' 
' 
' 
' 
' 
' 
' ' 2a find part types 
' 
' for i=0 to k-1
	mov	local03, #0
	mov	local34, local15
LR__0119
	cmps	local03, local34 wc
 if_ae	jmp	#LR__0128
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	mov	local12, local03
	shl	local12, #3
	mov	local23, objptr
	add	local12, objptr
	rdlong	arg01, local12
	sub	objptr, ##43216
	call	#_isseparator
	getbyte	result1, result1, #0
	add	local09, #4
	wrlong	result1, local09
' lparts(i).token=isseparator(lparts(i).part$): if lparts(i).token>0 then goto 102
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	rdlong	local11, local09
	cmps	local11, #1 wc
	sub	objptr, ##43216
 if_ae	jmp	#LR__0127
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	mov	local12, local03
	shl	local12, #3
	mov	local23, objptr
	add	local12, objptr
	rdlong	arg01, local12
	sub	objptr, ##43216
	call	#_isoperator
	getbyte	result1, result1, #0
	add	local09, #4
	wrlong	result1, local09
' lparts(i).token=isoperator(lparts(i).part$): if lparts(i).token>0 then goto 102
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	rdlong	local11, local09
	cmps	local11, #1 wc
	sub	objptr, ##43216
 if_ae	jmp	#LR__0127
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	mov	local12, local03
	shl	local12, #3
	mov	local23, objptr
	add	local12, objptr
	rdlong	arg01, local12
	sub	objptr, ##43216
' 
' select case s
	mov	arg02, ##@LR__4414
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	getbyte	result1, result1, #0
	add	local09, #4
	wrlong	result1, local09
' lparts(i).token=isassign(lparts(i).part$) : if lparts(i).token>0 then goto 102
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	rdlong	local11, local09
	cmps	local11, #1 wc
	sub	objptr, ##43216
 if_ae	jmp	#LR__0127
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	mov	local12, local03
	shl	local12, #3
	mov	local23, objptr
	add	local12, objptr
	rdlong	arg01, local12
	sub	objptr, ##43216
	call	#_iscommand
	getbyte	result1, result1, #0
	add	local09, #4
	wrlong	result1, local09
' lparts(i).token=iscommand(lparts(i).part$): if lparts(i).token>0 then goto 102
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	rdlong	local11, local09
	cmps	local11, #1 wc
	sub	objptr, ##43216
 if_ae	jmp	#LR__0127
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	mov	local10, local03
	mov	local13, local10
	mov	local12, local13
	shl	local12, #3
	mov	local23, objptr
	add	local12, objptr
	rdlong	arg01, local12
	sub	objptr, ##43216
	call	#_isfunction
	getbyte	result1, result1, #0
	add	local09, #4
	wrlong	result1, local09
' lparts(i).token=isfunction(lparts(i).part$): if lparts(i).token>0 then goto 102
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	rdlong	local11, local09
	cmps	local11, #1 wc
	sub	objptr, ##43216
 if_ae	jmp	#LR__0127
	mov	local05, local03
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##43216
	call	#_isnum
	mov	local01, result1
	add	objptr, ##62896
	wrlong	local01, objptr
	mov	local05, local03
	shl	local05, #3
	sub	objptr, ##19680
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##43216
	call	#_isint
	mov	local01, result1
	add	objptr, ##62900
	wrlong	local01, objptr
	mov	local05, local03
	shl	local05, #3
	sub	objptr, ##19684
	mov	local06, objptr
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##43216
	call	#_isdec
	add	objptr, ##62904
	wrlong	result1, objptr
' if b1 andalso b2 andalso b3 then lparts(i).token=token_decimal : goto 102 					' pure decimal for line num
	sub	objptr, #8
	rdlong	local01, objptr wz
	sub	objptr, ##62896
 if_e	jmp	#LR__0120
	add	objptr, ##62900
	rdlong	local09, objptr wz
	sub	objptr, ##62900
 if_e	jmp	#LR__0120
	add	objptr, ##62904
	rdlong	local11, objptr wz
	sub	objptr, ##62904
 if_e	jmp	#LR__0120
	mov	local04, local03
	mov	local09, local04
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	wrlong	##512, local09
	sub	objptr, ##43216
	jmp	#LR__0127
LR__0120
' if b1 andalso b2 andalso (not b3) then lparts(i).token=token_integer : goto 102 				' integer
	add	objptr, ##62896
	rdlong	local01, objptr wz
	sub	objptr, ##62896
 if_e	jmp	#LR__0121
	add	objptr, ##62900
	rdlong	local09, objptr wz
	sub	objptr, ##62900
 if_ne	add	objptr, ##62904
 if_ne	rdlong	local11, objptr
 if_ne	sub	objptr, ##62904
 if_ne	not	local06, local11
 if_ne	cmp	local06, #0 wz
 if_e	jmp	#LR__0121
	mov	local04, local03
	mov	local09, local04
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	wrlong	##513, local09
	sub	objptr, ##43216
	jmp	#LR__0127
LR__0121
' if b1 andalso (not b2) andalso (not b3) then lparts(i).token=token_float :goto 102 				' float
	add	objptr, ##62896
	rdlong	local01, objptr wz
	sub	objptr, ##62896
 if_ne	add	objptr, ##62900
 if_ne	rdlong	local09, objptr
 if_ne	sub	objptr, ##62900
 if_ne	not	local09, local09
 if_ne	cmp	local09, #0 wz
 if_ne	add	objptr, ##62904
 if_ne	rdlong	local11, objptr
 if_ne	sub	objptr, ##62904
 if_ne	not	local06, local11
 if_ne	cmp	local06, #0 wz
 if_e	jmp	#LR__0122
	mov	local04, local03
	mov	local09, local04
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	wrlong	##514, local09
	sub	objptr, ##43216
	jmp	#LR__0127
LR__0122
' 
' if isstring(lparts(i).part$) then 
	mov	local05, local03
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##43216
	call	#_isstring
	cmp	result1, #0 wz
 if_e	jmp	#LR__0125
	mov	local09, local03
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	wrlong	##515, local09
	mov	local04, local03
	mov	local09, local04
	shl	local09, #3
	add	local09, objptr
	mov	local13, local03
	shl	local13, #3
	add	local13, objptr
	rdlong	local06, local13
	mov	local11, #2
	mov	local23, local03
	mov	local19, local23
	mov	local20, local19
	shl	local20, #3
	mov	local21, objptr
	add	local20, objptr
	rdlong	arg01, local20
	sub	objptr, ##43216
	mov	local07, arg01
	callpa	#(@LR__0124-@LR__0123)>>2,fcache_load_ptr_
LR__0123
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0123
LR__0124
	sub	local07, arg01
	mov	local12, local07
	mov	arg03, local12
	sub	arg03, #2
	mov	arg01, local06
	mov	arg02, local11
	call	#__system__Mid_S
	wrlong	result1, local09
	jmp	#LR__0127
LR__0125
' if isname(lparts(i).part$) then lparts(i).token=token_name : goto 102						' name
	mov	local04, local03
	mov	local05, local04
	shl	local05, #3
	add	objptr, ##43216
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##43216
	call	#_isname
	cmp	result1, #0 wz
 if_e	jmp	#LR__0126
	mov	local04, local03
	mov	local09, local04
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	wrlong	##516, local09
	sub	objptr, ##43216
LR__0126
LR__0127
	add	local03, #1
	jmp	#LR__0119
LR__0128
	mov	local09, local15
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	add	local09, #4
	wrlong	#510, local09
	mov	local09, local15
	shl	local09, #3
	mov	local05, objptr
	add	local09, objptr
	mov	local06, ##@LR__4362
	wrlong	local06, local09
	add	objptr, ##8276
	wrlong	local15, objptr
' 
' lparts(k).token=token_end : lparts(k).part$="": tokennum=k
' 
'  '                                      					 	for i=0 to k: print lparts(i).token,lparts(i).part$ : next i
'  
' if (lp$="load" orelse lp$="save" orelse lp$="brun" orelse lp$="lo." orelse lp$="s." orelse lp$="br.") andalso lparts(addptr+1).token=token_name then lparts(addptr+1).token=token_string
	add	objptr, ##11396
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	local09, ##@LR__4363
	mov	arg02, local09
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0129
	add	objptr, ##62888
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	local05, ##@LR__4364
	mov	local09, local05
	mov	arg02, local09
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0129
	add	objptr, ##62888
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	local06, ##@LR__4365
	mov	local05, local06
	mov	arg02, local05
	call	#__system___string_cmp
	mov	local09, result1 wz
 if_e	jmp	#LR__0129
	add	objptr, ##62888
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	local11, ##@LR__4366
	mov	local06, local11
	mov	arg02, local06
	call	#__system___string_cmp
	mov	local05, result1 wz
 if_e	jmp	#LR__0129
	add	objptr, ##62888
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	local11, ##@LR__4367
	mov	arg02, local11
	call	#__system___string_cmp
	mov	local06, result1 wz
 if_e	jmp	#LR__0129
	add	objptr, ##62888
	rdlong	arg01, objptr
	sub	objptr, ##62888
	mov	local13, ##@LR__4368
	mov	local10, local13
	mov	arg02, local10
	call	#__system___string_cmp
	mov	local11, result1 wz
 if_ne	jmp	#LR__0130
LR__0129
	add	objptr, ##62884
	rdlong	local13, objptr
	mov	local10, local13
	add	local10, #1
	mov	local12, local10
	mov	local23, local12
	shl	local23, #3
	sub	objptr, ##19668
	mov	local19, objptr
	add	local23, objptr
	add	local23, #4
	rdlong	local21, local23
	sub	local23, #4
	mov	local20, local21
	cmp	local20, ##516 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0130
	add	objptr, ##62884
	rdlong	local09, objptr
	add	local09, #1
	mov	local05, local09
	shl	local05, #3
	sub	objptr, ##19668
	mov	local06, objptr
	add	local05, objptr
	mov	local11, ##515
	add	local05, #4
	wrlong	##515, local05
	sub	local05, #4
	sub	objptr, ##43216
LR__0130
' 
' ' abbreviated command has to be at the position addptr
' 
' 
' 
' '2b determine a type of the line
' if isdec(lparts(0).part$) then linenum=val%(lparts(0).part$)
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	call	#_isdec
	cmp	result1, #0 wz
 if_e	jmp	#LR__0131
	add	objptr, ##43216
	rdlong	arg01, objptr
	sub	objptr, ##43216
	mov	arg02, #0
	call	#__system____builtin_atoi
	add	objptr, ##62804
	wrlong	result1, objptr
	sub	objptr, ##62804
LR__0131
' 
' if linenum>0 andalso k=1 andalso cont=3 then deleteline(linenum) : goto 104
	add	objptr, ##62804
	rdlong	local01, objptr
	sub	objptr, ##62804
	cmp	local01, #1 wc
 if_b	jmp	#LR__0132
	cmp	local15, #1 wz
 if_e	add	objptr, ##44264
 if_e	rdlong	local05, objptr
 if_e	sub	objptr, ##44264
 if_e	cmp	local05, #3 wz
 if_ne	jmp	#LR__0132
	add	objptr, ##62804
	rdlong	arg01, objptr
	sub	objptr, ##62804
	call	#_deleteline
	jmp	#LR__0149
LR__0132
' 
' if linenum>0  andalso (cont=0 orelse cont=3) andalso lparts(2).token<>token_eq  then  
	add	objptr, ##62804
	rdlong	local01, objptr
	sub	objptr, ##62804
	cmp	local01, #1 wc
 if_b	jmp	#LR__0135
	add	objptr, ##44264
	rdlong	local05, objptr
	sub	objptr, ##44264
	mov	local09, local05 wz
 if_e	jmp	#LR__0133
	add	objptr, ##44264
	rdlong	local11, objptr
	sub	objptr, ##44264
	mov	local06, local11
	cmp	local06, #3 wz
 if_ne	jmp	#LR__0135
LR__0133
	add	objptr, ##43236
	rdlong	local13, objptr
	sub	objptr, ##43236
	mov	local10, local13
	cmp	local10, #27 wz
 if_e	jmp	#LR__0135
	add	objptr, ##62804
	rdlong	arg01, objptr
	sub	objptr, ##18540
	rdlong	arg03, objptr
	sub	objptr, ##44264
	mov	arg02, #0
	call	#_compile
	mov	local02, result1 wz
'   err= compile(linenum,0,cont) ': print "called compile with cont=";cont, "line$=";line$
'   if err<>0 then printerror(err): goto 104
 if_e	jmp	#LR__0134
	mov	arg01, local02
	call	#_printerror
	jmp	#LR__0149
LR__0134
'   if rest$<>"" then  line$=rest$ : cont=4 : goto 108 else goto 104
	add	objptr, ##62848
	rdlong	arg01, objptr
	sub	objptr, ##62848
	mov	arg02, ##@LR__4369
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0149
	add	objptr, ##62848
	rdlong	local01, objptr
	sub	objptr, ##18592
	wrlong	local01, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##44264
	jmp	#LR__0020
LR__0135
'       							
' if linenum>0 andalso (cont=1 orelse cont=2) andalso lparts(1).token<>token_eq  then 
	add	objptr, ##62804
	rdlong	local01, objptr
	sub	objptr, ##62804
	cmp	local01, #1 wc
 if_b	jmp	#LR__0138
	add	objptr, ##44264
	rdlong	local05, objptr
	sub	objptr, ##44264
	cmp	local05, #1 wz
 if_e	jmp	#LR__0136
	add	objptr, ##44264
	rdlong	local11, objptr
	sub	objptr, ##44264
	mov	local06, local11
	cmp	local06, #2 wz
 if_ne	jmp	#LR__0138
LR__0136
	add	objptr, ##43228
	rdlong	local13, objptr
	sub	objptr, ##43228
	mov	local10, local13
	cmp	local10, #27 wz
 if_e	jmp	#LR__0138
	add	objptr, ##62804
	rdlong	arg01, objptr
	sub	objptr, ##18540
	rdlong	arg03, objptr
	sub	objptr, ##44264
	mov	arg02, #0
	call	#_compile
	mov	local02, result1 wz
'   err= compile(linenum,0,cont) ': print "called compile with cont=";cont, "line$=";line$
'   if err<>0 then printerror(err): goto 104
 if_e	jmp	#LR__0137
	mov	arg01, local02
	call	#_printerror
	jmp	#LR__0149
LR__0137
'   if rest$<>"" then line$=rest$: cont=4 : goto 108 else goto 104  	
	add	objptr, ##62848
	rdlong	arg01, objptr
	sub	objptr, ##62848
	mov	arg02, ##@LR__4370
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0149
	add	objptr, ##62848
	rdlong	local01, objptr
	sub	objptr, ##18592
	wrlong	local01, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##44264
	jmp	#LR__0020
LR__0138
' 							 
' if linenum>0 andalso (cont=0 orelse cont=3) andalso lparts(2).token=token_eq then  
	add	objptr, ##62804
	rdlong	local01, objptr
	sub	objptr, ##62804
	cmp	local01, #1 wc
 if_b	jmp	#LR__0140
	add	objptr, ##44264
	rdlong	local05, objptr wz
	sub	objptr, ##44264
 if_e	jmp	#LR__0139
	add	objptr, ##44264
	rdlong	local11, objptr
	sub	objptr, ##44264
	mov	local06, local11
	cmp	local06, #3 wz
 if_ne	jmp	#LR__0140
LR__0139
	add	objptr, ##43236
	rdlong	local13, objptr
	sub	objptr, ##43236
	mov	local10, local13
	cmp	local10, #27 wz
 if_ne	jmp	#LR__0140
	add	objptr, ##62804
	rdlong	arg01, objptr
	sub	objptr, ##18540
	rdlong	arg03, objptr
	sub	objptr, ##44264
	mov	arg02, #0
	call	#_compile_assign
'   compile_assign(linenum,0,cont)': print "called compile_assign with cont=";cont, "line$=";line$
'   if rest$<>"" then line$=rest$: cont=4 : goto 108 else goto 104
	add	objptr, ##62848
	rdlong	arg01, objptr
	sub	objptr, ##62848
	mov	arg02, ##@LR__4371
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0149
	add	objptr, ##62848
	rdlong	local01, objptr
	sub	objptr, ##18592
	wrlong	local01, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##44264
	jmp	#LR__0020
LR__0140
'     							 
' if linenum>0 andalso (cont=1 orelse cont=2) andalso lparts(1).token=token_eq then 
	add	objptr, ##62804
	rdlong	local01, objptr
	sub	objptr, ##62804
	cmp	local01, #1 wc
 if_b	jmp	#LR__0141
	add	objptr, ##44264
	rdlong	local05, objptr
	sub	objptr, ##44264
	cmp	local05, #1 wz
 if_ne	add	objptr, ##44264
 if_ne	rdlong	local11, objptr
 if_ne	sub	objptr, ##44264
 if_ne	cmp	local11, #2 wz
 if_e	add	objptr, ##43228
 if_e	rdlong	local13, objptr
 if_e	sub	objptr, ##43228
 if_e	mov	local10, local13
 if_e	cmp	local10, #27 wz
 if_ne	jmp	#LR__0141
	add	objptr, ##62804
	rdlong	arg01, objptr
	sub	objptr, ##18540
	rdlong	arg03, objptr
	sub	objptr, ##44264
	mov	arg02, #0
	call	#_compile_assign
'   compile_assign(linenum,0,cont) ': print "called compile_assign with cont=";cont, "line$=";line$
'   if rest$<>"" then line$=rest$: cont=4 : goto 108 else goto 104  								'<-- TODO: add a line to a program
	add	objptr, ##62848
	rdlong	arg01, objptr
	sub	objptr, ##62848
	mov	arg02, ##@LR__4372
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0149
	add	objptr, ##62848
	rdlong	local01, objptr
	sub	objptr, ##18592
	wrlong	local01, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##44264
	jmp	#LR__0020
LR__0141
' 
' if lparts(0).token=token_name andalso lparts(1).token=token_eq then compile_assign(0) : goto 103    					' assign a variable
	add	objptr, ##43220
	rdlong	local01, objptr
	sub	objptr, ##43220
	cmp	local01, ##516 wz
 if_e	add	objptr, ##43228
 if_e	rdlong	local09, objptr
 if_e	sub	objptr, ##43228
 if_e	cmp	local09, #27 wz
 if_ne	jmp	#LR__0142
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#_compile_assign
	jmp	#LR__0144
LR__0142
' if lparts(0).token=token_name andalso lparts(1).token=token_rpar then print " User functions and arrays not yet implemented" : goto 101
	add	objptr, ##43220
	rdlong	local01, objptr
	sub	objptr, ##43220
	cmp	local01, ##516 wz
 if_e	add	objptr, ##43228
 if_e	rdlong	local09, objptr
 if_e	sub	objptr, ##43228
 if_e	cmp	local09, #20 wz
 if_ne	jmp	#LR__0143
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4373
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	jmp	#LR__0148
LR__0143
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#_compile
	mov	local02, result1
LR__0144
' 
' ' if we are here, this is not a program line to add, so try to execute this
' 
' err=compile(0) : '' execute(0) ' print "  this is a command to execute"  ''' param=line to compile
' 103  'for i=0 to lineptr: print compiledline(i).result_type;" ";compiledline(i).result.uresult, : next i
' if err=0 then execute_line() else printerror(err)
	cmp	local02, #0 wz
 if_ne	jmp	#LR__0145
	mov	arg01, #0
	call	#_execute_line
	jmp	#LR__0146
LR__0145
	mov	arg01, local02
	call	#_printerror
LR__0146
' if rest$<>"" then line$=rest$:  goto 108 
	add	objptr, ##62848
	rdlong	arg01, objptr
	sub	objptr, ##62848
	mov	arg02, ##@LR__4374
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0147
	add	objptr, ##62848
	rdlong	local01, objptr
	sub	objptr, ##18592
	wrlong	local01, objptr
	sub	objptr, ##44256
	jmp	#LR__0020
LR__0147
LR__0148
	mov	arg01, ##@LR__4375
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
	mov	arg01, ##@LR__4376
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
LR__0149
	mov	ptra, fp
	call	#popregs_
_interpret_ret
	ret

' 
' 
' '------------------------------ Helper functions for the tokenizer -------------------------------------------
' 
' function isoperator(s as string) as ubyte
_isoperator
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__4377
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0150
	mov	arg02, ##@LR__4378
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0151
	mov	arg02, ##@LR__4379
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0152
	mov	arg02, ##@LR__4380
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0153
	mov	arg02, ##@LR__4381
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0154
	mov	arg02, ##@LR__4382
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0155
	mov	arg02, ##@LR__4383
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0156
	mov	arg02, ##@LR__4384
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0157
	mov	arg02, ##@LR__4385
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0158
	mov	arg02, ##@LR__4386
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0159
	mov	arg02, ##@LR__4387
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0160
	mov	arg02, ##@LR__4388
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0161
	mov	arg02, ##@LR__4389
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0162
	mov	arg02, ##@LR__4390
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0163
	mov	arg02, ##@LR__4391
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0164
	mov	arg02, ##@LR__4392
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0165
	mov	arg02, ##@LR__4393
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0166
	mov	arg02, ##@LR__4394
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0167
	mov	arg02, ##@LR__4395
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0168
	mov	arg02, ##@LR__4396
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0169
	mov	arg02, ##@LR__4397
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0170
	mov	arg02, ##@LR__4398
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0171
	jmp	#LR__0172
LR__0150
	mov	result1, #1
	jmp	#LR__0173
LR__0151
	mov	result1, #2
	jmp	#LR__0173
LR__0152
	mov	result1, #3
	jmp	#LR__0173
LR__0153
	mov	result1, #4
	jmp	#LR__0173
LR__0154
	mov	result1, #5
	jmp	#LR__0173
LR__0155
	mov	result1, #6
	jmp	#LR__0173
LR__0156
	mov	result1, #7
	jmp	#LR__0173
LR__0157
	mov	result1, #8
	jmp	#LR__0173
LR__0158
	mov	result1, #9
	jmp	#LR__0173
LR__0159
	mov	result1, #10
	jmp	#LR__0173
LR__0160
	mov	result1, #11
	jmp	#LR__0173
LR__0161
	mov	result1, #12
	jmp	#LR__0173
LR__0162
	mov	result1, #13
	jmp	#LR__0173
LR__0163
	mov	result1, #14
	jmp	#LR__0173
LR__0164
	mov	result1, #27
	jmp	#LR__0173
LR__0165
	mov	result1, #39
	jmp	#LR__0173
LR__0166
	mov	result1, #38
	jmp	#LR__0173
LR__0167
	mov	result1, #16
	jmp	#LR__0173
LR__0168
	mov	result1, #15
	jmp	#LR__0173
LR__0169
	mov	result1, #42
	jmp	#LR__0173
LR__0170
	mov	result1, #40
	jmp	#LR__0173
LR__0171
	mov	result1, #41
	jmp	#LR__0173
LR__0172
	mov	result1, #0
LR__0173
	mov	ptra, fp
	call	#popregs_
_isoperator_ret
	ret

' 
' function isseparator(s as string) as ubyte
_isseparator
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__4399
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0180
	mov	arg02, ##@LR__4400
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0181
	mov	arg02, ##@LR__4401
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0182
	mov	arg02, ##@LR__4402
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0183
	mov	arg02, ##@LR__4403
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0184
	mov	arg02, ##@LR__4404
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0185
	mov	arg02, ##@LR__4405
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0186
	mov	arg02, ##@LR__4406
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0187
	mov	arg02, ##@LR__4407
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0188
	mov	arg02, ##@LR__4408
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0189
	mov	arg02, ##@LR__4409
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0190
	mov	arg02, ##@LR__4410
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0191
	mov	arg02, ##@LR__4411
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0192
	mov	arg02, ##@LR__4412
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0193
	mov	arg02, ##@LR__4413
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0194
	jmp	#LR__0195
LR__0180
	mov	result1, #1
	jmp	#LR__0196
LR__0181
	mov	result1, #2
	jmp	#LR__0196
LR__0182
	mov	result1, #27
	jmp	#LR__0196
LR__0183
	mov	result1, #17
	jmp	#LR__0196
LR__0184
	mov	result1, #5
	jmp	#LR__0196
LR__0185
	mov	result1, #6
	jmp	#LR__0196
LR__0186
	mov	result1, #18
	jmp	#LR__0196
LR__0187
	mov	result1, #19
	jmp	#LR__0196
LR__0188
	mov	result1, #12
	jmp	#LR__0196
LR__0189
	mov	result1, #20
	jmp	#LR__0196
LR__0190
	mov	result1, #21
	jmp	#LR__0196
LR__0191
	mov	result1, #22
	jmp	#LR__0196
LR__0192
	mov	result1, #511
	jmp	#LR__0196
LR__0193
	mov	result1, #15
	jmp	#LR__0196
LR__0194
	mov	result1, #16
	jmp	#LR__0196
LR__0195
	mov	result1, #0
LR__0196
	mov	ptra, fp
	call	#popregs_
_isseparator_ret
	ret

' 
' 
' function iscommand(s as string) as ubyte
_iscommand
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__4415
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0200
	mov	arg02, ##@LR__4416
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0201
	mov	arg02, ##@LR__4417
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0202
	mov	arg02, ##@LR__4418
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0203
	mov	arg02, ##@LR__4419
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0204
	mov	arg02, ##@LR__4420
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0205
	mov	arg02, ##@LR__4421
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0206
	mov	arg02, ##@LR__4422
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0207
	mov	arg02, ##@LR__4423
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0208
	mov	arg02, ##@LR__4424
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0209
	mov	arg02, ##@LR__4425
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0210
	mov	arg02, ##@LR__4426
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0211
	mov	arg02, ##@LR__4427
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0212
	mov	arg02, ##@LR__4428
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0213
	mov	arg02, ##@LR__4429
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0214
	mov	arg02, ##@LR__4430
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0215
	mov	arg02, ##@LR__4431
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0216
	mov	arg02, ##@LR__4432
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0217
	mov	arg02, ##@LR__4433
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0218
	mov	arg02, ##@LR__4434
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0219
	mov	arg02, ##@LR__4435
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0220
	mov	arg02, ##@LR__4436
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0221
	mov	arg02, ##@LR__4437
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0222
	mov	arg02, ##@LR__4438
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0223
	mov	arg02, ##@LR__4439
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0224
	mov	arg02, ##@LR__4440
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0225
	mov	arg02, ##@LR__4441
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0226
	mov	arg02, ##@LR__4442
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0227
	mov	arg02, ##@LR__4443
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0228
	mov	arg02, ##@LR__4444
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0229
	mov	arg02, ##@LR__4445
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0230
	mov	arg02, ##@LR__4446
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0231
	mov	arg02, ##@LR__4447
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0232
	mov	arg02, ##@LR__4448
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0233
	mov	arg02, ##@LR__4449
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0234
	mov	arg02, ##@LR__4450
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0235
	mov	arg02, ##@LR__4451
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0236
	mov	arg02, ##@LR__4452
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0237
	mov	arg02, ##@LR__4453
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0238
	mov	arg02, ##@LR__4454
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0239
	mov	arg02, ##@LR__4455
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0240
	mov	arg02, ##@LR__4456
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0241
	mov	arg02, ##@LR__4457
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0242
	mov	arg02, ##@LR__4458
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0243
	mov	arg02, ##@LR__4459
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0244
	mov	arg02, ##@LR__4460
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0245
	mov	arg02, ##@LR__4461
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0246
	mov	arg02, ##@LR__4462
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0247
	mov	arg02, ##@LR__4463
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0248
	mov	arg02, ##@LR__4464
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0249
	mov	arg02, ##@LR__4465
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0250
	mov	arg02, ##@LR__4466
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0251
	mov	arg02, ##@LR__4467
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0252
	mov	arg02, ##@LR__4468
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0253
	mov	arg02, ##@LR__4469
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0254
	mov	arg02, ##@LR__4470
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0255
	mov	arg02, ##@LR__4471
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0256
	mov	arg02, ##@LR__4472
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0257
	mov	arg02, ##@LR__4473
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0258
	mov	arg02, ##@LR__4474
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0259
	mov	arg02, ##@LR__4475
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0260
	mov	arg02, ##@LR__4476
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0261
	mov	arg02, ##@LR__4477
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0262
	mov	arg02, ##@LR__4478
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0263
	mov	arg02, ##@LR__4479
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0264
	mov	arg02, ##@LR__4480
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0265
	mov	arg02, ##@LR__4481
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0266
	mov	arg02, ##@LR__4482
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0267
	mov	arg02, ##@LR__4483
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0268
	mov	arg02, ##@LR__4484
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0269
	mov	arg02, ##@LR__4485
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0270
	mov	arg02, ##@LR__4486
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0271
	mov	arg02, ##@LR__4487
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0272
	mov	arg02, ##@LR__4488
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0273
	mov	arg02, ##@LR__4489
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0274
	mov	arg02, ##@LR__4490
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0275
	mov	arg02, ##@LR__4491
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0276
	mov	arg02, ##@LR__4492
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0277
	mov	arg02, ##@LR__4493
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0278
	mov	arg02, ##@LR__4494
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0279
	jmp	#LR__0280
LR__0200
	mov	result1, #92
	jmp	#LR__0281
LR__0201
	mov	result1, #92
	jmp	#LR__0281
LR__0202
	mov	result1, #71
	jmp	#LR__0281
LR__0203
	mov	result1, #89
	jmp	#LR__0281
LR__0204
	mov	result1, #89
	jmp	#LR__0281
LR__0205
	mov	result1, #69
	jmp	#LR__0281
LR__0206
	mov	result1, #69
	jmp	#LR__0281
LR__0207
	mov	result1, #105
	jmp	#LR__0281
LR__0208
	mov	result1, #64
	jmp	#LR__0281
LR__0209
	mov	result1, #73
	jmp	#LR__0281
LR__0210
	mov	result1, #73
	jmp	#LR__0281
LR__0211
	mov	result1, #80
	jmp	#LR__0281
LR__0212
	mov	result1, #80
	jmp	#LR__0281
LR__0213
	mov	result1, #104
	jmp	#LR__0281
LR__0214
	mov	result1, #115
	jmp	#LR__0281
LR__0215
	mov	result1, #116
	jmp	#LR__0281
LR__0216
	mov	result1, #108
	jmp	#LR__0281
LR__0217
	mov	result1, #108
	jmp	#LR__0281
LR__0218
	mov	result1, #137
	jmp	#LR__0281
LR__0219
	mov	result1, #114
	jmp	#LR__0281
LR__0220
	mov	result1, #93
	jmp	#LR__0281
LR__0221
	mov	result1, #67
	jmp	#LR__0281
LR__0222
	mov	result1, #67
	jmp	#LR__0281
LR__0223
	mov	result1, #90
	jmp	#LR__0281
LR__0224
	mov	result1, #70
	jmp	#LR__0281
LR__0225
	mov	result1, #70
	jmp	#LR__0281
LR__0226
	mov	result1, #113
	jmp	#LR__0281
LR__0227
	mov	result1, #113
	jmp	#LR__0281
LR__0228
	mov	result1, #96
	jmp	#LR__0281
LR__0229
	mov	result1, #74
	jmp	#LR__0281
LR__0230
	mov	result1, #74
	jmp	#LR__0281
LR__0231
	mov	result1, #72
	jmp	#LR__0281
LR__0232
	mov	result1, #72
	jmp	#LR__0281
LR__0233
	mov	result1, #78
	jmp	#LR__0281
LR__0234
	mov	result1, #78
	jmp	#LR__0281
LR__0235
	mov	result1, #88
	jmp	#LR__0281
LR__0236
	mov	result1, #95
	jmp	#LR__0281
LR__0237
	mov	result1, #95
	jmp	#LR__0281
LR__0238
	mov	result1, #138
	jmp	#LR__0281
LR__0239
	mov	result1, #76
	jmp	#LR__0281
LR__0240
	mov	result1, #76
	jmp	#LR__0281
LR__0241
	mov	result1, #82
	jmp	#LR__0281
LR__0242
	mov	result1, #82
	jmp	#LR__0281
LR__0243
	mov	result1, #97
	jmp	#LR__0281
LR__0244
	mov	result1, #97
	jmp	#LR__0281
LR__0245
	mov	result1, #99
	jmp	#LR__0281
LR__0246
	mov	result1, #65
	jmp	#LR__0281
LR__0247
	mov	result1, #75
	jmp	#LR__0281
LR__0248
	mov	result1, #75
	jmp	#LR__0281
LR__0249
	mov	result1, #94
	jmp	#LR__0281
LR__0250
	mov	result1, #94
	jmp	#LR__0281
LR__0251
	mov	result1, #124
	jmp	#LR__0281
LR__0252
	mov	result1, #126
	jmp	#LR__0281
LR__0253
	mov	result1, #125
	jmp	#LR__0281
LR__0254
	mov	result1, #127
	jmp	#LR__0281
LR__0255
	mov	result1, #128
	jmp	#LR__0281
LR__0256
	mov	result1, #85
	jmp	#LR__0281
LR__0257
	mov	result1, #117
	jmp	#LR__0281
LR__0258
	mov	result1, #66
	jmp	#LR__0281
LR__0259
	mov	result1, #66
	jmp	#LR__0281
LR__0260
	mov	result1, #129
	jmp	#LR__0281
LR__0261
	mov	result1, #129
	jmp	#LR__0281
LR__0262
	mov	result1, #68
	jmp	#LR__0281
LR__0263
	mov	result1, #68
	jmp	#LR__0281
LR__0264
	mov	result1, #136
	jmp	#LR__0281
LR__0265
	mov	result1, #77
	jmp	#LR__0281
LR__0266
	mov	result1, #81
	jmp	#LR__0281
LR__0267
	mov	result1, #81
	jmp	#LR__0281
LR__0268
	mov	result1, #117
	jmp	#LR__0281
LR__0269
	mov	result1, #117
	jmp	#LR__0281
LR__0270
	mov	result1, #109
	jmp	#LR__0281
LR__0271
	mov	result1, #109
	jmp	#LR__0281
LR__0272
	mov	result1, #91
	jmp	#LR__0281
LR__0273
	mov	result1, #86
	jmp	#LR__0281
LR__0274
	mov	result1, #112
	jmp	#LR__0281
LR__0275
	mov	result1, #112
	jmp	#LR__0281
LR__0276
	mov	result1, #87
	jmp	#LR__0281
LR__0277
	mov	result1, #87
	jmp	#LR__0281
LR__0278
	mov	result1, #119
	jmp	#LR__0281
LR__0279
	mov	result1, #120
	jmp	#LR__0281
LR__0280
	mov	result1, #0
LR__0281
	mov	ptra, fp
	call	#popregs_
_iscommand_ret
	ret

' 
' function isfunction(s as string) as ubyte
_isfunction
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__4495
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0290
	mov	arg02, ##@LR__4496
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0291
	mov	arg02, ##@LR__4497
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0292
	mov	arg02, ##@LR__4498
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0293
	mov	arg02, ##@LR__4499
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0294
	mov	arg02, ##@LR__4500
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0295
	mov	arg02, ##@LR__4501
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0296
	mov	arg02, ##@LR__4502
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0297
	mov	arg02, ##@LR__4503
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0298
	mov	arg02, ##@LR__4504
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0299
	mov	arg02, ##@LR__4505
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0300
	mov	arg02, ##@LR__4506
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0301
	mov	arg02, ##@LR__4507
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0302
	mov	arg02, ##@LR__4508
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0303
	mov	arg02, ##@LR__4509
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0304
	mov	arg02, ##@LR__4510
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0305
	mov	arg02, ##@LR__4511
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0306
	mov	arg02, ##@LR__4512
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0307
	mov	arg02, ##@LR__4513
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0308
	mov	arg02, ##@LR__4514
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0309
	jmp	#LR__0310
LR__0290
	mov	result1, #133
	jmp	#LR__0311
LR__0291
	mov	result1, #132
	jmp	#LR__0311
LR__0292
	mov	result1, #134
	jmp	#LR__0311
LR__0293
	mov	result1, #130
	jmp	#LR__0311
LR__0294
	mov	result1, #111
	jmp	#LR__0311
LR__0295
	mov	result1, #111
	jmp	#LR__0311
LR__0296
	mov	result1, #98
	jmp	#LR__0311
LR__0297
	mov	result1, #102
	jmp	#LR__0311
LR__0298
	mov	result1, #103
	jmp	#LR__0311
LR__0299
	mov	result1, #100
	jmp	#LR__0311
LR__0300
	mov	result1, #101
	jmp	#LR__0311
LR__0301
	mov	result1, #123
	jmp	#LR__0311
LR__0302
	mov	result1, #118
	jmp	#LR__0311
LR__0303
	mov	result1, #122
	jmp	#LR__0311
LR__0304
	mov	result1, #84
	jmp	#LR__0311
LR__0305
	mov	result1, #107
	jmp	#LR__0311
LR__0306
	mov	result1, #135
	jmp	#LR__0311
LR__0307
	mov	result1, #106
	jmp	#LR__0311
LR__0308
	mov	result1, #110
	jmp	#LR__0311
LR__0309
	mov	result1, #131
	jmp	#LR__0311
LR__0310
	mov	result1, #0
LR__0311
	mov	ptra, fp
	call	#popregs_
_isfunction_ret
	ret

' 
' function isname(s as string) as boolean
_isname
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0321-@LR__0320)>>2,fcache_load_ptr_
LR__0320
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0320
LR__0321
	sub	local02, arg01
	mov	result1, local02
	mov	local03, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0333
	mov	arg01, local01
	mov	arg02, #1
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
' m$=mid$(s,1,1) : if (m$<"a" orelse m$>"z")  andalso m$<>"_" then return false
	mov	arg02, ##@LR__4515
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0322
	mov	arg02, ##@LR__4516
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0323
LR__0322
	mov	arg02, ##@LR__4517
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0333
LR__0323
' if l>2 then 
	cmps	local03, #3 wc
 if_b	jmp	#LR__0332
'   for i=2 to l
	mov	local05, #2
	mov	local06, local03
	add	local06, #1
LR__0324
	cmps	local05, local06 wc
 if_ae	jmp	#LR__0331
	mov	arg01, local01
	mov	arg02, local05
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
'     m$=mid$(s,i,1) : if (i<l) andalso (m$<"a" orelse m$>"z") andalso (m$<"0" orelse m$>"9") andalso m$<>"_" andalso m$<>"." then return false
	cmps	local05, local03 wc
 if_ae	jmp	#LR__0327
	mov	arg02, ##@LR__4518
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0325
	mov	arg02, ##@LR__4519
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0327
LR__0325
	mov	arg02, ##@LR__4520
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0326
	mov	arg02, ##@LR__4521
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0327
LR__0326
	mov	local07, ##@LR__4522
	mov	arg01, local04
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0327
	mov	local08, ##@LR__4523
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local09, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0333
LR__0327
'     if (i=l) andalso (m$<"a" orelse m$>"z") andalso (m$<"0" orelse m$>"9") andalso m$<>"_" andalso m$<>"$" andalso m$<>"%" andalso m$<>"!" then return false
	cmp	local05, local03 wz
 if_ne	jmp	#LR__0330
	mov	local10, ##@LR__4524
	mov	arg01, local04
	mov	arg02, local10
	call	#__system___string_cmp
	mov	local11, result1
	cmps	local11, #0 wc
 if_b	jmp	#LR__0328
	mov	arg02, ##@LR__4525
	mov	arg01, local04
	call	#__system___string_cmp
	mov	local10, result1
	cmps	local10, #1 wc
 if_b	jmp	#LR__0330
LR__0328
	mov	arg02, ##@LR__4526
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0329
	mov	local09, ##@LR__4527
	mov	arg01, local04
	mov	arg02, local09
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0330
LR__0329
	mov	local09, ##@LR__4528
	mov	arg01, local04
	mov	arg02, local09
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	jmp	#LR__0330
	mov	local08, ##@LR__4529
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local09, result1 wz
 if_e	jmp	#LR__0330
	mov	local12, ##@LR__4530
	mov	local08, local12
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local07, result1 wz
 if_e	jmp	#LR__0330
	mov	local13, ##@LR__4531
	mov	local12, local13
	mov	arg01, local04
	mov	arg02, local12
	call	#__system___string_cmp
	mov	local08, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0333
LR__0330
	add	local05, #1
	jmp	#LR__0324
LR__0331
LR__0332
' return true
	neg	result1, #1
LR__0333
	mov	ptra, fp
	call	#popregs_
_isname_ret
	ret

' 
' function isnum(s as string) as boolean
_isnum
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	mov	local03, #0
	mov	arg01, local01
	mov	local04, arg01
	callpa	#(@LR__0341-@LR__0340)>>2,fcache_load_ptr_
LR__0340
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0340
LR__0341
	sub	local04, arg01
	mov	result1, local04
	mov	local05, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0352
	mov	arg01, local01
	mov	arg02, #1
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local06, result1
' m$=mid$(s,1,1) : if (m$<"0" orelse m$>"9") andalso m$<>"." andalso m$<>"$" andalso m$<>"%" andalso m$<>"-" then return false
	mov	arg02, ##@LR__4532
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0342
	mov	arg02, ##@LR__4533
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0343
LR__0342
	mov	arg02, ##@LR__4534
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0343
	mov	local07, ##@LR__4535
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0343
	mov	local08, ##@LR__4536
	mov	local07, local08
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	jmp	#LR__0343
	mov	local09, ##@LR__4537
	mov	local08, local09
	mov	arg01, local06
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local07, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0352
LR__0343
' if m$="." then ds=1
	mov	arg02, ##@LR__4538
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local02, #1
' if l>1 then 
	cmps	local05, #2 wc
 if_b	jmp	#LR__0351
'   for i=2 to l
	mov	local10, #2
	mov	local11, local05
	add	local11, #1
LR__0344
	cmps	local10, local11 wc
 if_ae	jmp	#LR__0350
	mov	arg01, local01
	mov	arg02, local10
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local06, result1
'     m$=mid$(s,i,1) : if (m$<"0" orelse m$>"9") andalso m$<>"_" andalso m$<>"." andalso m$<>"E" andalso m$<>"e" andalso m$<>"-" then return false
	mov	arg02, ##@LR__4539
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0345
	mov	arg02, ##@LR__4540
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0346
LR__0345
	mov	arg02, ##@LR__4541
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0346
	mov	local07, ##@LR__4542
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	jmp	#LR__0346
	mov	local08, ##@LR__4543
	mov	local07, local08
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	mov	local12, result1 wz
 if_e	jmp	#LR__0346
	mov	local09, ##@LR__4544
	mov	local08, local09
	mov	arg01, local06
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local07, result1 wz
 if_e	jmp	#LR__0346
	mov	local13, ##@LR__4545
	mov	local09, local13
	mov	arg01, local06
	mov	arg02, local09
	call	#__system___string_cmp
	mov	local08, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0352
LR__0346
'     if m$="-" andalso lcase$(mid$(s,i-1,1))<>"e" then return false
	mov	arg02, ##@LR__4546
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0347
	mov	arg02, local10
	sub	arg02, #1
	mov	arg01, local01
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	call	#__system__LCase_S
	mov	arg01, result1
	mov	arg02, ##@LR__4547
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0352
LR__0347
'     if m$="." then ds+=1: if ds>1 then return false
	mov	arg02, ##@LR__4548
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	local02, #1
 if_e	cmps	local02, #2 wc
 if_nc_and_z	mov	result1, #0
 if_nc_and_z	jmp	#LR__0352
'     if m$="E" orelse m$="e" then es+=1: if es>1 then return false
	mov	arg02, ##@LR__4549
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	jmp	#LR__0348
	mov	arg02, ##@LR__4550
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_ne	jmp	#LR__0349
LR__0348
	add	local03, #1
	cmps	local03, #2 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#LR__0352
LR__0349
	add	local10, #1
	jmp	#LR__0344
LR__0350
LR__0351
' return true
	neg	result1, #1
LR__0352
	mov	ptra, fp
	call	#popregs_
_isnum_ret
	ret

'   
' function isint(s as string) as boolean
_isint
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0361-@LR__0360)>>2,fcache_load_ptr_
LR__0360
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0360
LR__0361
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0369
	mov	arg01, local01
	mov	arg02, #1
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local03, result1
' m$=mid$(s,1,1) : if (m$<"0" orelse m$>"9") andalso m$<>"$" andalso m$<>"%" andalso m$<>"-" then return false
	mov	arg02, ##@LR__4551
	mov	arg01, local03
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0362
	mov	arg02, ##@LR__4552
	mov	arg01, local03
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0363
LR__0362
	mov	arg02, ##@LR__4553
	mov	arg01, local03
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0363
	mov	arg02, ##@LR__4554
	mov	arg01, local03
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0363
	mov	arg02, ##@LR__4555
	mov	arg01, local03
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0369
LR__0363
' 
' if l>1 then 
	cmps	local02, #2 wc
 if_b	jmp	#LR__0368
'   for i=2 to l
	mov	local04, #2
	mov	local05, local02
	add	local05, #1
LR__0364
	cmps	local04, local05 wc
 if_ae	jmp	#LR__0367
	mov	arg01, local01
	mov	arg02, local04
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local03, result1
'     m$=mid$(s,i,1) : if (m$<"0" orelse m$>"9") andalso m$<>"_"  then return false
	mov	arg02, ##@LR__4556
	mov	arg01, local03
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0365
	mov	arg02, ##@LR__4557
	mov	arg01, local03
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0366
LR__0365
	mov	arg02, ##@LR__4558
	mov	arg01, local03
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0369
LR__0366
	add	local04, #1
	jmp	#LR__0364
LR__0367
LR__0368
' return true
	neg	result1, #1
LR__0369
	mov	ptra, fp
	call	#popregs_
_isint_ret
	ret

' 
' function isdec(s as string) as boolean
_isdec
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0371-@LR__0370)>>2,fcache_load_ptr_
LR__0370
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0370
LR__0371
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0376
' for i=1 to l
	mov	local03, #1
	mov	local04, local02
	add	local04, #1
LR__0372
	cmps	local03, local04 wc
 if_ae	jmp	#LR__0375
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local05, result1
'     m$=mid$(s,i,1) : if (m$<"0" orelse m$>"9") andalso m$<>"_"  then return false
	mov	arg02, ##@LR__4559
	mov	arg01, local05
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0373
	mov	arg02, ##@LR__4560
	mov	arg01, local05
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0374
LR__0373
	mov	arg02, ##@LR__4561
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0376
LR__0374
	add	local03, #1
	jmp	#LR__0372
LR__0375
' return true
	neg	result1, #1
LR__0376
	mov	ptra, fp
	call	#popregs_
_isdec_ret
	ret

' 
' function isstring(s as string) as boolean
_isstring
	mov	COUNT_, #1
	call	#pushregs_
' if left$(s,1)="""" andalso right$(s,1)="""" then return true else return false
	mov	local01, arg01
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__4562
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_ne	jmp	#LR__0380
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__4563
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__0381
LR__0380
	mov	result1, #0
LR__0381
	mov	ptra, fp
	call	#popregs_
_isstring_ret
	ret

' 
' '--------------------- The end of interpreter/tokenizer functions ----------------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '----------------------Reverse Polish notation precompiler -----------------------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '----- delete a line from a program
' 
' function deleteline(aline as ulong) as integer
_deleteline
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #44
	add	fp, #4
	wrlong	arg01, fp
	add	objptr, ##54088
	rdlong	local01, objptr
	add	fp, #12
	wrlong	local01, fp
	sub	fp, #16
' 
' 
' searchptr=programstart
' 
' do
	sub	objptr, ##48264
LR__0390
	add	fp, #20
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #16
	mov	arg03, #24
	call	#_psram_spin2_read1
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #8
	wrlong	local01, fp
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #24
	wrlong	local01, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #16
	rdlong	arg03, fp
	sub	fp, #4
	cmp	local01, arg03 wc
 if_b	add	fp, #40
 if_b	rdlong	local02, fp
 if_b	sub	fp, #40
 if_b	cmp	local02, ##2147483647 wz
 if_c_and_nz	jmp	#LR__0390
	sub	objptr, ##5824
' 
' 
' if header(0)<>aline then return -1
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #16
	rdlong	local03, fp
	sub	fp, #4
	cmp	local01, local03 wz
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__0396
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	neg	arg02, #1
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
' 
' pslpoke(lineptr2,$FFFF_FFFF) ' flag the deleted line
' 
' if header(5)=$7FFF_FFFF andalso header(4)=$FFFF_FFFF then  ' this is one and only line in the program
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmp	local01, ##2147483647 wz
 if_e	add	fp, #36
 if_e	rdlong	local03, fp
 if_e	sub	fp, #36
 if_e	cmp	local03, ##-1 wz
 if_ne	jmp	#LR__0391
	add	objptr, ##54088
	wrlong	#0, objptr
	sub	objptr, ##3624
	wrlong	#0, objptr
	add	objptr, ##3628
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	mov	arg01, #0
	neg	arg02, #1
	mov	arg03, #1
	mov	arg04, #0
	sub	objptr, ##48272
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	mov	arg01, #16
	neg	arg02, #1
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	mov	arg01, #20
	bmask	arg02, #30
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	add	objptr, ##56244
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	#0, objptr
	sub	objptr, ##62072
LR__0391
' 
' if header(5)=$7FFF_FFFF andalso header(4)<>$FFFF_FFFF then ' this is the last, and not first, line of the program
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmp	local01, ##2147483647 wz
 if_ne	jmp	#LR__0392
	add	fp, #36
	rdlong	local03, fp
	sub	fp, #36
	cmp	local03, ##-1 wz
 if_e	jmp	#LR__0392
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #20
	bmask	arg02, #30
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	add	fp, #36
	rdlong	local01, fp
	add	objptr, ##48272
	wrlong	local01, objptr
	sub	objptr, ##54096
	rdlong	arg01, fp
	sub	fp, #36
	call	#_pslpeek
	add	objptr, ##54092
	wrlong	result1, objptr
	sub	objptr, ##54092
'   pslpoke(header(4)+20,$7FFF_FFFF) ' unlink the previous line
'   lastlineptr=header(4)            ' keep last line pointer to avoid searching while sequentially adding a new line
'   lastline=pslpeek(header(4))
'   return 0
	mov	result1, #0
	jmp	#LR__0396
LR__0392
' 
' if header(5)<>$7FFF_FFFF andalso header(4)=$FFFF_FFFF then ' this is the first line, but not the last
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmp	local01, ##2147483647 wz
 if_e	jmp	#LR__0393
	add	fp, #36
	rdlong	local03, fp
	sub	fp, #36
	cmp	local03, ##-1 wz
 if_ne	jmp	#LR__0393
	add	fp, #40
	rdlong	arg01, fp
	sub	fp, #40
	add	arg01, #16
	neg	arg02, #1
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	add	objptr, ##48264
	wrlong	local01, objptr
	sub	objptr, ##54088
' '   print "deleted first line"
'   pslpoke(header(5)+16,$FFFF_FFFF) 
'   programstart=header(5) ' adjust the program start to point on the first new line
'   return 0
	mov	result1, #0
	jmp	#LR__0396
LR__0393
' 
' if header(5)<>$7FFF_FFFF andalso header(4)<>$FFFF_FFFF then ' the line is not first and not last
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmp	local01, ##2147483647 wz
 if_ne	add	fp, #36
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #36
 if_ne	cmp	local03, ##-1 wz
 if_e	jmp	#LR__0394
	add	fp, #40
	rdlong	arg01, fp
	add	arg01, #16
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #36
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	add	fp, #36
	rdlong	arg01, fp
	add	arg01, #20
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #40
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
'    pslpoke(header(5)+16,header(4))  
'    pslpoke(header(4)+20, header(5))
'    return 0
	mov	result1, #0
	jmp	#LR__0396
LR__0394
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #8
	wrlong	local01, fp
	add	objptr, ##54088
	rdlong	local01, objptr
	add	fp, #8
	wrlong	local01, fp
	sub	fp, #16
' 
' 
' 
' ' now find if the deleted line was a target for goto and replace fast_goto with find_goto
' 
' lineptr2=searchptr
' searchptr=programstart
' 
' do
	sub	objptr, ##48264
LR__0395
	add	fp, #20
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #16
	mov	arg03, #24
	call	#_psram_spin2_read1
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #8
	wrlong	local01, fp
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #24
	wrlong	local01, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #16
	rdlong	local03, fp
	sub	fp, #4
	cmp	local01, local03 wc
 if_b	add	fp, #40
 if_b	rdlong	local02, fp
 if_b	sub	fp, #40
 if_b	cmp	local02, ##2147483647 wz
 if_c_and_nz	jmp	#LR__0395
	sub	objptr, ##5824
	mov	result1, #0
LR__0396
	mov	ptra, fp
	call	#popregs_
_deleteline_ret
	ret

' 
' sub save_line
_save_line
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, ##54080
	rdlong	arg03, objptr
	add	arg03, #1
	sub	objptr, ##2584
	rdlong	arg02, objptr
	qmul	arg02, arg03
	sub	objptr, ##7236
	rdlong	arg01, objptr
	sub	objptr, ##44260
	mov	local01, arg01
	getqx	local02
	callpa	#(@LR__0401-@LR__0400)>>2,fcache_load_ptr_
LR__0400
	rdbyte	result1, local01 wz
 if_ne	add	local01, #1
 if_ne	jmp	#LR__0400
LR__0401
	sub	local01, arg01
	test	local01, #3 wz
 if_ne	shr	local01, #2
 if_ne	add	local01, #1
 if_ne	shl	local01, #2
	mov	local03, local02
	add	local03, local01
	add	objptr, ##50464
	rdlong	arg03, objptr
	add	arg03, local02
	add	objptr, ##2088
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	local01, objptr
	sub	objptr, #12
	mov	arg01, objptr
	sub	objptr, ##2080
	rdlong	arg02, objptr
	mov	arg03, local02
	sub	objptr, ##44640
	call	#_psram_spin2_write
	add	objptr, ##38436
	rdlong	arg01, objptr
	add	objptr, ##6204
	rdlong	arg02, objptr
	add	arg02, local02
	mov	arg03, local01
	sub	objptr, ##44640
	call	#_psram_spin2_write
	add	objptr, ##44640
	rdlong	local01, objptr
	add	local01, local03
	wrlong	local01, objptr
	sub	objptr, ##50464
	mov	ptra, fp
	call	#popregs_
_save_line_ret
	ret

' 
' 
' function insertline(aline as ulong) as integer
_insertline
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #40
	add	fp, #4
	wrlong	arg01, fp
	add	objptr, ##54088
	rdlong	local01, objptr
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
' 
' do
	sub	objptr, ##48264
LR__0410
	add	fp, #16
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	mov	arg03, #24
	call	#_psram_spin2_read1
	add	fp, #8
	rdlong	local01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #24
	rdlong	local01, fp
	sub	fp, #28
	wrlong	local01, fp
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #12
	rdlong	arg03, fp
	sub	fp, #4
	cmp	local01, arg03 wc
 if_b	add	fp, #36
 if_b	rdlong	local02, fp
 if_b	sub	fp, #36
 if_b	cmp	local02, ##2147483647 wz
 if_c_and_nz	jmp	#LR__0410
	sub	objptr, ##5824
' 
' if header(0)=aline then return -1 ' delete it first
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #12
	rdlong	local02, fp
	sub	fp, #4
	cmp	local01, local02 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__0413
' if header(0)<aline then return -2 ' end of program reached
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #12
	rdlong	arg03, fp
	sub	fp, #4
	cmp	local01, arg03 wc
 if_b	neg	result1, #2
 if_b	jmp	#LR__0413
' 
' if  header(4)=$FFFF_FFFF then ' this is one first line in the program so the inserted line will be new first
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, ##-1 wz
 if_ne	jmp	#LR__0411
	add	objptr, ##50464
	rdlong	local01, objptr
	add	objptr, ##3624
	wrlong	local01, objptr
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #16
	sub	objptr, ##3624
	rdlong	arg02, objptr
	mov	arg03, #1
	mov	arg04, #0
	sub	objptr, ##44640
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	add	objptr, ##46736
	wrlong	##-1, objptr
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	add	objptr, #4
	wrlong	local01, objptr
	sub	objptr, ##52564
	call	#_save_line
'   programstart=programptr
'   pslpoke(lineptr2+16,programptr)
'   ucompiledline(4)=$FFFF_FFFF
'   ucompiledline(5)=lineptr2
'   save_line
'   return 0
	mov	result1, #0
	jmp	#LR__0413
LR__0411
' 
' if header(4)<>$FFFF_FFFF then ' this is not first line of the program. It doesn't matter if it is last as we will insert it before
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, ##-1 wz
 if_e	jmp	#LR__0412
	add	fp, #32
	rdlong	local01, fp
	add	objptr, ##52560
	wrlong	local01, objptr
	sub	fp, #20
	rdlong	local01, fp
	add	objptr, #4
	wrlong	local01, objptr
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #16
	sub	objptr, ##2100
	rdlong	arg02, objptr
	mov	arg03, #1
	mov	arg04, #0
	sub	objptr, ##44640
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	add	fp, #32
	rdlong	arg01, fp
	sub	fp, #32
	add	arg01, #20
	add	objptr, ##44640
	rdlong	arg02, objptr
	mov	arg03, #1
	mov	arg04, #0
	sub	objptr, ##44640
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	call	#_save_line
'   ucompiledline(4)=header(4)
'   ucompiledline(5)=lineptr2
'   pslpoke(lineptr2+16,programptr)
'   pslpoke(header(4)+20,programptr)
'   save_line
'   return 0
	mov	result1, #0
	jmp	#LR__0413
LR__0412
	mov	result1, #0
LR__0413
	mov	ptra, fp
	call	#popregs_
_insertline_ret
	ret

' 
' sub add_line_at_end(aline) 
_add_line_at_end
	add	objptr, ##54092
	wrlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##1536
	wrlong	arg02, objptr
	add	objptr, ##1536
	rdlong	arg01, objptr
	add	arg01, #20
	sub	objptr, ##3632
	rdlong	arg02, objptr
	mov	arg03, #1
	mov	arg04, #0
	sub	objptr, ##44640
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	add	objptr, ##44640
	rdlong	arg02, objptr
	add	objptr, ##3632
	wrlong	arg02, objptr
	sub	objptr, ##1532
	wrlong	##2147483647, objptr
' 
' lastline=aline: ucompiledline(4)=lastlineptr : pslpoke(lastlineptr+20,programptr) : lastlineptr=programptr : ucompiledline(5)=$7FFF_FFFF 
' if programptr=0 then ucompiledline(4)=$FFFFFFFF ' that is the first line
	sub	objptr, ##2100
	rdlong	arg02, objptr wz
	sub	objptr, ##50464
 if_e	add	objptr, ##52560
 if_e	wrlong	##-1, objptr
 if_e	sub	objptr, ##52560
	call	#_save_line
	add	objptr, ##50464
	rdlong	arg01, objptr
	neg	arg02, #1
	mov	arg03, #1
	mov	arg04, #0
	sub	objptr, ##44640
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
_add_line_at_end_ret
	ret

' 
' function compile_immediate(linetype as ulong) as integer
_compile_immediate
	mov	COUNT_, #9
	call	#pushregs_
_compile_immediate_enter
	mov	local04, arg01 wz
	mov	local05, #0
	mov	local06, #0
' 
' ' linetype=cont+1, linetype=0 immediate
' '  : 1: this is the first part of the line that will continue
' ' 2 - this is the continuation of the line
' ' 3 - this is the last continued line
' ' 4 - this is the one and only part
' 
' err=0
' cmd=0
' if linetype=0 then cmd=lparts(0).token : ct=1 : lineptr=0 
 if_ne	jmp	#LR__0420
	add	objptr, ##43220
	rdlong	local06, objptr
	add	objptr, ##1076
	wrlong	#1, objptr
	add	objptr, ##9784
	wrlong	#0, objptr
	sub	objptr, ##54080
LR__0420
' if linetype=2 orelse linetype=3 then cmd=lparts(0).token : ct=1 ' don't set lineptr
	cmp	local04, #2 wz
 if_ne	cmp	local04, #3 wz
 if_e	add	objptr, ##43220
 if_e	rdlong	local06, objptr
 if_e	add	objptr, ##1076
 if_e	wrlong	#1, objptr
 if_e	sub	objptr, ##44296
' if linetype=4 orelse linetype=1 then cmd=lparts(1).token : ct=2 : lineptr=2
	cmp	local04, #4 wz
 if_ne	cmp	local04, #1 wz
 if_ne	jmp	#LR__0421
	add	objptr, ##43228
	rdlong	local06, objptr
	add	objptr, ##1068
	wrlong	#2, objptr
	add	objptr, ##9784
	wrlong	#2, objptr
	sub	objptr, ##54080
LR__0421
' if linetype=5 then cmd=lparts(ct).token : ct+=1 ' continued after if/else
	cmp	local04, #5 wz
 if_ne	jmp	#LR__0422
	add	objptr, ##44296
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	add	local06, #4
	rdlong	local06, local06
	add	local07, #1
	add	objptr, ##1080
	wrlong	local07, objptr
	sub	objptr, ##44296
LR__0422
	mov	local08, #0
' vars=0
' 'print  "In compile_immediate cmd=:", cmd
' 451 select case cmd
	cmp	local06, #92 wz
 if_e	jmp	#LR__0423
	cmp	local06, #71 wz
 if_e	jmp	#LR__0424
	cmp	local06, #89 wz
 if_e	jmp	#LR__0425
	cmp	local06, #69 wz
 if_e	jmp	#LR__0426
	cmp	local06, #105 wz
 if_e	jmp	#LR__0427
	cmp	local06, #64 wz
 if_e	jmp	#LR__0471
	cmp	local06, #73 wz
 if_e	jmp	#LR__0428
	cmp	local06, #80 wz
 if_e	jmp	#LR__0429
	cmp	local06, #104 wz
 if_e	jmp	#LR__0430
	cmp	local06, #116 wz
 if_e	jmp	#LR__0431
	cmp	local06, #115 wz
 if_e	jmp	#LR__0432
	cmp	local06, #108 wz
 if_e	jmp	#LR__0433
	cmp	local06, #137 wz
 if_e	jmp	#LR__0471
	cmp	local06, #114 wz
 if_e	jmp	#LR__0434
	cmp	local06, #93 wz
 if_e	jmp	#LR__0471
	cmp	local06, #67 wz
 if_e	jmp	#LR__0435
	cmp	local06, #90 wz
 if_e	jmp	#LR__0436
	cmp	local06, #78 wz
 if_e	jmp	#LR__0437
	cmp	local06, #70 wz
 if_e	jmp	#LR__0439
	cmp	local06, #113 wz
 if_e	jmp	#LR__0440
	cmp	local06, #96 wz
 if_e	jmp	#LR__0441
	cmp	local06, #74 wz
 if_e	jmp	#LR__0442
	cmp	local06, #72 wz
 if_e	jmp	#LR__0443
	cmp	local06, #88 wz
 if_e	jmp	#LR__0444
	cmp	local06, #95 wz
 if_e	jmp	#LR__0445
	cmp	local06, #138 wz
 if_e	jmp	#LR__0446
	cmp	local06, #76 wz
 if_e	jmp	#LR__0447
	cmp	local06, #82 wz
 if_e	jmp	#LR__0448
	cmp	local06, #97 wz
 if_e	jmp	#LR__0449
	cmp	local06, #99 wz
 if_e	jmp	#LR__0450
	cmp	local06, #65 wz
 if_e	jmp	#LR__0471
	cmp	local06, #75 wz
 if_e	jmp	#LR__0451
	cmp	local06, #94 wz
 if_e	jmp	#LR__0452
	cmp	local06, #124 wz
 if_e	jmp	#LR__0453
	cmp	local06, #125 wz
 if_e	jmp	#LR__0454
	cmp	local06, #126 wz
 if_e	jmp	#LR__0455
	cmp	local06, #127 wz
 if_e	jmp	#LR__0456
	cmp	local06, #128 wz
 if_e	jmp	#LR__0457
	cmp	local06, #85 wz
 if_e	jmp	#LR__0458
	cmp	local06, #117 wz
 if_e	jmp	#LR__0459
	cmp	local06, #66 wz
 if_e	jmp	#LR__0460
	cmp	local06, #129 wz
 if_e	jmp	#LR__0461
	cmp	local06, #68 wz
 if_e	jmp	#LR__0462
	cmp	local06, #136 wz
 if_ne	cmp	local06, #77 wz
 if_e	jmp	#LR__0471
	cmp	local06, #81 wz
 if_e	jmp	#LR__0463
	cmp	local06, #109 wz
 if_e	jmp	#LR__0464
	cmp	local06, #112 wz
 if_e	jmp	#LR__0471
	cmp	local06, #86 wz
 if_e	jmp	#LR__0465
	cmp	local06, #87 wz
 if_e	jmp	#LR__0471
	cmp	local06, #121 wz
 if_e	jmp	#LR__0466
	cmp	local06, #119 wz
 if_e	jmp	#LR__0467
	cmp	local06, #120 wz
 if_e	jmp	#LR__0468
	cmp	local06, ##516 wz
 if_e	jmp	#LR__0469
	jmp	#LR__0470
LR__0423
	call	#_compile_fun_2p
	mov	local05, result1
	jmp	#LR__0471
LR__0424
	call	#_compile_fun_4p
	mov	local05, result1
	jmp	#LR__0471
LR__0425
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0426
	call	#_compile_fun_3p
	mov	local05, result1
	jmp	#LR__0471
LR__0427
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0428
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0429
	call	#_compile_fun_varp
	mov	local08, result1
	jmp	#LR__0471
LR__0430
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0431
	call	#_compile_fun_varp
	mov	local08, result1
	jmp	#LR__0471
LR__0432
	call	#_compile_fun_varp
	mov	local08, result1
	jmp	#LR__0471
LR__0433
	call	#_compile_fun_5p
	mov	local05, result1
	jmp	#LR__0471
LR__0434
	call	#_compile_dim
	jmp	#LR__0472
LR__0435
	call	#_compile_fun_2p
	mov	local05, result1
	jmp	#LR__0471
LR__0436
	call	#_compile_else
	jmp	#LR__0472
LR__0437
	cmp	local04, #1 wc
 if_b	jmp	#LR__0438
	call	#_compile_goto
	jmp	#LR__0472
LR__0438
	mov	arg01, #25
	call	#_printerror
	jmp	#LR__0472
LR__0439
	call	#_compile_fun_3p
	mov	local05, result1
	jmp	#LR__0471
LR__0440
	call	#_compile_fun_4p
	mov	local05, result1
	jmp	#LR__0471
LR__0441
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0442
	call	#_compile_for
	jmp	#LR__0472
LR__0443
	call	#_compile_fun_4p
	mov	local05, result1
	jmp	#LR__0471
LR__0444
	call	#_compile_if
	jmp	#LR__0472
LR__0445
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0446
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0447
	call	#_compile_fun_varp
	mov	local08, result1
	jmp	#LR__0471
LR__0448
	call	#_compile_fun_varp
	mov	local08, result1
	jmp	#LR__0471
LR__0449
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0450
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0451
	call	#_compile_next
	jmp	#LR__0472
LR__0452
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0453
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0454
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0455
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0456
	call	#_compile_fun_4p
	mov	local05, result1
	jmp	#LR__0471
LR__0457
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0458
	call	#_compile_fun_2p
	mov	local05, result1
	jmp	#LR__0471
LR__0459
	call	#_compile_fun_varp
	mov	local08, result1
	jmp	#LR__0471
LR__0460
	call	#_compile_fun_2p
	mov	local05, result1
	jmp	#LR__0471
LR__0461
	call	#_compile_fun_2p
	mov	local05, result1
	jmp	#LR__0471
LR__0462
	call	#_compile_print
	mov	local05, result1
	jmp	#LR__0472
LR__0463
	call	#_compile_fun_varp
	mov	local08, result1
	jmp	#LR__0471
LR__0464
	call	#_compile_fun_3p
	mov	local05, result1
	jmp	#LR__0471
LR__0465
	call	#_expr
' expr()
' return 0
	mov	local05, #0
	jmp	#LR__0471
LR__0466
	call	#_compile_fun_2p
	mov	local05, result1
	jmp	#LR__0471
LR__0467
	call	#_compile_fun_2p
	mov	local05, result1
	jmp	#LR__0471
LR__0468
	call	#_compile_fun_2p
	mov	local05, result1
	jmp	#LR__0471
LR__0469
	call	#_compile_array_assign
	jmp	#LR__0472
LR__0470
	call	#_compile_unknown
	jmp	#LR__0472
LR__0471
	mov	local03, local06
	mov	local01, local08
	mov	local07, local01
	mov	local09, local02
	mov	local01, local03
	add	objptr, ##54080
	rdlong	local08, objptr
	mov	local06, local08
	shl	local06, #1
	add	local06, local08
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	wrlong	local07, local06
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local07, local08
	shl	local07, #1
	add	local07, local08
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	add	local07, #4
	wrlong	local09, local07
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local08, local09
	shl	local08, #1
	add	local08, local09
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	add	local08, #8
	wrlong	local01, local08
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##54080
LR__0472
' 
' t3.result_type=cmd : t3.result.uresult=vars : compiledline(lineptr)=t3:  lineptr+=1
' 450 if linetype=0 orelse linetype=3 orelse linetype=4 then compiledline(lineptr).result_type=token_end ' end token if the last part or imm
	cmp	local04, #0 wz
 if_ne	cmp	local04, #3 wz
 if_ne	cmp	local04, #4 wz
 if_ne	jmp	#LR__0473
	add	objptr, ##54080
	rdlong	local09, objptr
	mov	local01, local09
	shl	local01, #1
	add	local01, local09
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	#510, local01
	sub	objptr, ##52544
LR__0473
' 
' ' print "In compile_immediate:" : for i=0 to lineptr: print compiledline(i).result_type;" ";compiledline(i).result.uresult, compiledline(i).result.twowords(1) : next i
' return err
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
_compile_immediate_ret
	ret

' 
' sub compile_array_assign
_compile_array_assign
	mov	COUNT_, #10
	call	#pushregs_
	mov	local04, #0
	add	objptr, ##44296
	rdlong	local05, objptr
	mov	result1, local05
	sub	result1, #1
	shl	result1, #3
	sub	objptr, ##1080
	add	result1, objptr
	rdlong	local06, result1
' numpar=0
' 'print "In array_assign, lparts(ct).token=",lparts(ct).token,lparts(ct).part$
' ' todo here: recognize params and t1.result.twowords=numpar
' varname$=lparts(ct-1).part$' : print "In array_assign, varname$=";varname$
' if lparts(ct).token=token_lpar then
	shl	local05, #3
	add	local05, objptr
	add	local05, #4
	rdlong	local05, local05
	cmp	local05, #21 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0484
	add	objptr, ##44296
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##44296
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__0480
	call	#_expr
	add	objptr, ##44296
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	add	local04, #1
	sub	local05, #1
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local07, local05
	cmp	local07, #20 wz
	sub	objptr, ##43216
 if_e	jmp	#LR__0481
	add	objptr, ##44296
	rdlong	local07, objptr
	shl	local07, #3
	sub	objptr, ##1080
	add	local07, objptr
	add	local07, #4
	rdlong	local07, local07
	cmp	local07, #510 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0480
LR__0481
	add	objptr, ##44296
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##44296
	call	#_expr
	neg	local08, #1
	mov	local09, #0
' '   print "in array_assign, rpar found, numpar=",numpar
'  'if lparts(ct).token=token_end then print "in getfun, end found, numpar=",numpar
' 'if lparts(ct).token<>token_eq then print "in array_assign,= expected" else print "in array_assign,= found"
' ct+=1 : expr()
' ' now find the vae
' 
' j=-1 : i=0 : do : 
LR__0482
'   if variables(i).name=varname$ then j=i: exit loop
	mov	local05, local09
	shl	local05, #4
	add	objptr, ##26828
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, local06
	sub	objptr, ##26828
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local08, local09
 if_e	jmp	#LR__0483
	add	local09, #1
	add	objptr, ##43212
	rdlong	local07, objptr
	sub	objptr, ##43212
	cmps	local09, local07 wcz
 if_be	jmp	#LR__0482
LR__0483
	mov	local01, local08
	mov	local02, local04
	mov	local03, #23
	mov	local07, local01
	mov	local10, local02
	mov	local08, local03
	add	objptr, ##54080
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local07, local09
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local10, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local01, local10
	shl	local01, #1
	add	local01, local10
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	local08, local01
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##54080
LR__0484
	mov	ptra, fp
	call	#popregs_
_compile_array_assign_ret
	ret

' 
' 
' sub compile_immediate_assign(linetype as ulong)
_compile_immediate_assign
	mov	COUNT_, #9
	call	#pushregs_
	mov	local04, arg01 wz
	mov	local03, #255
	neg	local05, #1
' 
' t1.result_type=result_error : t1.result.uresult=0
' i=-1: j=-1
' 
' if linetype=0 then varname2$=lparts(0).part$: ct=2 : lineptr=0 
 if_ne	jmp	#LR__0490
	add	objptr, ##43216
	rdlong	local06, objptr
	add	objptr, ##1080
	wrlong	#2, objptr
	add	objptr, ##9784
	wrlong	#0, objptr
	sub	objptr, ##54080
LR__0490
' if linetype=2 orelse linetype=3 then varname2$=lparts(0).part$ : ct=2 ' don't set lineptr
	cmp	local04, #2 wz
 if_ne	cmp	local04, #3 wz
 if_e	add	objptr, ##43216
 if_e	rdlong	local06, objptr
 if_e	add	objptr, ##1080
 if_e	wrlong	#2, objptr
 if_e	sub	objptr, ##44296
' if linetype=4 orelse linetype=1 then varname2$=lparts(1).part$ : ct=3 : lineptr=2
	cmp	local04, #4 wz
 if_ne	cmp	local04, #1 wz
 if_ne	jmp	#LR__0491
	add	objptr, ##43224
	rdlong	local06, objptr
	add	objptr, ##1072
	wrlong	#3, objptr
	add	objptr, ##9784
	wrlong	#2, objptr
	sub	objptr, ##54080
LR__0491
' if linetype=5 then varname2$=lparts(ct).part$ : ct+=2 ' continued after if/else
	cmp	local04, #5 wz
 if_ne	jmp	#LR__0492
	add	objptr, ##44296
	rdlong	result1, objptr
	mov	local06, result1
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	rdlong	local06, local06
	add	result1, #2
	add	objptr, ##1080
	wrlong	result1, objptr
	sub	objptr, ##44296
LR__0492
	mov	arg01, local06
	mov	arg02, #1
	call	#__system__Right_S
	call	#_expr
'  
' 'print "Called compile immediate assign with linetype",linetype, "varname=",varname2$, "lineptr=", lineptr
' 
' suffix2$=right$(varname2$,1)
' expr()
' 
' 
' if varnum>0 then
	add	objptr, ##43212
	rdlong	local07, objptr
	sub	objptr, ##43212
	cmps	local07, #1 wc
 if_b	jmp	#LR__0495
'   for i=0 to varnum-1
	mov	local08, #0
	add	objptr, ##43212
	rdlong	local09, objptr
	sub	objptr, ##43212
LR__0493
	cmps	local08, local09 wc
 if_ae	jmp	#LR__0494
'     if variables(i).name=varname2$ then j=i : exit
	mov	local07, local08
	shl	local07, #4
	add	objptr, ##26828
	add	local07, objptr
	rdlong	arg01, local07
	mov	arg02, local06
	sub	objptr, ##26828
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local05, local08
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0493
LR__0494
LR__0495
' if  j=-1 andalso varnum<maxvars then   
	cmp	local05, ##-1 wz
 if_ne	jmp	#LR__0496
	add	objptr, ##43212
	rdlong	local07, objptr
	sub	objptr, ##43212
	cmps	local07, ##1023 wc
 if_ae	jmp	#LR__0496
	add	objptr, ##43212
	rdlong	local09, objptr
	shl	local09, #4
	sub	objptr, ##16384
	add	local09, objptr
	wrlong	local06, local09
	add	objptr, ##16384
	rdlong	local07, objptr
	mov	local05, local07
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##43212
LR__0496
	mov	local01, local05
	mov	local03, #23
	mov	local07, local01
	mov	local09, local02
	mov	local01, local03
	add	objptr, ##54080
	rdlong	local08, objptr
	mov	local06, local08
	shl	local06, #1
	add	local06, local08
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	wrlong	local07, local06
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local07, local08
	shl	local07, #1
	add	local07, local08
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	add	local07, #4
	wrlong	local09, local07
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local08, local09
	shl	local08, #1
	add	local08, local09
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	add	local08, #8
	wrlong	local01, local08
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##54080
' t1.result.uresult=j: t1.result_type=fun_assign  
' 
' 
' 
' 
' 
' 
' compiledline(lineptr)=t1:  lineptr+=1 
'  if linetype=0 orelse linetype=3 orelse linetype=4 then compiledline(lineptr).result_type=token_end
	cmp	local04, #0 wz
 if_ne	cmp	local04, #3 wz
 if_ne	cmp	local04, #4 wz
 if_ne	jmp	#LR__0497
	add	objptr, ##54080
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #8
	wrlong	#510, local09
	sub	objptr, ##52544
LR__0497
	mov	ptra, fp
	call	#popregs_
_compile_immediate_assign_ret
	ret

' 
' ' ------------------ compile the line that is calling a command 
' 
' function compile (alinemajor as ulong, alineminor=0 as ulong, cont=0 as ulong)
_compile
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, arg02
	mov	local03, arg03
' 'line header: num major, num minor,list start, list length, prev, next. That implements 2-way list of program lines 
' ' num_minor bit 31: the line is goto target. If deleted, a proper record(s) has to be added to goto list
'  
' '  print "called compile with line= "; alinemajor;" and cont= "; cont 
' if alinemajor=0 then err=compile_immediate(0) : return err  
 if_ne	jmp	#LR__0500
	mov	arg01, #0
	call	#_compile_immediate
	jmp	#LR__0507
LR__0500
	add	objptr, ##52544
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	local02, objptr
	sub	objptr, ##52548
	mov	arg01, local03
	add	arg01, #1
	call	#_compile_immediate
	mov	local04, result1 wz
' 
' ucompiledline(0)=alinemajor
' ucompiledline(1)=alineminor
' 
' 
' ' cont: 0: this is the first part of the line that will continue
' ' 1 - this is the continuation of the line
' ' 2 - this is the last continued line
' ' 3 - this is the ome and only part
' 
' err=compile_immediate(cont+1) 
' if err=0 then
 if_ne	jmp	#LR__0506
'   if cont=3 orelse cont=2 then 
	cmp	local03, #3 wz
 if_ne	cmp	local03, #2 wz
 if_ne	jmp	#LR__0505
'     if alinemajor >lastline then 
	add	objptr, ##54092
	rdlong	arg03, objptr
	sub	objptr, ##54092
	cmp	local01, arg03 wcz
 if_be	jmp	#LR__0501
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0504
LR__0501
	mov	arg01, local01
	call	#_deleteline
'       deleteline(alinemajor)  
'       if alinemajor>lastline then add_line_at_end(alinemajor)  else insertline(alinemajor)   ' yes I know that's not optimal    
	add	objptr, ##54092
	rdlong	arg03, objptr
	sub	objptr, ##54092
	cmp	local01, arg03 wcz
 if_be	jmp	#LR__0502
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0503
LR__0502
	mov	arg01, local01
	call	#_insertline
LR__0503
LR__0504
LR__0505
LR__0506
' return err
	mov	result1, local04
LR__0507
	mov	ptra, fp
	call	#popregs_
_compile_ret
	ret

' 
' ' ------------------ compile the line that is assigning to a variable
' 
' sub compile_assign (alinemajor as ulong, alineminor=0 as ulong, cont=0 as ulong)  
_compile_assign
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, arg02
	mov	local03, arg03
' 
' '  print "called compile_assign  with line= "; alinemajor;" and cont= "; cont 
' if alinemajor=0 then compile_immediate_assign(0) : return  
 if_ne	jmp	#LR__0510
	mov	arg01, #0
	call	#_compile_immediate_assign
	jmp	#LR__0516
LR__0510
	add	objptr, ##52544
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	local02, objptr
	sub	objptr, ##52548
	mov	arg01, local03
	add	arg01, #1
	call	#_compile_immediate_assign
' 
' ucompiledline(0)=alinemajor
' ucompiledline(1)=alineminor
' 
' compile_immediate_assign(cont+1) 
' 
' if cont=3 orelse cont=2 then 
	cmp	local03, #3 wz
 if_ne	cmp	local03, #2 wz
 if_ne	jmp	#LR__0515
'   if alinemajor >lastline then 
	add	objptr, ##54092
	rdlong	arg03, objptr
	sub	objptr, ##54092
	cmp	local01, arg03 wcz
 if_be	jmp	#LR__0511
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0514
LR__0511
	mov	arg01, local01
	call	#_deleteline
'     deleteline(alinemajor)  
'     if alinemajor>lastline then add_line_at_end(alinemajor) else insertline(alinemajor)   
	add	objptr, ##54092
	rdlong	arg03, objptr
	sub	objptr, ##54092
	cmp	local01, arg03 wcz
 if_be	jmp	#LR__0512
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0513
LR__0512
	mov	arg01, local01
	call	#_insertline
LR__0513
LR__0514
LR__0515
LR__0516
	mov	ptra, fp
	call	#popregs_
_compile_assign_ret
	ret

' 
' sub compile_error(errno)
_compile_error
	mov	_var03, #255
	mov	_var04, _var02
	mov	_var05, _var03
	add	objptr, ##54080
	rdlong	_var06, objptr
	mov	_var07, _var06
	shl	_var07, #1
	add	_var07, _var06
	shl	_var07, #2
	sub	objptr, ##1536
	add	_var07, objptr
	wrlong	arg01, _var07
	add	objptr, ##1536
	rdlong	_var07, objptr
	mov	_var06, _var07
	shl	_var06, #1
	add	_var06, _var07
	shl	_var06, #2
	sub	objptr, ##1536
	add	_var06, objptr
	add	_var06, #4
	wrlong	_var04, _var06
	add	objptr, ##1536
	rdlong	_var07, objptr
	mov	_var06, _var07
	shl	_var06, #1
	add	_var06, _var07
	shl	_var06, #2
	sub	objptr, ##1536
	add	_var06, objptr
	add	_var06, #8
	wrlong	_var05, _var06
	add	objptr, ##1536
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##54080
_compile_error_ret
	ret

' 
' sub compile_unknown() 
_compile_unknown
	mov	_var03, #255
	mov	_var01, #23
	mov	_var04, _var02
	mov	_var01, _var03
	add	objptr, ##54080
	rdlong	_var05, objptr
	mov	_var06, _var05
	shl	_var06, #1
	add	_var06, _var05
	shl	_var06, #2
	sub	objptr, ##1536
	add	_var06, objptr
	wrlong	#23, _var06
	add	objptr, ##1536
	rdlong	_var06, objptr
	mov	_var05, _var06
	shl	_var05, #1
	add	_var05, _var06
	shl	_var05, #2
	sub	objptr, ##1536
	add	_var05, objptr
	add	_var05, #4
	wrlong	_var04, _var05
	add	objptr, ##1536
	rdlong	_var06, objptr
	mov	_var05, _var06
	shl	_var05, #1
	add	_var05, _var06
	shl	_var05, #2
	sub	objptr, ##1536
	add	_var05, objptr
	add	_var05, #8
	wrlong	_var01, _var05
	add	objptr, ##1536
	rdlong	_var06, objptr
	add	_var06, #1
	wrlong	_var06, objptr
	sub	objptr, ##54080
_compile_unknown_ret
	ret

' 
' function compile_fun_2p() as ulong
_compile_fun_2p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
' 
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0520
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
	mov	result1, #0
LR__0520
	mov	ptra, fp
	call	#popregs_
_compile_fun_2p_ret
	ret

' 
' function compile_fun_3p() as ulong
_compile_fun_3p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
' 
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0530
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0530
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
	mov	result1, #0
LR__0530
	mov	ptra, fp
	call	#popregs_
_compile_fun_3p_ret
	ret

' 
' function compile_fun_4p() as ulong
_compile_fun_4p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
' 
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0540
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0540
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0540
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
	mov	result1, #0
LR__0540
	mov	ptra, fp
	call	#popregs_
_compile_fun_4p_ret
	ret

' 
' 
' function compile_fun_5p() as ulong
_compile_fun_5p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
' 
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0550
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0550
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0550
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
' expr()
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##44296
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0550
	add	objptr, ##44296
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##44296
	call	#_expr
	mov	result1, #0
LR__0550
	mov	ptra, fp
	call	#popregs_
_compile_fun_5p_ret
	ret

' 
' function compile_fun_varp() as ulong 
_compile_fun_varp
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, #0
' i=0
' if lparts(ct).token<>token_end then
	add	objptr, ##44296
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #510 wz
	sub	objptr, ##43216
 if_e	jmp	#LR__0562
'   do
LR__0560
	call	#_expr
	add	local01, #1
'   expr()
'    i+=1
'    if lparts(ct).token<> token_comma then exit loop else ct+=1
	add	objptr, ##44296
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #17 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0561
	add	objptr, ##44296
	rdlong	local02, objptr
	add	local02, #1
	wrlong	local02, objptr
	sub	objptr, ##44296
	jmp	#LR__0560
LR__0561
LR__0562
' return i
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
_compile_fun_varp_ret
	ret

' 
' 
' function compile_print() as ulong ' todo reconfigurable editor start position
_compile_print
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, #0
	mov	local03, #29
' t1.result.uresult=0 : t1.result_type=result_uint
' if lparts(ct).token=token_end then t1.result_type=print_mod_empty: compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1 :return 0 	'print without parameters
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #510 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0570
	mov	local03, #32
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##54080
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local10, local05
	shl	local10, #1
	add	local10, local05
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local11, local05
	shl	local11, #1
	add	local11, local05
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##54080
	mov	result1, #0
	jmp	#LR__0577
LR__0570
' do
LR__0571
	call	#_expr
'   expr()  ': print "In compile_print token= "; lparts(ct).token; " part$= "; lparts(ct).part$ :
'   if lparts(ct).token=token_comma then t1.result_type=print_mod_comma : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #17 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0572
	mov	local03, #33
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##54080
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local11, local05
	shl	local11, #1
	add	local11, local05
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##54080
LR__0572
'   if lparts(ct).token=token_semicolon then  t1.result_type=print_mod_semicolon : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #18 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0573
	mov	local03, #34
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##54080
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local11, local05
	shl	local11, #1
	add	local11, local05
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##54080
LR__0573
'   if lparts(ct).token=token_end then t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #510 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0574
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##54080
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##54080
LR__0574
'   if lparts(ct).token <>token_comma andalso lparts(ct).token <>token_semicolon andalso lparts(ct).token <>token_end then  return 22
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #17 wz
	sub	objptr, ##43216
 if_e	jmp	#LR__0575
	add	objptr, ##44296
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local08, local08
	cmp	local08, #18 wz
	sub	objptr, ##43216
 if_e	jmp	#LR__0575
	add	objptr, ##44296
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local11, local11
	cmp	local11, #510 wz
	sub	objptr, ##43216
 if_ne	mov	result1, #22
 if_ne	jmp	#LR__0577
LR__0575
	add	objptr, ##44296
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #510 wz
	sub	objptr, ##43216
 if_e	jmp	#LR__0576
	add	objptr, ##44296
	rdlong	local11, objptr
	add	objptr, ##7196
	rdlong	local10, objptr
	sub	objptr, ##51492
	cmps	local11, local10 wc
 if_b	jmp	#LR__0571
LR__0576
' return 0
	mov	result1, #0
LR__0577
	mov	ptra, fp
	call	#popregs_
_compile_print_ret
	ret

' 
' function compile_if() as ulong  
_compile_if
	mov	COUNT_, #5
	call	#pushregs_
_compile_if_enter
	call	#_expr
' expr()
' return 0
	add	objptr, ##44296
	rdlong	result1, objptr
	add	result1, #1
	wrlong	result1, objptr
	mov	local03, #88
	mov	local04, local01
	mov	local05, local02
	mov	local01, local03
	add	objptr, ##9784
	rdlong	arg01, objptr
	mov	result1, arg01
	shl	result1, #1
	add	result1, arg01
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local04, result1
	add	objptr, ##1536
	rdlong	arg01, objptr
	mov	local04, arg01
	shl	local04, #1
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local05, local04
	add	objptr, ##1536
	rdlong	local04, objptr
	mov	local05, local04
	shl	local05, #1
	add	local05, local04
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #8
	wrlong	local01, local05
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
' 
' 'print "In compile_if"
' compile_fun_1p()
' cmd=lparts(ct).token : ct+=1
' 'print cmd ' : if cmd<> token_then then print "Expected then" else print "Found then"
' t1.result_type=token_if : compiledline(lineptr)=t1:  lineptr+=1
' if isassign(lparts(ct+1).part$) then compile_immediate_assign(5) else compile_immediate(5)
	sub	objptr, ##9784
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##43216
' 
' select case s
	mov	arg02, ##@LR__4414
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0580
	mov	arg01, #5
	call	#_compile_immediate_assign
	jmp	#LR__0581
LR__0580
	mov	arg01, #5
	call	#_compile_immediate
LR__0581
' 
' 
' return 0
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_compile_if_ret
	ret

' 
' function compile_else() as ulong  
_compile_else
	mov	COUNT_, #5
	call	#pushregs_
_compile_else_enter
	mov	local03, #90
	mov	local04, local01
	mov	local05, local02
	mov	local01, local03
	add	objptr, ##54080
	rdlong	arg01, objptr
	mov	result1, arg01
	shl	result1, #1
	add	result1, arg01
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local04, result1
	add	objptr, ##1536
	rdlong	result1, objptr
	mov	local04, result1
	shl	local04, #1
	add	local04, result1
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local05, local04
	add	objptr, ##1536
	rdlong	local04, objptr
	mov	local05, local04
	shl	local05, #1
	add	local05, local04
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #8
	wrlong	local01, local05
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
' 
' t1.result_type=token_else : compiledline(lineptr)=t1:  lineptr+=1
' if isassign(lparts(ct+1).part$) then compile_immediate_assign(5) else compile_immediate(5)
	sub	objptr, ##9784
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##43216
' 
' select case s
	mov	arg02, ##@LR__4414
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0590
	mov	arg01, #5
	call	#_compile_immediate_assign
	jmp	#LR__0591
LR__0590
	mov	arg01, #5
	call	#_compile_immediate
LR__0591
' 
' 
' return 0
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_compile_else_ret
	ret

' 
' 
' function compile_dim() as ulong  
_compile_dim
	mov	COUNT_, #17
	call	#pushregs_
	mov	local01, #1
	mov	local02, #1
	mov	local03, #1
' 
' dims(0)=1: dims(1)=1: dims(2)=1
' 
' if isname(lparts(ct).part$) then 
	add	objptr, ##44296
	rdlong	arg04, objptr
	shl	arg04, #3
	sub	objptr, ##1080
	add	arg04, objptr
	rdlong	arg01, arg04
	sub	objptr, ##43216
	call	#_isname
	cmp	result1, #0 wz
 if_e	jmp	#LR__0624
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	local05, local04
	neg	local06, #1
'   varname2$=lparts(ct).part$ 
'   j=-1
'   if varnum>0 then
	sub	objptr, #4
	rdlong	local07, objptr
	sub	objptr, ##43212
	cmps	local07, #1 wc
 if_b	jmp	#LR__0602
'  '   print "in dim, varnum=";varnum
'     for i=0 to varnum-1
	mov	local08, #0
	add	objptr, ##43212
	rdlong	local09, objptr
	sub	objptr, ##43212
LR__0600
	cmps	local08, local09 wc
 if_ae	jmp	#LR__0601
'       if variables(i).name=varname2$ then j=i : exit
	mov	local04, local08
	shl	local04, #4
	add	objptr, ##26828
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, local05
	sub	objptr, ##26828
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local06, local08
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0600
LR__0601
LR__0602
' '  if j<>-1 then printerror (42) : return 42
'   if j=-1 then j=varnum else print "Dim: at line ";linenum;": warning: the variable existed."
	cmp	local06, ##-1 wz
 if_e	add	objptr, ##43212
 if_e	rdlong	local06, objptr
 if_e	sub	objptr, ##43212
 if_e	jmp	#LR__0603
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4564
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##62804
	rdlong	arg02, objptr
	sub	objptr, ##62804
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg02, ##@LR__4565
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__0603
'   if lparts(ct+1).part$ <>"(" andalso lparts(ct+1).part$<>"as" then printerror(43) : return 43
	add	objptr, ##44296
	rdlong	arg04, objptr
	add	arg04, #1
	shl	arg04, #3
	sub	objptr, ##1080
	add	arg04, objptr
	rdlong	arg01, arg04
	mov	arg02, ##@LR__4566
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0604
	add	objptr, ##44296
	rdlong	local09, objptr
	add	local09, #1
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	rdlong	arg01, local09
	mov	arg02, ##@LR__4567
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0604
	mov	arg01, #43
	call	#_printerror
	mov	result1, #43
	jmp	#LR__0626
LR__0604
'   if lparts(ct+1).part$ = "as" then l=ct+1: goto 1350
	add	objptr, ##44296
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, ##@LR__4568
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##44296
 if_e	rdlong	local10, objptr
 if_e	sub	objptr, ##44296
 if_e	add	local10, #1
 if_e	jmp	#LR__0610
	add	objptr, ##44296
	rdlong	local10, objptr
	sub	objptr, ##44296
	add	local10, #2
	mov	local11, #0
'   l=ct+2 : m=0 : do
LR__0605
'    ' print "in dim, lparts: ";lparts(l).part$, isdec(lparts(l).part$)
'     if isdec(lparts(l).part$) then 
	mov	local04, local10
	shl	local04, #3
	add	objptr, ##43216
	add	local04, objptr
	rdlong	arg01, local04
	sub	objptr, ##43216
	call	#_isdec
	cmp	result1, #0 wz
 if_e	jmp	#LR__0606
	mov	local12, local11
	add	local12, #local01
	mov	local09, local10
	shl	local09, #3
	add	objptr, ##43216
	add	local09, objptr
	rdlong	arg01, local09
	mov	arg02, #0
	sub	objptr, ##43216
	call	#__system____builtin_atoi
	mov	local13, result1
	'.live	local13
	'.live	local12
	altd	local12, #0
	mov	local12, local13
	add	local11, #1
	jmp	#LR__0607
LR__0606
	mov	arg01, #17
	call	#_printerror
'       printerror (17)  : return(17)
	mov	result1, #17
	jmp	#LR__0626
LR__0607
'     if (lparts(l+1).part$<>"," andalso lparts(l+1).part$<>")" ) then printerror (44)  : return(44)
	mov	local04, local10
	add	local04, #1
	shl	local04, #3
	add	objptr, ##43216
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__4569
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0608
	mov	local13, local10
	add	local13, #1
	shl	local13, #3
	add	objptr, ##43216
	add	local13, objptr
	rdlong	arg01, local13
	mov	arg02, ##@LR__4570
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0608
	mov	arg01, #44
	call	#_printerror
	mov	result1, #44
	jmp	#LR__0626
LR__0608
	add	local10, #2
	mov	local04, local10
	sub	local04, #1
	shl	local04, #3
	add	objptr, ##43216
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__4571
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	cmps	local11, #3 wc
 if_c_and_nz	jmp	#LR__0605
'   if m>3 then printerror(45): return(45)
	cmps	local11, #4 wc
 if_b	jmp	#LR__0609
	mov	arg01, #45
	call	#_printerror
	mov	result1, #45
	jmp	#LR__0626
LR__0609
	mov	local14, #256
	mov	local15, #12
LR__0610
'  ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' print lparts(l-1).part$,lparts(l).part$, lparts(l+1).part$
'   arraytype=array_no_type : esize=12
' 1350 
'   if lparts(l).part$="as" then
	mov	local04, local10
	shl	local04, #3
	add	objptr, ##43216
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__4572
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0625
'     select case lparts(l+1).part$
	mov	local12, local10
	add	local12, #1
	shl	local12, #3
	add	objptr, ##43216
	add	local12, objptr
	rdlong	local16, local12
	mov	arg02, ##@LR__4573
	mov	arg01, local16
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0611
	mov	arg02, ##@LR__4574
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0612
	mov	arg02, ##@LR__4575
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0613
	mov	arg02, ##@LR__4576
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0614
	mov	arg02, ##@LR__4577
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0615
	mov	arg02, ##@LR__4578
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0616
	mov	arg02, ##@LR__4579
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0617
	mov	arg02, ##@LR__4580
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0618
	mov	arg02, ##@LR__4581
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0619
	mov	arg02, ##@LR__4582
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0620
	mov	arg02, ##@LR__4583
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0621
	mov	arg02, ##@LR__4584
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0622
	jmp	#LR__0623
LR__0611
	mov	local14, #257
	mov	local15, #1
	jmp	#LR__0625
LR__0612
	mov	local14, #258
	mov	local15, #1
	jmp	#LR__0625
LR__0613
	mov	local14, #259
	mov	local15, #2
	jmp	#LR__0625
LR__0614
	mov	local14, #260
	mov	local15, #2
	jmp	#LR__0625
LR__0615
	mov	local14, #261
	mov	local15, #4
	jmp	#LR__0625
LR__0616
	mov	local14, #261
	mov	local15, #4
	jmp	#LR__0625
LR__0617
	mov	local14, #262
	mov	local15, #4
	jmp	#LR__0625
LR__0618
	mov	local14, #263
	mov	local15, #8
	jmp	#LR__0625
LR__0619
	mov	local14, #264
	mov	local15, #8
	jmp	#LR__0625
LR__0620
	mov	local14, #265
	mov	local15, #4
	jmp	#LR__0625
LR__0621
	mov	local14, #266
	mov	local15, #8
	jmp	#LR__0625
LR__0622
	mov	local14, #267
	mov	local15, #4
	jmp	#LR__0625
LR__0623
	mov	arg01, #47
	call	#_printerror
	mov	result1, #47
	jmp	#LR__0626
LR__0624
	mov	arg01, #46
	call	#_printerror
'   printerror(46): return 46
	mov	result1, #46
	jmp	#LR__0626
LR__0625
	qmul	local15, local01
	getqx	local07
	qmul	local07, local02
	getqx	local16
	qmul	local16, local03
	add	objptr, ##62780
	rdlong	local17, objptr
	mov	arg02, local14
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	getqx	local16
	sub	local17, local16
	sub	local17, #16
	wrlong	local17, objptr
	mov	arg01, local17
	sub	objptr, ##56956
	call	#_psram_spin2_fill
	mov	arg01, local17
	add	arg01, #2
	mov	arg02, local15
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 1)
	mov	arg05, #1
	call	#_psram_spin2_fill
	mov	arg01, local17
	add	arg01, #4
	mov	arg02, local01
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	mov	arg01, local17
	add	arg01, #8
	mov	arg02, local02
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	mov	arg01, local17
	add	arg01, #12
	mov	arg02, local03
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	mov	local12, local06
	shl	local12, #4
	add	objptr, ##21004
	add	local12, objptr
	wrlong	local05, local12
	mov	local12, local06
	shl	local12, #4
	add	local12, objptr
	add	local12, #4
	wrlong	local17, local12
	mov	local12, local06
	shl	local12, #4
	add	local12, objptr
	add	local12, #12
	wrlong	local14, local12
' 'print dims(0),dims(1),dims(2),arraytype
' 
' arraysize=esize*dims(0)*dims(1)*dims(2)
' arrayptr=memtop-arraysize-16
' memtop=arrayptr
' 
' pslpoke arrayptr,arraytype
' pspoke arrayptr+2,esize
' pslpoke arrayptr+4,dims(0)
' pslpoke arrayptr+8,dims(1)
' pslpoke arrayptr+12,dims(2)
' 
' variables(j).name=varname2$
' variables(j).value.uresult=arrayptr
' variables(j).vartype=arraytype
' if j=varnum then varnum+=1
	add	objptr, ##16384
	rdlong	local07, objptr
	sub	objptr, ##43212
	cmp	local06, local07 wz
 if_e	add	objptr, ##43212
 if_e	rdlong	local07, objptr
 if_e	add	local07, #1
 if_e	wrlong	local07, objptr
 if_e	sub	objptr, ##43212
' 
' return 0
	mov	result1, #0
LR__0626
	mov	ptra, fp
	call	#popregs_
_compile_dim_ret
	ret

' 
' 
' function compile_for() as ulong  
_compile_for
	mov	COUNT_, #7
	call	#pushregs_
' 
' 
' 
' if isassign(lparts(ct+1).part$) then compile_immediate_assign(5) else compile_error(32) : return 32
	add	objptr, ##44296
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	sub	objptr, ##43216
' 
' select case s
	mov	arg02, ##@LR__4414
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0630
	mov	arg01, #5
	call	#_compile_immediate_assign
	jmp	#LR__0631
LR__0630
	mov	arg01, #32
	call	#_compile_error
	mov	result1, #32
	jmp	#LR__0637
LR__0631
	add	objptr, ##54080
	rdlong	arg01, objptr
	mov	local04, arg01
	sub	local04, #1
	mov	arg02, local04
	shl	arg02, #1
	add	arg02, local04
	shl	arg02, #2
	sub	objptr, ##1536
	add	arg02, objptr
	rdlong	local01, arg02
	add	arg02, #4
	rdlong	local05, arg02
	sub	arg01, #1
	mov	local06, arg01
	shl	local06, #1
	add	local06, arg01
	shl	local06, #2
	add	local06, objptr
	add	local06, #8
	rdlong	arg01, local06
	mov	local02, local05
	mov	local03, arg01
' '' after this we should have fun_assign_i or fun_assign_u with var# as uresult.
' t1=compiledline(lineptr-1): if t1.result_type<>fun_assign  then compile_error(34) : return 34
	cmp	local03, #23 wz
	sub	objptr, ##52544
 if_e	jmp	#LR__0632
	mov	arg01, #34
	call	#_compile_error
	mov	result1, #34
	jmp	#LR__0637
LR__0632
	mov	local07, local01
' varnum=t1.result.uresult
' if lparts(ct).part$<>"to" then  compile_error(33) : return 33
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__4585
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0633
	mov	arg01, #33
	call	#_compile_error
	mov	result1, #33
	jmp	#LR__0637
LR__0633
	add	objptr, ##44296
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##44296
	call	#_expr
' ct+=1
' expr()  ' there is "to" value pushed on the stack
' if lparts(ct).part$="step" orelse lparts(ct).part$="s." then
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__4586
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0634
	add	objptr, ##44296
	rdlong	local06, objptr
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, ##@LR__4587
	sub	objptr, ##43216
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0635
LR__0634
	add	objptr, ##44296
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
	call	#_expr
	jmp	#LR__0636
LR__0635
	add	objptr, ##54080
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #8
	wrlong	#28, local05
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	wrlong	#1, local05
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##54080
LR__0636
	add	objptr, ##54080
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #8
	wrlong	#28, local05
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	wrlong	local07, local05
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	#74, local06
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	wrlong	#0, local06
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##54080
' compiledline(lineptr).result_type=result_int : compiledline(lineptr).result.iresult=varnum :lineptr+=1
' compiledline(lineptr).result_type=token_for : compiledline(lineptr).result.iresult=0 :lineptr+=1
' 
' 
' return 0
	mov	result1, #0
LR__0637
	mov	ptra, fp
	call	#popregs_
_compile_for_ret
	ret

' 
' 
' sub do_for()
_do_for
	mov	COUNT_, #5
	call	#pushregs_
	add	objptr, ##62108
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##62108
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	objptr, ##62108
	rdlong	local04, objptr
	mov	local05, local04
	shl	local05, #2
	add	local05, local04
	shl	local05, #2
	sub	objptr, ##3904
	add	local05, objptr
	add	local05, #8
	wrlong	local01, local05
	sub	objptr, ##58204
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	objptr, ##62108
	rdlong	local04, objptr
	mov	local05, local04
	shl	local05, #2
	add	local05, local04
	shl	local05, #2
	sub	objptr, ##3904
	add	local05, objptr
	add	local05, #12
	wrlong	local01, local05
	sub	objptr, ##58204
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	objptr, ##62108
	rdlong	local04, objptr
	mov	local05, local04
	shl	local05, #2
	add	local05, local04
	shl	local05, #2
	sub	objptr, ##3904
	add	local05, objptr
	add	local05, #16
	wrlong	local01, local05
' fortop+=1
' 'i=-1: do: i+=1 : loop until fortable(i).varnum= -1 orelse i>= maxfor
' 'if i> maxfor then printerror(36) : return
' t1=pop() : fortable(fortop).varnum=t1.result.iresult
' t1=pop() : fortable(fortop).stepval=t1.result.iresult
' t1=pop() : fortable(fortop).endval=t1.result.iresult
' if compiledline(lineptr_e).result_type=token_end then
	sub	objptr, ##4120
	rdlong	local01, objptr
	mov	local05, local01
	shl	local05, #1
	add	local05, local01
	shl	local05, #2
	sub	objptr, ##1540
	add	local05, objptr
	add	local05, #8
	rdlong	local05, local05
	cmp	local05, #510 wz
	sub	objptr, ##52544
 if_ne	jmp	#LR__0640
	add	objptr, ##62108
	rdlong	local01, objptr
	mov	local05, local01
	shl	local05, #2
	add	local05, local01
	shl	local05, #2
	sub	objptr, ##3904
	add	local05, objptr
	add	objptr, ##3864
	rdlong	local01, objptr
	wrlong	local01, local05
	add	objptr, #40
	rdlong	local01, objptr
	mov	local05, local01
	shl	local05, #2
	add	local05, local01
	shl	local05, #2
	sub	objptr, ##3904
	add	local05, objptr
	add	local05, #4
	wrlong	#0, local05
	sub	objptr, ##58204
	jmp	#LR__0641
LR__0640
	add	objptr, ##62108
	rdlong	local01, objptr
	mov	local05, local01
	shl	local05, #2
	add	local05, local01
	shl	local05, #2
	sub	objptr, ##3904
	add	local05, objptr
	add	objptr, ##3872
	rdlong	local01, objptr
	wrlong	local01, local05
	add	objptr, #32
	rdlong	local01, objptr
	mov	local05, local01
	shl	local05, #2
	add	local05, local01
	shl	local05, #2
	sub	objptr, ##3904
	add	local05, objptr
	sub	objptr, ##4120
	rdlong	local01, objptr
	sub	objptr, ##54084
	add	local01, #1
	add	local05, #4
	wrlong	local01, local05
LR__0641
	mov	ptra, fp
	call	#popregs_
_do_for_ret
	ret

' 
' ' now do_next todo
' 
' sub do_next()
_do_next
	mov	COUNT_, #4
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' 
' t1=pop() :varnum=t1.result.uresult
' if fortable(fortop).varnum<>t1.result.uresult then printerror(37) : return
	add	objptr, ##62108
	rdlong	arg01, objptr
	mov	local04, arg01
	shl	local04, #2
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##3904
	add	local04, objptr
	add	local04, #8
	rdlong	local04, local04
	cmp	local04, local01 wz
	sub	objptr, ##58204
 if_e	jmp	#LR__0650
	mov	arg01, #37
	call	#_printerror
	jmp	#LR__0654
LR__0650
	add	objptr, ##62108
	rdlong	arg01, objptr
	mov	local04, arg01
	shl	local04, #2
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##3904
	add	local04, objptr
	add	local04, #12
	rdlong	local04, local04
	mov	arg01, local01
	shl	arg01, #4
	sub	objptr, ##31376
	add	arg01, objptr
	mov	result3, local01
	shl	result3, #4
	add	result3, objptr
	add	result3, #4
	rdlong	result3, result3
	add	result3, local04
	add	arg01, #4
	wrlong	result3, arg01
' variables(varnum).value.iresult+=fortable(fortop).stepval 
' if fortable(fortop).stepval>=0 then
	add	objptr, ##35280
	rdlong	arg01, objptr
	mov	local04, arg01
	shl	local04, #2
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##3904
	add	local04, objptr
	add	local04, #12
	rdlong	local04, local04
	cmps	local04, #0 wc
	sub	objptr, ##58204
 if_b	jmp	#LR__0651
'   if variables(varnum).value.iresult>fortable(fortop).endval then fortop-=1 : return ' do nothing 
	shl	local01, #4
	add	objptr, ##26828
	add	local01, objptr
	add	objptr, ##35280
	rdlong	local04, objptr
	mov	arg01, local04
	shl	arg01, #2
	add	arg01, local04
	shl	arg01, #2
	sub	objptr, ##3904
	add	arg01, objptr
	add	local01, #4
	rdlong	local04, local01
	add	arg01, #16
	rdlong	arg01, arg01
	cmps	local04, arg01 wcz
	sub	objptr, ##58204
 if_be	jmp	#LR__0653
	add	objptr, ##62108
	rdlong	local04, objptr
	sub	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##62108
	jmp	#LR__0654
LR__0651
'   if variables(varnum).value.iresult<fortable(fortop).endval then fortop -=1 : return ' do nothing 
	mov	arg01, local01
	shl	arg01, #4
	add	objptr, ##26828
	add	arg01, objptr
	add	objptr, ##35280
	rdlong	local04, objptr
	mov	local01, local04
	shl	local01, #2
	add	local01, local04
	shl	local01, #2
	sub	objptr, ##3904
	add	local01, objptr
	add	arg01, #4
	rdlong	arg01, arg01
	add	local01, #16
	rdlong	local01, local01
	cmps	arg01, local01 wc
	sub	objptr, ##58204
 if_ae	jmp	#LR__0652
	add	objptr, ##62108
	rdlong	local04, objptr
	sub	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##62108
	jmp	#LR__0654
LR__0652
LR__0653
	add	objptr, ##62108
	rdlong	local01, objptr
	mov	local04, local01
	shl	local04, #2
	add	local04, local01
	shl	local04, #2
	sub	objptr, ##3904
	add	local04, objptr
	rdlong	local04, local04
	add	objptr, ##3864
	wrlong	local04, objptr
	add	objptr, #40
	rdlong	local01, objptr
	mov	local04, local01
	shl	local04, #2
	add	local04, local01
	shl	local04, #2
	sub	objptr, ##3904
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	add	objptr, ##3868
	wrlong	local04, objptr
	sub	objptr, ##7992
	rdlong	local04, objptr
	sub	local04, #1
	add	objptr, #4
	wrlong	local04, objptr
	sub	objptr, ##54084
LR__0654
	mov	ptra, fp
	call	#popregs_
_do_next_ret
	ret

' 
' 
' function compile_next() as ulong
_compile_next
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, ##44296
	rdlong	arg01, objptr
	shl	arg01, #3
	sub	objptr, ##1080
	add	arg01, objptr
	rdlong	local01, arg01
' 
' varname$=lparts(ct).part$ 
' 'suffix$=right$(varname$,1)
' 'if varname$="" orelse suffix$="$" orelse suffix$="!" orelse suffix$="#" then  compile_error(34) : printerror(34) : return 34
' if varnum=0 then compile_error(35)  : return 35
	sub	objptr, #4
	rdlong	arg02, objptr wz
	sub	objptr, ##43212
 if_ne	jmp	#LR__0660
	mov	arg01, #35
	call	#_compile_error
	mov	result1, #35
	jmp	#LR__0664
LR__0660
	neg	local02, #1
' j=-1
' for i=0 to varnum-1
	mov	local03, #0
	add	objptr, ##43212
	rdlong	local04, objptr
	sub	objptr, ##43212
LR__0661
	cmp	local03, local04 wc
 if_ae	jmp	#LR__0662
'   if variables(i).name=varname$ then j=i : exit
	mov	arg02, local03
	shl	arg02, #4
	add	objptr, ##26828
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, local01
	sub	objptr, ##26828
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local02, local03
 if_ne	add	local03, #1
 if_ne	jmp	#LR__0661
LR__0662
' if j=-1 then compile_error(35) : return 35
	cmp	local02, ##-1 wz
 if_ne	jmp	#LR__0663
	mov	arg01, #35
	call	#_compile_error
	mov	result1, #35
	jmp	#LR__0664
LR__0663
	add	objptr, ##54080
	rdlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	add	local03, #8
	wrlong	#28, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	wrlong	local02, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	add	local03, #8
	wrlong	#75, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	wrlong	#0, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##54080
' compiledline(lineptr).result_type=result_int : compiledline(lineptr).result.iresult=j :lineptr+=1
' compiledline(lineptr).result_type=token_next : compiledline(lineptr).result.iresult=0 :lineptr+=1
' return 0
	mov	result1, #0
LR__0664
	mov	ptra, fp
	call	#popregs_
_compile_next_ret
	ret

' 
' 
' ' next: we  have to find the variable in the table, compile pushvar, then next
' ' do_for: push its own pointer, varnum, step, end on the for stack. var init is already compiled before
' ' do_next: find the entry with the varnum. Add step to varnum. Compare to the end. If step>0, check >, else check <. If not end, goto forptr (how?) 
' 
' 
' function compile_goto( ) as ulong
_compile_goto
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #40
' 
' if lparts(ct).token=token_decimal andalso lparts(ct+1).token=token_end then 
	add	objptr, ##44296
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg03, arg03
	cmp	arg03, ##512 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0675
	add	objptr, ##44296
	rdlong	arg03, objptr
	add	arg03, #1
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg03, arg03
	cmp	arg03, #510 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0675
	add	objptr, ##44296
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	mov	arg02, #0
	sub	objptr, ##43216
	call	#__system____builtin_atoi
	add	fp, #4
	wrlong	result1, fp
	add	objptr, ##54080
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	local02, #8
	wrlong	#78, local02
	add	objptr, ##1544
	rdlong	local03, objptr
	sub	objptr, ##54088
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #8
' 
'   gotoline=val%(lparts(ct).part$) 
'   compiledline(lineptr).result_type=token_fast_goto
' ' now find a pointer to goto
'   gotoptr=programstart
'   do
LR__0670
	add	fp, #16
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	mov	arg03, #24
	add	objptr, ##5824
	call	#_psram_spin2_read1
	sub	objptr, ##5824
'     psram.read1(varptr(gotoheader),gotoptr,24)  : 
'     if gotoheader(0)<>$FFFFFFFF then
	add	fp, #16
	rdlong	local03, fp
	sub	fp, #16
	cmp	local03, ##-1 wz
 if_e	jmp	#LR__0671
	add	fp, #8
	rdlong	local03, fp
	add	fp, #4
	wrlong	local03, fp
	add	fp, #24
	rdlong	local03, fp
	sub	fp, #28
	wrlong	local03, fp
	sub	fp, #8
LR__0671
	add	fp, #36
	rdlong	local03, fp
	sub	fp, #36
	cmp	local03, ##2147483647 wz
 if_ne	add	fp, #16
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #16
 if_ne	cmp	local01, ##-1 wz
 if_e	jmp	#LR__0672
	add	fp, #16
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local02, fp
	sub	fp, #4
	cmp	local03, local02 wz
 if_ne	jmp	#LR__0670
LR__0672
'   if gotoheader(0)=gotoline then
	add	fp, #16
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #4
	cmp	local03, local01 wz
 if_ne	jmp	#LR__0673
	add	objptr, ##54080
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, local02
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	sub	fp, #8
	rdlong	local03, fp
	sub	fp, #4
	add	local02, #4
	wrlong	local03, local02
	sub	objptr, ##52544
	jmp	#LR__0674
LR__0673
	add	objptr, ##54080
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	wrlong	##-2147483648, local02
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local02, #4
	wrlong	local03, local02
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	local02, #8
	wrlong	#83, local02
	sub	objptr, ##52544
LR__0674
	add	objptr, ##54080
	rdlong	local03, objptr
	add	local03, #1
	wrlong	local03, objptr
	sub	objptr, ##54080
	jmp	#LR__0676
LR__0675
'    print "We have a slow goto, todo  "
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4588
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__0676
' ' if not, there is a slow goto. Call converttoint to get an int value from expression, then do_slow_goto
' ' Do_slow_goto searches a line pointer list to find the linenum and pointer, then do the goto  
' return 0
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_compile_goto_ret
	ret

' 
' 
' 
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '------------------------------ End of the precompiler  --------------------------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '---------------------------- Compile time expression decoder/evaluator ----------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' 
' function expr() as integer 
_expr
	mov	COUNT_, #7
	call	#pushregs_
_expr_enter
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' 
' op=lparts(ct).token : if op=token_end then t3.result.uresult=29 : t3.result_type=result_error : compiledline(lineptr)=t3 : lineptr+=1: return 29
	cmp	local05, #510 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0680
	mov	local01, #29
	mov	local03, #255
	mov	local06, local01
	mov	local07, local02
	mov	local01, local03
	add	objptr, ##54080
	rdlong	local05, objptr
	mov	local04, local05
	shl	local04, #1
	add	local04, local05
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	local06, local04
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #4
	wrlong	local07, local05
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local01, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##54080
	mov	result1, #29
	jmp	#LR__0683
LR__0680
	mov	local01, #0
	call	#_addsub
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' t3.result.uresult=0
' rt=addsub()             			' call higher priority operator check. It will itself call getval/getvar if no multiplies or divides
' op = lparts(ct).token				' that idea is from github adamdunkels/ubasic
' do while (op = token_eq orelse op = token_gt orelse op = token_lt orelse op=token_ge orelse op=token_le orelse op=token_ne)
	sub	objptr, ##43216
LR__0681
	cmp	local05, #27 wz
 if_ne	cmp	local05, #15 wz
 if_ne	cmp	local05, #16 wz
 if_ne	cmp	local05, #39 wz
 if_ne	cmp	local05, #38 wz
 if_ne	cmp	local05, #42 wz
 if_ne	jmp	#LR__0682
	add	objptr, ##44296
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
	call	#_addsub
	mov	local03, local05
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##54080
	rdlong	local04, objptr
	mov	result1, local04
	shl	result1, #1
	add	result1, local04
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local06, result1
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local04, local06
	shl	local04, #1
	add	local04, local06
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local07, local04
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
	sub	objptr, ##43216
	jmp	#LR__0681
LR__0682
' return 0  
	mov	result1, #0
LR__0683
	mov	ptra, fp
	call	#popregs_
_expr_ret
	ret

' 
' 
' '' todo: use propre ops. At getvar and getconst level we know the rt. If both are ints, do int op. If one are float, compile converttofloat, do float op. If both strings, call string op. If string ant int combined, compile err
' 
' function addsub() as integer 
_addsub
	mov	COUNT_, #7
	call	#pushregs_
_addsub_enter
	mov	local01, #0
	call	#_muldiv
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' t3.result.uresult=0
' muldiv()             			' call higher priority operator check. It will itself call getval/getvar if no multiplies or divides
' op = lparts(ct).token				' that idea is from github adamdunkels/ubasic
' do while (op = token_plus orelse op = token_minus orelse op = token_and orelse op=token_or)
	sub	objptr, ##43216
LR__0690
	cmp	local05, #1 wz
 if_ne	cmp	local05, #2 wz
 if_ne	cmp	local05, #7 wz
 if_ne	cmp	local05, #3 wz
 if_ne	jmp	#LR__0691
	add	objptr, ##44296
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##44296
	call	#_muldiv
	mov	local03, local05
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##54080
	rdlong	local04, objptr
	mov	result1, local04
	shl	result1, #1
	add	result1, local04
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local06, result1
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local04, local06
	shl	local04, #1
	add	local04, local06
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local07, local04
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
	sub	objptr, ##43216
	jmp	#LR__0690
LR__0691
'   return 0
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_addsub_ret
	ret

' 
' sub muldiv()
_muldiv
	mov	COUNT_, #8
	call	#pushregs_
_muldiv_enter
	mov	local01, #0
	call	#_getvalue
	add	objptr, ##44296
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' t3.result.uresult=0
' getvalue()    
' op = lparts(ct).token
' do while (op = token_mul orelse op = token_div orelse op = token_fdiv orelse op=token_mod orelse op=token_shl orelse op=token_shr orelse op=token_power)
	sub	objptr, ##43216
LR__0700
	cmp	local05, #5 wz
 if_ne	cmp	local05, #8 wz
 if_ne	cmp	local05, #6 wz
 if_ne	cmp	local05, #9 wz
 if_ne	cmp	local05, #10 wz
 if_ne	cmp	local05, #11 wz
 if_ne	cmp	local05, #12 wz
 if_ne	jmp	#LR__0701
	add	objptr, ##44296
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##44296
	call	#_getvalue
	mov	local03, local05
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##54080
	rdlong	local04, objptr
	mov	local08, local04
	shl	local08, #1
	add	local08, local04
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	wrlong	local06, local08
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local06, local08
	shl	local06, #1
	add	local06, local08
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #4
	wrlong	local07, local06
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local07, local08
	shl	local07, #1
	add	local07, local08
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	add	local07, #8
	wrlong	local05, local07
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
	sub	objptr, ##43216
	jmp	#LR__0700
LR__0701
	mov	ptra, fp
	call	#popregs_
_muldiv_ret
	ret

' 
' sub getvalue() 
_getvalue
	mov	COUNT_, #11
	call	#pushregs_
_getvalue_enter
	mov	local04, #1
	mov	local01, #0
	mov	local03, #29
	add	objptr, ##44296
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	local05, arg03
' m=1
' t1.result.uresult=0: t1.result_type=result_uint
' op=lparts(ct).token
' if op=token_minus then m=-1: ct+=1 : op=lparts(ct).token
	cmp	local05, #2 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0710
	neg	local04, #1
	add	objptr, ##44296
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local05, local05
	sub	objptr, ##43216
LR__0710
' select case op
	cmp	local05, ##512 wz
 if_e	jmp	#LR__0711
	cmp	local05, ##513 wz
 if_e	jmp	#LR__0714
	cmp	local05, ##514 wz
 if_e	jmp	#LR__0715
	cmp	local05, ##515 wz
 if_e	jmp	#LR__0718
	cmp	local05, ##516 wz
 if_e	jmp	#LR__0723
	cmp	local05, #21 wz
 if_e	jmp	#LR__0724
	jmp	#LR__0725
LR__0711
'     if m=1 then t1.result.uresult=m*val%(lparts(ct).part$): t1.result_type=result_int ' todo token_int64
	cmp	local04, #1 wz
 if_ne	jmp	#LR__0712
	add	objptr, ##44296
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #0
	sub	objptr, ##43216
	call	#__system____builtin_atoi
	qmul	local04, result1
	getqx	local01
	mov	local03, #28
LR__0712
'     if m=-1 then t1.result.iresult=m*val%(lparts(ct).part$): t1.result_type=result_int ' todo token_int64
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0713
	add	objptr, ##44296
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #0
	sub	objptr, ##43216
	call	#__system____builtin_atoi
	qmul	local04, result1
	getqx	local01
	mov	local03, #28
LR__0713
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##54080
	rdlong	local01, objptr
	mov	local04, local01
	shl	local04, #1
	add	local04, local01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	local06, local04
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local01, local06
	shl	local01, #1
	add	local01, local06
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #4
	wrlong	local07, local01
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
	jmp	#LR__0726
LR__0714
	add	objptr, ##44296
	rdlong	local06, objptr
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #0
	sub	objptr, ##43216
	call	#__system____builtin_atoi
	qmul	local04, result1
	add	objptr, ##54080
	rdlong	local06, objptr
	mov	local08, local06
	shl	local08, #1
	add	local08, local06
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	add	objptr, ##1536
	getqx	local01
	mov	local03, #28
	mov	local06, local01
	mov	local07, local02
	wrlong	local06, local08
	mov	local08, local03
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #4
	wrlong	local07, local05
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local08, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
	jmp	#LR__0726
LR__0715
'     if m=1 then t1.result.fresult=1.0*val(lparts(ct).part$): t1.result_type=result_float  
	cmp	local04, #1 wz
 if_ne	jmp	#LR__0716
	mov	local06, ##1065353216
	add	objptr, ##44296
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	rdlong	arg01, local08
	sub	objptr, ##43216
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	mov	local01, result1
	mov	local03, #30
LR__0716
'     if m=-1 then t1.result.fresult=-1.0*val(lparts(ct).part$): t1.result_type=result_float
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0717
	mov	local06, ##-1082130432
	add	objptr, ##44296
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	rdlong	arg01, local08
	sub	objptr, ##43216
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	mov	local01, result1
	mov	local03, #30
LR__0717
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##54080
	rdlong	local01, objptr
	mov	local08, local01
	shl	local08, #1
	add	local08, local01
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	wrlong	local06, local08
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local06, local08
	shl	local06, #1
	add	local06, local08
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #4
	wrlong	local07, local06
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local07, local08
	shl	local07, #1
	add	local07, local08
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	add	local07, #8
	wrlong	local05, local07
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
	jmp	#LR__0726
LR__0718
	mov	local03, #31
	add	objptr, ##44296
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	sub	objptr, ##43216
	mov	local09, arg01
	callpa	#(@LR__0720-@LR__0719)>>2,fcache_load_ptr_
LR__0719
	rdbyte	result1, local09 wz
 if_ne	add	local09, #1
 if_ne	jmp	#LR__0719
LR__0720
	sub	local09, arg01
	mov	result1, local09
	add	objptr, ##62840
	wrlong	result1, objptr
	sub	objptr, #60
	rdlong	arg01, objptr
	sub	arg01, result1
	sub	arg01, #4
	andn	arg01, #3
	wrlong	arg01, objptr
	add	objptr, #60
	rdlong	arg02, objptr
	mov	arg03, #1
	mov	arg04, #0
	sub	objptr, ##57016
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
'     pslpoke memtop,l
'     for i=1 to l : pspoke memtop+3+i, asc(mid$(lparts(ct).part$,i,1)) : next i
	mov	local10, #1
	add	objptr, ##57016
	rdlong	local11, objptr
	sub	objptr, ##62840
	add	local11, #1
LR__0721
	cmps	local10, local11 wc
 if_ae	jmp	#LR__0722
	add	objptr, ##62780
	rdlong	local07, objptr
	add	local07, #3
	add	local07, local10
	sub	objptr, ##18484
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	rdlong	arg01, local08
	mov	arg02, local10
	mov	arg03, #1
	sub	objptr, ##43216
	call	#__system__Mid_S
	rdbyte	arg02, result1
	mov	arg01, local07
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 1)
	mov	arg05, #1
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	add	local10, #1
	jmp	#LR__0721
LR__0722
	add	objptr, ##62780
	rdlong	local01, objptr
	mov	local03, #43
	mov	local06, local01
	mov	local07, local02
	mov	local11, local03
	sub	objptr, ##8700
	rdlong	local10, objptr
	mov	local08, local10
	shl	local08, #1
	add	local08, local10
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	wrlong	local06, local08
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local08, local10
	shl	local08, #1
	add	local08, local10
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	add	local08, #4
	wrlong	local07, local08
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local08, local10
	shl	local08, #1
	add	local08, local10
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	add	local08, #8
	wrlong	local11, local08
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
	jmp	#LR__0726
LR__0723
	mov	arg01, local04
	call	#_getvar
	add	objptr, ##44296
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
	jmp	#LR__0726
LR__0724
	add	objptr, ##44296
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
	call	#_expr
'     ct+=1
'     expr() 
'     if lparts(ct).token=token_rpar then ct+=1
	add	objptr, ##44296
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local11, local11
	cmp	local11, #20 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0726
	add	objptr, ##44296
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
	jmp	#LR__0726
LR__0725
	mov	arg01, local04
	call	#_getfun
	add	objptr, ##44296
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##44296
LR__0726
	mov	ptra, fp
	call	#popregs_
_getvalue_ret
	ret

' 
' sub getfun(m as integer) ' todo - functions return type, todo" fun can have expr list after it
_getfun
	mov	COUNT_, #10
	call	#pushregs_
_getfun_enter
	mov	local04, arg01
	add	objptr, ##44296
	rdlong	local05, objptr
	mov	local06, local05
	mov	local07, #0
'  ' if lparts(ct+1).token=token_lpar then oldct=ct: ct+=1: expr()
' oldct=ct
' numpar=0
'   
' if lparts(ct+1).token=token_lpar then
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local05, local05
	cmp	local05, #21 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0734
	add	objptr, ##44296
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##44296
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__0730
	add	objptr, ##44296
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
'     ct+=1  											': print "In getfun, ct=",ct,"lparts(ct).token=",lparts(ct).token, "part$=",lparts(ct).part$
'     if lparts(ct).token=token_lpar then ct+=1 : expr() : ct+=1 else expr()
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local08, local05
	cmp	local08, #21 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0731
	add	objptr, ##44296
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##44296
	call	#_expr
	add	objptr, ##44296
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##44296
	jmp	#LR__0732
LR__0731
	call	#_expr
LR__0732
	add	local07, #1
	add	objptr, ##44296
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local08, local05
	cmp	local08, #20 wz
	sub	objptr, ##43216
 if_e	jmp	#LR__0733
	add	objptr, ##44296
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local08, local08
	cmp	local08, #510 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0730
LR__0733
LR__0734
	mov	local01, local07
	shl	local06, #3
	add	objptr, ##43216
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local08, local01
	mov	local07, local02
	mov	local06, local03
	add	objptr, ##10864
	rdlong	local05, objptr
	mov	arg01, local05
	shl	arg01, #1
	add	arg01, local05
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	wrlong	local08, arg01
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local07, local09
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local10, local08
	shl	local10, #1
	add	local10, local08
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #8
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##54080
' 
' t2.result.uresult=numpar
' 
' t2.result_type=lparts(oldct).token  ' todo here: expression lists..... 
' compiledline(lineptr)=t2: lineptr+=1   ' if t2.result.uresult=-1, generate error
' 
'   
' if m=-1 then t2.result_type=fun_negative: compiledline(lineptr)=t2: lineptr+=1
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0735
	mov	local03, #21
	mov	local08, local01
	mov	local07, local02
	mov	local06, local03
	add	objptr, ##54080
	rdlong	local05, objptr
	mov	arg01, local05
	shl	arg01, #1
	add	arg01, local05
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	wrlong	local08, arg01
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local07, local09
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local10, local09
	shl	local10, #1
	add	local10, local09
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #8
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##54080
LR__0735
	mov	ptra, fp
	call	#popregs_
_getfun_ret
	ret

'   
'   
' sub getvar(m as integer) 
_getvar
	mov	COUNT_, #10
	call	#pushregs_
_getvar_enter
	mov	local04, arg01
	add	objptr, ##44296
	rdlong	arg02, objptr
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	local05, arg02
	mov	arg01, local05
	mov	arg02, #1
	sub	objptr, ##43216
	call	#__system__Right_S
	mov	local06, result1
	neg	local07, #1
' 
' varname$=lparts(ct).part$
' suffix$=right$(varname$,1)
' j=-1
' 
' for i=0 to varnum-1
	mov	local08, #0
	add	objptr, ##43212
	rdlong	local09, objptr
	sub	objptr, ##43212
LR__0740
	cmps	local08, local09 wc
 if_ae	jmp	#LR__0741
'   if variables(i).name=varname$ then j=i : exit
	mov	arg02, local08
	shl	arg02, #4
	add	objptr, ##26828
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, local05
	sub	objptr, ##26828
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local07, local08
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0740
LR__0741
' if  j=-1 andalso varnum<maxvars then   
	cmp	local07, ##-1 wz
 if_ne	jmp	#LR__0742
	add	objptr, ##43212
	rdlong	local09, objptr
	sub	objptr, ##43212
	cmps	local09, ##1023 wc
 if_ae	jmp	#LR__0742
	add	objptr, ##43212
	rdlong	local09, objptr
	shl	local09, #4
	sub	objptr, ##16384
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##16384
	rdlong	local09, objptr
	shl	local09, #4
	sub	objptr, ##16384
	add	local09, objptr
	add	local09, #4
	wrlong	#0, local09
	add	objptr, ##16384
	rdlong	local09, objptr
	shl	local09, #4
	sub	objptr, ##16384
	add	local09, objptr
	add	local09, #12
	wrlong	#28, local09
	add	objptr, ##16384
	rdlong	local09, objptr
	mov	local07, local09
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##43212
LR__0742
	mov	local09, #0
' numpar=0
' ' check if it is an array
' 
' if lparts(ct+1).token=token_lpar then
	add	objptr, ##44296
	rdlong	local08, objptr
	add	local08, #1
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local08, local08
	cmp	local08, #21 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0747
	add	objptr, ##44296
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##44296
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__0743
	add	objptr, ##44296
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
'     ct+=1  											': print "In getfun, ct=",ct,"lparts(ct).token=",lparts(ct).token, "part$=",lparts(ct).part$
'     if lparts(ct).token=token_lpar then ct+=1 : expr() : ct+=1 else expr()
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local10, local08
	cmp	local10, #21 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0744
	add	objptr, ##44296
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##44296
	call	#_expr
	add	objptr, ##44296
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##44296
	jmp	#LR__0745
LR__0744
	call	#_expr
LR__0745
	add	local09, #1
	add	objptr, ##44296
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local10, local08
	cmp	local10, #20 wz
	sub	objptr, ##43216
 if_e	jmp	#LR__0746
	add	objptr, ##44296
	rdlong	local10, objptr
	shl	local10, #3
	sub	objptr, ##1080
	add	local10, objptr
	add	local10, #4
	rdlong	local10, local10
	cmp	local10, #510 wz
	sub	objptr, ##43216
 if_ne	jmp	#LR__0743
LR__0746
LR__0747
	mov	local02, local09
	mov	local03, #17
	mov	local01, local07
	mov	local10, local01
	mov	local09, local02
	mov	local08, local03
	add	objptr, ##54080
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	wrlong	local10, local06
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local05, local10
	shl	local05, #1
	add	local05, local10
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #4
	wrlong	local09, local05
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	result1, local10
	shl	result1, #1
	add	result1, local10
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	add	result1, #8
	wrlong	local08, result1
	add	objptr, ##1536
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##54080
' 
' t2.result.twowords(1)=numpar
' 
' 
' 
' t2.result_type=fun_getvar:t2.result.twowords(0)=j
' 
' 
'  
' 
' 701 
' compiledline(lineptr)=t2: lineptr+=1   ' if t2.result.uresult=-1, generate error
' if m=-1 then t2.result_type=fun_negative: compiledline(lineptr)=t2: lineptr+=1
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0748
	mov	local03, #21
	mov	local10, local01
	mov	local09, local02
	mov	local08, local03
	add	objptr, ##54080
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	wrlong	local10, local06
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local05, local01
	shl	local05, #1
	add	local05, local01
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #4
	wrlong	local09, local05
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	result1, local01
	shl	result1, #1
	add	result1, local01
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	add	result1, #8
	wrlong	local08, result1
	add	objptr, ##1536
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##54080
LR__0748
	mov	ptra, fp
	call	#popregs_
_getvar_ret
	ret

' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------------- End of expression evaluator --------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------------- Runtime functions ------------------------------------------------------------------------ 
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' function execute_line (astart=0 as integer) as integer
_execute_line
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, ##62072
	wrlong	#0, objptr
' runptr2=0
' for lineptr_e=astart to lineptr-1
	sub	objptr, ##7988
	wrlong	arg01, objptr
	sub	objptr, #4
	rdlong	local01, objptr
	sub	objptr, ##54080
LR__0750
	add	objptr, ##54084
	rdlong	result1, objptr
	sub	objptr, ##54084
	cmps	result1, local01 wc
 if_ae	jmp	#LR__0751
	add	objptr, ##54084
	rdlong	result1, objptr
	mov	local02, result1
	shl	local02, #1
	add	local02, result1
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	local02, #8
	rdlong	local02, local02
	getbyte	local02, local02, #0
	shl	local02, #2
	sub	objptr, ##2076
	add	local02, objptr
	rdlong	local02, local02
	mov	local03, local02
	zerox	local02, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	sub	objptr, ##50468
	mov	local04, objptr
	mov	objptr, local02
	call	local03
	mov	objptr, local04
	add	objptr, ##54084
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##54084
	jmp	#LR__0750
LR__0751
' return runptr2
	add	objptr, ##62072
	rdlong	result1, objptr
	sub	objptr, ##62072
	mov	ptra, fp
	call	#popregs_
_execute_line_ret
	ret

' 
' 
' ' ------------------- pop and push functions called by do_xxx functions to pop arguments and push results
' 
' function pop() as expr_result
_pop
' 
' if stackpointer=0 then
	add	objptr, ##50460
	rdlong	result1, objptr wz
	sub	objptr, ##50460
 if_e	mov	_var03, #255
 if_e	mov	_var01, #24
 if_e	jmp	#LR__0760
	add	objptr, ##50460
	rdlong	result1, objptr
	sub	result1, #1
	wrlong	result1, objptr
	mov	result3, result1
	shl	result3, #1
	add	result3, result1
	shl	result3, #2
	sub	objptr, ##6156
	add	result3, objptr
	rdlong	_var01, result3
	add	result3, #4
	rdlong	result3, result3
	mov	result2, result1
	shl	result2, #1
	add	result2, result1
	shl	result2, #2
	add	result2, objptr
	add	result2, #8
	rdlong	result1, result2
	mov	_var02, result3
	mov	_var03, result1
	sub	objptr, ##44304
LR__0760
' return t1
	mov	result2, _var02
	mov	result3, _var03
	mov	result1, _var01
_pop_ret
	ret

' 
' sub push(t1 as expr_result )
_push
' 
' 'print "In push: "; t1.result_type
' 'print "In push: "; t1.result.uresult
' 
' if stackpointer<maxstack then 
	add	objptr, ##50460
	rdlong	_var01, objptr
	sub	objptr, ##50460
	cmps	_var01, ##512 wc
 if_ae	jmp	#LR__0770
	rdlong	_var01, arg01
	add	arg01, #4
	rdlong	_var02, arg01
	add	arg01, #4
	rdlong	arg01, arg01
	add	objptr, ##50460
	rdlong	_var03, objptr
	mov	_var04, _var03
	shl	_var04, #1
	add	_var04, _var03
	shl	_var04, #2
	sub	objptr, ##6156
	add	_var04, objptr
	wrlong	_var01, _var04
	add	objptr, ##6156
	rdlong	_var04, objptr
	mov	_var03, _var04
	shl	_var03, #1
	add	_var03, _var04
	shl	_var03, #2
	sub	objptr, ##6156
	add	_var03, objptr
	add	_var03, #4
	wrlong	_var02, _var03
	add	objptr, ##6156
	rdlong	_var04, objptr
	mov	_var03, _var04
	shl	_var03, #1
	add	_var03, _var04
	shl	_var03, #2
	sub	objptr, ##6156
	add	_var03, objptr
	add	_var03, #8
	wrlong	arg01, _var03
	add	objptr, ##6156
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##50460
LR__0770
_push_ret
	ret

' 
' ' ------------------ push a variable on the stack as an independent operation called by execute_line 
' 
' sub do_push
_do_push
' if stackpointer<maxstack then 
	add	objptr, ##50460
	rdlong	_var01, objptr
	sub	objptr, ##50460
	cmps	_var01, ##512 wc
 if_ae	jmp	#LR__0780
	add	objptr, ##54084
	rdlong	_var02, objptr
	mov	_var03, _var02
	shl	_var03, #1
	add	_var03, _var02
	shl	_var03, #2
	sub	objptr, ##1540
	add	_var03, objptr
	rdlong	_var01, _var03
	add	_var03, #4
	rdlong	_var04, _var03
	mov	_var03, _var02
	shl	_var03, #1
	add	_var03, _var02
	shl	_var03, #2
	add	_var03, objptr
	add	_var03, #8
	rdlong	_var02, _var03
	sub	objptr, ##2084
	rdlong	_var03, objptr
	mov	_var05, _var03
	shl	_var05, #1
	add	_var05, _var03
	shl	_var05, #2
	sub	objptr, ##6156
	add	_var05, objptr
	wrlong	_var01, _var05
	add	objptr, ##6156
	rdlong	_var05, objptr
	mov	_var03, _var05
	shl	_var03, #1
	add	_var03, _var05
	shl	_var03, #2
	sub	objptr, ##6156
	add	_var03, objptr
	add	_var03, #4
	wrlong	_var04, _var03
	add	objptr, ##6156
	rdlong	_var05, objptr
	mov	_var04, _var05
	shl	_var04, #1
	add	_var04, _var05
	shl	_var04, #2
	sub	objptr, ##6156
	add	_var04, objptr
	add	_var04, #8
	wrlong	_var02, _var04
	add	objptr, ##6156
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##50460
LR__0780
_do_push_ret
	ret

' 
'   
' sub csave_block(address as ulong)
_csave_block
	mov	_var01, arg01
' 
' ' let it be 1k blocks=256 longs=8 kbits=32 k samples
' ' we enter it at the state of playing 1 kHz header tone
' 
' for i=0 to 63 step 2
	mov	_var02, #0
LR__0790
'   do: loop until lpeek(base+32*7)>32768
	add	objptr, ##44244
	callpa	#(@LR__0792-@LR__0791)>>2,fcache_load_ptr_
LR__0791
	rdlong	arg01, objptr
	add	arg01, #224
	rdlong	result1, arg01
	cmps	result1, ##32769 wc
 if_b	jmp	#LR__0791
LR__0792
	mov	arg01, _var01
	mov	_var03, _var02
	shl	_var03, #2
	add	arg01, _var03
	rdlong	_var04, arg01
	add	objptr, ##18628
	wrlong	_var04, objptr
	sub	objptr, ##62872
'   q=lpeek(address+4*i)
'      for bit=0 to 31
	mov	_var05, #0
	callpa	#(@LR__0797-@LR__0793)>>2,fcache_load_ptr_
LR__0793
'       if (q and (1 shl bit)) then sample(4*bit)=127: sample(4*bit+1)=128 : sample(4*bit+2)=127 : sample (4*bit+3)=128 else sample(4*bit)=128: sample(4*bit+1)=128 : sample(4*bit+2)=127 : sample (4*bit+3)=127
	add	objptr, ##62872
	rdlong	_var04, objptr
	sub	objptr, ##62872
	decod	_var03, _var05
	test	_var04, _var03 wz
 if_e	jmp	#LR__0794
	mov	_var03, _var05
	shl	_var03, #2
	add	objptr, ##60784
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #1
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #2
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #3
	add	_var03, objptr
	wrbyte	#128, _var03
	sub	objptr, ##60784
	jmp	#LR__0795
LR__0794
	mov	_var03, _var05
	shl	_var03, #2
	add	objptr, ##60784
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #1
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #2
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #3
	add	_var03, objptr
	wrbyte	#127, _var03
	sub	objptr, ##60784
LR__0795
	add	_var05, #1
	cmps	_var05, #32 wc
 if_b	jmp	#LR__0793
'   do: loop until lpeek(base+32*7)<32768
	add	objptr, ##44244
LR__0796
	rdlong	arg01, objptr
	add	arg01, #224
	rdlong	result1, arg01
	cmps	result1, ##32768 wc
 if_ae	jmp	#LR__0796
LR__0797
	mov	arg01, _var01
	add	arg01, #4
	mov	_var03, _var02
	shl	_var03, #2
	add	arg01, _var03
	rdlong	_var04, arg01
	add	objptr, ##18628
	wrlong	_var04, objptr
	sub	objptr, ##62872
'   q=lpeek(address+4+4*i)
'      for bit=0 to 31
	mov	_var05, #0
	callpa	#(@LR__0801-@LR__0798)>>2,fcache_load_ptr_
LR__0798
'       if (q and (1 shl bit)) then sample(128+4*bit)=127: sample(128+4*bit+1)=128 : sample(128+4*bit+2)=127 : sample (128+4*bit+3)=128 else sample(128+4*bit)=128: sample(128+4*bit+1)=128 : sample(128+4*bit+2)=127 : sample (128+4*bit+3)=127
	add	objptr, ##62872
	rdlong	_var04, objptr
	sub	objptr, ##62872
	decod	_var03, _var05
	test	_var04, _var03 wz
 if_e	jmp	#LR__0799
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	objptr, ##60784
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #1
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #2
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #3
	add	_var03, objptr
	wrbyte	#128, _var03
	sub	objptr, ##60784
	jmp	#LR__0800
LR__0799
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	objptr, ##60784
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #1
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #2
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #3
	add	_var03, objptr
	wrbyte	#127, _var03
	sub	objptr, ##60784
LR__0800
	add	_var05, #1
	cmps	_var05, #32 wc
 if_b	jmp	#LR__0798
LR__0801
	add	_var02, #2
	cmps	_var02, #64 wc
 if_b	jmp	#LR__0790
' do: loop until lpeek(base+32*7)>32768
	add	objptr, ##44244
	callpa	#(@LR__0810-@LR__0802)>>2,fcache_load_ptr_
LR__0802
	rdlong	arg01, objptr
	add	arg01, #224
	rdlong	result1, arg01
	cmps	result1, ##32769 wc
 if_b	jmp	#LR__0802
	sub	objptr, ##44244
' for i=0 to 127: if i mod 8 < 4 then sample(i)=127 else sample(i)=128 
	mov	_var02, #0
LR__0803
	abs	_var04, _var02 wc
	and	_var04, #7
	negc	_var04, _var04
	cmps	_var04, #4 wc
 if_ae	jmp	#LR__0804
	mov	_var06, _var02
	add	objptr, ##60784
	add	_var06, objptr
	wrbyte	#127, _var06
	sub	objptr, ##60784
	jmp	#LR__0805
LR__0804
	mov	_var06, _var02
	add	objptr, ##60784
	add	_var06, objptr
	wrbyte	#128, _var06
	sub	objptr, ##60784
LR__0805
	add	_var02, #1
	cmps	_var02, #128 wc
 if_b	jmp	#LR__0803
' 
' do: loop until lpeek(base+32*7)<32768
	add	objptr, ##44244
LR__0806
	rdlong	arg01, objptr
	add	arg01, #224
	rdlong	result1, arg01
	cmps	result1, ##32768 wc
 if_ae	jmp	#LR__0806
	sub	objptr, ##44244
' for i=128 to 255: if i mod 8 < 4 then sample(i)=127 else sample(i)=128 
	mov	_var02, #128
LR__0807
	abs	_var04, _var02 wc
	and	_var04, #7
	negc	_var04, _var04
	cmps	_var04, #4 wc
 if_ae	jmp	#LR__0808
	mov	_var06, _var02
	add	objptr, ##60784
	add	_var06, objptr
	wrbyte	#127, _var06
	sub	objptr, ##60784
	jmp	#LR__0809
LR__0808
	mov	_var06, _var02
	add	objptr, ##60784
	add	_var06, objptr
	wrbyte	#128, _var06
	sub	objptr, ##60784
LR__0809
	add	_var02, #1
	cmp	_var02, #256 wc
 if_b	jmp	#LR__0807
LR__0810
_csave_block_ret
	ret

' 
' sub csave_addtoblock(d as ubyte, force as ubyte)
_csave_addtoblock
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' 
' if force=0 then
	zerox	arg02, #7 wz
 if_ne	jmp	#LR__0820
	add	objptr, ##62064
	rdlong	arg02, objptr
	sub	objptr, ##1024
	add	arg02, objptr
	wrbyte	local01, arg02
	add	objptr, ##1024
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
'   block(blockptr)=d
'   blockptr+=1
'   if blockptr>=255 then
	sub	objptr, ##62064
	cmp	local01, #255 wc
 if_b	jmp	#LR__0824
	add	objptr, ##61040
	mov	arg01, objptr
	sub	objptr, ##61040
	call	#_csave_block
	add	objptr, ##62064
	wrlong	#0, objptr
	sub	objptr, ##62064
	mov	arg01, #300
	call	#__system___waitms
	jmp	#LR__0824
LR__0820
	add	objptr, ##62064
	rdlong	local02, objptr
	sub	objptr, ##1024
	add	local02, objptr
	wrbyte	local01, local02
'   block(blockptr)=d
'   if blockptr<255 then for i=blockptr to 255 : block(i)=0 : next i 
	add	objptr, ##1024
	rdlong	local03, objptr
	sub	objptr, ##62064
	cmp	local03, #255 wc
 if_ae	jmp	#LR__0823
	add	objptr, ##62064
	rdlong	local04, objptr
	sub	objptr, ##62064
LR__0821
	cmps	local04, #256 wc
 if_ae	jmp	#LR__0822
	mov	local02, local04
	add	objptr, ##61040
	add	local02, objptr
	wrbyte	#0, local02
	add	local04, #1
	sub	objptr, ##61040
	jmp	#LR__0821
LR__0822
LR__0823
	add	objptr, ##61040
	mov	arg01, objptr
	sub	objptr, ##61040
	call	#_csave_block
	add	objptr, ##62064
	wrlong	#0, objptr
	sub	objptr, ##62064
	mov	arg01, #300
	call	#__system___waitms
LR__0824
	mov	ptra, fp
	call	#popregs_
_csave_addtoblock_ret
	ret

' 
' sub test_csave
_test_csave
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #192
' 'dim fileheader,savestart, saveptr as ulong
' 
' if pslpeek(programstart)=$FFFFFFFF then printerror(27): return
	add	objptr, ##54088
	rdlong	arg01, objptr
	sub	objptr, ##54088
	call	#_pslpeek
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__0830
	mov	arg01, #27
	call	#_printerror
	jmp	#LR__0842
LR__0830
	call	#_pop
	mov	local01, result3
	add	fp, #144
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
' t1=pop()
' if t1.result_type<>result_string then name$="noname.bas" else name$=t1.result.sresult
	sub	fp, #152
	cmp	local01, #31 wz
 if_ne	mov	local01, ##@LR__4589
 if_ne	add	fp, #140
 if_ne	wrlong	local01, fp
 if_ne	sub	fp, #140
 if_e	add	fp, #144
 if_e	rdlong	local01, fp
 if_e	sub	fp, #4
 if_e	wrlong	local01, fp
 if_e	sub	fp, #140
' 
' ' prepare 1 kHz header wave
' 
' for i=0 to 255: if i mod 8 < 4 then sample(i)=127 else sample(i)=128 
	wrlong	#0, fp
	callpa	#(@LR__0834-@LR__0831)>>2,fcache_load_ptr_
LR__0831
	rdlong	local01, fp
	abs	local01, local01 wc
	and	local01, #7
	negc	local01, local01
	cmps	local01, #4 wc
 if_ae	jmp	#LR__0832
	rdlong	local01, fp
	add	objptr, ##60784
	add	local01, objptr
	wrbyte	#127, local01
	sub	objptr, ##60784
	jmp	#LR__0833
LR__0832
	rdlong	local01, fp
	add	objptr, ##60784
	add	local01, objptr
	wrbyte	#128, local01
	sub	objptr, ##60784
LR__0833
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	cmps	local01, #256 wc
 if_b	jmp	#LR__0831
LR__0834
	add	objptr, ##60784
	mov	arg02, objptr
	mov	arg01, #7
	mov	arg03, ##8000
	decod	arg04, #14
	mov	arg05, #256
	mov	arg06, #0
	sub	objptr, ##54960
	call	#_Audio093b_8_sc_spin2_play8
	sub	objptr, ##5824
	mov	arg01, ##3000
	call	#__system___waitms
	add	objptr, ##62064
	wrlong	#0, objptr
	sub	objptr, ##62064
	mov	arg01, #114
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #98
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #97
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #13
	mov	arg02, #0
	call	#_csave_addtoblock
' paula.play8(7,varptr(sample),8000,16384,256,0)
' waitms 3000 
' 
' blockptr=0
' csave_addtoblock($72,0): csave_addtoblock($62,0): csave_addtoblock($61,0): csave_addtoblock($0D,0) ' rba+ver(13)
' for i=1 to len(name$): csave_addtoblock(asc(mid$(name$,i,1)),0) : next i : csave_addtoblock(0,0) 
	wrlong	#1, fp
	add	fp, #140
	rdlong	arg01, fp
	sub	fp, #140
	mov	local02, arg01
	callpa	#(@LR__0836-@LR__0835)>>2,fcache_load_ptr_
LR__0835
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0835
LR__0836
	sub	local02, arg01
	mov	local03, local02
	add	local03, #1
LR__0837
	rdlong	local01, fp
	cmps	local01, local03 wc
 if_ae	jmp	#LR__0838
	add	fp, #140
	rdlong	arg01, fp
	sub	fp, #140
	rdlong	arg02, fp
	mov	arg03, #1
	call	#__system__Mid_S
	rdbyte	arg01, result1
	mov	arg02, #0
	call	#_csave_addtoblock
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	jmp	#LR__0837
LR__0838
	mov	arg01, #0
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #114
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #98
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #115
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #13
	mov	arg02, #0
	call	#_csave_addtoblock
	add	objptr, ##54088
	rdlong	local01, objptr
	sub	objptr, ##54088
	add	fp, #156
	wrlong	local01, fp
	sub	fp, #156
' csave_addtoblock($72,0): csave_addtoblock($62,0): csave_addtoblock($73,0): csave_addtoblock($0D,0) ' rbs+ver(13)
' 
' saveptr=programstart
' do
LR__0839
	add	fp, #160
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #156
	mov	arg03, #24
	add	objptr, ##5824
	call	#_psram_spin2_read1
	add	fp, #12
	mov	arg01, fp
	add	fp, #156
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #172
	call	#_psram_spin2_read1
	sub	objptr, ##5824
	add	fp, #172
	rdlong	arg01, fp
	sub	fp, #172
	mov	arg02, #0
	call	#_csave_addtoblock
'   psram.read1(varptr(header(0)),saveptr,24)
'   psram.read1(varptr(linebuf(0)),header(2),header(3))  
'   csave_addtoblock(header(3),0) ' that's always <255
'   for i=0 to header(3)-1: csave_addtoblock(linebuf(i),0)    :next i
	wrlong	#0, fp
	add	fp, #172
	rdlong	local04, fp
	sub	fp, #172
LR__0840
	rdlong	local01, fp
	cmps	local01, local04 wc
 if_ae	jmp	#LR__0841
	rdlong	local03, fp
	add	fp, #12
	add	local03, fp
	rdbyte	arg01, local03
	mov	arg02, #0
	sub	fp, #12
	call	#_csave_addtoblock
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	jmp	#LR__0840
LR__0841
	add	fp, #180
	rdlong	local01, fp
	sub	fp, #24
	wrlong	local01, fp
	add	fp, #24
	rdlong	local01, fp
	sub	fp, #180
	cmp	local01, ##2147483647 wz
 if_ne	jmp	#LR__0839
	mov	arg01, #0
	mov	arg02, #1
	call	#_csave_addtoblock
	add	objptr, ##44244
	rdlong	arg01, objptr
	sub	objptr, ##44244
	add	arg01, #244
	wrword	#0, arg01
LR__0842
	mov	ptra, fp
	call	#popregs_
_test_csave_ret
	ret

' 
' ' ----------------- Save the program
' 
' sub do_save                           ''' <------------------------ TODO vartables has to be saved too! Or maybe o
_do_save
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, ##700
	add	fp, ##528
	wrlong	##224486002, fp
	sub	fp, ##528
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
' 
' fileheader=$0D616272' rba+ver'
' 
' t1=pop() 
' if pslpeek(programstart)=$FFFFFFFF then printerror(27): return
	add	objptr, ##54088
	rdlong	arg01, objptr
	sub	objptr, ##54088
	call	#_pslpeek
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__0850
	mov	arg01, #27
	call	#_printerror
	jmp	#LR__0856
LR__0850
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult): t1.result_type=result_string
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__0851
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__0851
' if t1.result_type=result_string then
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_ne	jmp	#LR__0855
'   if t1.result.sresult="" then t1.result.sresult="noname.bas"
	rdlong	arg01, fp
	mov	arg02, ##@LR__4590
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local01, ##@LR__4591
 if_e	wrlong	local01, fp
'   close #9: open currentdir$+"/"+t1.result.sresult for output as #9
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	add	objptr, ##58200
	rdlong	arg01, objptr
	sub	objptr, ##58200
	mov	arg02, ##@LR__4592
	call	#__system___string_concat
	mov	arg01, result1
	rdlong	arg02, fp
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #13
	call	#__system___basic_open_string
	add	fp, ##524
	wrlong	#5, fp
	add	objptr, ##54088
	rdlong	local01, objptr
	sub	objptr, ##54088
	add	fp, #12
	wrlong	local01, fp
	sub	fp, ##536
' '  put #9,1,fileheader,1
'   i=5
'   saveptr=programstart
'   do
LR__0852
	add	fp, ##540
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, ##536
	mov	arg03, #24
	add	objptr, ##5824
	call	#_psram_spin2_read1
	add	fp, ##564
	mov	arg01, fp
	sub	fp, #16
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, ##552
	call	#_psram_spin2_read1
	sub	objptr, ##5824
	mov	local01, ##@LR__4593
	add	fp, ##692
	wrlong	local01, fp
'     psram.read1(varptr(header(0)),saveptr,24)
'     psram.read1(varptr(linebuf(0)),header(2),header(3)) 
'     saveline$="" : for i=1 to header(3) : saveline$=saveline$+chr$(linebuf(i-1)) : next i 
	sub	fp, #168
	wrlong	#1, fp
	add	fp, #28
	rdlong	local02, fp
	sub	fp, ##552
	add	local02, #1
LR__0853
	add	fp, ##524
	rdlong	local01, fp
	sub	fp, ##524
	cmps	local01, local02 wc
 if_ae	jmp	#LR__0854
	add	fp, ##692
	rdlong	local01, fp
	sub	fp, #168
	rdlong	arg03, fp
	sub	arg03, #1
	add	fp, #40
	add	arg03, fp
	rdbyte	arg01, arg03
	sub	fp, ##564
	call	#__system__Chr_S
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	add	fp, ##692
	wrlong	result1, fp
	sub	fp, #168
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	sub	fp, ##524
	jmp	#LR__0853
LR__0854
'  '   put #9,i,header(3),1 : i+=4
'  '   put #9,i,linebuf(0),header(3) : i+=header(3)
'      print #9, saveline$
	mov	arg01, #9
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	add	fp, ##692
	rdlong	arg02, fp
	sub	fp, ##692
	mov	arg01, #9
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #9
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #9
	call	#__system___getiolock_0425
	wrlong	#0, result1
	add	fp, ##560
	rdlong	local01, fp
	sub	fp, #24
	wrlong	local01, fp
	add	fp, #24
	rdlong	local01, fp
	sub	fp, ##560
	cmp	local01, ##2147483647 wz
 if_ne	jmp	#LR__0852
'   close #9  
	mov	arg01, #9
	call	#__system__close
LR__0855
LR__0856
	mov	ptra, fp
	call	#popregs_
_do_save_ret
	ret

' 
' '----------------- Load the program
' 'lo todo: errors while loading
' sub do_load
_do_load
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #164
	add	fp, #160
	mov	arg01, fp
	sub	fp, #128
	mov	arg02, fp
	sub	fp, #32
	wrlong	arg02, arg01
	call	#_pop
	mov	arg05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
' 
' lpoke varptr(line2$),varptr(line2)
' t1=pop() 
' 'print "popped "; t1.result.uresult, t1.result_type
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult): t1.result_type=result_string ': print t1.result.sresult
	sub	fp, #8
	cmp	arg05, #43 wz
 if_ne	jmp	#LR__0860
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__0860
' if t1.result_type=result_string then
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_ne	jmp	#LR__0867
	call	#_do_new
'   do_new
'   if t1.result.sresult="" then t1.result.sresult="noname.bas" 
	rdlong	arg01, fp
	mov	arg02, ##@LR__4594
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local01, ##@LR__4595
 if_e	wrlong	local01, fp
'   close #9: open currentdir$+"/"+t1.result.sresult for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	add	objptr, ##58200
	rdlong	arg01, objptr
	sub	objptr, ##58200
	mov	arg02, ##@LR__4596
	call	#__system___string_concat
	mov	arg01, result1
	rdlong	arg02, fp
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	sub	ptr___system__dat__, #32
	add	fp, #16
	wrlong	result1, fp
'   r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return
	sub	fp, #16
 if_e	jmp	#LR__0861
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4597
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #16
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__4598
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__0869
LR__0861
	add	fp, #12
	wrlong	#5, fp
'   i=5
'   get #9,1,header,1
	add	fp, #12
	mov	arg03, fp
	sub	fp, #24
	mov	arg01, #9
	mov	arg02, #1
	mov	arg04, #1
	mov	arg05, #4
	call	#__system___basic_get
'   
'   if header<>$0D616272 then 
	add	fp, #24
	rdlong	local01, fp
	sub	fp, #24
	cmp	local01, ##224486002 wz
 if_e	jmp	#LR__0864
'     close #9: open currentdir$+"/"+t1.result.sresult for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	add	objptr, ##58200
	rdlong	arg01, objptr
	sub	objptr, ##58200
	mov	arg02, ##@LR__4599
	call	#__system___string_concat
	mov	arg01, result1
	rdlong	arg02, fp
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_open_string
'     do
LR__0862
	mov	arg01, #9
	call	#__system___basic_read_line
	add	objptr, ##44256
	wrlong	result1, objptr
'       if left$(line$,1) >="0" andalso left$(line$,1)<="9" then interpret
	sub	objptr, ##44256
	mov	arg01, result1
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__4600
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0863
	add	objptr, ##44256
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__4601
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	call	#_interpret
LR__0863
	add	objptr, ##44256
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	arg02, ##@LR__4602
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0862
'     close #9
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__0868
LR__0864
'   'printerror(26) : close #9 : return
'     do
LR__0865
'       get #9,i,linelength,1,amount : i+=4 : line2(linelength)=0
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #16
	mov	arg03, fp
	sub	fp, #28
	mov	arg01, #9
	mov	arg04, #1
	mov	arg05, #4
	call	#__system___basic_get
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #8
	rdlong	local01, fp
	add	local01, #4
	wrlong	local01, fp
	add	fp, #16
	rdlong	local01, fp
	add	fp, #4
	add	local01, fp
	wrbyte	#0, local01
'       if amount=1 then  
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #1 wz
 if_ne	jmp	#LR__0866
'         get #9,i,line2(0),linelength : i+=linelength
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #20
	mov	arg03, fp
	sub	fp, #4
	rdlong	arg04, fp
	sub	fp, #28
	mov	arg01, #9
	mov	arg05, #1
	call	#__system___basic_get
	add	fp, #12
	rdlong	local01, fp
	add	fp, #16
	rdlong	arg05, fp
	add	local01, arg05
	sub	fp, #16
	wrlong	local01, fp
	add	fp, #148
	rdlong	local01, fp
	sub	fp, #160
	add	objptr, ##44256
	wrlong	local01, objptr
	sub	objptr, ##44256
	call	#_interpret
LR__0866
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmps	local01, #1 wc
 if_ae	jmp	#LR__0865
'     close #9 
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__0868
LR__0867
	mov	arg01, #30
	call	#_printerror
LR__0868
LR__0869
	mov	ptra, fp
	call	#popregs_
_do_load_ret
	ret

' 
' '----------------- Run the program 
' 
' '' line header: linenum major, linenum minor, list start, list length, prev ptr, next ptr
' 
' sub do_run
_do_run
	mov	COUNT_, #1
	call	#pushregs_
	add	objptr, ##54088
	rdlong	arg06, objptr
	add	objptr, ##7980
	wrlong	arg06, objptr
	add	objptr, #4
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	##-1, objptr
' if inrun>0 then 
	add	objptr, #4
	rdlong	arg06, objptr
	sub	objptr, ##62080
	cmp	arg06, #1 wc
 if_b	jmp	#LR__0870
	add	objptr, ##62084
	mov	arg01, objptr
	sub	objptr, #16
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##56244
	call	#_psram_spin2_read1
	sub	objptr, ##5824
'   psram.read1(varptr(runheader),runptr,24)  
'   return
	jmp	#LR__0876
LR__0870
	add	objptr, ##62080
	wrlong	#1, objptr
	add	objptr, #4
	mov	arg01, objptr
	sub	objptr, #16
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##56244
	call	#_psram_spin2_read1
' inrun=1
' psram.read1(varptr(runheader),runptr,24) 
' if runheader(0)=$FFFFFFFF then inrun=0: return 
	add	objptr, ##56260
	rdlong	local01, objptr
	sub	objptr, ##62084
	cmp	local01, ##-1 wz
 if_e	add	objptr, ##62080
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##62080
 if_e	jmp	#LR__0876
' do 
LR__0871
'   if runptr<>oldrunptr then
	add	objptr, ##62068
	rdlong	local01, objptr
	add	objptr, #8
	rdlong	arg06, objptr
	sub	objptr, ##62076
	cmp	local01, arg06 wz
 if_e	jmp	#LR__0872
	add	objptr, ##62084
	mov	arg01, objptr
	sub	objptr, #16
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##56244
	call	#_psram_spin2_read1
	add	objptr, ##46720
	mov	arg01, objptr
	add	objptr, ##9524
	rdlong	arg02, objptr
	sub	objptr, ##10572
	rdlong	local01, objptr
	shl	local01, #1
	add	arg02, local01
	add	objptr, ##10596
	rdlong	arg03, objptr
	sub	objptr, #24
	rdlong	local01, objptr
	sub	arg03, local01
	sub	objptr, ##56244
	call	#_psram_spin2_read1
	add	objptr, ##56268
	rdlong	local01, objptr
	sub	objptr, #24
	rdlong	arg06, objptr
	sub	local01, arg06
	sub	objptr, ##10572
	rdlong	arg06, objptr
	qdiv	local01, arg06
	add	objptr, ##2584
	getqx	local01
	sub	local01, #3
	wrlong	local01, objptr
	add	objptr, ##7988
	rdlong	local01, objptr
	add	objptr, #8
	wrlong	local01, objptr
	sub	objptr, ##62076
LR__0872
	add	objptr, ##62104
	rdlong	local01, objptr
	sub	objptr, #36
	wrlong	local01, objptr
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, ##62072
	call	#_execute_line
	add	objptr, ##62072
	wrlong	result1, objptr
	sub	objptr, #4
	rdlong	local01, objptr
	sub	objptr, ##62068
	cmp	local01, ##2147483647 wz
 if_e	jmp	#LR__0873
	call	#_usbnew_spin2_get_key
	cmp	result1, #262 wz
 if_ne	jmp	#LR__0871
LR__0873
' if runheader(5)<>$7FFF_FFFF then 
	add	objptr, ##62104
	rdlong	local01, objptr
	sub	objptr, ##62104
	cmp	local01, ##2147483647 wz
 if_e	jmp	#LR__0875
'   if keyclick=1 then paula.play(7,keyclick_spl,44100,16384,spl_len)  
	add	objptr, ##62116
	rdlong	local01, objptr
	sub	objptr, ##62116
	cmp	local01, #1 wz
 if_ne	jmp	#LR__0874
	add	objptr, ##62792
	rdlong	arg02, objptr
	sub	objptr, #4
	rdlong	arg05, objptr
	mov	arg01, #7
	mov	arg03, ##44100
	decod	arg04, #14
	neg	arg06, #1
	sub	objptr, ##56964
	call	#_Audio093b_8_sc_spin2_play
	sub	objptr, ##5824
LR__0874
'   print "Stopped at line ";runheader(0)
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4603
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##62084
	rdlong	arg02, objptr
	sub	objptr, ##62084
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__0875
	add	objptr, ##62080
	wrlong	#0, objptr
	sub	objptr, ##62080
LR__0876
	mov	ptra, fp
	call	#popregs_
_do_run_ret
	ret

' 
' sub do_defenv
_do_defenv
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #132
	add	objptr, ##54084
	rdlong	arg05, objptr
	mov	arg04, arg05
	shl	arg04, #1
	add	arg04, arg05
	shl	arg04, #2
	sub	objptr, ##1540
	add	arg04, objptr
	rdlong	arg05, arg04
	wrlong	arg05, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' 
' 
' ' defenv channel, string - tries to load from /media/h a h2 file from PC-Softsynth
' ' defenv channel, l1,r1,l2,r2,l3,r3,l4,r4 - defines ADSR in Yamaha DX  style, except these are linear values
' ' Every 5 ms added 
' ' defsnd channel, a,d,s,r - defines ADSR as in SID 
' 
' 
' if numpar<2 then return
	cmps	arg05, #2 wc
	sub	objptr, ##52544
 if_b	jmp	#LR__0906
' 
'  
' if numpar=2 then
	rdlong	arg05, fp
	cmp	arg05, #2 wz
 if_ne	jmp	#LR__0889
	call	#_pop
	mov	arg05, result3
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
'   t1=pop()
'   if t1.result_type=result_string2 then 
	sub	fp, #48
	cmp	arg05, #43 wz
 if_ne	jmp	#LR__0880
	add	fp, #40
	rdlong	arg01, fp
	sub	fp, #40
	call	#_convertstring
	add	fp, #52
	wrlong	result1, fp
	sub	fp, #52
	jmp	#LR__0883
LR__0880
	add	fp, #48
	rdlong	arg05, fp
	sub	fp, #48
	cmp	arg05, #31 wz
 if_ne	jmp	#LR__0881
	add	fp, #40
	rdlong	arg05, fp
	add	fp, #12
	wrlong	arg05, fp
	sub	fp, #52
	jmp	#LR__0882
LR__0881
	mov	arg05, ##@LR__4604
	add	fp, #52
	wrlong	arg05, fp
	sub	fp, #52
LR__0882
LR__0883
' 
'     
'   if s<>"" then 
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #52
	mov	arg02, ##@LR__4605
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0887
	call	#_pop
	mov	arg05, result3
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #40
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
'     t1=pop()
'     channel=converttoint(t1) 
'     close #9 : open "/sd/media/h/"+s for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	mov	arg01, ##@LR__4606
	add	fp, #52
	rdlong	arg02, fp
	sub	fp, #52
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	sub	ptr___system__dat__, #32
	add	objptr, ##62916
	wrlong	result1, objptr
'     r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return   
	sub	objptr, ##62916
 if_e	jmp	#LR__0884
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4607
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##62916
	rdlong	arg02, objptr
	sub	objptr, ##62916
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__4608
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local01, #0
	add	objptr, ##62916
	rdlong	arg01, objptr
	sub	objptr, ##62916
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__0906
LR__0884
'     get #9,17,envbuf8(channel,0),256
	add	fp, #16
	rdlong	arg05, fp
	sub	fp, #16
	mov	arg03, arg05
	shl	arg03, #9
	add	arg03, arg05
	add	objptr, ##22732
	add	arg03, objptr
	mov	arg01, #9
	mov	arg02, #17
	mov	arg04, #256
	mov	arg05, #1
	sub	objptr, ##22732
	call	#__system___basic_get
'     for i=255 to 0 step -1 : envbuf(channel,i)=envbuf8(channel,i)*256 : next i
	add	fp, #4
	wrlong	#255, fp
	sub	fp, #4
	add	objptr, ##22732
	callpa	#(@LR__0886-@LR__0885)>>2,fcache_load_ptr_
LR__0885
	add	fp, #16
	rdlong	local01, fp
	mov	arg05, local01
	shl	arg05, #9
	add	arg05, objptr
	sub	fp, #12
	rdlong	arg04, fp
	mov	arg03, arg04
	shl	arg03, #1
	add	arg03, arg05
	mov	arg05, local01
	shl	arg05, #9
	add	arg05, local01
	add	arg05, objptr
	add	arg04, arg05
	rdbyte	local01, arg04
	mul	local01, #256
	wrword	local01, arg03
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #4
	cmps	local01, #0 wc
 if_ae	jmp	#LR__0885
LR__0886
	sub	objptr, ##22732
'     close #9
	mov	arg01, #9
	call	#__system__close
'                                                                     '  for i=0 to 255: v.putpixel(i,288-envbuf(channel,i)/400,40) : next i
'     return
	jmp	#LR__0906
LR__0887
	add	fp, #40
	mov	arg01, fp
	sub	fp, #40
	call	#_converttoint
	mov	local01, result1
	add	fp, #12
	wrlong	local01, fp
	sub	fp, #12
'   
'   par=converttoint(t1)  : print par
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	call	#_pop
	mov	local01, result3
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #40
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
'   t1=pop()
'   channel=converttoint(t1)  
'   if par=0 then for i=0 to 1023: samplebuf(channel,i)=round(32600*sin(1.0/512*3.14159265359*i)) : next i
	sub	fp, #4
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__0906
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__0888
	add	fp, #16
	rdlong	local01, fp
	shl	local01, #11
	add	objptr, ##6348
	add	local01, objptr
	sub	fp, #12
	rdlong	arg01, fp
	mov	local02, arg01
	shl	local02, #1
	add	local02, local01
	sub	fp, #4
	sub	objptr, ##6348
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, ##1003032539
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, ##1191096320
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local02
	add	fp, #4
	rdlong	local02, fp
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #4
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__0888
'                                                                            '  for i=0 to 1023: v.putpixel(i,288-samplebuf(channel,i)/200,40) : next i
'   return
	jmp	#LR__0906
LR__0889
' for i=0 to 15 : harm(i)=0: next i  
	add	fp, #4
	wrlong	#0, fp
	callpa	#(@LR__0891-@LR__0890)>>2,fcache_load_ptr_
LR__0890
	rdlong	local01, fp
	shl	local01, #2
	add	fp, #52
	add	local01, fp
	wrlong	#0, local01
	sub	fp, #52
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	cmps	local01, #16 wc
 if_b	jmp	#LR__0890
LR__0891
	sub	fp, #4
' for i=numpar to 2 step -1 
	rdlong	local01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #4
LR__0892
	call	#_pop
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #44
	rdlong	local01, fp
	sub	local01, #2
	shl	local01, #2
	add	fp, #52
	add	local01, fp
	sub	fp, #16
	mov	arg01, fp
	sub	fp, #40
	call	#_converttofloat
	wrlong	result1, local01
	add	fp, #4
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #4
	cmps	local01, #2 wc
 if_ae	jmp	#LR__0892
	call	#_pop
	mov	local01, result3
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #40
	call	#_converttoint
	mov	local01, result1
	add	fp, #16
	wrlong	local01, fp
	sub	fp, #16
' t1=pop()
' channel=converttoint(t1) : print channel
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #16
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
' for j=0 to 1023: samplebuf(channel, i) =0 : next j
	add	fp, #8
	wrlong	##1024, fp
	sub	fp, #8
	add	objptr, ##6348
	callpa	#(@LR__0895-@LR__0893)>>2,fcache_load_ptr_
LR__0893
	rep	@LR__0896, ##1024
LR__0894
	add	fp, #16
	rdlong	local02, fp
	shl	local02, #11
	add	local02, objptr
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #4
	shl	local01, #1
	add	local01, local02
	wrword	#0, local01
LR__0895
LR__0896
	sub	objptr, ##6348
	add	fp, #28
	wrlong	#0, fp
' max=0
' if harm(0)<0 then
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #56
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__0899
	add	fp, #56
	rdlong	result1, fp
	bitl	result1, #31
	sub	fp, #36
	wrlong	result1, fp
	add	fp, #40
	rdlong	result1, fp
	bitl	result1, #31
	sub	fp, #36
	wrlong	result1, fp
	add	fp, #32
	wrlong	##1065353216, fp
	sub	fp, #36
	rdlong	local01, fp
	add	fp, #40
	wrlong	local01, fp
	sub	fp, #36
	rdlong	local01, fp
	add	fp, #40
	wrlong	local01, fp
'   harm(0)=1
'   harm(1)=even
'   harm(2)=odd
'   for i=3 to 15 step 2 : harm(i)=harm(i-2)*even : next i
	sub	fp, #60
	wrlong	#3, fp
LR__0897
	rdlong	arg05, fp
	mov	local04, arg05
	shl	local04, #2
	add	fp, #52
	add	local04, fp
	sub	arg05, #2
	shl	arg05, #2
	add	arg05, fp
	rdlong	arg01, arg05
	sub	fp, #36
	rdlong	arg02, fp
	sub	fp, #20
	call	#__system___float_mul
	wrlong	result1, local04
	add	fp, #4
	rdlong	local05, fp
	add	local05, #2
	wrlong	local05, fp
	cmps	local05, #16 wc
 if_b	jmp	#LR__0897
'   for i=4 to 14 step 2 : harm(i)=harm(i-2)*odd : next i
	wrlong	#4, fp
LR__0898
	rdlong	local05, fp
	mov	local04, local05
	shl	local04, #2
	add	fp, #52
	add	local04, fp
	sub	local05, #2
	shl	local05, #2
	add	local05, fp
	rdlong	arg01, local05
	sub	fp, #32
	rdlong	arg02, fp
	sub	fp, #24
	call	#__system___float_mul
	wrlong	result1, local04
	add	fp, #4
	rdlong	local05, fp
	add	local05, #2
	wrlong	local05, fp
	cmps	local05, #15 wc
 if_b	jmp	#LR__0898
	sub	fp, #4
LR__0899
' if harm(0)>=0 then ' synthesize with harmonics
	add	fp, #56
	rdlong	arg01, fp
	sub	fp, #56
	mov	arg02, #0
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0905
'   for i=0 to 1023
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__0900
	add	fp, #32
	wrlong	#0, fp
'     spl=0
'     for j=0 to 15 : spl+=harm(j)*sin((1.0/512)*3.14159265359*i*(j+1)) : next j 
	sub	fp, #24
	wrlong	#0, fp
LR__0901
	rdlong	local04, fp
	shl	local04, #2
	add	fp, #48
	add	local04, fp
	rdlong	local05, local04
	mov	local04, ##1003032539
	sub	fp, #52
	rdlong	arg01, fp
	sub	fp, #4
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	local04, result1
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_mul
	mov	arg02, result1
	add	fp, #32
	rdlong	arg01, fp
	sub	fp, #32
	call	#__system___float_add
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #24
	rdlong	arg03, fp
	add	arg03, #1
	wrlong	arg03, fp
	cmps	arg03, #16 wc
 if_b	jmp	#LR__0901
'     if abs(spl)>max then max=abs(spl)  ': print max 
	add	fp, #24
	rdlong	arg01, fp
	bitl	arg01, #31
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0902
	add	fp, #32
	rdlong	result1, fp
	bitl	result1, #31
	sub	fp, #4
	wrlong	result1, fp
	sub	fp, #28
LR__0902
	add	fp, #4
	rdlong	local05, fp
	add	local05, #1
	wrlong	local05, fp
	sub	fp, #4
	cmps	local05, ##1024 wc
 if_b	jmp	#LR__0900
'   for i=0 to 1023
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__0903
	add	fp, #32
	wrlong	#0, fp
'     spl=0
'     for j=0 to 15: spl+=harm(j)*(32600.0/max)*sin(1.0/512*3.14159265359*i*(j+1)) :next j ':' print spl
	sub	fp, #24
	wrlong	#0, fp
LR__0904
	rdlong	local05, fp
	shl	local05, #2
	add	fp, #48
	add	local05, fp
	rdlong	local05, local05
	sub	fp, #28
	rdlong	arg02, fp
	sub	fp, #28
	mov	arg01, ##1191096320
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_mul
	mov	local05, result1
	mov	local04, ##1003032539
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	local04, result1
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_mul
	mov	arg02, result1
	add	fp, #32
	rdlong	arg01, fp
	sub	fp, #32
	call	#__system___float_add
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #24
	rdlong	local05, fp
	add	local05, #1
	wrlong	local05, fp
	cmps	local05, #16 wc
 if_b	jmp	#LR__0904
	add	fp, #8
	rdlong	local05, fp
	shl	local05, #11
	add	objptr, ##6348
	add	local05, objptr
	sub	fp, #12
	rdlong	local02, fp
	shl	local02, #1
	add	local02, local05
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #32
	sub	objptr, ##6348
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local02
	add	fp, #4
	rdlong	local05, fp
	add	local05, #1
	wrlong	local05, fp
	sub	fp, #4
	cmps	local05, ##1024 wc
 if_b	jmp	#LR__0903
LR__0905
LR__0906
	mov	ptra, fp
	call	#popregs_
_do_defenv_ret
	ret

' 
' 
' sub do_play
_do_play
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #56
	add	fp, #20
	wrlong	#0, fp
	add	fp, #4
	wrlong	#440, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	##16384, fp
	add	fp, #4
	wrlong	##-1, fp
	sub	fp, #36
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	rdlong	local03, local02
	wrlong	local03, fp
' 
' params(0)=0 : params(1)=440 : params(2)=0 : params(3)=16384 : params(4)=-1
' 
' numpar=compiledline(lineptr_e).result.uresult
' for i=numpar to 1 step -1 
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #4
	sub	objptr, ##52544
LR__0910
	call	#_pop
	add	fp, #44
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #48
	rdlong	local02, fp
	sub	local02, #1
	shl	local02, #2
	add	fp, #16
	add	local02, fp
	add	fp, #24
	mov	arg01, fp
	sub	fp, #44
	call	#_converttofloat
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, local02
	add	fp, #4
	rdlong	local03, fp
	sub	local03, #1
	wrlong	local03, fp
	sub	fp, #4
	cmps	local03, #1 wc
 if_ae	jmp	#LR__0910
	add	objptr, ##44244
	rdlong	local03, objptr
	sub	objptr, ##44244
	add	fp, #20
	rdlong	local01, fp
	shl	local01, #6
	add	local03, local01
	sub	fp, #12
	wrlong	local03, fp
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #24
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg01, result1
	mov	arg02, ##1083040364
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #8
	rdlong	arg01, fp
	add	arg01, #8
	add	fp, #12
	rdlong	arg02, fp
	shl	arg02, #11
	add	objptr, ##6348
	add	arg02, objptr
	sub	objptr, ##6348
	add	arg02, ##-1073741824
	wrlong	arg02, arg01
	sub	fp, #12
	rdlong	arg01, fp
	add	arg01, #16
	wrlong	##2048, arg01
	rdlong	arg01, fp
	add	arg01, #12
	wrlong	#0, arg01
	rdlong	arg01, fp
	add	arg01, #20
	add	fp, #24
	rdlong	arg02, fp
	wrword	arg02, arg01
	sub	fp, #24
	rdlong	arg01, fp
	add	arg01, #22
	wrword	##8192, arg01
	rdlong	arg01, fp
	add	arg01, #24
	wrword	#60, arg01
	rdlong	arg01, fp
	add	arg01, #26
	add	fp, #8
	rdlong	arg02, fp
	wrword	arg02, arg01
	sub	fp, #8
	rdlong	arg01, fp
	add	arg01, #28
	wrword	#0, arg01
	rdlong	arg01, fp
	add	arg01, #32
	wrlong	#0, arg01
' base2=base+64*params(0)
' skip=round(params(1)*4.4338896)
'  
' lpoke base2+8,varptr(samplebuf(params(0),0))+$C000_0000 
' lpoke base2+16,2048
' lpoke base2+12,0
' dpoke base2+20,params(3)
' dpoke base2+22,8192
' dpoke base2+24,60  'spl=59122.8 57.773711 Hz at skip 256, 0.225535610 per skip
' dpoke base2+26,skip ' todo: use skip to make accurate sample rate
' dpoke base2+28,$4000_0000
' lpoke base2+32,0 
' if params(4)=-1 then lpoke base2+36,0 else lpoke base2+36,varptr(envbuf(params(4),0))
	add	fp, #28
	rdlong	local03, fp
	sub	fp, #36
	cmp	local03, ##-1 wz
 if_ne	jmp	#LR__0911
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #36
	wrlong	#0, arg01
	jmp	#LR__0912
LR__0911
	add	fp, #8
	rdlong	arg01, fp
	add	arg01, #36
	add	fp, #28
	rdlong	arg02, fp
	sub	fp, #36
	shl	arg02, #9
	add	objptr, ##22732
	add	arg02, objptr
	sub	objptr, ##22732
	wrlong	arg02, arg01
LR__0912
	add	fp, #8
	rdlong	arg01, fp
	add	arg01, #40
	wrlong	##512, arg01
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #44
	wrlong	#255, arg01
	mov	ptra, fp
	call	#popregs_
_do_play_ret
	ret

' 
' 
' 
' sub do_defsnd
_do_defsnd
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #132
	add	objptr, ##54084
	rdlong	arg05, objptr
	mov	arg04, arg05
	shl	arg04, #1
	add	arg04, arg05
	shl	arg04, #2
	sub	objptr, ##1540
	add	arg04, objptr
	rdlong	arg05, arg04
	wrlong	arg05, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' 
' 
' ' defsnd channel, string - tries to load from /media/s an s2 file from PC-Softsynth
' ' defsnd channel, h1,h2.... h15 - defines harmonics
' ' defsnd channel, negfloat, negfloat - defines even and odd harmonics dampening
' ' defsnd channel, oneint - defines waveshape as in SID and 0=sinewave
' 
' if numpar<2 then return
	cmps	arg05, #2 wc
	sub	objptr, ##52544
 if_b	jmp	#LR__0944
' 
'  
' if numpar=2 then
	rdlong	arg05, fp
	cmp	arg05, #2 wz
 if_ne	jmp	#LR__0927
	call	#_pop
	mov	arg05, result3
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
'   t1=pop()
'   if t1.result_type=result_string2 then 
	sub	fp, #48
	cmp	arg05, #43 wz
 if_ne	jmp	#LR__0920
	add	fp, #40
	rdlong	arg01, fp
	sub	fp, #40
	call	#_convertstring
	add	fp, #52
	wrlong	result1, fp
	sub	fp, #52
	jmp	#LR__0923
LR__0920
	add	fp, #48
	rdlong	arg05, fp
	sub	fp, #48
	cmp	arg05, #31 wz
 if_ne	jmp	#LR__0921
	add	fp, #40
	rdlong	arg05, fp
	add	fp, #12
	wrlong	arg05, fp
	sub	fp, #52
	jmp	#LR__0922
LR__0921
	mov	arg05, ##@LR__4609
	add	fp, #52
	wrlong	arg05, fp
	sub	fp, #52
LR__0922
LR__0923
' 
'     
'   if s<>"" then 
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #52
	mov	arg02, ##@LR__4610
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0925
	call	#_pop
	mov	arg05, result3
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #40
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
'     t1=pop()
'     channel=converttoint(t1) 
'     close #9 : open "/sd/media/s/"+s for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	mov	arg01, ##@LR__4611
	add	fp, #52
	rdlong	arg02, fp
	sub	fp, #52
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	sub	ptr___system__dat__, #32
	add	objptr, ##62916
	wrlong	result1, objptr
'     r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return   
	sub	objptr, ##62916
 if_e	jmp	#LR__0924
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4612
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##62916
	rdlong	arg02, objptr
	sub	objptr, ##62916
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__4613
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local01, #0
	add	objptr, ##62916
	rdlong	arg01, objptr
	sub	objptr, ##62916
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__0944
LR__0924
'     get #9,17,samplebuf(channel,0),1024
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #16
	shl	arg03, #11
	add	objptr, ##6348
	add	arg03, objptr
	mov	arg01, #9
	mov	arg02, #17
	decod	arg04, #10
	mov	arg05, #2
	sub	objptr, ##6348
	call	#__system___basic_get
'     close #9
	mov	arg01, #9
	call	#__system__close
'                                                                        'for i=0 to 1023: v.putpixel(i,288-samplebuf(channel,i)/200,40) : next i
'     return
	jmp	#LR__0944
LR__0925
	add	fp, #40
	mov	arg01, fp
	sub	fp, #40
	call	#_converttoint
	mov	local01, result1
	add	fp, #12
	wrlong	local01, fp
	sub	fp, #12
'   
'   par=converttoint(t1)  : print par
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	call	#_pop
	mov	local01, result3
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #40
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
'   t1=pop()
'   channel=converttoint(t1)  
'   if par=0 then for i=0 to 1023: samplebuf(channel,i)=round(32600*sin(1.0/512*3.14159265359*i)) : next i
	sub	fp, #4
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__0944
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__0926
	add	fp, #16
	rdlong	local01, fp
	shl	local01, #11
	add	objptr, ##6348
	add	local01, objptr
	sub	fp, #12
	rdlong	arg01, fp
	mov	local02, arg01
	shl	local02, #1
	add	local02, local01
	sub	fp, #4
	sub	objptr, ##6348
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, ##1003032539
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, ##1191096320
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local02
	add	fp, #4
	rdlong	local02, fp
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #4
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__0926
'                                                                            '  for i=0 to 1023: v.putpixel(i,288-samplebuf(channel,i)/200,40) : next i
'   return
	jmp	#LR__0944
LR__0927
' for i=0 to 15 : harm(i)=0: next i  
	add	fp, #4
	wrlong	#0, fp
	callpa	#(@LR__0929-@LR__0928)>>2,fcache_load_ptr_
LR__0928
	rdlong	local01, fp
	shl	local01, #2
	add	fp, #52
	add	local01, fp
	wrlong	#0, local01
	sub	fp, #52
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	cmps	local01, #16 wc
 if_b	jmp	#LR__0928
LR__0929
	sub	fp, #4
' for i=numpar to 2 step -1 
	rdlong	local01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #4
LR__0930
	call	#_pop
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #44
	rdlong	local01, fp
	sub	local01, #2
	shl	local01, #2
	add	fp, #52
	add	local01, fp
	sub	fp, #16
	mov	arg01, fp
	sub	fp, #40
	call	#_converttofloat
	wrlong	result1, local01
	add	fp, #4
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #4
	cmps	local01, #2 wc
 if_ae	jmp	#LR__0930
	call	#_pop
	mov	local01, result3
	add	fp, #40
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #40
	call	#_converttoint
	mov	local01, result1
	add	fp, #16
	wrlong	local01, fp
	sub	fp, #16
' t1=pop()
' channel=converttoint(t1) : print channel
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #16
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
' for j=0 to 1023: samplebuf(channel, i) =0 : next j
	add	fp, #8
	wrlong	##1024, fp
	sub	fp, #8
	add	objptr, ##6348
	callpa	#(@LR__0933-@LR__0931)>>2,fcache_load_ptr_
LR__0931
	rep	@LR__0934, ##1024
LR__0932
	add	fp, #16
	rdlong	local02, fp
	shl	local02, #11
	add	local02, objptr
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #4
	shl	local01, #1
	add	local01, local02
	wrword	#0, local01
LR__0933
LR__0934
	sub	objptr, ##6348
	add	fp, #28
	wrlong	#0, fp
' max=0
' if harm(0)<0 then
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #56
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__0937
	add	fp, #56
	rdlong	result1, fp
	bitl	result1, #31
	sub	fp, #36
	wrlong	result1, fp
	add	fp, #40
	rdlong	result1, fp
	bitl	result1, #31
	sub	fp, #36
	wrlong	result1, fp
	add	fp, #32
	wrlong	##1065353216, fp
	sub	fp, #36
	rdlong	local01, fp
	add	fp, #40
	wrlong	local01, fp
	sub	fp, #36
	rdlong	local01, fp
	add	fp, #40
	wrlong	local01, fp
'   harm(0)=1
'   harm(1)=even
'   harm(2)=odd
'   for i=3 to 15 step 2 : harm(i)=harm(i-2)*even : next i
	sub	fp, #60
	wrlong	#3, fp
LR__0935
	rdlong	arg05, fp
	mov	local04, arg05
	shl	local04, #2
	add	fp, #52
	add	local04, fp
	sub	arg05, #2
	shl	arg05, #2
	add	arg05, fp
	rdlong	arg01, arg05
	sub	fp, #36
	rdlong	arg02, fp
	sub	fp, #20
	call	#__system___float_mul
	wrlong	result1, local04
	add	fp, #4
	rdlong	local05, fp
	add	local05, #2
	wrlong	local05, fp
	cmps	local05, #16 wc
 if_b	jmp	#LR__0935
'   for i=4 to 14 step 2 : harm(i)=harm(i-2)*odd : next i
	wrlong	#4, fp
LR__0936
	rdlong	local05, fp
	mov	local04, local05
	shl	local04, #2
	add	fp, #52
	add	local04, fp
	sub	local05, #2
	shl	local05, #2
	add	local05, fp
	rdlong	arg01, local05
	sub	fp, #32
	rdlong	arg02, fp
	sub	fp, #24
	call	#__system___float_mul
	wrlong	result1, local04
	add	fp, #4
	rdlong	local05, fp
	add	local05, #2
	wrlong	local05, fp
	cmps	local05, #15 wc
 if_b	jmp	#LR__0936
	sub	fp, #4
LR__0937
' if harm(0)>=0 then ' synthesize with harmonics
	add	fp, #56
	rdlong	arg01, fp
	sub	fp, #56
	mov	arg02, #0
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0943
'   for i=0 to 1023
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__0938
	add	fp, #32
	wrlong	#0, fp
'     spl=0
'     for j=0 to 15 : spl+=harm(j)*sin((1.0/512)*3.14159265359*i*(j+1)) : next j 
	sub	fp, #24
	wrlong	#0, fp
LR__0939
	rdlong	local04, fp
	shl	local04, #2
	add	fp, #48
	add	local04, fp
	rdlong	local05, local04
	mov	local04, ##1003032539
	sub	fp, #52
	rdlong	arg01, fp
	sub	fp, #4
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	local04, result1
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_mul
	mov	arg02, result1
	add	fp, #32
	rdlong	arg01, fp
	sub	fp, #32
	call	#__system___float_add
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #24
	rdlong	arg03, fp
	add	arg03, #1
	wrlong	arg03, fp
	cmps	arg03, #16 wc
 if_b	jmp	#LR__0939
'     if abs(spl)>max then max=abs(spl)  ': print max 
	add	fp, #24
	rdlong	arg01, fp
	bitl	arg01, #31
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0940
	add	fp, #32
	rdlong	result1, fp
	bitl	result1, #31
	sub	fp, #4
	wrlong	result1, fp
	sub	fp, #28
LR__0940
	add	fp, #4
	rdlong	local05, fp
	add	local05, #1
	wrlong	local05, fp
	sub	fp, #4
	cmps	local05, ##1024 wc
 if_b	jmp	#LR__0938
'   for i=0 to 1023
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__0941
	add	fp, #32
	wrlong	#0, fp
'     spl=0
'     for j=0 to 15: spl+=harm(j)*(32600.0/max)*sin(1.0/512*3.14159265359*i*(j+1)) :next j ':' print spl
	sub	fp, #24
	wrlong	#0, fp
LR__0942
	rdlong	local05, fp
	shl	local05, #2
	add	fp, #48
	add	local05, fp
	rdlong	local05, local05
	sub	fp, #28
	rdlong	arg02, fp
	sub	fp, #28
	mov	arg01, ##1191096320
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_mul
	mov	local05, result1
	mov	local04, ##1003032539
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	local04, result1
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_mul
	mov	arg02, result1
	add	fp, #32
	rdlong	arg01, fp
	sub	fp, #32
	call	#__system___float_add
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #24
	rdlong	local05, fp
	add	local05, #1
	wrlong	local05, fp
	cmps	local05, #16 wc
 if_b	jmp	#LR__0942
	add	fp, #8
	rdlong	local05, fp
	shl	local05, #11
	add	objptr, ##6348
	add	local05, objptr
	sub	fp, #12
	rdlong	local02, fp
	shl	local02, #1
	add	local02, local05
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #32
	sub	objptr, ##6348
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local02
	add	fp, #4
	rdlong	local05, fp
	add	local05, #1
	wrlong	local05, fp
	sub	fp, #4
	cmps	local05, ##1024 wc
 if_b	jmp	#LR__0941
LR__0943
LR__0944
	mov	ptra, fp
	call	#popregs_
_do_defsnd_ret
	ret

' 
' ' ---------------  List the program. 
' 
' sub do_list
_do_list
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #184
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	##2147483647, fp
	sub	fp, #8
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	wrlong	arg03, fp
' 
' startline=0 : endline=$7FFFFFFF
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=1 then t1=pop() : startline=converttoint(t1)
	cmp	arg03, #1 wz
	sub	objptr, ##52544
 if_ne	jmp	#LR__0950
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #4
	wrlong	result1, fp
	sub	fp, #4
LR__0950
' if numpar=2 then t1=pop() : endline=converttoint(t1) : t1=pop() : startline=converttoint(t1)
	rdlong	arg03, fp
	cmp	arg03, #2 wz
 if_ne	jmp	#LR__0951
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	add	fp, #8
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #4
	wrlong	result1, fp
	sub	fp, #4
LR__0951
' 
' 
' print
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	add	objptr, ##54088
	rdlong	local02, objptr
	add	objptr, ##8820
	wrlong	local02, objptr
	sub	objptr, ##62908
' do 
LR__0952
	add	fp, #32
	mov	arg01, fp
	sub	fp, #32
	add	objptr, ##62908
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##57084
	call	#_psram_spin2_read1
	sub	objptr, ##5824
'   psram.read1(varptr(header),listptr,24) ': print header(0),header(1),header(2),header(3),header(4),header(5), programstart : waitms 7000 : waitms 7000 : waitms 7000
'   
'   if header(0)<> $FFFFFFFF then
	add	fp, #32
	rdlong	local02, fp
	sub	fp, #32
	cmp	local02, ##-1 wz
 if_e	jmp	#LR__0954
	add	fp, #56
	mov	arg03, #63
	setq	arg03
	wrlong	#0, fp
	mov	arg01, fp
	sub	fp, #16
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #44
	add	objptr, ##5824
	call	#_psram_spin2_read1
	sub	objptr, ##5824
'     longfill(linebuf,0,64)
'     psram.read1(varptr(linebuf),header(2),header(3))
'     if header(0)>=startline andalso header(0)<=endline then v.writeln(varptr(linebuf))  
	add	fp, #32
	rdlong	local02, fp
	sub	fp, #28
	rdlong	local01, fp
	sub	fp, #4
	cmps	local02, local01 wc
 if_b	jmp	#LR__0953
	add	fp, #32
	rdlong	local02, fp
	sub	fp, #24
	rdlong	arg03, fp
	sub	fp, #8
	cmps	local02, arg03 wcz
 if_a	jmp	#LR__0953
	add	fp, #56
	mov	arg01, fp
	sub	fp, #56
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
LR__0953
	add	fp, #52
	rdlong	local02, fp
	sub	fp, #52
	add	objptr, ##62908
	wrlong	local02, objptr
	sub	objptr, ##62908
LR__0954
	add	fp, #52
	rdlong	local02, fp
	sub	fp, #52
	cmp	local02, ##2147483647 wz
 if_ne	add	fp, #32
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #32
 if_ne	cmp	local01, ##-1 wz
 if_ne	jmp	#LR__0952
	mov	ptra, fp
	call	#popregs_
_do_list_ret
	ret

' 
' '---------------- Clear the program
' 
' sub do_new
_do_new
	mov	COUNT_, #3
	call	#pushregs_
	mov	arg01, #0
	neg	arg02, #1
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	add	objptr, ##37388
	wrlong	#0, objptr
	add	objptr, ##10876
	wrlong	#0, objptr
	add	objptr, ##7980
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	#0, objptr
	sub	objptr, ##11612
	wrlong	#0, objptr
	add	objptr, ##3620
	wrlong	#0, objptr
	sub	objptr, ##3616
	wrlong	#0, objptr
	add	objptr, ##7732
	wrlong	#0, objptr
	sub	objptr, ##4104
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	add	objptr, ##8012
	wrlong	#0, objptr
' 
' pslpoke(0,$FFFFFFFF)
' varnum=0
' programstart=0 :runptr=0 : runptr2=0
' stackpointer=0
' lineptr=0 
' programptr=0 : stringptr=0
' lastline=0 : lastlineptr=-1 :fortop=0
' for i=0 to maxfor: fortable(i).varnum=-1 : next i
	mov	local01, #0
	sub	objptr, ##3904
	callpa	#(@LR__0961-@LR__0960)>>2,fcache_load_ptr_
LR__0960
	mov	local02, local01
	shl	local02, #2
	add	local02, local01
	shl	local02, #2
	add	local02, objptr
	add	local02, #8
	wrlong	##-1, local02
	add	local01, #1
	cmps	local01, #129 wc
 if_b	jmp	#LR__0960
LR__0961
	sub	objptr, ##58204
' for i=0 to 15: if sprite(i)<> nil then v.setspritesize(i,0,0) : delete(sprite(i))
	mov	local01, #0
LR__0962
	mov	local02, local01
	shl	local02, #2
	add	objptr, ##62712
	add	local02, objptr
	rdlong	local02, local02 wz
	sub	objptr, ##62712
 if_e	jmp	#LR__0963
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritesize
	mov	local02, local01
	shl	local02, #2
	add	objptr, ##62712
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##62712
	call	#__system___gc_free
LR__0963
	add	objptr, ##62796
	wrlong	##1065353216, objptr
	add	objptr, #4
	wrlong	##1065353216, objptr
	sub	objptr, ##62800
	rdlong	local03, objptr
	add	objptr, ##62780
	wrlong	local03, objptr
	sub	objptr, ##62780
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_hg010b_spin2_setspritesize
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_hg010b_spin2_setspritesize
	add	local01, #1
	cmps	local01, #16 wc
 if_b	jmp	#LR__0962
	mov	ptra, fp
	call	#popregs_
_do_new_ret
	ret

' 
' '----------------------- goto
' sub do_fast_goto
_do_fast_goto
	mov	COUNT_, #2
	call	#pushregs_
_do_fast_goto_enter
	add	objptr, ##54084
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #1
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	rdlong	local02, local01
	mov	arg01, local02
	sub	objptr, ##52544
	call	#_pslpeek
	mov	arg01, result1
' 
' testptr=compiledline(lineptr_e).result.uresult
' flag=pslpeek(testptr)' :print " In goto:",flag , testptr : waitms(1000)
' if flag=compiledline(lineptr_e).result.twowords(1) then
	add	objptr, ##54084
	rdlong	result1, objptr
	mov	local01, result1
	shl	local01, #1
	add	local01, result1
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	arg01, local01 wz
	sub	objptr, ##52544
 if_ne	jmp	#LR__0970
	add	objptr, ##62068
	wrlong	local02, objptr
	sub	objptr, ##7988
	rdlong	local02, objptr
	sub	local02, #1
	add	objptr, #4
	wrlong	local02, objptr
'   runptr=testptr
'   lineptr_e=lineptr-1
'   if runheader(5)=$7FFF_FFFF  then runheader(5)=0
	add	objptr, ##8020
	rdlong	local02, objptr
	sub	objptr, ##62104
	cmp	local02, ##2147483647 wz
 if_e	add	objptr, ##62104
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##62104
	jmp	#LR__0971
LR__0970
	call	#_do_find_goto
LR__0971
	mov	ptra, fp
	call	#popregs_
_do_fast_goto_ret
	ret

' 
' 
' 
' 
' sub do_find_goto
_do_find_goto
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #36
_do_find_goto_enter
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	wrlong	local02, fp
	add	objptr, ##1544
	rdlong	local03, objptr
	sub	objptr, ##54088
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #4
' 
' gotoline=compiledline(lineptr_e).result.twowords(1)
'  ' print "find goto"                                                                     'print gotoline 
' gotoptr=programstart
' do
LR__0980
	add	fp, #12
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #24
	add	objptr, ##5824
	call	#_psram_spin2_read1
	sub	objptr, ##5824
'   psram.read1(varptr(gotoheader),gotoptr,24)  : 
'   if gotoheader(0)<>$FFFFFFFF then
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local03, ##-1 wz
 if_e	jmp	#LR__0981
	add	fp, #4
	rdlong	local03, fp
	add	fp, #4
	wrlong	local03, fp
	add	fp, #24
	rdlong	local03, fp
	sub	fp, #28
	wrlong	local03, fp
	sub	fp, #4
LR__0981
	add	fp, #32
	rdlong	local03, fp
	sub	fp, #32
	cmp	local03, ##2147483647 wz
 if_ne	add	fp, #12
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #12
 if_ne	cmp	local01, ##-1 wz
 if_e	jmp	#LR__0982
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local02, fp
	cmp	local03, local02 wz
 if_ne	jmp	#LR__0980
LR__0982
' 
' if gotoheader(0)=gotoline then
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local01, fp
	cmp	local03, local01 wz
 if_ne	jmp	#LR__0983
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	fp, #8
	rdlong	local03, fp
	wrlong	local03, local02
	add	objptr, ##1540
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	local02, #8
	wrlong	#78, local02
	add	objptr, ##1540
	rdlong	local02, objptr
	mov	arg01, local02
	shl	arg01, #1
	add	arg01, local02
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	add	objptr, ##9532
	rdlong	arg02, objptr
	mov	local03, #2
	add	local03, local02
	sub	objptr, ##10580
	rdlong	arg03, objptr
	qmul	local03, arg03
	sub	fp, #8
	sub	objptr, ##45672
	getqx	local03
	add	arg02, local03
	call	#_psram_spin2_write
	sub	objptr, ##5824
	call	#_do_fast_goto
	jmp	#LR__0984
LR__0983
	mov	arg01, #38
	call	#_printerror
LR__0984
	mov	ptra, fp
	call	#popregs_
_do_find_goto_ret
	ret

' 
' sub do_slow_goto
_do_slow_goto
_do_slow_goto_ret
	ret

' 
' '----------------------- Error processing
' 
' sub do_error
_do_error
	mov	COUNT_, #1
	call	#pushregs_
	add	objptr, ##54084
	rdlong	arg04, objptr
	mov	arg03, arg04
	shl	arg03, #1
	add	arg03, arg04
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local01, arg03
' r=compiledline(lineptr_e).result.uresult
' print "Error ";r;": ";errors$(r)
	mov	arg01, #0
	sub	objptr, ##52544
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4614
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg02, ##@LR__4615
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	shl	local01, #2
	add	objptr, ##51520
	add	local01, objptr
	rdlong	arg02, local01
	mov	arg01, #0
	mov	arg03, #0
	sub	objptr, ##51520
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	ptra, fp
	call	#popregs_
_do_error_ret
	ret

' 
' 
' '------------------ Assigning to a variable  
' 
' function  convertstring(psaddr as ulong) as string
_convertstring
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	call	#_pslpeek
	mov	local02, result1
	mov	local03, ##@LR__4616
' 'print "in convertstring: psaddr=";psaddr
' l=pslpeek(psaddr)
' 'print "in convertstring: len=";l
' s="" 
' for i=1 to l : s+=chr$(pspeek(psaddr+3+i)) :next i
	mov	local04, #1
	add	local02, #1
LR__0990
	cmps	local04, local02 wc
 if_ae	jmp	#LR__0991
	mov	arg01, local01
	add	arg01, #3
	add	arg01, local04
	call	#_pspeek
	getbyte	arg01, result1, #0
	call	#__system__Chr_S
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___string_concat
	mov	local03, result1
	add	local04, #1
	jmp	#LR__0990
LR__0991
' 'print "in convertstring: str=";s
' return s
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_convertstring_ret
	ret

' 
' sub do_assign
_do_assign
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #68
	add	objptr, ##54084
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg02, arg02
	add	fp, #24
	wrlong	arg02, fp
' 
' varnum=compiledline(lineptr_e).result.uresult ' numpar is in twowords(1), pop numpar 
' 
' if variables(varnum).vartype<array_no_type then 
	sub	fp, #24
	shl	arg02, #4
	sub	objptr, ##25716
	add	arg02, objptr
	add	arg02, #12
	rdlong	arg03, arg02
	cmp	arg03, #256 wc
	sub	objptr, ##26828
 if_ae	jmp	#LR__1000
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #20
	rdlong	arg01, fp
	shl	arg01, #4
	add	objptr, ##26828
	add	arg01, objptr
	add	arg01, #4
	wrlong	arg03, arg01
	rdlong	arg03, fp
	shl	arg03, #4
	add	arg03, objptr
	add	arg03, #8
	wrlong	arg02, arg03
	rdlong	arg03, fp
	shl	arg03, #4
	add	arg03, objptr
	sub	fp, #16
	rdlong	arg02, fp
	add	arg03, #12
	wrlong	arg02, arg03
'   t1=pop() 
' 'print "In do_assign value to assign=";t1.result.uresult, "type to assign=";t1.result_type  
'    variables(varnum).value=t1.result : variables(varnum).vartype=t1.result_type 
'   if variables(varnum).vartype<>result_string2 then return
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #24
	shl	arg03, #4
	add	arg03, objptr
	add	arg03, #12
	rdlong	arg03, arg03
	cmp	arg03, #43 wz
	sub	objptr, ##26828
 if_ne	jmp	#LR__1023
	add	fp, #24
	rdlong	arg03, fp
	mov	local01, arg03
	shl	local01, #4
	add	objptr, ##26828
	add	local01, objptr
	sub	fp, #24
	shl	arg03, #4
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg01, arg03
	sub	objptr, ##26828
	call	#_convertstring
	add	local01, #4
	wrlong	result1, local01
	add	fp, #24
	rdlong	local01, fp
	sub	fp, #24
	shl	local01, #4
	add	objptr, ##26828
	add	local01, objptr
	add	local01, #12
	wrlong	#31, local01
'   variables(varnum).value.sresult=convertstring(variables(varnum).value.uresult)
'   variables(varnum).vartype=result_string
'   return
	sub	objptr, ##26828
	jmp	#LR__1023
LR__1000
' for i=0 to 2 : arrid(i)=0 : next i
	add	fp, #28
	wrlong	#0, fp
	callpa	#(@LR__1002-@LR__1001)>>2,fcache_load_ptr_
LR__1001
	rdlong	local01, fp
	shl	local01, #2
	add	fp, #24
	add	local01, fp
	wrlong	#0, local01
	sub	fp, #24
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	cmp	local01, #3 wc
 if_b	jmp	#LR__1001
LR__1002
	add	objptr, ##54084
	rdlong	arg03, objptr
	mov	local01, arg03
	shl	local01, #1
	add	local01, arg03
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	add	local01, #4
	rdlong	local02, local01
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #32
	sub	objptr, ##52544
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' numpar=compiledline(lineptr_e).result.twowords(1) 
' t1=pop() ' var value
' if numpar>0 then
	add	fp, #24
	rdlong	local03, fp
	sub	fp, #32
	cmp	local03, #1 wc
 if_b	jmp	#LR__1005
'   for i=numpar to 1 step -1
	add	fp, #32
	rdlong	local04, fp wz
	sub	fp, #4
	wrlong	local04, fp
	sub	fp, #28
 if_e	jmp	#LR__1004
LR__1003
	call	#_pop
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	add	fp, #8
	rdlong	local03, fp
	sub	local03, #1
	shl	local03, #2
	add	fp, #24
	add	local03, fp
	sub	fp, #40
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	wrlong	result1, local03
	add	fp, #28
	rdlong	local04, fp
	sub	local04, #1 wz
	wrlong	local04, fp
	sub	fp, #28
 if_ne	jmp	#LR__1003
LR__1004
LR__1005
	add	fp, #24
	rdlong	local01, fp
	shl	local01, #4
	add	objptr, ##26828
	add	local01, objptr
	add	local01, #4
	rdlong	arg01, local01
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #36
	sub	objptr, ##26828
	call	#_pslpeek
	getword	local04, result1, #0
	add	fp, #40
	wrlong	local04, fp
	sub	fp, #4
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #2
	call	#_pspeek
	getbyte	result1, result1, #0
	add	fp, #44
	wrlong	result1, fp
' esize=pspeek(arrptr+2)
' if arrid(0)>=pslpeek(arrptr+4) orelse arrid(1)>=pslpeek(arrptr+8) orelse arrid(2)>=pslpeek(arrptr+12) then printerror(49) : return
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #4
	call	#_pslpeek
	mov	local04, result1
	add	fp, #52
	rdlong	local01, fp
	sub	fp, #52
	cmp	local01, local04 wc
 if_ae	jmp	#LR__1006
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #8
	call	#_pslpeek
	mov	local01, result1
	add	fp, #56
	rdlong	local04, fp
	sub	fp, #56
	cmp	local04, local01 wc
 if_ae	jmp	#LR__1006
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #12
	call	#_pslpeek
	add	fp, #60
	rdlong	local04, fp
	sub	fp, #60
	cmp	local04, result1 wc
 if_b	jmp	#LR__1007
LR__1006
	mov	arg01, #49
	call	#_printerror
	jmp	#LR__1023
LR__1007
	add	fp, #36
	rdlong	arg01, fp
	mov	local04, arg01
	add	local04, #16
	sub	fp, #36
	add	arg01, #4
	call	#_pslpeek
	mov	local01, result1
	add	fp, #56
	rdlong	local02, fp
	qmul	local01, local02
	sub	fp, #4
	rdlong	local03, fp
	sub	fp, #16
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #8
	getqx	local02
	add	local03, local02
	call	#_pslpeek
	mov	local02, result1
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #4
	call	#_pslpeek
	qmul	local02, result1
	add	fp, #60
	rdlong	local02, fp
	getqx	local01
	qmul	local01, local02
	sub	fp, #16
	rdlong	local02, fp
	getqx	local01
	add	local03, local01
	qmul	local02, local03
	add	fp, #4
' 
' arridx=arrptr+16+esize*(arrid(0)+pslpeek(arrptr+4)*arrid(1)+pslpeek(arrptr+8)*pslpeek(arrptr+4)*arrid(2))
' select case arrtype
	getqx	local03
	add	local04, local03
	wrlong	local04, fp
	sub	fp, #8
	rdlong	local05, fp
	sub	fp, #40
	sub	local05, #256
	fle	local05, #12
	jmprel	local05
LR__1008
	jmp	#LR__1009
	jmp	#LR__1010
	jmp	#LR__1011
	jmp	#LR__1012
	jmp	#LR__1013
	jmp	#LR__1014
	jmp	#LR__1015
	jmp	#LR__1016
	jmp	#LR__1017
	jmp	#LR__1018
	jmp	#LR__1019
	jmp	#LR__1020
	jmp	#LR__1021
LR__1009
	mov	arg01, fp
	add	fp, #48
	rdlong	arg02, fp
	sub	fp, #48
	mov	arg03, #12
	add	objptr, ##5824
	call	#_psram_spin2_write
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1010
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 1)
	mov	arg05, #1
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1011
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 1)
	mov	arg05, #1
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1012
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 1)
	mov	arg05, #1
	call	#_psram_spin2_fill
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	add	arg01, #1
	rdlong	arg02, fp
	shr	arg02, #8
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 1)
	mov	arg05, #1
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1013
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 1)
	mov	arg05, #1
	call	#_psram_spin2_fill
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	add	arg01, #1
	rdlong	arg02, fp
	shr	arg02, #8
	mov	arg03, #1
	mov	arg04, #0
'     return fill(addr, pattern, count, listPtr, 1)
	mov	arg05, #1
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1014
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1015
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1016
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1017
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1018
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1019
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1020
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	arg03, #1
	mov	arg04, #0
	add	objptr, ##5824
'     return fill(addr, pattern, count, listPtr, 4)
	mov	arg05, #4
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	jmp	#LR__1022
LR__1021
	mov	arg01, #47
	call	#_printerror
LR__1022
LR__1023
	mov	ptra, fp
	call	#popregs_
_do_assign_ret
	ret

' 
' 
' ' --------------------- Read a variable and push to the stack
' 
' ' getvar : fun_getvar, var#, numpar. Var, if array, has array type and a pointer
' 
' sub do_getvar
_do_getvar
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #60
' 'print "in do_getvar, compiledline(lineptr_e) rt,ttw0,tw1="; compiledline(lineptr_e).result_type, compiledline(lineptr_e).result.twowords(0),compiledline(lineptr_e).result.twowords(1)
' if compiledline(lineptr_e).result.twowords(1)=0 then
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg03, arg03 wz
	sub	objptr, ##52544
 if_ne	jmp	#LR__1031
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg01, local01
	shl	arg01, #1
	add	arg01, local01
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	local01, arg01
	shl	local01, #4
	sub	objptr, ##25716
	add	local01, objptr
	add	local01, #4
	rdlong	arg01, local01
	add	local01, #4
	rdlong	local01, local01
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	objptr, ##27256
	rdlong	local01, objptr
	mov	arg01, local01
	shl	arg01, #1
	add	arg01, local01
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	local01, arg01
	shl	local01, #4
	sub	objptr, ##25716
	add	local01, objptr
	add	local01, #12
	rdlong	local01, local01
	add	fp, #4
	wrlong	local01, fp
'   t1.result=variables(compiledline(lineptr_e).result.uresult).value
'   t1.result_type=variables(compiledline(lineptr_e).result.uresult).vartype
'   if t1.result_type<array_no_type then push t1 : return else goto 2100
	sub	fp, #8
	cmp	local01, #256 wc
	sub	objptr, ##26828
 if_ae	jmp	#LR__1030
	mov	arg01, fp
	call	#_push
	jmp	#LR__1052
LR__1030
LR__1031
	add	objptr, ##54084
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
	shl	arg03, #4
	sub	objptr, ##25716
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg01, arg03
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #12
	sub	objptr, ##26828
	call	#_pslpeek
	getword	result1, result1, #0
	add	fp, #16
	wrlong	result1, fp
	add	objptr, ##54084
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	add	arg02, #4
	rdlong	arg03, arg02
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #2
	sub	objptr, ##52544
	call	#_pspeek
	getbyte	result1, result1, #0
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #4
	call	#_pslpeek
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #16
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #8
	call	#_pslpeek
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #20
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #12
	call	#_pslpeek
	add	fp, #36
	wrlong	result1, fp
' numpar=compiledline(lineptr_e).result.twowords(1) ':print "in do_getvar numpar=",numpar
' esize=pspeek(arrptr+2)
' dim1=pslpeek(arrptr+4) ' todo :do one read from psram for speed
' dim2=pslpeek(arrptr+8) ' todo :do one read from psram for speed
' dim3=pslpeek(arrptr+12) ' todo :do one read from psram for speed
' if numpar>2 then t1=pop() : i3=converttoint(t1)   else i3=0 
	sub	fp, #16
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, #3 wc
 if_b	jmp	#LR__1032
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #48
	wrlong	result1, fp
	sub	fp, #48
	jmp	#LR__1033
LR__1032
	add	fp, #48
	wrlong	#0, fp
	sub	fp, #48
LR__1033
' if numpar>1 then t1=pop() : i2=converttoint(t1)   else i2=0 
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, #2 wc
 if_b	jmp	#LR__1034
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #44
	wrlong	result1, fp
	sub	fp, #44
	jmp	#LR__1035
LR__1034
	add	fp, #44
	wrlong	#0, fp
	sub	fp, #44
LR__1035
' if numpar>0 then t1=pop() : i1=converttoint(t1)   else i1=0 
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, #1 wc
 if_b	jmp	#LR__1036
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #40
	jmp	#LR__1037
LR__1036
	add	fp, #40
	wrlong	#0, fp
	sub	fp, #40
LR__1037
	add	fp, #12
	rdlong	local02, fp
	add	fp, #28
	rdlong	local03, fp
	add	fp, #4
	rdlong	result2, fp
	sub	fp, #16
	rdlong	result3, fp
	qmul	result2, result3
	add	local02, #16
	add	fp, #20
	rdlong	result2, fp
	getqx	result1
	qmul	result2, result3
	add	local03, result1
	sub	fp, #16
	rdlong	result3, fp
	getqx	result2
	qmul	result2, result3
	sub	fp, #8
	rdlong	result3, fp
	getqx	result2
	add	local03, result2
	qmul	local03, result3
	add	fp, #28
' 'print "dim1=",dim1,"dim2=",dim2,"dim3=",dim3, "esize=",esize, "i1=", i1,"i2=", i2, "i3=", i3
' varidx=arrptr+16+(i1+i2*dim1+i3*dim1*dim2)*esize ': print "arrptr=",arrptr,"varidx=",varidx,"memtop=",memtop,"bufptr=",v.buf_ptr
' 
' select case vartype
	getqx	result2
	add	local02, result2
	wrlong	local02, fp
	sub	fp, #36
	rdlong	local04, fp
	sub	fp, #16
	sub	local04, #256
	fle	local04, #12
	jmprel	local04
LR__1038
	jmp	#LR__1039
	jmp	#LR__1040
	jmp	#LR__1041
	jmp	#LR__1042
	jmp	#LR__1043
	jmp	#LR__1044
	jmp	#LR__1045
	jmp	#LR__1046
	jmp	#LR__1047
	jmp	#LR__1048
	jmp	#LR__1049
	jmp	#LR__1050
	jmp	#LR__1051
LR__1039
	mov	arg01, fp
	add	fp, #52
	rdlong	arg02, fp
	sub	fp, #52
	mov	arg03, #12
	add	objptr, ##5824
	call	#_psram_spin2_read1
	sub	objptr, ##5824
	jmp	#LR__1051
LR__1040
	add	fp, #8
	wrlong	#28, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pspeek
	getbyte	result1, result1, #0
	wrlong	result1, fp
	cmp	result1, #128 wc
 if_ae	neg	local01, #256
 if_ae	rdlong	local03, fp
 if_ae	or	local01, local03
 if_ae	wrlong	local01, fp
	jmp	#LR__1051
LR__1041
	add	fp, #8
	wrlong	#29, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pspeek
	getbyte	result1, result1, #0
	wrlong	result1, fp
	jmp	#LR__1051
LR__1042
	add	fp, #8
	wrlong	#28, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	getword	result1, result1, #0
	wrlong	result1, fp
	cmp	result1, ##32768 wc
 if_ae	mov	local01, ##16776960
 if_ae	rdlong	local03, fp
 if_ae	or	local01, local03
 if_ae	wrlong	local01, fp
	jmp	#LR__1051
LR__1043
	add	fp, #8
	wrlong	#29, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	getword	result1, result1, #0
	wrlong	result1, fp
	jmp	#LR__1051
LR__1044
	add	fp, #8
	wrlong	#28, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	wrlong	result1, fp
	jmp	#LR__1051
LR__1045
	add	fp, #8
	wrlong	#29, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	wrlong	result1, fp
	jmp	#LR__1051
LR__1046
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
	wrlong	#48, fp
	jmp	#LR__1051
LR__1047
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
	wrlong	#48, fp
	jmp	#LR__1051
LR__1048
	add	fp, #8
	wrlong	#30, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	wrlong	result1, fp
	jmp	#LR__1051
LR__1049
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
	wrlong	#48, fp
	jmp	#LR__1051
LR__1050
	add	fp, #8
	wrlong	#31, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	wrlong	result1, fp
	cmp	result1, ##524288 wc
 if_ae	add	fp, #8
 if_ae	wrlong	#43, fp
 if_ae	sub	fp, #8
LR__1051
	mov	arg01, fp
	call	#_push
LR__1052
	mov	ptra, fp
	call	#popregs_
_do_getvar_ret
	ret

' 
' '------------------------ Operators 
' 
' sub do_plus 
_do_plus
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' 
' 
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult+=t2.result.uresult :goto 1040
	sub	fp, #8
	cmp	local03, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1060
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local01, local02
	wrlong	local01, fp
	jmp	#LR__1075
LR__1060
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult+t2.result.iresult: t1.result_type=result_int :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1061
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local01, local02
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__1075
LR__1061
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.uresult)+t2.result.fresult: t1.result_type=result_float :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1062
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__1075
LR__1062
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult+=t2.result.uresult: goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1063
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local01, local02
	wrlong	local01, fp
	jmp	#LR__1075
LR__1063
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult+=t2.result.iresult:goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1064
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local01, local02
	wrlong	local01, fp
	jmp	#LR__1075
LR__1064
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.iresult)+t2.result.fresult: t1.result_type=result_float :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1065
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__1075
LR__1065
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.fresult=t1.result.fresult+cast(single,t2.result.uresult) :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1066
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__1075
LR__1066
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.fresult=t1.result.fresult+cast(single,t2.result.iresult) :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1067
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__1075
LR__1067
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult+=t2.result.fresult:goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #30 wz
 if_ne	jmp	#LR__1068
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__1075
LR__1068
' if t1.result_type=result_string andalso t2.result_type<>result_string then t1.result.uresult=2 :t1.result_type=result_error:goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_ne	jmp	#LR__1069
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #31 wz
 if_ne	wrlong	#2, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__1075
LR__1069
' if t2.result_type=result_string andalso t1.result_type<>result_string then t1.result.uresult=2 :t1.result_type=result_error:goto 1040
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #31 wz
 if_ne	jmp	#LR__1070
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	wrlong	#2, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__1075
LR__1070
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.sresult=t1.result.sresult+t2.result.sresult :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1071
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_concat
	wrlong	result1, fp
	jmp	#LR__1075
LR__1071
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.sresult=convertstring(t1.result.uresult)+t2.result.sresult : t1.result_type=result_string:goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1072
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_concat
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	jmp	#LR__1075
LR__1072
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.sresult=t1.result.sresult+convertstring(t2.result.uresult) :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1073
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	wrlong	result1, fp
	jmp	#LR__1075
LR__1073
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult)+convertstring(t2.result.uresult) : t1.result_type=result_string :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1074
	rdlong	arg01, fp
	call	#_convertstring
	mov	local01, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	jmp	#LR__1075
LR__1074
	wrlong	#4, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__1075
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_plus_ret
	ret

' 
' sub do_minus
_do_minus
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_uint andalso t2.result_type=result_uint then 
	sub	fp, #8
	cmp	local03, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1081
'     if t2.result.uresult<t1.result.uresult then  t1.result.uresult-=t2.result.uresult : goto 1050 else t1.result.iresult=t1.result.uresult-t2.result.uresult : t1.result_type=result_int : goto 1050
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	local03, fp
	cmp	local01, local03 wc
 if_ae	jmp	#LR__1080
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	jmp	#LR__1090
LR__1080
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__1090
LR__1081
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult-t2.result.iresult: t1.result_type=result_int :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1082
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__1090
LR__1082
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.uresult)-t2.result.fresult: t1.result_type=result_float :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1083
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__1090
LR__1083
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult-=t2.result.uresult:goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1084
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	jmp	#LR__1090
LR__1084
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult-=t2.result.iresult:goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #28 wz
 if_ne	jmp	#LR__1085
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	jmp	#LR__1090
LR__1085
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.iresult)-t2.result.fresult: t1.result_type=result_float :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1086
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__1090
LR__1086
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.fresult=t1.result.fresult-cast(single,t2.result.uresult) :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1087
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__1090
LR__1087
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.fresult=t1.result.fresult-cast(single,t2.result.iresult) :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1088
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__1090
LR__1088
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult-=t2.result.fresult:goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1089
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__1090
LR__1089
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=3: t1.result_type=result_error: goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#3, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	wrlong	#5, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
LR__1090
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_minus_ret
	ret

' 
' sub do_and 
_do_and
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	add	fp, #12
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local03, #28 wz
 if_e	rdlong	local03, fp
 if_e	wrlong	local03, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1100
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #20
LR__1100
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1060
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local03, #30 wz
 if_ne	add	fp, #20
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1101
	rdlong	local03, fp
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	and	local03, local01
	wrlong	local03, fp
LR__1101
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_and_ret
	ret

' 
' sub do_or 
_do_or
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	add	fp, #12
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local03, #28 wz
 if_e	rdlong	local03, fp
 if_e	wrlong	local03, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1110
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #20
LR__1110
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1070
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local03, #30 wz
 if_ne	add	fp, #20
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1111
	rdlong	local03, fp
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	or	local03, local01
	wrlong	local03, fp
LR__1111
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_or_ret
	ret

' 
' sub do_mul
_do_mul
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult*=t2.result.uresult :goto 1080
	sub	fp, #8
	cmp	local03, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1120
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	qmul	local02, local03
	sub	fp, #12
	getqx	local01
	wrlong	local01, fp
	jmp	#LR__1129
LR__1120
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult*t2.result.iresult: t1.result_type=result_int :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1121
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	qmul	local02, local03
	sub	fp, #12
	getqx	local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__1129
LR__1121
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.uresult)*t2.result.fresult: t1.result_type=result_float :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1122
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__1129
LR__1122
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult*=t2.result.uresult:goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1123
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	qmul	local02, local03
	sub	fp, #12
	getqx	local01
	wrlong	local01, fp
	jmp	#LR__1129
LR__1123
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult*=t2.result.iresult:goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #28 wz
 if_ne	jmp	#LR__1124
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	qmul	local02, local03
	sub	fp, #12
	getqx	local01
	wrlong	local01, fp
	jmp	#LR__1129
LR__1124
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.iresult)*t2.result.fresult: t1.result_type=result_float :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1125
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__1129
LR__1125
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.fresult=t1.result.fresult*cast(single,t2.result.uresult) :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1126
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	wrlong	result1, fp
	jmp	#LR__1129
LR__1126
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.fresult=t1.result.fresult*cast(single,t2.result.iresult) :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1127
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	wrlong	result1, fp
	jmp	#LR__1129
LR__1127
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult*=t2.result.fresult:goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1128
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_mul
	wrlong	result1, fp
	jmp	#LR__1129
LR__1128
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=8: t1.result_type=result_error: goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#8, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	wrlong	#9, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
LR__1129
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mul_ret
	ret

' 
' sub do_div 
_do_div
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	muldivb_, result1
	mov	muldiva_, result2
	mov	local01, result3
	add	fp, #12
	wrlong	muldivb_, fp
	add	fp, #4
	wrlong	muldiva_, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=10: t1.result_type=result_error: goto 1090
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg01, #31 wz
 if_e	wrlong	#10, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1136
' if t1.result_type=result_float then t1.result_type=result_int : t1.result.iresult=cast(integer,t1.result.fresult)
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__1130
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
LR__1130
' if t2.result_type=result_float then t2.result_type=result_int : t2.result.iresult=cast(integer,t2.result.fresult)
	add	fp, #20
	rdlong	muldivb_, fp
	sub	fp, #20
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__1131
	add	fp, #20
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	mov	arg02, #0
	call	#__system___float_tointeger
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__1131
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult/=t2.result.uresult :goto 1090
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #29 wz
 if_ne	jmp	#LR__1132
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	muldivb_, fp
	qdiv	muldivb_, local01
	getqx	local01
	wrlong	local01, fp
	jmp	#LR__1136
LR__1132
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult/t2.result.iresult: t1.result_type=result_int :goto 1090
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #28 wz
 if_ne	jmp	#LR__1133
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	muldivb_, fp
	qdiv	muldivb_, local01
	getqx	local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__1136
LR__1133
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult/=t2.result.uresult :goto 1090
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #29 wz
 if_ne	jmp	#LR__1134
	rdlong	muldiva_, fp
	add	fp, #12
	rdlong	muldivb_, fp
	sub	fp, #12
	call	#divide_
	wrlong	muldivb_, fp
	jmp	#LR__1136
LR__1134
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult=t1.result.iresult/t2.result.iresult: goto 1090
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #28 wz
 if_ne	jmp	#LR__1135
	rdlong	muldiva_, fp
	add	fp, #12
	rdlong	muldivb_, fp
	sub	fp, #12
	call	#divide_
	wrlong	muldivb_, fp
	jmp	#LR__1136
LR__1135
	wrlong	#11, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__1136
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_div_ret
	ret

' 
' sub do_fdiv 
_do_fdiv
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=10: t1.result_type=result_error: goto 1100
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local01, #31 wz
 if_e	wrlong	#10, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1145
' if t1.result_type=result_int then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.iresult) 
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__1140
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	wrlong	result1, fp
LR__1140
' if t1.result_type=result_uint then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.uresult)
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__1141
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	call	#__system___float_fromuns
	wrlong	result1, fp
LR__1141
' if t2.result_type=result_int then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.iresult) 
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__1142
	add	fp, #20
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__1142
' if t2.result_type=result_uint then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.uresult) 
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__1143
	add	fp, #20
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__1143
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult/=t2.result.fresult: goto 1100
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #30 wz
 if_ne	jmp	#LR__1144
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_div
	wrlong	result1, fp
	jmp	#LR__1145
LR__1144
	wrlong	#11, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__1145
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_fdiv_ret
	ret

' 
' 
' sub do_mod 
_do_mod
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	muldivb_, result1
	mov	muldiva_, result2
	mov	local01, result3
	add	fp, #12
	wrlong	muldivb_, fp
	add	fp, #4
	wrlong	muldiva_, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=10: t1.result_type=result_error: goto 1110
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg01, #31 wz
 if_e	wrlong	#10, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1156
' if t1.result_type=result_float then t1.result_type=result_int : t1.result.iresult=cast(integer,t1.result.fresult)
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__1150
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
LR__1150
' if t2.result_type=result_float then t2.result_type=result_int : t2.result.iresult=cast(integer,t2.result.fresult)
	add	fp, #20
	rdlong	muldivb_, fp
	sub	fp, #20
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__1151
	add	fp, #20
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	mov	arg02, #0
	call	#__system___float_tointeger
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__1151
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=t1.result.uresult mod t2.result.uresult :goto 1110
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #29 wz
 if_ne	jmp	#LR__1152
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	muldivb_, fp
	qdiv	muldivb_, local01
	getqy	local01
	wrlong	local01, fp
	jmp	#LR__1156
LR__1152
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult mod t2.result.iresult: t1.result_type=result_int :goto 1110
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #28 wz
 if_ne	jmp	#LR__1153
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	muldivb_, fp
	qdiv	muldivb_, local01
	getqy	local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__1156
LR__1153
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult=t1.result.iresult mod t2.result.uresult :goto 1110
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #29 wz
 if_ne	jmp	#LR__1154
	rdlong	muldiva_, fp
	add	fp, #12
	rdlong	muldivb_, fp
	sub	fp, #12
	call	#divide_
	wrlong	muldiva_, fp
	jmp	#LR__1156
LR__1154
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult=t1.result.iresult mod t2.result.iresult: goto 1110
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #28 wz
 if_ne	jmp	#LR__1155
	rdlong	muldiva_, fp
	add	fp, #12
	rdlong	muldivb_, fp
	sub	fp, #12
	call	#divide_
	wrlong	muldiva_, fp
	jmp	#LR__1156
LR__1155
	wrlong	#11, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__1156
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mod_ret
	ret

' 
' sub do_shl 
_do_shl
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	add	fp, #12
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local03, #28 wz
 if_e	rdlong	local03, fp
 if_e	wrlong	local03, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1160
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #20
LR__1160
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1120
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local03, #30 wz
 if_ne	add	fp, #20
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1161
	rdlong	local03, fp
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	shl	local03, local01
	wrlong	local03, fp
LR__1161
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_shl_ret
	ret

' 
' sub do_shr 
_do_shr
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	add	fp, #12
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local03, #28 wz
 if_e	rdlong	local03, fp
 if_e	wrlong	local03, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1170
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #20
LR__1170
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1130
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local03, #30 wz
 if_ne	add	fp, #20
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1171
	rdlong	local03, fp
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	shr	local03, local01
	wrlong	local03, fp
LR__1171
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_shr_ret
	ret

' 
' sub do_power 
_do_power
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t2=pop()
' t1=pop()
' 
' 
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=12: t1.result_type=result_error: goto 1140
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local01, #31 wz
 if_e	wrlong	#12, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__1185
' if t1.result_type=result_int then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.iresult) 
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__1180
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	wrlong	result1, fp
LR__1180
' if t1.result_type=result_uint then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.uresult) 
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__1181
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	call	#__system___float_fromuns
	wrlong	result1, fp
LR__1181
' if t2.result_type=result_int then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.iresult) 
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__1182
	add	fp, #20
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__1182
' if t2.result_type=result_uint then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.uresult) 
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__1183
	add	fp, #20
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__1183
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult=t1.result.fresult^t2.result.fresult: goto 1140
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #30 wz
 if_ne	jmp	#LR__1184
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system____builtin_powf
	wrlong	result1, fp
	jmp	#LR__1185
LR__1184
	wrlong	#13, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__1185
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_power_ret
	ret

' 
' 
' sub do_eq
_do_eq
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult=t2.result.sresult) : goto 1150
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1190
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1203
LR__1190
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult=t2.result.fresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1191
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1203
LR__1191
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult=t2.result.iresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1192
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1203
LR__1192
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult=t2.result.uresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1193
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1203
LR__1193
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult=t2.result.fresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1194
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1203
LR__1194
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult=t2.result.iresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1195
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_e	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1203
LR__1195
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult=t2.result.uresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #29 wz
 if_ne	jmp	#LR__1196
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_e	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1203
LR__1196
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult=t2.result.fresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1197
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1203
LR__1197
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult=t2.result.iresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1198
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_e	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1203
LR__1198
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult=t2.result.uresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1199
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_e	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1203
LR__1199
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)=t2.result.sresult):goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1200
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1203
LR__1200
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult=convertstring(t2.result.uresult)) :goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1201
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1203
LR__1201
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)=convertstring(t2.result.uresult)) :goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1202
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1203
LR__1202
	wrlong	#0, fp
LR__1203
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_eq_ret
	ret

' 
' sub do_gt
_do_gt
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult>t2.result.sresult) : goto 1160
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1210
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1223
LR__1210
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult>t2.result.fresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1211
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1223
LR__1211
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult>t2.result.iresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1212
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1223
LR__1212
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult>t2.result.uresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1213
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1223
LR__1213
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult>t2.result.fresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1214
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1223
LR__1214
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult>t2.result.iresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1215
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_a	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1223
LR__1215
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult>t2.result.uresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #29 wz
 if_ne	jmp	#LR__1216
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_a	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1223
LR__1216
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult>t2.result.fresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1217
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1223
LR__1217
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult>t2.result.iresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1218
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_a	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1223
LR__1218
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult>t2.result.uresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1219
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wcz
 if_a	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1223
LR__1219
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)>t2.result.sresult):goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1220
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1223
LR__1220
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult>convertstring(t2.result.uresult)) :goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1221
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1223
LR__1221
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)>convertstring(t2.result.uresult)) :goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1222
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1223
LR__1222
	wrlong	#0, fp
LR__1223
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_gt_ret
	ret

' 
' sub do_lt
_do_lt
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult<t2.result.sresult) : goto 1170
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1230
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1243
LR__1230
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult<t2.result.fresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1231
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1243
LR__1231
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult<t2.result.iresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1232
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1243
LR__1232
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult<t2.result.uresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1233
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1243
LR__1233
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult<t2.result.fresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1234
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1243
LR__1234
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult<t2.result.iresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1235
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
	subx	local01, local01
	wrlong	local01, fp
	jmp	#LR__1243
LR__1235
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult<t2.result.uresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #29 wz
 if_ne	jmp	#LR__1236
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
	subx	local01, local01
	wrlong	local01, fp
	jmp	#LR__1243
LR__1236
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult<t2.result.fresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1237
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1243
LR__1237
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult<t2.result.iresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1238
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
	subx	local01, local01
	wrlong	local01, fp
	jmp	#LR__1243
LR__1238
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult<t2.result.uresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1239
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wc
	subx	local01, local01
	wrlong	local01, fp
	jmp	#LR__1243
LR__1239
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)<t2.result.sresult):goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1240
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1243
LR__1240
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult<convertstring(t2.result.uresult)) :goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1241
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1243
LR__1241
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)<convertstring(t2.result.uresult)) :goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1242
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1243
LR__1242
	wrlong	#0, fp
LR__1243
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_lt_ret
	ret

' 
' sub do_ge
_do_ge
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult>=t2.result.sresult) : goto 1180
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1250
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1263
LR__1250
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult>=t2.result.fresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1251
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1263
LR__1251
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult>=t2.result.iresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1252
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1263
LR__1252
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult>=t2.result.uresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1253
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1263
LR__1253
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult>=t2.result.fresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1254
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1263
LR__1254
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult>=t2.result.iresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1255
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
 if_ae	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1263
LR__1255
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult>=t2.result.uresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #29 wz
 if_ne	jmp	#LR__1256
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
 if_ae	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1263
LR__1256
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult>=t2.result.fresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1257
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1263
LR__1257
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult>=t2.result.iresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1258
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
 if_ae	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1263
LR__1258
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult>=t2.result.uresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1259
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wc
 if_ae	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1263
LR__1259
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)>=t2.result.sresult):goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1260
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1263
LR__1260
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult>=convertstring(t2.result.uresult)) :goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1261
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1263
LR__1261
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)>=convertstring(t2.result.uresult)) :goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1262
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1263
LR__1262
	wrlong	#0, fp
LR__1263
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_ge_ret
	ret

' 
' sub do_le
_do_le
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult<=t2.result.sresult) : goto 1190
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1270
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1283
LR__1270
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult<=t2.result.fresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1271
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1283
LR__1271
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult<=t2.result.iresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1272
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1283
LR__1272
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult<=t2.result.uresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1273
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1283
LR__1273
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult<=t2.result.fresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1274
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1283
LR__1274
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult<=t2.result.iresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1275
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_be	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1283
LR__1275
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult<=t2.result.uresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #29 wz
 if_ne	jmp	#LR__1276
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_be	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1283
LR__1276
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult<=t2.result.fresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1277
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1283
LR__1277
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult<=t2.result.iresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1278
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_be	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1283
LR__1278
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult<=t2.result.uresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1279
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wcz
 if_be	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1283
LR__1279
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)<=t2.result.sresult):goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1280
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1283
LR__1280
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult<=convertstring(t2.result.uresult)) :goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1281
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1283
LR__1281
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)<=convertstring(t2.result.uresult)) :goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1282
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1283
LR__1282
	wrlong	#0, fp
LR__1283
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_le_ret
	ret

' 
' 
' sub do_ne
_do_ne
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' t2=pop()
' t1=pop()
' 
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult<>t2.result.sresult) : goto 1192
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1290
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1303
LR__1290
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult<>t2.result.fresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1291
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1303
LR__1291
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult<>t2.result.iresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1292
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1303
LR__1292
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult<>t2.result.uresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1293
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1303
LR__1293
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult<>t2.result.fresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1294
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1303
LR__1294
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult<>t2.result.iresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1295
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_ne	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1303
LR__1295
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult<>t2.result.uresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #29 wz
 if_ne	jmp	#LR__1296
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_ne	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1303
LR__1296
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult<>t2.result.fresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__1297
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1303
LR__1297
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult<>t2.result.iresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__1298
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_ne	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1303
LR__1298
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult<>t2.result.uresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__1299
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_ne	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__1303
LR__1299
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)<>t2.result.sresult):goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__1300
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1303
LR__1300
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult<>convertstring(t2.result.uresult)) :goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1301
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1303
LR__1301
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)<>convertstring(t2.result.uresult)) :goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__1302
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__1303
LR__1302
	wrlong	#0, fp
LR__1303
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_ne_ret
	ret

' 
' 
' 
' ' -------------------   convert a variable on the top of stack to integer
' 
' sub do_converttoint
_do_converttoint
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result2
	mov	local02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
' t1=pop() 
' select case t1.result_type
	sub	fp, #8
	cmp	local02, #28 wz
 if_e	jmp	#LR__1310
	cmp	local02, #29 wz
 if_e	jmp	#LR__1311
	cmp	local02, #30 wz
 if_e	jmp	#LR__1312
	cmp	local02, #31 wz
 if_e	jmp	#LR__1313
	cmp	local02, #43 wz
 if_e	jmp	#LR__1314
	cmp	local02, #255 wz
 if_e	jmp	#LR__1315
	jmp	#LR__1316
LR__1310
	rdlong	local02, fp
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	#28, fp
	sub	fp, #16
	jmp	#LR__1317
LR__1311
	rdlong	local02, fp
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	#28, fp
	sub	fp, #16
	jmp	#LR__1317
LR__1312
	rdlong	arg01, fp
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	#28, fp
	sub	fp, #16
	jmp	#LR__1317
LR__1313
	rdlong	arg01, fp
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	#28, fp
	sub	fp, #16
	jmp	#LR__1317
LR__1314
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	#28, fp
	sub	fp, #16
	jmp	#LR__1317
LR__1315
	add	fp, #12
	wrlong	#0, fp
	sub	fp, #12
	rdlong	local02, fp
	add	fp, #16
	wrlong	local02, fp
	sub	fp, #16
	jmp	#LR__1317
LR__1316
	add	fp, #12
	wrlong	#0, fp
	add	fp, #4
	wrlong	#1, fp
	sub	fp, #16
LR__1317
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	wrlong	local02, fp
	add	fp, #16
	rdlong	local02, fp
	sub	fp, #8
	wrlong	local02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_converttoint_ret
	ret

' 
' function converttoint (t1 as expr_result) as integer
_converttoint
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' 
' select case t1.result_type
	add	local01, #8
	rdlong	local02, local01
	sub	local01, #8
	cmp	local02, #28 wz
 if_e	jmp	#LR__1320
	cmp	local02, #29 wz
 if_e	jmp	#LR__1321
	cmp	local02, #30 wz
 if_e	jmp	#LR__1322
	cmp	local02, #31 wz
 if_e	jmp	#LR__1323
	cmp	local02, #43 wz
 if_e	jmp	#LR__1324
	jmp	#LR__1325
LR__1320
	rdlong	result1, local01
	jmp	#LR__1326
LR__1321
	rdlong	result1, local01
	jmp	#LR__1326
LR__1322
	rdlong	arg01, local01
	mov	arg02, #1
	call	#__system___float_tointeger
	jmp	#LR__1326
LR__1323
	rdlong	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	jmp	#LR__1326
LR__1324
	rdlong	arg01, local01
	call	#_convertstring
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	jmp	#LR__1326
LR__1325
	mov	result1, #0
LR__1326
	mov	ptra, fp
	call	#popregs_
_converttoint_ret
	ret

' 
' function converttofloat (t1 as expr_result) as single
_converttofloat
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' select case t1.result_type
	add	local01, #8
	rdlong	local02, local01
	sub	local01, #8
	cmp	local02, #28 wz
 if_e	jmp	#LR__1330
	cmp	local02, #29 wz
 if_e	jmp	#LR__1331
	cmp	local02, #30 wz
 if_e	jmp	#LR__1332
	cmp	local02, #31 wz
 if_e	jmp	#LR__1333
	cmp	local02, #43 wz
 if_e	jmp	#LR__1334
	jmp	#LR__1335
LR__1330
	rdlong	arg01, local01
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	jmp	#LR__1336
LR__1331
	rdlong	arg01, local01
	call	#__system___float_fromuns
	jmp	#LR__1336
LR__1332
	rdlong	result1, local01
	jmp	#LR__1336
LR__1333
	rdlong	arg01, local01
	call	#__system____builtin_atof
	jmp	#LR__1336
LR__1334
	rdlong	arg01, local01
	call	#_convertstring
	mov	arg01, result1
	call	#__system____builtin_atof
	jmp	#LR__1336
LR__1335
	mov	result1, #0
LR__1336
	mov	ptra, fp
	call	#popregs_
_converttofloat_ret
	ret

' 
' sub do_rnd
_do_rnd
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "rnd: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	jmp	#LR__1340
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4617
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1347
LR__1340
' if numpar=0 then
	add	fp, #12
	rdlong	result3, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__1341
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	getrnd	result1
	wrlong	result1, fp
	mov	arg01, fp
	call	#_push
	jmp	#LR__1346
LR__1341
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
'   t1=pop()
'   if t1.result_type=result_int orelse t1.result_type=result_uint then
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1342
	getrnd	result1
	rdlong	local01, fp
	qdiv	result1, local01
	mov	arg01, fp
	getqy	local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	call	#_push
	jmp	#LR__1345
LR__1342
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_ne	jmp	#LR__1343
	rdlong	arg01, fp
	mov	arg02, ##1233125376
	call	#__system___float_div
	mov	local01, result1
	getrnd	arg01
	bitl	arg01, #372
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	jmp	#LR__1344
LR__1343
'     print "rnd: "; : printerror(40) 
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4618
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #40
	call	#_printerror
	mov	arg01, fp
	call	#_push
LR__1344
LR__1345
LR__1346
LR__1347
	mov	ptra, fp
	call	#popregs_
_do_rnd_ret
	ret

' 
' sub do_sin
_do_sin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "sin: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1350
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4619
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1351
LR__1350
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##62796
	rdlong	local01, objptr
	sub	objptr, ##62796
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1351
	mov	ptra, fp
	call	#popregs_
_do_sin_ret
	ret

' 
' sub do_cos
_do_cos
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "cos: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1360
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4620
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1361
LR__1360
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##62796
	rdlong	local01, objptr
	sub	objptr, ##62796
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, ##1070141403
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system____builtin_sinf
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1361
	mov	ptra, fp
	call	#popregs_
_do_cos_ret
	ret

' 
' sub do_tan
_do_tan
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "tan: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1370
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4621
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1371
LR__1370
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##62796
	rdlong	local01, objptr
	sub	objptr, ##62796
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_tanf
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1371
	mov	ptra, fp
	call	#popregs_
_do_tan_ret
	ret

' 
' sub do_asin
_do_asin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "asin: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1380
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4622
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1381
LR__1380
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	call	#__system____builtin_asinf
	mov	arg01, result1
	add	objptr, ##62800
	rdlong	arg02, objptr
	sub	objptr, ##62800
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1381
	mov	ptra, fp
	call	#popregs_
_do_asin_ret
	ret

' 
' sub do_acos
_do_acos
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "acos: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1390
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4623
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1391
LR__1390
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	call	#__system____builtin_acosf
	mov	arg01, result1
	add	objptr, ##62800
	rdlong	arg02, objptr
	sub	objptr, ##62800
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1391
	mov	ptra, fp
	call	#popregs_
_do_acos_ret
	ret

' 
' sub do_atn
_do_atn
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "atn: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1400
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4624
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1401
LR__1400
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	mov	arg02, ##1065353216
	call	#__system____builtin_atan2f
	mov	arg01, result1
	add	objptr, ##62800
	rdlong	arg02, objptr
	sub	objptr, ##62800
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1401
	mov	ptra, fp
	call	#popregs_
_do_atn_ret
	ret

' 
' sub do_sqr
_do_sqr
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "sqr: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1410
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4625
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1411
LR__1410
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	call	#__system___float_sqrt
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1411
	mov	ptra, fp
	call	#popregs_
_do_sqr_ret
	ret

' 
' sub do_stick
_do_stick
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "stick: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	jmp	#LR__1420
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4626
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1424
LR__1420
' 
' if numpar=0 then t1.result.uresult=stick(0) : t1.result_type=result_uint : push t1 : return
	add	fp, #12
	rdlong	result3, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__1421
	add	objptr, ##62656
	rdlong	local01, objptr
	sub	objptr, ##62656
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	jmp	#LR__1424
LR__1421
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1423
	rdlong	local01, fp
	add	objptr, ##62872
	wrlong	local01, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##62872
	cmps	local01, #7 wc
 if_ae	jmp	#LR__1422
	add	objptr, ##62872
	rdlong	local01, objptr
	shl	local01, #2
	sub	objptr, #216
	add	local01, objptr
	rdlong	local01, local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	sub	objptr, ##62656
	call	#_push
'     t1.result.uresult=stick(q) : t1.result_type=result_uint : push t1 : return 
	jmp	#LR__1424
LR__1422
	mov	arg01, #41
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1424
LR__1423
	mov	arg01, #41
	call	#_printerror
LR__1424
	mov	ptra, fp
	call	#popregs_
_do_stick_ret
	ret

' 
' sub do_strig
_do_strig
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##54084
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "strig: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##52544
 if_b	jmp	#LR__1430
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4627
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1434
LR__1430
' 
' if numpar=0 then t1.result.uresult=strig(0) : t1.result_type=result_uint : push t1 : return
	add	fp, #12
	rdlong	result3, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__1431
	add	objptr, ##62684
	rdlong	local01, objptr
	sub	objptr, ##62684
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	jmp	#LR__1434
LR__1431
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1433
	rdlong	local01, fp
	add	objptr, ##62872
	wrlong	local01, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##62872
	cmps	local01, #7 wc
 if_ae	jmp	#LR__1432
	add	objptr, ##62872
	rdlong	local01, objptr
	shl	local01, #2
	sub	objptr, #188
	add	local01, objptr
	rdlong	local01, local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	sub	objptr, ##62684
	call	#_push
'     t1.result.uresult=strig(q) : t1.result_type=result_uint : push t1 : return 
	jmp	#LR__1434
LR__1432
	mov	arg01, #41
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1434
LR__1433
	mov	arg01, #41
	call	#_printerror
LR__1434
	mov	ptra, fp
	call	#popregs_
_do_strig_ret
	ret

' 
' sub do_getpixel
_do_getpixel
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #36
	add	objptr, ##54084
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
	add	fp, #24
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>2 then print "getpixel: "; : printerror(39) : return
	sub	fp, #24
	cmp	arg03, #2 wz
	sub	objptr, ##52544
 if_e	jmp	#LR__1440
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4628
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1441
LR__1440
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #16
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	arg03, result1
	add	fp, #32
	wrlong	arg03, fp
	rdlong	arg01, objptr
	sub	fp, #4
	rdlong	result3, fp
	add	arg01, result3
	sub	fp, #28
	shl	arg03, #10
	add	arg01, arg03
	call	#_pspeek
	getbyte	result1, result1, #0
	wrlong	result1, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1441
	mov	ptra, fp
	call	#popregs_
_do_getpixel_ret
	ret

' 
' 
' 
' sub do_defsprite
_do_defsprite
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #92
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #48
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #56
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #36
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #44
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #60
	wrlong	result1, fp
	sub	fp, #48
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #64
	wrlong	result1, fp
	sub	fp, #40
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	add	fp, #68
	wrlong	result1, fp
	sub	fp, #32
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	add	fp, #72
	wrlong	result1, fp
	sub	fp, #24
	mov	arg01, fp
	sub	fp, #48
	call	#_converttoint
	add	fp, #76
	wrlong	result1, fp
' 
' t5=pop()
' t4=pop()
' t3=pop()
' t2=pop()
' t1=pop()
' 
' ' do convert, defsprite is not a racing command
' a1=converttoint(t1) : a2=converttoint(t2) : a3=converttoint(t3) : a4=converttoint(t4) : a5=converttoint(t5)
'  
' ' todo: check parameters for linits
' if sprite(a1)<> nil then delete(sprite(a1))
	sub	fp, #16
	rdlong	arg03, fp
	sub	fp, #60
	shl	arg03, #2
	add	objptr, ##62712
	add	arg03, objptr
	rdlong	arg03, arg03 wz
	sub	objptr, ##62712
 if_e	jmp	#LR__1450
	add	fp, #60
	rdlong	arg03, fp
	sub	fp, #60
	shl	arg03, #2
	add	objptr, ##62712
	add	arg03, objptr
	rdlong	arg01, arg03
	sub	objptr, ##62712
	call	#__system___gc_free
LR__1450
	add	fp, #60
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg02, fp
	qmul	arg03, arg02
	shl	local01, #2
	add	objptr, ##62712
	add	local01, objptr
	sub	fp, #76
	sub	objptr, ##62712
	getqx	arg01
	call	#__system___gc_alloc_managed
	wrlong	result1, local01
' for y=a3 to a3+a5-1
	add	fp, #68
	rdlong	local02, fp
	add	fp, #12
	wrlong	local02, fp
	sub	fp, #12
	rdlong	local03, fp
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #76
	add	local03, local04
LR__1451
	add	fp, #80
	rdlong	local02, fp
	sub	fp, #80
	cmps	local02, local03 wc
 if_ae	jmp	#LR__1454
'   for x=a2 to a4+a2-1
	add	fp, #64
	rdlong	local01, fp
	add	objptr, ##62828
	wrlong	local01, objptr
	sub	objptr, ##62828
	add	fp, #8
	rdlong	local05, fp
	sub	fp, #8
	rdlong	local06, fp
	sub	fp, #64
	add	local05, local06
LR__1452
	add	objptr, ##62828
	rdlong	local01, objptr
	sub	objptr, ##62828
	cmps	local01, local05 wc
 if_ae	jmp	#LR__1453
	add	fp, #60
	rdlong	local06, fp
	add	fp, #4
	rdlong	local04, fp
	add	fp, #16
	rdlong	local02, fp
	mov	local01, local02
	sub	fp, #12
	rdlong	arg03, fp
	sub	local01, arg03
	add	fp, #4
	rdlong	arg03, fp
	qmul	local01, arg03
	shl	local06, #2
	add	objptr, ##62712
	add	local06, objptr
	rdlong	local06, local06
	add	objptr, #116
	rdlong	local01, objptr
	sub	objptr, ##62828
	mov	local07, local01
	sub	local07, local04
	rdlong	arg01, objptr
	add	arg01, local01
	sub	fp, #72
	shl	local02, #10
	add	arg01, local02
	getqx	local04
	add	local07, local04
	add	local07, local06
	call	#_pspeek
	wrbyte	result1, local07
	add	objptr, ##62828
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##62828
	jmp	#LR__1452
LR__1453
	add	fp, #80
	rdlong	local07, fp
	add	local07, #1
	wrlong	local07, fp
	sub	fp, #80
	jmp	#LR__1451
LR__1454
	add	fp, #60
	rdlong	local07, fp
	mov	arg01, local07
	sub	fp, #60
	shl	local07, #2
	add	objptr, ##62712
	add	local07, objptr
	rdlong	arg02, local07
	sub	objptr, ##62712
	call	#_hg010b_spin2_setspriteptr
	add	fp, #60
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #76
	call	#_hg010b_spin2_setspritesize
	mov	ptra, fp
	call	#popregs_
_do_defsprite_ret
	ret

' 
' sub do_sprite
_do_sprite
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #36
	wrlong	result1, fp
	sub	fp, #24
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #16
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	add	fp, #44
	wrlong	result1, fp
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	mov	arg03, result1
	sub	fp, #40
	call	#_hg010b_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_do_sprite_ret
	ret

' 
' sub do_mousex
_do_mousex
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	add	objptr, ##62640
	rdlong	arg01, objptr
	sub	objptr, ##62640
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousex_ret
	ret

' 
' sub do_mousey
_do_mousey
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	add	objptr, ##62644
	rdlong	arg01, objptr
	sub	objptr, ##62644
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousey_ret
	ret

' 
' sub do_mousew
_do_mousew
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	add	objptr, ##62652
	rdlong	arg01, objptr
	sub	objptr, ##62652
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousew_ret
	ret

' 
' sub do_mousek
_do_mousek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	add	objptr, ##62648
	rdlong	arg01, objptr
	sub	objptr, ##62648
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousek_ret
	ret

' 
' 
' sub do_rdpin
_do_rdpin
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	rdpin	result1, result1
	add	objptr, ##62916
	wrlong	result1, objptr
	sub	objptr, ##62916
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	#4, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_rdpin_ret
	ret

' 
' sub do_rqpin
_do_rqpin
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
	mov	result1, #0
	rqpin	result1, arg01
	add	objptr, ##62916
	wrlong	result1, objptr
	sub	objptr, ##62916
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	#4, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_rqpin_ret
	ret

' 
' sub do_pinread
_do_pinread
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
	test	arg01, #32 wz
 if_ne	mov	result1, inb
 if_e	mov	result1, ina
	shr	result1, arg01
	shr	arg01, #6
	zerox	result1, arg01
	add	objptr, ##62916
	wrlong	result1, objptr
	sub	objptr, ##62916
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	#4, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_pinread_ret
	ret

' 
' sub do_gettime
_do_gettime
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #20
' 
' const asm 
	getct	local01 wc
	getct	local02
' 
' return hi1, lo1
	mov	result2, local02
	wrlong	local01, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #12
	wrlong	#29, fp
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #4
	mov	arg01, fp
	sub	fp, #8
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_gettime_ret
	ret

'    
' 
' '' ----------------------------- Graphics related runtime procedures --------------------------------------
' 
' '' ----------------------------- Clear the screen
' 
' sub do_cls
_do_cls
	add	objptr, ##44288
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##44284
	call	#_hg010b_spin2_cls
	add	objptr, ##44288
	rdlong	arg02, objptr
	sub	objptr, #20
	wrlong	arg02, objptr
	sub	objptr, ##44268
' cls(ink,paper): plot_color=ink: print
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
_do_cls_ret
	ret

' 
' '' ----------------------------- Set a color # from the palette to plot/draw
' 
' sub do_color
_do_color
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	objptr, ##44268
	wrlong	local01, objptr
	sub	objptr, ##44268
	mov	ptra, fp
	call	#popregs_
_do_color_ret
	ret

' 
' ' ----------------------------- Plot a point, set starting point to draw a line
' 
' sub do_plot
_do_plot
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	objptr, ##44272
	wrlong	arg03, objptr
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	objptr, ##44268
	call	#_hg010b_spin2_putpixel
	mov	ptra, fp
	call	#popregs_
_do_plot_ret
	ret

' 
' ' --------------------------- Draw a line to point set by plot or previous draw, set a new starting point
' 
' sub do_draw
_do_draw
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #12
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #20
	call	#_pop
	mov	arg05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
	add	objptr, ##44272
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	fp, #4
	rdlong	arg03, fp
	mov	arg04, result1
	sub	fp, #24
	sub	objptr, #8
	rdlong	arg05, objptr
	sub	objptr, ##44268
	call	#_hg010b_spin2_draw
	add	fp, #24
	rdlong	arg05, fp
	add	objptr, ##44272
	wrlong	arg05, objptr
	add	fp, #4
	rdlong	arg05, fp
	sub	fp, #28
	add	objptr, #4
	wrlong	arg05, objptr
	sub	objptr, ##44276
	mov	ptra, fp
	call	#popregs_
_do_draw_ret
	ret

' 
' ' -------------------------- Draw a filled circle at x,y and radius r
' 
' sub do_fcircle
_do_fcircle
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #36
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	arg02, result3
	add	fp, #24
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #32
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t3=pop()
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) andalso (t2.result_type=result_int orelse t2.result_type=result_uint) andalso (t3.result_type=result_int orelse t3.result_type=result_uint) then
	mov	arg04, result3
	sub	fp, #8
	cmp	arg04, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1460
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #28 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1460
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, #28 wz
 if_ne	add	fp, #32
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #32
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1460
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #12
	rdlong	arg03, fp
	sub	fp, #24
	add	objptr, ##44268
	rdlong	arg04, objptr
	sub	objptr, ##44268
	call	#_hg010b_spin2_fcircle
'    v.fcircle(t1.result.iresult,t2.result.iresult,t3.result.iresult,plot_color) : return
	jmp	#LR__1461
LR__1460
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	arg03, result1
	add	objptr, ##44268
	rdlong	arg04, objptr
	sub	objptr, ##44268
	mov	arg01, local01
	mov	arg02, local02
	call	#_hg010b_spin2_fcircle
LR__1461
	mov	ptra, fp
	call	#popregs_
_do_fcircle_ret
	ret

' 
' ' -------------------------- Draw an empty circle at x,y and radius r
' 
' sub do_circle
_do_circle
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #36
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	arg02, result3
	add	fp, #24
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #32
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t3=pop()
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) andalso (t2.result_type=result_int orelse t2.result_type=result_uint) andalso (t3.result_type=result_int orelse t3.result_type=result_uint) then
	mov	arg04, result3
	sub	fp, #8
	cmp	arg04, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1470
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #28 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1470
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, #28 wz
 if_ne	add	fp, #32
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #32
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1470
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #12
	rdlong	arg03, fp
	sub	fp, #24
	add	objptr, ##44268
	rdlong	arg04, objptr
	sub	objptr, ##44268
	call	#_hg010b_spin2_circle
'    v.circle(t1.result.iresult,t2.result.iresult,t3.result.iresult,plot_color) : return
	jmp	#LR__1471
LR__1470
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	arg03, result1
	add	objptr, ##44268
	rdlong	arg04, objptr
	sub	objptr, ##44268
	mov	arg01, local01
	mov	arg02, local02
	call	#_hg010b_spin2_circle
LR__1471
	mov	ptra, fp
	call	#popregs_
_do_circle_ret
	ret

' 
' ' -------------------------- Draw a rectangle
' 
' sub do_box
_do_box
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #36
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #44
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #24
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #32
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t4=pop()
' t3=pop()
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) andalso (t2.result_type=result_int orelse t2.result_type=result_uint) andalso (t3.result_type=result_int orelse t3.result_type=result_uint) andalso (t4.result_type=result_int orelse t4.result_type=result_uint) then
	mov	arg05, result3
	sub	fp, #8
	cmp	arg05, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1480
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #28 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1480
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, #28 wz
 if_ne	add	fp, #32
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #32
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1480
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #44
	cmp	local01, #28 wz
 if_ne	add	fp, #44
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #44
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1480
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #12
	rdlong	arg03, fp
	add	fp, #12
	rdlong	arg04, fp
	sub	fp, #36
	add	objptr, ##44268
	rdlong	arg05, objptr
	sub	objptr, ##44268
	call	#_hg010b_spin2_box
'    v.box(t1.result.iresult,t2.result.iresult,t3.result.iresult,t4.result.iresult,plot_color) : return
	jmp	#LR__1481
LR__1480
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local03, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	local01, result1
	add	fp, #36
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	arg04, result1
	add	objptr, ##44268
	rdlong	arg05, objptr
	sub	objptr, ##44268
	mov	arg01, local02
	mov	arg02, local03
	mov	arg03, local01
	call	#_hg010b_spin2_box
LR__1481
	mov	ptra, fp
	call	#popregs_
_do_box_ret
	ret

' 
' sub do_fill
_do_fill
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	arg02, result3
	add	fp, #36
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #44
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	arg02, result3
	add	fp, #24
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #32
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t4=pop()
' t3=pop()
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) andalso (t2.result_type=result_int orelse t2.result_type=result_uint) andalso (t3.result_type=result_int orelse t3.result_type=result_uint) andalso (t4.result_type=result_int orelse t4.result_type=result_uint) then
	mov	arg04, result3
	sub	fp, #8
	cmp	arg04, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1490
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #28 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1490
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, #28 wz
 if_ne	add	fp, #32
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #32
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1490
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #44
	cmp	local01, #28 wz
 if_ne	add	fp, #44
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #44
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1490
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #12
	rdlong	arg03, fp
	add	fp, #12
	rdlong	arg04, fp
	sub	fp, #36
	call	#_hg010b_spin2_fill
'    v.fill(t1.result.iresult,t2.result.iresult,t3.result.iresult,t4.result.iresult) : return
	jmp	#LR__1491
LR__1490
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local03, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	local01, result1
	add	fp, #36
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	arg04, result1
	mov	arg01, local02
	mov	arg02, local03
	mov	arg03, local01
	call	#_hg010b_spin2_fill
LR__1491
	mov	ptra, fp
	call	#popregs_
_do_fill_ret
	ret

' 
' ' -------------------------- Draw a frane
' 
' sub do_frame
_do_frame
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #36
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #44
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #24
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #32
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t4=pop()
' t3=pop()
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) andalso (t2.result_type=result_int orelse t2.result_type=result_uint) andalso (t3.result_type=result_int orelse t3.result_type=result_uint) andalso (t4.result_type=result_int orelse t4.result_type=result_uint) then
	mov	arg05, result3
	sub	fp, #8
	cmp	arg05, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1500
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #28 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1500
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, #28 wz
 if_ne	add	fp, #32
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #32
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1500
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #44
	cmp	local01, #28 wz
 if_ne	add	fp, #44
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #44
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1500
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #12
	rdlong	arg03, fp
	add	fp, #12
	rdlong	arg04, fp
	sub	fp, #36
	add	objptr, ##44268
	rdlong	arg05, objptr
	sub	objptr, ##44268
	call	#_hg010b_spin2_frame
'    v.frame(t1.result.iresult,t2.result.iresult,t3.result.iresult,t4.result.iresult,plot_color) : return
	jmp	#LR__1501
LR__1500
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local03, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	local01, result1
	add	fp, #36
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	arg04, result1
	add	objptr, ##44268
	rdlong	arg05, objptr
	sub	objptr, ##44268
	mov	arg01, local02
	mov	arg02, local03
	mov	arg03, local01
	call	#_hg010b_spin2_frame
LR__1501
	mov	ptra, fp
	call	#popregs_
_do_frame_ret
	ret

' 
' '' ----------------------------- Text related runtime procedures --------------------------------------
' 
' ' ------------------------- Print to the screem
' 
' sub do_print  
_do_print
	mov	COUNT_, #10
	call	#pushregs_
	mov	local04, #0
	call	#_pop
	mov	local05, result1
	mov	local06, result2
	mov	local07, result3
	mov	local01, local05
	mov	local02, local06
	mov	local03, local07
'  
' r=0
' t1=pop() 
' 'print t1.result_type,t1.result.uresult
' 
' if t1.result_type=print_mod_comma orelse t1.result_type=print_mod_semicolon then r=t1.result_type :  t1=pop()
	cmp	local03, #33 wz
 if_ne	cmp	local03, #34 wz
 if_ne	jmp	#LR__1510
	mov	local04, local03
	call	#_pop
	mov	local05, result1
	mov	local06, result2
	mov	local07, result3
	mov	local01, local05
	mov	local02, local06
	mov	local03, local07
LR__1510
' if t1.result_type=print_mod_empty then r=t1.result_type 
	cmp	local03, #32 wz
 if_e	mov	local04, local03
' if t1.result_type=result_error then printerror(t1.result.uresult): goto 811
	cmp	local03, #255 wz
 if_ne	jmp	#LR__1511
	mov	arg01, local01
	call	#_printerror
	jmp	#LR__1529
LR__1511
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult)  :  t1.result_type=result_string  
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1512
	mov	arg01, local01
	call	#_convertstring
	mov	local05, result1
	mov	local01, local05
	mov	local03, #31
LR__1512
' 
' if r=print_mod_comma  then
	cmp	local04, #33 wz
 if_ne	jmp	#LR__1517
'   if t1.result_type=result_int then print t1.result.iresult,
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1513
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local08, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__1513
'   if t1.result_type=result_uint then print t1.result.uresult,
	cmp	local03, #29 wz
 if_ne	jmp	#LR__1514
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local08, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__1514
'   if t1.result_type=result_float then print t1.result.fresult,
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1515
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local08, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__1515
'   if t1.result_type=result_string then print t1.result.sresult,
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1516
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local08, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__1516
LR__1517
' if r=print_mod_semicolon then 
	cmp	local04, #34 wz
 if_ne	jmp	#LR__1522
'   if t1.result_type=result_int then print t1.result.iresult;
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1518
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	local10, #0
	mov	local08, #10
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	result1, #0
	mov	local09, #0
LR__1518
'   if t1.result_type=result_uint then print t1.result.uresult;
	cmp	local03, #29 wz
 if_ne	jmp	#LR__1519
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	local10, #0
	mov	local08, #10
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	result1, #0
	mov	local09, #0
LR__1519
'   if t1.result_type=result_float then print t1.result.fresult;
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1520
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__1520
'   if t1.result_type=result_string then print t1.result.sresult;
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1521
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__1521
LR__1522
' if r=0 then 
	cmp	local04, #0 wz
 if_ne	jmp	#LR__1527
'   if t1.result_type=result_int then print t1.result.iresult
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1523
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__1523
'   if t1.result_type=result_uint then print t1.result.uresult
	cmp	local03, #29 wz
 if_ne	jmp	#LR__1524
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__1524
'   if t1.result_type=result_float then print t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1525
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__1525
'   if t1.result_type=result_string then print t1.result.sresult
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1526
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__1526
LR__1527
' if r=print_mod_empty then print
	cmp	local04, #32 wz
 if_ne	jmp	#LR__1528
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
LR__1528
LR__1529
	mov	ptra, fp
	call	#popregs_
_do_print_ret
	ret

' 
' 
' sub do_paper
_do_paper
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1530
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1530
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1531
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1531
	add	objptr, ##44284
	wrlong	local01, objptr
	add	objptr, #4
	rdlong	arg01, objptr
' 
' write_color:=ff
	sub	objptr, ##44227
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	local01, objptr
	sub	objptr, #65
	mov	ptra, fp
	call	#popregs_
_do_paper_ret
	ret

' 
' sub do_ink
_do_ink
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1540
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1540
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1541
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1541
	add	objptr, ##44288
	wrlong	local01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##44223
	wrlong	local01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	add	objptr, ##44223
	rdlong	arg01, objptr
	sub	objptr, ##44288
	call	#_hg010b_spin2_setcursorcolor
	mov	ptra, fp
	call	#popregs_
_do_ink_ret
	ret

' 
' 
' sub do_font
_do_font
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1550
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1550
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1551
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1551
	add	objptr, ##44292
	wrlong	local01, objptr
	sub	objptr, ##44292
	shl	local01, #2
	mov	arg01, local01
	call	#_hg010b_spin2_setfontfamily
	mov	ptra, fp
	call	#popregs_
_do_font_ret
	ret

' 
' sub do_mode
_do_mode
	mov	COUNT_, #4
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1560
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1560
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1561
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1561
' select case t1.result.iresult
	mov	local04, local01
	fle	local04, #5
	jmprel	local04
LR__1562
	jmp	#LR__1563
	jmp	#LR__1564
	jmp	#LR__1565
	jmp	#LR__1566
	jmp	#LR__1567
	jmp	#LR__1568
LR__1563
	add	objptr, ##44292
	wrlong	#1, objptr
	sub	objptr, #4
	wrlong	#154, objptr
	add	objptr, ##17828
	wrlong	#1, objptr
	sub	objptr, ##17832
	wrlong	#147, objptr
	sub	objptr, ##44284
	mov	arg01, #4
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##44288
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##44223
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	add	ptr__dat__, ##512
	add	objptr, ##62727
	wrlong	ptr__dat__, objptr
	sub	objptr, #4
	wrlong	##1684, objptr
	sub	objptr, ##62788
	sub	ptr__dat__, ##512
	jmp	#LR__1568
LR__1564
	add	objptr, ##44292
	wrlong	#0, objptr
	sub	objptr, #4
	wrlong	#23, objptr
	add	objptr, ##17828
	wrlong	#0, objptr
	sub	objptr, ##17832
	wrlong	#0, objptr
	sub	objptr, ##44284
	mov	arg01, #0
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##44288
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##44223
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #65
	jmp	#LR__1568
LR__1565
	add	objptr, ##44292
	wrlong	#0, objptr
	sub	objptr, #4
	wrlong	#181, objptr
	add	objptr, ##17828
	wrlong	#0, objptr
	sub	objptr, ##17832
	wrlong	#0, objptr
	sub	objptr, ##44284
	mov	arg01, #0
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##44288
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##44223
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #65
	jmp	#LR__1568
LR__1566
	add	objptr, ##44292
	wrlong	#0, objptr
	sub	objptr, #4
	wrlong	#15, objptr
	add	objptr, ##17828
	wrlong	#0, objptr
	sub	objptr, ##17832
	wrlong	#0, objptr
	sub	objptr, ##44284
	mov	arg01, #0
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##44288
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##44223
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #65
	jmp	#LR__1568
LR__1567
	add	objptr, ##44292
	wrlong	#1, objptr
	sub	objptr, #4
	wrlong	#1, objptr
	add	objptr, ##17828
	wrlong	#1, objptr
	sub	objptr, ##17832
	wrlong	#14, objptr
	sub	objptr, ##44284
	mov	arg01, #4
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##44288
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##44223
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	add	ptr__dat__, ##3954
	add	objptr, ##62727
	wrlong	ptr__dat__, objptr
	sub	objptr, #4
	wrlong	##1684, objptr
	sub	objptr, ##62788
	sub	ptr__dat__, ##3954
LR__1568
	add	objptr, ##62784
	wrlong	local01, objptr
	sub	objptr, ##18496
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##44284
	call	#_hg010b_spin2_cls
	mov	arg01, ##@LR__4629
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
	add	ptr__dat__, ##8464
	rdlong	arg01, ptr__dat__
	sub	ptr__dat__, ##8464
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
	add	objptr, ##62112
	rdlong	arg01, objptr
	sub	objptr, ##62112
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
	mov	ptra, fp
	call	#popregs_
_do_mode_ret
	ret

' 
' 
' 
' sub do_pinwrite
_do_pinwrite
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___pinwrite
	mov	ptra, fp
	call	#popregs_
_do_pinwrite_ret
	ret

' 
' sub do_pinfloat
_do_pinfloat
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	fltl	result1
	mov	ptra, fp
	call	#popregs_
_do_pinfloat_ret
	ret

' 
' sub do_pinlo
_do_pinlo
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	drvl	result1
	mov	ptra, fp
	call	#popregs_
_do_pinlo_ret
	ret

' 
' sub do_pinhi
_do_pinhi
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	drvh	result1
	mov	ptra, fp
	call	#popregs_
_do_pinhi_ret
	ret

' 
' sub do_pintoggle
_do_pintoggle
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	drvnot	result1
	mov	ptra, fp
	call	#popregs_
_do_pintoggle_ret
	ret

' 
' 
' sub do_pinstart
_do_pinstart
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result3
	add	fp, #36
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	local01, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	local02, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local03, result1
	mov	arg01, fp
	call	#_converttoint
	dirl	local01
	wrpin	local02, local01
	wxpin	local03, local01
	wypin	result1, local01
	dirh	local01
	mov	ptra, fp
	call	#popregs_
_do_pinstart_ret
	ret

' 
' 
' sub do_wrpin
_do_wrpin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	wrpin	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_wrpin_ret
	ret

' 
' sub do_wxpin
_do_wxpin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	wxpin	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_wxpin_ret
	ret

' 
' sub do_wypin
_do_wypin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	wypin	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_wypin_ret
	ret

' 
' sub do_position
_do_position
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	mov	arg02, result1
	mov	arg01, local01
	call	#_hg010b_spin2_setcursorpos
	mov	ptra, fp
	call	#popregs_
_do_position_ret
	ret

' 
' sub do_waitms
_do_waitms
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t1=pop() 'value
' 
' if (t1.result_type=result_int orelse t1.result_type=result_uint) then t=t1.result.iresult else t=converttoint(t1)
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	arg01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	arg01, #29 wz
 if_e	rdlong	arg01, fp
 if_e	add	fp, #12
 if_e	wrlong	arg01, fp
 if_e	sub	fp, #12
 if_e	jmp	#LR__1570
	mov	arg01, fp
	call	#_converttoint
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__1570
' if t<0 then return
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	cmps	arg01, #0 wc
 if_b	jmp	#LR__1575
' if t < 5000 then 
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	cmps	arg01, ##5000 wc
 if_ae	jmp	#LR__1571
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___waitms
	jmp	#LR__1574
LR__1571
	add	fp, #16
	wrlong	#1, fp
	sub	fp, #4
	rdlong	arg01, fp
	abs	arg01, arg01 wc
	qdiv	arg01, ##5000
'   for i=1 to t/5000
	sub	fp, #12
	getqx	local01
	negc	local01, local01
	add	local01, #1
LR__1572
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	cmps	arg01, local01 wc
 if_ae	jmp	#LR__1573
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___waitms
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, #1
	wrlong	arg01, fp
	sub	fp, #16
	jmp	#LR__1572
LR__1573
	add	fp, #12
	rdlong	local01, fp
	abs	local01, local01 wc
	qdiv	local01, ##5000
	sub	fp, #12
	getqy	local01
	negc	arg01, local01
	call	#__system___waitms
LR__1574
LR__1575
	mov	ptra, fp
	call	#popregs_
_do_waitms_ret
	ret

' 
' sub do_waitvbl
_do_waitvbl
	mov	arg01, #1
	call	#_hg010b_spin2_waitvbl
_do_waitvbl_ret
	ret

' 
' sub do_waitclock
_do_waitclock
	add	objptr, ##62776
	rdlong	_var01, objptr
' c=hkcnt
' do: loop until hkcnt<>c
LR__1580
	rdlong	_var02, objptr
	cmp	_var02, _var01 wz
 if_e	jmp	#LR__1580
	sub	objptr, ##62776
_do_waitclock_ret
	ret

' 
' sub do_dir
_do_dir
	mov	COUNT_, #3
	call	#pushregs_
	mov	arg01, ##@LR__4630
	call	#__system___chdir
' chdir("/sd/bas")       ' set working directory
' print "Working directory: "; currentdir$ 
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4631
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##58200
	rdlong	arg02, objptr
	sub	objptr, ##58200
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, ##@LR__4632
	mov	arg02, #16
	call	#__system___basic_dir
	mov	local01, result1
' 
' filename=dir$("*", fbDirectory)
' while filename <> "" and filename <> nil
LR__1590
	mov	local02, #0
	mov	arg02, ##@LR__4633
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local02, #0
	mov	local03, #0
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local03, #0
	test	local02, local03 wz
 if_e	jmp	#LR__1591
'   print "[dir] ";filename
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4634
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #0
	mov	arg02, #0
	call	#__system___basic_dir
	mov	local01, result1
	jmp	#LR__1590
LR__1591
	mov	arg01, ##@LR__4635
	mov	arg02, #33
	call	#__system___basic_dir
	mov	local01, result1
' 
' filename = dir$("*", fbNormal )  ' start scan for all files and directories
' do while filename <> "" and filename <> nil
LR__1592
	mov	local02, #0
	mov	arg02, ##@LR__4636
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local02, #0
	mov	local03, #0
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local03, #0
	test	local02, local03 wz
 if_e	jmp	#LR__1596
'   print filename
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #0
	mov	arg02, #0
	call	#__system___basic_dir
	mov	local01, result1
'   filename = dir$()      ' continue scan
'     if v.getcursory()=34 then    'bug, after first break, cursory is always 35
' return cursor_y
	add	objptr, #58
	rdbyte	result1, objptr
	sub	objptr, #58
	cmp	result1, #34 wz
 if_ne	jmp	#LR__1592
'     print "-----more, press any key";
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4637
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
'     do 
LR__1593
	call	#_usbnew_spin2_get_key
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1593
'     do
LR__1594
	call	#_usbnew_spin2_get_key
	cmp	result1, #0 wz
 if_e	jmp	#LR__1594
'       if keyclick=1 then paula.play(7,keyclick_spl,44100,16384,spl_len) 
	add	objptr, ##62116
	rdlong	local02, objptr
	sub	objptr, ##62116
	cmp	local02, #1 wz
 if_ne	jmp	#LR__1595
	add	objptr, ##62792
	rdlong	arg02, objptr
	sub	objptr, #4
	rdlong	arg05, objptr
	mov	arg01, #7
	mov	arg03, ##44100
	decod	arg04, #14
	neg	arg06, #1
	sub	objptr, ##56964
	call	#_Audio093b_8_sc_spin2_play
	sub	objptr, ##5824
LR__1595
	mov	arg01, #0
	mov	arg02, #35
	call	#_hg010b_spin2_setcursorpos
'     position 0,35: print "                             ";: position 4,35  
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4638
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #4
	mov	arg02, #35
	call	#_hg010b_spin2_setcursorpos
	jmp	#LR__1592
LR__1596
	mov	ptra, fp
	call	#popregs_
_do_dir_ret
	ret

' 
' sub do_if
_do_if
	mov	COUNT_, #5
	call	#pushregs_
	call	#_pop
	mov	local01, result1 wz
	mov	local02, result2
	mov	local03, result3
' t1=pop()
' ' if uresult=0, jump over else
' if t1.result.uresult = 0 then 
 if_ne	jmp	#LR__1602
'   for i=lineptr_e to lineptr-1
	add	objptr, ##54084
	rdlong	local04, objptr
	sub	objptr, #4
	rdlong	local05, objptr
	sub	objptr, ##54080
LR__1600
	cmps	local04, local05 wc
 if_ae	jmp	#LR__1601
	mov	result3, local04
	shl	result3, #1
	add	result3, local04
	shl	result3, #2
	add	objptr, ##52544
	add	result3, objptr
	rdlong	local01, result3
	add	result3, #4
	rdlong	result2, result3
	mov	result3, local04
	shl	result3, #1
	add	result3, local04
	shl	result3, #2
	add	result3, objptr
	add	result3, #8
	rdlong	result3, result3
	mov	local02, result2
	mov	local03, result3
'     t1=compiledline(i)
'     if t1.result_type=token_else then lineptr_e=i : return
	cmp	local03, #90 wz
	sub	objptr, ##52544
 if_e	add	objptr, ##54084
 if_e	wrlong	local04, objptr
 if_e	sub	objptr, ##54084
 if_e	jmp	#LR__1603
	add	local04, #1
	jmp	#LR__1600
LR__1601
	add	objptr, ##54080
	rdlong	local05, objptr
	sub	local05, #1
	add	objptr, #4
	wrlong	local05, objptr
	sub	objptr, ##54084
LR__1602
LR__1603
	mov	ptra, fp
	call	#popregs_
_do_if_ret
	ret

' 
' sub do_else
_do_else
	add	objptr, ##54080
	rdlong	_var01, objptr
	sub	_var01, #1
	add	objptr, #4
	wrlong	_var01, objptr
	sub	objptr, ##54084
_do_else_ret
	ret

' 
' sub do_rad
_do_rad
	add	objptr, ##62796
	wrlong	##1065353216, objptr
	add	objptr, #4
	wrlong	##1065353216, objptr
	sub	objptr, ##62800
_do_rad_ret
	ret

' 
' sub do_deg
_do_deg
	add	objptr, ##62796
	wrlong	##1016003125, objptr
	add	objptr, #4
	wrlong	##1113927393, objptr
	sub	objptr, ##62800
_do_deg_ret
	ret

' 
' sub do_int
_do_int
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	wrlong	result1, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_int_ret
	ret

' 
' sub do_nothing
_do_nothing
_do_nothing_ret
	ret

' 
' sub do_brun
_do_brun
	mov	COUNT_, #8
	call	#pushregs_
	call	#_pop
	mov	arg05, result2
	mov	arg04, result3
	mov	local01, result1
	mov	local02, arg05
	mov	local03, arg04
' 
' t1=pop() 
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult): t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1610
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1610
' if t1.result_type=result_string then
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1614
	mov	local04, local01
'   filename=t1.result.sresult
'   if left$(filename,1)="/" then 
	mov	arg01, local04
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__4639
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local05, local04
 if_e	jmp	#LR__1611
	mov	arg01, ##@LR__4640
	mov	arg02, local04
	call	#__system___string_concat
	mov	local05, result1
LR__1611
' '  if mid$(filename,2,1)=":" then fullfilename=right$(filename,len(filename-3)) ' todo for future: strip c:/
'   open fullfilename for input as #9
	mov	arg01, #9
	mov	arg02, local05
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'   r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return
 if_e	jmp	#LR__1612
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4641
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__4642
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, local06
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1615
LR__1612
	mov	local07, #1
	mov	local08, #0
'   do
LR__1613
'     get #9,pos,block(0),1024,r : pos+=r	
	add	objptr, ##61040
	mov	arg03, objptr
	sub	objptr, ##61040
	mov	arg01, #9
	mov	arg02, local07
	decod	arg04, #10
	mov	arg05, #1
	call	#__system___basic_get
	mov	local06, result1
	add	local07, result1
	add	objptr, ##61040
	mov	arg01, objptr
	mov	arg02, local08
	decod	arg03, #10
	sub	objptr, ##55216
	call	#_psram_spin2_write
	sub	objptr, ##5824
	add	local08, local06
	cmp	local06, ##1024 wz
 if_e	cmps	local08, ##507904 wc
 if_c_and_z	jmp	#LR__1613
	add	objptr, ##44224
	rdlong	arg01, objptr
	cogstop	arg01
	add	objptr, #4
	rdlong	arg01, objptr
	cogstop	arg01
	add	objptr, #4
	rdlong	arg01, objptr
	cogstop	arg01
	add	objptr, ##17888
	rdlong	arg01, objptr
	cogstop	arg01
	add	ptr__dat__, ##8348
	mov	arg02, ptr__dat__
	sub	ptr__dat__, ##8348
	sub	objptr, ##17880
	mov	local08, #30
	setq	objptr
	coginit	local08, arg02 wc
 if_b	neg	local08, #1
	add	objptr, ##18684
	wrlong	local08, objptr
	sub	objptr, ##62924
	mov	arg01, #0
	cogid	arg01
	cogstop	arg01
LR__1614
LR__1615
	mov	ptra, fp
	call	#popregs_
_do_brun_ret
	ret

' 
' 
' sub do_mouse
_do_mouse
	call	#_pop
	cmps	result1, #0 wz
' 
' t1=pop()
' 
' if t1.result.uresult=0 then v.setspritesize(16,0,0) else v.setspritesize(16,32,32)
 if_ne	jmp	#LR__1620
	mov	arg01, #16
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritesize
	jmp	#LR__1621
LR__1620
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_hg010b_spin2_setspritesize
LR__1621
_do_mouse_ret
	ret

' 
' sub do_cursor
_do_cursor
	call	#_pop
	cmps	result1, #0 wz
' 
' t1=pop()
' 
' if t1.result.uresult=0 then  v.setspritesize(17,0,0) else v.setspritesize(17,8,16) 
 if_ne	jmp	#LR__1630
	mov	arg01, #17
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritesize
	jmp	#LR__1631
LR__1630
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_hg010b_spin2_setspritesize
LR__1631
_do_cursor_ret
	ret

' 
' 
' sub do_click
_do_click
	call	#_pop
	cmps	result1, #0 wz
' 
' t1=pop()
' 
' if t1.result.uresult=0 then keyclick=0 else keyclick=1
 if_e	add	objptr, ##62116
 if_e	wrlong	#0, objptr
	sumz	objptr, ##62116
 if_ne	wrlong	#1, objptr
 if_ne	sub	objptr, ##62116
_do_click_ret
	ret

' 
' 
' sub do_beep
_do_beep
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	local01, result1
	mov	arg06, result2
	mov	local02, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	arg06, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' 
' 
' t2=pop()
' t1=pop()
' 
' 
' if (t1.result_type=result_int orelse t1.result_type=result_uint) then freq=t1.result.iresult else freq=converttoint(t1)
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local02, #29 wz
 if_e	rdlong	local01, fp
 if_e	add	fp, #24
 if_e	wrlong	local01, fp
 if_e	sub	fp, #24
 if_e	jmp	#LR__1640
	mov	arg01, fp
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #24
LR__1640
	add	fp, #28
	wrbyte	#127, fp
	add	fp, #1
	wrbyte	#128, fp
	sub	fp, #1
	mov	arg02, fp
	sub	fp, #4
	rdlong	arg03, fp
	sub	fp, #24
	shl	arg03, #1
	mov	arg01, #7
	decod	arg04, #14
	mov	arg05, #2
	mov	arg06, #0
	add	objptr, ##5824
	call	#_Audio093b_8_sc_spin2_play8
	sub	objptr, ##5824
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_push
	call	#_do_waitms
	mov	arg01, #7
	add	objptr, ##5824
	call	#_Audio093b_8_sc_spin2_stop
	sub	objptr, ##5824
	mov	ptra, fp
	call	#popregs_
_do_beep_ret
	ret

' 
' sub do_no_command
_do_no_command
	mov	arg01, #23
	call	#_printerror
_do_no_command_ret
	ret

' 
' sub do_negative
_do_negative
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
' t1=pop()
' if t1.result_type=result_int then 
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	rdlong	local02, fp
 if_e	neg	local01, local02
 if_e	wrlong	local01, fp
 if_e	jmp	#LR__1652
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_ne	jmp	#LR__1650
	rdlong	local02, fp
	neg	local01, local02
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__1651
LR__1650
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	rdlong	result1, fp
 if_e	bitnot	result1, #31
 if_e	wrlong	result1, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	wrlong	#40, fp
LR__1651
LR__1652
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_negative_ret
	ret

' 
' '--------------------------- THE END OF THE MAIN PROGRAM ------------------------------------------------------
' 
' ''----------------------------------------------------------------------------------------------------
' ''------------------ Initialization procedures -------------------------------------------------------
' ''----------------------------------------------------------------------------------------------------
' 
' ''--------------------------- Command function pointers
' 
' sub init_commands
_init_commands
' 
' for i=0 to 255 : commands(i)=@do_no_command : next i
	mov	_var01, #0
	callpa	#(@LR__1661-@LR__1660)>>2,fcache_load_ptr_
LR__1660
	mov	result1, _var01
	shl	result1, #2
	add	objptr, ##50468
	add	result1, objptr
	sub	objptr, ##50468
	wrlong	objptr, result1
	add	_var01, #1
	cmps	_var01, #256 wc
 if_b	jmp	#LR__1660
LR__1661
	mov	result1, objptr
	bith	result1, #20
	add	objptr, ##50472
	wrlong	result1, objptr
	sub	objptr, ##50472
	mov	result1, objptr
	bith	result1, #21
	add	objptr, ##50476
	wrlong	result1, objptr
	sub	objptr, ##50476
	mov	result1, objptr
	bith	result1, #52
	add	objptr, ##50480
	wrlong	result1, objptr
	sub	objptr, ##50480
	mov	result1, objptr
	bith	result1, #22
	add	objptr, ##50488
	wrlong	result1, objptr
	sub	objptr, ##50488
	mov	result1, objptr
	or	result1, ##5242880
	add	objptr, ##50492
	wrlong	result1, objptr
	sub	objptr, ##50492
	mov	result1, objptr
	bith	result1, #53
	add	objptr, ##50496
	wrlong	result1, objptr
	sub	objptr, ##50496
	mov	result1, objptr
	bith	result1, #84
	add	objptr, ##50500
	wrlong	result1, objptr
	sub	objptr, ##50500
	mov	result1, objptr
	bith	result1, #23
	add	objptr, ##50504
	wrlong	result1, objptr
	sub	objptr, ##50504
	mov	result1, objptr
	or	result1, ##9437184
	add	objptr, ##50508
	wrlong	result1, objptr
	sub	objptr, ##50508
	mov	result1, objptr
	or	result1, ##10485760
	add	objptr, ##50512
	wrlong	result1, objptr
	sub	objptr, ##50512
	mov	result1, objptr
	or	result1, ##11534336
	add	objptr, ##50516
	wrlong	result1, objptr
	sub	objptr, ##50516
	mov	result1, objptr
	bith	result1, #54
	add	objptr, ##50536
	wrlong	result1, objptr
	sub	objptr, ##50536
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##50584
	wrlong	result1, objptr
	sub	objptr, ##50584
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##50580
	wrlong	result1, objptr
	sub	objptr, ##50580
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##50588
	wrlong	result1, objptr
	sub	objptr, ##50588
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##50592
	wrlong	result1, objptr
	sub	objptr, ##50592
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##50640
	wrlong	result1, objptr
	sub	objptr, ##50640
	mov	result1, objptr
	bith	result1, #85
	add	objptr, ##50560
	wrlong	result1, objptr
	sub	objptr, ##50560
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##50596
	wrlong	result1, objptr
	sub	objptr, ##50596
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##50600
	wrlong	result1, objptr
	sub	objptr, ##50600
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##50604
	wrlong	result1, objptr
	sub	objptr, ##50604
	mov	result1, objptr
	bith	result1, #116
	add	objptr, ##50724
	wrlong	result1, objptr
	sub	objptr, ##50724
	mov	result1, objptr
	bith	result1, #24
	add	objptr, ##50728
	wrlong	result1, objptr
	sub	objptr, ##50728
	mov	result1, objptr
	or	result1, ##17825792
	add	objptr, ##50732
	wrlong	result1, objptr
	sub	objptr, ##50732
	mov	result1, objptr
	or	result1, ##18874368
	add	objptr, ##50736
	wrlong	result1, objptr
	sub	objptr, ##50736
	mov	result1, objptr
	or	result1, ##19922944
	add	objptr, ##50740
	wrlong	result1, objptr
	sub	objptr, ##50740
	mov	result1, objptr
	or	result1, ##20971520
	add	objptr, ##50744
	wrlong	result1, objptr
	sub	objptr, ##50744
	mov	result1, objptr
	or	result1, ##22020096
	add	objptr, ##50748
	wrlong	result1, objptr
	sub	objptr, ##50748
	mov	result1, objptr
	or	result1, ##23068672
	add	objptr, ##50752
	wrlong	result1, objptr
	sub	objptr, ##50752
	mov	result1, objptr
	or	result1, ##24117248
	add	objptr, ##50756
	wrlong	result1, objptr
	sub	objptr, ##50756
	mov	result1, objptr
	bith	result1, #55
	add	objptr, ##50760
	wrlong	result1, objptr
	sub	objptr, ##50760
	mov	result1, objptr
	or	result1, ##26214400
	add	objptr, ##50764
	wrlong	result1, objptr
	sub	objptr, ##50764
	mov	result1, objptr
	or	result1, ##27262976
	add	objptr, ##50768
	wrlong	result1, objptr
	sub	objptr, ##50768
	mov	result1, objptr
	or	result1, ##28311552
	add	objptr, ##50772
	wrlong	result1, objptr
	sub	objptr, ##50772
	mov	result1, objptr
	bith	result1, #86
	add	objptr, ##50776
	wrlong	result1, objptr
	sub	objptr, ##50776
	mov	result1, objptr
	or	result1, ##30408704
	add	objptr, ##51488
	wrlong	result1, objptr
	sub	objptr, ##51488
	mov	result1, objptr
	bith	result1, #117
	add	objptr, ##50780
	wrlong	result1, objptr
	sub	objptr, ##50780
	mov	result1, objptr
	bith	result1, #148
	add	objptr, ##50800
	wrlong	result1, objptr
	sub	objptr, ##50800
	mov	result1, objptr
	bith	result1, #25
	add	objptr, ##50784
	wrlong	result1, objptr
	sub	objptr, ##50784
	mov	result1, objptr
	or	result1, ##34603008
	add	objptr, ##50556
	wrlong	result1, objptr
	sub	objptr, ##50556
	mov	result1, objptr
	or	result1, ##35651584
	add	objptr, ##50788
	wrlong	result1, objptr
	sub	objptr, ##50788
	mov	result1, objptr
	or	result1, ##36700160
	add	objptr, ##50792
	wrlong	result1, objptr
	sub	objptr, ##50792
	mov	result1, objptr
	or	result1, ##37748736
	add	objptr, ##50796
	wrlong	result1, objptr
	sub	objptr, ##50796
	mov	result1, objptr
	or	result1, ##38797312
	add	objptr, ##50808
	wrlong	result1, objptr
	sub	objptr, ##50808
	mov	result1, objptr
	or	result1, ##39845888
	add	objptr, ##50812
	wrlong	result1, objptr
	sub	objptr, ##50812
	mov	result1, objptr
	or	result1, ##40894464
	add	objptr, ##50816
	wrlong	result1, objptr
	sub	objptr, ##50816
	mov	result1, objptr
	or	result1, ##41943040
	add	objptr, ##50820
	wrlong	result1, objptr
	sub	objptr, ##50820
	mov	result1, objptr
	or	result1, ##42991616
	add	objptr, ##50828
	wrlong	result1, objptr
	sub	objptr, ##50828
	mov	result1, objptr
	or	result1, ##44040192
	add	objptr, ##50832
	wrlong	result1, objptr
	sub	objptr, ##50832
	mov	result1, objptr
	or	result1, ##45088768
	add	objptr, ##50576
	wrlong	result1, objptr
	sub	objptr, ##50576
	mov	result1, objptr
	or	result1, ##46137344
	add	objptr, ##50624
	wrlong	result1, objptr
	sub	objptr, ##50624
	mov	result1, objptr
	or	result1, ##47185920
	add	objptr, ##50620
	wrlong	result1, objptr
	sub	objptr, ##50620
	mov	result1, objptr
	or	result1, ##48234496
	add	objptr, ##50528
	wrlong	result1, objptr
	sub	objptr, ##50528
	mov	result1, objptr
	or	result1, ##49283072
	add	objptr, ##50532
	wrlong	result1, objptr
	sub	objptr, ##50532
	mov	result1, objptr
	bith	result1, #56
	add	objptr, ##50636
	wrlong	result1, objptr
	sub	objptr, ##50636
	mov	result1, objptr
	or	result1, ##51380224
	add	objptr, ##50804
	wrlong	result1, objptr
	sub	objptr, ##50804
	mov	result1, objptr
	or	result1, ##52428800
	add	objptr, ##50824
	wrlong	result1, objptr
	sub	objptr, ##50824
	mov	result1, objptr
	or	result1, ##53477376
	add	objptr, ##50836
	wrlong	result1, objptr
	sub	objptr, ##50836
	mov	result1, objptr
	or	result1, ##54525952
	add	objptr, ##50840
	wrlong	result1, objptr
	sub	objptr, ##50840
	mov	result1, objptr
	or	result1, ##55574528
	add	objptr, ##50844
	wrlong	result1, objptr
	sub	objptr, ##50844
	mov	result1, objptr
	or	result1, ##56623104
	add	objptr, ##50848
	wrlong	result1, objptr
	sub	objptr, ##50848
	mov	result1, objptr
	or	result1, ##57671680
	add	objptr, ##50852
	wrlong	result1, objptr
	sub	objptr, ##50852
	mov	result1, objptr
	bith	result1, #87
	add	objptr, ##50856
	wrlong	result1, objptr
	sub	objptr, ##50856
	mov	result1, objptr
	bith	result1, #148
	add	objptr, ##50800
	wrlong	result1, objptr
	sub	objptr, ##50800
	mov	result1, objptr
	or	result1, ##59768832
	add	objptr, ##50864
	wrlong	result1, objptr
	sub	objptr, ##50864
	mov	result1, objptr
	or	result1, ##60817408
	add	objptr, ##50860
	wrlong	result1, objptr
	sub	objptr, ##50860
	mov	result1, objptr
	or	result1, ##61865984
	add	objptr, ##50884
	wrlong	result1, objptr
	sub	objptr, ##50884
	mov	result1, objptr
	bith	result1, #118
	add	objptr, ##50888
	wrlong	result1, objptr
	sub	objptr, ##50888
	mov	result1, objptr
	or	result1, ##63963136
	add	objptr, ##50868
	wrlong	result1, objptr
	sub	objptr, ##50868
	mov	result1, objptr
	bith	result1, #149
	add	objptr, ##50872
	wrlong	result1, objptr
	sub	objptr, ##50872
	mov	result1, objptr
	bith	result1, #180
	add	objptr, ##50876
	wrlong	result1, objptr
	sub	objptr, ##50876
	mov	result1, objptr
	bith	result1, #26
	add	objptr, ##50880
	wrlong	result1, objptr
	sub	objptr, ##50880
	mov	result1, objptr
	or	result1, ##68157440
	add	objptr, ##50896
	wrlong	result1, objptr
	sub	objptr, ##50896
	mov	result1, objptr
	or	result1, ##69206016
	add	objptr, ##50892
	wrlong	result1, objptr
	sub	objptr, ##50892
	mov	result1, objptr
	or	result1, ##70254592
	add	objptr, ##50908
	wrlong	result1, objptr
	sub	objptr, ##50908
	mov	result1, objptr
	or	result1, ##71303168
	add	objptr, ##50904
	wrlong	result1, objptr
	sub	objptr, ##50904
	mov	result1, objptr
	or	result1, ##72351744
	add	objptr, ##50900
	wrlong	result1, objptr
	sub	objptr, ##50900
	mov	result1, objptr
	or	result1, ##73400320
	add	objptr, ##50912
	wrlong	result1, objptr
	sub	objptr, ##50912
	mov	result1, objptr
	or	result1, ##74448896
	add	objptr, ##50916
	wrlong	result1, objptr
	sub	objptr, ##50916
	mov	result1, objptr
	or	result1, ##75497472
	add	objptr, ##50552
	wrlong	result1, objptr
	sub	objptr, ##50552
	mov	result1, objptr
	or	result1, ##76546048
	add	objptr, ##50940
	wrlong	result1, objptr
	sub	objptr, ##50940
	mov	result1, objptr
	or	result1, ##77594624
	add	objptr, ##50956
	wrlong	result1, objptr
	sub	objptr, ##50956
	mov	result1, objptr
	or	result1, ##78643200
	add	objptr, ##50960
	wrlong	result1, objptr
	sub	objptr, ##50960
	mov	result1, objptr
	or	result1, ##79691776
	add	objptr, ##50952
	wrlong	result1, objptr
	sub	objptr, ##50952
	mov	result1, objptr
	or	result1, ##80740352
	add	objptr, ##50944
	wrlong	result1, objptr
	sub	objptr, ##50944
	mov	result1, objptr
	or	result1, ##81788928
	add	objptr, ##50948
	wrlong	result1, objptr
	sub	objptr, ##50948
	mov	result1, objptr
	or	result1, ##82837504
	add	objptr, ##50964
	wrlong	result1, objptr
	sub	objptr, ##50964
	mov	result1, objptr
	or	result1, ##83886080
	add	objptr, ##50968
	wrlong	result1, objptr
	sub	objptr, ##50968
	mov	result1, objptr
	or	result1, ##84934656
	add	objptr, ##50972
	wrlong	result1, objptr
	sub	objptr, ##50972
	mov	result1, objptr
	or	result1, ##85983232
	add	objptr, ##50976
	wrlong	result1, objptr
	sub	objptr, ##50976
	mov	result1, objptr
	or	result1, ##87031808
	add	objptr, ##50980
	wrlong	result1, objptr
	sub	objptr, ##50980
	mov	result1, objptr
	or	result1, ##88080384
	add	objptr, ##50984
	wrlong	result1, objptr
	sub	objptr, ##50984
	mov	result1, objptr
	or	result1, ##89128960
	add	objptr, ##50988
	wrlong	result1, objptr
	sub	objptr, ##50988
	mov	result1, objptr
	or	result1, ##90177536
	add	objptr, ##50992
	wrlong	result1, objptr
	sub	objptr, ##50992
	mov	result1, objptr
	or	result1, ##91226112
	add	objptr, ##51004
	wrlong	result1, objptr
	sub	objptr, ##51004
	mov	result1, objptr
	or	result1, ##92274688
	add	objptr, ##50996
	wrlong	result1, objptr
	sub	objptr, ##50996
	mov	result1, objptr
	or	result1, ##93323264
	add	objptr, ##51000
	wrlong	result1, objptr
	sub	objptr, ##51000
	mov	result1, objptr
	or	result1, ##94371840
	add	objptr, ##51008
	wrlong	result1, objptr
	sub	objptr, ##51008
	mov	result1, objptr
	or	result1, ##95420416
	add	objptr, ##50920
	wrlong	result1, objptr
	sub	objptr, ##50920
	mov	result1, objptr
	or	result1, ##96468992
	add	objptr, ##50928
	wrlong	result1, objptr
	sub	objptr, ##50928
	mov	result1, objptr
	or	result1, ##97517568
	add	objptr, ##50932
	wrlong	result1, objptr
	sub	objptr, ##50932
	mov	result1, objptr
	or	result1, ##98566144
	add	objptr, ##51012
	wrlong	result1, objptr
	sub	objptr, ##51012
	mov	result1, objptr
	or	result1, ##99614720
	add	objptr, ##51016
	wrlong	result1, objptr
	sub	objptr, ##51016
	mov	result1, objptr
	bith	result1, #57
	add	objptr, ##51020
	wrlong	result1, objptr
	sub	objptr, ##51020
	mov	result1, objptr
	or	result1, ##101711872
	add	objptr, ##50936
	wrlong	result1, objptr
	sub	objptr, ##50936
_init_commands_ret
	ret

' 
' ''--------------------------------Error strings -------------------------------------
' sub init_audio
_init_audio
	mov	COUNT_, #5
	call	#pushregs_
' 
' for i=0 to 1023 : for j=0 to 7 : samplebuf(j,i)=round(32600*sin(i*3.1415926535/512.0)) : next j: next i
	mov	local01, #0
LR__1670
	mov	local02, #0
LR__1671
	mov	arg02, local02
	shl	arg02, #11
	add	objptr, ##6348
	add	arg02, objptr
	mov	local03, local01
	shl	local03, #1
	add	local03, arg02
	mov	local04, ##1191096320
	sub	objptr, ##6348
	abs	arg01, local01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	mov	arg02, ##1078530011
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, ##1140850688
	call	#__system___float_div
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local03
	add	local02, #1
	cmps	local02, #8 wc
 if_b	jmp	#LR__1671
	add	local01, #1
	cmps	local01, ##1024 wc
 if_b	jmp	#LR__1670
' for i=0 to 255 : for j=0 to 7 : envbuf(j,i)=65280-256*i : next j : next i
	mov	local01, #0
	callpa	#(@LR__1674-@LR__1672)>>2,fcache_load_ptr_
LR__1672
	mov	local02, #0
	add	objptr, ##22732
LR__1673
	mov	local04, local02
	shl	local04, #9
	add	local04, objptr
	mov	local03, local01
	shl	local03, #1
	add	local03, local04
	mov	arg02, local01
	shl	arg02, #8
	mov	local04, ##65280
	sub	local04, arg02
	wrword	local04, local03
	add	local02, #1
	cmps	local02, #8 wc
 if_b	jmp	#LR__1673
	sub	objptr, ##22732
	add	local01, #1
	cmps	local01, #256 wc
 if_b	jmp	#LR__1672
LR__1674
	mov	ptra, fp
	call	#popregs_
_init_audio_ret
	ret

' 
' sub init_error_strings
_init_error_strings
	mov	_var01, ##@LR__4643
	add	objptr, ##51520
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4644
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4645
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4646
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4647
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4648
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4649
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4650
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4651
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4652
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4653
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4654
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4655
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4656
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4657
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4658
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4659
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4660
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4661
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4662
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4663
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4664
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4665
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4666
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4667
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4668
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4669
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4670
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4671
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4672
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4673
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4674
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4675
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4676
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4677
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4678
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4679
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4680
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4681
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4682
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4683
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4684
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4685
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4686
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4687
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4688
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4689
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4690
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4691
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__4692
	add	objptr, #4
	wrlong	_var01, objptr
	sub	objptr, ##51716
_init_error_strings_ret
	ret

'         
' sub printerror(err as integer)
_printerror
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, ##@LR__4693
	call	#_hg010b_spin2_write
	mov	arg01, local01
	call	#_hg010b_spin2_inttostr
	mov	arg01, result1
	call	#_hg010b_spin2_write
	mov	arg01, ##@LR__4694
	call	#_hg010b_spin2_write
	shl	local01, #2
	add	objptr, ##51520
	add	local01, objptr
	rdlong	arg01, local01
	sub	objptr, ##51520
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
	mov	ptra, fp
	call	#popregs_
_printerror_ret
	ret

' 
' '' ------------------------------- Hardware start/stop/initialization 
' 
' sub startpsram
_startpsram
	mov	arg01, #0
	decod	arg02, #10
	mov	arg03, #11
	mov	arg04, #7
	add	objptr, ##5824
	call	#_psram_spin2_startx
	add	objptr, ##38412
	wrlong	result1, objptr
'     return $7FF00 + cog*12
	add	objptr, #12
	wrlong	##524032, objptr
	sub	objptr, ##44248
_startpsram_ret
	ret

' 
' function startvideo(mode=64, pin=0, mb=0) 'todo return a cog#
_startvideo
	mov	COUNT_, #1
	call	#pushregs_
	add	objptr, ##44248
	rdlong	arg04, objptr
	sub	objptr, ##44248
	mov	arg01, arg02
	mov	arg02, arg04
	call	#_hg010b_spin2_start
	add	objptr, ##44228
	wrlong	result1, objptr
' 
' videocog=v.start(pin,mbox)
' 
' for thecog=0 to 7:psram.setQos(thecog, 80 << 16) :next thecog
	mov	local01, #0
	sub	objptr, ##38404
LR__1680
	mov	arg01, local01
	mov	arg02, ##5242880
	call	#_psram_spin2_setQos
	add	local01, #1
	cmps	local01, #8 wc
 if_b	jmp	#LR__1680
	add	objptr, ##38404
	rdlong	arg01, objptr
	mov	arg02, ##67171328
	sub	objptr, ##38404
	call	#_psram_spin2_setQos
	sub	objptr, ##5824
' psram.setQoS(videocog, $0400f400) 
' open SendRecvDevice(@v.putchar, nil, nil) as #0
	mov	arg02, objptr
	or	arg02, ##102760448
	mov	arg03, #0
	mov	arg04, #0
	mov	arg01, #0
	call	#__system___basic_open
' return videocog
	add	objptr, ##44228
	rdlong	result1, objptr
	sub	objptr, ##44228
	mov	ptra, fp
	call	#popregs_
_startvideo_ret
	ret

' 
' function pspeek(adr as ulong) as ubyte
_pspeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #1
	add	objptr, ##5824
	call	#_psram_spin2_read1
	sub	objptr, ##5824
' psram.read1(varptr(res),adr,1)
' return res
	add	fp, #8
	rdbyte	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_pspeek_ret
	ret

' 
' function pslpeek(adr as ulong) as ulong
_pslpeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #4
	add	objptr, ##5824
	call	#_psram_spin2_read1
	sub	objptr, ##5824
' psram.read1(varptr(res),adr,4)
' return res
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_pslpeek_ret
	ret

' 
' '' ------------------------------- USB keyboard scan to char translator
' 
' function scantochar(key)
_scantochar
' 
' select case (key shr 8) and 255
	mov	_var01, arg01
	sar	_var01, #8
	and	_var01, #255 wz
 if_e	jmp	#LR__1690
	cmp	_var01, #2 wz
 if_ne	cmp	_var01, #32 wz
 if_e	jmp	#LR__1691
	cmp	_var01, #64 wz
 if_e	jmp	#LR__1692
	cmp	_var01, #66 wz
 if_ne	cmp	_var01, #96 wz
 if_ne	jmp	#LR__1694
	jmp	#LR__1693
LR__1690
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__1691
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #1
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__1692
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #2
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__1693
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #3
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__1694
_scantochar_ret
	ret

_program
	mov	COUNT_, #11
	call	#pushregs_
	call	#_startpsram
	mov	arg01, #64
	mov	arg02, #0
	mov	arg03, #0
	call	#_startvideo
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	add	objptr, ##5824
	call	#_Audio093b_8_sc_spin2_start
	mov	arg06, result2
	add	objptr, ##38400
	wrlong	result1, objptr
	add	objptr, #20
	wrlong	arg06, objptr
	sub	objptr, ##44244
	mov	arg01, #50
	call	#__system___waitms
	add	objptr, ##44244
	rdlong	arg01, objptr
	sub	objptr, ##44244
	add	arg01, #20
	wrword	##16384, arg01
	call	#_usbnew_spin2_start
	add	objptr, ##44232
	wrlong	result1, objptr
'   mouse_limits[0] := xlim
	add	ptr__usbnew_spin2_dat__, ##7868
	wrlong	##1023, ptr__usbnew_spin2_dat__
'   mouse_limits[1] := ylim
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	##575, ptr__usbnew_spin2_dat__
	sub	objptr, ##43963
	mov	arg01, objptr
	sub	objptr, #269
	add	arg01, #196
'   mouse_outptr := ptr
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	arg01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7876
	add	ptr__dat__, ##7322
	mov	arg02, ptr__dat__
	sub	ptr__dat__, ##7322
	mov	arg01, #16
	call	#_hg010b_spin2_setspriteptr
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_hg010b_spin2_setspritesize
	decod	arg01, #9
	mov	arg02, #288
	call	#_usbnew_spin2_mouse_move
	mov	arg06, objptr
	add	objptr, ##62124
	mov	arg05, objptr
	wrlong	arg06, arg05
	add	arg05, #4
	wrlong	ptr__housekeeper_, arg05
	mov	arg02, entryptr__
	mov	local01, objptr
	mov	result1, #30
	setq	local01
	coginit	result1, arg02 wc
 if_b	neg	result1, #1
	sub	objptr, #4
	wrlong	result1, objptr
	add	objptr, ##656
	wrlong	#0, objptr
	sub	objptr, ##18496
	wrlong	#2, objptr
	add	objptr, #4
	wrlong	#147, objptr
	add	objptr, #4
	wrlong	#154, objptr
	add	objptr, #4
	wrlong	#4, objptr
	sub	objptr, #4
	rdlong	arg06, objptr
	sub	objptr, #20
	wrlong	arg06, objptr
	add	objptr, #4
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	#0, objptr
	add	objptr, ##17840
	wrlong	#1, objptr
	add	objptr, ##668
	wrlong	#0, objptr
	add	ptr__dat__, ##512
	add	objptr, #8
	wrlong	ptr__dat__, objptr
	sub	objptr, #4
	wrlong	##1684, objptr
	sub	objptr, ##11292
	wrlong	#12, objptr
	sub	objptr, ##51496
	sub	ptr__dat__, ##512
	call	#_init_commands
	call	#_init_error_strings
	call	#_init_audio
	call	#_do_new
	add	objptr, ##44288
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##44284
	call	#_hg010b_spin2_cls
	add	objptr, ##44292
	rdlong	arg01, objptr
	sub	objptr, ##44292
	call	#_hg010b_spin2_setfontfamily
' 
' leading_spaces:=amount
	add	objptr, ##690
	wrlong	#2, objptr
	sub	objptr, ##690
	mov	local02, ##@LR__4695
	mov	arg01, #61
	mov	arg02, #60
	mov	arg03, #59
	mov	arg04, #58
	call	#__system___vfs_open_sdcardx
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___mount
	mov	arg01, ##@LR__4696
	call	#__system___chdir
	mov	local02, ##@LR__4697
	add	objptr, ##58200
	wrlong	local02, objptr
	sub	objptr, ##13920
	rdlong	arg01, objptr
	sub	objptr, ##44280
	shl	arg01, #1
	mov	arg02, #1
	call	#_hg010b_spin2_setcursorpos
' 
' init_commands
' init_error_strings
' init_audio
' do_new
' 
' 
' cls(ink, paper)
' v.setfontfamily(font) 				' use ST Mono font
' v.setleadingspaces(2)
' mount "/sd", _vfs_open_sdcard()
' chdir "/sd/bas"
' 
' currentdir$="/sd/bas"
' 
' position 2*editor_spaces,1 : print ver$
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	add	ptr__dat__, ##8464
	rdlong	arg02, ptr__dat__
	sub	ptr__dat__, ##8464
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	rdlong	arg01, objptr
	mov	arg02, #0
	mov	arg03, #10
	call	#__system__Number_S
	mov	arg01, result1
	mov	arg02, ##@LR__4698
	call	#__system___string_concat
	mov	local02, result1
	add	objptr, ##62112
	wrlong	local02, objptr
	sub	objptr, ##62112
' free$=decuns$(v.buf_ptr)+" BASIC bytes free" : print free$
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	add	objptr, ##62112
	rdlong	arg02, objptr
	sub	objptr, ##62112
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	add	objptr, ##44280
	rdlong	arg01, objptr
	sub	objptr, ##44280
	shl	arg01, #1
	mov	arg02, #4
	call	#_hg010b_spin2_setcursorpos
' position 2*editor_spaces,4 : print "Ready"
	mov	arg01, #0
	call	#__system___getiolock_0425
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__4699
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local03, result1
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local04, #1
	mov	arg01, #0
	call	#__system___getiolock_0425
	wrlong	#0, result1
	mov	local05, #0
	mov	arg02, #0
	test	arg02, #1 wc
	drvc	#38
	test	arg02, #1 wc
	drvc	#39
' 'hubset( %1_000001__00_0001_1010__1111_1011)
' pinwrite 38,0 : pinwrite 39,0 ' LEDs off
' 
' 'paula.play(0,@samplebuf(0,0),88200,16484,0,2048)
' 
' 'base2:=@channel1[0]+64*channel
' 'long[base2+8]:=sample+$C0000000 
' 'long[base2+12]:= len
' 'if loop >=0 
' '  long[base2+16]:= loop
' 'else
' '  long[base2+16]:= len+2
' 'word[base2+20]:=vol
' 'word[base2+24]:= 3546911/splfreq 
' 'word[base2+26]:=256 ' todo: use skip to make accurate sample rate
' 'long[base2+28]:=$40000000
' 
' 'lpoke base+8,varptr(samplebuf(0,0))+$C000_0000 
' 'lpoke base+16,2048
' 'lpoke base+12,0
' 'dpoke base+20,16383
' 'dpoke base+22,8192
' 'dpoke base+24,40
' 'dpoke base+26,1280 ' todo: use skip to make accurate sample rate
' 'dpoke base+28,$4000_0000
' 'lpoke base+32,0 
' 'lpoke base+36, varptr(envbuf(0,0))
' 'lpoke base+40,25600' speed
' 'lpoke base+44,1023 'len
' 
' 'do: position 0,0 : print lpeek(base+32): loop 
' '-------------------------------------------------------------------------------------------------------- 
' '-------------------------------------- MAIN LOOP -------------------------------------------------------
' '--------------------------------------------------------------------------------------------------------
' 
' do
LR__1700
	mov	arg01, #1
	call	#_hg010b_spin2_waitvbl
	call	#_usbnew_spin2_get_key
	add	objptr, ##51512
	wrlong	result1, objptr
'   return hkbd_led_rep
	add	ptr__usbnew_spin2_dat__, ##10196
	rdbyte	result1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10196
	add	objptr, ##11296
	wrlong	result1, objptr
' if key>0 andalso key<4 andalso keyclick=1 then paula.play(7,@atari2_spl,44100,16384,0,1758): waitms(10): paula.stop(7)
	sub	objptr, ##11296
	rdlong	local02, objptr
	sub	objptr, ##51512
	cmp	local02, #1 wc
 if_b	jmp	#LR__1701
	add	objptr, ##51512
	rdlong	local04, objptr
	sub	objptr, ##51512
	mov	local03, local04
	cmp	local03, #4 wc
 if_ae	jmp	#LR__1701
	add	objptr, ##62116
	rdlong	local01, objptr
	sub	objptr, ##62116
	mov	local05, local01
	cmp	local05, #1 wz
 if_ne	jmp	#LR__1701
	add	ptr__dat__, ##2196
	mov	arg02, ptr__dat__
	sub	ptr__dat__, ##2196
	mov	local03, ##44100
	decod	local04, #14
	mov	local05, #0
	mov	local01, ##1758
	mov	arg01, #7
	mov	arg03, ##44100
	decod	arg04, #14
	mov	arg05, #0
	mov	arg06, ##1758
	add	objptr, ##5824
	call	#_Audio093b_8_sc_spin2_play
	sub	objptr, ##5824
	mov	arg01, #10
	call	#__system___waitms
	mov	arg01, #7
	add	objptr, ##5824
	call	#_Audio093b_8_sc_spin2_stop
	sub	objptr, ##5824
LR__1701
' if key>3 andalso key<$80000000 andalso (key and 255) <$E0 then let key2=key : let rpt=1 : let key3=key2
	add	objptr, ##51512
	rdlong	local02, objptr
	sub	objptr, ##51512
	cmp	local02, #4 wc
 if_b	jmp	#LR__1702
	add	objptr, ##51512
	rdlong	local04, objptr
	sub	objptr, ##51512
	mov	local03, local04
	cmp	local03, ##-2147483648 wc
 if_b	add	objptr, ##51512
 if_b	rdlong	local01, objptr
 if_b	sub	objptr, ##51512
 if_b	getbyte	local05, local01, #0
 if_b	cmp	local05, #224 wc
 if_ae	jmp	#LR__1702
	add	objptr, ##51512
	rdlong	local02, objptr
	add	objptr, #4
	wrlong	local02, objptr
	add	objptr, ##11296
	wrlong	#1, objptr
	sub	objptr, ##11296
	rdlong	local02, objptr
	add	objptr, ##11300
	wrlong	local02, objptr
	sub	objptr, ##62816
LR__1702
' if key>$80000000 then let rptcnt=0 : let rpt=0
	add	objptr, ##51512
	rdlong	local02, objptr
	sub	objptr, ##51512
	cmp	local02, ##-2147483647 wc
 if_ae	add	objptr, ##62820
 if_ae	wrlong	#0, objptr
 if_ae	sub	objptr, #8
 if_ae	wrlong	#0, objptr
 if_ae	sub	objptr, ##62812
' if key=0 andalso rpt=1 then rptcnt+=1
	add	objptr, ##51512
	rdlong	local02, objptr wz
	sub	objptr, ##51512
 if_e	add	objptr, ##62812
 if_e	rdlong	local04, objptr
 if_e	sub	objptr, ##62812
 if_e	mov	local03, local04
 if_e	cmp	local03, #1 wz
 if_e	add	objptr, ##62820
 if_e	rdlong	local02, objptr
 if_e	add	local02, #1
 if_e	wrlong	local02, objptr
 if_e	sub	objptr, ##62820
' if key<$80000000 then if rptcnt=25 then key3=key2 : rptcnt=21
	add	objptr, ##51512
	rdlong	local02, objptr
	sub	objptr, ##51512
	cmp	local02, ##-2147483648 wc
 if_ae	jmp	#LR__1704
	add	objptr, ##62820
	rdlong	local02, objptr
	sub	objptr, ##62820
	cmp	local02, #25 wz
 if_ne	jmp	#LR__1703
	add	objptr, ##51516
	rdlong	local02, objptr
	add	objptr, ##11300
	wrlong	local02, objptr
	add	objptr, #4
	wrlong	#21, objptr
	sub	objptr, ##62820
LR__1703
LR__1704
' 
' 
' if key3<>0 then
	add	objptr, ##62816
	rdlong	local06, objptr wz
	sub	objptr, ##62816
 if_e	jmp	#LR__1700
'   if keyclick=1 then paula.play(7,keyclick_spl,44100,16384,spl_len) 
	add	objptr, ##62116
	rdlong	local02, objptr
	sub	objptr, ##62116
	cmp	local02, #1 wz
 if_ne	jmp	#LR__1705
	add	objptr, ##62792
	rdlong	arg02, objptr
	mov	local03, ##44100
	decod	local04, #14
	sub	objptr, #4
	rdlong	local05, objptr
	neg	local01, #1
	mov	arg01, #7
	mov	arg03, ##44100
	decod	arg04, #14
	mov	arg05, local05
	neg	arg06, #1
	sub	objptr, ##56964
	call	#_Audio093b_8_sc_spin2_play
	sub	objptr, ##5824
LR__1705
	add	objptr, ##62816
	rdlong	arg01, objptr
	sub	objptr, ##62816
	call	#_scantochar
	add	objptr, ##62824
	wrlong	result1, objptr
'   if leds and 2 = 2 then 
	sub	objptr, #16
	rdlong	local02, objptr wz
	sub	objptr, ##62808
 if_e	jmp	#LR__1713
'     if key4>96 andalso key4<123 then
	add	objptr, ##62824
	rdlong	local02, objptr
	sub	objptr, ##62824
	cmps	local02, #97 wc
 if_b	jmp	#LR__1706
	add	objptr, ##62824
	rdlong	local04, objptr
	sub	objptr, ##62824
	mov	local03, local04
	cmps	local03, #123 wc
 if_ae	jmp	#LR__1706
	add	objptr, ##62824
	rdlong	local02, objptr
	sub	local02, #32
	wrlong	local02, objptr
	sub	objptr, ##62824
	jmp	#LR__1712
LR__1706
	add	objptr, ##62824
	rdlong	local02, objptr
	sub	objptr, ##62824
	cmps	local02, #65 wc
 if_b	jmp	#LR__1707
	add	objptr, ##62824
	rdlong	local04, objptr
	sub	objptr, ##62824
	mov	local03, local04
	cmps	local03, #91 wc
 if_ae	jmp	#LR__1707
	add	objptr, ##62824
	rdlong	local02, objptr
	add	local02, #32
	wrlong	local02, objptr
	sub	objptr, ##62824
	jmp	#LR__1711
LR__1707
	add	objptr, ##62824
	rdlong	local02, objptr
	sub	objptr, ##62824
	cmps	local02, #23 wc
 if_b	jmp	#LR__1708
	add	objptr, ##62824
	rdlong	local04, objptr
	sub	objptr, ##62824
	mov	local03, local04
	cmps	local03, #32 wc
 if_ae	jmp	#LR__1708
	add	objptr, ##62824
	rdlong	local02, objptr
	sub	local02, #9
	wrlong	local02, objptr
	sub	objptr, ##62824
	jmp	#LR__1710
LR__1708
	add	objptr, ##62824
	rdlong	local02, objptr
	sub	objptr, ##62824
	cmps	local02, #14 wc
 if_b	jmp	#LR__1709
	add	objptr, ##62824
	rdlong	local04, objptr
	sub	objptr, ##62824
	mov	local03, local04
	cmps	local03, #23 wc
 if_b	add	objptr, ##62824
 if_b	rdlong	local02, objptr
 if_b	add	local02, #39
 if_b	wrlong	local02, objptr
 if_b	sub	objptr, ##62824
LR__1709
LR__1710
LR__1711
LR__1712
LR__1713
'  
'   if key4>0 andalso key4<127 andalso v.cursor_x<254 then line$+=chr$(key4): v.putchar(key4)
	add	objptr, ##62824
	rdlong	local02, objptr
	sub	objptr, ##62824
	cmps	local02, #1 wc
 if_b	jmp	#LR__1714
	add	objptr, ##62824
	rdlong	local04, objptr
	sub	objptr, ##62824
	mov	local03, local04
	cmps	local03, #127 wc
 if_b	add	objptr, #56
 if_b	rdword	local01, objptr
 if_b	sub	objptr, #56
 if_b	getword	local05, local01, #0
 if_b	cmp	local05, #254 wc
 if_ae	jmp	#LR__1714
	add	objptr, ##62824
	rdlong	arg01, objptr
	sub	objptr, ##62824
	call	#__system__Chr_S
	mov	local07, result1
	add	objptr, ##44256
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	arg02, local07
	call	#__system___string_concat
	add	objptr, ##44256
	wrlong	result1, objptr
	add	objptr, ##18568
	rdlong	arg01, objptr
	sub	objptr, ##62824
	call	#_hg010b_spin2_putchar
LR__1714
'   if key4>0 andalso key4<127 andalso v.cursor_x=254 andalso keyclick=1 then paula.play(7,@atari2_spl,44100,16384,0,1758): waitms(300): paula.stop(7) 'end of line reached
	add	objptr, ##62824
	rdlong	local02, objptr
	sub	objptr, ##62824
	cmps	local02, #1 wc
 if_b	jmp	#LR__1715
	add	objptr, ##62824
	rdlong	local04, objptr
	sub	objptr, ##62824
	mov	local03, local04
	cmps	local03, #127 wc
 if_ae	jmp	#LR__1715
	add	objptr, #56
	rdword	local01, objptr
	sub	objptr, #56
	getword	local05, local01, #0
	cmp	local05, #254 wz
 if_e	add	objptr, ##62116
 if_e	rdlong	local08, objptr
 if_e	sub	objptr, ##62116
 if_e	mov	local09, local08
 if_e	cmp	local09, #1 wz
 if_ne	jmp	#LR__1715
	add	ptr__dat__, ##2196
	mov	arg02, ptr__dat__
	sub	ptr__dat__, ##2196
	mov	local03, ##44100
	decod	local04, #14
	mov	local05, #0
	mov	local01, ##1758
	mov	arg01, #7
	mov	arg03, ##44100
	decod	arg04, #14
	mov	arg05, #0
	mov	arg06, ##1758
	add	objptr, ##5824
	call	#_Audio093b_8_sc_spin2_play
	sub	objptr, ##5824
	mov	arg01, #300
	call	#__system___waitms
	mov	arg01, #7
	add	objptr, ##5824
	call	#_Audio093b_8_sc_spin2_stop
	sub	objptr, ##5824
LR__1715
'  
'   'tab
'   if (key3 and 255) = 43 andalso v.cursor_x>=240 andalso keyclick=1 then paula.play(0,@atari2_spl,44100,16384,0,1758): waitms(300): paula.stop(0)
	add	objptr, ##62816
	rdlong	local02, objptr
	sub	objptr, ##62816
	getbyte	local02, local02, #0
	cmp	local02, #43 wz
 if_ne	jmp	#LR__1716
	add	objptr, #56
	rdword	local04, objptr
	sub	objptr, #56
	getword	local03, local04, #0
	cmp	local03, #240 wc
 if_b	jmp	#LR__1716
	add	objptr, ##62116
	rdlong	local01, objptr
	sub	objptr, ##62116
	mov	local05, local01
	cmp	local05, #1 wz
 if_ne	jmp	#LR__1716
	add	ptr__dat__, ##2196
	mov	arg02, ptr__dat__
	sub	ptr__dat__, ##2196
	mov	local03, ##44100
	decod	local04, #14
	mov	local05, #0
	mov	local01, ##1758
	mov	arg01, #0
	mov	arg03, ##44100
	decod	arg04, #14
	mov	arg05, #0
	mov	arg06, ##1758
	add	objptr, ##5824
	call	#_Audio093b_8_sc_spin2_play
	sub	objptr, ##5824
	mov	arg01, #300
	call	#__system___waitms
	mov	arg01, #0
	add	objptr, ##5824
	call	#_Audio093b_8_sc_spin2_stop
	sub	objptr, ##5824
LR__1716
'   if (key3 and 255) = 43 andalso v.cursor_x<240 then let x=(v.cursor_x mod 16)/2: for i=x to 7: line$+=" " :  v.write (" ") : next i  
	add	objptr, ##62816
	rdlong	local02, objptr
	sub	objptr, ##62816
	getbyte	local02, local02, #0
	cmp	local02, #43 wz
 if_ne	jmp	#LR__1719
	add	objptr, #56
	rdword	local04, objptr
	sub	objptr, #56
	getword	local03, local04, #0
	cmp	local03, #240 wc
 if_ae	jmp	#LR__1719
	add	objptr, #56
	rdword	local02, objptr
	abs	local03, local02 wc
	getnib	local03, local03, #0
	negc	local03, local03
	abs	local04, local03 wc
	shr	local04, #1
	negc	local04, local04
	add	objptr, ##62772
	wrlong	local04, objptr
	mov	local10, local04
	sub	objptr, ##62828
LR__1717
	cmps	local10, #8 wc
 if_ae	jmp	#LR__1718
	add	objptr, ##44256
	rdlong	arg01, objptr
	sub	objptr, ##44256
	mov	local04, ##@LR__4700
	mov	arg02, local04
	call	#__system___string_concat
	add	objptr, ##44256
	wrlong	result1, objptr
	sub	objptr, ##44256
	mov	arg01, ##@LR__4701
	call	#_hg010b_spin2_write
	mov	local03, local10
	add	local03, #1
	mov	local10, local03
	jmp	#LR__1717
LR__1718
LR__1719
'  
'   'backspace
'   if (key3 and 255) = 42 then 
	add	objptr, ##62816
	rdlong	local02, objptr
	sub	objptr, ##62816
	getbyte	local02, local02, #0
	cmp	local02, #42 wz
 if_ne	jmp	#LR__1724
'       if v.cursor_x>4 then 
	add	objptr, #56
	rdword	local02, objptr
	sub	objptr, #56
	cmp	local02, #5 wc
 if_b	jmp	#LR__1722
	add	objptr, ##44256
	rdlong	local05, objptr
	sub	objptr, ##44256
	mov	arg01, local05
	mov	local11, arg01
	callpa	#(@LR__1721-@LR__1720)>>2,fcache_load_ptr_
LR__1720
	rdbyte	result1, local11 wz
 if_ne	add	local11, #1
 if_ne	jmp	#LR__1720
LR__1721
	sub	local11, arg01
	mov	arg02, local11
	sub	arg02, #1
	mov	arg01, local05
	call	#__system__Left_S
	add	objptr, ##44256
	wrlong	result1, objptr
	sub	objptr, ##44200
	rdword	arg01, objptr
	sub	arg01, #2
	add	objptr, #2
	rdbyte	arg02, objptr
	sub	objptr, #58
	call	#_hg010b_spin2_setcursorpos
	mov	arg01, #32
	call	#_hg010b_spin2_putchar
	add	objptr, #56
	rdword	arg01, objptr
	sub	arg01, #2
	add	objptr, #2
	rdbyte	local04, objptr
	sub	objptr, #58
	getbyte	local03, local04, #0
	mov	arg02, local03
	call	#_hg010b_spin2_setcursorpos
	jmp	#LR__1723
LR__1722
	mov	local02, ##@LR__4702
	add	objptr, ##44256
	wrlong	local02, objptr
	sub	objptr, ##44200
	wrword	#4, objptr
	sub	objptr, #56
LR__1723
LR__1724
'    
'  ' To do: arrows and DEL; use textscreen array to implement fullscreen editing
'  
'   if key4=key_enter then 
	add	objptr, ##62824
	rdlong	local06, objptr
	sub	objptr, ##62824
	cmp	local06, #141 wz
 if_ne	jmp	#LR__1725
	call	#_hg010b_spin2_crlf
	call	#_interpret
	mov	local02, ##@LR__4703
	add	objptr, ##44256
	wrlong	local02, objptr
	getct	result1
	add	objptr, ##18576
	rdlong	local04, objptr
	mov	local03, local04
	sub	result1, local03
	wrlong	result1, objptr
	sub	objptr, #20
	wrlong	#0, objptr
	add	objptr, #8
	wrlong	#0, objptr
	sub	objptr, ##62820
LR__1725
	add	objptr, ##62816
	wrlong	#0, objptr
	sub	objptr, ##62816
	jmp	#LR__1700
	mov	ptra, fp
	call	#popregs_
_program_ret
	ret

' '' this is not a main program.
' 
' '****************************************************************************************************************
' '                                                                                                             	*
' 'Start the driver with graphics mode 'mode' at pins 'base'                            		rev 20220320 	*
' '                                                                                                            	*
' ' mode - mode #, see below											*
' ' base - HDMI base pin												*
' ' mb - PSRAM mailbox pointer, 0 if no PSRAM									*
' '														*
' '' mode number: :  %p_tn_bb_cc_vv_hh										*
' '' set bit #15 for custom timings														*
' '' p - 1 - psram, 0 - hub											*
' '' t - 1 - graphics, 0 - text											*
' '' n - 1 - 60 Hz,  0 - 50 Hz 											*
' '' hh - h.zoom, vv-v.zoom, cc-color depth if graphic, unused in text,						*
' '' bb - borders, 00-wide, 01 medium, 10 no border, 11 no border, extended resolution (1024x576/896x496)		*
' '														*
' '****************************************************************************************************************
' 
' pub start(base,mb):result |i
_hg010b_spin2_start
' 
' '--------------------------- initialize pointers and variables
' 
' border_ptr:=@bordercolor					' Initial border color pointer, can be changed via DL
	add	objptr, #48
	mov	result1, objptr
	sub	objptr, #40
	wrlong	result1, objptr
' 'font_ptr:=@amiga_font						' Initial 8x16 font definition
' hdmibase:=base							' HDMI base pin, 8*n
	add	objptr, #24
	wrlong	arg01, objptr
' mailbox_ptr:=mb		
	add	objptr, #4
	wrlong	arg02, objptr
' mailbox0:=mb				' PSRAM mailbox pointer
	add	objptr, #449
	wrlong	arg02, objptr
' sprite_ptr:=@spr1ptr
	sub	objptr, #216
	mov	result1, objptr
	sub	objptr, #229
	wrlong	result1, objptr
' 
' 		'
' word[spr1ptr+17*12+4]:=8				' spr18w
	add	objptr, #229
	rdlong	result1, objptr
	add	result1, #208
	wrword	#8, result1
' word[spr1ptr+17*12+6]:=16				' for a blinking cursor
	rdlong	arg03, objptr
	add	arg03, #210
	wrword	#16, arg03
' leading_spaces:=0				'
	add	objptr, #421
	wrlong	#0, objptr
' 
' emptydl[0]:=%0100_0000_0000_0000_0000_0000_0000_0111
	sub	objptr, #153
	wrlong	##1073741831, objptr
' emptydl[1]:=0
	add	objptr, #4
	wrlong	#0, objptr
' 
' '---------------------------- the mode has to be set here to enable computing the buffer length
' 
' s_debug:=debugger						' check if debug mode defined (eats 16 kB upper RAM so don't use it)					' 
	sub	objptr, #296
	wrlong	#1, objptr
' if s_debug<>0
'   s_debug:=16384						' the buffers adresses will be corrected to not interfere with the debugger
	wrlong	##16384, objptr
	sub	objptr, #245
' setmode()							' set the mode, see below
	call	#_hg010b_spin2_setmode
' vblank_ptr:=@vblank						' set pointers before starting the driver
	add	objptr, #69
	mov	result1, objptr
	sub	objptr, #53
	wrlong	result1, objptr
' cursor_ptr:=@cursor_x						
	add	objptr, #40
	mov	arg03, objptr
	sub	objptr, #44
	wrlong	arg03, objptr
' fontnum:=0  							' start with a PC type font 
	add	objptr, #85
	wrlong	#0, objptr
' bytemove(@colors,@vgacolors,16)					' prepare standard DOS VGA colors
	add	objptr, #28
	mov	arg01, objptr
	sub	objptr, #125
	add	ptr__hg010b_spin2_dat__, ##8320
	mov	arg02, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##8320
	mov	arg03, #16
	call	#__system____builtin_memmove
' leading_spaces:=0
	add	objptr, ##690
	wrlong	#0, objptr
	sub	objptr, ##690
' '---------------------------- initialize a cursor (MSDOS type)
' 
' initcursor(154)
	mov	arg01, #154
	call	#_hg010b_spin2_initcursor
' 
' '---------------------------- start the cog
' 
' cog:=coginit(16,@hdmi, @vblank_ptr)				' start the driver cog			
	add	ptr__hg010b_spin2_dat__, ##8336
	mov	arg02, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##8336
	add	objptr, #16
	mov	result1, #16
	setq	objptr
	coginit	result1, arg02 wc
 if_b	neg	result1, #1
	add	objptr, #28
	wrlong	result1, objptr
	sub	objptr, #44
' waitms(40)							' wait for stabilize
	mov	arg01, #40
	call	#__system___waitms
' return cog							' return the driver's cog #
	add	objptr, #44
	rdlong	result1, objptr
	sub	objptr, #44
_hg010b_spin2_start_ret
	ret

' 
' 
' '**************************************************************************************************************** 
' '                                                                                                             	*
' '  Simple standard mode setting                                                             	rev. 20220319 	*
' '  Mode number - see start() above or bits below								*
' '                                                                                                             	*
' '****************************************************************************************************************
' 
' '---------------------------- initialize a cursor (MSDOS type)
' pub initcursor(color) |i
_hg010b_spin2_initcursor
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' cursor_x:=0							' place the cursor at 0:0
	add	objptr, #56
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' repeat i from 0 to 111
	mov	local02, #0
	add	objptr, #504
	callpa	#(@LR__1732-@LR__1730)>>2,fcache_load_ptr_
LR__1730
'   cursor[i]:=0
	mov	local03, local02
	add	local03, objptr
	wrbyte	#0, local03
	add	local02, #1
	cmps	local02, #112 wc
 if_b	jmp	#LR__1730
' repeat i from 112 to 127
	mov	local02, #112
LR__1731
'   cursor[i]:=color  
	mov	local03, local02
	add	local03, objptr
	wrbyte	local01, local03
	add	local02, #1
	cmp	local02, #128 wc
 if_b	jmp	#LR__1731
LR__1732
' 'repeat i from 0 to 127
' '  if ((i/8)//2)
' '    cursor[i]:=15
' '  else
' '    cursor[i]:=0
' '  if i>=120    
' '    cursor[i]:=40
' setspriteptr(17,@cursor)
	mov	arg02, objptr
	sub	objptr, ##562
	mov	arg01, #17
	call	#_hg010b_spin2_setspriteptr
' setspritesize(17,8,16)
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_hg010b_spin2_setspritesize
' setspritepos(17,0,0)
	mov	arg01, #17
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_initcursor_ret
	ret

' 
'  
' pub setcursorcolor(color) |i
_hg010b_spin2_setcursorcolor
' 
' 
' repeat i from 0 to 111
	mov	_var01, #0
	add	objptr, ##562
	callpa	#(@LR__1742-@LR__1740)>>2,fcache_load_ptr_
LR__1740
'   cursor[i]:=0
	mov	_var02, _var01
	add	_var02, objptr
	wrbyte	#0, _var02
	add	_var01, #1
	cmps	_var01, #112 wc
 if_b	jmp	#LR__1740
' repeat i from 112 to 127
	mov	_var01, #112
LR__1741
'   cursor[i]:=color  
	mov	_var02, _var01
	add	_var02, objptr
	wrbyte	arg01, _var02
	add	_var01, #1
	cmp	_var01, #128 wc
 if_b	jmp	#LR__1741
LR__1742
	sub	objptr, ##562
_hg010b_spin2_setcursorcolor_ret
	ret

'  
' 
' pub setmode() | i', 'xzoom, yzoom, azoom
_hg010b_spin2_setmode
	mov	COUNT_, #2
	call	#pushregs_
' 
' 
' dl_ptr:=@emptydl[0]
	add	objptr, ##537
	mov	muldivb_, objptr
	sub	objptr, #509
	wrlong	muldivb_, objptr
' 
' if cog>0 
	add	objptr, #16
	rdlong	muldivb_, objptr
	sub	objptr, #44
	cmps	muldivb_, #1 wc
'    waitvbl(1)						    	' if the driver is active, wait for vblank to set the new mode and DL	
 if_ae	mov	arg01, #1
 if_ae	call	#_hg010b_spin2_waitvbl
' xres:=1024
	add	objptr, ##546
	wrlong	##1024, objptr
' yres:=576  
	add	objptr, #4
	wrlong	##576, objptr
' ppl:=(timings[3])
	add	ptr__hg010b_spin2_dat__, ##8268
	rdlong	muldivb_, ptr__hg010b_spin2_dat__
	sub	objptr, #337
	wrlong	muldivb_, objptr
' cpl:=timings[7]<<1                                      	' now cpl is longs per line
	add	ptr__hg010b_spin2_dat__, #16
	rdlong	local01, ptr__hg010b_spin2_dat__
	shl	local01, #1
	sub	objptr, #128
	wrlong	local01, objptr
' cpl1:=cpl '' todo remove
	add	objptr, #4
	wrlong	local01, objptr
' palette_ptr:=@ataripalette				    	' use 256-colors palettr
	sub	ptr__hg010b_spin2_dat__, ##1052
	sub	objptr, #65
	wrlong	ptr__hg010b_spin2_dat__, objptr
' repeat i from 0 to 3
	mov	local02, #0
	add	ptr__hg010b_spin2_dat__, ##1024
	add	objptr, #8
	callpa	#(@LR__1751-@LR__1750)>>2,fcache_load_ptr_
LR__1750
'   timings[i]:=timings[i]+hdmibase<<17+ timingsxxt          	' add a streamer config (imm->pins) to horizontal timings 
	mov	local01, local02
	shl	local01, #2
	add	local01, ptr__hg010b_spin2_dat__
	rdlong	muldivb_, objptr
	shl	muldivb_, #17
	rdlong	local01, local01
	add	local01, muldivb_
	add	local01, ##1887502336
	mov	muldivb_, local02
	shl	muldivb_, #2
	add	muldivb_, ptr__hg010b_spin2_dat__
	wrlong	local01, muldivb_
	add	local02, #1
	cmps	local02, #4 wc
 if_b	jmp	#LR__1750
LR__1751
	sub	objptr, #32
' clkfreq:=timings[9]					    	' set the clock frequency for the mode
	add	ptr__hg010b_spin2_dat__, #36
	rdlong	local01, ptr__hg010b_spin2_dat__
	wrlong	local01, #20
' hubset(timings[10])
	add	ptr__hg010b_spin2_dat__, #4
	rdlong	arg01, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##8296
	hubset	arg01
' waitms(1)                                                   	' wait for stabilization
	mov	arg01, #1
	call	#__system___waitms
	add	ptr__hg010b_spin2_dat__, ##8300
	rdlong	local02, ptr__hg010b_spin2_dat__
	add	objptr, #93
	wrlong	local02, objptr
	abs	local01, local02 wc
	shr	local01, #4
	negc	local01, local01
	add	objptr, #156
	wrlong	local01, objptr
	sub	objptr, #164
	rdlong	local02, objptr
	add	objptr, #8
	rdlong	local01, objptr
	qmul	local02, local01
' lines:=timings[11]
' t_lines:=lines/16
' buflen:=cpl*lines						' framebuffer length in longs
	sub	objptr, #41
' buf_ptr:=$2000000-4*buflen                          	     	' todo: get a PSRAM real himem 
	decod	local01, #25
' mode_ptr:=@timings						' set pointers to timings
	sub	ptr__hg010b_spin2_dat__, #44
' graphmode:=1024+512+192+48							' det global variable
' makedl(graphmode)							' make a DL for the mode
	mov	arg01, ##1776
	getqx	local02
	wrlong	local02, objptr
	sub	objptr, #52
	shl	local02, #2
	sub	local01, local02
	wrlong	local01, objptr
	add	objptr, #20
	wrlong	ptr__hg010b_spin2_dat__, objptr
	add	objptr, #121
	wrlong	##1776, objptr
	sub	objptr, #141
	sub	ptr__hg010b_spin2_dat__, ##8256
	call	#_hg010b_spin2_makedl
' s_buf_ptr:=buf_ptr						' secondary copies of main framebuffer parameters 
	rdlong	local01, objptr
	add	objptr, #217
	wrlong	local01, objptr
' s_font_ptr:=font_ptr
	sub	objptr, #213
	rdlong	local01, objptr
	add	objptr, #217
	wrlong	local01, objptr
' s_lines:=lines
	sub	objptr, #128
	rdlong	local01, objptr
	add	objptr, #132
	wrlong	local01, objptr
' s_buflen:=buflen
	sub	objptr, #173
	rdlong	local01, objptr
	add	objptr, #181
	wrlong	local01, objptr
' s_cpl:=cpl
	sub	objptr, #148
	rdlong	local01, objptr
	add	objptr, #144
	wrlong	local01, objptr
' s_cpl1:=cpl
	sub	objptr, #144
	rdlong	local01, objptr
	add	objptr, #152
	wrlong	local01, objptr
' st_lines:=t_lines
	add	objptr, #12
	rdlong	local01, objptr
	add	objptr, #4
	wrlong	local01, objptr
' ppl:=ppl/xzoom  
	sub	objptr, #40
	rdlong	muldiva_, objptr
	add	objptr, #44
	rdlong	muldivb_, objptr
	sub	objptr, #257
	call	#divide_
	add	objptr, #213
	wrlong	muldivb_, objptr
' s_ppl:=ppl
	add	objptr, #28
	wrlong	muldivb_, objptr
	sub	objptr, #241
' waitms(20)							' wait 
	mov	arg01, #20
	call	#__system___waitms
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_setmode_ret
	ret

' 
' 
' '****************************************************************************************************************
' '                                                                                                             	*
' '  Make a display list for simple standard modes                                             	rev.20220319    *
' '                                                                                                             	*
' '****************************************************************************************************************
' 
' pub makedl(mode) |i,vzoom,border,psbuf,lines2
_hg010b_spin2_makedl
' 
' psbuf:=$80000-s_debug-1024                                                     ' HUB line buffer on the top of HUB RAM (-16 kB if debug enabled)
' vzoom:=1<<((mode>>2) & 3)                                                      ' real vzoom from mode#
' repeat i from 0 to 11                                                           ' clear DL
	mov	_var01, #0
	add	objptr, #489
	callpa	#(@LR__1761-@LR__1760)>>2,fcache_load_ptr_
LR__1760
'   displaylist[i]:=0 
	mov	_var02, _var01
	shl	_var02, #2
	add	_var02, objptr
	wrlong	#0, _var02
	add	_var01, #1
	cmps	_var01, #12 wc
 if_b	jmp	#LR__1760
LR__1761
'                         ' 
' displaylist[0]:=lines<<20+(0)<<16+%0001+ (0+(cpl1<<2)) <<4             
	sub	objptr, #396
	rdlong	_var02, objptr
	shl	_var02, #20
	add	_var02, #1
	sub	objptr, #4
	rdlong	_var01, objptr
	shl	_var01, #2
	shl	_var01, #4
	add	_var02, _var01
	add	objptr, #400
	wrlong	_var02, objptr
	sub	objptr, #489
' displaylist[1]:=buf_ptr<<4+%10  
	rdlong	_var02, objptr
	shl	_var02, #4
	add	_var02, #2
	add	objptr, #493
	wrlong	_var02, objptr
' dl_ptr:=@displaylist[0] 						      ' tell the driver where to find the DL
	sub	objptr, #4
	mov	_var02, objptr
	sub	objptr, #461
	wrlong	_var02, objptr
	sub	objptr, #28
_hg010b_spin2_makedl_ret
	ret

' 
' 
' '****************************************************************************************************************
' '                                                                        					*
' '  Graphic primitives                                                    					*
' '                                                                        					*
' '****************************************************************************************************************
' 
' pub setspriteptr(num,ptr)
_hg010b_spin2_setspriteptr
' long[@spr1ptr+12*num]:=ptr
	add	objptr, #269
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	wrlong	arg02, _var01
	sub	objptr, #269
_hg010b_spin2_setspriteptr_ret
	ret

' 
' pub setspritepos(num,x,y)
_hg010b_spin2_setspritepos
' word[@spr1ptr+12*num+4]:=x
	add	objptr, #269
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #4
	wrword	arg02, _var01
' word[@spr1ptr+12*num+6]:=y
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #6
	wrword	arg03, _var01
	sub	objptr, #269
_hg010b_spin2_setspritepos_ret
	ret

' 
' pub setspritesize(num,w,h)
_hg010b_spin2_setspritesize
' word[@spr1ptr+12*num+8]:=w
	add	objptr, #269
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #8
	wrword	arg02, _var01
' word[@spr1ptr+12*num+10]:=h
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #10
	wrword	arg03, _var01
	sub	objptr, #269
_hg010b_spin2_setspritesize_ret
	ret

' 
' 
' ''---------- putpixel - put a pixel on the screen - a mother of all graphic functions ---------------------------
' 
' 
' pub putpixel(x,y,c)
_hg010b_spin2_putpixel
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' if ((x>=0) & (x<4*s_cpl) & (y>=0) & (y<s_lines))
	mov	local02, #0
	cmps	local01, #0 wc
 if_ae	neg	local02, #1
	add	objptr, #229
	rdlong	arg05, objptr
	shl	arg05, #2
	cmps	local01, arg05 wc
	subx	local03, local03
	and	local02, local03
	mov	local03, #0
	cmps	arg02, #0 wc
 if_ae	neg	local03, #1
	and	local02, local03
	sub	objptr, #4
	rdlong	local03, objptr
	sub	objptr, #225
	cmps	arg02, local03 wc
	subx	local04, local04
	test	local02, local04 wz
 if_e	jmp	#LR__1770
	add	objptr, #217
	rdlong	arg01, objptr
	add	objptr, #20
	rdlong	local04, objptr
	shl	local04, #2
	qmul	local04, arg02
'   ram.fill(s_buf_ptr+(4*s_cpl1*y+x),c,1,0,1)
	mov	arg02, arg03
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5587
	getqx	local04
	add	local04, local01
	add	arg01, local04
	call	#_psram_spin2_fill
	sub	objptr, ##5824
LR__1770
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putpixel_ret
	ret

' 
' pub putpixel2(x,y,c)
_hg010b_spin2_putpixel2
	mov	COUNT_, #2
	call	#pushregs_
	add	objptr, #217
	rdlong	local01, objptr
	add	objptr, #20
	rdlong	arg05, objptr
	shl	arg05, #2
	qmul	arg05, arg02
' ram.fill(s_buf_ptr+(4*s_cpl1*y+x),c,1,0,1)
	mov	arg02, arg03
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5587
	getqx	local02
	add	local02, arg01
	add	local01, local02
	mov	arg01, local01
	call	#_psram_spin2_fill
	sub	objptr, ##5824
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putpixel2_ret
	ret

' 
' pub getpixel2(x,y): c 
_hg010b_spin2_getpixel2
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	wrlong	#0, fp
	mov	arg01, fp
	add	objptr, #217
	rdlong	arg02, objptr
	add	objptr, #20
	rdlong	arg03, objptr
	shl	arg03, #2
	add	fp, #8
	rdlong	result1, fp
	qmul	arg03, result1
' 
' ram.read1(@c,s_buf_ptr+(4*s_cpl1*y+x),1)
	sub	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	mov	arg03, #1
	add	objptr, ##5587
	getqx	local02
	add	local02, local01
	add	arg02, local02
	call	#_psram_spin2_read1
	sub	objptr, ##5824
' return c
	rdlong	result1, fp
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_getpixel2_ret
	ret

'   
' '----------- A line drawing family. BASIC doesn't like the name, so it is named "draw" and aliased  -----------------------------
' 
' pub fastline(x1,x2,y,c)									' a fast 8bpp horizontal line
_hg010b_spin2_fastline
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' if y<0 || y>=yres || (x1<0 && x2<0) || (x1>xres && x2>xres)
	cmps	arg03, #0 wc
 if_b	jmp	#LR__1780
	add	objptr, ##550
	rdlong	arg05, objptr
	sub	objptr, ##550
	cmps	arg03, arg05 wc
 if_ae	jmp	#LR__1780
	cmps	local01, #0 wc
 if_b	cmps	local02, #0 wc
 if_b	jmp	#LR__1780
	add	objptr, ##546
	rdlong	arg05, objptr
	sub	objptr, ##546
	cmps	local01, arg05 wcz
 if_a	add	objptr, ##546
 if_a	rdlong	arg01, objptr
 if_a	sub	objptr, ##546
 if_a	cmps	local02, arg01 wcz
'   return
 if_a	jmp	#LR__1780
	cmps	local01, local02 wcz
 if_a	mov	arg05, local01
 if_a	mov	local01, local02
 if_a	mov	local02, arg05
	cmps	local01, #0 wc
 if_b	mov	local01, #0
	add	objptr, ##546
	rdlong	arg05, objptr
	sub	objptr, ##546
	cmps	local02, arg05 wc
 if_ae	add	objptr, ##546
 if_ae	rdlong	local02, objptr
 if_ae	sub	objptr, ##546
	add	objptr, #217
	rdlong	arg01, objptr
	add	objptr, #20
	rdlong	arg05, objptr
	shl	arg05, #2
	qmul	arg05, arg03
' if x1>x2
'   x1,x2:=x2,x1
' if x1<0 
'   x1:=0
' if x2>=xres
'   x2:=xres-1  
 if_ae	sub	local02, #1
' ram.fill(s_buf_ptr+(4*s_cpl1*y+x1),c,1+x2-x1,0,1)
	mov	arg03, #1
	add	arg03, local02
	sub	arg03, local01
	mov	arg02, arg04
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5587
	getqx	local02
	add	local02, local01
	add	arg01, local02
	call	#_psram_spin2_fill
	sub	objptr, ##5824
LR__1780
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_fastline_ret
	ret

' 
' pub draw(x1,y1,x2,y2,c) | d,dx,dy,ai,bi,xi,yi,x,y					' I had to rename the function for BASIC	
_hg010b_spin2_draw
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' if (y1==y2)
	cmp	local02, local04 wz
 if_ne	jmp	#LR__1790
'   fastline(x1,x2,y1,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local02
	mov	arg04, local05
	call	#_hg010b_spin2_fastline
	jmp	#LR__1796
LR__1790
' else  
'   x:=x1
	mov	local06, local01
'   y:=y1
	mov	local07, local02
' 
'   if (x1<x2) 
	cmps	local01, local03 wc
'     xi:=1
 if_b	mov	local08, #1
'     dx:=x2-x1
 if_b	mov	local09, local03
 if_b	sub	local09, local01
'   else
'     xi:=-1
 if_ae	neg	local08, #1
'     dx:=x1-x2
 if_ae	sub	local01, local03
 if_ae	mov	local09, local01
'   
'   if (y1<y2) 
	cmps	local02, local04 wc
'     yi:=1
 if_b	mov	local10, #1
'     dy:=y2-y1
 if_b	mov	local11, local04
 if_b	sub	local11, local02
'   else
'     yi:=-1
 if_ae	neg	local10, #1
'     dy:=y1-y2
 if_ae	sub	local02, local04
 if_ae	mov	local11, local02
' 
'   putpixel(x,y,c)
	mov	arg03, local05
	mov	arg01, local06
	mov	arg02, local07
	call	#_hg010b_spin2_putpixel
' 
'   if (dx>dy)
	cmps	local09, local11 wcz
 if_be	jmp	#LR__1792
'     ai:=(dy-dx)*2
	mov	local12, local11
	sub	local12, local09
	shl	local12, #1
'     bi:=dy*2
	shl	local11, #1
	mov	local13, local11
'     d:= bi-dx
	mov	local14, local13
	sub	local14, local09
'     repeat while (x<>x2) 
LR__1791
	cmp	local06, local03 wz
 if_e	jmp	#LR__1795
'       if (d>=0) 
	cmps	local14, #0 wc
'         x+=xi
 if_ae	add	local06, local08
'         y+=yi
 if_ae	add	local07, local10
'         d+=ai
 if_ae	add	local14, local12
'       else
'         d+=bi
 if_b	add	local14, local13
'         x+=xi
 if_b	add	local06, local08
'       putpixel(x,y,c)
	mov	arg01, local06
	mov	arg02, local07
	mov	arg03, local05
	call	#_hg010b_spin2_putpixel
	jmp	#LR__1791
LR__1792
'   else
'     ai:=(dx-dy)*2
	mov	local12, local09
	sub	local12, local11
	shl	local12, #1
'     bi:=dx*2
	shl	local09, #1
	mov	local13, local09
'     d:=bi-dy
	mov	local14, local13
	sub	local14, local11
'     repeat while (y<>y2)
LR__1793
	cmp	local07, local04 wz
 if_e	jmp	#LR__1794
'       if (d>=0)
	cmps	local14, #0 wc
'         x+=xi
 if_ae	add	local06, local08
'         y+=yi
 if_ae	add	local07, local10
'         d+=ai
 if_ae	add	local14, local12
'       else
'         d+=bi
 if_b	add	local14, local13
'         y+=yi
 if_b	add	local07, local10
'       putpixel(x, y,c)
	mov	arg01, local06
	mov	arg02, local07
	mov	arg03, local05
	call	#_hg010b_spin2_putpixel
	jmp	#LR__1793
LR__1794
LR__1795
LR__1796
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_draw_ret
	ret

'  
' pub fillpush(val) 
_hg010b_spin2_fillpush
' fillstack[fillptr]:=val
	add	objptr, ##5814
	rdlong	_var01, objptr
	shl	_var01, #2
	sub	objptr, ##5120
	add	_var01, objptr
	wrlong	arg01, _var01
' fillptr+=1   
	add	objptr, ##5120
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##5814
_hg010b_spin2_fillpush_ret
	ret

' 
'     
' pub fillpop() : val
_hg010b_spin2_fillpop
' 
' fillptr-=1
	add	objptr, ##5814
	rdlong	result1, objptr
	sub	result1, #1
	wrlong	result1, objptr
' if fillptr<0
	sub	objptr, ##5814
	cmps	result1, #0 wc
'   fillptr:=0
 if_b	add	objptr, ##5814
 if_b	wrlong	#0, objptr
 if_b	sub	objptr, ##5814
'   val:=-12345
 if_b	mov	_var01, ##-12345
 if_b	jmp	#LR__1800
' else 
'   val:=fillstack[fillptr]
	add	objptr, ##5814
	rdlong	_var01, objptr
	shl	_var01, #2
	sub	objptr, ##5120
	add	_var01, objptr
	rdlong	_var01, _var01
	sub	objptr, ##694
LR__1800
' return val
	mov	result1, _var01
_hg010b_spin2_fillpop_ret
	ret

' 
'       
' pub fill(x,y,newcolor,oldcolor) | x1, spanabove, spanbelow, ov
_hg010b_spin2_fill
	mov	COUNT_, #11
	call	#pushregs_
' 
' newcolor:=newcolor & 255
	getbyte	local01, arg03, #0
' oldcolor:=oldcolor & 255
	getbyte	local02, arg04, #0
' 
' if (oldcolor == newcolor) 
	cmp	local02, local01 wz
'   return
 if_e	jmp	#LR__1819
' 
' fillptr:=0
	add	objptr, ##5814
	wrlong	#0, objptr
' fillmax:=0
	add	objptr, #4
	wrlong	#0, objptr
	sub	objptr, ##5818
' fillpush(x)
	call	#_hg010b_spin2_fillpush
' fillpush(y)
	mov	arg01, arg02
	call	#_hg010b_spin2_fillpush
' y:=fillpop()
	call	#_hg010b_spin2_fillpop
	mov	local03, result1
' x:=fillpop()
	call	#_hg010b_spin2_fillpop
	mov	local04, result1
' 'pinhigh(38)
' repeat while (x>-1)       
LR__1810
	cmps	local04, #0 wc
 if_b	jmp	#LR__1818
'  ' pintoggle(39)
'   x1 := x
	mov	local05, local04
'   repeat while((x1 >= 0) && (getpixel2(x1,y) == oldColor))
LR__1811
	mov	local06, #0
	mov	local07, #0
	cmps	local05, #0 wc
 if_ae	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
'     x1--
 if_ne	sub	local05, #1
 if_ne	jmp	#LR__1811
'   x1++
	add	local05, #1
'   spanabove := 0
	mov	local10, #0
'   spanbelow := 0
	mov	local11, #0
'   repeat while ((x1 < 1024) && getpixel2(x1,y) == oldColor)
LR__1812
	mov	local06, #0
	cmps	local05, ##1024 wc
 if_b	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
 if_e	jmp	#LR__1817
'     putpixel2 (x1,y, newcolor & 255)
	getbyte	arg03, local01, #0
	mov	arg01, local05
	mov	arg02, local03
	call	#_hg010b_spin2_putpixel2
'     if ((spanabove == 0) && (y > 0) && (getpixel2(x1,y-1)== oldColor))
	mov	local06, #0
	mov	local07, #0
	cmp	local10, #0 wz
 if_e	cmps	local03, #1 wc
 if_nc_and_z	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	sub	arg02, #1
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
 if_e	jmp	#LR__1813
'       fillpush(x1)
	mov	arg01, local05
	call	#_hg010b_spin2_fillpush
'       fillpush(y-1)
	mov	arg01, local03
	sub	arg01, #1
	call	#_hg010b_spin2_fillpush
'       spanabove := 1 
	mov	local10, #1
	jmp	#LR__1814
LR__1813
'     elseif ((spanabove<>0) && (y > 0) && (getpixel2(x1,y-1)<> oldColor))
	mov	local06, #0
	mov	local07, #0
	cmp	local10, #0 wz
 if_ne	cmps	local03, #1 wc
 if_a	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	sub	arg02, #1
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_ne	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
'       spanabove := 0 
 if_ne	mov	local10, #0
LR__1814
'     if((spanbelow == 0 ) && (y < 575) && getpixel2(x1,y+1) == oldColor)
	mov	local06, #0
	mov	local07, #0
	cmp	local11, #0 wz
 if_e	cmps	local03, ##575 wc
 if_c_and_z	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	add	arg02, #1
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
 if_e	jmp	#LR__1815
'       fillpush(x1)
	mov	arg01, local05
	call	#_hg010b_spin2_fillpush
'       fillpush(y + 1)
	mov	arg01, local03
	add	arg01, #1
	call	#_hg010b_spin2_fillpush
'       spanBelow := 1
	mov	local11, #1
	jmp	#LR__1816
LR__1815
'     elseif((spanbelow<>0) && (y < 575) && (getpixel2(x1,y + 1)<> oldColor))
	mov	local06, #0
	mov	local07, #0
	cmp	local11, #0 wz
 if_ne	cmps	local03, ##575 wc
 if_c_and_nz	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	add	arg02, #1
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_ne	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
'       spanbelow := 0
 if_ne	mov	local11, #0
LR__1816
'     x1++
	add	local05, #1
	jmp	#LR__1812
LR__1817
'   y:=fillpop()
	call	#_hg010b_spin2_fillpop
	mov	local03, result1
'   x:=fillpop()
	call	#_hg010b_spin2_fillpop
	mov	local04, result1
	jmp	#LR__1810
LR__1818
LR__1819
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_fill_ret
	ret

' 'pinlow(38)    
' 
' '-- A filled circle -----------------------------------------------------
' 
' pub fcircle(x0,y0,r,c) | d,x,y,da,db
_hg010b_spin2_fcircle
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg03
	qmul	local01, ##-2
	mov	local02, arg01
	mov	local03, arg02
	mov	local04, arg04
' 
' d:=5-4*r
	mov	arg04, local01
	shl	arg04, #2
	mov	local05, #5
	sub	local05, arg04
' x:=0
	mov	local06, #0
' y:=r
' da:=(-2*r+5)*4
' db:=3*4
	mov	local07, #12
' repeat while (x<=y) 
	getqx	local08
	add	local08, #5
	shl	local08, #2
LR__1820
	cmps	local06, local01 wcz
 if_a	jmp	#LR__1822
'   fastline(x0-x,x0+x,y0-y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local02
	add	arg02, local06
	mov	arg03, local03
	sub	arg03, local01
	mov	arg04, local04
	call	#_hg010b_spin2_fastline
'   fastline(x0-x,x0+x,y0+y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local02
	add	arg02, local06
	mov	arg03, local03
	add	arg03, local01
	mov	arg04, local04
	call	#_hg010b_spin2_fastline
'   fastline(x0-y,x0+y,y0-x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local02
	add	arg02, local01
	mov	arg03, local03
	sub	arg03, local06
	mov	arg04, local04
	call	#_hg010b_spin2_fastline
'   fastline(x0-y,x0+y,y0+x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local02
	add	arg02, local01
	mov	arg03, local03
	add	arg03, local06
	mov	arg04, local04
	call	#_hg010b_spin2_fastline
'   if d>0 
	cmps	local05, #1 wc
 if_b	jmp	#LR__1821
'     d+=da
	add	local05, local08
'     y-=1
	sub	local01, #1
'     x+=1
	add	local06, #1
'     da+=4*4
	add	local08, #16
'     db+=2*4
	add	local07, #8
	jmp	#LR__1820
LR__1821
'   else
'     d+=db
	add	local05, local07
'     x+=1
	add	local06, #1
'     da+=2*4
	add	local08, #8
'     db+=2*4
	add	local07, #8
	jmp	#LR__1820
LR__1822
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_fcircle_ret
	ret

'  
' '-- A circle ------------------------------------------------------------ 
'  
' pub circle(x0,y0,r,c) | d,x,y,da,db
_hg010b_spin2_circle
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg03
	qmul	local01, ##-2
	mov	local02, arg01
	mov	local03, arg02
	mov	local04, arg04
' 
'  
' d:=5-4*r
	mov	arg04, local01
	shl	arg04, #2
	mov	local05, #5
	sub	local05, arg04
' x:=0
	mov	local06, #0
' y:=r
' da:=(-2*r+5)*4
' db:=3*4
	mov	local07, #12
' repeat while (x<=y) 
	getqx	local08
	add	local08, #5
	shl	local08, #2
LR__1830
	cmps	local06, local01 wcz
 if_a	jmp	#LR__1832
'   putpixel(x0-x,y0-y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local03
	sub	arg02, local01
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0-x,y0+y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local03
	add	arg02, local01
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0+x,y0-y,c)
	mov	arg01, local02
	add	arg01, local06
	mov	arg02, local03
	sub	arg02, local01
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0+x,y0+y,c)
	mov	arg01, local02
	add	arg01, local06
	mov	arg02, local03
	add	arg02, local01
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0-y,y0-x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local03
	sub	arg02, local06
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0-y,y0+x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local03
	add	arg02, local06
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0+y,y0-x,c)
	mov	arg01, local02
	add	arg01, local01
	mov	arg02, local03
	sub	arg02, local06
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0+y,y0+x,c)
	mov	arg01, local02
	add	arg01, local01
	mov	arg02, local03
	add	arg02, local06
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   if d>0 
	cmps	local05, #1 wc
 if_b	jmp	#LR__1831
'     d+=da
	add	local05, local08
'     y-=1
	sub	local01, #1
'     x+=1
	add	local06, #1
'     da+=4*4
	add	local08, #16
'     db+=2*4
	add	local07, #8
	jmp	#LR__1830
LR__1831
'   else
'     d+=db
	add	local05, local07
'     x+=1
	add	local06, #1
'     da+=2*4
	add	local08, #8
'     db+=2*4
	add	local07, #8
	jmp	#LR__1830
LR__1832
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_circle_ret
	ret

'     
' '-- A frame (an empty rectangle) ---------------------------------------
' 
' pub frame(x1,y1,x2,y2,c)
_hg010b_spin2_frame
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' fastline(x1,x2,y1,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local02
	mov	arg04, local05
	call	#_hg010b_spin2_fastline
' fastline(x1,x2,y2,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local05
	call	#_hg010b_spin2_fastline
' line(x1,y1,x1,y2,c)
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local01
	mov	arg04, local04
	mov	arg05, local05
' draw(x1,y1,x2,y2,c)
	call	#_hg010b_spin2_draw
' line(x2,y1,x2,y2,c)
	mov	arg01, local03
	mov	arg02, local02
	mov	arg03, local03
	mov	arg04, local04
	mov	arg05, local05
' draw(x1,y1,x2,y2,c)
	call	#_hg010b_spin2_draw
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_frame_ret
	ret

' 
' '-- A box (a filled rectangle) ----------------------------------------
' 
' pub box(x1,y1,x2,y2,c) |yy
_hg010b_spin2_box
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' repeat yy from y1 to y2
	cmps	local04, local02 wc
	negc	local06, #1
	add	local04, local06
LR__1840
'   fastline(x1,x2,yy,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg04, local05
	mov	arg03, local02
	call	#_hg010b_spin2_fastline
	add	local02, local06
	cmp	local02, local04 wz
 if_ne	jmp	#LR__1840
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_box_ret
	ret

'       
' pub putcharxycgf(x,y,achar,f,b) |xx, yy,bb,c1,c2
_hg010b_spin2_putcharxycgf
' 
'  
' repeat yy from 0 to 15
	mov	_var01, #0
	callpa	#(@LR__1852-@LR__1850)>>2,fcache_load_ptr_
LR__1850
' 
'   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
	add	objptr, #145
	rdlong	_var02, objptr
	shl	_var02, #10
	mov	_var03, ptr__hg010b_spin2_dat__
	add	_var03, _var02
	mov	_var02, arg03
	shl	_var02, #4
	add	_var03, _var02
	add	_var03, _var01
	rdbyte	_var03, _var03
'   asm
	testb	_var03, #0 wz
 if_e	setbyte	_var04, arg04, #0
 if_ne	setbyte	_var04, arg05, #0
	testb	_var03, #1 wz
 if_e	setbyte	_var04, arg04, #1
 if_ne	setbyte	_var04, arg05, #1
	testb	_var03, #2 wz
 if_e	setbyte	_var04, arg04, #2
 if_ne	setbyte	_var04, arg05, #2
	testb	_var03, #3 wz
 if_e	setbyte	_var04, arg04, #3
 if_ne	setbyte	_var04, arg05, #3
	testb	_var03, #4 wz
 if_e	setbyte	_var05, arg04, #0
 if_ne	setbyte	_var05, arg05, #0
	testb	_var03, #5 wz
 if_e	setbyte	_var05, arg04, #1
 if_ne	setbyte	_var05, arg05, #1
	testb	_var03, #6 wz
 if_e	setbyte	_var05, arg04, #2
 if_ne	setbyte	_var05, arg05, #2
	testb	_var03, #7 wz
 if_e	setbyte	_var05, arg04, #3
 if_ne	setbyte	_var05, arg05, #3
'   
'   ccc[0]:=c1
	add	objptr, #409
	wrlong	_var04, objptr
'   ccc[1]:=c2 
	add	objptr, #4
	wrlong	_var05, objptr
'   long[mailbox0][2]:=8
	sub	objptr, #73
	rdlong	_var03, objptr
	add	_var03, #8
	wrlong	#8, _var03
'   long[mailbox0][1]:=@ccc
	add	objptr, #69
	mov	_var03, objptr
	sub	objptr, #69
	rdlong	_var02, objptr
	add	_var02, #4
	wrlong	_var03, _var02
'   long[mailbox0]:= s_buf_ptr+((y+yy)<<10+x<<2)+$f0000000   
	sub	objptr, #268
	rdlong	_var03, objptr
	mov	_var02, arg02
	add	_var02, _var01
	shl	_var02, #10
	mov	_var06, arg01
	shl	_var06, #2
	add	_var02, _var06
	add	_var03, _var02
	add	_var03, ##-268435456
	add	objptr, #268
	rdlong	_var06, objptr
	wrlong	_var03, _var06
'   repeat
LR__1851
	rdlong	_var03, objptr
	rdlong	_var02, _var03
	cmps	_var02, #0 wc
 if_b	jmp	#LR__1851
	sub	objptr, #485
	add	_var01, #1
	cmps	_var01, #16 wc
 if_b	jmp	#LR__1850
LR__1852
_hg010b_spin2_putcharxycgf_ret
	ret

' 
' 
' '**********************************************************************r***
' '                                                                        *
' ' Font related functions                                                 *
' '                                                                        *
' '*************************************************************************
' 
' ''--------- Set a font offset. TODO: remove, use byte#1 instead
' 
' pub setfontfamily(afontnum)
_hg010b_spin2_setfontfamily
' 
' font_family:=afontnum
	add	objptr, #145
	wrlong	arg01, objptr
	sub	objptr, #145
' 'if afontnum==8
' '  font_ptr:=@amiga_font
' 
' if afontnum==4
	cmp	arg01, #4 wz
'   font_ptr:=@st_font
 if_e	add	ptr__hg010b_spin2_dat__, ##4096
 if_e	add	objptr, #4
 if_e	wrlong	ptr__hg010b_spin2_dat__, objptr
 if_e	sub	objptr, #4
 if_e	sub	ptr__hg010b_spin2_dat__, ##4096
' if afontnum==0
	cmp	arg01, #0 wz
'   font_ptr:=@vga_font
 if_e	add	objptr, #4
 if_e	wrlong	ptr__hg010b_spin2_dat__, objptr
 if_e	sub	objptr, #4
_hg010b_spin2_setfontfamily_ret
	ret

' 
' '*************************************************************************
' '                                                                        *
' '  Cursor functions                                                      *
' '                                                                        *
' '*************************************************************************
' 
' 
' pub setcursorpos(x,y)
_hg010b_spin2_setcursorpos
' 
' ''---------- Set the (x,y) position of cursor
' 
' cursor_x:=x
	add	objptr, #56
	wrword	arg01, objptr
' cursor_y:=y
	add	objptr, #2
	wrbyte	arg02, objptr
' setspritepos(17,4*cursor_x,16*cursor_y )
	sub	objptr, #2
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #58
	shl	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
_hg010b_spin2_setcursorpos_ret
	ret

' 
' '*************************************************************************
' '                                                                        *
' '  VBlank functions                                                      *
' '                                                                        *
' '*************************************************************************
' 
' pub waitvbl(amount) | i
_hg010b_spin2_waitvbl
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' ''---------- Wait for start of vblank. Amount=delay in frames
' 
' repeat i from 1 to amount
	mov	local02, #1
	cmps	local01, #1 wc
	negc	local03, #1
	add	local01, local03
LR__1860
'   repeat until vblank==0
LR__1861
	add	objptr, #69
	rdlong	arg01, objptr wz
	sub	objptr, #69
 if_e	jmp	#LR__1862
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__1861
LR__1862
'   repeat until vblank==1
LR__1863
	add	objptr, #69
	rdlong	arg01, objptr
	sub	objptr, #69
	cmp	arg01, #1 wz
 if_e	jmp	#LR__1864
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__1863
LR__1864
	add	local02, local03
	cmp	local02, local01 wz
 if_ne	jmp	#LR__1860
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_waitvbl_ret
	ret

' 
' 
' pub cls(fc,bc)   :c,i
_hg010b_spin2_cls
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' c:=bc
' ram.fill(s_buf_ptr,c,4*buflen,0,1)  
	add	objptr, #217
	rdlong	arg01, objptr
	sub	objptr, #165
	rdlong	arg03, objptr
	shl	arg03, #2
	mov	arg02, local02
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5772
	call	#_psram_spin2_fill
' setwritecolors(fc,bc)
' 
' write_color:=ff
	sub	objptr, ##5763
	wrlong	local01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	local02, objptr
' cursor_x:=0
	sub	objptr, #9
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' setspritepos(17,4*cursor_x,16*cursor_y )
	sub	objptr, #2
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #58
	shl	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
' setcursorcolor(fc)
	mov	arg01, local01
	call	#_hg010b_spin2_setcursorcolor
	mov	result1, local02
	mov	result2, #0
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_cls_ret
	ret

' 
' ''---------- Output a char at the cursor position, move the cursor 
' 
' pub putchar(achar) | c,x,y,l,newcpl
_hg010b_spin2_putchar
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
' 
' if achar==10
	cmp	local01, #10 wz
'   crlf()
 if_e	call	#_hg010b_spin2_crlf
' if achar==9
	cmp	local01, #9 wz
 if_ne	jmp	#LR__1870
'   cursor_x:=(cursor_x& %11110000)+16
	add	objptr, #56
	rdword	arg03, objptr
	and	arg03, #240
	add	arg03, #16
	wrword	arg03, objptr
	sub	objptr, #56
LR__1870
'   
' if (achar<>9) && (achar<>10) 
	cmp	local01, #9 wz
 if_ne	cmp	local01, #10 wz
 if_e	jmp	#LR__1871
'   putcharxycgf(cursor_x,16*cursor_y,achar,write_color,write_background)
	add	objptr, #56
	rdword	arg01, objptr
	add	objptr, #2
	rdbyte	arg02, objptr
	shl	arg02, #4
	add	objptr, #3
	rdlong	arg04, objptr
	add	objptr, #4
	rdlong	arg05, objptr
	sub	objptr, #65
	mov	arg03, local01
	call	#_hg010b_spin2_putcharxycgf
'   cursor_x+=2
	add	objptr, #56
	rdword	local01, objptr
	add	local01, #2
	wrword	local01, objptr
	sub	objptr, #56
LR__1871
' 
' if cursor_x>=256
	add	objptr, #56
	rdword	local01, objptr
	sub	objptr, #56
	cmps	local01, #256 wc
 if_b	jmp	#LR__1873
'   cursor_x:=0
	add	objptr, #56
	wrword	#0, objptr
'   cursor_y+=1
	add	objptr, #2
	rdbyte	local01, objptr
	add	local01, #1
	wrbyte	local01, objptr
'   if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	local01, objptr
	sub	local01, #1
	sub	objptr, #195
	rdbyte	arg03, objptr
	sub	objptr, #58
	cmps	arg03, local01 wcz
 if_be	jmp	#LR__1872
'     scrollup()
	mov	arg01, #0
	mov	arg02, ##576
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup
'     cursor_y:=st_lines-1
	add	objptr, #253
	rdlong	local01, objptr
	sub	local01, #1
	sub	objptr, #195
	wrbyte	local01, objptr
	sub	objptr, #58
LR__1872
LR__1873
' setspritepos(17,4*cursor_x,16*cursor_y )
	add	objptr, #56
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #58
	shl	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putchar_ret
	ret

'     
' ''---------- Output a char at the cursor position, move the cursor, don't react for tab or lf 
' 
' pub putchar2(achar) | c,x,y,l,newcpl
_hg010b_spin2_putchar2
	mov	COUNT_, #1
	call	#pushregs_
' 
' putcharxycgf(cursor_x,16*cursor_y,achar,write_color,write_background)
	add	objptr, #56
	rdword	local01, objptr
	add	objptr, #2
	rdbyte	arg02, objptr
	shl	arg02, #4
	mov	arg03, arg01
	add	objptr, #3
	rdlong	arg04, objptr
	add	objptr, #4
	rdlong	arg05, objptr
	sub	objptr, #65
	mov	arg01, local01
	call	#_hg010b_spin2_putcharxycgf
' cursor_x+=2
	add	objptr, #56
	rdword	local01, objptr
	add	local01, #2
	wrword	local01, objptr
' if cursor_x>=256
	rdword	local01, objptr
	sub	objptr, #56
	cmps	local01, #256 wc
 if_b	jmp	#LR__1881
'   cursor_x:=0
	add	objptr, #56
	wrword	#0, objptr
'   cursor_y+=1
	add	objptr, #2
	rdbyte	local01, objptr
	add	local01, #1
	wrbyte	local01, objptr
'   if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	local01, objptr
	sub	local01, #1
	sub	objptr, #195
	rdbyte	arg05, objptr
	sub	objptr, #58
	cmps	arg05, local01 wcz
 if_be	jmp	#LR__1880
'     scrollup()
	mov	arg01, #0
	mov	arg02, ##576
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup
'     cursor_y:=st_lines-1
	add	objptr, #253
	rdlong	local01, objptr
	sub	local01, #1
	sub	objptr, #195
	wrbyte	local01, objptr
	sub	objptr, #58
LR__1880
LR__1881
' setspritepos(17,4*cursor_x,16*cursor_y ) 
	add	objptr, #56
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #58
	shl	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putchar2_ret
	ret

' ''--------- Output a string at the cursor position, move the cursor  
' 
' pub write(text) | iii,c,ncx,ncy
_hg010b_spin2_write
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' repeat iii from 0 to strsize(text)-1
	mov	local02, #0
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__1891-@LR__1890)>>2,fcache_load_ptr_
LR__1890
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__1890
LR__1891
	sub	local03, arg01
	sub	local03, #1
	cmps	local03, #0 wc
	negc	local04, #1
	add	local03, local04
LR__1892
'   putchar2(byte[text+iii])
	mov	arg01, local01
	add	arg01, local02
	rdbyte	arg01, arg01
	call	#_hg010b_spin2_putchar2
	add	local02, local04
	cmp	local02, local03 wz
 if_ne	jmp	#LR__1892
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_write_ret
	ret

' 
' ''-----------  Scroll the screen one line up
' 
' pub scrollup(start=0, end=576 , amount=16) | i
_hg010b_spin2_scrollup
	mov	COUNT_, #1
	call	#pushregs_
' 	
' repeat i from 0 to 559 
	mov	local01, #0
LR__1900
	add	objptr, #245
	rdlong	arg04, objptr
	sub	objptr, #28
	rdlong	arg02, objptr
	mov	arg01, local01
	add	arg01, #16
	shl	arg01, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg01, arg03
'   ram.read1($80000-4096-1024-s_debug, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
	mov	arg01, ##519168
	sub	arg01, arg04
	shl	arg03, #2
	add	objptr, ##5587
	getqx	arg04
	add	arg02, arg04
	call	#_psram_spin2_read1
	sub	objptr, ##5579
	rdlong	arg04, objptr
	sub	objptr, #28
	rdlong	arg02, objptr
	mov	arg01, local01
	shl	arg01, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg01, arg03
'   ram.write($80000-4096-1024-s_debug, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
	mov	arg01, ##519168
	sub	arg01, arg04
	shl	arg03, #2
	add	objptr, ##5587
	getqx	arg04
	add	arg02, arg04
	call	#_psram_spin2_write
	sub	objptr, ##5824
	add	local01, #1
	cmps	local01, ##560 wc
 if_b	jmp	#LR__1900
' 
' repeat i from 560 to 575
	mov	local01, ##560
LR__1901
'    fastline(0,1023,i,write_background)   
	add	objptr, #65
	rdlong	arg04, objptr
	sub	objptr, #65
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local01
	call	#_hg010b_spin2_fastline
	add	local01, #1
	cmp	local01, ##576 wc
 if_b	jmp	#LR__1901
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_scrollup_ret
	ret

' 
' ''----------- Set cursor at the first character in a new line, scroll if needed 
' 
' pub crlf()
_hg010b_spin2_crlf
' 
' cursor_x:=leading_spaces*2
	add	objptr, ##690
	rdlong	arg03, objptr
	shl	arg03, #1
	sub	objptr, ##634
	wrword	arg03, objptr
' cursor_y+=1
	add	objptr, #2
	rdbyte	arg03, objptr
	add	arg03, #1
	wrbyte	arg03, objptr
' if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #195
	rdbyte	arg02, objptr
	sub	objptr, #58
	cmps	arg02, arg03 wcz
 if_be	jmp	#LR__1910
'   scrollup()
	mov	arg01, #0
	mov	arg02, ##576
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup
'   cursor_y:=st_lines-1
	add	objptr, #253
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #195
	wrbyte	arg03, objptr
	sub	objptr, #58
LR__1910
' setspritepos(17,4*cursor_x,16*cursor_y )  
	add	objptr, #56
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #58
	shl	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
_hg010b_spin2_crlf_ret
	ret

' 
' 
' '*************************************************************************
' '                                                                        *
' '  Conversions                                                           *
' '                                                                        *
' '*************************************************************************
' 
' ''---------- Convert a integer to dec string, return a pointer
' 
' pub inttostr(i):result |q,pos,k,j
_hg010b_spin2_inttostr
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01 wz
' 
' j:=i
' pos:=10
	mov	local02, #10
' k:=0
	mov	local03, #0
' 
' if (j==0)
 if_ne	jmp	#LR__1920
'   n_string[0]:=48
	add	objptr, #73
	wrbyte	#48, objptr
'   n_string[1]:=0
	add	objptr, #1
	wrbyte	#0, objptr
	sub	objptr, #74
	jmp	#LR__1927
LR__1920
' 
' else
'   if (j<0)
	abs	local01, local01 wc
'     j:=0-j
'     k:=45
 if_b	mov	local03, #45
' 
'   n_string[11]:=0
	add	objptr, #84
	wrbyte	#0, objptr
	sub	objptr, #84
	callpa	#(@LR__1922-@LR__1921)>>2,fcache_load_ptr_
'   repeat while (pos>-1)
LR__1921
	cmps	local02, #0 wc
 if_b	jmp	#LR__1923
	abs	result1, local01 wc
	qdiv	result1, #10
'     q:=j//10
	getqy	result1
	negc	result1, result1
	abs	local01, local01 wc
	qdiv	local01, #10
'     q:=48+q
	add	result1, #48
'     n_string[pos]:=q
	mov	local01, local02
	add	objptr, #73
	add	local01, objptr
	wrbyte	result1, local01
'     j:=j/10
	sub	objptr, #73
'     pos-=1
	sub	local02, #1
	getqx	local01
	negc	local01, local01
	jmp	#LR__1921
LR__1922
LR__1923
'   repeat while n_string[0]==48
LR__1924
	add	objptr, #73
	rdbyte	arg03, objptr
	sub	objptr, #73
	cmp	arg03, #48 wz
 if_ne	jmp	#LR__1925
'     bytemove(@n_string,@n_string+1,12)
	add	objptr, #73
	mov	arg01, objptr
	mov	arg02, objptr
	sub	objptr, #73
	add	arg02, #1
	mov	arg03, #12
	call	#__system____builtin_memmove
	jmp	#LR__1924
LR__1925
' 
'   if k==45
	cmp	local03, #45 wz
 if_ne	jmp	#LR__1926
'      bytemove(@n_string+1,@n_string,12)
	add	objptr, #73
	mov	arg01, objptr
	add	arg01, #1
	mov	arg02, objptr
	sub	objptr, #73
	mov	arg03, #12
	call	#__system____builtin_memmove
'      n_string[0]:=k
	add	objptr, #73
	wrbyte	local03, objptr
	sub	objptr, #73
LR__1926
LR__1927
' 
' q:=@n_string
	add	objptr, #73
	mov	result1, objptr
	sub	objptr, #73
' return q
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_inttostr_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB startx(freq, burst, delay, desiredcog) : result | driverAddr
_psram_spin2_startx
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	mov	local03, arg04
'     stop() ' restart driver if required
	call	#_psram_spin2_stop
	cmp	local01, #0 wz
 if_e	rdlong	local01, #20
	abs	arg02, local01 wc
	qdiv	arg02, ##1000000
' 
'     ' use current frequency if none specified
' 
'     if freq == 0 
'         freq := clkfreq 
' 
'     ' compute the device burst size including overheads to keep CS low time below 8us
' 
'     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
'     if burst < 0
'         return ERR_TOO_SLOW ' P2 frequency is too low for any 8us transfers
	getqx	arg02
	negc	arg04, arg02
	shl	arg04, #3
	sub	arg04, #132
	shr	arg04, #4
	shl	arg04, #4
	cmps	arg04, #0 wc
 if_b	neg	result1, #14
 if_b	jmp	#LR__1933
' 
'     ' compute the input delay
' 
'     if delay <= 0
	cmps	local02, #1 wc
 if_ae	jmp	#LR__1930
'         delay := lookupDelay(freq)
	mov	arg01, local01
	call	#_psram_spin2_lookupDelay
	mov	local02, result1
	jmp	#LR__1931
LR__1930
'     else
'         delay <#= $f ' limit to 15
	fles	local02, #15
LR__1931
' 
'     ' create our lock
' 
'     driverlock := LOCKNEW()  
	mov	result1, #0
	locknew	result1
	add	ptr__psram_spin2_dat__, #260
	wrlong	result1, ptr__psram_spin2_dat__
'     if driverlock == -1
	sub	ptr__psram_spin2_dat__, #260
	cmp	result1, ##-1 wz
'         return ERR_NO_LOCK
 if_e	neg	result1, #26
 if_e	jmp	#LR__1933
' 
'     ' patch in the proper data and HUB addresses to the startup structure
' 
'     long[@startupData][0]:=clkfreq
	rdlong	local01, #20
	add	ptr__psram_spin2_dat__, #296
	wrlong	local01, ptr__psram_spin2_dat__
' '    long[@startupData][1]:=$1000_0000
'     long[@startupData][5]:=@deviceData
	add	ptr__psram_spin2_dat__, #32
	mov	local01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #32
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #20
	wrlong	local01, arg02
'     long[@startupData][6]:=@qosData
	add	ptr__psram_spin2_dat__, #160
	mov	local01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #160
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #24
	wrlong	local01, arg02
'     long[@startupData][7]:=$7FF00
	mov	local01, ptr__psram_spin2_dat__
	add	local01, #28
	wrlong	##524032, local01
' 
'     ' setup some default bank and QoS parameter values
' 
'     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
	add	ptr__psram_spin2_dat__, #32
	mov	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #328
	shl	arg04, #16
	shl	local02, #12
	or	arg04, local02
	or	arg04, #24
	mov	arg02, arg04
	mov	arg03, #2
	call	#\builtin_longfill_
'     longfill(@qosData, $FFFF0000, 8)
	add	ptr__psram_spin2_dat__, #456
	mov	arg03, #7
	setq	arg03
	wrlong	##-65536, ptr__psram_spin2_dat__
' 
'     ' get the address of the PSRAM memory driver so we can start it
' 
'     driverAddr:= driver.getDriverAddr()
'     return @driver_start
	add	ptr__psram16drv_spin2_dat__, #32
	mov	arg02, ptr__psram16drv_spin2_dat__
	sub	ptr__psram16drv_spin2_dat__, #32
' 
'     ' start the PSRAM memory driver and wait for it to complete initialization
' 
'     if desiredcog < 0
	cmps	local03, #0 wc
'         desiredcog := NEWCOG
 if_b	mov	local03, #16
'     drivercog := coginit(desiredcog, driverAddr, @startupData)
	sub	ptr__psram_spin2_dat__, #160
	mov	local04, local03
	setq	ptr__psram_spin2_dat__
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
	sub	ptr__psram_spin2_dat__, #40
	wrlong	local04, ptr__psram_spin2_dat__
'     repeat until long[@startupData] == 0 
	add	ptr__psram_spin2_dat__, #40
LR__1932
	rdlong	local04, ptr__psram_spin2_dat__ wz
 if_ne	jmp	#LR__1932
' 
'     return drivercog
	sub	ptr__psram_spin2_dat__, #40
	rdlong	result1, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
LR__1933
	mov	ptra, fp
	call	#popregs_
_psram_spin2_startx_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB stop() : i
_psram_spin2_stop
	mov	_var01, #0
'     if drivercog <> -1
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	arg01, ##-1 wz
 if_e	jmp	#LR__1943
'         cogstop(drivercog) ' a rather brutal stop
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cogstop	arg01
	callpa	#(@LR__1942-@LR__1940)>>2,fcache_load_ptr_
'         repeat i from 0 to 7
LR__1940
'             if long[$7FF00][i*3] < 0
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##524032
	rdlong	result1, result1
	cmps	result1, #0 wc
 if_ae	jmp	#LR__1941
'                 long[$7FF00][i*3] := -ERR_ABORTED ' abort request
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##524032
	wrlong	#16, result1
LR__1941
	add	_var01, #1
	cmps	_var01, #8 wc
 if_b	jmp	#LR__1940
LR__1942
'         drivercog := -1
	add	ptr__psram_spin2_dat__, #256
	wrlong	##-1, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
LR__1943
'     if driverlock <> -1
	add	ptr__psram_spin2_dat__, #260
	rdlong	_var02, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #260
	cmp	_var02, ##-1 wz
'         LOCKRET(driverlock)
 if_ne	add	ptr__psram_spin2_dat__, #260
 if_ne	rdlong	arg01, ptr__psram_spin2_dat__
 if_ne	lockret	arg01
'         driverlock := -1
 if_ne	wrlong	##-1, ptr__psram_spin2_dat__
 if_ne	sub	ptr__psram_spin2_dat__, #260
	mov	result1, _var01
_psram_spin2_stop_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB read1(dstHubAddr, srcAddr, count) : result | mailbox
_psram_spin2_read1
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__1951
'     if count == 0 ' don't even bother reading
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__1951
'     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	mov	_var02, ##524032
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__1951
'     long[mailbox][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox][1] := dstHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox] := driver.R_READBURST + (srcAddr & $1ffffff) ' trigger burst read operation
	mov	_var03, arg02
	bitl	_var03, #217
	mov	_var01, ##-1342177280
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__1950
'         result := long[mailbox]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__1950
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__1951
_psram_spin2_read1_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB write(srcHubAddr, dstAddr, count) : result | mailbox
_psram_spin2_write
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__1961
'     if count == 0 ' don't even bother writing
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__1961
'     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	mov	_var02, ##524032
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__1961
'     long[mailbox][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox][1] := srcHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
	mov	_var03, arg02
	bitl	_var03, #217
	mov	_var01, ##-268435456
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__1960
'         result := long[mailbox]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__1960
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__1961
_psram_spin2_write_ret
	ret

' 
' ' generalized fill
' PUB fill(addr, pattern, count, listPtr, datasize) : r | mailbox, req
_psram_spin2_fill
	mov	_var01, arg01
	mov	_var02, arg02
	mov	_var03, arg03
	mov	_var04, arg05
'     case datasize 
	sub	_var04, #1
	fle	_var04, #4
	jmprel	_var04
LR__1970
	jmp	#LR__1971
	jmp	#LR__1972
	jmp	#LR__1974
	jmp	#LR__1973
	jmp	#LR__1974
LR__1971
'         1: req := driver.R_WRITEBYTE
	mov	_var05, ##-1073741824
	jmp	#LR__1975
LR__1972
'         2: req := driver.R_WRITEWORD
	mov	_var05, ##-805306368
	jmp	#LR__1975
LR__1973
'         4: req := driver.R_WRITELONG
	mov	_var05, ##-536870912
	jmp	#LR__1975
LR__1974
'         other : return ERR_INVALID
	neg	result1, #6
	jmp	#LR__1977
LR__1975
'     if count == 0   ' nothing to do
	cmp	_var03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__1977
'     if drivercog == -1
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var04, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var04, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__1977
'     mailbox := $7FF00 + 12*cogid() ' get mailbox base address for this COG
	mov	result1, #0
	cogid	result1
	mov	_var04, result1
	shl	_var04, #1
	add	_var04, result1
	shl	_var04, #2
	mov	_var06, ##524032
	add	_var06, _var04
'     if long[mailbox] < 0
	rdlong	_var04, _var06
	cmps	_var04, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__1977
'     long[mailbox][2] := count
	add	_var06, #8
	wrlong	_var03, _var06
'     long[mailbox][1] := pattern
	sub	_var06, #4
	wrlong	_var02, _var06
	sub	_var06, #4
'     long[mailbox] := req + (addr & $fffffff)
	mov	_var07, _var05
	mov	_var08, _var01
	bitl	_var08, #124
	add	_var07, _var08
	wrlong	_var07, _var06
'     repeat
LR__1976
'         r := long[mailbox]
	rdlong	_var08, _var06
	cmps	_var08, #0 wc
 if_b	jmp	#LR__1976
'     while r < 0
'     return -r                  ' return 0 for success or negated error code
	neg	result1, _var08
LR__1977
_psram_spin2_fill_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB setQos(cog, qos) : result | mailbox
_psram_spin2_setQos
	mov	_var01, arg01
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var02, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var02, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__1984
'     if cog < 0 or cog > 7 ' enforce cog id range
	cmps	_var01, #0 wc
 if_b	jmp	#LR__1980
	cmps	_var01, #8 wc
 if_b	jmp	#LR__1981
LR__1980
'         return ERR_INVALID
	neg	result1, #6
	jmp	#LR__1984
LR__1981
'     long[@qosData][cog] := qos & !$1ff
	andn	arg02, #511
	add	ptr__psram_spin2_dat__, #456
	shl	_var01, #2
	add	_var01, ptr__psram_spin2_dat__
	wrlong	arg02, _var01
'     mailbox := $7FF00 + drivercog*12
	sub	ptr__psram_spin2_dat__, #200
	rdlong	_var03, ptr__psram_spin2_dat__
	mov	_var04, _var03
	shl	_var04, #1
	add	_var04, _var03
	shl	_var04, #2
	mov	_var05, ##524032
	add	_var05, _var04
'     repeat until LOCKTRY(driverlock)
	add	ptr__psram_spin2_dat__, #4
LR__1982
	rdlong	arg01, ptr__psram_spin2_dat__
	locktry	arg01 wc
 if_ae	jmp	#LR__1982
	sub	ptr__psram_spin2_dat__, #260
'     long[mailbox] := driver.R_CONFIG + cogid()
	mov	_var04, #0
	cogid	_var04
	mov	_var02, ##-268435456
	add	_var02, _var04
	wrlong	_var02, _var05
'     repeat while long[mailbox] < 0
LR__1983
	rdlong	_var02, _var05
	cmps	_var02, #0 wc
 if_b	jmp	#LR__1983
'     LOCKREL(driverlock)
	add	ptr__psram_spin2_dat__, #260
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #260
	lockrel	arg01 wc
	mov	result1, #0
LR__1984
_psram_spin2_setQos_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PRI lookupDelay(freq) : delay | profile
_psram_spin2_lookupDelay
'     profile := @delayTable
	add	ptr__psram_spin2_dat__, #264
	mov	_var01, ptr__psram_spin2_dat__
'     delay := long[profile][0]
	rdlong	_var02, _var01
'     repeat while long[profile][1] 
	sub	ptr__psram_spin2_dat__, #264
	callpa	#(@LR__1991-@LR__1990)>>2,fcache_load_ptr_
LR__1990
	add	_var01, #4
	rdlong	result1, _var01 wz
	sub	_var01, #4
 if_e	jmp	#LR__1992
'         if freq +< long[profile][1] 
	add	_var01, #4
	rdlong	result1, _var01
	sub	_var01, #4
	cmp	arg01, result1 wc
'             quit
'         profile += 4
 if_ae	add	_var01, #4
'         delay++
 if_ae	add	_var02, #1
 if_ae	jmp	#LR__1990
LR__1991
LR__1992
	mov	result1, _var02
_psram_spin2_lookupDelay_ret
	ret

' 
' PUB start() : r
_usbnew_spin2_start
	mov	_var01, #0
'   ifnot driver_cog
	add	ptr__usbnew_spin2_dat__, ##10827
	rdbyte	_var02, ptr__usbnew_spin2_dat__ wz
	sub	ptr__usbnew_spin2_dat__, ##10827
 if_ne	jmp	#LR__2000
'     r := coginit(COGEXEC_NEW,@usb_host_start,0)
	mov	arg02, ptr__usbnew_spin2_dat__
	mov	_var01, #16
	mov	arg03, #0
	setq	arg03
	coginit	_var01, arg02 wc
 if_b	neg	_var01, #1
'     if r >= 0
	cmps	_var01, #0 wc
'       driver_cog := r+1
 if_ae	mov	_var02, _var01
 if_ae	add	_var02, #1
 if_ae	add	ptr__usbnew_spin2_dat__, ##10827
 if_ae	wrbyte	_var02, ptr__usbnew_spin2_dat__
 if_ae	sub	ptr__usbnew_spin2_dat__, ##10827
LR__2000
	mov	result1, _var01
_usbnew_spin2_start_ret
	ret

'     '' Set KEYQUEUE_SIZE to enable (recommended value: 32)
' 
' '' Return key event from buffer if there is one
' PUB get_key() : r | tail
_usbnew_spin2_get_key
'   tail := keyq_tail
	add	ptr__usbnew_spin2_dat__, ##7881
	rdbyte	_var01, ptr__usbnew_spin2_dat__
'   if keyq_head == tail
	sub	ptr__usbnew_spin2_dat__, #1
	rdbyte	_var02, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7880
	cmp	_var02, _var01 wz
'     return 0 ' No event
 if_e	mov	result1, #0
 if_e	jmp	#_usbnew_spin2_get_key_ret
'   r := keyq_data[tail]
	mov	_var02, _var01
	shl	_var02, #2
	add	ptr__usbnew_spin2_dat__, ##7882
	add	_var02, ptr__usbnew_spin2_dat__
	rdlong	result1, _var02
'   if ++tail == KEYQUEUE_SIZE
	add	_var01, #1
	cmp	_var01, #128 wz
'     tail := 0
 if_e	mov	_var01, #0
'   keyq_tail := tail
	sub	ptr__usbnew_spin2_dat__, #1
	wrbyte	_var01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7881
_usbnew_spin2_get_key_ret
	ret

' 
' '' Emulate mouse movement
' PUB mouse_move(x,y)
_usbnew_spin2_mouse_move
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'   mouse_lock := 1
	add	ptr__usbnew_spin2_dat__, ##10421
	wrbyte	#1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10421
'   waitus(2) ' hope driver is now done
	mov	arg01, #2
	call	#__system___waitus
'   mouse_xacc := x
	add	ptr__usbnew_spin2_dat__, ##10405
	wrlong	local01, ptr__usbnew_spin2_dat__
'   mouse_yacc := y
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	local02, ptr__usbnew_spin2_dat__
'   if mouse_outptr
	sub	ptr__usbnew_spin2_dat__, ##2533
	rdlong	arg02, ptr__usbnew_spin2_dat__ wz
	sub	ptr__usbnew_spin2_dat__, ##7876
 if_e	jmp	#LR__2010
'     long[mouse_outptr] := y << 16 | x & $FFFF
	shl	local02, #16
	getword	local01, local01, #0
	or	local02, local01
	add	ptr__usbnew_spin2_dat__, ##7876
	rdlong	local01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7876
	wrlong	local02, local01
LR__2010
'   mouse_lock := 0
	add	ptr__usbnew_spin2_dat__, ##10421
	wrbyte	#0, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10421
	mov	ptra, fp
	call	#popregs_
_usbnew_spin2_mouse_move_ret
	ret

'     '' Set HAVE_HIDPAD to enable.
'     '' Warning: never pass a device ID larger or equal than MAX_DEVICES
' 
' '' Get VID/PID pair for connected device. 0 means disconnected
' PUB hidpad_id(dev) : r
_usbnew_spin2_hidpad_id
'   return long[@hidpad_report+dev*HIDPAD_REPORT_SIZE][0]
	add	ptr__usbnew_spin2_dat__, ##10200
	mov	result1, ptr__usbnew_spin2_dat__
	mov	_var01, arg01
	shl	_var01, #3
	sub	_var01, arg01
	shl	_var01, #2
	add	result1, _var01
	rdlong	result1, result1
	sub	ptr__usbnew_spin2_dat__, ##10200
_usbnew_spin2_hidpad_id_ret
	ret

' 
' '' Get all button states for a device
' PUB hidpad_buttons(dev) : r 
_usbnew_spin2_hidpad_buttons
'   return long[@hidpad_report+dev*HIDPAD_REPORT_SIZE][5]
	add	ptr__usbnew_spin2_dat__, ##10200
	mov	result1, ptr__usbnew_spin2_dat__
	mov	_var01, arg01
	shl	_var01, #3
	sub	_var01, arg01
	shl	_var01, #2
	add	result1, _var01
	add	result1, #20
	rdlong	result1, result1
	sub	ptr__usbnew_spin2_dat__, ##10200
_usbnew_spin2_hidpad_buttons_ret
	ret

' 
' '' Get state of an axis (normalized between -32768 and 32767)
' PUB hidpad_axis(dev,axnum) : r
_usbnew_spin2_hidpad_axis
'   if axnum +>= 6
	cmp	arg02, #6 wc
'     return 0
 if_ae	mov	result1, #0
 if_ae	jmp	#_usbnew_spin2_hidpad_axis_ret
'   else 
'     return word[@hidpad_report+dev*HIDPAD_REPORT_SIZE][4+axnum] signx 15
	add	ptr__usbnew_spin2_dat__, ##10200
	mov	result1, ptr__usbnew_spin2_dat__
	mov	_var01, arg01
	shl	_var01, #3
	sub	_var01, arg01
	shl	_var01, #2
	add	result1, _var01
	mov	_var01, #4
	add	_var01, arg02
	shl	_var01, #1
	add	_var01, result1
	rdword	result1, _var01
	signx	result1, #15
	sub	ptr__usbnew_spin2_dat__, ##10200
_usbnew_spin2_hidpad_axis_ret
	ret

' 
' 
' '--------------------------------------------------------------
' '---------- Init the variables, start the cog. ----------------
' '--------------------------------------------------------------
' 
' pub start(mbox,scope,cache) :cog,base | iii
_Audio093b_8_sc_spin2_start
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' ' mbox: PSRAM mailbox or 0 if no PSRAM
' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
' 
' mailboxaddr:=mbox 
	wrlong	local01, objptr
' scope_ptr:=scope
	add	objptr, #4
	wrlong	arg02, objptr
' cache_ptr:=cache
	add	objptr, #4
	wrlong	arg03, objptr
' base:=@channel1[0]
	add	objptr, #4
	mov	local02, objptr
' 
' repeat iii from 0 to 7
	mov	local03, #0
	add	ptr__Audio093b_8_sc_spin2_dat__, ##1156
	sub	objptr, #12
	callpa	#(@LR__2021-@LR__2020)>>2,fcache_load_ptr_
LR__2020
'   long[base+64*iii]:=0
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	wrlong	#0, local01
'   long[base+64*iii+4]:=0
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	add	local01, #4
	wrlong	#0, local01
'   long[base+64*iii+12]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #12
	wrlong	#0, local04
'   long[base+64*iii+16]:=2 
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #16
	wrlong	#2, local04
'   word[base+64*iii+20]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #20
	wrword	#0, local04
'   word[base+64*iii+22]:=8192
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #22
	wrword	##8192, local04
'   word[base+64*iii+24]:=4000+2*iii
	mov	local04, local03
	shl	local04, #1
	mov	local01, ##4000
	add	local01, local04
	mov	local04, local02
	mov	result2, local03
	shl	result2, #6
	add	local04, result2
	add	local04, #24
	wrword	local01, local04
'   word[base+64*iii+26]:=2
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #26
	wrword	#2, local04
'   long [base+64*iii+8]:=@null | $C0000000
	mov	local01, ptr__Audio093b_8_sc_spin2_dat__
	bith	local01, #62
	mov	local04, local02
	mov	arg03, local03
	shl	arg03, #6
	add	local04, arg03
	add	local04, #8
	wrlong	local01, local04
'   long[base+64*iii+32]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #32
	wrlong	#0, local04
'   long[base+64*iii+36]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #36
	wrlong	#0, local04
'   long[base+64*iii+40]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #40
	wrlong	#0, local04
'   long[base+64*iii+44]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #44
	wrlong	#0, local04
	add	local03, #1
	cmps	local03, #8 wc
 if_b	jmp	#LR__2020
LR__2021
	sub	ptr__Audio093b_8_sc_spin2_dat__, ##1156
'   
' cog:=coginit(16,@audio,@mailboxaddr)
	mov	arg02, ptr__Audio093b_8_sc_spin2_dat__
	mov	arg03, objptr
	mov	local04, #16
	setq	arg03
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
' waitms(100)
	mov	arg01, #100
	call	#__system___waitms
' return cog,base
	mov	result2, local02
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_Audio093b_8_sc_spin2_start_ret
	ret

' 
' ' a simple play procedure to not poke everything. 
' 
' pub play(channel,sample,splfreq,vol,len,loop=-1) |base2
_Audio093b_8_sc_spin2_play
	add	objptr, #12
	mov	_var01, objptr
	shl	arg01, #6
	add	_var01, arg01
	add	arg02, ##-1073741824
	mov	arg01, _var01
	add	arg01, #8
	wrlong	arg02, arg01
	mov	arg02, _var01
	add	arg02, #12
	wrlong	arg05, arg02
	cmps	arg06, #0 wc
 if_ae	mov	arg02, _var01
 if_ae	add	arg02, #16
 if_ae	wrlong	arg06, arg02
 if_b	add	arg05, #2
 if_b	mov	arg01, _var01
 if_b	add	arg01, #16
 if_b	wrlong	arg05, arg01
	abs	arg02, arg03 wc
	qdiv	##3546911, arg02
' 
' base2:=@channel1[0]+64*channel
' long[base2+8]:=sample+$C0000000 
' long[base2+12]:= len
' if loop >=0 
'   long[base2+16]:= loop
	sub	objptr, #12
' else
'   long[base2+16]:= len+2
' word[base2+20]:=vol
	mov	arg02, _var01
	add	arg02, #20
	wrword	arg04, arg02
' word[base2+24]:= 3546911/splfreq 
	mov	arg01, _var01
	add	arg01, #24
' word[base2+26]:=256 ' todo: use skip to make accurate sample rate
' long[base2+28]:=$40000000
	getqx	arg02
	negc	arg02, arg02
	wrword	arg02, arg01
	mov	arg02, _var01
	add	arg02, #26
	wrword	#256, arg02
	add	_var01, #28
	wrlong	##1073741824, _var01
_Audio093b_8_sc_spin2_play_ret
	ret

' until (i >>8) >=len
' 
' pub play8(channel,sample,splfreq,vol,len,loop=-1) |base2,i
_Audio093b_8_sc_spin2_play8
' 
' base2:=@channel1[0]+64*channel
	add	objptr, #12
	mov	_var01, objptr
	shl	arg01, #6
	add	_var01, arg01
' long[base2]:=0
	wrlong	#0, _var01
' long[base2+8]:=sample+$40000000 
	add	arg02, ##1073741824
	mov	arg01, _var01
	add	arg01, #8
	wrlong	arg02, arg01
' if loop>=0
	cmps	arg06, #0 wc
	sub	objptr, #12
 if_b	jmp	#LR__2030
'   long[base2+12]:=loop
	mov	arg02, _var01
	add	arg02, #12
	wrlong	arg06, arg02
'   long[base2+16]:= len
	mov	arg06, _var01
	add	arg06, #16
	wrlong	arg05, arg06
	jmp	#LR__2031
LR__2030
' else
'   long[base2+12]:= len
	mov	arg06, _var01
	add	arg06, #12
	wrlong	arg05, arg06
'   long[base2+16]:= len+1
	add	arg05, #1
	mov	arg01, _var01
	add	arg01, #16
	wrlong	arg05, arg01
LR__2031
	abs	arg03, arg03 wc
	qdiv	##3546911, arg03
' word[base2+20]:=vol
	mov	arg03, _var01
	add	arg03, #20
	wrword	arg04, arg03
' word[base2+24]:= 3546911/splfreq 
	mov	arg01, _var01
	add	arg01, #24
' word[base2+26]:=256 ' todo: use skip to make accurate sample rate
' long[base2+28]:=$40000000
	getqx	arg04
	negc	arg04, arg04
	wrword	arg04, arg01
	mov	arg04, _var01
	add	arg04, #26
	wrword	#256, arg04
	add	_var01, #28
	wrlong	##1073741824, _var01
_Audio093b_8_sc_spin2_play8_ret
	ret

' 
'     
' pub stop(channel) 'silence it
_Audio093b_8_sc_spin2_stop
' 
' word[@channel1[0]+64*channel+20]:=0
	add	objptr, #12
	mov	_var01, objptr
	shl	arg01, #6
	add	_var01, arg01
	add	_var01, #20
	wrword	#0, _var01
	sub	objptr, #12
_Audio093b_8_sc_spin2_stop_ret
	ret
hubexit
	jmp	#cogexit

__system___setbaud
	rdlong	muldiva_, #20
	mov	muldivb_, arg01
	call	#divide_
	callpa	#(@LR__2041-@LR__2040)>>2,fcache_load_ptr_
LR__2040
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__2040
LR__2041
	dirl	#62
	dirl	#63
	wrlong	muldivb_, ptr___system__dat__
	shl	muldivb_, #16
	mov	arg02, #7
	add	arg02, muldivb_
	wrpin	#124, #62
	wxpin	arg02, #62
	wrpin	#62, #63
	add	arg02, #20
	wxpin	arg02, #63
	dirh	#62
	dirh	#63
__system___setbaud_ret
	ret

__system___txraw
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	callpa	#(@LR__2051-@LR__2050)>>2,fcache_load_ptr_
LR__2050
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__2050
LR__2051
	rdlong	result1, ptr___system__dat__ wz
 if_e	mov	arg01, ##230400
 if_e	call	#__system___setbaud
	drvl	#62
	wypin	local01, #62
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___txraw_ret
	ret

__system___rxraw
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, ptr___system__dat__ wz
 if_e	mov	arg01, ##230400
 if_e	call	#__system___setbaud
	cmp	local01, #0 wz
 if_e	jmp	#LR__2060
	rdlong	local03, #20
	shr	local03, #10
	qmul	local01, local03
	getct	result1
	getqx	local04
	add	result1, local04
	mov	local05, result1
	jmp	#LR__2061
LR__2060
	mov	local05, #0
LR__2061
	neg	local06, #1
	mov	local07, #63
	mov	local08, #0
	add	ptr___system__dat__, #4
	rdlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
LR__2062
	testb	local09, #8 wc
	testbn	local09, #9 andc
	shr	local09, #10
 if_b	mov	local08, #1
 if_ae	testp	#63 wz
 if_nc_and_z	mov	local08, #1
 if_nc_and_z	rdpin	local09, #63
 if_nc_and_z	shr	local09, #4
LR__2063
	mov	local02, #0
	cmp	local08, #0 wz
 if_ne	neg	local02, #1
	mov	local10, #0
	mov	local03, #0
	cmp	local01, #0 wz
 if_ne	neg	local03, #1
	mov	local04, #0
	mov	local11, #0
	getct	result1
	mov	local12, result1
	mov	local13, local12
	sub	local13, local05
	cmps	local13, #0 wc
 if_b	not	local11, #0
	cmp	local11, #0 wz
 if_ne	not	local04, #0
	test	local03, local04 wz
 if_ne	not	local10, #0
	or	local02, local10 wz
 if_e	jmp	#LR__2062
	cmp	local08, #0 wz
 if_ne	mov	local06, local09
 if_ne	getbyte	local06, local06, #0
	add	ptr___system__dat__, #4
	wrlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___rxraw_ret
	ret

__system___getus
	getct	result2 wc
	getct	_var01
	add	ptr___system__dat__, #16
	rdlong	_var02, ptr___system__dat__ wz
	sub	ptr___system__dat__, #16
 if_ne	jmp	#LR__2070
	rdlong	_var02, #20
	qdiv	_var02, ##1000000
	add	ptr___system__dat__, #16
	getqx	result1
	mov	_var02, result1
	wrlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #16
LR__2070
	qdiv	result2, _var02
	getqy	result2
	setq	result2
	qdiv	_var01, _var02
	getqx	result1
__system___getus_ret
	ret

__system____builtin_memmove
	mov	_var01, arg01
	cmps	arg01, arg02 wc
 if_b	jmp	#LR__2080
	mov	_var02, arg02
	add	_var02, arg03
	cmps	arg01, _var02 wc
 if_b	jmp	#LR__2086
LR__2080
	mov	_var03, arg03
	shr	_var03, #2 wz
 if_e	jmp	#LR__2085
	callpa	#(@LR__2083-@LR__2081)>>2,fcache_load_ptr_
LR__2081
	rep	@LR__2084, _var03
LR__2082
	rdlong	_var03, arg02
	wrlong	_var03, arg01
	add	arg01, #4
	add	arg02, #4
LR__2083
LR__2084
LR__2085
	test	arg03, #2 wz
 if_ne	rdword	_var02, arg02
 if_ne	wrword	_var02, arg01
 if_ne	add	arg01, #2
 if_ne	add	arg02, #2
	test	arg03, #1 wz
 if_ne	rdbyte	_var02, arg02
 if_ne	wrbyte	_var02, arg01
	jmp	#LR__2092
LR__2086
	add	arg01, arg03
	add	arg02, arg03
	mov	_var04, arg03 wz
 if_e	jmp	#LR__2091
	callpa	#(@LR__2089-@LR__2087)>>2,fcache_load_ptr_
LR__2087
	rep	@LR__2090, _var04
LR__2088
	sub	arg01, #1
	sub	arg02, #1
	rdbyte	_var02, arg02
	wrbyte	_var02, arg01
LR__2089
LR__2090
LR__2091
LR__2092
	mov	result1, _var01
__system____builtin_memmove_ret
	ret

__system____builtin_strcpy
	mov	_var01, arg01
	callpa	#(@LR__2101-@LR__2100)>>2,fcache_load_ptr_
LR__2100
	rdbyte	result1, arg02 wz
	wrbyte	result1, arg01
	add	arg02, #1
	add	arg01, #1
 if_ne	jmp	#LR__2100
LR__2101
	mov	result1, _var01
__system____builtin_strcpy_ret
	ret

__system____topofstack
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	add	fp, #4
	wrlong	arg01, fp
	mov	result1, fp
	sub	fp, #4
	mov	ptra, fp
	call	#popregs_
__system____topofstack_ret
	ret

__system___lockmem
	mov	result1, #0
	cogid	result1
	add	result1, #256
LR__2110
	rdlong	_var01, arg01 wz
 if_e	wrlong	result1, arg01
 if_e	rdlong	_var01, arg01
 if_e	rdlong	_var01, arg01
	cmp	_var01, result1 wz
 if_ne	jmp	#LR__2110
__system___lockmem_ret
	ret

__system___string_cmp
	callpa	#(@LR__2121-@LR__2120)>>2,fcache_load_ptr_
LR__2120
	rdbyte	_var01, arg01
	rdbyte	_var02, arg02
	mov	_var03, _var01
	sub	_var03, _var02 wz
	add	arg01, #1
	add	arg02, #1
 if_ne	jmp	#LR__2122
	cmp	_var01, #0 wz
 if_ne	cmp	_var02, #0 wz
 if_ne	jmp	#LR__2120
LR__2121
LR__2122
	mov	result1, _var03
__system___string_cmp_ret
	ret

__system___string_concat
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__2131-@LR__2130)>>2,fcache_load_ptr_
LR__2130
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__2130
LR__2131
	sub	local03, arg01
	mov	local04, local03
	mov	arg01, local02
	mov	local03, arg01
	callpa	#(@LR__2133-@LR__2132)>>2,fcache_load_ptr_
LR__2132
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__2132
LR__2133
	sub	local03, arg01
	mov	arg01, local04
	add	arg01, local03
	add	arg01, #1
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__2134
	mov	arg01, local05
	mov	arg02, local01
	mov	arg03, local04
	call	#__system____builtin_memmove
	mov	arg01, local05
	add	arg01, local04
	add	local03, #1
	mov	arg02, local02
	mov	arg03, local03
	call	#__system____builtin_memmove
LR__2134
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
__system___string_concat_ret
	ret

__system___tx
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	cmp	local01, #10 wz
 if_ne	jmp	#LR__2140
	add	ptr___system__dat__, #8
	rdlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	local02, #2 wz
 if_ne	mov	arg01, #13
 if_ne	call	#__system___txraw
LR__2140
	mov	arg01, local01
	call	#__system___txraw
	mov	ptra, fp
	call	#popregs_
__system___tx_ret
	ret

__system___rx
	mov	COUNT_, #1
	call	#pushregs_
LR__2150
	mov	arg01, #0
	call	#__system___rxraw
	mov	local01, result1
	cmp	local01, ##-1 wz
 if_e	jmp	#LR__2150
	cmp	local01, #13 wz
 if_ne	jmp	#LR__2151
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	result1, #2 wz
 if_ne	mov	local01, #10
LR__2151
	add	ptr___system__dat__, #8
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	arg01, #1 wz
 if_e	jmp	#LR__2154
	cmp	local01, #127 wz
 if_ne	jmp	#LR__2152
	mov	arg01, #8
	call	#__system___tx
	jmp	#LR__2153
LR__2152
	mov	arg01, local01
	call	#__system___tx
LR__2153
LR__2154
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system___rx_ret
	ret

__system___pinwrite
	mov	_var01, arg01
	and	_var01, #31
	test	arg01, #32 wz
	shr	arg01, #6
	bmask	arg01, arg01
	shl	arg01, _var01
	shl	arg02, _var01
 if_e	jmp	#LR__2160
	or	dirb, arg01
	mov	_var01, outb
	andn	_var01, arg01
	and	arg02, arg01
	or	_var01, arg02
	mov	outb, _var01
	jmp	#LR__2161
LR__2160
	or	dira, arg01
	mov	_var01, outa
	andn	_var01, arg01
	and	arg02, arg01
	or	_var01, arg02
	mov	outa, _var01
LR__2161
__system___pinwrite_ret
	ret

__system___basic_read_line
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	mov	local03, #24
	mov	local04, #0
	mov	arg01, #24
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__2173
LR__2170
	mov	arg01, local01
	call	#__system___basic_get_char
	mov	local06, result1
	cmps	local06, #1 wc
 if_b	jmp	#LR__2172
	cmp	local06, #10 wz
 if_ne	jmp	#LR__2171
	cmp	local04, #0 wz
 if_ne	cmps	local02, #1 wc
 if_a	sub	local02, #1
	jmp	#LR__2172
LR__2171
	cmp	local06, #13 wz
 if_e	mov	local04, #1
 if_ne	mov	local04, #0
	cmp	local06, #8 wz
 if_ne	cmp	local06, #127 wz
 if_e	cmps	local02, #1 wc
 if_nc_and_z	sub	local02, #1
 if_e	jmp	#LR__2170
	mov	arg03, local05
	add	arg03, local02
	wrbyte	local06, arg03
	add	local02, #1
	cmp	local02, local03 wz
 if_ne	jmp	#LR__2170
	mov	arg01, local03
	add	arg01, #32
	call	#__system___gc_alloc_managed
	mov	local06, result1 wz
 if_e	mov	result1, local06
 if_e	jmp	#LR__2173
	mov	arg01, local06
	mov	arg02, local05
	mov	arg03, local03
	call	#__system____builtin_memmove
	add	local03, #32
	mov	arg01, local05
	call	#__system___gc_free
	mov	local05, local06
	jmp	#LR__2170
LR__2172
	mov	local06, local05
	add	local06, local02
	wrbyte	#0, local06
	mov	result1, local05
LR__2173
	mov	ptra, fp
	call	#popregs_
__system___basic_read_line_ret
	ret

__system___waitms
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__2181-@LR__2180)>>2,fcache_load_ptr_
LR__2180
	cmps	_var01, ##1000 wc
 if_b	jmp	#LR__2182
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000
	jmp	#LR__2180
LR__2181
LR__2182
	cmps	_var01, #1 wc
 if_b	jmp	#LR__2183
	qmul	_var01, _var03
	mov	arg03, ##1000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	arg01
	addct1	arg01, _var02
	waitct1
LR__2183
__system___waitms_ret
	ret

__system___waitus
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__2191-@LR__2190)>>2,fcache_load_ptr_
LR__2190
	cmps	_var01, ##1000000 wc
 if_b	jmp	#LR__2192
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000000
	jmp	#LR__2190
LR__2191
LR__2192
	cmps	_var01, #1 wc
 if_b	jmp	#LR__2193
	qmul	_var01, _var03
	mov	arg03, ##1000000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	result1
	addct1	_var02, result1
	waitct1
LR__2193
__system___waitus_ret
	ret

__system___mount
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	neg	local03, #1
 if_e	neg	result1, #1
 if_e	jmp	#LR__2215
	rdbyte	result1, local01
	cmp	result1, #47 wz
 if_ne	jmp	#LR__2202
	mov	arg01, local01
	mov	local04, arg01
	callpa	#(@LR__2201-@LR__2200)>>2,fcache_load_ptr_
LR__2200
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__2200
LR__2201
	sub	local04, arg01
	mov	result1, local04
	cmps	result1, #16 wc
 if_b	jmp	#LR__2203
LR__2202
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__2215
LR__2203
	mov	local05, #0
LR__2204
	cmps	local05, #4 wc
 if_ae	jmp	#LR__2209
	mov	arg01, local05
	shl	arg01, #2
	add	ptr___system__dat__, #100
	add	arg01, ptr___system__dat__
	rdlong	result1, arg01 wz
	sub	ptr___system__dat__, #100
 if_e	cmps	local03, #0 wc
 if_c_and_z	mov	local03, local05
 if_c_and_z	jmp	#LR__2208
	mov	arg01, local05
	shl	arg01, #2
	add	ptr___system__dat__, #100
	add	arg01, ptr___system__dat__
	rdlong	arg01, arg01
	sub	ptr___system__dat__, #100
	mov	local04, arg01
	callpa	#(@LR__2206-@LR__2205)>>2,fcache_load_ptr_
LR__2205
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__2205
LR__2206
	sub	local04, arg01
	mov	local06, local04
	mov	arg01, local06
	add	arg01, local01
	rdbyte	result1, arg01
	cmp	result1, #47 wz
 if_ne	mov	local07, local06
 if_ne	add	local07, local01
 if_ne	rdbyte	arg01, local07 wz
 if_ne	jmp	#LR__2207
	mov	arg03, local05
	shl	arg03, #2
	add	ptr___system__dat__, #100
	add	arg03, ptr___system__dat__
	rdlong	arg02, arg03
	mov	arg01, local01
	mov	arg03, local06
	sub	ptr___system__dat__, #100
	call	#__system__strncmp
	cmp	result1, #0 wz
 if_e	mov	local03, local05
 if_e	jmp	#LR__2209
LR__2207
LR__2208
	add	local05, #1
	jmp	#LR__2204
LR__2209
	cmp	local03, ##-1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#11, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__2215
	mov	local05, local03
	mov	local07, local05
	shl	local07, #2
	add	ptr___system__dat__, #116
	add	local07, ptr___system__dat__
	rdlong	local06, local07 wz
	sub	ptr___system__dat__, #116
 if_e	jmp	#LR__2210
	add	local06, #76
	rdlong	local07, local06 wz
	sub	local06, #76
 if_e	jmp	#LR__2210
	add	local06, #76
	rdlong	local07, local06
	mov	local03, local07
	zerox	local07, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	local06, local05
	shl	local06, #2
	add	ptr___system__dat__, #100
	add	local06, ptr___system__dat__
	rdlong	arg01, local06
	mov	local06, objptr
	mov	objptr, local07
	sub	ptr___system__dat__, #100
	call	local03
	mov	objptr, local06
LR__2210
	mov	local08, local05
	shl	local08, #2
	add	ptr___system__dat__, #116
	add	local08, ptr___system__dat__
	wrlong	local02, local08
	cmp	local02, #0 wz
	sub	ptr___system__dat__, #116
 if_ne	jmp	#LR__2211
	shl	local05, #2
	add	ptr___system__dat__, #100
	add	local05, ptr___system__dat__
	wrlong	#0, local05
	sub	ptr___system__dat__, #100
	jmp	#LR__2214
LR__2211
	mov	local09, local05
	shl	local09, #4
	add	ptr___system__dat__, #36
	add	local09, ptr___system__dat__
	mov	arg01, local09
	mov	arg02, local01
	mov	arg03, #16
	sub	ptr___system__dat__, #36
	call	#__system__strncpy
	add	local02, #72
	rdlong	local08, local02 wz
	sub	local02, #72
 if_e	jmp	#LR__2213
	add	local02, #72
	rdlong	local08, local02
	mov	local10, local08
	zerox	local08, #19
	shr	local10, #20
	shl	local10, #2
	add	local10, __methods__
	rdlong	local10, local10
	mov	arg01, local09
	mov	local11, objptr
	mov	objptr, local08
	call	local10
	mov	objptr, local11
	mov	arg01, result1 wz
 if_e	jmp	#LR__2212
	mov	local08, local05
	shl	local08, #2
	add	ptr___system__dat__, #116
	add	local08, ptr___system__dat__
	wrlong	#0, local08
	shl	local05, #2
	sub	ptr___system__dat__, #16
	add	local05, ptr___system__dat__
	wrlong	#0, local05
	neg	arg01, arg01 wz
	sub	ptr___system__dat__, #68
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__2215
LR__2212
LR__2213
	shl	local05, #2
	add	ptr___system__dat__, #100
	add	local05, ptr___system__dat__
	wrlong	local09, local05
	sub	ptr___system__dat__, #100
LR__2214
	mov	result1, #0
LR__2215
	mov	ptra, fp
	call	#popregs_
__system___mount_ret
	ret

__system___chdir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #64
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg02, fp
	sub	fp, #8
	call	#__system__stat
	add	fp, #60
	wrlong	result1, fp
	sub	fp, #60
	cmp	result1, #0 wz
 if_ne	add	fp, #60
 if_ne	rdlong	result1, fp
 if_ne	sub	fp, #60
 if_ne	jmp	#LR__2222
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	and	arg01, ##61440
	cmp	arg01, ##4096 wz
 if_ne	add	ptr___system__dat__, #32
 if_ne	wrlong	#13, ptr___system__dat__
 if_ne	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__2222
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	rdbyte	arg03, arg03
	cmp	arg03, #47 wz
 if_ne	jmp	#LR__2220
	add	ptr___system__dat__, #132
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #132
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #256
	call	#__system__strncpy
	jmp	#LR__2221
LR__2220
	add	ptr___system__dat__, #388
	mov	arg01, ptr___system__dat__
	add	fp, #56
	wrlong	arg01, fp
	sub	fp, #56
	sub	ptr___system__dat__, #256
	mov	arg02, ptr___system__dat__
	sub	ptr___system__dat__, #132
	mov	arg03, #256
	call	#__system__strncpy
	add	fp, #56
	rdlong	arg01, fp
	sub	fp, #52
	rdlong	arg02, fp
	sub	fp, #4
	add	ptr___system__dat__, #132
	mov	arg03, ptr___system__dat__
	sub	ptr___system__dat__, #132
	call	#__system____getvfsforfile
LR__2221
	mov	result1, #0
LR__2222
	mov	ptra, fp
	call	#popregs_
__system___chdir_ret
	ret

__system____getvfsforfile
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	callpa	#(@LR__2231-@LR__2230)>>2,fcache_load_ptr_
LR__2230
	rdbyte	result1, local02
	cmp	result1, #47 wz
 if_e	add	local02, #1
 if_e	rdbyte	local04, local02
 if_e	sub	local02, #1
 if_e	cmp	local04, #47 wz
 if_e	add	local02, #1
 if_e	jmp	#LR__2230
LR__2231
	rdbyte	local04, local02
	cmp	local04, #47 wz
 if_ne	jmp	#LR__2232
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncpy
	jmp	#LR__2234
LR__2232
	add	ptr___system__dat__, #132
	mov	arg02, ptr___system__dat__
	sub	ptr___system__dat__, #132
	mov	arg01, local01
	mov	arg03, #256
	call	#__system__strncpy
	rdbyte	local04, local02 wz
 if_e	jmp	#LR__2233
	rdbyte	local04, local02
	cmp	local04, #46 wz
 if_e	add	local02, #1
 if_e	rdbyte	local05, local02
 if_e	sub	local02, #1
 if_e	mov	local06, local05
 if_e	zerox	local06, #7 wz
 if_e	jmp	#LR__2233
	rdbyte	local05, local01
	cmp	local05, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local04, local01
 if_e	sub	local01, #1
 if_e	cmps	local04, #0 wz
 if_ne	mov	arg02, ##@LR__4280
 if_ne	mov	arg01, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncat
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncat
LR__2233
LR__2234
	mov	arg01, local01
	call	#__system___normalizeName
	rdbyte	local04, local01 wz
 if_e	jmp	#LR__2235
	rdbyte	local04, local01
	cmp	local04, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local06, local01
 if_e	sub	local01, #1
 if_e	cmps	local06, #0 wz
 if_ne	jmp	#LR__2236
LR__2235
	add	ptr___system__dat__, ##644
	mov	result1, ptr___system__dat__
	sub	ptr___system__dat__, ##644
	jmp	#LR__2250
LR__2236
	mov	local07, #0
LR__2237
	cmps	local07, #4 wc
 if_ae	jmp	#LR__2249
	mov	local06, local07
	shl	local06, #2
	add	ptr___system__dat__, #100
	add	local06, ptr___system__dat__
	rdlong	local06, local06 wz
	sub	ptr___system__dat__, #100
 if_e	jmp	#LR__2248
	mov	local04, local07
	shl	local04, #2
	add	ptr___system__dat__, #100
	add	local04, ptr___system__dat__
	rdlong	arg01, local04
	sub	ptr___system__dat__, #100
	mov	local08, arg01
	callpa	#(@LR__2239-@LR__2238)>>2,fcache_load_ptr_
LR__2238
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__2238
LR__2239
	sub	local08, arg01
	mov	local09, local08
	mov	local04, local09
	add	local04, local01
	rdbyte	local06, local04
	cmp	local06, #47 wz
 if_ne	mov	local10, local09
 if_ne	add	local10, local01
 if_ne	rdbyte	local05, local10 wz
 if_ne	jmp	#LR__2247
	mov	arg03, local07
	shl	arg03, #2
	add	ptr___system__dat__, #100
	add	arg03, ptr___system__dat__
	rdlong	arg02, arg03
	mov	arg03, local09
	mov	arg01, local01
	sub	ptr___system__dat__, #100
	call	#__system__strncmp
	cmps	result1, #0 wz
 if_ne	jmp	#LR__2247
	mov	local11, local07
	shl	local11, #2
	add	ptr___system__dat__, #116
	add	local11, ptr___system__dat__
	rdlong	local12, local11
	sub	ptr___system__dat__, #116
	callpa	#(@LR__2241-@LR__2240)>>2,fcache_load_ptr_
LR__2240
	mov	local06, local09
	add	local06, #1
	add	local06, local01
	rdbyte	local11, local06
	cmp	local11, #46 wz
 if_ne	jmp	#LR__2242
	mov	local11, local09
	add	local11, #2
	add	local11, local01
	rdbyte	local10, local11
	cmp	local10, #47 wz
 if_ne	mov	local13, local09
 if_ne	add	local13, #2
 if_ne	add	local13, local01
 if_ne	rdbyte	local14, local13 wz
 if_e	add	local09, #1
 if_e	jmp	#LR__2240
LR__2241
LR__2242
	cmp	local03, #0 wz
 if_ne	mov	arg01, local03
 if_ne	mov	arg02, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncpy
	mov	arg02, local01
	add	arg02, local09
	add	arg02, #1
	mov	arg01, local01
	call	#__system____builtin_strcpy
	mov	arg01, local01
	mov	local08, arg01
	callpa	#(@LR__2244-@LR__2243)>>2,fcache_load_ptr_
LR__2243
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__2243
LR__2244
	sub	local08, arg01
	mov	local09, local08
LR__2245
	cmps	local09, #1 wc
 if_b	jmp	#LR__2246
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #47 wz
 if_e	mov	local11, local09
 if_e	add	local11, local01
 if_e	wrbyte	#0, local11
 if_e	sub	local09, #1
 if_e	jmp	#LR__2245
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #46 wz
 if_ne	jmp	#LR__2246
	cmps	local09, #2 wc
 if_b	jmp	#LR__2246
	mov	local14, local09
	sub	local14, #1
	add	local14, local01
	rdbyte	local05, local14
	cmp	local05, #47 wz
 if_ne	jmp	#LR__2246
	mov	local04, local09
	sub	local04, #1
	add	local04, local01
	wrbyte	#0, local04
	sub	local09, #2
	jmp	#LR__2245
LR__2246
	mov	result1, local12
	jmp	#LR__2250
LR__2247
LR__2248
	add	local07, #1
	jmp	#LR__2237
LR__2249
	add	ptr___system__dat__, ##1848
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, ##1848
LR__2250
	mov	ptra, fp
	call	#popregs_
__system____getvfsforfile_ret
	ret

__system___basic_open
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	mov	local04, #0
	call	#__system____getftab
	mov	local05, result1 wz
 if_ne	jmp	#LR__2260
	mov	arg01, abortchain
	mov	arg02, #12
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__2269
LR__2260
	add	local05, #8
	rdlong	result1, local05 wz
	sub	local05, #8
 if_ne	mov	arg01, local05
 if_ne	call	#__system___closeraw
	cmp	local01, #0 wz
 if_e	cmp	local02, #0 wz
 if_e	cmp	local03, #0 wz
 if_e	jmp	#LR__2262
	mov	arg01, #12
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_ne	jmp	#LR__2261
	mov	arg01, abortchain
	mov	arg02, #7
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__2269
LR__2261
	wrlong	#0, local04
	add	local04, #4
	wrlong	#0, local04
	sub	local04, #4
	wrlong	local04, local05
LR__2262
	cmp	local01, #0 wz
 if_e	jmp	#LR__2263
	wrlong	local01, local04
	mov	result1, local04
	or	result1, ##103809024
	add	local05, #28
	wrlong	result1, local05
	sub	local05, #28
	jmp	#LR__2264
LR__2263
	add	local05, #28
	wrlong	#0, local05
	sub	local05, #28
LR__2264
	cmp	local02, #0 wz
 if_e	jmp	#LR__2265
	add	local04, #4
	wrlong	local02, local04
	sub	local04, #4
	mov	result1, local04
	or	result1, ##104857600
	add	local05, #32
	wrlong	result1, local05
	sub	local05, #32
	jmp	#LR__2266
LR__2265
	add	local05, #32
	wrlong	#0, local05
	sub	local05, #32
LR__2266
	cmp	local03, #0 wz
 if_e	jmp	#LR__2267
	add	local04, #8
	wrlong	local03, local04
	sub	local04, #8
	or	local04, ##105906176
	add	local05, #36
	wrlong	local04, local05
	sub	local05, #36
	jmp	#LR__2268
LR__2267
	add	local05, #36
	wrlong	#0, local05
	sub	local05, #36
LR__2268
	add	local05, #8
	wrlong	#7, local05
	mov	result1, #0
LR__2269
	mov	ptra, fp
	call	#popregs_
__system___basic_open_ret
	ret

__system___basic_open_string
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	call	#__system____getftab
	mov	local03, result1 wz
 if_ne	jmp	#LR__2270
	mov	arg01, abortchain
	mov	arg02, #12
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__2272
LR__2270
	add	local03, #8
	rdlong	arg04, local03 wz
	sub	local03, #8
 if_ne	mov	arg01, local03
 if_ne	call	#__system___closeraw
	mov	arg02, local01
	mov	arg03, local02
	mov	arg01, local03
	mov	arg04, #438
	call	#__system___openraw
	mov	local04, result1
	cmps	local04, #0 wc
 if_ae	jmp	#LR__2271
	add	ptr___system__dat__, #32
	rdlong	arg02, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	arg01, abortchain
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__2272
LR__2271
	mov	result1, local04
LR__2272
	mov	ptra, fp
	call	#popregs_
__system___basic_open_string_ret
	ret

__system___basic_print_char
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	call	#__system___gettxfunc
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__2280
	mov	local03, local02
	zerox	local02, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local02
	call	local03
	mov	objptr, local01
	mov	result1, #1
LR__2280
	mov	ptra, fp
	call	#popregs_
__system___basic_print_char_ret
	ret

__system___basic_print_string
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	call	#__system___gettxfunc
	mov	local03, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__2290
	cmp	local01, #0 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local03
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	call	#__system___fmtstr
LR__2290
	mov	ptra, fp
	call	#popregs_
__system___basic_print_string_ret
	ret

__system___basic_print_integer
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	call	#__system___gettxfunc
	mov	local04, result1 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local04
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	mov	arg04, local03
 if_ne	call	#__system___fmtnum
	mov	ptra, fp
	call	#popregs_
__system___basic_print_integer_ret
	ret

__system___basic_print_unsigned
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	call	#__system___gettxfunc
	mov	arg01, result1 wz
 if_e	mov	result1, #0
 if_ne	bith	local02, #58
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	mov	arg04, local03
 if_ne	call	#__system___fmtnum
	mov	ptra, fp
	call	#popregs_
__system___basic_print_unsigned_ret
	ret

__system___basic_get_char
	mov	COUNT_, #3
	call	#pushregs_
	call	#__system___getrxfunc
	mov	local01, result1 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__2300
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
LR__2300
	mov	ptra, fp
	call	#popregs_
__system___basic_get_char_ret
	ret

__system___basic_get
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg05
	qmul	arg04, local01
	mov	local02, arg01
	mov	local03, arg03
	cmp	arg02, #0 wz
 if_ne	sub	arg02, #1
 if_ne	mov	arg01, local02
 if_ne	mov	arg03, #0
	getqx	local04
 if_ne	call	#__system__lseek
	mov	arg02, local03
	mov	arg03, local04
	mov	arg01, local02
	call	#__system__read
	mov	local04, result1
	cmps	local04, #1 wc
 if_b	jmp	#LR__2310
	mov	muldiva_, local04
	mov	muldivb_, local01
	call	#divide_
	mov	local04, muldivb_
LR__2310
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
__system___basic_get_ret
	ret

__system___fmtchar
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	getbyte	arg03, arg03, #0
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #4
	mov	arg03, fp
	sub	fp, #12
	call	#__system___fmtstr
	mov	ptra, fp
	call	#popregs_
__system___fmtchar_ret
	ret

__system___fmtstr
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg04, local02, #0
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__2321-@LR__2320)>>2,fcache_load_ptr_
LR__2320
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__2320
LR__2321
	sub	local04, arg01
	cmp	arg04, #0 wz
 if_ne	fles	local04, arg04 wcz
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #2
	call	#__system___fmtpad
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	mov	result1, local05
 if_b	jmp	#LR__2324
	cmps	local04, #1 wc
 if_b	jmp	#LR__2323
	mov	local06, local04
LR__2322
	mov	local07, local01
	mov	local08, local01
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	rdbyte	arg01, local03
	mov	local09, objptr
	mov	objptr, local07
	add	local03, #1
	call	local08
	mov	objptr, local09
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_b	jmp	#LR__2324
	add	local05, local09
	djnz	local06, #LR__2322
LR__2323
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #1
	call	#__system___fmtpad
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_ae	add	local05, local09
 if_ae	mov	result1, local05
LR__2324
	mov	ptra, fp
	call	#popregs_
__system___fmtstr_ret
	ret

__system___fmtnum
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, ptra
	mov	local06, local05
	mov	local07, #0
	mov	local08, local02
	shr	local08, #16
	and	local08, #63
	getbyte	local09, local02, #0
	mov	local10, local02
	shr	local10, #26
	and	local10, #3
	mov	local11, local10
	cmps	local08, #1 wc
	add	ptra, #68
 if_ae	sub	local08, #1
	cmps	local09, #65 wc
 if_b	cmp	local09, #0 wz
 if_nc_or_z	mov	local09, #64
	cmp	local11, #3 wz
 if_e	mov	local11, #0
 if_ne	cmps	local03, #0 wc
 if_c_and_nz	mov	local11, #4
 if_c_and_nz	neg	local03, local03
	cmp	local11, #0 wz
 if_e	jmp	#LR__2333
	mov	local07, #1
	cmp	local08, local09 wz
 if_ne	jmp	#LR__2331
	djnz	local08, #LR__2330
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #35
	call	#__system___fmtchar
	jmp	#LR__2337
LR__2330
LR__2331
	cmp	local11, #2 wz
 if_e	mov	local10, local06
 if_e	add	local06, #1
 if_e	wrbyte	#32, local10
 if_e	jmp	#LR__2332
	cmp	local11, #4 wz
 if_e	wrbyte	#45, local06
 if_e	add	local06, #1
 if_ne	wrbyte	#43, local06
 if_ne	add	local06, #1
LR__2332
LR__2333
	mov	arg01, local06
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local08
	mov	arg05, #0
	testbn	local02, #29 wz
 if_ne	mov	arg05, #1
	call	#__system___uitoa
	add	local07, result1
	cmps	local07, local09 wcz
 if_be	jmp	#LR__2336
	callpa	#(@LR__2335-@LR__2334)>>2,fcache_load_ptr_
LR__2334
	mov	local10, local09
	cmps	local10, #1 wc
	sub	local09, #1
 if_ae	mov	local10, local06
 if_ae	add	local06, #1
 if_ae	wrbyte	#35, local10
 if_ae	jmp	#LR__2334
LR__2335
	wrbyte	#0, local06
LR__2336
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local05
	call	#__system___fmtstr
LR__2337
	mov	ptra, fp
	call	#popregs_
__system___fmtnum_ret
	ret

__system___fmtfloat
	mov	COUNT_, #16
	call	#pushregs_
	add	ptra, #292
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #12
	wrlong	#10, fp
	add	fp, #8
	wrlong	#0, fp
	add	fp, #8
	wrlong	#0, fp
	add	fp, #8
	wrlong	#0, fp
	add	fp, #4
	wrlong	#2, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #24
	wrlong	#0, fp
	add	fp, #104
	mov	local01, fp
	sub	fp, #8
	wrlong	local01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #188
	rdlong	local01, fp
	shr	local01, #16
	and	local01, #63
	add	fp, #176
	wrlong	local01, fp
	sub	fp, #176
	rdlong	local01, fp
	shr	local01, #28
	and	local01, #1
	add	fp, #264
	wrlong	local01, fp
	sub	fp, #88
	rdlong	local01, fp wz
	sub	fp, #184
 if_ne	jmp	#LR__2341
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #97 wz
 if_ne	jmp	#LR__2340
	add	fp, #184
	wrlong	#13, fp
	sub	fp, #132
	wrlong	#1, fp
	sub	fp, #52
	jmp	#LR__2342
LR__2340
	add	fp, #184
	wrlong	#6, fp
	sub	fp, #184
	jmp	#LR__2342
LR__2341
	add	fp, #184
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #184
LR__2342
	add	fp, #8
	rdlong	local01, fp
	shr	local01, #22
	and	local01, #3
	add	fp, #260
	wrlong	local01, fp
	sub	fp, #260
	rdlong	local01, fp
	shr	local01, #29
	and	local01, #1
	add	fp, #180
	wrlong	local01, fp
	sub	fp, #180
	rdlong	local01, fp
	getbyte	local01, local01, #1
	add	fp, #96
	wrlong	local01, fp
	sub	fp, #96
	rdlong	local01, fp
	getbyte	local01, local01, #0
	add	fp, #100
	wrlong	local01, fp
	mov	local01, #0
	sub	fp, #92
	rdlong	arg05, fp
	cmp	arg05, #101 wz
 if_e	mov	local01, #1
	add	fp, #20
	wrlong	local01, fp
	add	fp, #152
	rdlong	local02, fp wz
 if_ne	mov	local01, #69
 if_e	mov	local01, #101
	sub	fp, #140
	wrlong	local01, fp
	sub	fp, #32
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #97 wz
 if_ne	jmp	#LR__2343
	add	fp, #36
	wrlong	#1, fp
	add	fp, #152
	rdlong	local02, fp wz
 if_ne	mov	local01, #80
 if_e	mov	local01, #112
	sub	fp, #140
	wrlong	local01, fp
	sub	fp, #20
	wrlong	#2, fp
	add	fp, #28
	wrlong	#1, fp
	add	fp, #132
	rdlong	local02, fp wz
 if_ne	mov	local01, #88
 if_e	mov	local01, #120
	sub	fp, #124
	wrlong	local01, fp
	sub	fp, #64
LR__2343
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #35 wz
 if_ne	jmp	#LR__2346
	add	fp, #72
	wrlong	#1, fp
	add	fp, #200
	rdlong	local01, fp wz
	sub	fp, #272
 if_e	jmp	#LR__2344
	add	fp, #16
	wrlong	#102, fp
	add	fp, #256
	wrlong	#0, fp
	sub	fp, #272
	jmp	#LR__2345
LR__2344
	add	fp, #272
	wrlong	#1, fp
	sub	fp, #272
LR__2345
LR__2346
	add	fp, #8
	rdlong	local01, fp
	shr	local01, #26
	and	local01, #3
	add	fp, #92
	wrlong	local01, fp
	sub	fp, #88
	rdlong	result1, fp
	sub	fp, #12
	shr	result1, #31 wz
 if_e	jmp	#LR__2347
	add	fp, #44
	wrlong	#45, fp
	sub	fp, #32
	rdlong	result1, fp
	bitnot	result1, #31
	wrlong	result1, fp
	sub	fp, #12
	jmp	#LR__2349
LR__2347
	add	fp, #100
	rdlong	local01, fp
	sub	fp, #100
	cmp	local01, #1 wz
 if_e	add	fp, #44
 if_e	wrlong	#43, fp
 if_e	sub	fp, #44
 if_e	jmp	#LR__2348
	add	fp, #100
	rdlong	local01, fp
	sub	fp, #100
	cmp	local01, #2 wz
 if_e	add	fp, #44
 if_e	wrlong	#32, fp
 if_e	sub	fp, #44
LR__2348
LR__2349
	add	fp, #8
	rdlong	local01, fp
	shr	local01, #24
	and	local01, #3
	add	fp, #60
	wrlong	local01, fp
	mov	local01, #0
	sub	fp, #24
	rdlong	local03, fp wz
	sub	fp, #44
 if_ne	jmp	#LR__2350
	add	fp, #28
	rdlong	local04, fp
	sub	fp, #28
	mov	local05, local04
	cmp	local05, #10 wz
 if_e	jmp	#LR__2351
LR__2350
	xor	local01, #1
LR__2351
	add	fp, #60
	wrlong	local01, fp
	sub	fp, #60
	cmp	local01, #0 wz
 if_e	jmp	#LR__2353
	add	fp, #68
	rdlong	local05, fp
	sub	fp, #68
	mov	local03, local05
	cmp	local03, #2 wz
 if_ne	jmp	#LR__2353
	add	fp, #268
	rdlong	local06, fp
	sub	fp, #268
	mov	local04, local06
	cmp	local04, #2 wz
 if_e	jmp	#LR__2353
	add	fp, #192
	rdlong	arg01, fp
	sub	fp, #148
	rdlong	arg02, fp
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #64
	call	#__system__emitsign_0385
	add	fp, #276
	wrlong	result1, fp
	sub	fp, #276
	cmps	result1, #0 wc
 if_b	add	fp, #276
 if_b	rdlong	result1, fp
 if_b	sub	fp, #276
 if_b	jmp	#LR__2403
	add	fp, #192
	rdlong	local01, fp
	add	fp, #84
	rdlong	local05, fp
	mov	local03, local05
	add	local01, local05
	sub	fp, #84
	wrlong	local01, fp
	sub	fp, #88
	rdlong	local01, fp wz
	sub	fp, #104
 if_e	jmp	#LR__2352
	add	fp, #104
	rdlong	local01, fp
	add	fp, #172
	rdlong	local03, fp
	sub	local01, local03
	sub	fp, #172
	wrlong	local01, fp
	sub	fp, #104
	cmps	local01, #0 wc
 if_b	add	fp, #104
 if_b	wrlong	#0, fp
 if_b	sub	fp, #104
	add	fp, #8
	rdlong	local01, fp
	bitl	local01, #232
	wrlong	local01, fp
	add	fp, #96
	rdlong	local05, fp
	mov	local03, local05
	shl	local03, #8
	or	local01, local03
	sub	fp, #96
	wrlong	local01, fp
	sub	fp, #8
LR__2352
	add	fp, #60
	wrlong	#0, fp
	sub	fp, #60
LR__2353
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system____builtin_ilogb
	cmp	result1, ##2147483647 wz
 if_ne	jmp	#LR__2355
	add	fp, #44
	rdlong	local01, fp wz
	sub	fp, #44
 if_e	jmp	#LR__2354
	add	fp, #192
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #148
	rdlong	local04, fp
	sub	fp, #44
	wrbyte	local04, local02
LR__2354
	add	fp, #192
	rdlong	arg01, fp
	sub	fp, #192
	mov	arg02, ##@LR__4281
	call	#__system____builtin_strcpy
	jmp	#LR__2391
LR__2355
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	mov	arg01, local02
	call	#__system____builtin_ilogb
	cmp	result1, ##-2147483648 wz
 if_ne	jmp	#LR__2357
	add	fp, #44
	rdlong	local01, fp wz
	sub	fp, #44
 if_e	jmp	#LR__2356
	add	fp, #192
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #148
	rdlong	local04, fp
	sub	fp, #44
	wrbyte	local04, local02
LR__2356
	add	fp, #192
	rdlong	arg01, fp
	sub	fp, #192
	mov	arg02, ##@LR__4282
	call	#__system____builtin_strcpy
	jmp	#LR__2391
LR__2357
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #103 wz
 if_ne	add	fp, #16
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #16
 if_ne	cmp	local03, #35 wz
 if_ne	jmp	#LR__2362
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	add	fp, #152
	rdlong	arg04, fp
	sub	fp, #156
	rdlong	arg05, fp
	sub	fp, #28
	call	#__system__disassemble_0383
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #35 wz
 if_ne	jmp	#LR__2359
	add	fp, #32
	rdlong	local01, fp
	add	fp, #152
	rdlong	local03, fp
	sub	fp, #184
	cmps	local01, local03 wcz
 if_a	add	fp, #36
 if_a	wrlong	#1, fp
 if_a	sub	fp, #36
 if_a	jmp	#LR__2365
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmps	local01, #0 wc
 if_ae	jmp	#LR__2358
	add	fp, #184
	rdlong	local01, fp
	neg	local01, local01
	sub	fp, #152
	rdlong	local03, fp
	sub	fp, #32
	cmps	local03, local01 wcz
 if_be	add	fp, #36
 if_be	wrlong	#1, fp
 if_be	sub	fp, #36
	jmp	#LR__2365
LR__2358
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmps	local01, #1 wc
 if_b	jmp	#LR__2365
	add	fp, #184
	rdlong	local01, fp
	sub	fp, #152
	rdlong	local03, fp
	sub	local01, local03
	add	fp, #152
	wrlong	local01, fp
	sub	fp, #184
	jmp	#LR__2365
LR__2359
	mov	local01, #0
	add	fp, #8
	rdlong	local02, fp
	shr	local02, #28
	and	local02, #1 wz
 if_e	mov	local01, #1
	add	fp, #44
	wrlong	local01, fp
	sub	fp, #20
	rdlong	local01, fp
	add	fp, #152
	rdlong	local03, fp
	sub	fp, #184
	cmps	local01, local03 wc
 if_ae	jmp	#LR__2360
	add	fp, #32
	rdlong	local04, fp
	sub	fp, #32
	cmps	local04, ##-4 wc
 if_ae	jmp	#LR__2361
LR__2360
	add	fp, #36
	wrlong	#1, fp
	sub	fp, #36
	jmp	#LR__2365
LR__2361
	add	fp, #184
	rdlong	local04, fp
	sub	fp, #152
	rdlong	local03, fp
	sub	local04, local03
	add	fp, #152
	wrlong	local04, fp
	sub	fp, #172
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	neg	arg04, local04
	sub	fp, #4
	rdlong	arg05, fp
	sub	fp, #28
	call	#__system__disassemble_0383
	jmp	#LR__2365
LR__2362
	add	fp, #36
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__2363
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	add	fp, #152
	rdlong	arg04, fp
	sub	fp, #156
	rdlong	arg05, fp
	sub	fp, #28
	call	#__system__disassemble_0383
	jmp	#LR__2364
LR__2363
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	add	fp, #152
	rdlong	local04, fp
	add	local04, #1
	neg	arg04, local04
	sub	fp, #156
	rdlong	arg05, fp
	sub	fp, #28
	call	#__system__disassemble_0383
LR__2364
LR__2365
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	cmp	local01, #2 wz
 if_ne	jmp	#LR__2368
	add	fp, #28
	wrlong	#16, fp
	sub	fp, #28
LR__2366
	add	fp, #20
	rdlong	local01, fp wz
	sub	fp, #20
 if_e	jmp	#LR__2367
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, ##16777216 wc
 if_ae	jmp	#LR__2367
	add	fp, #20
	rdlong	local01, fp
	shl	local01, #1
	wrlong	local01, fp
	sub	fp, #20
	jmp	#LR__2366
LR__2367
LR__2368
	add	fp, #112
	mov	arg01, fp
	sub	fp, #92
	rdlong	arg02, fp
	add	fp, #8
	rdlong	arg03, fp
	add	fp, #160
	rdlong	arg05, fp
	sub	fp, #188
	mov	arg04, #1
	call	#__system___uitoa
	add	fp, #88
	wrlong	result1, fp
	sub	fp, #56
	rdlong	local01, fp
	sub	fp, #32
	cmps	local01, #0 wc
 if_ae	jmp	#LR__2369
	add	fp, #96
	wrlong	#45, fp
	add	fp, #80
	mov	arg01, fp
	sub	fp, #144
	rdlong	local03, fp
	neg	arg02, local03
	add	fp, #24
	rdlong	arg04, fp
	add	fp, #132
	rdlong	local06, fp
	sub	fp, #188
	mov	local04, local06
	mov	arg03, #10
	mov	arg05, local04
	call	#__system___uitoa
	add	fp, #92
	wrlong	result1, fp
	sub	fp, #92
	jmp	#LR__2370
LR__2369
	add	fp, #96
	wrlong	#43, fp
	add	fp, #80
	mov	arg01, fp
	sub	fp, #144
	rdlong	arg02, fp
	add	fp, #24
	rdlong	arg04, fp
	add	fp, #132
	rdlong	local06, fp
	sub	fp, #188
	mov	local04, local06
	mov	arg03, #10
	mov	arg05, local04
	call	#__system___uitoa
	add	fp, #92
	wrlong	result1, fp
	sub	fp, #92
LR__2370
	add	fp, #36
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__2371
	add	fp, #80
	wrlong	#0, fp
	sub	fp, #4
	wrlong	#0, fp
	add	fp, #108
	rdlong	local01, fp
	add	local01, #1
	sub	fp, #100
	wrlong	local01, fp
	sub	fp, #84
	jmp	#LR__2374
LR__2371
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmps	local01, #0 wc
 if_ae	jmp	#LR__2372
	add	fp, #32
	rdlong	local02, fp
	add	fp, #48
	wrlong	local02, fp
	sub	fp, #4
	wrlong	local02, fp
	sub	fp, #44
	rdlong	local01, fp
	add	fp, #152
	rdlong	local03, fp
	add	local01, local03
	add	local01, #1
	sub	fp, #100
	wrlong	local01, fp
	sub	fp, #84
	jmp	#LR__2373
LR__2372
	add	fp, #76
	wrlong	#0, fp
	sub	fp, #44
	rdlong	local01, fp
	add	fp, #48
	wrlong	local01, fp
	add	fp, #104
	rdlong	local03, fp
	add	local01, local03
	add	local01, #1
	sub	fp, #100
	wrlong	local01, fp
	sub	fp, #84
LR__2373
LR__2374
	add	fp, #84
	rdlong	local01, fp
	sub	fp, #8
	rdlong	local03, fp
	sub	local01, local03
	add	local01, #1
	sub	fp, #36
	wrlong	local01, fp
	add	fp, #4
	rdlong	local01, fp wz
	sub	fp, #44
 if_ne	add	fp, #40
 if_ne	rdlong	local03, fp
 if_ne	add	local03, #1
 if_ne	wrlong	local03, fp
 if_ne	sub	fp, #40
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	cmp	local01, #16 wz
 if_e	add	fp, #40
 if_e	rdlong	local01, fp
 if_e	add	local01, #2
 if_e	wrlong	local01, fp
 if_e	sub	fp, #40
	add	fp, #36
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__2375
	add	fp, #40
	rdlong	local01, fp
	mov	local03, #2
	add	fp, #52
	rdlong	local05, fp
	add	local03, local05
	add	local01, local03
	sub	fp, #52
	wrlong	local01, fp
	sub	fp, #40
LR__2375
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmps	local01, #65 wc
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__2403
	add	fp, #60
	rdlong	local01, fp wz
	sub	fp, #60
 if_e	jmp	#LR__2376
	add	fp, #192
	rdlong	arg01, fp
	sub	fp, #148
	rdlong	arg02, fp
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #64
	call	#__system__emitsign_0385
	add	fp, #280
	wrlong	result1, fp
	sub	fp, #280
	cmps	result1, #0 wc
 if_b	add	fp, #280
 if_b	rdlong	result1, fp
 if_b	sub	fp, #280
 if_b	jmp	#LR__2403
	add	fp, #192
	rdlong	local01, fp
	add	fp, #88
	rdlong	local03, fp
	add	local01, local03
	sub	fp, #88
	wrlong	local01, fp
	sub	fp, #192
LR__2376
	add	fp, #76
	rdlong	local01, fp
	sub	fp, #52
	wrlong	local01, fp
	sub	fp, #24
	callpa	#(@LR__2382-@LR__2377)>>2,fcache_load_ptr_
LR__2377
	add	fp, #24
	rdlong	local02, fp
	add	fp, #60
	rdlong	local05, fp
	sub	fp, #84
	cmps	local02, local05 wc
 if_ae	jmp	#LR__2383
	add	fp, #24
	rdlong	local06, fp
	sub	fp, #24
	cmps	local06, #0 wc
 if_b	jmp	#LR__2378
	add	fp, #24
	rdlong	local06, fp
	add	fp, #64
	rdlong	local07, fp
	sub	fp, #88
	cmps	local06, local07 wc
 if_ae	jmp	#LR__2378
	add	fp, #192
	rdlong	local08, fp
	mov	local07, local08
	add	local07, #1
	wrlong	local07, fp
	sub	fp, #168
	rdlong	local07, fp
	mov	local09, local07
	add	fp, #88
	mov	local10, fp
	add	local09, fp
	rdbyte	local11, local09
	wrbyte	local11, local08
	sub	fp, #112
	jmp	#LR__2379
LR__2378
	add	fp, #192
	rdlong	local08, fp
	mov	local09, local08
	add	local09, #1
	wrlong	local09, fp
	sub	fp, #192
	mov	local09, #48
	wrbyte	#48, local08
LR__2379
	add	fp, #24
	rdlong	local06, fp
	add	fp, #56
	rdlong	local12, fp
	sub	fp, #80
	cmp	local06, local12 wz
 if_ne	jmp	#LR__2381
	add	fp, #272
	rdlong	local07, fp
	sub	fp, #272
	mov	local09, local07 wz
 if_ne	jmp	#LR__2380
	add	fp, #84
	rdlong	local11, fp
	mov	local10, local11
	sub	local10, #1
	sub	fp, #60
	rdlong	local13, fp
	sub	fp, #24
	mov	local14, local13
	cmps	local14, local10 wc
 if_ae	jmp	#LR__2381
LR__2380
	add	fp, #192
	rdlong	local08, fp
	mov	local12, local08
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #192
	mov	local09, #46
	wrbyte	#46, local08
LR__2381
	add	fp, #24
	rdlong	local15, fp
	mov	local12, local15
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #24
	jmp	#LR__2377
LR__2382
LR__2383
	add	fp, #52
	rdlong	local01, fp wz
	sub	fp, #52
 if_e	jmp	#LR__2387
	add	fp, #192
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #192
	callpa	#(@LR__2385-@LR__2384)>>2,fcache_load_ptr_
LR__2384
	add	fp, #192
	rdlong	local01, fp
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #196
	cmps	local01, local03 wcz
 if_be	jmp	#LR__2386
	add	fp, #192
	rdlong	local06, fp
	sub	fp, #192
	rdbyte	local04, local06
	cmp	local04, #48 wz
 if_ne	jmp	#LR__2386
	add	fp, #192
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #192
	jmp	#LR__2384
LR__2385
LR__2386
	add	fp, #192
	rdlong	local02, fp
	sub	fp, #192
	rdbyte	local01, local02
	cmp	local01, #46 wz
 if_e	add	fp, #192
 if_e	rdlong	local01, fp
 if_e	sub	local01, #1
 if_e	wrlong	local01, fp
 if_e	sub	fp, #192
	add	fp, #192
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #192
LR__2387
	add	fp, #36
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__2390
	add	fp, #192
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #144
	rdlong	local04, fp
	wrbyte	local04, local02
	add	fp, #144
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #96
	rdlong	local04, fp
	wrbyte	local04, local02
	sub	fp, #72
	wrlong	#0, fp
	sub	fp, #24
LR__2388
	add	fp, #24
	rdlong	local02, fp
	add	fp, #68
	rdlong	local05, fp
	sub	fp, #92
	cmps	local02, local05 wc
 if_ae	jmp	#LR__2389
	add	fp, #192
	rdlong	local08, fp
	mov	local12, local08
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #168
	rdlong	local07, fp
	mov	local09, local07
	add	fp, #152
	mov	local10, fp
	add	local09, fp
	rdbyte	local11, local09
	wrbyte	local11, local08
	sub	fp, #152
	rdlong	local12, fp
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #24
	jmp	#LR__2388
LR__2389
LR__2390
	add	fp, #192
	rdlong	local01, fp
	sub	fp, #192
	wrbyte	#0, local01
LR__2391
	add	fp, #108
	rdlong	local01, fp wz
	sub	fp, #108
 if_e	jmp	#LR__2402
	add	fp, #72
	rdlong	local03, fp wz
	sub	fp, #72
 if_e	jmp	#LR__2402
	add	fp, #196
	rdlong	arg01, fp
	sub	fp, #196
	mov	local16, arg01
	callpa	#(@LR__2393-@LR__2392)>>2,fcache_load_ptr_
LR__2392
	rdbyte	result1, local16 wz
 if_ne	add	local16, #1
 if_ne	jmp	#LR__2392
LR__2393
	sub	local16, arg01
	mov	local04, local16
	add	fp, #108
	rdlong	local06, fp
	sub	fp, #108
	cmps	local04, local06 wcz
 if_be	jmp	#LR__2402
	add	fp, #196
	rdlong	local01, fp
	add	fp, #92
	wrlong	local01, fp
	sub	fp, #252
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__2394
	add	fp, #184
	wrlong	#0, fp
	sub	fp, #76
	rdlong	local01, fp
	add	fp, #176
	wrlong	local01, fp
	sub	fp, #284
	jmp	#LR__2395
LR__2394
	add	fp, #108
	rdlong	local01, fp
	sub	local01, #1
	add	fp, #76
	rdlong	local03, fp
	sub	local01, local03
	add	fp, #100
	wrlong	local01, fp
	sub	fp, #284
LR__2395
	callpa	#(@LR__2397-@LR__2396)>>2,fcache_load_ptr_
LR__2396
	add	fp, #284
	rdlong	local01, fp wz
	sub	fp, #284
 if_e	jmp	#LR__2398
	add	fp, #288
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	wrbyte	#42, local02
	sub	fp, #4
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #284
	jmp	#LR__2396
LR__2397
LR__2398
	add	fp, #184
	rdlong	local01, fp wz
	sub	fp, #184
 if_e	jmp	#LR__2401
	add	fp, #288
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	wrbyte	#46, local02
	sub	fp, #4
	wrlong	#0, fp
	sub	fp, #284
LR__2399
	add	fp, #284
	rdlong	local02, fp
	sub	fp, #100
	rdlong	local05, fp
	sub	fp, #184
	cmps	local02, local05 wc
 if_ae	jmp	#LR__2400
	add	fp, #288
	rdlong	local08, fp
	mov	local12, local08
	add	local12, #1
	wrlong	local12, fp
	wrbyte	#42, local08
	sub	fp, #4
	rdlong	local12, fp
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #284
	jmp	#LR__2399
LR__2400
LR__2401
	add	fp, #288
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #288
	wrbyte	#0, local02
LR__2402
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #188
	rdlong	arg03, fp
	sub	fp, #196
	call	#__system___fmtstr
LR__2403
	mov	ptra, fp
	call	#popregs_
__system___fmtfloat_ret
	ret

__system__Left_S
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	cmps	local02, #1 wc
 if_b	mov	result1, ##@LR__4283
 if_b	jmp	#LR__2413
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__2411-@LR__2410)>>2,fcache_load_ptr_
LR__2410
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__2410
LR__2411
	sub	local03, arg01
	mov	result1, local03
	cmps	result1, local02 wcz
 if_be	mov	result1, local01
 if_be	jmp	#LR__2413
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_e	jmp	#LR__2412
	mov	arg01, local04
	mov	arg02, local01
	mov	arg03, local02
	call	#__system____builtin_memmove
	add	local02, local04
	wrbyte	#0, local02
LR__2412
	mov	result1, local04
LR__2413
	mov	ptra, fp
	call	#popregs_
__system__Left_S_ret
	ret

__system__Right_S
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	cmps	local02, #1 wc
 if_b	mov	result1, ##@LR__4284
 if_b	jmp	#LR__2423
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__2421-@LR__2420)>>2,fcache_load_ptr_
LR__2420
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__2420
LR__2421
	sub	local03, arg01
	mov	result1, local03
	mov	local04, result1
	cmps	local04, local02 wcz
 if_be	mov	result1, local01
 if_be	jmp	#LR__2423
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__2422
	sub	local04, local02
	add	local04, local01
	add	local02, #1
	mov	arg01, local05
	mov	arg02, local04
	mov	arg03, local02
	call	#__system____builtin_memmove
LR__2422
	mov	result1, local05
LR__2423
	mov	ptra, fp
	call	#popregs_
__system__Right_S_ret
	ret

__system__Mid_S
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	cmps	arg03, #1 wc
 if_b	mov	result1, ##@LR__4285
 if_b	jmp	#LR__2433
	sub	local02, #1
	fges	local02, #0 wc
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__2431-@LR__2430)>>2,fcache_load_ptr_
LR__2430
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__2430
LR__2431
	sub	local03, arg01
	mov	result1, local03
	mov	arg02, result1
	cmps	arg02, local02 wc
 if_b	mov	result1, ##@LR__4286
 if_b	jmp	#LR__2433
	mov	local04, arg02
	sub	local04, local02
	cmps	local04, arg03 wcz
 if_a	mov	local04, arg03
	mov	arg01, local04
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__2432
	add	local02, local01
	mov	arg01, local05
	mov	arg02, local02
	mov	arg03, local04
	call	#__system____builtin_memmove
	add	local04, local05
	wrbyte	#0, local04
LR__2432
	mov	result1, local05
LR__2433
	mov	ptra, fp
	call	#popregs_
__system__Mid_S_ret
	ret

__system__Chr_S
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #3
	call	#__system___gc_alloc_managed
	cmps	result1, #0 wz
 if_ne	wrbyte	local01, result1
 if_ne	add	result1, #1
 if_ne	wrbyte	#0, result1
 if_ne	sub	result1, #1
	mov	ptra, fp
	call	#popregs_
__system__Chr_S_ret
	ret

__system__Number_S
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	mov	local03, arg03
 if_ne	jmp	#LR__2442
	mov	local02, #1
	mov	local04, local03
	mov	local05, #1
	callpa	#(@LR__2441-@LR__2440)>>2,fcache_load_ptr_
LR__2440
	mov	local06, #0
	cmp	local04, local01 wcz
 if_be	neg	local06, #1
	cmp	local05, local04 wc
	subx	local07, local07
	test	local06, local07 wz
 if_ne	qmul	local04, local03
 if_ne	mov	local05, local04
 if_ne	add	local02, #1
 if_ne	getqx	local04
 if_ne	jmp	#LR__2440
LR__2441
LR__2442
	fle	local02, #32 wc
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local06, result1
	mov	local07, local02
	add	local07, local06
	wrbyte	#0, local07
	callpa	#(@LR__2444-@LR__2443)>>2,fcache_load_ptr_
LR__2443
	cmp	local02, #1 wc
 if_b	jmp	#LR__2445
	qdiv	local01, local03
	sub	local02, #1
	mov	local07, local02
	add	local07, local06
	getqy	local08
	cmp	local08, #10 wc
 if_b	add	local08, #48
 if_ae	add	local08, #55
	wrbyte	local08, local07
	getqx	local01
	jmp	#LR__2443
LR__2444
LR__2445
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system__Number_S_ret
	ret

__system__LCase_S
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__2451-@LR__2450)>>2,fcache_load_ptr_
LR__2450
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__2450
LR__2451
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, ##@LR__4287
 if_e	jmp	#LR__2457
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local03, result1 wz
 if_e	jmp	#LR__2456
	neg	local04, #1
	callpa	#(@LR__2455-@LR__2452)>>2,fcache_load_ptr_
LR__2452
	add	local04, #1
	mov	local05, local04
	add	local05, local01
	rdbyte	local06, local05
	cmps	local06, #65 wc
 if_b	jmp	#LR__2453
	cmps	local06, #91 wc
 if_b	mov	local07, local04
 if_b	add	local07, local03
 if_b	add	local06, #32
 if_b	wrbyte	local06, local07
 if_b	jmp	#LR__2454
LR__2453
	mov	local07, local04
	add	local07, local03
	wrbyte	local06, local07
LR__2454
	mov	local06, local02
	sub	local06, #1
	cmp	local04, local06 wz
 if_ne	jmp	#LR__2452
LR__2455
	add	local02, local03
	wrbyte	#0, local02
	mov	result1, local03
	jmp	#LR__2457
LR__2456
	mov	result1, local03
LR__2457
	mov	ptra, fp
	call	#popregs_
__system__LCase_S_ret
	ret

__system__LTrim_S
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__2461-@LR__2460)>>2,fcache_load_ptr_
LR__2460
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__2460
LR__2461
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, ##@LR__4288
 if_e	jmp	#LR__2466
	mov	local03, #0
	mov	local04, local02
LR__2462
	cmps	local03, local04 wc
 if_ae	jmp	#LR__2465
	mov	arg03, local03
	add	arg03, local01
	rdbyte	arg03, arg03
	cmp	arg03, #32 wz
 if_e	jmp	#LR__2464
	mov	arg01, local02
	sub	arg01, local03
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__2463
	mov	arg02, local03
	add	arg02, local01
	mov	arg03, local02
	sub	arg03, local03
	mov	arg01, local05
	call	#__system____builtin_memmove
	sub	local02, local03
	add	local02, local05
	wrbyte	#0, local02
	mov	result1, local05
	jmp	#LR__2466
LR__2463
	mov	result1, local05
	jmp	#LR__2466
LR__2464
	add	local03, #1
	jmp	#LR__2462
LR__2465
	mov	result1, local01
LR__2466
	mov	ptra, fp
	call	#popregs_
__system__LTrim_S_ret
	ret

__system__RTrim_S
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__2471-@LR__2470)>>2,fcache_load_ptr_
LR__2470
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__2470
LR__2471
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, ##@LR__4289
 if_e	jmp	#LR__2475
	mov	local03, local02
	sub	local03, #1
LR__2472
	mov	arg02, local03
	add	arg02, local01
	rdbyte	local02, arg02
	cmp	local02, #32 wz
 if_e	jmp	#LR__2474
	mov	arg01, local03
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_e	jmp	#LR__2473
	mov	arg03, local03
	add	arg03, #1
	mov	arg01, local04
	mov	arg02, local01
	call	#__system____builtin_memmove
	add	local03, #1
	add	local03, local04
	wrbyte	#0, local03
	mov	result1, local04
	jmp	#LR__2475
LR__2473
	mov	result1, local04
	jmp	#LR__2475
LR__2474
	sub	local03, #1
	cmps	local03, #0 wc
 if_ae	jmp	#LR__2472
	mov	result1, ##@LR__4290
LR__2475
	mov	ptra, fp
	call	#popregs_
__system__RTrim_S_ret
	ret

__system__Instr
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__2481-@LR__2480)>>2,fcache_load_ptr_
LR__2480
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__2480
LR__2481
	sub	local04, arg01
	mov	local05, local04
	mov	arg01, local02
	mov	local04, arg01
	callpa	#(@LR__2483-@LR__2482)>>2,fcache_load_ptr_
LR__2482
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__2482
LR__2483
	sub	local04, arg01
	mov	result1, local04
	mov	arg04, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__2487
	cmp	local05, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__2487
	cmps	local01, arg04 wcz
 if_a	mov	result1, #0
 if_a	jmp	#LR__2487
	cmps	local01, #1 wc
 if_b	mov	local01, #1
	rdbyte	local06, local03
	cmp	local05, #1 wz
 if_ne	jmp	#LR__2484
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local01
	mov	arg04, #0
	call	#__system____ScanForChar
	jmp	#LR__2487
LR__2484
	mov	local07, local01
LR__2485
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local07
	mov	arg04, #0
	call	#__system____ScanForChar
	mov	local07, result1 wz
 if_e	jmp	#LR__2486
	mov	arg03, local05
	mov	arg01, local02
	mov	arg02, local07
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, local03
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__2487
	add	local07, local05
	jmp	#LR__2485
LR__2486
	mov	result1, #0
LR__2487
	mov	ptra, fp
	call	#popregs_
__system__Instr_ret
	ret

__system___strerror
	cmps	arg01, #0 wc
 if_b	jmp	#LR__2490
	cmps	arg01, #26 wc
 if_b	jmp	#LR__2491
LR__2490
	mov	arg01, #25
LR__2491
	shl	arg01, #2
	add	ptr___system__dat__, ##728
	add	arg01, ptr___system__dat__
	rdlong	result1, arg01
	sub	ptr___system__dat__, ##728
__system___strerror_ret
	ret

__system___int64_shl
	test	arg03, #32 wz
 if_ne	mov	arg02, arg01
 if_ne	mov	arg01, #0
	test	arg03, #31 wz
 if_e	jmp	#LR__2500
	shl	arg02, arg03
	mov	result1, arg01
	neg	result2, arg03
	shr	result1, result2
	or	arg02, result1
	shl	arg01, arg03
LR__2500
	mov	result2, arg02
	mov	result1, arg01
__system___int64_shl_ret
	ret

__system___usepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #20
	test	arg01, _var01 wz
 if_e	add	ptr___system__dat__, #24
 if_e	rdlong	_var02, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #24
 if_e	test	arg02, _var02 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___usepins_ret
	add	ptr___system__dat__, #20
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg01
	wrlong	_var02, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg02
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #24
	neg	result1, #1
__system___usepins_ret
	ret

__system___freepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg01
	wrlong	_var01, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg02
	wrlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #24
__system___freepins_ret
	ret

__system___float_fromuns
	mov	arg03, arg01 wz
 if_e	mov	result1, arg03
 if_e	jmp	#LR__2510
	encod	arg02, arg03 wc
 if_b	add	arg02, #1
	sub	arg02, #1
	mov	arg01, #31
	sub	arg01, arg02
	shl	arg03, arg01
	shr	arg03, #2
	mov	arg01, #0
	call	#__system___float_Pack
LR__2510
__system___float_fromuns_ret
	ret

__system___float_add
	mov	COUNT_, #15
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	mov	local04, local01
	mov	local05, local04
	zerox	local05, #22
	mov	local06, local04
	shl	local06, #1
	shr	local06, #24
	shr	local04, #31
	mov	arg01, local02
	mov	result1, arg01
	mov	local07, result1
	mov	local08, local07
	zerox	local08, #22
	mov	local09, local07
	shl	local09, #1
	shr	local09, #24
	mov	local10, local09
	shr	local07, #31
	mov	local11, #0
	mov	local12, #0
	cmp	local06, local10 wc
 if_ae	cmp	local06, local10 wz
 if_a	jmp	#LR__2520
 if_ae	cmp	local05, local08 wc
 if_ae	jmp	#LR__2520
	mov	local13, local05
	mov	local05, local08
	mov	local08, local13
	mov	local13, local06
	mov	local06, local10
	mov	local10, local13
	mov	local13, local04
	mov	local04, local07
	mov	local07, local13
LR__2520
	cmp	local06, #255 wz
 if_e	jmp	#LR__2535
	cmp	local06, #0 wz
 if_e	jmp	#LR__2537
	bith	local05, #23
LR__2521
	cmp	local10, #0 wz
 if_e	jmp	#LR__2541
	bith	local08, #23
LR__2522
	sub	local06, #127
	sub	local10, #127
	mov	local14, local06
	sub	local14, local10
	callpa	#(@LR__2524-@LR__2523)>>2,fcache_load_ptr_
LR__2523
	cmps	local14, #32 wc
 if_b	jmp	#LR__2525
	mov	local09, local08
	cmp	local11, #0 wz
	wrnz	local11
	or	local09, local11
	mov	local11, local09
	mov	local08, #0
	sub	local14, #32
	jmp	#LR__2523
LR__2524
LR__2525
	cmp	local14, #0 wz
 if_e	jmp	#LR__2526
	mov	local13, local08
	mov	local10, #32
	sub	local10, local14
	shl	local13, local10
	mov	local10, local11
	mov	local09, #32
	sub	local09, local14
	shl	local10, local09 wz
	shr	local11, local14
	shr	local08, local14
	or	local11, local13
	mov	local15, #0
 if_ne	mov	local15, #1
	or	local11, local15
LR__2526
	mov	local15, local04
	xor	local15, local07
	test	local15, #1 wz
 if_e	jmp	#LR__2527
	not	local08, local08
	not	local11, local11
	add	local11, #1 wz
	mov	local15, #0
 if_e	mov	local15, #1
	add	local08, local15
LR__2527
	add	local12, local11 wc
	addx	local05, local08
	cmps	local05, #0 wc
 if_ae	jmp	#LR__2528
	xor	local04, #1
	not	local05, local05
	not	local12, local12
	add	local12, #1 wz
	mov	local15, #0
 if_e	mov	local15, #1
	add	local05, local15
LR__2528
	cmp	local05, ##16777216 wc
 if_b	jmp	#LR__2529
	add	local06, #1
	mov	local14, local12
	and	local14, #1
	shr	local12, #1
	mov	local15, local05
	shl	local15, #31
	or	local12, local15
	or	local12, local14
	shr	local05, #1
	jmp	#LR__2534
LR__2529
	cmp	local05, ##8388608 wc
 if_ae	jmp	#LR__2533
	cmp	local05, #0 wz
 if_e	cmp	local12, #0 wz
 if_e	or	local04, #8
 if_e	andn	local04, #1
 if_e	jmp	#LR__2532
LR__2530
	cmp	local05, ##8388608 wc
 if_ae	jmp	#LR__2531
	add	local12, local12 wc
	addx	local05, local05
	sub	local06, #1
	jmp	#LR__2530
LR__2531
LR__2532
LR__2533
LR__2534
	mov	arg01, local05
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	call	#__system__pack_0491
	jmp	#LR__2545
LR__2535
	cmp	local10, #255 wz
 if_ne	jmp	#LR__2536
	cmp	local07, local04 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__2545
LR__2536
	cmp	local05, #0 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__2545
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	or	arg04, #2
	mov	arg01, local05
	call	#__system__pack_0491
	jmp	#LR__2545
LR__2537
	cmp	local05, #0 wz
 if_e	jmp	#LR__2540
	shl	local05, #1
	callpa	#(@LR__2539-@LR__2538)>>2,fcache_load_ptr_
LR__2538
	cmp	local05, ##8388608 wc
 if_b	mov	local15, local06
 if_b	sub	local15, #1
 if_b	mov	local06, local15
 if_b	shl	local05, #1
 if_b	jmp	#LR__2538
LR__2539
	jmp	#LR__2521
LR__2540
	and	local04, local07
	mov	arg04, local04
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0491
	jmp	#LR__2545
LR__2541
	cmp	local08, #0 wz
 if_e	jmp	#LR__2544
	shl	local08, #1
	callpa	#(@LR__2543-@LR__2542)>>2,fcache_load_ptr_
LR__2542
	cmp	local08, ##8388608 wc
 if_b	mov	local15, local10
 if_b	sub	local15, #1
 if_b	mov	local10, local15
 if_b	shl	local08, #1
 if_b	jmp	#LR__2542
LR__2543
	jmp	#LR__2522
LR__2544
	sub	local06, #127
	mov	arg01, local05
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	call	#__system__pack_0491
LR__2545
	mov	ptra, fp
	call	#popregs_
__system___float_add_ret
	ret

__system___float_sqrt
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	result1, arg01
	mov	local02, result1
	mov	local03, local02
	zerox	local03, #22
	mov	local04, local02
	shl	local04, #1
	shr	local04, #24 wz
	shr	local02, #31
 if_e	jmp	#LR__2551
	bith	local03, #23
LR__2550
	cmp	local02, #0 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__2554
	cmp	local04, #255 wz
 if_e	mov	result1, local01
 if_e	jmp	#LR__2554
	sub	local04, #127
	test	local04, #1 wz
 if_ne	shl	local03, #1
	shl	local03, #5
	qsqrt	#0, local03
 if_ne	sub	local04, #1
	abs	local04, local04 wc
	shr	local04, #1
	negc	arg03, local04
	mov	arg04, local02
	getqx	arg01
	mov	arg02, arg01
	shl	arg02, #25
	shr	arg01, #7
	cmp	arg01, ##16777217 wc
 if_ae	add	arg03, #1
 if_ae	shr	arg01, #1
	call	#__system__pack_0491
	jmp	#LR__2554
LR__2551
	cmp	local03, #0 wz
 if_e	mov	result1, local01
 if_e	jmp	#LR__2554
	shl	local03, #1
	callpa	#(@LR__2553-@LR__2552)>>2,fcache_load_ptr_
LR__2552
	cmp	local03, ##8388608 wc
 if_b	sub	local04, #1
 if_b	shl	local03, #1
 if_b	jmp	#LR__2552
LR__2553
	jmp	#LR__2550
LR__2554
	mov	ptra, fp
	call	#popregs_
__system___float_sqrt_ret
	ret

__system___float_mul
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, local01
	mov	local04, local03
	zerox	local04, #22
	mov	local05, local03
	shl	local05, #1
	shr	local05, #24
	shr	local03, #31
	mov	result1, local02
	mov	local06, result1
	mov	local07, local06
	zerox	local07, #22
	mov	local08, local06
	shl	local08, #1
	shr	local08, #24
	shr	local06, #31
	xor	local03, local06
	cmp	local05, #255 wz
 if_e	jmp	#LR__2563
	cmp	local08, #255 wz
 if_e	jmp	#LR__2565
	cmp	local05, #0 wz
 if_e	jmp	#LR__2566
	bith	local04, #23
LR__2560
	cmp	local08, #0 wz
 if_e	jmp	#LR__2570
	bith	local07, #23
LR__2561
	mov	local02, local04
	shl	local02, #4
	mov	local06, local07
	shl	local06, #5
	qmul	local02, local06
	add	local05, local08
	sub	local05, #254
	mov	local09, local05
	shl	local04, #4
	shl	local07, #5
	getqx	local10
	qmul	local04, local07
	getqy	local11
	cmp	local11, ##16777216 wc
 if_b	jmp	#LR__2562
	add	local09, #1
	shr	local10, #1
	mov	local08, local11
	shl	local08, #31
	or	local10, local08
	shr	local11, #1
LR__2562
	mov	arg01, local11
	mov	arg02, local10
	mov	arg03, local09
	mov	arg04, local03
	call	#__system__pack_0491
	jmp	#LR__2574
LR__2563
	cmp	local04, #0 wz
 if_ne	mov	result1, local01
 if_ne	jmp	#LR__2574
	cmps	local08, #255 wc
 if_b	cmp	local08, #0 wz
 if_c_and_z	cmp	local07, #0 wz
 if_c_and_nz	jmp	#LR__2564
 if_b	mov	result1, ##2146435072
 if_b	jmp	#LR__2574
	cmp	local07, #0 wz
 if_ne	mov	result1, local02
 if_ne	jmp	#LR__2574
LR__2564
	or	local03, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, local05
	mov	arg04, local03
	call	#__system__pack_0491
	jmp	#LR__2574
LR__2565
	cmp	local05, #0 wz
 if_e	cmp	local04, #0 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__2574
	cmp	local07, #0 wz
 if_ne	mov	result1, local02
 if_ne	jmp	#LR__2574
	mov	arg03, local08
	mov	arg04, local03
	or	arg04, #2
	mov	arg01, #0
	mov	arg02, #0
	call	#__system__pack_0491
	jmp	#LR__2574
LR__2566
	cmp	local04, #0 wz
 if_e	jmp	#LR__2569
	shl	local04, #1
	callpa	#(@LR__2568-@LR__2567)>>2,fcache_load_ptr_
LR__2567
	cmp	local04, ##8388608 wc
 if_b	sub	local05, #1
 if_b	shl	local04, #1
 if_b	jmp	#LR__2567
LR__2568
	jmp	#LR__2560
LR__2569
	or	local03, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local03
	call	#__system__pack_0491
	jmp	#LR__2574
LR__2570
	cmp	local07, #0 wz
 if_e	jmp	#LR__2573
	shl	local07, #1
	callpa	#(@LR__2572-@LR__2571)>>2,fcache_load_ptr_
LR__2571
	cmp	local07, ##8388608 wc
 if_b	sub	local08, #1
 if_b	shl	local07, #1
 if_b	jmp	#LR__2571
LR__2572
	jmp	#LR__2561
LR__2573
	or	local03, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local03
	call	#__system__pack_0491
LR__2574
	mov	ptra, fp
	call	#popregs_
__system___float_mul_ret
	ret

__system___float_div
	mov	COUNT_, #14
	call	#pushregs_
	mov	local03, arg01
	mov	local04, arg02
	mov	local05, local03
	mov	local06, local05
	zerox	local06, #22
	mov	local07, local05
	shl	local07, #1
	shr	local07, #24
	shr	local05, #31
	mov	result1, local04
	mov	local08, result1
	mov	local09, local08
	zerox	local09, #22
	mov	local10, local08
	shl	local10, #1
	shr	local10, #24
	shr	local08, #31
	xor	local05, local08
	cmp	local07, #255 wz
 if_e	jmp	#LR__2585
	cmp	local10, #255 wz
 if_e	jmp	#LR__2586
	cmp	local07, #0 wz
 if_e	jmp	#LR__2587
	bith	local06, #23
LR__2580
	cmp	local10, #0 wz
 if_e	jmp	#LR__2591
	bith	local09, #23
LR__2581
	sub	local07, local10
	mov	local11, local07
	mov	arg01, local06
	shr	arg01, #2
	shl	local06, #30
	mov	arg02, local06
	mov	arg03, local09
	setq	arg01
	qdiv	arg02, arg03
	mov	local12, #0
	getqx	local01
	getqy	result2
	mov	local02, result2
	mov	local13, local01
	cmps	local02, #0 wz
	mov	local14, local13
	shl	local14, #25
 if_ne	mov	local12, #1
	or	local14, local12
	shr	local13, #7
	cmp	local13, ##16777216 wc
 if_b	jmp	#LR__2582
	add	local11, #1
	shr	local14, #1
	mov	local12, local13
	shl	local12, #31
	or	local14, local12
	shr	local13, #1
	jmp	#LR__2584
LR__2582
	cmp	local13, ##8388608 wc
 if_ae	jmp	#LR__2583
	sub	local11, #1
	shl	local13, #1
	mov	local12, local14
	shr	local12, #31
	or	local13, local12
	shl	local14, #1
LR__2583
LR__2584
	mov	arg01, local13
	mov	arg02, local14
	mov	arg03, local11
	mov	arg04, local05
	call	#__system__pack_0491
	jmp	#LR__2595
LR__2585
	cmp	local06, #0 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__2595
	cmp	local10, #255 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__2595
	or	local05, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, local07
	mov	arg04, local05
	call	#__system__pack_0491
	jmp	#LR__2595
LR__2586
	cmp	local09, #0 wz
 if_ne	mov	result1, local04
 if_ne	jmp	#LR__2595
	mov	arg04, local05
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0491
	jmp	#LR__2595
LR__2587
	cmp	local06, #0 wz
 if_e	jmp	#LR__2590
	shl	local06, #1
	callpa	#(@LR__2589-@LR__2588)>>2,fcache_load_ptr_
LR__2588
	cmp	local06, ##8388608 wc
 if_b	sub	local07, #1
 if_b	shl	local06, #1
 if_b	jmp	#LR__2588
LR__2589
	jmp	#LR__2580
LR__2590
	cmp	local10, #0 wz
 if_e	cmp	local09, #0 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__2595
	mov	arg04, local05
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0491
	jmp	#LR__2595
LR__2591
	cmp	local09, #0 wz
 if_e	jmp	#LR__2594
	shl	local09, #1
	callpa	#(@LR__2593-@LR__2592)>>2,fcache_load_ptr_
LR__2592
	cmp	local09, ##8388608 wc
 if_b	sub	local10, #1
 if_b	shl	local09, #1
 if_b	jmp	#LR__2592
LR__2593
	jmp	#LR__2581
LR__2594
	or	local05, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local05
	call	#__system__pack_0491
LR__2595
	mov	ptra, fp
	call	#popregs_
__system___float_div_ret
	ret

__system___float_cmp
	cmps	arg01, ##2139095041 wc
 if_b	cmps	arg02, ##2139095041 wc
 if_ae	mov	result1, arg03
 if_ae	jmp	#__system___float_cmp_ret
	cmp	arg01, ##-8388607 wc
 if_b	cmp	arg01, ##-8388607 wc
 if_ae	mov	result1, arg03
 if_ae	jmp	#__system___float_cmp_ret
	cmps	arg01, #0 wc
 if_ae	jmp	#LR__2600
	cmps	arg02, #0 wc
 if_b	mov	result1, arg02
 if_b	sub	result1, arg01
 if_b	jmp	#__system___float_cmp_ret
	cmp	arg02, #0 wz
 if_e	cmp	arg01, ##-2147483648 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system___float_cmp_ret
	neg	result1, #1
	jmp	#__system___float_cmp_ret
LR__2600
	cmps	arg02, #0 wc
 if_ae	jmp	#LR__2601
	cmp	arg01, #0 wz
 if_e	cmp	arg02, ##-2147483648 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system___float_cmp_ret
	mov	result1, #1
	jmp	#__system___float_cmp_ret
LR__2601
	sub	arg01, arg02
	mov	result1, arg01
__system___float_cmp_ret
	ret

__system___float_tointeger
	mov	COUNT_, #2
	call	#pushregs_
	call	#__system___float_Unpack
	cmps	result2, ##-1 wc
 if_b	jmp	#LR__2610
	cmps	result2, #31 wc
 if_ae	jmp	#LR__2610
	shl	result3, #2
	mov	local01, #30
	sub	local01, result2
	shr	result3, local01
	mov	local02, result3
	add	local02, arg02
	shr	local02, #1
	cmp	result1, #0 wz
 if_ne	neg	local02, local02
	mov	result1, local02
	jmp	#LR__2611
LR__2610
	mov	result1, #0
LR__2611
	mov	ptra, fp
	call	#popregs_
__system___float_tointeger_ret
	ret

__system___float_Unpack
	mov	_var01, arg01
	shr	_var01, #31
	mov	_var02, arg01
	shl	_var02, #1
	shr	_var02, #24 wz
	bitl	arg01, #279
 if_ne	shl	arg01, #6
 if_ne	bith	arg01, #29
 if_ne	jmp	#LR__2620
	encod	_var03, arg01 wc
 if_b	add	_var03, #1
	sub	_var03, #23
	mov	_var02, _var03
	mov	result2, #7
	sub	result2, _var03
	shl	arg01, result2
LR__2620
	sub	_var02, #127
	mov	result3, arg01
	mov	result1, _var01
	mov	result2, _var02
__system___float_Unpack_ret
	ret

__system___float_Pack
	mov	_var01, #0
	cmp	arg03, #0 wz
 if_e	jmp	#LR__2631
	encod	_var02, arg03 wc
 if_b	add	_var02, #1
	mov	_var01, #33
	sub	_var01, _var02
	shl	arg03, _var01
	mov	_var02, #3
	sub	_var02, _var01
	add	arg02, _var02
	mov	_var03, arg02
	add	arg03, #256
	mov	_var02, arg03
	andn	_var02, #255 wz
 if_e	add	_var03, #1
	add	_var03, #127
	fges	_var03, ##-23
	fles	_var03, #255
	cmps	_var03, #1 wc
 if_ae	jmp	#LR__2630
	shr	arg03, #1
	decod	_var02, #31
	add	_var02, arg03
	neg	_var03, _var03
	shr	_var02, _var03
	mov	arg03, _var02
	mov	_var03, #0
LR__2630
	mov	result1, arg01
	shl	result1, #31
	mov	_var02, _var03
	shl	_var02, #23
	or	result1, _var02
	mov	_var04, arg03
	shr	_var04, #9
	or	result1, _var04
	jmp	#__system___float_Pack_ret
LR__2631
	mov	result1, _var01
__system___float_Pack_ret
	ret

__system___basic_print_float
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03 wz
	mov	local04, arg04
 if_ne	jmp	#LR__2640
	cmp	local04, #35 wz
 if_e	mov	local05, ##537198592
 if_ne	decod	local05, #29
	mov	local03, local05
LR__2640
	mov	arg01, local01
	call	#__system___gettxfunc
	mov	local05, result1 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local05
 if_ne	mov	arg02, local03
 if_ne	mov	arg03, local02
 if_ne	mov	arg04, local04
 if_ne	call	#__system___fmtfloat
	mov	ptra, fp
	call	#popregs_
__system___basic_print_float_ret
	ret

__system____builtin_atoi
	mov	COUNT_, #7
	call	#pushregs_
__system____builtin_atoi_enter
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	mov	local04, #0
	mov	local05, #0
	callpa	#(@LR__2651-@LR__2650)>>2,fcache_load_ptr_
LR__2650
	rdbyte	local06, local01
	cmp	local06, #32 wz
 if_e	add	local01, #1
 if_e	jmp	#LR__2650
LR__2651
	rdbyte	local07, local01
LR__2652
	cmp	local07, #45 wz
 if_ne	cmp	local07, #43 wz
 if_ne	jmp	#LR__2653
	add	local01, #1
	cmp	local07, #45 wz
 if_e	mov	local06, #1
 if_e	subr	local05, local06
	rdbyte	local07, local01
	jmp	#LR__2652
LR__2653
	callpa	#(@LR__2661-@LR__2654)>>2,fcache_load_ptr_
LR__2654
LR__2655
	rdbyte	local07, local01
	cmp	local07, #95 wz
	add	local01, #1
 if_e	jmp	#LR__2655
	cmp	local07, #48 wz
 if_ne	cmp	local07, #38 wz
 if_e	mov	local04, #0
 if_e	jmp	#LR__2660
	cmps	local07, #49 wc
 if_b	jmp	#LR__2656
	cmps	local07, #58 wc
 if_b	mov	local04, local07
 if_b	sub	local04, #48
 if_b	cmp	local02, #0 wz
 if_c_and_z	mov	local02, #10
 if_b	jmp	#LR__2659
LR__2656
	cmps	local02, #11 wc
 if_ae	cmps	local07, #97 wc
 if_b	jmp	#LR__2657
	cmps	local07, #103 wc
 if_b	sub	local07, #97
 if_b	mov	local04, #10
 if_b	add	local04, local07
 if_b	jmp	#LR__2658
LR__2657
	cmps	local02, #11 wc
 if_ae	cmps	local07, #65 wc
 if_b	jmp	#LR__2662
	cmps	local07, #71 wc
 if_b	sub	local07, #65
 if_b	mov	local04, #10
 if_b	add	local04, local07
 if_ae	jmp	#LR__2662
LR__2658
LR__2659
LR__2660
	qmul	local02, local03
	getqx	local03
	add	local03, local04
	jmp	#LR__2654
LR__2661
LR__2662
	cmp	local02, #0 wz
 if_ne	jmp	#LR__2668
	cmp	local07, #120 wz
 if_ne	cmp	local07, #104 wz
 if_ne	cmp	local07, #88 wz
 if_ne	cmp	local07, #72 wz
 if_ne	jmp	#LR__2663
	mov	arg01, local01
	mov	arg02, #16
	call	#__system____builtin_atoi
	mov	local03, result1
	jmp	#LR__2667
LR__2663
	cmp	local07, #98 wz
 if_ne	cmp	local07, #66 wz
 if_ne	jmp	#LR__2664
	mov	arg01, local01
	mov	arg02, #2
	call	#__system____builtin_atoi
	mov	local03, result1
	jmp	#LR__2666
LR__2664
	cmp	local07, #111 wz
 if_ne	cmp	local07, #79 wz
 if_ne	jmp	#LR__2665
	mov	arg01, local01
	mov	arg02, #8
	call	#__system____builtin_atoi
	mov	local03, result1
LR__2665
LR__2666
LR__2667
LR__2668
	cmp	local05, #0 wz
 if_ne	neg	local03, local03
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
__system____builtin_atoi_ret
	ret

__system____builtin_atof
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	mov	local03, #0
	mov	local04, #0
	mov	local05, #0
	callpa	#(@LR__2671-@LR__2670)>>2,fcache_load_ptr_
LR__2670
	rdbyte	arg03, local01
	cmp	arg03, #32 wz
 if_e	add	local01, #1
 if_e	jmp	#LR__2670
LR__2671
	rdbyte	local06, local01
LR__2672
	cmp	local06, #43 wz
 if_ne	cmp	local06, #45 wz
 if_ne	jmp	#LR__2673
	cmp	local06, #45 wz
 if_e	bitnot	local04, #31
	add	local01, #1
	rdbyte	local06, local01
	jmp	#LR__2672
LR__2673
LR__2674
	callpa	#(@LR__2676-@LR__2675)>>2,fcache_load_ptr_
LR__2675
	rdbyte	local06, local01
	cmp	local06, #95 wz
	add	local01, #1
 if_e	jmp	#LR__2675
LR__2676
	cmp	local06, #0 wz
 if_e	jmp	#LR__2678
	cmps	local06, #48 wc
 if_b	jmp	#LR__2677
	cmps	local06, #58 wc
 if_ae	jmp	#LR__2677
	mov	arg01, local02
	mov	arg02, ##1092616192
	call	#__system___float_mul
	mov	local02, result1
	sub	local06, #48
	mov	arg01, local06
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local02, result1
	cmp	local05, #0 wz
 if_ne	sub	local03, #1
	jmp	#LR__2674
LR__2677
	cmp	local06, #46 wz
 if_e	cmp	local05, #0 wz
 if_e	mov	local05, #1
 if_e	jmp	#LR__2674
LR__2678
	cmp	local06, #69 wz
 if_ne	cmp	local06, #101 wz
 if_ne	jmp	#LR__2679
	mov	arg01, local01
	mov	arg02, #0
	call	#__system____builtin_atoi
	add	result1, local03
	mov	local07, result1
	jmp	#LR__2680
LR__2679
	mov	local07, local03
LR__2680
	mov	arg03, local07
	mov	arg01, local02
	mov	arg02, ##1092616192
	call	#__system___float_pow_n
	xor	result1, local04
	mov	ptra, fp
	call	#popregs_
__system____builtin_atof_ret
	ret

__system____builtin_ilogb
	call	#__system___float_Unpack
	cmp	result3, #0 wz
 if_e	mov	result1, ##-2147483647
 if_e	jmp	#LR__2691
	cmp	result2, #128 wz
 if_ne	jmp	#LR__2690
	cmp	result3, ##536870912 wz
 if_e	bmask	result1, #30
 if_e	jmp	#LR__2691
	decod	result1, #31
	jmp	#LR__2691
LR__2690
	mov	result1, result2
LR__2691
__system____builtin_ilogb_ret
	ret

__system____builtin_sinf
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, ##1086918619
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	arg03, result1 wz
 if_e	jmp	#LR__2700
	abs	arg01, arg03 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg01, result1
	decod	arg02, #30
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, ##1078530011
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local01, result1
LR__2700
	mov	arg01, local01
	mov	arg02, ##1036831949
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__2701
	mov	arg01, local01
	mov	arg02, ##-1110651699
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__2701
	mov	arg01, local01
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, ##1086324736
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local03, result1
	jmp	#LR__2702
LR__2701
	mov	arg01, local01
	mov	arg02, ##1294137731
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	shl	result1, #2
	qrotate	##1073741824, result1
	getqy	arg01
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg01, result1
	mov	arg02, ##1317011456
	call	#__system___float_div
	mov	local03, result1
LR__2702
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
__system____builtin_sinf_ret
	ret

__system____builtin_tanf
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	call	#__system____builtin_sinf
	mov	local02, result1
	mov	arg02, local01
	mov	arg01, ##1070141403
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	mov	ptra, fp
	call	#popregs_
__system____builtin_tanf_ret
	ret

__system____builtin_asinf
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, local01
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, ##1065353216
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system___float_sqrt
	mov	arg02, result1
	mov	arg01, local01
	call	#__system____builtin_atan2f
	mov	ptra, fp
	call	#popregs_
__system____builtin_asinf_ret
	ret

__system____builtin_acosf
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, local01
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, ##1065353216
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system___float_sqrt
	mov	arg01, result1
	mov	arg02, local01
	call	#__system____builtin_atan2f
	mov	ptra, fp
	call	#popregs_
__system____builtin_acosf_ret
	ret

__system____builtin_atan2f
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2710
	mov	arg01, local02
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	result1, ##-1068953637
 if_b	jmp	#LR__2711
	mov	result1, #0
	jmp	#LR__2711
LR__2710
	mov	arg01, local02
	mov	arg02, local02
	call	#__system___float_mul
	mov	local03, result1
	mov	arg01, local01
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_add
	mov	arg01, result1
	call	#__system___float_sqrt
	mov	local03, result1
	mov	arg01, local02
	mov	arg02, local03
	call	#__system___float_div
	mov	local02, result1
	mov	arg01, local01
	mov	arg02, local03
	call	#__system___float_div
	mov	local01, result1
	mov	arg01, ##1317011456
	mov	arg02, local02
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local03, result1
	mov	arg01, ##1317011456
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	qvector	local03, result1
	mov	local03, ##1078530011
	getqy	arg01
	sar	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg01, result1
	mov	arg02, ##1317011456
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_mul
LR__2711
	mov	ptra, fp
	call	#popregs_
__system____builtin_atan2f_ret
	ret

__system____builtin_exp2f
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, ##1123942400
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	mov	result1, ##2139095040
 if_ae	jmp	#LR__2721
	mov	arg01, local01
	mov	arg02, ##-1023541248
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__2721
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local02, result1
	abs	arg01, local02 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local04, result1
	mov	arg01, local04
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__2720
	mov	arg01, local04
	mov	arg02, ##1065353216
	call	#__system___float_add
	mov	local04, result1
	sub	local02, #1
LR__2720
	add	local02, #127
	shl	local02, #23
	mov	arg01, local04
	mov	arg02, ##1291845632
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local04, result1 wz
 if_e	mov	result1, local02
 if_e	jmp	#LR__2721
	bith	local04, #62
	qexp	local04
	mov	arg01, local02
	getqx	arg02
	add	arg02, #1
	shr	arg02, #1
	add	arg02, ##1056964608
	call	#__system___float_mul
LR__2721
	mov	ptra, fp
	call	#popregs_
__system____builtin_exp2f_ret
	ret

__system____builtin_log2f
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01 wz
 if_ne	cmp	local02, ##-2147483648 wz
 if_e	neg	result1, ##8388608
 if_e	jmp	#LR__2734
	cmps	local02, #0 wc
 if_b	mov	result1, ##2143289344
 if_b	jmp	#LR__2734
	mov	arg01, local01
	mov	arg02, ##1092616192
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, ##1079286392
 if_e	jmp	#LR__2734
	mov	arg01, local01
	mov	arg02, ##1076754516
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, ##1069066811
 if_e	jmp	#LR__2734
	mov	local03, local02
	shr	local03, #23
	getbyte	local03, local03, #0
	bitl	local02, #279
	mov	local04, local02
	cmp	local03, #255 wz
 if_ne	jmp	#LR__2730
	cmp	local04, #0 wz
 if_ne	mov	local05, ##2139095040
 if_e	mov	local05, ##2143289344
	mov	result1, local05
	jmp	#LR__2734
LR__2730
	cmp	local03, #0 wz
 if_ne	bith	local04, #23
 if_ne	sub	local03, #127
 if_ne	jmp	#LR__2733
	cmp	local04, #0 wz
 if_e	neg	result1, ##8388608
 if_e	jmp	#LR__2734
	neg	local03, #126
	callpa	#(@LR__2732-@LR__2731)>>2,fcache_load_ptr_
LR__2731
	testbn	local04, #23 wz
 if_e	shl	local04, #1
 if_e	add	local03, #1
 if_e	jmp	#LR__2731
LR__2732
LR__2733
	qlog	local04
	sub	local03, #1
	abs	arg01, local03 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	getqx	local05
	bitl	local05, #155
	add	local05, #8
	shr	local05, #4
	add	local05, ##1065353216
	call	#__system___float_fromuns
	xor	result1, local06
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_add
LR__2734
	mov	ptra, fp
	call	#popregs_
__system____builtin_log2f_ret
	ret

__system____builtin_powf
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local02
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local03, result1
	abs	arg01, local03 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg01, result1
	mov	arg02, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2740
	mov	arg01, ##1065353216
	mov	arg02, local01
	mov	arg03, local03
	call	#__system___float_pow_n
	jmp	#LR__2741
LR__2740
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	result1, ##2143289344
 if_b	jmp	#LR__2741
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__2741
	mov	arg01, local01
	call	#__system____builtin_log2f
	mov	arg01, result1
	mov	arg02, local02
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_exp2f
LR__2741
	mov	ptra, fp
	call	#popregs_
__system____builtin_powf_ret
	ret

__system___float_pow_n
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	cmps	local03, #0 wc
 if_ae	jmp	#LR__2750
	mov	local04, #1
	neg	local03, local03
	cmps	local03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__2758
	jmp	#LR__2751
LR__2750
	mov	local04, #0
LR__2751
	mov	local05, ##1065353216
LR__2752
	cmps	local03, #1 wc
 if_b	jmp	#LR__2754
	test	local03, #1 wz
 if_e	jmp	#LR__2753
	mov	arg01, local05
	mov	arg02, local02
	call	#__system___float_mul
	mov	local05, result1
LR__2753
	sar	local03, #1
	mov	arg01, local02
	mov	arg02, local02
	call	#__system___float_mul
	mov	local02, result1
	jmp	#LR__2752
LR__2754
	cmp	local04, #0 wz
 if_e	jmp	#LR__2755
	mov	arg01, local01
	mov	arg02, local05
	call	#__system___float_div
	mov	local05, result1
	jmp	#LR__2757
LR__2755
	mov	arg01, local01
	mov	arg02, ##1065353216
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__2756
	mov	arg01, local01
	mov	arg02, local05
	call	#__system___float_mul
	mov	local05, result1
LR__2756
LR__2757
	mov	result1, local05
LR__2758
	mov	ptra, fp
	call	#popregs_
__system___float_pow_n_ret
	ret

__system___gc_ptrs
	mov	_var01, __heap_ptr
	mov	_var02, _var01
	add	_var02, ##191992
	rdlong	result2, _var01 wz
 if_ne	jmp	#LR__2760
	mov	result2, _var02
	sub	result2, _var01
	wrword	#1, _var01
	mov	result1, _var01
	add	result1, #2
	wrword	##27792, result1
	mov	result1, _var01
	add	result1, #4
	wrword	#0, result1
	mov	result1, _var01
	add	result1, #6
	wrword	#1, result1
	add	_var01, #16
	abs	result2, result2 wc
	shr	result2, #4
	negc	result2, result2
	wrword	result2, _var01
	mov	result2, _var01
	add	result2, #2
	wrword	##27791, result2
	mov	result2, _var01
	add	result2, #4
	wrword	#0, result2
	mov	result2, _var01
	add	result2, #6
	wrword	#0, result2
	sub	_var01, #16
LR__2760
	mov	result1, _var01
	mov	result2, _var02
__system___gc_ptrs_ret
	ret

__system___gc_tryalloc
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
	mov	local05, local03
	mov	local06, #0
	callpa	#(@LR__2771-@LR__2770)>>2,fcache_load_ptr_
LR__2770
	mov	local07, local05
	add	local05, #6
	rdword	arg02, local05 wz
	mov	arg01, local03
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local05, result1 wz
 if_ne	rdword	local06, local05
	cmp	local05, #0 wz
 if_ne	cmps	local05, local04 wc
 if_a	jmp	#LR__2772
 if_ne	cmps	local01, local06 wcz
 if_a	jmp	#LR__2770
LR__2771
LR__2772
	cmp	local05, #0 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__2775
	mov	result2, local05
	add	result2, #6
	rdword	local08, result2
	cmps	local01, local06 wc
 if_ae	jmp	#LR__2774
	wrword	local01, local05
	mov	arg01, local05
	mov	local08, local01
	shl	local08, #4
	add	arg01, local08
	sub	local06, local01
	wrword	local06, arg01
	mov	local08, arg01
	add	local08, #2
	wrword	##27791, local08
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, arg01
	add	local08, #4
	wrword	result1, local08
	mov	local08, local05
	add	local08, #6
	mov	arg02, arg01
	rdword	local08, local08
	add	arg02, #6
	wrword	local08, arg02
	mov	local09, arg01
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, result1
	rdword	local10, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local10, #4
 if_ne	add	arg01, local10
 if_ne	mov	result1, arg01
	mov	local11, result1 wz
 if_e	jmp	#LR__2773
	cmps	local11, local04 wc
 if_ae	jmp	#LR__2773
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local11, #4
	wrword	result1, local11
LR__2773
LR__2774
	add	local07, #6
	wrword	local08, local07
	mov	local09, ##27776
	or	local09, local02
	mov	result1, #0
	cogid	result1
	or	local09, result1
	mov	local11, local05
	add	local11, #2
	wrword	local09, local11
	mov	local09, local03
	add	local09, #8
	mov	local11, local05
	rdword	local09, local09
	add	local11, #6
	wrword	local09, local11
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local03, #8
	wrword	result1, local03
	add	local05, #8
	mov	result1, local05
LR__2775
	mov	ptra, fp
	call	#popregs_
__system___gc_tryalloc_ret
	ret

__system___gc_alloc_managed
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, #0
	call	#__system___gc_doalloc
	mov	arg02, result1 wz
 if_e	cmps	local01, #1 wc
 if_nc_and_z	mov	result1, #0
 if_c_or_nz	mov	result1, arg02
	mov	ptra, fp
	call	#popregs_
__system___gc_alloc_managed_ret
	ret

__system___gc_doalloc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, arg02
 if_e	mov	result1, #0
 if_e	jmp	#LR__2787
	add	local01, #23
	andn	local01, #15
	shr	local01, #4
	add	ptr___system__dat__, #28
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #28
	call	#__system___lockmem
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1 wz
 if_ne	jmp	#LR__2780
	call	#__system___gc_docollect
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1
LR__2780
	add	ptr___system__dat__, #28
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #28
	wrlong	#0, arg01
	cmp	local03, #0 wz
 if_e	jmp	#LR__2786
	shl	local01, #4
	sub	local01, #8
	abs	local04, local01 wc
	shr	local04, #2
	negc	local05, local04 wz
	mov	local06, local03
 if_e	jmp	#LR__2785
	callpa	#(@LR__2783-@LR__2781)>>2,fcache_load_ptr_
LR__2781
	rep	@LR__2784, local05
LR__2782
	wrlong	#0, local06
	add	local06, #4
LR__2783
LR__2784
LR__2785
LR__2786
	mov	result1, local03
LR__2787
	mov	ptra, fp
	call	#popregs_
__system___gc_doalloc_ret
	ret

__system___gc_isvalidptr
	bitl	arg03, #248
	sub	arg03, #8
	cmps	arg03, arg01 wc
 if_b	jmp	#LR__2790
	cmps	arg03, arg02 wc
 if_b	jmp	#LR__2791
LR__2790
	mov	result1, #0
	jmp	#__system___gc_isvalidptr_ret
LR__2791
	mov	_var01, arg03
	xor	_var01, arg01
	test	_var01, #15 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___gc_isvalidptr_ret
	mov	_var01, arg03
	add	_var01, #2
	rdword	_var01, _var01
	and	_var01, ##65472
	cmp	_var01, ##27776 wz
 if_ne	mov	result1, #0
 if_e	mov	result1, arg03
__system___gc_isvalidptr_ret
	ret

__system___gc_free
	mov	arg03, arg01
	call	#__system___gc_ptrs
	mov	arg01, result1
	mov	arg02, result2
	call	#__system___gc_isvalidptr
	mov	arg02, result1 wz
 if_e	jmp	#LR__2800
	add	ptr___system__dat__, #28
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #28
	call	#__system___lockmem
	mov	arg01, arg02
	call	#__system___gc_dofree
	add	ptr___system__dat__, #28
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #28
	wrlong	#0, arg01
LR__2800
__system___gc_free_ret
	ret

__system___gc_dofree
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	call	#__system___gc_ptrs
	mov	local02, result1
	mov	local03, result2
	mov	arg02, local01
	add	arg02, #2
	wrword	##27791, arg02
	mov	local04, local01
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	callpa	#(@LR__2811-@LR__2810)>>2,fcache_load_ptr_
LR__2810
	add	local04, #4
	rdword	arg02, local04 wz
	mov	arg01, local02
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_e	jmp	#LR__2812
	mov	arg01, local04
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__2810
LR__2811
LR__2812
	cmp	local04, #0 wz
 if_e	mov	local04, local02
	mov	arg02, local04
	add	arg02, #6
	mov	arg01, local01
	rdword	arg02, arg02
	add	arg01, #6
	wrword	arg02, arg01
	mov	arg02, local01 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local04
	add	arg02, #6
	wrword	result1, arg02
	cmp	local04, local02 wz
 if_e	jmp	#LR__2815
	mov	arg01, local04
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	cmp	result1, local01 wz
 if_ne	jmp	#LR__2814
	rdword	local06, local04
	rdword	arg02, local01
	add	local06, arg02
	wrword	local06, local04
	mov	local06, local01
	add	local06, #2
	wrword	#0, local06
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	cmps	local06, local03 wc
 if_ae	jmp	#LR__2813
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local06
	add	arg02, #4
	wrword	result1, arg02
LR__2813
	mov	arg02, local01
	add	arg02, #6
	mov	result2, local04
	rdword	arg02, arg02
	add	result2, #6
	wrword	arg02, result2
	add	local01, #6
	wrword	#0, local01
	mov	local01, local04
LR__2814
LR__2815
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	arg02, result1 wz
 if_e	jmp	#LR__2817
	cmps	arg02, local03 wc
 if_ae	jmp	#LR__2817
	mov	arg01, arg02
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__2817
	mov	local04, local01
	rdword	local06, local04
	mov	arg01, arg02
	rdword	local01, arg01
	add	local06, local01
	wrword	local06, local04
	mov	local06, arg01
	add	local06, #6
	mov	local01, local04
	rdword	local06, local06
	add	local01, #6
	wrword	local06, local01
	mov	local06, arg01
	add	local06, #2
	wrword	#170, local06
	mov	local06, arg01
	add	local06, #6
	wrword	#0, local06
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1 wz
 if_e	jmp	#LR__2816
	cmps	local06, local03 wc
 if_ae	jmp	#LR__2816
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local04, local06
	add	local04, #4
	wrword	result1, local04
LR__2816
LR__2817
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___gc_dofree_ret
	ret

__system___gc_docollect
	mov	COUNT_, #5
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result2
	mov	local02, result1
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
	mov	result1, #0
	cogid	result1
	mov	local05, result1
 if_e	jmp	#LR__2822
	callpa	#(@LR__2821-@LR__2820)>>2,fcache_load_ptr_
LR__2820
	cmps	local04, local01 wc
 if_ae	jmp	#LR__2822
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	andn	arg02, #32
	mov	arg01, local04
	add	arg01, #2
	wrword	arg02, arg01
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_ne	jmp	#LR__2820
LR__2821
LR__2822
	mov	local03, #0
	mov	arg01, #0
	call	#__system____topofstack
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___gc_markhub
	call	#__system___gc_markcog
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1 wz
 if_e	jmp	#LR__2826
LR__2823
	mov	local04, local02
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	test	arg02, #32 wz
 if_e	test	arg02, #16 wz
 if_ne	jmp	#LR__2825
	getnib	arg02, arg02, #0
	cmp	arg02, local05 wz
 if_ne	cmp	arg02, #14 wz
 if_ne	jmp	#LR__2824
	mov	arg01, local04
	call	#__system___gc_dofree
	mov	local02, result1
LR__2824
LR__2825
	cmp	local02, #0 wz
 if_ne	cmps	local02, local01 wc
 if_c_and_nz	jmp	#LR__2823
LR__2826
	mov	ptra, fp
	call	#popregs_
__system___gc_docollect_ret
	ret

__system___gc_markhub
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
LR__2830
	cmps	local01, local02 wc
 if_ae	jmp	#LR__2831
	rdlong	arg03, local01
	add	local01, #4
	mov	arg02, local04
	mov	arg01, local03
	call	#__system___gc_isvalidptr
	mov	arg03, result1 wz
 if_e	jmp	#LR__2830
	mov	arg01, arg03
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2830
	mov	result2, arg03
	add	result2, #2
	rdword	result2, result2
	andn	result2, #15
	or	result2, #46
	add	arg03, #2
	wrword	result2, arg03
	jmp	#LR__2830
LR__2831
	mov	ptra, fp
	call	#popregs_
__system___gc_markhub_ret
	ret

__system___gc_markcog
	mov	COUNT_, #4
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result1
	mov	local02, result2
	mov	local03, #495
LR__2840
	'.live	local03
	alts	local03, #0
	mov	local04, local03
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local04
	call	#__system___gc_isvalidptr
	cmp	result1, #0 wz
 if_e	jmp	#LR__2841
	mov	local04, result1
	add	local04, #2
	rdword	local04, local04
	or	local04, #32
	add	result1, #2
	wrword	local04, result1
LR__2841
	sub	local03, #1
	cmps	local03, #0 wc
 if_ae	jmp	#LR__2840
	mov	ptra, fp
	call	#popregs_
__system___gc_markcog_ret
	ret

__system__opendir
	mov	COUNT_, #6
	call	#pushregs_
	add	ptr___system__dat__, #388
	mov	local01, ptr___system__dat__
	mov	arg02, arg01
	mov	arg01, local01
	mov	arg03, #0
	sub	ptr___system__dat__, #388
	call	#__system____getvfsforfile
	mov	local02, result1 wz
 if_e	jmp	#LR__2850
	add	local02, #40
	rdlong	arg03, local02 wz
	sub	local02, #40
 if_ne	jmp	#LR__2851
LR__2850
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__2853
LR__2851
	mov	arg01, #92
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	mov	result1, #0
 if_e	jmp	#LR__2853
	add	local02, #40
	rdlong	local04, local02
	mov	local05, local04
	sub	local02, #40
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local03
	mov	arg02, local01
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	mov	arg03, result1 wz
 if_e	jmp	#LR__2852
	cmps	arg03, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg03, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	arg01, local03
	call	#__system___gc_free
	mov	result1, #0
	jmp	#LR__2853
LR__2852
	wrlong	local02, local03
	mov	result1, local03
LR__2853
	mov	ptra, fp
	call	#popregs_
__system__opendir_ret
	ret

__system__closedir
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	rdlong	arg01, local01
	add	arg01, #44
	rdlong	local02, arg01
	mov	local03, local02
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg01, local01
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
	mov	local04, result1
	mov	arg01, local01
	call	#__system___gc_free
	cmps	local04, #0 wz
	add	ptr___system__dat__, #32
	wrlong	local04, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system__closedir_ret
	ret

__system__readdir
	mov	COUNT_, #4
	call	#pushregs_
	rdlong	arg02, arg01 wz
	add	arg01, #8
	mov	local01, arg01
	sub	arg01, #8
 if_e	mov	result1, #0
 if_e	jmp	#LR__2861
	add	arg02, #48
	rdlong	local02, arg02
	mov	local03, local02
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg02, local01
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
	cmps	result1, #0 wz
 if_e	jmp	#LR__2860
	cmps	result1, #1 wc
 if_ae	cmps	result1, #0 wz
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	result1, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__2861
LR__2860
	mov	result1, local01
LR__2861
	mov	ptra, fp
	call	#popregs_
__system__readdir_ret
	ret

__system___openraw
	mov	COUNT_, #21
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, #4
	mov	local06, local01
	mov	local07, #0
	add	ptr___system__dat__, #388
	mov	local08, ptr___system__dat__
	mov	arg01, local08
	mov	arg02, local02
	mov	arg03, #0
	sub	ptr___system__dat__, #388
	call	#__system____getvfsforfile
	mov	local09, result1 wz
 if_e	jmp	#LR__2870
	add	local09, #32
	rdlong	result1, local09 wz
	sub	local09, #32
 if_ne	jmp	#LR__2871
LR__2870
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__2884
LR__2871
	mov	arg01, local06
	mov	arg02, #0
	mov	arg03, #52
	mov	local10, arg01
	call	#\builtin_bytefill_
	add	local09, #32
	rdlong	local11, local09
	mov	local12, local11
	mov	local13, local11
	sub	local09, #32
	mov	local14, local13
	zerox	local12, #19
	shr	local14, #20
	shl	local14, #2
	add	local14, __methods__
	rdlong	local14, local14
	mov	local15, local06
	mov	local16, local08
	mov	local17, local03
	mov	arg01, local15
	mov	arg02, local16
	mov	arg03, local17
	mov	local18, objptr
	mov	objptr, local12
	call	local14
	mov	objptr, local18
	mov	local19, result1 wz
 if_ne	test	local03, #4 wz
 if_e	jmp	#LR__2872
	add	local09, #36
	rdlong	local11, local09
	mov	local12, local11
	mov	local13, local11
	sub	local09, #36
	mov	local14, local13
	zerox	local12, #19
	shr	local14, #20
	shl	local14, #2
	add	local14, __methods__
	rdlong	local14, local14
	mov	local15, local06
	mov	local16, local08
	mov	local17, local04
	mov	arg01, local15
	mov	arg02, local16
	mov	arg03, local17
	mov	local18, objptr
	mov	objptr, local12
	call	local14
	mov	objptr, local18
	mov	local19, result1
LR__2872
	cmp	local19, #0 wz
 if_ne	jmp	#LR__2882
	mov	local20, local03
	and	local20, #3 wz
 if_ne	or	local05, #2
	cmp	local20, #1 wz
 if_ne	or	local05, #1
	test	local03, #32 wz
 if_ne	or	local05, #192
	add	local06, #8
	wrlong	local05, local06
	add	local06, #12
	rdlong	local21, local06 wz
	sub	local06, #20
 if_ne	jmp	#LR__2873
	add	local09, #4
	rdlong	local21, local09
	sub	local09, #4
	add	local06, #20
	wrlong	local21, local06
	sub	local06, #20
LR__2873
	add	local06, #24
	rdlong	local21, local06 wz
	sub	local06, #24
 if_ne	jmp	#LR__2874
	add	local09, #8
	rdlong	local21, local09
	sub	local09, #8
	add	local06, #24
	wrlong	local21, local06
	sub	local06, #24
LR__2874
	add	local06, #36
	rdlong	local21, local06 wz
	sub	local06, #36
 if_e	rdlong	local21, local09
 if_e	add	local06, #36
 if_e	wrlong	local21, local06
 if_e	sub	local06, #36
	add	local06, #40
	rdlong	local21, local06 wz
	sub	local06, #40
 if_ne	jmp	#LR__2875
	add	local09, #16
	rdlong	local21, local09
	sub	local09, #16
	add	local06, #40
	wrlong	local21, local06
	sub	local06, #40
LR__2875
	add	local06, #48
	rdlong	local21, local06 wz
	sub	local06, #48
 if_ne	jmp	#LR__2876
	add	local09, #12
	rdlong	local21, local09
	sub	local09, #12
	add	local06, #48
	wrlong	local21, local06
	sub	local06, #48
LR__2876
	add	local06, #28
	rdlong	local21, local06 wz
	sub	local06, #28
 if_ne	jmp	#LR__2877
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##114294784
	add	local06, #28
	wrlong	arg01, local06
	sub	local06, #28
LR__2877
	add	local06, #32
	rdlong	local21, local06 wz
	sub	local06, #32
 if_ne	jmp	#LR__2878
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##115343360
	add	local06, #32
	wrlong	arg01, local06
	sub	local06, #32
LR__2878
	add	local06, #44
	rdlong	local21, local06 wz
	sub	local06, #44
 if_ne	jmp	#LR__2881
	add	local09, #20
	rdlong	local21, local09 wz
	sub	local09, #20
 if_e	jmp	#LR__2879
	add	local09, #20
	rdlong	local21, local09
	add	local06, #44
	wrlong	local21, local06
	sub	local06, #44
	jmp	#LR__2880
LR__2879
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##116391936
	add	local06, #44
	wrlong	arg01, local06
	sub	local06, #44
LR__2880
LR__2881
LR__2882
	cmp	local07, #0 wz
 if_ne	mov	arg01, local06
 if_ne	call	#__system____default_buffer_init
	cmp	local19, #0 wz
 if_e	mov	arg01, #0
 if_ne	jmp	#LR__2883
	cmps	arg01, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
LR__2883
	mov	result1, local19
LR__2884
	mov	ptra, fp
	call	#popregs_
__system___openraw_ret
	ret

__system___closeraw
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__2892
	add	local01, #44
	rdlong	result1, local01 wz
	sub	local01, #44
 if_e	jmp	#LR__2890
	add	local01, #44
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #44
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
LR__2890
	add	local01, #36
	rdlong	local05, local01 wz
	sub	local01, #36
 if_e	jmp	#LR__2891
	add	local01, #36
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #36
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local02, result1
LR__2891
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
	mov	result1, local02
LR__2892
	mov	ptra, fp
	call	#popregs_
__system___closeraw_ret
	ret

__system___vfs_open_sdcardx
	mov	COUNT_, #11
	call	#pushregs_
	mov	local03, arg01
	mov	local04, arg02
	mov	local05, arg03
	mov	local06, arg04
	mov	arg01, ##548
	call	#__system___gc_alloc_managed
	mov	local07, result1
	mov	arg01, ##564
	call	#__system___gc_alloc_managed
	mov	local08, result1
	mov	arg04, local03
	sar	arg04, #31
	mov	arg03, local03
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	local01, result1
	mov	local09, result2
	mov	arg04, local04
	sar	arg04, #31
	mov	arg03, local04
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local09, result2
	mov	arg04, local05
	sar	arg04, #31
	mov	arg03, local05
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local09, result2
	mov	arg04, local06
	sar	arg04, #31
	mov	arg03, local06
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	arg02, local09
	or	local01, result1
	or	result2, arg02
	mov	local02, result2
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___usepins
	cmp	result1, #0 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#22, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	mov	result1, #0
 if_e	jmp	#LR__2902
	mov	local10, local01
	mov	local09, local02
	add	local07, ##520
	wrlong	local10, local07
	add	local07, #4
	wrlong	local09, local07
	sub	local07, ##524
	mov	arg05, local06
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local05
	mov	local10, objptr
	mov	objptr, local07
	call	#_fatfs_cc_disk_setpins
	mov	objptr, local10
	mov	local11, result1 wz
 if_ne	jmp	#LR__2900
	mov	arg02, ##@LR__4297
	mov	arg01, local08
	mov	arg03, #0
	mov	local11, objptr
	mov	objptr, local07
	call	#_fatfs_cc_f_mount
	mov	objptr, local11
	mov	local11, result1
LR__2900
	cmp	local11, #0 wz
 if_e	jmp	#LR__2901
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___freepins
	neg	arg01, local11 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__2902
LR__2901
	mov	arg01, local07
	mov	local11, objptr
	mov	objptr, local07
	call	#_fatfs_cc_get_vfs
	mov	objptr, local11
LR__2902
	mov	ptra, fp
	call	#popregs_
__system___vfs_open_sdcardx_ret
	ret

__system____default_getc
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #8
	rdlong	local03, local02
	test	local03, #2 wz
 if_ne	mov	arg01, local01
 if_ne	call	#__system____default_flush
	rdlong	local03, local02
	or	local03, #1
	wrlong	local03, local02
	sub	local02, #8
	rdlong	local03, local02 wz
 if_ne	jmp	#LR__2910
	mov	arg01, local01
	call	#__system____default_filbuf
	mov	local03, result1
LR__2910
	cmps	local03, #1 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__2911
	sub	local03, #1
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	rdbyte	result1, local03
	add	local03, #1
	wrlong	local03, local02
LR__2911
	mov	ptra, fp
	call	#popregs_
__system____default_getc_ret
	ret

__system____default_putc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local02
	add	local03, #8
	rdlong	result1, local03
	test	result1, #1 wz
 if_ne	mov	arg01, local02
 if_ne	call	#__system____default_flush
	rdlong	local04, local03
	or	local04, #2
	wrlong	local04, local03
	sub	local03, #8
	rdlong	local05, local03
	add	local03, #16
	rdlong	arg02, local03
	sub	local03, #16
	mov	result1, local05
	add	result1, arg02
	wrbyte	local01, result1
	getbyte	local01, local01, #0
	add	local05, #1
	wrlong	local05, local03
	add	local02, #6
	rdword	local06, local02 wz
	sub	local02, #6
 if_ne	add	local03, #12
 if_ne	rdlong	local04, local03
 if_ne	cmp	local05, local04 wz
 if_e	jmp	#LR__2920
	cmp	local01, #10 wz
 if_e	cmp	local06, #1 wz
 if_ne	jmp	#LR__2921
LR__2920
	mov	arg01, local02
	call	#__system____default_flush
	cmp	result1, #0 wz
 if_ne	neg	local01, #1
LR__2921
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system____default_putc_ret
	ret

__system____default_flush
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	rdlong	local03, local02
	add	local02, #8
	rdlong	result1, local02
	sub	local02, #8
	test	result1, #2 wz
 if_e	jmp	#LR__2932
	cmps	local03, #1 wc
 if_b	jmp	#LR__2934
	add	local01, #8
	rdlong	result1, local01
	sub	local01, #8
	test	result1, #64 wz
 if_e	jmp	#LR__2931
	add	local01, #8
	rdlong	arg03, local01
	sub	local01, #8
	test	arg03, #128 wz
 if_e	jmp	#LR__2930
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #2
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	add	local01, #8
	rdlong	local06, local01
	andn	local06, #128
	wrlong	local06, local01
	sub	local01, #8
LR__2930
LR__2931
	add	local01, #24
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #24
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	add	local02, #16
	rdlong	arg02, local02
	sub	local02, #16
	mov	arg01, local01
	mov	arg03, local03
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	jmp	#LR__2934
LR__2932
	add	local02, #8
	rdlong	local06, local02
	sub	local02, #8
	test	local06, #1 wz
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__2933
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	neg	arg02, local03
	mov	arg03, #1
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
LR__2933
LR__2934
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system____default_flush_ret
	ret

__system____default_buffer_init
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	call	#__system___isatty
	cmp	result1, #0 wz
 if_ne	add	local01, #6
 if_ne	wrword	#5, local01
 if_e	add	local01, #6
 if_e	wrword	#6, local01
	add	local02, #20
	mov	local01, local02
	sub	local02, #4
	wrlong	local01, local02
	sub	local02, #4
	wrlong	##1024, local02
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system____default_buffer_init_ret
	ret

__system__stat
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	add	ptr___system__dat__, #388
	mov	local02, ptr___system__dat__
	mov	arg02, arg01
	mov	arg01, local02
	mov	arg03, #0
	sub	ptr___system__dat__, #388
	call	#__system____getvfsforfile
	mov	local03, result1 wz
 if_e	jmp	#LR__2940
	add	local03, #52
	rdlong	arg03, local03 wz
	sub	local03, #52
 if_ne	jmp	#LR__2941
LR__2940
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__2942
LR__2941
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #48
	mov	local04, arg01
	call	#\builtin_bytefill_
	mov	result1, local04
	rdbyte	arg01, local02 wz
 if_e	add	local01, #8
 if_e	wrlong	##4607, local01
 if_e	mov	result1, #0
 if_e	jmp	#LR__2942
	add	local03, #52
	rdlong	local03, local03
	mov	local04, local03
	zerox	local03, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local02
	mov	arg02, local01
	mov	local02, objptr
	mov	objptr, local03
	call	local04
	mov	objptr, local02
LR__2942
	mov	ptra, fp
	call	#popregs_
__system__stat_ret
	ret

__system__read
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__2950
	qmul	arg01, #52
	add	ptr___system__dat__, ##1312
	getqx	arg01
	add	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1312
	call	#__system___vfsread
LR__2950
__system__read_ret
	ret

__system__close
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__2960
	qmul	arg01, #52
	add	ptr___system__dat__, ##1312
	getqx	arg01
	add	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1312
	call	#__system___closeraw
LR__2960
__system__close_ret
	ret

__system__lseek
	mov	COUNT_, #6
	call	#pushregs_
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__2971
	qmul	arg01, #52
	add	ptr___system__dat__, ##1312
	getqx	local01
	add	local01, ptr___system__dat__
	add	local01, #48
	rdlong	arg01, local01 wz
	sub	local01, #48
	sub	ptr___system__dat__, ##1312
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#16, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__2971
	add	local01, #8
	rdlong	local02, local01
	sub	local01, #8
	test	local02, #64 wz
 if_ne	add	local01, #8
 if_ne	rdlong	local02, local01
 if_ne	or	local02, #128
 if_ne	wrlong	local02, local01
 if_ne	sub	local01, #8
	add	local01, #48
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #48
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local06, result1
	cmps	local06, #0 wc
 if_ae	jmp	#LR__2970
	neg	arg01, local06 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__2971
LR__2970
	mov	result1, local06
LR__2971
	mov	ptra, fp
	call	#popregs_
__system__lseek_ret
	ret

__system___ioctl
	mov	COUNT_, #3
	call	#pushregs_
	cmps	arg01, #0 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__2981
	add	arg01, #40
	rdlong	local01, arg01
	mov	local02, local01
	sub	arg01, #40
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	arg01, result1 wz
 if_e	jmp	#LR__2980
	cmps	arg01, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__2981
LR__2980
	mov	result1, #0
LR__2981
	mov	ptra, fp
	call	#popregs_
__system___ioctl_ret
	ret

__system___isatty
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg03, fp
	sub	fp, #8
	mov	arg02, #256
	call	#__system___ioctl
	cmp	result1, #0 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system___isatty_ret
	ret

__system____getftab
	cmp	arg01, #10 wc
 if_b	qmul	arg01, #52
 if_ae	mov	result1, #0
 if_b	add	ptr___system__dat__, ##1312
 if_b	getqx	result1
 if_b	add	result1, ptr___system__dat__
 if_b	sub	ptr___system__dat__, ##1312
__system____getftab_ret
	ret

__system__strncpy
	mov	_var01, arg01
LR__2990
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_b	jmp	#LR__2991
	rdbyte	result1, arg02
	wrbyte	result1, _var01
	add	arg02, #1
	rdbyte	result1, _var01 wz
	add	_var01, #1
 if_ne	jmp	#LR__2990
LR__2991
	callpa	#(@LR__2993-@LR__2992)>>2,fcache_load_ptr_
LR__2992
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_ae	mov	_var02, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	#0, _var02
 if_ae	jmp	#LR__2992
LR__2993
	mov	result1, arg01
__system__strncpy_ret
	ret

__system__strncat
	cmps	arg02, #0 wz
 if_e	jmp	#LR__3004
	cmp	arg03, #1 wc
 if_b	jmp	#LR__3004
	mov	_var01, arg01
	callpa	#(@LR__3002-@LR__3000)>>2,fcache_load_ptr_
LR__3000
	rdbyte	result1, _var01 wz
 if_ne	add	_var01, #1
 if_ne	jmp	#LR__3000
	mov	_var02, arg03
LR__3001
	rdbyte	_var03, arg02
	mov	_var04, _var03
	zerox	_var04, #7 wz
	add	arg02, #1
 if_e	jmp	#LR__3003
	sub	_var02, #1
	cmps	_var02, #0 wc
 if_ae	mov	_var04, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	_var03, _var04
 if_ae	jmp	#LR__3001
LR__3002
LR__3003
	wrbyte	#0, _var01
LR__3004
	mov	result1, arg01
__system__strncat_ret
	ret

__system__strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__3010
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#__system__strncmp_ret
LR__3010
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#__system__strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__3012-@LR__3011)>>2,fcache_load_ptr_
LR__3011
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__3013
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__3011
LR__3012
LR__3013
	cmps	_var03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#__system__strncmp_ret
	cmp	_var04, _var06 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system__strncmp_ret
	cmp	_var04, #0 wz
 if_e	neg	result1, #1
 if_e	jmp	#__system__strncmp_ret
	cmp	_var06, #0 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
__system__strncmp_ret
	ret

__system____root_opendir
	add	ptr___system__dat__, #100
	add	arg01, #4
	wrlong	ptr___system__dat__, arg01
	mov	result1, #0
	sub	ptr___system__dat__, #100
__system____root_opendir_ret
	ret

__system____root_readdir
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	add	local01, #4
	rdlong	local03, local01
	sub	local01, #4
LR__3020
	add	ptr___system__dat__, #116
	cmp	local03, ptr___system__dat__ wz
	sub	ptr___system__dat__, #116
 if_e	neg	result1, #1
 if_e	jmp	#LR__3021
	rdlong	arg03, local03 wz
 if_e	add	local03, #4
 if_e	jmp	#LR__3020
	rdlong	arg02, local03
	add	arg02, #1
	mov	arg01, local02
	mov	arg03, #64
	call	#__system__strncpy
	add	local02, #80
	wrbyte	#1, local02
	sub	local02, #8
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local03, #4
	add	local01, #4
	wrlong	local03, local01
	mov	result1, #0
LR__3021
	mov	ptra, fp
	call	#popregs_
__system____root_readdir_ret
	ret

__system____root_closedir
	mov	result1, #0
__system____root_closedir_ret
	ret

__system____root_stat
	mov	_var01, arg02
	mov	arg01, _var01
	mov	arg02, #0
	mov	arg03, #48
	call	#\builtin_bytefill_
	add	_var01, #8
	wrlong	##4607, _var01
	mov	result1, #0
__system____root_stat_ret
	ret

__system___normalizeName
	mov	_var01, #0
	mov	_var02, arg01
	mov	_var03, _var02
LR__3030
	rdbyte	_var04, _var02 wz
 if_e	jmp	#LR__3049
	cmp	_var01, #0 wz
 if_ne	mov	_var04, _var03
 if_ne	add	_var03, #1
 if_ne	wrbyte	#47, _var04
 if_ne	mov	_var01, #0
	rdbyte	_var04, _var02
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__3042
	add	_var02, #1
	rdbyte	_var04, _var02
	sub	_var02, #1
	cmp	_var04, #47 wz
 if_e	jmp	#LR__3031
	add	_var02, #1
	rdbyte	_var05, _var02
	sub	_var02, #1
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__3032
LR__3031
	mov	_var07, _var02
	add	_var07, #1
	mov	_var02, _var07
	jmp	#LR__3046
LR__3032
	add	_var02, #1
	rdbyte	_var07, _var02
	sub	_var02, #1
	getbyte	_var04, _var07, #0
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__3041
	add	_var02, #2
	rdbyte	_var07, _var02
	sub	_var02, #2
	getbyte	_var04, _var07, #0
	cmp	_var04, #47 wz
 if_e	jmp	#LR__3033
	add	_var02, #2
	rdbyte	_var05, _var02
	sub	_var02, #2
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__3040
LR__3033
	add	_var02, #2
	cmps	_var03, arg01 wcz
 if_be	jmp	#LR__3039
	mov	_var08, _var03
	sub	_var08, #1
LR__3034
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__3035
	cmps	_var08, arg01 wcz
 if_a	sub	_var08, #1
 if_a	jmp	#LR__3034
LR__3035
	callpa	#(@LR__3037-@LR__3036)>>2,fcache_load_ptr_
LR__3036
	cmps	_var08, arg01 wcz
 if_be	jmp	#LR__3038
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	sub	_var08, #1
 if_ne	jmp	#LR__3036
LR__3037
LR__3038
	mov	_var03, _var08
LR__3039
	mov	_var01, #1
	jmp	#LR__3046
LR__3040
LR__3041
LR__3042
	callpa	#(@LR__3044-@LR__3043)>>2,fcache_load_ptr_
LR__3043
	rdbyte	_var04, _var02 wz
 if_ne	rdbyte	_var07, _var02
 if_ne	cmp	_var07, #47 wz
 if_e	jmp	#LR__3045
	mov	_var06, _var02
	mov	_var05, _var02
	add	_var05, #1
	rdbyte	_var09, _var06
	mov	_var02, _var05
	wrbyte	_var09, _var03
	add	_var03, #1
	jmp	#LR__3043
LR__3044
LR__3045
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__3030
	mov	_var01, #1
LR__3046
	callpa	#(@LR__3048-@LR__3047)>>2,fcache_load_ptr_
LR__3047
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_e	mov	_var07, _var02
 if_e	add	_var07, #1
 if_e	mov	_var02, _var07
 if_e	jmp	#LR__3047
LR__3048
	jmp	#LR__3030
LR__3049
	wrbyte	#0, _var03
__system___normalizeName_ret
	ret

__system___strrev
	rdbyte	_var01, arg01 wz
 if_e	jmp	#__system___strrev_ret
	mov	_var02, arg01
	callpa	#(@LR__3052-@LR__3050)>>2,fcache_load_ptr_
LR__3050
	rdbyte	_var01, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__3050
	sub	_var02, #1
LR__3051
	cmps	_var02, arg01 wcz
 if_be	jmp	#LR__3053
	rdbyte	_var01, arg01
	rdbyte	_var03, _var02
	wrbyte	_var03, arg01
	wrbyte	_var01, _var02
	add	arg01, #1
	sub	_var02, #1
	jmp	#LR__3051
LR__3052
LR__3053
__system___strrev_ret
	ret

__system___fmtpad
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg01, local02, #1
	shr	local02, #22
	and	local02, #3 wz
	mov	local04, #0
 if_e	mov	local02, #1
	test	local02, arg04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3063
	subr	local03, arg01
	cmps	local03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__3063
	cmp	local02, #3 wz
 if_ne	jmp	#LR__3060
	cmp	arg04, #1 wz
	wrz	local02
	add	local03, local02
	abs	local03, local03 wc
	shr	local03, #1
	negc	local03, local03
LR__3060
	cmps	local03, #1 wc
 if_b	jmp	#LR__3062
	mov	local05, local03
LR__3061
	mov	local02, local01
	mov	local06, local01
	zerox	local02, #19
	shr	local06, #20
	shl	local06, #2
	add	local06, __methods__
	rdlong	local06, local06
	mov	arg01, #32
	mov	local03, objptr
	mov	objptr, local02
	call	local06
	mov	objptr, local03
	mov	local06, result1
	cmps	local06, #0 wc
 if_b	mov	result1, local06
 if_b	jmp	#LR__3063
	add	local04, local06
	djnz	local05, #LR__3061
LR__3062
	mov	result1, local04
LR__3063
	mov	ptra, fp
	call	#popregs_
__system___fmtpad_ret
	ret

__system___uitoa
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	cmps	arg05, #0 wz
	mov	arg05, local01
	mov	local02, #0
 if_ne	mov	local03, #55
 if_e	mov	local03, #87
LR__3070
	qdiv	arg02, arg03
	getqy	local04
	qdiv	arg02, arg03
	cmp	local04, #10 wc
 if_b	add	local04, #48
 if_ae	add	local04, local03
	wrbyte	local04, arg05
	add	arg05, #1
	add	local02, #1
	getqx	arg02
	cmp	arg02, #0 wz
 if_ne	jmp	#LR__3070
	cmp	local02, arg04 wc
 if_b	jmp	#LR__3070
	wrbyte	#0, arg05
	mov	arg01, local01
	call	#__system___strrev
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
__system___uitoa_ret
	ret

__system__disassemble_0383
	mov	COUNT_, #16
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
	abs	arg01, local05 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	local07, result1
	mov	local08, #0
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	local09, #0
 if_e	wrlong	#0, local02
 if_e	wrlong	local09, local03
 if_e	jmp	#LR__3092
	mov	arg01, local01
	call	#__system____builtin_ilogb
	mov	local10, result1
	cmp	local05, #10 wz
 if_ne	jmp	#LR__3080
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	abs	local10, local09 wc
	qdiv	local10, #10
	mov	local11, #9
	getqx	local10
	negc	local10, local10
	jmp	#LR__3081
LR__3080
	mov	local11, #24
LR__3081
LR__3082
	cmps	local08, #8 wc
	add	local08, #1
 if_ae	jmp	#LR__3083
	mov	arg01, ##1065353216
	mov	arg02, local07
	mov	arg03, local10
	call	#__system___float_pow_n
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_div
	mov	local12, result1
	mov	arg01, local12
	mov	arg02, ##1065353216
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	sub	local10, #1
 if_b	jmp	#LR__3082
	mov	arg02, local07
	mov	arg01, local12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	add	local10, #1
 if_ae	jmp	#LR__3082
LR__3083
	mov	arg01, local12
	call	#__system____builtin_ilogb
	mov	local13, result1
	mov	local14, local12
	bitl	local14, #279
	bith	local14, #23
	shl	local14, local13
	cmp	local05, #2 wz
 if_e	shl	local04, #2
	mov	local15, #0
	cmps	local04, #0 wc
 if_ae	jmp	#LR__3084
	subr	local04, local10
	cmps	local04, #0 wc
 if_b	jmp	#LR__3091
	jmp	#LR__3085
LR__3084
	add	local04, #1
LR__3085
	fles	local04, local11 wcz
	mov	local16, #1
	callpa	#(@LR__3087-@LR__3086)>>2,fcache_load_ptr_
LR__3086
	cmp	local15, ##8388608 wc
 if_ae	jmp	#LR__3088
	cmps	local04, #1 wc
	sub	local04, #1
 if_b	jmp	#LR__3088
	qmul	local15, local05
	mov	local13, local14
	shr	local13, #23
	bitl	local14, #279
	getqx	local15
	qmul	local16, local05
	getqx	local16
	qmul	local14, local05
	add	local15, local13
	getqx	local14
	jmp	#LR__3086
LR__3087
LR__3088
	mov	local09, local05
	shl	local09, #23
	abs	local13, local09 wc
	shr	local13, #1
	negc	local13, local13
	cmp	local14, local13 wcz
 if_a	jmp	#LR__3089
	shl	local05, #23
	abs	local13, local05 wc
	shr	local13, #1
	negc	local13, local13
	cmp	local14, local13 wz
 if_ne	jmp	#LR__3090
	test	local15, #1 wz
 if_e	jmp	#LR__3090
LR__3089
	add	local15, #1
	cmp	local15, local16 wz
 if_e	add	local10, #1
LR__3090
LR__3091
	wrlong	local15, local02
	wrlong	local10, local03
LR__3092
	mov	ptra, fp
	call	#popregs_
__system__disassemble_0383_ret
	ret

__system__emitsign_0385
	mov	result1, #0
	cmp	arg02, #0 wz
 if_ne	mov	_var01, arg01
 if_ne	add	arg01, #1
 if_ne	wrbyte	arg02, _var01
 if_ne	mov	result1, #1
	cmp	arg03, #0 wz
 if_ne	wrbyte	#48, arg01
 if_ne	add	arg01, #1
 if_ne	wrbyte	arg03, arg01
 if_ne	add	result1, #2
__system__emitsign_0385_ret
	ret

__system___gettxfunc
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__3100
	add	local01, #8
	rdlong	arg02, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__3101
LR__3100
	mov	result1, #0
	jmp	#LR__3102
LR__3101
	or	local01, ##106954752
	mov	result1, local01
LR__3102
	mov	ptra, fp
	call	#popregs_
__system___gettxfunc_ret
	ret

__system___getrxfunc
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__3110
	add	local01, #8
	rdlong	arg02, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__3111
LR__3110
	mov	result1, #0
	jmp	#LR__3112
LR__3111
	or	local01, ##108003328
	mov	result1, local01
LR__3112
	mov	ptra, fp
	call	#popregs_
__system___getrxfunc_ret
	ret

__system___getiolock_0425
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__3120
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__3121
LR__3120
	add	ptr___system__dat__, ##724
	mov	result1, ptr___system__dat__
	sub	ptr___system__dat__, ##724
	jmp	#LR__3122
LR__3121
	add	local01, #12
	mov	result1, local01
LR__3122
	mov	ptra, fp
	call	#popregs_
__system___getiolock_0425_ret
	ret

__system____ScanForChar
	mov	_var01, arg01
	mov	_var02, arg01
	callpa	#(@LR__3131-@LR__3130)>>2,fcache_load_ptr_
LR__3130
	rdbyte	result1, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__3130
LR__3131
	sub	_var02, arg01
	mov	result1, _var02
	mov	arg01, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3138
	mov	_var03, arg02
	zerox	_var03, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3138
	cmp	arg03, #1 wc
 if_b	cmp	arg04, #0 wz
 if_c_and_z	mov	arg03, #1
 if_c_and_nz	mov	result1, #0
 if_c_and_nz	jmp	#LR__3138
	cmp	arg03, arg01 wcz
 if_be	jmp	#LR__3132
	cmp	arg04, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3138
	mov	arg03, arg01
LR__3132
	sub	arg03, #1
	cmp	arg04, #0 wz
 if_ne	jmp	#LR__3134
	mov	_var04, arg03
	mov	_var05, arg01
LR__3133
	cmp	_var04, _var05 wc
 if_ae	jmp	#LR__3137
	mov	_var03, _var04
	add	_var03, _var01
	rdbyte	_var03, _var03
	getbyte	arg04, arg02, #0
	cmp	_var03, arg04 wz
 if_e	add	_var04, #1
 if_e	mov	result1, _var04
 if_e	jmp	#LR__3138
	add	_var04, #1
	jmp	#LR__3133
LR__3134
	mov	_var04, arg03
LR__3135
	cmp	_var04, arg03 wcz
 if_a	jmp	#LR__3136
	mov	_var05, _var04
	add	_var05, _var01
	rdbyte	_var03, _var05
	getbyte	_var05, arg02, #0
	cmp	_var03, _var05 wz
 if_e	add	_var04, #1
 if_e	mov	result1, _var04
 if_e	jmp	#LR__3138
	sub	_var04, #1
	jmp	#LR__3135
LR__3136
LR__3137
	mov	result1, #0
LR__3138
__system____ScanForChar_ret
	ret

__system___basic_dir
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #76
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg02, fp wz
	sub	fp, #4
 if_ne	add	fp, #4
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #4
 if_ne	rdbyte	local02, local01 wz
 if_e	jmp	#LR__3140
	add	ptr___system__dat__, ##1832
	rdlong	local02, ptr___system__dat__ wz
	sub	ptr___system__dat__, ##1832
 if_ne	add	ptr___system__dat__, ##1832
 if_ne	rdlong	arg01, ptr___system__dat__
 if_ne	sub	ptr___system__dat__, ##1832
 if_ne	call	#__system__closedir
	mov	arg01, ##@LR__4298
	call	#__system__opendir
	add	ptr___system__dat__, ##1832
	wrlong	result1, ptr___system__dat__
	add	fp, #8
	rdlong	local02, fp
	add	ptr___system__dat__, #4
	wrlong	local02, ptr___system__dat__
	sub	fp, #4
	rdlong	local02, fp
	sub	fp, #4
	add	ptr___system__dat__, #4
	wrlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, ##1840
LR__3140
	add	ptr___system__dat__, ##1832
	rdlong	local02, ptr___system__dat__ wz
	sub	ptr___system__dat__, ##1832
 if_e	mov	result1, ##@LR__4299
 if_e	jmp	#LR__3153
LR__3141
	add	ptr___system__dat__, ##1832
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1832
	call	#__system__readdir
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3142
	add	ptr___system__dat__, ##1832
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1832
	call	#__system__closedir
	add	ptr___system__dat__, ##1832
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, ##1832
	mov	result1, ##@LR__4300
	jmp	#LR__3153
LR__3142
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	add	ptr___system__dat__, ##1840
	rdlong	arg02, ptr___system__dat__
	sub	ptr___system__dat__, ##1840
	call	#__system___pat_match
	cmp	result1, #0 wz
 if_e	jmp	#LR__3141
	add	ptr___system__dat__, ##1836
	rdlong	local02, ptr___system__dat__ wz
	sub	ptr___system__dat__, ##1836
 if_e	jmp	#LR__3149
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	mov	arg02, fp
	sub	fp, #16
	call	#__system__stat
	add	fp, #64
	wrlong	result1, fp
	sub	fp, #64
	cmp	result1, #0 wz
 if_ne	mov	result1, ##@LR__4301
 if_ne	jmp	#LR__3153
	add	fp, #24
	rdlong	local02, fp
	and	local02, ##61440
	add	fp, #44
	wrlong	local02, fp
	sub	fp, #56
	rdlong	local02, fp
	sub	fp, #12
	rdbyte	local02, local02
	cmp	local02, #46 wz
 if_e	add	fp, #8
 if_e	wrlong	#2, fp
	sumz	fp, #8
 if_ne	wrlong	#0, fp
 if_ne	sub	fp, #8
	add	fp, #68
	rdlong	local02, fp
	sub	fp, #68
	cmp	local02, ##4096 wz
 if_ne	jmp	#LR__3143
	add	fp, #8
	rdlong	local02, fp
	or	local02, #16
	wrlong	local02, fp
	sub	fp, #8
	jmp	#LR__3148
LR__3143
	add	fp, #68
	rdlong	local02, fp
	sub	fp, #68
	cmp	local02, ##8192 wz
 if_ne	add	fp, #68
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #68
 if_ne	cmp	local01, ##12288 wz
 if_ne	add	fp, #68
 if_ne	mov	local03, local01
 if_ne	sub	fp, #68
 if_ne	cmp	local03, ##16384 wz
 if_ne	jmp	#LR__3144
	add	fp, #8
	rdlong	local02, fp
	or	local02, #4
	wrlong	local02, fp
	sub	fp, #8
	jmp	#LR__3147
LR__3144
	add	fp, #24
	rdlong	local02, fp
	sub	fp, #24
	test	local02, #146 wz
 if_ne	jmp	#LR__3145
	add	fp, #8
	rdlong	local02, fp
	or	local02, #1
	wrlong	local02, fp
	sub	fp, #8
	jmp	#LR__3146
LR__3145
	add	fp, #68
	rdlong	local04, fp
	sub	fp, #68
	cmp	local04, ##4096 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local04, fp
 if_ne	or	local04, #32
 if_ne	wrlong	local04, fp
 if_ne	sub	fp, #8
LR__3146
LR__3147
LR__3148
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	add	ptr___system__dat__, ##1836
	rdlong	local01, ptr___system__dat__
	sub	ptr___system__dat__, ##1836
	test	local04, local01 wz
 if_e	jmp	#LR__3141
LR__3149
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	mov	local05, arg01
	callpa	#(@LR__3151-@LR__3150)>>2,fcache_load_ptr_
LR__3150
	rdbyte	result1, local05 wz
 if_ne	add	local05, #1
 if_ne	jmp	#LR__3150
LR__3151
	subr	arg01, local05
	add	arg01, #1
	call	#__system___gc_alloc_managed
	add	fp, #72
	wrlong	result1, fp
	sub	fp, #72
	cmp	result1, #0 wz
 if_e	jmp	#LR__3152
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #60
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system____builtin_strcpy
LR__3152
	add	fp, #72
	rdlong	result1, fp
	sub	fp, #72
LR__3153
	mov	ptra, fp
	call	#popregs_
__system___basic_dir_ret
	ret

__system__pack_0491
	mov	_var01, arg01
	add	arg03, #127
	test	arg04, #4 wz
 if_e	jmp	#LR__3160
	cmp	_var01, #0 wz
 if_e	decod	_var01, #22
	bith	_var01, #247
	jmp	#LR__3169
LR__3160
	test	arg04, #2 wz
 if_ne	mov	_var01, ##2139095040
 if_ne	mov	arg02, #0
 if_ne	jmp	#LR__3168
	test	arg04, #8 wz
 if_ne	mov	_var01, #0
 if_ne	jmp	#LR__3167
	cmps	arg03, #255 wc
 if_ae	mov	_var01, ##2139095040
 if_ae	mov	arg02, #0
 if_ae	jmp	#LR__3166
	cmps	arg03, #1 wc
 if_ae	jmp	#LR__3164
	shr	arg02, #1
	mov	_var02, _var01
	and	_var02, #1
	shl	_var02, #31
	or	arg02, _var02
	shr	_var01, #1
	callpa	#(@LR__3162-@LR__3161)>>2,fcache_load_ptr_
LR__3161
	cmps	arg03, #0 wc
 if_ae	jmp	#LR__3163
	cmp	_var01, #0 wz
 if_e	jmp	#LR__3163
	mov	arg01, arg02
	and	arg01, #1
	add	arg03, #1
	shr	arg02, #1
	mov	_var02, _var01
	and	_var02, #1
	shl	_var02, #31
	or	arg02, _var02
	or	arg02, arg01
	shr	_var01, #1
	jmp	#LR__3161
LR__3162
LR__3163
	cmps	arg03, #0 wc
 if_ae	jmp	#LR__3165
	cmp	arg02, #0 wz
	wrnz	arg02
	jmp	#LR__3165
LR__3164
	bitl	_var01, #279
	shl	arg03, #23
	or	_var01, arg03
LR__3165
LR__3166
LR__3167
LR__3168
LR__3169
	test	_var01, #1 wz
 if_ne	or	arg02, #1
	mov	arg03, arg02
	mov	_var02, #0
	add	arg02, ##2147483647
	cmp	arg02, arg03 wc
 if_b	mov	_var02, #1
	add	_var01, _var02
	test	arg04, #1 wz
 if_ne	bith	_var01, #31
	mov	result1, _var01
__system__pack_0491_ret
	ret

__system___rxtxioctl_0581
	cmp	arg02, #256 wz
 if_e	jmp	#LR__3170
	cmp	arg02, #257 wz
 if_e	jmp	#LR__3171
	jmp	#LR__3172
LR__3170
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	wrlong	result1, arg03
	mov	result1, #0
	jmp	#LR__3173
LR__3171
	rdlong	arg01, arg03
	add	ptr___system__dat__, #8
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	mov	result1, #0
	jmp	#LR__3173
LR__3172
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
LR__3173
__system___rxtxioctl_0581_ret
	ret

__system____dummy_flush_0582
	mov	result1, #0
__system____dummy_flush_0582_ret
	ret

__system___vfsread
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #40
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #4
	rdlong	result1, fp
	add	fp, #20
	wrlong	result1, fp
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #28
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #8
	rdlong	result1, arg01
	test	result1, #1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__3186
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #20
	rdlong	result1, arg01 wz
 if_e	jmp	#LR__3181
	add	fp, #4
	rdlong	arg01, fp
	mov	arg03, arg01
	add	arg03, #20
	rdlong	local01, arg03
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #12
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmps	result1, #0 wc
 if_ae	jmp	#LR__3180
	add	fp, #4
	rdlong	local03, fp
	mov	local01, local03
	add	local03, #8
	rdlong	local02, local03
	or	local02, #32
	add	local01, #8
	wrlong	local02, local01
	add	fp, #12
	rdlong	arg01, fp wz
	sub	fp, #16
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__3186
LR__3180
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
	jmp	#LR__3186
LR__3181
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #32
	rdlong	arg01, arg01 wz
	add	fp, #20
	wrlong	arg01, fp
	sub	fp, #24
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__3186
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #40
	rdlong	local02, local03 wz
 if_e	jmp	#LR__3183
	add	fp, #4
	rdlong	arg01, fp
	mov	local03, arg01
	add	local03, #40
	rdlong	local01, local03
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	add	fp, #32
	mov	arg03, fp
	sub	fp, #36
	mov	arg02, #256
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	add	fp, #16
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #16
 if_ne	jmp	#LR__3182
	add	fp, #36
	rdlong	local02, fp
	sub	fp, #36
	test	local02, #2 wz
 if_ne	add	fp, #32
 if_ne	wrlong	#1, fp
 if_ne	sub	fp, #32
LR__3182
LR__3183
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #16
LR__3184
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local03, #1 wc
 if_b	jmp	#LR__3185
	add	fp, #24
	rdlong	local02, fp
	mov	local03, local02
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	sub	fp, #20
	rdlong	arg01, fp
	sub	fp, #4
	mov	local01, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local01
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmps	result1, #0 wc
 if_b	jmp	#LR__3185
	add	fp, #28
	rdlong	local03, fp
	mov	local02, local03
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #8
	rdlong	local02, fp
	wrbyte	local02, local03
	sub	fp, #4
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #4
	rdlong	local03, fp
	sub	local03, #1
	wrlong	local03, fp
	add	fp, #20
	rdlong	local03, fp wz
	sub	fp, #32
 if_e	jmp	#LR__3184
	add	fp, #20
	rdlong	local02, fp
	sub	fp, #20
	cmp	local02, #10 wz
 if_ne	jmp	#LR__3184
LR__3185
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
LR__3186
	mov	ptra, fp
	call	#popregs_
__system___vfsread_ret
	ret

__system____default_filbuf
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #12
	rdlong	result1, local02 wz
	sub	local02, #12
 if_ne	jmp	#LR__3190
	add	local02, #20
	mov	result1, local02
	sub	local02, #4
	wrlong	result1, local02
	sub	local02, #4
	wrlong	##1024, local02
	sub	local02, #12
LR__3190
	add	local01, #20
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #20
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	add	local02, #16
	rdlong	arg02, local02
	sub	local02, #4
	rdlong	arg03, local02
	sub	local02, #12
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local01
	mov	local04, result1
	cmps	local04, #0 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__3191
	wrlong	local04, local02
	add	local02, #16
	rdlong	local03, local02
	sub	local02, #12
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	or	local03, #1
	wrlong	local03, local02
	mov	result1, local04
LR__3191
	mov	ptra, fp
	call	#popregs_
__system____default_filbuf_ret
	ret

__system__getlower_0967
	cmps	arg01, #65 wc
 if_b	jmp	#LR__3200
	cmps	arg01, #91 wc
 if_b	mov	result1, arg01
 if_b	add	result1, #32
 if_b	jmp	#__system__getlower_0967_ret
LR__3200
	mov	result1, arg01
__system__getlower_0967_ret
	ret

__system___pat_match
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
LR__3210
	rdbyte	arg01, arg02 wz
 if_ne	rdbyte	arg01, local01 wz
 if_ne	rdbyte	local02, arg02
 if_ne	cmp	local02, #42 wz
 if_e	jmp	#LR__3211
	rdbyte	arg01, arg02
	call	#__system__getlower_0967
	mov	local03, result1
	rdbyte	arg01, local01
	call	#__system__getlower_0967
	cmp	result1, local03 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__3219
	add	local01, #1
	add	arg02, #1
	jmp	#LR__3210
LR__3211
	rdbyte	local03, arg02
	cmp	local03, #42 wz
 if_ne	jmp	#LR__3218
	add	arg02, #1
	rdbyte	local02, arg02
	sub	arg02, #1
	cmp	local02, #46 wz
 if_ne	jmp	#LR__3212
	add	arg02, #2
	rdbyte	local02, arg02
	sub	arg02, #2
	cmp	local02, #42 wz
 if_e	add	arg02, #3
 if_e	rdbyte	local04, arg02
 if_e	sub	arg02, #3
 if_e	mov	local05, local04 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__3219
LR__3212
	add	arg02, #1
	mov	local06, #0
	callpa	#(@LR__3215-@LR__3213)>>2,fcache_load_ptr_
LR__3213
	mov	local07, local06
	add	local07, arg02
	rdbyte	local07, local07 wz
 if_ne	mov	local05, local06
 if_ne	add	local05, #1
 if_ne	mov	local06, local05
 if_ne	jmp	#LR__3213
	mov	local08, #0
LR__3214
	mov	local07, local08
	add	local07, local01
	rdbyte	local07, local07 wz
 if_ne	mov	local05, local08
 if_ne	add	local05, #1
 if_ne	mov	local08, local05
 if_ne	jmp	#LR__3214
LR__3215
	cmps	local08, local06 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__3219
	mov	local02, local08
	sub	local02, local06
	add	local01, local02
LR__3216
	cmps	local06, #1 wc
 if_b	jmp	#LR__3217
	rdbyte	arg01, local01
	call	#__system__getlower_0967
	mov	local08, result1
	rdbyte	arg01, arg02
	call	#__system__getlower_0967
	cmp	local08, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__3219
	add	local01, #1
	add	arg02, #1
	sub	local06, #1
	jmp	#LR__3216
LR__3217
LR__3218
	rdbyte	local08, arg02 wz
 if_e	rdbyte	local07, local01 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, #0
LR__3219
	mov	ptra, fp
	call	#popregs_
__system___pat_match_ret
	ret

_fatfs_cc_ff_uni2oem
	mov	_var01, #0
	cmp	arg01, #128 wc
 if_b	mov	_var01, arg01
 if_b	jmp	#LR__3224
	cmp	arg01, ##65536 wc
 if_ae	jmp	#LR__3223
	getword	result1, arg02, #0
	cmp	result1, ##850 wz
 if_ne	jmp	#LR__3223
' 			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
	mov	_var01, #0
	callpa	#(@LR__3221-@LR__3220)>>2,fcache_load_ptr_
LR__3220
	getword	result1, _var01, #0
	cmp	result1, #128 wc
 if_ae	jmp	#LR__3222
	getword	result1, _var01, #0
	shl	result1, #1
	add	result1, ptr__fatfs_cc_dat__
	rdword	result1, result1
	cmp	arg01, result1 wz
 if_ne	add	_var01, #1
 if_ne	jmp	#LR__3220
LR__3221
LR__3222
	getword	_var01, _var01, #0
	add	_var01, #128
	getbyte	_var01, _var01, #0
LR__3223
LR__3224
' 			c = (c + 0x80) & 0xFF;
' 		}
' 	}
' 
' 	return c;
	mov	result1, _var01
_fatfs_cc_ff_uni2oem_ret
	ret

_fatfs_cc_ff_oem2uni
	mov	_var01, #0
	getword	result1, arg01, #0
	cmp	result1, #128 wc
 if_b	mov	_var01, arg01
 if_b	jmp	#LR__3231
	getword	arg02, arg02, #0
	cmp	arg02, ##850 wz
 if_ne	jmp	#LR__3230
	getword	result1, arg01, #0
	cmp	result1, #256 wc
 if_b	getword	arg01, arg01, #0
 if_b	sub	arg01, #128
 if_b	shl	arg01, #1
 if_b	add	arg01, ptr__fatfs_cc_dat__
 if_b	rdword	_var01, arg01
LR__3230
LR__3231
' 		}
' 	}
' 
' 	return c;
	mov	result1, _var01
_fatfs_cc_ff_oem2uni_ret
	ret

_fatfs_cc_ff_wtoupper
	mov	_var01, arg01
	cmp	_var01, ##65536 wc
 if_ae	jmp	#LR__3253
	mov	_var02, _var01
	getword	_var01, _var02, #0
	cmp	_var01, ##4096 wc
 if_b	add	ptr__fatfs_cc_dat__, #256
 if_b	mov	_var03, ptr__fatfs_cc_dat__
 if_b	sub	ptr__fatfs_cc_dat__, #256
 if_ae	add	ptr__fatfs_cc_dat__, ##754
 if_ae	mov	_var03, ptr__fatfs_cc_dat__
 if_ae	sub	ptr__fatfs_cc_dat__, ##754
	mov	_var04, _var03
' 		uc = (WORD)uni;
' 		p = uc < 0x1000 ? cvt1 : cvt2;
' 		for (;;) {
LR__3240
	rdword	_var05, _var04
	mov	_var03, _var05
	zerox	_var03, #15 wz
	add	_var04, #2
 if_e	jmp	#LR__3252
	getword	_var03, _var02, #0
	getword	_var01, _var05, #0
	cmp	_var03, _var01 wc
 if_b	jmp	#LR__3252
	rdword	_var06, _var04
	getword	_var07, _var06, #0
	shr	_var07, #8
	getword	_var06, _var06, #0
	getbyte	_var06, _var06, #0
	getword	_var03, _var02, #0
	getword	_var08, _var05, #0
	getword	_var01, _var06, #0
	add	_var08, _var01
	cmps	_var03, _var08 wc
	add	_var04, #2
 if_ae	jmp	#LR__3251
' 				switch (cmd) {
	getword	_var09, _var07, #0
	fle	_var09, #9
	jmprel	_var09
LR__3241
	jmp	#LR__3242
	jmp	#LR__3243
	jmp	#LR__3244
	jmp	#LR__3245
	jmp	#LR__3246
	jmp	#LR__3247
	jmp	#LR__3248
	jmp	#LR__3249
	jmp	#LR__3250
	jmp	#LR__3252
LR__3242
	getword	_var02, _var02, #0
	getword	_var05, _var05, #0
	sub	_var02, _var05
	shl	_var02, #1
	add	_var02, _var04
	rdword	_var02, _var02
	jmp	#LR__3252
LR__3243
	getword	_var03, _var02, #0
	getword	_var02, _var02, #0
	getword	_var05, _var05, #0
	sub	_var02, _var05
	and	_var02, #1
	subr	_var02, _var03
	jmp	#LR__3252
LR__3244
	getword	_var02, _var02, #0
	sub	_var02, #16
	jmp	#LR__3252
LR__3245
	getword	_var02, _var02, #0
	sub	_var02, #32
	jmp	#LR__3252
LR__3246
	getword	_var02, _var02, #0
	sub	_var02, #48
	jmp	#LR__3252
LR__3247
	getword	_var02, _var02, #0
	sub	_var02, #26
	jmp	#LR__3252
LR__3248
	getword	_var02, _var02, #0
	add	_var02, #8
	jmp	#LR__3252
LR__3249
	getword	_var02, _var02, #0
	sub	_var02, #80
	jmp	#LR__3252
LR__3250
	getword	_var02, _var02, #0
	sub	_var02, ##7264
' 				}
' 				break;
	jmp	#LR__3252
LR__3251
	zerox	_var07, #15 wz
 if_e	mul	_var06, #2
 if_e	add	_var04, _var06
	jmp	#LR__3240
LR__3252
	getword	_var01, _var02, #0
LR__3253
' 		}
' 		uni = uc;
' 	}
' 
' 	return uni;
	mov	result1, _var01
_fatfs_cc_ff_wtoupper_ret
	ret

_fatfs_cc_strncpy
	mov	_var01, arg01
	callpa	#(@LR__3261-@LR__3260)>>2,fcache_load_ptr_
' 
' 	dscan = dst;
' 	sscan = src;
' 	count = n;
' 	while (--count >= 0 && (*dscan++ = *sscan++) != '\0')
LR__3260
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_b	jmp	#LR__3262
	rdbyte	result1, arg02
	wrbyte	result1, _var01
	add	arg02, #1
	rdbyte	result1, _var01 wz
' 		continue;
	add	_var01, #1
 if_ne	jmp	#LR__3260
LR__3261
LR__3262
	callpa	#(@LR__3264-@LR__3263)>>2,fcache_load_ptr_
' 	while (--count >= 0)
LR__3263
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_ae	mov	_var02, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	#0, _var02
 if_ae	jmp	#LR__3263
LR__3264
' 		*dscan++ = '\0';
' 	return(dst);
	mov	result1, arg01
_fatfs_cc_strncpy_ret
	ret

_fatfs_cc_memcmp
' 	for (n = size; n > 0; n--)
	cmp	arg03, #0 wz
 if_e	jmp	#LR__3271
LR__3270
	rdbyte	_var01, arg01
	rdbyte	_var02, arg02
	cmp	_var01, _var02 wz
 if_e	add	arg01, #1
 if_e	add	arg02, #1
' 			return( ((unsigned char)(*scan1))  -  ((unsigned char)(*scan2)) );
 if_ne	rdbyte	result1, arg01
 if_ne	rdbyte	_var02, arg02
 if_ne	sub	result1, _var02
 if_ne	jmp	#_fatfs_cc_memcmp_ret
	djnz	arg03, #LR__3270
LR__3271
' 
' 	return(0);
	mov	result1, #0
_fatfs_cc_memcmp_ret
	ret

_fatfs_cc_strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__3280
' 		return scan2 ? -1 : 0;
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#_fatfs_cc_strncmp_ret
LR__3280
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__3282-@LR__3281)>>2,fcache_load_ptr_
' 	count = n;
' 	do {
LR__3281
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__3283
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__3281
LR__3282
LR__3283
	cmps	_var03, #0 wc
' 		return(0);
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, _var06 wz
' 		return(0);
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, #0 wz
' 		return(-1);
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var06, #0 wz
' 		return(1);
 if_e	mov	result1, #1
' 		return(c1 - c2);
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
_fatfs_cc_strncmp_ret
	ret

_fatfs_cc_strchr
' #line 16 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/libc/string/strchr.c"
' 	while ((c = *s++) != (char) charwanted)
LR__3290
	mov	_var01, arg01
	rdbyte	_var02, _var01
	getbyte	_var03, _var02, #0
	getbyte	_var04, arg02, #0
	cmp	_var03, _var04 wz
	add	arg01, #1
 if_e	jmp	#LR__3291
	mov	_var03, _var02
	zerox	_var03, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strchr_ret
	jmp	#LR__3290
LR__3291
' 	return((char *)--s);
	sub	arg01, #1
	mov	result1, arg01
_fatfs_cc_strchr_ret
	ret

_fatfs_cc_disk_initialize
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #64
	add	fp, #4
	wrbyte	arg01, fp
	add	objptr, ##532
	rdlong	arg04, objptr
	add	fp, #44
	wrlong	arg04, fp
	sub	objptr, #4
	rdlong	arg04, objptr
	add	fp, #4
	wrlong	arg04, fp
	add	objptr, #8
	rdlong	arg04, objptr
	add	fp, #4
	wrlong	arg04, fp
	add	objptr, #4
	rdlong	arg04, objptr
	add	fp, #4
	wrlong	arg04, fp
	add	objptr, #4
	wrbyte	#1, objptr
	sub	objptr, ##544
	sub	fp, #56
	rdbyte	arg04, fp wz
	sub	fp, #4
' #line 531 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/sdmm.cc"
'             return RES_NOTRDY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__3318
	mov	arg01, ##10000
	call	#__system___waitus
	add	fp, #48
	rdlong	arg01, fp
	wrpin	#0, arg01
	add	fp, #4
	rdlong	arg01, fp
	wrpin	#0, arg01
	add	fp, #4
	rdlong	arg01, fp
	wrpin	#0, arg01
	add	fp, #4
	rdlong	arg01, fp
	wrpin	##4608, arg01
	sub	fp, #12
	rdlong	arg01, fp
	drvh	arg01
	add	fp, #4
	rdlong	arg01, fp
	drvh	arg01
	add	fp, #4
	rdlong	arg01, fp
	drvh	arg01
	add	fp, #4
	rdlong	arg01, fp
	drvh	arg01
	sub	fp, #32
	wrlong	##524304, fp
	add	fp, #4
	wrlong	##409672, fp
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #24
	rdlong	arg03, fp
	dirl	local01
	wrpin	##475208, local01
	wxpin	arg03, local01
	wypin	#0, local01
	dirh	local01
	add	fp, #28
	rdlong	local02, fp
	sub	local01, local02
	and	local01, #7
	shl	local01, #24
	mov	arg02, #120
	or	arg02, local01
	sub	fp, #20
	wrlong	arg02, fp
	add	fp, #20
	rdlong	arg01, fp
	bith	arg02, #16
	dirl	arg01
	wrpin	arg02, arg01
	wxpin	#31, arg01
	wypin	##-1, arg01
	dirh	arg01
	sub	fp, #4
	rdlong	arg02, fp
	add	fp, #8
	rdlong	local03, fp
	sub	arg02, local03
	and	arg02, #7
	shl	arg02, #24
	sub	fp, #20
	wrlong	arg02, fp
	or	arg02, ##21114
	wrlong	arg02, fp
	add	fp, #20
	rdlong	arg01, fp
	dirl	arg01
	wrpin	arg02, arg01
	wxpin	#39, arg01
	wypin	#0, arg01
	dirh	arg01
	sub	fp, #40
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #10
	call	#_fatfs_cc_rcvr_mmc_1001
	mov	arg01, #0
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1025
	call	#_fatfs_cc_deselect_1011
	mov	arg01, #100
	call	#__system___waitus
	add	fp, #20
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #10
	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #12
	wrbyte	#0, fp
	sub	fp, #12
	mov	arg01, #0
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1025
	getbyte	arg04, result1, #0
	cmp	arg04, #1 wz
 if_ne	jmp	#LR__3317
	mov	arg01, #8
	mov	arg02, #426
	call	#_fatfs_cc_send_cmd_1025
	getbyte	result1, result1, #0
	cmp	result1, #1 wz
 if_ne	jmp	#LR__3303
	add	fp, #20
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #4
	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #22
	rdbyte	local04, fp
	sub	fp, #22
	cmp	local04, #1 wz
 if_e	add	fp, #23
 if_e	rdbyte	local03, fp
 if_e	sub	fp, #23
 if_e	cmp	local03, #170 wz
 if_ne	jmp	#LR__3316
' 				for (tmr = 1000; tmr; tmr--) {
	add	fp, #24
	wrlong	##1000, fp
	sub	fp, #24
LR__3300
	add	fp, #24
	rdlong	local01, fp wz
	sub	fp, #24
 if_e	jmp	#LR__3301
	mov	arg01, #169
	decod	arg02, #30
	call	#_fatfs_cc_send_cmd_1025
	mov	local04, result1
	zerox	local04, #7 wz
 if_e	jmp	#LR__3301
	mov	arg01, ##1000
	call	#__system___waitus
	add	fp, #24
	rdlong	local04, fp
	sub	local04, #1
	wrlong	local04, fp
	sub	fp, #24
	jmp	#LR__3300
LR__3301
	add	fp, #24
	rdlong	local04, fp wz
	sub	fp, #24
 if_e	jmp	#LR__3302
	mov	arg01, #58
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1025
	mov	local03, result1
	zerox	local03, #7 wz
 if_ne	jmp	#LR__3302
	add	fp, #20
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #4
	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #20
	rdbyte	local01, fp
	test	local01, #64 wz
 if_ne	mov	local04, #12
 if_e	mov	local04, #4
	sub	fp, #8
	wrbyte	local04, fp
	sub	fp, #12
LR__3302
	rdlong	local04, #20
	add	fp, #24
	wrlong	local04, fp
	add	fp, #12
	rdlong	local04, fp
	bith	local04, #27
	wrlong	local04, fp
	sub	fp, #12
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##150000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##131076, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__3316
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##200000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##131077, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__3316
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##280000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##131078, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__3316
	add	fp, #28
	wrlong	##196616, fp
	sub	fp, #28
	jmp	#LR__3316
LR__3303
	mov	arg01, #169
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1025
	getbyte	local04, result1, #0
	cmp	local04, #2 wc
 if_ae	jmp	#LR__3304
	add	fp, #12
	wrbyte	#2, fp
	add	fp, #4
	wrbyte	#169, fp
	sub	fp, #16
	jmp	#LR__3305
LR__3304
	add	fp, #12
	wrbyte	#1, fp
	add	fp, #4
	wrbyte	#1, fp
	sub	fp, #16
LR__3305
' 				ty =  0x01 ; cmd =  (1) ;
' 			}
' 			for (tmr = 1000; tmr; tmr--) {
	add	fp, #24
	wrlong	##1000, fp
	sub	fp, #24
LR__3306
	add	fp, #24
	rdlong	local03, fp wz
	sub	fp, #24
 if_e	jmp	#LR__3307
	add	fp, #16
	rdbyte	arg01, fp
	sub	fp, #16
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1025
	mov	local04, result1
	zerox	local04, #7 wz
 if_e	jmp	#LR__3307
	mov	arg01, ##1000
	call	#__system___waitus
	add	fp, #24
	rdlong	local04, fp
	sub	local04, #1
	wrlong	local04, fp
	sub	fp, #24
	jmp	#LR__3306
LR__3307
	add	fp, #24
	rdlong	local04, fp wz
	sub	fp, #24
 if_e	jmp	#LR__3308
	mov	arg01, #16
	decod	arg02, #9
	call	#_fatfs_cc_send_cmd_1025
	zerox	result1, #7 wz
 if_e	jmp	#LR__3309
LR__3308
	add	fp, #12
	wrbyte	#0, fp
	sub	fp, #12
LR__3309
	rdlong	local04, #20
	add	fp, #24
	wrlong	local04, fp
	sub	fp, #24
	cmp	local04, ##100000001 wc
 if_ae	jmp	#LR__3310
	add	fp, #36
	rdlong	local04, fp
	bith	local04, #27
	wrlong	local04, fp
	sub	fp, #36
	jmp	#LR__3311
LR__3310
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##200000001 wc
 if_b	add	fp, #36
 if_b	rdlong	local04, fp
 if_b	or	local04, ##134283264
 if_b	wrlong	local04, fp
 if_b	sub	fp, #36
LR__3311
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##100000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##131076, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__3315
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##150000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##196614, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__3314
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##200000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##262152, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__3313
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##250000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##327690, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__3312
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##300000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##393228, fp
	sumc	fp, #28
 if_ae	wrlong	##458766, fp
 if_ae	sub	fp, #28
LR__3312
LR__3313
LR__3314
LR__3315
LR__3316
LR__3317
	add	fp, #12
	rdbyte	local04, fp
	add	objptr, ##545
	wrbyte	local04, objptr
	rdbyte	local01, fp wz
 if_ne	mov	local04, #0
 if_e	mov	local04, #1
	add	fp, #32
	wrbyte	local04, fp
	rdbyte	local04, fp
	sub	fp, #44
	sub	objptr, #1
	wrbyte	local04, objptr
	sub	objptr, ##544
	call	#_fatfs_cc_deselect_1011
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #24
	rdlong	arg02, fp
	wxpin	arg02, arg01
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	wrpin	arg02, arg01
' 
' 		}
' 	}
' #line 631 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/sdmm.cc"
' 	CardType = ty;
' 	s = ty ? 0 :  0x01 ;
' 	Stat = s;
' 
' 	deselect();
' 
' 
' 	_wxpin( PIN_CLK, ck_div );
' 	_wrpin( PIN_DI, spm_tx );
' #line 644 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/sdmm.cc"
' 	return s;
	add	fp, #8
	rdbyte	result1, fp
	sub	fp, #44
LR__3318
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_initialize_ret
	ret

_fatfs_cc_disk_read
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__3322
	add	objptr, ##545
	rdbyte	local04, objptr
	sub	objptr, ##545
	test	local04, #8 wz
 if_e	shl	local02, #9
	cmp	local03, #2 wc
 if_ae	mov	local04, #18
 if_b	mov	local04, #17
	mov	arg02, local02
	mov	arg01, local04
	call	#_fatfs_cc_send_cmd_1025
	mov	local05, result1
	zerox	local05, #7 wz
 if_ne	jmp	#LR__3321
' 		do {
LR__3320
	mov	arg01, local01
	decod	arg02, #9
	call	#_fatfs_cc_rcvr_datablock_1019
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local03, #LR__3320
	getbyte	local04, local04, #0
	cmp	local04, #18 wz
 if_e	mov	arg01, #12
 if_e	mov	arg02, #0
 if_e	call	#_fatfs_cc_send_cmd_1025
LR__3321
	call	#_fatfs_cc_deselect_1011
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local03, #0 wz
 if_ne	mov	local05, #1
 if_e	mov	local05, #0
	mov	result1, local05
LR__3322
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_read_ret
	ret

_fatfs_cc_disk_write
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg04
	mov	local03, arg03
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__3334
	add	objptr, ##545
	rdbyte	arg03, objptr
	sub	objptr, ##545
	test	arg03, #8 wz
 if_e	shl	local03, #9
	cmp	local02, #1 wz
 if_ne	jmp	#LR__3330
	mov	arg01, #24
	mov	arg02, local03
	call	#_fatfs_cc_send_cmd_1025
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__3333
	mov	arg01, local01
	mov	arg02, #254
	call	#_fatfs_cc_xmit_datablock_1021
	cmp	result1, #0 wz
 if_ne	mov	local02, #0
	jmp	#LR__3333
LR__3330
	add	objptr, ##545
	rdbyte	local04, objptr
	sub	objptr, ##545
	test	local04, #6 wz
 if_ne	mov	arg01, #151
 if_ne	mov	arg02, local02
 if_ne	call	#_fatfs_cc_send_cmd_1025
	mov	arg02, local03
	mov	arg01, #25
	call	#_fatfs_cc_send_cmd_1025
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__3332
' 			do {
LR__3331
	mov	arg01, local01
	mov	arg02, #252
	call	#_fatfs_cc_xmit_datablock_1021
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local02, #LR__3331
	mov	arg01, #0
	mov	arg02, #253
	call	#_fatfs_cc_xmit_datablock_1021
	cmp	result1, #0 wz
 if_e	mov	local02, #1
LR__3332
LR__3333
	call	#_fatfs_cc_deselect_1011
' 				count = 1;
' 		}
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local02, #0 wz
 if_ne	mov	local04, #1
 if_e	mov	local04, #0
	mov	result1, local04
LR__3334
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_write_ret
	ret

_fatfs_cc_disk_ioctl
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #48
	add	fp, #4
	wrbyte	arg01, fp
	add	fp, #4
	wrbyte	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdbyte	arg01, fp wz
	sub	fp, #4
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__3348
	add	fp, #16
	wrlong	#1, fp
' 
' 	res = RES_ERROR;
' 	switch (ctrl) {
	sub	fp, #8
	rdbyte	local01, fp
	sub	fp, #8
	fle	local01, #4
	jmprel	local01
LR__3340
	jmp	#LR__3341
	jmp	#LR__3342
	jmp	#LR__3346
	jmp	#LR__3345
	jmp	#LR__3346
LR__3341
	call	#_fatfs_cc_select_1015
	cmp	result1, #0 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#0, fp
 if_ne	sub	fp, #16
' 			break;
	jmp	#LR__3347
LR__3342
	mov	arg01, #9
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1025
	mov	local01, result1
	zerox	local01, #7 wz
 if_ne	jmp	#LR__3347
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	mov	arg02, #16
	call	#_fatfs_cc_rcvr_datablock_1019
	cmp	result1, #0 wz
 if_e	jmp	#LR__3347
	add	fp, #24
	rdbyte	local01, fp
	sub	fp, #24
	shr	local01, #6
	cmp	local01, #1 wz
 if_ne	jmp	#LR__3343
	add	fp, #33
	rdbyte	local01, fp
	sub	fp, #1
	rdbyte	result1, fp
	getword	result1, result1, #0
	shl	result1, #8
	add	local01, result1
	sub	fp, #1
	rdbyte	result1, fp
	and	result1, #63
	shl	result1, #16
	add	local01, result1
	add	local01, #1
	add	fp, #9
	wrlong	local01, fp
	sub	fp, #28
	rdlong	local01, fp
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #40
	shl	result1, #10
	wrlong	result1, local01
	jmp	#LR__3344
LR__3343
	add	fp, #29
	rdbyte	local01, fp
	getnib	local01, local01, #0
	add	fp, #5
	rdbyte	result1, fp
	and	result1, #128
	sar	result1, #7
	add	local01, result1
	sub	fp, #1
	rdbyte	result1, fp
	and	result1, #3
	shl	result1, #1
	add	local01, result1
	add	local01, #2
	sub	fp, #13
	wrbyte	local01, fp
	add	fp, #12
	rdbyte	local01, fp
	shr	local01, #6
	sub	fp, #1
	rdbyte	result1, fp
	getword	result1, result1, #0
	shl	result1, #2
	add	local01, result1
	sub	fp, #1
	rdbyte	result1, fp
	and	result1, #3
	getword	result1, result1, #0
	shl	result1, #10
	add	local01, result1
	add	local01, #1
	add	fp, #10
	wrlong	local01, fp
	sub	fp, #28
	rdlong	local01, fp
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #20
	rdbyte	arg03, fp
	sub	fp, #20
	sub	arg03, #9
	shl	result1, arg03
	wrlong	result1, local01
LR__3344
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #16
' 					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
' 					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
' 					*(LBA_t*)buff = cs << (n - 9);
' 				}
' 				res = RES_OK;
' 			}
' 			break;
	jmp	#LR__3347
LR__3345
	add	fp, #12
	rdlong	local01, fp
	wrlong	#128, local01
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #16
' 			*(DWORD*)buff = 128;
' 			res = RES_OK;
' 			break;
	jmp	#LR__3347
LR__3346
	add	fp, #16
	wrlong	#4, fp
	sub	fp, #16
LR__3347
	call	#_fatfs_cc_deselect_1011
' 			res = RES_PARERR;
' 	}
' 
' 	deselect();
' 
' 	return res;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
LR__3348
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_ioctl_ret
	ret

_fatfs_cc_disk_setpins
	cmp	arg01, #0 wz
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_disk_setpins_ret
	add	objptr, ##528
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	arg04, objptr
	add	objptr, #4
	wrlong	arg05, objptr
	sub	objptr, ##540
	mov	result1, #0
_fatfs_cc_disk_setpins_ret
	ret

_fatfs_cc_tchar2uni
	rdlong	_var01, arg01
	mov	_var02, _var01
	add	_var01, #1
	mov	_var03, _var01
	rdbyte	_var04, _var02
	test	_var04, #128 wz
 if_e	jmp	#LR__3357
	mov	_var05, _var04
	and	_var05, #224
	cmp	_var05, #192 wz
 if_e	and	_var04, #31
 if_e	mov	_var06, #1
 if_e	jmp	#LR__3351
	mov	_var05, _var04
	and	_var05, #240
	cmp	_var05, #224 wz
 if_e	getnib	_var04, _var04, #0
 if_e	mov	_var06, #2
 if_e	jmp	#LR__3350
	mov	_var05, _var04
	and	_var05, #248
	cmp	_var05, #240 wz
 if_e	and	_var04, #7
 if_e	mov	_var06, #3
' 			return 0xFFFFFFFF;
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_tchar2uni_ret
LR__3350
LR__3351
' 		}
' 		do {
LR__3352
	rdbyte	_var07, _var03
	getbyte	_var05, _var07, #0
	and	_var05, #192
	cmp	_var05, #128 wz
	add	_var03, #1
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_tchar2uni_ret
	shl	_var04, #6
	getbyte	_var02, _var07, #0
	and	_var02, #63
	or	_var04, _var02
	djnz	_var06, #LR__3352
	cmp	_var04, #128 wc
 if_b	jmp	#LR__3354
	cmp	_var04, ##55296 wc
 if_b	jmp	#LR__3353
	cmp	_var04, ##57344 wc
 if_b	jmp	#LR__3354
LR__3353
	cmp	_var04, ##1114112 wc
 if_b	jmp	#LR__3355
LR__3354
	neg	result1, #1
	jmp	#_fatfs_cc_tchar2uni_ret
LR__3355
	cmp	_var04, ##65536 wc
 if_b	jmp	#LR__3356
	mov	_var02, _var04
	sub	_var02, ##65536
	shl	_var02, #6
	and	_var02, ##67043328
	mov	_var05, ##-671032320
	or	_var05, _var02
	zerox	_var04, #9
	or	_var04, _var05
LR__3356
LR__3357
	wrlong	_var03, arg01
' 	}
' #line 811 "ff.c"
' 	*str = p;
' 	return uc;
	mov	result1, _var04
_fatfs_cc_tchar2uni_ret
	ret

_fatfs_cc_put_utf
	cmp	arg01, #128 wc
 if_ae	jmp	#LR__3360
	cmp	arg03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	wrbyte	arg01, arg02
' 		*buf = (TCHAR)chr;
' 		return 1;
	mov	result1, #1
	jmp	#_fatfs_cc_put_utf_ret
LR__3360
	cmp	arg01, ##2048 wc
 if_ae	jmp	#LR__3361
	cmp	arg03, #2 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	mov	result1, arg01
	shr	result1, #6
	and	result1, #31
	mov	arg03, #192
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	arg01, #63
	mov	result1, #128
	or	result1, arg01
	wrbyte	result1, arg02
' 		*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 		return 2;
	mov	result1, #2
	jmp	#_fatfs_cc_put_utf_ret
LR__3361
	cmp	arg01, ##65536 wc
 if_ae	jmp	#LR__3364
	cmp	arg03, #3 wc
 if_b	jmp	#LR__3362
	cmp	arg01, ##55296 wc
 if_b	jmp	#LR__3363
	cmp	arg01, ##57344 wc
 if_ae	jmp	#LR__3363
LR__3362
	mov	result1, #0
	jmp	#_fatfs_cc_put_utf_ret
LR__3363
	getnib	result1, arg01, #3
	mov	arg03, #224
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, arg01
	shr	result1, #6
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	arg01, #63
	mov	result1, #128
	or	result1, arg01
	wrbyte	result1, arg02
' 		*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 		return 3;
	mov	result1, #3
	jmp	#_fatfs_cc_put_utf_ret
LR__3364
	cmp	arg03, #4 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	mov	_var01, arg01
	bitl	_var01, #480
	sub	_var01, ##-671088640
	shr	_var01, #6
	getword	arg01, arg01, #0
	sub	arg01, ##56320
	cmp	_var01, ##1048576 wc
 if_b	cmp	arg01, ##1024 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#_fatfs_cc_put_utf_ret
	or	_var01, arg01
	add	_var01, ##65536
	mov	result1, _var01
	shr	result1, #18
	and	result1, #7
	mov	arg03, #240
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, _var01
	shr	result1, #12
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, _var01
	shr	result1, #6
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	_var01, #63
	mov	result1, #128
	or	result1, _var01
	wrbyte	result1, arg02
' 	chr = (hc | chr) + 0x10000;
' 	*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 	return 4;
	mov	result1, #4
_fatfs_cc_put_utf_ret
	ret

_fatfs_cc_sync_window
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #3
	rdbyte	result1, local01 wz
	sub	local01, #3
 if_e	jmp	#LR__3372
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #48
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3370
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #45
	rdlong	result1, local01
	sub	local01, #12
	rdlong	arg04, local01
	sub	result1, arg04
	sub	local01, #8
	rdlong	arg04, local01
	sub	local01, #28
	cmp	result1, arg04 wc
 if_ae	jmp	#LR__3371
	add	local01, #2
	rdbyte	arg04, local01
	sub	local01, #2
	cmp	arg04, #2 wz
 if_ne	jmp	#LR__3371
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #20
	rdlong	local01, local01
	add	arg03, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	jmp	#LR__3371
LR__3370
	mov	local02, #1
LR__3371
LR__3372
' 			res = FR_DISK_ERR;
' 		}
' 	}
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_window_ret
	ret

_fatfs_cc_move_window
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	add	local01, #48
	rdlong	arg04, local01
	sub	local01, #48
	cmp	local02, arg04 wz
 if_e	jmp	#LR__3381
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__3380
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	mov	arg03, local02
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	neg	local02, #1
 if_ne	mov	local03, #1
	sub	local01, #4
	wrlong	local02, local01
LR__3380
LR__3381
' 				sect = (LBA_t)0 - 1;
' 				res = FR_DISK_ERR;
' 			}
' 			fs->winsect = sect;
' 		}
' 	}
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_move_window_ret
	ret

_fatfs_cc_sync_fs
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	call	#_fatfs_cc_sync_window
	mov	local02, result1 wz
 if_ne	jmp	#LR__3391
	rdbyte	arg04, local01
	cmp	arg04, #3 wz
 if_e	add	local01, #4
 if_e	rdbyte	arg04, local01
 if_e	sub	local01, #4
 if_e	cmp	arg04, #1 wz
 if_ne	jmp	#LR__3390
	add	local01, #52
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	arg01, local01
	add	arg01, #510
	wrword	##43605, arg01
	wrlong	##1096897106, local01
	mov	arg01, local01
	add	arg01, #484
	wrlong	##1631679090, arg01
	mov	arg01, local01
	add	arg01, #488
	sub	local01, #32
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #32
	mov	arg01, local01
	add	arg01, #492
	sub	local01, #36
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #16
	rdlong	arg03, local01
	add	arg03, #1
	add	local01, #16
	wrlong	arg03, local01
	sub	local01, #47
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	sub	local01, #48
	wrbyte	#0, local01
	sub	local01, #4
LR__3390
	add	local01, #1
	rdbyte	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	call	#_fatfs_cc_disk_ioctl
	cmp	result1, #0 wz
 if_ne	mov	local02, #1
LR__3391
' 	}
' 
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_fs_ret
	ret

_fatfs_cc_clst2sect
	sub	arg02, #2
	add	arg01, #24
	rdlong	_var01, arg01
	sub	arg01, #24
	sub	_var01, #2
	cmp	arg02, _var01 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#_fatfs_cc_clst2sect_ret
	add	arg01, #10
	rdword	_var01, arg01
	qmul	_var01, arg02
' 	return fs->database + (LBA_t)fs->csize * clst;
	add	arg01, #34
	rdlong	result1, arg01
	getqx	_var01
	add	result1, _var01
_fatfs_cc_clst2sect_ret
	ret

_fatfs_cc_get_fat
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg02
	rdlong	local02, arg01
	cmp	local01, #2 wc
 if_b	jmp	#LR__3400
	add	local02, #24
	rdlong	local03, local02
	sub	local02, #24
	cmp	local01, local03 wc
 if_b	jmp	#LR__3401
LR__3400
	mov	local04, #1
	jmp	#LR__3408
LR__3401
	neg	local04, #1
' 		val = 0xFFFFFFFF;
' 
' 		switch (fs->fs_type) {
	rdbyte	local05, local02
	sub	local05, #1
	fle	local05, #3
	jmprel	local05
LR__3402
	jmp	#LR__3403
	jmp	#LR__3404
	jmp	#LR__3405
	jmp	#LR__3406
LR__3403
	mov	local05, local01
	mov	arg01, local01
	shr	arg01, #1
	add	local05, arg01
	mov	arg01, local02
	mov	local06, local05
	shr	local06, #9
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3407
	mov	local06, local05
	and	local06, #511
	add	local02, #52
	add	local06, local02
	rdbyte	local07, local06
	sub	local02, #52
	mov	arg01, local02
	add	local05, #1
	mov	local06, local05
	shr	local06, #9
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3407
	and	local05, #511
	add	local02, #52
	add	local05, local02
	rdbyte	local06, local05
	shl	local06, #8
	or	local07, local06
	test	local01, #1 wz
 if_ne	shr	local07, #4
 if_ne	mov	local03, local07
 if_e	zerox	local07, #11
 if_e	mov	local03, local07
	mov	local04, local03
' 			wc |= fs->win[bc %  ((UINT) 512 ) ] << 8;
' 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
' 			break;
	jmp	#LR__3407
LR__3404
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #8
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3407
	add	local02, #52
	shl	local01, #1
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, local02
	getword	local04, result1, #0
' 			val = ld_word(fs->win + clst * 2 %  ((UINT) 512 ) );
' 			break;
	jmp	#LR__3407
LR__3405
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #7
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3407
	add	local02, #52
	shl	local01, #2
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local04, local02
	bitl	local04, #124
' 			val = ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0x0FFFFFFF;
' 			break;
	jmp	#LR__3407
LR__3406
	mov	local04, #1
LR__3407
LR__3408
' 			val = 1;
' 		}
' 	}
' 
' 	return val;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_fat_ret
	ret

_fatfs_cc_put_fat
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, #2
	cmp	local02, #2 wc
 if_b	jmp	#LR__3417
	add	local01, #24
	rdlong	local05, local01
	sub	local01, #24
	cmp	local02, local05 wc
 if_ae	jmp	#LR__3417
' 		switch (fs->fs_type) {
	rdbyte	local06, local01
	sub	local06, #1
	fle	local06, #3
	jmprel	local06
LR__3410
	jmp	#LR__3411
	jmp	#LR__3414
	jmp	#LR__3415
	jmp	#LR__3416
LR__3411
	mov	local07, local02
	mov	local05, local02
	shr	local05, #1
	add	local07, local05
	mov	arg01, local01
	mov	local06, local07
	shr	local06, #9
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__3416
	add	local01, #52
	mov	local08, local01
	mov	local05, local07
	and	local05, #511
	add	local08, local05
	test	local02, #1 wz
	sub	local01, #52
	add	local07, #1
 if_e	jmp	#LR__3412
	rdbyte	local05, local08
	getnib	local05, local05, #0
	getbyte	local06, local03, #0
	shl	local06, #4
	or	local05, local06
	jmp	#LR__3413
LR__3412
	mov	local05, local03
LR__3413
	wrbyte	local05, local08
	add	local01, #3
	wrbyte	#1, local01
	sub	local01, #3
	mov	arg01, local01
	mov	local08, local07
	shr	local08, #9
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__3416
	add	local01, #52
	mov	local08, local01
	and	local07, #511
	add	local08, local07
	test	local02, #1 wz
 if_ne	shr	local03, #4
 if_ne	mov	local05, local03
 if_e	rdbyte	local05, local08
 if_e	and	local05, #240
 if_e	getbyte	local03, local03, #1
 if_e	getnib	local03, local03, #0
 if_e	or	local05, local03
	wrbyte	local05, local08
	sub	local01, #49
	wrbyte	#1, local01
' 			p = fs->win + bc %  ((UINT) 512 ) ;
' 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__3416
LR__3414
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #8
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__3416
	add	local01, #52
	mov	arg01, local01
	shl	local02, #1
	and	local02, #511
	add	arg01, local02
	wrword	local03, arg01
	sub	local01, #49
	wrbyte	#1, local01
' 			st_word(fs->win + clst * 2 %  ((UINT) 512 ) , (WORD)val);
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__3416
LR__3415
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #7
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__3416
	bitl	local03, #124
	add	local01, #52
	mov	local08, local02
	shl	local08, #2
	and	local08, #511
	mov	arg01, local01
	add	arg01, local08
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local08, arg01
	and	local08, ##-268435456
	or	local03, local08
	mov	arg01, local01
	shl	local02, #2
	and	local02, #511
	add	arg01, local02
	wrlong	local03, arg01
	sub	local01, #49
	wrbyte	#1, local01
' 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0xF0000000);
' 			}
' 			st_dword(fs->win + clst * 4 %  ((UINT) 512 ) , val);
' 			fs->wflag = 1;
' 			break;
LR__3416
LR__3417
' 		}
' 	}
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_put_fat_ret
	ret

_fatfs_cc_remove_chain
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	rdlong	local04, local01
	cmp	local02, #2 wc
 if_b	jmp	#LR__3420
	add	local04, #24
	rdlong	result1, local04
	sub	local04, #24
	cmp	local02, result1 wc
 if_b	jmp	#LR__3421
LR__3420
	mov	result1, #2
	jmp	#LR__3426
LR__3421
	cmp	local03, #0 wz
 if_e	jmp	#LR__3422
	mov	arg02, local03
	mov	arg01, local04
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3426
LR__3422
' 	}
' 
' 
' 	do {
LR__3423
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1 wz
 if_e	jmp	#LR__3425
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__3426
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__3426
	mov	arg02, local02
	mov	arg01, local04
	mov	arg03, #0
	call	#_fatfs_cc_put_fat
	mov	local03, result1 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__3426
	add	local04, #24
	rdlong	local03, local04
	sub	local03, #2
	sub	local04, #4
	rdlong	local02, local04
	sub	local04, #20
	cmp	local02, local03 wc
 if_ae	jmp	#LR__3424
	add	local04, #20
	rdlong	local03, local04
	add	local03, #1
	wrlong	local03, local04
	sub	local04, #16
	rdbyte	local03, local04
	or	local03, #1
	wrbyte	local03, local04
	sub	local04, #4
LR__3424
	mov	local02, local05
	add	local04, #24
	rdlong	local05, local04
	sub	local04, #24
	cmp	local02, local05 wc
 if_b	jmp	#LR__3423
LR__3425
' #line 1500 "ff.c"
' 	return FR_OK;
	mov	result1, #0
LR__3426
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_remove_chain_ret
	ret

_fatfs_cc_create_chain
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	rdlong	local03, local01
 if_ne	jmp	#LR__3430
	add	local03, #16
	rdlong	local04, local03 wz
	sub	local03, #16
 if_ne	add	local03, #24
 if_ne	rdlong	local05, local03
 if_ne	sub	local03, #24
 if_ne	cmp	local04, local05 wc
 if_c_and_nz	jmp	#LR__3431
	mov	local04, #1
	jmp	#LR__3431
LR__3430
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, #2 wc
 if_b	mov	result1, #1
 if_b	jmp	#LR__3441
	cmp	local04, ##-1 wz
 if_e	mov	result1, local04
 if_e	jmp	#LR__3441
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local04, local05 wc
 if_b	mov	result1, local04
 if_b	jmp	#LR__3441
	mov	local04, local02
LR__3431
	add	local03, #20
	rdlong	local05, local03 wz
	sub	local03, #20
 if_e	mov	result1, #0
 if_e	jmp	#LR__3441
	mov	local06, #0
	cmp	local04, local02 wz
 if_ne	jmp	#LR__3434
	mov	local06, local04
	add	local06, #1
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #1 wz
 if_ne	cmp	local05, ##-1 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__3441
	cmp	local05, #0 wz
 if_e	jmp	#LR__3433
	add	local03, #16
	rdlong	local07, local03
	sub	local03, #16
	cmp	local07, #2 wc
 if_b	jmp	#LR__3432
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local07, local05 wc
 if_b	mov	local04, local07
LR__3432
	mov	local06, #0
LR__3433
LR__3434
	cmp	local06, #0 wz
 if_ne	jmp	#LR__3437
	mov	local06, local04
' 			ncl = scl;
' 			for (;;) {
LR__3435
	add	local06, #1
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
 if_ae	cmp	local06, local04 wcz
 if_a	mov	result1, #0
 if_a	jmp	#LR__3441
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local07, result1 wz
 if_e	jmp	#LR__3436
	cmp	local07, #1 wz
 if_ne	cmp	local07, ##-1 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__3441
	cmp	local06, local04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3441
	jmp	#LR__3435
LR__3436
LR__3437
	mov	arg01, local03
	mov	arg02, local06
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	mov	local08, result1 wz
 if_ne	jmp	#LR__3438
	cmp	local02, #0 wz
 if_e	jmp	#LR__3438
	mov	arg01, local03
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_put_fat
	mov	local08, result1
LR__3438
	cmp	local08, #0 wz
 if_ne	jmp	#LR__3439
	add	local03, #16
	wrlong	local06, local03
	add	local03, #8
	rdlong	local05, local03
	sub	local05, #2
	sub	local03, #4
	rdlong	local09, local03
	sub	local03, #20
	cmp	local09, local05 wcz
 if_be	add	local03, #20
 if_be	rdlong	local09, local03
 if_be	sub	local09, #1
 if_be	wrlong	local09, local03
 if_be	sub	local03, #20
	add	local03, #4
	rdbyte	local05, local03
	or	local05, #1
	wrbyte	local05, local03
	jmp	#LR__3440
LR__3439
	cmp	local08, #1 wz
	negz	local06, #1
LR__3440
' 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
' 	}
' 
' 	return ncl;
	mov	result1, local06
LR__3441
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_chain_ret
	ret

_fatfs_cc_dir_clear
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__3452
	mov	arg01, local01
	mov	arg02, local02
	call	#_fatfs_cc_clst2sect
	mov	local03, result1
	add	local01, #48
	wrlong	local03, local01
	add	local01, #4
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	local04, local01
' #line 1667 "ff.c"
' 	{
' 		ibuf = fs->win; szb = 1;
' 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
	mov	local05, #0
	sub	local01, #52
LR__3450
	add	local01, #10
	rdword	local06, local01
	sub	local01, #10
	cmp	local05, local06 wc
 if_ae	jmp	#LR__3451
	add	local01, #1
	rdbyte	arg01, local01
	sub	local01, #1
	mov	arg02, local04
	mov	arg03, local03
	add	arg03, local05
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	add	local05, #1
 if_e	jmp	#LR__3450
LR__3451
' 	}
' 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
	add	local01, #10
	rdword	local04, local01
	cmp	local05, local04 wz
 if_e	mov	local06, #0
 if_ne	mov	local06, #1
	mov	result1, local06
LR__3452
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_clear_ret
	ret

_fatfs_cc_dir_sdi
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	cmp	local02, ##2097152 wc
 if_b	test	local02, #31 wz
' 		return FR_INT_ERR;
 if_nc_or_nz	mov	result1, #2
 if_nc_or_nz	jmp	#LR__3466
	add	local01, #16
	wrlong	local02, local01
	sub	local01, #8
	rdlong	local04, local01 wz
	sub	local01, #8
 if_e	rdbyte	local05, local03
 if_e	cmp	local05, #3 wc
 if_nc_and_z	add	local03, #40
 if_nc_and_z	rdlong	local04, local03
 if_nc_and_z	sub	local03, #40
	cmp	local04, #0 wz
 if_ne	jmp	#LR__3460
	mov	local05, local02
	shr	local05, #5
	add	local03, #8
	rdword	arg02, local03
	sub	local03, #8
	cmp	local05, arg02 wc
 if_ae	mov	result1, #2
 if_ae	jmp	#LR__3466
	add	local03, #40
	rdlong	local05, local03
	sub	local03, #40
	add	local01, #24
	wrlong	local05, local01
	sub	local01, #24
	jmp	#LR__3465
LR__3460
	add	local03, #10
	rdword	local06, local03
	sub	local03, #10
	shl	local06, #9
' 		csz = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 		while (ofs >= csz) {
LR__3461
	cmp	local02, local06 wc
 if_b	jmp	#LR__3464
	mov	arg01, local01
	mov	arg02, local04
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__3466
	cmp	local04, #2 wc
 if_b	jmp	#LR__3462
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local04, local05 wc
 if_b	jmp	#LR__3463
LR__3462
	mov	result1, #2
	jmp	#LR__3466
LR__3463
	sub	local02, local06
	jmp	#LR__3461
LR__3464
	mov	arg01, local03
	mov	arg02, local04
	call	#_fatfs_cc_clst2sect
	add	local01, #24
	wrlong	result1, local01
	sub	local01, #24
LR__3465
	add	local01, #20
	wrlong	local04, local01
	add	local01, #4
	rdlong	local05, local01 wz
	sub	local01, #24
 if_e	mov	result1, #2
 if_e	jmp	#LR__3466
	mov	local06, local02
	shr	local06, #9
	add	local01, #24
	rdlong	local05, local01
	add	local05, local06
	wrlong	local05, local01
	add	local03, #52
	and	local02, #511
	add	local03, local02
	add	local01, #4
	wrlong	local03, local01
' 	dp->sect += ofs /  ((UINT) 512 ) ;
' 	dp->dir = fs->win + (ofs %  ((UINT) 512 ) );
' 
' 	return FR_OK;
	mov	result1, #0
LR__3466
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_sdi_ret
	ret

_fatfs_cc_dir_next
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	add	local01, #16
	rdlong	local04, local01
	sub	local01, #16
	add	local04, #32
	cmp	local04, ##2097152 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
 if_ae	sub	local01, #24
	add	local01, #24
	rdlong	arg02, local01 wz
	sub	local01, #24
 if_e	mov	result1, #4
 if_e	jmp	#LR__3475
	test	local04, #511 wz
 if_ne	jmp	#LR__3474
	add	local01, #24
	rdlong	arg02, local01
	add	arg02, #1
	wrlong	arg02, local01
	sub	local01, #4
	rdlong	arg02, local01 wz
	sub	local01, #20
 if_ne	jmp	#LR__3470
	mov	arg02, local04
	shr	arg02, #5
	add	local03, #8
	rdword	local02, local03
	sub	local03, #8
	cmp	arg02, local02 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
' 				dp->sect = 0; return FR_NO_FILE;
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__3475
	jmp	#LR__3473
LR__3470
	mov	arg01, local04
	shr	arg01, #9
	add	local03, #10
	rdword	arg02, local03
	sub	local03, #10
	sub	arg02, #1
	test	arg01, arg02 wz
 if_ne	jmp	#LR__3472
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #2 wc
 if_b	mov	result1, #2
 if_b	jmp	#LR__3475
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__3475
	add	local03, #24
	rdlong	arg02, local03
	sub	local03, #24
	cmp	local05, arg02 wc
 if_b	jmp	#LR__3471
	cmp	local02, #0 wz
 if_e	add	local01, #24
 if_e	wrlong	#0, local01
' 						dp->sect = 0; return FR_NO_FILE;
 if_e	mov	result1, #4
 if_e	jmp	#LR__3475
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_create_chain
	mov	local05, result1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__3475
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__3475
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__3475
	mov	arg02, local05
	mov	arg01, local03
	call	#_fatfs_cc_dir_clear
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__3475
LR__3471
	add	local01, #20
	wrlong	local05, local01
	mov	arg01, local03
	mov	arg02, local05
	call	#_fatfs_cc_clst2sect
	add	local01, #4
	wrlong	result1, local01
	sub	local01, #24
LR__3472
LR__3473
LR__3474
	add	local01, #16
	wrlong	local04, local01
	add	local03, #52
	and	local04, #511
	add	local03, local04
	add	local01, #12
	wrlong	local03, local01
' #line 1771 "ff.c"
' 				}
' 				dp->clust = clst;
' 				dp->sect = clst2sect(fs, clst);
' 			}
' 		}
' 	}
' 	dp->dptr = ofs;
' 	dp->dir = fs->win + ofs %  ((UINT) 512 ) ;
' 
' 	return FR_OK;
	mov	result1, #0
LR__3475
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_next_ret
	ret

_fatfs_cc_dir_alloc
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local04, result1 wz
 if_ne	jmp	#LR__3484
	mov	local05, #0
' 		n = 0;
' 		do {
LR__3480
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local03
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__3483
	add	local01, #28
	rdlong	local06, local01
	sub	local01, #28
	rdbyte	local06, local06
	cmp	local06, #229 wz
 if_ne	add	local01, #28
 if_ne	rdlong	local07, local01
 if_ne	sub	local01, #28
 if_ne	rdbyte	local08, local07 wz
 if_ne	jmp	#LR__3481
	add	local05, #1
	cmp	local05, local02 wz
 if_e	jmp	#LR__3483
	jmp	#LR__3482
LR__3481
	mov	local05, #0
LR__3482
	mov	arg01, local01
	mov	arg02, #1
	call	#_fatfs_cc_dir_next
	mov	local04, result1 wz
 if_e	jmp	#LR__3480
LR__3483
LR__3484
	cmp	local04, #4 wz
 if_e	mov	local04, #7
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_alloc_ret
	ret

_fatfs_cc_ld_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	arg01, result1, #0
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
' {
' 
' 	return *((WORD*)ptr);
 if_e	rdword	result1, arg02
 if_e	shl	result1, #16
 if_e	or	arg01, result1
' 		cl |= (DWORD)ld_word(dir +  20 ) << 16;
' 	}
' 
' 	return cl;
	mov	result1, arg01
_fatfs_cc_ld_clust_ret
	ret

_fatfs_cc_st_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
	wrword	arg03, arg01
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
 if_e	shr	arg03, #16
 if_e	wrword	arg03, arg02
_fatfs_cc_st_clust_ret
	ret

_fatfs_cc_cmp_lfn
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__3496
	rdbyte	local02, arg02
	and	local02, #63
	sub	local02, #1
	qmul	local02, #13
' 
' 	i = ((dir[ 0 ] & 0x3F) - 1) * 13;
' 
' 	for (wc = 1, s = 0; s < 13; s++) {
	mov	local03, #1
	mov	local04, #0
	getqx	local05
LR__3490
	cmp	local04, #13 wc
 if_ae	jmp	#LR__3495
	mov	arg01, arg02
	mov	local02, local04
	add	ptr__fatfs_cc_dat__, ##942
	add	local02, ptr__fatfs_cc_dat__
	rdbyte	local02, local02
	mul	local02, #1
	add	arg01, local02
	sub	ptr__fatfs_cc_dat__, ##942
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local06, result1
	mov	local02, local03
	zerox	local02, #15 wz
 if_e	jmp	#LR__3493
	cmp	local05, #256 wc
 if_ae	jmp	#LR__3491
	getword	arg01, local06, #0
	call	#_fatfs_cc_ff_wtoupper
	mov	local02, result1
	mov	local03, local05
	shl	local03, #1
	add	local03, local01
	rdword	arg01, local03
	add	local05, #1
	call	#_fatfs_cc_ff_wtoupper
	cmp	local02, result1 wz
 if_e	jmp	#LR__3492
LR__3491
' 				return 0;
	mov	result1, #0
	jmp	#LR__3496
LR__3492
	mov	local03, local06
	jmp	#LR__3494
LR__3493
	getword	local06, local06, #0
	cmp	local06, ##65535 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__3496
LR__3494
	add	local04, #1
	jmp	#LR__3490
LR__3495
	rdbyte	local02, arg02
	test	local02, #64 wz
 if_ne	cmp	local03, #0 wz
 if_ne	shl	local05, #1
 if_ne	add	local05, local01
 if_ne	rdword	local07, local05 wz
 if_ne	mov	result1, #0
' 
' 	return 1;
 if_e	mov	result1, #1
LR__3496
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_cmp_lfn_ret
	ret

_fatfs_cc_pick_lfn
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__3505
	rdbyte	_var02, arg02
	andn	_var02, #64
	sub	_var02, #1
	qmul	_var02, #13
' 
' 	i = ((dir[ 0 ] & ~ 0x40 ) - 1) * 13;
' 
' 	for (wc = 1, s = 0; s < 13; s++) {
	mov	_var03, #1
	mov	_var04, #0
	getqx	_var05
LR__3500
	cmp	_var04, #13 wc
 if_ae	jmp	#LR__3503
	mov	arg01, arg02
	mov	_var02, _var04
	add	ptr__fatfs_cc_dat__, ##942
	add	_var02, ptr__fatfs_cc_dat__
	rdbyte	_var02, _var02
	mul	_var02, #1
	add	arg01, _var02
	sub	ptr__fatfs_cc_dat__, ##942
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	_var06, result1
	mov	_var02, _var03
	zerox	_var02, #15 wz
 if_e	jmp	#LR__3501
	cmp	_var05, #256 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#LR__3505
	mov	_var02, _var05
	shl	_var02, #1
	add	_var02, _var01
	mov	_var03, _var06
	wrword	_var03, _var02
	add	_var05, #1
	jmp	#LR__3502
LR__3501
	getword	_var06, _var06, #0
	cmp	_var06, ##65535 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__3505
LR__3502
	add	_var04, #1
	jmp	#LR__3500
LR__3503
	rdbyte	_var02, arg02
	test	_var02, #64 wz
 if_ne	mov	_var07, _var03
 if_ne	zerox	_var07, #15 wz
 if_e	jmp	#LR__3504
	cmp	_var05, #256 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#LR__3505
	shl	_var05, #1
	add	_var05, _var01
	wrword	#0, _var05
LR__3504
' 		lfnbuf[i] = 0;
' 	}
' 
' 	return 1;
	mov	result1, #1
LR__3505
_fatfs_cc_pick_lfn_ret
	ret

_fatfs_cc_put_lfn
	add	arg02, #13
	wrbyte	arg04, arg02
	getbyte	arg04, arg03, #0
	sub	arg04, #1
	qmul	arg04, #13
	mov	_var01, arg01
	sub	arg02, #2
	wrbyte	#15, arg02
	add	arg02, #1
	wrbyte	#0, arg02
	sub	arg02, #12
	mov	arg01, arg02
	add	arg01, #26
	wrword	#0, arg01
	mov	_var02, #0
	mov	_var03, #0
' 	BYTE* dir,
' 	BYTE ord,
' 	BYTE sum
' )
' {
' 	UINT i, s;
' 	WCHAR wc;
' 
' 
' 	dir[ 13 ] = sum;
' 	dir[ 11 ] =  0x0F ;
' 	dir[ 12 ] = 0;
' 	st_word(dir +  26 , 0);
' 
' 	i = (ord - 1) * 13;
' 	s = wc = 0;
' 	do {
	add	ptr__fatfs_cc_dat__, ##942
	getqx	_var04
	callpa	#(@LR__3511-@LR__3510)>>2,fcache_load_ptr_
LR__3510
	getword	arg04, _var02, #0
	cmp	arg04, ##65535 wz
 if_ne	mov	arg01, _var04
 if_ne	add	_var04, #1
 if_ne	shl	arg01, #1
 if_ne	add	arg01, _var01
 if_ne	rdword	_var02, arg01
	mov	arg01, arg02
	mov	arg04, _var03
	add	arg04, ptr__fatfs_cc_dat__
	rdbyte	arg04, arg04
	mul	arg04, #1
	add	arg01, arg04
	wrword	_var02, arg01
	mov	arg04, _var02
	zerox	arg04, #15 wz
 if_e	bmask	_var02, #15
	add	_var03, #1
	cmp	_var03, #13 wc
 if_b	jmp	#LR__3510
LR__3511
	sub	ptr__fatfs_cc_dat__, ##942
	getword	_var02, _var02, #0
	cmp	_var02, ##65535 wz
 if_ne	shl	_var04, #1
 if_ne	add	_var04, _var01
 if_ne	rdword	_var04, _var04 wz
 if_e	getbyte	arg03, arg03, #0
 if_e	or	arg03, #64
	wrbyte	arg03, arg02
_fatfs_cc_put_lfn_ret
	ret

_fatfs_cc_gen_numname
	mov	COUNT_, #8
	call	#pushregs_
	add	ptra, #44
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #11
	call	#__system____builtin_memmove
	cmp	local04, #6 wc
 if_b	jmp	#LR__3525
	mov	local05, local04
	callpa	#(@LR__3523-@LR__3520)>>2,fcache_load_ptr_
' 		sreg = seq;
' 		while (*lfn) {
LR__3520
	rdword	local06, local03 wz
 if_e	jmp	#LR__3524
	rdword	local07, local03
' 			wc = *lfn++;
' 			for (i = 0; i < 16; i++) {
	add	local03, #2
	rep	@LR__3522, #16
LR__3521
	shl	local05, #1
	getword	local06, local07, #0
	and	local06, #1
	add	local05, local06
	getword	local07, local07, #0
	shr	local07, #1
	testbn	local05, #16 wz
 if_ne	xor	local05, ##69665
LR__3522
	jmp	#LR__3520
LR__3523
LR__3524
	mov	local04, local05
LR__3525
	mov	local07, #7
' 			}
' 		}
' 		seq = (UINT)sreg;
' 	}
' 
' 
' 	i = 7;
' 	do {
	add	fp, #16
	callpa	#(@LR__3527-@LR__3526)>>2,fcache_load_ptr_
LR__3526
	getnib	local05, local04, #0
	add	local05, #48
	shr	local04, #4
	getbyte	local06, local05, #0
	cmp	local06, #58 wc
 if_ae	getbyte	local05, local05, #0
 if_ae	add	local05, #7
	mov	local06, local07
	sub	local07, #1 wz
	add	local06, fp
	wrbyte	local05, local06
 if_ne	cmp	local04, #0 wz
 if_ne	jmp	#LR__3526
LR__3527
	mov	local06, local07
	add	local06, fp
	wrbyte	#126, local06
' 	ns[i] = '~';
' 
' 
' 	for (j = 0; j < i && dst[j] != ' '; j++) {
	mov	local05, #0
	sub	fp, #16
	callpa	#(@LR__3530-@LR__3528)>>2,fcache_load_ptr_
LR__3528
	cmp	local05, local07 wc
 if_ae	jmp	#LR__3531
	mov	local06, local05
	add	local06, local01
	rdbyte	local06, local06
	cmp	local06, #32 wz
 if_e	jmp	#LR__3531
	mov	arg01, local05
	add	arg01, local01
	rdbyte	arg01, arg01 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__3529
	mov	local06, local07
	sub	local06, #1
	cmp	local05, local06 wz
 if_e	jmp	#LR__3531
	add	local05, #1
LR__3529
	add	local05, #1
	jmp	#LR__3528
LR__3530
LR__3531
	callpa	#(@LR__3535-@LR__3532)>>2,fcache_load_ptr_
' 			j++;
' 		}
' 	}
' 	do {
LR__3532
	mov	local06, local05
	add	local06, local01
	cmp	local07, #8 wc
	add	local05, #1
 if_ae	jmp	#LR__3533
	mov	local04, local07
	add	fp, #16
	add	local04, fp
	rdbyte	local08, local04
	add	local07, #1
	sub	fp, #16
	jmp	#LR__3534
LR__3533
	mov	local08, #32
LR__3534
	wrbyte	local08, local06
	cmp	local05, #8 wc
 if_b	jmp	#LR__3532
LR__3535
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_gen_numname_ret
	ret

_fatfs_cc_sum_sfn
	mov	_var01, #0
' )
' {
' 	BYTE sum = 0;
' 	UINT n = 11;
' 
' 	do {
	callpa	#(@LR__3542-@LR__3540)>>2,fcache_load_ptr_
LR__3540
	rep	@LR__3543, #11
LR__3541
	getbyte	result1, _var01, #0
	shr	result1, #1
	getbyte	_var01, _var01, #0
	shl	_var01, #7
	add	result1, _var01
	rdbyte	_var01, arg01
	add	_var01, result1
	add	arg01, #1
LR__3542
LR__3543
' 	return sum;
	mov	result1, _var01
_fatfs_cc_sum_sfn_ret
	ret

_fatfs_cc_dir_read
	mov	COUNT_, #12
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #4
	rdlong	local04, local01
	mov	local05, #255
	mov	local06, #255
' )
' {
' 	FRESULT res = FR_NO_FILE;
' 	FATFS *fs = dp->obj.fs;
' 	BYTE attr, b;
' 
' 	BYTE ord = 0xFF, sum = 0xFF;
' 
' 
' 	while (dp->sect) {
LR__3550
	add	local01, #24
	rdlong	result1, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__3560
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local04
	call	#_fatfs_cc_move_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__3560
	add	local01, #28
	rdlong	result1, local01
	sub	local01, #28
	rdbyte	local07, result1
	mov	result1, local07
	zerox	result1, #7 wz
 if_e	mov	local03, #4
' 			res = FR_NO_FILE; break;
 if_e	jmp	#LR__3560
	add	local01, #28
	rdlong	local08, local01
	add	local08, #11
	rdbyte	local09, local08
	and	local09, #63
	sub	local01, #22
	wrbyte	local09, local01
	sub	local01, #6
	getbyte	result1, local07, #0
	cmp	result1, #229 wz
 if_ne	mov	local08, local07
 if_ne	getbyte	local08, local08, #0
 if_ne	cmp	local08, #46 wz
 if_e	jmp	#LR__3551
	mov	local10, #0
	getbyte	local08, local09, #0
	andn	local08, #32
	cmp	local08, #8 wz
 if_e	mov	local10, #1
	cmp	local10, local02 wz
 if_e	jmp	#LR__3552
LR__3551
	mov	local05, #255
	jmp	#LR__3559
LR__3552
	getbyte	local09, local09, #0
	cmp	local09, #15 wz
 if_ne	jmp	#LR__3556
	getbyte	local11, local07, #0
	test	local11, #64 wz
 if_e	jmp	#LR__3553
	add	local01, #28
	rdlong	local11, local01
	add	local11, #13
	rdbyte	local06, local11
	getbyte	local07, local07, #0
	and	local07, #191
	mov	local05, local07
	sub	local01, #12
	rdlong	local11, local01
	add	local01, #28
	wrlong	local11, local01
	sub	local01, #44
LR__3553
	getbyte	local08, local07, #0
	getbyte	local10, local05, #0
	cmp	local08, local10 wz
 if_ne	jmp	#LR__3554
	getbyte	local10, local06, #0
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	add	local09, #13
	rdbyte	local08, local09
	getbyte	local09, local08, #0
	cmp	local10, local09 wz
 if_ne	jmp	#LR__3554
	add	local04, #12
	rdlong	arg01, local04
	sub	local04, #12
	add	local01, #28
	rdlong	local12, local01
	sub	local01, #28
	mov	arg02, local12
	call	#_fatfs_cc_pick_lfn
	cmps	result1, #0 wz
 if_ne	mov	local12, local05
 if_ne	getbyte	local12, local12, #0
 if_ne	sub	local12, #1
 if_ne	mov	local11, local12
 if_ne	jmp	#LR__3555
LR__3554
	mov	local11, #255
LR__3555
	mov	local05, local11
	jmp	#LR__3558
LR__3556
	mov	local11, local05
	zerox	local11, #7 wz
 if_ne	jmp	#LR__3557
	getbyte	local06, local06, #0
	add	local01, #28
	rdlong	arg01, local01
	sub	local01, #28
	call	#_fatfs_cc_sum_sfn
	getbyte	result1, result1, #0
	cmp	local06, result1 wz
 if_e	jmp	#LR__3560
LR__3557
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
' 						dp->blk_ofs = 0xFFFFFFFF;
' 					}
' 					break;
	jmp	#LR__3560
LR__3558
LR__3559
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local03, result1 wz
 if_e	jmp	#LR__3550
LR__3560
	cmp	local03, #0 wz
 if_ne	add	local01, #24
 if_ne	wrlong	#0, local01
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_read_ret
	ret

_fatfs_cc_dir_find
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3582
	mov	local03, #255
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
' #line 2404 "ff.c"
' 	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;
' 
' 	do {
LR__3570
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local05, result1 wz
 if_ne	jmp	#LR__3581
	add	local01, #28
	rdlong	arg03, local01
	sub	local01, #28
	rdbyte	local06, arg03
	mov	arg03, local06
	zerox	arg03, #7 wz
 if_e	mov	local05, #4
 if_e	jmp	#LR__3581
	add	local01, #28
	rdlong	local07, local01
	mov	arg03, local07
	add	arg03, #11
	rdbyte	local08, arg03
	and	local08, #63
	sub	local01, #22
	wrbyte	local08, local01
	sub	local01, #6
	getbyte	arg03, local06, #0
	cmp	arg03, #229 wz
 if_e	jmp	#LR__3571
	getbyte	arg03, local08, #0
	test	arg03, #8 wz
 if_ne	mov	local07, local08
 if_ne	getbyte	local07, local07, #0
 if_ne	cmp	local07, #15 wz
 if_e	jmp	#LR__3572
LR__3571
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
	jmp	#LR__3580
LR__3572
	getbyte	local08, local08, #0
	cmp	local08, #15 wz
 if_ne	jmp	#LR__3576
	add	local01, #43
	rdbyte	local08, local01
	sub	local01, #43
	test	local08, #64 wz
 if_ne	jmp	#LR__3579
	getbyte	local09, local06, #0
	test	local09, #64 wz
 if_e	jmp	#LR__3573
	add	local01, #28
	rdlong	local09, local01
	add	local09, #13
	rdbyte	local03, local09
	getbyte	local06, local06, #0
	and	local06, #191
	mov	local04, local06
	sub	local01, #12
	rdlong	local09, local01
	add	local01, #28
	wrlong	local09, local01
	sub	local01, #44
LR__3573
	getbyte	local10, local06, #0
	getbyte	local07, local04, #0
	cmp	local10, local07 wz
 if_ne	jmp	#LR__3574
	getbyte	local08, local03, #0
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	add	local07, #13
	rdbyte	local06, local07
	getbyte	local07, local06, #0
	cmp	local08, local07 wz
 if_ne	jmp	#LR__3574
	add	local02, #12
	rdlong	arg01, local02
	sub	local02, #12
	add	local01, #28
	rdlong	local11, local01
	sub	local01, #28
	mov	arg02, local11
	call	#_fatfs_cc_cmp_lfn
	cmps	result1, #0 wz
 if_ne	mov	local11, local04
 if_ne	getbyte	local11, local11, #0
 if_ne	sub	local11, #1
 if_ne	mov	local09, local11
 if_ne	jmp	#LR__3575
LR__3574
	mov	local09, #255
LR__3575
	mov	local04, local09
	jmp	#LR__3579
LR__3576
	mov	local09, local04
	zerox	local09, #7 wz
 if_ne	jmp	#LR__3577
	getbyte	local10, local03, #0
	add	local01, #28
	rdlong	arg01, local01
	sub	local01, #28
	call	#_fatfs_cc_sum_sfn
	getbyte	result1, result1, #0
	cmp	local10, result1 wz
 if_e	jmp	#LR__3581
LR__3577
	add	local01, #43
	rdbyte	local09, local01
	sub	local01, #43
	test	local09, #1 wz
 if_ne	jmp	#LR__3578
	add	local01, #28
	rdlong	arg01, local01
	add	local01, #4
	mov	arg02, local01
	sub	local01, #32
	mov	arg03, #11
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__3581
LR__3578
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
LR__3579
LR__3580
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local05, result1 wz
 if_e	jmp	#LR__3570
LR__3581
' 
' 	return res;
	mov	result1, local05
LR__3582
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_find_ret
	ret

_fatfs_cc_dir_register
	mov	COUNT_, #10
	call	#pushregs_
	add	ptra, #44
	add	fp, #4
	wrlong	arg01, fp
	rdlong	local01, arg01
	add	fp, #8
	wrlong	local01, fp
	sub	fp, #8
	rdlong	local02, fp
	sub	fp, #4
	add	local02, #43
	rdbyte	local02, local02
	test	local02, #160 wz
 if_ne	mov	result1, #6
 if_ne	jmp	#LR__3605
' 	for (len = 0; fs->lfnbuf[len]; len++) ;
	add	fp, #20
	wrlong	#0, fp
	sub	fp, #20
	callpa	#(@LR__3591-@LR__3590)>>2,fcache_load_ptr_
LR__3590
	add	fp, #12
	rdlong	local02, fp
	add	local02, #12
	rdlong	local03, local02
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #20
	shl	local04, #1
	add	local04, local03
	rdword	local02, local04 wz
 if_e	jmp	#LR__3592
	add	fp, #20
	rdlong	local05, fp
	mov	local06, local05
	mov	local07, local05
	mov	local08, local07
	add	local08, #1
	wrlong	local08, fp
	sub	fp, #20
	jmp	#LR__3590
LR__3591
LR__3592
	add	fp, #28
	mov	arg01, fp
	sub	fp, #24
	rdlong	arg02, fp
	sub	fp, #4
	add	arg02, #32
	mov	arg03, #12
	call	#__system____builtin_memmove
	add	fp, #39
	rdbyte	local09, fp
	sub	fp, #39
	test	local09, #1 wz
 if_e	jmp	#LR__3595
	add	fp, #4
	rdlong	local10, fp
	add	local10, #43
	wrbyte	#64, local10
' 		dp->fn[ 11 ] =  0x40 ;
' 		for (n = 1; n < 100; n++) {
	add	fp, #12
	wrlong	#1, fp
	sub	fp, #16
LR__3593
	add	fp, #16
	rdlong	local02, fp
	sub	fp, #16
	cmp	local02, #100 wc
 if_ae	jmp	#LR__3594
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #32
	add	fp, #24
	mov	arg02, fp
	sub	fp, #16
	rdlong	local10, fp
	add	local10, #12
	rdlong	arg03, local10
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #16
	call	#_fatfs_cc_gen_numname
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	call	#_fatfs_cc_dir_find
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__3594
	add	fp, #16
	rdlong	local10, fp
	add	local10, #1
	wrlong	local10, fp
	sub	fp, #16
	jmp	#LR__3593
LR__3594
	add	fp, #16
	rdlong	local10, fp
	sub	fp, #16
	cmp	local10, #100 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__3605
	add	fp, #8
	rdlong	local10, fp
	sub	fp, #8
	cmp	local10, #4 wz
 if_ne	add	fp, #8
 if_ne	rdlong	result1, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__3605
	add	fp, #4
	rdlong	local10, fp
	add	fp, #35
	rdbyte	local01, fp
	sub	fp, #39
	add	local10, #43
	wrbyte	local01, local10
LR__3595
	add	fp, #39
	rdbyte	local02, fp
	sub	fp, #39
	test	local02, #2 wz
 if_e	jmp	#LR__3596
	add	fp, #20
	rdlong	local10, fp
	add	local10, #12
	qdiv	local10, #13
	sub	fp, #20
	getqx	local10
	add	local10, #1
	jmp	#LR__3597
LR__3596
	mov	local10, #1
LR__3597
	add	fp, #24
	wrlong	local10, fp
	sub	fp, #20
	rdlong	arg01, fp
	mov	arg02, local10
	sub	fp, #4
	call	#_fatfs_cc_dir_alloc
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3602
	add	fp, #24
	rdlong	local10, fp
	sub	local10, #1 wz
	wrlong	local10, fp
	sub	fp, #24
 if_e	jmp	#LR__3602
	add	fp, #4
	rdlong	local10, fp
	mov	arg01, local10
	add	fp, #20
	rdlong	arg04, fp
	sub	fp, #24
	shl	arg04, #5
	add	local10, #16
	rdlong	arg02, local10
	sub	arg02, arg04
	call	#_fatfs_cc_dir_sdi
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3601
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #32
	call	#_fatfs_cc_sum_sfn
	mov	local10, result1
	add	fp, #40
	wrbyte	local10, fp
	sub	fp, #40
' 			sum = sum_sfn(dp->fn);
' 			do {
LR__3598
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #8
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #24
	rdlong	arg02, local01
	call	#_fatfs_cc_move_window
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__3600
	add	fp, #12
	rdlong	local02, fp
	add	local02, #12
	rdlong	arg01, local02
	sub	fp, #8
	rdlong	local01, fp
	add	local01, #28
	rdlong	arg02, local01
	add	fp, #20
	rdlong	arg03, fp
	add	fp, #16
	rdbyte	arg04, fp
	sub	fp, #40
	call	#_fatfs_cc_put_lfn
	add	fp, #12
	rdlong	local10, fp
	add	local10, #3
	wrbyte	#1, local10
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__3599
	add	fp, #24
	rdlong	local10, fp
	sub	local10, #1 wz
	wrlong	local10, fp
	sub	fp, #24
 if_ne	jmp	#LR__3598
LR__3599
LR__3600
LR__3601
LR__3602
	add	fp, #8
	rdlong	local10, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__3604
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #8
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #24
	rdlong	arg02, local01
	call	#_fatfs_cc_move_window
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3603
	add	fp, #4
	rdlong	local02, fp
	sub	fp, #4
	add	local02, #28
	rdlong	arg01, local02
	mov	arg02, #0
	mov	arg03, #32
	call	#\builtin_bytefill_
	add	fp, #4
	rdlong	arg02, fp
	mov	local01, arg02
	add	local01, #28
	rdlong	arg01, local01
	sub	fp, #4
	add	arg02, #32
	mov	arg03, #11
	call	#__system____builtin_memmove
	add	fp, #4
	rdlong	local09, fp
	mov	local10, local09
	add	local10, #28
	rdlong	local01, local10
	add	local09, #43
	rdbyte	local10, local09
	and	local10, #24
	add	local01, #12
	wrbyte	local10, local01
	add	fp, #8
	rdlong	local10, fp
	sub	fp, #12
	add	local10, #3
	wrbyte	#1, local10
LR__3603
LR__3604
' 			__builtin_memset(dp->dir, 0, 32 ) ;
' 			__builtin_memcpy(dp->dir + 0 , dp->fn, 11) ;
' 
' 			dp->dir[ 12 ] = dp->fn[ 11 ] & ( 0x08  |  0x10 );
' 
' 			fs->wflag = 1;
' 		}
' 	}
' 
' 	return res;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
LR__3605
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_register_ret
	ret

_fatfs_cc_dir_remove
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #16
	rdlong	local03, local01
	add	local01, #28
	rdlong	arg02, local01
	sub	local01, #44
	cmp	arg02, ##-1 wz
 if_e	mov	local04, #0
 if_e	jmp	#LR__3610
	mov	arg01, local01
	add	local01, #44
	rdlong	arg02, local01
	sub	local01, #44
	call	#_fatfs_cc_dir_sdi
	mov	local04, result1
LR__3610
	mov	local05, local04 wz
 if_ne	jmp	#LR__3613
' 		do {
LR__3611
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local05, result1 wz
 if_ne	jmp	#LR__3612
	add	local01, #28
	rdlong	local04, local01
	wrbyte	#229, local04
	add	local02, #3
	wrbyte	#1, local02
	sub	local02, #3
	sub	local01, #12
	rdlong	local04, local01
	sub	local01, #16
	cmp	local04, local03 wc
 if_ae	jmp	#LR__3612
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local05, result1 wz
 if_e	jmp	#LR__3611
LR__3612
	cmp	local05, #4 wz
 if_e	mov	local05, #2
LR__3613
' 	}
' #line 2590 "ff.c"
' 	return res;
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_remove_ret
	ret

_fatfs_cc_get_fileinfo
	mov	COUNT_, #15
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	add	local02, #28
	wrbyte	#0, local02
	sub	local02, #28
	add	local01, #24
	rdlong	local04, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__3634
	add	local01, #44
	rdlong	local04, local01
	sub	local01, #44
	cmp	local04, ##-1 wz
 if_e	jmp	#LR__3623
	mov	local05, #0
	mov	local06, #0
	mov	local07, #0
' 			si = di = 0;
' 			hs = 0;
' 			while (fs->lfnbuf[si] != 0) {
LR__3620
	add	local03, #12
	rdlong	local04, local03
	sub	local03, #12
	mov	local08, local06
	shl	local08, #1
	add	local08, local04
	rdword	local04, local08 wz
 if_e	jmp	#LR__3622
	add	local03, #12
	rdlong	local09, local03
	sub	local03, #12
	mov	local10, local06
	shl	local10, #1
	add	local10, local09
	rdword	local11, local10
	mov	local04, local07
	zerox	local04, #15 wz
	add	local06, #1
 if_ne	jmp	#LR__3621
	getword	local12, local11, #0
	cmp	local12, ##55296 wc
 if_b	jmp	#LR__3621
	getword	local13, local11, #0
	cmp	local13, ##57344 wc
 if_b	mov	local07, local11
' 					hs = wc; continue;
 if_b	jmp	#LR__3620
LR__3621
	getword	arg01, local07, #0
	shl	arg01, #16
	getword	local11, local11, #0
	or	arg01, local11
	mov	arg02, local05
	add	local02, #28
	add	arg02, local02
	mov	arg03, #255
	sub	arg03, local05
	sub	local02, #28
	call	#_fatfs_cc_put_utf
	mov	local14, result1 wz
 if_e	mov	local05, #0
 if_ne	add	local05, local14
 if_ne	mov	local07, #0
 if_ne	jmp	#LR__3620
LR__3622
	mov	local04, local07
	zerox	local04, #15 wz
 if_ne	mov	local05, #0
	add	local02, #28
	add	local05, local02
	wrbyte	#0, local05
	sub	local02, #28
LR__3623
	mov	local05, #0
	mov	local06, #0
' 			fno->fname[di] = 0;
' 		}
' 	}
' 
' 	si = di = 0;
' 	while (si < 11) {
LR__3624
	cmp	local06, #11 wc
 if_ae	jmp	#LR__3627
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	mov	local10, local06
	add	local10, local09
	rdbyte	local11, local10
	getword	local04, local11, #0
	cmp	local04, #32 wz
	add	local06, #1
 if_e	jmp	#LR__3624
	getword	local04, local11, #0
	cmp	local04, #5 wz
 if_e	mov	local11, #229
	cmp	local06, #9 wz
 if_ne	jmp	#LR__3625
	cmp	local05, #12 wc
 if_ae	jmp	#LR__3625
	mov	local13, local05
	add	local02, #12
	add	local13, local02
	wrbyte	#46, local13
	add	local05, #1
	sub	local02, #12
LR__3625
	getword	arg01, local11, #0
	zerox	arg01, #7 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_ne	cmp	local06, #8 wz
 if_ne	cmp	local06, #11 wz
 if_e	jmp	#LR__3626
	add	local01, #28
	rdlong	local10, local01
	sub	local01, #28
	mov	local08, local06
	add	local08, local10
	rdbyte	arg01, local08 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__3626
	getword	local11, local11, #0
	shl	local11, #8
	add	local01, #28
	rdlong	local14, local01
	sub	local01, #28
	mov	local09, local06
	add	local09, local14
	rdbyte	local12, local09
	or	local11, local12
	add	local06, #1
LR__3626
	mov	arg01, local11
	mov	arg02, ##850
	call	#_fatfs_cc_ff_oem2uni
	mov	local11, result1
	mov	local04, local11
	zerox	local04, #15 wz
 if_e	mov	local05, #0
 if_e	jmp	#LR__3627
	getword	arg01, local11, #0
	mov	arg02, local05
	add	local02, #12
	add	arg02, local02
	mov	arg03, #12
	sub	arg03, local05
	sub	local02, #12
	call	#_fatfs_cc_put_utf
	mov	local14, result1 wz
 if_e	mov	local05, #0
 if_ne	add	local05, local14
 if_ne	jmp	#LR__3624
LR__3627
	mov	local04, local05
	add	local02, #12
	add	local04, local02
	wrbyte	#0, local04
	add	local02, #16
	rdbyte	local04, local02 wz
	sub	local02, #28
 if_ne	jmp	#LR__3633
	cmp	local05, #0 wz
 if_ne	jmp	#LR__3628
	mov	local13, local05
	add	local02, #28
	add	local13, local02
	wrbyte	#63, local13
	add	local05, #1
	sub	local02, #28
	jmp	#LR__3632
LR__3628
' 			for (si = di = 0, lcf =  0x08 ; fno->altname[si]; si++, di++) {
	mov	local05, #0
	mov	local06, #0
	mov	local15, #8
LR__3629
	mov	local04, local06
	add	local02, #12
	add	local04, local02
	rdbyte	local13, local04 wz
	sub	local02, #12
 if_e	jmp	#LR__3631
	mov	local08, local06
	add	local02, #12
	add	local08, local02
	rdbyte	local11, local08
	getword	local14, local11, #0
	cmp	local14, #46 wz
	sub	local02, #12
 if_e	mov	local15, #16
	getword	local14, local11, #0
	cmp	local14, #65 wc
 if_b	jmp	#LR__3630
	getword	local08, local11, #0
	cmp	local08, #91 wc
 if_ae	jmp	#LR__3630
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	add	local09, #12
	rdbyte	local10, local09
	getbyte	local14, local15, #0
	test	local10, local14 wz
 if_ne	getword	local11, local11, #0
 if_ne	add	local11, #32
LR__3630
	mov	local14, local05
	add	local02, #28
	add	local14, local02
	getword	local11, local11, #0
	wrbyte	local11, local14
	add	local06, #1
	add	local05, #1
	sub	local02, #28
	jmp	#LR__3629
LR__3631
LR__3632
	add	local02, #28
	add	local05, local02
	wrbyte	#0, local05
	add	local01, #28
	rdlong	local04, local01
	sub	local01, #28
	add	local04, #12
	rdbyte	local13, local04 wz
	sub	local02, #28
 if_e	add	local02, #12
 if_e	wrbyte	#0, local02
 if_e	sub	local02, #12
LR__3633
	add	local01, #28
	rdlong	local12, local01
	add	local12, #11
	rdbyte	local04, local12
	and	local04, #63
	add	local02, #8
	wrbyte	local04, local02
	sub	local02, #8
	rdlong	arg01, local01
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	wrlong	result1, local02
	rdlong	arg01, local01
	add	arg01, #22
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	local02, #6
	wrword	result1, local02
	rdlong	arg01, local01
	add	arg01, #24
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	local02, #2
	wrword	result1, local02
LR__3634
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_fileinfo_ret
	ret

_fatfs_cc_create_name
	mov	COUNT_, #13
	call	#pushregs_
	add	ptra, #52
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	rdlong	result1, arg02
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #44
	rdlong	result1, fp
	rdlong	local01, result1
	add	local01, #12
	rdlong	local02, local01
	add	fp, #20
	wrlong	local02, fp
	add	fp, #20
	wrlong	#0, fp
	sub	fp, #44
' 
' 
' 
' 	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
' 	for (;;) {
LR__3640
	add	fp, #48
	mov	arg01, fp
	sub	fp, #48
	call	#_fatfs_cc_tchar2uni
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	cmp	result1, ##-1 wz
 if_e	mov	result1, #6
 if_e	jmp	#LR__3680
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	cmp	local01, ##65536 wc
 if_b	jmp	#LR__3641
	add	fp, #24
	rdlong	local03, fp
	add	fp, #20
	rdlong	local01, fp
	mov	local04, local01
	add	local04, #1
	wrlong	local04, fp
	shl	local01, #1
	add	local01, local03
	sub	fp, #16
	rdlong	local05, fp
	sub	fp, #28
	mov	local06, local05
	shr	local06, #16
	wrword	local06, local01
LR__3641
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #8
	wrword	local01, fp
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #32 wc
 if_b	jmp	#LR__3643
	add	fp, #20
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #47 wz
 if_ne	add	fp, #20
 if_ne	rdword	local04, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local04, #92 wz
 if_e	jmp	#LR__3643
	add	fp, #20
	rdword	arg01, fp
	sub	fp, #20
	cmp	arg01, #128 wc
 if_ae	jmp	#LR__3642
	mov	arg01, ##@LR__4302
	add	fp, #20
	rdword	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_strchr
	cmp	result1, #0 wz
 if_ne	mov	result1, #6
 if_ne	jmp	#LR__3680
LR__3642
	add	fp, #44
	rdlong	local06, fp
	sub	fp, #44
	cmp	local06, #255 wc
 if_ae	mov	result1, #6
 if_ae	jmp	#LR__3680
	add	fp, #24
	rdlong	local03, fp
	add	fp, #20
	rdlong	local02, fp
	mov	local04, local02
	add	local04, #1
	wrlong	local04, fp
	mov	local01, local02
	shl	local01, #1
	add	local01, local03
	sub	fp, #24
	rdword	local06, fp
	sub	fp, #20
	wrword	local06, local01
	jmp	#LR__3640
LR__3643
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #32 wc
 if_b	add	fp, #16
 if_b	wrbyte	#4, fp
 if_b	sub	fp, #16
 if_b	jmp	#LR__3648
	callpa	#(@LR__3646-@LR__3644)>>2,fcache_load_ptr_
' 		while ( ((*p) == '/' || (*p) == '\\') ) p++;
LR__3644
	add	fp, #48
	rdlong	local04, fp
	sub	fp, #48
	rdbyte	local07, local04
	cmp	local07, #47 wz
 if_e	jmp	#LR__3645
	add	fp, #48
	rdlong	local04, fp
	sub	fp, #48
	rdbyte	local02, local04
	cmp	local02, #92 wz
 if_ne	jmp	#LR__3647
LR__3645
	add	fp, #48
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	sub	fp, #48
	jmp	#LR__3644
LR__3646
LR__3647
	add	fp, #16
	wrbyte	#0, fp
	add	fp, #32
	rdlong	local06, fp
	sub	fp, #48
	rdbyte	local07, local06
	cmp	local07, #32 wc
 if_b	add	fp, #16
 if_b	wrbyte	#4, fp
 if_b	sub	fp, #16
LR__3648
	add	fp, #8
	rdlong	local07, fp
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #48
	wrlong	local01, local07
	callpa	#(@LR__3650-@LR__3649)>>2,fcache_load_ptr_
' 	}
' 	*path = p;
' #line 2862 "ff.c"
' 	while (di) {
LR__3649
	add	fp, #44
	rdlong	local07, fp wz
	sub	fp, #44
 if_e	jmp	#LR__3651
	add	fp, #24
	rdlong	local06, fp
	add	fp, #20
	rdlong	local04, fp
	sub	local04, #1
	shl	local04, #1
	add	local04, local06
	rdword	local06, local04
	sub	fp, #24
	wrword	local06, fp
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #32 wz
 if_ne	add	fp, #20
 if_ne	rdword	local01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local01, #46 wz
 if_ne	jmp	#LR__3651
	add	fp, #44
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #44
	jmp	#LR__3649
LR__3650
LR__3651
	add	fp, #24
	rdlong	local08, fp
	add	fp, #20
	rdlong	local04, fp
	shl	local04, #1
	add	local04, local08
	wrword	#0, local04
	rdlong	local07, fp wz
	sub	fp, #44
 if_e	mov	result1, #6
 if_e	jmp	#LR__3680
' 
' 
' 	for (si = 0; lfn[si] == ' '; si++) ;
	add	fp, #40
	wrlong	#0, fp
	sub	fp, #40
	callpa	#(@LR__3653-@LR__3652)>>2,fcache_load_ptr_
LR__3652
	add	fp, #24
	rdlong	local09, fp
	add	fp, #16
	rdlong	local10, fp
	sub	fp, #40
	shl	local10, #1
	add	local10, local09
	rdword	local11, local10
	cmp	local11, #32 wz
 if_ne	jmp	#LR__3654
	add	fp, #40
	rdlong	local12, fp
	mov	local05, local12
	add	local05, #1
	wrlong	local05, fp
	sub	fp, #40
	jmp	#LR__3652
LR__3653
LR__3654
	add	fp, #40
	rdlong	local07, fp
	sub	fp, #40
	cmp	local07, #1 wc
 if_ae	jmp	#LR__3655
	add	fp, #24
	rdlong	local03, fp
	add	fp, #16
	rdlong	local09, fp
	sub	fp, #40
	shl	local09, #1
	add	local09, local03
	rdword	local01, local09
	cmp	local01, #46 wz
 if_ne	jmp	#LR__3656
LR__3655
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #3
	wrbyte	local07, fp
	sub	fp, #16
LR__3656
	callpa	#(@LR__3658-@LR__3657)>>2,fcache_load_ptr_
' 	while (di > 0 && lfn[di - 1] != '.') di--;
LR__3657
	add	fp, #44
	rdlong	local07, fp
	sub	fp, #44
	cmp	local07, #1 wc
 if_b	jmp	#LR__3659
	add	fp, #24
	rdlong	local06, fp
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #44
	sub	local03, #1
	shl	local03, #1
	add	local03, local06
	rdword	local01, local03
	cmp	local01, #46 wz
 if_e	jmp	#LR__3659
	add	fp, #44
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #44
	jmp	#LR__3657
LR__3658
LR__3659
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #32
	mov	arg02, #32
	mov	arg03, #11
	mov	local13, arg01
	call	#\builtin_bytefill_
	mov	result1, local13
	add	fp, #12
	wrbyte	#0, fp
	rdbyte	local07, fp
	add	fp, #20
	wrlong	local07, fp
	add	fp, #4
	wrlong	#8, fp
	sub	fp, #36
' 
' 	__builtin_memset(dp->fn, ' ', 11) ;
' 	i = b = 0; ni = 8;
' 	for (;;) {
LR__3660
	add	fp, #24
	rdlong	local03, fp
	add	fp, #16
	rdlong	local09, fp
	mov	local04, local09
	add	local04, #1
	wrlong	local04, fp
	shl	local09, #1
	add	local09, local03
	rdword	local06, local09
	sub	fp, #20
	wrword	local06, fp
	rdword	local07, fp wz
	sub	fp, #20
 if_e	jmp	#LR__3676
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #32 wz
 if_e	jmp	#LR__3661
	add	fp, #20
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #46 wz
 if_ne	jmp	#LR__3662
	add	fp, #40
	rdlong	local04, fp
	add	fp, #4
	rdlong	local10, fp
	sub	fp, #44
	cmp	local04, local10 wz
 if_e	jmp	#LR__3662
LR__3661
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #3
	wrbyte	local07, fp
	sub	fp, #16
' 			cf |=  0x01  |  0x02 ;
' 			continue;
	jmp	#LR__3660
LR__3662
	add	fp, #32
	rdlong	local07, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #36
	cmp	local07, local01 wc
 if_ae	jmp	#LR__3663
	add	fp, #40
	rdlong	local08, fp
	add	fp, #4
	rdlong	local10, fp
	sub	fp, #44
	cmp	local08, local10 wz
 if_ne	jmp	#LR__3665
LR__3663
	add	fp, #36
	rdlong	local07, fp
	sub	fp, #36
	cmp	local07, #11 wz
 if_ne	jmp	#LR__3664
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #3
	wrbyte	local07, fp
	sub	fp, #16
' 				cf |=  0x01  |  0x02 ;
' 				break;
	jmp	#LR__3676
LR__3664
	add	fp, #40
	rdlong	local07, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #44
	cmp	local07, local01 wz
 if_ne	add	fp, #16
 if_ne	rdbyte	local07, fp
 if_ne	or	local07, #3
 if_ne	wrbyte	local07, fp
 if_ne	sub	fp, #16
	add	fp, #40
	rdlong	local07, fp
	add	fp, #4
	rdlong	local02, fp
	sub	fp, #44
	cmp	local07, local02 wcz
 if_a	jmp	#LR__3676
	add	fp, #44
	rdlong	local07, fp
	sub	fp, #4
	wrlong	local07, fp
	sub	fp, #8
	wrlong	#8, fp
	add	fp, #4
	wrlong	#11, fp
	sub	fp, #24
	rdbyte	local11, fp
	getbyte	local07, local11, #0
	shl	local07, #2
	wrbyte	local07, fp
	sub	fp, #12
' 			si = di; i = 8; ni = 11; b <<= 2;
' 			continue;
	jmp	#LR__3660
LR__3665
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #128 wc
 if_b	jmp	#LR__3667
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #2
	wrbyte	local07, fp
	add	fp, #4
	rdword	arg01, fp
	sub	fp, #20
	mov	arg02, ##850
	call	#_fatfs_cc_ff_uni2oem
	add	fp, #20
	wrword	result1, fp
	rdword	local07, fp
	sub	fp, #20
	test	local07, #128 wz
 if_e	jmp	#LR__3666
	add	fp, #20
	rdword	local02, fp
	and	local02, #127
	add	ptr__fatfs_cc_dat__, ##955
	add	local02, ptr__fatfs_cc_dat__
	rdbyte	local07, local02
	wrword	local07, fp
	sub	fp, #20
	sub	ptr__fatfs_cc_dat__, ##955
LR__3666
LR__3667
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #256 wc
 if_b	jmp	#LR__3669
	add	fp, #36
	rdlong	local07, fp
	sub	local07, #1
	sub	fp, #4
	rdlong	local02, fp
	sub	fp, #32
	cmp	local02, local07 wc
 if_b	jmp	#LR__3668
	add	fp, #16
	rdbyte	local11, fp
	getbyte	local07, local11, #0
	or	local07, #3
	wrbyte	local07, fp
	add	fp, #20
	rdlong	local07, fp
	sub	fp, #4
	wrlong	local07, fp
	sub	fp, #32
' 				cf |=  0x01  |  0x02 ;
' 				i = ni; continue;
	jmp	#LR__3660
LR__3668
	add	fp, #4
	rdlong	local09, fp
	add	fp, #28
	rdlong	local10, fp
	mov	local04, local10
	add	local04, #1
	wrlong	local04, fp
	add	local09, #32
	add	local10, local09
	sub	fp, #12
	rdword	local03, fp
	sub	fp, #20
	shr	local03, #8
	wrbyte	local03, local10
	jmp	#LR__3675
LR__3669
	add	fp, #20
	rdword	local07, fp wz
	sub	fp, #20
 if_e	jmp	#LR__3670
	mov	arg01, ##@LR__4303
	add	fp, #20
	rdword	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_strchr
	cmp	result1, #0 wz
 if_e	jmp	#LR__3671
LR__3670
	add	fp, #20
	wrword	#95, fp
	sub	fp, #4
	rdbyte	local07, fp
	or	local07, #3
	wrbyte	local07, fp
	sub	fp, #16
	jmp	#LR__3674
LR__3671
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #65 wc
 if_b	jmp	#LR__3672
	add	fp, #20
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #91 wc
 if_b	add	fp, #12
 if_b	rdbyte	local07, fp
 if_b	or	local07, #2
 if_b	wrbyte	local07, fp
 if_b	sub	fp, #12
LR__3672
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #97 wc
 if_b	jmp	#LR__3673
	add	fp, #20
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #123 wc
 if_ae	jmp	#LR__3673
	add	fp, #12
	rdbyte	local07, fp
	or	local07, #1
	wrbyte	local07, fp
	add	fp, #8
	rdword	local07, fp
	sub	local07, #32
	wrword	local07, fp
	sub	fp, #20
LR__3673
LR__3674
LR__3675
	add	fp, #4
	rdlong	local11, fp
	mov	local09, local11
	add	fp, #28
	rdlong	local02, fp
	mov	local04, local02
	add	local04, #1
	wrlong	local04, fp
	mov	local10, local02
	add	local09, #32
	add	local10, local09
	sub	fp, #12
	rdword	local03, fp
	sub	fp, #20
	wrbyte	local03, local10
	jmp	#LR__3660
LR__3676
	add	fp, #4
	rdlong	local11, fp
	sub	fp, #4
	add	local11, #32
	rdbyte	local07, local11
	cmp	local07, #229 wz
 if_e	add	fp, #4
 if_e	rdlong	local07, fp
 if_e	sub	fp, #4
 if_e	add	local07, #32
 if_e	wrbyte	#5, local07
	add	fp, #36
	rdlong	local07, fp
	sub	fp, #36
	cmp	local07, #8 wz
 if_e	add	fp, #12
 if_e	rdbyte	local07, fp
 if_e	shl	local07, #2
 if_e	wrbyte	local07, fp
 if_e	sub	fp, #12
	add	fp, #12
	rdbyte	local07, fp
	sub	fp, #12
	and	local07, #12
	cmp	local07, #12 wz
 if_e	jmp	#LR__3677
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	and	local01, #3
	cmp	local01, #3 wz
 if_ne	jmp	#LR__3678
LR__3677
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #2
	wrbyte	local07, fp
	sub	fp, #16
LR__3678
	add	fp, #16
	rdbyte	local07, fp
	sub	fp, #16
	test	local07, #2 wz
 if_ne	jmp	#LR__3679
	add	fp, #12
	rdbyte	local07, fp
	sub	fp, #12
	test	local07, #1 wz
 if_ne	add	fp, #16
 if_ne	rdbyte	local07, fp
 if_ne	or	local07, #16
 if_ne	wrbyte	local07, fp
 if_ne	sub	fp, #16
	add	fp, #12
	rdbyte	local07, fp
	sub	fp, #12
	test	local07, #4 wz
 if_ne	add	fp, #16
 if_ne	rdbyte	local07, fp
 if_ne	or	local07, #8
 if_ne	wrbyte	local07, fp
 if_ne	sub	fp, #16
LR__3679
	add	fp, #4
	rdlong	local07, fp
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #16
	add	local07, #43
	wrbyte	local01, local07
' 	}
' 
' 	dp->fn[ 11 ] = cf;
' 
' 	return FR_OK;
	mov	result1, #0
LR__3680
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_name_ret
	ret

_fatfs_cc_follow_path
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	result1, fp
	rdlong	local01, result1
	add	fp, #16
	wrlong	local01, fp
	sub	fp, #20
	callpa	#(@LR__3692-@LR__3690)>>2,fcache_load_ptr_
' )
' {
' 	FRESULT res;
' 	BYTE ns;
' 	FATFS *fs = dp->obj.fs;
' #line 3034 "ff.c"
' 	{
' 		while ( ((*path) == '/' || (*path) == '\\') ) path++;
LR__3690
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	rdbyte	local01, local01
	cmp	local01, #47 wz
 if_e	jmp	#LR__3691
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	rdbyte	local01, local01
	cmp	local01, #92 wz
 if_ne	jmp	#LR__3693
LR__3691
	add	fp, #8
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	sub	fp, #8
	jmp	#LR__3690
LR__3692
LR__3693
	add	fp, #4
	rdlong	local01, fp
	add	local01, #8
	wrlong	#0, local01
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #8
	rdbyte	local01, local01
	cmp	local01, #32 wc
 if_ae	jmp	#LR__3694
	add	fp, #4
	rdlong	local01, fp
	add	local01, #43
	wrbyte	#128, local01
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	jmp	#LR__3698
LR__3694
' 		for (;;) {
LR__3695
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	mov	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_create_name
	add	fp, #12
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #12
 if_ne	jmp	#LR__3697
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	call	#_fatfs_cc_dir_find
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #8
	rdlong	local01, fp
	add	local01, #43
	rdbyte	local01, local01
	add	fp, #12
	wrbyte	local01, fp
	sub	fp, #4
	rdlong	local01, fp wz
	sub	fp, #12
 if_e	jmp	#LR__3696
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #4 wz
 if_ne	jmp	#LR__3697
	add	fp, #16
	rdbyte	local01, fp
	sub	fp, #16
	test	local01, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#5, fp
 if_e	sub	fp, #12
' 					}
' 				}
' 				break;
	jmp	#LR__3697
LR__3696
	add	fp, #16
	rdbyte	local01, fp
	sub	fp, #16
	test	local01, #4 wz
 if_ne	jmp	#LR__3697
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #6
	rdbyte	local01, local01
	test	local01, #16 wz
 if_e	add	fp, #12
 if_e	wrlong	#5, fp
 if_e	sub	fp, #12
' 				res = FR_NO_PATH; break;
 if_e	jmp	#LR__3697
	add	fp, #4
	rdlong	local02, fp
	mov	local01, local02
	add	fp, #16
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg02, #52
	sub	fp, #20
	add	local02, #16
	rdlong	local02, local02
	and	local02, #511
	add	arg02, local02
	call	#_fatfs_cc_ld_clust
	add	local01, #8
	wrlong	result1, local01
	jmp	#LR__3695
LR__3697
LR__3698
' 			}
' #line 3090 "ff.c"
' 			{
' 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr %  ((UINT) 512 ) );
' 			}
' 		}
' 	}
' 
' 	return res;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_follow_path_ret
	ret

_fatfs_cc_get_ldnumber
	neg	_var01, #1
	rdlong	_var02, arg01 wz
	mov	_var03, _var02
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_get_ldnumber_ret
	callpa	#(@LR__3701-@LR__3700)>>2,fcache_load_ptr_
' 	do tc = *tt++; while (! ((UINT)(tc) < ( 1 ? ' ' : '!'))  && tc != ':');
LR__3700
	rdbyte	_var04, _var03
	getbyte	result1, _var04, #0
	cmp	result1, #32 wc
	add	_var03, #1
 if_ae	mov	_var05, _var04
 if_ae	getbyte	_var05, _var05, #0
 if_ae	cmp	_var05, #58 wz
 if_a	jmp	#LR__3700
LR__3701
	getbyte	_var04, _var04, #0
	cmp	_var04, #58 wz
 if_ne	jmp	#LR__3703
	mov	_var06, #1
	rdbyte	_var05, _var02
	cmp	_var05, #48 wc
 if_b	jmp	#LR__3702
	rdbyte	_var05, _var02
	cmp	_var05, #58 wc
 if_b	mov	_var07, _var02
 if_b	add	_var07, #2
 if_b	cmp	_var07, _var03 wz
 if_c_and_z	rdbyte	_var06, _var02
 if_c_and_z	sub	_var06, #48
LR__3702
	cmps	_var06, #1 wc
 if_b	mov	_var01, _var06
 if_b	wrlong	_var03, arg01
' 			vol = i;
' 			*path = tt;
' 		}
' 		return vol;
	mov	result1, _var01
	jmp	#_fatfs_cc_get_ldnumber_ret
LR__3703
' 	}
' #line 3170 "ff.c"
' 	vol = 0;
' 
' 	return vol;
	mov	result1, #0
_fatfs_cc_get_ldnumber_ret
	ret

_fatfs_cc_check_fs
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #45
	wrlong	##-1, local01
	sub	local01, #48
	mov	arg01, local01
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #4
 if_ne	jmp	#LR__3714
	add	local01, #52
	mov	arg01, local01
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	local02, arg01
	rdbyte	local03, local01
	sub	local01, #52
	getbyte	local04, local03, #0
	cmp	local04, #235 wz
 if_ne	mov	arg03, local03
 if_ne	getbyte	arg03, arg03, #0
 if_ne	cmp	arg03, #233 wz
 if_ne	getbyte	local03, local03, #0
 if_ne	cmp	local03, #232 wz
 if_ne	jmp	#LR__3713
	getword	local04, local02, #0
	cmp	local04, ##43605 wz
 if_ne	jmp	#LR__3710
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #82
	mov	arg02, ##@LR__4304
	mov	arg03, #8
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
' 			return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__3714
LR__3710
	add	local01, #52
	mov	arg01, local01
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	local01, #13
	rdbyte	local03, local01
	sub	local01, #65
	getword	local04, result1, #0
	getword	arg02, result1, #0
	sub	arg02, #1
	test	local04, arg02 wz
 if_ne	jmp	#LR__3712
	getword	arg02, result1, #0
	cmp	arg02, ##512 wc
 if_b	jmp	#LR__3712
	getword	arg02, result1, #0
	cmp	arg02, ##513 wc
 if_ae	jmp	#LR__3712
	mov	arg01, local03
	zerox	arg01, #7 wz
 if_e	jmp	#LR__3712
	getbyte	arg01, local03, #0
	getbyte	local03, local03, #0
	sub	local03, #1
	test	arg01, local03 wz
 if_ne	jmp	#LR__3712
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #14
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__3712
	add	local01, #68
	rdbyte	arg01, local01
	sub	local01, #68
	sub	arg01, #1
	cmp	arg01, #2 wc
 if_ae	jmp	#LR__3712
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #17
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__3712
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #19
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local03, result1, #0
	cmp	local03, #128 wc
 if_ae	jmp	#LR__3711
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #32
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	cmp	result1, ##65536 wc
 if_b	jmp	#LR__3712
LR__3711
	add	local01, #74
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, local01 wz
' 			&& b != 0 && (b & (b - 1)) == 0
' 			&& ld_word(fs->win +  14 ) != 0
' 			&& (UINT)fs->win[ 16 ] - 1 <= 1
' 			&& ld_word(fs->win +  17 ) != 0
' 			&& (ld_word(fs->win +  19 ) >= 128 || ld_dword(fs->win +  32 ) >= 0x10000)
' 			&& ld_word(fs->win +  22 ) != 0) {
' 				return 0;
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__3714
LR__3712
LR__3713
' 		}
' 	}
' 	return sign == 0xAA55 ? 2 : 3;
	getword	local03, local02, #0
	cmp	local03, ##43605 wz
 if_e	mov	local04, #2
 if_ne	mov	local04, #3
	mov	result1, local04
LR__3714
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_check_fs_ret
	ret

_fatfs_cc_find_volume
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #36
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_check_fs
	cmp	result1, #2 wz
 if_e	jmp	#LR__3720
	cmp	result1, #3 wc
 if_b	cmp	local02, #0 wz
 if_nc_or_z	jmp	#LR__3728
LR__3720
' 	for (i = 0; i < 4; i++) {
	mov	local03, #0
	callpa	#(@LR__3722-@LR__3721)>>2,fcache_load_ptr_
LR__3721
	cmp	local03, #4 wc
 if_ae	jmp	#LR__3723
	mov	local04, local03
	shl	local04, #2
	add	fp, #20
	add	local04, fp
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #446
	mov	arg02, local03
	shl	arg02, #4
	add	arg01, arg02
	add	arg01, #8
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	fp, #20
	wrlong	result1, local04
	add	local03, #1
	jmp	#LR__3721
LR__3722
LR__3723
	cmp	local02, #0 wz
 if_ne	mov	local04, local02
 if_ne	sub	local04, #1
 if_e	mov	local04, #0
	mov	local03, local04
' 		mbr_pt[i] = ld_dword(fs->win +  446  + i *  16  +  8 );
' 	}
' 	i = part ? part - 1 : 0;
' 	do {
LR__3724
	mov	local04, local03
	shl	local04, #2
	add	fp, #20
	add	local04, fp
	rdlong	local04, local04 wz
	sub	fp, #20
 if_e	jmp	#LR__3725
	mov	local04, local03
	shl	local04, #2
	add	fp, #20
	add	local04, fp
	rdlong	arg02, local04
	mov	arg01, local01
	sub	fp, #20
	call	#_fatfs_cc_check_fs
	mov	local04, result1
	jmp	#LR__3726
LR__3725
	mov	local04, #3
LR__3726
	mov	local05, local04
	cmp	local02, #0 wz
 if_e	cmp	local05, #2 wc
 if_c_and_z	jmp	#LR__3727
 if_e	add	local03, #1
 if_e	cmp	local03, #4 wc
 if_c_and_z	jmp	#LR__3724
LR__3727
' 	return fmt;
	mov	result1, local05
LR__3728
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_find_volume_ret
	ret

_fatfs_cc_mount_volume
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	wrlong	#0, local01
	call	#_fatfs_cc_get_ldnumber
	mov	local03, result1
	cmps	local03, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__3740
	mov	arg03, local03
	shl	arg03, #2
	add	arg03, objptr
	rdlong	local04, arg03 wz
 if_e	mov	result1, #12
 if_e	jmp	#LR__3740
	wrlong	local04, local01
	getbyte	local02, local02, #0
	and	local02, #254
	rdbyte	arg03, local04 wz
 if_e	jmp	#LR__3731
	add	local04, #1
	rdbyte	arg01, local04 wz
	sub	local04, #1
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	arg03, result1, #0
	test	arg03, #1 wz
 if_ne	jmp	#LR__3730
	cmp	local02, #0 wz
 if_ne	getbyte	result1, result1, #0
 if_ne	test	result1, #4 wz
' 				return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__3740
' 			}
' 			return FR_OK;
	mov	result1, #0
	jmp	#LR__3740
LR__3730
LR__3731
	wrbyte	#0, local04
	add	local04, #1
	wrbyte	local03, local04
	rdbyte	arg01, local04
	sub	local04, #1
	call	#_fatfs_cc_disk_initialize
	mov	arg03, result1
	getbyte	local05, arg03, #0
	test	local05, #1 wz
' 		return FR_NOT_READY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__3740
	cmp	local02, #0 wz
 if_ne	mov	local05, arg03
 if_ne	getbyte	local05, local05, #0
 if_ne	test	local05, #4 wz
' 		return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__3740
	mov	arg01, local04
	mov	arg02, #0
	call	#_fatfs_cc_find_volume
	mov	arg01, result1
	cmp	arg01, #4 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__3740
	cmp	arg01, #2 wc
 if_ae	mov	result1, #13
 if_ae	jmp	#LR__3740
	add	local04, #48
	rdlong	local06, local04
	add	local04, #4
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	cmp	result1, ##512 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__3740
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #22
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local07, result1 wz
 if_ne	jmp	#LR__3732
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #36
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	mov	local07, result1
LR__3732
	add	local04, #28
	wrlong	local07, local04
	add	local04, #40
	rdbyte	local05, local04
	sub	local04, #66
	wrbyte	local05, local04
	rdbyte	local05, local04
	sub	local04, #2
	cmp	local05, #1 wz
 if_ne	add	local04, #2
 if_ne	rdbyte	local05, local04
 if_ne	sub	local04, #2
 if_ne	cmp	local05, #2 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__3740
	add	local04, #2
	rdbyte	local05, local04
	qmul	local07, local05
	add	local04, #63
	rdbyte	local05, local04
	sub	local04, #55
	wrword	local05, local04
	rdword	local05, local04 wz
	sub	local04, #10
	getqx	local07
 if_e	jmp	#LR__3733
	add	local04, #10
	rdword	local05, local04
	getword	local03, local05, #0
	sub	local04, #10
	getword	local05, local05, #0
	sub	local05, #1
	test	local03, local05 wz
 if_e	jmp	#LR__3734
LR__3733
	mov	result1, #13
	jmp	#LR__3740
LR__3734
	add	local04, #52
	mov	arg01, local04
	add	arg01, #17
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	local04, #44
	wrword	result1, local04
	rdword	local05, local04
	sub	local04, #8
	abs	arg01, local05 wc
	getnib	arg01, arg01, #0
	negc	arg01, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__3740
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #19
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local08, result1 wz
 if_e	add	local04, #52
 if_e	mov	arg01, local04
 if_e	sub	local04, #52
 if_e	add	arg01, #32
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	local08, arg01
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #14
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	arg01, result1
	mov	local05, arg01
	zerox	local05, #15 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__3740
	getword	local09, arg01, #0
	add	local09, local07
	add	local04, #8
	rdword	local05, local04
	sub	local04, #8
	abs	local05, local05 wc
	shr	local05, #4
	sumc	local09, local05
	cmp	local08, local09 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__3740
	sub	local08, local09
	add	local04, #10
	rdword	local05, local04
	qdiv	local08, local05
	sub	local04, #10
	getqx	local05
	cmp	local05, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__3740
	mov	local10, #0
	cmp	local05, ##268435446 wc
 if_b	mov	local10, #3
	cmp	local05, ##65526 wc
 if_b	mov	local10, #2
	cmp	local05, ##4086 wc
 if_b	mov	local10, #1
	cmp	local10, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__3740
	add	local05, #2
	add	local04, #24
	wrlong	local05, local04
	add	local04, #8
	wrlong	local06, local04
	mov	local05, local06
	getword	arg01, arg01, #0
	add	local05, arg01
	add	local04, #4
	wrlong	local05, local04
	mov	local05, local06
	add	local05, local09
	add	local04, #8
	wrlong	local05, local04
	sub	local04, #44
	cmp	local10, #3 wz
 if_ne	jmp	#LR__3735
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #42
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__3740
	add	local04, #8
	rdword	local05, local04 wz
	sub	local04, #8
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__3740
	add	local04, #52
	mov	arg01, local04
	add	arg01, #44
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local04, #12
	wrlong	result1, local04
	sub	local04, #16
	rdlong	local11, local04
	sub	local04, #24
	shl	local11, #2
	jmp	#LR__3737
LR__3735
	add	local04, #8
	rdword	local05, local04 wz
	sub	local04, #8
 if_e	mov	result1, #13
 if_e	jmp	#LR__3740
	add	local04, #36
	rdlong	local05, local04
	add	local05, local07
	add	local04, #4
	wrlong	local05, local04
	sub	local04, #40
	cmp	local10, #2 wz
 if_e	add	local04, #24
 if_e	rdlong	local05, local04
 if_e	sub	local04, #24
 if_e	shl	local05, #1
 if_e	jmp	#LR__3736
	add	local04, #24
	rdlong	local11, local04
	mov	local05, local11
	shl	local05, #1
	add	local05, local11
	shr	local05, #1
	sub	local04, #24
	and	local11, #1
	add	local05, local11
LR__3736
	mov	local11, local05
LR__3737
	add	local11, #511
	shr	local11, #9
	add	local04, #28
	rdlong	arg03, local04
	sub	local04, #28
	cmp	arg03, local11 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__3740
	add	local04, #20
	wrlong	##-1, local04
	sub	local04, #4
	wrlong	##-1, local04
	sub	local04, #12
	wrbyte	#128, local04
	sub	local04, #4
	cmp	local10, #3 wz
 if_ne	jmp	#LR__3739
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #48
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local05, result1, #0
	cmp	local05, #1 wz
 if_ne	jmp	#LR__3739
	add	local06, #1
	mov	arg01, local04
	mov	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3739
	add	local04, #4
	wrbyte	#0, local04
	add	local04, #48
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local05, result1, #0
	cmp	local05, ##43605 wz
 if_e	add	local04, #52
 if_e	mov	arg01, local04
 if_e	sub	local04, #52
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	cmp	result1, ##1096897106 wz
 if_ne	jmp	#LR__3738
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #484
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	cmp	result1, ##1631679090 wz
 if_ne	jmp	#LR__3738
	add	local04, #52
	mov	arg01, local04
	add	arg01, #488
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local04, #32
	wrlong	result1, local04
	add	local04, #32
	mov	arg01, local04
	add	arg01, #492
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local04, #36
	wrlong	result1, local04
	sub	local04, #16
LR__3738
LR__3739
	wrbyte	local10, local04
	add	objptr, #4
	rdword	local05, objptr
	add	local05, #1
	wrword	local05, objptr
	rdword	local11, objptr
	add	local04, #6
	wrword	local11, local04
	add	objptr, #4
	add	local04, #6
	wrlong	objptr, local04
' 				&& ld_dword(fs->win +  0 ) == 0x41615252
' 				&& ld_dword(fs->win +  484 ) == 0x61417272)
' 			{
' 
' 				fs->free_clst = ld_dword(fs->win +  488 );
' 
' 
' 				fs->last_clst = ld_dword(fs->win +  492 );
' 
' 			}
' 		}
' 
' 
' 	}
' 
' 	fs->fs_type = (BYTE)fmt;
' 	fs->id = ++Fsid;
' 
' 	fs->lfnbuf = LfnBuf;
' #line 3567 "ff.c"
' 	return FR_OK;
	mov	result1, #0
	sub	objptr, #8
LR__3740
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mount_volume_ret
	ret

_fatfs_cc_validate
	mov	_var01, arg01 wz
	mov	_var02, #9
 if_ne	rdlong	_var03, _var01 wz
 if_ne	rdbyte	_var04, _var03 wz
 if_e	jmp	#LR__3750
	add	_var01, #4
	rdword	_var04, _var01
	sub	_var01, #4
	rdlong	arg01, _var01
	add	arg01, #6
	rdword	result1, arg01
	cmp	_var04, result1 wz
 if_ne	jmp	#LR__3750
	rdlong	_var04, _var01
	add	_var04, #1
	rdbyte	arg01, _var04 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	_var03, result1, #0
	test	_var03, #1 wz
 if_e	mov	_var02, #0
LR__3750
	cmp	_var02, #0 wz
 if_e	rdlong	_var03, _var01
 if_ne	mov	_var03, #0
	wrlong	_var03, arg02
' 			res = FR_OK;
' 		}
' 
' 	}
' 	*rfs = (res == FR_OK) ? obj->fs : 0;
' 	return res;
	mov	result1, _var02
_fatfs_cc_validate_ret
	ret

_fatfs_cc_f_mount
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #32
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrbyte	arg03, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	fp, #20
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #28
	call	#_fatfs_cc_get_ldnumber
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmps	result1, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__3761
	add	fp, #20
	rdlong	arg03, fp
	shl	arg03, #2
	add	arg03, objptr
	rdlong	arg03, arg03 wz
	sub	fp, #4
	wrlong	arg03, fp
	sub	fp, #16
 if_e	jmp	#LR__3760
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #16
	add	arg03, #1
	rdbyte	arg01, arg03
	call	#_fatfs_cc_disk_deinitialize
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #16
	wrbyte	#0, arg03
LR__3760
	add	fp, #4
	rdlong	local01, fp wz
	sub	fp, #4
 if_ne	add	fp, #4
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #4
 if_ne	wrbyte	#0, local01
	add	fp, #20
	rdlong	local01, fp
	shl	local01, #2
	add	local01, objptr
	sub	fp, #16
	rdlong	arg03, fp
	wrlong	arg03, local01
	add	fp, #8
	rdbyte	local01, fp wz
	sub	fp, #12
 if_e	mov	result1, #0
 if_e	jmp	#LR__3761
	add	fp, #8
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, fp
	sub	fp, #4
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	add	fp, #24
	wrlong	result1, fp
' 
' 	res = mount_volume(&path, &fs, 0);
' 	return res ;
	sub	fp, #24
LR__3761
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mount_ret
	ret

_fatfs_cc_f_open
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #96
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrbyte	arg03, fp
	sub	fp, #8
	rdlong	arg04, fp wz
	sub	fp, #4
 if_e	mov	result1, #9
 if_e	jmp	#LR__3787
	add	fp, #12
	rdbyte	arg04, fp
	and	arg04, #63
	wrbyte	arg04, fp
	sub	fp, #4
	mov	arg01, fp
	add	fp, #60
	mov	arg02, fp
	sub	fp, #56
	rdbyte	arg03, fp
	sub	fp, #12
	call	#_fatfs_cc_mount_volume
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3786
	add	fp, #68
	rdlong	arg04, fp
	sub	fp, #48
	wrlong	arg04, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #8
	mov	arg02, local01
	call	#_fatfs_cc_follow_path
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3770
	add	fp, #63
	rdbyte	arg04, fp
	sub	fp, #63
	test	arg04, #128 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #16
LR__3770
	add	fp, #12
	rdbyte	arg04, fp
	sub	fp, #12
	test	arg04, #28 wz
 if_e	jmp	#LR__3775
	add	fp, #16
	rdlong	local01, fp wz
	sub	fp, #16
 if_e	jmp	#LR__3772
	add	fp, #16
	rdlong	arg04, fp
	sub	fp, #16
	cmp	arg04, #4 wz
 if_ne	jmp	#LR__3771
	add	fp, #20
	mov	arg01, fp
	sub	fp, #20
	call	#_fatfs_cc_dir_register
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
LR__3771
	add	fp, #12
	rdbyte	local01, fp
	or	local01, #8
	wrbyte	local01, fp
	sub	fp, #12
	jmp	#LR__3774
LR__3772
	add	fp, #26
	rdbyte	local01, fp
	sub	fp, #26
	test	local01, #17 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#7, fp
 if_ne	sub	fp, #16
 if_ne	jmp	#LR__3773
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	test	local01, #4 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#8, fp
 if_ne	sub	fp, #16
LR__3773
LR__3774
	add	fp, #16
	rdlong	local01, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__3778
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	test	local01, #8 wz
 if_e	jmp	#LR__3778
	call	#_fatfs_cc__get_fattime
	add	fp, #84
	wrlong	result1, fp
	sub	fp, #36
	rdlong	arg01, fp
	add	arg01, #14
	wrlong	result1, arg01
	rdlong	arg01, fp
	add	arg01, #22
	add	fp, #36
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	add	fp, #72
	wrlong	result1, fp
	sub	fp, #24
	rdlong	local01, fp
	add	local01, #11
	wrbyte	#32, local01
	add	fp, #20
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	mov	arg03, #0
	call	#_fatfs_cc_st_clust
	add	fp, #48
	rdlong	arg01, fp
	add	arg01, #28
	wrlong	#0, arg01
	add	fp, #20
	rdlong	local01, fp
	add	local01, #3
	wrbyte	#1, local01
	add	fp, #4
	rdlong	local01, fp wz
	sub	fp, #72
 if_e	jmp	#LR__3778
	add	fp, #68
	rdlong	local01, fp
	add	local01, #48
	rdlong	local01, local01
	add	fp, #20
	wrlong	local01, fp
	sub	fp, #68
	mov	arg01, fp
	add	fp, #52
	rdlong	arg02, fp
	sub	fp, #72
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3778
	add	fp, #68
	rdlong	arg01, fp
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #88
	call	#_fatfs_cc_move_window
	add	fp, #16
	wrlong	result1, fp
	add	fp, #52
	rdlong	arg04, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #72
	sub	local01, #1
	add	arg04, #16
	wrlong	local01, arg04
	jmp	#LR__3778
LR__3775
	add	fp, #16
	rdlong	arg04, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__3777
	add	fp, #26
	rdbyte	arg04, fp
	sub	fp, #26
	test	arg04, #16 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#4, fp
 if_ne	sub	fp, #16
 if_ne	jmp	#LR__3776
	add	fp, #12
	rdbyte	arg04, fp
	sub	fp, #12
	test	arg04, #2 wz
 if_ne	add	fp, #26
 if_ne	rdbyte	local01, fp
 if_ne	sub	fp, #26
 if_ne	test	local01, #1 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#7, fp
 if_ne	sub	fp, #16
LR__3776
LR__3777
LR__3778
	add	fp, #16
	rdlong	local01, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__3779
	add	fp, #12
	rdbyte	local02, fp
	sub	fp, #12
	test	local02, #8 wz
 if_ne	add	fp, #12
 if_ne	rdbyte	local02, fp
 if_ne	or	local02, #64
 if_ne	wrbyte	local02, fp
 if_ne	sub	fp, #12
	add	fp, #4
	rdlong	local02, fp
	add	fp, #64
	rdlong	local01, fp
	add	local01, #48
	rdlong	local01, local01
	add	local02, #32
	wrlong	local01, local02
	sub	fp, #64
	rdlong	local02, fp
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #48
	add	local02, #36
	wrlong	local01, local02
LR__3779
	add	fp, #16
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__3785
	add	fp, #4
	rdlong	local02, fp
	add	fp, #64
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	add	local02, #8
	wrlong	result1, local02
	add	fp, #4
	rdlong	local02, fp
	add	fp, #44
	rdlong	arg01, fp
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	add	local02, #12
	wrlong	result1, local02
	sub	fp, #44
	rdlong	local02, fp
	add	fp, #64
	rdlong	local01, fp
	wrlong	local01, local02
	sub	fp, #64
	rdlong	local02, fp
	add	fp, #64
	rdlong	local01, fp
	add	local01, #6
	rdword	local01, local01
	add	local02, #4
	wrword	local01, local02
	sub	fp, #64
	rdlong	local02, fp
	add	fp, #8
	rdbyte	local01, fp
	add	local02, #16
	wrbyte	local01, local02
	sub	fp, #8
	rdlong	local02, fp
	add	local02, #17
	wrbyte	#0, local02
	rdlong	local02, fp
	add	local02, #28
	wrlong	#0, local02
	rdlong	local02, fp
	add	local02, #20
	wrlong	#0, local02
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #40
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	add	fp, #12
	rdbyte	local02, fp
	sub	fp, #12
	test	local02, #32 wz
 if_e	jmp	#LR__3784
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #12
	rdlong	local02, local01
	cmp	local02, #1 wc
 if_b	jmp	#LR__3784
	add	fp, #4
	rdlong	local01, fp
	mov	local02, local01
	add	local01, #12
	rdlong	local01, local01
	add	local02, #20
	wrlong	local01, local02
	add	fp, #64
	rdlong	local02, fp
	add	local02, #10
	rdword	local02, local02
	shl	local02, #9
	add	fp, #8
	wrlong	local02, fp
	sub	fp, #72
	rdlong	local02, fp
	add	local02, #8
	rdlong	local01, local02
	add	fp, #76
	wrlong	local01, fp
' 				fp->fptr = fp->obj.objsize;
' 				bcs = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 				clst = fp->obj.sclust;
' 				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
	sub	fp, #76
	rdlong	local02, fp
	add	local02, #12
	rdlong	local01, local02
	add	fp, #88
	wrlong	local01, fp
	sub	fp, #92
LR__3780
	add	fp, #16
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__3781
	add	fp, #92
	rdlong	local02, fp
	sub	fp, #16
	rdlong	local01, fp
	sub	fp, #76
	cmp	local02, local01 wcz
 if_be	jmp	#LR__3781
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #76
	rdlong	arg02, fp
	sub	fp, #80
	call	#_fatfs_cc_get_fat
	add	fp, #80
	wrlong	result1, fp
	sub	fp, #80
	cmp	result1, #2 wc
 if_b	add	fp, #16
 if_b	wrlong	#2, fp
 if_b	sub	fp, #16
	add	fp, #80
	rdlong	local02, fp
	sub	fp, #80
	cmp	local02, ##-1 wz
 if_e	add	fp, #16
 if_e	wrlong	#1, fp
 if_e	sub	fp, #16
	add	fp, #92
	rdlong	local02, fp
	sub	fp, #16
	rdlong	local01, fp
	sub	local02, local01
	add	fp, #16
	wrlong	local02, fp
	sub	fp, #92
	jmp	#LR__3780
LR__3781
	add	fp, #4
	rdlong	local02, fp
	add	fp, #76
	rdlong	local01, fp
	add	local02, #24
	wrlong	local01, local02
	sub	fp, #64
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__3783
	add	fp, #92
	rdlong	local01, fp
	sub	fp, #92
	test	local01, #511 wz
 if_e	jmp	#LR__3783
	add	fp, #68
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #80
	call	#_fatfs_cc_clst2sect
	add	fp, #88
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #88
 if_e	add	fp, #16
 if_e	wrlong	#2, fp
 if_e	sub	fp, #16
 if_e	jmp	#LR__3782
	add	fp, #4
	rdlong	local02, fp
	add	fp, #84
	rdlong	local01, fp
	add	fp, #4
	rdlong	arg04, fp
	shr	arg04, #9
	add	local01, arg04
	add	local02, #28
	wrlong	local01, local02
	sub	fp, #24
	rdlong	local02, fp
	add	local02, #1
	rdbyte	arg01, local02
	sub	fp, #64
	rdlong	local02, fp
	mov	arg02, local02
	add	arg02, #40
	sub	fp, #4
	add	local02, #28
	rdlong	arg03, local02
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#1, fp
 if_ne	sub	fp, #16
LR__3782
LR__3783
LR__3784
LR__3785
LR__3786
	add	fp, #16
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	add	fp, #4
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #4
 if_ne	wrlong	#0, local02
' 
' 	return res ;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
LR__3787
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_open_ret
	ret

_fatfs_cc_f_read
	mov	COUNT_, #14
	call	#pushregs_
	add	ptra, #56
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	rdlong	result1, fp
	add	fp, #44
	wrlong	result1, fp
	sub	fp, #36
	rdlong	result1, fp
	wrlong	#0, result1
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #20
	mov	arg02, fp
	sub	fp, #24
	call	#_fatfs_cc_validate
	add	fp, #20
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #20
 if_ne	jmp	#LR__3790
	add	fp, #4
	rdlong	arg02, fp
	add	arg02, #17
	rdbyte	arg02, arg02 wz
	add	fp, #16
	wrlong	arg02, fp
	sub	fp, #20
 if_e	jmp	#LR__3791
LR__3790
	add	fp, #20
	rdlong	result1, fp
	sub	fp, #20
	jmp	#LR__3810
LR__3791
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__3810
	add	fp, #4
	rdlong	local01, fp
	mov	local02, local01
	add	local02, #12
	rdlong	local03, local02
	add	local01, #20
	rdlong	local01, local01
	sub	local03, local01
	add	fp, #32
	wrlong	local03, fp
	sub	fp, #24
	rdlong	local04, fp
	sub	fp, #12
	cmp	local04, local03 wcz
 if_a	add	fp, #36
 if_a	rdlong	local04, fp
 if_a	sub	fp, #24
 if_a	wrlong	local04, fp
 if_a	sub	fp, #12
' 
' 	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
LR__3792
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	mov	local04, local02
	cmp	local04, #1 wc
 if_b	jmp	#LR__3809
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #20
	rdlong	local03, local03
	test	local03, #511 wz
 if_ne	jmp	#LR__3807
	add	fp, #4
	rdlong	local01, fp
	add	local01, #20
	rdlong	local03, local01
	shr	local03, #9
	add	fp, #20
	rdlong	local05, fp
	mov	local06, local05
	add	local06, #10
	rdword	local07, local06
	sub	local06, #10
	getword	local08, local07, #0
	sub	local08, #1
	and	local03, local08 wz
	add	fp, #24
	wrlong	local03, fp
	sub	fp, #48
 if_ne	jmp	#LR__3797
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #20
	rdlong	local03, local03 wz
 if_ne	jmp	#LR__3793
	add	fp, #4
	rdlong	local03, fp
	add	local03, #8
	rdlong	local03, local03
	add	fp, #24
	wrlong	local03, fp
	sub	fp, #28
	jmp	#LR__3794
LR__3793
	add	fp, #4
	rdlong	local08, fp
	mov	arg01, local08
	sub	fp, #4
	add	local08, #24
	rdlong	arg02, local08
	call	#_fatfs_cc_get_fat
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
LR__3794
	add	fp, #28
	rdlong	local03, fp
	sub	fp, #28
	cmp	local03, #2 wc
 if_ae	jmp	#LR__3795
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#2, local03
	mov	result1, #2
	jmp	#LR__3810
LR__3795
	add	fp, #28
	rdlong	local03, fp
	sub	fp, #28
	cmp	local03, ##-1 wz
 if_ne	jmp	#LR__3796
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__3810
LR__3796
	add	fp, #4
	rdlong	local03, fp
	add	fp, #24
	rdlong	local08, fp
	sub	fp, #28
	add	local03, #24
	wrlong	local08, local03
LR__3797
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #24
	rdlong	arg02, local03
	call	#_fatfs_cc_clst2sect
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3798
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#2, local03
	mov	result1, #2
	jmp	#LR__3810
LR__3798
	add	fp, #32
	rdlong	local03, fp
	add	fp, #16
	rdlong	local08, fp
	add	local03, local08
	sub	fp, #16
	wrlong	local03, fp
	sub	fp, #20
	rdlong	local03, fp
	shr	local03, #9
	add	fp, #32
	wrlong	local03, fp
	sub	fp, #44
	cmp	local03, #1 wc
 if_b	jmp	#LR__3802
	add	fp, #48
	rdlong	local03, fp
	sub	fp, #4
	rdlong	local08, fp
	add	local03, local08
	sub	fp, #20
	rdlong	local08, fp
	sub	fp, #24
	add	local08, #10
	rdword	local08, local08
	cmp	local03, local08 wcz
 if_be	jmp	#LR__3799
	add	fp, #24
	rdlong	local01, fp
	add	local01, #10
	rdword	local03, local01
	add	fp, #24
	rdlong	local08, fp
	sub	local03, local08
	sub	fp, #4
	wrlong	local03, fp
	sub	fp, #44
LR__3799
	add	fp, #24
	rdlong	local01, fp
	add	local01, #1
	rdbyte	arg01, local01
	add	fp, #28
	rdlong	arg02, fp
	sub	fp, #20
	rdlong	arg03, fp
	add	fp, #12
	rdlong	arg04, fp
	sub	fp, #44
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_e	jmp	#LR__3800
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__3810
LR__3800
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #16
	rdbyte	local03, local01
	test	local03, #128 wz
 if_e	jmp	#LR__3801
	add	fp, #4
	rdlong	local08, fp
	add	local08, #28
	rdlong	local08, local08
	add	fp, #28
	rdlong	local09, fp
	sub	local08, local09
	add	fp, #12
	rdlong	local10, fp
	sub	fp, #44
	mov	local11, local10
	cmp	local08, local11 wc
 if_ae	jmp	#LR__3801
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	local11, arg02
	add	local11, #28
	rdlong	local09, local11
	add	fp, #28
	rdlong	local05, fp
	sub	local09, local05
	shl	local09, #9
	mov	local11, local09
	add	arg01, local09
	sub	fp, #32
	add	arg02, #40
	decod	arg03, #9
	call	#__system____builtin_memmove
LR__3801
	add	fp, #44
	rdlong	local03, fp
	shl	local03, #9
	sub	fp, #4
	wrlong	local03, fp
	sub	fp, #40
' 					__builtin_memcpy(rbuff + ((fp->sect - sect) * ((UINT) 512 ) ), fp->buf, ((UINT) 512 ) ) ;
' 				}
' 
' 
' 				rcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__3808
LR__3802
	add	fp, #4
	rdlong	local03, fp
	add	local03, #28
	rdlong	local03, local03
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #32
	cmp	local03, local01 wz
 if_e	jmp	#LR__3806
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #16
	rdbyte	local03, local01
	test	local03, #128 wz
 if_e	jmp	#LR__3804
	add	fp, #24
	rdlong	local01, fp
	add	local01, #1
	rdbyte	arg01, local01
	sub	fp, #20
	rdlong	local03, fp
	mov	arg02, local03
	add	arg02, #40
	sub	fp, #4
	add	local03, #28
	rdlong	arg03, local03
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__3803
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__3810
LR__3803
	add	fp, #4
	rdlong	local11, fp
	mov	local03, local11
	sub	fp, #4
	add	local11, #16
	rdbyte	local11, local11
	and	local11, #127
	add	local03, #16
	wrbyte	local11, local03
LR__3804
	add	fp, #24
	rdlong	local01, fp
	add	local01, #1
	rdbyte	arg01, local01
	sub	fp, #20
	rdlong	arg02, fp
	add	arg02, #40
	add	fp, #28
	rdlong	arg03, fp
	sub	fp, #32
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_e	jmp	#LR__3805
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__3810
LR__3805
LR__3806
	add	fp, #4
	rdlong	local03, fp
	add	fp, #28
	rdlong	local11, fp
	sub	fp, #32
	add	local03, #28
	wrlong	local11, local03
LR__3807
	add	fp, #4
	rdlong	local01, fp
	add	local01, #20
	rdlong	local11, local01
	and	local11, #511
	decod	local03, #9
	sub	local03, local11
	add	fp, #36
	wrlong	local03, fp
	sub	fp, #28
	rdlong	local11, fp
	sub	fp, #12
	cmp	local03, local11 wcz
 if_a	add	fp, #12
 if_a	rdlong	local03, fp
 if_a	add	fp, #28
 if_a	wrlong	local03, fp
 if_a	sub	fp, #40
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	local06, fp
	mov	arg02, local06
	add	arg02, #40
	add	local06, #20
	rdlong	local11, local06
	mov	local09, local11
	mov	local10, local09
	and	local10, #511
	add	arg02, local10
	add	fp, #36
	rdlong	arg03, fp
	sub	fp, #40
	call	#__system____builtin_memmove
LR__3808
	add	fp, #12
	rdlong	local03, fp
	add	fp, #28
	rdlong	local08, fp
	sub	local03, local08
	sub	fp, #28
	wrlong	local03, fp
	add	fp, #4
	rdlong	local01, fp
	rdlong	local07, local01
	add	fp, #24
	rdlong	local08, fp
	add	local07, local08
	wrlong	local07, local01
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local12, fp
	add	local03, local12
	add	fp, #12
	wrlong	local03, fp
	sub	fp, #48
	rdlong	local13, fp
	mov	local03, local13
	add	local13, #20
	rdlong	local14, local13
	add	fp, #36
	rdlong	local06, fp
	sub	fp, #40
	add	local14, local06
	add	local03, #20
	wrlong	local14, local03
	jmp	#LR__3792
LR__3809
' 
' 
' 
' 
' 		__builtin_memcpy(rbuff, fp->buf + fp->fptr % ((UINT) 512 ) , rcnt) ;
' 
' 	}
' 
' 	return FR_OK ;
	mov	result1, #0
LR__3810
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_read_ret
	ret

_fatfs_cc_f_write
	mov	COUNT_, #21
	call	#pushregs_
	add	ptra, #52
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	rdlong	result1, fp
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #32
	rdlong	result1, fp
	wrlong	#0, result1
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #20
	mov	arg02, fp
	sub	fp, #24
	call	#_fatfs_cc_validate
	add	fp, #20
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #20
 if_ne	jmp	#LR__3820
	add	fp, #4
	rdlong	arg02, fp
	add	arg02, #17
	rdbyte	arg02, arg02 wz
	add	fp, #16
	wrlong	arg02, fp
	sub	fp, #20
 if_e	jmp	#LR__3821
LR__3820
	add	fp, #20
	rdlong	result1, fp
	sub	fp, #20
	jmp	#LR__3843
LR__3821
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	add	arg02, #16
	rdbyte	arg02, arg02
	test	arg02, #2 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__3843
	add	fp, #4
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg01, #20
	rdlong	arg01, arg01
	add	fp, #8
	rdlong	result1, fp
	add	arg01, result1
	sub	fp, #12
	add	arg02, #20
	rdlong	result1, arg02
	cmp	arg01, result1 wc
 if_ae	jmp	#LR__3822
	add	fp, #4
	rdlong	arg02, fp
	neg	result1, #1
	add	arg02, #20
	rdlong	arg02, arg02
	sub	result1, arg02
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #12
LR__3822
' 		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
' 	}
' 
' 	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
LR__3823
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	cmp	result1, #1 wc
 if_b	jmp	#LR__3842
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #20
	rdlong	result1, result1
	test	result1, #511 wz
 if_ne	jmp	#LR__3838
	add	fp, #4
	rdlong	result1, fp
	add	result1, #20
	rdlong	result1, result1
	shr	result1, #9
	add	fp, #20
	rdlong	arg02, fp
	add	arg02, #10
	rdword	arg04, arg02
	getword	arg02, arg04, #0
	sub	arg02, #1
	and	result1, arg02 wz
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #44
 if_ne	jmp	#LR__3829
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #20
	rdlong	arg02, result1 wz
 if_ne	jmp	#LR__3824
	add	fp, #4
	rdlong	arg02, fp
	add	arg02, #8
	rdlong	arg02, arg02 wz
	add	fp, #24
	wrlong	arg02, fp
	sub	fp, #28
 if_ne	jmp	#LR__3825
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	jmp	#LR__3825
LR__3824
	add	fp, #4
	rdlong	arg04, fp
	mov	arg01, arg04
	sub	fp, #4
	add	arg04, #24
	rdlong	arg02, arg04
	call	#_fatfs_cc_create_chain
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
LR__3825
	add	fp, #28
	rdlong	result1, fp wz
	sub	fp, #28
 if_e	jmp	#LR__3842
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #28
	cmp	result1, #1 wz
 if_ne	jmp	#LR__3826
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#2, result1
	mov	result1, #2
	jmp	#LR__3843
LR__3826
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #28
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__3827
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#1, result1
	mov	result1, #1
	jmp	#LR__3843
LR__3827
	add	fp, #4
	rdlong	result1, fp
	add	fp, #24
	rdlong	arg04, fp
	add	result1, #24
	wrlong	arg04, result1
	sub	fp, #24
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #8
	rdlong	result1, result1 wz
 if_ne	jmp	#LR__3828
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #28
	add	arg04, #8
	wrlong	result1, arg04
LR__3828
LR__3829
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #128 wz
 if_e	jmp	#LR__3831
	add	fp, #24
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	sub	fp, #20
	rdlong	arg04, fp
	mov	arg02, arg04
	add	arg02, #40
	sub	fp, #4
	add	arg04, #28
	rdlong	arg03, arg04
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__3830
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#1, result1
	mov	result1, #1
	jmp	#LR__3843
LR__3830
	add	fp, #4
	rdlong	arg04, fp
	mov	result1, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	result1, #16
	wrbyte	arg04, result1
LR__3831
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #4
	add	arg02, #24
	rdlong	arg02, arg02
	call	#_fatfs_cc_clst2sect
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3832
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#2, result1
	mov	result1, #2
	jmp	#LR__3843
LR__3832
	add	fp, #32
	rdlong	result1, fp
	add	fp, #12
	rdlong	local01, fp
	add	result1, local01
	sub	fp, #12
	wrlong	result1, fp
	sub	fp, #20
	rdlong	result1, fp
	shr	result1, #9
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #40
	cmp	result1, #1 wc
 if_b	jmp	#LR__3836
	add	fp, #44
	rdlong	result1, fp
	sub	fp, #4
	rdlong	arg04, fp
	add	result1, arg04
	sub	fp, #16
	rdlong	arg04, fp
	sub	fp, #24
	add	arg04, #10
	rdword	arg04, arg04
	cmp	result1, arg04 wcz
 if_be	jmp	#LR__3833
	add	fp, #24
	rdlong	result1, fp
	add	result1, #10
	rdword	result1, result1
	add	fp, #20
	rdlong	arg04, fp
	sub	result1, arg04
	sub	fp, #4
	wrlong	result1, fp
	sub	fp, #40
LR__3833
	add	fp, #24
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	add	fp, #24
	rdlong	arg02, fp
	sub	fp, #16
	rdlong	arg03, fp
	add	fp, #8
	rdlong	arg04, fp
	sub	fp, #40
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__3834
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #17
	wrbyte	#1, local01
	mov	result1, #1
	jmp	#LR__3843
LR__3834
	add	fp, #4
	rdlong	result1, fp
	add	result1, #28
	rdlong	result1, result1
	add	fp, #28
	rdlong	local02, fp
	sub	result1, local02
	add	fp, #8
	rdlong	arg04, fp
	sub	fp, #40
	cmp	result1, arg04 wc
 if_ae	jmp	#LR__3835
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #40
	add	fp, #44
	rdlong	arg02, fp
	sub	fp, #44
	rdlong	result1, fp
	add	result1, #28
	rdlong	local03, result1
	add	fp, #28
	rdlong	arg04, fp
	sub	fp, #32
	sub	local03, arg04
	shl	local03, #9
	add	arg02, local03
	decod	arg03, #9
	call	#__system____builtin_memmove
	add	fp, #4
	rdlong	arg04, fp
	mov	result1, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	result1, #16
	wrbyte	arg04, result1
LR__3835
	add	fp, #40
	rdlong	result1, fp
	shl	result1, #9
	sub	fp, #4
	wrlong	result1, fp
	sub	fp, #36
' 					__builtin_memcpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT) 512 ) ), ((UINT) 512 ) ) ;
' 					fp->flag &= (BYTE)~ 0x80 ;
' 				}
' 
' 
' 				wcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__3839
LR__3836
	add	fp, #4
	rdlong	local02, fp
	add	local02, #28
	rdlong	result1, local02
	add	fp, #28
	rdlong	local02, fp
	sub	fp, #32
	cmp	result1, local02 wz
 if_e	jmp	#LR__3837
	add	fp, #4
	rdlong	result1, fp
	mov	local03, result1
	sub	fp, #4
	add	local03, #20
	rdlong	local03, local03
	add	result1, #12
	rdlong	local04, result1
	mov	local05, local04
	cmp	local03, local05 wc
 if_ae	jmp	#LR__3837
	add	fp, #24
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	sub	fp, #20
	rdlong	local06, fp
	add	local06, #40
	mov	local07, local06
	add	fp, #28
	rdlong	local08, fp
	sub	fp, #32
	mov	local09, #1
	mov	arg02, local07
	mov	arg03, local08
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	mov	local10, result1 wz
 if_e	jmp	#LR__3837
	add	fp, #4
	rdlong	local10, fp
	sub	fp, #4
	add	local10, #17
	wrbyte	#1, local10
' 				fp->fptr < fp->obj.objsize &&
' 				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
' 					{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR ; } ;
	mov	result1, #1
	jmp	#LR__3843
LR__3837
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #32
	add	arg04, #28
	wrlong	result1, arg04
LR__3838
	add	fp, #4
	rdlong	result1, fp
	add	result1, #20
	rdlong	result1, result1
	and	result1, #511
	decod	local11, #9
	sub	local11, result1
	add	fp, #32
	wrlong	local11, fp
	sub	fp, #24
	rdlong	result1, fp
	sub	fp, #12
	cmp	local11, result1 wcz
 if_a	add	fp, #12
 if_a	rdlong	local11, fp
 if_a	add	fp, #24
 if_a	wrlong	local11, fp
 if_a	sub	fp, #36
	add	fp, #4
	rdlong	local11, fp
	mov	arg01, local11
	add	arg01, #40
	add	local11, #20
	rdlong	local11, local11
	and	local11, #511
	add	arg01, local11
	add	fp, #44
	rdlong	arg02, fp
	sub	fp, #12
	rdlong	arg03, fp
	sub	fp, #36
	call	#__system____builtin_memmove
	add	fp, #4
	rdlong	result1, fp
	mov	local11, result1
	sub	fp, #4
	add	result1, #16
	rdbyte	result1, result1
	or	result1, #128
	add	local11, #16
	wrbyte	result1, local11
LR__3839
	add	fp, #12
	rdlong	local11, fp
	add	fp, #24
	rdlong	result1, fp
	sub	local11, result1
	sub	fp, #24
	wrlong	local11, fp
	add	fp, #4
	rdlong	local12, fp
	rdlong	local11, local12
	add	fp, #20
	rdlong	local13, fp
	add	local11, local13
	wrlong	local11, local12
	add	fp, #12
	rdlong	local11, fp
	sub	fp, #12
	rdlong	local14, fp
	add	local11, local14
	add	fp, #12
	wrlong	local11, fp
	sub	fp, #44
	rdlong	local15, fp
	mov	local11, local15
	add	local15, #20
	rdlong	local15, local15
	add	fp, #32
	rdlong	local16, fp
	add	local15, local16
	add	local11, #20
	wrlong	local15, local11
	sub	fp, #32
	rdlong	local17, fp
	mov	local11, local17
	mov	local18, local17
	sub	fp, #4
	add	local17, #20
	rdlong	local19, local17
	add	local18, #12
	rdlong	local20, local18
	cmp	local19, local20 wcz
 if_be	jmp	#LR__3840
	add	fp, #4
	rdlong	local05, fp
	sub	fp, #4
	mov	local03, local05
	add	local03, #20
	rdlong	local04, local03
	sub	local03, #20
	mov	local21, local04
	jmp	#LR__3841
LR__3840
	add	fp, #4
	rdlong	local07, fp
	sub	fp, #4
	mov	local10, local07
	add	local10, #12
	rdlong	local08, local10
	sub	local10, #12
	mov	local21, local08
LR__3841
	add	local11, #12
	wrlong	local21, local11
	jmp	#LR__3823
LR__3842
	add	fp, #4
	rdlong	local12, fp
	mov	local01, local12
	sub	fp, #4
	add	local12, #16
	rdbyte	local11, local12
	or	local11, #64
	add	local01, #16
	wrbyte	local11, local01
' 
' 
' 
' 
' 
' 		__builtin_memcpy(fp->buf + fp->fptr % ((UINT) 512 ) , wbuff, wcnt) ;
' 		fp->flag |=  0x80 ;
' 
' 	}
' 
' 	fp->flag |=  0x40 ;
' 
' 	return FR_OK ;
	mov	result1, #0
LR__3843
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_write_ret
	ret

_fatfs_cc_f_sync
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #24
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_validate
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3853
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #64 wz
 if_e	jmp	#LR__3852
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #128 wz
 if_e	jmp	#LR__3850
	add	fp, #12
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	sub	fp, #8
	rdlong	arg04, fp
	mov	arg02, arg04
	add	arg02, #40
	sub	fp, #4
	add	arg04, #28
	rdlong	arg03, arg04
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__3854
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	arg03, #16
	wrbyte	arg04, arg03
LR__3850
	call	#_fatfs_cc__get_fattime
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #4
	rdlong	arg01, fp
	sub	fp, #8
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #32
	rdlong	arg02, arg04
	call	#_fatfs_cc_move_window
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3851
	add	fp, #4
	rdlong	arg04, fp
	add	arg04, #36
	rdlong	arg04, arg04
	add	fp, #16
	wrlong	arg04, fp
	mov	arg03, arg04
	add	arg03, #11
	rdbyte	arg03, arg03
	or	arg03, #32
	add	arg04, #11
	wrbyte	arg03, arg04
	sub	fp, #16
	rdlong	arg04, fp
	rdlong	arg01, arg04
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #20
	add	arg04, #8
	rdlong	arg03, arg04
	call	#_fatfs_cc_st_clust
	add	fp, #20
	rdlong	arg01, fp
	add	arg01, #28
	sub	fp, #16
	rdlong	arg04, fp
	add	arg04, #12
	rdlong	arg02, arg04
	wrlong	arg02, arg01
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, #22
	sub	fp, #4
	rdlong	arg02, fp
	wrlong	arg02, arg01
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #18
	wrword	#0, arg01
	sub	fp, #8
	rdlong	arg04, fp
	add	arg04, #3
	wrbyte	#1, arg04
	rdlong	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc_sync_fs
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #191
	add	arg03, #16
	wrbyte	arg04, arg03
LR__3851
LR__3852
LR__3853
' 					dir = fp->dir_ptr;
' 					dir[ 11 ] |=  0x20 ;
' 					st_clust(fp->obj.fs, dir, fp->obj.sclust);
' 					st_dword(dir +  28 , (DWORD)fp->obj.objsize);
' 					st_dword(dir +  22 , tm);
' 					st_word(dir +  18 , 0);
' 					fs->wflag = 1;
' 					res = sync_fs(fs);
' 					fp->flag &= (BYTE)~ 0x40 ;
' 				}
' 			}
' 		}
' 	}
' 
' 	return res ;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
LR__3854
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_sync_ret
	ret

_fatfs_cc_f_close
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #4
	call	#_fatfs_cc_f_sync
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3860
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_validate
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_e	add	fp, #4
 if_e	rdlong	local01, fp
 if_e	sub	fp, #4
 if_e	wrlong	#0, local01
LR__3860
' 
' 
' 
' 
' 			fp->obj.fs = 0;
' #line 4192 "ff.c"
' 		}
' 	}
' 	return res;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_close_ret
	ret

_fatfs_cc_f_lseek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #36
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc_validate
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3870
	add	fp, #4
	rdlong	arg04, fp
	add	arg04, #17
	rdbyte	arg04, arg04
	add	fp, #8
	wrlong	arg04, fp
	sub	fp, #12
LR__3870
	add	fp, #12
	rdlong	arg04, fp wz
	sub	fp, #12
 if_ne	add	fp, #12
 if_ne	rdlong	result1, fp
 if_ne	sub	fp, #12
 if_ne	jmp	#LR__3893
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #8
	add	arg04, #12
	rdlong	arg04, arg04
	cmp	arg03, arg04 wcz
 if_be	jmp	#LR__3871
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #16
	rdbyte	arg03, arg03
	getbyte	arg03, arg03, #0
	test	arg03, #2 wz
 if_ne	jmp	#LR__3871
	add	fp, #4
	rdlong	arg03, fp
	add	arg03, #12
	rdlong	arg03, arg03
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
LR__3871
	add	fp, #4
	rdlong	arg03, fp
	add	arg03, #20
	rdlong	arg03, arg03
	add	fp, #28
	wrlong	arg03, fp
	sub	fp, #28
	rdlong	arg03, fp
	add	fp, #24
	wrlong	#0, fp
	add	arg03, #20
	wrlong	#0, arg03
	sub	fp, #20
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #1 wc
 if_b	jmp	#LR__3887
	add	fp, #16
	rdlong	arg03, fp
	add	arg03, #10
	rdword	arg04, arg03
	shl	arg04, #9
	add	fp, #8
	wrlong	arg04, fp
	add	fp, #8
	rdlong	arg04, fp
	sub	fp, #32
	cmp	arg04, #1 wc
 if_b	jmp	#LR__3872
	add	fp, #8
	rdlong	arg04, fp
	sub	arg04, #1
	add	fp, #16
	rdlong	arg03, fp
	qdiv	arg04, arg03
	add	fp, #8
	rdlong	result1, fp
	sub	result1, #1
	getqx	arg04
	qdiv	result1, arg03
	sub	fp, #32
	getqx	arg03
	cmp	arg04, arg03 wc
 if_b	jmp	#LR__3872
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #28
	rdlong	result1, fp
	sub	result1, #1
	sub	fp, #8
	rdlong	arg04, fp
	sub	arg04, #1
	andn	result1, arg04
	add	arg03, #20
	wrlong	result1, arg03
	sub	fp, #16
	rdlong	arg03, fp
	sub	fp, #4
	rdlong	arg04, fp
	add	arg04, #20
	rdlong	arg04, arg04
	sub	arg03, arg04
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	arg03, #24
	rdlong	arg03, arg03
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #20
	jmp	#LR__3876
LR__3872
	add	fp, #4
	rdlong	arg03, fp
	add	arg03, #8
	rdlong	arg03, arg03 wz
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #20
 if_ne	jmp	#LR__3875
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmp	result1, #1 wz
 if_ne	jmp	#LR__3873
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#2, arg03
	mov	result1, #2
	jmp	#LR__3893
LR__3873
	add	fp, #20
	rdlong	result1, fp
	sub	fp, #20
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__3874
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__3893
LR__3874
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #16
	rdlong	arg04, fp
	sub	fp, #20
	add	arg03, #8
	wrlong	arg04, arg03
LR__3875
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #16
	rdlong	arg04, fp
	sub	fp, #20
	add	arg03, #24
	wrlong	arg04, arg03
LR__3876
	add	fp, #20
	rdlong	arg03, fp wz
	sub	fp, #20
 if_e	jmp	#LR__3886
' 				while (ofs > bcs) {
LR__3877
	add	fp, #8
	rdlong	arg04, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #24
	cmp	arg04, arg03 wcz
 if_be	jmp	#LR__3883
	add	fp, #8
	rdlong	arg04, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	arg04, arg03
	sub	fp, #16
	wrlong	arg04, fp
	sub	fp, #4
	rdlong	arg04, fp
	mov	result1, arg04
	add	arg04, #20
	rdlong	arg04, arg04
	add	fp, #20
	rdlong	arg03, fp
	add	arg04, arg03
	add	result1, #20
	wrlong	arg04, result1
	sub	fp, #20
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #16
	rdbyte	arg03, arg03
	test	arg03, #2 wz
 if_e	jmp	#LR__3878
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_create_chain
	add	fp, #20
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #20
 if_e	add	fp, #8
 if_e	wrlong	#0, fp
 if_e	sub	fp, #8
' 							ofs = 0; break;
 if_e	jmp	#LR__3883
	jmp	#LR__3879
LR__3878
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_get_fat
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
LR__3879
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, ##-1 wz
 if_ne	jmp	#LR__3880
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__3893
LR__3880
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, #2 wc
 if_b	jmp	#LR__3881
	add	fp, #16
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #20
	add	arg04, #24
	rdlong	arg04, arg04
	cmp	arg03, arg04 wc
 if_b	jmp	#LR__3882
LR__3881
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#2, arg03
	mov	result1, #2
	jmp	#LR__3893
LR__3882
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #20
	add	arg04, #24
	wrlong	arg03, arg04
	jmp	#LR__3877
LR__3883
	add	fp, #4
	rdlong	arg03, fp
	mov	arg01, arg03
	add	arg03, #20
	rdlong	arg02, arg03
	add	fp, #4
	rdlong	arg03, fp
	add	arg02, arg03
	add	arg01, #20
	wrlong	arg02, arg01
	rdlong	arg03, fp
	sub	fp, #8
	test	arg03, #511 wz
 if_e	jmp	#LR__3885
	add	fp, #16
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_clst2sect
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3884
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#2, arg03
	mov	result1, #2
	jmp	#LR__3893
LR__3884
	add	fp, #28
	rdlong	arg04, fp
	sub	fp, #20
	rdlong	arg03, fp
	shr	arg03, #9
	add	arg04, arg03
	add	fp, #20
	wrlong	arg04, fp
	sub	fp, #28
LR__3885
LR__3886
LR__3887
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg03, #20
	rdlong	arg03, arg03
	add	arg04, #12
	rdlong	arg04, arg04
	cmp	arg03, arg04 wcz
 if_be	jmp	#LR__3888
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	add	arg04, #20
	rdlong	arg04, arg04
	add	arg03, #12
	wrlong	arg04, arg03
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	or	arg04, #64
	add	arg03, #16
	wrbyte	arg04, arg03
LR__3888
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #20
	rdlong	arg03, arg03
	test	arg03, #511 wz
 if_e	jmp	#LR__3892
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #24
	rdlong	arg03, fp
	sub	fp, #28
	add	arg04, #28
	rdlong	arg04, arg04
	cmp	arg03, arg04 wz
 if_e	jmp	#LR__3892
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #16
	rdbyte	arg03, arg03
	test	arg03, #128 wz
 if_e	jmp	#LR__3890
	add	fp, #16
	rdlong	arg03, fp
	add	arg03, #1
	rdbyte	arg01, arg03
	sub	fp, #12
	rdlong	arg03, fp
	mov	arg02, arg03
	add	arg02, #40
	sub	fp, #4
	add	arg03, #28
	rdlong	arg03, arg03
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__3889
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__3893
LR__3889
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	arg03, #16
	wrbyte	arg04, arg03
LR__3890
	add	fp, #16
	rdlong	arg03, fp
	add	arg03, #1
	rdbyte	arg01, arg03
	sub	fp, #12
	rdlong	arg02, fp
	add	arg02, #40
	add	fp, #24
	rdlong	arg03, fp
	sub	fp, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_e	jmp	#LR__3891
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__3893
LR__3891
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #24
	rdlong	arg03, fp
	sub	fp, #28
	add	arg04, #28
	wrlong	arg03, arg04
LR__3892
' 
' 			fp->sect = nsect;
' 		}
' 	}
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
LR__3893
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_lseek_ret
	ret

_fatfs_cc_f_opendir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg03, fp wz
	sub	fp, #4
 if_e	mov	result1, #9
 if_e	jmp	#LR__3906
	add	fp, #8
	mov	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3905
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #12
	rdlong	result1, fp
	wrlong	result1, arg03
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3904
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #43
	rdbyte	arg03, arg03
	test	arg03, #128 wz
 if_ne	jmp	#LR__3902
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #6
	rdbyte	arg03, arg03
	test	arg03, #16 wz
 if_e	jmp	#LR__3900
	add	fp, #4
	rdlong	arg03, fp
	mov	local01, arg03
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #16
	add	arg03, #28
	rdlong	arg02, arg03
	call	#_fatfs_cc_ld_clust
	add	local01, #8
	wrlong	result1, local01
	jmp	#LR__3901
LR__3900
	add	fp, #12
	wrlong	#5, fp
	sub	fp, #12
LR__3901
LR__3902
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__3903
	add	fp, #4
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg03, fp
	add	arg03, #6
	rdword	arg03, arg03
	add	local01, #4
	wrword	arg03, local01
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__3903
LR__3904
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#5, fp
 if_e	sub	fp, #12
LR__3905
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	add	fp, #4
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #4
 if_ne	wrlong	#0, local01
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
LR__3906
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_opendir_ret
	ret

_fatfs_cc_f_closedir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_validate
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_e	add	fp, #4
 if_e	rdlong	result1, fp
 if_e	sub	fp, #4
 if_e	wrlong	#0, result1
' 
' 
' 
' 
' 		dp->obj.fs = 0;
' #line 4633 "ff.c"
' 	}
' 	return res;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_closedir_ret
	ret

_fatfs_cc_f_readdir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc_validate
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3913
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__3910
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	jmp	#LR__3912
LR__3910
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#0, fp
 if_e	sub	fp, #12
	add	fp, #12
	rdlong	result1, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__3911
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_get_fileinfo
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#0, fp
 if_e	sub	fp, #12
LR__3911
LR__3912
LR__3913
' 			}
' 			;
' 		}
' 	}
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_readdir_ret
	ret

_fatfs_cc_f_stat
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #64
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3923
	add	fp, #16
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3922
	add	fp, #59
	rdbyte	result1, fp
	sub	fp, #59
	test	result1, #128 wz
 if_ne	add	fp, #12
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #12
 if_ne	jmp	#LR__3921
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_e	jmp	#LR__3920
	add	fp, #16
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_get_fileinfo
LR__3920
LR__3921
LR__3922
LR__3923
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_stat_ret
	ret

_fatfs_cc_f_unlink
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #116
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #104
	wrlong	#0, fp
	sub	fp, #104
	mov	arg01, fp
	add	fp, #108
	mov	arg02, fp
	sub	fp, #112
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3938
	add	fp, #112
	rdlong	arg03, fp
	sub	fp, #100
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__3937
	add	fp, #55
	rdbyte	result1, fp
	sub	fp, #55
	test	result1, #128 wz
 if_ne	add	fp, #8
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__3930
	add	fp, #18
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #1 wz
 if_ne	add	fp, #8
 if_ne	wrlong	#7, fp
 if_ne	sub	fp, #8
LR__3930
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__3933
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #72
	rdlong	arg02, fp
	sub	fp, #40
	call	#_fatfs_cc_ld_clust
	add	fp, #108
	wrlong	result1, fp
	sub	fp, #90
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #16 wz
 if_e	jmp	#LR__3932
	add	fp, #112
	rdlong	result1, fp
	sub	fp, #52
	wrlong	result1, fp
	add	fp, #48
	rdlong	arg03, fp
	sub	fp, #40
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3931
	add	fp, #60
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_e	add	fp, #8
 if_e	wrlong	#7, fp
 if_e	sub	fp, #8
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	cmp	result1, #4 wz
 if_e	add	fp, #8
 if_e	wrlong	#0, fp
 if_e	sub	fp, #8
LR__3931
LR__3932
LR__3933
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__3936
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc_dir_remove
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3934
	add	fp, #108
	rdlong	result1, fp wz
	sub	fp, #108
 if_e	jmp	#LR__3934
	add	fp, #12
	mov	arg01, fp
	add	fp, #96
	rdlong	arg02, fp
	sub	fp, #108
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
LR__3934
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__3935
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	call	#_fatfs_cc_sync_fs
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
LR__3935
LR__3936
LR__3937
LR__3938
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_unlink_ret
	ret

_fatfs_cc_f_mkdir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #92
	add	fp, #4
	wrlong	arg01, fp
	mov	arg01, fp
	add	fp, #72
	mov	arg02, fp
	sub	fp, #76
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3945
	add	fp, #76
	rdlong	arg03, fp
	sub	fp, #64
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_e	add	fp, #8
 if_e	wrlong	#8, fp
 if_e	sub	fp, #8
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	cmp	result1, #4 wz
 if_ne	jmp	#LR__3944
	add	fp, #76
	rdlong	arg03, fp
	sub	fp, #16
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	add	fp, #80
	wrlong	result1, fp
	sub	fp, #72
	wrlong	#0, fp
	add	fp, #72
	rdlong	result1, fp wz
	sub	fp, #80
 if_e	add	fp, #8
 if_e	wrlong	#7, fp
 if_e	sub	fp, #8
	add	fp, #80
	rdlong	result1, fp
	sub	fp, #80
	cmp	result1, #1 wz
 if_e	add	fp, #8
 if_e	wrlong	#2, fp
 if_e	sub	fp, #8
	add	fp, #80
	rdlong	arg03, fp
	sub	fp, #80
	cmp	arg03, ##-1 wz
 if_e	add	fp, #8
 if_e	wrlong	#1, fp
 if_e	sub	fp, #8
	call	#_fatfs_cc__get_fattime
	add	fp, #88
	wrlong	result1, fp
	sub	fp, #80
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__3941
	add	fp, #76
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #80
	call	#_fatfs_cc_dir_clear
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__3940
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	add	arg01, #52
	mov	arg02, #32
	mov	arg03, #11
	call	#\builtin_bytefill_
	add	fp, #76
	rdlong	result1, fp
	add	result1, #52
	wrbyte	#46, result1
	rdlong	arg03, fp
	add	arg03, #63
	wrbyte	#16, arg03
	rdlong	arg01, fp
	add	arg01, #74
	add	fp, #12
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #12
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg02, #52
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #80
	call	#_fatfs_cc_st_clust
	add	fp, #76
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg01, #84
	sub	fp, #76
	add	arg02, #52
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #76
	rdlong	arg03, fp
	add	arg03, #85
	wrbyte	#46, arg03
	sub	fp, #56
	rdlong	arg03, fp
	add	fp, #64
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg02, #84
	sub	fp, #76
	call	#_fatfs_cc_st_clust
	add	fp, #76
	rdlong	arg03, fp
	add	arg03, #3
	wrbyte	#1, arg03
	sub	fp, #64
	mov	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc_dir_register
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
LR__3940
LR__3941
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__3942
	add	fp, #40
	rdlong	arg01, fp
	add	arg01, #22
	add	fp, #48
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #36
	rdlong	arg02, fp
	add	fp, #40
	rdlong	arg03, fp
	sub	fp, #80
	call	#_fatfs_cc_st_clust
	add	fp, #40
	rdlong	result1, fp
	add	result1, #11
	wrbyte	#16, result1
	add	fp, #36
	rdlong	result1, fp
	add	result1, #3
	wrbyte	#1, result1
	sub	fp, #68
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__3943
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	call	#_fatfs_cc_sync_fs
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	jmp	#LR__3943
LR__3942
	add	fp, #60
	mov	arg01, fp
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #80
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
LR__3943
LR__3944
LR__3945
' 				remove_chain(&sobj, dcl, 0);
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mkdir_ret
	ret

_fatfs_cc_f_rename
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #156
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #8
	call	#_fatfs_cc_get_ldnumber
	add	fp, #4
	mov	arg01, fp
	add	fp, #108
	mov	arg02, fp
	sub	fp, #112
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3963
	add	fp, #112
	rdlong	arg03, fp
	sub	fp, #96
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #12
 if_ne	jmp	#LR__3950
	add	fp, #59
	rdbyte	result1, fp
	sub	fp, #59
	test	result1, #160 wz
 if_ne	add	fp, #12
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #12
LR__3950
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__3962
	add	fp, #116
	mov	arg01, fp
	sub	fp, #72
	rdlong	arg02, fp
	sub	fp, #44
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #64
	mov	arg01, fp
	sub	fp, #48
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #48
	call	#__system____builtin_memmove
	add	fp, #64
	mov	arg01, fp
	sub	fp, #56
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3953
	add	fp, #72
	rdlong	result1, fp
	sub	fp, #48
	rdlong	arg03, fp
	sub	fp, #24
	cmp	result1, arg03 wz
 if_ne	jmp	#LR__3951
	add	fp, #80
	rdlong	result1, fp
	sub	fp, #48
	rdlong	arg03, fp
	sub	fp, #32
	cmp	result1, arg03 wz
 if_e	mov	local01, #4
 if_e	jmp	#LR__3952
LR__3951
	mov	local01, #8
LR__3952
	add	fp, #12
	wrlong	local01, fp
	sub	fp, #12
LR__3953
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #4 wz
 if_ne	jmp	#LR__3959
	add	fp, #64
	mov	arg01, fp
	sub	fp, #64
	call	#_fatfs_cc_dir_register
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3958
	add	fp, #92
	rdlong	arg01, fp
	add	fp, #56
	wrlong	arg01, fp
	add	arg01, #13
	sub	fp, #32
	mov	arg02, fp
	sub	fp, #116
	add	arg02, #13
	mov	arg03, #19
	call	#__system____builtin_memmove
	add	fp, #148
	rdlong	local01, fp
	sub	fp, #21
	rdbyte	result1, fp
	add	local01, #11
	wrbyte	result1, local01
	add	fp, #21
	rdlong	local01, fp
	sub	fp, #148
	add	local01, #11
	rdbyte	local01, local01
	test	local01, #16 wz
 if_ne	jmp	#LR__3954
	add	fp, #148
	rdlong	result1, fp
	mov	local01, result1
	sub	fp, #148
	add	result1, #11
	rdbyte	result1, result1
	or	result1, #32
	add	local01, #11
	wrbyte	result1, local01
LR__3954
	add	fp, #112
	rdlong	local01, fp
	add	local01, #3
	wrbyte	#1, local01
	add	fp, #36
	rdlong	local01, fp
	sub	fp, #148
	add	local01, #11
	rdbyte	local01, local01
	test	local01, #16 wz
 if_e	jmp	#LR__3957
	add	fp, #24
	rdlong	arg03, fp
	add	fp, #48
	rdlong	local01, fp
	sub	fp, #72
	cmp	arg03, local01 wz
 if_e	jmp	#LR__3957
	add	fp, #112
	rdlong	arg01, fp
	mov	local01, arg01
	add	fp, #36
	rdlong	arg02, fp
	sub	fp, #148
	call	#_fatfs_cc_ld_clust
	mov	arg02, result1
	mov	arg01, local01
	call	#_fatfs_cc_clst2sect
	add	fp, #152
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #152
 if_e	add	fp, #12
 if_e	wrlong	#2, fp
 if_e	sub	fp, #12
 if_e	jmp	#LR__3956
	add	fp, #112
	rdlong	arg01, fp
	add	fp, #40
	rdlong	arg02, fp
	sub	fp, #152
	call	#_fatfs_cc_move_window
	add	fp, #12
	wrlong	result1, fp
	add	fp, #100
	rdlong	local01, fp
	add	local01, #84
	add	fp, #36
	wrlong	local01, fp
	sub	fp, #136
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__3955
	add	fp, #148
	rdlong	local01, fp
	sub	fp, #148
	add	local01, #1
	rdbyte	local01, local01
	cmp	local01, #46 wz
 if_ne	jmp	#LR__3955
	add	fp, #112
	rdlong	arg01, fp
	add	fp, #36
	rdlong	arg02, fp
	sub	fp, #76
	rdlong	arg03, fp
	sub	fp, #72
	call	#_fatfs_cc_st_clust
	add	fp, #112
	rdlong	local01, fp
	sub	fp, #112
	add	local01, #3
	wrbyte	#1, local01
LR__3955
LR__3956
LR__3957
LR__3958
LR__3959
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__3961
	add	fp, #16
	mov	arg01, fp
	sub	fp, #16
	call	#_fatfs_cc_dir_remove
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3960
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	call	#_fatfs_cc_sync_fs
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__3960
LR__3961
LR__3962
LR__3963
' 					res = sync_fs(fs);
' 				}
' 			}
' 
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_rename_ret
	ret

_fatfs_cc_time
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg01, fp
	sub	fp, #8
	mov	arg02, #0
	call	#_fatfs_cc_gettimeofday
	add	fp, #8
	rdlong	result1, fp
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #12
	rdlong	result1, fp wz
	sub	fp, #4
 if_e	jmp	#LR__3970
	add	fp, #4
	rdlong	result1, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #16
	wrlong	arg02, result1
LR__3970
'         *tp = now;
'     return now;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_time_ret
	ret

_fatfs_cc_mktime
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	add	local01, #20
	rdlong	arg01, local01
	sub	local01, #20
	cmps	arg01, #70 wc
'                 return (time_t) -1;
 if_b	neg	result1, #1
 if_b	jmp	#LR__3984
	mov	local02, ##1900
	add	local01, #20
	rdlong	result1, local01
	add	local02, result1
	sub	local01, #8
	rdlong	local03, local01
	sub	local03, #1
	add	local01, #4
	rdlong	arg01, local01
	sub	local01, #16
	shl	arg01, #2
	add	ptr__fatfs_cc_dat__, ##1224
	add	arg01, ptr__fatfs_cc_dat__
	rdlong	result1, arg01
	add	local03, result1
	mov	arg01, local02
	sub	ptr__fatfs_cc_dat__, ##1224
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_e	jmp	#LR__3980
	mov	local04, #0
	add	local01, #16
	rdlong	result1, local01
	sub	local01, #16
	cmps	result1, #2 wc
 if_ae	mov	local04, #1
	jmp	#LR__3981
LR__3980
	mov	local04, #0
LR__3981
	add	local01, #4
	rdlong	result1, local01
	sub	local01, #4
	rdlong	local05, local01
	add	local01, #8
	rdlong	arg01, local01
	qmul	arg01, ##3600
	add	local03, local04
	mov	local04, result1
	shl	local04, #4
	sub	local04, result1
	shl	local04, #2
	add	local05, local04
	sub	local01, #8
	getqx	local04
	qmul	local03, ##86400
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1970
	getqx	local04
	qmul	local03, ##31536000
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1969
	abs	local06, local03 wc
	shr	local06, #2
	negc	local06, local06
	cmps	local02, ##2001 wc
	getqx	local04
	add	local05, local04
 if_b	jmp	#LR__3982
	sub	local02, ##2000
	abs	local04, local02 wc
	qdiv	local04, #100
	getqx	local04
	sumnc	local06, local04
LR__3982
	qmul	local06, ##86400
	getqx	local06
	add	local05, local06
	call	#_fatfs_cc__tzset
	add	ptr__fatfs_cc_dat__, ##1172
	rdlong	local06, ptr__fatfs_cc_dat__
	add	local05, local06
	add	ptr__fatfs_cc_dat__, #104
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1276
	cmp	local03, #1 wz
 if_ne	jmp	#LR__3983
	mov	arg01, local01
	call	#_fatfs_cc___indst
	cmp	result1, #0 wz
 if_ne	sub	local05, ##3600
LR__3983
'                 s -=  (3600L) ;
' 
'         return s;
	mov	result1, local05
LR__3984
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mktime_ret
	ret

_fatfs_cc__gmtime_r
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, arg01
	qdiv	local01, ##86400
	getqx	result1
	add	result1, #4
	qdiv	result1, #7
	add	arg02, #24
	cmp	local01, ##1325376000 wc
 if_ae	sub	local01, ##1325376000
 if_ae	mov	local02, ##2012
 if_b	mov	local02, ##1970
' 	  year = 1970;
' 	}
' 
' 	for(;;) {
	getqy	result1
	wrlong	result1, arg02
	sub	arg02, #24
LR__3990
	mov	arg01, local02
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, ##31622400
 if_e	mov	local03, ##31536000
	cmp	local01, local03 wc
' 	    break;
 if_ae	add	local02, #1
 if_ae	sub	local01, local03
 if_ae	jmp	#LR__3990
	qdiv	local01, ##86400
	mov	local03, local02
	sub	local03, ##1900
	add	arg02, #20
	wrlong	local03, arg02
	add	arg02, #8
	mov	arg01, local02
	getqx	local02
	wrlong	local02, arg02
	sub	arg02, #28
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, #29
 if_e	mov	local03, #28
	add	ptr__fatfs_cc_dat__, ##1180
	wrlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1180
' 
'         days_per_mth[1] = _is_leap_year(year) ? 29 : 28;
'         for (i = 0; mday >= days_per_mth[i]; i++)
	mov	arg01, #0
	callpa	#(@LR__3992-@LR__3991)>>2,fcache_load_ptr_
LR__3991
	mov	local03, arg01
	shl	local03, #2
	add	ptr__fatfs_cc_dat__, ##1176
	add	local03, ptr__fatfs_cc_dat__
	rdlong	local03, local03
	cmps	local02, local03 wc
	sub	ptr__fatfs_cc_dat__, ##1176
 if_b	jmp	#LR__3993
	mov	local03, arg01
	shl	local03, #2
	add	ptr__fatfs_cc_dat__, ##1176
	add	local03, ptr__fatfs_cc_dat__
	rdlong	local03, local03
	sub	local02, local03
	add	arg01, #1
	sub	ptr__fatfs_cc_dat__, ##1176
	jmp	#LR__3991
LR__3992
LR__3993
	qdiv	local01, ##86400
	add	arg02, #16
	wrlong	arg01, arg02
	add	local02, #1
	sub	arg02, #4
	wrlong	local02, arg02
	getqy	local01
	qdiv	local01, ##3600
	getqx	local03
	qdiv	local01, ##3600
	sub	arg02, #4
	wrlong	local03, arg02
	getqy	local01
	qdiv	local01, #60
	getqx	local03
	qdiv	local01, #60
	sub	arg02, #4
	wrlong	local03, arg02
	sub	arg02, #4
'         stm->tm_isdst = 0;
' 
' ;
'         return stm;
	mov	result1, arg02
	getqy	local03
	wrlong	local03, arg02
	add	arg02, #32
	wrlong	#0, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__gmtime_r_ret
	ret

_fatfs_cc__tzset
	mov	arg01, ##@LR__4305
	call	#_fatfs_cc_getenv
	mov	arg01, result1
	add	ptr__fatfs_cc_dat__, ##1276
	mov	arg02, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1276
	call	#_fatfs_cc___tzoffset
	add	ptr__fatfs_cc_dat__, ##1172
	wrlong	result1, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1172
_fatfs_cc__tzset_ret
	ret

_fatfs_cc_getenv
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__4001-@LR__4000)>>2,fcache_load_ptr_
LR__4000
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__4000
LR__4001
	sub	local02, arg01
	mov	result1, local02
	add	ptr__fatfs_cc_dat__, ##1356
	rdlong	arg03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1356
'             return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__4004
' 
' 	for (var = _environ_ptr; (name = *var) != 0; var++) {
	add	ptr__fatfs_cc_dat__, ##1356
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1356
LR__4002
	rdlong	local04, local03 wz
 if_e	jmp	#LR__4003
	mov	arg01, local04
	mov	arg02, local01
	mov	arg03, local02
	call	#_fatfs_cc_strncmp
	cmp	result1, #0 wz
 if_e	mov	local05, local02
 if_e	add	local05, local04
 if_e	rdbyte	local06, local05
 if_e	cmp	local06, #61 wz
' 			return name+len+1;
 if_e	add	local04, local02
 if_e	add	local04, #1
 if_e	mov	result1, local04
 if_e	jmp	#LR__4004
	add	local03, #4
	jmp	#LR__4002
LR__4003
' 	}
' 	return 0;
	mov	result1, #0
LR__4004
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_getenv_ret
	ret

_fatfs_cc__get_fattime
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #52
	mov	arg01, #0
	call	#_fatfs_cc_time
	add	fp, #4
	wrlong	result1, fp
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc__gmtime_r
	add	fp, #36
	rdlong	arg02, fp
	sub	arg02, #80
	shl	arg02, #9
	sub	fp, #4
	rdlong	result1, fp
	add	result1, #1
	shl	result1, #5
	or	arg02, result1
	sub	fp, #4
	rdlong	result1, fp
	or	arg02, result1
	sub	fp, #20
	wrlong	arg02, fp
	add	fp, #16
	rdlong	arg02, fp
	shl	arg02, #11
	sub	fp, #4
	rdlong	result1, fp
	shl	result1, #5
	or	arg02, result1
	sub	fp, #4
	rdlong	result1, fp
	or	arg02, result1
	sub	fp, #4
	wrlong	arg02, fp
' 
'     now = time(0);
'     _gmtime_r (&now, &date);
'     ffdate = ((date.tm_year - 80) << 9) | ((date.tm_mon + 1) << 5) | ((date.tm_mday));
'     fftime = (date.tm_hour << 11) | (date.tm_min << 5) | (date.tm_sec);
'     return (ffdate << 16) | fftime;
	sub	fp, #4
	rdlong	result1, fp
	shl	result1, #16
	sub	fp, #8
	or	result1, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__get_fattime_ret
	ret

_fatfs_cc_unixtime_0845
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #52
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg02, fp
	shr	arg02, #9
	and	arg02, #127
	mov	result1, #80
	add	result1, arg02
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	rdlong	result1, fp
	shr	result1, #5
	getnib	result1, result1, #0
	sub	result1, #1
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	rdlong	result1, fp
	and	result1, #31
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #20
	rdlong	result1, fp
	shr	result1, #11
	and	result1, #31
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	rdlong	result1, fp
	shr	result1, #5
	and	result1, #63
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	rdlong	arg02, fp
	and	arg02, #31
	shl	arg02, #1
	add	fp, #8
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #16
	call	#_fatfs_cc_mktime
	add	fp, #12
	wrlong	result1, fp
' 
'     date.tm_year = 80 + ((dosdate >> 9) & 0x7f);
'     date.tm_mon = ((dosdate >> 5) & 0xf) - 1;
'     date.tm_mday = (dosdate & 0x1f);
'     date.tm_hour = (dostime >> 11) & 0x1f;
'     date.tm_min = (dostime >> 5) & 0x3f;
'     date.tm_sec = (dostime & 0x1f) << 1;
' 
'     t = mktime(&date);
' #line 60 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return t;
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_unixtime_0845_ret
	ret

_fatfs_cc__set_dos_error_0847
	mov	_var01, arg01
' #line 74 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     switch (derr) {
	fle	_var01, #20
	jmprel	_var01
LR__4010
	jmp	#LR__4011
	jmp	#LR__4025
	jmp	#LR__4026
	jmp	#LR__4027
	jmp	#LR__4012
	jmp	#LR__4013
	jmp	#LR__4014
	jmp	#LR__4015
	jmp	#LR__4017
	jmp	#LR__4020
	jmp	#LR__4016
	jmp	#LR__4021
	jmp	#LR__4022
	jmp	#LR__4023
	jmp	#LR__4028
	jmp	#LR__4028
	jmp	#LR__4028
	jmp	#LR__4018
	jmp	#LR__4024
	jmp	#LR__4019
	jmp	#LR__4028
LR__4011
	mov	_var02, #0
'         r = 0;
'         break;
	jmp	#LR__4029
LR__4012
LR__4013
LR__4014
	mov	_var02, #4
'         r =  4 ;
'         break;
	jmp	#LR__4029
LR__4015
LR__4016
	mov	_var02, #6
'         r =  6 ;
'         break;
	jmp	#LR__4029
LR__4017
	mov	_var02, #9
'         r =  9 ;
'         break;
	jmp	#LR__4029
LR__4018
	mov	_var02, #7
'         r =  7 ;
'         break;
	jmp	#LR__4029
LR__4019
LR__4020
LR__4021
LR__4022
LR__4023
	mov	_var02, #10
'         r =  10 ;
'         break;
	jmp	#LR__4029
LR__4024
	mov	_var02, #11
'         r =  11 ;
'         break;
	jmp	#LR__4029
LR__4025
LR__4026
LR__4027
LR__4028
	mov	_var02, #12
'         r =  12 ;
'         break;
LR__4029
'     }
'     return _seterror(r);
	cmps	_var02, #0 wz
	add	ptr___system__dat__, #32
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
_fatfs_cc__set_dos_error_0847_ret
	ret

_fatfs_cc_v_creat
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, ##1596
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4031
	mov	arg01, local03
	mov	arg02, #0
	mov	arg03, ##1596
	call	#\builtin_bytefill_
	add	local03, ##1044
	mov	arg01, local03
	sub	local03, ##1044
	mov	arg02, local02
	mov	arg03, #7
	call	#_fatfs_cc_f_open
	mov	local04, result1 wz
 if_e	jmp	#LR__4030
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_0847
	jmp	#LR__4031
LR__4030
	wrlong	local03, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__4031
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_creat_ret
	ret

_fatfs_cc_v_close
	mov	COUNT_, #2
	call	#pushregs_
	rdlong	local01, arg01
	add	local01, ##1044
	mov	arg01, local01
	sub	local01, ##1044
	call	#_fatfs_cc_f_close
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
'     FAT_FIL *f = fil->vfsdata;
'     r=f_close(&f->fil);
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local02
	call	#_fatfs_cc__set_dos_error_0847
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_close_ret
	ret

_fatfs_cc_v_opendir
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, #48
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
' #line 158 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/fatfs.cc"
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4041
	mov	arg02, local02
	mov	arg01, local03
	call	#_fatfs_cc_f_opendir
	mov	local04, result1 wz
 if_e	jmp	#LR__4040
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'         free(f);
'         return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_0847
	jmp	#LR__4041
LR__4040
	add	local01, #4
	wrlong	local03, local01
'     }
'     dir->vfsdata = f;
'     return 0;
	mov	result1, #0
LR__4041
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_opendir_ret
	ret

_fatfs_cc_v_closedir
	mov	COUNT_, #2
	call	#pushregs_
	add	arg01, #4
	rdlong	local01, arg01
	mov	arg01, local01
	call	#_fatfs_cc_f_closedir
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
	cmp	local02, #0 wz
 if_ne	mov	arg01, local02
 if_ne	call	#_fatfs_cc__set_dos_error_0847
'     return r;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_closedir_ret
	ret

_fatfs_cc_v_readdir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #300
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	arg03, #4
	rdlong	arg01, arg03
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_f_readdir
	add	fp, #296
	wrlong	result1, fp
	sub	fp, #296
	cmp	result1, #0 wz
 if_e	jmp	#LR__4050
'         return _set_dos_error(r);
	add	fp, #296
	rdlong	arg01, fp
	sub	fp, #296
	call	#_fatfs_cc__set_dos_error_0847
	jmp	#LR__4053
LR__4050
	add	fp, #40
	rdbyte	arg03, fp wz
	sub	fp, #40
'         return -1;
 if_e	neg	result1, #1
 if_e	jmp	#LR__4053
	add	fp, #8
	rdlong	arg01, fp
	add	fp, #32
	mov	arg02, fp
	sub	fp, #40
	mov	arg03, #63
	call	#_fatfs_cc_strncpy
	add	fp, #8
	rdlong	arg03, fp
	add	arg03, #63
	wrbyte	#0, arg03
	add	fp, #12
	rdbyte	arg03, fp
	sub	fp, #20
	test	arg03, #16 wz
 if_e	jmp	#LR__4051
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	add	arg03, #80
	wrbyte	#1, arg03
	jmp	#LR__4052
LR__4051
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	add	arg03, #80
	wrbyte	#0, arg03
LR__4052
	add	fp, #8
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg02, fp
	add	arg03, #72
	wrlong	arg02, arg03
	sub	fp, #4
	rdlong	local01, fp
	add	fp, #8
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #18
	call	#_fatfs_cc_unixtime_0845
	add	local01, #76
	wrlong	result1, local01
'         ent->d_type =  (0) ;
'     }
'     ent->d_size = finfo.fsize;
'     ent->d_mtime = unixtime(finfo.fdate, finfo.ftime);
'     return 0;
	mov	result1, #0
LR__4053
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_readdir_ret
	ret

_fatfs_cc_v_stat
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #304
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, arg02
	mov	arg02, #0
	mov	arg03, #48
	call	#\builtin_bytefill_
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	rdbyte	result1, result1 wz
 if_e	jmp	#LR__4060
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	rdbyte	result1, result1
	cmp	result1, #46 wz
 if_e	add	fp, #4
 if_e	rdlong	local01, fp
 if_e	sub	fp, #4
 if_e	add	local01, #1
 if_e	rdbyte	local02, local01 wz
 if_ne	jmp	#LR__4061
LR__4060
	add	fp, #24
	wrbyte	#16, fp
	sub	fp, #12
	wrlong	#0, fp
	sub	fp, #12
	jmp	#LR__4062
LR__4061
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc_f_stat
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__4062
	add	fp, #12
	rdlong	local02, fp wz
	sub	fp, #12
 if_e	jmp	#LR__4063
'         return _set_dos_error(r);
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc__set_dos_error_0847
	jmp	#LR__4064
LR__4063
	add	fp, #300
	wrlong	#292, fp
	sub	fp, #276
	rdbyte	local03, fp
	sub	fp, #24
	test	local03, #1 wz
 if_e	add	fp, #300
 if_e	rdlong	local03, fp
 if_e	or	local03, #146
 if_e	wrlong	local03, fp
 if_e	sub	fp, #300
	add	fp, #24
	rdbyte	local03, fp
	sub	fp, #24
	test	local03, #16 wz
 if_ne	add	fp, #300
 if_ne	rdlong	local03, fp
 if_ne	or	local03, ##4169
 if_ne	wrlong	local03, fp
 if_ne	sub	fp, #300
	add	fp, #8
	rdlong	local03, fp
	add	fp, #292
	rdlong	local02, fp
	add	local03, #8
	wrlong	local02, local03
	sub	fp, #292
	rdlong	local03, fp
	add	local03, #12
	wrlong	#1, local03
	rdlong	local03, fp
	add	fp, #8
	rdlong	local02, fp
	add	local03, #24
	wrlong	local02, local03
	sub	fp, #8
	rdlong	local03, fp
	add	local03, #28
	wrlong	##512, local03
	rdlong	local02, fp
	mov	local03, local02
	add	local02, #24
	rdlong	local02, local02
	add	local02, #511
	abs	local02, local02 wc
	shr	local02, #9
	negc	local02, local02
	add	local03, #32
	wrlong	local02, local03
	rdlong	local02, fp
	mov	local03, local02
	mov	local01, local02
	add	fp, #12
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #22
	call	#_fatfs_cc_unixtime_0845
	add	local01, #44
	wrlong	result1, local01
	add	local02, #40
	wrlong	result1, local02
	add	local03, #36
	wrlong	result1, local03
'         mode |=  0010000  |  0100  |  0010  |  0001 ;
'     }
'     buf->st_mode = mode;
'     buf->st_nlink = 1;
'     buf->st_size = finfo.fsize;
'     buf->st_blksize = 512;
'     buf->st_blocks = (buf->st_size + 511) / 512;
'     buf->st_atime = buf->st_mtime = buf->st_ctime = unixtime(finfo.fdate, finfo.ftime);
' #line 249 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return r;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
LR__4064
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_stat_ret
	ret

_fatfs_cc_v_read
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #28
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	rdlong	arg01, arg01 wz
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #16
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4072
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, ##1044
	sub	fp, #8
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #12
	mov	arg04, fp
	sub	fp, #24
	call	#_fatfs_cc_f_read
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmp	result1, #0 wz
 if_e	jmp	#LR__4070
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	add	arg04, #8
	rdlong	arg04, arg04
	or	arg04, #32
	add	arg03, #8
	wrlong	arg04, arg03
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	call	#_fatfs_cc__set_dos_error_0847
	jmp	#LR__4072
LR__4070
	add	fp, #24
	rdlong	result1, fp wz
	sub	fp, #24
 if_ne	jmp	#LR__4071
	add	fp, #4
	rdlong	result1, fp
	mov	arg04, result1
	sub	fp, #4
	add	result1, #8
	rdlong	result1, result1
	or	result1, #16
	add	arg04, #8
	wrlong	result1, arg04
LR__4071
'         fil->state |=  (0x10) ;
'     }
'     return x;
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #24
LR__4072
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_read_ret
	ret

_fatfs_cc_v_write
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #28
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	rdlong	arg01, arg01 wz
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #16
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4081
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, ##1044
	sub	fp, #8
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #12
	mov	arg04, fp
	sub	fp, #24
	call	#_fatfs_cc_f_write
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmp	result1, #0 wz
 if_e	jmp	#LR__4080
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	add	arg04, #8
	rdlong	arg04, arg04
	or	arg04, #32
	add	arg03, #8
	wrlong	arg04, arg03
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	call	#_fatfs_cc__set_dos_error_0847
	jmp	#LR__4081
LR__4080
'     }
'     return x;
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #24
LR__4081
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_write_ret
	ret

_fatfs_cc_v_lseek
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	rdlong	local03, arg01
	add	local03, ##1044 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4092
	cmp	local02, #0 wz
 if_e	jmp	#LR__4090
	cmp	local02, #1 wz
 if_e	add	local03, #20
 if_e	rdlong	local04, local03
 if_e	sub	local03, #20
 if_e	add	local01, local04
 if_ne	add	local03, #12
 if_ne	rdlong	local04, local03
 if_ne	sub	local03, #12
 if_ne	add	local01, local04
LR__4090
	mov	arg02, local01
	mov	arg01, local03
	call	#_fatfs_cc_f_lseek
	mov	arg01, result1 wz
 if_e	jmp	#LR__4091
'         return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_0847
	jmp	#LR__4092
LR__4091
'     }
'     return offset;
	mov	result1, local01
LR__4092
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_lseek_ret
	ret

_fatfs_cc_v_ioctl
' {
'     return _seterror( 10 );
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
_fatfs_cc_v_ioctl_ret
	ret

_fatfs_cc_v_mkdir
	call	#_fatfs_cc_f_mkdir
	mov	arg01, result1
' 
'     r = f_mkdir(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0847
_fatfs_cc_v_mkdir_ret
	ret

_fatfs_cc_v_remove
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0847
_fatfs_cc_v_remove_ret
	ret

_fatfs_cc_v_rmdir
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0847
_fatfs_cc_v_rmdir_ret
	ret

_fatfs_cc_v_rename
	call	#_fatfs_cc_f_rename
	mov	arg01, result1
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0847
_fatfs_cc_v_rename_ret
	ret

_fatfs_cc_v_open
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, ##1596
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local04, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4106
	mov	arg01, local04
	mov	arg02, #0
	mov	arg03, ##1596
	call	#\builtin_bytefill_
'   switch (flags & 3) {
	mov	local05, local03
	and	local05, #3 wz
 if_e	jmp	#LR__4100
	cmp	local05, #1 wz
 if_e	jmp	#LR__4101
	jmp	#LR__4102
LR__4100
	mov	local06, #1
'       fs_flags =  0x01 ;
'       break;
	jmp	#LR__4103
LR__4101
	mov	local06, #2
'       fs_flags =  0x02 ;
'       break;
	jmp	#LR__4103
LR__4102
	mov	local06, #3
'       fs_flags =  0x01  |  0x02 ;
'       break;
LR__4103
	test	local03, #8 wz
 if_ne	or	local06, #24
 if_ne	jmp	#LR__4104
	test	local03, #32 wz
 if_ne	or	local06, #48
LR__4104
	add	local04, ##1044
	mov	arg01, local04
	sub	local04, ##1044
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_f_open
	mov	local07, result1 wz
 if_e	jmp	#LR__4105
	mov	arg01, local04
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
' #line 417 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(r);
	mov	arg01, local07
	call	#_fatfs_cc__set_dos_error_0847
	jmp	#LR__4106
LR__4105
	wrlong	local04, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__4106
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_open_ret
	ret

_fatfs_cc_v_flush
	rdlong	arg01, arg01
	add	arg01, ##1044 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4110
	call	#_fatfs_cc_f_sync
	mov	arg01, result1
'     }
' #line 437 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     result = f_sync(f);
' #line 441 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_0847
LR__4110
_fatfs_cc_v_flush_ret
	ret

_fatfs_cc_v_init
' {
'     return 0;
	mov	result1, #0
_fatfs_cc_v_init_ret
	ret

_fatfs_cc_v_deinit
	mov	arg02, ##@LR__4306
	mov	arg01, #0
	mov	arg03, #0
	call	#_fatfs_cc_f_mount
	add	objptr, ##520
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##524
	call	#__system___freepins
' #line 462 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     _freepins(f_pinmask);
'     return 0;
	mov	result1, #0
_fatfs_cc_v_deinit_ret
	ret

_fatfs_cc_get_vfs
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #80
	call	#__system___gc_alloc_managed
	mov	arg01, result1
	mov	result1, objptr
	bith	result1, #88
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##118489088
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##119537664
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##120586240
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##121634816
	add	arg01, #4
	wrlong	result1, arg01
	add	arg01, #4
	wrlong	#0, arg01
	add	arg01, #4
	wrlong	local01, arg01
	add	arg01, #4
	wrlong	#0, arg01
	mov	result1, objptr
	or	result1, ##122683392
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##123731968
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##124780544
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #119
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##126877696
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##127926272
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##128974848
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #150
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##131072000
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #181
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #212
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	bith	result1, #27
	add	arg01, #4
	wrlong	result1, arg01
	sub	arg01, #76
' 
'     v->close = &v_close;
'     v->read = &v_read;
'     v->write = &v_write;
'     v->lseek = &v_lseek;
'     v->ioctl = &v_ioctl;
'     v->flush = 0;
'     v->vfs_data = ptr;
'     v->reserved = 0;
' 
'     v->open = &v_open;
'     v->creat = &v_creat;
'     v->opendir = &v_opendir;
'     v->closedir = &v_closedir;
'     v->readdir = &v_readdir;
'     v->stat = &v_stat;
' 
'     v->mkdir = &v_mkdir;
'     v->rmdir = &v_rmdir;
' 
'     v->remove = &v_remove;
'     v->rename = &v_rename;
' 
'     v->init = &v_init;
'     v->deinit = &v_deinit;
' 
'     return v;
	mov	result1, arg01
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_vfs_ret
	ret

_fatfs_cc_xmit_mmc_0994
	add	objptr, ##528
	rdlong	_var01, objptr
	add	objptr, #8
	rdlong	_var02, objptr
	sub	objptr, ##536
	dirl	_var02
	setq	#1
	rdlong	_var03, arg01
	rev	_var03
	movbyts	_var03, #27
	wypin	_var03, _var02
	mov	_var03, arg02
	shr	arg02, #2 wz
	shl	_var03, #3
	wypin	_var03, _var01
	dirh	_var02
	add	arg01, #8
	rev	_var04
	movbyts	_var04, #27
LR__4120
 if_ne	wypin	_var04, _var02
 if_ne	rdlong	_var04, arg01
 if_ne	add	arg01, #4
 if_ne	rev	_var04
 if_ne	movbyts	_var04, #27
LR__4121
 if_ne	testp	_var02 wc
 if_a	jmp	#LR__4121
 if_ne	djnz	arg02, #LR__4120
LR__4122
	testp	_var01 wc
 if_ae	jmp	#LR__4122
	dirl	_var02
	wypin	##-1, _var02
	dirh	_var02
_fatfs_cc_xmit_mmc_0994_ret
	ret

_fatfs_cc_rcvr_mmc_1001
	add	objptr, ##528
	rdlong	_var01, objptr
	add	objptr, #12
	rdlong	_var02, objptr
	sub	objptr, ##540
	akpin	_var02
	mov	_var03, arg02 wz
	shr	_var03, #2 wz
 if_e	jmp	#LR__4132
	mov	_var04, _var03
	shl	_var04, #5
	wypin	_var04, _var01
	wxpin	#63, _var02
LR__4130
LR__4131
	testp	_var02 wc
 if_ae	jmp	#LR__4131
	rdpin	_var04, _var02
	rev	_var04
	movbyts	_var04, #27
	wrlong	_var04, arg01
	add	arg01, #4
	djnz	_var03, #LR__4130
LR__4132
	and	arg02, #3 wz
 if_e	jmp	#LR__4135
	wxpin	#39, _var02
LR__4133
	wypin	#8, _var01
LR__4134
	testp	_var02 wc
 if_ae	jmp	#LR__4134
	rdpin	_var04, _var02
	rev	_var04
	wrbyte	_var04, arg01
	add	arg01, #1
	djnz	arg02, #LR__4133
LR__4135
_fatfs_cc_rcvr_mmc_1001_ret
	ret

_fatfs_cc_wait_ready_1005
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	getct	result1
	add	fp, #8
	wrlong	result1, fp
	rdlong	local01, #20
	shr	local01, #1
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #12
' {
' 	BYTE d;
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 1;
' 	for(;;) {
LR__4140
	add	fp, #4
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #4
	rdbyte	local01, fp
	sub	fp, #4
	cmp	local01, #255 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4141
	getct	result1
	add	fp, #8
	rdlong	local01, fp
	sub	result1, local01
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #12
	cmp	result1, local01 wc
 if_ae	mov	result1, #0
 if_b	jmp	#LR__4140
LR__4141
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_wait_ready_1005_ret
	ret

_fatfs_cc_deselect_1011
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##532
	rdlong	arg02, objptr
	add	fp, #4
	wrlong	arg02, fp
	sub	objptr, #4
	rdlong	arg02, objptr
	add	fp, #4
	wrlong	arg02, fp
	add	objptr, #8
	rdlong	arg02, objptr
	add	fp, #4
	wrlong	arg02, fp
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##540
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #4
	drvh	arg01
	waitx	#16
	mov	arg01, fp
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1001
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_deselect_1011_ret
	ret

_fatfs_cc_select_1015
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##532
	rdlong	arg02, objptr
	add	fp, #8
	wrlong	arg02, fp
	add	objptr, #8
	rdlong	arg01, objptr
	sub	objptr, ##540
	add	fp, #4
	wrlong	arg01, fp
	fltl	arg01
	sub	fp, #4
	rdlong	arg01, fp
	drvl	arg01
	waitx	#16
	add	fp, #4
	rdlong	arg01, fp
	dirh	arg01
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1001
	call	#_fatfs_cc_wait_ready_1005
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__4150
	call	#_fatfs_cc_deselect_1011
' 
' 	deselect();
' 	return 0;
	mov	result1, #0
LR__4150
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_select_1015_ret
	ret

_fatfs_cc_rcvr_datablock_1019
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	getct	result1
	add	fp, #8
	wrlong	result1, fp
	rdlong	local01, #20
	shr	local01, #3
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
' 	BYTE *buff,
' 	UINT btr
' )
' {
' 	BYTE d[2];
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 3;
' 	for(;;) {
LR__4160
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	cmp	local01, #255 wz
 if_ne	jmp	#LR__4161
	getct	result1
	mov	local01, result1
	add	fp, #16
	rdlong	arg02, fp
	sub	local01, arg02
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #20
	cmp	local01, arg02 wc
 if_b	jmp	#LR__4160
LR__4161
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	cmp	local01, #254 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4162
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #2
	call	#_fatfs_cc_rcvr_mmc_1001
' 
' 	rcvr_mmc(buff, btr);
' 	rcvr_mmc(d, 2);
' 
' 	return 1;
	mov	result1, #1
LR__4162
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_rcvr_datablock_1019_ret
	ret

_fatfs_cc_xmit_datablock_1021
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrbyte	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_wait_ready_1005
	cmp	result1, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4171
	add	fp, #8
	rdbyte	arg02, fp
	add	fp, #4
	wrbyte	arg02, fp
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #1
	call	#_fatfs_cc_xmit_mmc_0994
	add	fp, #8
	rdbyte	arg02, fp
	sub	fp, #8
	cmp	arg02, #253 wz
 if_e	jmp	#LR__4170
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	decod	arg02, #9
	call	#_fatfs_cc_xmit_mmc_0994
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #2
	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #12
	rdbyte	arg02, fp
	sub	fp, #12
	and	arg02, #31
	cmp	arg02, #5 wz
' 			return 0;
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4171
LR__4170
' 	}
' 
' 	return 1;
	mov	result1, #1
LR__4171
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_xmit_datablock_1021_ret
	ret

_fatfs_cc_send_cmd_1025
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #28
_fatfs_cc_send_cmd_1025_enter
	add	fp, #4
	wrbyte	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdbyte	result1, fp
	sub	fp, #4
	test	result1, #128 wz
 if_e	jmp	#LR__4180
	add	fp, #4
	rdbyte	arg02, fp
	and	arg02, #127
	wrbyte	arg02, fp
	sub	fp, #4
	mov	arg01, #55
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1025
	add	fp, #12
	wrbyte	result1, fp
	rdbyte	arg02, fp
	sub	fp, #12
	cmp	arg02, #2 wc
 if_ae	add	fp, #12
 if_ae	rdbyte	result1, fp
 if_ae	sub	fp, #12
 if_ae	jmp	#LR__4184
LR__4180
	add	fp, #4
	rdbyte	arg02, fp
	sub	fp, #4
	cmp	arg02, #12 wz
 if_e	jmp	#LR__4181
	call	#_fatfs_cc_deselect_1011
	call	#_fatfs_cc_select_1015
	cmp	result1, #0 wz
 if_e	mov	result1, #255
 if_e	jmp	#LR__4184
LR__4181
	add	fp, #4
	rdbyte	arg02, fp
	mov	result1, #64
	or	result1, arg02
	add	fp, #16
	wrbyte	result1, fp
	sub	fp, #12
	rdlong	result1, fp
	shr	result1, #24
	add	fp, #13
	wrbyte	result1, fp
	sub	fp, #13
	rdlong	result1, fp
	shr	result1, #16
	add	fp, #14
	wrbyte	result1, fp
	sub	fp, #14
	rdlong	result1, fp
	shr	result1, #8
	add	fp, #15
	wrbyte	result1, fp
	sub	fp, #15
	rdlong	result1, fp
	add	fp, #16
	wrbyte	result1, fp
	sub	fp, #12
	wrbyte	#1, fp
	sub	fp, #8
	rdbyte	result1, fp wz
	sub	fp, #4
 if_e	add	fp, #12
 if_e	wrbyte	#149, fp
 if_e	sub	fp, #12
	add	fp, #4
	rdbyte	result1, fp
	sub	fp, #4
	cmp	result1, #8 wz
 if_e	add	fp, #12
 if_e	wrbyte	#135, fp
 if_e	sub	fp, #12
	add	fp, #12
	rdbyte	arg02, fp
	add	fp, #13
	wrbyte	arg02, fp
	sub	fp, #5
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #6
	call	#_fatfs_cc_xmit_mmc_0994
	add	fp, #4
	rdbyte	local01, fp
	sub	fp, #4
	cmp	local01, #12 wz
 if_e	add	fp, #16
 if_e	mov	arg01, fp
 if_e	sub	fp, #16
 if_e	mov	arg02, #1
 if_e	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #12
	wrbyte	#10, fp
	sub	fp, #12
' 	n = 10;
' 	do
LR__4182
	add	fp, #16
	mov	arg01, fp
	sub	fp, #16
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1001
	add	fp, #16
	rdbyte	local01, fp
	sub	fp, #16
	test	local01, #128 wz
 if_e	jmp	#LR__4183
	add	fp, #12
	rdbyte	local01, fp
	sub	local01, #1
	wrbyte	local01, fp
	rdbyte	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__4182
LR__4183
' 
' 	return d;
	add	fp, #16
	rdbyte	result1, fp
	sub	fp, #16
LR__4184
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_send_cmd_1025_ret
	ret

_fatfs_cc_disk_deinitialize
	mov	COUNT_, #3
	call	#pushregs_
	cmps	arg01, #0 wz
	add	objptr, ##532
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	local01, objptr
	add	objptr, #8
	rdlong	local02, objptr
	add	objptr, #4
	rdlong	local03, objptr
	sub	objptr, ##540
' #line 799 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/sdmm.cc"
'         return RES_NOTRDY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4190
	fltl	arg01
	wrpin	#0, arg01
	fltl	local01
	wrpin	#0, local01
	fltl	local02
	wrpin	#0, local02
	fltl	local03
	wrpin	#0, local03
	mov	arg01, #10
	call	#__system___waitms
'     }
' #line 805 "C:/Users/Piotr/Downloads/flexprop-6.3.0/flexprop/include/filesys/fatfs/sdmm.cc"
'     _pinclear(PIN_SS);
'     _pinclear(PIN_CLK);
'     _pinclear(PIN_DI);
'     _pinclear(PIN_DO);
' 
'     _waitms(10);
' 
'     return 0;
	mov	result1, #0
LR__4190
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_deinitialize_ret
	ret

_fatfs_cc_gettimeofday
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	call	#__system___getus
	mov	arg01, result1
	add	ptr__fatfs_cc_dat__, ##1368
	rdlong	local02, ptr__fatfs_cc_dat__
	mov	result1, arg01
	sub	result1, local02
	qdiv	result1, ##1000000
	sub	ptr__fatfs_cc_dat__, ##1368
	getqx	local02
	qdiv	result1, ##1000000
	cmp	local02, #0 wz
	getqy	local03
 if_e	jmp	#LR__4200
	add	ptr__fatfs_cc_dat__, ##1364
	rdlong	local04, ptr__fatfs_cc_dat__
	add	local04, local02
	wrlong	local04, ptr__fatfs_cc_dat__
	sub	arg01, local03
	add	ptr__fatfs_cc_dat__, #4
	wrlong	arg01, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1368
LR__4200
	add	ptr__fatfs_cc_dat__, ##1364
	rdlong	local04, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1364
	wrlong	local04, local01
	add	local01, #4
	wrlong	local03, local01
'         lastsec += secs;
'         lastus = now - leftover;
'     }
'     tv->tv_sec = lastsec;
'     tv->tv_usec = leftover;
'     return 0;
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_gettimeofday_ret
	ret

_fatfs_cc__is_leap_year
	abs	result1, arg01 wc
	and	result1, #3
	negc	result1, result1 wz
 if_ne	jmp	#LR__4211
	abs	result1, arg01 wc
	qdiv	result1, #100
	getqy	result1
	negc	result1, result1 wz
 if_ne	jmp	#LR__4210
	abs	result1, arg01 wc
	qdiv	result1, #400
'       return (0 == y % 400);
	mov	result1, #0
	getqy	_var01
	negc	_var01, _var01 wz
 if_e	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__4210
'     return 1;
	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__4211
'   }
'   return 0;
	mov	result1, #0
_fatfs_cc__is_leap_year_ret
	ret

_fatfs_cc___tzoffset
	mov	_var01, arg01 wz
	wrlong	##-1, arg02
	mov	_var02, #1
 if_ne	rdbyte	_var03, _var01 wz
'                 return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__4237
	wrlong	#0, arg02
	add	ptr__fatfs_cc_dat__, ##1324
	mov	_var04, ptr__fatfs_cc_dat__
' 
'        *hasdst = 0;
' 
' 	n = stdname;
'         while (*s && isalpha(*s)) {
	sub	ptr__fatfs_cc_dat__, ##1324
	callpa	#(@LR__4221-@LR__4220)>>2,fcache_load_ptr_
LR__4220
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__4222
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, ##1372
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #12 wz
 if_e	jmp	#LR__4222
	mov	_var05, _var01
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var05
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__4220
LR__4221
LR__4222
	wrbyte	#0, _var04
	mov	_var08, #0
	rdbyte	_var03, _var01
	cmp	_var03, #45 wz
 if_e	neg	_var02, #1
 if_e	add	_var01, #1
	callpa	#(@LR__4224-@LR__4223)>>2,fcache_load_ptr_
'                 sgn = -1;
'                 s++;
'         }
'         while (isdigit(*s)) {
LR__4223
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, ##1372
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #2 wz
 if_e	jmp	#LR__4225
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__4223
LR__4224
LR__4225
	qmul	_var08, ##3600
	rdbyte	_var03, _var01
	cmp	_var03, #58 wz
	getqx	_var09
 if_ne	jmp	#LR__4229
	mov	_var08, #0
	add	_var01, #1
	callpa	#(@LR__4227-@LR__4226)>>2,fcache_load_ptr_
'                 x = 0;
'                 s++;
'                 while (isdigit(*s)) {
LR__4226
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, ##1372
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #2 wz
 if_e	jmp	#LR__4228
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__4226
LR__4227
LR__4228
	mov	_var07, _var08
	shl	_var07, #4
	sub	_var07, _var08
	shl	_var07, #2
	add	_var09, _var07
LR__4229
	add	ptr__fatfs_cc_dat__, ##1333
	mov	_var04, ptr__fatfs_cc_dat__
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, #39
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #12 wz
 if_e	jmp	#LR__4232
	wrlong	#1, arg02
'                 *hasdst = 1;
' 		while (*s && isalpha(*s)) *n++ = *s++;
LR__4230
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__4231
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, ##1372
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #12 wz
 if_e	jmp	#LR__4231
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var01
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__4230
LR__4231
LR__4232
	wrbyte	#0, _var04
	add	ptr__fatfs_cc_dat__, ##1324
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1324
 if_e	jmp	#LR__4233
	add	ptr__fatfs_cc_dat__, ##1324
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #8
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1316
	jmp	#LR__4234
LR__4233
	add	ptr__fatfs_cc_dat__, ##1342
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #26
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1316
LR__4234
	add	ptr__fatfs_cc_dat__, ##1333
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1333
 if_e	jmp	#LR__4235
	add	ptr__fatfs_cc_dat__, ##1333
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #13
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1320
	jmp	#LR__4236
LR__4235
	add	ptr__fatfs_cc_dat__, ##1324
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #4
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1320
LR__4236
	qmul	_var02, _var09
' 		_tzname[1] = stdname;
' 
'         return sgn * off;
	getqx	result1
LR__4237
_fatfs_cc___tzoffset_ret
	ret

_fatfs_cc___indst
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #2 wz
 if_ne	jmp	#LR__4240
	mov	_var01, #7
	add	arg01, #24
	rdlong	_var02, arg01
	add	_var01, _var02
	sub	arg01, #12
	rdlong	_var03, arg01
	sub	_var01, _var03
	cmps	_var01, #0 wc
'                         return 1;
 if_b	mov	result1, #1
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 0;
	mov	result1, #0
	jmp	#_fatfs_cc___indst_ret
LR__4240
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #10 wz
 if_ne	jmp	#LR__4241
	add	arg01, #24
	rdlong	_var01, arg01
	sub	arg01, #12
	rdlong	_var04, arg01
	sub	_var01, _var04
	cmps	_var01, #0 wc
'                         return 0;
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 1;
	mov	result1, #1
	jmp	#_fatfs_cc___indst_ret
LR__4241
'         }
' 
'         return (t->tm_mon > 2 && t->tm_mon < 10);
	mov	_var01, #0
	add	arg01, #16
	rdlong	_var02, arg01
	sub	arg01, #16
	cmps	_var02, #3 wc
 if_b	jmp	#LR__4242
	add	arg01, #16
	rdlong	_var03, arg01
	cmps	_var03, #10 wc
 if_b	mov	_var01, #1
LR__4242
	mov	result1, _var01
_fatfs_cc___indst_ret
	ret

' 	
' 	FUNCTION pfunc(c as integer) as integer
___strs_cl_pfunc
' 		if (i < 16) then
	add	objptr, #4
	rdlong	result1, objptr
	sub	objptr, #4
	cmps	result1, #16 wc
 if_ae	jmp	#LR__4250
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	_var01, objptr
	add	_var01, result1
	wrbyte	arg01, _var01
	rdlong	result1, objptr
	add	result1, #1
	wrlong	result1, objptr
	sub	objptr, #4
' 			p(i) = c
' 			i = i+1
' 			return 1
	mov	result1, #1
	jmp	#___strs_cl_pfunc_ret
LR__4250
' 			return -1
	neg	result1, #1
___strs_cl_pfunc_ret
	ret

__struct__s_vfs_file_t_putchar
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, #28
	rdlong	local01, objptr wz
	sub	objptr, #28
 if_e	mov	result1, #0
 if_e	jmp	#LR__4260
	add	objptr, #28
	rdlong	local02, objptr
	mov	local03, local02
	sub	objptr, #28
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg02, objptr
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
'     return (i < 0) ? 0 : 1;
	cmps	result1, #0 wc
 if_b	mov	local01, #0
 if_ae	mov	local01, #1
	mov	result1, local01
LR__4260
	mov	ptra, fp
	call	#popregs_
__struct__s_vfs_file_t_putchar_ret
	ret

__struct__s_vfs_file_t_getchar
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #32
	rdlong	arg01, objptr wz
	sub	objptr, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4270
'     return getcf(__this);
	add	objptr, #32
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #32
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	arg01, objptr
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
LR__4270
	mov	ptra, fp
	call	#popregs_
__struct__s_vfs_file_t_getchar_ret
	ret

__struct___bas_wrap_sender_tx
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, objptr
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__struct___bas_wrap_sender_tx_ret
	ret

__struct___bas_wrap_sender_rx
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #4
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #4
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__struct___bas_wrap_sender_rx_ret
	ret

__struct___bas_wrap_sender_close
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #8
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #8
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__struct___bas_wrap_sender_close_ret
	ret

LR__4280
	byte	"/"
	byte	0
LR__4281
	byte	"inf"
	byte	0
LR__4282
	byte	"nan"
	byte	0
LR__4283
	byte	
	byte	0
LR__4284
	byte	
	byte	0
LR__4285
	byte	
	byte	0
LR__4286
	byte	
	byte	0
LR__4287
	byte	
	byte	0
LR__4288
	byte	
	byte	0
LR__4289
	byte	
	byte	0
LR__4290
	byte	
	byte	0
LR__4291
	byte	0
	byte	0
LR__4292
	byte	0
	byte	0
LR__4293
	byte	0
	byte	0
LR__4294
	byte	" !!! corrupted heap??? !!! "
	byte	0
LR__4295
	byte	" !!! out of heap memory !!! "
	byte	0
LR__4296
	byte	" !!! corrupted heap !!! "
	byte	0
LR__4297
	byte	0
	byte	0
LR__4298
	byte	"."
	byte	0
LR__4299
	byte	0
	byte	0
LR__4300
	byte	0
	byte	0
LR__4301
	byte	0
	byte	0
LR__4302
	byte	"*:<>|",34,"?",127
	byte	0
LR__4303
	byte	"+,;=[]"
	byte	0
LR__4304
	byte	"FAT32   "
	byte	0
LR__4305
	byte	"TZ"
	byte	0
LR__4306
	byte	0
	byte	0
LR__4307
	byte	
	byte	0
LR__4308
	byte	
	byte	0
LR__4309
	byte	34
	byte	0
LR__4310
	byte	34
	byte	0
LR__4311
	byte	":"
	byte	0
LR__4312
	byte	
	byte	0
LR__4313
	byte	
	byte	0
LR__4314
	byte	
	byte	0
LR__4315
	byte	
	byte	0
LR__4316
	byte	
	byte	0
LR__4317
	byte	
	byte	0
LR__4318
	byte	
	byte	0
LR__4319
	byte	34
	byte	0
LR__4320
	byte	34
	byte	0
LR__4321
	byte	34
	byte	0
LR__4322
	byte	34
	byte	0
LR__4323
	byte	34
	byte	0
LR__4324
	byte	">"
	byte	0
LR__4325
	byte	">"
	byte	0
LR__4326
	byte	"+"
	byte	0
LR__4327
	byte	"-"
	byte	0
LR__4328
	byte	"*"
	byte	0
LR__4329
	byte	"/"
	byte	0
LR__4330
	byte	"^"
	byte	0
LR__4331
	byte	"="
	byte	0
LR__4332
	byte	"+"
	byte	0
LR__4333
	byte	"+"
	byte	0
LR__4334
	byte	"-"
	byte	0
LR__4335
	byte	"-"
	byte	0
LR__4336
	byte	"<"
	byte	0
LR__4337
	byte	">"
	byte	0
LR__4338
	byte	34
	byte	0
LR__4339
	byte	34
	byte	0
LR__4340
	byte	"."
	byte	0
LR__4341
	byte	"?"
	byte	0
LR__4342
	byte	"?"
	byte	0
LR__4343
	byte	"mouse"
	byte	0
LR__4344
	byte	"cursor"
	byte	0
LR__4345
	byte	"click"
	byte	0
LR__4346
	byte	"on"
	byte	0
LR__4347
	byte	"1"
	byte	0
LR__4348
	byte	"off"
	byte	0
LR__4349
	byte	"0"
	byte	0
LR__4350
	byte	"mode"
	byte	0
LR__4351
	byte	"m."
	byte	0
LR__4352
	byte	"atari"
	byte	0
LR__4353
	byte	"0"
	byte	0
LR__4354
	byte	"pc_amber"
	byte	0
LR__4355
	byte	"1"
	byte	0
LR__4356
	byte	"pc_green"
	byte	0
LR__4357
	byte	"2"
	byte	0
LR__4358
	byte	"pc_white"
	byte	0
LR__4359
	byte	"3"
	byte	0
LR__4360
	byte	"st"
	byte	0
LR__4361
	byte	"4"
	byte	0
LR__4362
	byte	
	byte	0
LR__4363
	byte	"load"
	byte	0
LR__4364
	byte	"save"
	byte	0
LR__4365
	byte	"brun"
	byte	0
LR__4366
	byte	"lo."
	byte	0
LR__4367
	byte	"s."
	byte	0
LR__4368
	byte	"br."
	byte	0
LR__4369
	byte	
	byte	0
LR__4370
	byte	
	byte	0
LR__4371
	byte	
	byte	0
LR__4372
	byte	
	byte	0
LR__4373
	byte	" User functions and arrays not yet implemented"
	byte	0
LR__4374
	byte	
	byte	0
LR__4375
	byte	
	byte	0
LR__4376
	byte	"Ready"
	byte	0
LR__4377
	byte	"+"
	byte	0
LR__4378
	byte	"-"
	byte	0
LR__4379
	byte	"or"
	byte	0
LR__4380
	byte	"xor"
	byte	0
LR__4381
	byte	"*"
	byte	0
LR__4382
	byte	"/"
	byte	0
LR__4383
	byte	"and"
	byte	0
LR__4384
	byte	"div"
	byte	0
LR__4385
	byte	"mod"
	byte	0
LR__4386
	byte	"shl"
	byte	0
LR__4387
	byte	"shr"
	byte	0
LR__4388
	byte	"^"
	byte	0
LR__4389
	byte	"not"
	byte	0
LR__4390
	byte	"@"
	byte	0
LR__4391
	byte	"="
	byte	0
LR__4392
	byte	">="
	byte	0
LR__4393
	byte	"<="
	byte	0
LR__4394
	byte	"<"
	byte	0
LR__4395
	byte	">"
	byte	0
LR__4396
	byte	"<>"
	byte	0
LR__4397
	byte	"++"
	byte	0
LR__4398
	byte	"--"
	byte	0
LR__4399
	byte	"+"
	byte	0
LR__4400
	byte	"-"
	byte	0
LR__4401
	byte	"="
	byte	0
LR__4402
	byte	","
	byte	0
LR__4403
	byte	"*"
	byte	0
LR__4404
	byte	"/"
	byte	0
LR__4405
	byte	";"
	byte	0
LR__4406
	byte	34
	byte	0
LR__4407
	byte	"^"
	byte	0
LR__4408
	byte	")"
	byte	0
LR__4409
	byte	"("
	byte	0
LR__4410
	byte	":"
	byte	0
LR__4411
	byte	" "
	byte	0
LR__4412
	byte	">"
	byte	0
LR__4413
	byte	"<"
	byte	0
LR__4414
	byte	"="
	byte	0
LR__4415
	byte	"beep"
	byte	0
LR__4416
	byte	"b."
	byte	0
LR__4417
	byte	"box"
	byte	0
LR__4418
	byte	"brun"
	byte	0
LR__4419
	byte	"br."
	byte	0
LR__4420
	byte	"circle"
	byte	0
LR__4421
	byte	"ci."
	byte	0
LR__4422
	byte	"click"
	byte	0
LR__4423
	byte	"cls"
	byte	0
LR__4424
	byte	"color"
	byte	0
LR__4425
	byte	"c."
	byte	0
LR__4426
	byte	"csave"
	byte	0
LR__4427
	byte	"cs."
	byte	0
LR__4428
	byte	"cursor"
	byte	0
LR__4429
	byte	"defsnd"
	byte	0
LR__4430
	byte	"defenv"
	byte	0
LR__4431
	byte	"defsprite"
	byte	0
LR__4432
	byte	"ds."
	byte	0
LR__4433
	byte	"deg"
	byte	0
LR__4434
	byte	"dim"
	byte	0
LR__4435
	byte	"dir"
	byte	0
LR__4436
	byte	"draw"
	byte	0
LR__4437
	byte	"dr."
	byte	0
LR__4438
	byte	"else"
	byte	0
LR__4439
	byte	"fcircle"
	byte	0
LR__4440
	byte	"fc."
	byte	0
LR__4441
	byte	"fill"
	byte	0
LR__4442
	byte	"fi."
	byte	0
LR__4443
	byte	"font"
	byte	0
LR__4444
	byte	"for"
	byte	0
LR__4445
	byte	"f."
	byte	0
LR__4446
	byte	"frame"
	byte	0
LR__4447
	byte	"fr."
	byte	0
LR__4448
	byte	"goto"
	byte	0
LR__4449
	byte	"g."
	byte	0
LR__4450
	byte	"if"
	byte	0
LR__4451
	byte	"ink"
	byte	0
LR__4452
	byte	"i."
	byte	0
LR__4453
	byte	"int"
	byte	0
LR__4454
	byte	"list"
	byte	0
LR__4455
	byte	"l."
	byte	0
LR__4456
	byte	"load"
	byte	0
LR__4457
	byte	"lo."
	byte	0
LR__4458
	byte	"mode"
	byte	0
LR__4459
	byte	"m."
	byte	0
LR__4460
	byte	"mouse"
	byte	0
LR__4461
	byte	"new"
	byte	0
LR__4462
	byte	"next"
	byte	0
LR__4463
	byte	"n."
	byte	0
LR__4464
	byte	"paper"
	byte	0
LR__4465
	byte	"p."
	byte	0
LR__4466
	byte	"pinfloat"
	byte	0
LR__4467
	byte	"pinhi"
	byte	0
LR__4468
	byte	"pinlo"
	byte	0
LR__4469
	byte	"pinstart"
	byte	0
LR__4470
	byte	"pintoggle"
	byte	0
LR__4471
	byte	"pinwrite"
	byte	0
LR__4472
	byte	"play"
	byte	0
LR__4473
	byte	"plot"
	byte	0
LR__4474
	byte	"pl."
	byte	0
LR__4475
	byte	"position"
	byte	0
LR__4476
	byte	"pos."
	byte	0
LR__4477
	byte	"print"
	byte	0
LR__4478
	byte	"?"
	byte	0
LR__4479
	byte	"rad"
	byte	0
LR__4480
	byte	"run"
	byte	0
LR__4481
	byte	"save"
	byte	0
LR__4482
	byte	"s."
	byte	0
LR__4483
	byte	"sound"
	byte	0
LR__4484
	byte	"so."
	byte	0
LR__4485
	byte	"sprite"
	byte	0
LR__4486
	byte	"sp."
	byte	0
LR__4487
	byte	"then"
	byte	0
LR__4488
	byte	"waitms"
	byte	0
LR__4489
	byte	"waitclock"
	byte	0
LR__4490
	byte	"wc."
	byte	0
LR__4491
	byte	"waitvbl"
	byte	0
LR__4492
	byte	"wv."
	byte	0
LR__4493
	byte	"wxpin"
	byte	0
LR__4494
	byte	"wypin"
	byte	0
LR__4495
	byte	"acos"
	byte	0
LR__4496
	byte	"asin"
	byte	0
LR__4497
	byte	"atn"
	byte	0
LR__4498
	byte	"cos"
	byte	0
LR__4499
	byte	"getpixel"
	byte	0
LR__4500
	byte	"ge."
	byte	0
LR__4501
	byte	"gettime"
	byte	0
LR__4502
	byte	"mousek"
	byte	0
LR__4503
	byte	"mousew"
	byte	0
LR__4504
	byte	"mousex"
	byte	0
LR__4505
	byte	"mousey"
	byte	0
LR__4506
	byte	"pinread"
	byte	0
LR__4507
	byte	"rdpin"
	byte	0
LR__4508
	byte	"rqpin"
	byte	0
LR__4509
	byte	"rnd"
	byte	0
LR__4510
	byte	"sin"
	byte	0
LR__4511
	byte	"sqr"
	byte	0
LR__4512
	byte	"stick"
	byte	0
LR__4513
	byte	"strig"
	byte	0
LR__4514
	byte	"tan"
	byte	0
LR__4515
	byte	"a"
	byte	0
LR__4516
	byte	"z"
	byte	0
LR__4517
	byte	"_"
	byte	0
LR__4518
	byte	"a"
	byte	0
LR__4519
	byte	"z"
	byte	0
LR__4520
	byte	"0"
	byte	0
LR__4521
	byte	"9"
	byte	0
LR__4522
	byte	"_"
	byte	0
LR__4523
	byte	"."
	byte	0
LR__4524
	byte	"a"
	byte	0
LR__4525
	byte	"z"
	byte	0
LR__4526
	byte	"0"
	byte	0
LR__4527
	byte	"9"
	byte	0
LR__4528
	byte	"_"
	byte	0
LR__4529
	byte	"$"
	byte	0
LR__4530
	byte	"%"
	byte	0
LR__4531
	byte	"!"
	byte	0
LR__4532
	byte	"0"
	byte	0
LR__4533
	byte	"9"
	byte	0
LR__4534
	byte	"."
	byte	0
LR__4535
	byte	"$"
	byte	0
LR__4536
	byte	"%"
	byte	0
LR__4537
	byte	"-"
	byte	0
LR__4538
	byte	"."
	byte	0
LR__4539
	byte	"0"
	byte	0
LR__4540
	byte	"9"
	byte	0
LR__4541
	byte	"_"
	byte	0
LR__4542
	byte	"."
	byte	0
LR__4543
	byte	"E"
	byte	0
LR__4544
	byte	"e"
	byte	0
LR__4545
	byte	"-"
	byte	0
LR__4546
	byte	"-"
	byte	0
LR__4547
	byte	"e"
	byte	0
LR__4548
	byte	"."
	byte	0
LR__4549
	byte	"E"
	byte	0
LR__4550
	byte	"e"
	byte	0
LR__4551
	byte	"0"
	byte	0
LR__4552
	byte	"9"
	byte	0
LR__4553
	byte	"$"
	byte	0
LR__4554
	byte	"%"
	byte	0
LR__4555
	byte	"-"
	byte	0
LR__4556
	byte	"0"
	byte	0
LR__4557
	byte	"9"
	byte	0
LR__4558
	byte	"_"
	byte	0
LR__4559
	byte	"0"
	byte	0
LR__4560
	byte	"9"
	byte	0
LR__4561
	byte	"_"
	byte	0
LR__4562
	byte	34
	byte	0
LR__4563
	byte	34
	byte	0
LR__4564
	byte	"Dim: at line "
	byte	0
LR__4565
	byte	": warning: the variable existed."
	byte	0
LR__4566
	byte	"("
	byte	0
LR__4567
	byte	"as"
	byte	0
LR__4568
	byte	"as"
	byte	0
LR__4569
	byte	","
	byte	0
LR__4570
	byte	")"
	byte	0
LR__4571
	byte	")"
	byte	0
LR__4572
	byte	"as"
	byte	0
LR__4573
	byte	"byte"
	byte	0
LR__4574
	byte	"ubyte"
	byte	0
LR__4575
	byte	"short"
	byte	0
LR__4576
	byte	"ushort"
	byte	0
LR__4577
	byte	"long"
	byte	0
LR__4578
	byte	"integer"
	byte	0
LR__4579
	byte	"ulong"
	byte	0
LR__4580
	byte	"int64"
	byte	0
LR__4581
	byte	"uint64"
	byte	0
LR__4582
	byte	"single"
	byte	0
LR__4583
	byte	"double"
	byte	0
LR__4584
	byte	"string"
	byte	0
LR__4585
	byte	"to"
	byte	0
LR__4586
	byte	"step"
	byte	0
LR__4587
	byte	"s."
	byte	0
LR__4588
	byte	"We have a slow goto, todo  "
	byte	0
LR__4589
	byte	"noname.bas"
	byte	0
LR__4590
	byte	
	byte	0
LR__4591
	byte	"noname.bas"
	byte	0
LR__4592
	byte	"/"
	byte	0
LR__4593
	byte	
	byte	0
LR__4594
	byte	
	byte	0
LR__4595
	byte	"noname.bas"
	byte	0
LR__4596
	byte	"/"
	byte	0
LR__4597
	byte	"System error "
	byte	0
LR__4598
	byte	": "
	byte	0
LR__4599
	byte	"/"
	byte	0
LR__4600
	byte	"0"
	byte	0
LR__4601
	byte	"9"
	byte	0
LR__4602
	byte	
	byte	0
LR__4603
	byte	"Stopped at line "
	byte	0
LR__4604
	byte	
	byte	0
LR__4605
	byte	
	byte	0
LR__4606
	byte	"/sd/media/h/"
	byte	0
LR__4607
	byte	"System error "
	byte	0
LR__4608
	byte	": "
	byte	0
LR__4609
	byte	
	byte	0
LR__4610
	byte	
	byte	0
LR__4611
	byte	"/sd/media/s/"
	byte	0
LR__4612
	byte	"System error "
	byte	0
LR__4613
	byte	": "
	byte	0
LR__4614
	byte	"Error "
	byte	0
LR__4615
	byte	": "
	byte	0
LR__4616
	byte	
	byte	0
LR__4617
	byte	"rnd: "
	byte	0
LR__4618
	byte	"rnd: "
	byte	0
LR__4619
	byte	"sin: "
	byte	0
LR__4620
	byte	"cos: "
	byte	0
LR__4621
	byte	"tan: "
	byte	0
LR__4622
	byte	"asin: "
	byte	0
LR__4623
	byte	"acos: "
	byte	0
LR__4624
	byte	"atn: "
	byte	0
LR__4625
	byte	"sqr: "
	byte	0
LR__4626
	byte	"stick: "
	byte	0
LR__4627
	byte	"strig: "
	byte	0
LR__4628
	byte	"getpixel: "
	byte	0
LR__4629
	byte	
	byte	0
LR__4630
	byte	"/sd/bas"
	byte	0
LR__4631
	byte	"Working directory: "
	byte	0
LR__4632
	byte	"*"
	byte	0
LR__4633
	byte	
	byte	0
LR__4634
	byte	"[dir] "
	byte	0
LR__4635
	byte	"*"
	byte	0
LR__4636
	byte	
	byte	0
LR__4637
	byte	"-----more, press any key"
	byte	0
LR__4638
	byte	"                             "
	byte	0
LR__4639
	byte	"/"
	byte	0
LR__4640
	byte	"/sd/bin/"
	byte	0
LR__4641
	byte	"System error "
	byte	0
LR__4642
	byte	": "
	byte	0
LR__4643
	byte	
	byte	0
LR__4644
	byte	"Expected number, got something else."
	byte	0
LR__4645
	byte	"Cannot add a number to a string."
	byte	0
LR__4646
	byte	"Cannot substract strings."
	byte	0
LR__4647
	byte	"Unknown error while adding."
	byte	0
LR__4648
	byte	"Unknown error while substracting."
	byte	0
LR__4649
	byte	"Cannot do logic operation on string or float."
	byte	0
LR__4650
	byte	"Unknown error while doing logic operation."
	byte	0
LR__4651
	byte	"Cannot multiply strings."
	byte	0
LR__4652
	byte	"Unknown error while multiplying."
	byte	0
LR__4653
	byte	"Cannot divide strings."
	byte	0
LR__4654
	byte	"Unknown error while dividing."
	byte	0
LR__4655
	byte	"Cannot compute a power of a string."
	byte	0
LR__4656
	byte	"Unknown error while computing a power."
	byte	0
LR__4657
	byte	"Right parenthesis expected."
	byte	0
LR__4658
	byte	"Expected string."
	byte	0
LR__4659
	byte	"Expected float."
	byte	0
LR__4660
	byte	"Expected unsigned integer."
	byte	0
LR__4661
	byte	"Expected integer."
	byte	0
LR__4662
	byte	"No more variable slots."
	byte	0
LR__4663
	byte	"Variable not found."
	byte	0
LR__4664
	byte	"Comma expected."
	byte	0
LR__4665
	byte	"Comma or semicolon expected."
	byte	0
LR__4666
	byte	"Unknown command."
	byte	0
LR__4667
	byte	"Stack underflow."
	byte	0
LR__4668
	byte	"Cannot execute goto in the immediate mode."
	byte	0
LR__4669
	byte	"Cannot load from this file."
	byte	0
LR__4670
	byte	"The program is empty."
	byte	0
LR__4671
	byte	"If after if."
	byte	0
LR__4672
	byte	"Empty expression."
	byte	0
LR__4673
	byte	"String expected."
	byte	0
LR__4674
	byte	"Interpreter internal error."
	byte	0
LR__4675
	byte	"Expected assign."
	byte	0
LR__4676
	byte	"Expected 'to'."
	byte	0
LR__4677
	byte	"Expected integer variable."
	byte	0
LR__4678
	byte	"Uninitialized variable in 'next', use 'for' before."
	byte	0
LR__4679
	byte	"No more slots for 'for'."
	byte	0
LR__4680
	byte	"'Next' doesn't match 'for'."
	byte	0
LR__4681
	byte	"'Goto' target line not found."
	byte	0
LR__4682
	byte	"Bad number of parameters"
	byte	0
LR__4683
	byte	"Function undefined for strings"
	byte	0
LR__4684
	byte	"Bad parameter."
	byte	0
LR__4685
	byte	"Cannot declare an array: the variable exists."
	byte	0
LR__4686
	byte	"Expected '('."
	byte	0
LR__4687
	byte	"Expected ')' or ','."
	byte	0
LR__4688
	byte	"No more than 3 dimensions supported"
	byte	0
LR__4689
	byte	"Variable name expected"
	byte	0
LR__4690
	byte	"Type name expected"
	byte	0
LR__4691
	byte	"Type not supported yet"
	byte	0
LR__4692
	byte	"Array index out of bound"
	byte	0
LR__4693
	byte	"Error "
	byte	0
LR__4694
	byte	": "
	byte	0
LR__4695
	byte	"/sd"
	byte	0
LR__4696
	byte	"/sd/bas"
	byte	0
LR__4697
	byte	"/sd/bas"
	byte	0
LR__4698
	byte	" BASIC bytes free"
	byte	0
LR__4699
	byte	"Ready"
	byte	0
LR__4700
	byte	" "
	byte	0
LR__4701
	byte	" "
	byte	0
LR__4702
	byte	
	byte	0
LR__4703
	byte	
	byte	0
	alignl
_dat_
	byte	$00[16]
	byte	$61, $41, $17, $0e, $62, $42, $00, $00, $63, $43, $19, $10, $64, $44, $00, $00
	byte	$65, $45, $18, $0f, $66, $46, $00, $00, $67, $47, $00, $00, $68, $48, $00, $00
	byte	$69, $49, $00, $00, $6a, $4a, $00, $00, $6b, $4b, $00, $00, $6c, $4c, $1f, $16
	byte	$6d, $4d, $00, $00, $6e, $4e, $1a, $11, $6f, $4f, $1e, $15, $70, $50, $00, $00
	byte	$71, $51, $00, $00, $72, $52, $00, $00, $73, $53, $1b, $12, $74, $54, $00, $00
	byte	$75, $55, $00, $00, $76, $56, $00, $00, $77, $57, $00, $00, $78, $58, $1c, $13
	byte	$79, $59, $00, $00, $7a, $5a, $1d, $14, $31, $21, $04, $00, $32, $40, $05, $00
	byte	$33, $23, $06, $00, $34, $24, $07, $00, $35, $25, $08, $00, $36, $5e, $09, $00
	byte	$37, $26, $0a, $00, $38, $2a, $0b, $00, $39, $28, $0c, $00, $30, $29, $0d, $00
	byte	$8d, $8d, $00, $00, $9b, $9b, $00, $00, $88, $88, $00, $00, $89, $89, $00, $00
	byte	$20, $20, $00, $00, $2d, $5f, $00, $00, $3d, $2b, $00, $00, $5b, $7b, $00, $00
	byte	$5d, $7d, $00, $00, $5c, $7c, $00, $00, $23, $7e, $00, $00, $3b, $3a, $00, $00
	byte	$27, $22, $00, $00, $60, $7e, $03, $00, $2c, $3c, $00, $00, $2e, $3e, $00, $00
	byte	$2f, $3f, $00, $00, $b9, $b9, $00, $00, $ba, $00, $00, $00, $bb, $00, $00, $00
	byte	$bc, $00, $00, $00, $bd, $00, $00, $00, $be, $00, $00, $00, $bf, $00, $00, $00
	byte	$c0, $00, $00, $00, $c1, $00, $00, $00, $c2, $00, $00, $00, $c3, $00, $00, $00
	byte	$c4, $00, $00, $00, $c5, $00, $00, $00, $c6, $00, $00, $00, $c7, $00, $00, $00
	byte	$c8, $00, $00, $00, $c9, $00, $00, $00, $ca, $00, $00, $00, $cb, $00, $00, $00
	byte	$7f, $7f, $00, $00, $cc, $00, $00, $00, $cd, $00, $00, $00, $ce, $00, $00, $00
	byte	$cf, $00, $00, $00, $d0, $00, $00, $00, $d1, $00, $00, $00, $d2, $00, $00, $00
	byte	$2f, $2f, $00, $00, $2a, $2a, $00, $00, $2d, $2d, $00, $00, $2b, $2b, $00, $00
	byte	$8d, $8d, $00, $00, $31, $31, $00, $00, $32, $32, $00, $00, $33, $33, $00, $00
	byte	$34, $34, $00, $00, $35, $35, $00, $00, $36, $36, $00, $00, $37, $37, $00, $00
	byte	$38, $38, $00, $00, $39, $39, $00, $00, $30, $30, $00, $00, $2e, $7f, $00, $00
	byte	$5c, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3d, $3d, $00, $00
	byte	$00[96]
'-' atari_spl file "atari.spl"
	byte	$2b, $00, $a6, $f2, $24, $a7, $09, $80, $5b, $88, $4d, $89, $80, $88, $a5, $88
	byte	$6d, $88, $b8, $88, $80, $88, $cb, $88, $92, $88, $a5, $88, $a5, $88, $b8, $88
	byte	$a5, $88, $ca, $88, $a6, $88, $dd, $88, $b8, $88, $ab, $89, $42, $87, $32, $84
	byte	$c8, $ad, $c6, $f1, $91, $06, $b6, $ff, $13, $00, $4a, $00, $71, $00, $5e, $00
	byte	$5d, $00, $5e, $00, $5d, $00, $5e, $00, $5e, $00, $5d, $00, $5e, $00, $71, $00
	byte	$38, $00, $83, $00, $25, $00, $83, $00, $c3, $fe, $d1, $04, $96, $00, $27, $c3
	byte	$48, $88, $38, $85, $41, $8a, $cb, $88, $28, $89, $b8, $88, $28, $89, $f0, $88
	byte	$15, $89, $03, $89, $02, $89, $15, $89, $16, $89, $15, $89, $15, $89, $28, $89
	byte	$15, $89, $3a, $89, $72, $89, $e3, $89, $52, $83, $ad, $97, $c3, $dc, $a3, $06
	byte	$0c, $02, $b6, $ff, $e1, $00, $a8, $00, $f3, $00, $a8, $00, $e0, $00, $bb, $00
	byte	$ce, $00, $cd, $00, $cd, $00, $ba, $00, $e1, $00, $bb, $00, $f2, $00, $a8, $00
	byte	$df, $00, $c9, $ff, $e6, $01, $b6, $06, $ee, $dd, $8d, $98, $53, $83, $f5, $89
	byte	$97, $89, $73, $89, $3b, $89, $60, $89, $60, $89, $60, $89, $73, $89, $72, $89
	byte	$73, $89, $72, $89, $85, $89, $73, $89, $aa, $89, $60, $89, $bd, $89, $72, $89
	byte	$e8, $8a, $18, $86, $92, $88, $a5, $c2, $e0, $00, $c3, $05, $7d, $ff, $50, $01
	byte	$f2, $00, $64, $01, $06, $01, $3e, $01, $2b, $01, $2b, $01, $2b, $01, $2b, $01
	byte	$2b, $01, $2a, $01, $2b, $01, $2b, $01, $2b, $01, $18, $01, $cd, $00, $5d, $00
	byte	$39, $07, $61, $f3, $c0, $af, $37, $85, $0f, $88, $8b, $8a, $ab, $89, $d0, $89
	byte	$ab, $89, $d0, $89, $ab, $89, $d0, $89, $d0, $89, $cf, $89, $d0, $89, $e3, $89
	byte	$d0, $89, $f5, $89, $bd, $89, $08, $8a, $cf, $89, $e8, $8a, $5a, $88, $82, $85
	byte	$53, $b3, $0d, $f8, $f4, $07, $38, $00, $63, $01, $63, $01, $9a, $01, $75, $01
	byte	$88, $01, $88, $01, $76, $01, $88, $01, $88, $01, $89, $01, $89, $01, $88, $01
	byte	$75, $01, $ae, $01, $76, $01, $88, $01, $4a, $00, $46, $06, $d0, $fd, $bf, $c0
	byte	$08, $8a, $9a, $86, $33, $8b, $08, $8a, $2d, $8a, $f5, $89, $2e, $8a, $08, $8a
	byte	$2d, $8a, $2d, $8a, $2e, $8a, $1b, $8a, $40, $8a, $2d, $8a, $53, $8a, $40, $8a
	byte	$2e, $8a, $79, $8a, $66, $8a, $c8, $8b, $72, $82, $2b, $97, $9a, $e2, $49, $0a
	byte	$1d, $02, $05, $01, $f8, $01, $c0, $01, $0b, $02, $c0, $01, $0b, $02, $d3, $01
	byte	$f9, $01, $d3, $01, $f8, $01, $d3, $01, $f8, $01, $d2, $01, $f8, $01, $d2, $01
	byte	$e6, $01, $2b, $01, $8e, $02, $5f, $07, $f7, $e2, $ed, $9c, $9c, $83, $d6, $8a
	byte	$e8, $8a, $78, $8a, $78, $8a, $65, $8a, $8b, $8a, $78, $8a, $9e, $8a, $8b, $8a
	byte	$8b, $8a, $9d, $8a, $9d, $8a, $8b, $8a, $c2, $8a, $78, $8a, $e8, $8a, $78, $8a
	byte	$70, $8c, $18, $86, $8b, $8a, $23, $c9, $cb, $03, $c4, $05, $e0, $00, $68, $02
	byte	$0b, $02, $7b, $02, $1e, $02, $55, $02, $30, $02, $43, $02, $43, $02, $43, $02
	byte	$43, $02, $44, $02, $43, $02, $30, $02, $68, $02, $31, $02, $31, $02, $3e, $01
	byte	$07, $08, $3f, $f7, $73, $b2, $13, $85, $15, $89, $ed, $8b, $9d, $8a, $fb, $8a
	byte	$b0, $8a, $fb, $8a, $d5, $8a, $fa, $8a, $e8, $8a, $fb, $8a, $fb, $8a, $0e, $8b
	byte	$e8, $8a, $21, $8b, $e7, $8a, $33, $8b, $e8, $8a, $26, $8c, $be, $89, $ff, $84
	byte	$8d, $b0, $27, $f6, $9c, $08, $ad, $01, $7b, $02, $8d, $02, $c6, $02, $8e, $02
	byte	$a1, $02, $a0, $02, $a1, $02, $a0, $02, $a0, $02, $a0, $02, $8e, $02, $b4, $02
	byte	$7b, $02, $d8, $02, $7b, $02, $c6, $02, $3e, $01, $c3, $05, $f6, $04, $0f, $cc
	byte	$00, $8c, $2a, $86, $e0, $8c, $fa, $8a, $6a, $8b, $fb, $8a, $58, $8b, $33, $8b
	byte	$45, $8b, $45, $8b, $45, $8b, $6b, $8b, $46, $8b, $59, $8b, $58, $8b, $6b, $8b
	byte	$6b, $8b, $6b, $8b, $6b, $8b, $6b, $8b, $7d, $8b, $7d, $8b, $7d, $8b, $7d, $8b
	byte	$90, $8b, $91, $8b, $90, $8b, $90, $8b, $a3, $8b, $a3, $8b, $a3, $8b, $a3, $8b
	byte	$b5, $8b, $b6, $8b, $b5, $8b, $b5, $8b, $b6, $8b, $c8, $8b, $c9, $8b, $c8, $8b
	byte	$c8, $8b, $da, $8b, $db, $8b, $db, $8b, $db, $8b, $dc, $8b, $ee, $8b, $ee, $8b
	byte	$ee, $8b, $ee, $8b, $00, $8c, $01, $8c, $00, $8c, $01, $8c, $00, $8c, $13, $8c
	byte	$12, $8c, $13, $8c, $13, $8c, $26, $8c, $26, $8c, $26, $8c, $26, $8c, $39, $8c
	byte	$38, $8c, $38, $8c, $38, $8c, $38, $8c, $4b, $8c, $4b, $8c, $4b, $8c, $4c, $8c
	byte	$5e, $8c, $5e, $8c, $5e, $8c, $5e, $8c, $70, $8c, $70, $8c, $71, $8c, $70, $8c
	byte	$70, $8c, $83, $8c, $83, $8c, $83, $8c, $83, $8c, $96, $8c, $95, $8c, $96, $8c
	byte	$95, $8c, $a9, $8c, $a9, $8c, $a8, $8c, $a8, $8c, $a8, $8c, $bb, $8c, $bb, $8c
	byte	$bb, $8c, $bb, $8c, $bb, $8c, $ce, $8c, $ce, $8c, $ce, $8c, $ce, $8c, $e0, $8c
	byte	$e0, $8c, $e1, $8c, $e1, $8c, $e0, $8c, $f4, $8c, $f2, $8c, $f2, $8c, $f3, $8c
	byte	$05, $8d, $05, $8d, $06, $8d, $06, $8d, $19, $8d, $19, $8d, $18, $8d, $18, $8d
	byte	$18, $8d, $2b, $8d, $2b, $8d, $2b, $8d, $2a, $8d, $3e, $8d, $3e, $8d, $3f, $8d
	byte	$3e, $8d, $51, $8d, $50, $8d, $50, $8d, $50, $8d, $51, $8d, $62, $8d, $62, $8d
	byte	$63, $8d, $64, $8d, $76, $8d, $75, $8d, $75, $8d, $76, $8d, $89, $8d, $89, $8d
	byte	$88, $8d, $88, $8d, $89, $8d, $9b, $8d, $9a, $8d, $9b, $8d, $9b, $8d, $af, $8d
	byte	$ad, $8d, $ae, $8d, $ad, $8d, $ae, $8d, $c1, $8d, $c1, $8d, $c0, $8d, $c1, $8d
	byte	$d3, $8d, $d3, $8d, $d3, $8d, $d3, $8d, $d3, $8d, $e6, $8d, $e6, $8d, $e6, $8d
	byte	$e6, $8d, $e6, $8d, $f9, $8d, $f9, $8d, $f9, $8d, $f8, $8d, $0b, $8e, $0b, $8e
	byte	$0b, $8e, $0b, $8e, $1d, $8e, $1d, $8e, $1e, $8e, $1e, $8e, $1e, $8e, $30, $8e
	byte	$31, $8e, $31, $8e, $31, $8e, $42, $8e, $43, $8e, $43, $8e, $43, $8e, $43, $8e
	byte	$56, $8e, $56, $8e, $55, $8e, $56, $8e, $68, $8e, $69, $8e, $68, $8e, $68, $8e
	byte	$69, $8e, $7b, $8e, $7c, $8e, $7b, $8e, $7b, $8e, $8d, $8e, $8e, $8e, $8e, $8e
	byte	$8d, $8e, $a1, $8e, $a0, $8e, $a1, $8e, $a1, $8e, $a0, $8e, $b3, $8e, $b3, $8e
	byte	$b3, $8e, $b3, $8e, $c6, $8e, $c5, $8e, $c6, $8e, $c6, $8e, $c6, $8e, $d8, $8e
	byte	$d8, $8e, $d9, $8e, $d8, $8e, $ec, $8e, $eb, $8e, $ec, $8e, $eb, $8e, $eb, $8e
	byte	$fe, $8e, $fe, $8e, $fe, $8e, $fe, $8e, $10, $8f, $10, $8f, $11, $8f, $11, $8f
	byte	$11, $8f, $23, $8f, $24, $8f, $23, $8f, $24, $8f, $37, $8f, $37, $8f, $36, $8f
	byte	$36, $8f, $36, $8f, $48, $8f, $49, $8f, $49, $8f, $49, $8f, $5b, $8f, $5b, $8f
	byte	$5b, $8f, $5c, $8f, $5b, $8f, $6e, $8f, $6e, $8f, $6e, $8f, $6e, $8f, $6e, $8f
	byte	$81, $8f, $81, $8f, $81, $8f, $81, $8f, $93, $8f, $93, $8f, $94, $8f, $93, $8f
	byte	$93, $8f, $a6, $8f, $a6, $8f, $a6, $8f, $a6, $8f, $b9, $8f, $b9, $8f, $b9, $8f
	byte	$b9, $8f, $b9, $8f, $cc, $8f, $cb, $8f, $cb, $8f, $cc, $8f, $de, $8f, $de, $8f
	byte	$df, $8f, $de, $8f, $de, $8f, $f1, $8f, $f1, $8f, $f1, $8f, $f0, $8f, $04, $90
	byte	$03, $90, $04, $90, $04, $90, $04, $90, $16, $90, $17, $90, $16, $90, $16, $90
	byte	$29, $90, $28, $90, $29, $90, $28, $90, $29, $90, $3c, $90, $3c, $90, $3b, $90
	byte	$3c, $90, $4f, $90, $4e, $90, $4e, $90, $4e, $90, $4e, $90, $61, $90, $60, $90
	byte	$61, $90, $61, $90, $73, $90, $74, $90, $74, $90, $74, $90, $74, $90, $86, $90
	byte	$87, $90, $86, $90, $87, $90, $86, $90, $99, $90, $99, $90, $99, $90, $99, $90
	byte	$ab, $90, $ab, $90, $ac, $90, $ab, $90, $ab, $90, $bf, $90, $be, $90, $be, $90
	byte	$be, $90, $d1, $90, $d0, $90, $d1, $90, $d1, $90, $d1, $90, $e3, $90, $e3, $90
	byte	$e3, $90, $e4, $90, $f6, $90, $f6, $90, $f6, $90, $f6, $90, $f6, $90, $08, $91
	byte	$09, $91, $0a, $91, $0a, $91, $1c, $91, $1c, $91, $1c, $91, $1b, $91, $1c, $91
	byte	$2f, $91, $2e, $91, $2f, $91, $2f, $91, $2e, $91, $41, $91, $41, $91, $41, $91
	byte	$41, $91, $53, $91, $54, $91, $54, $91, $53, $91, $54, $91, $67, $91, $66, $91
	byte	$67, $91, $67, $91, $79, $91, $7a, $91, $79, $91, $78, $91, $7a, $91, $8b, $91
	byte	$8c, $91, $8b, $91, $8c, $91, $8c, $91, $9e, $91, $9e, $91, $9e, $91, $9e, $91
	byte	$b1, $91, $b1, $91, $b2, $91, $b1, $91, $b1, $91, $c4, $91, $c4, $91, $c5, $91
	byte	$c4, $91, $d6, $91, $d7, $91, $d7, $91, $d7, $91, $d6, $91, $e9, $91, $ea, $91
	byte	$ea, $91, $ea, $91, $ea, $91, $fc, $91, $fc, $91, $fb, $91, $fc, $91, $0e, $92
	byte	$0e, $92, $0f, $92, $0f, $92, $0e, $92, $21, $92, $21, $92, $22, $92, $21, $92
	byte	$21, $92, $34, $92, $33, $92, $34, $92, $34, $92, $47, $92, $47, $92, $46, $92
	byte	$46, $92, $47, $92, $59, $92, $59, $92, $59, $92, $59, $92, $59, $92, $6c, $92
	byte	$6c, $92, $6c, $92, $6b, $92, $7e, $92, $7e, $92, $7e, $92, $7f, $92, $7e, $92
	byte	$92, $92, $91, $92, $91, $92, $90, $92, $91, $92, $a4, $92, $a4, $92, $a4, $92
	byte	$a3, $92, $b6, $92, $b6, $92, $b7, $92, $b7, $92, $b6, $92, $c9, $92, $c9, $92
	byte	$ca, $92, $c9, $92, $ca, $92, $dc, $92, $dc, $92, $dc, $92, $db, $92, $ee, $92
	byte	$ef, $92, $ef, $92, $ef, $92, $ef, $92, $01, $93, $01, $93, $01, $93, $02, $93
	byte	$15, $93, $14, $93, $14, $93, $14, $93, $14, $93, $27, $93, $26, $93, $27, $93
	byte	$27, $93, $39, $93, $3a, $93, $39, $93, $39, $93, $39, $93, $4c, $93, $4c, $93
	byte	$4b, $93, $4c, $93, $5f, $93, $5f, $93, $5f, $93, $5e, $93, $5e, $93, $71, $93
	byte	$5f, $93, $84, $93, $4c, $93, $96, $93, $5f, $93, $ae, $94, $e4, $90, $29, $90
	byte	$7b, $c1, $00, $00
'-' atari2_spl file "atari2.spl" '1758
	byte	$7a, $d7, $00, $80, $87, $8a, $48, $8f, $ec, $8c, $76, $8d, $f2, $8c, $c0, $8d
	byte	$3c, $8d, $82, $8d, $42, $8d, $88, $8d, $8c, $8d, $8e, $8d, $92, $8d, $d8, $8d
	byte	$97, $8d, $de, $8d, $e1, $8d, $f1, $8e, $d8, $8c, $a3, $83, $45, $c0, $be, $3d
	byte	$65, $71, $c9, $65, $fc, $64, $c4, $65, $c1, $65, $bf, $65, $bc, $65, $fc, $65
	byte	$b6, $65, $b4, $65, $b2, $65, $ae, $65, $ac, $65, $ed, $65, $64, $65, $e7, $65
	byte	$5e, $65, $25, $66, $fa, $62, $23, $6b, $b5, $6c, $61, $0a, $d2, $94, $04, $85
	byte	$5d, $90, $be, $8d, $47, $8e, $c3, $8d, $09, $8e, $c9, $8d, $10, $8e, $13, $8e
	byte	$15, $8e, $19, $8e, $1b, $8e, $62, $8e, $64, $8e, $68, $8e, $28, $8e, $b2, $8e
	byte	$b5, $8e, $4c, $90, $fa, $84, $3c, $9d, $98, $13, $79, $6d, $18, $6b, $3a, $64
	byte	$d9, $66, $50, $66, $d4, $66, $4b, $66, $8c, $66, $46, $66, $86, $66, $84, $66
	byte	$81, $66, $3a, $66, $7c, $66, $36, $66, $76, $66, $30, $66, $71, $66, $1d, $65
	byte	$6b, $66, $88, $72, $bf, $37, $e7, $b7, $75, $83, $8b, $8e, $57, $8f, $90, $8e
	byte	$94, $8e, $96, $8e, $dd, $8e, $9c, $8e, $e2, $8e, $a2, $8e, $e9, $8e, $ec, $8e
	byte	$ee, $8e, $ae, $8e, $38, $8f, $b5, $8e, $3f, $8f, $fd, $8e, $1c, $91, $0f, $8b
	byte	$a5, $87, $1e, $e3, $6d, $5d, $fa, $71, $41, $64, $25, $67, $de, $66, $63, $67
	byte	$d9, $66, $1a, $67, $18, $67, $15, $67, $12, $67, $0f, $67, $0c, $67, $0a, $67
	byte	$07, $67, $c0, $66, $01, $67, $bc, $66, $b8, $66, $de, $64, $b8, $70, $40, $59
	byte	$43, $e5, $1f, $8b, $14, $8a, $f1, $90, $1c, $8f, $63, $8f, $df, $8e, $69, $8f
	byte	$29, $8f, $6e, $8f, $72, $8f, $75, $8f, $34, $8f, $be, $8f, $7e, $8f, $c3, $8f
	byte	$84, $8f, $87, $8f, $cc, $8f, $56, $90, $67, $91, $49, $80, $f5, $b3, $59, $3e
	byte	$46, $77, $a6, $66, $e8, $66, $b0, $67, $ad, $67, $ed, $67, $64, $67, $e9, $67
	byte	$a2, $67, $e3, $67, $9d, $67, $9a, $67, $98, $67, $94, $67, $92, $67, $d2, $67
	byte	$49, $67, $cd, $67, $28, $65, $5f, $6e, $82, $67, $3a, $01, $6c, $95, $fd, $87
	byte	$c2, $91, $a9, $8f, $ef, $8f, $ae, $8f, $f4, $8f, $b5, $8f, $f9, $8f, $fd, $8f
	byte	$01, $90, $03, $90, $07, $90, $09, $90, $0c, $90, $53, $90, $12, $90, $9c, $90
	byte	$18, $90, $44, $93, $85, $84, $d6, $9d, $87, $1f, $2f, $75, $e5, $6a, $23, $66
	byte	$c4, $68, $f6, $67, $be, $68, $f1, $67, $76, $68, $2e, $68, $6f, $68, $29, $68
	byte	$27, $68, $24, $68, $64, $68, $1e, $68, $5f, $68, $19, $68, $5a, $68, $06, $67
	byte	$dc, $68, $56, $72, $7e, $36, $c2, $b8, $d7, $84, $73, $90, $41, $91, $79, $90
	byte	$7b, $90, $7f, $90, $82, $90, $84, $90, $cb, $90, $8b, $90, $8e, $90, $90, $90
	byte	$d7, $90, $96, $90, $20, $91, $59, $90, $25, $91, $a2, $90, $8c, $93, $62, $8b
	byte	$d0, $89, $40, $ee, $12, $64, $c4, $71, $29, $66, $0c, $69, $82, $68, $4a, $69
	byte	$c0, $68, $02, $69, $fe, $68, $fb, $68, $f9, $68, $f6, $68, $f2, $68, $f1, $68
	byte	$ee, $68, $a8, $68, $2c, $69, $5f, $68, $e2, $68, $81, $66, $4c, $71, $5e, $5f
	byte	$1e, $eb, $a6, $8a, $73, $8b, $5e, $93, $7b, $90, $48, $91, $81, $90, $4e, $91
	byte	$0d, $91, $11, $91, $14, $91, $16, $91, $5c, $91, $1c, $91, $63, $91, $66, $91
	byte	$68, $91, $af, $91, $2a, $91, $b5, $91, $75, $91, $1a, $94, $ba, $87, $b7, $9a
	byte	$70, $0e, $cb, $6c, $5d, $6e, $c4, $67, $99, $69, $54, $69, $d8, $69, $4e, $69
	byte	$d2, $69, $49, $69, $89, $69, $86, $69, $40, $69, $c4, $69, $3b, $69, $bf, $69
	byte	$35, $69, $76, $69, $58, $67, $eb, $6d, $e9, $6d, $89, $0f, $73, $99, $46, $87
	byte	$33, $94, $94, $91, $d9, $91, $56, $91, $e0, $91, $9f, $91, $e5, $91, $e8, $91
	byte	$ec, $91, $ee, $91, $f1, $91, $f4, $91, $f7, $91, $3d, $92, $fc, $91, $42, $92
	byte	$46, $92, $21, $94, $11, $89, $a4, $9d, $fd, $0e, $8f, $6c, $73, $6f, $0e, $68
	byte	$28, $6a, $e1, $69, $65, $6a, $1f, $6a, $5f, $6a, $1a, $6a, $17, $6a, $13, $6a
	byte	$54, $6a, $0f, $6a, $4f, $6a, $09, $6a, $06, $6a, $03, $6a, $00, $6a, $76, $69
	byte	$23, $68, $69, $77, $3a, $4d, $38, $ca, $38, $86, $4e, $91, $6d, $93, $1e, $92
	byte	$64, $92, $24, $92, $6a, $92, $2a, $92, $70, $92, $30, $92, $76, $92, $79, $92
	byte	$7b, $92, $7e, $92, $c5, $92, $84, $92, $cb, $92, $8a, $92, $a9, $94, $9b, $8e
	byte	$4d, $8d, $f9, $e2, $97, $59, $fe, $74, $db, $68, $6d, $6a, $ae, $6a, $ef, $6a
	byte	$a8, $6a, $a5, $6a, $a3, $6a, $9f, $6a, $9d, $6a, $9b, $6a, $98, $6a, $95, $6a
	byte	$d6, $6a, $8f, $6a, $cf, $6a, $46, $6a, $ca, $6a, $e1, $67, $34, $73, $10, $67
	byte	$d3, $f7, $15, $92, $90, $8c, $bf, $94, $a6, $92, $eb, $92, $68, $92, $36, $93
	byte	$b1, $92, $f7, $92, $fa, $92, $fd, $92, $00, $93, $02, $93, $06, $93, $4c, $93
	byte	$4f, $93, $52, $93, $54, $93, $22, $94, $5a, $93, $8f, $88, $e9, $ba, $f7, $39
	byte	$1c, $77, $07, $6c, $e8, $69, $7a, $6b, $34, $6b, $75, $6b, $2e, $6b, $6f, $6b
	byte	$29, $6b, $26, $6b, $24, $6b, $21, $6b, $1d, $6b, $5e, $6b, $18, $6b, $59, $6b
	byte	$12, $6b, $52, $6b, $34, $69, $34, $6e, $ba, $73, $a4, $24, $99, $aa, $de, $88
	byte	$7a, $94, $b3, $93, $72, $93, $31, $93, $78, $93, $7a, $93, $7e, $93, $81, $93
	byte	$83, $93, $86, $93, $89, $93, $d0, $93, $d2, $93, $d5, $93, $94, $93, $1e, $94
	byte	$dd, $93, $40, $96, $30, $8b, $99, $9c, $52, $10, $94, $71, $91, $71, $63, $69
	byte	$46, $6c, $79, $6b, $40, $6c, $b7, $6b, $f7, $6b, $b1, $6b, $f1, $6b, $ef, $6b
	byte	$ec, $6b, $a5, $6b, $a2, $6b, $9f, $6b, $9d, $6b, $9a, $6b, $97, $6b, $0d, $6b
	byte	$c8, $6a, $e4, $76, $20, $4b, $f9, $ce, $2e, $8a, $1a, $92, $46, $95, $b5, $93
	byte	$fb, $93, $ba, $93, $01, $94, $03, $94, $4a, $94, $09, $94, $0c, $94, $0e, $94
	byte	$55, $94, $14, $94, $9e, $94, $1a, $94, $61, $94, $20, $94, $fa, $95, $5b, $93
	byte	$3e, $87, $e5, $cd, $5f, $50, $6c, $78, $b5, $6a, $04, $6c, $45, $6c, $85, $6c
	byte	$83, $6c, $7f, $6c, $7c, $6c, $36, $6c, $76, $6c, $74, $6c, $71, $6c, $6f, $6c
	byte	$6b, $6c, $25, $6c, $66, $6c, $1f, $6c, $1d, $6c, $41, $6a, $ff, $73, $48, $66
	byte	$ba, $fa, $fc, $94, $5b, $8d, $97, $96, $3b, $94, $c5, $94, $40, $94, $ca, $94
	byte	$89, $94, $8c, $94, $8f, $94, $92, $94, $94, $94, $db, $94, $9b, $94, $e1, $94
	byte	$e4, $94, $e7, $94, $2d, $95, $74, $95, $c8, $96, $15, $89, $e4, $ab, $5c, $29
	byte	$cb, $75, $31, $6f, $7e, $6b, $10, $6d, $c9, $6c, $0a, $6d, $c3, $6c, $05, $6d
	byte	$bd, $6c, $ff, $6c, $fb, $6c, $f9, $6c, $b2, $6c, $f3, $6c, $ac, $6c, $ed, $6c
	byte	$a7, $6c, $e8, $6c, $0d, $6b, $85, $6f, $c7, $74, $10, $28, $2e, $ac, $21, $89
	byte	$96, $96, $47, $95, $06, $95, $0a, $95, $0c, $95, $0f, $95, $12, $95, $14, $95
	byte	$17, $95, $5e, $95, $61, $95, $63, $95, $22, $95, $ac, $95, $28, $95, $b1, $95
	byte	$72, $95, $17, $98, $59, $8e, $01, $96, $cf, $fc, $5a, $68, $fe, $74, $7e, $6b
	byte	$96, $6d, $50, $6d, $d5, $6d, $4a, $6d, $8c, $6d, $89, $6d, $85, $6d, $82, $6d
	byte	$80, $6d, $3a, $6d, $7a, $6d, $77, $6d, $75, $6d, $71, $6d, $2b, $6d, $e5, $6c
	byte	$18, $6c, $bc, $78, $9a, $4f, $7e, $cf, $1f, $89, $f1, $93, $1e, $97, $48, $95
	byte	$d2, $95, $4e, $95, $d7, $95, $53, $95, $dd, $95, $e0, $95, $e3, $95, $e5, $95
	byte	$a5, $95, $eb, $95, $ee, $95, $f0, $95, $37, $96, $b3, $95, $3c, $96, $3f, $96
	byte	$1a, $98, $d5, $8d, $c5, $9f, $cd, $0f, $0f, $71, $f3, $73, $c3, $6b, $63, $6e
	byte	$d9, $6d, $5e, $6e, $d3, $6d, $58, $6e, $12, $6e, $0f, $6e, $0c, $6e, $08, $6e
	byte	$49, $6e, $bf, $6d, $87, $6e, $76, $6d, $81, $6e, $11, $6b, $48, $74, $01, $74
	byte	$3f, $09, $44, $95, $e5, $8d, $3f, $99, $d4, $95, $a2, $96, $da, $95, $64, $96
	byte	$23, $96, $69, $96, $6b, $96, $6e, $96, $71, $96, $74, $96, $77, $96, $7a, $96
	byte	$bf, $96, $3c, $96, $c6, $96, $c8, $96, $a3, $98, $51, $8d, $51, $a5, $ee, $1b
	byte	$cf, $75, $29, $73, $90, $6c, $ec, $6e, $62, $6e, $e7, $6e, $5c, $6e, $e0, $6e
	byte	$9a, $6e, $98, $6e, $95, $6e, $91, $6e, $8e, $6e, $cf, $6e, $45, $6e, $c9, $6e
	byte	$40, $6e, $c3, $6e, $e8, $6c, $45, $6f, $a5, $7b, $c9, $35, $4e, $b3, $76, $8a
	byte	$2d, $98, $23, $97, $e1, $96, $a0, $96, $a4, $96, $ea, $96, $a9, $96, $ef, $96
	byte	$af, $96, $f4, $96, $f8, $96, $3e, $97, $fd, $96, $43, $97, $bf, $96, $8c, $97
	byte	$08, $97, $6b, $99, $d6, $92, $88, $91, $d8, $ee, $84, $66, $be, $79, $8e, $6c
	byte	$2e, $6f, $e7, $6e, $6c, $6f, $24, $6f, $21, $6f, $1f, $6f, $1c, $6f, $1a, $6f
	byte	$17, $6f, $13, $6f, $54, $6f, $0e, $6f, $0b, $6f, $4b, $6f, $c0, $6e, $bf, $6e
	byte	$27, $6d, $1c, $7b, $19, $59, $9f, $db, $66, $8e, $bc, $94, $b3, $98, $20, $97
	byte	$67, $97, $26, $97, $6d, $97, $2b, $97, $72, $97, $32, $97, $78, $97, $7a, $97
	byte	$c1, $97, $7f, $97, $c6, $97, $85, $97, $cb, $97, $ce, $97, $df, $98, $17, $98
	byte	$ec, $8a, $c4, $c6, $68, $4c, $f4, $7d, $63, $6e, $e8, $6e, $b0, $6f, $ac, $6f
	byte	$ed, $6f, $a7, $6f, $e7, $6f, $a0, $6f, $e1, $6f, $9b, $6f, $97, $6f, $94, $6f
	byte	$d5, $6f, $8f, $6f, $ce, $6f, $45, $6f, $86, $6f, $68, $6d, $09, $75, $dc, $71
	byte	$c0, $13, $ad, $a2, $a7, $8e, $79, $99, $e6, $97, $e8, $97, $a8, $97, $ee, $97
	byte	$f1, $97, $f3, $97, $f6, $97, $f9, $97, $fb, $97, $fe, $97, $01, $98, $04, $98
	byte	$4a, $98, $0a, $98, $93, $98, $0f, $98, $7f, $9b, $bf, $8c, $d8, $a1, $6d, $21
	byte	$91, $7b, $62, $73, $1a, $6e, $b9, $70, $eb, $6f, $b3, $70, $e6, $6f, $6a, $70
	byte	$25, $70, $20, $70, $1e, $70, $1b, $70, $18, $70, $15, $70, $12, $70, $0f, $70
	byte	$0d, $70, $09, $70, $07, $70, $03, $70, $01, $70, $fd, $6f, $fa, $6f, $f7, $6f
	byte	$f6, $6f, $f2, $6f, $ef, $6f, $ec, $6f, $2c, $70, $e6, $6f, $27, $70, $9d, $6f
	byte	$dd, $6f, $97, $6f, $d7, $6f, $84, $6e, $8f, $6f, $3f, $7d, $b7, $3d
'-' atarist_spl file "atarist.spl" '512
	byte	$ff[6]
	byte	$00[10]
	byte	$17, $7f, $f2, $7f, $b2, $7f, $72, $7f, $33, $7f, $f4, $7e, $b4, $7e, $75, $7e
	byte	$36, $7e, $f5, $7d, $e9, $51, $f2, $0d, $8e, $00, $f3, $fd, $72, $fd, $5a, $fd
	byte	$57, $fd, $58, $fd, $5b, $fd, $5c, $fd, $5c, $fd, $60, $7d, $52, $7d, $14, $7d
	byte	$d6, $7c, $98, $7c, $59, $7c, $1a, $7c, $dc, $7b, $9e, $7b, $61, $7b, $72, $34
	byte	$f3, $05, $00, $fd, $41, $fb, $ea, $fa, $d9, $fa, $db, $fa, $de, $fa, $e1, $fa
	byte	$e4, $fa, $9b, $36, $f8, $7a, $c0, $7a, $84, $7a, $45, $7a, $08, $7a, $cd, $79
	byte	$8e, $79, $51, $79, $15, $79, $d7, $78, $3c, $1f, $eb, $ff, $cf, $f9, $a5, $f8
	byte	$6d, $f8, $65, $f8, $68, $f8, $6d, $f8, $70, $f8, $74, $f8, $84, $57, $db, $60
	byte	$ab, $60, $79, $60, $4b, $60, $1a, $60, $e9, $5f, $b9, $5f, $89, $5f, $5a, $5f
	byte	$fb, $59, $b2, $0b, $92, $fa, $3a, $f7, $96, $f6, $79, $f6, $79, $f6, $7c, $f6
	byte	$82, $f6, $86, $f6, $8c, $f6, $db, $5d, $f1, $5e, $c1, $5e, $92, $5e, $63, $5e
	byte	$34, $5e, $04, $5e, $d6, $5d, $a6, $5d, $78, $5d, $d4, $3e, $11, $03, $63, $f7
	byte	$27, $f5, $ba, $f4, $ab, $f4, $ad, $f4, $b2, $f4, $b8, $f4, $be, $f4, $c3, $f4
	byte	$26, $5d, $2b, $5d, $fc, $5c, $cd, $5c, $9f, $5c, $70, $5c, $42, $5c, $15, $5c
	byte	$e5, $5b, $b8, $5b, $db, $24, $a7, $fc, $d1, $f4, $4d, $f3, $05, $f3, $fd, $f2
	byte	$04, $f3, $0b, $f3, $11, $f3, $16, $f3, $de, $18, $98, $5b, $73, $5b, $99, $54
	byte	$4e, $4a, $29, $48, $a0, $47, $6a, $47, $43, $47, $20, $47, $fd, $46, $35, $0d
	byte	$e2, $f6, $98, $f2, $c5, $f1, $a3, $f1, $a3, $f1, $a8, $f1, $b0, $f1, $b8, $f1
	byte	$bf, $f1, $00, $3d, $ef, $46, $cd, $46, $aa, $46, $86, $46, $63, $46, $3f, $46
	byte	$1c, $46, $f9, $45, $d7, $45, $ee, $43, $de, $02, $e8, $f3, $01, $f1, $76, $f0
	byte	$61, $f0, $65, $f0, $6d, $f0, $74, $f0, $7c, $f0, $84, $f0, $39, $44, $b1, $45
	byte	$8e, $45, $6d, $45, $49, $45, $27, $45, $05, $45, $e1, $44, $bf, $44, $9d, $44
	byte	$f1, $2f, $a9, $fb, $8b, $f1, $9b, $ef, $40, $ef, $36, $ef, $3d, $ef, $46, $ef
	byte	$4d, $ef, $56, $ef, $5e, $ef, $7b, $44, $8c, $44, $69, $44, $47, $44, $26, $44
	byte	$03, $44, $e1, $43, $c0, $43, $f5, $37, $69, $33, $0f, $11, $f0, $f4, $70, $ef
	byte	$66, $ee, $37, $ee, $38, $ee, $40, $ee, $48, $ee, $51, $ee, $5b, $ee, $18, $01
	byte	$7d, $32, $6a, $32, $51, $32, $37, $32, $1f, $32, $05, $32, $eb, $31, $d2, $31
	byte	$b9, $31, $a1, $31, $f1, $04, $f4, $f1, $50, $ee, $a0, $ed, $85, $ed, $88, $ed
	byte	$93, $ed, $9a, $ed, $a4, $ed, $ad, $ed, $f4, $27, $c1, $31, $a9, $31, $90, $31
	byte	$78, $31, $5f, $31, $46, $31, $2e, $31, $15, $31, $fc, $30, $e4, $30, $9b, $fc
	byte	$c4, $ef, $4a, $ed, $dc, $ec, $cb, $ec, $d2, $ec, $da, $ec, $e6, $ec, $ef, $ec
	byte	$f9, $ec, $64, $2f, $0a, $31, $f1, $30, $d9, $30, $c0, $30, $a7, $30, $91, $30
	byte	$78, $30, $5f, $30, $46, $30, $38, $23, $a6, $f6, $19, $ee, $70, $ec, $25, $ec
	byte	$20, $ec, $28, $ec, $32, $ec, $3c, $ec, $47, $ec, $51, $ec, $93, $22, $b5, $22
	byte	$a3, $22, $93, $22, $7f, $22, $6e, $22, $5d, $22, $4c, $22, $3c, $22, $2b, $22
	byte	$77, $09, $76, $f1, $cc, $ec, $f0, $eb, $cd, $eb, $ce, $eb, $d7, $eb, $e3, $eb
	byte	$ed, $eb, $f5, $eb, $3e, $f6, $6b, $22, $5f, $22, $4e, $22, $3d, $22, $2c, $22
	byte	$1b, $22, $0b, $22, $fa, $21, $e9, $21, $d8, $21, $4d, $ff, $44, $ef, $25, $ec
	byte	$92, $eb, $7b, $eb, $82, $eb, $8c, $eb, $97, $eb, $a1, $eb, $ab, $eb, $2e, $16
	byte	$15, $22, $04, $22, $f3, $21, $e3, $21, $d2, $21, $c0, $21, $af, $21, $9e, $21
	byte	$8e, $21, $7d, $21, $9a, $f8, $a4, $ed, $8e, $eb, $2f, $eb, $24, $eb, $2d, $eb
	byte	$37, $eb, $42, $eb, $4c, $eb, $57, $eb, $b2, $17, $22, $19, $15, $19, $0a, $19
	byte	$fd, $18, $ef, $18, $e3, $18, $d6, $18, $ca, $18, $bd, $18, $49, $12, $92, $f2
	byte	$60, $ec, $35, $eb, $01, $eb, $01, $eb, $0c, $eb, $16, $eb, $20, $eb, $2b, $eb
	byte	$34, $eb, $d0, $18, $00, $19, $f4, $18, $e8, $18, $da, $18, $cf, $18, $c2, $18
	byte	$b6, $18, $a9, $18, $9d, $18, $91, $05, $f0, $ef, $ca, $eb, $02, $eb, $e6, $ea
	byte	$e8, $ea, $f2, $ea, $fe, $ea, $07, $eb, $12, $eb, $c2, $ef, $e9, $18, $e6, $18
	byte	$d9, $18, $cd, $18, $c0, $18, $b3, $18, $a7, $18, $9b, $18, $8e, $18, $83, $18
	byte	$b8, $fc, $30, $ee, $61, $eb, $dc, $ea, $cd, $ea, $d2, $ea, $de, $ea, $e7, $ea
	byte	$f3, $ea, $fe, $ea, $d2, $09, $d1, $18, $c3, $18, $17, $18, $c7, $12, $a5, $11
	byte	$66, $11, $52, $11, $49, $11, $41, $11, $38, $11, $e0, $f4, $a5, $ec, $13, $eb
	byte	$c9, $ea, $c5, $ea, $cf, $ea, $db, $ea, $e6, $ea, $ef, $ea, $fb, $ea, $0e, $10
	byte	$89, $11, $80, $11, $78, $11, $6e, $11, $67, $11, $5d, $11, $54, $11, $4c, $11
	byte	$43, $11, $32, $0d, $9c, $f1, $07, $ec, $f8, $ea, $cd, $ea, $cc, $ea, $d8, $ea
	byte	$e4, $ea, $ed, $ea, $f8, $ea, $02, $eb, $55, $11, $91, $11, $89, $11, $80, $11
	byte	$75, $11, $6e, $11, $64, $11, $5e, $11, $54, $11, $4a, $11, $bc, $02, $5e, $ef
	byte	$a8, $eb, $f1, $ea, $d9, $ea, $dc, $ea, $e8, $ea, $f1, $ea, $fc, $ea, $06, $eb
	byte	$a6, $eb, $9e, $11, $a0, $11, $96, $11, $8d, $11, $85, $11, $7b, $11, $72, $11
	byte	$6a, $11, $ca, $0d, $36, $0b, $57, $f8, $6c, $ed, $57, $eb, $f8, $ea, $ee, $ea
	byte	$f4, $ea, $ff, $ea, $09, $eb, $15, $eb, $1e, $eb, $1a, $fd, $f9, $0a, $f2, $0a
	byte	$ed, $0a, $e8, $0a, $e2, $0a, $dc, $0a, $d6, $0a, $d1, $0a, $cd, $0a, $c7, $0a
	byte	$f8, $f3, $bc, $ec, $57, $eb, $1e, $eb, $18, $eb, $24, $eb, $2d, $eb, $39, $eb
	byte	$42, $eb, $4d, $eb, $08, $09, $20, $0b, $1a, $0b, $14, $0b, $0f, $0b, $09, $0b
	byte	$04, $0b, $fe, $0a, $f9, $0a, $f2, $0a, $84, $08, $3a, $f1, $4f, $ec, $66, $eb
	byte	$42, $eb, $42, $eb, $4e, $eb, $57, $eb, $62, $eb, $6b, $eb, $77, $eb, $06, $0b
	byte	$48, $0b, $43, $0b, $3c, $0b, $36, $0b, $31, $0b, $2c, $0b, $26, $0b, $20, $0b
	byte	$1b, $0b, $5c, $00, $6a, $ef, $1b, $ec, $81, $eb, $6a, $eb, $6f, $eb, $79, $eb
	byte	$85, $eb, $8e, $eb, $99, $eb, $a3, $eb, $dd, $05, $e5, $05, $e1, $05, $df, $05
	byte	$db, $05, $d8, $05, $d5, $05, $d1, $05, $d0, $05, $cb, $05, $63, $f7, $da, $ed
	byte	$0c, $ec, $bb, $eb, $b3, $eb, $bb, $eb, $c5, $eb, $d0, $eb, $d9, $eb, $e3, $eb
	byte	$e4, $f7, $2c, $06, $28, $06, $24, $06, $22, $06, $1f, $06, $1c, $06, $1a, $06
	byte	$16, $06, $14, $06, $0f, $06, $d0, $f3, $65, $ed, $2d, $ec, $f9, $eb, $f6, $eb
	byte	$01, $ec, $0a, $ec, $14, $ec, $1e, $ec, $29, $ec, $fb, $03, $6a, $06, $67, $06
	byte	$63, $06, $60, $06, $5e, $06, $59, $06, $58, $06, $54, $06, $50, $06, $12, $05
	byte	$69, $f1, $21, $ed, $55, $ec, $33, $ec, $36, $ec, $40, $ec, $49, $ec, $53, $ec
	byte	$5c, $ec, $68, $ec, $92, $02, $d9, $02, $d7, $02, $d7, $02, $d5, $02, $d3, $02
	byte	$d1, $02, $d1, $02, $ce, $02, $cd, $02, $5d, $fc, $80, $ef, $07, $ed, $90, $ec
	byte	$83, $ec, $8a, $ec, $93, $ec, $9c, $ec, $a5, $ec, $b1, $ec, $ba, $ec, $24, $03
	byte	$2b, $03, $2a, $03, $29, $03, $26, $03, $25, $03, $24, $03, $22, $03, $20, $03
	byte	$1f, $03, $70, $f7, $d0, $ee, $27, $ed, $db, $ec, $d4, $ec, $dd, $ec, $e7, $ec
	byte	$f0, $ec, $fa, $ec, $02, $ed, $f9, $f4, $7b, $03, $7c, $03, $7a, $03, $78, $03
	byte	$75, $03, $73, $03, $72, $03, $70, $03, $6d, $03, $6c, $03, $4f, $f4, $70, $ee
	byte	$54, $ed, $22, $ed, $22, $ed, $2c, $ed, $35, $ed, $3f, $ed, $48, $ed, $52, $ed
	byte	$14, $01, $c3, $03, $c1, $03, $c0, $03, $5f, $01, $a5, $00, $82, $00, $7b, $00
	byte	$7b, $00, $7c, $00, $20, $00, $85, $f1, $2a, $ee, $89, $ed, $73, $ed, $76, $ed
	byte	$80, $ed, $87, $ed, $90, $ed, $9a, $ed, $a3, $ed, $73, $00, $d2, $00, $d2, $00
	byte	$d0, $00, $d0, $00, $d0, $00, $d0, $00, $d0, $00, $cf, $00, $ce, $00, $48, $fc
	byte	$80, $f0, $3d, $ee, $d5, $ed, $c7, $ed, $cd, $ed, $d6, $ed, $df, $ed, $e9, $ed
	byte	$f2, $ed, $fa, $ed, $1d, $01, $29, $01, $27, $01, $27, $01, $27, $01, $25, $01
	byte	$25, $01, $26, $01, $26, $01, $23, $01, $d0, $f7, $ec, $ef, $65, $ee, $23, $ee
	byte	$1c, $ee, $24, $ee, $2d, $ee, $37, $ee, $40, $ee, $47, $ee, $6e, $f3, $7a, $01
	byte	$7d, $01, $7b, $01, $7a, $01, $7a, $01, $79, $01, $78, $01, $79, $01, $62, $00
	byte	$84, $fe, $de, $f3, $6c, $ef, $93, $ee, $72, $ee, $72, $ee, $7a, $ee, $85, $ee
	byte	$8b, $ee, $95, $ee, $9e, $ee, $15, $fc, $67, $fe, $67, $fe, $69, $fe, $69, $fe
	byte	$6b, $fe, $6b, $fe, $6d, $fe, $6d, $fe, $6d, $fe, $6f, $fe, $63, $f2, $6d, $ef
	byte	$df, $ee, $cc, $ee, $cf, $ee, $d9, $ee, $e1, $ee, $ea, $ee, $f2, $ee, $fc, $ee
	byte	$5a, $fe, $c4, $fe, $c3, $fe, $c5, $fe, $c6, $fe, $c6, $fe, $c6, $fe, $c7, $fe
	byte	$c8, $fe, $c7, $fe, $da, $fb, $85, $f1, $8d, $ef, $31, $ef, $25, $ef, $2d, $ef
	byte	$34, $ef, $3e, $ef, $46, $ef, $4f, $ef, $57, $ef, $0d, $ff, $1f, $ff, $1f, $ff
	byte	$1f, $ff, $1f, $ff, $21, $ff, $21, $ff, $21, $ff, $21, $ff, $23, $ff, $10, $f8
	byte	$15, $f1, $be, $ef, $84, $ef, $7e, $ef, $88, $ef, $8f, $ef, $97, $ef, $a0, $ef
	byte	$a9, $ef, $06, $f2, $a6, $fc, $ab, $fc, $ad, $fc, $ae, $fc, $b0, $fc, $b2, $fc
	byte	$b2, $fc, $b4, $fc, $b6, $fc, $b7, $fc, $8b, $f4, $bd, $f0, $01, $f0, $e3, $ef
	byte	$e4, $ef, $ee, $ef, $f6, $ef, $fd, $ef, $04, $f0, $0e, $f0, $11, $fa, $09, $fd
	byte	$0b, $fd, $0d, $fd, $0f, $fd, $11, $fd, $11, $fd, $13, $fd, $14, $fd, $17, $fd
	byte	$17, $fd, $64, $f3, $cd, $f0, $52, $f0, $41, $f0, $45, $f0, $4c, $f0, $55, $f0
	byte	$5b, $f0, $64, $f0, $6d, $f0, $fb, $fc, $65, $fd, $68, $fd, $69, $fd, $6c, $fd
	byte	$6c, $fd, $6d, $fd, $6f, $fd, $70, $fd, $72, $fd, $b3, $fb, $b1, $f2, $f4, $f0
	byte	$a4, $f0, $99, $f0, $a0, $f0, $a8, $f0, $ae, $f0, $b9, $f0, $c1, $f0, $c8, $f0
	byte	$cb, $fb, $dd, $fb, $de, $fb, $e0, $fb, $e3, $fb, $e3, $fb, $e5, $fb, $e8, $fb
	byte	$e9, $fb, $ec, $fb, $62, $f7, $27, $f2, $2a, $f1, $ff, $f0, $fd, $f0, $05, $f1
	byte	$0c, $f1, $13, $f1, $1b, $f1, $23, $f1, $33, $f2, $3c, $fc, $3e, $fc, $40, $fc
	byte	$42, $fc, $45, $fc, $47, $fc, $48, $fc, $4a, $fc, $4c, $fc, $4e, $fc, $a5, $f5
	byte	$20, $f2, $77, $f1, $5c, $f1, $5f, $f1, $64, $f1, $6c, $f1, $73, $f1, $7c, $f1
	byte	$83, $f1, $dc, $f8, $9a, $fc, $9a, $fc, $9b, $fc, $9e, $fc, $9f, $fc, $a1, $fc
	byte	$a3, $fc, $a4, $fc, $a6, $fc, $a9, $fc, $90, $f4, $33, $f2, $c5, $f1, $b6, $f1
	byte	$ba, $f1, $bf, $f1, $c7, $f1, $ce, $f1, $d6, $f1, $dc, $f1, $79, $fc, $f0, $fc
	byte	$f3, $fc, $f5, $fc, $fe, $fb, $79, $fb, $62, $fb, $5f, $fb, $61, $fb, $63, $fb
	byte	$6f, $fa, $af, $f3, $53, $f2, $12, $f2, $0f, $f2, $15, $f2, $1d, $f2, $24, $f2
	byte	$2a, $f2, $32, $f2, $38, $f2, $9a, $fb, $af, $fb, $b1, $fb, $b3, $fb, $b4, $fb
	byte	$b7, $fb, $b8, $fb, $ba, $fb, $bc, $fb, $c1, $fb, $3b, $f8, $7e, $f3, $96, $f2
	byte	$6e, $f2, $6c, $f2, $74, $f2, $7a, $f2, $81, $f2, $87, $f2, $8e, $f2, $a7, $f2
	byte	$06, $fc, $09, $fc, $0c, $fc, $0e, $fc, $0f, $fc, $12, $fc, $13, $fc, $16, $fc
	byte	$17, $fc, $1a, $fc, $b2, $f6, $7b, $f3, $dd, $f2, $c5, $f2, $c7, $f2, $cf, $f2
	byte	$d4, $f2, $db, $f2, $e0, $f2, $e8, $f2, $28, $f8, $60, $fc, $61, $fc, $62, $fc
	byte	$64, $fc, $66, $fc, $68, $fc, $6a, $fc, $6d, $fc, $52, $fc, $19, $fb, $4a, $f5
	byte	$78, $f3, $24, $f3, $1a, $f3, $1e, $f3, $24, $f3, $2a, $f3, $31, $f3, $38, $f3
	byte	$3d, $f3, $80, $fa, $0c, $fb, $0f, $fb, $10, $fb, $14, $fb, $15, $fb, $17, $fb
	byte	$1b, $fb, $1d, $fb, $1f, $fb, $92, $fa, $de, $f4, $ae, $f3, $79, $f3, $72, $f3
	byte	$79, $f3, $7e, $f3, $84, $f3, $8c, $f3, $92, $f3, $97, $f3, $52, $fb, $65, $fb
	byte	$67, $fb, $69, $fb, $6b, $fb, $6f, $fb, $71, $fb, $72, $fb, $74, $fb, $76, $fb
	byte	$e3, $f8, $ba, $f4, $ee, $f3, $cc, $f3, $ca, $f3, $cf, $f3, $d5, $f3, $dd, $f3
	byte	$e2, $f3, $e8, $f3, $ed, $f3, $b7, $fb, $bc, $fb, $be, $fb, $c0, $fb, $c1, $fb
	byte	$c4, $fb, $c6, $fb, $c8, $fb, $c9, $fb, $cc, $fb, $8f, $f7, $b9, $f4, $33, $f4
	byte	$1e, $f4, $1e, $f4, $24, $f4, $2a, $f4, $30, $f4, $38, $f4, $3e, $f4, $1f, $f7
	byte	$ad, $fa, $b1, $fa, $b4, $fa, $b6, $fa, $ba, $fa, $bb, $fa, $be, $fa, $c1, $fa
	byte	$c2, $fa, $c6, $fa, $55, $f6, $c6, $f4, $7d, $f4, $72, $f4, $78, $f4, $7e, $f4
	byte	$83, $f4, $89, $f4, $8f, $f4, $94, $f4, $66, $fa, $03, $fb, $07, $fb, $08, $fb
	byte	$0a, $fb, $0e, $fb, $10, $fb, $11, $fb, $16, $fb, $18, $fb, $d0, $fa, $02, $f6
	byte	$f9, $f4, $ca, $f4, $c5, $f4, $cb, $f4, $d1, $f4, $d7, $f4, $dc, $f4, $e1, $f4
	byte	$e8, $f4, $3f, $fb, $56, $fb, $58, $fb, $5a, $fb, $5e, $fb, $5f, $fb, $61, $fb
	byte	$64, $fb, $64, $fb, $69, $fb, $99, $f9, $e9, $f5, $33, $f5, $17, $f5, $17, $f5
	byte	$1d, $f5, $22, $f5, $27, $f5, $2e, $f5, $32, $f5, $37, $f5, $b3, $fa, $b6, $fa
	byte	$bc, $fa, $bc, $fa, $c1, $fa, $c2, $fa, $c4, $fa, $c8, $fa, $ca, $fa, $ce, $fa
	byte	$f9, $f7, $db, $f5, $78, $f5, $69, $f5, $6a, $f5, $70, $f5, $75, $f5, $7b, $f5
	byte	$7f, $f5, $85, $f5, $6e, $f7, $06, $fb, $0a, $fb, $0b, $fb, $0d, $fb, $12, $fb
	byte	$14, $fb, $15, $fb, $18, $fb, $1b, $fb, $1d, $fb, $70, $f7, $01, $f6, $c0, $f5
	byte	$b6, $f5, $bb, $f5, $c0, $f5, $c6, $f5, $ca, $f5, $cf, $f5, $d4, $f5, $a8, $fa
	byte	$54, $fb, $56, $fb, $5a, $fb, $5b, $fb, $5e, $fb, $5f, $fb, $63, $fb, $65, $fb
	byte	$67, $fb, $52, $fb, $29, $f7, $33, $f6, $06, $f6, $02, $f6, $08, $f6, $0b, $f6
	byte	$10, $f6, $16, $f6, $1a, $f6, $1f, $f6, $81, $fb, $9f, $fb, $a2, $fb, $a4, $fb
	byte	$51, $fb, $f2, $fa, $e3, $fa, $e3, $fa, $e5, $fa, $e9, $fa, $d2, $f9, $f0, $f6
	byte	$64, $f6, $4d, $f6, $4d, $f6, $53, $f6, $57, $f6, $5c, $f6, $60, $f6, $66, $f6
	byte	$6a, $f6, $19, $fb, $1e, $fb, $22, $fb, $23, $fb, $24, $fb, $26, $fb, $2a, $fb
	byte	$2c, $fb, $2e, $fb, $32, $fb, $f0, $f8, $01, $f7, $a5, $f6, $98, $f6, $9a, $f6
	byte	$9f, $f6, $a3, $f6, $a6, $f6, $ac, $f6, $b0, $f6, $eb, $f7, $65, $fb, $68, $fb
	byte	$68, $fb, $6c, $fb, $6e, $fb, $71, $fb, $72, $fb, $74, $fb, $78, $fb, $7a, $fb
	byte	$71, $f8, $21, $f7, $e5, $f6, $dd, $f6, $e1, $f6, $e6, $f6, $ea, $f6, $ef, $f6
	byte	$f5, $f6, $f7, $f6, $f7, $fa, $ab, $fb, $ad, $fb, $af, $fb, $b0, $fb, $b5, $fb
	byte	$b6, $fb, $b9, $fb, $bb, $fb, $bc, $fb, $21, $fb, $07, $f8, $46, $f7, $23, $f7
	byte	$22, $f7, $26, $f7, $2b, $f7, $2e, $f7, $34, $f7, $38, $f7, $3c, $f7, $f7, $fa
	byte	$13, $fb, $16, $fb, $17, $fb, $1b, $fb, $1e, $fb, $20, $fb, $23, $fb, $25, $fb
	byte	$26, $fb, $77, $fa, $f3, $f7, $7c, $f7, $67, $f7, $6a, $f7, $6d, $f7, $70, $f7
	byte	$74, $f7, $7a, $f7, $7e, $f7, $82, $f7, $53, $fb, $5a, $fb, $5b, $fb, $5d, $fb
	byte	$5f, $fb, $63, $fb, $65, $fb, $67, $fb, $69, $fb, $6a, $fb, $b9, $f9, $03, $f8
	byte	$b5, $f7, $a9, $f7, $ad, $f7, $b0, $f7, $b5, $f7, $b8, $f7, $be, $f7, $c3, $f7
	byte	$6e, $f8, $99, $fb, $9c, $fb, $9d, $fb, $9f, $fb, $a4, $fb, $a5, $fb, $a8, $fb
	byte	$a9, $fb, $ab, $fb, $ad, $fb, $46, $f9, $26, $f8, $f0, $f7, $ea, $f7, $f0, $f7
	byte	$f4, $f7, $f8, $f7, $fb, $f7, $ff, $f7, $03, $f8, $65, $fa, $26, $fb, $29, $fb
	byte	$2b, $fb, $2f, $fb, $30, $fb, $32, $fb, $34, $fb, $38, $fb, $39, $fb, $3b, $fb
	byte	$e9, $f8, $4a, $f8, $2e, $f8, $2c, $f8, $2f, $f8, $36, $f8, $3a, $f8, $3e, $f8
	byte	$41, $f8, $44, $f8, $4a, $fb, $67, $fb, $68, $fb, $6b, $fb, $6f, $fb, $70, $fb
	byte	$73, $fb, $74, $fb, $78, $fb, $7a, $fb, $14, $fb, $e7, $f8, $7d, $f8, $6d, $f8
	byte	$6d, $f8, $70, $f8, $73, $f8, $78, $f8, $7c, $f8, $80, $f8, $84, $f8, $9f, $fb
	byte	$a6, $fb, $a7, $fb, $a9, $fb, $ac, $fb, $af, $fb, $b1, $fb, $b3, $fb, $b4, $fb
	byte	$b7, $fb, $73, $fa, $f8, $f8, $b4, $f8, $a9, $f8, $ab, $f8, $af, $f8, $b1, $f8
	byte	$b4, $f8, $b8, $f8, $bb, $f8, $fa, $f8, $64, $fb, $65, $fb, $67, $fb, $6b, $fb
	byte	$6d, $fb, $6f, $fb, $70, $fb, $74, $fb, $77, $fb, $77, $fb, $e4, $f9, $0f, $f9
	byte	$e9, $f8, $e4, $f8, $e8, $f8, $eb, $f8, $ee, $f8, $f2, $f8, $f7, $f8, $fb, $f8
	byte	$b5, $fa, $9f, $fb, $a1, $fb, $a4, $fb, $a5, $fb, $a9, $fb, $ab, $fb, $ae, $fb
	byte	$ae, $fb, $b1, $fb, $b2, $fb, $c7, $f9, $39, $f9, $22, $f9, $20, $f9, $22, $f9
	byte	$26, $f9, $2a, $f9, $2e, $f9, $32, $f9, $33, $f9, $ba, $fb, $d8, $fb, $db, $fb
	byte	$de, $fb, $e1, $fb, $e2, $fb, $e4, $fb, $e5, $fb, $e7, $fb, $e9, $fb, $a7, $fb
	byte	$c5, $f9, $67, $f9, $57, $f9, $56, $f9, $5b, $f9, $5f, $f9, $62, $f9, $66, $f9
	byte	$68, $f9, $6c, $f9, $0b, $fc, $11, $fc, $14, $fc, $15, $fc, $07, $fc, $c2, $fb
	byte	$b5, $fb, $b5, $fb, $b6, $fb, $b8, $fb, $e9, $fa, $c8, $f9, $94, $f9, $8d, $f9
	byte	$90, $f9, $94, $f9, $95, $f9, $99, $f9, $9d, $f9, $9f, $f9, $a3, $f9, $dd, $fb
	byte	$de, $fb, $df, $fb, $e2, $fb, $e4, $fb, $e6, $fb, $e8, $fb, $e9, $fb, $ed, $fb
	byte	$ef, $fb, $ac, $fa, $e9, $f9, $c7, $f9, $c3, $f9, $c8, $f9, $ca, $f9, $cc, $f9
	byte	$d0, $f9, $d4, $f9, $d6, $f9, $0e, $fb, $11, $fc, $13, $fc, $16, $fc, $17, $fc
	byte	$19, $fc, $1b, $fc, $1d, $fc, $1e, $fc, $21, $fc, $22, $fc, $8d, $fa, $0f, $fa
	byte	$f7, $f9, $f7, $f9, $fb, $f9, $fe, $f9, $00, $fa, $03, $fa, $07, $fa, $0b, $fa
	byte	$1b, $fc, $45, $fc, $46, $fc, $48, $fc, $4a, $fc, $4b, $fc, $4e, $fc, $50, $fc
	byte	$52, $fc, $54, $fc, $f3, $fb, $82, $fa, $35, $fa, $28, $fa, $2a, $fa, $2d, $fa
	byte	$31, $fa, $32, $fa, $37, $fa, $37, $fa, $3c, $fa, $00, $fc, $06, $fc, $09, $fc
	byte	$09, $fc, $0b, $fc, $0f, $fc, $12, $fc, $12, $fc, $15, $fc, $17, $fc, $84, $fb
	byte	$8d, $fa, $60, $fa, $5b, $fa, $5c, $fa, $60, $fa, $61, $fa, $66, $fa, $67, $fa
	byte	$6c, $fa, $6d, $fa, $37, $fc, $3a, $fc, $3b, $fc, $3d, $fc, $3e, $fc, $41, $fc
	byte	$43, $fc, $44, $fc, $45, $fc, $47, $fc, $51, $fb, $ab, $fa, $8e, $fa, $8b, $fa
	byte	$8e, $fa, $91, $fa, $93, $fa, $95, $fa, $98, $fa, $9b, $fa, $64, $fb, $67, $fc
	byte	$68, $fc, $6a, $fc, $6c, $fc, $6e, $fc, $70, $fc, $72, $fc, $74, $fc, $74, $fc
	byte	$76, $fc, $3b, $fb, $d0, $fa, $bb, $fa, $b9, $fa, $bd, $fa, $bf, $fa, $c2, $fa
	byte	$c4, $fa, $c6, $fa, $ca, $fa, $13, $fc, $3a, $fc, $3a, $fc, $3e, $fc, $3e, $fc
	byte	$41, $fc, $43, $fc, $44, $fc, $47, $fc, $48, $fc, $3c, $fc, $2b, $fb, $f0, $fa
	byte	$e6, $fa, $e8, $fa, $eb, $fa, $ee, $fa, $f0, $fa, $f2, $fa, $f6, $fa, $f7, $fa
	byte	$61, $fc, $66, $fc, $68, $fc, $6b, $fc, $6c, $fc, $6e, $fc, $70, $fc, $72, $fc
	byte	$73, $fc, $75, $fc, $13, $fc, $3f, $fb, $17, $fb, $12, $fb, $16, $fb, $18, $fb
	byte	$1a, $fb, $1d, $fb, $1f, $fb, $20, $fb, $23, $fb, $92, $fc, $94, $fc, $96, $fc
	byte	$96, $fc, $97, $fc, $9a, $fc, $9c, $fc, $9e, $fc, $9f, $fc, $a1, $fc, $e7, $fb
	byte	$5a, $fb, $41, $fb, $3e, $fb, $41, $fb
'-' mouse  file "mouse2.def"
	byte	$01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0b, $01, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0c, $0d, $0d, $03, $01, $01, $01, $01, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0c, $01, $09, $0d, $03, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0c, $01, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0c, $01, $00, $00, $01, $0a, $0d, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $01, $00, $00, $00, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00
	byte	$00[22]
	byte	$01, $0b, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[425]
'-' 
'-'              	org
	byte	$00, $00
'-' loadcog      	cogid   t11              		' get a cogid
	byte	$01, $2c, $60, $fd
'-'                 mul     t11, #12                        ' compute the offset to PSRAM mailbox 
	byte	$0c, $2c, $04, $fa
'-'                 add     mailbox, t11                     ' add offset to find this COG's mailbox
	byte	$16, $2e, $00, $f1
'-' 
'-'                 mov     psramaddr,#0
	byte	$00, $30, $04, $f6
'-' 
'-' p101            mov     buf1,psramaddr			' psramaddr=hubaddr
	byte	$18, $36, $00, $f6
'-'                 mov     buf2,##16384			' loading size
	byte	$20, $00, $00, $ff, $00, $38, $04, $f6
'-'                 mov     cmd,psramaddr                   ' set the address for reading
	byte	$18, $34, $00, $f6
'-'                 setnib  cmd, #%1011, #7                 ' attach the command - read burst
	byte	$0b, $34, $3c, $f8
'-'                 setq    #2			 	' write 3 longs to the mailbox
	byte	$28, $04, $64, $fd
'-'                 wrlong  cmd, mailbox			' read the PSRAM
	byte	$17, $34, $60, $fc
'-' p102            rdlong  cmd, mailbox                	' poll mailbox for result
	byte	$17, $34, $00, $fb
'-'                 tjs     cmd, #p102                 	' retry until valid 
	byte	$fe, $35, $b4, $fb
'-' 
'-'                 add 	psramaddr,##16384
	byte	$20, $00, $00, $ff, $00, $30, $04, $f1
'-' 		cmp 	psramaddr,##$7C000 wcz
	byte	$e0, $03, $00, $ff, $00, $30, $1c, $f2
'-' 	if_lt	jmp 	#p101				' loop until full hub loaded
	byte	$c8, $ff, $9f, $cd
'-' 
'-'                 
'-'                 cogstop #7				' stop psram driver
	byte	$03, $0e, $64, $fd
'-'     
'-'                 cogid 	t11				' get id
	byte	$01, $2c, $60, $fd
'-'                 coginit #0,#0				' start the new program
	byte	$00, $00, $ec, $fc
'-'                 cogstop t11				' stop the loader
	byte	$03, $2c, $60, $fd
'-' 
'-' t11 		long 	0
	byte	$00, $00, $00, $00
'-' mailbox 	long 	$7FF00
	byte	$00, $ff, $07, $00
'-' psramaddr 	long 	0
	byte	$00, $00, $00, $00
'-' pslockval	long 	0
	byte	$00, $00, $00, $00
'-' cmd             long    0
	byte	$00, $00, $00, $00
'-' buf1            long    0
	byte	$00, $00, $00, $00
'-' buf2            long    16384
	byte	$00, $40, $00, $00
	long	@@@_dat_ + 8468
	byte	$50, $32, $20, $52, $65, $74, $72, $6f, $6d, $61, $63, $68, $69, $6e, $65, $20
	byte	$42, $41, $53, $49, $43, $20, $76, $65, $72, $73, $69, $6f, $6e, $20, $30, $2e
	byte	$32, $35, $00, $00
	alignl
_hg010b_spin2_dat_
'-' 
'-' vga_font       file "vgafont.def"
	byte	$00[19]
	byte	$7e, $81, $a5, $81, $81, $bd, $99, $81, $81, $7e, $00, $00, $00, $00, $00, $00
	byte	$7e, $ff, $db, $ff, $ff, $c3, $e7, $ff, $ff, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $7f, $7f, $7f, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $3e, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $3c, $e7, $e7, $e7, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $ff, $ff, $7e, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $3c, $3c, $18, $00, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $ff, $e7, $c3, $c3, $e7, $ff, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$00, $00, $3c, $66, $42, $42, $66, $3c, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $c3, $99, $bd, $bd, $99, $c3, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$78, $70, $58, $4c, $1e, $33, $33, $33, $33, $1e, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$fc, $cc, $fc, $0c, $0c, $0c, $0c, $0e, $0f, $07, $00, $00, $00, $00, $00, $00
	byte	$fe, $c6, $fe, $c6, $c6, $c6, $c6, $e6, $e7, $67, $03, $00, $00, $00, $00, $00
	byte	$18, $18, $db, $3c, $e7, $3c, $db, $18, $18, $00, $00, $00, $00, $00, $00, $01
	byte	$03, $07, $0f, $1f, $7f, $1f, $0f, $07, $03, $01, $00, $00, $00, $00, $00, $40
	byte	$60, $70, $78, $7c, $7f, $7c, $78, $70, $60, $40, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $18, $18, $18, $7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$00, $66, $66, $00, $00, $00, $00, $00, $00, $fe, $db, $db, $db, $de, $d8, $d8
	byte	$d8, $d8, $d8, $00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c
	byte	$30, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $7f, $7f, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $7e
	byte	$3c, $18, $7e, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $18
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $18, $30, $7f, $30, $18
	byte	$00[11]
	byte	$0c, $06, $7f, $06, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $03, $03, $03, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$14, $36, $7f, $36, $14, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $1c, $3e, $3e, $7f, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $3e, $3e, $1c, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[14]
	byte	$18, $3c, $3c, $3c, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $66, $66
	byte	$66, $24, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $18, $18
	byte	$3e, $63, $43, $03, $3e, $60, $60, $61, $63, $3e, $18, $18, $00, $00, $00, $00
	byte	$00, $00, $43, $63, $30, $18, $0c, $06, $63, $61, $00, $00, $00, $00, $00, $00
	byte	$1c, $36, $36, $1c, $6e, $3b, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00
	byte	$0c, $0c, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $30, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f, $00, $00
	byte	$00[16]
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $40, $60, $30, $18, $0c, $06
	byte	$03, $01, $00, $00, $00, $00, $00, $00, $1c, $36, $63, $63, $6b, $6b, $63, $63
	byte	$36, $1c, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18, $18
	byte	$18, $7e, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $30, $18, $0c, $06, $03
	byte	$63, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $60, $3c, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30, $30
	byte	$30, $78, $00, $00, $00, $00, $00, $00, $7f, $03, $03, $03, $3f, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $1c, $06, $03, $03, $3f, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $7f, $63, $60, $60, $30, $18, $0c, $0c
	byte	$0c, $0c, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $3e, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $7e, $60, $60, $60
	byte	$30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $60, $30, $18, $0c, $06, $0c, $18
	byte	$30, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00, $7e, $00
	byte	$00[9]
	byte	$06, $0c, $18, $30, $60, $30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $3e
	byte	$63, $63, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $63, $7b, $7b, $7b, $3b, $03, $3e, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3f
	byte	$66, $66, $66, $3e, $66, $66, $66, $66, $3f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00, $00, $1f
	byte	$36, $66, $66, $66, $66, $66, $66, $36, $1f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $7b, $63, $63, $66, $5c, $00, $00, $00, $00, $00, $00, $63
	byte	$63, $63, $63, $7f, $63, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3c
	byte	$18[8]
	byte	$3c, $00, $00, $00, $00, $00, $00, $78, $30, $30, $30, $30, $30, $33, $33, $33
	byte	$1e, $00, $00, $00, $00, $00, $00, $67, $66, $66, $36, $1e, $1e, $36, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $7f, $6b, $63, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $06, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $6b, $7b
	byte	$3e, $30, $70, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $36, $1c
	byte	$08, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $6b, $6b, $6b, $7f, $77
	byte	$36, $00, $00, $00, $00, $00, $00, $63, $63, $36, $3e, $1c, $1c, $3e, $36, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $01, $03, $07, $0e, $1c, $38, $70, $60
	byte	$40, $00, $00, $00, $00, $00, $00, $3c, $30, $30, $30, $30, $30, $30, $30, $30
	byte	$3c, $00, $00, $00, $1c, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$ff, $00, $00, $0c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $07, $06, $06
	byte	$1e, $36, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $30, $30
	byte	$3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $7f, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $6c, $4c
	byte	$0c, $1e, $0c, $0c, $0c, $0c, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$6e, $33, $33, $33, $33, $33, $3e, $30, $33, $1e, $00, $00, $00, $07, $06, $06
	byte	$36, $6e, $66, $66, $66, $66, $67, $00, $00, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $60, $60, $00
	byte	$70, $60, $60, $60, $60, $60, $60, $66, $66, $3c, $00, $00, $00, $07, $06, $06
	byte	$66, $36, $1e, $1e, $36, $66, $67, $00, $00, $00, $00, $00, $00, $1c, $18, $18
	byte	$18[6]
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $6b, $6b, $6b
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$3e, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $6e, $33, $33, $33, $33, $33
	byte	$3e, $30, $30, $78, $00, $00, $00, $00, $00, $00, $3b, $6e, $66, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36
	byte	$1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $6b, $6b, $6b, $7f
	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $1c, $36
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63
	byte	$7e, $60, $30, $1f, $00, $00, $00, $00, $00, $00, $7f, $33, $18, $0c, $06, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18, $18
	byte	$70, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18, $18
	byte	$0e, $00, $00, $00, $6e, $3b, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[10]
	byte	$08, $1c, $36, $63, $63, $63, $7f, $00, $00, $00, $00, $00, $00, $3c, $66, $43
	byte	$03, $03, $03, $03, $43, $66, $3c, $18, $30, $1e, $00, $00, $00, $00, $33, $00
	byte	$33[6]
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $33, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $1c, $36, $1c, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $18, $30, $1e, $00, $00, $00, $1c, $58, $78, $38, $18, $1c, $1e, $1a, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $66, $33, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $cc, $66, $33, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $18, $3c, $66, $00, $1c, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $63, $00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63
	byte	$63, $00, $00, $00, $30, $18, $00, $3c, $66, $43, $03, $03, $03, $03, $43, $66
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66
	byte	$7f, $00, $00, $00, $0c, $06, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $6f, $46, $26, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $6e, $4c, $2c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$1e, $00, $00, $00, $30, $18, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $6c, $38, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $60, $48, $2c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $0f, $26, $36, $1e, $0e, $07, $07, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36, $63, $00
	byte	$00[6]
	byte	$36, $1c, $08, $00, $3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63, $63, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $1e, $30, $3e, $33, $33, $33, $6e, $18, $0c, $78, $36, $1c
	byte	$00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00
	byte	$00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66, $7f, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $7f, $03, $03, $63, $3e, $18, $0c, $78, $00, $00
	byte	$00, $3c, $66, $03, $1f, $03, $0f, $03, $03, $66, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $6c, $38
	byte	$00, $3c, $66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63, $3e, $18, $30, $1e, $00, $00
	byte	$00[6]
	byte	$6c, $36, $1b, $36, $6c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$1b, $36, $6c, $36, $1b, $00, $00, $00, $88, $22, $88, $22, $88, $22, $88, $22
	byte	$88, $22, $88, $22, $88, $22, $88, $22, $aa, $55, $aa, $55, $aa, $55, $aa, $55
	byte	$aa, $55, $aa, $55, $aa, $55, $aa, $55, $bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee
	byte	$bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18[15]
	byte	$1f, $18, $18, $18, $18, $18, $18, $18, $18, $30, $18, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $1c, $36, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $36, $1c, $00, $7f, $66, $46, $16
	byte	$1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06
	byte	$1c, $30, $60, $63, $63, $3e, $18, $30, $1e, $6c, $6c, $6c, $6c, $6c, $6f, $60
	byte	$6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6c[9]
	byte	$00[5]
	byte	$7f, $60, $6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6f, $60, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $7f, $63
	byte	$61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00, $00, $18, $18
	byte	$00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $63, $3e, $00, $08, $1c
	byte	$36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $63, $3e
	byte	$00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $fc, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$fc, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$63, $3e, $63, $63, $63, $63, $3e, $63, $00, $00, $00, $00, $00, $00, $30, $7e
	byte	$30, $3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $1f, $36
	byte	$66, $66, $6f, $66, $66, $66, $36, $1f, $00, $00, $00, $36, $1c, $00, $1f, $36
	byte	$66[6]
	byte	$36, $1f, $00, $00, $00, $00, $63, $00, $7f, $66, $46, $16, $1e, $16, $06, $46
	byte	$66, $7f, $00, $00, $00, $6c, $38, $00, $38, $30, $30, $3c, $36, $33, $33, $33
	byte	$33, $6e, $00, $00, $00, $36, $1c, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63
	byte	$63, $63, $00, $00, $00, $30, $18, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $3c, $66, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $00, $00, $36, $1c, $08, $00, $3e, $63, $7f, $03, $03
	byte	$63, $3e, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $1f, $00, $00, $00
	byte	$00[12]
	byte	$f8, $18, $18, $18, $18, $18, $18, $18, $18, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	byte	$ff[9]
	byte	$00[7]
	byte	$ff[9]
	byte	$00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18, $3c, $18, $30, $1e
	byte	$1c, $36, $1c, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$ff[7]
	byte	$00[9]
	byte	$30, $18, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $00, $1e, $33, $33, $33, $1b, $33, $63, $63, $63, $33, $00, $00, $00
	byte	$1c, $36, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63, $63, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$36, $1c, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3e, $63, $06, $1c, $30, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00
	byte	$30, $18, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00
	byte	$66, $33, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $63, $63, $63, $63, $63, $63, $7e, $60, $30, $1f
	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18, $3c, $00, $00, $00
	byte	$00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c, $38, $18, $30, $1e
	byte	$30, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $66, $33, $00, $00, $00, $00, $00, $00
	byte	$00[21]
	byte	$0c, $06, $3c, $36, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c, $30, $63, $3e
	byte	$00[8]
	byte	$18, $00, $7e, $00, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $30, $1e, $00, $00, $00, $1c, $36, $36, $1c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[5]
	byte	$cc, $66, $33, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $36, $1c
	byte	$00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $7e, $7e, $7e, $7e, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' 'vga_font       file "vgafont.def"
'-' st_font        file "st4font.def"
	byte	$00[55]
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$18[9]
	byte	$00[7]
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $00, $00, $18, $3c, $7e, $66, $66
	byte	$66, $7e, $7e, $66, $66, $66, $66, $30, $18, $00, $00, $7e, $7e, $06, $06, $3e
	byte	$3e, $06, $06, $06, $06, $7e, $7e, $18, $0c, $30, $18, $3c, $7e, $66, $66, $06
	byte	$06, $06, $06, $66, $66, $7e, $3c, $00, $00, $30, $18, $66, $66, $66, $6e, $6e
	byte	$7e, $7e, $76, $76, $66, $66, $66, $00, $00, $30, $18, $7c, $7e, $06, $06, $0e
	byte	$1c, $38, $70, $60, $60, $7e, $3e, $00, $00, $30, $18, $7e, $7e, $30, $30, $18
	byte	$18, $0c, $0c, $06, $06, $7e, $7e, $00, $00, $18, $18, $00, $7e, $7e, $30, $30
	byte	$18, $18, $0c, $0c, $06, $7e, $7e, $00, $00, $30, $18, $3c, $7e, $66, $66, $66
	byte	$66[5]
	byte	$7e, $3c, $00, $00, $00, $00, $06, $06, $06, $06, $16, $1e, $0e, $06, $06, $06
	byte	$7e, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $7c, $60, $7c, $7e, $66, $66
	byte	$7e, $7c, $30, $18, $00, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $06, $06
	byte	$7e, $7c, $18, $0c, $00, $00, $30, $18, $00, $3c, $3e, $06, $06, $06, $06, $06
	byte	$7e, $7c, $00, $00, $00, $00, $30, $18, $00, $3e, $7e, $66, $66, $66, $66, $66
	byte	$66, $66, $00, $00, $00, $00, $30, $18, $00, $7c, $7e, $06, $0e, $3c, $70, $60
	byte	$7e, $3e, $00, $00, $00, $00, $30, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $18, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $00, $3c, $7e, $66, $66, $66, $66, $66
	byte	$7e, $3c, $00, $00, $00, $00, $1c, $1c, $18, $18, $38, $3c, $1c, $18, $18, $18
	byte	$3c, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[8]
	byte	$00, $00, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $00, $00, $00, $00
	byte	$00[9]
	byte	$66, $66, $ff, $ff, $66, $66, $ff, $ff, $66, $66, $00, $00, $00, $00, $18, $18
	byte	$7c, $7e, $06, $06, $3e, $7c, $60, $60, $7e, $3e, $18, $18, $00, $00, $00, $66
	byte	$66, $30, $30, $18, $18, $0c, $0c, $66, $66, $00, $00, $00, $00, $00, $3c, $7e
	byte	$66, $66, $3c, $1c, $1c, $fc, $fe, $66, $66, $fe, $fc, $00, $00, $00, $00, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $30
	byte	$18, $1c, $0c, $0c, $0c, $0c, $0c, $0c, $1c, $18, $30, $00, $00, $00, $00, $0c
	byte	$18, $38, $30, $30, $30, $30, $30, $30, $38, $18, $0c, $00, $00, $00, $00, $00
	byte	$66, $66, $3c, $3c, $ff, $ff, $3c, $3c, $66, $66, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $18, $7e, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[5]
	byte	$0c, $04, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00[13]
	byte	$18, $18, $18, $00, $00, $00, $00, $60, $60, $60, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $76, $6e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $18, $18, $1c, $1c, $18, $18, $18, $18, $18
	byte	$18, $7e, $7e, $00, $00, $00, $00, $3c, $7e, $66, $66, $30, $30, $18, $18, $0c
	byte	$0c, $7e, $7e, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $30, $30, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $30, $30, $38, $38, $3c, $3c, $36, $36, $7e
	byte	$7e, $30, $30, $00, $00, $00, $00, $7e, $7e, $06, $06, $3e, $7e, $60, $60, $60
	byte	$66, $7e, $3c, $00, $00, $00, $00, $38, $3c, $0e, $06, $06, $3e, $7e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $7e, $7e, $60, $60, $30, $30, $18, $18, $0c
	byte	$0c, $0c, $0c, $00, $00, $00, $00, $3c, $7e, $66, $66, $3c, $3c, $66, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $7c, $60, $60, $60
	byte	$70, $3c, $1c, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $18
	byte	$18, $18, $18, $0c, $04, $00, $00, $00, $70, $38, $1c, $0e, $07, $0e, $1c, $38
	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $7e, $7e
	byte	$00[8]
	byte	$0e, $1c, $38, $70, $e0, $70, $38, $1c, $0e, $00, $00, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $30, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $66, $66, $36, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $18
	byte	$3c, $7e, $66, $66, $66, $7e, $7e, $66, $66, $66, $66, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $7e, $3e, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $06, $06, $06, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $66, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $7e, $7e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $7c
	byte	$7e, $06, $06, $76, $76, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $66
	byte	$66, $66, $66, $7e, $7e, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $7e
	byte	$7e, $18, $18, $18, $18, $18, $18, $18, $18, $7e, $7e, $00, $00, $00, $00, $60
	byte	$60[7]
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $36, $36, $1e, $1e, $36, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $06, $06, $06, $06, $06, $06, $06, $06
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $c6, $c6, $ee, $ee, $fe, $d6, $d6, $c6
	byte	$c6, $c6, $c6, $c6, $00, $00, $00, $00, $66, $66, $66, $6e, $6e, $7e, $7e, $76
	byte	$76, $66, $66, $66, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $66, $7e, $3e
	byte	$06, $06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $56, $3e, $6c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $7e, $3e, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $7c, $7e, $06, $06, $0e, $1c, $38, $70
	byte	$60, $60, $7e, $3e, $00, $00, $00, $00, $7e, $7e, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$3c, $3c, $18, $18, $00, $00, $00, $00, $c6, $c6, $c6, $c6, $c6, $d6, $d6, $fe
	byte	$fe, $ee, $c6, $82, $00, $00, $00, $00, $66, $66, $66, $3c, $3c, $18, $18, $3c
	byte	$3c, $66, $66, $66, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $3c, $3c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$0c, $0c, $3c, $3c, $00, $00, $00, $00, $06, $06, $0c, $0c, $18, $18, $30, $30
	byte	$60, $60, $c0, $c0, $00, $00, $00, $00, $3c, $3c, $30, $30, $30, $30, $30, $30
	byte	$30, $30, $3c, $3c, $00, $00, $00, $00, $18, $18, $3c, $3c, $66, $66, $00, $00
	byte	$00[18]
	byte	$fe, $fe, $00, $00, $00, $00, $0c, $0c, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$3c, $7c, $60, $7c, $7e, $66, $66, $7e, $7c, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $3e, $06, $06, $06, $06, $06, $7e, $7c, $00, $00, $00, $00, $60, $60, $60
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $7e, $06, $06, $7e, $7c, $00, $00, $00, $00, $70, $78, $18
	byte	$18, $7e, $7e, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $7e, $7c, $60, $7e, $3e, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $1c, $18, $18, $18, $18, $18, $3c, $3c, $00, $00, $00, $00, $30, $30, $00
	byte	$30[9]
	byte	$3e, $1e, $00, $00, $06, $06, $06, $36, $36, $1e, $1e, $1e, $36, $36, $66, $66
	byte	$00, $00, $00, $00, $1c, $1c, $18, $18, $18, $18, $18, $18, $18, $18, $3c, $3c
	byte	$00[7]
	byte	$6c, $fe, $fe, $d6, $d6, $c6, $c6, $c6, $c6, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $06, $06, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $60, $60, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $06, $0e, $3c, $70, $60, $7e, $3e, $00, $00, $00, $00, $00, $18, $18
	byte	$7e, $7e, $18, $18, $18, $18, $18, $78, $70, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$7e, $7c, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $c6, $c6, $d6, $d6, $fe, $fe, $ee
	byte	$c6, $82, $00, $00, $00, $00, $00, $00, $00, $66, $66, $3c, $3c, $18, $3c, $3c
	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $7e
	byte	$7c, $60, $7e, $3e, $00, $00, $00, $00, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $18, $18, $18, $0c, $0c, $18, $18, $18
	byte	$18, $30, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $0c, $18, $18, $18, $18, $30, $30, $18, $18, $18
	byte	$18, $0c, $00, $00, $00, $00, $6c, $7e, $36, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
'-' 'amiga_font     file "amigafont.def"
'-' a8_font        file "atari8.fnt"
	byte	$00, $6c, $fe, $fe, $7c, $38, $10, $00, $18, $18, $18, $f8, $f8, $18, $18, $18
	byte	$c0[8]
	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
	byte	$0f[8]
	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
	byte	$66[5]
	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
	byte	$08, $00
'-' vga16          long  $00000000,$00008000,$00800000,$00808000,$80000000,$80008000,$80400000,$AAAAAA00,$55555500,$0000FF00,$00FF0000,$00FFFF00,$FF000000,$FF00FF00,$FFFF0000,$FFFFFF00
	byte	$00[5]
	byte	$80, $00, $00, $00, $00, $80, $00, $00, $80, $80, $00, $00, $00, $00, $80, $00
	byte	$80, $00, $80, $00, $00, $40, $80, $00, $aa, $aa, $aa, $00, $55, $55, $55, $00
	byte	$ff, $00, $00, $00, $00, $ff, $00, $00, $ff, $ff, $00, $00, $00, $00, $ff, $00
	byte	$ff, $00, $ff, $00, $00, $ff, $ff, $00, $ff, $ff, $ff
'-' ataripalette   file "ataripalettep2.def"
	byte	$00[5]
	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
'-' 
'-' '**********************************************************************************
'-' '
'-' '        Timings and colors definitions
'-' '
'-' '**********************************************************************************
'-' 
'-' '                      bf.hs, hs,  bf.vis  visible, up p., vsync, down p.,  cpl, total lines, clock,       hubset                                scanlines  ud bord mode reserved
'-' timings         long   16,    80,  12,      1024,   8,     4,     8,        128, 576,         336956522,   %1_101101__11_0000_0110__1111_1011,   576,        0,     192, 0, 0
	byte	$10, $00, $00, $00, $50, $00, $00, $00, $0c, $00, $00, $00, $00, $04, $00, $00
	byte	$08, $00, $00, $00, $04, $00, $00, $00, $08, $00, $00, $00, $80, $00, $00, $00
	byte	$40, $02, $00, $00, $6a, $8c, $15, $14, $fb, $06, $b7, $01, $40, $02, $00, $00
	byte	$00, $00, $00, $00, $c0, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' vgacolors       byte   0, 117, 199, 151, 39, 71, 246, 10, 5, 121, 203, 155, 43, 75, 234, 15
	byte	$00, $75, $c7, $97, $27, $47, $f6, $0a, $05, $79, $cb, $9b, $2b, $4b, $ea, $0f
'-' 
'-' ''--------  Initialization  ----------------------------------------------------------------
'-' 
'-' hdmi            setq    #6
	byte	$28, $0c, $64, $fd
'-'                 rdlong  vblankptr,  ptra                   ' read pointers
	byte	$00, $a5, $05, $fb
'-'                 setq    #8
	byte	$28, $10, $64, $fd
'-'                 rdlong  m_bs,modeptr                       ' read timings
	byte	$d3, $8a, $01, $fb
'-' 
'-'                 bitl    hbase, #31 wcz                     ' if pin 31 is set, use full strength for Adafruit Pico HDMI board
	byte	$1f, $ac, $1d, $f4
'-'                 setcmod #$100                              ' enable HDMI mode
	byte	$3c, $00, $66, $fd
'-'                 mov     t1,#448                            ' 7 << 6          
	byte	$c0, $c7, $05, $f6
'-'                 add     t1,hbase
	byte	$d6, $c6, $01, $f1
'-'                 drvl    t1                                 ' #7<<6 + hdmi_base      ' enable HDMI pins
	byte	$58, $c6, $61, $fd
'-'         if_z    wrpin   #0, t1  '#7<<6 + hdmi_base         ' for Adafruit breakout board - full logic as in Pico, the board has 220 Ohm resistors on it
	byte	$e3, $00, $08, $ac
'-' 	if_nz   wrpin   ##%10110_1111_0111_10_00000_0, t1  ' #7<<6 + hdmi_base      ' a '123 ohm BITDAC for Parallax breakout board
	byte	$7b, $0b, $80, $5f, $e3, $00, $0b, $5c
'-'                 setxfrq ##$0CCCCCCC+1                      ' set streamer freq to 1/10th clk
	byte	$66, $66, $86, $ff, $1d, $9a, $65, $fd
'-' '
'-'                 mov 	t1,hbase			   '
	byte	$d6, $c6, $01, $f6
'-'                 shl 	t1,#17                             '
	byte	$11, $c6, $65, $f0
'-'                 add 	lutg8,t1                           ' add the pin base to he streamer constant
	byte	$e3, $a2, $01, $f1
'-'                 sub 	i_upporch,#2			   ' the driver will call 2 blank lines itself to preload the buffer, so sub #2 from up porch time
	byte	$02, $92, $85, $f1
'-' 
'-'                 cogid   t1              		   ' get a cogid
	byte	$01, $c6, $61, $fd
'-'                 mul     t1, #12                            ' compute the offset to PSRAM mailbox 
	byte	$0c, $c6, $05, $fa
'-'                 add     mailbox, t1                        ' add offset to find this COG's mailbox
	byte	$e3, $ae, $01, $f1
'-' 
'-' ''--------  frame rendering main loop  ---------------------------------------------------
'-' 
'-' p101            setq 	#3
	byte	$28, $06, $64, $fd
'-' 		rdlong  vblankptr,ptra
	byte	$00, $a5, $05, $fb
'-'                 setq    #47+6				   ' read sprite data
	byte	$28, $6a, $64, $fd
'-' 	 	rdlong  sprite1pointer,spriteptr
	byte	$d8, $dc, $01, $fb
'-' 		mov     spriteline,#0                      ' init the sprite line variable
	byte	$00, $4a, $06, $f6
'-'                 mov     dlinum, #0
	byte	$00, $a0, $05, $f6
'-'                 add     frames,#1			   ' increment the frame counter
	byte	$01, $9e, $05, $f1
'-'                 mov     dlptr2,dlptr			   ' init the temporary DL pointer
	byte	$d5, $b8, $01, $f6
'-' 
'-' 
'-'                 mov     linenum,#0			   ' init the current line #
	byte	$00, $9c, $05, $f6
'-'                 mov     rcnt,#0			   	   ' init the DL repeat counter
	byte	$00, $ce, $05, $f6
'-'                 mov     rcnt2a,affffffff 		   ' why?!                
	byte	$ed, $d2, $01, $f6
'-'                 
'-' 
'-' 
'-' '' ------- reload the palette. If bit31 set, don't reload, to prevent blinking while modifying the palette
'-'   
'-'                 testb   paletteptr,#31 wc
	byte	$1f, $a8, $15, $f4
'-'          if_nc  setq2   #255
	byte	$29, $fe, $65, $3d
'-'          if_nc  rdlong  $000, paletteptr                   'read palette
	byte	$d4, $00, $00, $3b
'-' 
'-' '' -----   up porch (before the picture)
'-' 
'-'                 mov     hsync0,sync_000      	           ' init constants for sync
	byte	$c0, $c2, $01, $f6
'-'                 mov     hsync1,sync_001	
	byte	$c1, $c4, $01, $f6
'-'                 callpa  i_upporch ,#blank                  ' call the porch line i_upporch (-2) times
	byte	$40, $92, $45, $fb
'-'                 wrlong  #0,vblankptr                       ' the vblank time ends here
	byte	$d2, $00, $68, $fc
'-'  
'-'    
'-'  
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'          	     call    #dli	                  ' call DL interpreter for line #0 at line #(-2) - 2 lines earlier, so it can start preloading data from PSRAM
	byte	$60, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                          rdfast  #64,buf1d                          ' prepare the HUB buffer for 4 scanlines
	byte	$df, $80, $78, $fc
'-' 
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-' 		call    #dli
	byte	$48, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                  call    #sprite				   ' sprites for line #0
	byte	$20, $01, $b0, $fd
'-'                 	
'-'                 
'-' 
'-'  
'-' '' ------- the main screen drawing starts here
'-' 
'-' p301            xcont   m_bs,hsync0   			  ' make a right porch
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1                       ' make hsync
	byte	$e2, $8c, $b1, $fc
'-'                 call    #dli                              ' process the DL for line+2                
	byte	$30, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   lutg8,#0			  ' display the line 
	byte	$00, $a2, $c5, $fc
'-'                  add     linenum,#1                        ' increment the current line number 
	byte	$01, $9c, $05, $f1
'-'                  call    #sprite                           ' process sprites for line+1             
	byte	$04, $01, $b0, $fd
'-'               
'-' 
'-'                 cmp     linenum,i_totalvis  wz            ' check if all lines displayed
	byte	$cd, $9c, $09, $f2
'-'     if_nz       jmp     #p301                             ' if not, display the next line
	byte	$dc, $ff, $9f, $5d
'-' 
'-' ' ---------------- All visible lines displayed now, start vblank  
'-' 
'-' p112            wrlong  #1,vblankptr                       ' tell the system that the vblank started
	byte	$d2, $02, $68, $fc
'-'                 callpa  i_downporch ,#blank                ' bottom blanks
	byte	$28, $96, $45, $fb
'-'                 mov     hsync0,sync_222                    ' vsync on
	byte	$c2, $c2, $01, $f6
'-'                 mov     hsync1,sync_223
	byte	$c3, $c4, $01, $f6
'-'                 callpa  i_vsync,#blank                     ' vertical sync blanks
	byte	$25, $94, $45, $fb
'-'                 jmp     #p101                              ' return to the main loop
	byte	$4c, $ff, $9f, $fd
'-' 
'-' '' --------------- END of frame rendering loop ---------------------------------------------------------------------------
'-' 
'-' '' --------------- Display list interpreter ---------------------------------------------------------------------------
'-' 
'-' dli             cmp     rcnt,#0 wz			   ' check the DL repeat counter 
	byte	$00, $ce, $0d, $f2
'-' 
'-'     if_z        rdlong  dl,dlptr2				
	byte	$dc, $ba, $01, $ab
'-'     if_z        add     dlptr2,#4
	byte	$04, $b8, $05, $a1
'-'     if_z        jmp     #p307                              ' no repeat, goto read and interpret the next DL entry
	byte	$14, $00, $90, $ad
'-' 
'-'                 sub     rcnt,#1 wz                         ' decrement the repeat counter
	byte	$01, $ce, $8d, $f1
'-'     if_nz       mov     dl,rdl                             ' restore repeating DL entry from temporary buffer
	byte	$eb, $ba, $01, $56
'-'                 incmod  rcnt2a,rcnt2 wcz                   ' address update counter
	byte	$e8, $d2, $19, $f7
'-'     if_c        add     dl,roffset                         ' if it rollovers, add the offset to the data address
	byte	$ea, $ba, $01, $c1
'-'                 mov     rdl,dl                             ' save the result
	byte	$dd, $d6, $01, $f6
'-' 
'-' p307	        mov     framebuf2,dl wcz                   ' move this to framebuf2. If normal DL entry, the frame buffer start will be extracted from this
	byte	$dd, $c0, $19, $f6
'-'                 getnib  t1,dl,#0
	byte	$dd, $c6, $41, $f8
'-'                 cmp     t1,#%0010 wz			   ' 0010 - display a normal graphics line, preload it from the PSRAM
	byte	$02, $c6, $0d, $f2
'-'     if_z        jmp     #preload
	byte	$70, $00, $90, $ad
'-'     		cmp     t1,#%0000 wz			   ' 0000 - display a line from a PSRAM list
	byte	$00, $c6, $0d, $f2
'-'     if_z        jmp     #preload2
	byte	$94, $00, $90, $ad
'-'                 cmp     t1,#%0001 wz			   ' 0001 - repeat
	byte	$01, $c6, $0d, $f2
'-'     if_z        jmp     #p390
	byte	$0c, $00, $90, $ad
'-'                 cmp     t1,#%0011 wz			   ' 0011 - palette reload
	byte	$03, $c6, $0d, $f2
'-'     if_z        jmp     #p391  
	byte	$28, $00, $90, $ad
'-' 
'-' p308            ret
	byte	$2d, $00, $64, $fd
'-'    
'-' p390            rdlong  rdl,dlptr2                         ' read the next DL entry to repeat
	byte	$dc, $d6, $01, $fb
'-'                 getword rcnt,framebuf2,#1                  ' read the repeat count
	byte	$e0, $ce, $39, $f9
'-'                 shr     rcnt,#4                            ' from 12 upper bits
	byte	$04, $ce, $45, $f0
'-'                 mov     rcnt2a,affffffff                   ' I still don't know why?
	byte	$ed, $d2, $01, $f6
'-'                 getnib  rcnt2,framebuf2,#4                 ' read the pointer update counter
	byte	$e0, $d0, $61, $f8
'-'                 getword roffset,framebuf2,#0               ' read the offset to add
	byte	$e0, $d4, $31, $f9
'-'                 shr     roffset,#4                         ' clean the command field from offset
	byte	$04, $d4, $45, $f0
'-'                 shl     roffset,#4                         ' and make it ready to add to the DL entry (address=20 upper bits)
	byte	$04, $d4, $65, $f0
'-'                 jmp     #dli                               ' now start repeating 
	byte	$8c, $ff, $9f, $fd
'-'  
'-' '' --------  Reload palette. To do 
'-' 
'-' p391           	getnib  t1,framebuf2,#2			   ' get a bank (0..15) of 16 colors
	byte	$e0, $c6, $51, $f8
'-'          	shl     t1,#4				   ' compute the LUT address
	byte	$04, $c6, $65, $f0
'-'         	shr     framebuf2,#12			   ' compute the HUB address of 16 new colors
	byte	$0c, $c0, $45, $f0
'-'          	setq2   #15				   ' load 16 entries
	byte	$29, $1e, $64, $fd
'-'          	altd    t1                                 ' from t1 LUT address
	byte	$00, $c6, $8d, $f9
'-'         	rdlong  $000, framebuf2         	
	byte	$e0, $00, $00, $fb
'-'         	jmp     #dli                
	byte	$70, $ff, $9f, $fd
'-'       
'-' '' --------------- A display list interpreter end ------------------------------------------------------------------------    
'-' 
'-' 
'-' '' --------------- Blank and vsync procedures called via callpa have to be in the middle of the code ---------------------
'-' 
'-' blank           xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'         _ret_   djnz    pa,#blank
	byte	$fb, $ed, $6f, $0b
'-'         
'-' '' -------------- Preload a line from PSRAM        
'-'         
'-' preload         mov     buf1c,dlinum			   ' preload a line buffer #dlinum (0..3)
	byte	$d0, $bc, $01, $f6
'-'                 shl     buf1c,#10		           ' 1024 bytes per line
	byte	$0a, $bc, $65, $f0
'-'                 add     buf1c,buf1d			   ' add the start address (himem-debug-4096) : Todo: debug variable!
	byte	$df, $bc, $01, $f1
'-'                 mov     buf1,buf1c
	byte	$de, $b4, $01, $f6
'-'                 incmod  dlinum,#3
	byte	$03, $a0, $05, $f7
'-' 
'-'                 shr     framebuf2,#4                      ' get the PSRAM start address from DL - Todo: use new DL format
	byte	$04, $c0, $45, $f0
'-'                 mov     buf2,a1024
	byte	$32, $b7, $01, $f6
'-'                 mov     cmd,framebuf2                      ' set the address
	byte	$e0, $b2, $01, $f6
'-'                 setnib  cmd, #%1011, #7                    ' attach the command - read burst from the external memory
	byte	$0b, $b2, $3d, $f8
'-'                 setq    #2				   ' write 3 longs to the mailbox
	byte	$28, $04, $64, $fd
'-'     _ret_       wrlong  cmd,mailbox			   ' read the PSRAM
	byte	$d7, $b2, $61, $0c
'-'  
'-'  
'-' preload2      '  incmod  dlinum,#3
'-'                 shr 	framebuf2,#4
	byte	$04, $c0, $45, $f0
'-'                 mov 	cmd,affffffff
	byte	$ed, $b2, $01, $f6
'-'                 mov 	buf1,framebuf2
	byte	$e0, $b4, $01, $f6
'-'                 setq	#1
	byte	$28, $02, $64, $fd
'-'     _ret_	wrlong  cmd,mailbox
	byte	$d7, $b2, $61, $0c
'-'                 
'-' 
'-' '' -------------- Draw sprites
'-' 
'-' sprite          mov t8,frames
	byte	$cf, $5c, $02, $f6
'-' 		and t8,#16 wz
	byte	$10, $5c, $0e, $f5
'-'                 mov     spritenum,#17			' 16 +2 sprites. Todo: this should be a parameter
	byte	$11, $48, $06, $f6
'-' 	if_z    mov spritenum, #16	
	byte	$10, $48, $06, $a6
'-' 		
'-' 
'-' p802            mov     t5,spritenum		   	' prepare a pointer to load sprite data
	byte	$24, $57, $02, $f6
'-'                 mul     t5,#3          			' one sprite data set needs 3 longs
	byte	$03, $56, $06, $fa
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_y,0-0,#1		        ' get a sprite y
	byte	$00, $4e, $3a, $f9
'-'                 signx	sprite_y,#15			' they can be negative
	byte	$0f, $4e, $66, $f7
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_x,0-0,#0                 ' and x
	byte	$00, $4c, $32, $f9
'-'                 signx	sprite_x,#15
	byte	$0f, $4c, $66, $f7
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_h,0-0,#1		       	' get a sprite height
	byte	$00, $52, $3a, $f9
'-'                 sub     sprite_h,#1
	byte	$01, $52, $86, $f1
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_w,0-0,#0                 ' and width
	byte	$00, $50, $32, $f9
'-' 
'-' 
'-'                	cmps	sprite_x,a1024 wcz	         
	byte	$32, $4d, $5a, $f2
'-'      if_ge	jmp 	#p801                           ' go out if >1023
	byte	$bc, $00, $90, $3d
'-'               	cmps	sprite_w,#0 wcz	         
	byte	$00, $50, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if w=0
	byte	$b4, $00, $90, $ad
'-'               	cmps	sprite_h,#0 wcz	         
	byte	$00, $52, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if h=0
	byte	$ac, $00, $90, $ad
'-'                 mov 	t9,#0
	byte	$00, $5e, $06, $f6
'-'                 sub 	t9,sprite_w                      	
	byte	$28, $5f, $82, $f1
'-'      		cmps  	sprite_x,t9 wcz   		'
	byte	$2f, $4d, $5a, $f2
'-'      if_le	jmp 	#p801	                        ' go out if sprite out of screen at right
	byte	$9c, $00, $90, $ed
'-'      
'-'   		mov     t2,linenum			' display line # to check if sprite has to be displayed
	byte	$ce, $c8, $01, $f6
'-'   		subs    t2,sprite_y wcz                 ' check if the sprite has to be displayed
	byte	$27, $c9, $d9, $f1
'-'      if_c       jmp     #p801				' if not, go out
	byte	$90, $00, $90, $cd
'-'                 cmp     t2,sprite_h wcz		    	' we have now the sprite line #, check, if it is not >= sprite height
	byte	$29, $c9, $19, $f2
'-'      if_gt      jmp     #p801				' if yes, go out
	byte	$88, $00, $90, $1d
'-'                 
'-'                 mov     t3,spriteline			' compute the line buffer addres where to put the sprite line
	byte	$25, $cb, $01, $f6
'-'                 shl     t3,#10			       	' =1024*spriteline where spriteline=0..3		' 
	byte	$0a, $ca, $65, $f0
'-'                 add     t3,buf1d			' line buffer addr
	byte	$df, $ca, $01, $f1
'-'   		
'-'   		testb	sprite_x,#31 wc 		' check if sprite pos <0
	byte	$1f, $4c, $16, $f4
'-'      if_nc      add     t3,sprite_x   			' if >=0 add xpos. If <0, the address is the start of the line  - now we have the address to where wmlong the sprite
	byte	$26, $cb, $01, $31
'-' 
'-'                 mul 	t2,sprite_w			' compute the offset to the sprite line data
	byte	$28, $c9, $01, $fa
'-'      if_c	add     sprite_w,sprite_x		' if sprite_x negative, shorten the width
	byte	$26, $51, $02, $c1
'-'      if_c	sub 	t2,sprite_x			' and add the offset (sub negative) to the sprite data offset
	byte	$26, $c9, $81, $c1
'-'  
'-'                 alts    t5,#sprite1pointer		' get the pointer to the sprite (3 longs per sprite data)
	byte	$ee, $56, $96, $f9
'-'                 add     t2,0-0				' then add the offset
	byte	$00, $c8, $01, $f1
'-'      if_c 	jmp     #p899		
	byte	$10, $00, $90, $cd
'-' 	
'-' 	
'-' 		mov 	t4,sprite_x	'
	byte	$26, $cd, $01, $f6
'-' 		add	t4,sprite_w
	byte	$28, $cd, $01, $f1
'-' 		sub     t4,a1024 wcz			' check if the sprite goes right off the screen
	byte	$32, $cd, $99, $f1
'-' 
'-' 	if_nc	sub	sprite_w,t4			' if yes, make it narrower
	byte	$e6, $50, $82, $31
'-' 
'-' p899		mov 	t6,sprite_w
	byte	$28, $59, $02, $f6
'-' 	 	sub     t6,#1
	byte	$01, $58, $86, $f1
'-' 	 	shr	t6,#2				' bytes to longs
	byte	$02, $58, $46, $f0
'-' 
'-'                 setq   	t6
	byte	$28, $58, $62, $fd
'-'                 rdlong 368,t2				' read sprite data to the cog
	byte	$e4, $e0, $02, $fb
'-'                 mov t8,sprite_w
	byte	$28, $5d, $02, $f6
'-'                 and t8,#3 wz				' if width mod 4=0 we have full longs, nothing to do
	byte	$03, $5c, $0e, $f5
'-'         if_z    jmp #p898
	byte	$24, $00, $90, $ad
'-'          
'-'         
'-'                 mov  t9,#368
	byte	$70, $5f, $06, $f6
'-'                 add t9,t6				' find the last long of the sprite
	byte	$2c, $5f, $02, $f1
'-' 
'-'                 subr t8,#4				' if modulo4=1, mask 3 bytes, if 2, mask 2, if 1, mask 3
	byte	$04, $5c, $c6, $f2
'-'                 mul t8,#8				' bits to shr
	byte	$08, $5c, $06, $fa
'-'                 mov t7,##-1				' full of 1s
	byte	$ff, $ff, $7f, $ff, $ff, $5b, $06, $f6
'-'                 shr t7,t8				' SHR to make 0s for masking
	byte	$2e, $5b, $42, $f0
'-'                 altd t9,#0				' and mask 
	byte	$00, $5e, $8e, $f9
'-'                 and 0-0, t7
	byte	$2d, $01, $00, $f5
'-'                
'-' 
'-' p898            setq   t6				' write the sprite data to the line buffer
	byte	$28, $58, $62, $fd
'-'                 wmlong 368,t3				
	byte	$e5, $e0, $7a, $fa
'-'                 
'-' p801            djnf spritenum,#p802			' get the next sprite
	byte	$c1, $49, $7e, $fb
'-'                 incmod spriteline,#3			' prepare to fill the next line
	byte	$03, $4a, $06, $f7
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 	
'-' 	
'-'                
'-'  
'-' '' -------------- Graphics line ------------------------------------------------------------
'-'  
'-' 
'-' '' consts and vars
'-' 
'-' sync_000        long    %1101010100_1101010100_1101010100_10    '
	byte	$52, $4d, $35, $d5
'-' sync_001        long    %1101010100_1101010100_0010101011_10    '        hsync
	byte	$ae, $42, $35, $d5
'-' sync_222        long    %0101010100_0101010100_0101010100_10    'vsync
	byte	$52, $45, $15, $55
'-' sync_223        long    %0101010100_0101010100_1010101011_10    'vsync + hsync
	byte	$ae, $4a, $15, $55
'-' 
'-' border          long    %00000000_00011010_00101100_00000000
	byte	$00, $2c, $1a, $00
'-' 
'-' '------ these longs will be set by setmode function
'-' 
'-' m_bs            long    0        'blanks before sync
	byte	$00, $00, $00, $00
'-' m_sn            long    0        'sync
	byte	$00, $00, $00, $00
'-' m_bv            long    0        'blanks before visible
	byte	$00, $00, $00, $00
'-' m_vi            long    0        'visible pixels #
	byte	$00, $00, $00, $00
'-' 'm_border        long    0        'left/right borders
'-' i_upporch       long    0        'up porch lines
	byte	$00, $00, $00, $00
'-' i_vsync         long    0        'vsync lines
	byte	$00, $00, $00, $00
'-' i_downporch     long    0        'down porch lines
	byte	$00, $00, $00, $00
'-' i_cpl           long    0        'chars/longs per line
	byte	$00, $00, $00, $00
'-' i_totalvis      long    0
	byte	$00, $00, $00, $00
'-' 
'-' '-------------------------------------
'-'  
'-' linenum         long    0
	byte	$00, $00, $00, $00
'-' frames          long    0
	byte	$00, $00, $00, $00
'-' dlinum long 0
	byte	$00, $00, $00, $00
'-' lutg8           long    $70880400 ' 0111_0000_1000_1000
	byte	$00, $04, $88, $70
'-' 
'-' vblankptr       long    0
	byte	$00, $00, $00, $00
'-' modeptr         long    0
	byte	$00, $00, $00, $00
'-' paletteptr      long    0
	byte	$00, $00, $00, $00
'-' dlptr           long    0
	byte	$00, $00, $00, $00
'-' hbase           long    1
	byte	$01, $00, $00, $00
'-' mailbox         long    0
	byte	$00, $00, $00, $00
'-' spriteptr          long 0
	byte	$00, $00, $00, $00
'-' 
'-' cmd             long    0
	byte	$00, $00, $00, $00
'-' buf1            long    $80000-16384-4096
	byte	$00, $b0, $07, $00
'-' buf2            long    1024
	byte	$00, $04, $00, $00
'-' dlptr2          long    1
	byte	$01, $00, $00, $00
'-' dl              long    1
	byte	$01, $00, $00, $00
'-' 
'-' buf1c long 0
	byte	$00, $00, $00, $00
'-' buf1d            long    $80000-16384-4096
	byte	$00, $b0, $07, $00
'-' framebuf2       long    1
	byte	$01, $00, $00, $00
'-' hsync0          long    1
	byte	$01, $00, $00, $00
'-' hsync1          long    1
	byte	$01, $00, $00, $00
'-' 
'-' t1              long    1
	byte	$01, $00, $00, $00
'-' t2 long 0
	byte	$00, $00, $00, $00
'-' t3 long 0
	byte	$00, $00, $00, $00
'-' t4 long 0
	byte	$00, $00, $00, $00
'-' 
'-' rcnt            long    0  'dl repeat count
	byte	$00, $00, $00, $00
'-' rcnt2           long    0
	byte	$00, $00, $00, $00
'-' rcnt2a          long    0
	byte	$00, $00, $00, $00
'-' roffset         long    0
	byte	$00, $00, $00, $00
'-' rdl             long    0  'dl repeat line
	byte	$00, $00, $00, $00
'-' dlc             long    0  'dl command
	byte	$00, $00, $00, $00
'-' 
'-' affffffff       long    $ffffffff
	byte	$ff, $ff, $ff, $ff
'-' sprite1pointer long 0
	byte	$00, $00, $00, $00
'-' sprite1xy      long 0
	byte	$00, $00, $00, $00
'-' sprite1wh      long 0
	byte	$00, $00, $00, $00
'-' sprite2pointer long 0
	byte	$00, $00, $00, $00
'-' sprite2xy      long 0
	byte	$00, $00, $00, $00
'-' sprite2wh      long 0
	byte	$00, $00, $00, $00
'-' sprite3pointer long 0
	byte	$00, $00, $00, $00
'-' sprite3xy      long 0
	byte	$00, $00, $00, $00
'-' sprite3wh      long 0
	byte	$00, $00, $00, $00
'-' sprite4pointer long 0
	byte	$00, $00, $00, $00
'-' sprite4xy      long 0
	byte	$00, $00, $00, $00
'-' sprite4wh      long 0
	byte	$00, $00, $00, $00
'-' sprite5pointer long 0
	byte	$00, $00, $00, $00
'-' sprite5xy      long 0
	byte	$00, $00, $00, $00
'-' sprite5wh      long 0
	byte	$00, $00, $00, $00
'-' sprite6pointer long 0
	byte	$00, $00, $00, $00
'-' sprite6xy      long 0
	byte	$00, $00, $00, $00
'-' sprite6wh      long 0
	byte	$00, $00, $00, $00
'-' sprite7pointer long 0
	byte	$00, $00, $00, $00
'-' sprite7xy      long 0
	byte	$00, $00, $00, $00
'-' sprite7wh      long 0
	byte	$00, $00, $00, $00
'-' sprite8pointer long 0
	byte	$00, $00, $00, $00
'-' sprite8xy      long 0
	byte	$00, $00, $00, $00
'-' sprite8wh      long 0
	byte	$00, $00, $00, $00
'-' sprite9pointer long 0
	byte	$00, $00, $00, $00
'-' sprite9xy      long 0
	byte	$00, $00, $00, $00
'-' sprite9wh      long 0
	byte	$00, $00, $00, $00
'-' sprite10pointer long 0
	byte	$00, $00, $00, $00
'-' sprite10xy      long 0
	byte	$00, $00, $00, $00
'-' sprite10wh      long 0
	byte	$00, $00, $00, $00
'-' sprite11pointer long 0
	byte	$00, $00, $00, $00
'-' sprite11xy      long 0
	byte	$00, $00, $00, $00
'-' sprite11wh      long 0
	byte	$00, $00, $00, $00
'-' sprite12pointer long 0
	byte	$00, $00, $00, $00
'-' sprite12xy      long 0
	byte	$00, $00, $00, $00
'-' sprite12wh      long 0
	byte	$00, $00, $00, $00
'-' sprite13pointer long 0
	byte	$00, $00, $00, $00
'-' sprite13xy      long 0
	byte	$00, $00, $00, $00
'-' sprite13wh      long 0
	byte	$00, $00, $00, $00
'-' sprite14pointer long 0
	byte	$00, $00, $00, $00
'-' sprite14xy      long 0
	byte	$00, $00, $00, $00
'-' sprite14wh      long 0
	byte	$00, $00, $00, $00
'-' sprite15pointer long 0
	byte	$00, $00, $00, $00
'-' sprite15xy      long 0
	byte	$00, $00, $00, $00
'-' sprite15wh      long 0
	byte	$00, $00, $00, $00
'-' sprite16pointer long 0
	byte	$00, $00, $00, $00
'-' sprite16xy      long 0
	byte	$00, $00, $00, $00
'-' sprite16wh      long 0
	byte	$00, $00, $00, $00
'-' sprite17pointer long 0
	byte	$00, $00, $00, $00
'-' sprite17xy      long 0
	byte	$00, $00, $00, $00
'-' sprite17wh      long 0
	byte	$00, $00, $00, $00
'-' sprite18pointer long 0
	byte	$00, $00, $00, $00
'-' sprite18xy      long 0
	byte	$00, $00, $00, $00
'-' sprite18wh      long 0
	byte	$00, $00, $00, $00
'-' spritenum long 0
	byte	$00, $00, $00, $00
'-' 
'-' spriteline long 0
	byte	$00, $00, $00, $00
'-' sprite_x long 900
	byte	$84, $03, $00, $00
'-' sprite_y long 0
	byte	$00, $00, $00, $00
'-' sprite_w long 16
	byte	$10, $00, $00, $00
'-' sprite_h long 64
	byte	$40, $00, $00, $00
'-' l2 long 0
	byte	$00, $00, $00, $00
'-' t5 long 0
	byte	$00, $00, $00, $00
'-' t6 long 0
	byte	$00, $00, $00, $00
'-' t7 long 0
	byte	$00, $00, $00, $00
'-' t8 long 0
	byte	$00, $00, $00, $00
'-' t9 long 0
	byte	$00, $00, $00, $00
'-' preloadaddr long 0
	byte	$00, $00, $00, $00
'-' preloadlineaddr long 0
	byte	$00, $00, $00, $00
'-' a1024 long 1024
	byte	$00, $04, $00, $00
'-' 
'-' aa long 992
	byte	$e0, $03, $00, $00
'-' a1023 long 1023
	byte	$ff, $03, $00, $00
'-' a4096 long 4096
	byte	$00, $10, $00, $00
'-'  fit 368
	alignl
_psram_spin2_dat_
'-'     listdata long 0[8*8]
	byte	$00[256]
'-'             orgh
'-' 
'-' ' driver state
'-' drivercog   long    -1  ' COG id of driver
	byte	$ff, $ff, $ff, $ff
'-' driverlock  long    -1  ' LOCK id of driver
	byte	$ff, $ff, $ff, $ff
'-' 
'-' ' delay profile
'-' delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
	byte	$07, $00, $00, $00, $00, $cf, $7b, $05, $80, $d1, $f0, $08, $80, $4f, $47, $0c
	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
'-' 
'-' ' data to be passed to driver when starting it
'-' startupData
'-'     long    0           ' current frequency
	byte	$00, $00, $00, $00
'-'     long    FLAGS       ' optional flags for driver
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port A for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port B for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    DATABUS     ' PSRAM data bus start pin
	byte	$28, $00, $00, $00
'-'     long    deviceData  ' address of devices data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 328
'-'     long    qosData     ' address of QoS data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 456
'-'     long    mailboxes   ' address of mailbox structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 488
'-' 
'-' ' data for memory
'-' deviceData
'-'     ' 16 bank parameters follow (16MB per bank)
'-'     long    0[16]                               ' banks 0-15
	byte	$00[64]
'-'     ' 16 banks of pin parameters follow
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
	byte	$39, $38, $00, $00
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
	byte	$39, $38, $00, $00
'-'     long    -1[14]                              ' banks 2-15
	byte	$ff[56]
'-' 
'-' ' data for COG polling
'-' qosData 
'-'     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
'-'     
'-' ' mailbox storage
'-' 
'-' mailboxes
'-'     long    0[8*3]          ' 3 longs per mailbox per COG
	byte	$00[96]
	alignl
_psram16drv_spin2_dat_
'-'                             orgh
'-' scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
	byte	$00[32]
'-' 
'-' driver_start
'-'                             org
'-' '..................................................................................................
'-' ' Memory layout for COG RAM once operational:
'-' '
'-' '  COG RAM address      Usage
'-' '  ---------------      ----
'-' '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
'-' '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
'-' '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
'-' '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
'-' '   $100-$197           Mailbox poller, error handlers, and all driver management code
'-' '  ~$198-$1F3           State and register variables
'-' '
'-' ' Also during driver COG startup:
'-' '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
'-' ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
'-' '..................................................................................................
'-'                             
'-' ' Mailbox storage after vector initialization
'-' 
'-' req0                        call    #init                   'do HW setup/initialization
	byte	$fc, $01, $b0, $fd
'-' data0                       rdlut   c, b wz                 'read bank info          
	byte	$f0, $e3, $ab, $fa
'-' count0                      mov     a, b                    'set COGRAM address low nibble
	byte	$f0, $df, $03, $f6
'-' req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
	byte	$68, $f0, $07, $a6
'-' data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
	byte	$0a, $e2, $17, $f4
'-' count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
	byte	$50, $f0, $07, $16
'-' req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
	byte	$58, $f0, $07, $46
'-' data2                       mov     c, #$8                  'setup vector base to $80
	byte	$08, $e2, $07, $f6
'-' count2                      setnib  a, c, #1                'prepare vector base address for bank
	byte	$f1, $df, $0b, $f8
'-' req3                        altd    a, #0                   'prepare COG destination read address
	byte	$00, $de, $8f, $f9
'-' data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
	byte	$61, $01, $a4, $fa
'-' count3                      incmod  c, #15 wz               'next vector
	byte	$0f, $e2, $0f, $f7
'-' req4        if_nz           jmp     #count2                 'repeat
	byte	$ec, $ff, $9f, $5d
'-' data4                       incmod  b, #15 wz               'next bank
	byte	$0f, $e0, $0f, $f7
'-' count4      if_nz           jmp     #data0                  'repeat
	byte	$c8, $ff, $9f, $5d
'-' req5                        mov     ptra, #$20              'setup base LUT address to clear
	byte	$20, $f0, $07, $f6
'-' data5                       rep     #5, #80                 'update next 80 longs      
	byte	$50, $0a, $dc, $fc
'-' count5                      cmp     ptra, header wc         'check if LUT address range 
	byte	$e2, $f1, $13, $f2
'-' req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
	byte	$e3, $f1, $93, $32
'-' data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
	byte	$61, $01, $3c, $cc
'-' count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
	byte	$61, $b1, $37, $3c
'-' req7        if_nc           add     $-1, const512           'increment source of LUT write data
	byte	$a5, $29, $00, $31
'-' data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
	byte	$ff, $c0, $03, $f6
'-' count7      _ret_           mov     255, #dolist            'setup list address, return to notify
	byte	$26, $ff, $05, $06
'-' 
'-' ' Mailbox parameter addresses per COG once patched
'-'                             
'-' cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
	byte	$04, $00, $00, $00
'-' cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
	byte	$10, $00, $00, $00
'-' cog2mboxdata                long    2*12+4                  '...
	byte	$1c, $00, $00, $00
'-' cog3mboxdata                long    3*12+4
	byte	$28, $00, $00, $00
'-' cog4mboxdata                long    4*12+4
	byte	$34, $00, $00, $00
'-' cog5mboxdata                long    5*12+4
	byte	$40, $00, $00, $00
'-' cog6mboxdata                long    6*12+4
	byte	$4c, $00, $00, $00
'-' cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
	byte	$58, $00, $00, $00
'-' 
'-' '..................................................................................................
'-' ' Per COG request and state setup and service branching
'-'         
'-' cog0                 
'-'                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
	byte	$20, $f0, $07, $f6
'-'                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
	byte	$18, $f2, $03, $f6
'-'                             mov     id, id0                 'get COG0 state
	byte	$d0, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG0 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$30, $04, $90, $5d
'-'                             mov     addr1, req0             'get mailbox request parameter for COG0
	byte	$00, $b0, $03, $f6
'-'                             mov     hubdata, data0          'get COG0 mailbox data parameter
	byte	$01, $b2, $03, $f6
'-'                             mov     count, count0           'get COG0 mailbox count parameter
	byte	$02, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog1                        
'-'                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
	byte	$2a, $f0, $07, $f6
'-'                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
	byte	$19, $f2, $03, $f6
'-'                             mov     id, id1                 'get COG1 state
	byte	$d1, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG1 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$00, $04, $90, $5d
'-'                             mov     addr1, req1             'get mailbox request parameter for COG1
	byte	$03, $b0, $03, $f6
'-'                             mov     hubdata, data1          'get COG1 mailbox data parameter
	byte	$04, $b2, $03, $f6
'-'                             mov     count, count1           'get COG1 mailbox count parameter
	byte	$05, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog2                         
'-'                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
	byte	$34, $f0, $07, $f6
'-'                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
	byte	$1a, $f2, $03, $f6
'-'                             mov     id, id2                 'get COG2 state
	byte	$d2, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG2 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$d0, $03, $90, $5d
'-'                             mov     addr1, req2             'get mailbox request parameter for COG2
	byte	$06, $b0, $03, $f6
'-'                             mov     hubdata, data2          'get COG2 mailbox data parameter
	byte	$07, $b2, $03, $f6
'-'                             mov     count, count2           'get COG2 mailbox count parameter
	byte	$08, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog3                        
'-'                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
	byte	$3e, $f0, $07, $f6
'-'                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
	byte	$1b, $f2, $03, $f6
'-'                             mov     id, id3                 'get COG3 state
	byte	$d3, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG3 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$a0, $03, $90, $5d
'-'                             mov     addr1, req3             'get mailbox request parameter for COG3
	byte	$09, $b0, $03, $f6
'-'                             mov     hubdata, data3          'get COG3 mailbox data parameter
	byte	$0a, $b2, $03, $f6
'-'                             mov     count, count3           'get COG3 mailbox count parameter
	byte	$0b, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog4                        
'-'                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
	byte	$48, $f0, $07, $f6
'-'                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
	byte	$1c, $f2, $03, $f6
'-'                             mov     id, id4                 'get COG4 state
	byte	$d4, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG4 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$70, $03, $90, $5d
'-'                             mov     addr1, req4             'get mailbox request parameter for COG4
	byte	$0c, $b0, $03, $f6
'-'                             mov     hubdata, data4          'get COG4 mailbox data parameter
	byte	$0d, $b2, $03, $f6
'-'                             mov     count, count4           'get COG4 mailbox count parameter
	byte	$0e, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog5                        
'-'                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
	byte	$52, $f0, $07, $f6
'-'                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
	byte	$1d, $f2, $03, $f6
'-'                             mov     id, id5                 'get COG5 state
	byte	$d5, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG5 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$40, $03, $90, $5d
'-'                             mov     addr1, req5             'get mailbox request parameter for COG5
	byte	$0f, $b0, $03, $f6
'-'                             mov     hubdata, data5          'get COG5 mailbox data parameter
	byte	$10, $b2, $03, $f6
'-'                             mov     count, count5           'get COG5 mailbox count parameter
	byte	$11, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog6                        
'-'                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
	byte	$5c, $f0, $07, $f6
'-'                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
	byte	$1e, $f2, $03, $f6
'-'                             mov     id, id6                 'get COG6 state
	byte	$d6, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG6 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$10, $03, $90, $5d
'-'                             mov     addr1, req6             'get mailbox request parameter for COG6
	byte	$12, $b0, $03, $f6
'-'                             mov     hubdata, data6          'get COG6 mailbox data parameter
	byte	$13, $b2, $03, $f6
'-'                             mov     count, count6           'get COG6 mailbox count parameter
	byte	$14, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog7                        
'-'                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
	byte	$66, $f0, $07, $f6
'-'                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
	byte	$1f, $f2, $03, $f6
'-'                             mov     id, id7                 'get COG7 state
	byte	$d7, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG7 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$e0, $02, $90, $5d
'-'                             mov     addr1, req7             'get mailbox request parameter for COG7
	byte	$15, $b0, $03, $f6
'-'                             mov     hubdata, data7          'get COG7 mailbox data parameter
	byte	$16, $b2, $03, $f6
'-'                             mov     count, count7           'get COG7 mailbox count parameter
	byte	$17, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-'                             fit     128
'-' 
'-'                             fit     128
'-' pad                         long    0[128-$]                'align init code to $80
'-' 
'-' '..................................................................................................
'-' 
'-' ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
'-' 
'-' init                        
'-'                             ' get driver scratch long address in hub
'-'                             cogid   hubscratch              'get cogid
	byte	$01, $da, $63, $fd
'-'                             add     hubscratch, #1          'increase by 1 from 1-8
	byte	$01, $da, $07, $f1
'-'                             mul     hubscratch, #4          'multiply by 4 to get 4-32
	byte	$04, $da, $07, $fa
'-'                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
	byte	$f9, $db, $c3, $f2
'-'                     
'-'                             ' read in the additional LUT RAM code
'-'                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
	byte	$f9, $41, $03, $f1
'-'                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
	byte	$29, $9e, $67, $fd
'-'                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
	byte	$a0, $61, $00, $fb
'-' 
'-'                             ' read the startup parameters
'-'                             setq    #8-1                    'read 8 longs from hub
	byte	$28, $0e, $64, $fd
'-'                             rdlong  startupparams, ptra     '.. as the startup parameters 
	byte	$00, $41, $07, $fb
'-' 
'-'                             ' setup some of the config flag dependent state and patch LUTRAM
'-'                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
	byte	$1c, $42, $0f, $f4
'-' 
'-'             if_z            add     expansion, ptrb         'compensate for HUB address
	byte	$f9, $71, $03, $a1
'-'             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
	byte	$01, $00, $00, $5f, $fb, $70, $07, $56
'-'                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
	byte	$1d, $42, $17, $f4
'-'             if_nc           or      clkconfig, registered   'enable this if so
	byte	$aa, $57, $43, $35
'-'             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
	byte	$00, $58, $07, $36
'-' 
'-'                             ' setup data pin modes and data bus pin group in streamer commands
'-'                             and     datapins, #%111000      'compute base pin
	byte	$38, $48, $07, $f5
'-'                             or      datapins, ##(15<<6)     'configure 16 pins total
	byte	$01, $00, $00, $ff, $c0, $49, $47, $f5
'-'                             mov     a, datapins             'get data pin base
	byte	$a4, $df, $03, $f6
'-'                             wrpin   registered, datapins    'prepare data pins for address phase transfer
	byte	$a4, $55, $03, $fc
'-'                             shr     a, #3                   'determine data pin group
	byte	$03, $de, $47, $f0
'-'                             and     a, #7                   'ignore the unwanted bits
	byte	$07, $de, $07, $f5
'-'                             or      a, #8
	byte	$08, $de, $47, $f5
'-'                             setnib  ximm8lut, a, #5         'setup bus group in streamer
	byte	$ef, $2f, $2b, $f8
'-'                             setnib  xrecvlo8, a, #5
	byte	$ef, $31, $2b, $f8
'-'                             setnib  xrecvdata, a, #5
	byte	$ef, $35, $2b, $f8
'-'                             setnib  xsenddata, a, #5
	byte	$ef, $37, $2b, $f8
'-'                             setnib  xsendimm, a, #5
	byte	$ef, $39, $2b, $f8
'-'                             add     a, #1
	byte	$01, $de, $07, $f1
'-'                             setnib  xrecvhi8, a, #5         ' increase port by one
	byte	$ef, $33, $2b, $f8
'-'  
'-'                             ' setup device control pin states
'-'                             setq2   #32-1                   'read 32 longs to LUTRAM
	byte	$29, $3e, $64, $fd
'-'                             rdlong  $000, devicelist        'read bank/pin data for all banks    
	byte	$a5, $01, $00, $fb
'-'                             mov     const512, ##512         'prepare constant
	byte	$01, $00, $00, $ff, $00, $4a, $07, $f6
'-' 
'-'                             mov     ptrb, #16               'point to bank pin config data
	byte	$10, $f2, $07, $f6
'-'                             rep     @pinloop, #16           'iterate through 16 banks
	byte	$10, $14, $dc, $fc
'-'                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
	byte	$e1, $cf, $b7, $fa
'-'                             and     pinconfig, pinmask      'save us from invalid bits in args
	byte	$af, $cf, $03, $f5
'-'             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
	byte	$e7, $53, $e3, $38
'-'             if_nc           wrpin   #0, cspin               'clear smart pin mode
	byte	$a9, $01, $08, $3c
'-'             if_nc           drvh    cspin                   'setup pins for all banks
	byte	$59, $52, $63, $3d
'-'             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
	byte	$e7, $51, $eb, $38
'-'             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
	byte	$50, $50, $63, $3d
'-'             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
	byte	$a8, $57, $03, $3c
'-'             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
	byte	$a8, $03, $18, $3c
'-'             if_nc           drvl    clkpin                  'set clk state low
	byte	$58, $50, $63, $3d
'-' pinloop
'-'                             ' generate minimum CE high time before access
'-'                             qdiv    frequency, ##1000000    'convert from Hz to MHz
	byte	$a1, $07, $00, $ff, $40, $40, $17, $fd
'-'                             getqx   c                       'get P2 clocks per microsecond
	byte	$18, $e2, $63, $fd
'-'                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
	byte	$96, $de, $07, $f6
'-'                             mul     a, c                    'convert microseconds to clocks
	byte	$f1, $df, $03, $fa
'-'                             waitx   a                       'delay
	byte	$1f, $de, $63, $fd
'-'                             call    #hwinit                 'setup HW into QSPI mode
	byte	$e8, $05, $b0, $fd
'-' 
'-'                             ' setup the COG mailboxes and addresses 
'-'                             rep     #2, #8                  'setup loop to patch mailbox addresses
	byte	$08, $04, $dc, $fc
'-'                             alti    $+1, #%111_000          'increase D field
	byte	$38, $70, $a5, $f9
'-'                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
	byte	$a7, $31, $00, $f1
'-' 
'-'                             setq    #24-1
	byte	$28, $2e, $64, $fd
'-'                             wrlong  #0, mbox                'clear out mailboxes ????
	byte	$a7, $01, $68, $fc
'-' 
'-'                             ' setup the polling loop for active COGs 
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             alts    id, #id0                'determine id register of control COG
	byte	$d0, $c3, $97, $f9
'-'                             setd    patchid, #0             'patch into destination address
	byte	$00, $90, $b6, $f9
'-'                             push    ptra                    'save ptra before we lose it
	byte	$2a, $f0, $63, $fd
'-'                             mov     ptra, #10
	byte	$0a, $f0, $07, $f6
'-'                             mul     ptra, id
	byte	$e1, $f1, $03, $fa
'-'                             add     ptra, #$20              'prep ptra for reloadcogs
	byte	$20, $f0, $07, $f1
'-'                             alts    id, #cog0_handler       'add to handler base
	byte	$b0, $c3, $97, $f9
'-'                             sets    ctrlpollinst, #0-0      'patch into jump instruction
	byte	$00, $48, $be, $f9
'-'                             mul     id, #3
	byte	$03, $c2, $07, $fa
'-'                             setd    ctrlpollinst, id
	byte	$e1, $49, $b2, $f9
'-'                             rdlut   id, ptra[9]             'save original value
	byte	$09, $c3, $a7, $fa
'-'                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
	byte	$09, $c1, $37, $fc
'-'                             call    #reloadcogs
	byte	$d8, $01, $b0, $fd
'-'                             wrlut   id, ptra[9]             'restore original value
	byte	$09, $c3, $37, $fc
'-'                             pop     ptra                    'restore original ptra
	byte	$2b, $f0, $63, $fd
'-'                             ' move LUT control vectors into temporary location to avoid clobbering them later
'-'                             setd    d, #addr1
	byte	$d8, $e5, $b7, $f9
'-'                             sets    d, #(ctrl_vect & $1ff)
	byte	$60, $e4, $bf, $f9
'-'                             rep     #2, #8
	byte	$08, $04, $dc, $fc
'-'                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
	byte	$3f, $e4, $a7, $f9
'-'                             rdlut   addr1-0, #$60-0
	byte	$60, $b0, $a7, $fa
'-' 
'-'                             'setup control COG service handling, we need to patch 5 instructions
'-'                             'one existing instruction is moved earlier and four instructions get replaced
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             mov     a, #(cog1-cog0)         'get code separation of handlers
	byte	$0c, $de, $07, $f6
'-'                             mul     a, id                   'scale ID by separation
	byte	$e1, $df, $03, $fa
'-'                             add     a, #cog0+4              'add to base for COG0 and offset
	byte	$24, $de, $07, $f1
'-'                             setd    d, a                    'set this as the destination
	byte	$ef, $e5, $b3, $f9
'-'                             add     a, #2                   'increment COG address
	byte	$02, $de, $07, $f1
'-'                             sets    d, a                    'set this as the source
	byte	$ef, $e5, $bb, $f9
'-'                             alti    d, #%111_100             
	byte	$3c, $e4, $a7, $f9
'-'                             mov     0-0, 0-0                'move instruction
	byte	$00, $00, $00, $f6
'-'                             sets    d, #controlpatch        'set source of patched instructions
	byte	$ee, $e4, $bf, $f9
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             add     d, const512             'skip two instructions
	byte	$a5, $e5, $03, $f1
'-'                             add     d, const512
	byte	$a5, $e5, $03, $f1
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             
'-'                             ' setup register values for control vector loop setup after we return
'-'                             mov     header, id              'get cog ID
	byte	$e1, $c5, $03, $f6
'-'                             mul     header, #10             'multiply by size of state memory per COG
	byte	$0a, $c4, $07, $fa
'-'                             add     header, #$20            'add to COG state base address in LUT
	byte	$20, $c4, $07, $f1
'-'                             mov     trailer, header         'determine start/end LUT address
	byte	$e2, $c7, $03, $f6
'-'                             add     trailer, #9             '...for control region
	byte	$09, $c6, $07, $f1
'-'                             or      id, initctrl            'set id field for control COG
	byte	$e0, $c3, $43, $f5
'-'                             altd    id, #id0
	byte	$d0, $c3, $8f, $f9
'-'                             mov     0-0, id                 'setup id field for notification
	byte	$e1, $01, $00, $f6
'-'                             mov     ptrb, ptra              'get startup parameter address
	byte	$f8, $f3, $03, $f6
'-'                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
	byte	$04, $f2, $07, $f1
'-'                             mov     b, #0                   'prepare b for upcoming loop
	byte	$00, $e0, $07, $f6
'-'                 _ret_       push    #notify                 'continue init in mailbox area
	byte	$2a, $14, $66, $0d
'-'  
'-' controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
	byte	$d8, $cb, $7b, $f8
'-'                             and     request, #7
	byte	$07, $ca, $07, $f5
'-'                             add     request, ptra           'add request vector offset
	byte	$f8, $cb, $03, $f1
'-'                             rdlut   request, request        'lookup jump vector service table 
	byte	$e5, $cb, $a3, $fa
'-'                             fit     $100                    'ensure all init code fits this space
'-' 
'-'                             fit     $100                    'ensure all init code fits this space
'-' 
'-'                             long    0[$100-$]               'pad more if required until table ends
	byte	$00[56]
'-' 
'-' '..................................................................................................
'-' ' Error result handling and COG notification of request completion
'-' 
'-' unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
	byte	$04, $04, $4c, $fb
'-' invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
	byte	$03, $02, $4c, $fb
'-' invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
	byte	$02, $06, $4c, $fb
'-' alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
	byte	$01, $08, $4c, $fb
'-' busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
	byte	$05, $ec, $07, $f6
'-' err                         altd    id, #id0                'adjust for the running COG
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
	byte	$09, $00, $04, $f4
'-'                             wrlut   #0, ptra[8]             'cancel any resume state
	byte	$08, $01, $3c, $fc
'-'                             skipf   #%10                    'dont notify with success code 0 below
	byte	$32, $04, $64, $fd
'-'                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
	byte	$bf, $ed, $67, $fc
'-' notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
	byte	$bf, $01, $6c, $fc
'-'                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
	byte	$0b, $c2, $0f, $f4
'-'                             decod   a, id                   'convert COG ID to bitmask
	byte	$e1, $df, $c3, $f9
'-'             if_z            cogatn  a                       'notify COG via ATN
	byte	$3f, $de, $63, $ad
'-' ' Poller re-starts here after a COG is serviced
'-' poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
	byte	$0f, $c2, $0f, $f4
'-'             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
	byte	$e6, $5f, $03, $57
'-'                             bmask   mask, rrcounter         'generate a RR skip mask from the count
	byte	$af, $45, $cb, $f9
'-' ' Main dynamic polling loop repeats until a request arrives
'-' polling_loop                rep     #0-0, #0                'repeat until we get a request for something
	byte	$00, $00, $dc, $fc
'-'                             setq    #24-1                   'read 24 longs
	byte	$28, $2e, $64, $fd
'-'                             rdlong  req0, mbox              'get all mailbox requests and data longs
	byte	$a7, $01, $00, $fb
'-' 
'-' polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
	byte	$b0, $01, $b0, $fb
'-'                             skipf   mask                    ']after all priority COG handlers if present
	byte	$32, $44, $63, $fd
'-'                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']based on the active COGs being polled
	byte	$b6, $25, $b0, $fb
'-'                             tjs     req7, cog7_handler      ']and whether priority or round robin.
	byte	$b7, $2b, $b0, $fb
'-'                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']have changed.
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
	byte	$b6, $25, $b0, $fb
'-' pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
	byte	$b7, $2b, $b0, $fb
'-' 
'-' ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
	byte	$b0, $01, $b0, $fb
'-' skipfinst                   skipf   mask                    'instruction template for skipf
	byte	$32, $44, $63, $fd
'-'  
'-' '..................................................................................................
'-' ' List handler                               
'-' 
'-' dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
	byte	$01, $b0, $a7, $fb
'-'                             execf   burstwrite              'otherwise do a burst write to this bank
	byte	$33, $c0, $63, $fd
'-' real_list                   setq    #8-1                    'read 8 longs (largest request size)
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, hubdata          '..to update the request state
	byte	$d9, $b1, $03, $fb
'-'                             tjns    addr1, #invalidlist     'error if request list item not valid
	byte	$d7, $b1, $bf, $fb
'-'                             altd    id, #id0                'get COG state
	byte	$d0, $c3, $8f, $f9
'-'                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
	byte	$09, $00, $3c, $f4
'-'                             bith    id, #LIST_BIT           'retain fact that we are in a list
	byte	$09, $c2, $27, $f4
'-'             if_z            jmp     #unsupported            'no list recursion is allowed!
	byte	$44, $ff, $9f, $ad
'-'                             getbyte request, addr1, #3      'get upper byte of this request
	byte	$d8, $cb, $fb, $f8
'-' service_request             altd    request, #0             'get request address in COG RAM
	byte	$00, $ca, $8f, $f9
'-'                             execf   0-0                     'process the request 
	byte	$33, $00, $60, $fd
'-' 
'-' '..................................................................................................
'-' ' Restoring per COG state and resuming where we left off
'-' 
'-' restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
	byte	$00, $b1, $a7, $fa
'-'                             rdlut   hubdata, ptra[1]
	byte	$01, $b3, $a7, $fa
'-'                             rdlut   count, ptra[2]
	byte	$02, $b5, $a7, $fa
'-'                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
	byte	$03, $b7, $b7, $fa
'-'                             getbyte request, addr1, #3
	byte	$d8, $cb, $fb, $f8
'-'             if_nc           execf   resume                  'if not extended then resume immediately
	byte	$33, $d2, $63, $3d
'-'                             rdlut   total, ptra[4]          'we need to read the extended parameters
	byte	$04, $b9, $a7, $fa
'-'                             rdlut   offset1, ptra[5]
	byte	$05, $bb, $a7, $fa
'-'                             rdlut   offset2, ptra[6]
	byte	$06, $bd, $a7, $fa
'-'                             rdlut   link, ptra[7]
	byte	$07, $bf, $a7, $fa
'-'                             rdlut   orighubsize, ptra[9]
	byte	$09, $d5, $a7, $fa
'-'                             execf   resume                  'then resume what we were doing last time
	byte	$33, $d2, $63, $fd
'-'                    
'-' '..................................................................................................
'-' ' Re-configuration of QoS settings and custom polling loop sequence generator
'-' 
'-' reconfig                    push    #notify                 'setup return addr, then reload 
	byte	$2a, $14, $66, $fd
'-' reloadcogs                  setq    #8-1                    'reload all per COG QoS params
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
	byte	$a6, $b1, $03, $fb
'-'                             setd    a, #id0
	byte	$d0, $df, $b7, $f9
'-'                             sets    a, #addr1
	byte	$d8, $df, $bf, $f9
'-'                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
	byte	$fe, $ff, $ff, $ff, $28, $00, $66, $fd
'-'                             rep     #2, #8                  'repeat for 8 COGs
	byte	$08, $04, $dc, $fc
'-'                             alti    a, #%111_111 
	byte	$3f, $de, $a7, $f9
'-'                             muxq    0-0, 0-0
	byte	$00, $00, $f0, $f9
'-' patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
	byte	$09, $01, $a4, $fa
'-'                             cogid   c
	byte	$01, $e2, $63, $fd
'-'                             decod   excludedcogs, c         'exclude driver cog initially
	byte	$f1, $41, $c3, $f9
'-'                             mov     a, #$8                  'a iterates through prio levels 8=lowest
	byte	$08, $de, $07, $f6
'-'                             neg     pa, #1                  'start with all ones
	byte	$01, $ec, $67, $f6
'-' fillprio                    mov     c, #7                   'c iterates through cogs
	byte	$07, $e2, $07, $f6
'-' prioloop                    alts    c, #id0
	byte	$d0, $e3, $97, $f9
'-'                             mov     b, 0-0
	byte	$00, $e0, $03, $f6
'-'                             getword d, b, #1                'get burst field
	byte	$f0, $e5, $3b, $f9
'-'                             test    d wz                    'if burst=0 
	byte	$f2, $e5, $cb, $f7
'-'             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
	byte	$f1, $41, $23, $a4
'-'             if_z            jmp     #excluded               
	byte	$0c, $00, $90, $ad
'-'                             getnib  d, b, #3                'get RR/PRI flag & priority
	byte	$f0, $e5, $5b, $f8
'-'                             cmp     d, a wz                 'compare against current priority level
	byte	$ef, $e5, $0b, $f2
'-'             if_z            rolnib  pa, c, #0               'if matches include COG at this level
	byte	$f1, $ed, $83, $a8
'-' excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
	byte	$f6, $e3, $7f, $fb
'-'                             incmod  a, #15 wz               'next level
	byte	$0f, $de, $0f, $f7
'-'             if_nz           jmp     #fillprio 
	byte	$cc, $ff, $9f, $5d
'-' 
'-' 'determine priority cogs and build instructions for the polling sequence
'-'                             mov     pb, #0                  'clear out set of priority COGs
	byte	$00, $ee, $07, $f6
'-'                             mov     a, #3                   'start with no COGs being polled + 3 instructions
	byte	$03, $de, $07, $f6
'-'                             setd    d, #polling_code        'initialize COGRAM write position
	byte	$14, $e5, $b7, $f9
'-' 
'-'                             rep     @endprioloop, #8        'test all 8 priority slots
	byte	$08, $18, $dc, $fc
'-'                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
	byte	$03, $ec, $17, $f4
'-'                             getnib  c, pa, #0               'get cogid ID at this priority level
	byte	$f6, $e3, $43, $f8
'-'             if_nc           testb   pb, c wz                'check if already exists as priority COG
	byte	$f1, $ef, $0b, $34
'-'             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
	byte	$f1, $ef, $23, $14
'-'             if_nc_and_nz    add     a, #1                   'add another COG to poll 
	byte	$01, $de, $07, $11
'-'             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
	byte	$b0, $e3, $97, $19
'-'             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $19
'-'             if_nc_and_nz    mul     c, #3
	byte	$03, $e2, $07, $1a
'-'             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
	byte	$f1, $47, $b2, $19
'-'             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $19
'-'             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $16
'-'                             ror     pa, #4                  'advance to next priority
	byte	$04, $ec, $07, $f0
'-' endprioloop
'-'                             xor     pb, #$ff                'invert to find all the non-priority COGs
	byte	$ff, $ee, $67, $f5
'-'                             andn    pb, excludedcogs        'and remove any other excluded COGs
	byte	$a0, $ef, $23, $f5
'-'                             ones    rrlimit, pb wz          'count the number of RR COGs
	byte	$f7, $cd, $ab, $f7
'-'                             add     a, rrlimit              'account for this number of RR COGs to poll
	byte	$e6, $df, $03, $f1
'-'                             sub     rrlimit, #1             'setup last RR count value for incmod
	byte	$01, $cc, $87, $f1
'-'                             alti    d, #%111_000            'generate the control polling instruction
	byte	$38, $e4, $a7, $f9
'-'                             mov     0-0, ctrlpollinst       'write the instruction
	byte	$24, $01, $00, $f6
'-'             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
	byte	$38, $e4, $a7, $59
'-'             if_nz           mov     0-0, skipfinst          'add the skipf instruction
	byte	$25, $01, $00, $56
'-'             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
	byte	$02, $de, $07, $51
'-'                             setd    polling_loop, a         'save it as the repeat count
	byte	$ef, $23, $b2, $f9
'-'             if_z            ret                             'we are done now, if no round robin COGs
	byte	$2d, $00, $64, $ad
'-' 
'-' ' populate the round robin COG polling instructions
'-'                             mov     rrcounter, #2           'fill the RR poll instruction list twice
	byte	$02, $5e, $07, $f6
'-' rrloop                      mov     b, pb                   'get the set of RR COGs
	byte	$f7, $e1, $03, $f6
'-'                             mov     c, #0                   'start at COG ID = 0
	byte	$00, $e2, $07, $f6
'-'                             mov     a, #0                   'req mailbox COGRAM address for COG 0
	byte	$00, $de, $07, $f6
'-' nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
	byte	$01, $e0, $5f, $f0
'-'             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
	byte	$ef, $47, $b2, $c9
'-'             if_c            alts    c, #cog0_handler        'determine jump address
	byte	$b0, $e3, $97, $c9
'-'             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $c9
'-'             if_c            alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $c9
'-'             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $c6
'-'                             add     c, #1                   'increment the COG ID
	byte	$01, $e2, $07, $f1
'-'                             add     a, #3                   'increase the request address
	byte	$03, $de, $07, $f1
'-'             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
	byte	$dc, $ff, $9f, $5d
'-'             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
	byte	$f3, $5f, $6f, $0b
'-' '..................................................................................................
'-' ' Code to get/set driver settings per bank or to dump COG/LUT state
'-' 
'-' set_latency                                                 '            (a) set latency
'-' get_latency                                                 '            (b) get latency
'-' set_burst                                                   '            (c) set burst size of bank
'-' get_burst                                                   '            (d) get burst size of bank
'-'                                                             '            (e) dump state
'-'                             getnib  b, addr1, #6            ' a b c d    get bank address
	byte	$d8, $e1, $73, $f8
'-' dump_state                  setq    #511                    ' | | | | e  prepare burst write
	byte	$28, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                                                             ' | | | | e  account for following AUGS
'-'                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
	byte	$04, $00, $00, $ff, $00, $b2, $07, $f1
'-'                             setq2   #511                    ' | | | | e  prepare burst write
	byte	$29, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                             add     b, #16                  ' a b | | |  point to latency params
	byte	$10, $e0, $07, $f1
'-'                             rdlut   a, b                    ' a b c d |  read data for bank
	byte	$f0, $df, $a3, $fa
'-'                             setbyte a, hubdata, #3          ' a | | | |  patch latency
	byte	$d9, $df, $db, $f8
'-'                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
	byte	$d9, $df, $03, $f6
'-'                             wrlut   a, b                    ' a | c | |  if setting, save bank data
	byte	$f0, $df, $33, $fc
'-'                             getbyte a, a, #3                ' | b | | |  extract latency field only
	byte	$ef, $df, $fb, $f8
'-'                             wrlong  a, ptrb                 ' | b | d |  write result          
	byte	$80, $df, $67, $fc
'-'                             jmp     #notify                 ' a b c d e  return success
	byte	$dc, $fd, $9f, $fd
'-' 
'-' '..................................................................................................
'-' ' Misc EXECF code
'-' 
'-' start_read_exec             execf   newburstr
	byte	$33, $72, $63, $fd
'-' start_write_exec            execf   resumewrites
	byte	$33, $7c, $63, $fd
'-' continue_read_exec          execf   lockedreads
	byte	$33, $78, $63, $fd
'-' continue_write_exec         execf   lockedwrites
	byte	$33, $7a, $63, $fd
'-' 
'-' '..................................................................................................
'-' ' Variables
'-' 
'-' ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
	byte	$08, $00, $cf, $20
'-' xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
	byte	$00, $00, $c0, $f0
'-' xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
	byte	$00, $00, $c0, $b0
'-' xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
	byte	$02, $00, $c0, $70
'-' 
'-' xfreq1          long    $80000000
	byte	$00, $00, $00, $80
'-' xfreq2          long    $40000000
	byte	$00, $00, $00, $40
'-' delay           long    3
	byte	$03, $00, $00, $00
'-' 
'-' lutcodeaddr                 
'-' startupparams
'-' excludedcogs                                    'careful: shared register use!
'-' frequency       long    lut_code - driver_start 'determine offset of LUT code from base
	byte	$cc, $07, $00, $00
'-' flags           long    0
	byte	$00, $00, $00, $00
'-' mask                                            'careful: shared register use!
'-' resetmaskA      long    0
	byte	$00, $00, $00, $00
'-' limit                                           'careful: shared register use!
'-' resetmaskB      long    0
	byte	$00, $00, $00, $00
'-' datapins        long    0
	byte	$00, $00, $00, $00
'-' const512                                        'careful: shared register use!
'-' devicelist      long    0
	byte	$00, $00, $00, $00
'-' coglist         long    0
	byte	$00, $00, $00, $00
'-' mbox            long    0 
	byte	$00, $00, $00, $00
'-' 
'-' clkpin                                          'shared with code patched during init
'-' clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
	byte	$a8, $03, $18, $fc
'-' cspin                                           'shared with code patched during init
'-' speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
	byte	$1d, $3a, $63, $fd
'-' registered      long    %100_000_000_00_00000_0 'config pin for clocked input
	byte	$00, $00, $01, $00
'-' clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
	byte	$4a, $00, $00, $00
'-' clkdelay        long    1
	byte	$01, $00, $00, $00
'-' regdatabus      long    0
	byte	$00, $00, $00, $00
'-' 
'-' deviceaddr      long    $10
	byte	$10, $00, $00, $00
'-' rrcounter
'-' pinmask         long    $ff3f7f7f
	byte	$7f, $7f, $3f, $ff
'-' 
'-' ' jump addresses for the per COG handlers
'-' cog0_handler    long    cog0
	byte	$20, $00, $00, $00
'-' cog1_handler    long    cog1
	byte	$2c, $00, $00, $00
'-' cog2_handler    long    cog2
	byte	$38, $00, $00, $00
'-' cog3_handler    long    cog3
	byte	$44, $00, $00, $00
'-' cog4_handler    long    cog4
	byte	$50, $00, $00, $00
'-' cog5_handler    long    cog5
	byte	$5c, $00, $00, $00
'-' cog6_handler    long    cog6
	byte	$68, $00, $00, $00
'-' cog7_handler    long    cog7
	byte	$74, $00, $00, $00
'-' expansion       long    gfxexpansion - driver_start
	byte	$0c, $0f, $00, $00
'-' 
'-' ' EXECF sequences
'-' newburstr       long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-' lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
	byte	$48, $9b, $ef, $00
'-' restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
	byte	$41, $f3, $05, $74
'-' lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
	byte	$80, $22, $3f, $00
'-' lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
	byte	$4b, $f3, $e0, $0f
'-' resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
	byte	$4b, $03, $e0, $0f
'-' resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
	byte	$76, $02, $8a, $84
'-' 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
'-' 
'-' 
'-' ' SKIPF sequences
'-' skiptable
'-'                 long    %11000011000001111110  ' read modify write byte
	byte	$7e, $30, $0c, $00
'-'                 long    %110011011100001110    ' read modify write word
	byte	$0e, $37, $03, $00
'-'                 long    0                      ' read modify write long
	byte	$00, $00, $00, $00
'-'                 long    %1111110               ' single byte read
	byte	$7e, $00, $00, $00
'-'                 long    %11110001110           ' single word read
	byte	$8e, $07, $00, $00
'-' pattern2        long    0
	byte	$00, $00, $00, $00
'-' pattern3        long    0
	byte	$00, $00, $00, $00
'-' singlelong      long    %1001110111  
	byte	$77, $02, $00, $00
'-' skipcase_a      long    %01101111100000000001000011111101
	byte	$fd, $10, $80, $6f
'-' skipcase_b      long    %00000000010100000001100000010000
	byte	$10, $18, $50, $00
'-' skipcase_c      long    %00000000011000000011111000010001
	byte	$11, $3e, $60, $00
'-' skipseq_write   long    %00000000000000000000111100000010
	byte	$02, $0f, $00, $00
'-' 
'-' ' LUT RAM address values
'-' complete_rw     long    complete_rw_lut
	byte	$ff, $02, $00, $00
'-' continue_read   long    continue_read_lut
	byte	$dd, $02, $00, $00
'-' continue_write  long    continue_write_lut
	byte	$db, $02, $00, $00
'-' noread          long    noread_lut
	byte	$f6, $02, $00, $00
'-' 
'-' id0             long    0
	byte	$00, $00, $00, $00
'-' id1             long    1
	byte	$01, $00, $00, $00
'-' id2             long    2
	byte	$02, $00, $00, $00
'-' id3             long    3
	byte	$03, $00, $00, $00
'-' id4             long    4
	byte	$04, $00, $00, $00
'-' id5             long    5
	byte	$05, $00, $00, $00
'-' id6             long    6
	byte	$06, $00, $00, $00
'-' id7             long    7
	byte	$07, $00, $00, $00
'-' 
'-' 'These next 10 request registers below are also temporarily reused during init 
'-' 'and COG updates and need to follow immediately after id0-id7
'-' addr1           long    0
	byte	$00, $00, $00, $00
'-' hubdata         long    0
	byte	$00, $00, $00, $00
'-' count           long    0
	byte	$00, $00, $00, $00
'-' addr2           long    0
	byte	$00, $00, $00, $00
'-' total           long    0
	byte	$00, $00, $00, $00
'-' offset1         long    0
	byte	$00, $00, $00, $00
'-' offset2         long    0
	byte	$00, $00, $00, $00
'-' link            long    0
	byte	$00, $00, $00, $00
'-' 
'-' burstwrite                                      'note shared register use during init
'-' initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
	byte	$00, $10, $f0, $fe
'-' id              long    0
	byte	$00, $00, $00, $00
'-' 
'-' header          long    0
	byte	$00, $00, $00, $00
'-' trailer         long    0
	byte	$00, $00, $00, $00
'-' cmdaddr         long    0
	byte	$00, $00, $00, $00
'-' request         long    0
	byte	$00, $00, $00, $00
'-' rrlimit         long    0
	byte	$00, $00, $00, $00
'-' pinconfig       long    0
	byte	$00, $00, $00, $00
'-' clks            long    0
	byte	$00, $00, $00, $00
'-' resume          long    0
	byte	$00, $00, $00, $00
'-' orighubsize     long    0
	byte	$00, $00, $00, $00
'-' wrclks          long    0
	byte	$00, $00, $00, $00
'-' 
'-' pattern         long    0
	byte	$00, $00, $00, $00
'-' hubscratch      long    0
	byte	$00, $00, $00, $00
'-' val4k           long    4096
	byte	$00, $10, $00, $00
'-' 
'-' ' temporary general purpose regs
'-' a               long    0
	byte	$00, $00, $00, $00
'-' b               long    0
	byte	$00, $00, $00, $00
'-' c               long    0
	byte	$00, $00, $00, $00
'-' d               long    0
	byte	$00, $00, $00, $00
'-'                 fit     502
'-' 
'-'                 fit     502
'-' 
'-' '..................................................................................................
'-' 
'-'             orgh
'-' 
'-' lut_code
'-' 'HW init code up to 80 longs
'-' 
'-' '..................................................................................................
'-' ' Memory layout for LUT RAM once operational:
'-' '
'-' '  LUT RAM address      Usage
'-' '  ---------------      ----
'-' '    $200-$20F          Bank parameters: burst + type + size per bank (16)
'-' '    $210-$21F          Pin parameters : latency + control pins per bank (16)
'-' '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
'-' '    $270-$3FF          Main PSRAM access code in LUTRAM 
'-' '
'-' ' Also during driver COG startup:
'-' ' $230-$24F is used for HW init setup
'-' ' $250-$26F is used as temporary vector storage 
'-' '..................................................................................................
'-' 
'-'                 org $230    
'-' 
'-' ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
'-' hwinit                      setxfrq xfreq2
	byte	$1d, $3c, $63, $fd
'-'                             pollxfi
	byte	$24, $16, $60, $fd
'-'                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
	byte	$ff, $aa, $2a, $ff, $ff, $ed, $07, $f6
'-'                             call    #sendqspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$0FF00FF0         '$66 - reset enable
	byte	$07, $f8, $07, $ff, $f0, $ed, $07, $f6
'-'                             call    #sendspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$F00FF00F         '$99 - reset
	byte	$f8, $07, $78, $ff, $0f, $ec, $07, $f6
'-'                             call    #sendspi
	byte	$1c, $00, $b0, $fd
'-'                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
	byte	$7f, $78, $78, $ff, $00, $ed, $07, $f6
'-'                             call    #sendspi 
	byte	$10, $00, $b0, $fd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-' 
'-' sendqspi                    mov     clks,#4
	byte	$04, $d0, $07, $f6
'-'                             skipf   #%110
	byte	$32, $0c, $64, $fd
'-'                             mov     pb, xsendimm
	byte	$9c, $ef, $03, $f6
'-' 
'-' sendspi                     mov     clks, #16
	byte	$10, $d0, $07, $f6
'-'                             mov     pb, ximm8lut
	byte	$97, $ef, $03, $f6
'-'                             drvl    cspin                   'active low chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   pb, pa                  'send 32 bit immediate data
	byte	$f6, $ef, $a3, $fc
'-'                             wypin   clks, clkpin            'start memory clock output 
	byte	$a8, $d1, $23, $fc
'-'                             waitxfi                         'wait for the completion
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                'float data bus
	byte	$50, $48, $63, $fd
'-'                             drvh    cspin                   'raise chip select
	byte	$59, $52, $63, $fd
'-'             _ret_           waitx   #200                    'delay before return to ensure CS delay
	byte	$1f, $90, $65, $0d
'-' 
'-'                 long    0[$270-32-$]
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-'     
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-' ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
'-' rw_vect ' PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    (%0111010000000000111000 << 10) + w_single
	byte	$41, $e3, $00, $74
'-'                 long    (%0111010000000000100100 << 10) + w_single
	byte	$41, $93, $00, $74
'-'                 long    (%0111010000000000011100 << 10) + w_single
	byte	$41, $73, $00, $74
'-'                 long    (%1111111000000000000110 << 10) + w_burst
	byte	$47, $1b, $00, $fe
'-' ro_vect ' R/O PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-' ctrl_vect ' Control jump vectors
'-'                 long    (%0000000000111001111110 << 10) + get_latency
	byte	$84, $f9, $39, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000001111011111110 << 10) + get_burst
	byte	$84, $f9, $7b, $00
'-'                 long    (%0000000001111111000000 << 10) + dump_state
	byte	$85, $01, $7f, $00
'-'                 long    (%0000000011010001111110 << 10) + set_latency
	byte	$84, $f9, $d1, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000011001011111110 << 10) + set_burst
	byte	$84, $f9, $cb, $00
'-'                 long    reconfig 
	byte	$3e, $01, $00, $00
'-' no_vect ' Invalid bank jump vectors
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 fit     $270
'-' 
'-'                 fit     $270
'-' '..................................................................................................
'-' ' PSRAM READS
'-'                                                             ' a b c d e f
'-'                                                             ' B W L B R L  (a) byte read
'-'                                                             ' Y O O U E O  (b) word read
'-'                                                             ' T R N R S C  (c) long read
'-'                                                             ' E D G S U K  (d) new burst read
'-'                                                             '       T M E  (e) resumed sub-burst
'-'                                                             '         E D  (f) locked sub-burst
'-' 
'-' 
'-' r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
	byte	$da, $d5, $03, $f6
'-' r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
	byte	$da, $b5, $cb, $f7
'-'                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
	byte	$36, $d9, $07, $f6
'-'             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
	byte	$20, $d9, $27, $a5
'-'                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
	byte	$02, $34, $27, $f9
'-'                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
	byte	$80, $b4, $97, $fb
'-' r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    ' a b c d e    get bank limit/mask
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 ' | | | d e    build mask for addr
	byte	$f0, $45, $cb, $f9
'-'                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
	byte	$f0, $3f, $eb, $f8
'-' p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
	byte	$11, $e0, $47, $f0
'-'                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
	byte	$f0, $47, $23, $f3
'-'                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
	byte	$05, $3e, $57, $f0
'-'             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
	byte	$10, $5a, $67, $04
'-'                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
	byte	$10, $5a, $67, $f4
'-'                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
	byte	$f9, $3b, $83, $fc
'-' r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
	byte	$d9, $3b, $83, $fc
'-'                             mov     c, count                ' | | | d e f  get count of bytes left to read
	byte	$da, $e3, $03, $f6
'-'                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
	byte	$20, $d0, $17, $f6
'-'             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
	byte	$cd, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
	byte	$cc, $d3, $03, $36
'-'                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
	byte	$32, $20, $64, $fd
'-'                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
	byte	$54, $00, $90, $fd
'-' 
'-'                             ' fall through to read bursts
'-'                         
'-' burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
	byte	$cd, $d3, $03, $c6
'-'                             mov     pattern, #0             'enable all by default
	byte	$00, $d8, $07, $f6
'-'                             testb   addr1, #1 wc            'test if start addr starts in second word
	byte	$01, $b0, $17, $f4
'-'                             bitnc   pattern, #1             'enable delay cycle if so
	byte	$01, $d8, $67, $f4
'-'                             wrc     clks                    'and account for its clock cycle
	byte	$6c, $d0, $63, $fd
'-'                             testb   addr1, #0 wc            'test if start addr starts on odd byte
	byte	$00, $b0, $17, $f4
'-'                             bitnc   pattern, #2             'add hi 8 transfer initially
	byte	$02, $d8, $67, $f4
'-'                             mov     d, c                    'get count of bytes to be read into HUB
	byte	$f1, $e5, $03, $f6
'-'             if_c            sub     d, #1                   'minus 1 if start addr was odd
	byte	$01, $e4, $87, $c1
'-'                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
	byte	$01, $e4, $4f, $f0
'-'                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
	byte	$f2, $d1, $23, $f1
'-'                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
	byte	$f2, $35, $23, $f9
'-'                             bitz    pattern, #3             'adjust the pattern to include this
	byte	$03, $d8, $87, $f4
'-'                             testb   c, #0 xorc              'test for end address
	byte	$00, $e2, $d7, $f4
'-'                             bitnc   pattern, #4             'include low 8 bit transfer if required
	byte	$04, $d8, $67, $f4
'-'                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
	byte	$0e, $d0, $27, $f1
'-'                             add     clks, clks
	byte	$e8, $d1, $03, $f1
'-' readcommon
'-'                             mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$EB, #3       'add quad read command
	byte	$eb, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-' 
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable data bus
	byte	$58, $48, $63, $fd
'-'             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
'-'                             xinit   ximm8lut, cmdaddr       'stream out command+address
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   clks, clkpin            'start clock output
	byte	$a8, $d1, $23, $fc
'-'                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
	byte	$00, $00, $cc, $fc
'-'                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
	byte	$00, $0c, $cc, $fc
'-'                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
'-'                             fltl    datapins                'safe to float the data bus, address has been sent by now
	byte	$50, $48, $63, $fd
'-'                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
	byte	$a4, $5b, $03, $fc
'-'                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
	byte	$28, $3a, $63, $fd
'-'                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
	byte	$00, $3e, $c7, $fc
'-'                             xcont   #6, #0                  'fixed delay offset to expand delay range
	byte	$00, $0c, $cc, $fc
'-'                             skipf   pattern                 'choose path below
	byte	$32, $d8, $63, $fd
'-'                                                             'Bursts Bytes Words Longs  RMW FromWrites
'-'                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
	byte	$28, $3c, $63, $fd
'-'                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
	byte	$00, $02, $cc, $fc
'-'                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
	byte	$00, $32, $c7, $fc
'-'                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
	byte	$00, $34, $c7, $fc
'-'                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
	byte	$00, $30, $c7, $fc
'-'                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
	byte	$24, $36, $60, $fd
'-'                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
	byte	$a4, $55, $03, $fc
'-'             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
	byte	$59, $52, $63, $0d
'-'                             drvh    cspin                   '         b     c           e       deassert chip select and continue
	byte	$59, $52, $63, $fd
'-'                             getnib  d, request, #1          'get request code value
	byte	$e5, $e5, $4b, $f8
'-'             if_nz           sub     d, #3                   'offset for table if RMW
	byte	$03, $e4, $87, $51
'-'                             altd    d, #skiptable-5         'patch next instruction
	byte	$bb, $e5, $8f, $f9
'-'                             skipf   0-0                     'generate skip sequence
	byte	$32, $00, $60, $fd
'-'                                                             ' B   W  RMWB RMWW RMLL 
'-'                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
	byte	$80, $df, $07, $fb
'-'                             setq    count                   ' |   |   |    |    e   setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
	byte	$d9, $df, $f3, $f9
'-'                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
	byte	$40, $00, $90, $fd
'-'                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
	byte	$01, $b0, $17, $f4
'-'             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
	byte	$ef, $ef, $3b, $c9
'-'             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
	byte	$ef, $ef, $33, $39
'-'                             mov     d, addr1                ' a   |   c    d
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3                   ' a   |   c    |        get LSBs of address
	byte	$03, $e4, $07, $f5
'-'                             altgb   d, #a                   ' a   |   c    |        index into long
	byte	$ef, $e5, $6f, $f9
'-'                             getbyte pb                      ' a   |   c    |        and extract the byte
	byte	$00, $ee, $e3, $f8
'-'                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
	byte	$80, $ef, $67, $fc
'-'                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
	byte	$c0, $00, $b0, $fd
'-'                             ret                             ' a   b   |    |        then return
	byte	$2d, $00, $64, $fd
'-'                             setq    count                   '         c    d        setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    pb, hubdata             '         c    d        apply bit mux
	byte	$d9, $ef, $f3, $f9
'-'                             altsb   d, #a                   '         c    |
	byte	$ef, $e5, $67, $f9
'-'                             setbyte 0-0, pb, #0             '         c    |
	byte	$f7, $01, $c0, $f8
'-'             if_c            setword a, pb, #1               '         |    d
	byte	$f7, $df, $2b, $c9
'-'             if_nc           setword a, pb, #0               '         |    d
	byte	$f7, $df, $23, $39
'-' writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
	byte	$37, $8a, $07, $f6
'-'                             mov     hubdata, a              'write a to PSRAM
	byte	$ef, $b3, $03, $f6
'-'                             mov     wrclks, #20             '20 clocks to write a long
	byte	$14, $d6, $07, $f6
'-'                             mov     resume, complete_rw     'we'll complete the operation after this
	byte	$cc, $d3, $03, $f6
'-'                             jmp     #writecommon
	byte	$10, $03, $90, $fd
'-' 
'-' '..................................................................................................
'-' ' Burst continuation testing
'-' 
'-' continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
	byte	$32, $96, $63, $fd
'-'                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
	byte	$be, $d3, $03, $f6
'-' continue_read_lut          
'-'                             mov     resume, resumereads     ' | setup resume address to execf
	byte	$bf, $d3, $03, $f6
'-'                             add     hubdata, c              ' a compute the next hub addr to use
	byte	$f1, $b3, $03, $f1
'-'                             sub     count, c                ' a account for the bytes already sent
	byte	$f1, $b5, $83, $f1
'-'                             add     c, addr1                ' a compute next external mem address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    ' a configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
	byte	$14, $00, $90, $5d
'-'                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
	byte	$e1, $47, $3b, $f9
'-'                             fle     limit, b                ' | also re-apply per bank limit
	byte	$f0, $47, $23, $f3
'-'             _ret_           push    #continue_read_exec     ' | 
	byte	$2a, $2a, $67, $0d
'-'             if_nz           jmp     #yield                  ' a
	byte	$04, $00, $90, $5d
'-'             _ret_           push    #continue_write_exec    ' a
	byte	$2a, $2c, $67, $0d
'-' 
'-' yield                       wrlut   total, ptra[4]          'save context for next time
	byte	$04, $b9, $37, $fc
'-'                             wrlut   offset1, ptra[5]        'save context for next time
	byte	$05, $bb, $37, $fc
'-'                             wrlut   offset2, ptra[6]        'save context for next time
	byte	$06, $bd, $37, $fc
'-'                             wrlut   link, ptra[7]           'save context for next time
	byte	$07, $bf, $37, $fc
'-' yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
	byte	$00, $b1, $37, $fc
'-'                             wrlut   hubdata, ptra[1]        'save context for next time
	byte	$01, $b3, $37, $fc
'-'                             wrlut   count, ptra[2]          'save context for next time
	byte	$02, $b5, $37, $fc
'-'                             wrlut   addr2, ptra[3]          'save context for next time
	byte	$03, $b7, $37, $fc
'-'                             wrlut   resume, ptra[8]         'save next resume address
	byte	$08, $d3, $37, $fc
'-'                             wrlut   orighubsize, ptra[9]    'save original hub size
	byte	$09, $d5, $37, $fc
'-'             _ret_           push    #poller
	byte	$2a, $1c, $66, $0d
'-' 
'-' 
'-' notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
	byte	$32, $be, $65, $fd
'-' nowrite_lut                                                 '  (a) new skip sequence 
'-' noread_lut                  skipf   #0                      ' | cancel skipping
	byte	$32, $00, $64, $fd
'-'                             wrlut   #0, ptra[8]             ' | clear resume
	byte	$08, $01, $3c, $fc
'-'                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_nz           jmp     #notify                 ' | if not a request list then we are done
	byte	$40, $f8, $9f, $5d
'-'                             testb   addr2, #31 wz           ' | check if extended list item
	byte	$1f, $b6, $0f, $f4
'-' donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
	byte	$df, $b7, $03, $a6
'-' checklist                   call    #checknext              ' | handle running from list
	byte	$1c, $00, $b0, $fd
'-'                             ret                             ' | continue processing
	byte	$2d, $00, $64, $fd
'-'             _ret_           push    noread                  'continue end of transfer
	byte	$2a, $9e, $63, $0d
'-' '..................................................................................................
'-' ' Completion of requests
'-' 
'-' complete_rw_lut             
'-'                             testb   id, #LIST_BIT wz        'test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_z            skipf   #%10                    'if a request list then skip notification
	byte	$32, $04, $64, $ad
'-'                             wrlut   #0, ptra[8]             ' a   default is not to resume
	byte	$08, $01, $3c, $fc
'-'             _ret_           push    #notify                 ' |   if not a request list then we are done
	byte	$2a, $14, $66, $0d
'-'                             tjs     addr2, #extendedreq     '     test for special extended request  
	byte	$0d, $b6, $b7, $fb
'-' checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
	byte	$07, $b6, $97, $fb
'-'                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
	byte	$bf, $ed, $07, $fb
'-'                             tjns    pa, #listcomplete       'exit if it has
	byte	$05, $ec, $bf, $fb
'-'                             testb   id, #LOCKED_BIT wz
	byte	$0a, $c2, $0f, $f4
'-'             if_z            mov     hubdata, addr2
	byte	$db, $b3, $03, $a6
'-'             if_z            skipf   #%110001
	byte	$32, $62, $64, $ad
'-'             if_nz           skipf   #%1000                  'do not notify if list is continuing
	byte	$32, $10, $64, $5d
'-'                             wrlong  addr2, ptrb             ' a  write back next list address
	byte	$80, $b7, $67, $fc
'-' listcomplete                altd    id, #id0                ' a  compute COG's state address
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
	byte	$09, $00, $04, $f4
'-'             _ret_           push    #notify                 ' |  we are done with the list
	byte	$2a, $14, $66, $0d
'-'             _ret_           push    #poller                 ' a  we are still continuing the list
	byte	$2a, $1c, $66, $0d
'-'             _ret_           push    #real_list              ' a  we are still continuing the list
	byte	$2a, $50, $66, $0d
'-' extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
	byte	$e3, $b5, $97, $fb
'-'                             getnib  a, addr2, #7            'check the request type
	byte	$db, $df, $7b, $f8
'-'                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
	byte	$0f, $de, $0f, $f2
'-'                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
	byte	$d8, $df, $73, $f8
'-'             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
	byte	$32, $90, $63, $5d
'-'                                                             ' skipcase (a) gfx copy to/from hub
'-'                                                             ' skipcase (b) gfx copy extmem bank to bank
'-'                                                             ' skipcase (c) linear copy extmem bank to bank
'-'                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
	byte	$db, $df, $73, $f8
'-'                             rdlut   d, a wz                 ' a      load bank information and check if valid
	byte	$ef, $e5, $ab, $fa
'-'             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
	byte	$31, $02, $64, $5d
'-'             _ret_           push    #invalidbank            ' |      otherwise bail out after this
	byte	$2a, $02, $66, $0d
'-'                             test    offset1 wz              ' |      check for first offset being zero
	byte	$dd, $bb, $cb, $f7
'-'             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
	byte	$de, $bd, $cb, $a7
'-'             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
	byte	$32, $94, $63, $ad
'-'                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
	byte	$32, $92, $63, $fd
'-'                             add     hubdata, c              ' a b c  add bytes just sent to hub address
	byte	$f1, $b3, $03, $f1
'-'                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
	byte	$ea, $b3, $83, $f1
'-'                             add     c, addr1                ' a b c  compute next address to use
	byte	$d8, $e3, $03, $f1
'-'                             test    total wz                ' a b |  check for zero tranfers
	byte	$dc, $b9, $cb, $f7
'-'                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
	byte	$dc, $d5, $2b, $f3
'-'             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
	byte	$44, $ff, $9f, $ad
'-'                             testb   addr1, #30 wz           ' a b c  check if reading/writing
	byte	$1e, $b0, $0f, $f4
'-'                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
	byte	$ea, $b5, $03, $f6
'-'                             sub     c, orighubsize          ' a b |  rewind to original position
	byte	$ea, $e3, $83, $f1
'-'             if_z            add     c, offset1              ' a b |  add any dst scanline offset
	byte	$dd, $e3, $03, $a1
'-'             if_nz           add     c, offset2              ' a b |  add any src scanline offset
	byte	$de, $e3, $03, $51
'-'             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
	byte	$de, $b3, $03, $a1
'-'             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
	byte	$dd, $b3, $03, $51
'-'                             setq    mask                    ' a b c  configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a b c  perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             mov     a, addr1                ' | b c  ]
	byte	$d8, $df, $03, $f6
'-'                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
	byte	$db, $b1, $03, $f6
'-'                             mov     addr2, a                ' | b c  ]
	byte	$ef, $b7, $03, $f6
'-'                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
	byte	$1e, $b0, $a7, $f4
'-'                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
	byte	$0f, $b6, $3f, $f8
'-'                             sub     total, #1 wz            ' a | |  decrement scanline count
	byte	$01, $b8, $8f, $f1
'-'             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
	byte	$01, $b8, $8f, $a1
'-'             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
	byte	$ea, $b9, $8b, $a1
'-'             if_z            mov     addr2, link
	byte	$df, $b7, $03, $a6
'-'             if_z            jmp     #checknext
	byte	$34, $ff, $9f, $ad
'-' moretransfers               getbyte request, addr1, #3      'prepare next request
	byte	$d8, $cb, $fb, $f8
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            skipf   #%1110                  '     skip some code if we are locked
	byte	$32, $1c, $64, $ad
'-'                             testb   addr1, #30 wz           ' a   test if will be reading or writing
	byte	$1e, $b0, $0f, $f4
'-'             if_z            mov     resume, resumewrites    ' |   resume burst writing
	byte	$be, $d3, $03, $a6
'-'             if_nz           mov     resume, newburstr       ' |   resume burst reading
	byte	$b9, $d3, $03, $56
'-'                             jmp     #yield                  ' |   yield to poller
	byte	$b0, $fe, $9f, $fd
'-'             if_z            skip    #%1                     '     skip next instruction for writing case
	byte	$31, $02, $64, $ad
'-'             _ret_           push    #start_read_exec        '(|)  do new read burst next 
	byte	$2a, $26, $67, $0d
'-'             _ret_           push    #start_write_exec       'do new write burst next
	byte	$2a, $28, $67, $0d
'-' 
'-' '..................................................................................................
'-' ' PSRAM WRITES
'-'                                                             '  a b c d e f g h
'-' 
'-'                                                             '  B W L F B R L L (a) byte write(s)
'-'                                                             '  Y O O I U E O O (b) word write(s)
'-'                                                             '  T R N L R S C C (c) long write(s)
'-'                                                             '  E D G L S U K K (d) resumed fill
'-'                                                             '          T M E E (e) new burst write
'-'                                                             '            E D D (f) resumed burst
'-'                                                             '              F B (g) locked fill
'-'                                                             '              I U (h) locked burst write
'-'                                                             '              L R 
'-'                                                             '              L S 
'-'                                                             '                T 
'-' 
'-' w_single                   
'-' w_fill_cont           
'-'                             getnib  a, addr1, #7            '  a b c d          obtain request
	byte	$d8, $df, $7b, $f8
'-'                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
	byte	$03, $de, $07, $f5
'-'                             movbyts hubdata, #0             '  a | | |          replicate byte across long
	byte	$00, $b2, $ff, $f9
'-'                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
	byte	$44, $b2, $ff, $f9
'-'                             andn    addr1, #1               '  | b | |          align word addresses
	byte	$01, $b0, $27, $f5
'-'                             andn    addr1, #3               '  | | c |          align long addresses
	byte	$03, $b0, $27, $f5
'-' w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
	byte	$da, $d5, $03, $f6
'-' w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
	byte	$01, $b4, $0f, $f2
'-'                             shl     count, a                '  a b c | |   |    scale into bytes
	byte	$ef, $b5, $63, $f0
'-'                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
	byte	$ab, $b5, $97, $fb
'-' w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
	byte	$da, $e3, $03, $f6
'-'                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
	byte	$76, $02, $a0, $fd
'-'                ' disable call to r_resume_burst for single longs when z=0
'-'                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
	byte	$3f, $8a, $0f, $f6
'-'                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
	byte	$ce, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
	byte	$cc, $d3, $03, $36
'-'                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
	byte	$d9, $df, $03, $f6
'-'                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
	byte	$14, $d6, $07, $f6
'-'                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
	byte	$01, $de, $17, $f4
'-'                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
	byte	$c7, $8b, $03, $f6
'-'             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
	byte	$14, $01, $90, $8d
'-'             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
	byte	$09, $8a, $67, $25
'-'             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
	byte	$5c, $00, $90, $2d
'-'                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
	byte	$0f, $8a, $07, $f6
'-'         
'-'             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
'-'             '
'-'             '  At least one of these 3 optional components will be sent
'-'             '     header - first partial long of data, gets aligned to PSRAM long boundary
'-'             '     body - N x full longs of data
'-'             '     trailer - last partial long of data
'-'             '
'-'             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
'-'             '
'-'             'Case    Type                           Sends
'-'             ' 1)     Single byte/word write         header only (takes its own optimized path)
'-'             ' 2)     Single long write              body only (takes its own optimized path)
'-'             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
'-'             ' 4)     Multiple long fill             body only
'-'             ' 5)     Burst write                    optional header, optional body, optional trailer
'-' 
'-'                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
	byte	$ce, $d3, $03, $c6
'-'                             mov     pattern3, #%10011
	byte	$13, $8c, $07, $f6
'-'                             mov     d, addr1                'get start address position 
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3 wz                'get alignment
	byte	$03, $e4, $0f, $f5
'-'                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
	byte	$04, $e2, $17, $f2
'-'                             mov     wrclks, #16             'clocks needed for address phase
	byte	$10, $d6, $07, $f6
'-'                             mov     pb, c                   'get number of bytes to send
	byte	$f1, $ef, $03, $f6
'-'                             add     pb, d                   'and increase total to send, including initial re-alignment
	byte	$f2, $ef, $03, $f1
'-'             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
	byte	$40, $00, $90, $2d
'-'                             
'-'                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'             if_c            skipf   #%11110                 'if fill skip burst write stuff
	byte	$32, $3c, $64, $cd
'-'                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
	byte	$04, $d6, $07, $f1
'-'                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
	byte	$f2, $df, $83, $f1
'-'                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
	byte	$ef, $e5, $03, $fb
'-'                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
	byte	$04, $de, $07, $f1
'-'                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
	byte	$32, $08, $64, $fd
'-'                             sub     pb, #4 wcz              ' subtract a long from the total
	byte	$04, $ee, $9f, $f1
'-'                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
	byte	$00, $8a, $07, $f4
'-' single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
	byte	$d9, $e5, $03, $f6
'-'                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
	byte	$88, $01, $b0, $fd
'-'                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
	byte	$5a, $b0, $47, $fb
'-'                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
	byte	$ed, $c5, $03, $fb
'-'                             setq    pa                      ' setup byte mux mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    header, d               ' copy bytes into long
	byte	$f2, $c5, $f3, $f9
'-'             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
	byte	$94, $00, $90, $ed
'-' 
'-' header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'                             mov     d, pb                   'preserve the count
	byte	$f7, $e5, $03, $f6
'-'                             andn    pb, #3 wz               'determine the number of full long bytes left to send
	byte	$03, $ee, $2f, $f5
'-'                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
	byte	$07, $ee, $97, $fb
'-'                  
'-'                             add     wrclks, pb              'include this number of bytes as more clock transitions
	byte	$f7, $d7, $03, $f1
'-'             if_c            skipf   #%1010                 'for fills we can skip burst stuff
	byte	$32, $14, $64, $cd
'-'             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
	byte	$0c, $8a, $27, $c5
'-'                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
	byte	$01, $8a, $07, $f4
'-'                             shr     pb, #1                  ' |  b  compute word count for bursts
	byte	$01, $ee, $47, $f0
'-'                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
	byte	$f7, $37, $23, $f9
'-'                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
	byte	$01, $ee, $47, $f0
'-' 
'-' body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
	byte	$03, $e4, $07, $f5
'-'                             tjz     d, #trailer_done        'no trailer to send, we exit now
	byte	$17, $e4, $97, $fb
'-'             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
	byte	$da, $e3, $0b, $c2
'-'             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
	byte	$cc, $d3, $0b, $32
'-'             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
	byte	$f2, $e3, $83, $51
'-'             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
	byte	$4c, $00, $90, $5d
'-' 
'-'                             'we have 1-3 more aligned residual bytes left to send as the trailer
'-'                             or      d, #$1f0                'setup mux mask address
	byte	$f0, $e5, $47, $f5
'-'                             rdlut   pa, d                   'read mux mask for this length at offset 0
	byte	$f2, $ed, $a3, $fa
'-'                             push    addr1                   'save address
	byte	$2a, $b0, $63, $fd
'-' 
'-' ' use this code (note: foldover can occur here in PSRAM bank)
'-'                             add     addr1, c                'find last long address in PSRAM
	byte	$f1, $b1, $03, $f1
'-'                             sub     addr1, #1               '..to be rewritten
	byte	$01, $b0, $87, $f1
'-'                             call    #readlong               'read data from this external address
	byte	$18, $01, $b0, $fd
'-'             
'-'             if_c            mov     d, hubdata              'get data to be sent for fills
	byte	$d9, $e5, $03, $c6
'-'             if_c            skipf   #%11110                 'skip burst code for fills
	byte	$32, $3c, $64, $cd
'-'                             pop     addr1                   'restore address
	byte	$2b, $b0, $63, $fd
'-'                             mov     d, pb                   ' | get number of full longs that were sent
	byte	$f7, $e5, $03, $f6
'-'                             shl     d, #2                   ' | convert to bytes
	byte	$02, $e4, $67, $f0
'-'                             add     d, a                    ' | add to start adress of longs to stream
	byte	$ef, $e5, $03, $f1
'-'                             rdlong  d, d                    ' | read this last long from HUB RAM
	byte	$f2, $e5, $03, $fb
'-' 
'-'                             rdlong  trailer, hubscratch     'read external RAM data value
	byte	$ed, $c7, $03, $fb
'-'                             setq    pa                      'setup byte mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    trailer, d              'apply byte mask to data via muxq
	byte	$f2, $c7, $f3, $f9
'-'                             add     wrclks, #4              'increase by 4 more clocks
	byte	$04, $d6, $07, $f1
'-'                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
	byte	$05, $8a, $07, $f4
'-'                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
	byte	$00, $8c, $07, $f4
'-' 
'-'                             'trailer is done
'-' trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
	byte	$ef, $3b, $73, $fc
'-' 
'-' writecommon                 mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$02, #3       'add quad write command
	byte	$02, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr                 
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-'                             
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   wrclks, clkpin          'start memory clock output 
	byte	$a8, $d7, $23, $fc
'-'                                                          
'-'                             skipf   pattern2                '   B W L Burst FB FW FL RMW
	byte	$32, $8a, $63, $fd
'-'                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
	byte	$e2, $39, $c3, $fc
'-'                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
	byte	$00, $36, $c7, $fc
'-'                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
	byte	$f7, $03, $d8, $fc
'-'                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
	byte	$d9, $39, $c3, $fc
'-'                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
	byte	$32, $8c, $63, $fd
'-'                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
	byte	$e3, $39, $c3, $fc
'-'                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
	byte	$50, $48, $63, $fd
'-'             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
	byte	$59, $52, $63, $0d
'-'  
'-'                             drvh    cspin
	byte	$59, $52, $63, $fd
'-' check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
	byte	$09, $c2, $17, $f4
'-'                             sub     count, c wz             'account for bytes written
	byte	$f1, $b5, $8b, $f1
'-'             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
	byte	$34, $00, $90, $5d
'-'                             wrlut   #0, ptra[8]             'default is not to resume
	byte	$08, $01, $3c, $fc
'-'             if_nc           jmp     #notify                 'if not a request list then we are done
	byte	$3c, $f5, $9f, $3d
'-'                             tjns    addr2, #checklist       'if not extended, check next list entry
	byte	$40, $b7, $bf, $fb
'-'                             djz     total, #donerepeats     'check for repeats remaining
	byte	$3e, $b9, $67, $fb
'-'                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
	byte	$b8, $b9, $b3, $fb
'-'                             mov     d, orighubsize
	byte	$ea, $e5, $03, $f6
'-'                             shl     d, a
	byte	$ef, $e5, $63, $f0
'-'                             sub     c, d
	byte	$f2, $e3, $83, $f1
'-'                             add     c, offset1
	byte	$dd, $e3, $03, $f1
'-'                             mov     count, d                'restore original count
	byte	$f2, $b5, $03, $f6
'-' readmask                    getnib  b, request, #0          'get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 'build mask for addr (in case count=1)
	byte	$f0, $45, $cb, $f9
'-' continue_fill               add     c, addr1                'add bytes to destination address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    'setup bit mask
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                'setup new external memory address
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            execf   lockedfill              'continue next fill operation
	byte	$33, $74, $63, $ad
'-'                             mov     resume, restorefill
	byte	$bb, $d3, $03, $f6
'-'             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
	byte	$00, $b6, $07, $36
'-'             if_nc           call    #yieldfill              'we have to yield now to other COGs
	byte	$80, $fc, $bf, $3d
'-'             if_c            call    #yield
	byte	$6c, $fc, $bf, $cd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-'                            
'-' getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
'-'                       '     rczl    pa                      'rotate left into address offset
'-'                       '     rczl    c wcz                   'restore count and flags
'-'                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
	byte	$03, $e2, $ef, $f7
'-'                             shl     pa, #2
	byte	$02, $ec, $67, $f0
'-'             if_z            setq    #3
	byte	$28, $06, $64, $ad
'-'             if_z            muxq    pa, c
	byte	$f1, $ed, $f3, $a9
'-'                             or      pa, #$1f0               'setup LUT address offset
	byte	$f0, $ed, $47, $f5
'-'            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
	byte	$f6, $ed, $a3, $fa
'-'                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
	byte	$2d, $00, $7c, $fd
'-' 
'-' readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
	byte	$ed, $3b, $83, $fc
'-'                             setword xrecvdata, #2, #0       'read 2x16 words
	byte	$02, $34, $27, $f9
'-'                             mov     clks, #32               '32 read clock transitions
	byte	$20, $d0, $07, $f6
'-'                             mov     pattern, #%110110       'setup read skip pattern
	byte	$36, $d8, $07, $f6
'-'                             jmp     #readcommon             'read then return directly to caller
	byte	$14, $fb, $9f, $fd
'-'                 fit 1024-32
'-'         
'-' 
'-' '..................................................................................................
'-' 
'-'                 fit 1024-32
'-'                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'                 org 1024-32
'-' 
'-' ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
'-'                 long $0000
	byte	$00, $00, $00, $00
'-'                 long $1111
	byte	$11, $11, $00, $00
'-'                 long $2222
	byte	$22, $22, $00, $00
'-'                 long $3333
	byte	$33, $33, $00, $00
'-'                 long $4444
	byte	$44, $44, $00, $00
'-'                 long $5555
	byte	$55, $55, $00, $00
'-'                 long $6666
	byte	$66, $66, $00, $00
'-'                 long $7777
	byte	$77, $77, $00, $00
'-'                 long $8888
	byte	$88, $88, $00, $00
'-'                 long $9999
	byte	$99, $99, $00, $00
'-'                 long $aaaa
	byte	$aa, $aa, $00, $00
'-'                 long $bbbb
	byte	$bb, $bb, $00, $00
'-'                 long $cccc
	byte	$cc, $cc, $00, $00
'-'                 long $dddd
	byte	$dd, $dd, $00, $00
'-'                 long $eeee
	byte	$ee, $ee, $00, $00
'-'                 long $ffff
	byte	$ff, $ff, $00, $00
'-' 
'-' 'masks
'-'                 long $ffffffff ' 00 aligned 0/4 length
	byte	$ff, $ff, $ff, $ff
'-'                 long $000000ff ' 00 aligned 1 length
	byte	$ff, $00, $00, $00
'-'                 long $0000ffff ' 00 aligned 2 length
	byte	$ff, $ff, $00, $00
'-'                 long $00ffffff ' 00 aligned 3 length
	byte	$ff, $ff, $ff, $00
'-' 
'-'                 long $ffffff00 ' 01 aligned 0/4 length
	byte	$00, $ff, $ff, $ff
'-'                 long $0000ff00 ' 01 aligned 1 length
	byte	$00, $ff, $00, $00
'-'                 long $00ffff00 ' 01 aligned 2 length
	byte	$00, $ff, $ff, $00
'-'                 long $ffffff00 ' 01 aligned 3 length
	byte	$00, $ff, $ff, $ff
'-' 
'-'                 long $ffff0000 ' 10 aligned 0/4 length
	byte	$00, $00, $ff, $ff
'-'                 long $00ff0000 ' 10 aligned 1 length
	byte	$00, $00, $ff, $00
'-'                 long $ffff0000 ' 10 aligned 2 length
	byte	$00, $00, $ff, $ff
'-'                 long $ffff0000 ' 10 aligned 3 length
	byte	$00, $00, $ff, $ff
'-' 
'-'                 long $ff000000 ' 11 aligned 0/4 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 1 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 2 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 3 length
	byte	$00, $00, $00, $ff
'-'         fit 1024
'-' 
'-'         fit 1024
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-'         orgh
'-' 
'-' gfxexpansion
'-'                             'simple line drawing graphics expansion of memory driver
'-'                             'jmp     #donerepeats                'just return for now
'-' 
'-'                             cmp     addr1, addr2 wz         'see if we've reached the end
	byte	$db, $b1, $0b, $f2
'-'             if_z            jmp     #donerepeats            'nothing more to draw
	byte	$fb, $02, $80, $ad
'-'                             add     total, #1               'restore total after decrement
	byte	$01, $b8, $07, $f1
'-'                             mov     b, offset1              'get error term
	byte	$dd, $e1, $03, $f6
'-'                             shl     b, #1                   'compute e2 = 2 x error
	byte	$01, $e0, $67, $f0
'-'                             getword d, offset2, #0          'get dx = abs(x0-x1)
	byte	$de, $e5, $33, $f9
'-'                             sar     offset2, #16            'get dy = -abs(y0-y1)
	byte	$10, $bc, $c7, $f0
'-'                             cmps    b, offset2 wc           'compare if e2 >= dy
	byte	$de, $e1, $53, $f2
'-'                             mov     c, #0                   'clear accumulator reg
	byte	$00, $e2, $07, $f6
'-'             if_c            skip    #%1110                  'if not, skip
	byte	$31, $1c, $64, $cd
'-'                             decod   a                       'decode as 1,2,or 4 byte size
	byte	$ef, $df, $c3, $f9
'-'                             add     offset1, offset2        'err+=dy 
	byte	$de, $bb, $03, $f1
'-'                             testb   total, #16 wz           'check sign sx   
	byte	$10, $b8, $0f, $f4
'-'                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
	byte	$ef, $e3, $c3, $f3
'-'                             cmps    d, b wc                 'compare if e2 <= dx
	byte	$f0, $e5, $53, $f2
'-'             if_c            skip    #%11110                 'if not, skip
	byte	$31, $3c, $64, $cd
'-'                             rolword offset2, d, #0          'restore offset
	byte	$f2, $bd, $43, $f9
'-'                             add     offset1, d              'err+=dx
	byte	$f2, $bb, $03, $f1
'-'                             testb   total, #17 wz           'check sign sy
	byte	$11, $b8, $0f, $f4
'-'                             getword d, total, #0            'get line width
	byte	$dc, $e5, $33, $f9
'-'                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
	byte	$f2, $e3, $c3, $f3
'-'                             encod   a wc                    'restore size and set carry
	byte	$ef, $df, $93, $f7
'-'                             mov     count, orighubsize      'reset the fill width
	byte	$ea, $b5, $03, $f6
'-'                             shl     count, a                '..for the type of transfer
	byte	$ef, $b5, $63, $f0
'-'                             jmp     #readmask               'continue filling
	byte	$c3, $03, $80, $fd
	alignl
_usbnew_spin2_dat_
'-'                 org     $000
'-' 
'-' usb_host_start
'-'                 mov     hcog_base_addr, ptrb
	byte	$f9, $8f, $02, $f6
'-' 
'-'                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
	byte	$03, $00, $00, $ff, $d0, $70, $07, $f6
'-'                 shr     htmp, #2                        ' so byte->long for the lut cell count
	byte	$02, $70, $47, $f0
'-'                 loc     pb, #@hlut_start - @usb_host_start
	byte	$b4, $04, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq2   htmp
	byte	$29, $70, $63, $fd
'-'                 rdlong  0, pb                           ' Do the hub->lut copy
	byte	$f7, $01, $00, $fb
'-' 
'-'                 loc     pb, #@usb_host_init - @usb_host_start
	byte	$88, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 jmp     pb                              ' Initialize host and enter main processing loop
	byte	$2c, $ee, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
'-' ' special because the receiving function must not respond with either STALL or
'-' ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
'-' ' non-control endpoint receives a SETUP token, or the function receives a
'-' ' corrupt packet, it must ignore the transaction
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data struct.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error code.
'-' '------------------------------------------------------------------------------
'-' txn_setup
'-'                 setbyte ep_addr_pid, #PID_SETUP, #0
	byte	$2d, $bc, $c6, $f8
'-'                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
	byte	$08, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
	byte	$03, $96, $06, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
	byte	$0c, $a2, $06, $f6
'-'                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
	byte	$f8, $ed, $03, $f6
'-' .setup
'-'                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
	byte	$24, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait
	byte	$7c, $0b, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
	byte	$f6, $f1, $03, $f6
'-'                 jmp     #.setup
	byte	$e0, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' IN/INTERRUPT transaction.
'-' ' Possible function response: STALL or NAK handshake, or DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_in
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$90, $03, $b0, $fd
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #utx_token                      ' Put IN request on the bus
	byte	$bc, $00, $b0, $fd
'-' 
'-'                 ' Fall through to urx_packet
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a packet from a device/function. As host, the only two packet types
'-' ' received are handshakes and IN DATAx.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'-' '     returned.
'-' '------------------------------------------------------------------------------
'-' urx_packet
'-'                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #urx_packet
	byte	$f4, $ff, $9f, $cd
'-'                 getct   hct2
	byte	$1a, $92, $63, $fd
'-'                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
	byte	$4e, $93, $6b, $fa
'-'                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
	byte	$05, $96, $06, $f4
'-'                 mov     newb_flg, #0                    ' Initialize for multi-byte read
	byte	$00, $a8, $06, $f6
'-' .wait_sop
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #.get_pid
	byte	$08, $00, $90, $cd
'-'                 jnct2   #.wait_sop
	byte	$fc, $25, $cc, $fb
'-'         _ret_   mov     retval, #ERR_TAT
	byte	$05, $be, $06, $06
'-' .get_pid
'-'                 call    #urx_next
	byte	$28, $02, $b0, $fd
'-'                 testb   urx, #BUS_ERRB          wc
	byte	$06, $a6, $16, $f4
'-'         if_nc   jmp     #.chk_pid
	byte	$04, $00, $90, $3d
'-'         _ret_   mov     retval, #ERR_URX
	byte	$02, $be, $06, $06
'-' .chk_pid
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $52
'-'         if_nz   cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
	byte	$38, $00, $90, $ad
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
	byte	$03, $96, $16, $f4
'-'                 cmp     retval, #PID_DATA0      wz
	byte	$c3, $be, $0e, $f2
'-'    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
	byte	$28, $01, $90, $2d
'-'    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
	byte	$10, $00, $90, $8d
'-'                 cmp     retval, #PID_DATA1      wz
	byte	$4b, $be, $0e, $f2
'-'    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
	byte	$1c, $01, $90, $8d
'-'    if_z_and_nc  jmp     #.ack_resend
	byte	$04, $00, $90, $2d
'-'         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
	byte	$04, $be, $06, $06
'-' .ack_resend
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.ack_resend
	byte	$f4, $ff, $9f, $3d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 call    #utx_handshake                  ' Send handshake PID and return to caller
	byte	$98, $01, $b0, $fd
'-'         _ret_   mov     retval, #ERR_DATAX_SYNC
	byte	$09, $be, $06, $06
'-' .chk_eop
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
	byte	$1c, $00, $90, $3d
'-'                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
	byte	$c8, $01, $b0, $fd
'-'                 testb   hstatus, #EOPB          wc
	byte	$05, $96, $16, $f4
'-'         if_c    jmp     #.idle                          ' Low-speed EOP seen
	byte	$10, $00, $90, $cd
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
	byte	$04, $be, $06, $36
'-'         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
	byte	$02, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
	byte	$f4, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send a token packet with CRC5 checksum of address and endpoint. It is the
'-' ' responsibility of the caller to append the appropriate inter-packet delay,
'-' ' if one is required.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - packed with the PID, address and endpoint.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_token
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #utx_token
	byte	$f4, $ff, $9f, $3d
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$34, $0d, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync byte
	byte	$70, $01, $b0, $fd
'-'                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
	byte	$5e, $71, $03, $f6
'-'                 mov     pkt_cnt, #3
	byte	$03, $b8, $06, $f6
'-' .next_byte
'-'                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
	byte	$b8, $a5, $e2, $f8
'-'                 shr     htmp, #8                        ' Shift to next byte to send
	byte	$08, $70, $47, $f0
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   utx, dm
	byte	$22, $a5, $22, $fc
'-'         _ret_   djnz    pkt_cnt, #.next_byte
	byte	$f9, $b9, $6e, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP/OUT/INTERRUPT transaction.
'-' ' Possible function response in order of precedence: STALL, ACK, NAK.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' '   PTRA - start address of the data buff/struct that has the bytes to send.
'-' '   pkt_data - count of DATAx payload bytes to send.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_out
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$88, $02, $b0, $fd
'-'                 call    #utx_token                      ' Put SETUP/OUT token on the bus
	byte	$b8, $ff, $bf, $fd
'-'                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
	byte	$00, $00, $c0, $ff, $f8, $01, $78, $fc
'-'                 mov     pkt_cnt, pkt_data
	byte	$58, $b9, $02, $f6
'-' 
'-'                 ' Fall through to utx_data
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
'-' ' calculated while the data byte is being shifted out. Since data stage
'-' ' success/fail is not determined until the status stage of the transaction,
'-' ' this routine is only concerned about the current DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - hub start address of the data to read.
'-' '   pkt_cnt - data payload size.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_data
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #utx_data
	byte	$f4, $ff, $9f, $cd
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
	byte	$2c, $0a, $b0, $fd
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$d8, $0c, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$14, $01, $b0, $fd
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
	byte	$03, $96, $16, $f4
'-'         if_nc   mov     utx, #PID_DATA0
	byte	$c3, $a4, $06, $36
'-'         if_c    mov     utx, #PID_DATA1
	byte	$4b, $a4, $06, $c6
'-'                 call    #utx_byte                       ' No CRC calc done on PID
	byte	$00, $01, $b0, $fd
'-'                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
	byte	$1c, $00, $90, $ad
'-' .read_byte
'-'                 rfbyte  utx                             ' Fetch data byte
	byte	$10, $a4, $62, $fd
'-'                 call    #utx_byte
	byte	$f0, $00, $b0, $fd
'-'                 rev     utx                             ' Calculate CRC while the data is shifting out
	byte	$69, $a4, $62, $fd
'-'                 setq    utx                             ' SETQ left-justifies the reflected data byte
	byte	$28, $a4, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-'                 djnz    pkt_cnt, #.read_byte
	byte	$f9, $b9, $6e, $fb
'-' .send_crc
'-'                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
	byte	$e0, $bb, $e6, $f4
'-'                 getbyte utx, crc, #0
	byte	$5d, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$d0, $00, $b0, $fd
'-'                 getbyte utx, crc, #1
	byte	$5d, $a5, $ea, $f8
'-'                 call    #utx_byte                       ' Last CRC byte out
	byte	$c8, $00, $b0, $fd
'-'                 jmp     #urx_packet                     ' Handle function response/error and back to caller
	byte	$7c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
'-' ' payload bytes are received. The routine reads bytes until EOP is detected and
'-' ' expects that the packet includes at least the CRC word.
'-' '
'-' ' In control transfers, it's possible to recieve fewer data bytes than what
'-' ' was requested, which makes it difficult to determine where the data stops
'-' ' and the CRC word begins. So the CRC calculation is done on every byte of the
'-' ' packet, including the CRC word. The CRC value should then be equal to the
'-' ' USB-16 expected residual value of 0xB001.
'-' '
'-' ' The routine writes the IN packet data to a static max_packet_size buffer
'-' ' so the caller can verify IN success before writing the data to its final
'-' ' destination.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   pkt_data - max byte count expected to be in the packet.
'-' '   newb_flg - signals new byte ready when toggled.
'-' ' On exit:
'-' '   pkt_cnt - actual number of bytes read.
'-' '------------------------------------------------------------------------------
'-' urx_data
'-'                 mov     htmp2, pb
	byte	$f7, $75, $03, $f6
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
	byte	$00, $00, $c0, $ff, $f7, $01, $88, $fc
'-'                 mov     pb, htmp2
	byte	$ba, $ef, $03, $f6
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
	byte	$00, $b8, $06, $f6
'-'                 mov     pkt_tmp, pkt_data
	byte	$58, $83, $03, $f6
'-'                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
	byte	$02, $82, $07, $f1
'-' .wait_byte
'-' ' In-line rx for max speed
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   jmp     #.get_byte                      ' New byte!
	byte	$0c, $00, $90, $5d
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_c    jmp     #.chk_crc                       ' At end-of-packet
	byte	$38, $00, $90, $cd
'-'                 jmp     #.wait_byte
	byte	$dc, $ff, $9f, $fd
'-' .get_byte
'-'                 getbyte retval, urx, #1                 ' New byte from smart pins
	byte	$53, $bf, $ea, $f8
'-'                 wfbyte  retval                          ' Add it to the data buffer
	byte	$15, $be, $62, $fd
'-'                 rev     retval                          ' Calculate CRC while next byte is shifting in
	byte	$69, $be, $62, $fd
'-'                 setq    retval                          ' SETQ left-justifies the reflected data byte
	byte	$28, $be, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-' .end_crc
'-'                 add     pkt_cnt, #1
	byte	$01, $b8, $06, $f1
'-'                 cmp     pkt_cnt, pkt_tmp        wcz
	byte	$c1, $b9, $1a, $f2
'-'         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
	byte	$04, $be, $06, $16
'-'         if_a    ret
	byte	$2d, $00, $64, $1d
'-' ' For full-speed at 80MHz, the time it takes to do the final byte write and
'-' ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
'-' ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
'-' ' to miss it, so cheat a bit and look for SOP clear here.
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
	byte	$a8, $ff, $9f, $3d
'-' ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
'-' .chk_crc
'-'                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
	byte	$02, $b8, $86, $f1
'-'                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
	byte	$58, $00, $00, $ff, $01, $ba, $6e, $f5
'-'         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
	byte	$f0, $fd, $9f, $5d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$34, $09, $b0, $fd
'-' 
'-'                 ' Fall through to utx_handshake
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
'-' ' the appropriate IP delay has been inserted.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - handshake PID to send.
'-' ' On exit:
'-' '   retval unchanged.
'-' '------------------------------------------------------------------------------
'-' utx_handshake
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$e0, $0b, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$1c, $00, $b0, $fd
'-'                 mov     utx, retval
	byte	$5f, $a5, $02, $f6
'-'                 call    #utx_byte                       ' Send handshake PID
	byte	$14, $00, $b0, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
	byte	$f4, $ff, $9f, $3d
'-'                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
	byte	$4e, $99, $02, $f6
'-'                 jmp     #poll_waitx
	byte	$08, $09, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for the USB tx buffer to empty and feed it a new byte.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   utx - byte to transmit.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_byte
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #utx_byte
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
	byte	$1f, $94, $62, $fd
'-'         _ret_   wypin   utx, dm
	byte	$22, $a5, $22, $0c
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Fetch the next data byte of a packet. Always check receiver status for EOP.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the byte read.
'-' '   urx - the receiver status. The caller must check the hstatus reg EOP flag
'-' '     on return. If EOP is set, the byte in reg retval remains as the last byte
'-' '     received.
'-' '------------------------------------------------------------------------------
'-' urx_next
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
	byte	$53, $bf, $ea, $58
'-'         if_nz   ret                                     ' New byte is priority, so return now
	byte	$2d, $00, $64, $5d
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
	byte	$d8, $ff, $9f, $4d
'-'         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
	byte	$05, $96, $26, $34
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
'-' ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
'-' ' length, and the PID is not included in the CRC calculation:
'-' '  CRC5  FRAME_NUMBER SOF (full-speed)
'-' '  CRC5  ENDP ADDRESS PID
'-' ' %00000_1111_1111111_xxxxxxxx
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - stuffed with the function endpoint, address and
'-' '     SETUP/IN/OUT/SOF PID according to the USB standard.
'-' ' On exit:
'-' '   ep_addr_pid - CRC value appended to the packet.
'-' '------------------------------------------------------------------------------
'-' calc_crc5
'-'                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
	byte	$ff, $03, $00, $ff, $ff, $bd, $06, $f5
'-'                 mov     htmp, ep_addr_pid
	byte	$5e, $71, $03, $f6
'-'                 shr     htmp, #8                        ' PID not included in CRC calc
	byte	$08, $70, $47, $f0
'-'                 mov     crc, #$1f                       ' Initial CRC5 value
	byte	$1f, $ba, $06, $f6
'-'                 rev     htmp                            ' Input data reflected
	byte	$69, $70, $63, $fd
'-'                 setq    htmp                            ' CRCNIB setup for data bits 0..7
	byte	$28, $70, $63, $fd
'-'                 crcnib  crc, #USB5_POLY
	byte	$14, $ba, $de, $f9
'-'                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
	byte	$14, $ba, $de, $f9
'-'                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
	byte	$09, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 xor     crc, #$1f                       ' Final XOR value
	byte	$1f, $ba, $66, $f5
'-'                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
	byte	$13, $ba, $66, $f0
'-'         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
	byte	$5d, $bd, $42, $05
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed/low-speed frame timing interrupt service routine.
'-' '------------------------------------------------------------------------------
'-' isr1_fsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6d, $13, $fc
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 mov     utx, #PID_SOF
	byte	$a5, $a4, $06, $f6
'-'                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
	byte	$22, $01, $29, $fc
'-'                 call    #utx_byte                       ' Send token PID byte
	byte	$4c, $ff, $bf, $fd
'-'                 mov     icrc, #$1f                      ' Prime the CRC5 pump
	byte	$1f, $b6, $06, $f6
'-'                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
	byte	$59, $b5, $02, $f6
'-'                 rev     sof_pkt                         ' Input data reflected
	byte	$69, $b4, $62, $fd
'-'                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
	byte	$28, $b4, $62, $fd
'-'                 crcnib  icrc, #USB5_POLY
	byte	$14, $b6, $de, $f9
'-'                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
	byte	$14, $b6, $de, $f9
'-'                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
	byte	$59, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$2c, $ff, $bf, $fd
'-'                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
	byte	$08, $b4, $66, $f0
'-'                 rep     #2, #3                          ' Three data bits left to process
	byte	$03, $04, $dc, $fc
'-'                 shl     sof_pkt, #1             wc
	byte	$01, $b4, $76, $f0
'-'                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
	byte	$14, $b6, $d6, $f9
'-'                 xor     icrc, #$1f                      ' Final XOR value
	byte	$1f, $b6, $66, $f5
'-'                 getbyte utx, frame, #1                  ' Send remaining frame number bits
	byte	$59, $a5, $ea, $f8
'-'                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
	byte	$03, $b6, $66, $f0
'-'                 or      utx, icrc
	byte	$5b, $a5, $42, $f5
'-'                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
	byte	$08, $ff, $bf, $fd
'-'                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
	byte	$a3, $81, $03, $f6
'-'                 jmp     #isr1_wait
	byte	$20, $00, $90, $fd
'-' isr1_lsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
	byte	$22, $09, $28, $fc
'-'                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
	byte	$a2, $81, $03, $f6
'-' isr1_wait
'-'                 rqpin   utx, dm
	byte	$22, $a5, $82, $fa
'-'                 testb   utx, #SOPB                 wc
	byte	$04, $a4, $16, $f4
'-'         if_c    jmp     #isr1_wait
	byte	$f4, $ff, $9f, $cd
'-'                 add     frame, #1                       ' Next frame# and check for wrap around
	byte	$01, $b2, $06, $f1
'-'                 and     frame, ##$7ff
	byte	$03, $00, $00, $ff, $ff, $b3, $06, $f5
'-'                 waitx   isrtmp1                         ' Make sure bus is idle
	byte	$1f, $80, $63, $fd
'-'                 reti1
	byte	$f5, $ff, $3b, $fb
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a window within the 1ms frame boundary that will ensure that a
'-' ' transaction will complete before the next frame is triggered.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' wait_txn_ok
'-'                 getct   htmp2
	byte	$1a, $74, $63, $fd
'-'                 sub     htmp2, iframe_ct_base
	byte	$49, $75, $83, $f1
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    cmp     htmp2, _txn_ok_ls_      wcz
	byte	$a0, $75, $1b, $c2
'-'         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
	byte	$a1, $75, $1b, $32
'-'         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
	byte	$e8, $ff, $9f, $1d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A device connection was detected, or a bus reset was requested by the USB
'-' ' client. Set the appropriate smart pin FS/LS speed mode to match the device
'-' ' and perform a reset sequence prior to device enumeration.
'-' '------------------------------------------------------------------------------
'-' dev_reset
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
	byte	$01, $a6, $16, $f4
'-'         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
	byte	$f4, $03, $b0, $cd
'-'         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
	byte	$e0, $03, $b0, $3d
'-' reset
'-'                 setint1 #0                              ' Don't want frame interrupt while in reset
	byte	$25, $00, $64, $fd
'-'                 wypin   #OUT_SE0, dm                    ' Assert bus reset
	byte	$22, $03, $28, $fc
'-'                 waitx   _reset_hold_                    ' Spec is >= 10ms
	byte	$1f, $5a, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 mov     frame, #0                       ' Reset the frame timespan count
	byte	$00, $b2, $06, $f6
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
	byte	$59, $71, $03, $f6
'-'                 add     htmp, #36
	byte	$24, $70, $07, $f1
'-'                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
	byte	$25, $02, $64, $fd
'-' .framewait
'-'                 cmp     frame, htmp             wcz
	byte	$b8, $b3, $1a, $f2
'-'         if_b    jmp     #.framewait
	byte	$f8, $ff, $9f, $cd
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - source address.
'-' '   PB - destination address.
'-' '   hr0 - length of copy, in bytes.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hmemcpy
'-'                 rdbyte  htmp, ptra++
	byte	$61, $71, $c7, $fa
'-'                 wrbyte  htmp, pb
	byte	$f7, $71, $43, $fc
'-'                 add     pb, #1
	byte	$01, $ee, $07, $f1
'-'         _ret_   djnz    hr0, #hmemcpy
	byte	$fc, $85, $6f, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
'-' ' loop until the errant device is disconnected.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' host_error
'-'           if ERROR_LED >= 0
'-'           end
'-'                 jmp     #host_reset                     ' See if it works...
	byte	$a0, $07, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get HID descriptor buffer for current port
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   PB - HID descriptor buffer pointer
'-' '------------------------------------------------------------------------------
'-' get_hid_descr_buffer
'-'                 mov     pb, hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb, #1
	byte	$01, $ee, $e7, $f2
'-'                 mul     pb, #HID_DESCR_LEN
	byte	$00, $ef, $07, $fa
'-'         _ret_   add     pb, hid_descr_p
	byte	$25, $ef, $03, $01
'-' 
'-' 
'-' usb16_poly_r    long    USB16_POLY
	byte	$01, $a0, $00, $00
'-' 
'-' ' USB commands and error codes
'-' cmd_data        long    0
	byte	$00, $00, $00, $00
'-' usb_err_code    long    ERR_NONE
	byte	$00, $00, $00, $00
'-' 
'-' ' Parameters block assigned at cog startup
'-' dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
	byte	$12, $00, $00, $00
'-' dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
	byte	$13, $00, $00, $00
'-' usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
	byte	$11, $00, $00, $00
'-' if ACTIVITY_LED >= 0
'-' host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
'-' end
'-' if ERROR_LED >= 0
'-' host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
'-' end
'-' hid_descr_p     long    0
	byte	$00, $00, $00, $00
'-' 'hid_report_p    long    0, 0[MAX_DEVICES]
'-' 'hkbd_report_p   long    0
'-' hub_descr_p     long    0
	byte	$00, $00, $00, $00
'-' urx_buff_p      long    0
	byte	$00, $00, $00, $00
'-' dev_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' con_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' cache_start_p   long    0
	byte	$00, $00, $00, $00
'-' cache_end_p     long    0
	byte	$00, $00, $00, $00
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_out_ptr  long    0
'-' end
'-' save_sysclk     long    0         ' Save the current sysclock as the client may change it
	byte	$00, $00, $00, $00
'-' 
'-' hdev_init_start
'-' hdev_port       res     1
'-' hdev_port       res     1
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' kbm_next_datax  res     1
'-' kbm_next_datax  res     1
'-' hub_intf_num    res     1
'-' hub_intf_num    res     1
'-' hub_next_datax  res     1
'-' hub_next_datax  res     1
'-' hub_status_chg  res     1
'-' hub_status_chg  res     1
'-' hub_port_status res     1
'-' hub_port_status res     1
'-' if HAVE_MOUSE
'-' ms_intf_num     res     1
'-' ms_intf_num     res     1
'-' ms_in_max_pkt   res     1
'-' ms_in_max_pkt   res     1
'-' end
'-' kb_intf_num     res     1
'-' kb_intf_num     res     1
'-' kb_interval     res     1
'-' kb_interval     res     1
'-' kb_in_max_pkt   res     1
'-' kb_in_max_pkt   res     1
'-' kb_max_index    res     1
'-' kb_max_index    res     1
'-' kb_led_states   res     1
'-' kb_led_states   res     1
'-' gp_intf_num     res     1
'-' gp_intf_num     res     1
'-' gp_interval     res     1
'-' gp_interval     res     1
'-' gp_max_index    res     1
'-' gp_max_index    res     1
'-' gp_descr_len    res     1+MAX_DEVICES
'-' gp_descr_len    res     1+MAX_DEVICES
'-' hdev_init_end
'-' 
'-' ' Initialized at cog startup:
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' iframe_ct_new   res     1
'-' iframe_ct_new   res     1
'-' iframe_ct_base  res     1
'-' iframe_ct_base  res     1
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' 
'-' ' This register block is reset to zero when a USB device connects
'-' hreg_init_start
'-' hstatus         res     1         ' Host status flags
'-' hstatus         res     1         ' Host status flags
'-' hctwait         res     1         ' Poll-based wait clocks
'-' hctwait         res     1         ' Poll-based wait clocks
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' xfer_retry      res     1         ' Control transfer retry count
'-' xfer_retry      res     1         ' Control transfer retry count
'-' retry           res     1         ' Transaction retry count
'-' retry           res     1         ' Transaction retry count
'-' utx             res     1         ' Byte to transmit on USB
'-' utx             res     1         ' Byte to transmit on USB
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' frame           res     1         ' USB 1ms frame counter value
'-' frame           res     1         ' USB 1ms frame counter value
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' crc             res     1         ' Used for CRC16 calculation
'-' crc             res     1         ' Used for CRC16 calculation
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' retval          res     1         ' Global success/fail return parameter
'-' retval          res     1         ' Global success/fail return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' ' Device stuff
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_bcd        res     1
'-' hdev_bcd        res     1
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' ' Keyboard/mouse stuff
'-' hctrl_ep_addr   res     1
'-' hctrl_ep_addr   res     1
'-' hctrl_max_pkt   res     1
'-' hctrl_max_pkt   res     1
'-' hconfig_base    res     1
'-' hconfig_base    res     1
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_class      res     1
'-' hdev_class      res     1
'-' hdev_subclass   res     1
'-' hdev_subclass   res     1
'-' hdev_protocol   res     1
'-' hdev_protocol   res     1
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' if HAVE_MOUSE
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' end
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_out_addr   res     1
'-' hdev_out_addr   res     1
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
'-' end
'-' 
'-' hreg_init_end
'-' 
'-' hidr_start
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_flags      res     1
'-' hidr_flags      res     1
'-' hidr_axis       res     3
'-' hidr_axis       res     3
'-' hidr_buttons    res     1
'-' hidr_buttons    res     1
'-' hidr_hats       res     1
'-' hidr_hats       res     1
'-' '' Above are actually useful values, 6 longs
'-' hidr_id         res     1
'-' hidr_id         res     1
'-' hidr_state      res     1
'-' hidr_state      res     1
'-' hidr_size       res     1
'-' hidr_size       res     1
'-' hidr_count      res     1
'-' hidr_count      res     1
'-' hidr_offset     res     1
'-' hidr_offset     res     1
'-' hidr_usage_idx  res     1
'-' hidr_usage_idx  res     1
'-' hidr_lminmax    res     1
'-' hidr_lminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_type       res     1
'-' hidr_type       res     1
'-' hidr_end
'-' 
'-' ' Variables dependent on the system freqency
'-' _var_64_lower_  res     1
'-' _var_64_lower_  res     1
'-' _var_64_upper_  res     1
'-' _var_64_upper_  res     1
'-' _12Mbps_        res     1
'-' _12Mbps_        res     1
'-' _1_5Mbps_       res     1
'-' _1_5Mbps_       res     1
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1us_           res     1         ' 1us
'-' _1us_           res     1         ' 1us
'-' _10us_          res     1         ' 10us
'-' _10us_          res     1         ' 10us
'-' _33us_          res     1         ' 33us
'-' _33us_          res     1         ' 33us
'-' _txn_err_       res     1         ' 250us
'-' _txn_err_       res     1         ' 250us
'-' _500us_         res     1         ' 500us
'-' _500us_         res     1         ' 500us
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _preamble_wait_ res     1
'-' _preamble_wait_ res     1
'-' _1ms_           res     1         ' 1ms
'-' _1ms_           res     1         ' 1ms
'-' _2ms_           res     1         ' 2ms
'-' _2ms_           res     1         ' 2ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _4ms_           res     1         ' 4ms
'-' _4ms_           res     1         ' 4ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _reset_hold_    res     1         ' 15ms
'-' _reset_hold_    res     1         ' 15ms
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _21ms_          res     1         ' 21ms
'-' _21ms_          res     1         ' 21ms
'-' _100ms_         res     1         ' 100ms
'-' _100ms_         res     1         ' 100ms
'-' _500ms_         res     1         ' 500ms
'-' _500ms_         res     1         ' 500ms
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' '------------------------------------------------------------------------------
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_d_ls_nco_  res     1
'-' _usb_d_ls_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' '------------------------------------------------------------------------------
'-' ' Scratch registers
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp1           res     1
'-' htmp1           res     1
'-' htmp2           res     1
'-' htmp2           res     1
'-' htmp3           res     1
'-' htmp3           res     1
'-' hrep            res     1         ' Repeat count
'-' hrep            res     1         ' Repeat count
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave1          res     1
'-' hsave1          res     1
'-' hsave2          res     1
'-' hsave2          res     1
'-' isrtmp1         res     1
'-' isrtmp1         res     1
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' hr0             res     1         ' Multi-purpose registers
'-' hr0             res     1         ' Multi-purpose registers
'-' hr1             res     1
'-' hr1             res     1
'-' hr2             res     1
'-' hr2             res     1
'-' hr3             res     1
'-' hr3             res     1
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar2           res     1
'-' hpar2           res     1
'-' hpar3           res     1
'-' hpar3           res     1
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' mod_cnt         res     1         ' Used in idle loops
'-' mod_cnt         res     1         ' Used in idle loops
'-'                 fit     $1F0
'-'                 org     $200
'-' hlut_start
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed is the host's native speed, so all that is needed is to set the FS
'-' ' settings to startup defaults.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: Save/restore caller C flag state if C is changed in this routine!
'-' '------------------------------------------------------------------------------
'-' set_speed_full
'-'                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$d0, $e8, $07, $f6
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
	byte	$a3, $9b, $02, $06
'-' '                ret                             wcz     ' Restore caller flags on exit
'-' 
'-' '------------------------------------------------------------------------------
'-' ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
'-' ' is a downstream hub connected (not yet implemented), the baud generator
'-' ' remains set at the full-speed rate, but signaling is switched to low-speed,
'-' ' which reverses the D-/D+ polarity. The polarity can be changed without
'-' ' putting the smart pins into reset.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: CZ flags restored to caller states
'-' '------------------------------------------------------------------------------
'-' set_speed_low
'-'                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
	byte	$80, $96, $ce, $f7
'-'         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$ed, $e8, $07, $a6
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
	byte	$22, $69, $13, $fc
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a4, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a2, $9b, $02, $f6
'-'                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
	byte	$02, $96, $26, $f4
'-'                 ret                             wcz     ' Restore caller flags on exit
	byte	$2d, $00, $7c, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform configuration stuff required when a device intitially connects.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' on_connect
'-'                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$02, $84, $07, $f6
'-'                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
	byte	$d8, $fb, $bf, $fd
'-' .retry
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
	byte	$01, $8c, $07, $c6
'-'         if_nc   mov     hpar1, #USB_SPEED_FULL
	byte	$02, $8c, $07, $36
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$1c, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$f4, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.get_dev_desc
	byte	$18, $00, $90, $ad
'-'                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$4c, $03, $b0, $fd
'-'                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$01, $84, $8f, $f1
'-'         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
	byte	$f0, $fb, $9f, $ad
'-'                 call    #reset                          ' Try another reset to see if the device responds
	byte	$a4, $fb, $bf, $fd
'-'                 jmp     #.retry
	byte	$b8, $ff, $9f, $fd
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
	byte	$28, $03, $b0, $fd
'-'                 call    #reset
	byte	$88, $fb, $bf, $fd
'-'                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
	byte	$34, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
	byte	$01, $11, $5c, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$d8, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$04, $03, $b0, $fd
'-'                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
	byte	$04, $00, $00, $ff, $00, $bc, $06, $f6
'-'                 call    #calc_crc5
	byte	$34, $fa, $bf, $fd
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
	byte	$1c, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$78, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
	byte	$07, $db, $c6, $fa
'-'                 mov     hctwait, _500us_
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $02, $b0, $fd
'-'                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$24, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$48, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $85, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $87, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $71, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $84, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $86, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $71, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #host_error
	byte	$2c, $fb, $9f, $cd
'-'                 loc     pa, #@init_kbdm_data - @usb_host_start
	byte	$14, $13, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-'                 loc     pa, #@hparse_con_desc - @usb_host_start
	byte	$b8, $0d, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 jmp     pa
	byte	$2c, $ec, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
'-' ' Status reporting is always in the function-to-host direction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data in hub.
'-' '   PB - start address of the buffer/struct to be written to during the IN data
'-' '     stage.
'-' '   ep_addr_pid - device address, endpoint and CRC5.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'-' '     contains the count of data stage bytes actually received, which must
'-' '     always be <= the count requested.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_read
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8d, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $8f, $03, $f6
'-'                 mov     hpar3, pb                       ' Save dest buffer pointer
	byte	$f7, $91, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$c0, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to caller to handle error
	byte	$2d, $00, $64, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$90, $01, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 mov     nak_retry, ##IN_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
	byte	$55, $b1, $02, $16
'-' .nak_retry
'-'                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
	byte	$0c, $a2, $06, $f6
'-' .in_retry
'-'                 call    #txn_in
	byte	$bc, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$28, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$a8, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$14, $02, $b0, $fd
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak_retry                     ' Function not ready to send data
	byte	$dc, $ff, $9f, $ad
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$94, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.in_retry                      ' Bus error retry
	byte	$d0, $ff, $9f, $5d
'-'                 ret                                     ' The transfer has failed
	byte	$2d, $00, $64, $fd
'-' .commit
'-'                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.pre_status                    ' and also end-of-data
	byte	$38, $00, $90, $ad
'-'                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
	byte	$27, $f1, $03, $f6
'-'                 mov     hr0, pkt_cnt
	byte	$5c, $85, $03, $f6
'-'                 cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $f2
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$6c, $fa, $bf, $5d
'-'                 add     stage_data, pkt_cnt             ' Update bytes received on commit
	byte	$5c, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
	byte	$56, $af, $0a, $f2
'-'         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
	byte	$1c, $00, $90, $ad
'-'                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
	byte	$58, $b9, $1a, $f2
'-'         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
	byte	$14, $00, $90, $cd
'-'         if_a    mov     retval, #ERR_PACKET
	byte	$04, $be, $06, $16
'-'         if_a    mov     context_retval, retval          ' In this case overall and context are the same
	byte	$5f, $c1, $02, $16
'-'         if_a    ret                                     ' Caller must handle ERR_PACKET
	byte	$2d, $00, $64, $1d
'-'                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $f4
'-'                 jmp     #.data                          ' Start next IN transaction
	byte	$78, $ff, $9f, $fd
'-' .pre_status
'-'                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
	byte	$57, $ad, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $f8
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-'                 mov     nak_retry, ##OUT_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-' .out_retry
'-'                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
	byte	$34, $f7, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret                                     ' All is good when ACK
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$18, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$84, $01, $b0, $fd
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
	byte	$d8, $ff, $9f, $5d
'-'                 ret                                     ' Caller must handle transfer retirement
	byte	$2d, $00, $64, $fd
'-' ' I've encountered transfer STALL, even though the data looks correct, and
'-' ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
'-' ' ControlRead() transfer gets things unstuck most of the time...
'-' .xfer_retry
'-'                 mov     hctwait, _xfer_wait_
	byte	$ab, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$58, $01, $b0, $fd
'-'                 call    #wait_txn_ok
	byte	$8c, $f9, $bf, $fd
'-'                 mov     ep_addr_pid, hpar1
	byte	$c6, $bd, $02, $f6
'-'                 mov     ptra, hpar2
	byte	$c7, $f1, $03, $f6
'-'                 mov     pb, hpar3
	byte	$c8, $ef, $03, $f6
'-'                 djnz    xfer_retry, #.xfer_start
	byte	$bb, $a1, $6e, $fb
'-'                 mov     context_retval, retval          ' Preserve the USB error code
	byte	$5f, $c1, $02, $f6
'-'         _ret_   mov     retval, #ERR_XFER_RETRY
	byte	$07, $be, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
'-' ' reporting is always in the function-to-host direction. It is assumed that
'-' ' the SETUP data struct is filled with the required values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - points to the start of the struct for the SETUP data.
'-' '   PB - the start address of the struct/buffer to be read for the OUT data
'-' '     stage.
'-' '   ep_addr_pid - the proper CRC'd address and endpoint to use.
'-' ' On exit:
'-' '   retval - used to convey the success/failure of each stage.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_write
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8d, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $8f, $03, $f6
'-'                 mov     hpar3, pb
	byte	$f7, $91, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
	byte	$00, $9e, $06, $f6
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$84, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
	byte	$ec, $00, $90, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$54, $00, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
	byte	$e1, $bc, $c6, $f8
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
	byte	$55, $b1, $02, $16
'-' .out_retry
'-'                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
	byte	$f7, $f1, $03, $f6
'-'                 call    #txn_out
	byte	$88, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit                        ' Function got the data
	byte	$10, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$e0, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry
	byte	$e4, $ff, $9f, $5d
'-'                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
	byte	$a4, $00, $90, $fd
'-' .commit
'-'                 mov     pb, ptra                        ' Save the current buffer/struct location
	byte	$f8, $ef, $03, $f6
'-'                 add     stage_data, pkt_data
	byte	$58, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz
	byte	$56, $af, $0a, $f2
'-'         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $54
'-'         if_nz   jmp     #.data                          ' More data to send
	byte	$bc, $ff, $9f, $5d
'-' pre_status_in
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .status_retry
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 call    #txn_in
	byte	$44, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
	byte	$d2, $be, $0e, $f2
'-'         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
	byte	$00, $b0, $0e, $a2
'-'         if_z    jmp     #dwnstream_reset                ' Control Write finished
	byte	$74, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait                     ' NAK or bus error, so delay a bit
	byte	$98, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.status_retry
	byte	$d8, $ff, $9f, $5d
'-' '               ret                                     ' Caller must handle transfer retirement
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - The function address and endpoint for the IN request.
'-' '   hpar2 - Address of the IN data buffer
'-' '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
'-' ' On exit:
'-' '   retval - the result of the operation.
'-' '   hpar3 - the count of IN data bytes actually received.
'-' '------------------------------------------------------------------------------
'-' do_int_in
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 getword htmp, hpar3, #0
	byte	$c8, $71, $33, $f9
'-'                 cmp     htmp, #PID_DATA0        wz
	byte	$c3, $70, $0f, $f2
'-'                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
	byte	$03, $96, $a6, $f4
'-'                 mov     retry, #TXN_RETRIES
	byte	$0c, $a2, $06, $f6
'-' .retry
'-'                 getword pkt_data, hpar3, #1             ' IN max packet length
	byte	$c8, $b1, $3a, $f9
'-'                 call    #txn_in
	byte	$00, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK if data received
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$1c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
	byte	$5a, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.post_ret                      ' The caller must handle either
	byte	$24, $00, $90, $ad
'-'                 call    #retry_wait
	byte	$54, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    jmp     #.post_ret
	byte	$18, $00, $90, $ad
'-'                 jmp     #.retry
	byte	$d4, $ff, $9f, $fd
'-' .commit
'-'                 mov     ptra, urx_buff_p                ' Copy the rx buffer
	byte	$27, $f1, $03, $f6
'-'                 mov     pb, hpar2                       ' to the destination buffer
	byte	$c7, $ef, $03, $f6
'-'                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
	byte	$5c, $85, $0b, $f6
'-'         if_nz   cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $52
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$c0, $f8, $bf, $5d
'-' .post_ret
'-'                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
	byte	$5c, $91, $03, $f6
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Resets the downstream hub port to FS
'-' '------------------------------------------------------------------------------
'-' dwnstream_reset
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_nc   ret                                     ' No LS device, reset not needed
	byte	$2d, $00, $64, $3d
'-' 
'-'                 bitl    _usb_h_ls_nco_, #14
	byte	$0e, $68, $07, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6d, $13, $fc
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The one millisecond frame timer is implemented as an interrupt service
'-' ' routine. Since this timing is critical, care must be taken to avoid any
'-' ' instructions that can delay the interrupt branch, which will likely upset
'-' ' the timer. WAITX is among those instructions, so any time you're inside
'-' ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hctwait - wait interval in sysclocks.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' poll_waitx
'-'                 getct   hct2
	byte	$1a, $92, $63, $fd
'-'                 addct2  hct2, hctwait
	byte	$4c, $93, $6b, $fa
'-' .wait
'-'                 jnct2   #.wait
	byte	$ff, $25, $cc, $fb
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transaction retry handling for NAK/STALL or bus error.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - transaction response PID or error code.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' retry_wait
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret                                     ' STALL is special case
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak
	byte	$14, $00, $90, $ad
'-'                 mov     hctwait, _txn_err_              ' Transaction error wait...
	byte	$9e, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$d8, $ff, $bf, $fd
'-' .dec
'-'                 sub     retry, #1               wz
	byte	$01, $a2, $8e, $f1
'-'         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
	byte	$06, $be, $06, $a6
'-'                 ret                                     ' Retry result to caller
	byte	$2d, $00, $64, $fd
'-' .nak
'-'                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
	byte	$9d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $ff, $bf, $fd
'-'                 cmp     nak_retry, #NAK_NOLIMIT wz
	byte	$00, $9e, $0e, $f2
'-'         if_z    ret                                     ' Indefinite NAK retries
	byte	$2d, $00, $64, $ad
'-'                 sub     nak_retry, #1           wz
	byte	$01, $9e, $8e, $f1
'-'         if_z    mov     retval, #ERR_NAK
	byte	$08, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' host_reset
'-'                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
	byte	$25, $00, $64, $fd
'-'                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
	byte	$14, $70, $07, $fb
'-' ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
'-'                 cmp     htmp, ##168_000_000     wcz
	byte	$bd, $01, $05, $ff, $00, $70, $1f, $f2
'-'         if_be   mov     utx_tweak, #0
	byte	$00, $94, $06, $e6
'-'         if_a    mov     utx_tweak, #3   '#20
	byte	$03, $94, $06, $16
'-' ' Check to see if the system clock has been changed.
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $71, $0b, $f2
'-'         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $5e
'-'         if_nz   add     pb, hcog_base_addr
	byte	$47, $ef, $03, $51
'-'         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $5d
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-' 
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
	byte	$22, $6d, $13, $fc
'-' .enable
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 waitx   _1us_
	byte	$1f, $36, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 ' Handle Port protection enable and startup delay
'-'                 cmp     usb_enable_pin, #0      wc
	byte	$00, $48, $16, $f2
'-'         if_ae   drvl    usb_enable_pin                 ' disable port
	byte	$58, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Wait a while for everything to turn off
	byte	$1f, $5e, $63, $fd
'-'         if_ae   drvh    usb_enable_pin                  ' Enable the port
	byte	$59, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Hold to let the idle state get settled
	byte	$1f, $5e, $63, $fd
'-' 
'-'                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
	byte	$4b, $ed, $b7, $f9
'-'                 rep     @.regloop,#hreg_init_end - hreg_init_start
	byte	$3b, $04, $dc, $fc
'-'                 alti    pa, #%000_111_000
	byte	$38, $ec, $a7, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' .regloop
'-' 
'-'                 'call #dev_reset ' TODO THINK ABOUT THIS
'-' 
'-' discon_entry
'-'                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
	byte	$03, $96, $07, $f6
'-' 
'-'               
'-'         if HAVE_HIDPAD
'-'                 loc     pb, #@hidpad_report - @usb_host_start
	byte	$d8, $27, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
	byte	$28, $60, $64, $fd
'-'                 wrlong  #0,pb
	byte	$f7, $01, $68, $fc
'-'         end
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-'                 ' Fall through to disconnected loop
'-' 
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' Device connect handling (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
'-' ' device to connect (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' disconnected
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
	byte	$14, $86, $07, $fb
'-'                 cmp     hr1, save_sysclk        wz
	byte	$2c, $87, $0b, $f2
'-'         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
	byte	$6c, $ff, $9f, $5d
'-'                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
	byte	$03, $86, $47, $f0
'-'                 waitx   hr1                             ' it down to smaller wait chunks
	byte	$1f, $86, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
	byte	$e0, $ff, $9f, $ad
'-'         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
	byte	$28, $00, $90, $5d
'-' .se1_test
'-'                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$fc, $fe, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
	byte	$00, $be, $06, $56
'-'         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
	byte	$b0, $ff, $9f, $5d
'-' .se1            'SE1 is a fatal error condition
'-'                 mov     hctwait, _100ms_
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$e4, $fe, $bf, $fd
'-'                 mov     retval, #ERR_SE1
	byte	$03, $be, $06, $f6
'-'                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
	byte	$88, $f7, $bf, $fd
'-' .connect_test                                           ' Test lines until stable J/K state seen
'-'                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
	byte	$1f, $60, $63, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #discon_entry                   ' D+ and D- low
	byte	$90, $ff, $9f, $ad
'-'         if_e    jmp     #.se1_test                      ' D+ and D- high
	byte	$c4, $ff, $9f, $ad
'-' connected
'-'                 bith    hstatus, #CONNECTEDB            ' Device plugged in
	byte	$01, $96, $26, $f4
'-'                 call    #on_connect                     ' Initial device configuration
	byte	$34, $fb, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #discon_entry
	byte	$7c, $ff, $9f, $5d
'-' .set_pulse
'-'                 getct   _pulse_time_
	byte	$1a, $64, $63, $fd
'-'                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
	byte	$b1, $65, $03, $f1
'-' ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
'-' ' of 1ms and make a correction, if necessary.
'-' '                mov     htmp, _1ms_
'-' '                subs    htmp, iframe_delta
'-' '                adds    _frame1ms_clks_, htmp
'-' '                debug(udec(_frame1ms_clks_))
'-' 
'-'                 ' Fall through to idle/processing loop
'-'                 cmp     hdev_port, #MAX_DEVICES wcz
	byte	$07, $5a, $1e, $f2
'-'         if_a    mov     hdev_port, #0 
	byte	$00, $5a, $06, $16
'-' 
'-' hidle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_c    jmp     #.se0_test
	byte	$98, $00, $90, $cd
'-'                 pollct3                         wc
	byte	$24, $06, $70, $fd
'-'         if_nc   jmp     #.nopoll
	byte	$68, $00, $90, $3d
'-'                 getct   hct3
	byte	$1a, $94, $63, $fd
'-'                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
	byte	$a7, $95, $73, $fa
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $70, $e3, $f8
'-' 
'-'                 cmp     htmp, #HUB_READY        wz
	byte	$09, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_hub_status - @usb_host_start
	byte	$88, $1b, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$40, $00, $90, $ad
'-' 
'-'         if _HAVE_GAMEPAD
'-'                 cmp     htmp, #HID_READY        wz
	byte	$06, $70, $0f, $f2
'-'         if_nz   cmp     htmp, #PS3_READY        wz
	byte	$08, $70, $0f, $52
'-'         if_nz   cmp     htmp, #XINPUT_READY     wz
	byte	$07, $70, $0f, $52
'-'         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
	byte	$10, $16, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$2c, $00, $90, $ad
'-'         end
'-' 
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$34, $15, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$20, $00, $90, $ad
'-'         end
'-' 
'-'                 cmp     htmp, #KB_READY         wz
	byte	$03, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$9c, $13, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$14, $00, $90, $ad
'-' 
'-'                 cmp     htmp, #KBM_READY        wz
	byte	$05, $70, $0f, $f2
'-'         if_nz   jmp     #.skip_poll
	byte	$14, $00, $90, $5d
'-'                 bitnot  hstatus, #KBM_TOGGLEB   wcz
	byte	$09, $96, $fe, $f4
'-'         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$9c, $13, $80, $3e
'-'         if HAVE_MOUSE
'-'         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$34, $15, $80, $ce
'-'         else
'-'         end
'-' 
'-' .poll
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-' .skip_poll
'-' 
'-'                 incmod  hdev_port, #MAX_DEVICES
	byte	$07, $5a, $06, $f7
'-' 
'-' .nopoll
'-'                 cmp     cmd_data, #CMD_SUSPEND  wz
	byte	$0e, $40, $0e, $f2
'-'         if_z    jmp     #hsuspend
	byte	$44, $00, $90, $ad
'-'                 cmp     cmd_data, #CMD_RESET    wz
	byte	$10, $40, $0e, $f2
'-'         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
	byte	$00, $40, $06, $a6
'-'         if_z    jmp     #host_reset                     ' See if it works...
	byte	$68, $fe, $9f, $ad
'-'                 getct   hr0
	byte	$1a, $84, $63, $fd
'-'                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
	byte	$b2, $85, $1b, $f2
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'         if_ae   getct   _pulse_time_
	byte	$1a, $64, $63, $3d
'-'         if_ae   add     _pulse_time_, _500ms_
	byte	$b1, $65, $03, $31
'-'                 jmp     #hidle
	byte	$5c, $ff, $9f, $fd
'-' ' Check for extended SE0 state on the bus
'-' .se0_test
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
	byte	$fc, $fd, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_nc   jmp     #hidle                          ' Bus still IDLE
	byte	$48, $ff, $9f, $3d
'-'                 call    #wait_txn_ok
	byte	$24, $f6, $bf, $fd
'-'                 wypin   ##OUT_IDLE, dm                  ' Float USB
	byte	$00, $00, $80, $ff, $22, $01, $28, $fc
'-'                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
'-'                 jmp     #host_reset                     ' Device disconnected
	byte	$30, $fe, $9f, $fd
'-' 
'-' hsuspend
'-'                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
	byte	$14, $f6, $bf, $fd
'-'                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
	byte	$25, $00, $64, $fd
'-'                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
	byte	$1f, $52, $63, $fd
'-'                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
	byte	$22, $01, $28, $fc
'-'                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
	byte	$00, $40, $06, $f6
'-'                 mov     mod_cnt, #0
	byte	$00, $96, $07, $f6
'-' 
'-'                 ' Fall through to resume wait loop
'-' 
'-' hwait_resume
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
	byte	$14, $86, $07, $fb
'-'                 shr     hr1, #2
	byte	$02, $86, $47, $f0
'-'                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
	byte	$1f, $86, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 cmp     cmd_data, #CMD_RESUME   wz
	byte	$0f, $40, $0e, $f2
'-'         if_nz   jmp     #hwait_resume
	byte	$ec, $ff, $9f, $5d
'-'                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
	byte	$14, $70, $07, $fb
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $71, $0b, $f2
'-'         if_z    jmp     #.resume
	byte	$18, $00, $90, $ad
'-'                 loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $fd
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
	byte	$22, $6d, $13, $3c
'-'         if_c    wxpin   _usb_h_ls_nco_, dm
	byte	$22, $69, $13, $cc
'-' .resume
'-'                 wypin   #OUT_K, dm
	byte	$22, $05, $28, $fc
'-'                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
	byte	$1f, $5c, $63, $fd
'-'                 wypin   #OUT_SE0, dm
	byte	$22, $03, $28, $fc
'-'                 mov     htmp, _ip_delay_ls_
	byte	$a2, $71, $03, $f6
'-'                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
	byte	$01, $70, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $70, $63, $fd
'-'                 wypin   #OUT_J, dm
	byte	$22, $07, $28, $fc
'-'                 shr     htmp, #1
	byte	$01, $70, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $70, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 setint1 #1                              ' Enable the 1ms frame ISR
	byte	$25, $02, $64, $fd
'-'                 mov     hctwait, _4ms_
	byte	$aa, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
	byte	$50, $fd, $bf, $fd
'-'         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
	byte	$00, $40, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send preamble to enable low-speed HUB ports
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   USB baud rate set to low-speed
'-' '------------------------------------------------------------------------------
'-' utx_pre
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   #0, dm                          ' Disable smartpin mode
	byte	$22, $01, $08, $fc
'-'                 drvl    dm
	byte	$58, $44, $62, $fd
'-'                 drvh    dp
	byte	$59, $46, $62, $fd
'-' 
'-'                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
	byte	$1e, $00, $00, $ff, $80, $70, $07, $f6
'-' 
'-'                 rep     @.l1, #16 + 1
	byte	$11, $08, $dc, $fc
'-'                 shr     htmp, #1        wc
	byte	$01, $70, $57, $f0
'-'         if_nc   setq    #1
	byte	$28, $02, $64, $3d
'-'         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
	byte	$4f, $44, $62, $3d
'-'                 waitx   _preamble_wait_
	byte	$1f, $4c, $63, $fd
'-' .l1
'-' 
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
	byte	$22, $69, $13, $fc
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a4, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a2, $9b, $02, $06
'-' 
'-' hlut_end
'-'                 fit     $400
'-'                 orgh
'-' if OVERLAP_MEMORY
'-'                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
'-' end
'-' '------------------------------------------------------------------------------
'-' ' Routines called from cog space.
'-' '------------------------------------------------------------------------------
'-' ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'-' '------------------------------------------------------------------------------
'-' 
'-' '------------------------------------------------------------------------------
'-' ' USB host cog initialization.
'-' '------------------------------------------------------------------------------
'-' usb_host_init
'-'                 ' Initialize buffer pointers
'-'         if OVERLAP_MEMORY
'-'         else
'-'                 loc     pb, #hid_descr
	byte	$40, $15, $b0, $fe
'-'         end
'-'                 mov     hid_descr_p, pb
	byte	$f7, $4b, $02, $f6
'-'                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
'-'                 {
'-'                 }
'-'         
'-'                 {
'-'                 }
'-'                 'loc     pb,#hkbd_report
'-'                 'mov     hkbd_report_p,pb
'-' 
'-'                 loc     pb, #hub_descr
	byte	$08, $1d, $b0, $fe
'-'                 mov     hub_descr_p, pb
	byte	$f7, $4d, $02, $f6
'-'                 loc     pb, #urx_buff
	byte	$1d, $1d, $b0, $fe
'-'                 mov     urx_buff_p, pb
	byte	$f7, $4f, $02, $f6
'-'                 loc     pb, #dev_desc_buff
	byte	$95, $1d, $b0, $fe
'-'                 mov     dev_desc_buff_p, pb
	byte	$f7, $51, $02, $f6
'-'                 loc     pb, #con_desc_buff
	byte	$9f, $1d, $b0, $fe
'-'                 mov     con_desc_buff_p, pb
	byte	$f7, $53, $02, $f6
'-'                 loc     pb, #usb_cache_start
	byte	$18, $15, $b0, $fe
'-'                 mov     cache_start_p, pb
	byte	$f7, $55, $02, $f6
'-'                 loc     pb, #usb_cache_end
	byte	$e9, $1c, $b0, $fe
'-'                 mov     cache_end_p, pb
	byte	$f7, $57, $02, $f6
'-' 
'-'         if ERROR_LED >= 0
'-'         end
'-' 
'-'                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
'-'                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
'-'                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
'-' ' Configure and enable the Serial Host USB port.
'-'                 jmp     #host_reset                     ' Initialize host and enter main processing loop
	byte	$03, $03, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Timing calculations happen before any interrupt(s) are enabled.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   htmp - current CLKFREQ value.
'-' '------------------------------------------------------------------------------
'-' hinit_usb_timings
'-' '                getct   htmp2
'-'                 mov     save_sysclk, htmp
	byte	$b8, $59, $02, $f6
'-'                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
	byte	$8d, $5b, $80, $ff, $2c, $01, $2a, $fd
'-'                 getqx   _12Mbps_
	byte	$18, $30, $63, $fd
'-'                 shr     _12Mbps_, #16           wc
	byte	$10, $30, $57, $f0
'-'                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
	byte	$00, $30, $27, $f1
'-'                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
	byte	$03, $6c, $07, $f6
'-'                 shl     _usb_h_fs_nco_, #14
	byte	$0e, $6c, $67, $f0
'-'                 add     _usb_h_fs_nco_, _12Mbps_
	byte	$98, $6d, $03, $f1
'-'                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
	byte	$01, $6e, $07, $f6
'-'                 shl     _usb_d_fs_nco_, #14
	byte	$0e, $6e, $67, $f0
'-'                 add     _usb_d_fs_nco_, _12Mbps_
	byte	$98, $6f, $03, $f1
'-'                 mov     _1_5Mbps_, _12Mbps_
	byte	$98, $33, $03, $f6
'-'                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
	byte	$03, $32, $47, $f0
'-'                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
	byte	$02, $68, $07, $f6
'-'                 shl     _usb_h_ls_nco_, #14
	byte	$0e, $68, $67, $f0
'-'                 add     _usb_h_ls_nco_, _1_5Mbps_
	byte	$99, $69, $03, $f1
'-'                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
	byte	$99, $6b, $03, $f6
'-'                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
	byte	$80, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1b
	byte	$65, $cd, $1d, $ff, $00, $2e, $27, $fd
'-'                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
	byte	$18, $34, $63, $fd
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1m
	byte	$a1, $07, $00, $ff, $40, $2e, $27, $fd
'-'                 getqx   _1us_                           ' 1us as 32,9 fixed point
	byte	$18, $36, $63, $fd
'-'                 mov     hsave0, _1us_                   ' Save it to compute other us values
	byte	$9b, $7b, $03, $f6
'-'                 shr     _1us_, #9               wc
	byte	$09, $36, $57, $f0
'-'                 addx    _1us_, #0                       ' Round to final value
	byte	$00, $36, $27, $f1
'-'                 qmul    hsave0, #10                     ' Calc 10us
	byte	$0a, $7a, $07, $fd
'-'                 getqx   _10us_
	byte	$18, $38, $63, $fd
'-'                 shr     _10us_, #9              wc
	byte	$09, $38, $57, $f0
'-'                 addx    _10us_, #0                      ' 10us
	byte	$00, $38, $27, $f1
'-'                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
	byte	$21, $7a, $07, $fd
'-'                 getqx   _33us_
	byte	$18, $3a, $63, $fd
'-'                 shr     _33us_, #9              wc
	byte	$09, $3a, $57, $f0
'-'                 addx    _33us_, #0                      ' 33us
	byte	$00, $3a, $27, $f1
'-'                 qmul    hsave0, #250                    ' Calc 250us
	byte	$fa, $7a, $07, $fd
'-'                 getqx   _txn_err_
	byte	$18, $3c, $63, $fd
'-'                 shr     _txn_err_, #9           wc
	byte	$09, $3c, $57, $f0
'-'                 addx    _txn_err_, #0                   ' 250us
	byte	$00, $3c, $27, $f1
'-'                 qmul    hsave0, #500                    ' Calc 500us
	byte	$f4, $7b, $07, $fd
'-'                 getqx   _500us_
	byte	$18, $3e, $63, $fd
'-'                 shr     _500us_, #9             wc
	byte	$09, $3e, $57, $f0
'-'                 addx    _500us_, #0                     ' 500us
	byte	$00, $3e, $27, $f1
'-'                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
	byte	$01, $00, $00, $ff, $9a, $7a, $07, $fd
'-'                 getqx   _txn_ok_ls_
	byte	$18, $40, $63, $fd
'-'                 shr     _txn_ok_ls_, #9         wc
	byte	$09, $40, $57, $f0
'-'                 addx    _txn_ok_ls_, #0                 ' 666us
	byte	$00, $40, $27, $f1
'-'                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
	byte	$01, $00, $00, $ff, $52, $7b, $07, $fd
'-'                 getqx   _txn_ok_fs_
	byte	$18, $42, $63, $fd
'-'                 shr     _txn_ok_fs_, #9         wc
	byte	$09, $42, $57, $f0
'-'                 addx    _txn_ok_fs_, #0                 ' 850us
	byte	$00, $42, $27, $f1
'-'                 mov     _ip_delay_ls_, _1ns16fp_
	byte	$9a, $45, $03, $f6
'-'                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
	byte	$05, $00, $00, $ff, $80, $44, $07, $fa
'-'                 shr     _ip_delay_ls_, #16      wc
	byte	$10, $44, $57, $f0
'-'                 addx    _ip_delay_ls_, #0
	byte	$00, $44, $27, $f1
'-'                 mov     _tat_wait_ls_, _1ns16fp_
	byte	$9a, $49, $03, $f6
'-'                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
	byte	$1c, $00, $00, $ff, $c0, $49, $07, $fa
'-'                 shr     _tat_wait_ls_, #16      wc
	byte	$10, $48, $57, $f0
'-'                 addx    _tat_wait_ls_, #0
	byte	$00, $48, $27, $f1
'-'                 mov     _ip_delay_fs_, _1ns16fp_
	byte	$9a, $47, $03, $f6
'-'                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
	byte	$00, $00, $00, $ff, $4e, $47, $07, $fa
'-'                 shr     _ip_delay_fs_, #16      wc
	byte	$10, $46, $57, $f0
'-'                 addx    _ip_delay_fs_, #0
	byte	$00, $46, $27, $f1
'-'                 mov     _tat_wait_fs_, _1ns16fp_
	byte	$9a, $4b, $03, $f6
'-'                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
	byte	$04, $00, $00, $ff, $23, $4b, $07, $fa
'-'                 shr     _tat_wait_fs_, #16      wc
	byte	$10, $4a, $57, $f0
'-'                 addx    _tat_wait_fs_, #0
	byte	$00, $4a, $27, $f1
'-'                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
	byte	$8d, $5b, $00, $ff, $00, $59, $16, $fd
'-'                 getqx   _preamble_wait_
	byte	$18, $4c, $63, $fd
'-'                 sub     _preamble_wait_,# 9 - 1
	byte	$08, $4c, $87, $f1
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1thou
	byte	$01, $00, $00, $ff, $e8, $2f, $27, $fd
'-'                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
	byte	$18, $4e, $63, $fd
'-'                 shr     _1ms_, #9               wc
	byte	$09, $4e, $57, $f0
'-'                 addx    _1ms_, #0                       ' 1ms
	byte	$00, $4e, $27, $f1
'-'                 mov     _frame1ms_clks_, ##-14
	byte	$ff, $ff, $7f, $ff, $f2, $67, $07, $f6
'-'                 adds    _frame1ms_clks_, _1ms_
	byte	$a7, $67, $43, $f1
'-'                 mov     _2ms_, _1ms_
	byte	$a7, $51, $03, $f6
'-'                 shl     _2ms_, #1                       ' 2ms
	byte	$01, $50, $67, $f0
'-'                 mov     _suspend_wait_, _1ms_
	byte	$a7, $53, $03, $f6
'-'                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
	byte	$a7, $53, $03, $f1
'-'                 mov     _4ms_, _1ms_
	byte	$a7, $55, $03, $f6
'-'                 shl     _4ms_, #2                       ' 4ms
	byte	$02, $54, $67, $f0
'-'                 mov     _xfer_wait_, _4ms_
	byte	$aa, $57, $03, $f6
'-'                 add     _xfer_wait_, _1ms_              ' 5ms
	byte	$a7, $57, $03, $f1
'-'                 mov     _reset_hold_, _xfer_wait_       ' 5ms
	byte	$ab, $5b, $03, $f6
'-'                 mov     _resume_hold_, _reset_hold_
	byte	$ad, $5d, $03, $f6
'-'                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
	byte	$02, $5c, $67, $f0
'-'                 mov     _100ms_, _resume_hold_          ' 20ms
	byte	$ae, $61, $03, $f6
'-'                 shl     _100ms_, #1                     ' 40ms
	byte	$01, $60, $67, $f0
'-'                 mov     _8ms_, _1ms_
	byte	$a7, $59, $03, $f6
'-'                 shl     _8ms_, #3                       ' 8ms
	byte	$03, $58, $67, $f0
'-'                 shl     _reset_hold_, #1                ' 10ms
	byte	$01, $5a, $67, $f0
'-'                 add     _100ms_, _reset_hold_           ' 50ms
	byte	$ad, $61, $03, $f1
'-'                 add     _reset_hold_, _xfer_wait_       ' 15ms
	byte	$ab, $5b, $03, $f1
'-'                 mov     _21ms_, _xfer_wait_             ' 5ms
	byte	$ab, $5f, $03, $f6
'-'                 shl     _21ms_, #2                      ' 20ms
	byte	$02, $5e, $67, $f0
'-'                 add     _21ms_, _1ms_                   ' 21ms
	byte	$a7, $5f, $03, $f1
'-'                 mov     _500ms_, _100ms_                ' 50ms
	byte	$b0, $63, $03, $f6
'-'                 shl     _100ms_, #1                     ' 100ms
	byte	$01, $60, $67, $f0
'-'                 shl     _500ms_, #3                     ' 400ms
	byte	$03, $62, $67, $f0
'-'         _ret_   add     _500ms_, _100ms_                ' 500ms
	byte	$b0, $63, $03, $01
'-' '        _ret_   mov     _1sec_, save_sysclk
'-' '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'-' '                ret
'-' {
'-' }
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Parse a configuration descriptor chain to see if the device is a recognized
'-' ' one. If it is, start the task progression that will configure the device for
'-' ' use.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hconfig_base - start address of the cached config descriptor chain.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hparse_con_desc
'-'                 mov     ptrb, dev_desc_buff_p
	byte	$28, $f3, $03, $f6
'-'                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
	byte	$82, $71, $07, $fb
'-'                 altr    hdev_port,#hdev_id
	byte	$61, $5b, $86, $f9
'-'                 movbyts htmp,#%%1032
	byte	$4e, $70, $ff, $f9
'-'                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
	byte	$86, $d3, $e6, $fa
'-'                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
'-' 
'-'                 mov     pa, #CON_wTotalLen
	byte	$02, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
	byte	$f6, $df, $e2, $fa
'-'                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
'-' ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
'-' ' that defines a keyboard and/or mouse.
'-'                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
	byte	$6e, $eb, $c2, $fa
'-' .next_intf
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #hset_config
	byte	$bc, $01, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $70, $0f, $f2
'-'         if_z    jmp     #.intf
	byte	$0c, $00, $90, $ad
'-'                 rdbyte  htmp, ptrb
	byte	$80, $71, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b8, $eb, $02, $f1
'-'                 jmp     #.next_intf
	byte	$d8, $ff, $9f, $fd
'-' .intf
'-'                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
	byte	$00, $8e, $07, $f6
'-'                 mov     hpar3, #0
	byte	$00, $90, $07, $f6
'-'                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
	byte	$82, $e1, $c6, $fa
'-'                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
	byte	$85, $e3, $c6, $fa
'-'                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
	byte	$86, $e5, $c6, $fa
'-'                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
	byte	$87, $e7, $c6, $fa
'-'                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
'-' 
'-' .endp
'-'                 rdbyte  htmp, ptrb
	byte	$80, $71, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b8, $eb, $02, $f1
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #.get_device
	byte	$78, $00, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $70, $0f, $f2
'-'         if_z    jmp     #.get_device
	byte	$64, $00, $90, $ad
'-'                 cmp     htmp, #TYPE_ENDPOINT    wz
	byte	$05, $70, $0f, $f2
'-'         if_z    jmp     #.get_ep
	byte	$04, $00, $90, $ad
'-'                 jmp     #.endp
	byte	$d0, $ff, $9f, $fd
'-' .get_ep
'-'                 rdbyte  hr1, ptrb[ENDP_bAddress]
	byte	$82, $87, $c7, $fa
'-'                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
	byte	$07, $86, $17, $f4
'-'                 shl     hr1, #8 + 7
	byte	$0f, $86, $67, $f0
'-'                 mov     htmp, hctrl_ep_addr
	byte	$6c, $71, $03, $f6
'-'                 and     htmp, ##ADDR_MASK
	byte	$3f, $00, $00, $ff, $00, $71, $07, $f5
'-'                 or      htmp, hr1                       ' endpoint address
	byte	$c3, $71, $43, $f5
'-'                 cmp     hpar2, #0               wz
	byte	$00, $8e, $0f, $f2
'-'  if_z_and_c     jmp     #.in_ep
	byte	$0c, $00, $90, $8d
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'  if_z_and_nc    jmp     #.out_ep
	byte	$18, $00, $90, $2d
'-'                 jmp     #.endp
	byte	$a0, $ff, $9f, $fd
'-' .in_ep
'-'                 mov     hpar2, htmp                     ' IN endpoint
	byte	$b8, $8f, $03, $f6
'-'                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
	byte	$84, $89, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $85, $c7, $fa
'-'                 setbyte hr2, hr0, #3
	byte	$c2, $89, $db, $f8
'-'                 jmp     #.endp
	byte	$8c, $ff, $9f, $fd
'-' .out_ep
'-'                 mov     hpar3, htmp                     ' OUT endpoint
	byte	$b8, $91, $03, $f6
'-'                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8b, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $85, $c7, $fa
'-'                 setbyte hr3, hr0, #3
	byte	$c2, $8b, $db, $f8
'-'                 jmp     #.endp
	byte	$78, $ff, $9f, $fd
'-' 
'-' .get_device
'-'                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
	byte	$ff, $e2, $0e, $f2
'-'         if_z    cmp     hdev_subclass, #$5D     wz
	byte	$5d, $e4, $0e, $a2
'-'         if_z    cmp     hdev_protocol, #$01     wz
	byte	$01, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$68, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HUB  wz
	byte	$09, $e2, $0e, $f2
'-'         if_z    jmp     #.hub
	byte	$ac, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HID              wz
	byte	$03, $e2, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No HID class, ignore
	byte	$18, $ff, $9f, $5d
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_z    cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$4c, $00, $90, $ad
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
	byte	$01, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
	byte	$04, $ff, $9f, $5d
'-' .keyboard
'-'                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
	byte	$01, $e6, $0e, $f2
'-'         if HAVE_MOUSE
'-'         if_nz  jmp      #.mouse                         ' No Keyboard
	byte	$1c, $00, $90, $5d
'-'         else
'-'         end
'-'                 cmp     hkbd_ep_addr, #0    wz
	byte	$00, $f2, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$f4, $fe, $9f, $5d
'-'                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6f, $e2, $f8
'-'                 getbyte kb_interval, hr2, #3
	byte	$c4, $71, $fa, $f8
'-'                 getbyte kb_in_max_pkt, hr2, #0
	byte	$c4, $73, $e2, $f8
'-'                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
	byte	$c7, $f3, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$e0, $fe, $9f, $fd
'-' if HAVE_MOUSE
'-' .mouse
'-'                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
	byte	$02, $e6, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No Mouse
	byte	$d8, $fe, $9f, $5d
'-'                 cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$d0, $fe, $9f, $5d
'-'                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6b, $e2, $f8
'-'                 'getbyte ms_interval, hr2, #3
'-'                 getbyte ms_in_max_pkt, hr2, #0
	byte	$c4, $6d, $e2, $f8
'-'                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
	byte	$c7, $f5, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$c0, $fe, $9f, $fd
'-' end
'-' .gamepad
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $71, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c7, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$ac, $fe, $9f, $ad
'-'         if HAVE_MOUSE
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $71, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c7, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$98, $fe, $9f, $ad
'-'         end
'-'                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz      ' |
	byte	$00, $00, $0c, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$8c, $fe, $9f, $5d
'-' 
'-'                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $79, $e2, $f8
'-'                 getbyte gp_interval, hr2, #3
	byte	$c4, $7b, $fa, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, hpar2                      ' IN endpoint address
	byte	$c7, $01, $00, $f6
'-'                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
	byte	$c8, $0b, $03, $f6
'-'                 'debug(udec(gp_intf_num))
'-'                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
'-'                 jmp     #.next_intf
	byte	$74, $fe, $9f, $fd
'-' .hub
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$6c, $fe, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_nz   cmp     hdev_protocol, #2                   wz
	byte	$02, $e6, $0e, $52
'-'         if_nz   jmp     #.next_intf
	byte	$60, $fe, $9f, $5d
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$58, $fe, $9f, $5d
'-'                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
	byte	$70, $63, $e2, $f8
'-'                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $ed, $02, $f6
'-'                 mov     ep_addr_pid, hpar2              ' IN endpoint address
	byte	$c7, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 mov     hhub_ep_addr, ep_addr_pid
	byte	$5e, $ef, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
	byte	$6c, $bd, $02, $f6
'-'                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
'-'                 jmp     #.next_intf
	byte	$3c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' If a newly-connected device is recognized, do whatever is needed to configure
'-' ' it according to its function, or functions. In the case of this boot protocol
'-' ' keyboard/mouse class driver:
'-' ' - SetConfiguration(config_num)
'-' ' - SetProtocol(boot)
'-' ' - SetIdle(indefinite)
'-' ' - Enter the device interrupt IN polling task stage.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_config
'-' '                mov     hkbd_ep_addr, #0                ' DEBUG
'-' '                mov     hmouse_ep_addr, #0              ' DEBUG
'-'                 mov     htmp2, #DEV_UNKNOWN
	byte	$02, $74, $07, $f6
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $a2
'-'         if HAVE_MOUSE
'-'         if_z    cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $a2
'-'         end
'-'         if_z    cmp     hhub_ep_addr, #0        wz
	byte	$00, $ee, $0e, $a2
'-'         if_z    jmp     #.notify_client                 ' No known device
	byte	$4c, $03, $90, $ad
'-' .set_config
'-'                 loc     ptra, #set_config
	byte	$6c, $0e, $d0, $fe
'-'                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
	byte	$05, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdbyte  hpar1, pa
	byte	$f6, $8d, $c3, $fa
'-'                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
	byte	$01, $8d, $57, $fc
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
	byte	$6c, $bd, $02, $f6
'-'                 mov     pb, #0                          ' SetConfiguration() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-' .kbd_config
'-'                 cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $f2
'-'         if_z    jmp     #.mouse_config                  ' No keyboard
	byte	$98, $00, $90, $ad
'-' 
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.mouse_config                  ' No keyboard
	byte	$84, $00, $90, $5d
'-' 
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $71, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$34, $0e, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$e4, $02, $90, $5d
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8c, $07, $f6
'-'                 getbyte hpar2, kb_intf_num, #0
	byte	$37, $8f, $e3, $f8
'-'                 call    #hset_idle
	byte	$30, $03, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hkbd_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 mov     hctwait, _2ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
	byte	$00, $76, $06, $f6
'-'                 mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $f6
'-'                 loc     pa, #hkbd_led_rep
	byte	$90, $17, $90, $fe
'-'                 wrbyte  hkbd_ledstates,pa
	byte	$f6, $f9, $42, $fc
'-'                 call    #hset_kbdled_report
	byte	$2c, $03, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$b0, $02, $90, $5d
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hkbd_ep_addr, ep_addr_pid
	byte	$5e, $f3, $02, $f6
'-'                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $f1, $02, $f6
'-'                 bitc    hkbd_ctrl_ep, #31
	byte	$1f, $f0, $46, $f4
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
	byte	$00, $f6, $06, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $c6, $f8
'-'                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
	byte	$03, $74, $07, $f6
'-'         if !!HAVE_MOUSE
'-'         end
'-' 
'-' .mouse_config
'-' if HAVE_MOUSE
'-'                 cmp     hmouse_ep_addr, #0        wz
	byte	$00, $f4, $0e, $f2
'-'         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$ac, $00, $90, $ad
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$98, $00, $90, $5d
'-' 
'-'                 debug("mouse passed addr check")
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$b0, $0d, $d0, $fe
'-'                 wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $ff, $03, $01, $5e, $fc
'-'                 wrword  ms_intf_num,ptra[wIndex]
	byte	$02, $6b, $56, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$44, $02, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),uhex_byte_array(pb,total_data))
'-' 
'-'                 getbyte htmp, ms_intf_num, #0
	byte	$35, $71, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$64, $0d, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$14, $02, $90, $5d
'-'                 debug("mouse passed SetProtocol")
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8c, $07, $f6
'-'                 getbyte hpar2, ms_intf_num, #0
	byte	$35, $8f, $e3, $f8
'-'                 call    #hset_idle
	byte	$60, $02, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hmouse_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 debug("mouse passed SetIdle")
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hmouse_ep_addr, ep_addr_pid
	byte	$5e, $f5, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $ce, $f8
'-'                 mov     htmp2, hkbd_ep_addr
	byte	$79, $75, $03, $f6
'-'                 xor     htmp2, hmouse_ep_addr
	byte	$7a, $75, $63, $f5
'-'                 and     htmp2, ##ADDR_MASK              wz
	byte	$3f, $00, $00, $ff, $00, $75, $0f, $f5
'-'         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
	byte	$05, $74, $07, $a6
'-'         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
	byte	$04, $74, $07, $56
'-'                 jmp     #.notify_client
	byte	$d0, $01, $90, $fd
'-' end
'-' .gamepad_config
'-' if _HAVE_GAMEPAD
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    jmp     #.hub_config                    ' No gamepad
	byte	$58, $01, $90, $ad
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     htmp, 0-0
	byte	$00, $70, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.hub_config                    ' No gamepad
	byte	$40, $01, $90, $5d
'-' 
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, ep_addr_pid
	byte	$5e, $01, $00, $f6
'-'                 mov     ep_addr_pid, hdev_out_addr  wz
	byte	$85, $bd, $0a, $f6
'-'         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $58
'-'         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $5d
'-'         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $54
'-'         if_nz   bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $54
'-'         if_nz   mov     hdev_out_addr, ep_addr_pid
	byte	$5e, $0b, $03, $56
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 if EMUPAD_MAX_PLAYER > 0
'-'                 
'-' .rule_loop           
'-'                 end
'-' 
'-'                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
	byte	$ff, $e2, $0e, $f2
'-'         if_e    jmp     #.xinput
	byte	$5c, $00, $90, $ad
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     htmp,0-0
	byte	$00, $70, $03, $f6
'-'                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
	byte	$01, $a6, $02, $ff, $68, $70, $0f, $f2
'-'         if_e    jmp     #.ps3
	byte	$7c, $00, $90, $ad
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$a0, $0c, $d0, $fe
'-'                 cmp     hdev_port,#0            wz
	byte	$00, $5a, $0e, $f2
'-'         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $5f, $03, $01, $5e, $5c
'-'         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
	byte	$03, $00, $80, $af, $03, $01, $5e, $ac
'-'                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
	byte	$02, $01, $5c, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$24, $01, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),uhex_byte_array(pb,total_data))
'-' 
'-'                 mov     htmp2, #HID_READY               ' Standard gamepad
	byte	$06, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$10, $01, $90, $fd
'-' .xinput
'-'                 loc     ptra, #xinp_led_cmd             ' Turn on LED
	byte	$b4, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb,#1 ' root device is also player 1
	byte	$01, $ee, $e7, $f2
'-'                 fle     pb,#3
	byte	$03, $ee, $27, $f3
'-'                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
	byte	$06, $ee, $07, $f1
'-'                 wrbyte  pb, ptra[2]
	byte	$02, $ef, $47, $fc
'-' 
'-'                 mov     pkt_data, #3
	byte	$03, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB
	byte	$03, $96, $06, $f4
'-'                 mov     ep_addr_pid, hdev_out_addr
	byte	$85, $bd, $02, $f6
'-'                 call    #txn_out
	byte	$5a, $00, $a0, $fd
'-'                 mov     ep_addr_pid, hctrl_ep_addr
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 mov     htmp2, #XINPUT_READY
	byte	$07, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$dc, $00, $90, $fd
'-' .ps3
'-'                 loc     ptra, #ps3_command_buff         ' Turn on LED
	byte	$50, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 fge     pb,#1 ' root device is also player 1
	byte	$01, $ee, $07, $f3
'-'                 fle     pb,#4
	byte	$04, $ee, $27, $f3
'-'                 decod   pb
	byte	$f7, $ef, $c3, $f9
'-'                 wrbyte  pb, ptra[9]
	byte	$09, $ef, $47, $fc
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$00, $0c, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $03, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #48, ptra[wLength]
	byte	$03, $61, $5c, $fc
'-'                 loc     pb, #ps3_command_buff
	byte	$20, $0c, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$e0, $0b, $d0, $fe
'-'                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $e9, $5f, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #4, ptra[wLength]
	byte	$03, $09, $5c, $fc
'-'                 loc     pb, #ps3_enable_cmd             ' Enable PS3
	byte	$fc, $0b, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK    wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$74, $00, $90, $5d
'-' 
'-'                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
	byte	$08, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$6c, $00, $90, $fd
'-' end
'-' 
'-' .hub_config
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_z    jmp     #.notify_client                 ' No HUB
	byte	$64, $00, $90, $ad
'-'                 mov     htmp, hhub_ep_addr
	byte	$77, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.notify_client                 ' No HUB
	byte	$50, $00, $90, $5d
'-' 
'-'                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
	byte	$a0, $0b, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, hub_descr_p
	byte	$26, $ef, $03, $f6
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hhub_ep_addr, #0
	byte	$00, $ee, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $00, $90, $5d
'-'                 debug(uhex_byte_array(hub_descr_p,total_data))
'-' 
'-'                 mov     ptra, hub_descr_p
	byte	$26, $f1, $03, $f6
'-'                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
	byte	$02, $77, $c7, $fa
'-'                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
	byte	$07, $76, $27, $f3
'-'                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
'-' .pwr_loop
'-'                 loc     ptra, #set_port_feat            ' Power on ports
	byte	$80, $0b, $d0, $fe
'-'                 wrword  #HUB_PORT_POWER, ptra[wValue]
	byte	$01, $11, $5c, $fc
'-'                 wrword  htmp3, ptra[wIndex]
	byte	$02, $77, $57, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 djnz    htmp3, #.pwr_loop
	byte	$fb, $77, $6f, $fb
'-' 
'-'                 mov     hctwait, _500ms_
	byte	$b1, $99, $02, $f6
'-'                 add     hctwait, _100ms_
	byte	$b0, $99, $02, $f1
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 mov     htmp2, #HUB_READY               ' Hub ready
	byte	$09, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$00, $00, $90, $fd
'-' 
'-' .notify_client
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte htmp2                           ' Save device ready
	byte	$ba, $01, $c0, $f8
'-'                 debug(uhex_long(hdev_type,hdev_type+1))
'-'         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Initialize the keyboard/mouse data area to start-up values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' init_kbdm_data
'-'                 mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $f6
'-'                 mov     hdev_ep_addr, #0
	byte	$00, $fa, $06, $f6
'-' 
'-'                 mov     ptra, cache_start_p         ' Clear cached data buffers
	byte	$2a, $f1, $03, $f6
'-'                 mov     pa, cache_end_p
	byte	$2b, $ed, $03, $f6
'-' .loop
'-'                 wrbyte  #0, ptra++
	byte	$61, $01, $4c, $fc
'-'                 cmp     ptra, pa                wcz
	byte	$f6, $f1, $1b, $f2
'-'         if_b    jmp     #.loop
	byte	$f4, $ff, $9f, $cd
'-'         
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' 
'-'                 mov     pa, #hdev_init_start        ' Clear device data registers
	byte	$2d, $ed, $07, $f6
'-' .regloop
'-'                 altd    pa
	byte	$00, $ec, $8f, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-'                 add     pa, #1
	byte	$01, $ec, $07, $f1
'-'                 cmp     pa, #hdev_init_end      wz
	byte	$47, $ed, $0f, $f2
'-'         if_nz   jmp     #.regloop
	byte	$ec, $ff, $9f, $5d
'-' 
'-'                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
	byte	$e1, $e1, $61, $ff, $c3, $5d, $06, $f6
'-'                 mov     hdev_next_datax + 1,hdev_next_datax
	byte	$2e, $5f, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0
	byte	$c3, $60, $c6, $f8
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1
	byte	$c3, $60, $ce, $f8
'-' 
'-'         _ret_   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
'-' ' function.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'-' '   hpar2 - index number of the target interface.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_idle
'-'                 mov     hctwait, _2ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #set_idle
	byte	$d8, $0a, $d0, $fe
'-'                 wrword  hpar1, ptra[wValue]
	byte	$01, $8d, $57, $fc
'-'                 wrword  hpar2, ptra[wIndex]
	byte	$02, $8f, $57, $fc
'-'                 jmp     #control_write
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
'-' ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - device address and enpoint for the request.
'-' ' On exit:
'-' '   retval - transaction result.
'-' '------------------------------------------------------------------------------
'-' hset_kbdled_report
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$cc, $0a, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
	byte	$01, $00, $80, $ff, $01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
	byte	$03, $03, $5c, $fc
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrbyte  kb_led_states, pb
	byte	$f7, $77, $42, $fc
'-'                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for keyboard activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_kbd_in_report
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #0
	byte	$30, $91, $e3, $f8
'-'                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
	byte	$39, $91, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
	byte	$30, $71, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
	byte	$4b, $60, $c6, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
	byte	$c3, $60, $c6, $58
'-' 
'-'                 mov     kb_max_index, hpar3             ' Save actual bytes read
	byte	$c8, $75, $02, $f6
'-'                 call    #hkbd_compare
	byte	$18, $00, $b0, $fd
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' .led_check
'-'                 mov     htmp, kb_led_states
	byte	$3b, $71, $03, $f6
'-'                 cmp     hkbd_ledstates, htmp    wz
	byte	$b8, $f9, $0a, $f2
'-'         if_z    ret                                     ' No toggle key indicator changes, so we're done
	byte	$2d, $00, $64, $ad
'-'                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
	byte	$7c, $77, $02, $f6
'-'                 mov     ep_addr_pid, hkbd_ctrl_ep
	byte	$78, $bd, $02, $f6
'-'                 jmp     #hset_kbdled_report             ' Set report and ignore errors
	byte	$88, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Compare current and previous keyboard data buffers for keypress changes.
'-' '------------------------------------------------------------------------------
'-' hkbd_compare
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$d4, $13, $f0, $fe
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $75, $07, $fb
'-'                 cmp     htmp1, htmp2    wz
	byte	$ba, $73, $0b, $f2
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $75, $07, $fb
'-'         if_z    cmp     htmp1, htmp2    wz
	byte	$ba, $73, $0b, $a2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-' 
'-'                 loc     ptra, #hkbd_report
	byte	$b4, $13, $d0, $fe
'-' 
'-'                 ' Handle modifiers
'-'                 rdbyte  hpar2, urx_buff_p
	byte	$27, $8f, $c3, $fa
'-'                 rdbyte  hr1, ptra
	byte	$00, $87, $c7, $fa
'-'                 rolword hr1,hpar2,#0
	byte	$c7, $87, $43, $f9
'-'                 mergew  hr1
	byte	$63, $86, $63, $fd
'-'                 mov     pa,#8
	byte	$08, $ec, $07, $f6
'-' .modloop
'-'                 rczr    hr1     wcz ' New value in C, old value in Z
	byte	$6a, $86, $7b, $fd
'-'                 mov     hpar1,#$E8
	byte	$e8, $8c, $07, $f6
'-'                 sub     hpar1,pa
	byte	$f6, $8d, $83, $f1
'-'       if_c_ne_z call    #hkbd_translate
	byte	$a0, $00, $b0, $6d
'-'                 djnz    pa,#.modloop
	byte	$fb, $ed, $6f, $fb
'-' 
'-' .release        modc    _set    wc
	byte	$6f, $e0, $75, $fd
'-'                 'alts    hdev_port, #hid_report_p
'-'                 'mov     ptra, hid_report_p
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .rl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8d, $cf, $fa
'-'         if_z    jmp     #.rl3
	byte	$20, $00, $90, $ad
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .rl2            rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b8, $8d, $0b, $f2
'-'         if_z    jmp     #.rl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.rl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$68, $00, $b0, $fd
'-' .rl3            djnz    pa, #.rl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-'                 mov     hpar3, #0
	byte	$00, $90, $07, $f6
'-'                 bith    hpar3, #31
	byte	$1f, $90, $27, $f4
'-' 
'-' .press          modc    _clr    wc
	byte	$6f, $00, $74, $fd
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .pl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8d, $cf, $fa
'-'         if_z    jmp     #.pl3
	byte	$20, $00, $90, $ad
'-'                 loc     ptrb, #hkbd_report
	byte	$30, $13, $f0, $fe
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .pl2            rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b8, $8d, $0b, $f2
'-'         if_z    jmp     #.pl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.pl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$24, $00, $b0, $fd
'-' .pl3            djnz    pa, #.pl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-' .copy           mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$08, $13, $f0, $fe
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 wrlong  htmp1, ptrb++
	byte	$e1, $73, $67, $fc
'-'                 wrbyte  hkbd_ledstates,ptrb++
	byte	$e1, $f9, $46, $fc
'-' 
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Translate keyboard scancode to ASCII
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - scancode
'-' '   hpar2 - key modifiers state
'-' '       c - pressed (0) or released (1) flag
'-' ' On exit:
'-' '   hpar1 - bit     31 = 0 pressed, 1 released
'-' '               30..17 = unused
'-' '                   18 = scroll-lock state 
'-' '                   17 = caps-lock state
'-' '                   16 = num-lock state 
'-' '                15..8 = key modifiers state
'-' '                 7..0 = scancode
'-' '------------------------------------------------------------------------------
'-' hkbd_translate
'-'                 cmp     hpar1, #KEY_CAPSLOCK    wz
	byte	$39, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
	byte	$01, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_NUMLOCK     wz
	byte	$53, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
	byte	$00, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_SCROLLLOCK  wz
	byte	$47, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
	byte	$02, $f8, $e6, $24
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' 
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' 
'-'         end
'-'                 setbyte hpar1, hpar2, #1
	byte	$c7, $8d, $cb, $f8
'-'                 setbyte hpar1, hkbd_ledstates,#2
	byte	$7c, $8d, $d3, $f8
'-'                 bitc    hpar1, #31
	byte	$1f, $8c, $47, $f4
'-'         if KEYQUEUE_SIZE > 0
'-'                 loc pb,#keyq_head
	byte	$c4, $09, $b0, $fe
'-'                 rdword htmp,pb
	byte	$f7, $71, $e3, $fa
'-'                 getbyte htmp1,htmp,#1 ' tail
	byte	$b8, $73, $eb, $f8
'-'                 getbyte htmp,htmp,#0 ' head
	byte	$b8, $71, $e3, $f8
'-'                 mov htmp2,htmp
	byte	$b8, $75, $03, $f6
'-'                 mul htmp2,#4
	byte	$04, $74, $07, $fa
'-'                 add htmp2,pb
	byte	$f7, $75, $03, $f1
'-'                 add htmp2,#2
	byte	$02, $74, $07, $f1
'-'                 incmod htmp,#KEYQUEUE_SIZE - 1
	byte	$7f, $70, $07, $f7
'-'                 cmp htmp1,htmp wz ' check buffer overflow
	byte	$b8, $73, $0b, $f2
'-'         if_nz   wrlong hpar1,htmp2
	byte	$ba, $8d, $63, $5c
'-'         if_nz   wrbyte htmp,pb
	byte	$f7, $71, $43, $5c
'-'         end
'-'                 ret wcz
	byte	$2d, $00, $7c, $fd
'-' 
'-' if HAVE_MOUSE
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for mouse activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_mouse_in_report
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #1
	byte	$30, $91, $eb, $f8
'-'                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
	byte	$36, $91, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
	byte	$30, $71, $eb, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
	byte	$4b, $60, $ce, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
	byte	$c3, $60, $ce, $58
'-' 
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 cmp     hpar3, #5               wcz     ' Hack: Combo PS/2-USB adapters adds report-id
	byte	$05, $90, $1f, $f2
'-'         if_ae   add     ptra, #1                        ' | skip
	byte	$01, $f0, $07, $31
'-'         if_ae   sub     hpar3, #1
	byte	$01, $90, $87, $31
'-' 
'-'                 loc     pa, #mouse_limits
	byte	$40, $09, $90, $fe
'-'                 loc     ptrb, #mouse_xacc
	byte	$25, $13, $f0, $fe
'-' 
'-'                 ' load xacc,yacc,zacc
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  hr1,ptrb
	byte	$80, $87, $07, $fb
'-'                 ' load limits and outptr
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  htmp1,pa
	byte	$f6, $73, $03, $fb
'-' 
'-'                 rdbyte  htmp, ptra++                     ' Button flags
	byte	$61, $71, $c7, $fa
'-'                 wrbyte  htmp, ptrb[12]                    ' write verbatim into extra byte
	byte	$8c, $71, $47, $fc
'-'                 testb   htmp,#0                 wc       ' left button flag
	byte	$00, $70, $17, $f4
'-'         if_c    wrbyte  #1,ptrb[13]
	byte	$8d, $03, $4c, $cc
'-'                 testb   htmp,#1                 wc       ' left button flag
	byte	$01, $70, $17, $f4
'-'         if_c    wrbyte  #1,ptrb[14]
	byte	$8e, $03, $4c, $cc
'-'                 testb   htmp,#2                 wc       ' left button flag
	byte	$02, $70, $17, $f4
'-'         if_c    wrbyte  #1,ptrb[15]
	byte	$8f, $03, $4c, $cc
'-'               
'-' 
'-'                 rdbyte  htmp, ptra++                     ' X direction and velocity is 8-bit signed
	byte	$61, $71, $c7, $fa
'-'                 signx   htmp, #7
	byte	$07, $70, $67, $f7
'-'                 add     hr1,htmp
	byte	$b8, $87, $03, $f1
'-'                 cmp     htmp1,#0 wz
	byte	$00, $72, $0f, $f2
'-'         if_ne   fles    hr1,htmp1
	byte	$b9, $87, $63, $53
'-'         if_ne   fges    hr1,#0
	byte	$00, $86, $47, $53
'-' 
'-'                 rdbyte  htmp, ptra++                     ' Y direction and velocity is 8-bit signed
	byte	$61, $71, $c7, $fa
'-'                 signx   htmp, #7
	byte	$07, $70, $67, $f7
'-'                 add     hr2,htmp
	byte	$b8, $89, $03, $f1
'-'                 cmp     htmp2,#0 wz
	byte	$00, $74, $0f, $f2
'-'         if_ne   fles    hr2,htmp2
	byte	$ba, $89, $63, $53
'-'         if_ne   fges    hr2,#0
	byte	$00, $88, $47, $53
'-'                 
'-' 
'-'                 cmp     hpar3, #4               wz      ' Very few mice send +/- scroll wheel data in boot protocol
	byte	$04, $90, $0f, $f2
'-'         if_z    rdbyte  htmp, ptra
	byte	$00, $71, $c7, $aa
'-'         if_z    signx   htmp, #7                        ' If it's there, use it
	byte	$07, $70, $67, $a7
'-'         if_z    add     hr3,htmp
	byte	$b8, $8b, $03, $a1
'-' 
'-'                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
	byte	$90, $71, $cf, $fa
'-'         if_nz   ret                                     ' If so, don't write results
	byte	$2d, $00, $64, $5d
'-' 
'-'                 ' write back accumulators
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 wrlong  hr1,ptrb
	byte	$80, $87, $67, $fc
'-'                 ' if outptr set, write X/Y words
'-'                 cmp htmp3,#0                    wz
	byte	$00, $76, $0f, $f2
'-'         if_nz   setword hr1,hr2,#1
	byte	$c4, $87, $2b, $59
'-'         if_nz   wrlong hr1,htmp3
	byte	$bb, $87, $63, $5c
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' hget_gp_in_report
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-' 
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 altgb   hdev_port, #hdev_next_datax
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte hpar3
	byte	$00, $90, $e3, $f8
'-'                 setword hpar3, #255, #1                 ' Always ask for max report size
	byte	$ff, $90, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-'                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte htmp                            ' |
	byte	$00, $70, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    mov     htmp, #PID_DATA1                ' |
	byte	$4b, $70, $07, $a6
'-'         if_nz   mov     htmp, #PID_DATA0                ' |
	byte	$c3, $70, $07, $56
'-'                 altsb   hdev_port, #hdev_next_datax     ' |
	byte	$2e, $5b, $66, $f9
'-'                 setbyte htmp                            ' |
	byte	$b8, $01, $c0, $f8
'-' 
'-' ' Note: the following code compares the current and previous reports
'-' ' and process the data if there are changes to ease the debug output.
'-' ' Actual implementations should remove this block, along with hid_pre_rpt_p and
'-' ' gpPreReport buffer.
'-' 
'-'                 ' ----- start of block to remove
'-'                 {
'-'                 }
'-'                 ' ----- end of block to remove
'-'                 loc pa,#hpad_translate
	byte	$f4, $04, $90, $fe
'-'                 push pa
	byte	$2a, $ec, $63, $fd
'-' 
'-'                 ' FALL THROUGH !!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Decode controller report
'-' '------------------------------------------------------------------------------
'-' hid_decode
'-'                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
'-'                 setq #(hidr_end-hidr_start)-1
	byte	$28, $1e, $64, $fd
'-'                 rdlong  hidr_start,##$8_0000
	byte	$00, $04, $00, $ff, $00, $0c, $07, $fb
'-' 
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte hidr_type
	byte	$00, $2a, $e3, $f8
'-'                 cmp     hidr_type, #XINPUT_READY        wz
	byte	$07, $2a, $0f, $f2
'-'         if_z    jmp     #hpad_xinput
	byte	$34, $02, $90, $ad
'-'                 cmp     hidr_type, #PS3_READY           wz
	byte	$08, $2a, $0f, $f2
'-'         if_z    jmp     #hpad_ps3
	byte	$1c, $03, $90, $ad
'-'                 cmp     hidr_type, #KBM_READY           wz
	byte	$05, $2a, $0f, $f2
'-'         if_z    mov     hidr_type,#M_READY
	byte	$04, $2a, $07, $a6
'-'                 cmp     hidr_type, #M_READY             wz
	byte	$04, $2a, $0f, $f2
'-'                 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle HID controller (or mouse now
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' hpad_hid
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 mov     ptra, pb
	byte	$f7, $f1, $03, $f6
'-'                 alts    hdev_port, #gp_descr_len
	byte	$3f, $5b, $96, $f9
'-'                 mov     pa, 0-0
	byte	$00, $ec, $03, $f6
'-'                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
'-'                 mov     hidr_usage, ##$76543210
	byte	$19, $2a, $3b, $ff, $10, $0c, $07, $f6
'-' 
'-' .next
'-'                 cmps    pa, #0      wcz
	byte	$00, $ec, $5f, $f2
'-'         if_be   ret     wcz
	byte	$2d, $00, $7c, $ed
'-' 
'-'                 rdbyte  hpar1, ptra++
	byte	$61, $8d, $c7, $fa
'-'                 sub     pa, #1
	byte	$01, $ec, $87, $f1
'-'                 mov     hpar2, #0
	byte	$00, $8e, $07, $f6
'-' 
'-'                 mov     htmp, hpar1
	byte	$c6, $71, $03, $f6
'-'                 and     htmp, #$03
	byte	$03, $70, $07, $f5
'-'                 cmp     htmp, #1    wz
	byte	$01, $70, $0f, $f2
'-'         if_z    rdbyte  hpar2, ptra++
	byte	$61, $8f, $c7, $aa
'-'         if_z    signx   hpar2,#7
	byte	$07, $8e, $67, $a7
'-'         if_z    sub     pa, #1
	byte	$01, $ec, $87, $a1
'-'                 cmp     htmp, #2    wz
	byte	$02, $70, $0f, $f2
'-'         if_z    rdword  hpar2, ptra++
	byte	$61, $8f, $e7, $aa
'-'         if_z    signx   hpar2,#15
	byte	$0f, $8e, $67, $a7
'-'         if_z    sub     pa, #2
	byte	$02, $ec, $87, $a1
'-'                 cmp     htmp, #3    wz
	byte	$03, $70, $0f, $f2
'-'         if_z    rdlong  hpar2, ptra++
	byte	$61, $8f, $07, $ab
'-'         if_z    sub     pa, #4
	byte	$04, $ec, $87, $a1
'-' 
'-'                 and     hpar1, #$FC
	byte	$fc, $8c, $07, $f5
'-'                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
'-' 
'-'                 cmp     hpar1, #HID_REPORT_ID   wz
	byte	$84, $8c, $0f, $f2
'-'         if_z    jmp     #.report_id
	byte	$0c, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE_PAGE  wz
	byte	$04, $8c, $0f, $f2
'-'         if_z    jmp     #.usage_page
	byte	$24, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE       wz
	byte	$08, $8c, $0f, $f2
'-'         if_z    jmp     #.usage
	byte	$2c, $01, $90, $ad
'-'                 cmp     hpar1, #HID_LOGICAL_MIN wz
	byte	$14, $8c, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #1
	byte	$c7, $27, $2b, $a9
'-'                 cmp     hpar1, #HID_LOGICAL_MAX wz
	byte	$24, $8c, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #0
	byte	$c7, $27, $23, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MIN wz
	byte	$34, $8c, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #1
	byte	$c7, $29, $2b, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MAX wz
	byte	$44, $8c, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #0
	byte	$c7, $29, $23, $a9
'-'                 cmp     hpar1, #HID_REPORT_SIZE wz
	byte	$74, $8c, $0f, $f2
'-'         if_z    mov     hidr_size, hpar2
	byte	$c7, $1f, $03, $a6
'-'                 cmp     hpar1, #HID_REPORT_COUNT wz
	byte	$94, $8c, $0f, $f2
'-'         if_z    mov     hidr_count, hpar2
	byte	$c7, $21, $03, $a6
'-'                 cmp     hpar1, #HID_INPUT       wz
	byte	$80, $8c, $0f, $f2
'-'         if_nz   jmp     #.next
	byte	$64, $ff, $9f, $5d
'-' 
'-'                 tjf     hidr_state,#.next
	byte	$d8, $1d, $a7, $fb
'-' 
'-'                 and     hpar2, #$03
	byte	$03, $8e, $07, $f5
'-'                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
	byte	$02, $8e, $0f, $f2
'-'         if_nz   jmp     #.skip
	byte	$18, $00, $90, $5d
'-' 
'-'                 cmp     hidr_state, #2  wz
	byte	$02, $1c, $0f, $f2
'-'         if_z    jmp     #.axes
	byte	$20, $00, $90, $ad
'-'                 cmp     hidr_state, #3  wz
	byte	$03, $1c, $0f, $f2
'-'         if_z    jmp     #.hats
	byte	$5c, $00, $90, $ad
'-'                 cmp     hidr_state, #4  wz
	byte	$04, $1c, $0f, $f2
'-'         if_z    jmp     #.buttons
	byte	$70, $00, $90, $ad
'-' .skip
'-'                 mov     htmp, hidr_size
	byte	$8f, $71, $03, $f6
'-'                 mul     htmp, hidr_count
	byte	$90, $71, $03, $fa
'-'                 add     hidr_offset, htmp
	byte	$b8, $23, $03, $f1
'-'                 jmp     #.next
	byte	$2c, $ff, $9f, $fd
'-' .axes
'-'                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 getnib  hr0, hidr_flags, #2
	byte	$87, $85, $53, $f8
'-'                 mov     hr1, hidr_count
	byte	$90, $87, $03, $f6
'-' .l1
'-'                 mov     hpar1, hidr_offset
	byte	$91, $8d, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$8f, $8f, $03, $f6
'-'                 call    #hpad_getbits
	byte	$04, $03, $b0, $fd
'-'                 call    #hpad_normalize
	byte	$64, $03, $b0, $fd
'-'                 cmp     hr0, #6         wcz
	byte	$06, $84, $1f, $f2
'-'         if_b    altgn   hr0, #hidr_usage
	byte	$86, $85, $5f, $c9
'-'         if_b    getnib  hr2
	byte	$00, $88, $43, $c8
'-'         if_b    altsw   hr2, #hidr_axis
	byte	$88, $89, $77, $c9
'-'         if_b    setword retval
	byte	$5f, $01, $20, $c9
'-'         if_b    add     hr0, #1
	byte	$01, $84, $07, $c1
'-'                 add     hidr_offset, hidr_size
	byte	$8f, $23, $03, $f1
'-'                 djnz    hr1, #.l1
	byte	$f4, $87, $6f, $fb
'-' 
'-'                 setnib  hidr_flags, hr0, #2
	byte	$c2, $0f, $13, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $1c, $07, $f6
'-'                 jmp     #.next
	byte	$e8, $fe, $9f, $fd
'-' .hats
'-'                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$91, $8d, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$8f, $8f, $03, $f6
'-'                 call    #hpad_getbits
	byte	$c8, $02, $b0, $fd
'-'                 setbyte hidr_hats, retval, #0
	byte	$5f, $19, $c3, $f8
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $1c, $07, $f6
'-'                 jmp     #.skip
	byte	$90, $ff, $9f, $fd
'-' .buttons
'-'                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$91, $8d, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$8f, $8f, $03, $f6
'-'                 mul     hpar2, hidr_count
	byte	$90, $8f, $03, $fa
'-'                 call    #hpad_getbits
	byte	$a8, $02, $b0, $fd
'-'                 getbyte htmp, hidr_flags, #0
	byte	$87, $71, $e3, $f8
'-'                 shl     retval, htmp
	byte	$b8, $bf, $62, $f0
'-'                 or      hidr_buttons, retval
	byte	$5f, $17, $43, $f5
'-'                 add     htmp, hidr_count
	byte	$90, $71, $03, $f1
'-'                 setbyte hidr_flags, htmp, #0
	byte	$b8, $0f, $c3, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $1c, $07, $f6
'-'                 jmp     #.skip
	byte	$64, $ff, $9f, $fd
'-' .report_id
'-'                 cmp     hidr_id, #0     wz
	byte	$00, $1a, $0f, $f2
'-'         if_nz   ret     wcz
	byte	$2d, $00, $7c, $5d
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     htmp, hpar2     wz
	byte	$c7, $71, $0b, $f2
'-'         if_z    mov     hidr_id, htmp
	byte	$b8, $1b, $03, $a6
'-'         if_nz   neg     hidr_state,#1
	byte	$01, $1c, $67, $56
'-'         if_nz   sub     ptrb,#1
	byte	$01, $f2, $87, $51
'-'                 jmp     #.next
	byte	$80, $fe, $9f, $fd
'-' .usage_page
'-'                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
	byte	$09, $8e, $0f, $f2
'-'         if_z    cmp     hidr_state, #1  wz
	byte	$01, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #4
	byte	$04, $1c, $07, $a6
'-'                 jmp     #.next
	byte	$70, $fe, $9f, $fd
'-' .usage
'-'                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
	byte	$04, $8e, $0f, $f2
'-'         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
	byte	$05, $8e, $0f, $52
'-'         if_z    cmp     hidr_type,#HID_READY        wz
	byte	$06, $2a, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $1c, $07, $a6
'-'         if_z    jmp     #.next
	byte	$5c, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_MOUSE     wz
	byte	$02, $8e, $0f, $f2
'-'         if_z    cmp     hidr_type,#M_READY          wz
	byte	$04, $2a, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $1c, $07, $a6
'-'         if_z    jmp     #.next
	byte	$4c, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_X     wz
	byte	$30, $8e, $0f, $f2
'-'         if_nz   cmp     hpar2, #HID_USAGE_Y     wz
	byte	$31, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_Z     wz
	byte	$32, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_RX    wz
	byte	$33, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_RY    wz
	byte	$34, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_RZ    wz
	byte	$35, $8e, $0f, $52
'-'         if_z    jmp     #.usage_axis
	byte	$10, $00, $90, $ad
'-'                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
	byte	$39, $8e, $0f, $f2
'-'         if_z    cmp     hidr_state, #1      wz
	byte	$01, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #3
	byte	$03, $1c, $07, $a6
'-'                 jmp     #.next
	byte	$20, $fe, $9f, $fd
'-' .usage_axis
'-'                 cmps    hidr_state, #1          wc
	byte	$01, $1c, $57, $f2
'-'         if_b    jmp     #.next
	byte	$18, $fe, $9f, $cd
'-'                 altsn   hidr_usage_idx, #hidr_usage
	byte	$86, $25, $57, $f9
'-'                 setnib  hpar2
	byte	$c7, $01, $00, $f8
'-' 
'-'                 sub     hpar2, #HID_USAGE_X - 16
	byte	$20, $8e, $87, $f1
'-'                 decod   hpar2
	byte	$c7, $8f, $c3, $f9
'-'                 or      hidr_flags, hpar2
	byte	$c7, $0f, $43, $f5
'-' 
'-'                 add     hidr_usage_idx, #1
	byte	$01, $24, $07, $f1
'-'                 mov     hidr_state, #2
	byte	$02, $1c, $07, $f6
'-'                 jmp     #.next
	byte	$f8, $fd, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle XInput controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_xinput
'-'                 rdbyte  htmp, ptrb      wz
	byte	$80, $71, $cf, $fa
'-'         if_nz   ret                         ' Ignore message type <> $00
	byte	$2d, $00, $64, $5d
'-'                 rdbyte  htmp, ptrb[1]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #$14      wz
	byte	$14, $70, $0f, $f2
'-'         if_nz   ret                         ' Ignore report length <> $14 (20)
	byte	$2d, $00, $64, $5d
'-' 
'-'                 debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
	byte	$b0, $0e, $27, $f4
'-'                 setnib  hidr_flags, #6, #2
	byte	$06, $0e, $17, $f8
'-' 
'-'                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
	byte	$83, $11, $e7, $fa
'-'                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
	byte	$84, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
	byte	$85, $13, $e7, $fa
'-'                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
	byte	$86, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $26, $07, $f6
'-'                 rdbyte  retval, ptrb[4]     ' left analog trigger
	byte	$84, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
	byte	$06, $16, $27, $34
'-'                 call    #hpad_normalize
	byte	$f8, $01, $b0, $fd
'-'                 setword hidr_axis+1, retval, #1
	byte	$5f, $13, $2b, $f9
'-'                 rdbyte  retval, ptrb[5]     ' right analog trigger
	byte	$85, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
	byte	$07, $16, $27, $34
'-'                 call    #hpad_normalize
	byte	$e4, $01, $b0, $fd
'-'                 setword hidr_axis+2, retval, #0
	byte	$5f, $15, $23, $f9
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 rdword  retval, ptrb[1]
	byte	$81, $bf, $e6, $fa
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $16, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $16, $47, $f4
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $16, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $16, $47, $f4
'-'                 testb   retval, #8      wc  ' LB
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $16, $47, $f4
'-'                 testb   retval, #9      wc  ' RB
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $16, $47, $f4
'-'                 testb   retval, #5      wc  ' SELECT
	byte	$05, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $16, $47, $f4
'-'                 testb   retval, #4      wc  ' START
	byte	$04, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $16, $47, $f4
'-'                 testb   retval, #6      wc  ' L3
	byte	$06, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $16, $47, $f4
'-'                 testb   retval, #7      wc  ' R3
	byte	$07, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $16, $47, $f4
'-'                 testb   retval, #10     wc  ' XBOX
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $16, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
	byte	$5f, $71, $43, $f8
'-'                 mov     htmp1, ##$F576_F40F
	byte	$7a, $bb, $7a, $ff, $0f, $72, $07, $f6
'-'                 mov     htmp2, ##$FFFF_F312
	byte	$f9, $ff, $7f, $ff, $12, $75, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$b9, $71, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $70, $43, $f8
'-'                 setbyte hidr_hats, htmp, #0
	byte	$b8, $19, $c3, $f8
'-' 
'-'                 jmp     #hpad_translate
	byte	$ac, $01, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle PS3 controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_ps3
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     htmp, #$01      wz
	byte	$01, $70, $0f, $f2
'-'         if_nz   ret                         ' Ignore report ID <> $01
	byte	$2d, $00, $64, $5d
'-' 
'-'                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $26, $07, $f6
'-'                 rdbyte  retval, ptrb[5]         ' X = left stick X
	byte	$85, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$40, $01, $b0, $fd
'-'                 setword hidr_axis, retval, #0
	byte	$5f, $11, $23, $f9
'-'                 bith    hidr_flags, #HID_AXIS_X
	byte	$10, $0e, $27, $f4
'-'                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
	byte	$86, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$30, $01, $b0, $fd
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 bith    hidr_flags, #HID_AXIS_Y
	byte	$11, $0e, $27, $f4
'-'                 rdbyte  retval, ptrb[7]         ' Z = right stick X
	byte	$87, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$20, $01, $b0, $fd
'-'                 setword hidr_axis+1, retval, #0
	byte	$5f, $13, $23, $f9
'-'                 bith    hidr_flags, #HID_AXIS_Z
	byte	$12, $0e, $27, $f4
'-'                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
	byte	$88, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$10, $01, $b0, $fd
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-'                 bith    hidr_flags, #HID_AXIS_RZ
	byte	$15, $0e, $27, $f4
'-'                 setnib  hidr_flags, #4, #2
	byte	$04, $0e, $17, $f8
'-' 
'-'                 mov     hpar1, #8
	byte	$08, $8c, $07, $f6
'-'                 mov     hpar2, #19
	byte	$13, $8e, $07, $f6
'-'                 call    #hpad_getbits
	byte	$94, $00, $b0, $fd
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $16, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $16, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $16, $47, $f4
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $16, $47, $f4
'-'                 testb   retval, #10     wc  ' L1
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $16, $47, $f4
'-'                 testb   retval, #11     wc  ' R1
	byte	$0b, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $16, $47, $f4
'-'                 testb   retval, #8      wc  ' L2
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #6
	byte	$06, $16, $47, $f4
'-'                 testb   retval, #9      wc  ' R2
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #7
	byte	$07, $16, $47, $f4
'-'                 testb   retval, #0      wc  ' SELECT
	byte	$00, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $16, $47, $f4
'-'                 testb   retval, #3      wc  ' START
	byte	$03, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $16, $47, $f4
'-'                 testb   retval, #1      wc  ' LEFT STICK
	byte	$01, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $16, $47, $f4
'-'                 testb   retval, #2      wc  ' RIGHT STICK
	byte	$02, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $16, $47, $f4
'-'                 testb   retval, #16     wc  ' HOME
	byte	$10, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $16, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
	byte	$5f, $71, $4b, $f8
'-'                 mov     htmp1, ##$F3F4_120F
	byte	$09, $fa, $79, $ff, $0f, $72, $07, $f6
'-'                 mov     htmp2, ##$FFF5_FF76
	byte	$ff, $fa, $7f, $ff, $76, $75, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$b9, $71, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $70, $43, $f8
'-'                 setbyte hidr_hats, htmp, #0
	byte	$b8, $19, $c3, $f8
'-' 
'-'                 jmp     #hpad_translate
	byte	$b8, $00, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Read bits from report data buffer
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRB - report buffer
'-' '   hpar1 - start bit
'-' '   hpar2 - number of bits
'-' ' On exit:
'-' '   retval - bits
'-' '------------------------------------------------------------------------------
'-' hpad_getbits
'-'                 mov     htmp, hpar1
	byte	$c6, $71, $03, $f6
'-'                 shr     htmp, #3        ' byte offset
	byte	$03, $70, $47, $f0
'-'                 add     htmp, ptrb
	byte	$f9, $71, $03, $f1
'-'                 rdlong  retval, htmp
	byte	$b8, $bf, $02, $fb
'-' 
'-'                 mov     htmp1, hpar1
	byte	$c6, $73, $03, $f6
'-'                 and     htmp1, #$07     ' shift
	byte	$07, $72, $07, $f5
'-'                 shr     retval, htmp1
	byte	$b9, $bf, $42, $f0
'-' 
'-'                 cmp     hpar2, #24      wcz
	byte	$18, $8e, $1f, $f2
'-'         if_a    jmp     #.l1
	byte	$10, $00, $90, $1d
'-' 
'-'                 decod   hpar2
	byte	$c7, $8f, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $8e, $87, $f1
'-'                 and     retval, hpar2
	byte	$c7, $bf, $02, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .l1
'-'                 and     retval, ##$00_FFFFFF
	byte	$ff, $7f, $00, $ff, $ff, $bf, $06, $f5
'-'                 add     htmp, #3
	byte	$03, $70, $07, $f1
'-'                 rdlong  htmp2, htmp
	byte	$b8, $75, $03, $fb
'-'                 sub     hpar2, #24
	byte	$18, $8e, $87, $f1
'-'                 decod   hpar2
	byte	$c7, $8f, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $8e, $87, $f1
'-'                 shr     htmp2, htmp1
	byte	$b9, $75, $43, $f0
'-'                 and     htmp2, hpar2
	byte	$c7, $75, $03, $f5
'-'                 shl     htmp2, #24
	byte	$18, $74, $67, $f0
'-'                 or      retval, htmp2
	byte	$ba, $bf, $42, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Normalize value to signed word (-32768 / 32767)
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - value to normalize
'-' '   hidr_lminmax - min (word 1) max (word 0) value range
'-' '   - or -
'-' '   hidr_pminmax - min (word 1) max (word 0) value range
'-' '   hidr_size - value bits length
'-' ' On exit:
'-' '   retval - normalized value
'-' '------------------------------------------------------------------------------
'-' hpad_normalize
'-'                 mov     htmp, hidr_lminmax  wz
	byte	$93, $71, $0b, $f6
'-'         if_z    mov     htmp, hidr_pminmax  wz
	byte	$94, $71, $0b, $a6
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 getword htmp1, htmp, #1     ' htmp1 = min
	byte	$b8, $73, $3b, $f9
'-'                 getword htmp, htmp, #0      ' htmp = max
	byte	$b8, $71, $33, $f9
'-'                 signx   htmp1, #15      wc
	byte	$0f, $72, $77, $f7
'-'         if_c    alts    hidr_size, #511
	byte	$ff, $1f, $97, $c9
'-'         if_c    signx   retval, #0-0
	byte	$00, $be, $66, $c7
'-'                 subs    htmp, htmp1         ' htmp = (max - min)
	byte	$b9, $71, $c3, $f1
'-'                 subs    retval, htmp1       ' retval = (retval - min)
	byte	$b9, $bf, $c2, $f1
'-'                 shl     retval, #16         ' retval = (retval - min) << 16
	byte	$10, $be, $66, $f0
'-'                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
	byte	$01, $be, $c6, $f1
'-'                 abs     htmp            wc
	byte	$b8, $71, $53, $f6
'-'                 testb   retval, #31     wz
	byte	$1f, $be, $0e, $f4
'-'                 abs     retval
	byte	$5f, $bf, $42, $f6
'-'                 qdiv    retval, htmp
	byte	$b8, $bf, $12, $fd
'-'                 getqx   retval
	byte	$18, $be, $62, $fd
'-'     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
	byte	$5f, $bf, $62, $66
'-'                 adds    retval, ##$8000 signx 15
	byte	$c0, $ff, $7f, $ff, $00, $be, $46, $f1
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform controller actions
'-' ' On entry:
'-' '    hidr_id        report id
'-' '    hidr_axis      axis value (signed word, 2 axes per long)
'-' '                      X = hidr_axis+0, #0
'-' '                      Y = hidr_axis+0, #1
'-' '                      Z = hidr_axis+1, #0
'-' '                     RX = hidr_axis+1, #1
'-' '                     RY = hidr_axis+2, #0
'-' '                     RZ = hidr_axis+2, #1
'-' '    hidr_buttons   buttons state (bits 0 to 31)
'-' '    hidr_hats      hats state (byte 0, 1, 2, 3)
'-' '
'-' '                     -------3 -------2 -------1 -------0 byte
'-' '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
'-' '    hidr_flags       xxxxxxxx_xxrrrzyx_hhhhaaaa_bbbbbbbb
'-' '                                zyx||| |||||||| ++++++++ n. buttons
'-' '                                |||||| ||||++++--------- n. axes
'-' '                                |||||| ++++------------- n. hats
'-' '                                ++++++------------------ valid axes
'-' '------------------------------------------------------------------------------
'-' hpad_translate
'-' 
'-' 
'-'         if HAVE_HIDPAD
'-'                 loc     ptrb,#hidpad_report
	byte	$84, $0c, $f0, $fe
'-'                 mov     htmp,hdev_port          wz
	byte	$2d, $71, $0b, $f6
'-'         if_z    mov     htmp,hidr_id
	byte	$8d, $71, $03, $a6
'-'                 cmpsub  htmp,#1
	byte	$01, $70, $e7, $f2
'-'         if_z    cmp     hidr_id, #MAX_DEVICES   wc
	byte	$07, $1a, $17, $a2
'-'         if_nz   cmp     hidr_id, #2             wc
	byte	$02, $1a, $17, $52
'-'         if_ae   ret     wcz
	byte	$2d, $00, $7c, $3d
'-'                 mul     htmp, #HIDPAD_REPORT_SIZE
	byte	$1c, $70, $07, $fa
'-'                 add     ptrb,htmp
	byte	$b8, $f3, $03, $f1
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
	byte	$00, $0c, $03, $f6
'-'                 setq    #7-1
	byte	$28, $0c, $64, $fd
'-'                 wrlong  hidr_usage,ptrb
	byte	$80, $0d, $67, $fc
'-'         end
'-' 
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' .emupad_no_hat
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' .emupad_slot_over
'-'         end
'-' 
'-'         if 0
'-'                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
'-' 
'-'                 debug("    btn: ", ubin_long_(hidr_buttons))
'-' 
'-'         end
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' '------------------------------------------------------------------------------
'-' ' Clear EmuPad state
'-' '------------------------------------------------------------------------------
'-' emupad_reset
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get EmuPad Player number for current device (into retval)
'-' ' Z flag is also set if current device is valid
'-' ' (Value may be larger than EMUPAD_MAX_PLAYER !)
'-' '------------------------------------------------------------------------------
'-' emupad_getnum
'-' .loop
'-' '------------------------------------------------------------------------------
'-' ' Handle disconnect of device (call after emupad_getnum returns with Z set)
'-' '------------------------------------------------------------------------------
'-' emupad_discon
'-' .loop         
'-'         
'-'         ' FALL THROUGH!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Update EmuPad reports (all of them...)
'-' '------------------------------------------------------------------------------
'-' emupad_write_reports
'-' .devloop
'-' 
'-' end
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_hub_status
'-'                 mov     ep_addr_pid, hhub_ep_addr
	byte	$77, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 setword hpar3, hub_next_datax, #0
	byte	$32, $91, $23, $f9
'-'                 setword hpar3, #1, #1
	byte	$01, $90, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.data
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
	byte	$1a, $01, $80, $5d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .data
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 cmp     hub_next_datax, #PID_DATA0  wz
	byte	$c3, $64, $0e, $f2
'-'         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
	byte	$4b, $64, $06, $a6
'-'         if_nz   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $56
'-'                 rdlong  hub_status_chg, urx_buff_p
	byte	$27, $67, $02, $fb
'-'                 debug(ubin_long(hub_status_chg))
'-' 
'-'                 mov     hdev_port, #1
	byte	$01, $5a, $06, $f6
'-' .loop
'-'                 testb   hub_status_chg, hdev_port wz
	byte	$2d, $67, $0a, $f4
'-'         if_x1   call    #hub_port_handler
	byte	$0c, $00, $b0, $ad
'-'                 incmod  hdev_port, #7           wcz
	byte	$07, $5a, $1e, $f7
'-'         if_nc   jmp     #.loop
	byte	$f0, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' hub_port_handler
'-'                 mov     ep_addr_pid, hhub_ctrl_ep
	byte	$76, $bd, $02, $f6
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$8c, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-' 
'-'                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
	byte	$10, $68, $0e, $f4
'-'         if_x0   jmp     #.other
	byte	$50, $01, $90, $5d
'-'                 loc     ptra, #clr_port_feat
	byte	$68, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
	byte	$01, $21, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
	byte	$00, $68, $0e, $f4
'-'         if_x0   jmp     #.disconnect
	byte	$7c, $01, $90, $5d
'-'                 mov     hctwait, _100ms_
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 loc     ptra, #set_port_feat            ' reset port
	byte	$40, $02, $d0, $fe
'-'                 wrword  #HUB_PORT_RESET, ptra[wValue]
	byte	$01, $09, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp3, #2
	byte	$02, $76, $07, $f6
'-' .wait_reset
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$34, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
	byte	$14, $68, $0e, $f4
'-'         if_x0   djnz    htmp3, #.wait_reset
	byte	$f7, $77, $6f, $5b
'-' 
'-'                 loc     ptra, #clr_port_feat
	byte	$10, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
	byte	$24, $70, $07, $f6
'-' .wait_recover
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 djnz    htmp,#.wait_recover
	byte	$fd, $71, $6f, $fb
'-' 
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$8c, $01, $d0, $fe
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$48, $01, $90, $5d
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
	byte	$80, $01, $d0, $fe
'-'                 mov     htmp, hdev_port             ' Address is hub port number
	byte	$2d, $71, $03, $f6
'-'                 wrword  htmp, ptra[wValue]
	byte	$01, $71, $57, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$24, $01, $90, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$ef, $02, $a0, $fd
'-'                 mov     ep_addr_pid, hdev_port
	byte	$2d, $bd, $02, $f6
'-'                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
	byte	$08, $bc, $66, $f0
'-'                 call    #calc_crc5
	byte	$be, $00, $a0, $fd
'-'                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
	byte	$3c, $01, $d0, $fe
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$f4, $00, $90, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
'-'                 mov     hctwait, _500us_
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$18, $01, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$cc, $00, $90, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $85, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $87, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $71, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $84, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $86, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $71, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #.done
	byte	$a4, $00, $90, $cd
'-'                 call    #hparse_con_desc
	byte	$6c, $f0, $bf, $fd
'-'                 jmp     #.done
	byte	$9c, $00, $90, $fd
'-' 
'-' .other
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz
	byte	$14, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$28, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
	byte	$11, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
	byte	$01, $23, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$1c, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
	byte	$12, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
	byte	$01, $25, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$10, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
	byte	$13, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
	byte	$01, $27, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$04, $00, $90, $ad
'-'                 jmp     #.done
	byte	$68, $00, $90, $fd
'-' .reset_feature
'-'                 loc     ptra, #clr_port_feat
	byte	$e4, $00, $d0, $fe
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 jmp     #.done
	byte	$58, $00, $90, $fd
'-' .disconnect
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $70, $e3, $f8
'-'                 cmp     htmp,#KB_READY wz
	byte	$03, $70, $0f, $f2
'-'         if_nz   cmp     htmp,#KBM_READY wz
	byte	$05, $70, $0f, $52
'-'         if_z    mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $a6
'-'         if_z    mov     hkbd_ctrl_ep, #0
	byte	$00, $f0, $06, $a6
'-'         if_z    mov     kb_led_states, #0
	byte	$00, $76, $06, $a6
'-'         if_z    mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $a6
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $70, $0f, $f2
'-'         if_nz   cmp     htmp, #KBM_READY        wz
	byte	$05, $70, $0f, $52
'-'         if_z    mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $a6
'-'         end
'-'         if HAVE_HIDPAD
'-'                 loc ptrb,#hidpad_report
	byte	$14, $0a, $f0, $fe
'-'                 mov htmp,hdev_port
	byte	$2d, $71, $03, $f6
'-'                 cmpsub htmp,#1
	byte	$01, $70, $e7, $f2
'-'                 mul htmp,#HIDPAD_REPORT_SIZE
	byte	$1c, $70, $07, $fa
'-'                 add ptrb,htmp
	byte	$b8, $f3, $03, $f1
'-'                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
	byte	$28, $0c, $64, $fd
'-'                 wrlong #0,ptrb
	byte	$80, $01, $6c, $fc
'-'         end
'-' 
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte #0
	byte	$00, $00, $c4, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' 
'-' .done
'-'                 bitl    _usb_h_ls_nco_, #14     wcz
	byte	$0e, $68, $1f, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6d, $13, $cc
'-'                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $f6
'-' 
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$6c, $00, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, ptra
	byte	$00, $69, $06, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Partially populated SETUP packets
'-' '------------------------------------------------------------------------------
'-' get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_DEVICE << 8
	byte	$00, $01
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_CONFIG << 8
	byte	$00, $02
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_CONFIG
	byte	$09
'-'                 word    0       ' Configuration value
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
	byte	$00, $00
'-' set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_ADDR
	byte	$05
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
'-' ' wValue field dictates which protocol should be used.
'-' '
'-' ' When initialized, all devices default to report protocol. However the host
'-' ' should not make any assumptions about the device state and should set the
'-' ' desired protocol whenever initializing a device.
'-' '------------------------------------------------------------------------------
'-' set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_PROTO
	byte	$0b
'-'                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
	byte	$00, $00
'-'                                                 ' (HID 1.11 Section 7.2.6).
'-'                 word    0               ' Interface index number.
	byte	$00, $00
'-'                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_IDLE
	byte	$0a
'-'                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
	byte	$00, $00
'-'                                         ' reporting until a change is detected in the report data
'-' 
'-'                                         ' (HID 1.11 Section 7.2.4).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
	byte	$00, $00
'-' set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_REPORT
	byte	$09
'-'                 word    0       ' Byte1 = report type, byte0 = ReportID.
	byte	$00, $00
'-'                                         ' (HID 1.11 Section 7.2.2).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Size of the report, in bytes.
	byte	$00, $00
'-' get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
	byte	$81
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_REPORT << 8
	byte	$00, $22
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
	byte	$a0
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_HUB << 8
	byte	$00, $29
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_SET_FEATURE
	byte	$03
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_CLEAR_FEATURE
	byte	$01
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
	byte	$a3
'-'                 byte    REQ_GET_STATUS
	byte	$00
'-'                 word    0
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    4       ' Number of bytes to transfer if there is a data stage
	byte	$04, $00
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' ps3_enable_cmd  byte    $42, $0C, $00, $00
	byte	$42, $0c, $00, $00
'-' ps3_command_buff
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
	byte	$00, $00, $00, $00, $02
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' '------------------------------------------------------------------------------
'-' xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
	byte	$01, $03, $06
'-'                                         ' 0x01 All blinking
'-'                                         ' 0x02 1 flashes, then on
'-'                                         ' 0x03 2 flashes, then on
'-'                                         ' 0x04 3 flashes, then on
'-'                                         ' 0x05 4 flashes, then on
'-'                                         ' 0x06 1 on
'-'                                         ' 0x07 2 on
'-'                                         ' 0x08 3 on
'-'                                         ' 0x09 4 on
'-'                                         ' 0x0A Rotating (e.g. 1-2-4-3)
'-'                                         ' 0x0B Blinking*
'-'                                         ' 0x0C Slow blinking*
'-'                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
'-' xinp_rumble_cmd byte    $00, $08, $00
	byte	$00, $08, $00
'-'                 byte    $00             ' Left rumble
	byte	$00
'-'                 byte    $00             ' Right rumble
	byte	$00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' end
	byte	$00
'-' alignl
'-' 
'-' if HAVE_MOUSE
'-' mouse_limits long 0[2]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' mouse_outptr long 0
	byte	$00, $00, $00, $00
'-' end
'-' 
'-' if KEYQUEUE_SIZE > 0
'-' keyq_head byte 0
	byte	$00
'-' keyq_tail byte 0
	byte	$00
'-' keyq_data long 0[KEYQUEUE_SIZE]
	byte	$00[514]
'-' alignl
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_rule_buffer
'-' if EMUPAD_BUILTIN_RULES
'-' file "padmap_builtin.dat"
'-' end
'-' byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
'-' '' Default rule directly follows!
'-' byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The USB data cache area gets zero-filled at every device disconnect
'-' '------------------------------------------------------------------------------
'-' usb_cache_start
'-' 
'-' ' HID descriptor and report buffers
'-' if !!OVERLAP_MEMORY
'-' hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
	byte	$00[1792]
'-' end
'-' hkbd_report     byte    0[8]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' hkbd_led_rep    byte    0
	byte	$00, $00, $00, $00
'-' alignl
'-' 
'-' if HAVE_HIDPAD
'-' hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
	byte	$00[196]
'-' end
'-' 
'-' ' HUB descriptor
'-' hub_descr       byte    0   ' bDescLength
	byte	$00
'-'                 byte    0   ' bDescriptorType
	byte	$00
'-'                 byte    0   ' bNbrPorts
	byte	$00
'-'                 word    0   ' wHubCharacteristics
	byte	$00, $00
'-'                 byte    0   ' bPwrOn2PwrGood
	byte	$00
'-'                 byte    0   ' bHubContrCurrent
	byte	$00
'-'                 byte    0   ' DeviceRemoveable
	byte	$00
'-'                 byte    0   ' PortPwrCtrlMask
	byte	$00
'-' 
'-' usb_cache_end
'-' 
'-' if HAVE_MOUSE
'-' mouse_xacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_yacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_zacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_bstate    byte 0
	byte	$00
'-' mouse_lpending  byte 0
	byte	$00
'-' mouse_rpending  byte 0
	byte	$00
'-' mouse_mpending  byte 0
	byte	$00
'-' mouse_lock      byte 0
	byte	$00
'-'                 byte 0[3] ' padding
	byte	$00, $00, $00
'-' end
'-' 
'-' urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
	byte	$00[128]
'-' dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
	byte	$00[18]
'-' con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
	byte	$00[256]
'-' 
'-' driver_cog      byte    0                       ' Current driver cog + 1
	byte	$00
	alignl
_Audio093b_8_sc_spin2_dat_
'-' 
'-' audio       org     0
'-' 
'-'             rdlong  mailbox2, ptra++     ' get start address of all mailboxes
	byte	$61, $c3, $05, $fb
'-'             rdlong  scbase, ptra++       ' get start address of scope buffer
	byte	$61, $11, $06, $fb
'-'             rdlong  hubptr, ptra++       ' get start address of PSRAM cache
	byte	$61, $1d, $06, $fb
'-' 
'-'             cogid   pa                   ' compute cogid
	byte	$01, $ec, $63, $fd
'-'             mul     pa, #12              ' and mailbox spacing
	byte	$0c, $ec, $07, $fa
'-'             add     mailbox2, pa         ' add offset to find this COG's mailbox
	byte	$f6, $c3, $01, $f1
'-'             mov     mailbox,mailbox2     ' we need 2 copies of this to ensble switching between hub and psram
	byte	$e1, $c0, $01, $f6
'-' 
'-'             mov     ptrb,#0              ' A tail pointer for the buffer
	byte	$00, $f2, $07, $f6
'-'             wrpin   dac,#left            ' Noise dither DACs at clk/95
	byte	$0e, $18, $06, $fc
'-'             wxpin   #95,#left       	 ' Set initial DACs sample rate. It is now controlled via a register by the main program
	byte	$0e, $be, $1c, $fc
'-'             wrpin   dac,#right
	byte	$0f, $18, $06, $fc
'-'             wxpin   #95,#right    
	byte	$0f, $be, $1c, $fc
'-'             dirh    #left addpins 1
	byte	$41, $9c, $64, $fd
'-'             setse1  #%001<<6 + left      ' Set the event - DAC empty
	byte	$20, $9c, $64, $fd
'-'             mov     ijmp1,#isr1          ' Init the interrupt
	byte	$c8, $e8, $07, $f6
'-'             setint1 #4                   ' Interrupt from DAC empty event
	byte	$25, $08, $64, $fd
'-'             
'-' '---------------------------------------------------------------------------------        
'-' '----------------- The main loop -------------------------------------------------
'-' '---------------------------------------------------------------------------------
'-' 
'-' loop        cmp     time0,a41000000 wc  ' time counter overflow protection
	byte	$d1, $a4, $11, $f2
'-'       if_c  jmp     #loop1
	byte	$10, $00, $90, $cd
'-'   
'-'             mov     cn,#9               ' Substract $40000000 from all the channel times and the main timer
	byte	$09, $f6, $05, $f6
'-' p402        altd    cn,#a41000000       ' this has to be done at once for all channels
	byte	$d1, $f6, $8d, $f9
'-'             sub     0-0,a40000000
	byte	$d0, $00, $80, $f1
'-'             djnz    cn,#p402
	byte	$fd, $f7, $6d, $fb
'-'     
'-' loop1       mov     cn,#0               ' Find the channel to compute
	byte	$00, $f6, $05, $f6
'-'             mov     ct,time1            ' with the lowest next sample time
	byte	$d3, $f8, $01, $f6
'-'             fle     ct,time2 wcz        ' How to size-optimize this???
	byte	$d4, $f8, $39, $f3
'-'     if_c    mov     cn,#1
	byte	$01, $f6, $05, $c6
'-'             fle     ct,time3 wcz
	byte	$d5, $f8, $39, $f3
'-'     if_c    mov     cn,#2     
	byte	$02, $f6, $05, $c6
'-'             fle     ct,time4 wcz
	byte	$d6, $f8, $39, $f3
'-'     if_c    mov     cn,#3
	byte	$03, $f6, $05, $c6
'-'             fle     ct,time5 wcz
	byte	$d7, $f8, $39, $f3
'-'     if_c    mov     cn,#4
	byte	$04, $f6, $05, $c6
'-'             fle     ct,time6 wcz
	byte	$d8, $f8, $39, $f3
'-'     if_c    mov     cn,#5
	byte	$05, $f6, $05, $c6
'-'             fle     ct,time7 wcz
	byte	$d9, $f8, $39, $f3
'-'     if_c    mov     cn,#6
	byte	$06, $f6, $05, $c6
'-'             fle     ct,time8 wcz
	byte	$da, $f8, $39, $f3
'-'     if_c    mov     cn,#7
	byte	$07, $f6, $05, $c6
'-' 
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- Compute channel samples --------------------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' 
'-' p401        mov     channeladd,cn             ' compute the pointer to channel parameters block
	byte	$fb, $b6, $01, $f6
'-'             shl     channeladd,#6
	byte	$06, $b6, $65, $f0
'-'             add     ptra,channeladd
	byte	$db, $f0, $03, $f1
'-' 
'-'             setq    #11                        ' read parameters
	byte	$28, $16, $64, $fd
'-'             rdlong  pointer0,ptra
	byte	$00, $cd, $05, $fb
'-'     	    
'-' p408        testb   command0,#31 wz	      ' bit #31 command - set the DAC sample rate
	byte	$1f, $da, $0d, $f4
'-'     if_nz   jmp     #p404                     ' if not set, proceed
	byte	$18, $00, $90, $5d
'-'             getword qq,command0,#0            ' get the new rate
	byte	$ed, $ba, $31, $f9
'-'             wxpin   qq,#left addpins 1        ' and program the pins
	byte	$4e, $ba, $15, $fc
'-'             getbyte qq,qq,#0 		      ' check if the rate is n*256
	byte	$dd, $ba, $e1, $f8
'-'             cmp     qq,#0 wz                         
	byte	$00, $ba, $0d, $f2
'-'     if_z    wrpin   dac2,#left addpins 1      ' if yes, set PWM DAC mode
	byte	$4e, $1a, $06, $ac
'-'     if_nz   wrpin   dac,#left addpins 1       ' else set noise DAC mode
	byte	$4e, $18, $06, $5c
'-'             
'-' p404        bitl    command0,#30 wcz             ' bit #30: select PSRAM/HUB
	byte	$1e, $da, $1d, $f4
'-'     if_nz   mov     mailbox,mailbox2             ' if not set, use PSRAM
	byte	$e1, $c0, $01, $56
'-'     if_z    mov     mailbox,#0                   ' if set, use HUB : TODO: this can be done at a channel level!
	byte	$00, $c0, $05, $a6
'-' 
'-' 
'-' p405        getword oldls,sample0,#0          ' extract old sample value
	byte	$e7, $fc, $31, $f9
'-'             getword oldrs,sample0,#1
	byte	$e7, $fe, $39, $f9
'-'      	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
	byte	$eb, $f2, $39, $f9
'-'     	    getword avol0,volpan0,#0
	byte	$eb, $f0, $31, $f9
'-'             getword askip0,freqskip0,#1    	    
	byte	$ec, $ee, $39, $f9
'-'             getword afreq0,freqskip0,#0
	byte	$ec, $ec, $31, $f9
'-' 
'-'             alts    cn, #time1                ' compute the time difference between this and previous sample
	byte	$d3, $f6, $95, $f9
'-'             mov     dt0,0-0    
	byte	$00, $fa, $01, $f6
'-'             sub     dt0,time0
	byte	$d2, $fa, $81, $f1
'-'             
'-'             altd    cn, #time1                ' add channel period to channel time
	byte	$d3, $f6, $8d, $f9
'-'             add     0-0,afreq0  	
	byte	$f6, $00, $00, $f1
'-'             
'-' '---- envelopes
'-'             
'-'             cmp     envptr0,#0 wcz    		' read the pointer
	byte	$00, $de, $1d, $f2
'-'     if_z    mov     envs1,##$4000		' if 0, no envelope, load $4000=1 for scas
	byte	$20, $00, $00, $af, $00, $3e, $06, $a6
'-'     if_z    jmp     #p410			' and run away	
	byte	$5c, $00, $90, $ad
'-' 
'-'             mov envs1,afreq0
	byte	$f6, $3e, $02, $f6
'-'             mul envs1,envspd0
	byte	$f0, $3e, $02, $fa
'-'             add envph0,envs1 
	byte	$1f, $dd, $01, $f1
'-' 
'-'       	    mov     envhi, envph0		' move phase acc to high part of env pointer
	byte	$ee, $3a, $02, $f6
'-' 	    shr     envhi,#6			' leave 10 bits in hi
	byte	$06, $3a, $46, $f0
'-' 	    getword envlo,envhi,#0              ' and 16 bit in lo
	byte	$1d, $3d, $32, $f9
'-' 	    shr     envhi,#16			' move 10 bits of hi to the lower word
	byte	$10, $3a, $46, $f0
'-' 	    cmp     envhi,envlen0 wcz		' compare this to envelope length
	byte	$f1, $3a, $1a, $f2
'-'     if_ge   mov     envhi,envlen0		' if greater than, set it at envlen
	byte	$f1, $3a, $02, $36
'-'     if_ge   mov     envlo,#0
	byte	$00, $3c, $06, $36
'-'     if_ge   mov     envph0,envlen0
	byte	$f1, $dc, $01, $36
'-'     if_ge   shl     envph0,#22
	byte	$16, $dc, $65, $30
'-' 
'-'             mov envs1,envhi
	byte	$1d, $3f, $02, $f6
'-'             shl envs1,#1
	byte	$01, $3e, $66, $f0
'-'             add envs1,envptr0
	byte	$ef, $3e, $02, $f1
'-'             rdlong envs1,envs1
	byte	$1f, $3f, $02, $fb
'-'             getword envs2,envs1,#1
	byte	$1f, $41, $3a, $f9
'-'             getword envs1,envs1,#0
	byte	$1f, $3f, $32, $f9
'-'             mul envs2,envlo
	byte	$1e, $41, $02, $fa
'-'             not envlo
	byte	$1e, $3d, $22, $f6
'-'             mul envs1,envlo
	byte	$1e, $3f, $02, $fa
'-'             add envs1,envs2
	byte	$20, $3f, $02, $f1
'-'             shr envs1,#18
	byte	$12, $3e, $46, $f0
'-'             
'-' 
'-' 
'-' p410              add     pointer0,askip0           ' compute the pointer to the next sample       
	byte	$f7, $cc, $01, $f1
'-'          setbyte pointer00,pointer0,#0
	byte	$e6, $38, $c2, $f8
'-'             shr     pointer0,#8
	byte	$08, $cc, $45, $f0
'-'          
'-'             testb   sstart0,#31 wz            
	byte	$1f, $d0, $0d, $f4
'-'     if_z    shl     pointer0,#1        
	byte	$01, $cc, $65, $a0
'-'             testb   sstart0,#28 wz            
	byte	$1c, $d0, $0d, $f4
'-'     if_z    shl     pointer0,#1        
	byte	$01, $cc, $65, $a0
'-'             
'-'             cmp     pointer0,lend0 wcz
	byte	$ea, $cc, $19, $f2
'-'     if_ge   sub     pointer0,lend0	      ' and loop if needed     
	byte	$ea, $cc, $81, $31
'-'     if_ge   add     pointer0,lstart0       
	byte	$e9, $cc, $01, $31
'-'             
'-'             mov     qq,pointer0               ' compute place in the memory from where the sample will be loaded
	byte	$e6, $ba, $01, $f6
'-'             add     qq,sstart0            
	byte	$e8, $ba, $01, $f1
'-' 
'-' 
'-' 
'-'             cmps    mailbox,#$1FF wcz            ' the mailbox has to point somewhere not at the start of HUB RAM
	byte	$ff, $c1, $5d, $f2
'-'     if_le   rdword  spl,qq                     ' if not, use HUB RAM for samples
	byte	$dd, $bc, $e1, $ea
'-'     if_gt   call    #cache_read
	byte	$14, $01, $b0, $1d
'-'          
'-'          
'-'  
'-'          
'-'             testb   sstart0,#31 wz 
	byte	$1f, $d0, $0d, $f4
'-'     if_nz   shl     spl,#8
	byte	$08, $bc, $65, $50
'-'     if_nz   shl     pointer0,#8
	byte	$08, $cc, $65, $50
'-'     if_z    shl     pointer0,#7
	byte	$07, $cc, $65, $a0
'-'             testb   sstart0,#28 wz            
	byte	$1c, $d0, $0d, $f4
'-'     if_z    shr     pointer0,#1    
	byte	$01, $cc, $45, $a0
'-' 	    setbyte pointer0,pointer00,#0       
	byte	$1c, $cd, $c1, $f8
'-'     
'-' 
'-' p406        
'-'            scas spl, envs1
	byte	$1f, $bd, $31, $fa
'-'             mov spl,0-0
	byte	$00, $bc, $01, $f6
'-'             scas    spl,avol0                 ' apply volume
	byte	$f8, $bc, $31, $fa
'-'             mov     spl,0-0
	byte	$00, $bc, $01, $f6
'-'  
'-'             scas    spl,apan0                 ' apply pan
	byte	$f9, $bc, $31, $fa
'-'             mov     ls0,0-0
	byte	$00, $00, $02, $f6
'-'             mov     qq,##16384
	byte	$20, $00, $00, $ff, $00, $ba, $05, $f6
'-'             sub     qq,apan0
	byte	$f9, $ba, $81, $f1
'-'             scas    spl,qq
	byte	$dd, $bc, $31, $fa
'-'             mov     rs0, 0-0
	byte	$00, $02, $02, $f6
'-' 
'-'             sub     rs,oldrs 		      ' replace the old sample with the new one in the mix
	byte	$ff, $06, $82, $f1
'-'             add     rs,rs0
	byte	$01, $07, $02, $f1
'-'             sub     ls,oldls
	byte	$fe, $04, $82, $f1
'-'             add     ls,ls0
	byte	$00, $05, $02, $f1
'-'    
'-'             setword sample0,rs0,#1           ' pack samples into long
	byte	$01, $cf, $29, $f9
'-'             setword sample0,ls0,#0
	byte	$00, $cf, $21, $f9
'-'             
'-'             bitl    sstart0, #30 wcz          ' if bit #30 of start pointer is set, the current pointers needs resetting  
	byte	$1e, $d0, $1d, $f4
'-'     if_z    mov     pointer0, #0  
	byte	$00, $cc, $05, $a6
'-'     if_z    mov     envph0, #0  
	byte	$00, $dc, $05, $a6
'-'     if_z    wrlong  sstart0, ptra[2]          ' reset bit #30 in hub
	byte	$02, $d1, $65, $ac
'-'             bitl    sstart0, #29 wcz	      ' if bit #29 is set, synchronize stereo at channels 1 and 2
	byte	$1d, $d0, $1d, $f4
'-'     if_z    add     time1,##2048
	byte	$04, $00, $00, $af, $00, $a6, $05, $a1
'-'     if_z    mov     time2,time1
	byte	$d3, $a8, $01, $a6
'-'     if_z    wrlong  sstart0,ptra[2]
	byte	$02, $d1, $65, $ac
'-'             
'-' p403        setq #1                          ' write new pointer and sample value to the hub
	byte	$28, $02, $64, $fd
'-'             wrlong  pointer0,ptra
	byte	$00, $cd, $65, $fc
'-'             wrlong  envph0,ptra[8]
	byte	$08, $dd, $65, $fc
'-'             sub     ptra, channeladd         ' reset the pointer to channel parameters
	byte	$db, $f0, $83, $f1
'-'                       
'-'             cmp     oldt0,time0 wz           ' If more than 1 sample is computed at the same time, write only the last result
	byte	$d2, $f4, $09, $f2
'-'     if_z    decmod  front, #511          
	byte	$ff, $b9, $25, $a7
'-'          
'-'             getword oldls,ls,#0              ' reuse oldls variable to convert the sample to unsigned
	byte	$02, $fd, $31, $f9
'-'  	    getword oldrs,rs,#0              ' getword instead of mov makes the upper bits=0
	byte	$03, $ff, $31, $f9
'-'             bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
	byte	$0f, $fc, $e5, $f4
'-'             bitnot  oldrs,#15		     ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
	byte	$0f, $fe, $e5, $f4
'-' 	    
'-' 		    
'-'             setword oldrs,oldls,#1           ' Pack L and R to one long    		
	byte	$fe, $fe, $29, $f9
'-'             mov     oldsample, newsample     ' The new computed sample will be outputted in the next loop, now we have to fill the buffer with the old one
	byte	$05, $09, $02, $f6
'-'             mov     newsample, oldrs       
	byte	$ff, $0a, $02, $f6
'-' 
'-'             mov     oldt0,time0              ' update global time
	byte	$d2, $f4, $01, $f6
'-'             add     time0,dt0    
	byte	$fd, $a4, $01, $f1
'-'                                      
'-'             cmp     dt0,#0 wz                ' now push dt0 samples to the buffer
	byte	$00, $fa, $0d, $f2
'-'     if_z    jmp     #loop1
	byte	$e4, $fd, $9f, $ad
'-'             mov     qq,dt0
	byte	$fd, $ba, $01, $f6
'-'   
'-' p301        alts    ptrb,#511                ' checking if the buffer is full - Wuerfel_21's magic stuff
	byte	$ff, $f3, $97, $f9
'-'             cmpr    front, #0-0 wcz
	byte	$00, $b8, $9d, $f2
'-'     if_e    jmp     #p301    
	byte	$f4, $ff, $9f, $ad
'-' 		
'-' 	    cmp     scbase,#0 wz
	byte	$00, $10, $0e, $f2
'-'     if_z    jmp #p302	   
	byte	$20, $00, $90, $ad
'-'  
'-'  
'-'             incmod  scope,#63 wc            ' save every 127th sample to the scope buffer
	byte	$3f, $16, $16, $f7
'-'     if_c    mov scptr2,scptr
	byte	$09, $15, $02, $c6
'-'     if_c    shl scptr2,#2
	byte	$02, $14, $66, $c0
'-'     if_c    add scptr2,scbase     
	byte	$08, $15, $02, $c1
'-'             wrlong scptr2,#$60
	byte	$60, $14, $66, $fc
'-'     if_c    wrlong oldsample,scptr2
	byte	$0a, $09, $62, $cc
'-'     if_c    incmod scptr,##639
	byte	$01, $00, $00, $cf, $7f, $12, $06, $c7
'-' 			    
'-' p302        wrlut   oldsample, front        ' if there is a free slot, put the sample into the buffer
	byte	$dc, $08, $32, $fc
'-'             incmod  front, ##511
	byte	$00, $00, $00, $ff, $ff, $b9, $05, $f7
'-'             djnz    qq,#p301
	byte	$ef, $bb, $6d, $fb
'-'             
'-'             jmp     #loop            'loop
	byte	$80, $fd, $9f, $fd
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- This is the end of the main loop -----------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- PSRAM cache ----------- --------------------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' ' There are 8 cache pointers for 8 channels
'-' ' if 24 higher bits of address=cache, then get a word from the cache
'-' ' else load the cache from PSRAM, update the pointer, then read a sample
'-' 
'-' 
'-' cache_read  getbyte addrlo,qq,#0 		' when this is called, qq is the addres of the sample			
	byte	$dd, $34, $e2, $f8
'-'             
'-' 	    mov     addrhi,qq		
	byte	$dd, $36, $02, $f6
'-' 	    shr     addrhi,#8		        ' get 24 upper bits
	byte	$08, $36, $46, $f0
'-' 	    alts    cn,#cache1            
	byte	$0f, $f7, $95, $f9
'-' 	    cmp	    addrhi,0-0 wz               ' and compare with the cache pointer for the channel
	byte	$00, $36, $0a, $f2
'-'     if_z    jmp     #p701	    		' if equal, cache hit, read the sample from it
	byte	$34, $00, $90, $ad
'-' 	
'-' p702	    altd    cn,#cache1			' cache miss. 
	byte	$0f, $f7, $8d, $f9
'-' 	    mov     0-0,addrhi                  ' update the pointer
	byte	$1b, $01, $00, $f6
'-' 	    mov     cmd,addrhi			' prepare the mailbox
	byte	$1b, $2f, $02, $f6
'-' 	    shl     cmd,#8
	byte	$08, $2e, $66, $f0
'-'             setnib  cmd, #%1011, #7             ' read burst from the external memory
	byte	$0b, $2e, $3e, $f8
'-'             mov     hubaddr,cn                  ' to the channel cache
	byte	$fb, $30, $02, $f6
'-'             shl     hubaddr,#8                  '
	byte	$08, $30, $66, $f0
'-'             add     hubaddr,hubptr 
	byte	$0e, $31, $02, $f1
'-'             mov     count,#256                  ' 256 bytes
	byte	$00, $33, $06, $f6
'-'             setq    #2                          ' write 3 longs
	byte	$28, $04, $64, $fd
'-'             wrlong  cmd, mailbox                ' run it
	byte	$e0, $2e, $62, $fc
'-' poll1       rdlong  cmd, mailbox                ' poll mailbox for result
	byte	$e0, $2e, $02, $fb
'-'             tjs     cmd, #poll1                 ' retry until valid 
	byte	$fe, $2f, $b6, $fb
'-'             
'-' 	
'-' p701	    mov     qq,cn			' cache hit
	byte	$fb, $ba, $01, $f6
'-' 	    shl     qq,#8			' compute the cache start
	byte	$08, $ba, $65, $f0
'-' 	    add     qq,hubptr
	byte	$0e, $bb, $01, $f1
'-' 	    add	    qq,addrlo			' add 8 lower bits to the cache addredd
	byte	$1a, $bb, $01, $f1
'-'     _ret_   rdword  spl,qq                      ' read a word
	byte	$dd, $bc, $e1, $0a
'-'           
'-' 
'-' '--------------------------------------------------------------------------
'-' '------ Interrupt service -------------------------------------------------
'-' '------ Output the sample, get the next one if exists ---------------------
'-' '--------------------------------------------------------------------------
'-' 
'-' isr1        wypin   lsample,#left        '2     The sample has to be outputted every 100 cycles     
	byte	$0e, $c4, $25, $fc
'-'             wypin   rsample,#right       '4
	byte	$0f, $c6, $25, $fc
'-'             cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
	byte	$dc, $f2, $1b, $f2
'-'     if_ne   rdlut   lsnext,ptrb          '11    else read the sample and its time from LUT
	byte	$80, $c9, $a5, $5a
'-'     if_ne   incmod  ptrb,#511
	byte	$ff, $f3, $07, $57
'-'     if_ne   getword rsample,lsnext,#1    '13
	byte	$e4, $c6, $39, $59
'-'     if_ne   getword lsample,lsnext,#0    '15
	byte	$e4, $c4, $31, $59
'-'     
'-'             reti1                        '17/19 
	byte	$f5, $ff, $3b, $fb
'-'           
'-' '---------------------------------------------------------------------------
'-' '-------- End of interrupt -------------------------------------------------
'-' '---------------------------------------------------------------------------    
'-' 
'-' 
'-' '---------------------------------------------------------------------------
'-' '------- Variables ---------------------------------------------------------
'-' '---------------------------------------------------------------------------
'-' 
'-' ' constants
'-' 
'-' a40000000   long $40000000
	byte	$00, $00, $00, $40
'-' a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before
	byte	$00, $00, $00, $41
'-' 
'-' ' Time variables
'-' 
'-' time0       long 0    ' Global sample computing time
	byte	$00, $00, $00, $00
'-' time1       long 1    ' Local channels time
	byte	$01, $00, $00, $00
'-' time2       long 2
	byte	$02, $00, $00, $00
'-' time3       long 3
	byte	$03, $00, $00, $00
'-' time4       long 4
	byte	$04, $00, $00, $00
'-' time5       long 5
	byte	$05, $00, $00, $00
'-' time6       long 6
	byte	$06, $00, $00, $00
'-' time7       long 7
	byte	$07, $00, $00, $00
'-' time8       long 8
	byte	$08, $00, $00, $00
'-' 
'-' channeladd long 0
	byte	$00, $00, $00, $00
'-' 
'-' front       long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' temporary variables 
'-' qq          long 0
	byte	$00, $00, $00, $00
'-' spl         long 0
	byte	$00, $00, $00, $00
'-' zero        long 0
	byte	$00, $00, $00, $00
'-' mailbox     long 0
	byte	$00, $00, $00, $00
'-' mailbox2 long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' Interrupt ISR variables
'-' 
'-' lsample     long 0
	byte	$00, $00, $00, $00
'-' rsample     long 0
	byte	$00, $00, $00, $00
'-' lsnext      long 0
	byte	$00, $00, $00, $00
'-' rsnext      long 0 
	byte	$00, $00, $00, $00
'-' 
'-' ' channel parameter block
'-' 
'-' pointer0    long 0     
	byte	$00, $00, $00, $00
'-' sample0     long 0
	byte	$00, $00, $00, $00
'-' sstart0     long 0     ' start pointer and type at bit 31
	byte	$00, $00, $00, $00
'-' lstart0     long 0
	byte	$00, $00, $00, $00
'-' lend0       long 0
	byte	$00, $00, $00, $00
'-' volpan0     long 0
	byte	$00, $00, $00, $00
'-' freqskip0   long 0
	byte	$00, $00, $00, $00
'-' command0    long 0
	byte	$00, $00, $00, $00
'-' envph0	    long 0
	byte	$00, $00, $00, $00
'-' envptr0	    long 0
	byte	$00, $00, $00, $00
'-' envspd0	    long 0
	byte	$00, $00, $00, $00
'-' envlen0	    long 0
	byte	$00, $00, $00, $00
'-' res5	    long 0
	byte	$00, $00, $00, $00
'-' res6	    long 0
	byte	$00, $00, $00, $00
'-' res7	    long 0
	byte	$00, $00, $00, $00
'-' res8	    long 0
	byte	$00, $00, $00, $00
'-' 
'-' afreq0      long 0
	byte	$00, $00, $00, $00
'-' askip0      long 0
	byte	$00, $00, $00, $00
'-' avol0       long 0
	byte	$00, $00, $00, $00
'-' apan0       long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldt0       long $FFFFFFFF    'Temporary time variables
	byte	$ff, $ff, $ff, $ff
'-' cn          long 0
	byte	$00, $00, $00, $00
'-' ct          long 0
	byte	$00, $00, $00, $00
'-' dt0         long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' Samples
'-' oldls       long 0
	byte	$00, $00, $00, $00
'-' oldrs       long 0
	byte	$00, $00, $00, $00
'-' 
'-' ls0         long 0
	byte	$00, $00, $00, $00
'-' rs0         long 0
	byte	$00, $00, $00, $00
'-' 
'-' ls          long 0    
	byte	$00, $00, $00, $00
'-' rs          long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldsample   long 0
	byte	$00, $00, $00, $00
'-' newsample   long 0
	byte	$00, $00, $00, $00
'-' 
'-' nrsample    long 0
	byte	$00, $00, $00, $00
'-' nlsample    long 0
	byte	$00, $00, $00, $00
'-' 
'-' scbase long 0
	byte	$00, $00, $00, $00
'-' scptr long 0
	byte	$00, $00, $00, $00
'-' scptr2 long 0
	byte	$00, $00, $00, $00
'-' scope long 0
	byte	$00, $00, $00, $00
'-' 
'-' dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
	byte	$44, $00, $17, $00
'-' dac2        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   
	byte	$46, $00, $17, $00
'-' 
'-' hubptr      long $71800
	byte	$00, $18, $07, $00
'-' cache1      long 0
	byte	$00, $00, $00, $00
'-' cache2      long 0
	byte	$00, $00, $00, $00
'-' cache3      long 0
	byte	$00, $00, $00, $00
'-' cache4      long 0
	byte	$00, $00, $00, $00
'-' cache5      long 0
	byte	$00, $00, $00, $00
'-' cache6      long 0
	byte	$00, $00, $00, $00
'-' cache7      long 0
	byte	$00, $00, $00, $00
'-' cache8      long 0
	byte	$00, $00, $00, $00
'-' 
'-' 
'-' cmd         long 0
	byte	$00, $00, $00, $00
'-' hubaddr     long 0
	byte	$00, $00, $00, $00
'-' count       long 256
	byte	$00, $01, $00, $00
'-' addrlo long 0
	byte	$00, $00, $00, $00
'-' addrhi long 0
	byte	$00, $00, $00, $00
'-' pointer00 long 0
	byte	$00, $00, $00, $00
'-' envhi long 0
	byte	$00, $00, $00, $00
'-' envlo long 0
	byte	$00, $00, $00, $00
'-' envs1 long 0
	byte	$00, $00, $00, $00
'-' envs2 long 0
	byte	$00, $00, $00, $00
'-' null  			long 	0,0           ' for channel reset
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	alignl
__system__dat_
	byte	$00[8]
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[660]
	long	(105 {__system____root_opendir})<<20
	long	(106 {__system____root_closedir})<<20
	long	(107 {__system____root_readdir})<<20
	long	(108 {__system____root_stat})<<20
	byte	$00[28]
	long	@@@__system__dat_ + 832
	long	@@@__system__dat_ + 835
	long	@@@__system__dat_ + 868
	long	@@@__system__dat_ + 893
	long	@@@__system__dat_ + 920
	long	@@@__system__dat_ + 946
	long	@@@__system__dat_ + 962
	long	@@@__system__dat_ + 980
	long	@@@__system__dat_ + 998
	long	@@@__system__dat_ + 1016
	long	@@@__system__dat_ + 1028
	long	@@@__system__dat_ + 1045
	long	@@@__system__dat_ + 1065
	long	@@@__system__dat_ + 1075
	long	@@@__system__dat_ + 1091
	long	@@@__system__dat_ + 1106
	long	@@@__system__dat_ + 1128
	long	@@@__system__dat_ + 1153
	long	@@@__system__dat_ + 1173
	long	@@@__system__dat_ + 1187
	long	@@@__system__dat_ + 1207
	long	@@@__system__dat_ + 1219
	long	@@@__system__dat_ + 1237
	long	@@@__system__dat_ + 1261
	long	@@@__system__dat_ + 1279
	long	@@@__system__dat_ + 1298
	byte	$4f, $4b, $00, $4e, $75, $6d, $65, $72, $69, $63, $61, $6c, $20, $61, $72, $67
	byte	$75, $6d, $65, $6e, $74, $20, $6f, $75, $74, $20, $6f, $66, $20, $64, $6f, $6d
	byte	$61, $69, $6e, $00, $52, $65, $73, $75, $6c, $74, $20, $6e, $6f, $74, $20, $72
	byte	$65, $70, $72, $65, $73, $65, $6e, $74, $61, $62, $6c, $65, $00, $49, $6c, $6c
	byte	$65, $67, $61, $6c, $20, $6d, $75, $6c, $74, $69, $62, $79, $74, $65, $20, $73
	byte	$65, $71, $75, $65, $6e, $63, $65, $00, $4e, $6f, $20, $73, $75, $63, $68, $20
	byte	$66, $69, $6c, $65, $20, $6f, $72, $20, $64, $69, $72, $65, $63, $74, $6f, $72
	byte	$79, $00, $42, $61, $64, $20, $66, $69, $6c, $65, $20, $6e, $75, $6d, $62, $65
	byte	$72, $00, $50, $65, $72, $6d, $69, $73, $73, $69, $6f, $6e, $20, $64, $65, $6e
	byte	$69, $65, $64, $00, $4e, $6f, $74, $20, $65, $6e, $6f, $75, $67, $68, $20, $6d
	byte	$65, $6d, $6f, $72, $79, $00, $54, $65, $6d, $70, $6f, $72, $61, $72, $79, $20
	byte	$66, $61, $69, $6c, $75, $72, $65, $00, $46, $69, $6c, $65, $20, $65, $78, $69
	byte	$73, $74, $73, $00, $49, $6e, $76, $61, $6c, $69, $64, $20, $61, $72, $67, $75
	byte	$6d, $65, $6e, $74, $00, $54, $6f, $6f, $20, $6d, $61, $6e, $79, $20, $6f, $70
	byte	$65, $6e, $20, $66, $69, $6c, $65, $73, $00, $49, $2f, $4f, $20, $65, $72, $72
	byte	$6f, $72, $00, $4e, $6f, $74, $20, $61, $20, $64, $69, $72, $65, $63, $74, $6f
	byte	$72, $79, $00, $49, $73, $20, $61, $20, $64, $69, $72, $65, $63, $74, $6f, $72
	byte	$79, $00, $52, $65, $61, $64, $20, $6f, $6e, $6c, $79, $20, $66, $69, $6c, $65
	byte	$20, $73, $79, $73, $74, $65, $6d, $00, $46, $75, $6e, $63, $74, $69, $6f, $6e
	byte	$20, $6e, $6f, $74, $20, $69, $6d, $70, $6c, $65, $6d, $65, $6e, $74, $65, $64
	byte	$00, $44, $69, $72, $65, $63, $74, $6f, $72, $79, $20, $6e, $6f, $74, $20, $65
	byte	$6d, $70, $74, $79, $00, $4e, $61, $6d, $65, $20, $74, $6f, $6f, $20, $6c, $6f
	byte	$6e, $67, $00, $44, $65, $76, $69, $63, $65, $20, $6e, $6f, $74, $20, $73, $65
	byte	$65, $6b, $61, $62, $6c, $65, $00, $42, $61, $64, $20, $61, $64, $64, $72, $65
	byte	$73, $73, $00, $42, $72, $6f, $6b, $65, $6e, $20, $63, $6f, $6e, $6e, $65, $63
	byte	$74, $69, $6f, $6e, $00, $44, $65, $76, $69, $63, $65, $20, $6f, $72, $20, $72
	byte	$65, $73, $6f, $75, $72, $63, $65, $20, $62, $75, $73, $79, $00, $43, $72, $6f
	byte	$73, $73, $20, $64, $65, $76, $69, $63, $65, $20, $6c, $69, $6e, $6b, $00, $4e
	byte	$6f, $20, $73, $70, $61, $63, $65, $20, $6f, $6e, $20, $64, $65, $76, $69, $63
	byte	$65, $00, $55, $6e, $6b, $6e, $6f, $77, $6e, $20, $65, $72, $72, $6f, $72, $00
	byte	$00[8]
	byte	$05, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
	long	(129 {__system___tx})<<20
	long	(130 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(131 {__system___rxtxioctl_0581})<<20
	long	(132 {__system____dummy_flush_0582})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(129 {__system___tx})<<20
	long	(130 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(131 {__system___rxtxioctl_0581})<<20
	long	(132 {__system____dummy_flush_0582})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(129 {__system___tx})<<20
	long	(130 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(131 {__system___rxtxioctl_0581})<<20
	long	(132 {__system____dummy_flush_0582})<<20
	byte	$00[376]
	long	@@@__system__dat_ + 1844
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	alignl
_fatfs_cc_dat_
	byte	$c7, $00, $fc, $00, $e9, $00, $e2, $00, $e4, $00, $e0, $00, $e5, $00, $e7, $00
	byte	$ea, $00, $eb, $00, $e8, $00, $ef, $00, $ee, $00, $ec, $00, $c4, $00, $c5, $00
	byte	$c9, $00, $e6, $00, $c6, $00, $f4, $00, $f6, $00, $f2, $00, $fb, $00, $f9, $00
	byte	$ff, $00, $d6, $00, $dc, $00, $f8, $00, $a3, $00, $d8, $00, $d7, $00, $92, $01
	byte	$e1, $00, $ed, $00, $f3, $00, $fa, $00, $f1, $00, $d1, $00, $aa, $00, $ba, $00
	byte	$bf, $00, $ae, $00, $ac, $00, $bd, $00, $bc, $00, $a1, $00, $ab, $00, $bb, $00
	byte	$91, $25, $92, $25, $93, $25, $02, $25, $24, $25, $c1, $00, $c2, $00, $c0, $00
	byte	$a9, $00, $63, $25, $51, $25, $57, $25, $5d, $25, $a2, $00, $a5, $00, $10, $25
	byte	$14, $25, $34, $25, $2c, $25, $1c, $25, $00, $25, $3c, $25, $e3, $00, $c3, $00
	byte	$5a, $25, $54, $25, $69, $25, $66, $25, $60, $25, $50, $25, $6c, $25, $a4, $00
	byte	$f0, $00, $d0, $00, $ca, $00, $cb, $00, $c8, $00, $31, $01, $cd, $00, $ce, $00
	byte	$cf, $00, $18, $25, $0c, $25, $88, $25, $84, $25, $a6, $00, $cc, $00, $80, $25
	byte	$d3, $00, $df, $00, $d4, $00, $d2, $00, $f5, $00, $d5, $00, $b5, $00, $fe, $00
	byte	$de, $00, $da, $00, $db, $00, $d9, $00, $fd, $00, $dd, $00, $af, $00, $b4, $00
	byte	$ad, $00, $b1, $00, $17, $20, $be, $00, $b6, $00, $a7, $00, $f7, $00, $b8, $00
	byte	$b0, $00, $a8, $00, $b7, $00, $b9, $00, $b3, $00, $b2, $00, $a0, $25, $a0, $00
	byte	$61, $00, $1a, $03, $e0, $00, $17, $03, $f8, $00, $07, $03, $ff, $00, $01, $00
	byte	$78, $01, $00, $01, $30, $01, $32, $01, $06, $01, $39, $01, $10, $01, $4a, $01
	byte	$2e, $01, $79, $01, $06, $01, $80, $01, $4d, $00, $43, $02, $81, $01, $82, $01
	byte	$82, $01, $84, $01, $84, $01, $86, $01, $87, $01, $87, $01, $89, $01, $8a, $01
	byte	$8b, $01, $8b, $01, $8d, $01, $8e, $01, $8f, $01, $90, $01, $91, $01, $91, $01
	byte	$93, $01, $94, $01, $f6, $01, $96, $01, $97, $01, $98, $01, $98, $01, $3d, $02
	byte	$9b, $01, $9c, $01, $9d, $01, $20, $02, $9f, $01, $a0, $01, $a0, $01, $a2, $01
	byte	$a2, $01, $a4, $01, $a4, $01, $a6, $01, $a7, $01, $a7, $01, $a9, $01, $aa, $01
	byte	$ab, $01, $ac, $01, $ac, $01, $ae, $01, $af, $01, $af, $01, $b1, $01, $b2, $01
	byte	$b3, $01, $b3, $01, $b5, $01, $b5, $01, $b7, $01, $b8, $01, $b8, $01, $ba, $01
	byte	$bb, $01, $bc, $01, $bc, $01, $be, $01, $f7, $01, $c0, $01, $c1, $01, $c2, $01
	byte	$c3, $01, $c4, $01, $c5, $01, $c4, $01, $c7, $01, $c8, $01, $c7, $01, $ca, $01
	byte	$cb, $01, $ca, $01, $cd, $01, $10, $01, $dd, $01, $01, $00, $8e, $01, $de, $01
	byte	$12, $01, $f3, $01, $03, $00, $f1, $01, $f4, $01, $f4, $01, $f8, $01, $28, $01
	byte	$22, $02, $12, $01, $3a, $02, $09, $00, $65, $2c, $3b, $02, $3b, $02, $3d, $02
	byte	$66, $2c, $3f, $02, $40, $02, $41, $02, $41, $02, $46, $02, $0a, $01, $53, $02
	byte	$40, $00, $81, $01, $86, $01, $55, $02, $89, $01, $8a, $01, $58, $02, $8f, $01
	byte	$5a, $02, $90, $01, $5c, $02, $5d, $02, $5e, $02, $5f, $02, $93, $01, $61, $02
	byte	$62, $02, $94, $01, $64, $02, $65, $02, $66, $02, $67, $02, $97, $01, $96, $01
	byte	$6a, $02, $62, $2c, $6c, $02, $6d, $02, $6e, $02, $9c, $01, $70, $02, $71, $02
	byte	$9d, $01, $73, $02, $74, $02, $9f, $01, $76, $02, $77, $02, $78, $02, $79, $02
	byte	$7a, $02, $7b, $02, $7c, $02, $64, $2c, $7e, $02, $7f, $02, $a6, $01, $81, $02
	byte	$82, $02, $a9, $01, $84, $02, $85, $02, $86, $02, $87, $02, $ae, $01, $44, $02
	byte	$b1, $01, $b2, $01, $45, $02, $8d, $02, $8e, $02, $8f, $02, $90, $02, $91, $02
	byte	$b7, $01, $7b, $03, $03, $00, $fd, $03, $fe, $03, $ff, $03, $ac, $03, $04, $00
	byte	$86, $03, $88, $03, $89, $03, $8a, $03, $b1, $03, $11, $03, $c2, $03, $02, $00
	byte	$a3, $03, $a3, $03, $c4, $03, $08, $03, $cc, $03, $03, $00, $8c, $03, $8e, $03
	byte	$8f, $03, $d8, $03, $18, $01, $f2, $03, $0a, $00, $f9, $03, $f3, $03, $f4, $03
	byte	$f5, $03, $f6, $03, $f7, $03, $f7, $03, $f9, $03, $fa, $03, $fa, $03, $30, $04
	byte	$20, $03, $50, $04, $10, $07, $60, $04, $22, $01, $8a, $04, $36, $01, $c1, $04
	byte	$0e, $01, $cf, $04, $01, $00, $c0, $04, $d0, $04, $44, $01, $61, $05, $26, $04
	byte	$00, $00, $7d, $1d, $01, $00, $63, $2c, $00, $1e, $96, $01, $a0, $1e, $5a, $01
	byte	$00, $1f, $08, $06, $10, $1f, $06, $06, $20, $1f, $08, $06, $30, $1f, $08, $06
	byte	$40, $1f, $06, $06, $51, $1f, $07, $00, $59, $1f, $52, $1f, $5b, $1f, $54, $1f
	byte	$5d, $1f, $56, $1f, $5f, $1f, $60, $1f, $08, $06, $70, $1f, $0e, $00, $ba, $1f
	byte	$bb, $1f, $c8, $1f, $c9, $1f, $ca, $1f, $cb, $1f, $da, $1f, $db, $1f, $f8, $1f
	byte	$f9, $1f, $ea, $1f, $eb, $1f, $fa, $1f, $fb, $1f, $80, $1f, $08, $06, $90, $1f
	byte	$08, $06, $a0, $1f, $08, $06, $b0, $1f, $04, $00, $b8, $1f, $b9, $1f, $b2, $1f
	byte	$bc, $1f, $cc, $1f, $01, $00, $c3, $1f, $d0, $1f, $02, $06, $e0, $1f, $02, $06
	byte	$e5, $1f, $01, $00, $ec, $1f, $f3, $1f, $01, $00, $fc, $1f, $4e, $21, $01, $00
	byte	$32, $21, $70, $21, $10, $02, $84, $21, $01, $00, $83, $21, $d0, $24, $1a, $05
	byte	$30, $2c, $2f, $04, $60, $2c, $02, $01, $67, $2c, $06, $01, $75, $2c, $02, $01
	byte	$80, $2c, $64, $01, $00, $2d, $26, $08, $41, $ff, $1a, $03, $00, $00, $01, $03
	byte	$05, $07, $09, $0e, $10, $12, $14, $16, $18, $1c, $1e, $43, $55, $45, $41, $41
	byte	$41, $41, $43, $45, $45, $45, $49, $49, $49, $41, $41, $45, $92, $92, $4f, $4f
	byte	$4f, $55, $55, $59, $4f, $55, $4f, $9c, $4f, $9e, $9f, $41, $49, $4f, $55, $a5
	byte	$a5, $a6, $a7, $a8, $a9, $aa, $ab, $ac, $ad, $ae, $af, $b0, $b1, $b2, $b3, $b4
	byte	$41, $41, $41, $b8, $b9, $ba, $bb, $bc, $bd, $be, $bf, $c0, $c1, $c2, $c3, $c4
	byte	$c5, $41, $41, $c8, $c9, $ca, $cb, $cc, $cd, $ce, $cf, $d1, $d1, $45, $45, $45
	byte	$49, $49, $49, $49, $d9, $da, $db, $dc, $dd, $49, $df, $4f, $e1, $4f, $4f, $4f
	byte	$4f, $e6, $e8, $e8, $55, $55, $55, $59, $59, $ee, $ef, $f0, $f1, $f2, $f3, $f4
	byte	$f5, $f6, $f7, $f8, $f9, $fa, $fb, $fc, $fd, $fe, $ff, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
	long	(112 {_fatfs_cc_v_close})<<20
	long	(113 {_fatfs_cc_v_read})<<20
	long	(114 {_fatfs_cc_v_write})<<20
	long	(115 {_fatfs_cc_v_lseek})<<20
	long	(116 {_fatfs_cc_v_ioctl})<<20
	long	(133 {_fatfs_cc_v_flush})<<20
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(117 {_fatfs_cc_v_open})<<20
	long	(118 {_fatfs_cc_v_creat})<<20
	long	(119 {_fatfs_cc_v_opendir})<<20
	long	(120 {_fatfs_cc_v_closedir})<<20
	long	(121 {_fatfs_cc_v_readdir})<<20
	long	(122 {_fatfs_cc_v_stat})<<20
	long	(123 {_fatfs_cc_v_mkdir})<<20
	long	(124 {_fatfs_cc_v_rmdir})<<20
	long	(125 {_fatfs_cc_v_remove})<<20
	long	(126 {_fatfs_cc_v_rename})<<20
	long	(127 {_fatfs_cc_v_init})<<20
	long	(128 {_fatfs_cc_v_deinit})<<20
	byte	$ff, $ff, $ff, $ff, $1f, $00, $00, $00, $1c, $00, $00, $00, $1f, $00, $00, $00
	byte	$1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00
	byte	$1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00
	byte	$1f, $00, $00, $00, $00, $00, $00, $00, $1f, $00, $00, $00, $3b, $00, $00, $00
	byte	$5a, $00, $00, $00, $78, $00, $00, $00, $97, $00, $00, $00, $b5, $00, $00, $00
	byte	$d4, $00, $00, $00, $f3, $00, $00, $00, $11, $01, $00, $00, $30, $01, $00, $00
	byte	$4e, $01, $00, $00, $6d, $01, $00, $00, $ff, $ff, $ff, $ff, $00, $00, $00, $00
	byte	$00[32]
	long	@@@_fatfs_cc_dat_ + 1346
	long	@@@_fatfs_cc_dat_ + 1350
	byte	$00[18]
	byte	$3f, $3f, $3f, $00, $55, $43, $54, $00, $55, $43, $54, $00, $00, $00, $00, $00
	byte	$00[7]
	byte	$ca, $9a, $3b, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$91, $11, $11, $11, $11, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$01[7]
	byte	$90, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
	byte	$42[10]
	byte	$20[7]
	byte	$44[6]
	byte	$04[20]
	byte	$20[6]
	byte	$48[6]
	byte	$08[20]
	byte	$20, $20, $20, $20, $01, $00, $00, $00, $00
__methodtable__
	long	@_do_no_command
	long	@_do_plus
	long	@_do_minus
	long	@_do_or
	long	@_do_mul
	long	@_do_fdiv
	long	@_do_and
	long	@_do_div
	long	@_do_mod
	long	@_do_shl
	long	@_do_shr
	long	@_do_power
	long	@_do_getvar
	long	@_do_push
	long	@_do_assign
	long	@_do_cls
	long	@_do_new
	long	@_do_plot
	long	@_do_draw
	long	@_do_print
	long	@_do_circle
	long	@_do_fcircle
	long	@_do_box
	long	@_do_frame
	long	@_do_color
	long	@_do_for
	long	@_do_next
	long	@_do_list
	long	@_do_run
	long	@_do_error
	long	@_do_fast_goto
	long	@_do_find_goto
	long	@_do_slow_goto
	long	@_do_converttoint
	long	@_test_csave
	long	@_do_save
	long	@_do_load
	long	@_do_pinwrite
	long	@_do_waitms
	long	@_do_waitvbl
	long	@_do_if
	long	@_do_else
	long	@_do_nothing
	long	@_do_eq
	long	@_do_ge
	long	@_do_le
	long	@_do_gt
	long	@_do_lt
	long	@_do_ne
	long	@_do_rnd
	long	@_do_brun
	long	@_do_beep
	long	@_do_dir
	long	@_do_paper
	long	@_do_ink
	long	@_do_font
	long	@_do_mode
	long	@_do_mouse
	long	@_do_gettime
	long	@_do_cursor
	long	@_do_click
	long	@_do_mousex
	long	@_do_mousey
	long	@_do_mousek
	long	@_do_mousew
	long	@_do_sin
	long	@_do_stick
	long	@_do_strig
	long	@_do_sprite
	long	@_do_defsprite
	long	@_do_getpixel
	long	@_do_waitclock
	long	@_do_negative
	long	@_do_rdpin
	long	@_do_rqpin
	long	@_do_pinread
	long	@_do_wrpin
	long	@_do_wxpin
	long	@_do_wypin
	long	@_do_pinfloat
	long	@_do_pinlo
	long	@_do_pinhi
	long	@_do_pinstart
	long	@_do_pintoggle
	long	@_do_position
	long	@_do_cos
	long	@_do_tan
	long	@_do_atn
	long	@_do_asin
	long	@_do_acos
	long	@_do_sqr
	long	@_do_fill
	long	@_do_defsnd
	long	@_do_defenv
	long	@_do_rad
	long	@_do_deg
	long	@_do_int
	long	@_do_play
	long	@_hg010b_spin2_putchar
	long	@__struct___bas_wrap_sender_tx
	long	@__struct___bas_wrap_sender_rx
	long	@__struct___bas_wrap_sender_close
	long	@__struct__s_vfs_file_t_putchar
	long	@__struct__s_vfs_file_t_getchar
	long	@___strs_cl_pfunc
	long	@__system____root_opendir
	long	@__system____root_closedir
	long	@__system____root_readdir
	long	@__system____root_stat
	long	@__system____default_putc
	long	@__system____default_getc
	long	@__system____default_flush
	long	@_fatfs_cc_v_close
	long	@_fatfs_cc_v_read
	long	@_fatfs_cc_v_write
	long	@_fatfs_cc_v_lseek
	long	@_fatfs_cc_v_ioctl
	long	@_fatfs_cc_v_open
	long	@_fatfs_cc_v_creat
	long	@_fatfs_cc_v_opendir
	long	@_fatfs_cc_v_closedir
	long	@_fatfs_cc_v_readdir
	long	@_fatfs_cc_v_stat
	long	@_fatfs_cc_v_mkdir
	long	@_fatfs_cc_v_rmdir
	long	@_fatfs_cc_v_remove
	long	@_fatfs_cc_v_rename
	long	@_fatfs_cc_v_init
	long	@_fatfs_cc_v_deinit
	long	@__system___tx
	long	@__system___rx
	long	@__system___rxtxioctl_0581
	long	@__system____dummy_flush_0582
	long	@_fatfs_cc_v_flush
__heap_base
	long	0[48002]
objmem
	long	0[15732]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
_var03
	res	1
_var04
	res	1
_var05
	res	1
_var06
	res	1
_var07
	res	1
_var08
	res	1
_var09
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
arg05
	res	1
arg06
	res	1
local01
	res	1
local02
	res	1
local03
	res	1
local04
	res	1
local05
	res	1
local06
	res	1
local07
	res	1
local08
	res	1
local09
	res	1
local10
	res	1
local11
	res	1
local12
	res	1
local13
	res	1
local14
	res	1
local15
	res	1
local16
	res	1
local17
	res	1
local18
	res	1
local19
	res	1
local20
	res	1
local21
	res	1
local22
	res	1
local23
	res	1
local24
	res	1
local25
	res	1
local26
	res	1
local27
	res	1
local28
	res	1
local29
	res	1
local30
	res	1
local31
	res	1
local32
	res	1
local33
	res	1
local34
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	480
