00000                 | 
00000                 | #line 1 "D:/programowanie/p2-retromachine/Propeller/Basic/audio093b-8-sc.p2asm"
00000                 | con
00000                 | 	_clkfreq = 20000000
00000                 | 	_clkmode = 16779595
00000                 | ' 
00000                 | ' 
00000                 | ' left= 14
00000                 | 	left = 14
00000                 | ' right=15
00000                 | 	right = 15
00000                 | ' 
00000                 | ' c4=262
00000                 | 	c4 = 262
00000                 | ' d4=294
00000                 | 	d4 = 294
00000                 | ' e4=330
00000                 | 	e4 = 330
00000                 | ' f4=349
00000                 | 	f4 = 349
00000                 | ' g4=392
00000                 | 	g4 = 392
00000                 | ' a4=440
00000                 | 	a4 = 440
00000                 | ' h4=494
00000                 | 	h4 = 494
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 20000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $100094b
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 7A 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 02 90 5D |  if_ne	jmp	#spininit
0040c 002 BC F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 01 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 04 80 80 FF 
00420 007 00 90 66 FD | 	hubset	##16779592
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 04 80 00 FF 
00430 00b 4B ED 07 F6 | 	mov	pa, ##16779595
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 96 98 80 FF 
00440 00f 14 00 6E FC | 	wrlong	##20000000, #20
00444 010 BC 01 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
005fc 07e 00 00 00 00 
00600 07f 00 00 00 00 | 	orgf	128
00604 080             | skip_clock_set_
00604 080 00 07 A0 FD | 	call	#_start
00608 081             | cogexit
00608 081 38 01 80 FF 
0060c 082 1F 00 66 FD | 	waitx	##160000
00610 083 01 84 61 FD | 	cogid	arg01
00614 084 03 84 61 FD | 	cogstop	arg01
00618 085             | spininit
00618 085 61 75 05 FB | 	rdlong	objptr, ptra++
0061c 086 61 7B 05 FB | 	rdlong	result1, ptra++
00620 087 28 06 64 FD | 	setq	#3
00624 088 00 85 05 FB | 	rdlong	arg01, ptra
00628 089 04 F0 87 F1 | 	sub	ptra, #4
0062c 08a 2D 7A 61 FD | 	call	result1
00630 08b D4 FF 9F FD | 	jmp	#cogexit
00634 08c             | FCACHE_LOAD_
00634 08c F9 2D 01 F6 |     mov	fcache_tmpb_,ptrb
00638 08d 2B F2 63 FD |     pop	ptrb
0063c 08e 95 EC 8B F9 |     altd	pa,ret_instr_
00640 08f 95 00 00 F6 |     mov	 0-0, ret_instr_
00644 090 28 EC 63 FD |     setq	pa
00648 091 E1 01 04 FB |     rdlong	$0, ptrb++
0064c 092 2A F2 63 FD |     push	ptrb
00650 093 96 F2 03 F6 |     mov ptrb,fcache_tmpb_
00654 094 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00658 095             | ret_instr_
00658 095 00 FE 07 02 |     _ret_ cmp inb,#0
0065c 096             | fcache_tmpb_
0065c 096 00 00 00 00 |     long 0
00660 097             | fcache_load_ptr_
00660 097 8C 00 00 00 |     long FCACHE_LOAD_
00664 098             | builtin_bytefill_
00664 098 01 88 55 F0 |         shr	arg03, #1 wc
00668 099 C2 86 41 CC |  if_c   wrbyte	arg02, arg01
0066c 09a 01 84 05 C1 |  if_c   add	arg01, #1
00670 09b 00 86 FD F9 |         movbyts	arg02, #0
00674 09c             | builtin_wordfill_
00674 09c 01 88 55 F0 |         shr	arg03, #1 wc
00678 09d C2 86 51 CC |  if_c   wrword	arg02, arg01
0067c 09e 02 84 05 C1 |  if_c   add	arg01, #2
00680 09f C3 86 29 F9 |         setword	arg02, arg02, #1
00684 0a0             | builtin_longfill_
00684 0a0 C2 00 88 FC |         wrfast	#0,arg01
00688 0a1 00 88 0D F2 |         cmp	arg03, #0 wz
0068c 0a2 C4 02 D8 5C |  if_nz  rep	#1, arg03
00690 0a3 17 86 61 5D |  if_nz  wflong	arg02
00694 0a4 2D 00 64 FD |         ret
00698 0a5             | COUNT_
00698 0a5 00 00 00 00 |     long 0
0069c 0a6             | RETADDR_
0069c 0a6 00 00 00 00 |     long 0
006a0 0a7             | fp
006a0 0a7 00 00 00 00 |     long 0
006a4 0a8             | pushregs_
006a4 0a8 2B EC 63 FD |     pop  pa
006a8 0a9 2B 4C 61 FD |     pop  RETADDR_
006ac 0aa 03 4A 95 FB |     tjz  COUNT_, #pushregs_done_
006b0 0ab FF 4B 8D F9 |     altd  COUNT_, #511
006b4 0ac 28 00 64 FD |     setq #0-0
006b8 0ad 61 8D 65 FC |     wrlong local01, ptra++
006bc 0ae             | pushregs_done_
006bc 0ae 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
006c0 0af 61 4B 65 FC |     wrlong COUNT_, ptra++
006c4 0b0 F8 4F 01 F6 |     mov    fp, ptra
006c8 0b1 2C EC 63 FD |     jmp  pa
006cc 0b2             |  popregs_
006cc 0b2 2B EC 63 FD |     pop    pa
006d0 0b3 28 04 64 FD |     setq   #2
006d4 0b4 5F 4B 05 FB |     rdlong COUNT_, --ptra
006d8 0b5 02 4A 75 FB |     djf    COUNT_, #popregs__ret
006dc 0b6 28 4A 61 FD |     setq   COUNT_
006e0 0b7 5F 8D 05 FB |     rdlong local01, --ptra
006e4 0b8             | popregs__ret
006e4 0b8 2A 4C 61 FD |     push   RETADDR_
006e8 0b9 2C EC 63 FD |     jmp    pa
006ec 0ba             | 
006ec 0ba             | objptr
006ec 0ba C8 0C 00 00 | 	long	@objmem
006f0 0bb             | ptr__dat__
006f0 0bb E8 08 00 00 | 	long	@_dat_
006f4 0bc             | ptr_stackspace_
006f4 0bc D4 0D 00 00 | 	long	@stackspace
006f8 0bd             | result1
006f8 0bd 00 00 00 00 | 	long	0
006fc 0be             | result2
006fc 0be 01 00 00 00 | 	long	1
00700 0bf             | COG_BSS_START
00700 0bf             | 	fit	480
00700                 | 	orgh
00700                 | hubentry
00700                 | 
00700                 | ' 
00700                 | ' 
00700                 | ' '--------------------------------------------------------------
00700                 | ' '---------- Init the variables, start the cog. ----------------
00700                 | ' '--------------------------------------------------------------
00700                 | ' 
00700                 | ' pub start(mbox,scope,cache) :cog,base | iii
00700                 | _start
00700     04 4A 05 F6 | 	mov	COUNT_, #4
00704     A8 00 A0 FD | 	call	#pushregs_
00708     C2 8C 01 F6 | 	mov	local01, arg01
0070c                 | ' 
0070c                 | ' ' mbox: PSRAM mailbox or 0 if no PSRAM
0070c                 | ' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
0070c                 | ' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
0070c                 | ' 
0070c                 | ' mailboxaddr:=mbox 
0070c     BA 8C 61 FC | 	wrlong	local01, objptr
00710                 | ' scope_ptr:=scope
00710     04 74 05 F1 | 	add	objptr, #4
00714     BA 86 61 FC | 	wrlong	arg02, objptr
00718                 | ' cache_ptr:=cache
00718     04 74 05 F1 | 	add	objptr, #4
0071c     BA 88 61 FC | 	wrlong	arg03, objptr
00720                 | ' base:=@channel1[0]
00720     04 74 05 F1 | 	add	objptr, #4
00724     BA 8E 01 F6 | 	mov	local02, objptr
00728                 | ' 
00728                 | ' repeat iii from 0 to 7
00728     00 90 05 F6 | 	mov	local03, #0
0072c     01 00 00 FF 
00730     D8 77 05 F1 | 	add	ptr__dat__, ##984
00734     0C 74 85 F1 | 	sub	objptr, #12
00738     97 80 48 FB | 	callpa	#(@LR__0002-@LR__0001)>>2,fcache_load_ptr_
0073c                 | LR__0001
0073c                 | '   long[base+32*iii]:=0
0073c     C7 8C 01 F6 | 	mov	local01, local02
00740     C8 7C 01 F6 | 	mov	result2, local03
00744     05 7C 65 F0 | 	shl	result2, #5
00748     BE 8C 01 F1 | 	add	local01, result2
0074c     C6 00 68 FC | 	wrlong	#0, local01
00750                 | '   long[base+32*iii+4]:=0
00750     C7 8C 01 F6 | 	mov	local01, local02
00754     C8 7C 01 F6 | 	mov	result2, local03
00758     05 7C 65 F0 | 	shl	result2, #5
0075c     BE 8C 01 F1 | 	add	local01, result2
00760     04 8C 05 F1 | 	add	local01, #4
00764     C6 00 68 FC | 	wrlong	#0, local01
00768                 | '   long[base+32*iii+12]:=0
00768     C7 92 01 F6 | 	mov	local04, local02
0076c     C8 8C 01 F6 | 	mov	local01, local03
00770     05 8C 65 F0 | 	shl	local01, #5
00774     C6 92 01 F1 | 	add	local04, local01
00778     0C 92 05 F1 | 	add	local04, #12
0077c     C9 00 68 FC | 	wrlong	#0, local04
00780                 | '   long[base+32*iii+16]:=2 
00780     C7 92 01 F6 | 	mov	local04, local02
00784     C8 8C 01 F6 | 	mov	local01, local03
00788     05 8C 65 F0 | 	shl	local01, #5
0078c     C6 92 01 F1 | 	add	local04, local01
00790     10 92 05 F1 | 	add	local04, #16
00794     C9 04 68 FC | 	wrlong	#2, local04
00798                 | '   word[base+32*iii+20]:=0
00798     C7 92 01 F6 | 	mov	local04, local02
0079c     C8 8C 01 F6 | 	mov	local01, local03
007a0     05 8C 65 F0 | 	shl	local01, #5
007a4     C6 92 01 F1 | 	add	local04, local01
007a8     14 92 05 F1 | 	add	local04, #20
007ac     C9 00 58 FC | 	wrword	#0, local04
007b0                 | '   word[base+32*iii+22]:=8192
007b0     C7 92 01 F6 | 	mov	local04, local02
007b4     C8 8C 01 F6 | 	mov	local01, local03
007b8     05 8C 65 F0 | 	shl	local01, #5
007bc     C6 92 01 F1 | 	add	local04, local01
007c0     16 92 05 F1 | 	add	local04, #22
007c4     10 00 80 FF 
007c8     C9 00 58 FC | 	wrword	##8192, local04
007cc                 | '   word[base+32*iii+24]:=4000+2*iii
007cc     C8 92 01 F6 | 	mov	local04, local03
007d0     01 92 65 F0 | 	shl	local04, #1
007d4     07 00 00 FF 
007d8     A0 8D 05 F6 | 	mov	local01, ##4000
007dc     C9 8C 01 F1 | 	add	local01, local04
007e0     C7 92 01 F6 | 	mov	local04, local02
007e4     C8 7C 01 F6 | 	mov	result2, local03
007e8     05 7C 65 F0 | 	shl	result2, #5
007ec     BE 92 01 F1 | 	add	local04, result2
007f0     18 92 05 F1 | 	add	local04, #24
007f4     C9 8C 51 FC | 	wrword	local01, local04
007f8                 | '   word[base+32*iii+26]:=2
007f8     C7 92 01 F6 | 	mov	local04, local02
007fc     C8 8C 01 F6 | 	mov	local01, local03
00800     05 8C 65 F0 | 	shl	local01, #5
00804     C6 92 01 F1 | 	add	local04, local01
00808     1A 92 05 F1 | 	add	local04, #26
0080c     C9 04 58 FC | 	wrword	#2, local04
00810                 | '   long [base+32*iii+8]:=@null | $C0000000
00810     BB 8C 01 F6 | 	mov	local01, ptr__dat__
00814     3E 8C 25 F4 | 	bith	local01, #62
00818     C7 92 01 F6 | 	mov	local04, local02
0081c     C8 88 01 F6 | 	mov	arg03, local03
00820     05 88 65 F0 | 	shl	arg03, #5
00824     C4 92 01 F1 | 	add	local04, arg03
00828     08 92 05 F1 | 	add	local04, #8
0082c     C9 8C 61 FC | 	wrlong	local01, local04
00830     01 90 05 F1 | 	add	local03, #1
00834     08 90 55 F2 | 	cmps	local03, #8 wc
00838     00 FF 9F CD |  if_b	jmp	#LR__0001
0083c                 | LR__0002
0083c     01 00 00 FF 
00840     D8 77 85 F1 | 	sub	ptr__dat__, ##984
00844                 | '   
00844                 | ' cog:=coginit(16,@audio,@mailboxaddr)
00844     BB 86 01 F6 | 	mov	arg02, ptr__dat__
00848     BA 88 01 F6 | 	mov	arg03, objptr
0084c     10 92 05 F6 | 	mov	local04, #16
00850     28 88 61 FD | 	setq	arg03
00854     C3 92 F1 FC | 	coginit	local04, arg02 wc
00858     01 92 65 C6 |  if_b	neg	local04, #1
0085c                 | ' waitms(100)
0085c     64 84 05 F6 | 	mov	arg01, #100
00860     18 00 B0 FD | 	call	#__system___waitms
00864                 | ' return cog,base
00864     C7 7C 01 F6 | 	mov	result2, local02
00868     C9 7A 01 F6 | 	mov	result1, local04
0086c     A7 F0 03 F6 | 	mov	ptra, fp
00870     B2 00 A0 FD | 	call	#popregs_
00874                 | _start_ret
00874     2D 00 64 FD | 	ret
00878                 | hubexit
00878     81 00 80 FD | 	jmp	#cogexit
0087c                 | 
0087c                 | __system___waitms
0087c     C2 7E 01 F6 | 	mov	_var01, arg01
00880     1A 80 61 FD | 	getct	_var02
00884     14 82 05 FB | 	rdlong	_var03, #20
00888     97 14 48 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
0088c                 | LR__0010
0088c     01 00 00 FF 
00890     E8 7F 55 F2 | 	cmps	_var01, ##1000 wc
00894     1C 00 90 CD |  if_b	jmp	#LR__0012
00898     C1 80 01 F1 | 	add	_var02, _var03
0089c     C0 84 01 F6 | 	mov	arg01, _var02
008a0     00 84 65 FA | 	addct1	arg01, #0
008a4     24 22 60 FD | 	waitct1
008a8     01 00 00 FF 
008ac     E8 7F 85 F1 | 	sub	_var01, ##1000
008b0     D8 FF 9F FD | 	jmp	#LR__0010
008b4                 | LR__0011
008b4                 | LR__0012
008b4     01 7E 55 F2 | 	cmps	_var01, #1 wc
008b8     28 00 90 CD |  if_b	jmp	#LR__0013
008bc     C1 7E 01 FD | 	qmul	_var01, _var03
008c0     01 00 00 FF 
008c4     E8 89 05 F6 | 	mov	arg03, ##1000
008c8     19 7A 61 FD | 	getqy	result1
008cc     18 84 61 FD | 	getqx	arg01
008d0     28 7A 61 FD | 	setq	result1
008d4     C4 84 11 FD | 	qdiv	arg01, arg03
008d8     18 84 61 FD | 	getqx	arg01
008dc     C0 84 61 FA | 	addct1	arg01, _var02
008e0     24 22 60 FD | 	waitct1
008e4                 | LR__0013
008e4                 | __system___waitms_ret
008e4     2D 00 64 FD | 	ret
008e8                 | 	alignl
008e8                 | _dat_
008e8                 | 
008e8                 | audio       org     0
008e8                 | 
008e8     61 85 05 FB |             rdlong  mailbox2, ptra++     ' get start address of all mailboxes
008ec     61 C3 05 FB |             rdlong  scbase, ptra++       ' get start address of scope buffer
008f0     61 CF 05 FB |             rdlong  hubptr, ptra++       ' get start address of PSRAM cache
008f4                 | 
008f4     01 EC 63 FD |             cogid   pa                   ' compute cogid
008f8     0C EC 07 FA |             mul     pa, #12              ' and mailbox spacing
008fc     F6 85 01 F1 |             add     mailbox2, pa         ' add offset to find this COG's mailbox
00900     C2 82 01 F6 |             mov     mailbox,mailbox2     ' we need 2 copies of this to ensble switching between hub and psram
00904                 | 
00904     00 F2 07 F6 |             mov     ptrb,#0              ' A tail pointer for the buffer
00908     0E CA 05 FC |             wrpin   dac,#left            ' Noise dither DACs at clk/100
0090c     0E BE 1C FC |             wxpin   #95,#left       	 ' Set initial DACs sample rate. It is now controlled via a register by the main program
00910     0F CA 05 FC |             wrpin   dac,#right
00914     0F BE 1C FC |             wxpin   #95,#right    
00918     41 9C 64 FD |             dirh    #left addpins 1
0091c     20 9C 64 FD |             setse1  #%001<<6 + left      ' Set the event - DAC empty
00920     A9 E8 07 F6 |             mov     ijmp1,#isr1          ' Init the interrupt
00924     25 08 64 FD |             setint1 #4                   ' Interrupt from DAC empty event
00928                 |             
00928                 | '---------------------------------------------------------------------------------        
00928                 | '----------------- The main loop -------------------------------------------------
00928                 | '---------------------------------------------------------------------------------
00928                 | 
00928     B2 66 11 F2 | loop        cmp     time0,a41000000 wc  ' time counter overflow protection
0092c     10 00 90 CD |       if_c  jmp     #loop1
00930                 |   
00930     09 A8 05 F6 |             mov     cn,#9               ' Substract $40000000 from all the channel times and the main timer
00934     B2 A8 8D F9 | p402        altd    cn,#a41000000       ' this has to be done at once for all channels
00938     B1 00 80 F1 |             sub     0-0,a40000000
0093c     FD A9 6D FB |             djnz    cn,#p402
00940                 |     
00940     00 A8 05 F6 | loop1       mov     cn,#0               ' Find the channel to compute
00944     B4 AA 01 F6 |             mov     ct,time1            ' with the lowest next sample time
00948     B5 AA 39 F3 |             fle     ct,time2 wcz        ' How to size-optimize this???
0094c     01 A8 05 C6 |     if_c    mov     cn,#1
00950     B6 AA 39 F3 |             fle     ct,time3 wcz
00954     02 A8 05 C6 |     if_c    mov     cn,#2     
00958     B7 AA 39 F3 |             fle     ct,time4 wcz
0095c     03 A8 05 C6 |     if_c    mov     cn,#3
00960     B8 AA 39 F3 |             fle     ct,time5 wcz
00964     04 A8 05 C6 |     if_c    mov     cn,#4
00968     B9 AA 39 F3 |             fle     ct,time6 wcz
0096c     05 A8 05 C6 |     if_c    mov     cn,#5
00970     BA AA 39 F3 |             fle     ct,time7 wcz
00974     06 A8 05 C6 |     if_c    mov     cn,#6
00978     BB AA 39 F3 |             fle     ct,time8 wcz
0097c     07 A8 05 C6 |     if_c    mov     cn,#7
00980                 | 
00980                 | 
00980                 | '----------------------------------------------------------------------------------
00980                 | '------------- Compute channel samples --------------------------------------------
00980                 | '----------------------------------------------------------------------------------
00980                 | 
00980                 | 
00980     D4 78 01 F6 | p401        mov     channeladd,cn             ' compute the pointer to channel parameters block
00984     05 78 65 F0 |             shl     channeladd,#5
00988     BC F0 03 F1 |             add     ptra,channeladd
0098c                 | 
0098c     28 0E 64 FD |             setq    #7                        ' read parameters
00990     00 8F 05 FB |             rdlong  pointer0,ptra
00994     1F 9C 0D F4 |             testb   command0,#31 wz	      ' bit #31 command - set the DAC sample rate
00998     18 00 90 5D |     if_nz   jmp     #p404                     ' if not set, proceed
0099c     CE 7C 31 F9 |             getword qq,command0,#0            ' get the new rate
009a0     4E 7C 15 FC |             wxpin   qq,#left addpins 1        ' and program the pins
009a4     BE 7C E1 F8 |             getbyte qq,qq,#0 		      ' check if the rate is n*256
009a8     00 7C 0D F2 |             cmp     qq,#0 wz                         
009ac     4E CC 05 AC |     if_z    wrpin   dac2,#left addpins 1      ' if yes, set PWM DAC mode
009b0     4E CA 05 5C |     if_nz   wrpin   dac,#left addpins 1       ' else set noise DAC mode
009b4                 |             
009b4     1E 9C 1D F4 | p404        bitl    command0,#30 wcz             ' bit #30: select PSRAM/HUB
009b8     C2 82 01 56 |     if_nz   mov     mailbox,mailbox2             ' if not set, use PSRAM
009bc     00 82 05 A6 |     if_z    mov     mailbox,#0                   ' if set, use HUB : TODO: this can be done at a channel level!
009c0                 | 
009c0                 | 
009c0     C8 AE 31 F9 | p405        getword oldls,sample0,#0          ' extract old sample value
009c4     C8 B0 39 F9 |             getword oldrs,sample0,#1
009c8     CC A4 39 F9 |      	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
009cc     CC A2 31 F9 |     	    getword avol0,volpan0,#0
009d0     CD A0 39 F9 |             getword askip0,freqskip0,#1    	    
009d4     CD 9E 31 F9 |             getword afreq0,freqskip0,#0
009d8                 | 
009d8     B4 A8 95 F9 |             alts    cn, #time1                ' compute the time difference between this and previous sample
009dc     00 AC 01 F6 |             mov     dt0,0-0    
009e0     B3 AC 81 F1 |             sub     dt0,time0
009e4                 |             
009e4     B4 A8 8D F9 |             altd    cn, #time1                ' add channel period to channel time
009e8     CF 00 00 F1 |             add     0-0,afreq0  	
009ec                 | 
009ec     D0 8E 01 F1 |             add     pointer0,askip0           ' compute the pointer to the next sample       
009f0     C7 EA C1 F8 |             setbyte pointer00,pointer0,#0
009f4     08 8E 45 F0 |             shr     pointer0,#8
009f8                 |          
009f8     1F 92 0D F4 |             testb   sstart0,#31 wz            
009fc     01 8E 65 A0 |     if_z    shl     pointer0,#1        
00a00     1C 92 0D F4 |             testb   sstart0,#28 wz            
00a04     01 8E 65 A0 |     if_z    shl     pointer0,#1        
00a08                 |             
00a08     CB 8E 19 F2 |             cmp     pointer0,lend0 wcz
00a0c     CB 8E 81 31 |     if_ge   sub     pointer0,lend0	      ' and loop if needed     
00a10     CA 8E 01 31 |     if_ge   add     pointer0,lstart0       
00a14                 |             
00a14     C7 7C 01 F6 |             mov     qq,pointer0               ' compute place in the memory from where the sample will be loaded
00a18     C9 7C 01 F1 |             add     qq,sstart0            
00a1c                 | 
00a1c                 | 
00a1c                 | 
00a1c     FF 83 5D F2 |             cmps    mailbox,#$1FF wcz            ' the mailbox has to point somewhere not at the start of HUB RAM
00a20     BE 7E E1 EA |     if_le   rdword  spl,qq                     ' if not, use HUB RAM for samples
00a24     04 01 B0 1D |     if_gt   call    #cache_read
00a28                 |          
00a28                 |          
00a28                 |  
00a28                 |          
00a28     1F 92 0D F4 |             testb   sstart0,#31 wz 
00a2c     08 7E 65 50 |     if_nz   shl     spl,#8
00a30     08 8E 65 50 |     if_nz   shl     pointer0,#8
00a34     07 8E 65 A0 |     if_z    shl     pointer0,#7
00a38     1C 92 0D F4 |             testb   sstart0,#28 wz            
00a3c     01 8E 45 A0 |     if_z    shr     pointer0,#1    
00a40     F5 8E C1 F8 | 	    setbyte pointer0,pointer00,#0       
00a44                 |     
00a44                 | 
00a44     D1 7E 31 FA | p406        scas    spl,avol0                 ' apply volume
00a48     00 7E 01 F6 |             mov     spl,0-0
00a4c                 |  
00a4c     D2 7E 31 FA |             scas    spl,apan0                 ' apply pan
00a50     00 B2 01 F6 |             mov     ls0,0-0
00a54     20 00 00 FF 
00a58     00 7C 05 F6 |             mov     qq,##16384
00a5c     D2 7C 81 F1 |             sub     qq,apan0
00a60     BE 7E 31 FA |             scas    spl,qq
00a64     00 B4 01 F6 |             mov     rs0, 0-0
00a68                 | 
00a68     D8 B8 81 F1 |             sub     rs,oldrs 		      ' replace the old sample with the new one in the mix
00a6c     DA B8 01 F1 |             add     rs,rs0
00a70     D7 B6 81 F1 |             sub     ls,oldls
00a74     D9 B6 01 F1 |             add     ls,ls0
00a78                 |    
00a78     DA 90 29 F9 |             setword sample0,rs0,#1           ' pack samples into long
00a7c     D9 90 21 F9 |             setword sample0,ls0,#0
00a80                 |             
00a80     1E 92 1D F4 |             bitl    sstart0, #30 wcz          ' if bit #30 of start pointer is set, the current pointer needs resetting  
00a84     00 8E 05 A6 |     if_z    mov     pointer0, #0  
00a88     02 93 65 AC |     if_z    wrlong  sstart0, ptra[2]          ' reset bit #30 in hub
00a8c     1D 92 1D F4 |             bitl    sstart0, #29 wcz	      ' if bit #29 is set, synchronize stereo at channels 1 and 2
00a90     04 00 00 AF 
00a94     00 68 05 A1 |     if_z    add     time1,##2048
00a98     B4 6A 01 A6 |     if_z    mov     time2,time1
00a9c     02 93 65 AC |     if_z    wrlong  sstart0,ptra[2]
00aa0                 |             
00aa0     28 02 64 FD | p403        setq #1                          ' write new pointer and sample value to the hub
00aa4     00 8F 65 FC |             wrlong  pointer0,ptra
00aa8     BC F0 83 F1 |             sub     ptra, channeladd         ' reset the pointer to channel parameters
00aac                 |                       
00aac     B3 A6 09 F2 |             cmp     oldt0,time0 wz           ' If more than 1 sample is computed at the same time, write only the last result
00ab0     FF 7B 25 A7 |     if_z    decmod  front, #511          
00ab4                 |          
00ab4     DB AE 31 F9 |             getword oldls,ls,#0              ' reuse oldls variable to convert the sample to unsigned
00ab8     DC B0 31 F9 |  	    getword oldrs,rs,#0              ' getword instead of mov makes the upper bits=0
00abc     0F AE E5 F4 |             bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
00ac0     0F B0 E5 F4 |             bitnot  oldrs,#15		     ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
00ac4                 | 	    
00ac4                 | 		    
00ac4     D7 B0 29 F9 |             setword oldrs,oldls,#1           ' Pack L and R to one long    		
00ac8     DE BA 01 F6 |             mov     oldsample, newsample     ' The new computed sample will be outputted in the next loop, now we have to fill the buffer with the old one
00acc     D8 BC 01 F6 |             mov     newsample, oldrs       
00ad0                 | 
00ad0     B3 A6 01 F6 |             mov     oldt0,time0              ' update global time
00ad4     D6 66 01 F1 |             add     time0,dt0    
00ad8                 |                                      
00ad8     00 AC 0D F2 |             cmp     dt0,#0 wz                ' now push dt0 samples to the buffer
00adc     60 FE 9F AD |     if_z    jmp     #loop1
00ae0     D6 7C 01 F6 |             mov     qq,dt0
00ae4                 |   
00ae4     FF F3 97 F9 | p301        alts    ptrb,#511                ' checking if the buffer is full - Wuerfel_21's magic stuff
00ae8     00 7A 9D F2 |             cmpr    front, #0-0 wcz
00aec     F4 FF 9F AD |     if_e    jmp     #p301    
00af0                 | 		
00af0     00 C2 0D F2 | 	    cmp     scbase,#0 wz
00af4     20 00 90 AD |     if_z    jmp #p302	   
00af8                 |  
00af8                 |  
00af8     3F C8 15 F7 |             incmod  scope,#63 wc            ' save every 127th sample to the scope buffer
00afc     E2 C6 01 C6 |     if_c    mov scptr2,scptr
00b00     02 C6 65 C0 |     if_c    shl scptr2,#2
00b04     E1 C6 01 C1 |     if_c    add scptr2,scbase     
00b08     60 C6 65 FC |             wrlong scptr2,#$60
00b0c     E3 BA 61 CC |     if_c    wrlong oldsample,scptr2
00b10     01 00 00 CF 
00b14     7F C4 05 C7 |     if_c    incmod scptr,##639
00b18                 | 			    
00b18     BD BA 31 FC | p302        wrlut   oldsample, front        ' if there is a free slot, put the sample into the buffer
00b1c     00 00 00 FF 
00b20     FF 7B 05 F7 |             incmod  front, ##511
00b24     EF 7D 6D FB |             djnz    qq,#p301
00b28                 |             
00b28     FC FD 9F FD |             jmp     #loop            'loop
00b2c                 | 
00b2c                 | '----------------------------------------------------------------------------------
00b2c                 | '------------- This is the end of the main loop -----------------------------------
00b2c                 | '----------------------------------------------------------------------------------
00b2c                 | 
00b2c                 | '----------------------------------------------------------------------------------
00b2c                 | '------------- PSRAM cache ----------- --------------------------------------------
00b2c                 | '----------------------------------------------------------------------------------
00b2c                 | 
00b2c                 | ' There are 8 cache pointers for 8 channels
00b2c                 | ' if 24 higher bits of address=cache, then ger a word from the cache
00b2c                 | ' else load the cache from PSRAM, update the pointer, then read a sample
00b2c                 | 
00b2c                 | 
00b2c     BE E6 E1 F8 | cache_read  getbyte addrlo,qq,#0 		' when this is called, qq is the addres of the sample			
00b30                 |             
00b30     BE E8 01 F6 | 	    mov     addrhi,qq		
00b34     08 E8 45 F0 | 	    shr     addrhi,#8		        ' get 24 upper bits
00b38     E8 A8 95 F9 | 	    alts    cn,#cache1            
00b3c     00 E8 09 F2 | 	    cmp	    addrhi,0-0 wz               ' and compare with the cache pointer for the channel
00b40     34 00 90 AD |     if_z    jmp     #p701	    		' if equal, cache hit, read the sample from it
00b44                 | 	
00b44     E8 A8 8D F9 | p702	    altd    cn,#cache1			' cache miss. 
00b48     F4 00 00 F6 | 	    mov     0-0,addrhi                  ' update the pointer
00b4c     F4 E0 01 F6 | 	    mov     cmd,addrhi			' prepare the mailbox
00b50     08 E0 65 F0 | 	    shl     cmd,#8
00b54     0B E0 3D F8 |             setnib  cmd, #%1011, #7             ' read burst from the external memory
00b58     D4 E2 01 F6 |             mov     hubaddr,cn                  ' to the channel cache
00b5c     08 E2 65 F0 |             shl     hubaddr,#8                  '
00b60     E7 E2 01 F1 |             add     hubaddr,hubptr 
00b64     00 E5 05 F6 |             mov     count,#256                  ' 256 bytes
00b68     28 04 64 FD |             setq    #2                          ' write 3 longs
00b6c     C1 E0 61 FC |             wrlong  cmd, mailbox                ' run it
00b70     C1 E0 01 FB | poll1       rdlong  cmd, mailbox                ' poll mailbox for result
00b74     FE E1 B5 FB |             tjs     cmd, #poll1                 ' retry until valid 
00b78                 |             
00b78                 | 	
00b78     D4 7C 01 F6 | p701	    mov     qq,cn			' cache hit
00b7c     08 7C 65 F0 | 	    shl     qq,#8			' compute the cache start
00b80     E7 7C 01 F1 | 	    add     qq,hubptr
00b84     F3 7C 01 F1 | 	    add	    qq,addrlo			' add 8 lower bits to the cache addredd
00b88     BE 7E E1 0A |     _ret_   rdword  spl,qq                      ' read a word
00b8c                 |           
00b8c                 | 
00b8c                 | '--------------------------------------------------------------------------
00b8c                 | '------ Interrupt service -------------------------------------------------
00b8c                 | '------ Output the sample, get the next one if exists ---------------------
00b8c                 | '--------------------------------------------------------------------------
00b8c                 | 
00b8c     0E 86 25 FC | isr1        wypin   lsample,#left        '2     The sample has to be outputted every 100 cycles     
00b90     0F 88 25 FC |             wypin   rsample,#right       '4
00b94     BD F2 1B F2 |             cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
00b98     80 8B A5 5A |     if_ne   rdlut   lsnext,ptrb          '11    else read the sample and its time from LUT
00b9c     FF F3 07 57 |     if_ne   incmod  ptrb,#511
00ba0     C5 88 39 59 |     if_ne   getword rsample,lsnext,#1    '13
00ba4     C5 86 31 59 |     if_ne   getword lsample,lsnext,#0    '15
00ba8                 |     
00ba8     F5 FF 3B FB |             reti1                        '17/19 
00bac                 |           
00bac                 | '---------------------------------------------------------------------------
00bac                 | '-------- End of interrupt -------------------------------------------------
00bac                 | '---------------------------------------------------------------------------    
00bac                 | 
00bac                 | 
00bac                 | '---------------------------------------------------------------------------
00bac                 | '------- Variables ---------------------------------------------------------
00bac                 | '---------------------------------------------------------------------------
00bac                 | 
00bac                 | ' constants
00bac                 | 
00bac     00 00 00 40 | a40000000   long $40000000
00bb0     00 00 00 41 | a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before
00bb4                 | 
00bb4                 | ' Time variables
00bb4                 | 
00bb4     00 00 00 00 | time0       long 0    ' Global sample computing time
00bb8     01 00 00 00 | time1       long 1    ' Local channels time
00bbc     02 00 00 00 | time2       long 2
00bc0     03 00 00 00 | time3       long 3
00bc4     04 00 00 00 | time4       long 4
00bc8     05 00 00 00 | time5       long 5
00bcc     06 00 00 00 | time6       long 6
00bd0     07 00 00 00 | time7       long 7
00bd4     08 00 00 00 | time8       long 8
00bd8                 | 
00bd8     00 00 00 00 | channeladd long 0
00bdc                 | 
00bdc     00 00 00 00 | front       long 0
00be0                 | 
00be0                 | ' temporary variables 
00be0     00 00 00 00 | qq          long 0
00be4     00 00 00 00 | spl         long 0
00be8     00 00 00 00 | zero        long 0
00bec     00 00 00 00 | mailbox     long 0
00bf0     00 00 00 00 | mailbox2 long 0
00bf4                 | 
00bf4                 | ' Interrupt ISR variables
00bf4                 | 
00bf4     00 00 00 00 | lsample     long 0
00bf8     00 00 00 00 | rsample     long 0
00bfc     00 00 00 00 | lsnext      long 0
00c00     00 00 00 00 | rsnext      long 0 
00c04                 | 
00c04                 | ' channel parameter block
00c04                 | 
00c04     00 00 00 00 | pointer0    long 0     
00c08     00 00 00 00 | sample0     long 0
00c0c     00 00 00 00 | sstart0     long 0     ' start pointer and type at bit 31
00c10     00 00 00 00 | lstart0     long 0
00c14     00 00 00 00 | lend0       long 0
00c18     00 00 00 00 | volpan0     long 0
00c1c     00 00 00 00 | freqskip0   long 0
00c20     00 00 00 00 | command0    long 0
00c24                 | 
00c24     00 00 00 00 | afreq0      long 0
00c28     00 00 00 00 | askip0      long 0
00c2c     00 00 00 00 | avol0       long 0
00c30     00 00 00 00 | apan0       long 0
00c34                 | 
00c34     FF FF FF FF | oldt0       long $FFFFFFFF    'Temporary time variables
00c38     00 00 00 00 | cn          long 0
00c3c     00 00 00 00 | ct          long 0
00c40     00 00 00 00 | dt0         long 0
00c44                 | 
00c44                 | ' Samples
00c44     00 00 00 00 | oldls       long 0
00c48     00 00 00 00 | oldrs       long 0
00c4c                 | 
00c4c     00 00 00 00 | ls0         long 0
00c50     00 00 00 00 | rs0         long 0
00c54                 | 
00c54     00 00 00 00 | ls          long 0    
00c58     00 00 00 00 | rs          long 0
00c5c                 | 
00c5c     00 00 00 00 | oldsample   long 0
00c60     00 00 00 00 | newsample   long 0
00c64                 | 
00c64     00 00 00 00 | nrsample    long 0
00c68     00 00 00 00 | nlsample    long 0
00c6c                 | 
00c6c     00 00 00 00 | scbase long 0
00c70     00 00 00 00 | scptr long 0
00c74     00 00 00 00 | scptr2 long 0
00c78     00 00 00 00 | scope long 0
00c7c                 | 
00c7c     44 00 17 00 | dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
00c80     46 00 17 00 | dac2        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   
00c84                 | 
00c84     00 18 07 00 | hubptr      long $71800
00c88     00 00 00 00 | cache1      long 0
00c8c     00 00 00 00 | cache2      long 0
00c90     00 00 00 00 | cache3      long 0
00c94     00 00 00 00 | cache4      long 0
00c98     00 00 00 00 | cache5      long 0
00c9c     00 00 00 00 | cache6      long 0
00ca0     00 00 00 00 | cache7      long 0
00ca4     00 00 00 00 | cache8      long 0
00ca8                 | 
00ca8                 | 
00ca8     00 00 00 00 | cmd         long 0
00cac     00 00 00 00 | hubaddr     long 0
00cb0     00 01 00 00 | count       long 256
00cb4     00 00 00 00 | addrlo long 0
00cb8     00 00 00 00 | addrhi long 0
00cbc     00 00 00 00 | pointer00 long 0
00cc0     00 00 00 00 
00cc4     00 00 00 00 | null  			long 	0,0           ' for channel reset
00cc8                 | objmem
00cc8     00 00 00 00 
      ...             
00dcc     00 00 00 00 
00dd0     00 00 00 00 | 	long	0[67]
00dd4                 | stackspace
00dd4     00 00 00 00 | 	long	0[1]
00dd8 0bf             | 	org	COG_BSS_START
00dd8 0bf             | _var01
00dd8 0bf             | 	res	1
00dd8 0c0             | _var02
00dd8 0c0             | 	res	1
00dd8 0c1             | _var03
00dd8 0c1             | 	res	1
00dd8 0c2             | arg01
00dd8 0c2             | 	res	1
00dd8 0c3             | arg02
00dd8 0c3             | 	res	1
00dd8 0c4             | arg03
00dd8 0c4             | 	res	1
00dd8 0c5             | arg04
00dd8 0c5             | 	res	1
00dd8 0c6             | local01
00dd8 0c6             | 	res	1
00dd8 0c7             | local02
00dd8 0c7             | 	res	1
00dd8 0c8             | local03
00dd8 0c8             | 	res	1
00dd8 0c9             | local04
00dd8 0c9             | 	res	1
00dd8 0ca             | 	fit	480
00dd8 0ca             | 
