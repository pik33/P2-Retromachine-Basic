00000                 | 
00000                 | #line 1 "D:/Programowanie/P2-Retromachine-Basic/audio093b-8-sc.p2asm"
00000                 | con
00000                 | 	_clkfreq = 20000000
00000                 | 	_clkmode = 16779595
00000                 | ' 
00000                 | ' 
00000                 | ' left= 14
00000                 | 	left = 14
00000                 | ' right=15
00000                 | 	right = 15
00000                 | ' 
00000                 | ' c4=262
00000                 | 	c4 = 262
00000                 | ' d4=294
00000                 | 	d4 = 294
00000                 | ' e4=330
00000                 | 	e4 = 330
00000                 | ' f4=349
00000                 | 	f4 = 349
00000                 | ' g4=392
00000                 | 	g4 = 392
00000                 | ' a4=440
00000                 | 	a4 = 440
00000                 | ' h4=494
00000                 | 	h4 = 494
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 20000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $100094b
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 7A 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 02 90 5D |  if_ne	jmp	#spininit
0040c 002 BC F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 01 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 04 80 80 FF 
00420 007 00 90 66 FD | 	hubset	##16779592
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 04 80 00 FF 
00430 00b 4B ED 07 F6 | 	mov	pa, ##16779595
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 96 98 80 FF 
00440 00f 14 00 6E FC | 	wrlong	##20000000, #20
00444 010 BC 01 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
005fc 07e 00 00 00 00 
00600 07f 00 00 00 00 | 	orgf	128
00604 080             | skip_clock_set_
00604 080 00 07 A0 FD | 	call	#_start
00608 081             | cogexit
00608 081 38 01 80 FF 
0060c 082 1F 00 66 FD | 	waitx	##160000
00610 083 01 84 61 FD | 	cogid	arg01
00614 084 03 84 61 FD | 	cogstop	arg01
00618 085             | spininit
00618 085 61 75 05 FB | 	rdlong	objptr, ptra++
0061c 086 61 7B 05 FB | 	rdlong	result1, ptra++
00620 087 28 06 64 FD | 	setq	#3
00624 088 00 85 05 FB | 	rdlong	arg01, ptra
00628 089 04 F0 87 F1 | 	sub	ptra, #4
0062c 08a 2D 7A 61 FD | 	call	result1
00630 08b D4 FF 9F FD | 	jmp	#cogexit
00634 08c             | FCACHE_LOAD_
00634 08c F9 2D 01 F6 |     mov	fcache_tmpb_,ptrb
00638 08d 2B F2 63 FD |     pop	ptrb
0063c 08e 95 EC 8B F9 |     altd	pa,ret_instr_
00640 08f 95 00 00 F6 |     mov	 0-0, ret_instr_
00644 090 28 EC 63 FD |     setq	pa
00648 091 E1 01 04 FB |     rdlong	$0, ptrb++
0064c 092 2A F2 63 FD |     push	ptrb
00650 093 96 F2 03 F6 |     mov ptrb,fcache_tmpb_
00654 094 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00658 095             | ret_instr_
00658 095 00 FE 07 02 |     _ret_ cmp inb,#0
0065c 096             | fcache_tmpb_
0065c 096 00 00 00 00 |     long 0
00660 097             | fcache_load_ptr_
00660 097 8C 00 00 00 |     long FCACHE_LOAD_
00664 098             | builtin_bytefill_
00664 098 01 88 55 F0 |         shr	arg03, #1 wc
00668 099 C2 86 41 CC |  if_c   wrbyte	arg02, arg01
0066c 09a 01 84 05 C1 |  if_c   add	arg01, #1
00670 09b 00 86 FD F9 |         movbyts	arg02, #0
00674 09c             | builtin_wordfill_
00674 09c 01 88 55 F0 |         shr	arg03, #1 wc
00678 09d C2 86 51 CC |  if_c   wrword	arg02, arg01
0067c 09e 02 84 05 C1 |  if_c   add	arg01, #2
00680 09f C3 86 29 F9 |         setword	arg02, arg02, #1
00684 0a0             | builtin_longfill_
00684 0a0 C2 00 88 FC |         wrfast	#0,arg01
00688 0a1 00 88 0D F2 |         cmp	arg03, #0 wz
0068c 0a2 C4 02 D8 5C |  if_nz  rep	#1, arg03
00690 0a3 17 86 61 5D |  if_nz  wflong	arg02
00694 0a4 2D 00 64 FD |         ret
00698 0a5             | COUNT_
00698 0a5 00 00 00 00 |     long 0
0069c 0a6             | RETADDR_
0069c 0a6 00 00 00 00 |     long 0
006a0 0a7             | fp
006a0 0a7 00 00 00 00 |     long 0
006a4 0a8             | pushregs_
006a4 0a8 2B EC 63 FD |     pop  pa
006a8 0a9 2B 4C 61 FD |     pop  RETADDR_
006ac 0aa 03 4A 95 FB |     tjz  COUNT_, #pushregs_done_
006b0 0ab FF 4B 8D F9 |     altd  COUNT_, #511
006b4 0ac 28 00 64 FD |     setq #0-0
006b8 0ad 61 8D 65 FC |     wrlong local01, ptra++
006bc 0ae             | pushregs_done_
006bc 0ae 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
006c0 0af 61 4B 65 FC |     wrlong COUNT_, ptra++
006c4 0b0 F8 4F 01 F6 |     mov    fp, ptra
006c8 0b1 2C EC 63 FD |     jmp  pa
006cc 0b2             |  popregs_
006cc 0b2 2B EC 63 FD |     pop    pa
006d0 0b3 28 04 64 FD |     setq   #2
006d4 0b4 5F 4B 05 FB |     rdlong COUNT_, --ptra
006d8 0b5 02 4A 75 FB |     djf    COUNT_, #popregs__ret
006dc 0b6 28 4A 61 FD |     setq   COUNT_
006e0 0b7 5F 8D 05 FB |     rdlong local01, --ptra
006e4 0b8             | popregs__ret
006e4 0b8 2A 4C 61 FD |     push   RETADDR_
006e8 0b9 2C EC 63 FD |     jmp    pa
006ec 0ba             | 
006ec 0ba             | objptr
006ec 0ba 54 0D 00 00 | 	long	@objmem
006f0 0bb             | ptr__dat__
006f0 0bb 48 09 00 00 | 	long	@_dat_
006f4 0bc             | ptr_stackspace_
006f4 0bc 60 0F 00 00 | 	long	@stackspace
006f8 0bd             | result1
006f8 0bd 00 00 00 00 | 	long	0
006fc 0be             | result2
006fc 0be 01 00 00 00 | 	long	1
00700 0bf             | COG_BSS_START
00700 0bf             | 	fit	480
00700                 | 	orgh
00700                 | hubentry
00700                 | 
00700                 | ' 
00700                 | ' 
00700                 | ' '--------------------------------------------------------------
00700                 | ' '---------- Init the variables, start the cog. ----------------
00700                 | ' '--------------------------------------------------------------
00700                 | ' 
00700                 | ' pub start(mbox,scope,cache) :cog,base | iii
00700                 | _start
00700     04 4A 05 F6 | 	mov	COUNT_, #4
00704     A8 00 A0 FD | 	call	#pushregs_
00708     C2 8C 01 F6 | 	mov	local01, arg01
0070c                 | ' 
0070c                 | ' ' mbox: PSRAM mailbox or 0 if no PSRAM
0070c                 | ' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
0070c                 | ' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
0070c                 | ' 
0070c                 | ' mailboxaddr:=mbox 
0070c     BA 8C 61 FC | 	wrlong	local01, objptr
00710                 | ' scope_ptr:=scope
00710     04 74 05 F1 | 	add	objptr, #4
00714     BA 86 61 FC | 	wrlong	arg02, objptr
00718                 | ' cache_ptr:=cache
00718     04 74 05 F1 | 	add	objptr, #4
0071c     BA 88 61 FC | 	wrlong	arg03, objptr
00720                 | ' base:=@channel1[0]
00720     04 74 05 F1 | 	add	objptr, #4
00724     BA 8E 01 F6 | 	mov	local02, objptr
00728                 | ' 
00728                 | ' repeat iii from 0 to 7
00728     00 90 05 F6 | 	mov	local03, #0
0072c     02 00 00 FF 
00730     04 76 05 F1 | 	add	ptr__dat__, ##1028
00734     0C 74 85 F1 | 	sub	objptr, #12
00738     97 B0 48 FB | 	callpa	#(@LR__0002-@LR__0001)>>2,fcache_load_ptr_
0073c                 | LR__0001
0073c                 | '   long[base+64*iii]:=0
0073c     C7 8C 01 F6 | 	mov	local01, local02
00740     C8 7C 01 F6 | 	mov	result2, local03
00744     06 7C 65 F0 | 	shl	result2, #6
00748     BE 8C 01 F1 | 	add	local01, result2
0074c     C6 00 68 FC | 	wrlong	#0, local01
00750                 | '   long[base+64*iii+4]:=0
00750     C7 8C 01 F6 | 	mov	local01, local02
00754     C8 7C 01 F6 | 	mov	result2, local03
00758     06 7C 65 F0 | 	shl	result2, #6
0075c     BE 8C 01 F1 | 	add	local01, result2
00760     04 8C 05 F1 | 	add	local01, #4
00764     C6 00 68 FC | 	wrlong	#0, local01
00768                 | '   long[base+64*iii+12]:=0
00768     C7 92 01 F6 | 	mov	local04, local02
0076c     C8 8C 01 F6 | 	mov	local01, local03
00770     06 8C 65 F0 | 	shl	local01, #6
00774     C6 92 01 F1 | 	add	local04, local01
00778     0C 92 05 F1 | 	add	local04, #12
0077c     C9 00 68 FC | 	wrlong	#0, local04
00780                 | '   long[base+64*iii+16]:=2 
00780     C7 92 01 F6 | 	mov	local04, local02
00784     C8 8C 01 F6 | 	mov	local01, local03
00788     06 8C 65 F0 | 	shl	local01, #6
0078c     C6 92 01 F1 | 	add	local04, local01
00790     10 92 05 F1 | 	add	local04, #16
00794     C9 04 68 FC | 	wrlong	#2, local04
00798                 | '   word[base+64*iii+20]:=0
00798     C7 92 01 F6 | 	mov	local04, local02
0079c     C8 8C 01 F6 | 	mov	local01, local03
007a0     06 8C 65 F0 | 	shl	local01, #6
007a4     C6 92 01 F1 | 	add	local04, local01
007a8     14 92 05 F1 | 	add	local04, #20
007ac     C9 00 58 FC | 	wrword	#0, local04
007b0                 | '   word[base+64*iii+22]:=8192
007b0     C7 92 01 F6 | 	mov	local04, local02
007b4     C8 8C 01 F6 | 	mov	local01, local03
007b8     06 8C 65 F0 | 	shl	local01, #6
007bc     C6 92 01 F1 | 	add	local04, local01
007c0     16 92 05 F1 | 	add	local04, #22
007c4     10 00 80 FF 
007c8     C9 00 58 FC | 	wrword	##8192, local04
007cc                 | '   word[base+64*iii+24]:=4000+2*iii
007cc     C8 92 01 F6 | 	mov	local04, local03
007d0     01 92 65 F0 | 	shl	local04, #1
007d4     07 00 00 FF 
007d8     A0 8D 05 F6 | 	mov	local01, ##4000
007dc     C9 8C 01 F1 | 	add	local01, local04
007e0     C7 92 01 F6 | 	mov	local04, local02
007e4     C8 7C 01 F6 | 	mov	result2, local03
007e8     06 7C 65 F0 | 	shl	result2, #6
007ec     BE 92 01 F1 | 	add	local04, result2
007f0     18 92 05 F1 | 	add	local04, #24
007f4     C9 8C 51 FC | 	wrword	local01, local04
007f8                 | '   word[base+64*iii+26]:=2
007f8     C7 92 01 F6 | 	mov	local04, local02
007fc     C8 8C 01 F6 | 	mov	local01, local03
00800     06 8C 65 F0 | 	shl	local01, #6
00804     C6 92 01 F1 | 	add	local04, local01
00808     1A 92 05 F1 | 	add	local04, #26
0080c     C9 04 58 FC | 	wrword	#2, local04
00810                 | '   long [base+64*iii+8]:=@null | $C0000000
00810     BB 8C 01 F6 | 	mov	local01, ptr__dat__
00814     3E 8C 25 F4 | 	bith	local01, #62
00818     C7 92 01 F6 | 	mov	local04, local02
0081c     C8 88 01 F6 | 	mov	arg03, local03
00820     06 88 65 F0 | 	shl	arg03, #6
00824     C4 92 01 F1 | 	add	local04, arg03
00828     08 92 05 F1 | 	add	local04, #8
0082c     C9 8C 61 FC | 	wrlong	local01, local04
00830                 | '   long[base+64*iii+32]:=0
00830     C7 92 01 F6 | 	mov	local04, local02
00834     C8 8C 01 F6 | 	mov	local01, local03
00838     06 8C 65 F0 | 	shl	local01, #6
0083c     C6 92 01 F1 | 	add	local04, local01
00840     20 92 05 F1 | 	add	local04, #32
00844     C9 00 68 FC | 	wrlong	#0, local04
00848                 | '   long[base+64*iii+36]:=0
00848     C7 92 01 F6 | 	mov	local04, local02
0084c     C8 8C 01 F6 | 	mov	local01, local03
00850     06 8C 65 F0 | 	shl	local01, #6
00854     C6 92 01 F1 | 	add	local04, local01
00858     24 92 05 F1 | 	add	local04, #36
0085c     C9 00 68 FC | 	wrlong	#0, local04
00860                 | '   long[base+64*iii+40]:=0
00860     C7 92 01 F6 | 	mov	local04, local02
00864     C8 8C 01 F6 | 	mov	local01, local03
00868     06 8C 65 F0 | 	shl	local01, #6
0086c     C6 92 01 F1 | 	add	local04, local01
00870     28 92 05 F1 | 	add	local04, #40
00874     C9 00 68 FC | 	wrlong	#0, local04
00878                 | '   long[base+64*iii+44]:=0
00878     C7 92 01 F6 | 	mov	local04, local02
0087c     C8 8C 01 F6 | 	mov	local01, local03
00880     06 8C 65 F0 | 	shl	local01, #6
00884     C6 92 01 F1 | 	add	local04, local01
00888     2C 92 05 F1 | 	add	local04, #44
0088c     C9 00 68 FC | 	wrlong	#0, local04
00890     01 90 05 F1 | 	add	local03, #1
00894     08 90 55 F2 | 	cmps	local03, #8 wc
00898     A0 FE 9F CD |  if_b	jmp	#LR__0001
0089c                 | LR__0002
0089c     02 00 00 FF 
008a0     04 76 85 F1 | 	sub	ptr__dat__, ##1028
008a4                 | '   
008a4                 | ' cog:=coginit(16,@audio,@mailboxaddr)
008a4     BB 86 01 F6 | 	mov	arg02, ptr__dat__
008a8     BA 88 01 F6 | 	mov	arg03, objptr
008ac     10 92 05 F6 | 	mov	local04, #16
008b0     28 88 61 FD | 	setq	arg03
008b4     C3 92 F1 FC | 	coginit	local04, arg02 wc
008b8     01 92 65 C6 |  if_b	neg	local04, #1
008bc                 | ' waitms(100)
008bc     64 84 05 F6 | 	mov	arg01, #100
008c0     18 00 B0 FD | 	call	#__system___waitms
008c4                 | ' return cog,base
008c4     C7 7C 01 F6 | 	mov	result2, local02
008c8     C9 7A 01 F6 | 	mov	result1, local04
008cc     A7 F0 03 F6 | 	mov	ptra, fp
008d0     B2 00 A0 FD | 	call	#popregs_
008d4                 | _start_ret
008d4     2D 00 64 FD | 	ret
008d8                 | hubexit
008d8     81 00 80 FD | 	jmp	#cogexit
008dc                 | 
008dc                 | __system___waitms
008dc     C2 7E 01 F6 | 	mov	_var01, arg01
008e0     1A 80 61 FD | 	getct	_var02
008e4     14 82 05 FB | 	rdlong	_var03, #20
008e8     97 14 48 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
008ec                 | LR__0010
008ec     01 00 00 FF 
008f0     E8 7F 55 F2 | 	cmps	_var01, ##1000 wc
008f4     1C 00 90 CD |  if_b	jmp	#LR__0012
008f8     C1 80 01 F1 | 	add	_var02, _var03
008fc     C0 84 01 F6 | 	mov	arg01, _var02
00900     00 84 65 FA | 	addct1	arg01, #0
00904     24 22 60 FD | 	waitct1
00908     01 00 00 FF 
0090c     E8 7F 85 F1 | 	sub	_var01, ##1000
00910     D8 FF 9F FD | 	jmp	#LR__0010
00914                 | LR__0011
00914                 | LR__0012
00914     01 7E 55 F2 | 	cmps	_var01, #1 wc
00918     28 00 90 CD |  if_b	jmp	#LR__0013
0091c     C1 7E 01 FD | 	qmul	_var01, _var03
00920     01 00 00 FF 
00924     E8 89 05 F6 | 	mov	arg03, ##1000
00928     19 7A 61 FD | 	getqy	result1
0092c     18 84 61 FD | 	getqx	arg01
00930     28 7A 61 FD | 	setq	result1
00934     C4 84 11 FD | 	qdiv	arg01, arg03
00938     18 84 61 FD | 	getqx	arg01
0093c     C0 84 61 FA | 	addct1	arg01, _var02
00940     24 22 60 FD | 	waitct1
00944                 | LR__0013
00944                 | __system___waitms_ret
00944     2D 00 64 FD | 	ret
00948                 | 	alignl
00948                 | _dat_
00948                 | 
00948                 | audio       org     0
00948                 | 
00948     61 8B 05 FB |             rdlong  mailbox2, ptra++     ' get start address of all mailboxes
0094c     61 D9 05 FB |             rdlong  scbase, ptra++       ' get start address of scope buffer
00950     61 E5 05 FB |             rdlong  hubptr, ptra++       ' get start address of PSRAM cache
00954                 | 
00954     01 EC 63 FD |             cogid   pa                   ' compute cogid
00958     0C EC 07 FA |             mul     pa, #12              ' and mailbox spacing
0095c     F6 8B 01 F1 |             add     mailbox2, pa         ' add offset to find this COG's mailbox
00960     C5 88 01 F6 |             mov     mailbox,mailbox2     ' we need 2 copies of this to ensble switching between hub and psram
00964                 | 
00964     00 F2 07 F6 |             mov     ptrb,#0              ' A tail pointer for the buffer
00968     0E E0 05 FC |             wrpin   dac,#left            ' Noise dither DACs at clk/95
0096c     0E BE 1C FC |             wxpin   #95,#left       	 ' Set initial DACs sample rate. It is now controlled via a register by the main program
00970     0F E0 05 FC |             wrpin   dac,#right
00974     0F BE 1C FC |             wxpin   #95,#right    
00978     41 9C 64 FD |             dirh    #left addpins 1
0097c     20 9C 64 FD |             setse1  #%001<<6 + left      ' Set the event - DAC empty
00980     AC E8 07 F6 |             mov     ijmp1,#isr1          ' Init the interrupt
00984     25 08 64 FD |             setint1 #4                   ' Interrupt from DAC empty event
00988                 |             
00988                 | '---------------------------------------------------------------------------------        
00988                 | '----------------- The main loop -------------------------------------------------
00988                 | '---------------------------------------------------------------------------------
00988                 | 
00988     B5 6C 11 F2 | loop        cmp     time0,a41000000 wc  ' time counter overflow protection
0098c     10 00 90 CD |       if_c  jmp     #loop1
00990                 |   
00990     09 BE 05 F6 |             mov     cn,#9               ' Substract $40000000 from all the channel times and the main timer
00994     B5 BE 8D F9 | p402        altd    cn,#a41000000       ' this has to be done at once for all channels
00998     B4 00 80 F1 |             sub     0-0,a40000000
0099c     FD BF 6D FB |             djnz    cn,#p402
009a0                 |     
009a0     00 BE 05 F6 | loop1       mov     cn,#0               ' Find the channel to compute
009a4     B7 C0 01 F6 |             mov     ct,time1            ' with the lowest next sample time
009a8     B8 C0 39 F3 |             fle     ct,time2 wcz        ' How to size-optimize this???
009ac     01 BE 05 C6 |     if_c    mov     cn,#1
009b0     B9 C0 39 F3 |             fle     ct,time3 wcz
009b4     02 BE 05 C6 |     if_c    mov     cn,#2     
009b8     BA C0 39 F3 |             fle     ct,time4 wcz
009bc     03 BE 05 C6 |     if_c    mov     cn,#3
009c0     BB C0 39 F3 |             fle     ct,time5 wcz
009c4     04 BE 05 C6 |     if_c    mov     cn,#4
009c8     BC C0 39 F3 |             fle     ct,time6 wcz
009cc     05 BE 05 C6 |     if_c    mov     cn,#5
009d0     BD C0 39 F3 |             fle     ct,time7 wcz
009d4     06 BE 05 C6 |     if_c    mov     cn,#6
009d8     BE C0 39 F3 |             fle     ct,time8 wcz
009dc     07 BE 05 C6 |     if_c    mov     cn,#7
009e0                 | 
009e0                 | 
009e0                 | '----------------------------------------------------------------------------------
009e0                 | '------------- Compute channel samples --------------------------------------------
009e0                 | '----------------------------------------------------------------------------------
009e0                 | 
009e0                 | 
009e0     DF 7E 01 F6 | p401        mov     channeladd,cn             ' compute the pointer to channel parameters block
009e4     06 7E 65 F0 |             shl     channeladd,#6
009e8     BF F0 03 F1 |             add     ptra,channeladd
009ec                 | 
009ec     28 16 64 FD |             setq    #11                        ' read parameters
009f0     00 95 05 FB |             rdlong  pointer0,ptra
009f4                 |     	    
009f4     1F A2 0D F4 | p408        testb   command0,#31 wz	      ' bit #31 command - set the DAC sample rate
009f8     18 00 90 5D |     if_nz   jmp     #p404                     ' if not set, proceed
009fc     D1 82 31 F9 |             getword qq,command0,#0            ' get the new rate
00a00     4E 82 15 FC |             wxpin   qq,#left addpins 1        ' and program the pins
00a04     C1 82 E1 F8 |             getbyte qq,qq,#0 		      ' check if the rate is n*256
00a08     00 82 0D F2 |             cmp     qq,#0 wz                         
00a0c     4E E2 05 AC |     if_z    wrpin   dac2,#left addpins 1      ' if yes, set PWM DAC mode
00a10     4E E0 05 5C |     if_nz   wrpin   dac,#left addpins 1       ' else set noise DAC mode
00a14                 |             
00a14     1E A2 1D F4 | p404        bitl    command0,#30 wcz             ' bit #30: select PSRAM/HUB
00a18     C5 88 01 56 |     if_nz   mov     mailbox,mailbox2             ' if not set, use PSRAM
00a1c     00 88 05 A6 |     if_z    mov     mailbox,#0                   ' if set, use HUB : TODO: this can be done at a channel level!
00a20                 | 
00a20                 | 
00a20     CB C4 31 F9 | p405        getword oldls,sample0,#0          ' extract old sample value
00a24     CB C6 39 F9 |             getword oldrs,sample0,#1
00a28     CF BA 39 F9 |      	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
00a2c     CF B8 31 F9 |     	    getword avol0,volpan0,#0
00a30     D0 B6 39 F9 |             getword askip0,freqskip0,#1    	    
00a34     D0 B4 31 F9 |             getword afreq0,freqskip0,#0
00a38                 | 
00a38     B7 BE 95 F9 |             alts    cn, #time1                ' compute the time difference between this and previous sample
00a3c     00 C2 01 F6 |             mov     dt0,0-0    
00a40     B6 C2 81 F1 |             sub     dt0,time0
00a44                 |             
00a44     B7 BE 8D F9 |             altd    cn, #time1                ' add channel period to channel time
00a48     DA 00 00 F1 |             add     0-0,afreq0  	
00a4c                 | 
00a4c     DA A4 01 F1 | 	    add	    envph0,afreq0
00a50                 | 
00a50     DB 94 01 F1 |             add     pointer0,askip0           ' compute the pointer to the next sample       
00a54     CA 00 C2 F8 |             setbyte pointer00,pointer0,#0
00a58     08 94 45 F0 |             shr     pointer0,#8
00a5c                 |          
00a5c     1F 98 0D F4 |             testb   sstart0,#31 wz            
00a60     01 94 65 A0 |     if_z    shl     pointer0,#1        
00a64     1C 98 0D F4 |             testb   sstart0,#28 wz            
00a68     01 94 65 A0 |     if_z    shl     pointer0,#1        
00a6c                 |             
00a6c     CE 94 19 F2 |             cmp     pointer0,lend0 wcz
00a70     CE 94 81 31 |     if_ge   sub     pointer0,lend0	      ' and loop if needed     
00a74     CD 94 01 31 |     if_ge   add     pointer0,lstart0       
00a78                 |             
00a78     CA 82 01 F6 |             mov     qq,pointer0               ' compute place in the memory from where the sample will be loaded
00a7c     CC 82 01 F1 |             add     qq,sstart0            
00a80                 | 
00a80                 | 
00a80                 | 
00a80     FF 89 5D F2 |             cmps    mailbox,#$1FF wcz            ' the mailbox has to point somewhere not at the start of HUB RAM
00a84     C1 84 E1 EA |     if_le   rdword  spl,qq                     ' if not, use HUB RAM for samples
00a88     0C 01 B0 1D |     if_gt   call    #cache_read
00a8c                 |          
00a8c                 |          
00a8c                 |  
00a8c                 |          
00a8c     1F 98 0D F4 |             testb   sstart0,#31 wz 
00a90     08 84 65 50 |     if_nz   shl     spl,#8
00a94     08 94 65 50 |     if_nz   shl     pointer0,#8
00a98     07 94 65 A0 |     if_z    shl     pointer0,#7
00a9c     1C 98 0D F4 |             testb   sstart0,#28 wz            
00aa0     01 94 45 A0 |     if_z    shr     pointer0,#1    
00aa4     00 95 C1 F8 | 	    setbyte pointer0,pointer00,#0       
00aa8                 |     
00aa8                 | 
00aa8     DC 84 31 FA | p406        scas    spl,avol0                 ' apply volume
00aac     00 84 01 F6 |             mov     spl,0-0
00ab0                 |  
00ab0     DD 84 31 FA |             scas    spl,apan0                 ' apply pan
00ab4     00 C8 01 F6 |             mov     ls0,0-0
00ab8     20 00 00 FF 
00abc     00 82 05 F6 |             mov     qq,##16384
00ac0     DD 82 81 F1 |             sub     qq,apan0
00ac4     C1 84 31 FA |             scas    spl,qq
00ac8     00 CA 01 F6 |             mov     rs0, 0-0
00acc                 | 
00acc     E3 CE 81 F1 |             sub     rs,oldrs 		      ' replace the old sample with the new one in the mix
00ad0     E5 CE 01 F1 |             add     rs,rs0
00ad4     E2 CC 81 F1 |             sub     ls,oldls
00ad8     E4 CC 01 F1 |             add     ls,ls0
00adc                 |    
00adc     E5 96 29 F9 |             setword sample0,rs0,#1           ' pack samples into long
00ae0     E4 96 21 F9 |             setword sample0,ls0,#0
00ae4                 |             
00ae4     1E 98 1D F4 |             bitl    sstart0, #30 wcz          ' if bit #30 of start pointer is set, the current pointers needs resetting  
00ae8     00 94 05 A6 |     if_z    mov     pointer0, #0  
00aec     00 A4 05 A6 |     if_z    mov     envph0, #0  
00af0     02 99 65 AC |     if_z    wrlong  sstart0, ptra[2]          ' reset bit #30 in hub
00af4     1D 98 1D F4 |             bitl    sstart0, #29 wcz	      ' if bit #29 is set, synchronize stereo at channels 1 and 2
00af8     04 00 00 AF 
00afc     00 6E 05 A1 |     if_z    add     time1,##2048
00b00     B7 70 01 A6 |     if_z    mov     time2,time1
00b04     02 99 65 AC |     if_z    wrlong  sstart0,ptra[2]
00b08                 |             
00b08     28 02 64 FD | p403        setq #1                          ' write new pointer and sample value to the hub
00b0c     00 95 65 FC |             wrlong  pointer0,ptra
00b10     08 A5 65 FC |             wrlong  envph0,ptra[8]
00b14     BF F0 83 F1 |             sub     ptra, channeladd         ' reset the pointer to channel parameters
00b18                 |                       
00b18     B6 BC 09 F2 |             cmp     oldt0,time0 wz           ' If more than 1 sample is computed at the same time, write only the last result
00b1c     FF 81 25 A7 |     if_z    decmod  front, #511          
00b20                 |          
00b20     E6 C4 31 F9 |             getword oldls,ls,#0              ' reuse oldls variable to convert the sample to unsigned
00b24     E7 C6 31 F9 |  	    getword oldrs,rs,#0              ' getword instead of mov makes the upper bits=0
00b28     0F C4 E5 F4 |             bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
00b2c     0F C6 E5 F4 |             bitnot  oldrs,#15		     ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
00b30                 | 	    
00b30                 | 		    
00b30     E2 C6 29 F9 |             setword oldrs,oldls,#1           ' Pack L and R to one long    		
00b34     E9 D0 01 F6 |             mov     oldsample, newsample     ' The new computed sample will be outputted in the next loop, now we have to fill the buffer with the old one
00b38     E3 D2 01 F6 |             mov     newsample, oldrs       
00b3c                 | 
00b3c     B6 BC 01 F6 |             mov     oldt0,time0              ' update global time
00b40     E1 6C 01 F1 |             add     time0,dt0    
00b44                 |                                      
00b44     00 C2 0D F2 |             cmp     dt0,#0 wz                ' now push dt0 samples to the buffer
00b48     54 FE 9F AD |     if_z    jmp     #loop1
00b4c     E1 82 01 F6 |             mov     qq,dt0
00b50                 |   
00b50     FF F3 97 F9 | p301        alts    ptrb,#511                ' checking if the buffer is full - Wuerfel_21's magic stuff
00b54     00 80 9D F2 |             cmpr    front, #0-0 wcz
00b58     F4 FF 9F AD |     if_e    jmp     #p301    
00b5c                 | 		
00b5c     00 D8 0D F2 | 	    cmp     scbase,#0 wz
00b60     20 00 90 AD |     if_z    jmp #p302	   
00b64                 |  
00b64                 |  
00b64     3F DE 15 F7 |             incmod  scope,#63 wc            ' save every 127th sample to the scope buffer
00b68     ED DC 01 C6 |     if_c    mov scptr2,scptr
00b6c     02 DC 65 C0 |     if_c    shl scptr2,#2
00b70     EC DC 01 C1 |     if_c    add scptr2,scbase     
00b74     60 DC 65 FC |             wrlong scptr2,#$60
00b78     EE D0 61 CC |     if_c    wrlong oldsample,scptr2
00b7c     01 00 00 CF 
00b80     7F DA 05 C7 |     if_c    incmod scptr,##639
00b84                 | 			    
00b84     C0 D0 31 FC | p302        wrlut   oldsample, front        ' if there is a free slot, put the sample into the buffer
00b88     00 00 00 FF 
00b8c     FF 81 05 F7 |             incmod  front, ##511
00b90     EF 83 6D FB |             djnz    qq,#p301
00b94                 |             
00b94     F0 FD 9F FD |             jmp     #loop            'loop
00b98                 | 
00b98                 | '----------------------------------------------------------------------------------
00b98                 | '------------- This is the end of the main loop -----------------------------------
00b98                 | '----------------------------------------------------------------------------------
00b98                 | 
00b98                 | '----------------------------------------------------------------------------------
00b98                 | '------------- PSRAM cache ----------- --------------------------------------------
00b98                 | '----------------------------------------------------------------------------------
00b98                 | 
00b98                 | ' There are 8 cache pointers for 8 channels
00b98                 | ' if 24 higher bits of address=cache, then get a word from the cache
00b98                 | ' else load the cache from PSRAM, update the pointer, then read a sample
00b98                 | 
00b98                 | 
00b98     C1 FC E1 F8 | cache_read  getbyte addrlo,qq,#0 		' when this is called, qq is the addres of the sample			
00b9c                 |             
00b9c     C1 FE 01 F6 | 	    mov     addrhi,qq		
00ba0     08 FE 45 F0 | 	    shr     addrhi,#8		        ' get 24 upper bits
00ba4     F3 BE 95 F9 | 	    alts    cn,#cache1            
00ba8     00 FE 09 F2 | 	    cmp	    addrhi,0-0 wz               ' and compare with the cache pointer for the channel
00bac     34 00 90 AD |     if_z    jmp     #p701	    		' if equal, cache hit, read the sample from it
00bb0                 | 	
00bb0     F3 BE 8D F9 | p702	    altd    cn,#cache1			' cache miss. 
00bb4     FF 00 00 F6 | 	    mov     0-0,addrhi                  ' update the pointer
00bb8     FF F6 01 F6 | 	    mov     cmd,addrhi			' prepare the mailbox
00bbc     08 F6 65 F0 | 	    shl     cmd,#8
00bc0     0B F6 3D F8 |             setnib  cmd, #%1011, #7             ' read burst from the external memory
00bc4     DF F8 01 F6 |             mov     hubaddr,cn                  ' to the channel cache
00bc8     08 F8 65 F0 |             shl     hubaddr,#8                  '
00bcc     F2 F8 01 F1 |             add     hubaddr,hubptr 
00bd0     00 FB 05 F6 |             mov     count,#256                  ' 256 bytes
00bd4     28 04 64 FD |             setq    #2                          ' write 3 longs
00bd8     C4 F6 61 FC |             wrlong  cmd, mailbox                ' run it
00bdc     C4 F6 01 FB | poll1       rdlong  cmd, mailbox                ' poll mailbox for result
00be0     FE F7 B5 FB |             tjs     cmd, #poll1                 ' retry until valid 
00be4                 |             
00be4                 | 	
00be4     DF 82 01 F6 | p701	    mov     qq,cn			' cache hit
00be8     08 82 65 F0 | 	    shl     qq,#8			' compute the cache start
00bec     F2 82 01 F1 | 	    add     qq,hubptr
00bf0     FE 82 01 F1 | 	    add	    qq,addrlo			' add 8 lower bits to the cache addredd
00bf4     C1 84 E1 0A |     _ret_   rdword  spl,qq                      ' read a word
00bf8                 |           
00bf8                 | 
00bf8                 | '--------------------------------------------------------------------------
00bf8                 | '------ Interrupt service -------------------------------------------------
00bf8                 | '------ Output the sample, get the next one if exists ---------------------
00bf8                 | '--------------------------------------------------------------------------
00bf8                 | 
00bf8     0E 8C 25 FC | isr1        wypin   lsample,#left        '2     The sample has to be outputted every 100 cycles     
00bfc     0F 8E 25 FC |             wypin   rsample,#right       '4
00c00     C0 F2 1B F2 |             cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
00c04     80 91 A5 5A |     if_ne   rdlut   lsnext,ptrb          '11    else read the sample and its time from LUT
00c08     FF F3 07 57 |     if_ne   incmod  ptrb,#511
00c0c     C8 8E 39 59 |     if_ne   getword rsample,lsnext,#1    '13
00c10     C8 8C 31 59 |     if_ne   getword lsample,lsnext,#0    '15
00c14                 |     
00c14     F5 FF 3B FB |             reti1                        '17/19 
00c18                 |           
00c18                 | '---------------------------------------------------------------------------
00c18                 | '-------- End of interrupt -------------------------------------------------
00c18                 | '---------------------------------------------------------------------------    
00c18                 | 
00c18                 | 
00c18                 | '---------------------------------------------------------------------------
00c18                 | '------- Variables ---------------------------------------------------------
00c18                 | '---------------------------------------------------------------------------
00c18                 | 
00c18                 | ' constants
00c18                 | 
00c18     00 00 00 40 | a40000000   long $40000000
00c1c     00 00 00 41 | a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before
00c20                 | 
00c20                 | ' Time variables
00c20                 | 
00c20     00 00 00 00 | time0       long 0    ' Global sample computing time
00c24     01 00 00 00 | time1       long 1    ' Local channels time
00c28     02 00 00 00 | time2       long 2
00c2c     03 00 00 00 | time3       long 3
00c30     04 00 00 00 | time4       long 4
00c34     05 00 00 00 | time5       long 5
00c38     06 00 00 00 | time6       long 6
00c3c     07 00 00 00 | time7       long 7
00c40     08 00 00 00 | time8       long 8
00c44                 | 
00c44     00 00 00 00 | channeladd long 0
00c48                 | 
00c48     00 00 00 00 | front       long 0
00c4c                 | 
00c4c                 | ' temporary variables 
00c4c     00 00 00 00 | qq          long 0
00c50     00 00 00 00 | spl         long 0
00c54     00 00 00 00 | zero        long 0
00c58     00 00 00 00 | mailbox     long 0
00c5c     00 00 00 00 | mailbox2 long 0
00c60                 | 
00c60                 | ' Interrupt ISR variables
00c60                 | 
00c60     00 00 00 00 | lsample     long 0
00c64     00 00 00 00 | rsample     long 0
00c68     00 00 00 00 | lsnext      long 0
00c6c     00 00 00 00 | rsnext      long 0 
00c70                 | 
00c70                 | ' channel parameter block
00c70                 | 
00c70     00 00 00 00 | pointer0    long 0     
00c74     00 00 00 00 | sample0     long 0
00c78     00 00 00 00 | sstart0     long 0     ' start pointer and type at bit 31
00c7c     00 00 00 00 | lstart0     long 0
00c80     00 00 00 00 | lend0       long 0
00c84     00 00 00 00 | volpan0     long 0
00c88     00 00 00 00 | freqskip0   long 0
00c8c     00 00 00 00 | command0    long 0
00c90     00 00 00 00 | envph0	    long 0
00c94     00 00 00 00 | envptr0	    long 0
00c98     00 00 00 00 | envspd0	    long 0
00c9c     00 00 00 00 | envlen0	    long 0
00ca0     00 00 00 00 | res5	    long 0
00ca4     00 00 00 00 | res6	    long 0
00ca8     00 00 00 00 | res7	    long 0
00cac     00 00 00 00 | res8	    long 0
00cb0                 | 
00cb0     00 00 00 00 | afreq0      long 0
00cb4     00 00 00 00 | askip0      long 0
00cb8     00 00 00 00 | avol0       long 0
00cbc     00 00 00 00 | apan0       long 0
00cc0                 | 
00cc0     FF FF FF FF | oldt0       long $FFFFFFFF    'Temporary time variables
00cc4     00 00 00 00 | cn          long 0
00cc8     00 00 00 00 | ct          long 0
00ccc     00 00 00 00 | dt0         long 0
00cd0                 | 
00cd0                 | ' Samples
00cd0     00 00 00 00 | oldls       long 0
00cd4     00 00 00 00 | oldrs       long 0
00cd8                 | 
00cd8     00 00 00 00 | ls0         long 0
00cdc     00 00 00 00 | rs0         long 0
00ce0                 | 
00ce0     00 00 00 00 | ls          long 0    
00ce4     00 00 00 00 | rs          long 0
00ce8                 | 
00ce8     00 00 00 00 | oldsample   long 0
00cec     00 00 00 00 | newsample   long 0
00cf0                 | 
00cf0     00 00 00 00 | nrsample    long 0
00cf4     00 00 00 00 | nlsample    long 0
00cf8                 | 
00cf8     00 00 00 00 | scbase long 0
00cfc     00 00 00 00 | scptr long 0
00d00     00 00 00 00 | scptr2 long 0
00d04     00 00 00 00 | scope long 0
00d08                 | 
00d08     44 00 17 00 | dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
00d0c     46 00 17 00 | dac2        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   
00d10                 | 
00d10     00 18 07 00 | hubptr      long $71800
00d14     00 00 00 00 | cache1      long 0
00d18     00 00 00 00 | cache2      long 0
00d1c     00 00 00 00 | cache3      long 0
00d20     00 00 00 00 | cache4      long 0
00d24     00 00 00 00 | cache5      long 0
00d28     00 00 00 00 | cache6      long 0
00d2c     00 00 00 00 | cache7      long 0
00d30     00 00 00 00 | cache8      long 0
00d34                 | 
00d34                 | 
00d34     00 00 00 00 | cmd         long 0
00d38     00 00 00 00 | hubaddr     long 0
00d3c     00 01 00 00 | count       long 256
00d40     00 00 00 00 | addrlo long 0
00d44     00 00 00 00 | addrhi long 0
00d48     00 00 00 00 | pointer00 long 0
00d4c     00 00 00 00 
00d50     00 00 00 00 | null  			long 	0,0           ' for channel reset
00d54                 | objmem
00d54     00 00 00 00 
      ...             
00f58     00 00 00 00 
00f5c     00 00 00 00 | 	long	0[131]
00f60                 | stackspace
00f60     00 00 00 00 | 	long	0[1]
00f64 0bf             | 	org	COG_BSS_START
00f64 0bf             | _var01
00f64 0bf             | 	res	1
00f64 0c0             | _var02
00f64 0c0             | 	res	1
00f64 0c1             | _var03
00f64 0c1             | 	res	1
00f64 0c2             | arg01
00f64 0c2             | 	res	1
00f64 0c3             | arg02
00f64 0c3             | 	res	1
00f64 0c4             | arg03
00f64 0c4             | 	res	1
00f64 0c5             | arg04
00f64 0c5             | 	res	1
00f64 0c6             | local01
00f64 0c6             | 	res	1
00f64 0c7             | local02
00f64 0c7             | 	res	1
00f64 0c8             | local03
00f64 0c8             | 	res	1
00f64 0c9             | local04
00f64 0c9             | 	res	1
00f64 0ca             | 	fit	480
00f64 0ca             | 
