00000                 | 
00000                 | #line 1 "D:/Programowanie/P2-Retromachine-Basic/usbnew.p2asm"
00000                 | con
00000                 | 	_clkfreq = 20000000
00000                 | 	_clkmode = 16779595
00000                 | ' 
00000                 | '   DEBUG_DISABLE = true
00000                 | 	DEBUG_DISABLE = -1
00000                 | ' 
00000                 | '   CLKFREQ_PTR = $14
00000                 | 	CLKFREQ_PTR = 20
00000                 | ' 
00000                 | '   USB_BASE_PIN  = 16
00000                 | 	USB_BASE_PIN = 16
00000                 | '   USB_ENABLE_OFFSET = 1 ' Set -1 if not present
00000                 | 	USB_ENABLE_OFFSET = 1
00000                 | '   USB_DMINUS_OFFSET = 2 ' Must end up on an even pin. D+ is always this +1
00000                 | 	USB_DMINUS_OFFSET = 2
00000                 | ' 
00000                 | '   ACTIVITY_LED  = -1
00000                 | 	ACTIVITY_LED = -1
00000                 | '   ERROR_LED     = -1
00000                 | 	ERROR_LED = -1
00000                 | ' 
00000                 | '   OVERLAP_MEMORY = false ' save memory at cost of making the driver non-reentrant
00000                 | 	OVERLAP_MEMORY = 0
00000                 | ' 
00000                 | '   KEYQUEUE_SIZE = 128
00000                 | 	KEYQUEUE_SIZE = 128
00000                 | ' 
00000                 | '   NUMLOCK_DEFAULT_STATE = false
00000                 | 	NUMLOCK_DEFAULT_STATE = 0
00000                 | '   RPI_KEYBOARD_NUMLOCK_HACK = true
00000                 | 	RPI_KEYBOARD_NUMLOCK_HACK = -1
00000                 | ' 
00000                 | '   HAVE_MOUSE = true
00000                 | 	HAVE_MOUSE = -1
00000                 | '   MOUSE_FULL_PROTOCOL = true ' Experimental: Use full HID report protocol for mice
00000                 | 	MOUSE_FULL_PROTOCOL = -1
00000                 | ' 
00000                 | '   HAVE_HIDPAD = true ' Set to false to disable HidPad inteface
00000                 | 	HAVE_HIDPAD = -1
00000                 | '   HIDPAD_REPORT_SIZE = 8*4 ' do not change!
00000                 | 	HIDPAD_REPORT_SIZE = 32
00000                 | ' 
00000                 | '   EMUPAD_MAX_PLAYER = 0 ' Set to 0 to disable EmuPad interface
00000                 | 	EMUPAD_MAX_PLAYER = 0
00000                 | '   EMUPAD_MAX_RULES = 32
00000                 | 	EMUPAD_MAX_RULES = 32
00000                 | '   EMUPAD_BUILTIN_RULES = false
00000                 | 	EMUPAD_BUILTIN_RULES = 0
00000                 | '   
00000                 | '     ' EmuPad report format config
00000                 | '   EMUPAD_TYPE_NIBBLE = 7
00000                 | 	EMUPAD_TYPE_NIBBLE = 7
00000                 | '   EMUPAD_TYPE_KBD = 1
00000                 | 	EMUPAD_TYPE_KBD = 1
00000                 | '   EMUPAD_TYPE_PAD = 2
00000                 | 	EMUPAD_TYPE_PAD = 2
00000                 | ' 
00000                 | '   EMUPAD_UP_BIT = 0
00000                 | 	EMUPAD_UP_BIT = 0
00000                 | '   EMUPAD_DOWN_BIT = 1
00000                 | 	EMUPAD_DOWN_BIT = 1
00000                 | '   EMUPAD_LEFT_BIT = 2
00000                 | 	EMUPAD_LEFT_BIT = 2
00000                 | '   EMUPAD_RIGHT_BIT = 3
00000                 | 	EMUPAD_RIGHT_BIT = 3
00000                 | '   EMUPAD_BT0_BIT = 4
00000                 | 	EMUPAD_BT0_BIT = 4
00000                 | '   EMUPAD_BT1_BIT = 5
00000                 | 	EMUPAD_BT1_BIT = 5
00000                 | '   EMUPAD_BT2_BIT = 6
00000                 | 	EMUPAD_BT2_BIT = 6
00000                 | '   EMUPAD_BT3_BIT = 7
00000                 | 	EMUPAD_BT3_BIT = 7
00000                 | '   EMUPAD_BT4_BIT = 8
00000                 | 	EMUPAD_BT4_BIT = 8
00000                 | '   EMUPAD_BT5_BIT = 9
00000                 | 	EMUPAD_BT5_BIT = 9
00000                 | '   EMUPAD_BT6_BIT = 10
00000                 | 	EMUPAD_BT6_BIT = 10
00000                 | '   EMUPAD_BT7_BIT = 11
00000                 | 	EMUPAD_BT7_BIT = 11
00000                 | '   EMUPAD_BT8_BIT = 12
00000                 | 	EMUPAD_BT8_BIT = 12
00000                 | '   EMUPAD_BT9_BIT = 13
00000                 | 	EMUPAD_BT9_BIT = 13
00000                 | ' 
00000                 | ' 
00000                 | '     ' Computed magic values
00000                 | '   _EMUPAD_UD_MASK = (decod EMUPAD_UP_BIT) | (decod EMUPAD_DOWN_BIT)
00000                 | 	_EMUPAD_UD_MASK = 3
00000                 | '   _EMUPAD_LR_MASK = (decod EMUPAD_LEFT_BIT) | (decod EMUPAD_RIGHT_BIT)
00000                 | 	_EMUPAD_LR_MASK = 12
00000                 | '   _EMUPAD_RULE_SIZE = 10+4+1
00000                 | 	_EMUPAD_RULE_SIZE = 15
00000                 | ' 
00000                 | '   _HAVE_GAMEPAD = HAVE_HIDPAD || (EMUPAD_MAX_PLAYER > 0)
00000                 | 	_HAVE_GAMEPAD = -1
00000                 | ' 
00000                 | '   MAX_DEVICES = 7 ' DO. NOT. TOUCH.
00000                 | 	MAX_DEVICES = 7
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Smart pin configuration for "long repository" mode with output enabled,
00000                 | ' ' regardless of DIR. This allows one pin to provide a long event code via IN
00000                 | ' ' and also to control the USB port activity LED on/off state vio OUT.
00000                 | '     SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
00000                 | 	SP_REPO1_MODE = 65602
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' A simple event/cmd system using a smart pin configured in "long repository"
00000                 | ' ' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
00000                 | ' ' signal the client that a particular event has occurred. The client must poll
00000                 | ' ' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
00000                 | ' ' loop and process the event IDs you're interested in.
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, M_READY, KBM_READY, HID_READY
00000                 | 	NO_EVENT = 0
00000                 | 	USB_ERROR = 1
00000                 | 	DEV_UNKNOWN = 2
00000                 | 	KB_READY = 3
00000                 | 	M_READY = 4
00000                 | 	KBM_READY = 5
00000                 | 	HID_READY = 6
00000                 | '     XINPUT_READY, PS3_READY, HUB_READY, DEV_DISCONNECT, DBG_DATA, M_DATA, GP_DATA
00000                 | 	XINPUT_READY = 7
00000                 | 	PS3_READY = 8
00000                 | 	HUB_READY = 9
00000                 | 	DEV_DISCONNECT = 10
00000                 | 	DBG_DATA = 11
00000                 | 	M_DATA = 12
00000                 | 	GP_DATA = 13
00000                 | '     CMD_SUSPEND, CMD_RESUME, CMD_RESET
00000                 | 	CMD_SUSPEND = 14
00000                 | 	CMD_RESUME = 15
00000                 | 	CMD_RESET = 16
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' The CMD_* tokens are asynchronous USB commands available to the user, through
00000                 | ' ' the Spin2 usbCommand method of this object. This method will post the cmd
00000                 | ' ' token to the host and when the cmd is complete the host will post the CMD_*
00000                 | ' ' token to byte[0] of the event long. Byte[1] is typically set to one of the
00000                 | ' ' below protocol error codes, with bytes[2..3] available for additional cmd data.
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Protocol error codes:
00000                 | '     #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
00000                 | 	ERR_NONE = 0
00000                 | 	ERR_CMD = 1
00000                 | 	ERR_URX = 2
00000                 | 	ERR_SE1 = 3
00000                 | 	ERR_PACKET = 4
00000                 | 	ERR_TAT = 5
00000                 | 	ERR_TXN_RETRY = 6
00000                 | '     ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
00000                 | 	ERR_XFER_RETRY = 7
00000                 | 	ERR_NAK = 8
00000                 | 	ERR_DATAX_SYNC = 9
00000                 | 	ERR_CONFIG_FAIL = 10
00000                 | 	ERR_TIMEOUT = 11
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Keyboard LED output report toggle key bit postions:
00000                 | '     #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
00000                 | 	LED_NUMLKB = 0
00000                 | 	LED_CAPSLKB = 1
00000                 | 	LED_SCRLKB = 2
00000                 | 	LED_COMPOSEB = 3
00000                 | '     LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
00000                 | 	LED_KANAB = 4
00000                 | 	LED_CONST0B = 5
00000                 | 	LED_CONST1B = 6
00000                 | 	LED_CONST2B = 7
00000                 | ' ' Keyboard LED output report toggle key bitflags:
00000                 | '     LED_NUMLKF   = decod(LED_NUMLKB)
00000                 | 	LED_NUMLKF = 1
00000                 | '     LED_CAPSLKF  = decod(LED_CAPSLKB)
00000                 | 	LED_CAPSLKF = 2
00000                 | '     LED_SCRLKF   = decod(LED_SCRLKB)
00000                 | 	LED_SCRLKF = 4
00000                 | '     LED_COMPOSEF = decod(LED_COMPOSEB)
00000                 | 	LED_COMPOSEF = 8
00000                 | '     LED_KANAF    = decod(LED_KANAB)
00000                 | 	LED_KANAF = 16
00000                 | '     LED_CONST0F  = decod(LED_CONST0B)
00000                 | 	LED_CONST0F = 32
00000                 | '     LED_CONST1F  = decod(LED_CONST1B)
00000                 | 	LED_CONST1F = 64
00000                 | '     LED_CONST2F  = decod(LED_CONST2B)
00000                 | 	LED_CONST2F = 128
00000                 | ' ' Keyboard modifier key bit positions:
00000                 | '     #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
00000                 | 	LEFT_CTRLB = 0
00000                 | 	LEFT_SHIFTB = 1
00000                 | 	LEFT_ALTB = 2
00000                 | 	LEFT_GUIB = 3
00000                 | '     RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
00000                 | 	RIGHT_CTRLB = 4
00000                 | 	RIGHT_SHIFTB = 5
00000                 | 	RIGHT_ALTB = 6
00000                 | 	RIGHT_GUIB = 7
00000                 | ' ' Keyboard modifier bitflags
00000                 | '     LEFT_CTRLF   = decod(LEFT_CTRLB)
00000                 | 	LEFT_CTRLF = 1
00000                 | '     LEFT_SHIFTF  = decod(LEFT_SHIFTB)
00000                 | 	LEFT_SHIFTF = 2
00000                 | '     LEFT_ALTF    = decod(LEFT_ALTB)
00000                 | 	LEFT_ALTF = 4
00000                 | '     LEFT_GUIF    = decod(LEFT_GUIB)
00000                 | 	LEFT_GUIF = 8
00000                 | '     RIGHT_CTRLF  = decod(RIGHT_CTRLB)
00000                 | 	RIGHT_CTRLF = 16
00000                 | '     RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
00000                 | 	RIGHT_SHIFTF = 32
00000                 | '     RIGHT_ALTF   = decod(RIGHT_ALTB)
00000                 | 	RIGHT_ALTF = 64
00000                 | '     RIGHT_GUIF   = decod(RIGHT_GUIB)
00000                 | 	RIGHT_GUIF = 128
00000                 | ' ' Consolidated left/right modkeys. Add the modifier keys you want to trap
00000                 | ' ' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
00000                 | ' ' The key() Spin2 method does this and the rawKey() method returns the key data
00000                 | ' ' as packed by the USB keyboard driver.
00000                 | ' '   SHIFT = $100
00000                 | ' '   CTRL  = $200
00000                 | ' '   ALT   = $400
00000                 | ' '   APP   = $800
00000                 | ' ' L|R key modifier flag combinations:
00000                 | '     KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
00000                 | 	KEYS_APP = 136
00000                 | '     KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
00000                 | 	KEYS_ALT = 68
00000                 | '     KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
00000                 | 	KEYS_CTRL = 17
00000                 | '     KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF
00000                 | 	KEYS_SHIFT = 34
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     _1thou         = 1_000
00000                 | 	_1thou = 1000
00000                 | '     _1m            = 1_000_000
00000                 | 	_1m = 1000000
00000                 | '     _1b            = 1_000_000_000
00000                 | 	_1b = 1000000000
00000                 | '     _12m           = 12_000_000
00000                 | 	_12m = 12000000
00000                 | '     LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
00000                 | 	LSBTns = 1143472128
00000                 | '     FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
00000                 | 	FSBTns = 1118246011
00000                 | '     LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
00000                 | 	LSBTns4 = 2688
00000                 | '     LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
00000                 | 	LSBTns22 = 14784
00000                 | '     FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
00000                 | 	FSBTns4 = 334
00000                 | '     FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
00000                 | 	FSBTns28 = 2339
00000                 | ' ' NCO baud calculations for low-speed/full-speed:
00000                 | ' '        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
00000                 | ' '        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
00000                 | ' ' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
00000                 | ' ' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
00000                 | '     USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
00000                 | 	USB_V1HMODE_LS = 65648
00000                 | '     USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
00000                 | 	USB_V1DMODE_LS = 65652
00000                 | '     USB_V1HMODE_FS = %1_11001_0 + 1 << 16
00000                 | 	USB_V1HMODE_FS = 65650
00000                 | '     USB_V1DMODE_FS = %1_11011_0 + 1 << 16
00000                 | 	USB_V1DMODE_FS = 65654
00000                 | ' ' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
00000                 | '     USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
00000                 | 	USB_V2_DRVOUT = 65654
00000                 | '     USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
00000                 | 	USB_V2_SNIFF = 65590
00000                 | ' ' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
00000                 | ' '   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
00000                 | ' '   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
00000                 | ' '   USB_H_FS_NCO   = %11 << 14 + _12Mbps
00000                 | ' '   USB_D_FS_NCO   = %01 << 14 + _12Mbps
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Time delays and intervals
00000                 | ' ' Useful USB constants and wait intervals:
00000                 | '     XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
00000                 | 	XFER_RETRIES = 12
00000                 | '     TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
00000                 | 	TXN_RETRIES = 12
00000                 | '     NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
00000                 | 	NAK_NOLIMIT = 0
00000                 | '     IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
00000                 | 	IN_NAK_RETRIES = 50000
00000                 | '     OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
00000                 | 	OUT_NAK_RETRIES = 50000
00000                 | ' ' Standard Device request maximum timeout periods (reference):
00000                 | ' {
00000                 | ' }
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Token packet format.
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' '                   CRC5  ENDP ADDRESS PID
00000                 | '     CRC_MASK     = %11111_0000_0000000_00000000
00000                 | 	CRC_MASK = 16252928
00000                 | '     EP_MASK      = %00000_1111_0000000_00000000
00000                 | 	EP_MASK = 491520
00000                 | '     ADDR_MASK    = %00000_0000_1111111_00000000
00000                 | 	ADDR_MASK = 32512
00000                 | '     EP_ADDR_MASK = %00000_1111_1111111_11111111
00000                 | 	EP_ADDR_MASK = 524287
00000                 | '     EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
00000                 | 	EP_ADDR_ZERO = 1048576
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Packet Identifier Bytes (PID). Notice that the first two LSBits are
00000                 | ' ' identical for each group.
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Token:
00000                 | '     PID_OUT   = %1110_0001                  ' $e1
00000                 | 	PID_OUT = 225
00000                 | '     PID_IN    = %0110_1001                  ' $69
00000                 | 	PID_IN = 105
00000                 | '     PID_SOF   = %1010_0101                  ' $a5
00000                 | 	PID_SOF = 165
00000                 | '     PID_SETUP = %0010_1101                  ' $2d
00000                 | 	PID_SETUP = 45
00000                 | ' ' Data:
00000                 | '     PID_DATA0 = %1100_0011                  ' $c3
00000                 | 	PID_DATA0 = 195
00000                 | '     PID_DATA1 = %0100_1011                  ' $4b
00000                 | 	PID_DATA1 = 75
00000                 | '     PID_DATA2 = %1000_0111                  ' $87
00000                 | 	PID_DATA2 = 135
00000                 | '     PID_MDATA = %0000_1111                  ' $0f
00000                 | 	PID_MDATA = 15
00000                 | ' ' Handshake:
00000                 | '     PID_ACK   = %1101_0010                  ' $d2
00000                 | 	PID_ACK = 210
00000                 | '     PID_NAK   = %0101_1010                  ' $5a
00000                 | 	PID_NAK = 90
00000                 | '     PID_STALL = %0001_1110                  ' $1e
00000                 | 	PID_STALL = 30
00000                 | '     PID_NYET  = %1001_0110                  ' $96
00000                 | 	PID_NYET = 150
00000                 | ' ' Special:
00000                 | '     PID_PRE   = %0011_1100                  ' $3c
00000                 | 	PID_PRE = 60
00000                 | '     PID_ERR   = %0011_1100                  ' $3c
00000                 | 	PID_ERR = 60
00000                 | '     PID_SPLIT = %0111_1000                  ' $78
00000                 | 	PID_SPLIT = 120
00000                 | '     PID_PING  = %1011_0100                  ' $b4
00000                 | 	PID_PING = 180
00000                 | '     PID_RESVD = %1111_0000                  ' $f0
00000                 | 	PID_RESVD = 240
00000                 | ' ' Tx, rx and host related constants
00000                 | ' ' USB transmitter WYPIN D line state options:
00000                 | '     OUT_IDLE = 0
00000                 | 	OUT_IDLE = 0
00000                 | '     OUT_SE0  = 1
00000                 | 	OUT_SE0 = 1
00000                 | '     OUT_K    = 2
00000                 | 	OUT_K = 2
00000                 | '     OUT_J    = 3
00000                 | 	OUT_J = 3
00000                 | '     OUT_EOP  = 4
00000                 | 	OUT_EOP = 4
00000                 | '     OUT_SOP  = $80
00000                 | 	OUT_SOP = 128
00000                 | ' ' USB receiver RDPIN status bit positions:
00000                 | '     #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
00000                 | 	J_IDLEB = 0
00000                 | 	K_RESUMEB = 1
00000                 | 	SE0_RESETB = 2
00000                 | 	SE1_BADB = 3
00000                 | 	SOPB = 4
00000                 | 	EOPB = 5
00000                 | 	BUS_ERRB = 6
00000                 | 	BYTE_TGLB = 7
00000                 | ' ' USB receiver RDPIN status bitflags:
00000                 | '     J_IDLEF    = decod(J_IDLEB)
00000                 | 	J_IDLEF = 1
00000                 | '     K_RESUMEF  = decod(K_RESUMEB)
00000                 | 	K_RESUMEF = 2
00000                 | '     SE0_RESETF = decod(SE0_RESETB)
00000                 | 	SE0_RESETF = 4
00000                 | '     SE1_BADF   = decod(SE1_BADB)
00000                 | 	SE1_BADF = 8
00000                 | '     SOPF       = decod(SOPB)
00000                 | 	SOPF = 16
00000                 | '     EOPF       = decod(EOPB)
00000                 | 	EOPF = 32
00000                 | '     BUS_ERRF   = decod(BUS_ERRB)
00000                 | 	BUS_ERRF = 64
00000                 | '     BYTE_TGLF  = decod(BYTE_TGLB)
00000                 | 	BYTE_TGLF = 128
00000                 | ' ' USB CRC constants:
00000                 | '     USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
00000                 | 	USB5_POLY = 20
00000                 | '     USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
00000                 | 	USB5_RESIDUAL = 6
00000                 | '     USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
00000                 | 	USB16_POLY = 40961
00000                 | '     USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
00000                 | 	USB16_RESIDUAL = 45057
00000                 | ' ' Host->class driver USB connect speed:
00000                 | '     #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
00000                 | 	USB_SPEED_UNKNOWN = 0
00000                 | 	USB_SPEED_LOW = 1
00000                 | 	USB_SPEED_FULL = 2
00000                 | ' ' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
00000                 | '     #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB, KBM_TOGGLEB
00000                 | 	IDLEB = 0
00000                 | 	CONNECTEDB = 1
00000                 | 	LOW_SPEEDB = 2
00000                 | 	DATAx_TGLB = 3
00000                 | 	DWNSTRM_HUBB = 7
00000                 | 	SUSPENDB = 8
00000                 | 	KBM_TOGGLEB = 9
00000                 | ' ' Host status bitflags. Unless otherwise noted, bit states are active high:
00000                 | '     IDLEF        = decod(IDLEB)             ' Set when USB in idle state
00000                 | 	IDLEF = 1
00000                 | '     CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
00000                 | 	CONNECTEDF = 2
00000                 | '     LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
00000                 | 	LOW_SPEEDF = 4
00000                 | '     DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
00000                 | 	DATAx_TGLF = 8
00000                 | ' '   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
00000                 | ' '   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
00000                 | ' '   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
00000                 | '     DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
00000                 | 	DWNSTRM_HUBF = 128
00000                 | '     SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
00000                 | 	SUSPENDF = 256
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' USB References:
00000                 | ' ' Universal Serial Bus Specification, Revision 2.0
00000                 | ' '   www.usb.org/developers/docs/usb20_docs/
00000                 | ' ' Device Class Definition for Human Interface Devices (HID), Version 1.11
00000                 | ' '   www.usb.org/developers/hidpage/
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
00000                 | ' ' Use TYPE_STANDARD for all USB Standard Device Request codes.
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' D7 Data direction  | D6:5 Type    | D4:0 Recipient
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' 0 - Host-to-device | 0 = Standard | 0 = Device
00000                 | ' ' 1 - Device-to-host | 1 = Class    | 1 = Interface
00000                 | ' '                    | 2 = Vendor   | 2 = Endpoint
00000                 | ' '                    | 3 = Reserved | 3 = Other
00000                 | ' '                    |              | 4 -31 = Reserved
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     DIR_HOST_TO_DEV = 0 << 7
00000                 | 	DIR_HOST_TO_DEV = 0
00000                 | '     DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
00000                 | 	DIR_DEV_TO_HOST = 128
00000                 | '     TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
00000                 | 	TYPE_STANDARD = 0
00000                 | '     TYPE_CLASS      = %01 << 5
00000                 | 	TYPE_CLASS = 32
00000                 | '     TYPE_VENDOR     = %10 << 5
00000                 | 	TYPE_VENDOR = 64
00000                 | '     TYPE_RESERVED   = %11 << 5
00000                 | 	TYPE_RESERVED = 96
00000                 | '     RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
00000                 | 	RECIP_DEVICE = 0
00000                 | '     RECIP_INTERFACE = %0_0001
00000                 | 	RECIP_INTERFACE = 1
00000                 | '     RECIP_ENDPOINT  = %0_0010
00000                 | 	RECIP_ENDPOINT = 2
00000                 | '     RECIP_OTHER     = %0_0011
00000                 | 	RECIP_OTHER = 3
00000                 | ' '    RECIP 4 - 31 = Reserved
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Standard Device Request codes (Section 9.4, Table 9-4):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
00000                 | 	REQ_GET_STATUS = 0
00000                 | 	REQ_CLEAR_FEATURE = 1
00000                 | 	REQ_RESERVED_1 = 2
00000                 | 	REQ_SET_FEATURE = 3
00000                 | '     REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
00000                 | 	REQ_RESERVED2 = 4
00000                 | 	REQ_SET_ADDR = 5
00000                 | 	REQ_GET_DESC = 6
00000                 | 	REQ_SET_DESC = 7
00000                 | 	REQ_GET_CONFIG = 8
00000                 | '     REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
00000                 | 	REQ_SET_CONFIG = 9
00000                 | 	REQ_GET_INTF = 10
00000                 | 	REQ_SET_INTF = 11
00000                 | 	REQ_SYNC_FRAME = 12
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Standard descriptor types (Section 9.4, Table 9-5):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
00000                 | 	TYPE_DEVICE = 1
00000                 | 	TYPE_CONFIG = 2
00000                 | 	TYPE_STRING = 3
00000                 | 	TYPE_INTERFACE = 4
00000                 | 	TYPE_ENDPOINT = 5
00000                 | '     TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
00000                 | 	TYPE_QUALIFIER = 6
00000                 | 	TYPE_OTHER_SPEED = 7
00000                 | 	TYPE_INTERFACE_PWR = 8
00000                 | 	TYPE_OTG = 9
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
00000                 | 	CLASS_INFO_INTF = 0
00000                 | 	CLASS_AUDIO = 1
00000                 | 	CLASS_COMM = 2
00000                 | 	CLASS_HID = 3
00000                 | 	CLASS_UNDEF0 = 4
00000                 | '     CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
00000                 | 	CLASS_PHYSICAL = 5
00000                 | 	CLASS_IMAGE = 6
00000                 | 	CLASS_PRINTER = 7
00000                 | 	CLASS_MASS_STORAGE = 8
00000                 | 	CLASS_HUB = 9
00000                 | '     CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
00000                 | 	CLASS_CDC_DATA = 10
00000                 | 	CLASS_SMARTCARD = 11
00000                 | 	CLASS_UNDEF1 = 12
00000                 | 	CLASS_CONT_SECURITY = 13
00000                 | 	CLASS_VIDEO = 14
00000                 | '     CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
00000                 | 	CLASS_HEALTH = 15
00000                 | 	CLASS_AUDIO_VIDEO = 16
00000                 | 	CLASS_BILLBOARD = 17
00000                 | 	CLASS_TYPE_C_BRIDGE = 18
00000                 | '     CLASS_DIAGNOSTIC_DEV  = $dc
00000                 | 	CLASS_DIAGNOSTIC_DEV = 220
00000                 | '     CLASS_WIRELESS_CTRL   = $e0
00000                 | 	CLASS_WIRELESS_CTRL = 224
00000                 | '     CLASS_MISCELLANEOUS   = $ef
00000                 | 	CLASS_MISCELLANEOUS = 239
00000                 | '     CLASS_APP_SPECIFIC    = $fe
00000                 | 	CLASS_APP_SPECIFIC = 254
00000                 | '     CLASS_VENDOR_SPECIFIC = $ff
00000                 | 	CLASS_VENDOR_SPECIFIC = 255
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HUB Class Requests
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #0, HUB_PORT_CONNECTION, HUB_PORT_ENABLE, HUB_PORT_SUSPEND, HUB_PORT_OVERCURRENT
00000                 | 	HUB_PORT_CONNECTION = 0
00000                 | 	HUB_PORT_ENABLE = 1
00000                 | 	HUB_PORT_SUSPEND = 2
00000                 | 	HUB_PORT_OVERCURRENT = 3
00000                 | '     HUB_PORT_RESET[4], HUB_PORT_POWER, HUB_PORT_LOWSPEED[7]
00000                 | 	HUB_PORT_RESET = 4
00000                 | 	HUB_PORT_POWER = 8
00000                 | 	HUB_PORT_LOWSPEED = 9
00000                 | '     HUB_C_PORT_CONNECTION, HUB_C_PORT_ENABLE, HUB_C_PORT_SUSPEND, HUB_C_PORT_OVERCURRENT
00000                 | 	HUB_C_PORT_CONNECTION = 16
00000                 | 	HUB_C_PORT_ENABLE = 17
00000                 | 	HUB_C_PORT_SUSPEND = 18
00000                 | 	HUB_C_PORT_OVERCURRENT = 19
00000                 | '     HUB_C_PORT_RESET, HUB_PORT_TEST, HUB_PORT_INDICATOR
00000                 | 	HUB_C_PORT_RESET = 20
00000                 | 	HUB_PORT_TEST = 21
00000                 | 	HUB_PORT_INDICATOR = 22
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
00000                 | 	HID_GET_REPORT = 1
00000                 | 	HID_GET_IDLE = 2
00000                 | 	HID_GET_PROTO = 3
00000                 | '     HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
00000                 | 	HID_SET_REPORT = 9
00000                 | 	HID_SET_IDLE = 10
00000                 | 	HID_SET_PROTO = 11
00000                 | ' ' HID Descriptor types:
00000                 | '     #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
00000                 | 	TYPE_HID = 33
00000                 | 	TYPE_REPORT = 34
00000                 | 	TYPE_PHYSICAL = 35
00000                 | '     #$29, TYPE_HUB
00000                 | 	TYPE_HUB = 41
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
00000                 | 	TYPE_INPUT = 1
00000                 | 	TYPE_OUTPUT = 2
00000                 | 	TYPE_FEATURE = 3
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID Interface SubClasses:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
00000                 | 	SUBCLASS_INTF_NONE = 0
00000                 | 	SUBCLASS_INTF_BOOT = 1
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID Protocol codes:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
00000                 | 	INTF_PROTO_NONE = 0
00000                 | 	INTF_PROTO_KBD = 1
00000                 | 	INTF_PROTO_MOUSE = 2
00000                 | '     #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
00000                 | 	BOOT_PROTOCOL = 0
00000                 | 	REPORT_PROTOCOL = 1
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Other HID buffer lengths:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     MAX_HID_REPTS   = 4             ' We have this many HID report buffers
00000                 | 	MAX_HID_REPTS = 4
00000                 | '     REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
00000                 | 	REPT_BUFF_LEN = 1024
00000                 | '     REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
00000                 | 	REPT_STRUCT_LEN = 1026
00000                 | '     LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
00000                 | 	LANG_BUFF_LEN = 128
00000                 | '     USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
00000                 | 	USTR_BUFF_LEN = 128
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     LANG_ENG_US  = $0409            ' English (United States)
00000                 | 	LANG_ENG_US = 1033
00000                 | '     LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
00000                 | 	LOCAL_LANGID = 1033
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' SETUP structure member offsets.
00000                 | ' ' NOTE: These offsets are defined in terms of the structure member's data type,
00000                 | ' '       to take advantage of PTRA/B scaled indexing, e.g.:
00000                 | ' '         RDBYTE D,   PTRA[bRequest]
00000                 | ' '         WRWORD D/#, PTRA[wLength]
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     bmRequestType = 0
00000                 | 	bmRequestType = 0
00000                 | '     bRequest      = 1
00000                 | 	bRequest = 1
00000                 | '     wValue        = 1
00000                 | 	wValue = 1
00000                 | '     wIndex        = 2
00000                 | 	wIndex = 2
00000                 | '     wLength       = 3
00000                 | 	wLength = 3
00000                 | ' ' SETUP bmRequestType combinations:
00000                 | ' {
00000                 | ' }
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Standard USB descriptor structure sizes in bytes. The values defined are the
00000                 | ' ' minimum size of the descriptor:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     SETUP_TXN_LEN = 8
00000                 | 	SETUP_TXN_LEN = 8
00000                 | '     DEV_DESC_LEN  = 18
00000                 | 	DEV_DESC_LEN = 18
00000                 | '     CON_DESC_LEN  = 9
00000                 | 	CON_DESC_LEN = 9
00000                 | '     INTF_DESC_LEN = 9
00000                 | 	INTF_DESC_LEN = 9
00000                 | '     ENDP_DESC_LEN = 7
00000                 | 	ENDP_DESC_LEN = 7
00000                 | '     STR0_DESC_LEN = 4
00000                 | 	STR0_DESC_LEN = 4
00000                 | '     USTR_DESC_LEN = 4
00000                 | 	USTR_DESC_LEN = 4
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Other USB-related buffer sizes:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     URX_BUFF_LEN = 128      ' USB receiver scratch buffer
00000                 | 	URX_BUFF_LEN = 128
00000                 | '     CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
00000                 | 	CON_BUFF_LEN = 256
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' CON_bmAttrs member bit positions:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     ATTR_RESVB     = 7      ' Reserved (should always be one)
00000                 | 	ATTR_RESVB = 7
00000                 | '     ATTR_SELF_PWRB = 6      ' Device Self-Powered
00000                 | 	ATTR_SELF_PWRB = 6
00000                 | '     ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
00000                 | 	ATTR_RMT_WAKEB = 5
00000                 | ' '    bmAttributes bits 4..0 reserved and reset to zero
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Standard USB descriptor struct member offset and member size, in bytes. Note
00000                 | ' ' that the DESC_bLength and DESC_bDescType members are defined in all of the
00000                 | ' ' descriptors (including HID) at the offsets shown.
00000                 | ' '------------------+
00000                 | ' ' !!! IMPORTANT !!!|
00000                 | ' '------------------+
00000                 | ' ' All standard descriptor member offsets are defined in bytes, so if you want
00000                 | ' ' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
00000                 | ' ' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
00000                 | ' ' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
00000                 | ' '       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
00000                 | ' ' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
00000                 | ' ' must be very careful...
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' '       Member          Offset  Size    Value           Description
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
00000                 | 	DESC_bLength = 0
00000                 | '     DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
00000                 | 	DESC_bDescType = 1
00000                 | ' ' Device Descriptor (Section 9.6.1, Table 9-8):
00000                 | '     DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
00000                 | 	DEV_bcdUSB = 2
00000                 | '     DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
00000                 | 	DEV_bDevClass = 4
00000                 | '     DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
00000                 | 	DEV_bDevSubClass = 5
00000                 | '     DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
00000                 | 	DEV_bProtocol = 6
00000                 | '     DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
00000                 | 	DEV_bMaxPktSize0 = 7
00000                 | '     DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
00000                 | 	DEV_idVendor = 8
00000                 | '     DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
00000                 | 	DEV_idProduct = 10
00000                 | '     DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
00000                 | 	DEV_bcdDevice = 12
00000                 | '     DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
00000                 | 	DEV_iMfg = 14
00000                 | '     DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
00000                 | 	DEV_iProduct = 15
00000                 | '     DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
00000                 | 	DEV_iSerialNum = 16
00000                 | '     DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
00000                 | 	DEV_iNumConfigs = 17
00000                 | '   ' Configuration Descriptor (Section 9.6.3, Table 9-10):
00000                 | ' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
00000                 | '     CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
00000                 | 	CON_wTotalLen = 2
00000                 | '     CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
00000                 | 	CON_bNumIntf = 4
00000                 | '     CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
00000                 | 	CON_bConfigVal = 5
00000                 | '     CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
00000                 | 	CON_iConfig = 6
00000                 | '     CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
00000                 | 	CON_bmAttrs = 7
00000                 | '     CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
00000                 | 	CON_bMaxPower = 8
00000                 | ' ' Interface Descriptor (Section 9.6.5, Table 9-12):
00000                 | ' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
00000                 | '     INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
00000                 | 	INTF_bIntfNum = 2
00000                 | '     INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
00000                 | 	INTF_bAltSetting = 3
00000                 | '     INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
00000                 | 	INTF_bNumEndpts = 4
00000                 | '     INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
00000                 | 	INTF_bIntfClass = 5
00000                 | '     INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
00000                 | 	INTF_bSubClass = 6
00000                 | '                             '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
00000                 | '                             '                       reserved for assignment by the USB-IF.
00000                 | '     INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
00000                 | 	INTF_bProtocol = 7
00000                 | '                             '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
00000                 | '                             '                       vendor-specific protocol for this interface.
00000                 | '     INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
00000                 | 	INTF_iInterface = 8
00000                 | ' ' Endpoint Descriptor (Section 9.6.6, Table 9-13):
00000                 | ' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
00000                 | '     ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
00000                 | 	ENDP_bAddress = 2
00000                 | '     ENDP_bmAttrs     = 3    ' 1     Bitmap
00000                 | 	ENDP_bmAttrs = 3
00000                 | '     ENDP_wMaxPktSize = 4    ' 2     Number
00000                 | 	ENDP_wMaxPktSize = 4
00000                 | '     ENDP_bInterval   = 6    ' 1     Number
00000                 | 	ENDP_bInterval = 6
00000                 | ' ' String Descriptor Zero (Section 9.6.7, Table 9-15):
00000                 | ' '    DESC_bLength     = 0    ' 1     N + 2
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant
00000                 | '     STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
00000                 | 	STR0_wLangID = 2
00000                 | ' ' Unicode String Descriptor (Section 9.6.7, Table 9-16):
00000                 | ' '    DESC_bLength     = 0    ' 1     N + 2
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant
00000                 | '     USTR_wString     = 2    ' N     wString[(N - 2) / 2]
00000                 | 	USTR_wString = 2
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID Descriptor (Section 6.2.1)
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
00000                 | '     HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
00000                 | 	HID_bcdHID = 2
00000                 | '     HID_bCountryCode = 4    ' 1     Number          Hardware target country
00000                 | 	HID_bCountryCode = 4
00000                 | '     HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
00000                 | 	HID_bNumDesc = 5
00000                 | '     HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
00000                 | 	HID_bDescType = 6
00000                 | '     HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).
00000                 | 	HID_wDescLength = 7
00000                 | ' 
00000                 | ' ' HID Report Items from HID 1.11 Section 6.2.2
00000                 | '     HID_USAGE_PAGE      = $04
00000                 | 	HID_USAGE_PAGE = 4
00000                 | '     HID_USAGE           = $08
00000                 | 	HID_USAGE = 8
00000                 | '     HID_COLLECTION      = $A0
00000                 | 	HID_COLLECTION = 160
00000                 | '     HID_END_COLLECTION  = $C0
00000                 | 	HID_END_COLLECTION = 192
00000                 | '     HID_REPORT_COUNT    = $94
00000                 | 	HID_REPORT_COUNT = 148
00000                 | '     HID_REPORT_SIZE     = $74
00000                 | 	HID_REPORT_SIZE = 116
00000                 | '     HID_USAGE_MIN       = $18
00000                 | 	HID_USAGE_MIN = 24
00000                 | '     HID_USAGE_MAX       = $28
00000                 | 	HID_USAGE_MAX = 40
00000                 | '     HID_LOGICAL_MIN     = $14
00000                 | 	HID_LOGICAL_MIN = 20
00000                 | '     HID_LOGICAL_MAX     = $24
00000                 | 	HID_LOGICAL_MAX = 36
00000                 | '     HID_PHYSICAL_MIN    = $34
00000                 | 	HID_PHYSICAL_MIN = 52
00000                 | '     HID_PHYSICAL_MAX    = $44
00000                 | 	HID_PHYSICAL_MAX = 68
00000                 | '     HID_INPUT           = $80
00000                 | 	HID_INPUT = 128
00000                 | '     HID_REPORT_ID       = $84
00000                 | 	HID_REPORT_ID = 132
00000                 | '     HID_OUTPUT          = $90
00000                 | 	HID_OUTPUT = 144
00000                 | '     HID_PUSH            = $A4
00000                 | 	HID_PUSH = 164
00000                 | '     HID_POP             = $B4
00000                 | 	HID_POP = 180
00000                 | ' 
00000                 | ' ' HID Report Usage Pages from HID Usage Tables 1.12 Section 3, Table 1
00000                 | '     HID_USAGE_PAGE_GENERIC_DESKTOP = $01
00000                 | 	HID_USAGE_PAGE_GENERIC_DESKTOP = 1
00000                 | '     HID_USAGE_PAGE_KEY_CODES       = $07
00000                 | 	HID_USAGE_PAGE_KEY_CODES = 7
00000                 | '     HID_USAGE_PAGE_LEDS            = $08
00000                 | 	HID_USAGE_PAGE_LEDS = 8
00000                 | '     HID_USAGE_PAGE_BUTTONS         = $09
00000                 | 	HID_USAGE_PAGE_BUTTONS = 9
00000                 | ' 
00000                 | ' ' HID Report Usages from HID Usage Tables 1.12 Section 4, Table 6
00000                 | '     HID_USAGE_POINTER   = $01
00000                 | 	HID_USAGE_POINTER = 1
00000                 | '     HID_USAGE_MOUSE     = $02
00000                 | 	HID_USAGE_MOUSE = 2
00000                 | '     HID_USAGE_JOYSTICK  = $04
00000                 | 	HID_USAGE_JOYSTICK = 4
00000                 | '     HID_USAGE_GAMEPAD   = $05
00000                 | 	HID_USAGE_GAMEPAD = 5
00000                 | '     HID_USAGE_KEYBOARD  = $06
00000                 | 	HID_USAGE_KEYBOARD = 6
00000                 | '     HID_USAGE_X         = $30
00000                 | 	HID_USAGE_X = 48
00000                 | '     HID_USAGE_Y         = $31
00000                 | 	HID_USAGE_Y = 49
00000                 | '     HID_USAGE_Z         = $32
00000                 | 	HID_USAGE_Z = 50
00000                 | '     HID_USAGE_RX        = $33
00000                 | 	HID_USAGE_RX = 51
00000                 | '     HID_USAGE_RY        = $34
00000                 | 	HID_USAGE_RY = 52
00000                 | '     HID_USAGE_RZ        = $35
00000                 | 	HID_USAGE_RZ = 53
00000                 | '     HID_USAGE_SLIDER    = $36
00000                 | 	HID_USAGE_SLIDER = 54
00000                 | '     HID_USAGE_DIAL      = $37
00000                 | 	HID_USAGE_DIAL = 55
00000                 | '     HID_USAGE_WHEEL     = $38
00000                 | 	HID_USAGE_WHEEL = 56
00000                 | '     HID_USAGE_HATSWITCH = $39
00000                 | 	HID_USAGE_HATSWITCH = 57
00000                 | ' 
00000                 | ' ' HID Report Collection Types from HID 1.12 6.2.2.6
00000                 | '     HID_COLLECTION_PHYSICAL    = 0
00000                 | 	HID_COLLECTION_PHYSICAL = 0
00000                 | '     HID_COLLECTION_APPLICATION = 1
00000                 | 	HID_COLLECTION_APPLICATION = 1
00000                 | ' 
00000                 | ' ' HID Input/Output/Feature Item Data (attributes) from HID 1.11 6.2.2.5
00000                 | '     HID_ITEM_CONSTANT = $1
00000                 | 	HID_ITEM_CONSTANT = 1
00000                 | '     HID_ITEM_VARIABLE = $2
00000                 | 	HID_ITEM_VARIABLE = 2
00000                 | '     HID_ITEM_RELATIVE = $4
00000                 | 	HID_ITEM_RELATIVE = 4
00000                 | ' 
00000                 | ' ' Keyboard report data buffer lengths (boot protocol):
00000                 | '     KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
00000                 | 	KBD_OUT_RPT_LEN = 1
00000                 | '     KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
00000                 | 	KBD_IN_RPT_LEN = 8
00000                 | ' ' Gamepad report and descriptor data buffer lengths:
00000                 | '     HID_IN_RPT_LEN   = 256
00000                 | 	HID_IN_RPT_LEN = 256
00000                 | '     HID_DESCR_LEN    = 256
00000                 | 	HID_DESCR_LEN = 256
00000                 | ' 
00000                 | ' ' Gamepad axes flag bits
00000                 | '     HID_AXIS_X   = 16+0
00000                 | 	HID_AXIS_X = 16
00000                 | '     HID_AXIS_Y   = 16+1
00000                 | 	HID_AXIS_Y = 17
00000                 | '     HID_AXIS_Z   = 16+2
00000                 | 	HID_AXIS_Z = 18
00000                 | '     HID_AXIS_RX  = 16+3
00000                 | 	HID_AXIS_RX = 19
00000                 | '     HID_AXIS_RY  = 16+4
00000                 | 	HID_AXIS_RY = 20
00000                 | '     HID_AXIS_RZ  = 16+5
00000                 | 	HID_AXIS_RZ = 21
00000                 | '     HID_AXIS_SL  = 16+6
00000                 | 	HID_AXIS_SL = 22
00000                 | '     HID_AXIS_WH  = 16+6
00000                 | 	HID_AXIS_WH = 22
00000                 | ' 
00000                 | ' ' Keyboard keys
00000                 | ' '-------------
00000                 | ' ' The first four scancodes are info/error indicators:
00000                 | '     #$00, KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF
00000                 | 	KEY_NO_KEY = 0
00000                 | 	KEY_ERR_ROLLOVER = 1
00000                 | 	KEY_POST_FAIL = 2
00000                 | 	KEY_ERR_UNDEF = 3
00000                 | ' ' Letters:
00000                 | '     KEY_A         = $04
00000                 | 	KEY_A = 4
00000                 | '     KEY_B         = $05
00000                 | 	KEY_B = 5
00000                 | '     KEY_C         = $06
00000                 | 	KEY_C = 6
00000                 | '     KEY_D         = $07
00000                 | 	KEY_D = 7
00000                 | '     KEY_E         = $08
00000                 | 	KEY_E = 8
00000                 | '     KEY_F         = $09
00000                 | 	KEY_F = 9
00000                 | '     KEY_G         = $0a
00000                 | 	KEY_G = 10
00000                 | '     KEY_H         = $0b
00000                 | 	KEY_H = 11
00000                 | '     KEY_I         = $0c
00000                 | 	KEY_I = 12
00000                 | '     KEY_J         = $0d
00000                 | 	KEY_J = 13
00000                 | '     KEY_K         = $0e
00000                 | 	KEY_K = 14
00000                 | '     KEY_L         = $0f
00000                 | 	KEY_L = 15
00000                 | '     KEY_M         = $10
00000                 | 	KEY_M = 16
00000                 | '     KEY_N         = $11
00000                 | 	KEY_N = 17
00000                 | '     KEY_O         = $12
00000                 | 	KEY_O = 18
00000                 | '     KEY_P         = $13
00000                 | 	KEY_P = 19
00000                 | '     KEY_Q         = $14
00000                 | 	KEY_Q = 20
00000                 | '     KEY_R         = $15
00000                 | 	KEY_R = 21
00000                 | '     KEY_S         = $16
00000                 | 	KEY_S = 22
00000                 | '     KEY_T         = $17
00000                 | 	KEY_T = 23
00000                 | '     KEY_U         = $18
00000                 | 	KEY_U = 24
00000                 | '     KEY_V         = $19
00000                 | 	KEY_V = 25
00000                 | '     KEY_W         = $1a
00000                 | 	KEY_W = 26
00000                 | '     KEY_X         = $1b
00000                 | 	KEY_X = 27
00000                 | '     KEY_Y         = $1c
00000                 | 	KEY_Y = 28
00000                 | '     KEY_Z         = $1d
00000                 | 	KEY_Z = 29
00000                 | ' ' Number Row:
00000                 | '     KEY_1         = $1e 
00000                 | 	KEY_1 = 30
00000                 | '     KEY_2         = $1f 
00000                 | 	KEY_2 = 31
00000                 | '     KEY_3         = $20 
00000                 | 	KEY_3 = 32
00000                 | '     KEY_4         = $21 
00000                 | 	KEY_4 = 33
00000                 | '     KEY_5         = $22 
00000                 | 	KEY_5 = 34
00000                 | '     KEY_6         = $23 
00000                 | 	KEY_6 = 35
00000                 | '     KEY_7         = $24 
00000                 | 	KEY_7 = 36
00000                 | '     KEY_8         = $25 
00000                 | 	KEY_8 = 37
00000                 | '     KEY_9         = $26 
00000                 | 	KEY_9 = 38
00000                 | '     KEY_0         = $27 
00000                 | 	KEY_0 = 39
00000                 | ' ' Keyboard return (ENTER), tab, space, etc.:
00000                 | '     KEY_ENTER     = $28
00000                 | 	KEY_ENTER = 40
00000                 | '     KEY_ESC       = $29
00000                 | 	KEY_ESC = 41
00000                 | '     KEY_BACKSPACE = $2a   ' Delete (backspace)
00000                 | 	KEY_BACKSPACE = 42
00000                 | '     KEY_TAB       = $2b
00000                 | 	KEY_TAB = 43
00000                 | '     KEY_SPACE     = $2c
00000                 | 	KEY_SPACE = 44
00000                 | '     KEY_MINUS     = $2d   ' - and _
00000                 | 	KEY_MINUS = 45
00000                 | '     KEY_EQUAL     = $2e   ' = and +
00000                 | 	KEY_EQUAL = 46
00000                 | '     KEY_LBRACE    = $2f   ' [ and {
00000                 | 	KEY_LBRACE = 47
00000                 | '     KEY_RBRACE    = $30   ' ] and }
00000                 | 	KEY_RBRACE = 48
00000                 | '     KEY_BACKSLASH = $31   ' \ and |
00000                 | 	KEY_BACKSLASH = 49
00000                 | '     KEY_HASHTILDE = $32   ' None-US # and ~
00000                 | 	KEY_HASHTILDE = 50
00000                 | '     KEY_SEMICOLON = $33   ' ; and :
00000                 | 	KEY_SEMICOLON = 51
00000                 | '     KEY_APOST     = $34   ' ' and "
00000                 | 	KEY_APOST = 52
00000                 | '     KEY_GRAVE     = $35   ' ` and ~
00000                 | 	KEY_GRAVE = 53
00000                 | '     KEY_COMMA     = $36   ' , and <
00000                 | 	KEY_COMMA = 54
00000                 | '     KEY_DOT       = $37   ' . and >
00000                 | 	KEY_DOT = 55
00000                 | '     KEY_SLASH     = $38   ' / and ?
00000                 | 	KEY_SLASH = 56
00000                 | '     KEY_CAPSLOCK  = $39
00000                 | 	KEY_CAPSLOCK = 57
00000                 | ' ' Function key scancodes:
00000                 | '     KEY_F1        = $3a
00000                 | 	KEY_F1 = 58
00000                 | '     KEY_F2        = $3b
00000                 | 	KEY_F2 = 59
00000                 | '     KEY_F3        = $3c
00000                 | 	KEY_F3 = 60
00000                 | '     KEY_F4        = $3d
00000                 | 	KEY_F4 = 61
00000                 | '     KEY_F5        = $3e
00000                 | 	KEY_F5 = 62
00000                 | '     KEY_F6        = $3f
00000                 | 	KEY_F6 = 63
00000                 | '     KEY_F7        = $40
00000                 | 	KEY_F7 = 64
00000                 | '     KEY_F8        = $41
00000                 | 	KEY_F8 = 65
00000                 | '     KEY_F9        = $42
00000                 | 	KEY_F9 = 66
00000                 | '     KEY_F10       = $43
00000                 | 	KEY_F10 = 67
00000                 | '     KEY_F11       = $44
00000                 | 	KEY_F11 = 68
00000                 | '     KEY_F12       = $45
00000                 | 	KEY_F12 = 69
00000                 | ' ' Special, toggle and movement keys:
00000                 | '     KEY_PRINTSCREEN = $46
00000                 | 	KEY_PRINTSCREEN = 70
00000                 | '     KEY_SCROLLLOCK  = $47
00000                 | 	KEY_SCROLLLOCK = 71
00000                 | '     KEY_PAUSE       = $48
00000                 | 	KEY_PAUSE = 72
00000                 | '     KEY_INSERT      = $49
00000                 | 	KEY_INSERT = 73
00000                 | '     KEY_HOME        = $4a
00000                 | 	KEY_HOME = 74
00000                 | '     KEY_PAGEUP      = $4b
00000                 | 	KEY_PAGEUP = 75
00000                 | '     KEY_DELETE      = $4c
00000                 | 	KEY_DELETE = 76
00000                 | '     KEY_END         = $4d
00000                 | 	KEY_END = 77
00000                 | '     KEY_PAGEDOWN    = $4e
00000                 | 	KEY_PAGEDOWN = 78
00000                 | '     KEY_RIGHT       = $4f
00000                 | 	KEY_RIGHT = 79
00000                 | '     KEY_LEFT        = $50
00000                 | 	KEY_LEFT = 80
00000                 | '     KEY_DOWN        = $51
00000                 | 	KEY_DOWN = 81
00000                 | '     KEY_UP          = $52
00000                 | 	KEY_UP = 82
00000                 | ' ' Keypad keys:
00000                 | '     KEY_NUMLOCK   = $53
00000                 | 	KEY_NUMLOCK = 83
00000                 | '     KEY_NUMSLASH  = $54
00000                 | 	KEY_NUMSLASH = 84
00000                 | '     KEY_NUMASTER  = $55
00000                 | 	KEY_NUMASTER = 85
00000                 | '     KEY_NUMMINUS  = $56
00000                 | 	KEY_NUMMINUS = 86
00000                 | '     KEY_NUMPLUS   = $57
00000                 | 	KEY_NUMPLUS = 87
00000                 | '     KEY_NUMENTER  = $58
00000                 | 	KEY_NUMENTER = 88
00000                 | '     KEY_NUM1      = $59
00000                 | 	KEY_NUM1 = 89
00000                 | '     KEY_NUM2      = $5a
00000                 | 	KEY_NUM2 = 90
00000                 | '     KEY_NUM3      = $5b
00000                 | 	KEY_NUM3 = 91
00000                 | '     KEY_NUM4      = $5c
00000                 | 	KEY_NUM4 = 92
00000                 | '     KEY_NUM5      = $5d
00000                 | 	KEY_NUM5 = 93
00000                 | '     KEY_NUM6      = $5e
00000                 | 	KEY_NUM6 = 94
00000                 | '     KEY_NUM7      = $5f
00000                 | 	KEY_NUM7 = 95
00000                 | '     KEY_NUM8      = $60
00000                 | 	KEY_NUM8 = 96
00000                 | '     KEY_NUM9      = $61
00000                 | 	KEY_NUM9 = 97
00000                 | '     KEY_NUM0      = $62
00000                 | 	KEY_NUM0 = 98
00000                 | '     KEY_DOT_DEL   = $63
00000                 | 	KEY_DOT_DEL = 99
00000                 | '     KEY_NOUS_SP   = $64   ' Non-US \ and |
00000                 | 	KEY_NOUS_SP = 100
00000                 | '     KEY_APP       = $65   ' Application key
00000                 | 	KEY_APP = 101
00000                 | ' ' Modifier keys:
00000                 | '     KEY_LCTRL     = $E0
00000                 | 	KEY_LCTRL = 224
00000                 | '     KEY_LSHIFT    = $E1
00000                 | 	KEY_LSHIFT = 225
00000                 | '     KEY_LALT      = $E2
00000                 | 	KEY_LALT = 226
00000                 | '     KEY_LMETA     = $E3 ' The left "Windows" key
00000                 | 	KEY_LMETA = 227
00000                 | '     KEY_RCTRL     = $E4
00000                 | 	KEY_RCTRL = 228
00000                 | '     KEY_RSHIFT    = $E5
00000                 | 	KEY_RSHIFT = 229
00000                 | '     KEY_RALT      = $E6
00000                 | 	KEY_RALT = 230
00000                 | '     KEY_RMETA     = $E7 ' The right "Windows" key
00000                 | 	KEY_RMETA = 231
00000                 | ' 
00000                 | '     ' EmuPad default keyboard map
00000                 | '     ' You should probably override these
00000                 | '   EMUPAD_KB_UP    = KEY_UP
00000                 | 	EMUPAD_KB_UP = 82
00000                 | '   EMUPAD_KB_DOWN  = KEY_DOWN
00000                 | 	EMUPAD_KB_DOWN = 81
00000                 | '   EMUPAD_KB_LEFT  = KEY_LEFT
00000                 | 	EMUPAD_KB_LEFT = 80
00000                 | '   EMUPAD_KB_RIGHT = KEY_RIGHT
00000                 | 	EMUPAD_KB_RIGHT = 79
00000                 | '   EMUPAD_KB_BT0   = KEY_D
00000                 | 	EMUPAD_KB_BT0 = 7
00000                 | '   EMUPAD_KB_BT1   = KEY_V
00000                 | 	EMUPAD_KB_BT1 = 25
00000                 | '   EMUPAD_KB_BT2   = KEY_C
00000                 | 	EMUPAD_KB_BT2 = 6
00000                 | '   EMUPAD_KB_BT3   = KEY_X
00000                 | 	EMUPAD_KB_BT3 = 27
00000                 | '   EMUPAD_KB_BT4   = KEY_F
00000                 | 	EMUPAD_KB_BT4 = 9
00000                 | '   EMUPAD_KB_BT5   = KEY_G
00000                 | 	EMUPAD_KB_BT5 = 10
00000                 | '   EMUPAD_KB_BT6   = KEY_T
00000                 | 	EMUPAD_KB_BT6 = 23
00000                 | '   EMUPAD_KB_BT7   = KEY_Y
00000                 | 	EMUPAD_KB_BT7 = 28
00000                 | '   EMUPAD_KB_BT8   = KEY_BACKSPACE
00000                 | 	EMUPAD_KB_BT8 = 42
00000                 | '   EMUPAD_KB_BT9   = KEY_ENTER
00000                 | 	EMUPAD_KB_BT9 = 40
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 20000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $100094b
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 D0 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 03 90 5D |  if_ne	jmp	#spininit
0040c 002 E7 F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 02 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 04 80 80 FF 
00420 007 00 90 66 FD | 	hubset	##16779592
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 04 80 00 FF 
00430 00b 4B ED 07 F6 | 	mov	pa, ##16779595
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 96 98 80 FF 
00440 00f 14 00 6E FC | 	wrlong	##20000000, #20
00444 010 BC 02 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
006fc 0be 00 00 00 00 
00700 0bf 00 00 00 00 | 	orgf	192
00704 0c0             | skip_clock_set_
00704 0c0 A8 07 A0 FD | 	call	#_start
00708 0c1             | cogexit
00708 0c1 38 01 80 FF 
0070c 0c2 1F 00 66 FD | 	waitx	##160000
00710 0c3 01 D6 61 FD | 	cogid	arg01
00714 0c4 03 D6 61 FD | 	cogstop	arg01
00718 0c5             | spininit
00718 0c5 61 CB 05 FB | 	rdlong	objptr, ptra++
0071c 0c6 61 D1 05 FB | 	rdlong	result1, ptra++
00720 0c7 28 06 64 FD | 	setq	#3
00724 0c8 00 D7 05 FB | 	rdlong	arg01, ptra
00728 0c9 04 F0 87 F1 | 	sub	ptra, #4
0072c 0ca 2D D0 61 FD | 	call	result1
00730 0cb D4 FF 9F FD | 	jmp	#cogexit
00734 0cc             | FCACHE_LOAD_
00734 0cc F9 AD 01 F6 |     mov	fcache_tmpb_,ptrb
00738 0cd 2B F2 63 FD |     pop	ptrb
0073c 0ce D5 EC 8B F9 |     altd	pa,ret_instr_
00740 0cf D5 00 00 F6 |     mov	 0-0, ret_instr_
00744 0d0 28 EC 63 FD |     setq	pa
00748 0d1 E1 01 04 FB |     rdlong	$0, ptrb++
0074c 0d2 2A F2 63 FD |     push	ptrb
00750 0d3 D6 F2 03 F6 |     mov ptrb,fcache_tmpb_
00754 0d4 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00758 0d5             | ret_instr_
00758 0d5 00 FE 07 02 |     _ret_ cmp inb,#0
0075c 0d6             | fcache_tmpb_
0075c 0d6 00 00 00 00 |     long 0
00760 0d7             | fcache_load_ptr_
00760 0d7 CC 00 00 00 |     long FCACHE_LOAD_
00764 0d8             | builtin_bytefill_
00764 0d8 01 DA 55 F0 |         shr	arg03, #1 wc
00768 0d9 EB D8 41 CC |  if_c   wrbyte	arg02, arg01
0076c 0da 01 D6 05 C1 |  if_c   add	arg01, #1
00770 0db 00 D8 FD F9 |         movbyts	arg02, #0
00774 0dc             | builtin_wordfill_
00774 0dc 01 DA 55 F0 |         shr	arg03, #1 wc
00778 0dd EB D8 51 CC |  if_c   wrword	arg02, arg01
0077c 0de 02 D6 05 C1 |  if_c   add	arg01, #2
00780 0df EC D8 29 F9 |         setword	arg02, arg02, #1
00784 0e0             | builtin_longfill_
00784 0e0 EB 00 88 FC |         wrfast	#0,arg01
00788 0e1 00 DA 0D F2 |         cmp	arg03, #0 wz
0078c 0e2 ED 02 D8 5C |  if_nz  rep	#1, arg03
00790 0e3 17 D8 61 5D |  if_nz  wflong	arg02
00794 0e4 2D 00 64 FD |         ret
00798 0e5             | 
00798 0e5             | objptr
00798 0e5 90 32 00 00 | 	long	@objmem
0079c 0e6             | ptr__dat__
0079c 0e6 08 08 00 00 | 	long	@_dat_
007a0 0e7             | ptr_stackspace_
007a0 0e7 90 32 00 00 | 	long	@stackspace
007a4 0e8             | result1
007a4 0e8 00 00 00 00 | 	long	0
007a8 0e9             | COG_BSS_START
007a8 0e9             | 	fit	480
007a8                 | 	orgh
007a8                 | hubentry
007a8                 | 
007a8                 | ' 
007a8                 | ' PUB start() : r
007a8                 | _start
007a8     00 D2 05 F6 | 	mov	_var01, #0
007ac                 | '   ifnot driver_cog
007ac     15 00 00 FF 
007b0     87 CC 05 F1 | 	add	ptr__dat__, ##10887
007b4     E6 D4 C9 FA | 	rdbyte	_var02, ptr__dat__ wz
007b8     15 00 00 FF 
007bc     87 CC 85 F1 | 	sub	ptr__dat__, ##10887
007c0     38 00 90 5D |  if_ne	jmp	#LR__0001
007c4                 | '     r := coginit(COGEXEC_NEW,@usb_host_start,0)
007c4     E6 D8 01 F6 | 	mov	arg02, ptr__dat__
007c8     10 D2 05 F6 | 	mov	_var01, #16
007cc     00 DA 05 F6 | 	mov	arg03, #0
007d0     28 DA 61 FD | 	setq	arg03
007d4     EC D2 F1 FC | 	coginit	_var01, arg02 wc
007d8     01 D2 65 C6 |  if_b	neg	_var01, #1
007dc                 | '     if r >= 0
007dc     00 D2 55 F2 | 	cmps	_var01, #0 wc
007e0                 | '       driver_cog := r+1
007e0     E9 D4 01 36 |  if_ae	mov	_var02, _var01
007e4     01 D4 05 31 |  if_ae	add	_var02, #1
007e8     15 00 00 3F 
007ec     87 CC 05 31 |  if_ae	add	ptr__dat__, ##10887
007f0     E6 D4 41 3C |  if_ae	wrbyte	_var02, ptr__dat__
007f4     15 00 00 3F 
007f8     87 CC 85 31 |  if_ae	sub	ptr__dat__, ##10887
007fc                 | LR__0001
007fc     E9 D0 01 F6 | 	mov	result1, _var01
00800                 | _start_ret
00800     2D 00 64 FD | 	ret
00804                 | hubexit
00804     C1 00 80 FD | 	jmp	#cogexit
00808                 | 	alignl
00808                 | _dat_
00808                 |                 org     $000
00808 000             | 
00808 000             | usb_host_start
00808 000 F9 8F 02 F6 |                 mov     hcog_base_addr, ptrb
0080c 001             | 
0080c 001 03 00 00 FF 
00810 002 D0 72 07 F6 |                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
00814 003 02 72 47 F0 |                 shr     htmp, #2                        ' so byte->long for the lut cell count
00818 004 B4 04 A0 FE |                 loc     pb, #@hlut_start - @usb_host_start
0081c 005 47 EF 03 F1 |                 add     pb, hcog_base_addr
00820 006 29 72 63 FD |                 setq2   htmp
00824 007 F7 01 00 FB |                 rdlong  0, pb                           ' Do the hub->lut copy
00828 008             | 
00828 008 88 0B A0 FE |                 loc     pb, #@usb_host_init - @usb_host_start
0082c 009 47 EF 03 F1 |                 add     pb, hcog_base_addr
00830 00a 2C EE 63 FD |                 jmp     pb                              ' Initialize host and enter main processing loop
00834 00b             | 
00834 00b             | '------------------------------------------------------------------------------
00834 00b             | ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
00834 00b             | ' special because the receiving function must not respond with either STALL or
00834 00b             | ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
00834 00b             | ' non-control endpoint receives a SETUP token, or the function receives a
00834 00b             | ' corrupt packet, it must ignore the transaction
00834 00b             | '------------------------------------------------------------------------------
00834 00b             | ' On entry:
00834 00b             | '   PTRA - start address of the SETUP data struct.
00834 00b             | ' On exit:
00834 00b             | '   retval - PID_ACK on success, otherwise error code.
00834 00b             | '------------------------------------------------------------------------------
00834 00b             | txn_setup
00834 00b 2D BC C6 F8 |                 setbyte ep_addr_pid, #PID_SETUP, #0
00838 00c 08 B0 06 F6 |                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
0083c 00d 03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
00840 00e 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
00844 00f F8 ED 03 F6 |                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
00848 010             | .setup
00848 010 24 01 B0 FD |                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
0084c 011 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00850 012 2D 00 64 AD |         if_z    ret
00854 013 7C 0B B0 FD |                 call    #retry_wait
00858 014 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
0085c 015 2D 00 64 AD |         if_z    ret
00860 016 F6 F1 03 F6 |                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
00864 017 E0 FF 9F FD |                 jmp     #.setup
00868 018             | 
00868 018             | '------------------------------------------------------------------------------
00868 018             | ' IN/INTERRUPT transaction.
00868 018             | ' Possible function response: STALL or NAK handshake, or DATAx packet.
00868 018             | '------------------------------------------------------------------------------
00868 018             | ' On entry:
00868 018             | '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
00868 018             | '     CRC(b19..23).
00868 018             | ' On exit:
00868 018             | '------------------------------------------------------------------------------
00868 018             | txn_in
00868 018 90 03 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
0086c 019 69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
00870 01a BC 00 B0 FD |                 call    #utx_token                      ' Put IN request on the bus
00874 01b             | 
00874 01b             |                 ' Fall through to urx_packet
00874 01b             | 
00874 01b             | '------------------------------------------------------------------------------
00874 01b             | ' Wait for a packet from a device/function. As host, the only two packet types
00874 01b             | ' received are handshakes and IN DATAx.
00874 01b             | '------------------------------------------------------------------------------
00874 01b             | ' On entry:
00874 01b             | ' On exit:
00874 01b             | '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
00874 01b             | '     returned.
00874 01b             | '------------------------------------------------------------------------------
00874 01b             | urx_packet
00874 01b 22 A7 82 FA |                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
00878 01c 04 A6 16 F4 |                 testb   urx, #SOPB              wc
0087c 01d F4 FF 9F CD |         if_c    jmp     #urx_packet
00880 01e 1A 94 63 FD |                 getct   hct2
00884 01f 4E 95 6B FA |                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
00888 020 05 96 06 F4 |                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
0088c 021 00 A8 06 F6 |                 mov     newb_flg, #0                    ' Initialize for multi-byte read
00890 022             | .wait_sop
00890 022 22 A7 8A FA |                 rdpin   urx, dm
00894 023 04 A6 16 F4 |                 testb   urx, #SOPB              wc
00898 024 08 00 90 CD |         if_c    jmp     #.get_pid
0089c 025 FC 25 CC FB |                 jnct2   #.wait_sop
008a0 026 05 BE 06 06 |         _ret_   mov     retval, #ERR_TAT
008a4 027             | .get_pid
008a4 027 28 02 B0 FD |                 call    #urx_next
008a8 028 06 A6 16 F4 |                 testb   urx, #BUS_ERRB          wc
008ac 029 04 00 90 3D |         if_nc   jmp     #.chk_pid
008b0 02a 02 BE 06 06 |         _ret_   mov     retval, #ERR_URX
008b4 02b             | .chk_pid
008b4 02b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
008b8 02c 5A BE 0E 52 |         if_nz   cmp     retval, #PID_NAK        wz
008bc 02d 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz
008c0 02e 38 00 90 AD |         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
008c4 02f 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
008c8 030 C3 BE 0E F2 |                 cmp     retval, #PID_DATA0      wz
008cc 031 28 01 90 2D |    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
008d0 032 10 00 90 8D |    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
008d4 033 4B BE 0E F2 |                 cmp     retval, #PID_DATA1      wz
008d8 034 1C 01 90 8D |    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
008dc 035 04 00 90 2D |    if_z_and_nc  jmp     #.ack_resend
008e0 036 04 BE 06 06 |         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
008e4 037             | .ack_resend
008e4 037 22 A7 82 FA |                 rqpin   urx, dm
008e8 038 05 A6 16 F4 |                 testb   urx, #EOPB              wc
008ec 039 F4 FF 9F 3D |         if_nc   jmp     #.ack_resend
008f0 03a D2 BE 06 F6 |                 mov     retval, #PID_ACK
008f4 03b 98 01 B0 FD |                 call    #utx_handshake                  ' Send handshake PID and return to caller
008f8 03c 09 BE 06 06 |         _ret_   mov     retval, #ERR_DATAX_SYNC
008fc 03d             | .chk_eop
008fc 03d 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
00900 03e 1C 00 90 3D |         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
00904 03f C8 01 B0 FD |                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
00908 040 05 96 16 F4 |                 testb   hstatus, #EOPB          wc
0090c 041 10 00 90 CD |         if_c    jmp     #.idle                          ' Low-speed EOP seen
00910 042 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
00914 043 04 BE 06 36 |         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
00918 044 02 BE 06 A6 |         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
0091c 045 2D 00 64 FD |                 ret
00920 046             | .idle
00920 046 22 A7 82 FA |                 rqpin   urx, dm
00924 047 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
00928 048 F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
0092c 049 2D 00 64 FD |                 ret
00930 04a             | 
00930 04a             | '------------------------------------------------------------------------------
00930 04a             | ' Send a token packet with CRC5 checksum of address and endpoint. It is the
00930 04a             | ' responsibility of the caller to append the appropriate inter-packet delay,
00930 04a             | ' if one is required.
00930 04a             | '------------------------------------------------------------------------------
00930 04a             | ' On entry:
00930 04a             | '   ep_addr_pid - packed with the PID, address and endpoint.
00930 04a             | ' On exit:
00930 04a             | '------------------------------------------------------------------------------
00930 04a             | utx_token
00930 04a 22 A7 82 FA |                 rqpin   urx, dm
00934 04b 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
00938 04c F4 FF 9F 3D |         if_nc   jmp     #utx_token
0093c 04d 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
00940 04e 34 0D B0 CD |         if_c    call    #utx_pre
00944 04f 80 A4 06 F6 |                 mov     utx, #OUT_SOP
00948 050 70 01 B0 FD |                 call    #utx_byte                       ' Send sync byte
0094c 051 5E 73 03 F6 |                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
00950 052 03 B8 06 F6 |                 mov     pkt_cnt, #3
00954 053             | .next_byte
00954 053 B9 A5 E2 F8 |                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
00958 054 08 72 47 F0 |                 shr     htmp, #8                        ' Shift to next byte to send
0095c 055             | .wait
0095c 055 40 46 72 FD |                 testp   dp                      wc
00960 056 F8 FF 9F 3D |         if_nc   jmp     #.wait
00964 057 23 03 08 FC |                 akpin   dp
00968 058 22 A5 22 FC |                 wypin   utx, dm
0096c 059 F9 B9 6E 0B |         _ret_   djnz    pkt_cnt, #.next_byte
00970 05a             | 
00970 05a             | '------------------------------------------------------------------------------
00970 05a             | ' SETUP/OUT/INTERRUPT transaction.
00970 05a             | ' Possible function response in order of precedence: STALL, ACK, NAK.
00970 05a             | '------------------------------------------------------------------------------
00970 05a             | ' On entry:
00970 05a             | '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
00970 05a             | '     CRC(b19..23).
00970 05a             | '   PTRA - start address of the data buff/struct that has the bytes to send.
00970 05a             | '   pkt_data - count of DATAx payload bytes to send.
00970 05a             | ' On exit:
00970 05a             | '------------------------------------------------------------------------------
00970 05a             | txn_out
00970 05a 88 02 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
00974 05b B8 FF BF FD |                 call    #utx_token                      ' Put SETUP/OUT token on the bus
00978 05c 00 00 C0 FF 
0097c 05d F8 01 78 FC |                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
00980 05e 58 B9 02 F6 |                 mov     pkt_cnt, pkt_data
00984 05f             | 
00984 05f             |                 ' Fall through to utx_data
00984 05f             | 
00984 05f             | '------------------------------------------------------------------------------
00984 05f             | ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
00984 05f             | ' calculated while the data byte is being shifted out. Since data stage
00984 05f             | ' success/fail is not determined until the status stage of the transaction,
00984 05f             | ' this routine is only concerned about the current DATAx packet.
00984 05f             | '------------------------------------------------------------------------------
00984 05f             | ' On entry:
00984 05f             | '   PTRA - hub start address of the data to read.
00984 05f             | '   pkt_cnt - data payload size.
00984 05f             | ' On exit:
00984 05f             | '------------------------------------------------------------------------------
00984 05f             | utx_data
00984 05f 22 A7 82 FA |                 rqpin   urx, dm
00988 060 04 A6 16 F4 |                 testb   urx, #SOPB              wc
0098c 061 F4 FF 9F CD |         if_c    jmp     #utx_data
00990 062 4D 99 02 F6 |                 mov     hctwait, ip_delay
00994 063 2C 0A B0 FD |                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
00998 064 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
0099c 065 D8 0C B0 CD |         if_c    call    #utx_pre
009a0 066 80 A4 06 F6 |                 mov     utx, #OUT_SOP
009a4 067 14 01 B0 FD |                 call    #utx_byte                       ' Send sync
009a8 068 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
009ac 069 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
009b0 06a C3 A4 06 36 |         if_nc   mov     utx, #PID_DATA0
009b4 06b 4B A4 06 C6 |         if_c    mov     utx, #PID_DATA1
009b8 06c 00 01 B0 FD |                 call    #utx_byte                       ' No CRC calc done on PID
009bc 06d 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
009c0 06e 1C 00 90 AD |         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
009c4 06f             | .read_byte
009c4 06f 10 A4 62 FD |                 rfbyte  utx                             ' Fetch data byte
009c8 070 F0 00 B0 FD |                 call    #utx_byte
009cc 071 69 A4 62 FD |                 rev     utx                             ' Calculate CRC while the data is shifting out
009d0 072 28 A4 62 FD |                 setq    utx                             ' SETQ left-justifies the reflected data byte
009d4 073 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
009d8 074 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
009dc 075 F9 B9 6E FB |                 djnz    pkt_cnt, #.read_byte
009e0 076             | .send_crc
009e0 076 E0 BB E6 F4 |                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
009e4 077 5D A5 E2 F8 |                 getbyte utx, crc, #0
009e8 078 D0 00 B0 FD |                 call    #utx_byte
009ec 079 5D A5 EA F8 |                 getbyte utx, crc, #1
009f0 07a C8 00 B0 FD |                 call    #utx_byte                       ' Last CRC byte out
009f4 07b 7C FE 9F FD |                 jmp     #urx_packet                     ' Handle function response/error and back to caller
009f8 07c             | 
009f8 07c             | '------------------------------------------------------------------------------
009f8 07c             | ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
009f8 07c             | ' payload bytes are received. The routine reads bytes until EOP is detected and
009f8 07c             | ' expects that the packet includes at least the CRC word.
009f8 07c             | '
009f8 07c             | ' In control transfers, it's possible to recieve fewer data bytes than what
009f8 07c             | ' was requested, which makes it difficult to determine where the data stops
009f8 07c             | ' and the CRC word begins. So the CRC calculation is done on every byte of the
009f8 07c             | ' packet, including the CRC word. The CRC value should then be equal to the
009f8 07c             | ' USB-16 expected residual value of 0xB001.
009f8 07c             | '
009f8 07c             | ' The routine writes the IN packet data to a static max_packet_size buffer
009f8 07c             | ' so the caller can verify IN success before writing the data to its final
009f8 07c             | ' destination.
009f8 07c             | '------------------------------------------------------------------------------
009f8 07c             | ' On entry:
009f8 07c             | '   pkt_data - max byte count expected to be in the packet.
009f8 07c             | '   newb_flg - signals new byte ready when toggled.
009f8 07c             | ' On exit:
009f8 07c             | '   pkt_cnt - actual number of bytes read.
009f8 07c             | '------------------------------------------------------------------------------
009f8 07c             | urx_data
009f8 07c F7 77 03 F6 |                 mov     htmp2, pb
009fc 07d 27 EF 03 F6 |                 mov     pb, urx_buff_p
00a00 07e 00 00 C0 FF 
00a04 07f F7 01 88 FC |                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
00a08 080 BB EF 03 F6 |                 mov     pb, htmp2
00a0c 081 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
00a10 082 00 B8 06 F6 |                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
00a14 083 58 85 03 F6 |                 mov     pkt_tmp, pkt_data
00a18 084 02 84 07 F1 |                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
00a1c 085             | .wait_byte
00a1c 085             | ' In-line rx for max speed
00a1c 085 22 A7 82 FA |                 rqpin   urx, dm
00a20 086 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
00a24 087 53 A5 02 F5 |                 and     utx, urx
00a28 088 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
00a2c 089 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
00a30 08a 0C 00 90 5D |         if_nz   jmp     #.get_byte                      ' New byte!
00a34 08b 05 A6 16 F4 |                 testb   urx, #EOPB              wc
00a38 08c 38 00 90 CD |         if_c    jmp     #.chk_crc                       ' At end-of-packet
00a3c 08d DC FF 9F FD |                 jmp     #.wait_byte
00a40 08e             | .get_byte
00a40 08e 53 BF EA F8 |                 getbyte retval, urx, #1                 ' New byte from smart pins
00a44 08f 15 BE 62 FD |                 wfbyte  retval                          ' Add it to the data buffer
00a48 090 69 BE 62 FD |                 rev     retval                          ' Calculate CRC while next byte is shifting in
00a4c 091 28 BE 62 FD |                 setq    retval                          ' SETQ left-justifies the reflected data byte
00a50 092 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
00a54 093 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
00a58 094             | .end_crc
00a58 094 01 B8 06 F1 |                 add     pkt_cnt, #1
00a5c 095 C2 B9 1A F2 |                 cmp     pkt_cnt, pkt_tmp        wcz
00a60 096 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
00a64 097 2D 00 64 1D |         if_a    ret
00a68 098             | ' For full-speed at 80MHz, the time it takes to do the final byte write and
00a68 098             | ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
00a68 098             | ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
00a68 098             | ' to miss it, so cheat a bit and look for SOP clear here.
00a68 098 22 A7 82 FA |                 rqpin   urx, dm
00a6c 099 05 A6 16 F4 |                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
00a70 09a A8 FF 9F 3D |         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
00a74 09b             | ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
00a74 09b             | .chk_crc
00a74 09b 02 B8 86 F1 |                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
00a78 09c 58 00 00 FF 
00a7c 09d 01 BA 6E F5 |                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
00a80 09e F0 FD 9F 5D |         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
00a84 09f D2 BE 06 F6 |                 mov     retval, #PID_ACK
00a88 0a0 4D 99 02 F6 |                 mov     hctwait, ip_delay
00a8c 0a1 34 09 B0 FD |                 call    #poll_waitx
00a90 0a2             | 
00a90 0a2             |                 ' Fall through to utx_handshake
00a90 0a2             | 
00a90 0a2             | '------------------------------------------------------------------------------
00a90 0a2             | ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
00a90 0a2             | ' the appropriate IP delay has been inserted.
00a90 0a2             | '------------------------------------------------------------------------------
00a90 0a2             | ' On entry:
00a90 0a2             | '   retval - handshake PID to send.
00a90 0a2             | ' On exit:
00a90 0a2             | '   retval unchanged.
00a90 0a2             | '------------------------------------------------------------------------------
00a90 0a2             | utx_handshake
00a90 0a2 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
00a94 0a3 E0 0B B0 CD |         if_c    call    #utx_pre
00a98 0a4 80 A4 06 F6 |                 mov     utx, #OUT_SOP
00a9c 0a5 1C 00 B0 FD |                 call    #utx_byte                       ' Send sync
00aa0 0a6 5F A5 02 F6 |                 mov     utx, retval
00aa4 0a7 14 00 B0 FD |                 call    #utx_byte                       ' Send handshake PID
00aa8 0a8             | .idle
00aa8 0a8 22 A7 82 FA |                 rqpin   urx, dm
00aac 0a9 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
00ab0 0aa F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
00ab4 0ab 4E 99 02 F6 |                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
00ab8 0ac 08 09 90 FD |                 jmp     #poll_waitx
00abc 0ad             | 
00abc 0ad             | '------------------------------------------------------------------------------
00abc 0ad             | ' Wait for the USB tx buffer to empty and feed it a new byte.
00abc 0ad             | '------------------------------------------------------------------------------
00abc 0ad             | ' On entry:
00abc 0ad             | '   utx - byte to transmit.
00abc 0ad             | ' On exit:
00abc 0ad             | '------------------------------------------------------------------------------
00abc 0ad             | utx_byte
00abc 0ad 40 46 72 FD |                 testp   dp                      wc
00ac0 0ae F8 FF 9F 3D |         if_nc   jmp     #utx_byte
00ac4 0af 23 03 08 FC |                 akpin   dp
00ac8 0b0 1F 94 62 FD |                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
00acc 0b1 22 A5 22 0C |         _ret_   wypin   utx, dm
00ad0 0b2             | 
00ad0 0b2             | '------------------------------------------------------------------------------
00ad0 0b2             | ' Fetch the next data byte of a packet. Always check receiver status for EOP.
00ad0 0b2             | '------------------------------------------------------------------------------
00ad0 0b2             | ' On entry:
00ad0 0b2             | ' On exit:
00ad0 0b2             | '   retval - the byte read.
00ad0 0b2             | '   urx - the receiver status. The caller must check the hstatus reg EOP flag
00ad0 0b2             | '     on return. If EOP is set, the byte in reg retval remains as the last byte
00ad0 0b2             | '     received.
00ad0 0b2             | '------------------------------------------------------------------------------
00ad0 0b2             | urx_next
00ad0 0b2 22 A7 8A FA |                 rdpin   urx, dm
00ad4 0b3 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
00ad8 0b4 53 A5 02 F5 |                 and     utx, urx
00adc 0b5 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
00ae0 0b6 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
00ae4 0b7 53 BF EA 58 |         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
00ae8 0b8 2D 00 64 5D |         if_nz   ret                                     ' New byte is priority, so return now
00aec 0b9 04 A6 16 F4 |                 testb   urx, #SOPB              wc
00af0 0ba 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
00af4 0bb D8 FF 9F 4D |    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
00af8 0bc 05 96 26 34 |         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
00afc 0bd 2D 00 64 FD |                 ret
00b00 0be             | 
00b00 0be             | '------------------------------------------------------------------------------
00b00 0be             | ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
00b00 0be             | ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
00b00 0be             | ' length, and the PID is not included in the CRC calculation:
00b00 0be             | '  CRC5  FRAME_NUMBER SOF (full-speed)
00b00 0be             | '  CRC5  ENDP ADDRESS PID
00b00 0be             | ' %00000_1111_1111111_xxxxxxxx
00b00 0be             | '------------------------------------------------------------------------------
00b00 0be             | ' On entry:
00b00 0be             | '   ep_addr_pid - stuffed with the function endpoint, address and
00b00 0be             | '     SETUP/IN/OUT/SOF PID according to the USB standard.
00b00 0be             | ' On exit:
00b00 0be             | '   ep_addr_pid - CRC value appended to the packet.
00b00 0be             | '------------------------------------------------------------------------------
00b00 0be             | calc_crc5
00b00 0be FF 03 00 FF 
00b04 0bf FF BD 06 F5 |                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
00b08 0c0 5E 73 03 F6 |                 mov     htmp, ep_addr_pid
00b0c 0c1 08 72 47 F0 |                 shr     htmp, #8                        ' PID not included in CRC calc
00b10 0c2 1F BA 06 F6 |                 mov     crc, #$1f                       ' Initial CRC5 value
00b14 0c3 69 72 63 FD |                 rev     htmp                            ' Input data reflected
00b18 0c4 28 72 63 FD |                 setq    htmp                            ' CRCNIB setup for data bits 0..7
00b1c 0c5 14 BA DE F9 |                 crcnib  crc, #USB5_POLY
00b20 0c6 14 BA DE F9 |                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
00b24 0c7 09 72 77 F0 |                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
00b28 0c8 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
00b2c 0c9 01 72 77 F0 |                 shl     htmp, #1                wc
00b30 0ca 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
00b34 0cb 01 72 77 F0 |                 shl     htmp, #1                wc
00b38 0cc 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
00b3c 0cd 1F BA 66 F5 |                 xor     crc, #$1f                       ' Final XOR value
00b40 0ce 13 BA 66 F0 |                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
00b44 0cf 5D BD 42 05 |         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
00b48 0d0             | 
00b48 0d0             | '------------------------------------------------------------------------------
00b48 0d0             | ' Full-speed/low-speed frame timing interrupt service routine.
00b48 0d0             | '------------------------------------------------------------------------------
00b48 0d0             | isr1_fsframe
00b48 0d0 1A 92 62 FD |                 getct   iframe_ct_base
00b4c 0d1 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
00b50 0d2 B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
00b54 0d3 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
00b58 0d4             | .wait
00b58 0d4 40 46 72 FD |                 testp   dp                      wc
00b5c 0d5 F8 FF 9F 3D |         if_nc   jmp     #.wait
00b60 0d6 23 03 08 FC |                 akpin   dp
00b64 0d7 A5 A4 06 F6 |                 mov     utx, #PID_SOF
00b68 0d8 22 01 29 FC |                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
00b6c 0d9 4C FF BF FD |                 call    #utx_byte                       ' Send token PID byte
00b70 0da 1F B6 06 F6 |                 mov     icrc, #$1f                      ' Prime the CRC5 pump
00b74 0db 59 B5 02 F6 |                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
00b78 0dc 69 B4 62 FD |                 rev     sof_pkt                         ' Input data reflected
00b7c 0dd 28 B4 62 FD |                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
00b80 0de 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY
00b84 0df 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
00b88 0e0 59 A5 E2 F8 |                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
00b8c 0e1 2C FF BF FD |                 call    #utx_byte
00b90 0e2 08 B4 66 F0 |                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
00b94 0e3 03 04 DC FC |                 rep     #2, #3                          ' Three data bits left to process
00b98 0e4 01 B4 76 F0 |                 shl     sof_pkt, #1             wc
00b9c 0e5 14 B6 D6 F9 |                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
00ba0 0e6 1F B6 66 F5 |                 xor     icrc, #$1f                      ' Final XOR value
00ba4 0e7 59 A5 EA F8 |                 getbyte utx, frame, #1                  ' Send remaining frame number bits
00ba8 0e8 03 B6 66 F0 |                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
00bac 0e9 5B A5 42 F5 |                 or      utx, icrc
00bb0 0ea 08 FF BF FD |                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
00bb4 0eb A4 83 03 F6 |                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
00bb8 0ec 20 00 90 FD |                 jmp     #isr1_wait
00bbc 0ed             | isr1_lsframe
00bbc 0ed 1A 92 62 FD |                 getct   iframe_ct_base
00bc0 0ee 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
00bc4 0ef B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
00bc8 0f0             | .wait
00bc8 0f0 40 46 72 FD |                 testp   dp                      wc
00bcc 0f1 F8 FF 9F 3D |         if_nc   jmp     #.wait
00bd0 0f2 23 03 08 FC |                 akpin   dp
00bd4 0f3 22 09 28 FC |                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
00bd8 0f4 A3 83 03 F6 |                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
00bdc 0f5             | isr1_wait
00bdc 0f5 22 A5 82 FA |                 rqpin   utx, dm
00be0 0f6 04 A4 16 F4 |                 testb   utx, #SOPB                 wc
00be4 0f7 F4 FF 9F CD |         if_c    jmp     #isr1_wait
00be8 0f8 01 B2 06 F1 |                 add     frame, #1                       ' Next frame# and check for wrap around
00bec 0f9 03 00 00 FF 
00bf0 0fa FF B3 06 F5 |                 and     frame, ##$7ff
00bf4 0fb 1F 82 63 FD |                 waitx   isrtmp1                         ' Make sure bus is idle
00bf8 0fc F5 FF 3B FB |                 reti1
00bfc 0fd             | 
00bfc 0fd             | '------------------------------------------------------------------------------
00bfc 0fd             | ' Wait for a window within the 1ms frame boundary that will ensure that a
00bfc 0fd             | ' transaction will complete before the next frame is triggered.
00bfc 0fd             | '------------------------------------------------------------------------------
00bfc 0fd             | ' On entry:
00bfc 0fd             | ' On exit:
00bfc 0fd             | '------------------------------------------------------------------------------
00bfc 0fd             | wait_txn_ok
00bfc 0fd 1A 76 63 FD |                 getct   htmp2
00c00 0fe 49 77 83 F1 |                 sub     htmp2, iframe_ct_base
00c04 0ff 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
00c08 100 A1 77 1B C2 |         if_c    cmp     htmp2, _txn_ok_ls_      wcz
00c0c 101 A2 77 1B 32 |         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
00c10 102 E8 FF 9F 1D |         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
00c14 103 2D 00 64 FD |                 ret
00c18 104             | 
00c18 104             | '------------------------------------------------------------------------------
00c18 104             | ' A device connection was detected, or a bus reset was requested by the USB
00c18 104             | ' client. Set the appropriate smart pin FS/LS speed mode to match the device
00c18 104             | ' and perform a reset sequence prior to device enumeration.
00c18 104             | '------------------------------------------------------------------------------
00c18 104             | dev_reset
00c18 104 22 A7 82 FA |                 rqpin   urx, dm
00c1c 105 01 A6 16 F4 |                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
00c20 106 F4 03 B0 CD |         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
00c24 107 E0 03 B0 3D |         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
00c28 108             | reset
00c28 108 25 00 64 FD |                 setint1 #0                              ' Don't want frame interrupt while in reset
00c2c 109 22 03 28 FC |                 wypin   #OUT_SE0, dm                    ' Assert bus reset
00c30 10a 1F 5C 63 FD |                 waitx   _reset_hold_                    ' Spec is >= 10ms
00c34 10b 22 01 28 FC |                 wypin   #OUT_IDLE, dm
00c38 10c 00 B2 06 F6 |                 mov     frame, #0                       ' Reset the frame timespan count
00c3c 10d 1A 92 62 FD |                 getct   iframe_ct_base
00c40 10e 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
00c44 10f B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
00c48 110 59 73 03 F6 |                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
00c4c 111 24 72 07 F1 |                 add     htmp, #36
00c50 112 25 02 64 FD |                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
00c54 113             | .framewait
00c54 113 B9 B3 1A F2 |                 cmp     frame, htmp             wcz
00c58 114 F8 FF 9F CD |         if_b    jmp     #.framewait
00c5c 115 2D 00 64 FD |                 ret
00c60 116             | 
00c60 116             | '------------------------------------------------------------------------------
00c60 116             | ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
00c60 116             | '------------------------------------------------------------------------------
00c60 116             | ' On entry:
00c60 116             | '   PTRA - source address.
00c60 116             | '   PB - destination address.
00c60 116             | '   hr0 - length of copy, in bytes.
00c60 116             | ' On exit:
00c60 116             | '------------------------------------------------------------------------------
00c60 116             | hmemcpy
00c60 116 61 73 C7 FA |                 rdbyte  htmp, ptra++
00c64 117 F7 73 43 FC |                 wrbyte  htmp, pb
00c68 118 01 EE 07 F1 |                 add     pb, #1
00c6c 119 FC 87 6F 0B |         _ret_   djnz    hr0, #hmemcpy
00c70 11a             | 
00c70 11a             | '------------------------------------------------------------------------------
00c70 11a             | ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
00c70 11a             | ' loop until the errant device is disconnected.
00c70 11a             | '------------------------------------------------------------------------------
00c70 11a             | ' On entry:
00c70 11a             | ' On exit:
00c70 11a             | '------------------------------------------------------------------------------
00c70 11a             | host_error
00c70 11a             |           if ERROR_LED >= 0
00c70 11a             |           end
00c70 11a A0 07 90 FD |                 jmp     #host_reset                     ' See if it works...
00c74 11b             | 
00c74 11b             | '------------------------------------------------------------------------------
00c74 11b             | ' Get HID descriptor buffer for current port
00c74 11b             | '------------------------------------------------------------------------------
00c74 11b             | ' On entry:
00c74 11b             | ' On exit:
00c74 11b             | '   PB - HID descriptor buffer pointer
00c74 11b             | '------------------------------------------------------------------------------
00c74 11b             | get_hid_descr_buffer
00c74 11b 2D EF 03 F6 |                 mov     pb, hdev_port
00c78 11c 01 EE E7 F2 |                 cmpsub  pb, #1
00c7c 11d 00 EF 07 FA |                 mul     pb, #HID_DESCR_LEN
00c80 11e 25 EF 03 01 |         _ret_   add     pb, hid_descr_p
00c84 11f             | 
00c84 11f             | 
00c84 11f 01 A0 00 00 | usb16_poly_r    long    USB16_POLY
00c88 120             | 
00c88 120             | ' USB commands and error codes
00c88 120 00 00 00 00 | cmd_data        long    0
00c8c 121 00 00 00 00 | usb_err_code    long    ERR_NONE
00c90 122             | 
00c90 122             | ' Parameters block assigned at cog startup
00c90 122 12 00 00 00 | dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
00c94 123 13 00 00 00 | dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
00c98 124 11 00 00 00 | usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
00c9c 125             | if ACTIVITY_LED >= 0
00c9c 125             | host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
00c9c 125             | end
00c9c 125             | if ERROR_LED >= 0
00c9c 125             | host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
00c9c 125             | end
00c9c 125 00 00 00 00 | hid_descr_p     long    0
00ca0 126             | 'hid_report_p    long    0, 0[MAX_DEVICES]
00ca0 126             | 'hkbd_report_p   long    0
00ca0 126 00 00 00 00 | hub_descr_p     long    0
00ca4 127 00 00 00 00 | urx_buff_p      long    0
00ca8 128 00 00 00 00 | dev_desc_buff_p long    0
00cac 129 00 00 00 00 | con_desc_buff_p long    0
00cb0 12a 00 00 00 00 | cache_start_p   long    0
00cb4 12b 00 00 00 00 | cache_end_p     long    0
00cb8 12c             | if EMUPAD_MAX_PLAYER > 0
00cb8 12c             | emupad_out_ptr  long    0
00cb8 12c             | end
00cb8 12c 00 00 00 00 | save_sysclk     long    0         ' Save the current sysclock as the client may change it
00cbc 12d             | 
00cbc 12d             | hdev_init_start
00cbc 12d             | hdev_port       res     1
00cbc 12d             | hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
00cbc 12d             | kbm_next_datax  res     1
00cbc 12d             | hub_intf_num    res     1
00cbc 12d             | hub_next_datax  res     1
00cbc 12d             | hub_status_chg  res     1
00cbc 12d             | hub_port_status res     1
00cbc 12d             | if HAVE_MOUSE
00cbc 12d             | ms_intf_num     res     1
00cbc 12d             | ms_in_max_pkt   res     1
00cbc 12d             | end
00cbc 12d             | kb_intf_num     res     1
00cbc 12d             | kb_interval     res     1
00cbc 12d             | kb_in_max_pkt   res     1
00cbc 12d             | kb_max_index    res     1
00cbc 12d             | kb_led_states   res     1
00cbc 12d             | gp_intf_num     res     1
00cbc 12d             | gp_interval     res     1
00cbc 12d             | gp_max_index    res     1
00cbc 12d             | gp_descr_len    res     1+MAX_DEVICES
00cbc 12d             | hdev_init_end
00cbc 12d             | 
00cbc 12d             | ' Initialized at cog startup:
00cbc 12d             | hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
00cbc 12d             | iframe_ct_new   res     1
00cbc 12d             | iframe_ct_base  res     1
00cbc 12d             | utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
00cbc 12d             | 
00cbc 12d             | ' This register block is reset to zero when a USB device connects
00cbc 12d             | hreg_init_start
00cbc 12d             | hstatus         res     1         ' Host status flags
00cbc 12d             | hctwait         res     1         ' Poll-based wait clocks
00cbc 12d             | ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
00cbc 12d             | tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
00cbc 12d             | nak_retry       res     1         ' NAK retry count, unlimited retries if zero
00cbc 12d             | xfer_retry      res     1         ' Control transfer retry count
00cbc 12d             | retry           res     1         ' Transaction retry count
00cbc 12d             | utx             res     1         ' Byte to transmit on USB
00cbc 12d             | urx             res     1         ' LSByte receiver status flags, MSByte received data
00cbc 12d             | newb_flg        res     1         ' Receive "new byte" bit toggle detector
00cbc 12d             | max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
00cbc 12d             | total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
00cbc 12d             | stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
00cbc 12d             | pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
00cbc 12d             | frame           res     1         ' USB 1ms frame counter value
00cbc 12d             | sof_pkt         res     1         ' ISR frame# packet and CRC5
00cbc 12d             | icrc            res     1         ' Only used by the 1ms frame output ISR routine
00cbc 12d             | pkt_cnt         res     1         ' Count of DATAx packet payload bytes
00cbc 12d             | crc             res     1         ' Used for CRC16 calculation
00cbc 12d             | ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
00cbc 12d             | retval          res     1         ' Global success/fail return parameter
00cbc 12d             | context_retval  res     1         ' Operation contextual return parameter
00cbc 12d             | ' Device stuff
00cbc 12d             | hdev_id         res     1+MAX_DEVICES
00cbc 12d             | hdev_bcd        res     1
00cbc 12d             | hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
00cbc 12d             | ' Keyboard/mouse stuff
00cbc 12d             | hctrl_ep_addr   res     1
00cbc 12d             | hctrl_max_pkt   res     1
00cbc 12d             | hconfig_base    res     1
00cbc 12d             | hcon_tot_len    res     1         ' Size of the complete config descriptor chain
00cbc 12d             | hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
00cbc 12d             | hdev_class      res     1
00cbc 12d             | hdev_subclass   res     1
00cbc 12d             | hdev_protocol   res     1
00cbc 12d             | hsearch_key     res     1         ' Descriptor type to search for in the config chain
00cbc 12d             | hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
00cbc 12d             | hhub_ctrl_ep    res     1         ' Hub control endpoint address
00cbc 12d             | hhub_ep_addr    res     1         ' Hub interface endpoint address
00cbc 12d             | hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
00cbc 12d             | hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
00cbc 12d             | if HAVE_MOUSE
00cbc 12d             | hmouse_ep_addr  res     1 ' Mouse interface endpoint address
00cbc 12d             | end
00cbc 12d             | hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
00cbc 12d             | hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
00cbc 12d             | hdev_ep_addr    res     1+MAX_DEVICES
00cbc 12d             | hdev_out_addr   res     1
00cbc 12d             | 
00cbc 12d             | if EMUPAD_MAX_PLAYER > 0
00cbc 12d             | hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
00cbc 12d             | hpad_emupad_buffer res EMUPAD_MAX_PLAYER
00cbc 12d             | hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
00cbc 12d             | end
00cbc 12d             | 
00cbc 12d             | hreg_init_end
00cbc 12d             | 
00cbc 12d             | hidr_start
00cbc 12d             | hidr_usage      res     1 ' <- can get trashed after parsing
00cbc 12d             | hidr_flags      res     1
00cbc 12d             | hidr_axis       res     4
00cbc 12d             | hidr_buttons    res     1
00cbc 12d             | hidr_hats       res     1
00cbc 12d             | '' Above are actually useful values, 6 longs
00cbc 12d             | hidr_type       res     1
00cbc 12d             | hidr_id         res     1
00cbc 12d             | hidr_offset     res     1
00cbc 12d             | hidr_usage_idx  res     1
00cbc 12d             | ' below need to be push/pop'd
00cbc 12d             | hidr_state      res     1
00cbc 12d             | hidr_size       res     1
00cbc 12d             | hidr_count      res     1
00cbc 12d             | hidr_lminmax    res     1
00cbc 12d             | hidr_pminmax    res     1
00cbc 12d             | hidr_end
00cbc 12d             | 
00cbc 12d             | ' Variables dependent on the system freqency
00cbc 12d             | _var_64_lower_  res     1
00cbc 12d             | _var_64_upper_  res     1
00cbc 12d             | _12Mbps_        res     1
00cbc 12d             | _1_5Mbps_       res     1
00cbc 12d             | _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
00cbc 12d             | _1us_           res     1         ' 1us
00cbc 12d             | _10us_          res     1         ' 10us
00cbc 12d             | _33us_          res     1         ' 33us
00cbc 12d             | _txn_err_       res     1         ' 250us
00cbc 12d             | _500us_         res     1         ' 500us
00cbc 12d             | _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
00cbc 12d             | _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
00cbc 12d             | _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
00cbc 12d             | _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
00cbc 12d             | _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
00cbc 12d             | _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
00cbc 12d             | _preamble_wait_ res     1
00cbc 12d             | _1ms_           res     1         ' 1ms
00cbc 12d             | _2ms_           res     1         ' 2ms
00cbc 12d             | _suspend_wait_  res     1         ' 3ms
00cbc 12d             | _4ms_           res     1         ' 4ms
00cbc 12d             | _xfer_wait_     res     1         ' 5ms
00cbc 12d             | _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
00cbc 12d             | _reset_hold_    res     1         ' 15ms
00cbc 12d             | _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
00cbc 12d             | _21ms_          res     1         ' 21ms
00cbc 12d             | _100ms_         res     1         ' 100ms
00cbc 12d             | _500ms_         res     1         ' 500ms
00cbc 12d             | _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
00cbc 12d             | _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
00cbc 12d             | '------------------------------------------------------------------------------
00cbc 12d             | _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
00cbc 12d             | _usb_d_ls_nco_  res     1
00cbc 12d             | _usb_h_fs_nco_  res     1
00cbc 12d             | _usb_d_fs_nco_  res     1
00cbc 12d             | '------------------------------------------------------------------------------
00cbc 12d             | ' Scratch registers
00cbc 12d             | htmp            res     1         ' Scratch registers whose context remains within the same code block
00cbc 12d             | htmp1           res     1
00cbc 12d             | htmp2           res     1
00cbc 12d             | htmp3           res     1
00cbc 12d             | hrep            res     1         ' Repeat count
00cbc 12d             | hsave0          res     1         ' Subroutine parameter saves
00cbc 12d             | hsave1          res     1
00cbc 12d             | hsave2          res     1
00cbc 12d             | isrtmp1         res     1
00cbc 12d             | pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
00cbc 12d             | hr0             res     1         ' Multi-purpose registers
00cbc 12d             | hr1             res     1
00cbc 12d             | hr2             res     1
00cbc 12d             | hr3             res     1
00cbc 12d             | hpar1           res     1         ' Routine entry/exit parameters
00cbc 12d             | hpar2           res     1
00cbc 12d             | hpar3           res     1
00cbc 12d             | hct2            res     1         ' Function response bus turn-around timer
00cbc 12d             | hct3            res     1         ' Keyboard/mouse poll timer
00cbc 12d             | mod_cnt         res     1         ' Used in idle loops
00cbc 12d             | 
00cbc 12d             |                 fit     $1F0
00cbc 12d             |                 fit     $1F0
00cbc 12d             |                 org     $200
00cbc 200             | hlut_start
00cbc 200             | 
00cbc 200             | '------------------------------------------------------------------------------
00cbc 200             | ' Full-speed is the host's native speed, so all that is needed is to set the FS
00cbc 200             | ' settings to startup defaults.
00cbc 200             | '------------------------------------------------------------------------------
00cbc 200             | ' On entry:
00cbc 200             | ' On exit: Save/restore caller C flag state if C is changed in this routine!
00cbc 200             | '------------------------------------------------------------------------------
00cbc 200             | set_speed_full
00cbc 200 D0 E8 07 F6 |                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
00cc0 201 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
00cc4 202 A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
00cc8 203 A4 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
00ccc 204             | '                ret                             wcz     ' Restore caller flags on exit
00ccc 204             | 
00ccc 204             | '------------------------------------------------------------------------------
00ccc 204             | ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
00ccc 204             | ' is a downstream hub connected (not yet implemented), the baud generator
00ccc 204             | ' remains set at the full-speed rate, but signaling is switched to low-speed,
00ccc 204             | ' which reverses the D-/D+ polarity. The polarity can be changed without
00ccc 204             | ' putting the smart pins into reset.
00ccc 204             | '------------------------------------------------------------------------------
00ccc 204             | ' On entry:
00ccc 204             | ' On exit: CZ flags restored to caller states
00ccc 204             | '------------------------------------------------------------------------------
00ccc 204             | set_speed_low
00ccc 204 80 96 CE F7 |                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
00cd0 205 ED E8 07 A6 |         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
00cd4 206 22 6B 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
00cd8 207 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
00cdc 208 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
00ce0 209 A3 9B 02 F6 |                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
00ce4 20a 02 96 26 F4 |                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
00ce8 20b 2D 00 7C FD |                 ret                             wcz     ' Restore caller flags on exit
00cec 20c             | 
00cec 20c             | '------------------------------------------------------------------------------
00cec 20c             | ' Perform configuration stuff required when a device intitially connects.
00cec 20c             | '------------------------------------------------------------------------------
00cec 20c             | ' On entry:
00cec 20c             | ' On exit:
00cec 20c             | '------------------------------------------------------------------------------
00cec 20c             | on_connect
00cec 20c 02 86 07 F6 |                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
00cf0 20d D8 FB BF FD |                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
00cf4 20e             | .retry
00cf4 20e 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
00cf8 20f 01 8E 07 C6 |         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
00cfc 210 02 8E 07 36 |         if_nc   mov     hpar1, #USB_SPEED_FULL
00d00 211 00 08 00 FF 
00d04 212 00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
00d08 213 20 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
00d0c 214 47 F1 03 F1 |                 add     ptra, hcog_base_addr
00d10 215 03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
00d14 216 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
00d18 217 F4 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
00d1c 218 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00d20 219 18 00 90 AD |         if_z    jmp     #.get_dev_desc
00d24 21a B2 99 02 F6 |                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
00d28 21b 4C 03 B0 FD |                 call    #poll_waitx
00d2c 21c 01 86 8F F1 |                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
00d30 21d F0 FB 9F AD |         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
00d34 21e A4 FB BF FD |                 call    #reset                          ' Try another reset to see if the device responds
00d38 21f B8 FF 9F FD |                 jmp     #.retry
00d3c 220             | .get_dev_desc
00d3c 220 28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
00d40 221 07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
00d44 222 F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
00d48 223 A8 99 02 F6 |                 mov     hctwait, _1ms_
00d4c 224 28 03 B0 FD |                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
00d50 225 88 FB BF FD |                 call    #reset
00d54 226 38 1E C0 FE |                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
00d58 227 47 F1 03 F1 |                 add     ptra, hcog_base_addr
00d5c 228 01 11 5C FC |                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
00d60 229 D8 01 B0 FD |                 call    #control_write                  ' Execute SetAddress()
00d64 22a D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00d68 22b 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
00d6c 22c AD 99 02 F6 |                 mov     hctwait, _8ms_
00d70 22d 04 03 B0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
00d74 22e 04 00 00 FF 
00d78 22f 00 BC 06 F6 |                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
00d7c 230 34 FA BF FD |                 call    #calc_crc5
00d80 231 20 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
00d84 232 47 F1 03 F1 |                 add     ptra, hcog_base_addr
00d88 233 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
00d8c 234 F7 AD C2 FA |                 rdbyte  total_data, pb
00d90 235 03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
00d94 236 78 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
00d98 237 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00d9c 238 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
00da0 239 5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
00da4 23a 28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
00da8 23b 07 DB C6 FA |                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
00dac 23c A0 99 02 F6 |                 mov     hctwait, _500us_
00db0 23d C4 02 B0 FD |                 call    #poll_waitx
00db4 23e 28 1E C0 FE |                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
00db8 23f 47 F1 03 F1 |                 add     ptra, hcog_base_addr
00dbc 240 03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
00dc0 241 29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
00dc4 242 48 00 B0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
00dc8 243 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00dcc 244 2D 00 64 5D |         if_nz   ret
00dd0 245 29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
00dd4 246 F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
00dd8 247 61 87 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
00ddc 248 61 89 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
00de0 249 00 73 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
00de4 24a 09 86 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
00de8 24b 02 88 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
00dec 24c 56 73 1B A2 |         if_z    cmp     htmp, total_data        wcz
00df0 24d 0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
00df4 24e 2C FB 9F CD |         if_b    jmp     #host_error
00df8 24f 24 13 80 FE |                 loc     pa, #@init_kbdm_data - @usb_host_start
00dfc 250 47 ED 03 F1 |                 add     pa, hcog_base_addr
00e00 251 2D EC 63 FD |                 call    pa
00e04 252 B8 0D 80 FE |                 loc     pa, #@hparse_con_desc - @usb_host_start
00e08 253 47 ED 03 F1 |                 add     pa, hcog_base_addr
00e0c 254 2C EC 63 FD |                 jmp     pa
00e10 255             | 
00e10 255             | '------------------------------------------------------------------------------
00e10 255             | ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
00e10 255             | ' Status reporting is always in the function-to-host direction.
00e10 255             | '------------------------------------------------------------------------------
00e10 255             | ' On entry:
00e10 255             | '   PTRA - start address of the SETUP data in hub.
00e10 255             | '   PB - start address of the buffer/struct to be written to during the IN data
00e10 255             | '     stage.
00e10 255             | '   ep_addr_pid - device address, endpoint and CRC5.
00e10 255             | ' On exit:
00e10 255             | '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
00e10 255             | '     contains the count of data stage bytes actually received, which must
00e10 255             | '     always be <= the count requested.
00e10 255             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
00e10 255             | '     more specific USB operation error code.
00e10 255             | '------------------------------------------------------------------------------
00e10 255             | control_read
00e10 255 5E 8F 03 F6 |                 mov     hpar1, ep_addr_pid
00e14 256 F8 91 03 F6 |                 mov     hpar2, ptra
00e18 257 F7 93 03 F6 |                 mov     hpar3, pb                       ' Save dest buffer pointer
00e1c 258 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
00e20 259             | .xfer_start
00e20 259 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
00e24 25a C0 F6 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
00e28 25b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00e2c 25c 2D 00 64 5D |         if_nz   ret                                     ' Back to caller to handle error
00e30 25d 00 AC 0E F2 |                 cmp     total_data, #0          wz
00e34 25e 90 01 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
00e38 25f 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
00e3c 260 61 00 00 FF 
00e40 261 50 9F 06 F6 |                 mov     nak_retry, ##IN_NAK_RETRIES
00e44 262 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
00e48 263             | .data
00e48 263 56 B1 02 F6 |                 mov     pkt_data, total_data
00e4c 264 57 B1 82 F1 |                 sub     pkt_data, stage_data
00e50 265 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
00e54 266 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
00e58 267             | .nak_retry
00e58 267 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
00e5c 268             | .in_retry
00e5c 268 BC F6 BF FD |                 call    #txn_in
00e60 269 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
00e64 26a 28 00 90 AD |         if_z    jmp     #.commit
00e68 26b 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
00e6c 26c A8 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
00e70 26d 14 02 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
00e74 26e 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
00e78 26f DC FF 9F AD |         if_z    jmp     #.nak_retry                     ' Function not ready to send data
00e7c 270 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
00e80 271 94 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
00e84 272 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
00e88 273 D0 FF 9F 5D |         if_nz   jmp     #.in_retry                      ' Bus error retry
00e8c 274 2D 00 64 FD |                 ret                                     ' The transfer has failed
00e90 275             | .commit
00e90 275 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
00e94 276 38 00 90 AD |         if_z    jmp     #.pre_status                    ' and also end-of-data
00e98 277 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
00e9c 278 5C 87 03 F6 |                 mov     hr0, pkt_cnt
00ea0 279 F7 F1 0B F2 |                 cmp     ptra, pb                wz
00ea4 27a 6C FA BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
00ea8 27b 5C AF 02 F1 |                 add     stage_data, pkt_cnt             ' Update bytes received on commit
00eac 27c 56 AF 0A F2 |                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
00eb0 27d 1C 00 90 AD |         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
00eb4 27e 58 B9 1A F2 |                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
00eb8 27f 14 00 90 CD |         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
00ebc 280 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET
00ec0 281 5F C1 02 16 |         if_a    mov     context_retval, retval          ' In this case overall and context are the same
00ec4 282 2D 00 64 1D |         if_a    ret                                     ' Caller must handle ERR_PACKET
00ec8 283 03 96 E6 F4 |                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
00ecc 284 78 FF 9F FD |                 jmp     #.data                          ' Start next IN transaction
00ed0 285             | .pre_status
00ed0 285 57 AD 02 F6 |                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
00ed4 286 E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0
00ed8 287 00 B0 06 F6 |                 mov     pkt_data, #0
00edc 288 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
00ee0 289 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
00ee4 28a 61 00 00 FF 
00ee8 28b 50 9F 06 F6 |                 mov     nak_retry, ##OUT_NAK_RETRIES
00eec 28c             | .out_retry
00eec 28c 34 F7 BF FD |                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
00ef0 28d D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00ef4 28e 2D 00 64 AD |         if_z    ret                                     ' All is good when ACK
00ef8 28f 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
00efc 290 18 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
00f00 291 84 01 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
00f04 292 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
00f08 293 0C 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
00f0c 294 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
00f10 295 D8 FF 9F 5D |         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
00f14 296 2D 00 64 FD |                 ret                                     ' Caller must handle transfer retirement
00f18 297             | ' I've encountered transfer STALL, even though the data looks correct, and
00f18 297             | ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
00f18 297             | ' ControlRead() transfer gets things unstuck most of the time...
00f18 297             | .xfer_retry
00f18 297 AC 99 02 F6 |                 mov     hctwait, _xfer_wait_
00f1c 298 58 01 B0 FD |                 call    #poll_waitx
00f20 299 8C F9 BF FD |                 call    #wait_txn_ok
00f24 29a C7 BD 02 F6 |                 mov     ep_addr_pid, hpar1
00f28 29b C8 F1 03 F6 |                 mov     ptra, hpar2
00f2c 29c C9 EF 03 F6 |                 mov     pb, hpar3
00f30 29d BB A1 6E FB |                 djnz    xfer_retry, #.xfer_start
00f34 29e 5F C1 02 F6 |                 mov     context_retval, retval          ' Preserve the USB error code
00f38 29f 07 BE 06 06 |         _ret_   mov     retval, #ERR_XFER_RETRY
00f3c 2a0             | 
00f3c 2a0             | '------------------------------------------------------------------------------
00f3c 2a0             | ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
00f3c 2a0             | ' reporting is always in the function-to-host direction. It is assumed that
00f3c 2a0             | ' the SETUP data struct is filled with the required values.
00f3c 2a0             | '------------------------------------------------------------------------------
00f3c 2a0             | ' On entry:
00f3c 2a0             | '   PTRA - points to the start of the struct for the SETUP data.
00f3c 2a0             | '   PB - the start address of the struct/buffer to be read for the OUT data
00f3c 2a0             | '     stage.
00f3c 2a0             | '   ep_addr_pid - the proper CRC'd address and endpoint to use.
00f3c 2a0             | ' On exit:
00f3c 2a0             | '   retval - used to convey the success/failure of each stage.
00f3c 2a0             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
00f3c 2a0             | '     more specific USB operation error code.
00f3c 2a0             | '------------------------------------------------------------------------------
00f3c 2a0             | control_write
00f3c 2a0 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
00f40 2a1 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
00f44 2a2 0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
00f48 2a3             | 
00f48 2a3 5E 8F 03 F6 |                 mov     hpar1, ep_addr_pid
00f4c 2a4 F8 91 03 F6 |                 mov     hpar2, ptra
00f50 2a5 F7 93 03 F6 |                 mov     hpar3, pb
00f54 2a6 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
00f58 2a7             | .xfer_start
00f58 2a7 00 9E 06 F6 |                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
00f5c 2a8 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
00f60 2a9 84 F5 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
00f64 2aa D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00f68 2ab EC 00 90 5D |         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
00f6c 2ac 00 AC 0E F2 |                 cmp     total_data, #0          wz
00f70 2ad 54 00 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
00f74 2ae 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
00f78 2af E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
00f7c 2b0 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
00f80 2b1 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
00f84 2b2             | .data
00f84 2b2 56 B1 02 F6 |                 mov     pkt_data, total_data
00f88 2b3 57 B1 82 F1 |                 sub     pkt_data, stage_data
00f8c 2b4 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
00f90 2b5 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
00f94 2b6             | .out_retry
00f94 2b6 F7 F1 03 F6 |                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
00f98 2b7 88 F6 BF FD |                 call    #txn_out
00f9c 2b8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00fa0 2b9 10 00 90 AD |         if_z    jmp     #.commit                        ' Function got the data
00fa4 2ba E0 00 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
00fa8 2bb 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
00fac 2bc E4 FF 9F 5D |         if_nz   jmp     #.out_retry
00fb0 2bd A4 00 90 FD |                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
00fb4 2be             | .commit
00fb4 2be F8 EF 03 F6 |                 mov     pb, ptra                        ' Save the current buffer/struct location
00fb8 2bf 58 AF 02 F1 |                 add     stage_data, pkt_data
00fbc 2c0 56 AF 0A F2 |                 cmp     stage_data, total_data  wz
00fc0 2c1 03 96 E6 54 |         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
00fc4 2c2 BC FF 9F 5D |         if_nz   jmp     #.data                          ' More data to send
00fc8 2c3             | pre_status_in
00fc8 2c3 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
00fcc 2c4 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
00fd0 2c5             | .status_retry
00fd0 2c5 00 B0 06 F6 |                 mov     pkt_data, #0
00fd4 2c6 44 F5 BF FD |                 call    #txn_in
00fd8 2c7 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
00fdc 2c8 00 B0 0E A2 |         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
00fe0 2c9 74 00 90 AD |         if_z    jmp     #dwnstream_reset                ' Control Write finished
00fe4 2ca 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
00fe8 2cb 2D 00 64 AD |         if_z    ret
00fec 2cc 98 00 B0 FD |                 call    #retry_wait                     ' NAK or bus error, so delay a bit
00ff0 2cd 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
00ff4 2ce D8 FF 9F 5D |         if_nz   jmp     #.status_retry
00ff8 2cf             | '               ret                                     ' Caller must handle transfer retirement
00ff8 2cf             | 
00ff8 2cf             | '------------------------------------------------------------------------------
00ff8 2cf             | ' Execute an IN interrupt transaction.
00ff8 2cf             | '------------------------------------------------------------------------------
00ff8 2cf             | ' On entry:
00ff8 2cf             | '   ep_addr_pid - The function address and endpoint for the IN request.
00ff8 2cf             | '   hpar2 - Address of the IN data buffer
00ff8 2cf             | '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
00ff8 2cf             | ' On exit:
00ff8 2cf             | '   retval - the result of the operation.
00ff8 2cf             | '   hpar3 - the count of IN data bytes actually received.
00ff8 2cf             | '------------------------------------------------------------------------------
00ff8 2cf             | do_int_in
00ff8 2cf 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
00ffc 2d0 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
01000 2d1 0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
01004 2d2             | 
01004 2d2 C9 73 33 F9 |                 getword htmp, hpar3, #0
01008 2d3 C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz
0100c 2d4 03 96 A6 F4 |                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
01010 2d5 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES
01014 2d6             | .retry
01014 2d6 C9 B1 3A F9 |                 getword pkt_data, hpar3, #1             ' IN max packet length
01018 2d7 00 F5 BF FD |                 call    #txn_in
0101c 2d8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK if data received
01020 2d9 1C 00 90 AD |         if_z    jmp     #.commit
01024 2da 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
01028 2db 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
0102c 2dc 24 00 90 AD |         if_z    jmp     #.post_ret                      ' The caller must handle either
01030 2dd 54 00 B0 FD |                 call    #retry_wait
01034 2de 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
01038 2df 18 00 90 AD |         if_z    jmp     #.post_ret
0103c 2e0 D4 FF 9F FD |                 jmp     #.retry
01040 2e1             | .commit
01040 2e1 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy the rx buffer
01044 2e2 C8 EF 03 F6 |                 mov     pb, hpar2                       ' to the destination buffer
01048 2e3 5C 87 0B F6 |                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
0104c 2e4 F7 F1 0B 52 |         if_nz   cmp     ptra, pb                wz
01050 2e5 C0 F8 BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
01054 2e6             | .post_ret
01054 2e6 5C 93 03 F6 |                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
01058 2e7             | 
01058 2e7             | 
01058 2e7             | '------------------------------------------------------------------------------
01058 2e7             | ' Resets the downstream hub port to FS
01058 2e7             | '------------------------------------------------------------------------------
01058 2e7             | dwnstream_reset
01058 2e7 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
0105c 2e8 2D 00 64 3D |         if_nc   ret                                     ' No LS device, reset not needed
01060 2e9             | 
01060 2e9 0E 6A 07 F4 |                 bitl    _usb_h_ls_nco_, #14
01064 2ea 07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
01068 2eb 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
0106c 2ec 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
01070 2ed A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
01074 2ee A4 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
01078 2ef             | 
01078 2ef             | '------------------------------------------------------------------------------
01078 2ef             | ' The one millisecond frame timer is implemented as an interrupt service
01078 2ef             | ' routine. Since this timing is critical, care must be taken to avoid any
01078 2ef             | ' instructions that can delay the interrupt branch, which will likely upset
01078 2ef             | ' the timer. WAITX is among those instructions, so any time you're inside
01078 2ef             | ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
01078 2ef             | '------------------------------------------------------------------------------
01078 2ef             | ' On entry:
01078 2ef             | '   hctwait - wait interval in sysclocks.
01078 2ef             | ' On exit:
01078 2ef             | '------------------------------------------------------------------------------
01078 2ef             | poll_waitx
01078 2ef 1A 94 63 FD |                 getct   hct2
0107c 2f0 4C 95 6B FA |                 addct2  hct2, hctwait
01080 2f1             | .wait
01080 2f1 FF 25 CC FB |                 jnct2   #.wait
01084 2f2 2D 00 64 FD |                 ret
01088 2f3             | 
01088 2f3             | '------------------------------------------------------------------------------
01088 2f3             | ' Transaction retry handling for NAK/STALL or bus error.
01088 2f3             | '------------------------------------------------------------------------------
01088 2f3             | ' On entry:
01088 2f3             | '   retval - transaction response PID or error code.
01088 2f3             | ' On exit:
01088 2f3             | '------------------------------------------------------------------------------
01088 2f3             | retry_wait
01088 2f3 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
0108c 2f4 2D 00 64 AD |         if_z    ret                                     ' STALL is special case
01090 2f5 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
01094 2f6 14 00 90 AD |         if_z    jmp     #.nak
01098 2f7 9F 99 02 F6 |                 mov     hctwait, _txn_err_              ' Transaction error wait...
0109c 2f8 D8 FF BF FD |                 call    #poll_waitx
010a0 2f9             | .dec
010a0 2f9 01 A2 8E F1 |                 sub     retry, #1               wz
010a4 2fa 06 BE 06 A6 |         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
010a8 2fb 2D 00 64 FD |                 ret                                     ' Retry result to caller
010ac 2fc             | .nak
010ac 2fc 9E 99 02 F6 |                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
010b0 2fd C4 FF BF FD |                 call    #poll_waitx
010b4 2fe 00 9E 0E F2 |                 cmp     nak_retry, #NAK_NOLIMIT wz
010b8 2ff 2D 00 64 AD |         if_z    ret                                     ' Indefinite NAK retries
010bc 300 01 9E 8E F1 |                 sub     nak_retry, #1           wz
010c0 301 08 BE 06 A6 |         if_z    mov     retval, #ERR_NAK
010c4 302 2D 00 64 FD |                 ret
010c8 303             | 
010c8 303             | host_reset
010c8 303 25 00 64 FD |                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
010cc 304 14 72 07 FB |                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
010d0 305             | ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
010d0 305 BD 01 05 FF 
010d4 306 00 72 1F F2 |                 cmp     htmp, ##168_000_000     wcz
010d8 307 00 94 06 E6 |         if_be   mov     utx_tweak, #0
010dc 308 03 94 06 16 |         if_a    mov     utx_tweak, #3   '#20
010e0 309             | ' Check to see if the system clock has been changed.
010e0 309 2C 73 0B F2 |                 cmp     htmp, save_sysclk       wz
010e4 30a C4 0B A0 5E |         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
010e8 30b 47 EF 03 51 |         if_nz   add     pb, hcog_base_addr
010ec 30c 2D EE 63 5D |         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
010f0 30d 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
010f4 30e 40 46 62 FD |                 dirl    dp
010f8 30f             | 
010f8 30f 28 02 64 FD |                 setq    #1
010fc 310 80 00 80 FF 
01100 311 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
01104 312 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
01108 313             | .enable
01108 313 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
0110c 314 41 46 62 FD |                 dirh    dp
01110 315 1F 38 63 FD |                 waitx   _1us_
01114 316 22 01 28 FC |                 wypin   #OUT_IDLE, dm
01118 317             | 
01118 317             |                 ' Handle Port protection enable and startup delay
01118 317 00 48 56 F2 |                 cmps    usb_enable_pin, #0      wc
0111c 318 58 48 62 3D |         if_ae   drvl    usb_enable_pin                 ' disable port
01120 319 1F 60 63 FD |                 waitx   _21ms_                          ' Wait a while for everything to turn off
01124 31a 59 48 62 3D |         if_ae   drvh    usb_enable_pin                  ' Enable the port
01128 31b 1F 60 63 FD |                 waitx   _21ms_                          ' Hold to let the idle state get settled
0112c 31c             | 
0112c 31c             |                 'call #dev_reset ' TODO THINK ABOUT THIS
0112c 31c             | 
0112c 31c             | discon_entry
0112c 31c 03 98 07 F6 |                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
01130 31d             | 
01130 31d 4B ED B7 F9 |                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
01134 31e 3B 04 DC FC |                 rep     @.regloop,#hreg_init_end - hreg_init_start
01138 31f 38 EC A7 F9 |                 alti    pa, #%000_111_000
0113c 320 00 00 04 F6 |                 mov     0-0, #0
01140 321             | .regloop
01140 321             |               
01140 321             |         if HAVE_HIDPAD
01140 321 F8 27 A0 FE |                 loc     pb, #@hidpad_report - @usb_host_start
01144 322 47 EF 03 F1 |                 add     pb, hcog_base_addr
01148 323 28 6E 64 FD |                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
0114c 324 F7 01 68 FC |                 wrlong  #0,pb
01150 325             |         end
01150 325             |         if EMUPAD_MAX_PLAYER > 0
01150 325             |         end
01150 325             | 
01150 325             |                 ' Fall through to disconnected loop
01150 325             | 
01150 325             | '-----------------------------------------------------------------------------------------------------------------
01150 325             | ' Device connect handling (Section 7.1.7.3).
01150 325             | '-----------------------------------------------------------------------------------------------------------------
01150 325             | ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
01150 325             | ' device to connect (Section 7.1.7.3).
01150 325             | '-----------------------------------------------------------------------------------------------------------------
01150 325             | disconnected
01150 325 14 88 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
01154 326 2C 89 0B F2 |                 cmp     hr1, save_sysclk        wz
01158 327 6C FF 9F 5D |         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
0115c 328 03 88 47 F0 |                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
01160 329 1F 88 63 FD |                 waitx   hr1                             ' it down to smaller wait chunks
01164 32a             |         if ACTIVITY_LED >= 0
01164 32a             |         end
01164 32a 22 A7 82 FA |                 rqpin   urx, dm
01168 32b 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
0116c 32c E0 FF 9F AD |         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
01170 32d 28 00 90 5D |         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
01174 32e             | .se1_test
01174 32e B1 99 02 F6 |                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
01178 32f FC FE BF FD |                 call    #poll_waitx
0117c 330 22 A7 82 FA |                 rqpin   urx, dm
01180 331 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
01184 332 00 BE 06 56 |         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
01188 333 A0 FF 9F 5D |         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
0118c 334             | .se1            'SE1 is a fatal error condition
0118c 334 B1 99 02 F6 |                 mov     hctwait, _100ms_
01190 335 E4 FE BF FD |                 call    #poll_waitx
01194 336 03 BE 06 F6 |                 mov     retval, #ERR_SE1
01198 337 88 F7 BF FD |                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
0119c 338             | .connect_test                                           ' Test lines until stable J/K state seen
0119c 338 1F 62 63 FD |                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
011a0 339 22 A7 82 FA |                 rqpin   urx, dm
011a4 33a 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
011a8 33b 80 FF 9F AD |         if_z    jmp     #discon_entry                   ' D+ and D- low
011ac 33c C4 FF 9F AD |         if_e    jmp     #.se1_test                      ' D+ and D- high
011b0 33d             | connected
011b0 33d 01 96 26 F4 |                 bith    hstatus, #CONNECTEDB            ' Device plugged in
011b4 33e 34 FB BF FD |                 call    #on_connect                     ' Initial device configuration
011b8 33f D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
011bc 340 6C FF 9F 5D |         if_nz   jmp     #discon_entry
011c0 341             | .set_pulse
011c0 341 1A 66 63 FD |                 getct   _pulse_time_
011c4 342 B2 67 03 F1 |                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
011c8 343             | ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
011c8 343             | ' of 1ms and make a correction, if necessary.
011c8 343             | '                mov     htmp, _1ms_
011c8 343             | '                subs    htmp, iframe_delta
011c8 343             | '                adds    _frame1ms_clks_, htmp
011c8 343             | '                debug(udec(_frame1ms_clks_))
011c8 343             | 
011c8 343             |                 ' Fall through to idle/processing loop
011c8 343 07 5A 1E F2 |                 cmp     hdev_port, #MAX_DEVICES wcz
011cc 344 00 5A 06 16 |         if_a    mov     hdev_port, #0 
011d0 345             | 
011d0 345             | hidle
011d0 345 22 A7 82 FA |                 rqpin   urx, dm
011d4 346 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
011d8 347 98 00 90 CD |         if_c    jmp     #.se0_test
011dc 348 24 06 70 FD |                 pollct3                         wc
011e0 349 68 00 90 3D |         if_nc   jmp     #.nopoll
011e4 34a 1A 96 63 FD |                 getct   hct3
011e8 34b A8 97 73 FA |                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
011ec 34c             | 
011ec 34c 6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
011f0 34d 00 72 E3 F8 |                 getbyte htmp
011f4 34e             | 
011f4 34e 09 72 0F F2 |                 cmp     htmp, #HUB_READY        wz
011f8 34f 8C 1B 80 AE |         if_z    loc     pa, #@hget_hub_status - @usb_host_start
011fc 350 40 00 90 AD |         if_z    jmp     #.poll
01200 351             | 
01200 351             |         if _HAVE_GAMEPAD
01200 351 06 72 0F F2 |                 cmp     htmp, #HID_READY        wz
01204 352 08 72 0F 52 |         if_nz   cmp     htmp, #PS3_READY        wz
01208 353 07 72 0F 52 |         if_nz   cmp     htmp, #XINPUT_READY     wz
0120c 354 F4 15 80 AE |         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
01210 355 2C 00 90 AD |         if_z    jmp     #.poll
01214 356             |         end
01214 356             | 
01214 356             |         if HAVE_MOUSE
01214 356 04 72 0F F2 |                 cmp     htmp, #M_READY          wz
01218 357 44 15 80 AE |         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
0121c 358 20 00 90 AD |         if_z    jmp     #.poll
01220 359             |         end
01220 359             | 
01220 359 03 72 0F F2 |                 cmp     htmp, #KB_READY         wz
01224 35a AC 13 80 AE |         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
01228 35b 14 00 90 AD |         if_z    jmp     #.poll
0122c 35c             | 
0122c 35c 05 72 0F F2 |                 cmp     htmp, #KBM_READY        wz
01230 35d 14 00 90 5D |         if_nz   jmp     #.skip_poll
01234 35e 09 96 FE F4 |                 bitnot  hstatus, #KBM_TOGGLEB   wcz
01238 35f AC 13 80 3E |         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
0123c 360             |         if HAVE_MOUSE
0123c 360 44 15 80 CE |         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
01240 361             |         else
01240 361             |         end
01240 361             | 
01240 361             | .poll
01240 361 47 ED 03 F1 |                 add     pa, hcog_base_addr
01244 362 2D EC 63 FD |                 call    pa
01248 363             | .skip_poll
01248 363             | 
01248 363 07 5A 06 F7 |                 incmod  hdev_port, #MAX_DEVICES
0124c 364             | 
0124c 364             | .nopoll
0124c 364 0E 40 0E F2 |                 cmp     cmd_data, #CMD_SUSPEND  wz
01250 365 44 00 90 AD |         if_z    jmp     #hsuspend
01254 366 10 40 0E F2 |                 cmp     cmd_data, #CMD_RESET    wz
01258 367 00 40 06 A6 |         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
0125c 368 68 FE 9F AD |         if_z    jmp     #host_reset                     ' See if it works...
01260 369 1A 86 63 FD |                 getct   hr0
01264 36a B3 87 1B F2 |                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
01268 36b             |         if ACTIVITY_LED >= 0
01268 36b             |         end
01268 36b 1A 66 63 3D |         if_ae   getct   _pulse_time_
0126c 36c B2 67 03 31 |         if_ae   add     _pulse_time_, _500ms_
01270 36d 5C FF 9F FD |                 jmp     #hidle
01274 36e             | ' Check for extended SE0 state on the bus
01274 36e             | .se0_test
01274 36e A8 99 02 F6 |                 mov     hctwait, _1ms_
01278 36f FC FD BF FD |                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
0127c 370 22 A7 82 FA |                 rqpin   urx, dm
01280 371 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
01284 372 48 FF 9F 3D |         if_nc   jmp     #hidle                          ' Bus still IDLE
01288 373 24 F6 BF FD |                 call    #wait_txn_ok
0128c 374 00 00 80 FF 
01290 375 22 01 28 FC |                 wypin   ##OUT_IDLE, dm                  ' Float USB
01294 376             |                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
01294 376 94 FE 9F FD |                 jmp     #discon_entry                   ' Device disconnected
01298 377             | 
01298 377             | hsuspend
01298 377 14 F6 BF FD |                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
0129c 378 25 00 64 FD |                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
012a0 379 1F 54 63 FD |                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
012a4 37a 22 01 28 FC |                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
012a8 37b 00 40 06 F6 |                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
012ac 37c 00 98 07 F6 |                 mov     mod_cnt, #0
012b0 37d             | 
012b0 37d             |                 ' Fall through to resume wait loop
012b0 37d             | 
012b0 37d             | hwait_resume
012b0 37d 14 88 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
012b4 37e 02 88 47 F0 |                 shr     hr1, #2
012b8 37f 1F 88 63 FD |                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
012bc 380             |         if ACTIVITY_LED >= 0
012bc 380             |         end
012bc 380 0F 40 0E F2 |                 cmp     cmd_data, #CMD_RESUME   wz
012c0 381 EC FF 9F 5D |         if_nz   jmp     #hwait_resume
012c4 382 14 72 07 FB |                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
012c8 383 2C 73 0B F2 |                 cmp     htmp, save_sysclk       wz
012cc 384 18 00 90 AD |         if_z    jmp     #.resume
012d0 385 C4 0B A0 FE |                 loc     pb, #@hinit_usb_timings - @usb_host_start
012d4 386 47 EF 03 F1 |                 add     pb, hcog_base_addr
012d8 387 2D EE 63 FD |                 call    pb                              ' Recalculate sysclk dependent timing values
012dc 388 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
012e0 389 22 6F 13 3C |         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
012e4 38a 22 6B 13 CC |         if_c    wxpin   _usb_h_ls_nco_, dm
012e8 38b             | .resume
012e8 38b 22 05 28 FC |                 wypin   #OUT_K, dm
012ec 38c 1F 5E 63 FD |                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
012f0 38d 22 03 28 FC |                 wypin   #OUT_SE0, dm
012f4 38e A3 73 03 F6 |                 mov     htmp, _ip_delay_ls_
012f8 38f 01 72 47 F0 |                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
012fc 390 1F 72 63 FD |                 waitx   htmp
01300 391 22 07 28 FC |                 wypin   #OUT_J, dm
01304 392 01 72 47 F0 |                 shr     htmp, #1
01308 393 1F 72 63 FD |                 waitx   htmp
0130c 394 22 01 28 FC |                 wypin   #OUT_IDLE, dm
01310 395 1A 92 62 FD |                 getct   iframe_ct_base
01314 396 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
01318 397 B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
0131c 398 25 02 64 FD |                 setint1 #1                              ' Enable the 1ms frame ISR
01320 399 AB 99 02 F6 |                 mov     hctwait, _4ms_
01324 39a 50 FD BF FD |                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
01328 39b 00 40 06 06 |         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
0132c 39c             | 
0132c 39c             | '------------------------------------------------------------------------------
0132c 39c             | ' Send preamble to enable low-speed HUB ports
0132c 39c             | '------------------------------------------------------------------------------
0132c 39c             | ' On entry:
0132c 39c             | ' On exit:
0132c 39c             | '   USB baud rate set to low-speed
0132c 39c             | '------------------------------------------------------------------------------
0132c 39c             | utx_pre
0132c 39c 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
01330 39d 40 46 62 FD |                 dirl    dp
01334 39e 28 02 64 FD |                 setq    #1
01338 39f 22 01 08 FC |                 wrpin   #0, dm                          ' Disable smartpin mode
0133c 3a0 58 44 62 FD |                 drvl    dm
01340 3a1 59 46 62 FD |                 drvh    dp
01344 3a2             | 
01344 3a2 1E 00 00 FF 
01348 3a3 80 72 07 F6 |                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
0134c 3a4             | 
0134c 3a4 11 08 DC FC |                 rep     @.l1, #16 + 1
01350 3a5 01 72 57 F0 |                 shr     htmp, #1        wc
01354 3a6 28 02 64 3D |         if_nc   setq    #1
01358 3a7 4F 44 62 3D |         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
0135c 3a8 1F 4E 63 FD |                 waitx   _preamble_wait_
01360 3a9             | .l1
01360 3a9             | 
01360 3a9 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
01364 3aa 40 46 62 FD |                 dirl    dp
01368 3ab 28 02 64 FD |                 setq    #1
0136c 3ac 80 00 80 FF 
01370 3ad 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
01374 3ae 22 6B 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
01378 3af 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
0137c 3b0 41 46 62 FD |                 dirh    dp
01380 3b1 22 01 28 FC |                 wypin   #OUT_IDLE, dm
01384 3b2             | 
01384 3b2 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
01388 3b3 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
0138c 3b4 A3 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
01390 3b5             | 
01390 3b5             | hlut_end
01390 3b5             |                 fit     $400
01390 3b5             |                 fit     $400
01390 3b5             |                 orgh
01390                 | if OVERLAP_MEMORY
01390                 |                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
01390                 | end
01390                 | '------------------------------------------------------------------------------
01390                 | ' Routines called from cog space.
01390                 | '------------------------------------------------------------------------------
01390                 | ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
01390                 | '------------------------------------------------------------------------------
01390                 | 
01390                 | '------------------------------------------------------------------------------
01390                 | ' USB host cog initialization.
01390                 | '------------------------------------------------------------------------------
01390                 | usb_host_init
01390                 |                 ' Initialize buffer pointers
01390                 |         if OVERLAP_MEMORY
01390                 |         else
01390     4C 15 B0 FE |                 loc     pb, #hid_descr
01394                 |         end
01394     F7 4B 02 F6 |                 mov     hid_descr_p, pb
01398                 |                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
01398                 |                 {
01398                 |                 }
01398                 |         
01398                 |                 {
01398                 |                 }
01398                 |                 'loc     pb,#hkbd_report
01398                 |                 'mov     hkbd_report_p,pb
01398                 | 
01398     44 1D B0 FE |                 loc     pb, #hub_descr
0139c     F7 4D 02 F6 |                 mov     hub_descr_p, pb
013a0     59 1D B0 FE |                 loc     pb, #urx_buff
013a4     F7 4F 02 F6 |                 mov     urx_buff_p, pb
013a8     D1 1D B0 FE |                 loc     pb, #dev_desc_buff
013ac     F7 51 02 F6 |                 mov     dev_desc_buff_p, pb
013b0     DB 1D B0 FE |                 loc     pb, #con_desc_buff
013b4     F7 53 02 F6 |                 mov     con_desc_buff_p, pb
013b8     24 15 B0 FE |                 loc     pb, #usb_cache_start
013bc     F7 55 02 F6 |                 mov     cache_start_p, pb
013c0     25 1D B0 FE |                 loc     pb, #usb_cache_end
013c4     F7 57 02 F6 |                 mov     cache_end_p, pb
013c8                 | 
013c8                 |         if ERROR_LED >= 0
013c8                 |         end
013c8                 | 
013c8                 |                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
013c8                 |                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
013c8                 |                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
013c8                 | ' Configure and enable the Serial Host USB port.
013c8     03 03 80 FD |                 jmp     #host_reset                     ' Initialize host and enter main processing loop
013cc                 | 
013cc                 | '------------------------------------------------------------------------------
013cc                 | ' Timing calculations happen before any interrupt(s) are enabled.
013cc                 | '------------------------------------------------------------------------------
013cc                 | ' On entry:
013cc                 | '   htmp - current CLKFREQ value.
013cc                 | '------------------------------------------------------------------------------
013cc                 | hinit_usb_timings
013cc                 | '                getct   htmp2
013cc     B9 59 02 F6 |                 mov     save_sysclk, htmp
013d0     8D 5B 80 FF 
013d4     2C 01 2A FD |                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
013d8     18 32 63 FD |                 getqx   _12Mbps_
013dc     10 32 57 F0 |                 shr     _12Mbps_, #16           wc
013e0     00 32 27 F1 |                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
013e4     03 6E 07 F6 |                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
013e8     0E 6E 67 F0 |                 shl     _usb_h_fs_nco_, #14
013ec     99 6F 03 F1 |                 add     _usb_h_fs_nco_, _12Mbps_
013f0     01 70 07 F6 |                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
013f4     0E 70 67 F0 |                 shl     _usb_d_fs_nco_, #14
013f8     99 71 03 F1 |                 add     _usb_d_fs_nco_, _12Mbps_
013fc     99 35 03 F6 |                 mov     _1_5Mbps_, _12Mbps_
01400     03 34 47 F0 |                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
01404     02 6A 07 F6 |                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
01408     0E 6A 67 F0 |                 shl     _usb_h_ls_nco_, #14
0140c     9A 6B 03 F1 |                 add     _usb_h_ls_nco_, _1_5Mbps_
01410     9A 6D 03 F6 |                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
01414     80 00 00 FF 
01418     00 58 06 FD |                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
0141c     18 2E 63 FD |                 getqx   _var_64_lower_
01420     19 30 63 FD |                 getqy   _var_64_upper_
01424     28 2E 63 FD |                 setq    _var_64_lower_
01428     65 CD 1D FF 
0142c     00 30 27 FD |                 qfrac   _var_64_upper_, ##_1b
01430     18 36 63 FD |                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
01434     01 00 00 FF 
01438     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
0143c     18 2E 63 FD |                 getqx   _var_64_lower_
01440     19 30 63 FD |                 getqy   _var_64_upper_
01444     28 2E 63 FD |                 setq    _var_64_lower_
01448     A1 07 00 FF 
0144c     40 30 27 FD |                 qfrac   _var_64_upper_, ##_1m
01450     18 38 63 FD |                 getqx   _1us_                           ' 1us as 32,9 fixed point
01454     9C 7D 03 F6 |                 mov     hsave0, _1us_                   ' Save it to compute other us values
01458     09 38 57 F0 |                 shr     _1us_, #9               wc
0145c     00 38 27 F1 |                 addx    _1us_, #0                       ' Round to final value
01460     0A 7C 07 FD |                 qmul    hsave0, #10                     ' Calc 10us
01464     18 3A 63 FD |                 getqx   _10us_
01468     09 3A 57 F0 |                 shr     _10us_, #9              wc
0146c     00 3A 27 F1 |                 addx    _10us_, #0                      ' 10us
01470     21 7C 07 FD |                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
01474     18 3C 63 FD |                 getqx   _33us_
01478     09 3C 57 F0 |                 shr     _33us_, #9              wc
0147c     00 3C 27 F1 |                 addx    _33us_, #0                      ' 33us
01480     FA 7C 07 FD |                 qmul    hsave0, #250                    ' Calc 250us
01484     18 3E 63 FD |                 getqx   _txn_err_
01488     09 3E 57 F0 |                 shr     _txn_err_, #9           wc
0148c     00 3E 27 F1 |                 addx    _txn_err_, #0                   ' 250us
01490     F4 7D 07 FD |                 qmul    hsave0, #500                    ' Calc 500us
01494     18 40 63 FD |                 getqx   _500us_
01498     09 40 57 F0 |                 shr     _500us_, #9             wc
0149c     00 40 27 F1 |                 addx    _500us_, #0                     ' 500us
014a0     01 00 00 FF 
014a4     9A 7C 07 FD |                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
014a8     18 42 63 FD |                 getqx   _txn_ok_ls_
014ac     09 42 57 F0 |                 shr     _txn_ok_ls_, #9         wc
014b0     00 42 27 F1 |                 addx    _txn_ok_ls_, #0                 ' 666us
014b4     01 00 00 FF 
014b8     52 7D 07 FD |                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
014bc     18 44 63 FD |                 getqx   _txn_ok_fs_
014c0     09 44 57 F0 |                 shr     _txn_ok_fs_, #9         wc
014c4     00 44 27 F1 |                 addx    _txn_ok_fs_, #0                 ' 850us
014c8     9B 47 03 F6 |                 mov     _ip_delay_ls_, _1ns16fp_
014cc     05 00 00 FF 
014d0     80 46 07 FA |                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
014d4     10 46 57 F0 |                 shr     _ip_delay_ls_, #16      wc
014d8     00 46 27 F1 |                 addx    _ip_delay_ls_, #0
014dc     9B 4B 03 F6 |                 mov     _tat_wait_ls_, _1ns16fp_
014e0     1C 00 00 FF 
014e4     C0 4B 07 FA |                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
014e8     10 4A 57 F0 |                 shr     _tat_wait_ls_, #16      wc
014ec     00 4A 27 F1 |                 addx    _tat_wait_ls_, #0
014f0     9B 49 03 F6 |                 mov     _ip_delay_fs_, _1ns16fp_
014f4     00 00 00 FF 
014f8     4E 49 07 FA |                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
014fc     10 48 57 F0 |                 shr     _ip_delay_fs_, #16      wc
01500     00 48 27 F1 |                 addx    _ip_delay_fs_, #0
01504     9B 4D 03 F6 |                 mov     _tat_wait_fs_, _1ns16fp_
01508     04 00 00 FF 
0150c     23 4D 07 FA |                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
01510     10 4C 57 F0 |                 shr     _tat_wait_fs_, #16      wc
01514     00 4C 27 F1 |                 addx    _tat_wait_fs_, #0
01518     8D 5B 00 FF 
0151c     00 59 16 FD |                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
01520     18 4E 63 FD |                 getqx   _preamble_wait_
01524     08 4E 87 F1 |                 sub     _preamble_wait_,# 9 - 1
01528     01 00 00 FF 
0152c     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
01530     18 2E 63 FD |                 getqx   _var_64_lower_
01534     19 30 63 FD |                 getqy   _var_64_upper_
01538     28 2E 63 FD |                 setq    _var_64_lower_
0153c     01 00 00 FF 
01540     E8 31 27 FD |                 qfrac   _var_64_upper_, ##_1thou
01544     18 50 63 FD |                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
01548     09 50 57 F0 |                 shr     _1ms_, #9               wc
0154c     00 50 27 F1 |                 addx    _1ms_, #0                       ' 1ms
01550     FF FF 7F FF 
01554     F2 69 07 F6 |                 mov     _frame1ms_clks_, ##-14
01558     A8 69 43 F1 |                 adds    _frame1ms_clks_, _1ms_
0155c     A8 53 03 F6 |                 mov     _2ms_, _1ms_
01560     01 52 67 F0 |                 shl     _2ms_, #1                       ' 2ms
01564     A8 55 03 F6 |                 mov     _suspend_wait_, _1ms_
01568     A8 55 03 F1 |                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
0156c     A8 57 03 F6 |                 mov     _4ms_, _1ms_
01570     02 56 67 F0 |                 shl     _4ms_, #2                       ' 4ms
01574     AB 59 03 F6 |                 mov     _xfer_wait_, _4ms_
01578     A8 59 03 F1 |                 add     _xfer_wait_, _1ms_              ' 5ms
0157c     AC 5D 03 F6 |                 mov     _reset_hold_, _xfer_wait_       ' 5ms
01580     AE 5F 03 F6 |                 mov     _resume_hold_, _reset_hold_
01584     02 5E 67 F0 |                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
01588     AF 63 03 F6 |                 mov     _100ms_, _resume_hold_          ' 20ms
0158c     01 62 67 F0 |                 shl     _100ms_, #1                     ' 40ms
01590     A8 5B 03 F6 |                 mov     _8ms_, _1ms_
01594     03 5A 67 F0 |                 shl     _8ms_, #3                       ' 8ms
01598     01 5C 67 F0 |                 shl     _reset_hold_, #1                ' 10ms
0159c     AE 63 03 F1 |                 add     _100ms_, _reset_hold_           ' 50ms
015a0     AC 5D 03 F1 |                 add     _reset_hold_, _xfer_wait_       ' 15ms
015a4     AC 61 03 F6 |                 mov     _21ms_, _xfer_wait_             ' 5ms
015a8     02 60 67 F0 |                 shl     _21ms_, #2                      ' 20ms
015ac     A8 61 03 F1 |                 add     _21ms_, _1ms_                   ' 21ms
015b0     B1 65 03 F6 |                 mov     _500ms_, _100ms_                ' 50ms
015b4     01 62 67 F0 |                 shl     _100ms_, #1                     ' 100ms
015b8     03 64 67 F0 |                 shl     _500ms_, #3                     ' 400ms
015bc     B1 65 03 01 |         _ret_   add     _500ms_, _100ms_                ' 500ms
015c0                 | '        _ret_   mov     _1sec_, save_sysclk
015c0                 | '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
015c0                 | '                ret
015c0                 | {
015c0                 | }
015c0                 | 
015c0                 | '------------------------------------------------------------------------------
015c0                 | ' Parse a configuration descriptor chain to see if the device is a recognized
015c0                 | ' one. If it is, start the task progression that will configure the device for
015c0                 | ' use.
015c0                 | '------------------------------------------------------------------------------
015c0                 | ' On entry:
015c0                 | '   hconfig_base - start address of the cached config descriptor chain.
015c0                 | ' On exit:
015c0                 | '------------------------------------------------------------------------------
015c0                 | hparse_con_desc
015c0     28 F3 03 F6 |                 mov     ptrb, dev_desc_buff_p
015c4     82 73 07 FB |                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
015c8     61 5B 86 F9 |                 altr    hdev_port,#hdev_id
015cc     4E 72 FF F9 |                 movbyts htmp,#%%1032
015d0     86 D3 E6 FA |                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
015d4                 |                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
015d4                 | 
015d4     02 EC 07 F6 |                 mov     pa, #CON_wTotalLen
015d8     6E ED 03 F1 |                 add     pa, hconfig_base
015dc     F6 DF E2 FA |                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
015e0                 |                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
015e0                 | ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
015e0                 | ' that defines a keyboard and/or mouse.
015e0     6E EB C2 FA |                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
015e4                 | .next_intf
015e4     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
015e8     B8 01 90 3D |         if_ae   jmp     #hset_config
015ec     6E F3 03 F6 |                 mov     ptrb, hconfig_base
015f0     75 F3 03 F1 |                 add     ptrb, hnext_desc
015f4     81 73 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
015f8     04 72 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
015fc     0C 00 90 AD |         if_z    jmp     #.intf
01600     80 73 C7 FA |                 rdbyte  htmp, ptrb
01604     B9 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
01608     D8 FF 9F FD |                 jmp     #.next_intf
0160c                 | .intf
0160c     00 90 07 F6 |                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
01610     00 92 07 F6 |                 mov     hpar3, #0
01614     82 E1 C6 FA |                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
01618     85 E3 C6 FA |                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
0161c     86 E5 C6 FA |                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
01620     87 E7 C6 FA |                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
01624                 |                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
01624                 | 
01624                 | .endp
01624     80 73 C7 FA |                 rdbyte  htmp, ptrb
01628     B9 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
0162c     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
01630     78 00 90 3D |         if_ae   jmp     #.get_device
01634     6E F3 03 F6 |                 mov     ptrb, hconfig_base
01638     75 F3 03 F1 |                 add     ptrb, hnext_desc
0163c     81 73 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
01640     04 72 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
01644     64 00 90 AD |         if_z    jmp     #.get_device
01648     05 72 0F F2 |                 cmp     htmp, #TYPE_ENDPOINT    wz
0164c     04 00 90 AD |         if_z    jmp     #.get_ep
01650     D0 FF 9F FD |                 jmp     #.endp
01654                 | .get_ep
01654     82 89 C7 FA |                 rdbyte  hr1, ptrb[ENDP_bAddress]
01658     07 88 17 F4 |                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
0165c     0F 88 67 F0 |                 shl     hr1, #8 + 7
01660     6C 73 03 F6 |                 mov     htmp, hctrl_ep_addr
01664     3F 00 00 FF 
01668     00 73 07 F5 |                 and     htmp, ##ADDR_MASK
0166c     C4 73 43 F5 |                 or      htmp, hr1                       ' endpoint address
01670     00 90 0F F2 |                 cmp     hpar2, #0               wz
01674     0C 00 90 8D |  if_z_and_c     jmp     #.in_ep
01678     00 92 0F F2 |                 cmp     hpar3, #0               wz
0167c     18 00 90 2D |  if_z_and_nc    jmp     #.out_ep
01680     A0 FF 9F FD |                 jmp     #.endp
01684                 | .in_ep
01684     B9 91 03 F6 |                 mov     hpar2, htmp                     ' IN endpoint
01688     84 8B C7 FA |                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
0168c                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
0168c     86 87 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
01690     C3 8B DB F8 |                 setbyte hr2, hr0, #3
01694     8C FF 9F FD |                 jmp     #.endp
01698                 | .out_ep
01698     B9 93 03 F6 |                 mov     hpar3, htmp                     ' OUT endpoint
0169c     84 8D C7 FA |                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
016a0                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
016a0     86 87 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
016a4     C3 8D DB F8 |                 setbyte hr3, hr0, #3
016a8     78 FF 9F FD |                 jmp     #.endp
016ac                 | 
016ac                 | .get_device
016ac     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
016b0     5D E4 0E A2 |         if_z    cmp     hdev_subclass, #$5D     wz
016b4     01 E6 0E A2 |         if_z    cmp     hdev_protocol, #$01     wz
016b8     64 00 90 AD |         if_z    jmp     #.gamepad
016bc     09 E2 0E F2 |                 cmp     hdev_class, #CLASS_HUB  wz
016c0     A8 00 90 AD |         if_z    jmp     #.hub
016c4     03 E2 0E F2 |                 cmp     hdev_class, #CLASS_HID              wz
016c8     18 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No HID class, ignore
016cc     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
016d0     4C 00 90 AD |         if_z    jmp     #.gamepad
016d4     01 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
016d8     08 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
016dc                 | .keyboard
016dc     01 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
016e0                 |         if HAVE_MOUSE
016e0     1C 00 90 5D |         if_nz  jmp      #.mouse                         ' No Keyboard
016e4                 |         else
016e4                 |         end
016e4     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0    wz
016e8     F8 FE 9F 5D |         if_nz   jmp     #.next_intf
016ec     70 6F E2 F8 |                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
016f0     C5 71 FA F8 |                 getbyte kb_interval, hr2, #3
016f4     C5 73 E2 F8 |                 getbyte kb_in_max_pkt, hr2, #0
016f8     C8 F3 02 F6 |                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
016fc                 |                 'debug(udec(kb_intf_num))
016fc                 |                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
016fc     E4 FE 9F FD |                 jmp     #.next_intf
01700                 | if HAVE_MOUSE
01700                 | .mouse
01700     02 E6 0E F2 |                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
01704     DC FE 9F 5D |         if_nz   jmp     #.next_intf                     ' No Mouse
01708     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0      wz
0170c     D4 FE 9F 5D |         if_nz   jmp     #.next_intf
01710     70 6B E2 F8 |                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
01714                 |                 'getbyte ms_interval, hr2, #3
01714     C5 6D E2 F8 |                 getbyte ms_in_max_pkt, hr2, #0
01718     C8 F5 02 F6 |                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
0171c                 |                 'debug(udec(kb_intf_num))
0171c                 |                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
0171c     C4 FE 9F FD |                 jmp     #.next_intf
01720                 | end
01720                 | .gamepad
01720     79 73 03 F6 |                 mov     htmp, hkbd_ep_addr
01724     C8 73 63 F5 |                 xor     htmp, hpar2
01728     3F 00 00 FF 
0172c     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
01730     B0 FE 9F AD |         if_z    jmp     #.next_intf
01734                 |         if HAVE_MOUSE
01734     7A 73 03 F6 |                 mov     htmp, hmouse_ep_addr
01738     C8 73 63 F5 |                 xor     htmp, hpar2
0173c     3F 00 00 FF 
01740     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
01744     9C FE 9F AD |         if_z    jmp     #.next_intf
01748                 |         end
01748     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
0174c     00 00 0C F2 |                 cmp     0-0, #0                 wz      ' |
01750     90 FE 9F 5D |         if_nz   jmp     #.next_intf
01754                 | 
01754     70 79 E2 F8 |                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
01758     C5 7B FA F8 |                 getbyte gp_interval, hr2, #3
0175c     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
01760     C8 01 00 F6 |                 mov     0-0, hpar2                      ' IN endpoint address
01764     C9 0B 03 F6 |                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
01768                 |                 'debug(udec(gp_intf_num))
01768                 |                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
01768     78 FE 9F FD |                 jmp     #.next_intf
0176c                 | .hub
0176c     00 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
01770     70 FE 9F 5D |         if_nz   jmp     #.next_intf
01774     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
01778     02 E6 0E 52 |         if_nz   cmp     hdev_protocol, #2                   wz
0177c     64 FE 9F 5D |         if_nz   jmp     #.next_intf
01780     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
01784     5C FE 9F 5D |         if_nz   jmp     #.next_intf
01788     70 63 E2 F8 |                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
0178c     6C ED 02 F6 |                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
01790     C8 BD 02 F6 |                 mov     ep_addr_pid, hpar2              ' IN endpoint address
01794     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
01798     5E EF 02 F6 |                 mov     hhub_ep_addr, ep_addr_pid
0179c     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
017a0                 |                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
017a0     40 FE 9F FD |                 jmp     #.next_intf
017a4                 | 
017a4                 | '------------------------------------------------------------------------------
017a4                 | ' If a newly-connected device is recognized, do whatever is needed to configure
017a4                 | ' it according to its function, or functions. In the case of this boot protocol
017a4                 | ' keyboard/mouse class driver:
017a4                 | ' - SetConfiguration(config_num)
017a4                 | ' - SetProtocol(boot)
017a4                 | ' - SetIdle(indefinite)
017a4                 | ' - Enter the device interrupt IN polling task stage.
017a4                 | '------------------------------------------------------------------------------
017a4                 | ' On entry:
017a4                 | ' On exit:
017a4                 | '------------------------------------------------------------------------------
017a4                 | hset_config
017a4                 | '                mov     hkbd_ep_addr, #0                ' DEBUG
017a4                 | '                mov     hmouse_ep_addr, #0              ' DEBUG
017a4     02 76 07 F6 |                 mov     htmp2, #DEV_UNKNOWN
017a8     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
017ac     00 00 0C F2 |                 cmp     0-0, #0                 wz
017b0     00 F2 0E A2 |         if_z    cmp     hkbd_ep_addr, #0        wz
017b4                 |         if HAVE_MOUSE
017b4     00 F4 0E A2 |         if_z    cmp     hmouse_ep_addr, #0      wz
017b8                 |         end
017b8     00 EE 0E A2 |         if_z    cmp     hhub_ep_addr, #0        wz
017bc     60 03 90 AD |         if_z    jmp     #.notify_client                 ' No known device
017c0                 | .set_config
017c0     74 0E D0 FE |                 loc     ptra, #set_config
017c4     05 EC 07 F6 |                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
017c8     6E ED 03 F1 |                 add     pa, hconfig_base
017cc     F6 8F C3 FA |                 rdbyte  hpar1, pa
017d0                 |                 debug("SetConfiguration: ",udec_(hpar1))
017d0     01 8F 57 FC |                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
017d4     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
017d8     00 EE 07 F6 |                 mov     pb, #0                          ' SetConfiguration() has no data stage
017dc     A0 02 A0 FD |                 call    #control_write
017e0     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
017e4     2D 00 64 5D |         if_nz   ret
017e8                 | .kbd_config
017e8     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0        wz
017ec     98 00 90 AD |         if_z    jmp     #.mouse_config                  ' No keyboard
017f0                 | 
017f0     79 73 03 F6 |                 mov     htmp, hkbd_ep_addr
017f4     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
017f8     3F 00 00 FF 
017fc     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
01800     84 00 90 5D |         if_nz   jmp     #.mouse_config                  ' No keyboard
01804                 | 
01804     37 73 E3 F8 |                 getbyte htmp, kb_intf_num, #0
01808     3C 0E D0 FE |                 loc     ptra, #set_protocol
0180c     01 01 5C FC |                 wrword  #BOOT_PROTOCOL, ptra[wValue]
01810     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
01814     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
01818     A0 02 A0 FD |                 call    #control_write
0181c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01820     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
01824     F8 02 90 5D |         if_nz   jmp     #.notify_client
01828     00 8E 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
0182c     37 91 E3 F8 |                 getbyte hpar2, kb_intf_num, #0
01830     44 03 B0 FD |                 call    #hset_idle
01834                 |                 'cmp     retval, #PID_ACK        wz
01834                 |         'if_nz   mov     hkbd_ep_addr, #0
01834                 |         'if_nz   jmp     #.notify_client
01834     A9 99 02 F6 |                 mov     hctwait, _2ms_
01838     EF 02 A0 FD |                 call    #poll_waitx
0183c     00 76 06 F6 |                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
01840                 |         if NUMLOCK_DEFAULT_STATE && RPI_KEYBOARD_NUMLOCK_HACK
01840                 |         end
01840     3B F9 02 F6 |                 mov     hkbd_ledstates, kb_led_states
01844     A0 17 90 FE |                 loc     pa, #hkbd_led_rep
01848     F6 F9 42 FC |                 wrbyte  hkbd_ledstates,pa
0184c     40 03 B0 FD |                 call    #hset_kbdled_report
01850     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01854     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
01858     C4 02 90 5D |         if_nz   jmp     #.notify_client
0185c     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
01860     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
01864     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
01868     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
0186c     5E F3 02 F6 |                 mov     hkbd_ep_addr, ep_addr_pid
01870     6C F1 02 F6 |                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
01874     1F F0 46 F4 |                 bitc    hkbd_ctrl_ep, #31
01878     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
0187c     00 F6 06 F6 |                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
01880     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
01884     03 76 07 F6 |                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
01888                 |         if !!HAVE_MOUSE
01888                 |         end
01888                 | 
01888                 | .mouse_config
01888                 | if HAVE_MOUSE
01888     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0        wz
0188c     AC 00 90 AD |         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
01890     7A 73 03 F6 |                 mov     htmp, hmouse_ep_addr
01894     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
01898     3F 00 00 FF 
0189c     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
018a0     98 00 90 5D |         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
018a4                 | 
018a4                 |                 debug("mouse passed addr check")
018a4                 | 
018a4     B8 0D D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
018a8     00 00 80 FF 
018ac     03 01 5E FC |                 wrword  ##HID_DESCR_LEN, ptra[wLength]
018b0     02 6B 56 FC |                 wrword  ms_intf_num,ptra[wIndex]
018b4     1B 01 A0 FD |                 call    #get_hid_descr_buffer
018b8     55 02 A0 FD |                 call    #control_read
018bc     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
018c0     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
018c4     58 02 90 5D |         if_nz   jmp     #.notify_client
018c8     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
018cc     56 01 00 F6 |                 mov     0-0, total_data
018d0     1B 01 A0 FD |                 call    #get_hid_descr_buffer
018d4                 |                 debug(uhex(pb),uhex_byte_array(pb,total_data))
018d4                 | 
018d4     35 73 E3 F8 |                 getbyte htmp, ms_intf_num, #0
018d8     6C 0D D0 FE |                 loc     ptra, #set_protocol
018dc     01 03 5C FC |                 wrword  #MOUSE_FULL_PROTOCOL ? REPORT_PROTOCOL : BOOT_PROTOCOL, ptra[wValue]
018e0     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
018e4     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
018e8     A0 02 A0 FD |                 call    #control_write
018ec     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
018f0     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
018f4     28 02 90 5D |         if_nz   jmp     #.notify_client
018f8                 |                 debug("mouse passed SetProtocol")
018f8     00 8E 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
018fc     35 91 E3 F8 |                 getbyte hpar2, ms_intf_num, #0
01900     74 02 B0 FD |                 call    #hset_idle
01904                 |                 'cmp     retval, #PID_ACK        wz
01904                 |         'if_nz   mov     hmouse_ep_addr, #0
01904                 |         'if_nz   jmp     #.notify_client
01904                 |                 debug("mouse passed SetIdle")
01904     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
01908     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
0190c     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
01910     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
01914     5E F5 02 F6 |                 mov     hmouse_ep_addr, ep_addr_pid
01918     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
0191c     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
01920     79 77 03 F6 |                 mov     htmp2, hkbd_ep_addr
01924     7A 77 63 F5 |                 xor     htmp2, hmouse_ep_addr
01928     3F 00 00 FF 
0192c     00 77 0F F5 |                 and     htmp2, ##ADDR_MASK              wz
01930     05 76 07 A6 |         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
01934     04 76 07 56 |         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
01938     E4 01 90 FD |                 jmp     #.notify_client
0193c                 | end
0193c                 | .gamepad_config
0193c                 | if _HAVE_GAMEPAD
0193c     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
01940     00 00 0C F2 |                 cmp     0-0, #0                 wz
01944     6C 01 90 AD |         if_z    jmp     #.hub_config                    ' No gamepad
01948     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
0194c     00 72 03 F6 |                 mov     htmp, 0-0
01950     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
01954     3F 00 00 FF 
01958     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
0195c     54 01 90 5D |         if_nz   jmp     #.hub_config                    ' No gamepad
01960                 | 
01960     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
01964     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
01968     69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
0196c     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
01970     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
01974     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
01978     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
0197c     5E 01 00 F6 |                 mov     0-0, ep_addr_pid
01980     85 BD 0A F6 |                 mov     ep_addr_pid, hdev_out_addr  wz
01984     E1 BC C6 58 |         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
01988     BE 00 A0 5D |         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
0198c     09 68 16 54 |         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
01990     1F BC 46 54 |         if_nz   bitc    ep_addr_pid, #31
01994     5E 0B 03 56 |         if_nz   mov     hdev_out_addr, ep_addr_pid
01998     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
0199c                 | 
0199c                 |                 if EMUPAD_MAX_PLAYER > 0
0199c                 |                 
0199c                 | .rule_loop           
0199c                 |                 end
0199c                 | 
0199c     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
019a0     5C 00 90 AD |         if_e    jmp     #.xinput
019a4     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
019a8     00 72 03 F6 |                 mov     htmp,0-0
019ac     01 A6 02 FF 
019b0     68 72 0F F2 |                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
019b4     8C 00 90 AD |         if_e    jmp     #.ps3
019b8                 | 
019b8     A4 0C D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
019bc     00 5A 0E F2 |                 cmp     hdev_port,#0            wz
019c0     00 00 80 5F 
019c4     03 01 5E 5C |         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
019c8     03 00 80 AF 
019cc     03 01 5E AC |         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
019d0     02 01 5C FC |                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
019d4     1B 01 A0 FD |                 call    #get_hid_descr_buffer
019d8     55 02 A0 FD |                 call    #control_read
019dc     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
019e0     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
019e4     00 00 04 56 |         if_nz   mov     0-0, #0
019e8     34 01 90 5D |         if_nz   jmp     #.notify_client
019ec     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
019f0     56 01 00 F6 |                 mov     0-0, total_data
019f4     1B 01 A0 FD |                 call    #get_hid_descr_buffer
019f8                 |                 debug(uhex(pb),udec(total_data),uhex_byte_array(pb,total_data))
019f8                 | 
019f8     06 76 07 F6 |                 mov     htmp2, #HID_READY               ' Standard gamepad
019fc     20 01 90 FD |                 jmp     #.notify_client
01a00                 | .xinput
01a00     B8 0C D0 FE |                 loc     ptra, #xinp_led_cmd             ' Turn on LED
01a04     2D EF 03 F6 |                 mov     pb,hdev_port
01a08     01 EE E7 F2 |                 cmpsub  pb,#1 ' root device is also player 1
01a0c     03 EE 27 F3 |                 fle     pb,#3
01a10     06 EE 07 F1 |                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
01a14     02 EF 47 FC |                 wrbyte  pb, ptra[2]
01a18                 | 
01a18     03 B0 06 F6 |                 mov     pkt_data, #3
01a1c     03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB
01a20     85 BD 02 F6 |                 mov     ep_addr_pid, hdev_out_addr
01a24                 |                 debug("XInput LED set ",uhex_long(ep_addr_pid),uhex_byte(pb))
01a24     5A 00 A0 FD |                 call    #txn_out
01a28     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr
01a2c                 | 
01a2c     97 0C D0 FE |                 loc     ptra, #xinp_fix_8bitdo
01a30     27 EF 03 F6 |                 mov     pb, urx_buff_p          ' We don't actually care where it goes
01a34     55 02 A0 FD |                 call    #control_read           ' Execute GetDeviceDescriptor()
01a38                 |                 debug("8bitdo weird fix... ",uhex(retval))
01a38     D2 BE 06 F6 |                 mov retval,#PID_ACK             ' If we don't do this something else becomes sad (TODO fix?)
01a3c                 | 
01a3c                 | 
01a3c     07 76 07 F6 |                 mov     htmp2, #XINPUT_READY
01a40     DC 00 90 FD |                 jmp     #.notify_client
01a44                 | .ps3
01a44     44 0C D0 FE |                 loc     ptra, #ps3_command_buff         ' Turn on LED
01a48     2D EF 03 F6 |                 mov     pb,hdev_port
01a4c     01 EE 07 F3 |                 fge     pb,#1 ' root device is also player 1
01a50     04 EE 27 F3 |                 fle     pb,#4
01a54     F7 EF C3 F9 |                 decod   pb
01a58     09 EF 47 FC |                 wrbyte  pb, ptra[9]
01a5c                 | 
01a5c     3C 73 E3 F8 |                 getbyte htmp, gp_intf_num, #0
01a60     F4 0B D0 FE |                 loc     ptra, #set_report
01a64     01 00 80 FF 
01a68     01 03 5C FC |                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
01a6c     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
01a70     03 61 5C FC |                 wrword  #48, ptra[wLength]
01a74     14 0C B0 FE |                 loc     pb, #ps3_command_buff
01a78     A0 02 A0 FD |                 call    #control_write
01a7c                 | 
01a7c     3C 73 E3 F8 |                 getbyte htmp, gp_intf_num, #0
01a80     D4 0B D0 FE |                 loc     ptra, #set_report
01a84     01 00 80 FF 
01a88     01 E9 5F FC |                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
01a8c     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
01a90     03 09 5C FC |                 wrword  #4, ptra[wLength]
01a94     F0 0B B0 FE |                 loc     pb, #ps3_enable_cmd             ' Enable PS3
01a98     A0 02 A0 FD |                 call    #control_write
01a9c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK    wz
01aa0     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
01aa4     00 00 04 56 |         if_nz   mov     0-0, #0
01aa8     74 00 90 5D |         if_nz   jmp     #.notify_client
01aac                 | 
01aac     08 76 07 F6 |                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
01ab0     6C 00 90 FD |                 jmp     #.notify_client
01ab4                 | end
01ab4                 | 
01ab4                 | .hub_config
01ab4     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
01ab8     64 00 90 AD |         if_z    jmp     #.notify_client                 ' No HUB
01abc     77 73 03 F6 |                 mov     htmp, hhub_ep_addr
01ac0     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
01ac4     3F 00 00 FF 
01ac8     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
01acc     50 00 90 5D |         if_nz   jmp     #.notify_client                 ' No HUB
01ad0                 | 
01ad0     94 0B D0 FE |                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
01ad4     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]
01ad8     26 EF 03 F6 |                 mov     pb, hub_descr_p
01adc     55 02 A0 FD |                 call    #control_read
01ae0     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01ae4     00 EE 06 56 |         if_nz   mov     hhub_ep_addr, #0
01ae8     34 00 90 5D |         if_nz   jmp     #.notify_client
01aec                 |                 debug(uhex_byte_array(hub_descr_p,total_data))
01aec                 | 
01aec     26 F1 03 F6 |                 mov     ptra, hub_descr_p
01af0     02 79 C7 FA |                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
01af4     07 78 27 F3 |                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
01af8                 |                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
01af8                 | .pwr_loop
01af8     74 0B D0 FE |                 loc     ptra, #set_port_feat            ' Power on ports
01afc     01 11 5C FC |                 wrword  #HUB_PORT_POWER, ptra[wValue]
01b00     02 79 57 FC |                 wrword  htmp3, ptra[wIndex]
01b04     A0 02 A0 FD |                 call    #control_write
01b08     FB 79 6F FB |                 djnz    htmp3, #.pwr_loop
01b0c                 | 
01b0c     B2 99 02 F6 |                 mov     hctwait, _500ms_
01b10     B1 99 02 F1 |                 add     hctwait, _100ms_
01b14     EF 02 A0 FD |                 call    #poll_waitx
01b18                 | 
01b18     09 76 07 F6 |                 mov     htmp2, #HUB_READY               ' Hub ready
01b1c     00 00 90 FD |                 jmp     #.notify_client
01b20                 | 
01b20                 | .notify_client
01b20     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
01b24     BB 01 C0 F8 |                 setbyte htmp2                           ' Save device ready
01b28                 |                 debug(uhex_long(hdev_type,hdev_type+1))
01b28                 |         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
01b28     2D 00 64 FD |                 ret
01b2c                 | 
01b2c                 | '------------------------------------------------------------------------------
01b2c                 | ' Initialize the keyboard/mouse data area to start-up values.
01b2c                 | '------------------------------------------------------------------------------
01b2c                 | ' On entry:
01b2c                 | ' On exit:
01b2c                 | '------------------------------------------------------------------------------
01b2c                 | init_kbdm_data
01b2c     00 F2 06 F6 |                 mov     hkbd_ep_addr, #0
01b30     00 FA 06 F6 |                 mov     hdev_ep_addr, #0
01b34                 | 
01b34     2A F1 03 F6 |                 mov     ptra, cache_start_p         ' Clear cached data buffers
01b38     2B ED 03 F6 |                 mov     pa, cache_end_p
01b3c                 | .loop
01b3c     61 01 4C FC |                 wrbyte  #0, ptra++
01b40     F6 F1 1B F2 |                 cmp     ptra, pa                wcz
01b44     F4 FF 9F CD |         if_b    jmp     #.loop
01b48                 |         
01b48                 |         if EMUPAD_MAX_PLAYER > 0
01b48                 |         end
01b48                 | 
01b48                 | 
01b48     2D ED 07 F6 |                 mov     pa, #hdev_init_start        ' Clear device data registers
01b4c                 | .regloop
01b4c     00 EC 8F F9 |                 altd    pa
01b50     00 00 04 F6 |                 mov     0-0, #0
01b54     01 EC 07 F1 |                 add     pa, #1
01b58     47 ED 0F F2 |                 cmp     pa, #hdev_init_end      wz
01b5c     EC FF 9F 5D |         if_nz   jmp     #.regloop
01b60                 | 
01b60     E1 E1 61 FF 
01b64     C3 5D 06 F6 |                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
01b68     2E 5F 02 F6 |                 mov     hdev_next_datax + 1,hdev_next_datax
01b6c     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0
01b70     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1
01b74                 | 
01b74     C3 64 06 06 |         _ret_   mov     hub_next_datax, #PID_DATA0
01b78                 | 
01b78                 | '------------------------------------------------------------------------------
01b78                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
01b78                 | ' function.
01b78                 | '------------------------------------------------------------------------------
01b78                 | ' On entry:
01b78                 | '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
01b78                 | '   hpar2 - index number of the target interface.
01b78                 | ' On exit:
01b78                 | '------------------------------------------------------------------------------
01b78                 | hset_idle
01b78     A9 99 02 F6 |                 mov     hctwait, _2ms_
01b7c     EF 02 A0 FD |                 call    #poll_waitx
01b80     CC 0A D0 FE |                 loc     ptra, #set_idle
01b84     01 8F 57 FC |                 wrword  hpar1, ptra[wValue]
01b88     02 91 57 FC |                 wrword  hpar2, ptra[wIndex]
01b8c     A0 02 80 FD |                 jmp     #control_write
01b90                 | 
01b90                 | '------------------------------------------------------------------------------
01b90                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
01b90                 | ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
01b90                 | '------------------------------------------------------------------------------
01b90                 | ' On entry:
01b90                 | '   ep_addr_pid - device address and enpoint for the request.
01b90                 | ' On exit:
01b90                 | '   retval - transaction result.
01b90                 | '------------------------------------------------------------------------------
01b90                 | hset_kbdled_report
01b90     37 73 E3 F8 |                 getbyte htmp, kb_intf_num, #0
01b94     C0 0A D0 FE |                 loc     ptra, #set_report
01b98     01 00 80 FF 
01b9c     01 01 5C FC |                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
01ba0     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
01ba4     03 03 5C FC |                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
01ba8     27 EF 03 F6 |                 mov     pb, urx_buff_p
01bac     F7 77 42 FC |                 wrbyte  kb_led_states, pb
01bb0     A0 02 80 FD |                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
01bb4                 | 
01bb4                 | '------------------------------------------------------------------------------
01bb4                 | ' Execute an IN interrupt transaction to poll for keyboard activity.
01bb4                 | '------------------------------------------------------------------------------
01bb4                 | ' On entry:
01bb4                 | ' On exit:
01bb4                 | '------------------------------------------------------------------------------
01bb4                 | hget_kbd_in_report
01bb4     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
01bb8     27 91 03 F6 |                 mov     hpar2, urx_buff_p
01bbc     30 93 E3 F8 |                 getbyte hpar3, kbm_next_datax, #0
01bc0     39 93 2B F9 |                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
01bc4     CF 02 A0 FD |                 call    #do_int_in
01bc8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01bcc     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
01bd0                 | 
01bd0     00 92 0F F2 |                 cmp     hpar3, #0               wz
01bd4     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
01bd8                 | 
01bd8     30 73 E3 F8 |                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
01bdc     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
01be0     4B 60 C6 A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
01be4     C3 60 C6 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
01be8                 | 
01be8     C9 75 02 F6 |                 mov     kb_max_index, hpar3             ' Save actual bytes read
01bec     18 00 B0 FD |                 call    #hkbd_compare
01bf0                 |         if EMUPAD_MAX_PLAYER > 0
01bf0                 |         end
01bf0                 | 
01bf0                 | .led_check
01bf0     3B 73 03 F6 |                 mov     htmp, kb_led_states
01bf4     B9 F9 0A F2 |                 cmp     hkbd_ledstates, htmp    wz
01bf8     2D 00 64 AD |         if_z    ret                                     ' No toggle key indicator changes, so we're done
01bfc     7C 77 02 F6 |                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
01c00     78 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ctrl_ep
01c04     88 FF 9F FD |                 jmp     #hset_kbdled_report             ' Set report and ignore errors
01c08                 | 
01c08                 | '------------------------------------------------------------------------------
01c08                 | ' Compare current and previous keyboard data buffers for keypress changes.
01c08                 | '------------------------------------------------------------------------------
01c08                 | hkbd_compare
01c08     27 F1 03 F6 |                 mov     ptra, urx_buff_p
01c0c     D0 13 F0 FE |                 loc     ptrb, #hkbd_report
01c10     61 75 07 FB |                 rdlong  htmp1, ptra++
01c14     E1 77 07 FB |                 rdlong  htmp2, ptrb++
01c18     BB 75 0B F2 |                 cmp     htmp1, htmp2    wz
01c1c     61 75 07 FB |                 rdlong  htmp1, ptra++
01c20     E1 77 07 FB |                 rdlong  htmp2, ptrb++
01c24     BB 75 0B A2 |         if_z    cmp     htmp1, htmp2    wz
01c28     2D 00 64 AD |         if_z    ret
01c2c                 | 
01c2c     B0 13 D0 FE |                 loc     ptra, #hkbd_report
01c30                 | 
01c30                 |                 ' Handle modifiers
01c30     27 91 C3 FA |                 rdbyte  hpar2, urx_buff_p
01c34     00 89 C7 FA |                 rdbyte  hr1, ptra
01c38     C8 89 43 F9 |                 rolword hr1,hpar2,#0
01c3c     63 88 63 FD |                 mergew  hr1
01c40     08 EC 07 F6 |                 mov     pa,#8
01c44                 | .modloop
01c44     6A 88 7B FD |                 rczr    hr1     wcz ' New value in C, old value in Z
01c48     E8 8E 07 F6 |                 mov     hpar1,#$E8
01c4c     F6 8F 83 F1 |                 sub     hpar1,pa
01c50     A0 00 B0 6D |       if_c_ne_z call    #hkbd_translate
01c54     FB ED 6F FB |                 djnz    pa,#.modloop
01c58                 | 
01c58     6F E0 75 FD | .release        modc    _set    wc
01c5c                 |                 'alts    hdev_port, #hid_report_p
01c5c                 |                 'mov     ptra, hid_report_p
01c5c     02 F0 07 F1 |                 add     ptra, #2
01c60     06 EC 07 F6 |                 mov     pa, #6
01c64     61 8F CF FA | .rl1            rdbyte  hpar1, ptra++   wz
01c68     20 00 90 AD |         if_z    jmp     #.rl3
01c6c     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
01c70     02 F2 07 F1 |                 add     ptrb, #2
01c74     06 EE 07 F6 |                 mov     pb, #6
01c78     E1 73 C7 FA | .rl2            rdbyte  htmp, ptrb++
01c7c     B9 8F 0B F2 |                 cmp     hpar1, htmp     wz
01c80     08 00 90 AD |         if_z    jmp     #.rl3
01c84     FC EF 6F FB |                 djnz    pb, #.rl2
01c88     68 00 B0 FD |                 call    #hkbd_translate
01c8c     F5 ED 6F FB | .rl3            djnz    pa, #.rl1
01c90                 | 
01c90     00 92 07 F6 |                 mov     hpar3, #0
01c94     1F 92 27 F4 |                 bith    hpar3, #31
01c98                 | 
01c98     6F 00 74 FD | .press          modc    _clr    wc
01c9c     27 F1 03 F6 |                 mov     ptra, urx_buff_p
01ca0     02 F0 07 F1 |                 add     ptra, #2
01ca4     06 EC 07 F6 |                 mov     pa, #6
01ca8     61 8F CF FA | .pl1            rdbyte  hpar1, ptra++   wz
01cac     20 00 90 AD |         if_z    jmp     #.pl3
01cb0     2C 13 F0 FE |                 loc     ptrb, #hkbd_report
01cb4     02 F2 07 F1 |                 add     ptrb, #2
01cb8     06 EE 07 F6 |                 mov     pb, #6
01cbc     E1 73 C7 FA | .pl2            rdbyte  htmp, ptrb++
01cc0     B9 8F 0B F2 |                 cmp     hpar1, htmp     wz
01cc4     08 00 90 AD |         if_z    jmp     #.pl3
01cc8     FC EF 6F FB |                 djnz    pb, #.pl2
01ccc     24 00 B0 FD |                 call    #hkbd_translate
01cd0     F5 ED 6F FB | .pl3            djnz    pa, #.pl1
01cd4                 | 
01cd4     27 F1 03 F6 | .copy           mov     ptra, urx_buff_p
01cd8     04 13 F0 FE |                 loc     ptrb, #hkbd_report
01cdc     28 02 64 FD |                 setq #1
01ce0     61 75 07 FB |                 rdlong  htmp1, ptra++
01ce4     28 02 64 FD |                 setq #1
01ce8     E1 75 67 FC |                 wrlong  htmp1, ptrb++
01cec     E1 F9 46 FC |                 wrbyte  hkbd_ledstates,ptrb++
01cf0                 | 
01cf0     2D 00 64 FD |                 ret
01cf4                 | 
01cf4                 | '------------------------------------------------------------------------------
01cf4                 | ' Translate keyboard scancode to ASCII
01cf4                 | '------------------------------------------------------------------------------
01cf4                 | ' On entry:
01cf4                 | '   hpar1 - scancode
01cf4                 | '   hpar2 - key modifiers state
01cf4                 | '       c - pressed (0) or released (1) flag
01cf4                 | ' On exit:
01cf4                 | '   hpar1 - bit     31 = 0 pressed, 1 released
01cf4                 | '               30..17 = unused
01cf4                 | '                   18 = scroll-lock state 
01cf4                 | '                   17 = caps-lock state
01cf4                 | '                   16 = num-lock state 
01cf4                 | '                15..8 = key modifiers state
01cf4                 | '                 7..0 = scancode
01cf4                 | '------------------------------------------------------------------------------
01cf4                 | hkbd_translate
01cf4     39 8E 0F F2 |                 cmp     hpar1, #KEY_CAPSLOCK    wz
01cf8     01 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
01cfc     53 8E 0F F2 |                 cmp     hpar1, #KEY_NUMLOCK     wz
01d00     00 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
01d04     47 8E 0F F2 |                 cmp     hpar1, #KEY_SCROLLLOCK  wz
01d08     02 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
01d0c                 | 
01d0c                 |         if EMUPAD_MAX_PLAYER > 0
01d0c                 | 
01d0c                 |         if EMUPAD_BT0_BIT >= 0
01d0c                 |         end
01d0c                 |         if EMUPAD_BT1_BIT >= 0
01d0c                 |         end
01d0c                 |         if EMUPAD_BT2_BIT >= 0
01d0c                 |         end
01d0c                 |         if EMUPAD_BT3_BIT >= 0
01d0c                 |         end
01d0c                 |         if EMUPAD_BT4_BIT >= 0
01d0c                 |         end
01d0c                 |         if EMUPAD_BT5_BIT >= 0
01d0c                 |         end
01d0c                 |         if EMUPAD_BT6_BIT >= 0
01d0c                 |         end
01d0c                 |         if EMUPAD_BT7_BIT >= 0
01d0c                 |         end
01d0c                 |         if EMUPAD_BT8_BIT >= 0
01d0c                 |         end
01d0c                 |         if EMUPAD_BT9_BIT >= 0
01d0c                 |         end
01d0c                 | 
01d0c                 |         end
01d0c     C8 8F CB F8 |                 setbyte hpar1, hpar2, #1
01d10     7C 8F D3 F8 |                 setbyte hpar1, hkbd_ledstates,#2
01d14     1F 8E 47 F4 |                 bitc    hpar1, #31
01d18                 |         if KEYQUEUE_SIZE > 0
01d18     C0 09 B0 FE |                 loc pb,#keyq_head
01d1c     F7 73 E3 FA |                 rdword htmp,pb
01d20     B9 75 EB F8 |                 getbyte htmp1,htmp,#1 ' tail
01d24     B9 73 E3 F8 |                 getbyte htmp,htmp,#0 ' head
01d28     B9 77 03 F6 |                 mov htmp2,htmp
01d2c     04 76 07 FA |                 mul htmp2,#4
01d30     F7 77 03 F1 |                 add htmp2,pb
01d34     02 76 07 F1 |                 add htmp2,#2
01d38     7F 72 07 F7 |                 incmod htmp,#KEYQUEUE_SIZE - 1
01d3c     B9 75 0B F2 |                 cmp htmp1,htmp wz ' check buffer overflow
01d40     BB 8F 63 5C |         if_nz   wrlong hpar1,htmp2
01d44     F7 73 43 5C |         if_nz   wrbyte htmp,pb
01d48                 |         end
01d48     2D 00 7C FD |                 ret wcz
01d4c                 | 
01d4c                 | if HAVE_MOUSE
01d4c                 | '------------------------------------------------------------------------------
01d4c                 | ' Execute an IN interrupt transaction to poll for mouse activity.
01d4c                 | '------------------------------------------------------------------------------
01d4c                 | ' On entry:
01d4c                 | ' On exit:
01d4c                 | '------------------------------------------------------------------------------
01d4c                 | hget_mouse_in_report
01d4c     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
01d50     27 91 03 F6 |                 mov     hpar2, urx_buff_p
01d54     30 93 EB F8 |                 getbyte hpar3, kbm_next_datax, #1
01d58     36 93 2B F9 |                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
01d5c     CF 02 A0 FD |                 call    #do_int_in
01d60     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01d64     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
01d68                 | 
01d68     00 92 0F F2 |                 cmp     hpar3, #0               wz
01d6c     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
01d70                 | 
01d70     30 73 EB F8 |                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
01d74     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
01d78     4B 60 CE A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
01d7c     C3 60 CE 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
01d80                 | 
01d80                 |         'debug(uhex_byte_array(urx_buff_p,hpar3))
01d80                 | 
01d80                 |         if MOUSE_FULL_PROTOCOL
01d80     C8 00 B0 FD |                 call #hid_decode
01d84                 |         else
01d84                 |         end
01d84                 | 
01d84     48 09 90 FE |                 loc     pa, #mouse_limits
01d88     5D 13 F0 FE |                 loc     ptrb, #mouse_xacc
01d8c                 | 
01d8c                 |                 ' load xacc,yacc,zacc
01d8c     28 04 64 FD |                 setq    #3-1
01d90     80 89 07 FB |                 rdlong  hr1,ptrb
01d94                 |                 ' load limits and outptr
01d94     28 04 64 FD |                 setq    #3-1
01d98     F6 75 03 FB |                 rdlong  htmp1,pa
01d9c                 | 
01d9c                 |         if MOUSE_FULL_PROTOCOL
01d9c     8C 19 47 FC |                 wrbyte  hidr_buttons, ptrb[12]
01da0                 |         else
01da0                 |                 { ' Currently not used
01da0                 |                 '}
01da0                 |         end
01da0                 | 
01da0                 |         if MOUSE_FULL_PROTOCOL
01da0     88 73 33 F9 |                 getword htmp, hidr_axis+0, #0
01da4     0F 72 67 F7 |                 signx   htmp, #15
01da8                 |         else
01da8                 |         end
01da8     B9 89 03 F1 |                 add     hr1,htmp
01dac     00 74 0F F2 |                 cmp     htmp1,#0 wz
01db0     BA 89 63 53 |         if_ne   fles    hr1,htmp1
01db4     00 88 47 53 |         if_ne   fges    hr1,#0
01db8                 | 
01db8                 |         if MOUSE_FULL_PROTOCOL
01db8     88 73 3B F9 |                 getword htmp, hidr_axis+0, #1
01dbc     0F 72 67 F7 |                 signx   htmp, #15
01dc0                 |         else
01dc0                 |         end
01dc0     B9 8B 03 F1 |                 add     hr2,htmp
01dc4     00 76 0F F2 |                 cmp     htmp2,#0 wz
01dc8     BB 8B 63 53 |         if_ne   fles    hr2,htmp2
01dcc     00 8A 47 53 |         if_ne   fges    hr2,#0
01dd0                 |                 
01dd0                 |         if MOUSE_FULL_PROTOCOL
01dd0     8B 73 3B F9 |                 getword htmp, hidr_axis+3, #1           ' Mouse wheel is actually on the "wheel axis"
01dd4     0F 72 67 F7 |                 signx   htmp, #15
01dd8     B9 8D 03 F1 |                 add     hr3, htmp
01ddc                 |         else    
01ddc                 |         end
01ddc                 | 
01ddc     90 73 CF FA |                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
01de0     2D 00 64 5D |         if_nz   ret                                     ' If so, don't write results
01de4                 | 
01de4                 |                 ' write back accumulators
01de4     28 04 64 FD |                 setq    #3-1
01de8     80 89 67 FC |                 wrlong  hr1,ptrb
01dec                 |                 ' if outptr set, write X/Y words
01dec     00 78 0F F2 |                 cmp htmp3,#0                    wz
01df0     C5 89 2B 59 |         if_nz   setword hr1,hr2,#1
01df4     BC 89 63 5C |         if_nz   wrlong hr1,htmp3
01df8     2D 00 64 FD |                 ret
01dfc                 | end
01dfc                 | 
01dfc                 | '------------------------------------------------------------------------------
01dfc                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
01dfc                 | '------------------------------------------------------------------------------
01dfc                 | ' On entry:
01dfc                 | ' On exit:
01dfc                 | '------------------------------------------------------------------------------
01dfc                 | if _HAVE_GAMEPAD
01dfc                 | hget_gp_in_report
01dfc     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
01e00     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
01e04                 | 
01e04     27 91 03 F6 |                 mov     hpar2, urx_buff_p
01e08     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax
01e0c     00 92 E3 F8 |                 getbyte hpar3
01e10     FF 92 2F F9 |                 setword hpar3, #255, #1                 ' Always ask for max report size
01e14     CF 02 A0 FD |                 call    #do_int_in
01e18     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01e1c     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
01e20                 | 
01e20     00 92 0F F2 |                 cmp     hpar3, #0               wz
01e24     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
01e28                 |                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
01e28                 | 
01e28     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
01e2c     00 72 E3 F8 |                 getbyte htmp                            ' |
01e30     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
01e34     4B 72 07 A6 |         if_z    mov     htmp, #PID_DATA1                ' |
01e38     C3 72 07 56 |         if_nz   mov     htmp, #PID_DATA0                ' |
01e3c     2E 5B 66 F9 |                 altsb   hdev_port, #hdev_next_datax     ' |
01e40     B9 01 C0 F8 |                 setbyte htmp                            ' |
01e44                 | 
01e44                 | ' Note: the following code compares the current and previous reports
01e44                 | ' and process the data if there are changes to ease the debug output.
01e44                 | ' Actual implementations should remove this block, along with hid_pre_rpt_p and
01e44                 | ' gpPreReport buffer.
01e44                 | 
01e44                 |                 ' ----- start of block to remove
01e44                 |                 {
01e44                 |                 }
01e44                 |                 ' ----- end of block to remove
01e44     14 05 90 FE |                 loc pa,#hpad_translate
01e48     2A EC 63 FD |                 push pa
01e4c                 | 
01e4c                 |                 ' FALL THROUGH !!!!
01e4c                 | end
01e4c                 | if _HAVE_GAMEPAD || MOUSE_FULL_PROTOCOL
01e4c                 | '------------------------------------------------------------------------------
01e4c                 | ' Decode controller report
01e4c                 | '------------------------------------------------------------------------------
01e4c                 | hid_decode
01e4c                 |                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
01e4c     28 20 64 FD |                 setq #(hidr_end-hidr_start)-1
01e50     00 04 00 FF 
01e54     00 0C 07 FB |                 rdlong  hidr_start,##$8_0000
01e58                 | 
01e58     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
01e5c                 | 
01e5c     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
01e60     00 1C E3 F8 |                 getbyte hidr_type
01e64                 |         if _HAVE_GAMEPAD
01e64     07 1C 0F F2 |                 cmp     hidr_type, #XINPUT_READY        wz
01e68     08 03 90 AD |         if_z    jmp     #hpad_xinput
01e6c     08 1C 0F F2 |                 cmp     hidr_type, #PS3_READY           wz
01e70     EC 03 90 AD |         if_z    jmp     #hpad_ps3
01e74                 |         end
01e74     05 1C 0F F2 |                 cmp     hidr_type, #KBM_READY           wz
01e78     04 1C 07 A6 |         if_z    mov     hidr_type,#M_READY
01e7c     04 1C 0F F2 |                 cmp     hidr_type, #M_READY             wz
01e80                 |                 
01e80                 | 
01e80                 | '------------------------------------------------------------------------------
01e80                 | ' Handle HID controller (or mouse now
01e80                 | ' On entry:
01e80                 | '   ptrb - controller report
01e80                 | '------------------------------------------------------------------------------
01e80                 | hpad_hid
01e80     1B 01 A0 FD |                 call    #get_hid_descr_buffer
01e84     F7 F1 03 F6 |                 mov     ptra, pb
01e88     3F 5B 96 F9 |                 alts    hdev_port, #gp_descr_len
01e8c     00 EC 03 F6 |                 mov     pa, 0-0
01e90                 |                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
01e90     19 2A 3B FF 
01e94     10 0C 07 F6 |                 mov     hidr_usage, ##$76543210
01e98                 | 
01e98                 | .next
01e98     00 EC 5F F2 |                 cmps    pa, #0      wcz
01e9c     2D 00 7C ED |         if_be   ret     wcz
01ea0                 | 
01ea0     61 8F C7 FA |                 rdbyte  hpar1, ptra++
01ea4     01 EC 87 F1 |                 sub     pa, #1
01ea8     00 90 07 F6 |                 mov     hpar2, #0
01eac                 | 
01eac     C7 73 03 F6 |                 mov     htmp, hpar1
01eb0     03 72 07 F5 |                 and     htmp, #$03
01eb4     01 72 0F F2 |                 cmp     htmp, #1    wz
01eb8     61 91 C7 AA |         if_z    rdbyte  hpar2, ptra++
01ebc     07 90 67 A7 |         if_z    signx   hpar2,#7
01ec0     01 EC 87 A1 |         if_z    sub     pa, #1
01ec4     02 72 0F F2 |                 cmp     htmp, #2    wz
01ec8     61 91 E7 AA |         if_z    rdword  hpar2, ptra++
01ecc     0F 90 67 A7 |         if_z    signx   hpar2,#15
01ed0     02 EC 87 A1 |         if_z    sub     pa, #2
01ed4     03 72 0F F2 |                 cmp     htmp, #3    wz
01ed8     61 91 07 AB |         if_z    rdlong  hpar2, ptra++
01edc     04 EC 87 A1 |         if_z    sub     pa, #4
01ee0                 | 
01ee0     FC 8E 07 F5 |                 and     hpar1, #$FC
01ee4                 |                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
01ee4                 | 
01ee4     84 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_ID   wz
01ee8     18 01 90 AD |         if_z    jmp     #.report_id
01eec     04 8E 0F F2 |                 cmp     hpar1, #HID_USAGE_PAGE  wz
01ef0     30 01 90 AD |         if_z    jmp     #.usage_page
01ef4     08 8E 0F F2 |                 cmp     hpar1, #HID_USAGE       wz
01ef8     38 01 90 AD |         if_z    jmp     #.usage
01efc     14 8E 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MIN wz
01f00     C8 2B 2B A9 |         if_z    setword hidr_lminmax, hpar2, #1
01f04     24 8E 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MAX wz
01f08     C8 2B 23 A9 |         if_z    setword hidr_lminmax, hpar2, #0
01f0c     34 8E 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MIN wz
01f10     C8 2D 2B A9 |         if_z    setword hidr_pminmax, hpar2, #1
01f14     44 8E 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MAX wz
01f18     C8 2D 23 A9 |         if_z    setword hidr_pminmax, hpar2, #0
01f1c     74 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_SIZE wz
01f20     C8 27 03 A6 |         if_z    mov     hidr_size, hpar2
01f24     94 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_COUNT wz
01f28     C8 29 03 A6 |         if_z    mov     hidr_count, hpar2
01f2c     B4 8E 1F F2 |                 cmp     hpar1, #HID_POP wcz
01f30     A4 8E 0F 52 |         if_nz   cmp     hpar1, #HID_PUSH wz
01f34     64 01 90 AD |         if_z    jmp     #.pushpop ' Entering with C set if PUSH  
01f38     80 8E 0F F2 |                 cmp     hpar1, #HID_INPUT       wz
01f3c     58 FF 9F 5D |         if_nz   jmp     #.next
01f40                 | 
01f40     D5 25 A7 FB |                 tjf     hidr_state,#.next
01f44                 | 
01f44     03 90 07 F5 |                 and     hpar2, #$03
01f48     02 90 0F F2 |                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
01f4c     18 00 90 5D |         if_nz   jmp     #.skip
01f50                 | 
01f50     02 24 0F F2 |                 cmp     hidr_state, #2  wz
01f54     20 00 90 AD |         if_z    jmp     #.axes
01f58     03 24 0F F2 |                 cmp     hidr_state, #3  wz
01f5c     5C 00 90 AD |         if_z    jmp     #.hats
01f60     04 24 0F F2 |                 cmp     hidr_state, #4  wz
01f64     70 00 90 AD |         if_z    jmp     #.buttons
01f68                 | .skip
01f68     93 73 03 F6 |                 mov     htmp, hidr_size
01f6c     94 73 03 FA |                 mul     htmp, hidr_count
01f70     B9 21 03 F1 |                 add     hidr_offset, htmp
01f74     20 FF 9F FD |                 jmp     #.next
01f78                 | .axes
01f78                 |                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count),uhex_long(hidr_flags))
01f78     87 87 53 F8 |                 getnib  hr0, hidr_flags, #2
01f7c     94 89 03 F6 |                 mov     hr1, hidr_count
01f80                 | .l1
01f80     90 8F 03 F6 |                 mov     hpar1, hidr_offset
01f84     93 91 03 F6 |                 mov     hpar2, hidr_size
01f88     28 01 B0 FD |                 call    #hpad_getbits
01f8c     88 01 B0 FD |                 call    #hpad_normalize
01f90     08 86 1F F2 |                 cmp     hr0, #8         wcz
01f94     86 87 5F C9 |         if_b    altgn   hr0, #hidr_usage
01f98     00 8A 43 C8 |         if_b    getnib  hr2
01f9c     88 8B 77 C9 |         if_b    altsw   hr2, #hidr_axis
01fa0     5F 01 20 C9 |         if_b    setword retval
01fa4     01 86 07 C1 |         if_b    add     hr0, #1
01fa8     93 21 03 F1 |                 add     hidr_offset, hidr_size
01fac     F4 89 6F FB |                 djnz    hr1, #.l1
01fb0                 | 
01fb0     C3 0F 13 F8 |                 setnib  hidr_flags, hr0, #2
01fb4     01 24 07 F6 |                 mov     hidr_state, #1
01fb8     DC FE 9F FD |                 jmp     #.next
01fbc                 | .hats
01fbc                 |                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
01fbc     90 8F 03 F6 |                 mov     hpar1, hidr_offset
01fc0     93 91 03 F6 |                 mov     hpar2, hidr_size
01fc4     EC 00 B0 FD |                 call    #hpad_getbits
01fc8     5F 1B C3 F8 |                 setbyte hidr_hats, retval, #0
01fcc     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
01fd0     01 24 07 F6 |                 mov     hidr_state, #1
01fd4     90 FF 9F FD |                 jmp     #.skip
01fd8                 | .buttons
01fd8                 |                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
01fd8     90 8F 03 F6 |                 mov     hpar1, hidr_offset
01fdc     93 91 03 F6 |                 mov     hpar2, hidr_size
01fe0     94 91 03 FA |                 mul     hpar2, hidr_count
01fe4     CC 00 B0 FD |                 call    #hpad_getbits
01fe8     87 73 E3 F8 |                 getbyte htmp, hidr_flags, #0
01fec     B9 BF 62 F0 |                 shl     retval, htmp
01ff0     5F 19 43 F5 |                 or      hidr_buttons, retval
01ff4     94 73 03 F1 |                 add     htmp, hidr_count
01ff8     B9 0F C3 F8 |                 setbyte hidr_flags, htmp, #0
01ffc     01 24 07 F6 |                 mov     hidr_state, #1
02000     64 FF 9F FD |                 jmp     #.skip
02004                 | .report_id
02004     00 1E 0F F2 |                 cmp     hidr_id, #0     wz
02008     2D 00 7C 5D |         if_nz   ret     wcz
0200c     E1 73 C7 FA |                 rdbyte  htmp, ptrb++
02010                 |                 'debug(".report_id",udec(htmp,hpar2))
02010     C8 73 0B F2 |                 cmp     htmp, hpar2     wz
02014     B9 1F 03 A6 |         if_z    mov     hidr_id, htmp
02018     01 24 67 56 |         if_nz   neg     hidr_state,#1
0201c     01 F2 87 51 |         if_nz   sub     ptrb,#1
02020     74 FE 9F FD |                 jmp     #.next
02024                 | .usage_page
02024     09 90 0F F2 |                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
02028     01 24 0F A2 |         if_z    cmp     hidr_state, #1  wz
0202c     04 24 07 A6 |         if_z    mov     hidr_state, #4
02030     64 FE 9F FD |                 jmp     #.next
02034                 | .usage
02034     04 90 0F F2 |                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
02038     05 90 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
0203c     06 1C 0F A2 |         if_z    cmp     hidr_type,#HID_READY        wz
02040     01 24 07 A6 |         if_z    mov     hidr_state, #1
02044     50 FE 9F AD |         if_z    jmp     #.next
02048     02 90 0F F2 |                 cmp     hpar2, #HID_USAGE_MOUSE     wz
0204c     04 1C 0F A2 |         if_z    cmp     hidr_type,#M_READY          wz
02050     01 24 07 A6 |         if_z    mov     hidr_state, #1
02054     40 FE 9F AD |         if_z    jmp     #.next
02058     30 90 17 F2 |                 cmp     hpar2, #HID_USAGE_X     wc
0205c     38 90 97 32 |         if_nc   cmpr    hpar2, #HID_USAGE_WHEEL wc   
02060     10 00 90 3D |         if_nc   jmp     #.usage_axis
02064     39 90 0F F2 |                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
02068     01 24 0F A2 |         if_z    cmp     hidr_state, #1      wz
0206c     03 24 07 A6 |         if_z    mov     hidr_state, #3
02070     24 FE 9F FD |                 jmp     #.next
02074                 | .usage_axis
02074     01 24 57 F2 |                 cmps    hidr_state, #1          wc
02078     1C FE 9F CD |         if_b    jmp     #.next
0207c     37 90 27 F3 |                 fle     hpar2, #HID_USAGE_DIAL   ' Let's just say wheel and dial are the same to keep sane
02080     86 23 57 F9 |                 altsn   hidr_usage_idx, #hidr_usage
02084     C8 01 00 F8 |                 setnib  hpar2
02088                 | 
02088     20 90 87 F1 |                 sub     hpar2, #HID_USAGE_X - 16
0208c     C8 0F 23 F4 |                 bith    hidr_flags, hpar2
02090                 | 
02090     01 22 07 F1 |                 add     hidr_usage_idx, #1
02094     02 24 07 F6 |                 mov     hidr_state, #2
02098     FC FD 9F FD |                 jmp     #.next
0209c                 | .pushpop
0209c                 |                 ' Entering with C set if PUSH  
0209c     4C 0F B0 FE |                 loc     pb, #hid_stack
020a0     28 08 64 CD |         if_c    setq    #(hidr_end-hidr_state)-1
020a4     F7 25 63 CC |         if_c    wrlong  hidr_state, pb
020a8     28 08 64 3D |         if_nc   setq    #(hidr_end-hidr_state)-1
020ac     F7 25 03 3B |         if_nc   rdlong  hidr_state, pb
020b0     E4 FD 9F FD |                 jmp     #.next
020b4                 | 
020b4                 | '------------------------------------------------------------------------------
020b4                 | ' Read bits from report data buffer
020b4                 | '------------------------------------------------------------------------------
020b4                 | ' On entry:
020b4                 | '   PTRB - report buffer
020b4                 | '   hpar1 - start bit
020b4                 | '   hpar2 - number of bits
020b4                 | ' On exit:
020b4                 | '   retval - bits
020b4                 | '------------------------------------------------------------------------------
020b4                 | hpad_getbits
020b4     C7 73 03 F6 |                 mov     htmp, hpar1
020b8     03 72 47 F0 |                 shr     htmp, #3        ' byte offset
020bc     F9 73 03 F1 |                 add     htmp, ptrb
020c0     B9 BF 02 FB |                 rdlong  retval, htmp
020c4                 | 
020c4     C7 75 03 F6 |                 mov     htmp1, hpar1
020c8     07 74 07 F5 |                 and     htmp1, #$07     ' shift
020cc     BA BF 42 F0 |                 shr     retval, htmp1
020d0                 | 
020d0     18 90 1F F2 |                 cmp     hpar2, #24      wcz
020d4     10 00 90 1D |         if_a    jmp     #.l1
020d8                 | 
020d8     C8 91 C3 F9 |                 decod   hpar2
020dc     01 90 87 F1 |                 sub     hpar2, #1
020e0     C8 BF 02 F5 |                 and     retval, hpar2
020e4     2D 00 64 FD |                 ret
020e8                 | .l1
020e8     FF 7F 00 FF 
020ec     FF BF 06 F5 |                 and     retval, ##$00_FFFFFF
020f0     03 72 07 F1 |                 add     htmp, #3
020f4     B9 77 03 FB |                 rdlong  htmp2, htmp
020f8     18 90 87 F1 |                 sub     hpar2, #24
020fc     C8 91 C3 F9 |                 decod   hpar2
02100     01 90 87 F1 |                 sub     hpar2, #1
02104     BA 77 43 F0 |                 shr     htmp2, htmp1
02108     C8 77 03 F5 |                 and     htmp2, hpar2
0210c     18 76 67 F0 |                 shl     htmp2, #24
02110     BB BF 42 F5 |                 or      retval, htmp2
02114     2D 00 64 FD |                 ret
02118                 | 
02118                 | '------------------------------------------------------------------------------
02118                 | ' Normalize value to signed word (-32768 / 32767)
02118                 | '------------------------------------------------------------------------------
02118                 | ' On entry:
02118                 | '   retval - value to normalize
02118                 | '   hidr_lminmax - min (word 1) max (word 0) value range
02118                 | '   - or -
02118                 | '   hidr_pminmax - min (word 1) max (word 0) value range
02118                 | '   hidr_size - value bits length
02118                 | ' On exit:
02118                 | '   retval - normalized value
02118                 | '------------------------------------------------------------------------------
02118                 | hpad_normalize
02118     95 73 0B F6 |                 mov     htmp, hidr_lminmax  wz
0211c     96 73 0B A6 |         if_z    mov     htmp, hidr_pminmax  wz
02120     2D 00 64 AD |         if_z    ret
02124     B9 75 3B F9 |                 getword htmp1, htmp, #1     ' htmp1 = min
02128     B9 73 33 F9 |                 getword htmp, htmp, #0      ' htmp = max
0212c     0F 74 77 F7 |                 signx   htmp1, #15      wc
02130     FF 27 97 C9 |         if_c    alts    hidr_size, #511
02134     00 BE 66 C7 |         if_c    signx   retval, #0-0
02138                 |                 ' slightly crappy hack: if in mouse mode, don't normalize
02138     04 1C 0F F2 |                 cmp     hidr_type, #M_READY wz
0213c     2D 00 64 AD |         if_z    ret
02140     BA 73 C3 F1 |                 subs    htmp, htmp1         ' htmp = (max - min)
02144     BA BF C2 F1 |                 subs    retval, htmp1       ' retval = (retval - min)
02148     10 BE 66 F0 |                 shl     retval, #16         ' retval = (retval - min) << 16
0214c     01 BE C6 F1 |                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
02150     B9 73 53 F6 |                 abs     htmp            wc
02154     1F BE 0E F4 |                 testb   retval, #31     wz
02158     5F BF 42 F6 |                 abs     retval
0215c     B9 BF 12 FD |                 qdiv    retval, htmp
02160     18 BE 62 FD |                 getqx   retval
02164     5F BF 62 66 |     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
02168     C0 FF 7F FF 
0216c     00 BE 46 F1 |                 adds    retval, ##$8000 signx 15
02170     2D 00 64 FD |                 ret
02174                 | end
02174                 | 
02174                 | if _HAVE_GAMEPAD
02174                 | '------------------------------------------------------------------------------
02174                 | ' Handle XInput controller
02174                 | ' On entry:
02174                 | '   ptrb - controller report
02174                 | '------------------------------------------------------------------------------
02174                 | '   Default implementation translates the report to a pseudo-defacto hid
02174                 | '   standard and jumps to hpad_translate for actions.
02174                 | '   Implementors may take specific actions for this kind of controller.
02174                 | '------------------------------------------------------------------------------
02174                 | hpad_xinput
02174     80 73 CF FA |                 rdbyte  htmp, ptrb      wz
02178     2D 00 64 5D |         if_nz   ret                         ' Ignore message type <> $00
0217c     81 73 C7 FA |                 rdbyte  htmp, ptrb[1]
02180     14 72 0F F2 |                 cmp     htmp, #$14      wz
02184     2D 00 64 5D |         if_nz   ret                         ' Ignore report length <> $14 (20)
02188                 | 
02188                 |                 'debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
02188                 | 
02188     B0 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
0218c     06 0E 17 F8 |                 setnib  hidr_flags, #6, #2
02190                 | 
02190     83 11 E7 FA |                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
02194     84 BF E6 FA |                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
02198     5F BF 22 F6 |                 not     retval
0219c     5F 11 2B F9 |                 setword hidr_axis, retval, #1
021a0     85 13 E7 FA |                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
021a4     86 BF E6 FA |                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
021a8     5F BF 22 F6 |                 not     retval
021ac     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
021b0                 | 
021b0     FF 2A 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
021b4     84 BF C6 FA |                 rdbyte  retval, ptrb[4]     ' left analog trigger
021b8     C0 BE 1E F2 |                 cmp     retval, #192    wcz
021bc     06 18 27 34 |         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
021c0     54 FF BF FD |                 call    #hpad_normalize
021c4     5F 13 2B F9 |                 setword hidr_axis+1, retval, #1
021c8     85 BF C6 FA |                 rdbyte  retval, ptrb[5]     ' right analog trigger
021cc     C0 BE 1E F2 |                 cmp     retval, #192    wcz
021d0     07 18 27 34 |         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
021d4     40 FF BF FD |                 call    #hpad_normalize
021d8     5F 15 23 F9 |                 setword hidr_axis+2, retval, #0
021dc                 | 
021dc     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
021e0     81 BF E6 FA |                 rdword  retval, ptrb[1]
021e4     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
021e8     00 18 47 F4 |                 bitc    hidr_buttons, #0
021ec     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
021f0     01 18 47 F4 |                 bitc    hidr_buttons, #1
021f4     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
021f8     02 18 47 F4 |                 bitc    hidr_buttons, #2
021fc     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
02200     03 18 47 F4 |                 bitc    hidr_buttons, #3
02204     08 BE 16 F4 |                 testb   retval, #8      wc  ' LB
02208     04 18 47 F4 |                 bitc    hidr_buttons, #4
0220c     09 BE 16 F4 |                 testb   retval, #9      wc  ' RB
02210     05 18 47 F4 |                 bitc    hidr_buttons, #5
02214     05 BE 16 F4 |                 testb   retval, #5      wc  ' SELECT
02218     08 18 47 F4 |                 bitc    hidr_buttons, #8
0221c     04 BE 16 F4 |                 testb   retval, #4      wc  ' START
02220     09 18 47 F4 |                 bitc    hidr_buttons, #9
02224     06 BE 16 F4 |                 testb   retval, #6      wc  ' L3
02228     0A 18 47 F4 |                 bitc    hidr_buttons, #10
0222c     07 BE 16 F4 |                 testb   retval, #7      wc  ' R3
02230     0B 18 47 F4 |                 bitc    hidr_buttons, #11
02234     0A BE 16 F4 |                 testb   retval, #10     wc  ' XBOX
02238     0C 18 47 F4 |                 bitc    hidr_buttons, #12
0223c                 | 
0223c     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
02240     5F 73 43 F8 |                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
02244     7A BB 7A FF 
02248     0F 74 07 F6 |                 mov     htmp1, ##$F576_F40F
0224c     F9 FF 7F FF 
02250     12 77 07 F6 |                 mov     htmp2, ##$FFFF_F312
02254     BA 73 5F F9 |                 altgn   htmp, #htmp1
02258     00 72 43 F8 |                 getnib  htmp
0225c     B9 1B C3 08 |         _ret_   setbyte hidr_hats, htmp, #0
02260                 | 
02260                 | '------------------------------------------------------------------------------
02260                 | ' Handle PS3 controller
02260                 | ' On entry:
02260                 | '   ptrb - controller report
02260                 | '------------------------------------------------------------------------------
02260                 | '   Default implementation translates the report to a pseudo-defacto hid
02260                 | '   standard and jumps to hpad_translate for actions.
02260                 | '   Implementors may take specific actions for this kind of controller.
02260                 | '------------------------------------------------------------------------------
02260                 | hpad_ps3
02260     E1 73 C7 FA |                 rdbyte  htmp, ptrb++
02264     01 72 0F F2 |                 cmp     htmp, #$01      wz
02268     2D 00 64 5D |         if_nz   ret                         ' Ignore report ID <> $01
0226c                 | 
0226c                 |                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
0226c                 | 
0226c     B0 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
02270     06 0E 17 F8 |                 setnib  hidr_flags, #6, #2
02274                 | 
02274     FF 2A 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
02278     85 BF C6 FA |                 rdbyte  retval, ptrb[5]         ' X = left stick X
0227c     98 FE BF FD |                 call    #hpad_normalize
02280     5F 11 23 F9 |                 setword hidr_axis, retval, #0
02284     86 BF C6 FA |                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
02288     8C FE BF FD |                 call    #hpad_normalize
0228c     5F 11 2B F9 |                 setword hidr_axis, retval, #1
02290     87 BF C6 FA |                 rdbyte  retval, ptrb[7]         ' Z = right stick X
02294     80 FE BF FD |                 call    #hpad_normalize
02298     5F 13 23 F9 |                 setword hidr_axis+1, retval, #0
0229c     88 BF C6 FA |                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
022a0     74 FE BF FD |                 call    #hpad_normalize
022a4     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
022a8     91 BF C6 FA |                 rdbyte  retval, ptrb[17]        ' RX = L2 analog
022ac     68 FE BF FD |                 call    #hpad_normalize
022b0     5F 13 2B F9 |                 setword hidr_axis+1, retval, #1
022b4     92 BF C6 FA |                 rdbyte  retval, ptrb[18]        ' RY = R2 analog
022b8     5C FE BF FD |                 call    #hpad_normalize
022bc     5F 15 23 F9 |                 setword hidr_axis+2, retval, #0
022c0                 | 
022c0     08 8E 07 F6 |                 mov     hpar1, #8
022c4     13 90 07 F6 |                 mov     hpar2, #19
022c8     E8 FD BF FD |                 call    #hpad_getbits
022cc                 | 
022cc     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
022d0     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
022d4     00 18 47 F4 |                 bitc    hidr_buttons, #0
022d8     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
022dc     01 18 47 F4 |                 bitc    hidr_buttons, #1
022e0     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
022e4     02 18 47 F4 |                 bitc    hidr_buttons, #2
022e8     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
022ec     03 18 47 F4 |                 bitc    hidr_buttons, #3
022f0     0A BE 16 F4 |                 testb   retval, #10     wc  ' L1
022f4     04 18 47 F4 |                 bitc    hidr_buttons, #4
022f8     0B BE 16 F4 |                 testb   retval, #11     wc  ' R1
022fc     05 18 47 F4 |                 bitc    hidr_buttons, #5
02300     08 BE 16 F4 |                 testb   retval, #8      wc  ' L2
02304     06 18 47 F4 |                 bitc    hidr_buttons, #6
02308     09 BE 16 F4 |                 testb   retval, #9      wc  ' R2
0230c     07 18 47 F4 |                 bitc    hidr_buttons, #7
02310     00 BE 16 F4 |                 testb   retval, #0      wc  ' SELECT
02314     08 18 47 F4 |                 bitc    hidr_buttons, #8
02318     03 BE 16 F4 |                 testb   retval, #3      wc  ' START
0231c     09 18 47 F4 |                 bitc    hidr_buttons, #9
02320     01 BE 16 F4 |                 testb   retval, #1      wc  ' LEFT STICK
02324     0A 18 47 F4 |                 bitc    hidr_buttons, #10
02328     02 BE 16 F4 |                 testb   retval, #2      wc  ' RIGHT STICK
0232c     0B 18 47 F4 |                 bitc    hidr_buttons, #11
02330     10 BE 16 F4 |                 testb   retval, #16     wc  ' HOME
02334     0C 18 47 F4 |                 bitc    hidr_buttons, #12
02338                 | 
02338     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
0233c     5F 73 4B F8 |                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
02340     09 FA 79 FF 
02344     0F 74 07 F6 |                 mov     htmp1, ##$F3F4_120F
02348     FF FA 7F FF 
0234c     76 77 07 F6 |                 mov     htmp2, ##$FFF5_FF76
02350     BA 73 5F F9 |                 altgn   htmp, #htmp1
02354     00 72 43 F8 |                 getnib  htmp
02358     B9 1B C3 08 |         _ret_   setbyte hidr_hats, htmp, #0
0235c                 | 
0235c                 | 
0235c                 | '------------------------------------------------------------------------------
0235c                 | ' Perform controller actions
0235c                 | ' On entry:
0235c                 | '    hidr_id        report id
0235c                 | '    hidr_axis      axis value (signed word, 2 axes per long)
0235c                 | '                      X = hidr_axis+0, #0
0235c                 | '                      Y = hidr_axis+0, #1
0235c                 | '                      Z = hidr_axis+1, #0
0235c                 | '                     RX = hidr_axis+1, #1
0235c                 | '                     RY = hidr_axis+2, #0
0235c                 | '                     RZ = hidr_axis+2, #1
0235c                 | '                     Sl = hidr_axis+3, #0
0235c                 | '                     Wh = hidr_axis+3, #1
0235c                 | '    hidr_buttons   buttons state (bits 0 to 31)
0235c                 | '    hidr_hats      hats state (byte 0, 1, 2, 3)
0235c                 | '
0235c                 | '                     -------3 -------2 -------1 -------0 byte
0235c                 | '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
0235c                 | '    hidr_flags       xxxxxxxx_wsrrrzyx_hhhhaaaa_bbbbbbbb
0235c                 | '                              hlzyx||| |||||||| ++++++++ n. buttons
0235c                 | '                              |||||||| ||||++++--------- n. axes
0235c                 | '                              |||||||| ++++------------- n. hats
0235c                 | '                              ++++++++------------------ valid axes
0235c                 | '------------------------------------------------------------------------------
0235c                 | hpad_translate
0235c                 | 
0235c                 | 
0235c                 |         if HAVE_HIDPAD
0235c     A0 0C F0 FE |                 loc     ptrb,#hidpad_report
02360     2D 73 0B F6 |                 mov     htmp,hdev_port          wz
02364     8F 73 03 A6 |         if_z    mov     htmp,hidr_id
02368     01 72 E7 F2 |                 cmpsub  htmp,#1
0236c     07 1E 17 A2 |         if_z    cmp     hidr_id, #MAX_DEVICES   wc
02370     02 1E 17 52 |         if_nz   cmp     hidr_id, #2             wc
02374     2D 00 7C 3D |         if_ae   ret     wcz
02378     20 72 07 FA |                 mul     htmp, #HIDPAD_REPORT_SIZE
0237c     B9 F3 03 F1 |                 add     ptrb,htmp
02380     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
02384     00 0C 03 F6 |                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
02388     28 0E 64 FD |                 setq    #8-1
0238c     80 0D 67 FC |                 wrlong  hidr_usage,ptrb
02390                 |         end
02390                 | 
02390                 | 
02390                 |         if EMUPAD_MAX_PLAYER > 0
02390                 | .emupad_no_hat
02390                 |         if EMUPAD_BT0_BIT >= 0
02390                 |         end
02390                 |         if EMUPAD_BT1_BIT >= 0
02390                 |         end
02390                 |         if EMUPAD_BT2_BIT >= 0
02390                 |         end
02390                 |         if EMUPAD_BT3_BIT >= 0
02390                 |         end
02390                 |         if EMUPAD_BT4_BIT >= 0
02390                 |         end
02390                 |         if EMUPAD_BT5_BIT >= 0
02390                 |         end
02390                 |         if EMUPAD_BT6_BIT >= 0
02390                 |         end
02390                 |         if EMUPAD_BT7_BIT >= 0
02390                 |         end
02390                 |         if EMUPAD_BT8_BIT >= 0
02390                 |         end
02390                 |         if EMUPAD_BT9_BIT >= 0
02390                 |         end
02390                 | .emupad_slot_over
02390                 |         end
02390                 | 
02390                 |         if 0
02390                 |                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
02390                 | 
02390                 |                 debug("    btn: ", ubin_long_(hidr_buttons))
02390                 | 
02390                 |         end
02390     2D 00 64 FD |                 ret
02394                 | end
02394                 | 
02394                 | if EMUPAD_MAX_PLAYER > 0
02394                 | '------------------------------------------------------------------------------
02394                 | ' Clear EmuPad state
02394                 | '------------------------------------------------------------------------------
02394                 | emupad_reset
02394                 | 
02394                 | '------------------------------------------------------------------------------
02394                 | ' Get EmuPad Player number for current device (into retval)
02394                 | ' Z flag is also set if current device is valid
02394                 | ' (Value may be larger than EMUPAD_MAX_PLAYER !)
02394                 | '------------------------------------------------------------------------------
02394                 | emupad_getnum
02394                 | .loop
02394                 | '------------------------------------------------------------------------------
02394                 | ' Handle disconnect of device (call after emupad_getnum returns with Z set)
02394                 | '------------------------------------------------------------------------------
02394                 | emupad_discon
02394                 | .loop         
02394                 |         
02394                 |         ' FALL THROUGH!!!
02394                 | 
02394                 | '------------------------------------------------------------------------------
02394                 | ' Update EmuPad reports (all of them...)
02394                 | '------------------------------------------------------------------------------
02394                 | emupad_write_reports
02394                 | .devloop
02394                 | 
02394                 | end
02394                 | 
02394                 | 
02394                 | '------------------------------------------------------------------------------
02394                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
02394                 | '------------------------------------------------------------------------------
02394                 | ' On entry:
02394                 | ' On exit:
02394                 | '------------------------------------------------------------------------------
02394                 | hget_hub_status
02394     77 BD 02 F6 |                 mov     ep_addr_pid, hhub_ep_addr
02398     27 91 03 F6 |                 mov     hpar2, urx_buff_p
0239c     32 93 23 F9 |                 setword hpar3, hub_next_datax, #0
023a0     01 92 2F F9 |                 setword hpar3, #1, #1
023a4     CF 02 A0 FD |                 call    #do_int_in
023a8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
023ac     0C 00 90 AD |         if_z    jmp     #.data
023b0     5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
023b4     1A 01 80 5D |         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
023b8     2D 00 64 FD |                 ret
023bc                 | .data
023bc     00 92 0F F2 |                 cmp     hpar3, #0               wz
023c0     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
023c4                 | 
023c4     C3 64 0E F2 |                 cmp     hub_next_datax, #PID_DATA0  wz
023c8     4B 64 06 A6 |         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
023cc     C3 64 06 56 |         if_nz   mov     hub_next_datax, #PID_DATA0
023d0     27 67 02 FB |                 rdlong  hub_status_chg, urx_buff_p
023d4                 |                 debug(ubin_long(hub_status_chg))
023d4                 | 
023d4     01 5A 06 F6 |                 mov     hdev_port, #1
023d8                 | .loop
023d8     2D 67 0A F4 |                 testb   hub_status_chg, hdev_port wz
023dc     0C 00 B0 AD |         if_x1   call    #hub_port_handler
023e0     07 5A 1E F7 |                 incmod  hdev_port, #7           wcz
023e4     F0 FF 9F 3D |         if_nc   jmp     #.loop
023e8     2D 00 64 FD |                 ret
023ec                 | 
023ec                 | hub_port_handler
023ec     76 BD 02 F6 |                 mov     ep_addr_pid, hhub_ctrl_ep
023f0     8C 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
023f4     27 EF 03 F6 |                 mov     pb, urx_buff_p
023f8     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
023fc     55 02 A0 FD |                 call    #control_read
02400     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
02404                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
02404                 | 
02404     10 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
02408     50 01 90 5D |         if_x0   jmp     #.other
0240c     68 02 D0 FE |                 loc     ptra, #clr_port_feat
02410     01 21 5C FC |                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
02414     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02418     A0 02 A0 FD |                 call    #control_write
0241c     00 68 0E F4 |                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
02420     7C 01 90 5D |         if_x0   jmp     #.disconnect
02424     B1 99 02 F6 |                 mov     hctwait, _100ms_
02428     EF 02 A0 FD |                 call    #poll_waitx
0242c                 | 
0242c     40 02 D0 FE |                 loc     ptra, #set_port_feat            ' reset port
02430     01 09 5C FC |                 wrword  #HUB_PORT_RESET, ptra[wValue]
02434     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02438     A0 02 A0 FD |                 call    #control_write
0243c                 | 
0243c     02 78 07 F6 |                 mov     htmp3, #2
02440                 | .wait_reset
02440     AD 99 02 F6 |                 mov     hctwait, _8ms_
02444     EF 02 A0 FD |                 call    #poll_waitx
02448     34 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
0244c     27 EF 03 F6 |                 mov     pb, urx_buff_p
02450     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02454     55 02 A0 FD |                 call    #control_read
02458     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
0245c     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
02460     F7 79 6F 5B |         if_x0   djnz    htmp3, #.wait_reset
02464                 | 
02464     10 02 D0 FE |                 loc     ptra, #clr_port_feat
02468     01 29 5C FC |                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
0246c     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02470     A0 02 A0 FD |                 call    #control_write
02474                 | 
02474     24 72 07 F6 |                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
02478                 | .wait_recover
02478     A8 99 02 F6 |                 mov     hctwait, _1ms_
0247c     EF 02 A0 FD |                 call    #poll_waitx
02480     FD 73 6F FB |                 djnz    htmp,#.wait_recover
02484                 | 
02484     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
02488     07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
0248c     0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
02490                 | 
02490     00 08 00 FF 
02494     00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
02498     8C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
0249c     03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
024a0     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
024a4     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
024a8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
024ac     48 01 90 5D |         if_nz   jmp     #.done
024b0                 | .get_dev_desc
024b0     28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
024b4     07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
024b8     F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
024bc     80 01 D0 FE |                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
024c0     2D 73 03 F6 |                 mov     htmp, hdev_port             ' Address is hub port number
024c4     01 73 57 FC |                 wrword  htmp, ptra[wValue]
024c8     A0 02 A0 FD |                 call    #control_write                  ' Execute SetAddress()
024cc     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
024d0     24 01 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
024d4     AD 99 02 F6 |                 mov     hctwait, _8ms_
024d8     EF 02 A0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
024dc     2D BD 02 F6 |                 mov     ep_addr_pid, hdev_port
024e0     08 BC 66 F0 |                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
024e4     BE 00 A0 FD |                 call    #calc_crc5
024e8     3C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
024ec     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
024f0     F7 AD C2 FA |                 rdbyte  total_data, pb
024f4     03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
024f8     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
024fc     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
02500     F4 00 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
02504     5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
02508     28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
0250c                 |                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
0250c     A0 99 02 F6 |                 mov     hctwait, _500us_
02510     EF 02 A0 FD |                 call    #poll_waitx
02514     18 01 D0 FE |                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
02518     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
0251c     29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
02520     55 02 A0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
02524     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
02528     CC 00 90 5D |         if_nz   jmp     #.done
0252c     29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
02530     F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
02534     61 87 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
02538     61 89 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
0253c     00 73 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
02540     09 86 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
02544     02 88 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
02548     56 73 1B A2 |         if_z    cmp     htmp, total_data        wcz
0254c     0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
02550     A4 00 90 CD |         if_b    jmp     #.done
02554     68 F0 BF FD |                 call    #hparse_con_desc
02558     9C 00 90 FD |                 jmp     #.done
0255c                 | 
0255c                 | .other
0255c     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz
02560     01 29 5C AC |         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
02564     28 00 90 AD |         if_x1   jmp     #.reset_feature
02568     11 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
0256c     01 23 5C AC |         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
02570     1C 00 90 AD |         if_x1   jmp     #.reset_feature
02574     12 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
02578     01 25 5C AC |         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
0257c     10 00 90 AD |         if_x1   jmp     #.reset_feature
02580     13 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
02584     01 27 5C AC |         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
02588     04 00 90 AD |         if_x1   jmp     #.reset_feature
0258c     68 00 90 FD |                 jmp     #.done
02590                 | .reset_feature
02590     E4 00 D0 FE |                 loc     ptra, #clr_port_feat
02594     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02598     A0 02 A0 FD |                 call    #control_write
0259c     58 00 90 FD |                 jmp     #.done
025a0                 | .disconnect
025a0                 | 
025a0     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
025a4     00 72 E3 F8 |                 getbyte htmp
025a8     03 72 0F F2 |                 cmp     htmp,#KB_READY wz
025ac     05 72 0F 52 |         if_nz   cmp     htmp,#KBM_READY wz
025b0     00 F2 06 A6 |         if_z    mov     hkbd_ep_addr, #0
025b4     00 F0 06 A6 |         if_z    mov     hkbd_ctrl_ep, #0
025b8     00 76 06 A6 |         if_z    mov     kb_led_states, #0
025bc     3B F9 02 A6 |         if_z    mov     hkbd_ledstates, kb_led_states
025c0                 |         if EMUPAD_MAX_PLAYER > 0
025c0                 |         end
025c0                 |         if HAVE_MOUSE
025c0     04 72 0F F2 |                 cmp     htmp, #M_READY          wz
025c4     05 72 0F 52 |         if_nz   cmp     htmp, #KBM_READY        wz
025c8     00 F4 06 A6 |         if_z    mov     hmouse_ep_addr, #0
025cc                 |         end
025cc                 |         if HAVE_HIDPAD
025cc     30 0A F0 FE |                 loc ptrb,#hidpad_report
025d0     2D 73 03 F6 |                 mov htmp,hdev_port
025d4     01 72 E7 F2 |                 cmpsub htmp,#1
025d8     20 72 07 FA |                 mul htmp,#HIDPAD_REPORT_SIZE
025dc     B9 F3 03 F1 |                 add ptrb,htmp
025e0     28 0E 64 FD |                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
025e4     80 01 6C FC |                 wrlong #0,ptrb
025e8                 |         end
025e8                 | 
025e8     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
025ec     00 00 C4 F8 |                 setbyte #0
025f0     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
025f4     00 00 04 F6 |                 mov     0-0, #0
025f8                 | 
025f8                 | .done
025f8     0E 6A 1F F4 |                 bitl    _usb_h_ls_nco_, #14     wcz
025fc     07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
02600     22 6F 13 CC |         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
02604     40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
02608     A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
0260c     A4 9B 02 F6 |                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
02610                 | 
02610     6C 00 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
02614     27 EF 03 F6 |                 mov     pb, urx_buff_p
02618     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
0261c     55 02 A0 FD |                 call    #control_read
02620     00 69 06 FB |                 rdlong  hub_port_status, ptra
02624                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
02624     2D 00 64 FD |                 ret
02628                 | 
02628                 | '------------------------------------------------------------------------------
02628                 | ' Partially populated SETUP packets
02628                 | '------------------------------------------------------------------------------
02628     80          | get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
02629     06          |                 byte    REQ_GET_DESC
0262a     00 01       |                 word    TYPE_DEVICE << 8
0262c     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
0262e     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
02630     80          | get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
02631     06          |                 byte    REQ_GET_DESC
02632     00 02       |                 word    TYPE_CONFIG << 8
02634     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
02636     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
02638     00          | set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
02639     09          |                 byte    REQ_SET_CONFIG
0263a     00 00       |                 word    0       ' Configuration value
0263c     00 00       |                 word    0       ' Zero
0263e     00 00       |                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
02640     00          | set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
02641     05          |                 byte    REQ_SET_ADDR
02642     00 00       |                 word    0       ' Zero
02644     00 00       |                 word    0       ' Zero
02646     00 00       |                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
02648                 | '------------------------------------------------------------------------------
02648                 | ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
02648                 | ' wValue field dictates which protocol should be used.
02648                 | '
02648                 | ' When initialized, all devices default to report protocol. However the host
02648                 | ' should not make any assumptions about the device state and should set the
02648                 | ' desired protocol whenever initializing a device.
02648                 | '------------------------------------------------------------------------------
02648     21          | set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
02649     0B          |                 byte    HID_SET_PROTO
0264a     00 00       |                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
0264c                 |                                                 ' (HID 1.11 Section 7.2.6).
0264c     00 00       |                 word    0               ' Interface index number.
0264e     00 00       |                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
02650                 | '------------------------------------------------------------------------------
02650     21          | set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
02651     0A          |                 byte    HID_SET_IDLE
02652     00 00       |                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
02654                 |                                         ' reporting until a change is detected in the report data
02654                 | 
02654                 |                                         ' (HID 1.11 Section 7.2.4).
02654     00 00       |                 word    0       ' Interface index number.
02656     00 00       |                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
02658     21          | set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
02659     09          |                 byte    HID_SET_REPORT
0265a     00 00       |                 word    0       ' Byte1 = report type, byte0 = ReportID.
0265c                 |                                         ' (HID 1.11 Section 7.2.2).
0265c     00 00       |                 word    0       ' Interface index number.
0265e     00 00       |                 word    0       ' Size of the report, in bytes.
02660     81          | get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
02661     06          |                 byte    REQ_GET_DESC
02662     00 22       |                 word    TYPE_REPORT << 8
02664     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
02666     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
02668                 | '------------------------------------------------------------------------------
02668     A0          | get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
02669     06          |                 byte    REQ_GET_DESC
0266a     00 29       |                 word    TYPE_HUB << 8
0266c     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
0266e     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
02670     23          | set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
02671     03          |                 byte    REQ_SET_FEATURE
02672     00 00       |                 word    0       ' port power
02674     01 00       |                 word    1       ' Port index number (1+)
02676     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
02678     23          | clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
02679     01          |                 byte    REQ_CLEAR_FEATURE
0267a     00 00       |                 word    0       ' port power
0267c     01 00       |                 word    1       ' Port index number (1+)
0267e     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
02680     A3          | get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
02681     00          |                 byte    REQ_GET_STATUS
02682     00 00       |                 word    0
02684     01 00       |                 word    1       ' Port index number (1+)
02686     04 00       |                 word    4       ' Number of bytes to transfer if there is a data stage
02688                 | '------------------------------------------------------------------------------
02688                 | if _HAVE_GAMEPAD
02688     42 0C 00 00 | ps3_enable_cmd  byte    $42, $0C, $00, $00
0268c                 | ps3_command_buff
0268c     00 00 00 00 
02690     00          |                 byte    $00, $00, $00, $00, $00
02691     00 00 00 00 
02695     02          |                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
02696     FF 27 10 00 
0269a     32          |                 byte    $FF, $27, $10, $00, $32
0269b     FF 27 10 00 
0269f     32          |                 byte    $FF, $27, $10, $00, $32
026a0     FF 27 10 00 
026a4     32          |                 byte    $FF, $27, $10, $00, $32
026a5     FF 27 10 00 
026a9     32          |                 byte    $FF, $27, $10, $00, $32
026aa     00 00 00 00 
026ae     00          |                 byte    $00, $00, $00, $00, $00
026af     00 00 00 00 
026b3     00          |                 byte    $00, $00, $00, $00, $00
026b4     00 00 00 00 
026b8     00          |                 byte    $00, $00, $00, $00, $00
026b9     00 00 00    |                 byte    $00, $00, $00
026bc                 | '------------------------------------------------------------------------------
026bc     01 03 06    | xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
026bf                 |                                         ' 0x01 All blinking
026bf                 |                                         ' 0x02 1 flashes, then on
026bf                 |                                         ' 0x03 2 flashes, then on
026bf                 |                                         ' 0x04 3 flashes, then on
026bf                 |                                         ' 0x05 4 flashes, then on
026bf                 |                                         ' 0x06 1 on
026bf                 |                                         ' 0x07 2 on
026bf                 |                                         ' 0x08 3 on
026bf                 |                                         ' 0x09 4 on
026bf                 |                                         ' 0x0A Rotating (e.g. 1-2-4-3)
026bf                 |                                         ' 0x0B Blinking*
026bf                 |                                         ' 0x0C Slow blinking*
026bf                 |                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
026bf     00 08 00    | xinp_rumble_cmd byte    $00, $08, $00
026c2     00          |                 byte    $00             ' Left rumble
026c3     00          |                 byte    $00             ' Right rumble
026c4     00 00 00    |                 byte    $00, $00, $00
026c7                 | 
026c7                 | xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
026c7                 |                 '' of certain wired 8bitdo gamepads.
026c7     80          |                 byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
026c8     06          |                 byte    REQ_GET_DESC
026c9     04 03       |                 word    TYPE_STRING << 8 + 4
026cb     09 04       |                 word    $0409   ' Zero or Language ID (Section 9.6.7)
026cd     02 00       |                 word    2       ' Number of bytes to transfer if there is a data stage
026cf     00          | end
026d0                 | alignl
026d0                 | 
026d0                 | if HAVE_MOUSE
026d0     00 00 00 00 
026d4     00 00 00 00 | mouse_limits long 0[2]
026d8     00 00 00 00 | mouse_outptr long 0
026dc                 | end
026dc                 | 
026dc                 | if KEYQUEUE_SIZE > 0
026dc     00          | keyq_head byte 0
026dd     00          | keyq_tail byte 0
026de     00 00 00 00 
      ...             
028da     00 00 00 00 
028de     00 00       | keyq_data long 0[KEYQUEUE_SIZE]
028e0                 | alignl
028e0                 | end
028e0                 | 
028e0                 | if EMUPAD_MAX_PLAYER > 0
028e0                 | emupad_rule_buffer
028e0                 | if EMUPAD_BUILTIN_RULES
028e0                 | file "padmap_builtin.dat"
028e0                 | end
028e0                 | byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
028e0                 | '' Default rule directly follows!
028e0                 | byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
028e0                 | end
028e0                 | 
028e0                 | '------------------------------------------------------------------------------
028e0                 | ' The USB data cache area gets zero-filled at every device disconnect
028e0                 | '------------------------------------------------------------------------------
028e0                 | usb_cache_start
028e0                 | 
028e0                 | ' HID descriptor and report buffers
028e0                 | if !!OVERLAP_MEMORY
028e0     00 00 00 00 
      ...             
02fd8     00 00 00 00 
02fdc     00 00 00 00 | hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
02fe0                 | end
02fe0     00 00 00 00 
02fe4     00 00 00 00 | hkbd_report     byte    0[8]
02fe8     00 00 00 00 | hkbd_led_rep    byte    0
02fec                 | alignl
02fec                 | 
02fec     00 00 00 00 
02ff0     00 00 00 00 
02ff4     00 00 00 00 
02ff8     00 00 00 00 
02ffc     00 00 00 00 | hid_stack       long 0[(hidr_end - hidr_state) * 1]
03000                 | 
03000                 | if HAVE_HIDPAD
03000     00 00 00 00 
      ...             
030d8     00 00 00 00 
030dc     00 00 00 00 | hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
030e0                 | end
030e0                 | 
030e0                 | ' HUB descriptor
030e0     00          | hub_descr       byte    0   ' bDescLength
030e1     00          |                 byte    0   ' bDescriptorType
030e2     00          |                 byte    0   ' bNbrPorts
030e3     00 00       |                 word    0   ' wHubCharacteristics
030e5     00          |                 byte    0   ' bPwrOn2PwrGood
030e6     00          |                 byte    0   ' bHubContrCurrent
030e7     00          |                 byte    0   ' DeviceRemoveable
030e8     00          |                 byte    0   ' PortPwrCtrlMask
030e9                 | 
030e9                 | usb_cache_end
030e9                 | 
030e9                 | if HAVE_MOUSE
030e9     00 00 00 00 | mouse_xacc      long 0
030ed     00 00 00 00 | mouse_yacc      long 0
030f1     00 00 00 00 | mouse_zacc      long 0
030f5     00          | mouse_bstate    byte 0
030f6     00          | mouse_lpending  byte 0
030f7     00          | mouse_rpending  byte 0
030f8     00          | mouse_mpending  byte 0
030f9     00          | mouse_lock      byte 0
030fa     00 00 00    |                 byte 0[3] ' padding
030fd                 | end
030fd                 | 
030fd     00 00 00 00 
      ...             
03175     00 00 00 00 
03179     00 00 00 00 | urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
0317d     00 00 00 00 
03181     00 00 00 00 
03185     00 00 00 00 
03189     00 00 00 00 
0318d     00 00       | dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
0318f     00 00 00 00 
      ...             
03287     00 00 00 00 
0328b     00 00 00 00 | con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
0328f                 | 
0328f     00          | driver_cog      byte    0                       ' Current driver cog + 1
03290                 | objmem
03290                 | 	long	0[0]
03290                 | stackspace
03290     00 00 00 00 | 	long	0[1]
03294 0e9             | 	org	COG_BSS_START
03294 0e9             | _var01
03294 0e9             | 	res	1
03294 0ea             | _var02
03294 0ea             | 	res	1
03294 0eb             | arg01
03294 0eb             | 	res	1
03294 0ec             | arg02
03294 0ec             | 	res	1
03294 0ed             | arg03
03294 0ed             | 	res	1
03294 0ee             | arg04
03294 0ee             | 	res	1
03294 0ef             | 	fit	480
03294 0ef             | 
