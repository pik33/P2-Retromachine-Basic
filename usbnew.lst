00000                 | 
00000                 | #line 1 "D:/programowanie/P2-Retromachine-Basic/usbnew.p2asm"
00000                 | con
00000                 | 	_clkfreq = 20000000
00000                 | 	_clkmode = 16779595
00000                 | ' 
00000                 | '   DEBUG_DISABLE = true
00000                 | 	DEBUG_DISABLE = -1
00000                 | ' 
00000                 | '   CLKFREQ_PTR = $14
00000                 | 	CLKFREQ_PTR = 20
00000                 | ' 
00000                 | '   USB_BASE_PIN  = 16
00000                 | 	USB_BASE_PIN = 16
00000                 | '   USB_ENABLE_OFFSET = 1 ' Set -1 if not present
00000                 | 	USB_ENABLE_OFFSET = 1
00000                 | '   USB_DMINUS_OFFSET = 2 ' Must end up on an even pin. D+ is always this +1
00000                 | 	USB_DMINUS_OFFSET = 2
00000                 | ' 
00000                 | '   ACTIVITY_LED  = -1
00000                 | 	ACTIVITY_LED = -1
00000                 | '   ERROR_LED     = -1
00000                 | 	ERROR_LED = -1
00000                 | ' 
00000                 | '   OVERLAP_MEMORY = false ' save memory at cost of making the driver non-reentrant
00000                 | 	OVERLAP_MEMORY = 0
00000                 | ' 
00000                 | '   KEYQUEUE_SIZE = 128
00000                 | 	KEYQUEUE_SIZE = 128
00000                 | ' 
00000                 | '   NUMLOCK_DEFAULT_STATE = false
00000                 | 	NUMLOCK_DEFAULT_STATE = 0
00000                 | ' 
00000                 | '   HAVE_MOUSE = true
00000                 | 	HAVE_MOUSE = -1
00000                 | ' 
00000                 | '   HAVE_HIDPAD = true ' Set to false to disable HidPad inteface
00000                 | 	HAVE_HIDPAD = -1
00000                 | '   HIDPAD_REPORT_SIZE = 7*4 ' do not change!
00000                 | 	HIDPAD_REPORT_SIZE = 28
00000                 | '   HIDPAD_DEVICES = 4 ' do not change!
00000                 | 	HIDPAD_DEVICES = 4
00000                 | ' 
00000                 | '   EMUPAD_MAX_PLAYER = 0 ' Set to 0 to disable EmuPad interface
00000                 | 	EMUPAD_MAX_PLAYER = 0
00000                 | '   EMUPAD_MAX_RULES = 32
00000                 | 	EMUPAD_MAX_RULES = 32
00000                 | '   EMUPAD_BUILTIN_RULES = false
00000                 | 	EMUPAD_BUILTIN_RULES = 0
00000                 | '   
00000                 | '     ' EmuPad report format config
00000                 | '   EMUPAD_TYPE_NIBBLE = 7
00000                 | 	EMUPAD_TYPE_NIBBLE = 7
00000                 | '   EMUPAD_TYPE_KBD = 1
00000                 | 	EMUPAD_TYPE_KBD = 1
00000                 | '   EMUPAD_TYPE_PAD = 2
00000                 | 	EMUPAD_TYPE_PAD = 2
00000                 | ' 
00000                 | '   EMUPAD_UP_BIT = 0
00000                 | 	EMUPAD_UP_BIT = 0
00000                 | '   EMUPAD_DOWN_BIT = 1
00000                 | 	EMUPAD_DOWN_BIT = 1
00000                 | '   EMUPAD_LEFT_BIT = 2
00000                 | 	EMUPAD_LEFT_BIT = 2
00000                 | '   EMUPAD_RIGHT_BIT = 3
00000                 | 	EMUPAD_RIGHT_BIT = 3
00000                 | '   EMUPAD_BT0_BIT = 4
00000                 | 	EMUPAD_BT0_BIT = 4
00000                 | '   EMUPAD_BT1_BIT = 5
00000                 | 	EMUPAD_BT1_BIT = 5
00000                 | '   EMUPAD_BT2_BIT = 6
00000                 | 	EMUPAD_BT2_BIT = 6
00000                 | '   EMUPAD_BT3_BIT = 7
00000                 | 	EMUPAD_BT3_BIT = 7
00000                 | '   EMUPAD_BT4_BIT = 8
00000                 | 	EMUPAD_BT4_BIT = 8
00000                 | '   EMUPAD_BT5_BIT = 9
00000                 | 	EMUPAD_BT5_BIT = 9
00000                 | '   EMUPAD_BT6_BIT = 10
00000                 | 	EMUPAD_BT6_BIT = 10
00000                 | '   EMUPAD_BT7_BIT = 11
00000                 | 	EMUPAD_BT7_BIT = 11
00000                 | '   EMUPAD_BT8_BIT = 12
00000                 | 	EMUPAD_BT8_BIT = 12
00000                 | '   EMUPAD_BT9_BIT = 13
00000                 | 	EMUPAD_BT9_BIT = 13
00000                 | ' 
00000                 | ' 
00000                 | '     ' Computed magic values
00000                 | '   _EMUPAD_UD_MASK = (decod EMUPAD_UP_BIT) | (decod EMUPAD_DOWN_BIT)
00000                 | 	_EMUPAD_UD_MASK = 3
00000                 | '   _EMUPAD_LR_MASK = (decod EMUPAD_LEFT_BIT) | (decod EMUPAD_RIGHT_BIT)
00000                 | 	_EMUPAD_LR_MASK = 12
00000                 | '   _EMUPAD_RULE_SIZE = 10+4+1
00000                 | 	_EMUPAD_RULE_SIZE = 15
00000                 | ' 
00000                 | '   _HAVE_GAMEPAD = HAVE_HIDPAD || (EMUPAD_MAX_PLAYER > 0)
00000                 | 	_HAVE_GAMEPAD = -1
00000                 | ' 
00000                 | '   MAX_DEVICES = 7 ' DO. NOT. TOUCH.
00000                 | 	MAX_DEVICES = 7
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Smart pin configuration for "long repository" mode with output enabled,
00000                 | ' ' regardless of DIR. This allows one pin to provide a long event code via IN
00000                 | ' ' and also to control the USB port activity LED on/off state vio OUT.
00000                 | '     SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
00000                 | 	SP_REPO1_MODE = 65602
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' A simple event/cmd system using a smart pin configured in "long repository"
00000                 | ' ' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
00000                 | ' ' signal the client that a particular event has occurred. The client must poll
00000                 | ' ' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
00000                 | ' ' loop and process the event IDs you're interested in.
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, M_READY, KBM_READY, HID_READY
00000                 | 	NO_EVENT = 0
00000                 | 	USB_ERROR = 1
00000                 | 	DEV_UNKNOWN = 2
00000                 | 	KB_READY = 3
00000                 | 	M_READY = 4
00000                 | 	KBM_READY = 5
00000                 | 	HID_READY = 6
00000                 | '     XINPUT_READY, PS3_READY, HUB_READY, DEV_DISCONNECT, DBG_DATA, M_DATA, GP_DATA
00000                 | 	XINPUT_READY = 7
00000                 | 	PS3_READY = 8
00000                 | 	HUB_READY = 9
00000                 | 	DEV_DISCONNECT = 10
00000                 | 	DBG_DATA = 11
00000                 | 	M_DATA = 12
00000                 | 	GP_DATA = 13
00000                 | '     CMD_SUSPEND, CMD_RESUME, CMD_RESET
00000                 | 	CMD_SUSPEND = 14
00000                 | 	CMD_RESUME = 15
00000                 | 	CMD_RESET = 16
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' The CMD_* tokens are asynchronous USB commands available to the user, through
00000                 | ' ' the Spin2 usbCommand method of this object. This method will post the cmd
00000                 | ' ' token to the host and when the cmd is complete the host will post the CMD_*
00000                 | ' ' token to byte[0] of the event long. Byte[1] is typically set to one of the
00000                 | ' ' below protocol error codes, with bytes[2..3] available for additional cmd data.
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Protocol error codes:
00000                 | '     #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
00000                 | 	ERR_NONE = 0
00000                 | 	ERR_CMD = 1
00000                 | 	ERR_URX = 2
00000                 | 	ERR_SE1 = 3
00000                 | 	ERR_PACKET = 4
00000                 | 	ERR_TAT = 5
00000                 | 	ERR_TXN_RETRY = 6
00000                 | '     ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
00000                 | 	ERR_XFER_RETRY = 7
00000                 | 	ERR_NAK = 8
00000                 | 	ERR_DATAX_SYNC = 9
00000                 | 	ERR_CONFIG_FAIL = 10
00000                 | 	ERR_TIMEOUT = 11
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Keyboard LED output report toggle key bit postions:
00000                 | '     #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
00000                 | 	LED_NUMLKB = 0
00000                 | 	LED_CAPSLKB = 1
00000                 | 	LED_SCRLKB = 2
00000                 | 	LED_COMPOSEB = 3
00000                 | '     LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
00000                 | 	LED_KANAB = 4
00000                 | 	LED_CONST0B = 5
00000                 | 	LED_CONST1B = 6
00000                 | 	LED_CONST2B = 7
00000                 | ' ' Keyboard LED output report toggle key bitflags:
00000                 | '     LED_NUMLKF   = decod(LED_NUMLKB)
00000                 | 	LED_NUMLKF = 1
00000                 | '     LED_CAPSLKF  = decod(LED_CAPSLKB)
00000                 | 	LED_CAPSLKF = 2
00000                 | '     LED_SCRLKF   = decod(LED_SCRLKB)
00000                 | 	LED_SCRLKF = 4
00000                 | '     LED_COMPOSEF = decod(LED_COMPOSEB)
00000                 | 	LED_COMPOSEF = 8
00000                 | '     LED_KANAF    = decod(LED_KANAB)
00000                 | 	LED_KANAF = 16
00000                 | '     LED_CONST0F  = decod(LED_CONST0B)
00000                 | 	LED_CONST0F = 32
00000                 | '     LED_CONST1F  = decod(LED_CONST1B)
00000                 | 	LED_CONST1F = 64
00000                 | '     LED_CONST2F  = decod(LED_CONST2B)
00000                 | 	LED_CONST2F = 128
00000                 | ' ' Keyboard modifier key bit positions:
00000                 | '     #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
00000                 | 	LEFT_CTRLB = 0
00000                 | 	LEFT_SHIFTB = 1
00000                 | 	LEFT_ALTB = 2
00000                 | 	LEFT_GUIB = 3
00000                 | '     RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
00000                 | 	RIGHT_CTRLB = 4
00000                 | 	RIGHT_SHIFTB = 5
00000                 | 	RIGHT_ALTB = 6
00000                 | 	RIGHT_GUIB = 7
00000                 | ' ' Keyboard modifier bitflags
00000                 | '     LEFT_CTRLF   = decod(LEFT_CTRLB)
00000                 | 	LEFT_CTRLF = 1
00000                 | '     LEFT_SHIFTF  = decod(LEFT_SHIFTB)
00000                 | 	LEFT_SHIFTF = 2
00000                 | '     LEFT_ALTF    = decod(LEFT_ALTB)
00000                 | 	LEFT_ALTF = 4
00000                 | '     LEFT_GUIF    = decod(LEFT_GUIB)
00000                 | 	LEFT_GUIF = 8
00000                 | '     RIGHT_CTRLF  = decod(RIGHT_CTRLB)
00000                 | 	RIGHT_CTRLF = 16
00000                 | '     RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
00000                 | 	RIGHT_SHIFTF = 32
00000                 | '     RIGHT_ALTF   = decod(RIGHT_ALTB)
00000                 | 	RIGHT_ALTF = 64
00000                 | '     RIGHT_GUIF   = decod(RIGHT_GUIB)
00000                 | 	RIGHT_GUIF = 128
00000                 | ' ' Consolidated left/right modkeys. Add the modifier keys you want to trap
00000                 | ' ' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
00000                 | ' ' The key() Spin2 method does this and the rawKey() method returns the key data
00000                 | ' ' as packed by the USB keyboard driver.
00000                 | ' '   SHIFT = $100
00000                 | ' '   CTRL  = $200
00000                 | ' '   ALT   = $400
00000                 | ' '   APP   = $800
00000                 | ' ' L|R key modifier flag combinations:
00000                 | '     KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
00000                 | 	KEYS_APP = 136
00000                 | '     KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
00000                 | 	KEYS_ALT = 68
00000                 | '     KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
00000                 | 	KEYS_CTRL = 17
00000                 | '     KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF
00000                 | 	KEYS_SHIFT = 34
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     _1thou         = 1_000
00000                 | 	_1thou = 1000
00000                 | '     _1m            = 1_000_000
00000                 | 	_1m = 1000000
00000                 | '     _1b            = 1_000_000_000
00000                 | 	_1b = 1000000000
00000                 | '     _12m           = 12_000_000
00000                 | 	_12m = 12000000
00000                 | '     LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
00000                 | 	LSBTns = 1143472128
00000                 | '     FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
00000                 | 	FSBTns = 1118246011
00000                 | '     LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
00000                 | 	LSBTns4 = 2688
00000                 | '     LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
00000                 | 	LSBTns22 = 14784
00000                 | '     FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
00000                 | 	FSBTns4 = 334
00000                 | '     FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
00000                 | 	FSBTns28 = 2339
00000                 | ' ' NCO baud calculations for low-speed/full-speed:
00000                 | ' '        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
00000                 | ' '        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
00000                 | ' ' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
00000                 | ' ' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
00000                 | '     USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
00000                 | 	USB_V1HMODE_LS = 65648
00000                 | '     USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
00000                 | 	USB_V1DMODE_LS = 65652
00000                 | '     USB_V1HMODE_FS = %1_11001_0 + 1 << 16
00000                 | 	USB_V1HMODE_FS = 65650
00000                 | '     USB_V1DMODE_FS = %1_11011_0 + 1 << 16
00000                 | 	USB_V1DMODE_FS = 65654
00000                 | ' ' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
00000                 | '     USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
00000                 | 	USB_V2_DRVOUT = 65654
00000                 | '     USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
00000                 | 	USB_V2_SNIFF = 65590
00000                 | ' ' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
00000                 | ' '   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
00000                 | ' '   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
00000                 | ' '   USB_H_FS_NCO   = %11 << 14 + _12Mbps
00000                 | ' '   USB_D_FS_NCO   = %01 << 14 + _12Mbps
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Time delays and intervals
00000                 | ' ' Useful USB constants and wait intervals:
00000                 | '     XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
00000                 | 	XFER_RETRIES = 12
00000                 | '     TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
00000                 | 	TXN_RETRIES = 12
00000                 | '     NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
00000                 | 	NAK_NOLIMIT = 0
00000                 | '     IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
00000                 | 	IN_NAK_RETRIES = 50000
00000                 | '     OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
00000                 | 	OUT_NAK_RETRIES = 50000
00000                 | ' ' Standard Device request maximum timeout periods (reference):
00000                 | ' {
00000                 | ' }
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Token packet format.
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' '                   CRC5  ENDP ADDRESS PID
00000                 | '     CRC_MASK     = %11111_0000_0000000_00000000
00000                 | 	CRC_MASK = 16252928
00000                 | '     EP_MASK      = %00000_1111_0000000_00000000
00000                 | 	EP_MASK = 491520
00000                 | '     ADDR_MASK    = %00000_0000_1111111_00000000
00000                 | 	ADDR_MASK = 32512
00000                 | '     EP_ADDR_MASK = %00000_1111_1111111_11111111
00000                 | 	EP_ADDR_MASK = 524287
00000                 | '     EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
00000                 | 	EP_ADDR_ZERO = 1048576
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Packet Identifier Bytes (PID). Notice that the first two LSBits are
00000                 | ' ' identical for each group.
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Token:
00000                 | '     PID_OUT   = %1110_0001                  ' $e1
00000                 | 	PID_OUT = 225
00000                 | '     PID_IN    = %0110_1001                  ' $69
00000                 | 	PID_IN = 105
00000                 | '     PID_SOF   = %1010_0101                  ' $a5
00000                 | 	PID_SOF = 165
00000                 | '     PID_SETUP = %0010_1101                  ' $2d
00000                 | 	PID_SETUP = 45
00000                 | ' ' Data:
00000                 | '     PID_DATA0 = %1100_0011                  ' $c3
00000                 | 	PID_DATA0 = 195
00000                 | '     PID_DATA1 = %0100_1011                  ' $4b
00000                 | 	PID_DATA1 = 75
00000                 | '     PID_DATA2 = %1000_0111                  ' $87
00000                 | 	PID_DATA2 = 135
00000                 | '     PID_MDATA = %0000_1111                  ' $0f
00000                 | 	PID_MDATA = 15
00000                 | ' ' Handshake:
00000                 | '     PID_ACK   = %1101_0010                  ' $d2
00000                 | 	PID_ACK = 210
00000                 | '     PID_NAK   = %0101_1010                  ' $5a
00000                 | 	PID_NAK = 90
00000                 | '     PID_STALL = %0001_1110                  ' $1e
00000                 | 	PID_STALL = 30
00000                 | '     PID_NYET  = %1001_0110                  ' $96
00000                 | 	PID_NYET = 150
00000                 | ' ' Special:
00000                 | '     PID_PRE   = %0011_1100                  ' $3c
00000                 | 	PID_PRE = 60
00000                 | '     PID_ERR   = %0011_1100                  ' $3c
00000                 | 	PID_ERR = 60
00000                 | '     PID_SPLIT = %0111_1000                  ' $78
00000                 | 	PID_SPLIT = 120
00000                 | '     PID_PING  = %1011_0100                  ' $b4
00000                 | 	PID_PING = 180
00000                 | '     PID_RESVD = %1111_0000                  ' $f0
00000                 | 	PID_RESVD = 240
00000                 | ' ' Tx, rx and host related constants
00000                 | ' ' USB transmitter WYPIN D line state options:
00000                 | '     OUT_IDLE = 0
00000                 | 	OUT_IDLE = 0
00000                 | '     OUT_SE0  = 1
00000                 | 	OUT_SE0 = 1
00000                 | '     OUT_K    = 2
00000                 | 	OUT_K = 2
00000                 | '     OUT_J    = 3
00000                 | 	OUT_J = 3
00000                 | '     OUT_EOP  = 4
00000                 | 	OUT_EOP = 4
00000                 | '     OUT_SOP  = $80
00000                 | 	OUT_SOP = 128
00000                 | ' ' USB receiver RDPIN status bit positions:
00000                 | '     #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
00000                 | 	J_IDLEB = 0
00000                 | 	K_RESUMEB = 1
00000                 | 	SE0_RESETB = 2
00000                 | 	SE1_BADB = 3
00000                 | 	SOPB = 4
00000                 | 	EOPB = 5
00000                 | 	BUS_ERRB = 6
00000                 | 	BYTE_TGLB = 7
00000                 | ' ' USB receiver RDPIN status bitflags:
00000                 | '     J_IDLEF    = decod(J_IDLEB)
00000                 | 	J_IDLEF = 1
00000                 | '     K_RESUMEF  = decod(K_RESUMEB)
00000                 | 	K_RESUMEF = 2
00000                 | '     SE0_RESETF = decod(SE0_RESETB)
00000                 | 	SE0_RESETF = 4
00000                 | '     SE1_BADF   = decod(SE1_BADB)
00000                 | 	SE1_BADF = 8
00000                 | '     SOPF       = decod(SOPB)
00000                 | 	SOPF = 16
00000                 | '     EOPF       = decod(EOPB)
00000                 | 	EOPF = 32
00000                 | '     BUS_ERRF   = decod(BUS_ERRB)
00000                 | 	BUS_ERRF = 64
00000                 | '     BYTE_TGLF  = decod(BYTE_TGLB)
00000                 | 	BYTE_TGLF = 128
00000                 | ' ' USB CRC constants:
00000                 | '     USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
00000                 | 	USB5_POLY = 20
00000                 | '     USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
00000                 | 	USB5_RESIDUAL = 6
00000                 | '     USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
00000                 | 	USB16_POLY = 40961
00000                 | '     USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
00000                 | 	USB16_RESIDUAL = 45057
00000                 | ' ' Host->class driver USB connect speed:
00000                 | '     #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
00000                 | 	USB_SPEED_UNKNOWN = 0
00000                 | 	USB_SPEED_LOW = 1
00000                 | 	USB_SPEED_FULL = 2
00000                 | ' ' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
00000                 | '     #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB, KBM_TOGGLEB
00000                 | 	IDLEB = 0
00000                 | 	CONNECTEDB = 1
00000                 | 	LOW_SPEEDB = 2
00000                 | 	DATAx_TGLB = 3
00000                 | 	DWNSTRM_HUBB = 7
00000                 | 	SUSPENDB = 8
00000                 | 	KBM_TOGGLEB = 9
00000                 | ' ' Host status bitflags. Unless otherwise noted, bit states are active high:
00000                 | '     IDLEF        = decod(IDLEB)             ' Set when USB in idle state
00000                 | 	IDLEF = 1
00000                 | '     CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
00000                 | 	CONNECTEDF = 2
00000                 | '     LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
00000                 | 	LOW_SPEEDF = 4
00000                 | '     DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
00000                 | 	DATAx_TGLF = 8
00000                 | ' '   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
00000                 | ' '   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
00000                 | ' '   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
00000                 | '     DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
00000                 | 	DWNSTRM_HUBF = 128
00000                 | '     SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
00000                 | 	SUSPENDF = 256
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' USB References:
00000                 | ' ' Universal Serial Bus Specification, Revision 2.0
00000                 | ' '   www.usb.org/developers/docs/usb20_docs/
00000                 | ' ' Device Class Definition for Human Interface Devices (HID), Version 1.11
00000                 | ' '   www.usb.org/developers/hidpage/
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
00000                 | ' ' Use TYPE_STANDARD for all USB Standard Device Request codes.
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' D7 Data direction  | D6:5 Type    | D4:0 Recipient
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' 0 - Host-to-device | 0 = Standard | 0 = Device
00000                 | ' ' 1 - Device-to-host | 1 = Class    | 1 = Interface
00000                 | ' '                    | 2 = Vendor   | 2 = Endpoint
00000                 | ' '                    | 3 = Reserved | 3 = Other
00000                 | ' '                    |              | 4 -31 = Reserved
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     DIR_HOST_TO_DEV = 0 << 7
00000                 | 	DIR_HOST_TO_DEV = 0
00000                 | '     DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
00000                 | 	DIR_DEV_TO_HOST = 128
00000                 | '     TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
00000                 | 	TYPE_STANDARD = 0
00000                 | '     TYPE_CLASS      = %01 << 5
00000                 | 	TYPE_CLASS = 32
00000                 | '     TYPE_VENDOR     = %10 << 5
00000                 | 	TYPE_VENDOR = 64
00000                 | '     TYPE_RESERVED   = %11 << 5
00000                 | 	TYPE_RESERVED = 96
00000                 | '     RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
00000                 | 	RECIP_DEVICE = 0
00000                 | '     RECIP_INTERFACE = %0_0001
00000                 | 	RECIP_INTERFACE = 1
00000                 | '     RECIP_ENDPOINT  = %0_0010
00000                 | 	RECIP_ENDPOINT = 2
00000                 | '     RECIP_OTHER     = %0_0011
00000                 | 	RECIP_OTHER = 3
00000                 | ' '    RECIP 4 - 31 = Reserved
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Standard Device Request codes (Section 9.4, Table 9-4):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
00000                 | 	REQ_GET_STATUS = 0
00000                 | 	REQ_CLEAR_FEATURE = 1
00000                 | 	REQ_RESERVED_1 = 2
00000                 | 	REQ_SET_FEATURE = 3
00000                 | '     REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
00000                 | 	REQ_RESERVED2 = 4
00000                 | 	REQ_SET_ADDR = 5
00000                 | 	REQ_GET_DESC = 6
00000                 | 	REQ_SET_DESC = 7
00000                 | 	REQ_GET_CONFIG = 8
00000                 | '     REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
00000                 | 	REQ_SET_CONFIG = 9
00000                 | 	REQ_GET_INTF = 10
00000                 | 	REQ_SET_INTF = 11
00000                 | 	REQ_SYNC_FRAME = 12
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Standard descriptor types (Section 9.4, Table 9-5):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
00000                 | 	TYPE_DEVICE = 1
00000                 | 	TYPE_CONFIG = 2
00000                 | 	TYPE_STRING = 3
00000                 | 	TYPE_INTERFACE = 4
00000                 | 	TYPE_ENDPOINT = 5
00000                 | '     TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
00000                 | 	TYPE_QUALIFIER = 6
00000                 | 	TYPE_OTHER_SPEED = 7
00000                 | 	TYPE_INTERFACE_PWR = 8
00000                 | 	TYPE_OTG = 9
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
00000                 | 	CLASS_INFO_INTF = 0
00000                 | 	CLASS_AUDIO = 1
00000                 | 	CLASS_COMM = 2
00000                 | 	CLASS_HID = 3
00000                 | 	CLASS_UNDEF0 = 4
00000                 | '     CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
00000                 | 	CLASS_PHYSICAL = 5
00000                 | 	CLASS_IMAGE = 6
00000                 | 	CLASS_PRINTER = 7
00000                 | 	CLASS_MASS_STORAGE = 8
00000                 | 	CLASS_HUB = 9
00000                 | '     CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
00000                 | 	CLASS_CDC_DATA = 10
00000                 | 	CLASS_SMARTCARD = 11
00000                 | 	CLASS_UNDEF1 = 12
00000                 | 	CLASS_CONT_SECURITY = 13
00000                 | 	CLASS_VIDEO = 14
00000                 | '     CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
00000                 | 	CLASS_HEALTH = 15
00000                 | 	CLASS_AUDIO_VIDEO = 16
00000                 | 	CLASS_BILLBOARD = 17
00000                 | 	CLASS_TYPE_C_BRIDGE = 18
00000                 | '     CLASS_DIAGNOSTIC_DEV  = $dc
00000                 | 	CLASS_DIAGNOSTIC_DEV = 220
00000                 | '     CLASS_WIRELESS_CTRL   = $e0
00000                 | 	CLASS_WIRELESS_CTRL = 224
00000                 | '     CLASS_MISCELLANEOUS   = $ef
00000                 | 	CLASS_MISCELLANEOUS = 239
00000                 | '     CLASS_APP_SPECIFIC    = $fe
00000                 | 	CLASS_APP_SPECIFIC = 254
00000                 | '     CLASS_VENDOR_SPECIFIC = $ff
00000                 | 	CLASS_VENDOR_SPECIFIC = 255
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HUB Class Requests
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #0, HUB_PORT_CONNECTION, HUB_PORT_ENABLE, HUB_PORT_SUSPEND, HUB_PORT_OVERCURRENT
00000                 | 	HUB_PORT_CONNECTION = 0
00000                 | 	HUB_PORT_ENABLE = 1
00000                 | 	HUB_PORT_SUSPEND = 2
00000                 | 	HUB_PORT_OVERCURRENT = 3
00000                 | '     HUB_PORT_RESET[4], HUB_PORT_POWER, HUB_PORT_LOWSPEED[7]
00000                 | 	HUB_PORT_RESET = 4
00000                 | 	HUB_PORT_POWER = 8
00000                 | 	HUB_PORT_LOWSPEED = 9
00000                 | '     HUB_C_PORT_CONNECTION, HUB_C_PORT_ENABLE, HUB_C_PORT_SUSPEND, HUB_C_PORT_OVERCURRENT
00000                 | 	HUB_C_PORT_CONNECTION = 16
00000                 | 	HUB_C_PORT_ENABLE = 17
00000                 | 	HUB_C_PORT_SUSPEND = 18
00000                 | 	HUB_C_PORT_OVERCURRENT = 19
00000                 | '     HUB_C_PORT_RESET, HUB_PORT_TEST, HUB_PORT_INDICATOR
00000                 | 	HUB_C_PORT_RESET = 20
00000                 | 	HUB_PORT_TEST = 21
00000                 | 	HUB_PORT_INDICATOR = 22
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
00000                 | 	HID_GET_REPORT = 1
00000                 | 	HID_GET_IDLE = 2
00000                 | 	HID_GET_PROTO = 3
00000                 | '     HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
00000                 | 	HID_SET_REPORT = 9
00000                 | 	HID_SET_IDLE = 10
00000                 | 	HID_SET_PROTO = 11
00000                 | ' ' HID Descriptor types:
00000                 | '     #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
00000                 | 	TYPE_HID = 33
00000                 | 	TYPE_REPORT = 34
00000                 | 	TYPE_PHYSICAL = 35
00000                 | '     #$29, TYPE_HUB
00000                 | 	TYPE_HUB = 41
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
00000                 | 	TYPE_INPUT = 1
00000                 | 	TYPE_OUTPUT = 2
00000                 | 	TYPE_FEATURE = 3
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID Interface SubClasses:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
00000                 | 	SUBCLASS_INTF_NONE = 0
00000                 | 	SUBCLASS_INTF_BOOT = 1
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID Protocol codes:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
00000                 | 	INTF_PROTO_NONE = 0
00000                 | 	INTF_PROTO_KBD = 1
00000                 | 	INTF_PROTO_MOUSE = 2
00000                 | '     #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
00000                 | 	BOOT_PROTOCOL = 0
00000                 | 	REPORT_PROTOCOL = 1
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Other HID buffer lengths:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     MAX_HID_REPTS   = 4             ' We have this many HID report buffers
00000                 | 	MAX_HID_REPTS = 4
00000                 | '     REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
00000                 | 	REPT_BUFF_LEN = 1024
00000                 | '     REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
00000                 | 	REPT_STRUCT_LEN = 1026
00000                 | '     LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
00000                 | 	LANG_BUFF_LEN = 128
00000                 | '     USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
00000                 | 	USTR_BUFF_LEN = 128
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     LANG_ENG_US  = $0409            ' English (United States)
00000                 | 	LANG_ENG_US = 1033
00000                 | '     LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
00000                 | 	LOCAL_LANGID = 1033
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' SETUP structure member offsets.
00000                 | ' ' NOTE: These offsets are defined in terms of the structure member's data type,
00000                 | ' '       to take advantage of PTRA/B scaled indexing, e.g.:
00000                 | ' '         RDBYTE D,   PTRA[bRequest]
00000                 | ' '         WRWORD D/#, PTRA[wLength]
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     bmRequestType = 0
00000                 | 	bmRequestType = 0
00000                 | '     bRequest      = 1
00000                 | 	bRequest = 1
00000                 | '     wValue        = 1
00000                 | 	wValue = 1
00000                 | '     wIndex        = 2
00000                 | 	wIndex = 2
00000                 | '     wLength       = 3
00000                 | 	wLength = 3
00000                 | ' ' SETUP bmRequestType combinations:
00000                 | ' {
00000                 | ' }
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Standard USB descriptor structure sizes in bytes. The values defined are the
00000                 | ' ' minimum size of the descriptor:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     SETUP_TXN_LEN = 8
00000                 | 	SETUP_TXN_LEN = 8
00000                 | '     DEV_DESC_LEN  = 18
00000                 | 	DEV_DESC_LEN = 18
00000                 | '     CON_DESC_LEN  = 9
00000                 | 	CON_DESC_LEN = 9
00000                 | '     INTF_DESC_LEN = 9
00000                 | 	INTF_DESC_LEN = 9
00000                 | '     ENDP_DESC_LEN = 7
00000                 | 	ENDP_DESC_LEN = 7
00000                 | '     STR0_DESC_LEN = 4
00000                 | 	STR0_DESC_LEN = 4
00000                 | '     USTR_DESC_LEN = 4
00000                 | 	USTR_DESC_LEN = 4
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Other USB-related buffer sizes:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     URX_BUFF_LEN = 128      ' USB receiver scratch buffer
00000                 | 	URX_BUFF_LEN = 128
00000                 | '     CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
00000                 | 	CON_BUFF_LEN = 256
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' CON_bmAttrs member bit positions:
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     ATTR_RESVB     = 7      ' Reserved (should always be one)
00000                 | 	ATTR_RESVB = 7
00000                 | '     ATTR_SELF_PWRB = 6      ' Device Self-Powered
00000                 | 	ATTR_SELF_PWRB = 6
00000                 | '     ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
00000                 | 	ATTR_RMT_WAKEB = 5
00000                 | ' '    bmAttributes bits 4..0 reserved and reset to zero
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' Standard USB descriptor struct member offset and member size, in bytes. Note
00000                 | ' ' that the DESC_bLength and DESC_bDescType members are defined in all of the
00000                 | ' ' descriptors (including HID) at the offsets shown.
00000                 | ' '------------------+
00000                 | ' ' !!! IMPORTANT !!!|
00000                 | ' '------------------+
00000                 | ' ' All standard descriptor member offsets are defined in bytes, so if you want
00000                 | ' ' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
00000                 | ' ' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
00000                 | ' ' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
00000                 | ' '       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
00000                 | ' ' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
00000                 | ' ' must be very careful...
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' '       Member          Offset  Size    Value           Description
00000                 | ' '------------------------------------------------------------------------------
00000                 | '     DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
00000                 | 	DESC_bLength = 0
00000                 | '     DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
00000                 | 	DESC_bDescType = 1
00000                 | ' ' Device Descriptor (Section 9.6.1, Table 9-8):
00000                 | '     DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
00000                 | 	DEV_bcdUSB = 2
00000                 | '     DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
00000                 | 	DEV_bDevClass = 4
00000                 | '     DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
00000                 | 	DEV_bDevSubClass = 5
00000                 | '     DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
00000                 | 	DEV_bProtocol = 6
00000                 | '     DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
00000                 | 	DEV_bMaxPktSize0 = 7
00000                 | '     DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
00000                 | 	DEV_idVendor = 8
00000                 | '     DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
00000                 | 	DEV_idProduct = 10
00000                 | '     DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
00000                 | 	DEV_bcdDevice = 12
00000                 | '     DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
00000                 | 	DEV_iMfg = 14
00000                 | '     DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
00000                 | 	DEV_iProduct = 15
00000                 | '     DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
00000                 | 	DEV_iSerialNum = 16
00000                 | '     DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
00000                 | 	DEV_iNumConfigs = 17
00000                 | '   ' Configuration Descriptor (Section 9.6.3, Table 9-10):
00000                 | ' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
00000                 | '     CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
00000                 | 	CON_wTotalLen = 2
00000                 | '     CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
00000                 | 	CON_bNumIntf = 4
00000                 | '     CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
00000                 | 	CON_bConfigVal = 5
00000                 | '     CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
00000                 | 	CON_iConfig = 6
00000                 | '     CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
00000                 | 	CON_bmAttrs = 7
00000                 | '     CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
00000                 | 	CON_bMaxPower = 8
00000                 | ' ' Interface Descriptor (Section 9.6.5, Table 9-12):
00000                 | ' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
00000                 | '     INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
00000                 | 	INTF_bIntfNum = 2
00000                 | '     INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
00000                 | 	INTF_bAltSetting = 3
00000                 | '     INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
00000                 | 	INTF_bNumEndpts = 4
00000                 | '     INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
00000                 | 	INTF_bIntfClass = 5
00000                 | '     INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
00000                 | 	INTF_bSubClass = 6
00000                 | '                             '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
00000                 | '                             '                       reserved for assignment by the USB-IF.
00000                 | '     INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
00000                 | 	INTF_bProtocol = 7
00000                 | '                             '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
00000                 | '                             '                       vendor-specific protocol for this interface.
00000                 | '     INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
00000                 | 	INTF_iInterface = 8
00000                 | ' ' Endpoint Descriptor (Section 9.6.6, Table 9-13):
00000                 | ' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
00000                 | '     ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
00000                 | 	ENDP_bAddress = 2
00000                 | '     ENDP_bmAttrs     = 3    ' 1     Bitmap
00000                 | 	ENDP_bmAttrs = 3
00000                 | '     ENDP_wMaxPktSize = 4    ' 2     Number
00000                 | 	ENDP_wMaxPktSize = 4
00000                 | '     ENDP_bInterval   = 6    ' 1     Number
00000                 | 	ENDP_bInterval = 6
00000                 | ' ' String Descriptor Zero (Section 9.6.7, Table 9-15):
00000                 | ' '    DESC_bLength     = 0    ' 1     N + 2
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant
00000                 | '     STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
00000                 | 	STR0_wLangID = 2
00000                 | ' ' Unicode String Descriptor (Section 9.6.7, Table 9-16):
00000                 | ' '    DESC_bLength     = 0    ' 1     N + 2
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant
00000                 | '     USTR_wString     = 2    ' N     wString[(N - 2) / 2]
00000                 | 	USTR_wString = 2
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' ' HID Descriptor (Section 6.2.1)
00000                 | ' '------------------------------------------------------------------------------
00000                 | ' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
00000                 | ' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
00000                 | '     HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
00000                 | 	HID_bcdHID = 2
00000                 | '     HID_bCountryCode = 4    ' 1     Number          Hardware target country
00000                 | 	HID_bCountryCode = 4
00000                 | '     HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
00000                 | 	HID_bNumDesc = 5
00000                 | '     HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
00000                 | 	HID_bDescType = 6
00000                 | '     HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).
00000                 | 	HID_wDescLength = 7
00000                 | ' 
00000                 | ' ' HID Report Items from HID 1.11 Section 6.2.2
00000                 | '     HID_USAGE_PAGE      = $04
00000                 | 	HID_USAGE_PAGE = 4
00000                 | '     HID_USAGE           = $08
00000                 | 	HID_USAGE = 8
00000                 | '     HID_COLLECTION      = $A0
00000                 | 	HID_COLLECTION = 160
00000                 | '     HID_END_COLLECTION  = $C0
00000                 | 	HID_END_COLLECTION = 192
00000                 | '     HID_REPORT_COUNT    = $94
00000                 | 	HID_REPORT_COUNT = 148
00000                 | '     HID_REPORT_SIZE     = $74
00000                 | 	HID_REPORT_SIZE = 116
00000                 | '     HID_USAGE_MIN       = $18
00000                 | 	HID_USAGE_MIN = 24
00000                 | '     HID_USAGE_MAX       = $28
00000                 | 	HID_USAGE_MAX = 40
00000                 | '     HID_LOGICAL_MIN     = $14
00000                 | 	HID_LOGICAL_MIN = 20
00000                 | '     HID_LOGICAL_MAX     = $24
00000                 | 	HID_LOGICAL_MAX = 36
00000                 | '     HID_PHYSICAL_MIN    = $34
00000                 | 	HID_PHYSICAL_MIN = 52
00000                 | '     HID_PHYSICAL_MAX    = $44
00000                 | 	HID_PHYSICAL_MAX = 68
00000                 | '     HID_INPUT           = $80
00000                 | 	HID_INPUT = 128
00000                 | '     HID_REPORT_ID       = $84
00000                 | 	HID_REPORT_ID = 132
00000                 | '     HID_OUTPUT          = $90
00000                 | 	HID_OUTPUT = 144
00000                 | ' 
00000                 | ' ' HID Report Usage Pages from HID Usage Tables 1.12 Section 3, Table 1
00000                 | '     HID_USAGE_PAGE_GENERIC_DESKTOP = $01
00000                 | 	HID_USAGE_PAGE_GENERIC_DESKTOP = 1
00000                 | '     HID_USAGE_PAGE_KEY_CODES       = $07
00000                 | 	HID_USAGE_PAGE_KEY_CODES = 7
00000                 | '     HID_USAGE_PAGE_LEDS            = $08
00000                 | 	HID_USAGE_PAGE_LEDS = 8
00000                 | '     HID_USAGE_PAGE_BUTTONS         = $09
00000                 | 	HID_USAGE_PAGE_BUTTONS = 9
00000                 | ' 
00000                 | ' ' HID Report Usages from HID Usage Tables 1.12 Section 4, Table 6
00000                 | '     HID_USAGE_POINTER   = $01
00000                 | 	HID_USAGE_POINTER = 1
00000                 | '     HID_USAGE_MOUSE     = $02
00000                 | 	HID_USAGE_MOUSE = 2
00000                 | '     HID_USAGE_JOYSTICK  = $04
00000                 | 	HID_USAGE_JOYSTICK = 4
00000                 | '     HID_USAGE_GAMEPAD   = $05
00000                 | 	HID_USAGE_GAMEPAD = 5
00000                 | '     HID_USAGE_KEYBOARD  = $06
00000                 | 	HID_USAGE_KEYBOARD = 6
00000                 | '     HID_USAGE_X         = $30
00000                 | 	HID_USAGE_X = 48
00000                 | '     HID_USAGE_Y         = $31
00000                 | 	HID_USAGE_Y = 49
00000                 | '     HID_USAGE_Z         = $32
00000                 | 	HID_USAGE_Z = 50
00000                 | '     HID_USAGE_RX        = $33
00000                 | 	HID_USAGE_RX = 51
00000                 | '     HID_USAGE_RY        = $34
00000                 | 	HID_USAGE_RY = 52
00000                 | '     HID_USAGE_RZ        = $35
00000                 | 	HID_USAGE_RZ = 53
00000                 | '     HID_USAGE_SLIDER    = $36
00000                 | 	HID_USAGE_SLIDER = 54
00000                 | '     HID_USAGE_WHEEL     = $38
00000                 | 	HID_USAGE_WHEEL = 56
00000                 | '     HID_USAGE_HATSWITCH = $39
00000                 | 	HID_USAGE_HATSWITCH = 57
00000                 | ' 
00000                 | ' ' HID Report Collection Types from HID 1.12 6.2.2.6
00000                 | '     HID_COLLECTION_PHYSICAL    = 0
00000                 | 	HID_COLLECTION_PHYSICAL = 0
00000                 | '     HID_COLLECTION_APPLICATION = 1
00000                 | 	HID_COLLECTION_APPLICATION = 1
00000                 | ' 
00000                 | ' ' HID Input/Output/Feature Item Data (attributes) from HID 1.11 6.2.2.5
00000                 | '     HID_ITEM_CONSTANT = $1
00000                 | 	HID_ITEM_CONSTANT = 1
00000                 | '     HID_ITEM_VARIABLE = $2
00000                 | 	HID_ITEM_VARIABLE = 2
00000                 | '     HID_ITEM_RELATIVE = $4
00000                 | 	HID_ITEM_RELATIVE = 4
00000                 | ' 
00000                 | ' ' Keyboard report data buffer lengths (boot protocol):
00000                 | '     KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
00000                 | 	KBD_OUT_RPT_LEN = 1
00000                 | '     KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
00000                 | 	KBD_IN_RPT_LEN = 8
00000                 | ' ' Gamepad report and descriptor data buffer lengths:
00000                 | '     HID_IN_RPT_LEN   = 256
00000                 | 	HID_IN_RPT_LEN = 256
00000                 | '     HID_DESCR_LEN    = 256
00000                 | 	HID_DESCR_LEN = 256
00000                 | ' 
00000                 | ' ' Gamepad axes flag bits
00000                 | '     HID_AXIS_X   = 16+0
00000                 | 	HID_AXIS_X = 16
00000                 | '     HID_AXIS_Y   = 16+1
00000                 | 	HID_AXIS_Y = 17
00000                 | '     HID_AXIS_Z   = 16+2
00000                 | 	HID_AXIS_Z = 18
00000                 | '     HID_AXIS_RX  = 16+3
00000                 | 	HID_AXIS_RX = 19
00000                 | '     HID_AXIS_RY  = 16+4
00000                 | 	HID_AXIS_RY = 20
00000                 | '     HID_AXIS_RZ  = 16+5
00000                 | 	HID_AXIS_RZ = 21
00000                 | ' 
00000                 | ' ' Keyboard keys
00000                 | ' '-------------
00000                 | ' ' The first four scancodes are info/error indicators:
00000                 | '     #$00, KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF
00000                 | 	KEY_NO_KEY = 0
00000                 | 	KEY_ERR_ROLLOVER = 1
00000                 | 	KEY_POST_FAIL = 2
00000                 | 	KEY_ERR_UNDEF = 3
00000                 | ' ' Letters:
00000                 | '     KEY_A         = $04
00000                 | 	KEY_A = 4
00000                 | '     KEY_B         = $05
00000                 | 	KEY_B = 5
00000                 | '     KEY_C         = $06
00000                 | 	KEY_C = 6
00000                 | '     KEY_D         = $07
00000                 | 	KEY_D = 7
00000                 | '     KEY_E         = $08
00000                 | 	KEY_E = 8
00000                 | '     KEY_F         = $09
00000                 | 	KEY_F = 9
00000                 | '     KEY_G         = $0a
00000                 | 	KEY_G = 10
00000                 | '     KEY_H         = $0b
00000                 | 	KEY_H = 11
00000                 | '     KEY_I         = $0c
00000                 | 	KEY_I = 12
00000                 | '     KEY_J         = $0d
00000                 | 	KEY_J = 13
00000                 | '     KEY_K         = $0e
00000                 | 	KEY_K = 14
00000                 | '     KEY_L         = $0f
00000                 | 	KEY_L = 15
00000                 | '     KEY_M         = $10
00000                 | 	KEY_M = 16
00000                 | '     KEY_N         = $11
00000                 | 	KEY_N = 17
00000                 | '     KEY_O         = $12
00000                 | 	KEY_O = 18
00000                 | '     KEY_P         = $13
00000                 | 	KEY_P = 19
00000                 | '     KEY_Q         = $14
00000                 | 	KEY_Q = 20
00000                 | '     KEY_R         = $15
00000                 | 	KEY_R = 21
00000                 | '     KEY_S         = $16
00000                 | 	KEY_S = 22
00000                 | '     KEY_T         = $17
00000                 | 	KEY_T = 23
00000                 | '     KEY_U         = $18
00000                 | 	KEY_U = 24
00000                 | '     KEY_V         = $19
00000                 | 	KEY_V = 25
00000                 | '     KEY_W         = $1a
00000                 | 	KEY_W = 26
00000                 | '     KEY_X         = $1b
00000                 | 	KEY_X = 27
00000                 | '     KEY_Y         = $1c
00000                 | 	KEY_Y = 28
00000                 | '     KEY_Z         = $1d
00000                 | 	KEY_Z = 29
00000                 | ' ' Number Row:
00000                 | '     KEY_1         = $1e 
00000                 | 	KEY_1 = 30
00000                 | '     KEY_2         = $1f 
00000                 | 	KEY_2 = 31
00000                 | '     KEY_3         = $20 
00000                 | 	KEY_3 = 32
00000                 | '     KEY_4         = $21 
00000                 | 	KEY_4 = 33
00000                 | '     KEY_5         = $22 
00000                 | 	KEY_5 = 34
00000                 | '     KEY_6         = $23 
00000                 | 	KEY_6 = 35
00000                 | '     KEY_7         = $24 
00000                 | 	KEY_7 = 36
00000                 | '     KEY_8         = $25 
00000                 | 	KEY_8 = 37
00000                 | '     KEY_9         = $26 
00000                 | 	KEY_9 = 38
00000                 | '     KEY_0         = $27 
00000                 | 	KEY_0 = 39
00000                 | ' ' Keyboard return (ENTER), tab, space, etc.:
00000                 | '     KEY_ENTER     = $28
00000                 | 	KEY_ENTER = 40
00000                 | '     KEY_ESC       = $29
00000                 | 	KEY_ESC = 41
00000                 | '     KEY_BACKSPACE = $2a   ' Delete (backspace)
00000                 | 	KEY_BACKSPACE = 42
00000                 | '     KEY_TAB       = $2b
00000                 | 	KEY_TAB = 43
00000                 | '     KEY_SPACE     = $2c
00000                 | 	KEY_SPACE = 44
00000                 | '     KEY_MINUS     = $2d   ' - and _
00000                 | 	KEY_MINUS = 45
00000                 | '     KEY_EQUAL     = $2e   ' = and +
00000                 | 	KEY_EQUAL = 46
00000                 | '     KEY_LBRACE    = $2f   ' [ and {
00000                 | 	KEY_LBRACE = 47
00000                 | '     KEY_RBRACE    = $30   ' ] and }
00000                 | 	KEY_RBRACE = 48
00000                 | '     KEY_BACKSLASH = $31   ' \ and |
00000                 | 	KEY_BACKSLASH = 49
00000                 | '     KEY_HASHTILDE = $32   ' None-US # and ~
00000                 | 	KEY_HASHTILDE = 50
00000                 | '     KEY_SEMICOLON = $33   ' ; and :
00000                 | 	KEY_SEMICOLON = 51
00000                 | '     KEY_APOST     = $34   ' ' and "
00000                 | 	KEY_APOST = 52
00000                 | '     KEY_GRAVE     = $35   ' ` and ~
00000                 | 	KEY_GRAVE = 53
00000                 | '     KEY_COMMA     = $36   ' , and <
00000                 | 	KEY_COMMA = 54
00000                 | '     KEY_DOT       = $37   ' . and >
00000                 | 	KEY_DOT = 55
00000                 | '     KEY_SLASH     = $38   ' / and ?
00000                 | 	KEY_SLASH = 56
00000                 | '     KEY_CAPSLOCK  = $39
00000                 | 	KEY_CAPSLOCK = 57
00000                 | ' ' Function key scancodes:
00000                 | '     KEY_F1        = $3a
00000                 | 	KEY_F1 = 58
00000                 | '     KEY_F2        = $3b
00000                 | 	KEY_F2 = 59
00000                 | '     KEY_F3        = $3c
00000                 | 	KEY_F3 = 60
00000                 | '     KEY_F4        = $3d
00000                 | 	KEY_F4 = 61
00000                 | '     KEY_F5        = $3e
00000                 | 	KEY_F5 = 62
00000                 | '     KEY_F6        = $3f
00000                 | 	KEY_F6 = 63
00000                 | '     KEY_F7        = $40
00000                 | 	KEY_F7 = 64
00000                 | '     KEY_F8        = $41
00000                 | 	KEY_F8 = 65
00000                 | '     KEY_F9        = $42
00000                 | 	KEY_F9 = 66
00000                 | '     KEY_F10       = $43
00000                 | 	KEY_F10 = 67
00000                 | '     KEY_F11       = $44
00000                 | 	KEY_F11 = 68
00000                 | '     KEY_F12       = $45
00000                 | 	KEY_F12 = 69
00000                 | ' ' Special, toggle and movement keys:
00000                 | '     KEY_PRINTSCREEN = $46
00000                 | 	KEY_PRINTSCREEN = 70
00000                 | '     KEY_SCROLLLOCK  = $47
00000                 | 	KEY_SCROLLLOCK = 71
00000                 | '     KEY_PAUSE       = $48
00000                 | 	KEY_PAUSE = 72
00000                 | '     KEY_INSERT      = $49
00000                 | 	KEY_INSERT = 73
00000                 | '     KEY_HOME        = $4a
00000                 | 	KEY_HOME = 74
00000                 | '     KEY_PAGEUP      = $4b
00000                 | 	KEY_PAGEUP = 75
00000                 | '     KEY_DELETE      = $4c
00000                 | 	KEY_DELETE = 76
00000                 | '     KEY_END         = $4d
00000                 | 	KEY_END = 77
00000                 | '     KEY_PAGEDOWN    = $4e
00000                 | 	KEY_PAGEDOWN = 78
00000                 | '     KEY_RIGHT       = $4f
00000                 | 	KEY_RIGHT = 79
00000                 | '     KEY_LEFT        = $50
00000                 | 	KEY_LEFT = 80
00000                 | '     KEY_DOWN        = $51
00000                 | 	KEY_DOWN = 81
00000                 | '     KEY_UP          = $52
00000                 | 	KEY_UP = 82
00000                 | ' ' Keypad keys:
00000                 | '     KEY_NUMLOCK   = $53
00000                 | 	KEY_NUMLOCK = 83
00000                 | '     KEY_NUMSLASH  = $54
00000                 | 	KEY_NUMSLASH = 84
00000                 | '     KEY_NUMASTER  = $55
00000                 | 	KEY_NUMASTER = 85
00000                 | '     KEY_NUMMINUS  = $56
00000                 | 	KEY_NUMMINUS = 86
00000                 | '     KEY_NUMPLUS   = $57
00000                 | 	KEY_NUMPLUS = 87
00000                 | '     KEY_NUMENTER  = $58
00000                 | 	KEY_NUMENTER = 88
00000                 | '     KEY_NUM1      = $59
00000                 | 	KEY_NUM1 = 89
00000                 | '     KEY_NUM2      = $5a
00000                 | 	KEY_NUM2 = 90
00000                 | '     KEY_NUM3      = $5b
00000                 | 	KEY_NUM3 = 91
00000                 | '     KEY_NUM4      = $5c
00000                 | 	KEY_NUM4 = 92
00000                 | '     KEY_NUM5      = $5d
00000                 | 	KEY_NUM5 = 93
00000                 | '     KEY_NUM6      = $5e
00000                 | 	KEY_NUM6 = 94
00000                 | '     KEY_NUM7      = $5f
00000                 | 	KEY_NUM7 = 95
00000                 | '     KEY_NUM8      = $60
00000                 | 	KEY_NUM8 = 96
00000                 | '     KEY_NUM9      = $61
00000                 | 	KEY_NUM9 = 97
00000                 | '     KEY_NUM0      = $62
00000                 | 	KEY_NUM0 = 98
00000                 | '     KEY_DOT_DEL   = $63
00000                 | 	KEY_DOT_DEL = 99
00000                 | '     KEY_NOUS_SP   = $64   ' Non-US \ and |
00000                 | 	KEY_NOUS_SP = 100
00000                 | '     KEY_APP       = $65   ' Application key
00000                 | 	KEY_APP = 101
00000                 | ' ' Modifier keys:
00000                 | '     KEY_LCTRL     = $E0
00000                 | 	KEY_LCTRL = 224
00000                 | '     KEY_LSHIFT    = $E1
00000                 | 	KEY_LSHIFT = 225
00000                 | '     KEY_LALT      = $E2
00000                 | 	KEY_LALT = 226
00000                 | '     KEY_LMETA     = $E3 ' The left "Windows" key
00000                 | 	KEY_LMETA = 227
00000                 | '     KEY_RCTRL     = $E4
00000                 | 	KEY_RCTRL = 228
00000                 | '     KEY_RSHIFT    = $E5
00000                 | 	KEY_RSHIFT = 229
00000                 | '     KEY_RALT      = $E6
00000                 | 	KEY_RALT = 230
00000                 | '     KEY_RMETA     = $E7 ' The right "Windows" key
00000                 | 	KEY_RMETA = 231
00000                 | ' 
00000                 | '     ' EmuPad default keyboard map
00000                 | '     ' You should probably override these
00000                 | '   EMUPAD_KB_UP    = KEY_UP
00000                 | 	EMUPAD_KB_UP = 82
00000                 | '   EMUPAD_KB_DOWN  = KEY_DOWN
00000                 | 	EMUPAD_KB_DOWN = 81
00000                 | '   EMUPAD_KB_LEFT  = KEY_LEFT
00000                 | 	EMUPAD_KB_LEFT = 80
00000                 | '   EMUPAD_KB_RIGHT = KEY_RIGHT
00000                 | 	EMUPAD_KB_RIGHT = 79
00000                 | '   EMUPAD_KB_BT0   = KEY_D
00000                 | 	EMUPAD_KB_BT0 = 7
00000                 | '   EMUPAD_KB_BT1   = KEY_V
00000                 | 	EMUPAD_KB_BT1 = 25
00000                 | '   EMUPAD_KB_BT2   = KEY_C
00000                 | 	EMUPAD_KB_BT2 = 6
00000                 | '   EMUPAD_KB_BT3   = KEY_X
00000                 | 	EMUPAD_KB_BT3 = 27
00000                 | '   EMUPAD_KB_BT4   = KEY_F
00000                 | 	EMUPAD_KB_BT4 = 9
00000                 | '   EMUPAD_KB_BT5   = KEY_G
00000                 | 	EMUPAD_KB_BT5 = 10
00000                 | '   EMUPAD_KB_BT6   = KEY_T
00000                 | 	EMUPAD_KB_BT6 = 23
00000                 | '   EMUPAD_KB_BT7   = KEY_Y
00000                 | 	EMUPAD_KB_BT7 = 28
00000                 | '   EMUPAD_KB_BT8   = KEY_BACKSPACE
00000                 | 	EMUPAD_KB_BT8 = 42
00000                 | '   EMUPAD_KB_BT9   = KEY_ENTER
00000                 | 	EMUPAD_KB_BT9 = 40
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 20000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $100094b
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 50 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 02 90 5D |  if_ne	jmp	#spininit
0040c 002 A7 F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 01 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 04 80 80 FF 
00420 007 00 90 66 FD | 	hubset	##16779592
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 04 80 00 FF 
00430 00b 4B ED 07 F6 | 	mov	pa, ##16779595
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 96 98 80 FF 
00440 00f 14 00 6E FC | 	wrlong	##20000000, #20
00444 010 BC 01 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
005fc 07e 00 00 00 00 
00600 07f 00 00 00 00 | 	orgf	128
00604 080             | skip_clock_set_
00604 080 A8 06 A0 FD | 	call	#_start
00608 081             | cogexit
00608 081 38 01 80 FF 
0060c 082 1F 00 66 FD | 	waitx	##160000
00610 083 01 56 61 FD | 	cogid	arg01
00614 084 03 56 61 FD | 	cogstop	arg01
00618 085             | spininit
00618 085 61 4B 05 FB | 	rdlong	objptr, ptra++
0061c 086 61 51 05 FB | 	rdlong	result1, ptra++
00620 087 28 06 64 FD | 	setq	#3
00624 088 00 57 05 FB | 	rdlong	arg01, ptra
00628 089 04 F0 87 F1 | 	sub	ptra, #4
0062c 08a 2D 50 61 FD | 	call	result1
00630 08b D4 FF 9F FD | 	jmp	#cogexit
00634 08c             | FCACHE_LOAD_
00634 08c F9 2D 01 F6 |     mov	fcache_tmpb_,ptrb
00638 08d 2B F2 63 FD |     pop	ptrb
0063c 08e 95 EC 8B F9 |     altd	pa,ret_instr_
00640 08f 95 00 00 F6 |     mov	 0-0, ret_instr_
00644 090 28 EC 63 FD |     setq	pa
00648 091 E1 01 04 FB |     rdlong	$0, ptrb++
0064c 092 2A F2 63 FD |     push	ptrb
00650 093 96 F2 03 F6 |     mov ptrb,fcache_tmpb_
00654 094 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00658 095             | ret_instr_
00658 095 00 FE 07 02 |     _ret_ cmp inb,#0
0065c 096             | fcache_tmpb_
0065c 096 00 00 00 00 |     long 0
00660 097             | fcache_load_ptr_
00660 097 8C 00 00 00 |     long FCACHE_LOAD_
00664 098             | builtin_bytefill_
00664 098 01 5A 55 F0 |         shr	arg03, #1 wc
00668 099 AB 58 41 CC |  if_c   wrbyte	arg02, arg01
0066c 09a 01 56 05 C1 |  if_c   add	arg01, #1
00670 09b 00 58 FD F9 |         movbyts	arg02, #0
00674 09c             | builtin_wordfill_
00674 09c 01 5A 55 F0 |         shr	arg03, #1 wc
00678 09d AB 58 51 CC |  if_c   wrword	arg02, arg01
0067c 09e 02 56 05 C1 |  if_c   add	arg01, #2
00680 09f AC 58 29 F9 |         setword	arg02, arg02, #1
00684 0a0             | builtin_longfill_
00684 0a0 AB 00 88 FC |         wrfast	#0,arg01
00688 0a1 00 5A 0D F2 |         cmp	arg03, #0 wz
0068c 0a2 AD 02 D8 5C |  if_nz  rep	#1, arg03
00690 0a3 17 58 61 5D |  if_nz  wflong	arg02
00694 0a4 2D 00 64 FD |         ret
00698 0a5             | 
00698 0a5             | objptr
00698 0a5 54 31 00 00 | 	long	@objmem
0069c 0a6             | ptr__dat__
0069c 0a6 08 07 00 00 | 	long	@_dat_
006a0 0a7             | ptr_stackspace_
006a0 0a7 54 31 00 00 | 	long	@stackspace
006a4 0a8             | result1
006a4 0a8 00 00 00 00 | 	long	0
006a8 0a9             | COG_BSS_START
006a8 0a9             | 	fit	480
006a8                 | 	orgh
006a8                 | hubentry
006a8                 | 
006a8                 | ' 
006a8                 | ' PUB start() : r
006a8                 | _start
006a8     00 52 05 F6 | 	mov	_var01, #0
006ac                 | '   ifnot driver_cog
006ac     15 00 00 FF 
006b0     4B 4C 05 F1 | 	add	ptr__dat__, ##10827
006b4     A6 54 C9 FA | 	rdbyte	_var02, ptr__dat__ wz
006b8     15 00 00 FF 
006bc     4B 4C 85 F1 | 	sub	ptr__dat__, ##10827
006c0     38 00 90 5D |  if_ne	jmp	#LR__0001
006c4                 | '     r := coginit(COGEXEC_NEW,@usb_host_start,0)
006c4     A6 58 01 F6 | 	mov	arg02, ptr__dat__
006c8     10 52 05 F6 | 	mov	_var01, #16
006cc     00 5A 05 F6 | 	mov	arg03, #0
006d0     28 5A 61 FD | 	setq	arg03
006d4     AC 52 F1 FC | 	coginit	_var01, arg02 wc
006d8     01 52 65 C6 |  if_b	neg	_var01, #1
006dc                 | '     if r >= 0
006dc     00 52 55 F2 | 	cmps	_var01, #0 wc
006e0                 | '       driver_cog := r+1
006e0     A9 54 01 36 |  if_ae	mov	_var02, _var01
006e4     01 54 05 31 |  if_ae	add	_var02, #1
006e8     15 00 00 3F 
006ec     4B 4C 05 31 |  if_ae	add	ptr__dat__, ##10827
006f0     A6 54 41 3C |  if_ae	wrbyte	_var02, ptr__dat__
006f4     15 00 00 3F 
006f8     4B 4C 85 31 |  if_ae	sub	ptr__dat__, ##10827
006fc                 | LR__0001
006fc     A9 50 01 F6 | 	mov	result1, _var01
00700                 | _start_ret
00700     2D 00 64 FD | 	ret
00704                 | hubexit
00704     81 00 80 FD | 	jmp	#cogexit
00708                 | 	alignl
00708                 | _dat_
00708                 |                 org     $000
00708 000             | 
00708 000             | usb_host_start
00708 000 F9 8F 02 F6 |                 mov     hcog_base_addr, ptrb
0070c 001             | 
0070c 001 03 00 00 FF 
00710 002 D0 70 07 F6 |                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
00714 003 02 70 47 F0 |                 shr     htmp, #2                        ' so byte->long for the lut cell count
00718 004 B4 04 A0 FE |                 loc     pb, #@hlut_start - @usb_host_start
0071c 005 47 EF 03 F1 |                 add     pb, hcog_base_addr
00720 006 29 70 63 FD |                 setq2   htmp
00724 007 F7 01 00 FB |                 rdlong  0, pb                           ' Do the hub->lut copy
00728 008             | 
00728 008 88 0B A0 FE |                 loc     pb, #@usb_host_init - @usb_host_start
0072c 009 47 EF 03 F1 |                 add     pb, hcog_base_addr
00730 00a 2C EE 63 FD |                 jmp     pb                              ' Initialize host and enter main processing loop
00734 00b             | 
00734 00b             | '------------------------------------------------------------------------------
00734 00b             | ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
00734 00b             | ' special because the receiving function must not respond with either STALL or
00734 00b             | ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
00734 00b             | ' non-control endpoint receives a SETUP token, or the function receives a
00734 00b             | ' corrupt packet, it must ignore the transaction
00734 00b             | '------------------------------------------------------------------------------
00734 00b             | ' On entry:
00734 00b             | '   PTRA - start address of the SETUP data struct.
00734 00b             | ' On exit:
00734 00b             | '   retval - PID_ACK on success, otherwise error code.
00734 00b             | '------------------------------------------------------------------------------
00734 00b             | txn_setup
00734 00b 2D BC C6 F8 |                 setbyte ep_addr_pid, #PID_SETUP, #0
00738 00c 08 B0 06 F6 |                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
0073c 00d 03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
00740 00e 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
00744 00f F8 ED 03 F6 |                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
00748 010             | .setup
00748 010 24 01 B0 FD |                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
0074c 011 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00750 012 2D 00 64 AD |         if_z    ret
00754 013 7C 0B B0 FD |                 call    #retry_wait
00758 014 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
0075c 015 2D 00 64 AD |         if_z    ret
00760 016 F6 F1 03 F6 |                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
00764 017 E0 FF 9F FD |                 jmp     #.setup
00768 018             | 
00768 018             | '------------------------------------------------------------------------------
00768 018             | ' IN/INTERRUPT transaction.
00768 018             | ' Possible function response: STALL or NAK handshake, or DATAx packet.
00768 018             | '------------------------------------------------------------------------------
00768 018             | ' On entry:
00768 018             | '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
00768 018             | '     CRC(b19..23).
00768 018             | ' On exit:
00768 018             | '------------------------------------------------------------------------------
00768 018             | txn_in
00768 018 90 03 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
0076c 019 69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
00770 01a BC 00 B0 FD |                 call    #utx_token                      ' Put IN request on the bus
00774 01b             | 
00774 01b             |                 ' Fall through to urx_packet
00774 01b             | 
00774 01b             | '------------------------------------------------------------------------------
00774 01b             | ' Wait for a packet from a device/function. As host, the only two packet types
00774 01b             | ' received are handshakes and IN DATAx.
00774 01b             | '------------------------------------------------------------------------------
00774 01b             | ' On entry:
00774 01b             | ' On exit:
00774 01b             | '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
00774 01b             | '     returned.
00774 01b             | '------------------------------------------------------------------------------
00774 01b             | urx_packet
00774 01b 22 A7 82 FA |                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
00778 01c 04 A6 16 F4 |                 testb   urx, #SOPB              wc
0077c 01d F4 FF 9F CD |         if_c    jmp     #urx_packet
00780 01e 1A 92 63 FD |                 getct   hct2
00784 01f 4E 93 6B FA |                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
00788 020 05 96 06 F4 |                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
0078c 021 00 A8 06 F6 |                 mov     newb_flg, #0                    ' Initialize for multi-byte read
00790 022             | .wait_sop
00790 022 22 A7 8A FA |                 rdpin   urx, dm
00794 023 04 A6 16 F4 |                 testb   urx, #SOPB              wc
00798 024 08 00 90 CD |         if_c    jmp     #.get_pid
0079c 025 FC 25 CC FB |                 jnct2   #.wait_sop
007a0 026 05 BE 06 06 |         _ret_   mov     retval, #ERR_TAT
007a4 027             | .get_pid
007a4 027 28 02 B0 FD |                 call    #urx_next
007a8 028 06 A6 16 F4 |                 testb   urx, #BUS_ERRB          wc
007ac 029 04 00 90 3D |         if_nc   jmp     #.chk_pid
007b0 02a 02 BE 06 06 |         _ret_   mov     retval, #ERR_URX
007b4 02b             | .chk_pid
007b4 02b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
007b8 02c 5A BE 0E 52 |         if_nz   cmp     retval, #PID_NAK        wz
007bc 02d 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz
007c0 02e 38 00 90 AD |         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
007c4 02f 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
007c8 030 C3 BE 0E F2 |                 cmp     retval, #PID_DATA0      wz
007cc 031 28 01 90 2D |    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
007d0 032 10 00 90 8D |    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
007d4 033 4B BE 0E F2 |                 cmp     retval, #PID_DATA1      wz
007d8 034 1C 01 90 8D |    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
007dc 035 04 00 90 2D |    if_z_and_nc  jmp     #.ack_resend
007e0 036 04 BE 06 06 |         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
007e4 037             | .ack_resend
007e4 037 22 A7 82 FA |                 rqpin   urx, dm
007e8 038 05 A6 16 F4 |                 testb   urx, #EOPB              wc
007ec 039 F4 FF 9F 3D |         if_nc   jmp     #.ack_resend
007f0 03a D2 BE 06 F6 |                 mov     retval, #PID_ACK
007f4 03b 98 01 B0 FD |                 call    #utx_handshake                  ' Send handshake PID and return to caller
007f8 03c 09 BE 06 06 |         _ret_   mov     retval, #ERR_DATAX_SYNC
007fc 03d             | .chk_eop
007fc 03d 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
00800 03e 1C 00 90 3D |         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
00804 03f C8 01 B0 FD |                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
00808 040 05 96 16 F4 |                 testb   hstatus, #EOPB          wc
0080c 041 10 00 90 CD |         if_c    jmp     #.idle                          ' Low-speed EOP seen
00810 042 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
00814 043 04 BE 06 36 |         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
00818 044 02 BE 06 A6 |         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
0081c 045 2D 00 64 FD |                 ret
00820 046             | .idle
00820 046 22 A7 82 FA |                 rqpin   urx, dm
00824 047 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
00828 048 F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
0082c 049 2D 00 64 FD |                 ret
00830 04a             | 
00830 04a             | '------------------------------------------------------------------------------
00830 04a             | ' Send a token packet with CRC5 checksum of address and endpoint. It is the
00830 04a             | ' responsibility of the caller to append the appropriate inter-packet delay,
00830 04a             | ' if one is required.
00830 04a             | '------------------------------------------------------------------------------
00830 04a             | ' On entry:
00830 04a             | '   ep_addr_pid - packed with the PID, address and endpoint.
00830 04a             | ' On exit:
00830 04a             | '------------------------------------------------------------------------------
00830 04a             | utx_token
00830 04a 22 A7 82 FA |                 rqpin   urx, dm
00834 04b 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
00838 04c F4 FF 9F 3D |         if_nc   jmp     #utx_token
0083c 04d 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
00840 04e 34 0D B0 CD |         if_c    call    #utx_pre
00844 04f 80 A4 06 F6 |                 mov     utx, #OUT_SOP
00848 050 70 01 B0 FD |                 call    #utx_byte                       ' Send sync byte
0084c 051 5E 71 03 F6 |                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
00850 052 03 B8 06 F6 |                 mov     pkt_cnt, #3
00854 053             | .next_byte
00854 053 B8 A5 E2 F8 |                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
00858 054 08 70 47 F0 |                 shr     htmp, #8                        ' Shift to next byte to send
0085c 055             | .wait
0085c 055 40 46 72 FD |                 testp   dp                      wc
00860 056 F8 FF 9F 3D |         if_nc   jmp     #.wait
00864 057 23 03 08 FC |                 akpin   dp
00868 058 22 A5 22 FC |                 wypin   utx, dm
0086c 059 F9 B9 6E 0B |         _ret_   djnz    pkt_cnt, #.next_byte
00870 05a             | 
00870 05a             | '------------------------------------------------------------------------------
00870 05a             | ' SETUP/OUT/INTERRUPT transaction.
00870 05a             | ' Possible function response in order of precedence: STALL, ACK, NAK.
00870 05a             | '------------------------------------------------------------------------------
00870 05a             | ' On entry:
00870 05a             | '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
00870 05a             | '     CRC(b19..23).
00870 05a             | '   PTRA - start address of the data buff/struct that has the bytes to send.
00870 05a             | '   pkt_data - count of DATAx payload bytes to send.
00870 05a             | ' On exit:
00870 05a             | '------------------------------------------------------------------------------
00870 05a             | txn_out
00870 05a 88 02 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
00874 05b B8 FF BF FD |                 call    #utx_token                      ' Put SETUP/OUT token on the bus
00878 05c 00 00 C0 FF 
0087c 05d F8 01 78 FC |                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
00880 05e 58 B9 02 F6 |                 mov     pkt_cnt, pkt_data
00884 05f             | 
00884 05f             |                 ' Fall through to utx_data
00884 05f             | 
00884 05f             | '------------------------------------------------------------------------------
00884 05f             | ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
00884 05f             | ' calculated while the data byte is being shifted out. Since data stage
00884 05f             | ' success/fail is not determined until the status stage of the transaction,
00884 05f             | ' this routine is only concerned about the current DATAx packet.
00884 05f             | '------------------------------------------------------------------------------
00884 05f             | ' On entry:
00884 05f             | '   PTRA - hub start address of the data to read.
00884 05f             | '   pkt_cnt - data payload size.
00884 05f             | ' On exit:
00884 05f             | '------------------------------------------------------------------------------
00884 05f             | utx_data
00884 05f 22 A7 82 FA |                 rqpin   urx, dm
00888 060 04 A6 16 F4 |                 testb   urx, #SOPB              wc
0088c 061 F4 FF 9F CD |         if_c    jmp     #utx_data
00890 062 4D 99 02 F6 |                 mov     hctwait, ip_delay
00894 063 2C 0A B0 FD |                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
00898 064 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
0089c 065 D8 0C B0 CD |         if_c    call    #utx_pre
008a0 066 80 A4 06 F6 |                 mov     utx, #OUT_SOP
008a4 067 14 01 B0 FD |                 call    #utx_byte                       ' Send sync
008a8 068 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
008ac 069 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
008b0 06a C3 A4 06 36 |         if_nc   mov     utx, #PID_DATA0
008b4 06b 4B A4 06 C6 |         if_c    mov     utx, #PID_DATA1
008b8 06c 00 01 B0 FD |                 call    #utx_byte                       ' No CRC calc done on PID
008bc 06d 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
008c0 06e 1C 00 90 AD |         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
008c4 06f             | .read_byte
008c4 06f 10 A4 62 FD |                 rfbyte  utx                             ' Fetch data byte
008c8 070 F0 00 B0 FD |                 call    #utx_byte
008cc 071 69 A4 62 FD |                 rev     utx                             ' Calculate CRC while the data is shifting out
008d0 072 28 A4 62 FD |                 setq    utx                             ' SETQ left-justifies the reflected data byte
008d4 073 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
008d8 074 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
008dc 075 F9 B9 6E FB |                 djnz    pkt_cnt, #.read_byte
008e0 076             | .send_crc
008e0 076 E0 BB E6 F4 |                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
008e4 077 5D A5 E2 F8 |                 getbyte utx, crc, #0
008e8 078 D0 00 B0 FD |                 call    #utx_byte
008ec 079 5D A5 EA F8 |                 getbyte utx, crc, #1
008f0 07a C8 00 B0 FD |                 call    #utx_byte                       ' Last CRC byte out
008f4 07b 7C FE 9F FD |                 jmp     #urx_packet                     ' Handle function response/error and back to caller
008f8 07c             | 
008f8 07c             | '------------------------------------------------------------------------------
008f8 07c             | ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
008f8 07c             | ' payload bytes are received. The routine reads bytes until EOP is detected and
008f8 07c             | ' expects that the packet includes at least the CRC word.
008f8 07c             | '
008f8 07c             | ' In control transfers, it's possible to recieve fewer data bytes than what
008f8 07c             | ' was requested, which makes it difficult to determine where the data stops
008f8 07c             | ' and the CRC word begins. So the CRC calculation is done on every byte of the
008f8 07c             | ' packet, including the CRC word. The CRC value should then be equal to the
008f8 07c             | ' USB-16 expected residual value of 0xB001.
008f8 07c             | '
008f8 07c             | ' The routine writes the IN packet data to a static max_packet_size buffer
008f8 07c             | ' so the caller can verify IN success before writing the data to its final
008f8 07c             | ' destination.
008f8 07c             | '------------------------------------------------------------------------------
008f8 07c             | ' On entry:
008f8 07c             | '   pkt_data - max byte count expected to be in the packet.
008f8 07c             | '   newb_flg - signals new byte ready when toggled.
008f8 07c             | ' On exit:
008f8 07c             | '   pkt_cnt - actual number of bytes read.
008f8 07c             | '------------------------------------------------------------------------------
008f8 07c             | urx_data
008f8 07c F7 75 03 F6 |                 mov     htmp2, pb
008fc 07d 27 EF 03 F6 |                 mov     pb, urx_buff_p
00900 07e 00 00 C0 FF 
00904 07f F7 01 88 FC |                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
00908 080 BA EF 03 F6 |                 mov     pb, htmp2
0090c 081 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
00910 082 00 B8 06 F6 |                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
00914 083 58 83 03 F6 |                 mov     pkt_tmp, pkt_data
00918 084 02 82 07 F1 |                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
0091c 085             | .wait_byte
0091c 085             | ' In-line rx for max speed
0091c 085 22 A7 82 FA |                 rqpin   urx, dm
00920 086 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
00924 087 53 A5 02 F5 |                 and     utx, urx
00928 088 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
0092c 089 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
00930 08a 0C 00 90 5D |         if_nz   jmp     #.get_byte                      ' New byte!
00934 08b 05 A6 16 F4 |                 testb   urx, #EOPB              wc
00938 08c 38 00 90 CD |         if_c    jmp     #.chk_crc                       ' At end-of-packet
0093c 08d DC FF 9F FD |                 jmp     #.wait_byte
00940 08e             | .get_byte
00940 08e 53 BF EA F8 |                 getbyte retval, urx, #1                 ' New byte from smart pins
00944 08f 15 BE 62 FD |                 wfbyte  retval                          ' Add it to the data buffer
00948 090 69 BE 62 FD |                 rev     retval                          ' Calculate CRC while next byte is shifting in
0094c 091 28 BE 62 FD |                 setq    retval                          ' SETQ left-justifies the reflected data byte
00950 092 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
00954 093 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
00958 094             | .end_crc
00958 094 01 B8 06 F1 |                 add     pkt_cnt, #1
0095c 095 C1 B9 1A F2 |                 cmp     pkt_cnt, pkt_tmp        wcz
00960 096 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
00964 097 2D 00 64 1D |         if_a    ret
00968 098             | ' For full-speed at 80MHz, the time it takes to do the final byte write and
00968 098             | ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
00968 098             | ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
00968 098             | ' to miss it, so cheat a bit and look for SOP clear here.
00968 098 22 A7 82 FA |                 rqpin   urx, dm
0096c 099 05 A6 16 F4 |                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
00970 09a A8 FF 9F 3D |         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
00974 09b             | ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
00974 09b             | .chk_crc
00974 09b 02 B8 86 F1 |                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
00978 09c 58 00 00 FF 
0097c 09d 01 BA 6E F5 |                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
00980 09e F0 FD 9F 5D |         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
00984 09f D2 BE 06 F6 |                 mov     retval, #PID_ACK
00988 0a0 4D 99 02 F6 |                 mov     hctwait, ip_delay
0098c 0a1 34 09 B0 FD |                 call    #poll_waitx
00990 0a2             | 
00990 0a2             |                 ' Fall through to utx_handshake
00990 0a2             | 
00990 0a2             | '------------------------------------------------------------------------------
00990 0a2             | ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
00990 0a2             | ' the appropriate IP delay has been inserted.
00990 0a2             | '------------------------------------------------------------------------------
00990 0a2             | ' On entry:
00990 0a2             | '   retval - handshake PID to send.
00990 0a2             | ' On exit:
00990 0a2             | '   retval unchanged.
00990 0a2             | '------------------------------------------------------------------------------
00990 0a2             | utx_handshake
00990 0a2 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
00994 0a3 E0 0B B0 CD |         if_c    call    #utx_pre
00998 0a4 80 A4 06 F6 |                 mov     utx, #OUT_SOP
0099c 0a5 1C 00 B0 FD |                 call    #utx_byte                       ' Send sync
009a0 0a6 5F A5 02 F6 |                 mov     utx, retval
009a4 0a7 14 00 B0 FD |                 call    #utx_byte                       ' Send handshake PID
009a8 0a8             | .idle
009a8 0a8 22 A7 82 FA |                 rqpin   urx, dm
009ac 0a9 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
009b0 0aa F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
009b4 0ab 4E 99 02 F6 |                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
009b8 0ac 08 09 90 FD |                 jmp     #poll_waitx
009bc 0ad             | 
009bc 0ad             | '------------------------------------------------------------------------------
009bc 0ad             | ' Wait for the USB tx buffer to empty and feed it a new byte.
009bc 0ad             | '------------------------------------------------------------------------------
009bc 0ad             | ' On entry:
009bc 0ad             | '   utx - byte to transmit.
009bc 0ad             | ' On exit:
009bc 0ad             | '------------------------------------------------------------------------------
009bc 0ad             | utx_byte
009bc 0ad 40 46 72 FD |                 testp   dp                      wc
009c0 0ae F8 FF 9F 3D |         if_nc   jmp     #utx_byte
009c4 0af 23 03 08 FC |                 akpin   dp
009c8 0b0 1F 94 62 FD |                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
009cc 0b1 22 A5 22 0C |         _ret_   wypin   utx, dm
009d0 0b2             | 
009d0 0b2             | '------------------------------------------------------------------------------
009d0 0b2             | ' Fetch the next data byte of a packet. Always check receiver status for EOP.
009d0 0b2             | '------------------------------------------------------------------------------
009d0 0b2             | ' On entry:
009d0 0b2             | ' On exit:
009d0 0b2             | '   retval - the byte read.
009d0 0b2             | '   urx - the receiver status. The caller must check the hstatus reg EOP flag
009d0 0b2             | '     on return. If EOP is set, the byte in reg retval remains as the last byte
009d0 0b2             | '     received.
009d0 0b2             | '------------------------------------------------------------------------------
009d0 0b2             | urx_next
009d0 0b2 22 A7 8A FA |                 rdpin   urx, dm
009d4 0b3 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
009d8 0b4 53 A5 02 F5 |                 and     utx, urx
009dc 0b5 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
009e0 0b6 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
009e4 0b7 53 BF EA 58 |         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
009e8 0b8 2D 00 64 5D |         if_nz   ret                                     ' New byte is priority, so return now
009ec 0b9 04 A6 16 F4 |                 testb   urx, #SOPB              wc
009f0 0ba 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
009f4 0bb D8 FF 9F 4D |    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
009f8 0bc 05 96 26 34 |         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
009fc 0bd 2D 00 64 FD |                 ret
00a00 0be             | 
00a00 0be             | '------------------------------------------------------------------------------
00a00 0be             | ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
00a00 0be             | ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
00a00 0be             | ' length, and the PID is not included in the CRC calculation:
00a00 0be             | '  CRC5  FRAME_NUMBER SOF (full-speed)
00a00 0be             | '  CRC5  ENDP ADDRESS PID
00a00 0be             | ' %00000_1111_1111111_xxxxxxxx
00a00 0be             | '------------------------------------------------------------------------------
00a00 0be             | ' On entry:
00a00 0be             | '   ep_addr_pid - stuffed with the function endpoint, address and
00a00 0be             | '     SETUP/IN/OUT/SOF PID according to the USB standard.
00a00 0be             | ' On exit:
00a00 0be             | '   ep_addr_pid - CRC value appended to the packet.
00a00 0be             | '------------------------------------------------------------------------------
00a00 0be             | calc_crc5
00a00 0be FF 03 00 FF 
00a04 0bf FF BD 06 F5 |                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
00a08 0c0 5E 71 03 F6 |                 mov     htmp, ep_addr_pid
00a0c 0c1 08 70 47 F0 |                 shr     htmp, #8                        ' PID not included in CRC calc
00a10 0c2 1F BA 06 F6 |                 mov     crc, #$1f                       ' Initial CRC5 value
00a14 0c3 69 70 63 FD |                 rev     htmp                            ' Input data reflected
00a18 0c4 28 70 63 FD |                 setq    htmp                            ' CRCNIB setup for data bits 0..7
00a1c 0c5 14 BA DE F9 |                 crcnib  crc, #USB5_POLY
00a20 0c6 14 BA DE F9 |                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
00a24 0c7 09 70 77 F0 |                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
00a28 0c8 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
00a2c 0c9 01 70 77 F0 |                 shl     htmp, #1                wc
00a30 0ca 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
00a34 0cb 01 70 77 F0 |                 shl     htmp, #1                wc
00a38 0cc 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
00a3c 0cd 1F BA 66 F5 |                 xor     crc, #$1f                       ' Final XOR value
00a40 0ce 13 BA 66 F0 |                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
00a44 0cf 5D BD 42 05 |         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
00a48 0d0             | 
00a48 0d0             | '------------------------------------------------------------------------------
00a48 0d0             | ' Full-speed/low-speed frame timing interrupt service routine.
00a48 0d0             | '------------------------------------------------------------------------------
00a48 0d0             | isr1_fsframe
00a48 0d0 1A 92 62 FD |                 getct   iframe_ct_base
00a4c 0d1 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
00a50 0d2 B3 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
00a54 0d3 22 6D 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
00a58 0d4             | .wait
00a58 0d4 40 46 72 FD |                 testp   dp                      wc
00a5c 0d5 F8 FF 9F 3D |         if_nc   jmp     #.wait
00a60 0d6 23 03 08 FC |                 akpin   dp
00a64 0d7 A5 A4 06 F6 |                 mov     utx, #PID_SOF
00a68 0d8 22 01 29 FC |                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
00a6c 0d9 4C FF BF FD |                 call    #utx_byte                       ' Send token PID byte
00a70 0da 1F B6 06 F6 |                 mov     icrc, #$1f                      ' Prime the CRC5 pump
00a74 0db 59 B5 02 F6 |                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
00a78 0dc 69 B4 62 FD |                 rev     sof_pkt                         ' Input data reflected
00a7c 0dd 28 B4 62 FD |                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
00a80 0de 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY
00a84 0df 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
00a88 0e0 59 A5 E2 F8 |                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
00a8c 0e1 2C FF BF FD |                 call    #utx_byte
00a90 0e2 08 B4 66 F0 |                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
00a94 0e3 03 04 DC FC |                 rep     #2, #3                          ' Three data bits left to process
00a98 0e4 01 B4 76 F0 |                 shl     sof_pkt, #1             wc
00a9c 0e5 14 B6 D6 F9 |                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
00aa0 0e6 1F B6 66 F5 |                 xor     icrc, #$1f                      ' Final XOR value
00aa4 0e7 59 A5 EA F8 |                 getbyte utx, frame, #1                  ' Send remaining frame number bits
00aa8 0e8 03 B6 66 F0 |                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
00aac 0e9 5B A5 42 F5 |                 or      utx, icrc
00ab0 0ea 08 FF BF FD |                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
00ab4 0eb A3 81 03 F6 |                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
00ab8 0ec 20 00 90 FD |                 jmp     #isr1_wait
00abc 0ed             | isr1_lsframe
00abc 0ed 1A 92 62 FD |                 getct   iframe_ct_base
00ac0 0ee 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
00ac4 0ef B3 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
00ac8 0f0             | .wait
00ac8 0f0 40 46 72 FD |                 testp   dp                      wc
00acc 0f1 F8 FF 9F 3D |         if_nc   jmp     #.wait
00ad0 0f2 23 03 08 FC |                 akpin   dp
00ad4 0f3 22 09 28 FC |                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
00ad8 0f4 A2 81 03 F6 |                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
00adc 0f5             | isr1_wait
00adc 0f5 22 A5 82 FA |                 rqpin   utx, dm
00ae0 0f6 04 A4 16 F4 |                 testb   utx, #SOPB                 wc
00ae4 0f7 F4 FF 9F CD |         if_c    jmp     #isr1_wait
00ae8 0f8 01 B2 06 F1 |                 add     frame, #1                       ' Next frame# and check for wrap around
00aec 0f9 03 00 00 FF 
00af0 0fa FF B3 06 F5 |                 and     frame, ##$7ff
00af4 0fb 1F 80 63 FD |                 waitx   isrtmp1                         ' Make sure bus is idle
00af8 0fc F5 FF 3B FB |                 reti1
00afc 0fd             | 
00afc 0fd             | '------------------------------------------------------------------------------
00afc 0fd             | ' Wait for a window within the 1ms frame boundary that will ensure that a
00afc 0fd             | ' transaction will complete before the next frame is triggered.
00afc 0fd             | '------------------------------------------------------------------------------
00afc 0fd             | ' On entry:
00afc 0fd             | ' On exit:
00afc 0fd             | '------------------------------------------------------------------------------
00afc 0fd             | wait_txn_ok
00afc 0fd 1A 74 63 FD |                 getct   htmp2
00b00 0fe 49 75 83 F1 |                 sub     htmp2, iframe_ct_base
00b04 0ff 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
00b08 100 A0 75 1B C2 |         if_c    cmp     htmp2, _txn_ok_ls_      wcz
00b0c 101 A1 75 1B 32 |         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
00b10 102 E8 FF 9F 1D |         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
00b14 103 2D 00 64 FD |                 ret
00b18 104             | 
00b18 104             | '------------------------------------------------------------------------------
00b18 104             | ' A device connection was detected, or a bus reset was requested by the USB
00b18 104             | ' client. Set the appropriate smart pin FS/LS speed mode to match the device
00b18 104             | ' and perform a reset sequence prior to device enumeration.
00b18 104             | '------------------------------------------------------------------------------
00b18 104             | dev_reset
00b18 104 22 A7 82 FA |                 rqpin   urx, dm
00b1c 105 01 A6 16 F4 |                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
00b20 106 F4 03 B0 CD |         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
00b24 107 E0 03 B0 3D |         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
00b28 108             | reset
00b28 108 25 00 64 FD |                 setint1 #0                              ' Don't want frame interrupt while in reset
00b2c 109 22 03 28 FC |                 wypin   #OUT_SE0, dm                    ' Assert bus reset
00b30 10a 1F 5A 63 FD |                 waitx   _reset_hold_                    ' Spec is >= 10ms
00b34 10b 22 01 28 FC |                 wypin   #OUT_IDLE, dm
00b38 10c 00 B2 06 F6 |                 mov     frame, #0                       ' Reset the frame timespan count
00b3c 10d 1A 92 62 FD |                 getct   iframe_ct_base
00b40 10e 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
00b44 10f B3 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
00b48 110 59 71 03 F6 |                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
00b4c 111 24 70 07 F1 |                 add     htmp, #36
00b50 112 25 02 64 FD |                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
00b54 113             | .framewait
00b54 113 B8 B3 1A F2 |                 cmp     frame, htmp             wcz
00b58 114 F8 FF 9F CD |         if_b    jmp     #.framewait
00b5c 115 2D 00 64 FD |                 ret
00b60 116             | 
00b60 116             | '------------------------------------------------------------------------------
00b60 116             | ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
00b60 116             | '------------------------------------------------------------------------------
00b60 116             | ' On entry:
00b60 116             | '   PTRA - source address.
00b60 116             | '   PB - destination address.
00b60 116             | '   hr0 - length of copy, in bytes.
00b60 116             | ' On exit:
00b60 116             | '------------------------------------------------------------------------------
00b60 116             | hmemcpy
00b60 116 61 71 C7 FA |                 rdbyte  htmp, ptra++
00b64 117 F7 71 43 FC |                 wrbyte  htmp, pb
00b68 118 01 EE 07 F1 |                 add     pb, #1
00b6c 119 FC 85 6F 0B |         _ret_   djnz    hr0, #hmemcpy
00b70 11a             | 
00b70 11a             | '------------------------------------------------------------------------------
00b70 11a             | ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
00b70 11a             | ' loop until the errant device is disconnected.
00b70 11a             | '------------------------------------------------------------------------------
00b70 11a             | ' On entry:
00b70 11a             | ' On exit:
00b70 11a             | '------------------------------------------------------------------------------
00b70 11a             | host_error
00b70 11a             |           if ERROR_LED >= 0
00b70 11a             |           end
00b70 11a A0 07 90 FD |                 jmp     #host_reset                     ' See if it works...
00b74 11b             | 
00b74 11b             | '------------------------------------------------------------------------------
00b74 11b             | ' Get HID descriptor buffer for current port
00b74 11b             | '------------------------------------------------------------------------------
00b74 11b             | ' On entry:
00b74 11b             | ' On exit:
00b74 11b             | '   PB - HID descriptor buffer pointer
00b74 11b             | '------------------------------------------------------------------------------
00b74 11b             | get_hid_descr_buffer
00b74 11b 2D EF 03 F6 |                 mov     pb, hdev_port
00b78 11c 01 EE E7 F2 |                 cmpsub  pb, #1
00b7c 11d 00 EF 07 FA |                 mul     pb, #HID_DESCR_LEN
00b80 11e 25 EF 03 01 |         _ret_   add     pb, hid_descr_p
00b84 11f             | 
00b84 11f             | 
00b84 11f 01 A0 00 00 | usb16_poly_r    long    USB16_POLY
00b88 120             | 
00b88 120             | ' USB commands and error codes
00b88 120 00 00 00 00 | cmd_data        long    0
00b8c 121 00 00 00 00 | usb_err_code    long    ERR_NONE
00b90 122             | 
00b90 122             | ' Parameters block assigned at cog startup
00b90 122 12 00 00 00 | dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
00b94 123 13 00 00 00 | dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
00b98 124 11 00 00 00 | usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
00b9c 125             | if ACTIVITY_LED >= 0
00b9c 125             | host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
00b9c 125             | end
00b9c 125             | if ERROR_LED >= 0
00b9c 125             | host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
00b9c 125             | end
00b9c 125 00 00 00 00 | hid_descr_p     long    0
00ba0 126             | 'hid_report_p    long    0, 0[MAX_DEVICES]
00ba0 126             | 'hkbd_report_p   long    0
00ba0 126 00 00 00 00 | hub_descr_p     long    0
00ba4 127 00 00 00 00 | urx_buff_p      long    0
00ba8 128 00 00 00 00 | dev_desc_buff_p long    0
00bac 129 00 00 00 00 | con_desc_buff_p long    0
00bb0 12a 00 00 00 00 | cache_start_p   long    0
00bb4 12b 00 00 00 00 | cache_end_p     long    0
00bb8 12c             | if EMUPAD_MAX_PLAYER > 0
00bb8 12c             | emupad_out_ptr  long    0
00bb8 12c             | end
00bb8 12c 00 00 00 00 | save_sysclk     long    0         ' Save the current sysclock as the client may change it
00bbc 12d             | 
00bbc 12d             | hdev_init_start
00bbc 12d             | hdev_port       res     1
00bbc 12d             | hdev_port       res     1
00bbc 12d             | hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
00bbc 12d             | hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
00bbc 12d             | kbm_next_datax  res     1
00bbc 12d             | kbm_next_datax  res     1
00bbc 12d             | hub_intf_num    res     1
00bbc 12d             | hub_intf_num    res     1
00bbc 12d             | hub_next_datax  res     1
00bbc 12d             | hub_next_datax  res     1
00bbc 12d             | hub_status_chg  res     1
00bbc 12d             | hub_status_chg  res     1
00bbc 12d             | hub_port_status res     1
00bbc 12d             | hub_port_status res     1
00bbc 12d             | if HAVE_MOUSE
00bbc 12d             | ms_intf_num     res     1
00bbc 12d             | ms_intf_num     res     1
00bbc 12d             | ms_in_max_pkt   res     1
00bbc 12d             | ms_in_max_pkt   res     1
00bbc 12d             | end
00bbc 12d             | kb_intf_num     res     1
00bbc 12d             | kb_intf_num     res     1
00bbc 12d             | kb_interval     res     1
00bbc 12d             | kb_interval     res     1
00bbc 12d             | kb_in_max_pkt   res     1
00bbc 12d             | kb_in_max_pkt   res     1
00bbc 12d             | kb_max_index    res     1
00bbc 12d             | kb_max_index    res     1
00bbc 12d             | kb_led_states   res     1
00bbc 12d             | kb_led_states   res     1
00bbc 12d             | gp_intf_num     res     1
00bbc 12d             | gp_intf_num     res     1
00bbc 12d             | gp_interval     res     1
00bbc 12d             | gp_interval     res     1
00bbc 12d             | gp_max_index    res     1
00bbc 12d             | gp_max_index    res     1
00bbc 12d             | gp_descr_len    res     1+MAX_DEVICES
00bbc 12d             | gp_descr_len    res     1+MAX_DEVICES
00bbc 12d             | hdev_init_end
00bbc 12d             | 
00bbc 12d             | ' Initialized at cog startup:
00bbc 12d             | hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
00bbc 12d             | hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
00bbc 12d             | iframe_ct_new   res     1
00bbc 12d             | iframe_ct_new   res     1
00bbc 12d             | iframe_ct_base  res     1
00bbc 12d             | iframe_ct_base  res     1
00bbc 12d             | utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
00bbc 12d             | utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
00bbc 12d             | 
00bbc 12d             | ' This register block is reset to zero when a USB device connects
00bbc 12d             | hreg_init_start
00bbc 12d             | hstatus         res     1         ' Host status flags
00bbc 12d             | hstatus         res     1         ' Host status flags
00bbc 12d             | hctwait         res     1         ' Poll-based wait clocks
00bbc 12d             | hctwait         res     1         ' Poll-based wait clocks
00bbc 12d             | ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
00bbc 12d             | ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
00bbc 12d             | tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
00bbc 12d             | tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
00bbc 12d             | nak_retry       res     1         ' NAK retry count, unlimited retries if zero
00bbc 12d             | nak_retry       res     1         ' NAK retry count, unlimited retries if zero
00bbc 12d             | xfer_retry      res     1         ' Control transfer retry count
00bbc 12d             | xfer_retry      res     1         ' Control transfer retry count
00bbc 12d             | retry           res     1         ' Transaction retry count
00bbc 12d             | retry           res     1         ' Transaction retry count
00bbc 12d             | utx             res     1         ' Byte to transmit on USB
00bbc 12d             | utx             res     1         ' Byte to transmit on USB
00bbc 12d             | urx             res     1         ' LSByte receiver status flags, MSByte received data
00bbc 12d             | urx             res     1         ' LSByte receiver status flags, MSByte received data
00bbc 12d             | newb_flg        res     1         ' Receive "new byte" bit toggle detector
00bbc 12d             | newb_flg        res     1         ' Receive "new byte" bit toggle detector
00bbc 12d             | max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
00bbc 12d             | max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
00bbc 12d             | total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
00bbc 12d             | total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
00bbc 12d             | stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
00bbc 12d             | stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
00bbc 12d             | pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
00bbc 12d             | pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
00bbc 12d             | frame           res     1         ' USB 1ms frame counter value
00bbc 12d             | frame           res     1         ' USB 1ms frame counter value
00bbc 12d             | sof_pkt         res     1         ' ISR frame# packet and CRC5
00bbc 12d             | sof_pkt         res     1         ' ISR frame# packet and CRC5
00bbc 12d             | icrc            res     1         ' Only used by the 1ms frame output ISR routine
00bbc 12d             | icrc            res     1         ' Only used by the 1ms frame output ISR routine
00bbc 12d             | pkt_cnt         res     1         ' Count of DATAx packet payload bytes
00bbc 12d             | pkt_cnt         res     1         ' Count of DATAx packet payload bytes
00bbc 12d             | crc             res     1         ' Used for CRC16 calculation
00bbc 12d             | crc             res     1         ' Used for CRC16 calculation
00bbc 12d             | ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
00bbc 12d             | ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
00bbc 12d             | retval          res     1         ' Global success/fail return parameter
00bbc 12d             | retval          res     1         ' Global success/fail return parameter
00bbc 12d             | context_retval  res     1         ' Operation contextual return parameter
00bbc 12d             | context_retval  res     1         ' Operation contextual return parameter
00bbc 12d             | ' Device stuff
00bbc 12d             | hdev_id         res     1+MAX_DEVICES
00bbc 12d             | hdev_id         res     1+MAX_DEVICES
00bbc 12d             | hdev_bcd        res     1
00bbc 12d             | hdev_bcd        res     1
00bbc 12d             | hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
00bbc 12d             | hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
00bbc 12d             | ' Keyboard/mouse stuff
00bbc 12d             | hctrl_ep_addr   res     1
00bbc 12d             | hctrl_ep_addr   res     1
00bbc 12d             | hctrl_max_pkt   res     1
00bbc 12d             | hctrl_max_pkt   res     1
00bbc 12d             | hconfig_base    res     1
00bbc 12d             | hconfig_base    res     1
00bbc 12d             | hcon_tot_len    res     1         ' Size of the complete config descriptor chain
00bbc 12d             | hcon_tot_len    res     1         ' Size of the complete config descriptor chain
00bbc 12d             | hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
00bbc 12d             | hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
00bbc 12d             | hdev_class      res     1
00bbc 12d             | hdev_class      res     1
00bbc 12d             | hdev_subclass   res     1
00bbc 12d             | hdev_subclass   res     1
00bbc 12d             | hdev_protocol   res     1
00bbc 12d             | hdev_protocol   res     1
00bbc 12d             | hsearch_key     res     1         ' Descriptor type to search for in the config chain
00bbc 12d             | hsearch_key     res     1         ' Descriptor type to search for in the config chain
00bbc 12d             | hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
00bbc 12d             | hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
00bbc 12d             | hhub_ctrl_ep    res     1         ' Hub control endpoint address
00bbc 12d             | hhub_ctrl_ep    res     1         ' Hub control endpoint address
00bbc 12d             | hhub_ep_addr    res     1         ' Hub interface endpoint address
00bbc 12d             | hhub_ep_addr    res     1         ' Hub interface endpoint address
00bbc 12d             | hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
00bbc 12d             | hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
00bbc 12d             | hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
00bbc 12d             | hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
00bbc 12d             | if HAVE_MOUSE
00bbc 12d             | hmouse_ep_addr  res     1 ' Mouse interface endpoint address
00bbc 12d             | hmouse_ep_addr  res     1 ' Mouse interface endpoint address
00bbc 12d             | end
00bbc 12d             | hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
00bbc 12d             | hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
00bbc 12d             | hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
00bbc 12d             | hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
00bbc 12d             | hdev_ep_addr    res     1+MAX_DEVICES
00bbc 12d             | hdev_ep_addr    res     1+MAX_DEVICES
00bbc 12d             | hdev_out_addr   res     1
00bbc 12d             | hdev_out_addr   res     1
00bbc 12d             | 
00bbc 12d             | if EMUPAD_MAX_PLAYER > 0
00bbc 12d             | hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
00bbc 12d             | hpad_emupad_buffer res EMUPAD_MAX_PLAYER
00bbc 12d             | hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
00bbc 12d             | end
00bbc 12d             | 
00bbc 12d             | hreg_init_end
00bbc 12d             | 
00bbc 12d             | hidr_start
00bbc 12d             | hidr_usage      res     1 ' <- can get trashed after parsing
00bbc 12d             | hidr_usage      res     1 ' <- can get trashed after parsing
00bbc 12d             | hidr_flags      res     1
00bbc 12d             | hidr_flags      res     1
00bbc 12d             | hidr_axis       res     3
00bbc 12d             | hidr_axis       res     3
00bbc 12d             | hidr_buttons    res     1
00bbc 12d             | hidr_buttons    res     1
00bbc 12d             | hidr_hats       res     1
00bbc 12d             | hidr_hats       res     1
00bbc 12d             | '' Above are actually useful values, 6 longs
00bbc 12d             | hidr_id         res     1
00bbc 12d             | hidr_id         res     1
00bbc 12d             | hidr_state      res     1
00bbc 12d             | hidr_state      res     1
00bbc 12d             | hidr_size       res     1
00bbc 12d             | hidr_size       res     1
00bbc 12d             | hidr_count      res     1
00bbc 12d             | hidr_count      res     1
00bbc 12d             | hidr_offset     res     1
00bbc 12d             | hidr_offset     res     1
00bbc 12d             | hidr_usage_idx  res     1
00bbc 12d             | hidr_usage_idx  res     1
00bbc 12d             | hidr_lminmax    res     1
00bbc 12d             | hidr_lminmax    res     1
00bbc 12d             | hidr_pminmax    res     1
00bbc 12d             | hidr_pminmax    res     1
00bbc 12d             | hidr_type       res     1
00bbc 12d             | hidr_type       res     1
00bbc 12d             | hidr_end
00bbc 12d             | 
00bbc 12d             | ' Variables dependent on the system freqency
00bbc 12d             | _var_64_lower_  res     1
00bbc 12d             | _var_64_lower_  res     1
00bbc 12d             | _var_64_upper_  res     1
00bbc 12d             | _var_64_upper_  res     1
00bbc 12d             | _12Mbps_        res     1
00bbc 12d             | _12Mbps_        res     1
00bbc 12d             | _1_5Mbps_       res     1
00bbc 12d             | _1_5Mbps_       res     1
00bbc 12d             | _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
00bbc 12d             | _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
00bbc 12d             | _1us_           res     1         ' 1us
00bbc 12d             | _1us_           res     1         ' 1us
00bbc 12d             | _10us_          res     1         ' 10us
00bbc 12d             | _10us_          res     1         ' 10us
00bbc 12d             | _33us_          res     1         ' 33us
00bbc 12d             | _33us_          res     1         ' 33us
00bbc 12d             | _txn_err_       res     1         ' 250us
00bbc 12d             | _txn_err_       res     1         ' 250us
00bbc 12d             | _500us_         res     1         ' 500us
00bbc 12d             | _500us_         res     1         ' 500us
00bbc 12d             | _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
00bbc 12d             | _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
00bbc 12d             | _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
00bbc 12d             | _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
00bbc 12d             | _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
00bbc 12d             | _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
00bbc 12d             | _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
00bbc 12d             | _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
00bbc 12d             | _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
00bbc 12d             | _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
00bbc 12d             | _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
00bbc 12d             | _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
00bbc 12d             | _preamble_wait_ res     1
00bbc 12d             | _preamble_wait_ res     1
00bbc 12d             | _1ms_           res     1         ' 1ms
00bbc 12d             | _1ms_           res     1         ' 1ms
00bbc 12d             | _2ms_           res     1         ' 2ms
00bbc 12d             | _2ms_           res     1         ' 2ms
00bbc 12d             | _suspend_wait_  res     1         ' 3ms
00bbc 12d             | _suspend_wait_  res     1         ' 3ms
00bbc 12d             | _4ms_           res     1         ' 4ms
00bbc 12d             | _4ms_           res     1         ' 4ms
00bbc 12d             | _xfer_wait_     res     1         ' 5ms
00bbc 12d             | _xfer_wait_     res     1         ' 5ms
00bbc 12d             | _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
00bbc 12d             | _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
00bbc 12d             | _reset_hold_    res     1         ' 15ms
00bbc 12d             | _reset_hold_    res     1         ' 15ms
00bbc 12d             | _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
00bbc 12d             | _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
00bbc 12d             | _21ms_          res     1         ' 21ms
00bbc 12d             | _21ms_          res     1         ' 21ms
00bbc 12d             | _100ms_         res     1         ' 100ms
00bbc 12d             | _100ms_         res     1         ' 100ms
00bbc 12d             | _500ms_         res     1         ' 500ms
00bbc 12d             | _500ms_         res     1         ' 500ms
00bbc 12d             | _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
00bbc 12d             | _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
00bbc 12d             | _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
00bbc 12d             | _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
00bbc 12d             | '------------------------------------------------------------------------------
00bbc 12d             | _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
00bbc 12d             | _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
00bbc 12d             | _usb_d_ls_nco_  res     1
00bbc 12d             | _usb_d_ls_nco_  res     1
00bbc 12d             | _usb_h_fs_nco_  res     1
00bbc 12d             | _usb_h_fs_nco_  res     1
00bbc 12d             | _usb_d_fs_nco_  res     1
00bbc 12d             | _usb_d_fs_nco_  res     1
00bbc 12d             | '------------------------------------------------------------------------------
00bbc 12d             | ' Scratch registers
00bbc 12d             | htmp            res     1         ' Scratch registers whose context remains within the same code block
00bbc 12d             | htmp            res     1         ' Scratch registers whose context remains within the same code block
00bbc 12d             | htmp1           res     1
00bbc 12d             | htmp1           res     1
00bbc 12d             | htmp2           res     1
00bbc 12d             | htmp2           res     1
00bbc 12d             | htmp3           res     1
00bbc 12d             | htmp3           res     1
00bbc 12d             | hrep            res     1         ' Repeat count
00bbc 12d             | hrep            res     1         ' Repeat count
00bbc 12d             | hsave0          res     1         ' Subroutine parameter saves
00bbc 12d             | hsave0          res     1         ' Subroutine parameter saves
00bbc 12d             | hsave1          res     1
00bbc 12d             | hsave1          res     1
00bbc 12d             | hsave2          res     1
00bbc 12d             | hsave2          res     1
00bbc 12d             | isrtmp1         res     1
00bbc 12d             | isrtmp1         res     1
00bbc 12d             | pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
00bbc 12d             | pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
00bbc 12d             | hr0             res     1         ' Multi-purpose registers
00bbc 12d             | hr0             res     1         ' Multi-purpose registers
00bbc 12d             | hr1             res     1
00bbc 12d             | hr1             res     1
00bbc 12d             | hr2             res     1
00bbc 12d             | hr2             res     1
00bbc 12d             | hr3             res     1
00bbc 12d             | hr3             res     1
00bbc 12d             | hpar1           res     1         ' Routine entry/exit parameters
00bbc 12d             | hpar1           res     1         ' Routine entry/exit parameters
00bbc 12d             | hpar2           res     1
00bbc 12d             | hpar2           res     1
00bbc 12d             | hpar3           res     1
00bbc 12d             | hpar3           res     1
00bbc 12d             | hct2            res     1         ' Function response bus turn-around timer
00bbc 12d             | hct2            res     1         ' Function response bus turn-around timer
00bbc 12d             | hct3            res     1         ' Keyboard/mouse poll timer
00bbc 12d             | hct3            res     1         ' Keyboard/mouse poll timer
00bbc 12d             | mod_cnt         res     1         ' Used in idle loops
00bbc 12d             | mod_cnt         res     1         ' Used in idle loops
00bbc 12d             |                 fit     $1F0
00bbc 12d             |                 org     $200
00bbc 200             | hlut_start
00bbc 200             | 
00bbc 200             | '------------------------------------------------------------------------------
00bbc 200             | ' Full-speed is the host's native speed, so all that is needed is to set the FS
00bbc 200             | ' settings to startup defaults.
00bbc 200             | '------------------------------------------------------------------------------
00bbc 200             | ' On entry:
00bbc 200             | ' On exit: Save/restore caller C flag state if C is changed in this routine!
00bbc 200             | '------------------------------------------------------------------------------
00bbc 200             | set_speed_full
00bbc 200 D0 E8 07 F6 |                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
00bc0 201 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
00bc4 202 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
00bc8 203 A3 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
00bcc 204             | '                ret                             wcz     ' Restore caller flags on exit
00bcc 204             | 
00bcc 204             | '------------------------------------------------------------------------------
00bcc 204             | ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
00bcc 204             | ' is a downstream hub connected (not yet implemented), the baud generator
00bcc 204             | ' remains set at the full-speed rate, but signaling is switched to low-speed,
00bcc 204             | ' which reverses the D-/D+ polarity. The polarity can be changed without
00bcc 204             | ' putting the smart pins into reset.
00bcc 204             | '------------------------------------------------------------------------------
00bcc 204             | ' On entry:
00bcc 204             | ' On exit: CZ flags restored to caller states
00bcc 204             | '------------------------------------------------------------------------------
00bcc 204             | set_speed_low
00bcc 204 80 96 CE F7 |                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
00bd0 205 ED E8 07 A6 |         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
00bd4 206 22 69 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
00bd8 207 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
00bdc 208 A4 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
00be0 209 A2 9B 02 F6 |                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
00be4 20a 02 96 26 F4 |                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
00be8 20b 2D 00 7C FD |                 ret                             wcz     ' Restore caller flags on exit
00bec 20c             | 
00bec 20c             | '------------------------------------------------------------------------------
00bec 20c             | ' Perform configuration stuff required when a device intitially connects.
00bec 20c             | '------------------------------------------------------------------------------
00bec 20c             | ' On entry:
00bec 20c             | ' On exit:
00bec 20c             | '------------------------------------------------------------------------------
00bec 20c             | on_connect
00bec 20c 02 84 07 F6 |                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
00bf0 20d D8 FB BF FD |                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
00bf4 20e             | .retry
00bf4 20e 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
00bf8 20f 01 8C 07 C6 |         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
00bfc 210 02 8C 07 36 |         if_nc   mov     hpar1, #USB_SPEED_FULL
00c00 211 00 08 00 FF 
00c04 212 00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
00c08 213 1C 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
00c0c 214 47 F1 03 F1 |                 add     ptra, hcog_base_addr
00c10 215 03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
00c14 216 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
00c18 217 F4 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
00c1c 218 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00c20 219 18 00 90 AD |         if_z    jmp     #.get_dev_desc
00c24 21a B1 99 02 F6 |                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
00c28 21b 4C 03 B0 FD |                 call    #poll_waitx
00c2c 21c 01 84 8F F1 |                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
00c30 21d F0 FB 9F AD |         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
00c34 21e A4 FB BF FD |                 call    #reset                          ' Try another reset to see if the device responds
00c38 21f B8 FF 9F FD |                 jmp     #.retry
00c3c 220             | .get_dev_desc
00c3c 220 28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
00c40 221 07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
00c44 222 F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
00c48 223 A7 99 02 F6 |                 mov     hctwait, _1ms_
00c4c 224 28 03 B0 FD |                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
00c50 225 88 FB BF FD |                 call    #reset
00c54 226 34 1E C0 FE |                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
00c58 227 47 F1 03 F1 |                 add     ptra, hcog_base_addr
00c5c 228 01 11 5C FC |                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
00c60 229 D8 01 B0 FD |                 call    #control_write                  ' Execute SetAddress()
00c64 22a D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00c68 22b 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
00c6c 22c AC 99 02 F6 |                 mov     hctwait, _8ms_
00c70 22d 04 03 B0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
00c74 22e 04 00 00 FF 
00c78 22f 00 BC 06 F6 |                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
00c7c 230 34 FA BF FD |                 call    #calc_crc5
00c80 231 1C 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
00c84 232 47 F1 03 F1 |                 add     ptra, hcog_base_addr
00c88 233 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
00c8c 234 F7 AD C2 FA |                 rdbyte  total_data, pb
00c90 235 03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
00c94 236 78 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
00c98 237 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00c9c 238 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
00ca0 239 5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
00ca4 23a 28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
00ca8 23b 07 DB C6 FA |                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
00cac 23c 9F 99 02 F6 |                 mov     hctwait, _500us_
00cb0 23d C4 02 B0 FD |                 call    #poll_waitx
00cb4 23e 24 1E C0 FE |                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
00cb8 23f 47 F1 03 F1 |                 add     ptra, hcog_base_addr
00cbc 240 03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
00cc0 241 29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
00cc4 242 48 00 B0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
00cc8 243 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00ccc 244 2D 00 64 5D |         if_nz   ret
00cd0 245 29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
00cd4 246 F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
00cd8 247 61 85 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
00cdc 248 61 87 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
00ce0 249 00 71 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
00ce4 24a 09 84 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
00ce8 24b 02 86 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
00cec 24c 56 71 1B A2 |         if_z    cmp     htmp, total_data        wcz
00cf0 24d 0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
00cf4 24e 2C FB 9F CD |         if_b    jmp     #host_error
00cf8 24f 14 13 80 FE |                 loc     pa, #@init_kbdm_data - @usb_host_start
00cfc 250 47 ED 03 F1 |                 add     pa, hcog_base_addr
00d00 251 2D EC 63 FD |                 call    pa
00d04 252 B8 0D 80 FE |                 loc     pa, #@hparse_con_desc - @usb_host_start
00d08 253 47 ED 03 F1 |                 add     pa, hcog_base_addr
00d0c 254 2C EC 63 FD |                 jmp     pa
00d10 255             | 
00d10 255             | '------------------------------------------------------------------------------
00d10 255             | ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
00d10 255             | ' Status reporting is always in the function-to-host direction.
00d10 255             | '------------------------------------------------------------------------------
00d10 255             | ' On entry:
00d10 255             | '   PTRA - start address of the SETUP data in hub.
00d10 255             | '   PB - start address of the buffer/struct to be written to during the IN data
00d10 255             | '     stage.
00d10 255             | '   ep_addr_pid - device address, endpoint and CRC5.
00d10 255             | ' On exit:
00d10 255             | '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
00d10 255             | '     contains the count of data stage bytes actually received, which must
00d10 255             | '     always be <= the count requested.
00d10 255             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
00d10 255             | '     more specific USB operation error code.
00d10 255             | '------------------------------------------------------------------------------
00d10 255             | control_read
00d10 255 5E 8D 03 F6 |                 mov     hpar1, ep_addr_pid
00d14 256 F8 8F 03 F6 |                 mov     hpar2, ptra
00d18 257 F7 91 03 F6 |                 mov     hpar3, pb                       ' Save dest buffer pointer
00d1c 258 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
00d20 259             | .xfer_start
00d20 259 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
00d24 25a C0 F6 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
00d28 25b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00d2c 25c 2D 00 64 5D |         if_nz   ret                                     ' Back to caller to handle error
00d30 25d 00 AC 0E F2 |                 cmp     total_data, #0          wz
00d34 25e 90 01 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
00d38 25f 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
00d3c 260 61 00 00 FF 
00d40 261 50 9F 06 F6 |                 mov     nak_retry, ##IN_NAK_RETRIES
00d44 262 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
00d48 263             | .data
00d48 263 56 B1 02 F6 |                 mov     pkt_data, total_data
00d4c 264 57 B1 82 F1 |                 sub     pkt_data, stage_data
00d50 265 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
00d54 266 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
00d58 267             | .nak_retry
00d58 267 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
00d5c 268             | .in_retry
00d5c 268 BC F6 BF FD |                 call    #txn_in
00d60 269 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
00d64 26a 28 00 90 AD |         if_z    jmp     #.commit
00d68 26b 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
00d6c 26c A8 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
00d70 26d 14 02 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
00d74 26e 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
00d78 26f DC FF 9F AD |         if_z    jmp     #.nak_retry                     ' Function not ready to send data
00d7c 270 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
00d80 271 94 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
00d84 272 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
00d88 273 D0 FF 9F 5D |         if_nz   jmp     #.in_retry                      ' Bus error retry
00d8c 274 2D 00 64 FD |                 ret                                     ' The transfer has failed
00d90 275             | .commit
00d90 275 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
00d94 276 38 00 90 AD |         if_z    jmp     #.pre_status                    ' and also end-of-data
00d98 277 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
00d9c 278 5C 85 03 F6 |                 mov     hr0, pkt_cnt
00da0 279 F7 F1 0B F2 |                 cmp     ptra, pb                wz
00da4 27a 6C FA BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
00da8 27b 5C AF 02 F1 |                 add     stage_data, pkt_cnt             ' Update bytes received on commit
00dac 27c 56 AF 0A F2 |                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
00db0 27d 1C 00 90 AD |         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
00db4 27e 58 B9 1A F2 |                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
00db8 27f 14 00 90 CD |         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
00dbc 280 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET
00dc0 281 5F C1 02 16 |         if_a    mov     context_retval, retval          ' In this case overall and context are the same
00dc4 282 2D 00 64 1D |         if_a    ret                                     ' Caller must handle ERR_PACKET
00dc8 283 03 96 E6 F4 |                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
00dcc 284 78 FF 9F FD |                 jmp     #.data                          ' Start next IN transaction
00dd0 285             | .pre_status
00dd0 285 57 AD 02 F6 |                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
00dd4 286 E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0
00dd8 287 00 B0 06 F6 |                 mov     pkt_data, #0
00ddc 288 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
00de0 289 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
00de4 28a 61 00 00 FF 
00de8 28b 50 9F 06 F6 |                 mov     nak_retry, ##OUT_NAK_RETRIES
00dec 28c             | .out_retry
00dec 28c 34 F7 BF FD |                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
00df0 28d D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00df4 28e 2D 00 64 AD |         if_z    ret                                     ' All is good when ACK
00df8 28f 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
00dfc 290 18 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
00e00 291 84 01 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
00e04 292 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
00e08 293 0C 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
00e0c 294 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
00e10 295 D8 FF 9F 5D |         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
00e14 296 2D 00 64 FD |                 ret                                     ' Caller must handle transfer retirement
00e18 297             | ' I've encountered transfer STALL, even though the data looks correct, and
00e18 297             | ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
00e18 297             | ' ControlRead() transfer gets things unstuck most of the time...
00e18 297             | .xfer_retry
00e18 297 AB 99 02 F6 |                 mov     hctwait, _xfer_wait_
00e1c 298 58 01 B0 FD |                 call    #poll_waitx
00e20 299 8C F9 BF FD |                 call    #wait_txn_ok
00e24 29a C6 BD 02 F6 |                 mov     ep_addr_pid, hpar1
00e28 29b C7 F1 03 F6 |                 mov     ptra, hpar2
00e2c 29c C8 EF 03 F6 |                 mov     pb, hpar3
00e30 29d BB A1 6E FB |                 djnz    xfer_retry, #.xfer_start
00e34 29e 5F C1 02 F6 |                 mov     context_retval, retval          ' Preserve the USB error code
00e38 29f 07 BE 06 06 |         _ret_   mov     retval, #ERR_XFER_RETRY
00e3c 2a0             | 
00e3c 2a0             | '------------------------------------------------------------------------------
00e3c 2a0             | ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
00e3c 2a0             | ' reporting is always in the function-to-host direction. It is assumed that
00e3c 2a0             | ' the SETUP data struct is filled with the required values.
00e3c 2a0             | '------------------------------------------------------------------------------
00e3c 2a0             | ' On entry:
00e3c 2a0             | '   PTRA - points to the start of the struct for the SETUP data.
00e3c 2a0             | '   PB - the start address of the struct/buffer to be read for the OUT data
00e3c 2a0             | '     stage.
00e3c 2a0             | '   ep_addr_pid - the proper CRC'd address and endpoint to use.
00e3c 2a0             | ' On exit:
00e3c 2a0             | '   retval - used to convey the success/failure of each stage.
00e3c 2a0             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
00e3c 2a0             | '     more specific USB operation error code.
00e3c 2a0             | '------------------------------------------------------------------------------
00e3c 2a0             | control_write
00e3c 2a0 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
00e40 2a1 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
00e44 2a2 0E 68 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
00e48 2a3             | 
00e48 2a3 5E 8D 03 F6 |                 mov     hpar1, ep_addr_pid
00e4c 2a4 F8 8F 03 F6 |                 mov     hpar2, ptra
00e50 2a5 F7 91 03 F6 |                 mov     hpar3, pb
00e54 2a6 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
00e58 2a7             | .xfer_start
00e58 2a7 00 9E 06 F6 |                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
00e5c 2a8 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
00e60 2a9 84 F5 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
00e64 2aa D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00e68 2ab EC 00 90 5D |         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
00e6c 2ac 00 AC 0E F2 |                 cmp     total_data, #0          wz
00e70 2ad 54 00 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
00e74 2ae 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
00e78 2af E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
00e7c 2b0 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
00e80 2b1 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
00e84 2b2             | .data
00e84 2b2 56 B1 02 F6 |                 mov     pkt_data, total_data
00e88 2b3 57 B1 82 F1 |                 sub     pkt_data, stage_data
00e8c 2b4 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
00e90 2b5 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
00e94 2b6             | .out_retry
00e94 2b6 F7 F1 03 F6 |                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
00e98 2b7 88 F6 BF FD |                 call    #txn_out
00e9c 2b8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
00ea0 2b9 10 00 90 AD |         if_z    jmp     #.commit                        ' Function got the data
00ea4 2ba E0 00 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
00ea8 2bb 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
00eac 2bc E4 FF 9F 5D |         if_nz   jmp     #.out_retry
00eb0 2bd A4 00 90 FD |                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
00eb4 2be             | .commit
00eb4 2be F8 EF 03 F6 |                 mov     pb, ptra                        ' Save the current buffer/struct location
00eb8 2bf 58 AF 02 F1 |                 add     stage_data, pkt_data
00ebc 2c0 56 AF 0A F2 |                 cmp     stage_data, total_data  wz
00ec0 2c1 03 96 E6 54 |         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
00ec4 2c2 BC FF 9F 5D |         if_nz   jmp     #.data                          ' More data to send
00ec8 2c3             | pre_status_in
00ec8 2c3 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
00ecc 2c4 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
00ed0 2c5             | .status_retry
00ed0 2c5 00 B0 06 F6 |                 mov     pkt_data, #0
00ed4 2c6 44 F5 BF FD |                 call    #txn_in
00ed8 2c7 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
00edc 2c8 00 B0 0E A2 |         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
00ee0 2c9 74 00 90 AD |         if_z    jmp     #dwnstream_reset                ' Control Write finished
00ee4 2ca 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
00ee8 2cb 2D 00 64 AD |         if_z    ret
00eec 2cc 98 00 B0 FD |                 call    #retry_wait                     ' NAK or bus error, so delay a bit
00ef0 2cd 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
00ef4 2ce D8 FF 9F 5D |         if_nz   jmp     #.status_retry
00ef8 2cf             | '               ret                                     ' Caller must handle transfer retirement
00ef8 2cf             | 
00ef8 2cf             | '------------------------------------------------------------------------------
00ef8 2cf             | ' Execute an IN interrupt transaction.
00ef8 2cf             | '------------------------------------------------------------------------------
00ef8 2cf             | ' On entry:
00ef8 2cf             | '   ep_addr_pid - The function address and endpoint for the IN request.
00ef8 2cf             | '   hpar2 - Address of the IN data buffer
00ef8 2cf             | '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
00ef8 2cf             | ' On exit:
00ef8 2cf             | '   retval - the result of the operation.
00ef8 2cf             | '   hpar3 - the count of IN data bytes actually received.
00ef8 2cf             | '------------------------------------------------------------------------------
00ef8 2cf             | do_int_in
00ef8 2cf 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
00efc 2d0 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
00f00 2d1 0E 68 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
00f04 2d2             | 
00f04 2d2 C8 71 33 F9 |                 getword htmp, hpar3, #0
00f08 2d3 C3 70 0F F2 |                 cmp     htmp, #PID_DATA0        wz
00f0c 2d4 03 96 A6 F4 |                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
00f10 2d5 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES
00f14 2d6             | .retry
00f14 2d6 C8 B1 3A F9 |                 getword pkt_data, hpar3, #1             ' IN max packet length
00f18 2d7 00 F5 BF FD |                 call    #txn_in
00f1c 2d8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK if data received
00f20 2d9 1C 00 90 AD |         if_z    jmp     #.commit
00f24 2da 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
00f28 2db 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
00f2c 2dc 24 00 90 AD |         if_z    jmp     #.post_ret                      ' The caller must handle either
00f30 2dd 54 00 B0 FD |                 call    #retry_wait
00f34 2de 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
00f38 2df 18 00 90 AD |         if_z    jmp     #.post_ret
00f3c 2e0 D4 FF 9F FD |                 jmp     #.retry
00f40 2e1             | .commit
00f40 2e1 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy the rx buffer
00f44 2e2 C7 EF 03 F6 |                 mov     pb, hpar2                       ' to the destination buffer
00f48 2e3 5C 85 0B F6 |                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
00f4c 2e4 F7 F1 0B 52 |         if_nz   cmp     ptra, pb                wz
00f50 2e5 C0 F8 BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
00f54 2e6             | .post_ret
00f54 2e6 5C 91 03 F6 |                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
00f58 2e7             | 
00f58 2e7             | 
00f58 2e7             | '------------------------------------------------------------------------------
00f58 2e7             | ' Resets the downstream hub port to FS
00f58 2e7             | '------------------------------------------------------------------------------
00f58 2e7             | dwnstream_reset
00f58 2e7 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
00f5c 2e8 2D 00 64 3D |         if_nc   ret                                     ' No LS device, reset not needed
00f60 2e9             | 
00f60 2e9 0E 68 07 F4 |                 bitl    _usb_h_ls_nco_, #14
00f64 2ea 07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
00f68 2eb 22 6D 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
00f6c 2ec 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
00f70 2ed A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
00f74 2ee A3 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
00f78 2ef             | 
00f78 2ef             | '------------------------------------------------------------------------------
00f78 2ef             | ' The one millisecond frame timer is implemented as an interrupt service
00f78 2ef             | ' routine. Since this timing is critical, care must be taken to avoid any
00f78 2ef             | ' instructions that can delay the interrupt branch, which will likely upset
00f78 2ef             | ' the timer. WAITX is among those instructions, so any time you're inside
00f78 2ef             | ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
00f78 2ef             | '------------------------------------------------------------------------------
00f78 2ef             | ' On entry:
00f78 2ef             | '   hctwait - wait interval in sysclocks.
00f78 2ef             | ' On exit:
00f78 2ef             | '------------------------------------------------------------------------------
00f78 2ef             | poll_waitx
00f78 2ef 1A 92 63 FD |                 getct   hct2
00f7c 2f0 4C 93 6B FA |                 addct2  hct2, hctwait
00f80 2f1             | .wait
00f80 2f1 FF 25 CC FB |                 jnct2   #.wait
00f84 2f2 2D 00 64 FD |                 ret
00f88 2f3             | 
00f88 2f3             | '------------------------------------------------------------------------------
00f88 2f3             | ' Transaction retry handling for NAK/STALL or bus error.
00f88 2f3             | '------------------------------------------------------------------------------
00f88 2f3             | ' On entry:
00f88 2f3             | '   retval - transaction response PID or error code.
00f88 2f3             | ' On exit:
00f88 2f3             | '------------------------------------------------------------------------------
00f88 2f3             | retry_wait
00f88 2f3 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
00f8c 2f4 2D 00 64 AD |         if_z    ret                                     ' STALL is special case
00f90 2f5 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
00f94 2f6 14 00 90 AD |         if_z    jmp     #.nak
00f98 2f7 9E 99 02 F6 |                 mov     hctwait, _txn_err_              ' Transaction error wait...
00f9c 2f8 D8 FF BF FD |                 call    #poll_waitx
00fa0 2f9             | .dec
00fa0 2f9 01 A2 8E F1 |                 sub     retry, #1               wz
00fa4 2fa 06 BE 06 A6 |         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
00fa8 2fb 2D 00 64 FD |                 ret                                     ' Retry result to caller
00fac 2fc             | .nak
00fac 2fc 9D 99 02 F6 |                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
00fb0 2fd C4 FF BF FD |                 call    #poll_waitx
00fb4 2fe 00 9E 0E F2 |                 cmp     nak_retry, #NAK_NOLIMIT wz
00fb8 2ff 2D 00 64 AD |         if_z    ret                                     ' Indefinite NAK retries
00fbc 300 01 9E 8E F1 |                 sub     nak_retry, #1           wz
00fc0 301 08 BE 06 A6 |         if_z    mov     retval, #ERR_NAK
00fc4 302 2D 00 64 FD |                 ret
00fc8 303             | 
00fc8 303             | host_reset
00fc8 303 25 00 64 FD |                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
00fcc 304 14 70 07 FB |                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
00fd0 305             | ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
00fd0 305 BD 01 05 FF 
00fd4 306 00 70 1F F2 |                 cmp     htmp, ##168_000_000     wcz
00fd8 307 00 94 06 E6 |         if_be   mov     utx_tweak, #0
00fdc 308 03 94 06 16 |         if_a    mov     utx_tweak, #3   '#20
00fe0 309             | ' Check to see if the system clock has been changed.
00fe0 309 2C 71 0B F2 |                 cmp     htmp, save_sysclk       wz
00fe4 30a C4 0B A0 5E |         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
00fe8 30b 47 EF 03 51 |         if_nz   add     pb, hcog_base_addr
00fec 30c 2D EE 63 5D |         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
00ff0 30d 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
00ff4 30e 40 46 62 FD |                 dirl    dp
00ff8 30f             | 
00ff8 30f 28 02 64 FD |                 setq    #1
00ffc 310 80 00 80 FF 
01000 311 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
01004 312 22 6D 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
01008 313             | .enable
01008 313 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
0100c 314 41 46 62 FD |                 dirh    dp
01010 315 1F 36 63 FD |                 waitx   _1us_
01014 316 22 01 28 FC |                 wypin   #OUT_IDLE, dm
01018 317             | 
01018 317             |                 ' Handle Port protection enable and startup delay
01018 317 00 48 16 F2 |                 cmp     usb_enable_pin, #0      wc
0101c 318 58 48 62 3D |         if_ae   drvl    usb_enable_pin                 ' disable port
01020 319 1F 5E 63 FD |                 waitx   _21ms_                          ' Wait a while for everything to turn off
01024 31a 59 48 62 3D |         if_ae   drvh    usb_enable_pin                  ' Enable the port
01028 31b 1F 5E 63 FD |                 waitx   _21ms_                          ' Hold to let the idle state get settled
0102c 31c             | 
0102c 31c 4B ED B7 F9 |                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
01030 31d 3B 04 DC FC |                 rep     @.regloop,#hreg_init_end - hreg_init_start
01034 31e 38 EC A7 F9 |                 alti    pa, #%000_111_000
01038 31f 00 00 04 F6 |                 mov     0-0, #0
0103c 320             | .regloop
0103c 320             | 
0103c 320             |                 'call #dev_reset ' TODO THINK ABOUT THIS
0103c 320             | 
0103c 320             | discon_entry
0103c 320 03 96 07 F6 |                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
01040 321             | 
01040 321             |               
01040 321             |         if HAVE_HIDPAD
01040 321 D8 27 A0 FE |                 loc     pb, #@hidpad_report - @usb_host_start
01044 322 47 EF 03 F1 |                 add     pb, hcog_base_addr
01048 323 28 60 64 FD |                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
0104c 324 F7 01 68 FC |                 wrlong  #0,pb
01050 325             |         end
01050 325             |         if EMUPAD_MAX_PLAYER > 0
01050 325             |         end
01050 325             | 
01050 325             |                 ' Fall through to disconnected loop
01050 325             | 
01050 325             | '-----------------------------------------------------------------------------------------------------------------
01050 325             | ' Device connect handling (Section 7.1.7.3).
01050 325             | '-----------------------------------------------------------------------------------------------------------------
01050 325             | ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
01050 325             | ' device to connect (Section 7.1.7.3).
01050 325             | '-----------------------------------------------------------------------------------------------------------------
01050 325             | disconnected
01050 325 14 86 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
01054 326 2C 87 0B F2 |                 cmp     hr1, save_sysclk        wz
01058 327 6C FF 9F 5D |         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
0105c 328 03 86 47 F0 |                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
01060 329 1F 86 63 FD |                 waitx   hr1                             ' it down to smaller wait chunks
01064 32a             |         if ACTIVITY_LED >= 0
01064 32a             |         end
01064 32a 22 A7 82 FA |                 rqpin   urx, dm
01068 32b 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
0106c 32c E0 FF 9F AD |         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
01070 32d 28 00 90 5D |         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
01074 32e             | .se1_test
01074 32e B0 99 02 F6 |                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
01078 32f FC FE BF FD |                 call    #poll_waitx
0107c 330 22 A7 82 FA |                 rqpin   urx, dm
01080 331 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
01084 332 00 BE 06 56 |         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
01088 333 B0 FF 9F 5D |         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
0108c 334             | .se1            'SE1 is a fatal error condition
0108c 334 B0 99 02 F6 |                 mov     hctwait, _100ms_
01090 335 E4 FE BF FD |                 call    #poll_waitx
01094 336 03 BE 06 F6 |                 mov     retval, #ERR_SE1
01098 337 88 F7 BF FD |                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
0109c 338             | .connect_test                                           ' Test lines until stable J/K state seen
0109c 338 1F 60 63 FD |                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
010a0 339 22 A7 82 FA |                 rqpin   urx, dm
010a4 33a 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
010a8 33b 90 FF 9F AD |         if_z    jmp     #discon_entry                   ' D+ and D- low
010ac 33c C4 FF 9F AD |         if_e    jmp     #.se1_test                      ' D+ and D- high
010b0 33d             | connected
010b0 33d 01 96 26 F4 |                 bith    hstatus, #CONNECTEDB            ' Device plugged in
010b4 33e 34 FB BF FD |                 call    #on_connect                     ' Initial device configuration
010b8 33f D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
010bc 340 7C FF 9F 5D |         if_nz   jmp     #discon_entry
010c0 341             | .set_pulse
010c0 341 1A 64 63 FD |                 getct   _pulse_time_
010c4 342 B1 65 03 F1 |                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
010c8 343             | ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
010c8 343             | ' of 1ms and make a correction, if necessary.
010c8 343             | '                mov     htmp, _1ms_
010c8 343             | '                subs    htmp, iframe_delta
010c8 343             | '                adds    _frame1ms_clks_, htmp
010c8 343             | '                debug(udec(_frame1ms_clks_))
010c8 343             | 
010c8 343             |                 ' Fall through to idle/processing loop
010c8 343 07 5A 1E F2 |                 cmp     hdev_port, #MAX_DEVICES wcz
010cc 344 00 5A 06 16 |         if_a    mov     hdev_port, #0 
010d0 345             | 
010d0 345             | hidle
010d0 345 22 A7 82 FA |                 rqpin   urx, dm
010d4 346 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
010d8 347 98 00 90 CD |         if_c    jmp     #.se0_test
010dc 348 24 06 70 FD |                 pollct3                         wc
010e0 349 68 00 90 3D |         if_nc   jmp     #.nopoll
010e4 34a 1A 94 63 FD |                 getct   hct3
010e8 34b A7 95 73 FA |                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
010ec 34c             | 
010ec 34c 6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
010f0 34d 00 70 E3 F8 |                 getbyte htmp
010f4 34e             | 
010f4 34e 09 70 0F F2 |                 cmp     htmp, #HUB_READY        wz
010f8 34f 88 1B 80 AE |         if_z    loc     pa, #@hget_hub_status - @usb_host_start
010fc 350 40 00 90 AD |         if_z    jmp     #.poll
01100 351             | 
01100 351             |         if _HAVE_GAMEPAD
01100 351 06 70 0F F2 |                 cmp     htmp, #HID_READY        wz
01104 352 08 70 0F 52 |         if_nz   cmp     htmp, #PS3_READY        wz
01108 353 07 70 0F 52 |         if_nz   cmp     htmp, #XINPUT_READY     wz
0110c 354 10 16 80 AE |         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
01110 355 2C 00 90 AD |         if_z    jmp     #.poll
01114 356             |         end
01114 356             | 
01114 356             |         if HAVE_MOUSE
01114 356 04 70 0F F2 |                 cmp     htmp, #M_READY          wz
01118 357 34 15 80 AE |         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
0111c 358 20 00 90 AD |         if_z    jmp     #.poll
01120 359             |         end
01120 359             | 
01120 359 03 70 0F F2 |                 cmp     htmp, #KB_READY         wz
01124 35a 9C 13 80 AE |         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
01128 35b 14 00 90 AD |         if_z    jmp     #.poll
0112c 35c             | 
0112c 35c 05 70 0F F2 |                 cmp     htmp, #KBM_READY        wz
01130 35d 14 00 90 5D |         if_nz   jmp     #.skip_poll
01134 35e 09 96 FE F4 |                 bitnot  hstatus, #KBM_TOGGLEB   wcz
01138 35f 9C 13 80 3E |         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
0113c 360             |         if HAVE_MOUSE
0113c 360 34 15 80 CE |         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
01140 361             |         else
01140 361             |         end
01140 361             | 
01140 361             | .poll
01140 361 47 ED 03 F1 |                 add     pa, hcog_base_addr
01144 362 2D EC 63 FD |                 call    pa
01148 363             | .skip_poll
01148 363             | 
01148 363 07 5A 06 F7 |                 incmod  hdev_port, #MAX_DEVICES
0114c 364             | 
0114c 364             | .nopoll
0114c 364 0E 40 0E F2 |                 cmp     cmd_data, #CMD_SUSPEND  wz
01150 365 44 00 90 AD |         if_z    jmp     #hsuspend
01154 366 10 40 0E F2 |                 cmp     cmd_data, #CMD_RESET    wz
01158 367 00 40 06 A6 |         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
0115c 368 68 FE 9F AD |         if_z    jmp     #host_reset                     ' See if it works...
01160 369 1A 84 63 FD |                 getct   hr0
01164 36a B2 85 1B F2 |                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
01168 36b             |         if ACTIVITY_LED >= 0
01168 36b             |         end
01168 36b 1A 64 63 3D |         if_ae   getct   _pulse_time_
0116c 36c B1 65 03 31 |         if_ae   add     _pulse_time_, _500ms_
01170 36d 5C FF 9F FD |                 jmp     #hidle
01174 36e             | ' Check for extended SE0 state on the bus
01174 36e             | .se0_test
01174 36e A7 99 02 F6 |                 mov     hctwait, _1ms_
01178 36f FC FD BF FD |                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
0117c 370 22 A7 82 FA |                 rqpin   urx, dm
01180 371 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
01184 372 48 FF 9F 3D |         if_nc   jmp     #hidle                          ' Bus still IDLE
01188 373 24 F6 BF FD |                 call    #wait_txn_ok
0118c 374 00 00 80 FF 
01190 375 22 01 28 FC |                 wypin   ##OUT_IDLE, dm                  ' Float USB
01194 376             |                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
01194 376 30 FE 9F FD |                 jmp     #host_reset                     ' Device disconnected
01198 377             | 
01198 377             | hsuspend
01198 377 14 F6 BF FD |                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
0119c 378 25 00 64 FD |                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
011a0 379 1F 52 63 FD |                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
011a4 37a 22 01 28 FC |                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
011a8 37b 00 40 06 F6 |                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
011ac 37c 00 96 07 F6 |                 mov     mod_cnt, #0
011b0 37d             | 
011b0 37d             |                 ' Fall through to resume wait loop
011b0 37d             | 
011b0 37d             | hwait_resume
011b0 37d 14 86 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
011b4 37e 02 86 47 F0 |                 shr     hr1, #2
011b8 37f 1F 86 63 FD |                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
011bc 380             |         if ACTIVITY_LED >= 0
011bc 380             |         end
011bc 380 0F 40 0E F2 |                 cmp     cmd_data, #CMD_RESUME   wz
011c0 381 EC FF 9F 5D |         if_nz   jmp     #hwait_resume
011c4 382 14 70 07 FB |                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
011c8 383 2C 71 0B F2 |                 cmp     htmp, save_sysclk       wz
011cc 384 18 00 90 AD |         if_z    jmp     #.resume
011d0 385 C4 0B A0 FE |                 loc     pb, #@hinit_usb_timings - @usb_host_start
011d4 386 47 EF 03 F1 |                 add     pb, hcog_base_addr
011d8 387 2D EE 63 FD |                 call    pb                              ' Recalculate sysclk dependent timing values
011dc 388 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
011e0 389 22 6D 13 3C |         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
011e4 38a 22 69 13 CC |         if_c    wxpin   _usb_h_ls_nco_, dm
011e8 38b             | .resume
011e8 38b 22 05 28 FC |                 wypin   #OUT_K, dm
011ec 38c 1F 5C 63 FD |                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
011f0 38d 22 03 28 FC |                 wypin   #OUT_SE0, dm
011f4 38e A2 71 03 F6 |                 mov     htmp, _ip_delay_ls_
011f8 38f 01 70 47 F0 |                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
011fc 390 1F 70 63 FD |                 waitx   htmp
01200 391 22 07 28 FC |                 wypin   #OUT_J, dm
01204 392 01 70 47 F0 |                 shr     htmp, #1
01208 393 1F 70 63 FD |                 waitx   htmp
0120c 394 22 01 28 FC |                 wypin   #OUT_IDLE, dm
01210 395 1A 92 62 FD |                 getct   iframe_ct_base
01214 396 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
01218 397 B3 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
0121c 398 25 02 64 FD |                 setint1 #1                              ' Enable the 1ms frame ISR
01220 399 AA 99 02 F6 |                 mov     hctwait, _4ms_
01224 39a 50 FD BF FD |                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
01228 39b 00 40 06 06 |         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
0122c 39c             | 
0122c 39c             | '------------------------------------------------------------------------------
0122c 39c             | ' Send preamble to enable low-speed HUB ports
0122c 39c             | '------------------------------------------------------------------------------
0122c 39c             | ' On entry:
0122c 39c             | ' On exit:
0122c 39c             | '   USB baud rate set to low-speed
0122c 39c             | '------------------------------------------------------------------------------
0122c 39c             | utx_pre
0122c 39c 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
01230 39d 40 46 62 FD |                 dirl    dp
01234 39e 28 02 64 FD |                 setq    #1
01238 39f 22 01 08 FC |                 wrpin   #0, dm                          ' Disable smartpin mode
0123c 3a0 58 44 62 FD |                 drvl    dm
01240 3a1 59 46 62 FD |                 drvh    dp
01244 3a2             | 
01244 3a2 1E 00 00 FF 
01248 3a3 80 70 07 F6 |                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
0124c 3a4             | 
0124c 3a4 11 08 DC FC |                 rep     @.l1, #16 + 1
01250 3a5 01 70 57 F0 |                 shr     htmp, #1        wc
01254 3a6 28 02 64 3D |         if_nc   setq    #1
01258 3a7 4F 44 62 3D |         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
0125c 3a8 1F 4C 63 FD |                 waitx   _preamble_wait_
01260 3a9             | .l1
01260 3a9             | 
01260 3a9 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
01264 3aa 40 46 62 FD |                 dirl    dp
01268 3ab 28 02 64 FD |                 setq    #1
0126c 3ac 80 00 80 FF 
01270 3ad 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
01274 3ae 22 69 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
01278 3af 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
0127c 3b0 41 46 62 FD |                 dirh    dp
01280 3b1 22 01 28 FC |                 wypin   #OUT_IDLE, dm
01284 3b2             | 
01284 3b2 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
01288 3b3 A4 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
0128c 3b4 A2 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
01290 3b5             | 
01290 3b5             | hlut_end
01290 3b5             |                 fit     $400
01290 3b5             |                 orgh
01290                 | if OVERLAP_MEMORY
01290                 |                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
01290                 | end
01290                 | '------------------------------------------------------------------------------
01290                 | ' Routines called from cog space.
01290                 | '------------------------------------------------------------------------------
01290                 | ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
01290                 | '------------------------------------------------------------------------------
01290                 | 
01290                 | '------------------------------------------------------------------------------
01290                 | ' USB host cog initialization.
01290                 | '------------------------------------------------------------------------------
01290                 | usb_host_init
01290                 |                 ' Initialize buffer pointers
01290                 |         if OVERLAP_MEMORY
01290                 |         else
01290     40 15 B0 FE |                 loc     pb, #hid_descr
01294                 |         end
01294     F7 4B 02 F6 |                 mov     hid_descr_p, pb
01298                 |                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
01298                 |                 {
01298                 |                 }
01298                 |         
01298                 |                 {
01298                 |                 }
01298                 |                 'loc     pb,#hkbd_report
01298                 |                 'mov     hkbd_report_p,pb
01298                 | 
01298     08 1D B0 FE |                 loc     pb, #hub_descr
0129c     F7 4D 02 F6 |                 mov     hub_descr_p, pb
012a0     1D 1D B0 FE |                 loc     pb, #urx_buff
012a4     F7 4F 02 F6 |                 mov     urx_buff_p, pb
012a8     95 1D B0 FE |                 loc     pb, #dev_desc_buff
012ac     F7 51 02 F6 |                 mov     dev_desc_buff_p, pb
012b0     9F 1D B0 FE |                 loc     pb, #con_desc_buff
012b4     F7 53 02 F6 |                 mov     con_desc_buff_p, pb
012b8     18 15 B0 FE |                 loc     pb, #usb_cache_start
012bc     F7 55 02 F6 |                 mov     cache_start_p, pb
012c0     E9 1C B0 FE |                 loc     pb, #usb_cache_end
012c4     F7 57 02 F6 |                 mov     cache_end_p, pb
012c8                 | 
012c8                 |         if ERROR_LED >= 0
012c8                 |         end
012c8                 | 
012c8                 |                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
012c8                 |                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
012c8                 |                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
012c8                 | ' Configure and enable the Serial Host USB port.
012c8     03 03 80 FD |                 jmp     #host_reset                     ' Initialize host and enter main processing loop
012cc                 | 
012cc                 | '------------------------------------------------------------------------------
012cc                 | ' Timing calculations happen before any interrupt(s) are enabled.
012cc                 | '------------------------------------------------------------------------------
012cc                 | ' On entry:
012cc                 | '   htmp - current CLKFREQ value.
012cc                 | '------------------------------------------------------------------------------
012cc                 | hinit_usb_timings
012cc                 | '                getct   htmp2
012cc     B8 59 02 F6 |                 mov     save_sysclk, htmp
012d0     8D 5B 80 FF 
012d4     2C 01 2A FD |                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
012d8     18 30 63 FD |                 getqx   _12Mbps_
012dc     10 30 57 F0 |                 shr     _12Mbps_, #16           wc
012e0     00 30 27 F1 |                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
012e4     03 6C 07 F6 |                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
012e8     0E 6C 67 F0 |                 shl     _usb_h_fs_nco_, #14
012ec     98 6D 03 F1 |                 add     _usb_h_fs_nco_, _12Mbps_
012f0     01 6E 07 F6 |                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
012f4     0E 6E 67 F0 |                 shl     _usb_d_fs_nco_, #14
012f8     98 6F 03 F1 |                 add     _usb_d_fs_nco_, _12Mbps_
012fc     98 33 03 F6 |                 mov     _1_5Mbps_, _12Mbps_
01300     03 32 47 F0 |                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
01304     02 68 07 F6 |                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
01308     0E 68 67 F0 |                 shl     _usb_h_ls_nco_, #14
0130c     99 69 03 F1 |                 add     _usb_h_ls_nco_, _1_5Mbps_
01310     99 6B 03 F6 |                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
01314     80 00 00 FF 
01318     00 58 06 FD |                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
0131c     18 2C 63 FD |                 getqx   _var_64_lower_
01320     19 2E 63 FD |                 getqy   _var_64_upper_
01324     28 2C 63 FD |                 setq    _var_64_lower_
01328     65 CD 1D FF 
0132c     00 2E 27 FD |                 qfrac   _var_64_upper_, ##_1b
01330     18 34 63 FD |                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
01334     01 00 00 FF 
01338     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
0133c     18 2C 63 FD |                 getqx   _var_64_lower_
01340     19 2E 63 FD |                 getqy   _var_64_upper_
01344     28 2C 63 FD |                 setq    _var_64_lower_
01348     A1 07 00 FF 
0134c     40 2E 27 FD |                 qfrac   _var_64_upper_, ##_1m
01350     18 36 63 FD |                 getqx   _1us_                           ' 1us as 32,9 fixed point
01354     9B 7B 03 F6 |                 mov     hsave0, _1us_                   ' Save it to compute other us values
01358     09 36 57 F0 |                 shr     _1us_, #9               wc
0135c     00 36 27 F1 |                 addx    _1us_, #0                       ' Round to final value
01360     0A 7A 07 FD |                 qmul    hsave0, #10                     ' Calc 10us
01364     18 38 63 FD |                 getqx   _10us_
01368     09 38 57 F0 |                 shr     _10us_, #9              wc
0136c     00 38 27 F1 |                 addx    _10us_, #0                      ' 10us
01370     21 7A 07 FD |                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
01374     18 3A 63 FD |                 getqx   _33us_
01378     09 3A 57 F0 |                 shr     _33us_, #9              wc
0137c     00 3A 27 F1 |                 addx    _33us_, #0                      ' 33us
01380     FA 7A 07 FD |                 qmul    hsave0, #250                    ' Calc 250us
01384     18 3C 63 FD |                 getqx   _txn_err_
01388     09 3C 57 F0 |                 shr     _txn_err_, #9           wc
0138c     00 3C 27 F1 |                 addx    _txn_err_, #0                   ' 250us
01390     F4 7B 07 FD |                 qmul    hsave0, #500                    ' Calc 500us
01394     18 3E 63 FD |                 getqx   _500us_
01398     09 3E 57 F0 |                 shr     _500us_, #9             wc
0139c     00 3E 27 F1 |                 addx    _500us_, #0                     ' 500us
013a0     01 00 00 FF 
013a4     9A 7A 07 FD |                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
013a8     18 40 63 FD |                 getqx   _txn_ok_ls_
013ac     09 40 57 F0 |                 shr     _txn_ok_ls_, #9         wc
013b0     00 40 27 F1 |                 addx    _txn_ok_ls_, #0                 ' 666us
013b4     01 00 00 FF 
013b8     52 7B 07 FD |                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
013bc     18 42 63 FD |                 getqx   _txn_ok_fs_
013c0     09 42 57 F0 |                 shr     _txn_ok_fs_, #9         wc
013c4     00 42 27 F1 |                 addx    _txn_ok_fs_, #0                 ' 850us
013c8     9A 45 03 F6 |                 mov     _ip_delay_ls_, _1ns16fp_
013cc     05 00 00 FF 
013d0     80 44 07 FA |                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
013d4     10 44 57 F0 |                 shr     _ip_delay_ls_, #16      wc
013d8     00 44 27 F1 |                 addx    _ip_delay_ls_, #0
013dc     9A 49 03 F6 |                 mov     _tat_wait_ls_, _1ns16fp_
013e0     1C 00 00 FF 
013e4     C0 49 07 FA |                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
013e8     10 48 57 F0 |                 shr     _tat_wait_ls_, #16      wc
013ec     00 48 27 F1 |                 addx    _tat_wait_ls_, #0
013f0     9A 47 03 F6 |                 mov     _ip_delay_fs_, _1ns16fp_
013f4     00 00 00 FF 
013f8     4E 47 07 FA |                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
013fc     10 46 57 F0 |                 shr     _ip_delay_fs_, #16      wc
01400     00 46 27 F1 |                 addx    _ip_delay_fs_, #0
01404     9A 4B 03 F6 |                 mov     _tat_wait_fs_, _1ns16fp_
01408     04 00 00 FF 
0140c     23 4B 07 FA |                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
01410     10 4A 57 F0 |                 shr     _tat_wait_fs_, #16      wc
01414     00 4A 27 F1 |                 addx    _tat_wait_fs_, #0
01418     8D 5B 00 FF 
0141c     00 59 16 FD |                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
01420     18 4C 63 FD |                 getqx   _preamble_wait_
01424     08 4C 87 F1 |                 sub     _preamble_wait_,# 9 - 1
01428     01 00 00 FF 
0142c     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
01430     18 2C 63 FD |                 getqx   _var_64_lower_
01434     19 2E 63 FD |                 getqy   _var_64_upper_
01438     28 2C 63 FD |                 setq    _var_64_lower_
0143c     01 00 00 FF 
01440     E8 2F 27 FD |                 qfrac   _var_64_upper_, ##_1thou
01444     18 4E 63 FD |                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
01448     09 4E 57 F0 |                 shr     _1ms_, #9               wc
0144c     00 4E 27 F1 |                 addx    _1ms_, #0                       ' 1ms
01450     FF FF 7F FF 
01454     F2 67 07 F6 |                 mov     _frame1ms_clks_, ##-14
01458     A7 67 43 F1 |                 adds    _frame1ms_clks_, _1ms_
0145c     A7 51 03 F6 |                 mov     _2ms_, _1ms_
01460     01 50 67 F0 |                 shl     _2ms_, #1                       ' 2ms
01464     A7 53 03 F6 |                 mov     _suspend_wait_, _1ms_
01468     A7 53 03 F1 |                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
0146c     A7 55 03 F6 |                 mov     _4ms_, _1ms_
01470     02 54 67 F0 |                 shl     _4ms_, #2                       ' 4ms
01474     AA 57 03 F6 |                 mov     _xfer_wait_, _4ms_
01478     A7 57 03 F1 |                 add     _xfer_wait_, _1ms_              ' 5ms
0147c     AB 5B 03 F6 |                 mov     _reset_hold_, _xfer_wait_       ' 5ms
01480     AD 5D 03 F6 |                 mov     _resume_hold_, _reset_hold_
01484     02 5C 67 F0 |                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
01488     AE 61 03 F6 |                 mov     _100ms_, _resume_hold_          ' 20ms
0148c     01 60 67 F0 |                 shl     _100ms_, #1                     ' 40ms
01490     A7 59 03 F6 |                 mov     _8ms_, _1ms_
01494     03 58 67 F0 |                 shl     _8ms_, #3                       ' 8ms
01498     01 5A 67 F0 |                 shl     _reset_hold_, #1                ' 10ms
0149c     AD 61 03 F1 |                 add     _100ms_, _reset_hold_           ' 50ms
014a0     AB 5B 03 F1 |                 add     _reset_hold_, _xfer_wait_       ' 15ms
014a4     AB 5F 03 F6 |                 mov     _21ms_, _xfer_wait_             ' 5ms
014a8     02 5E 67 F0 |                 shl     _21ms_, #2                      ' 20ms
014ac     A7 5F 03 F1 |                 add     _21ms_, _1ms_                   ' 21ms
014b0     B0 63 03 F6 |                 mov     _500ms_, _100ms_                ' 50ms
014b4     01 60 67 F0 |                 shl     _100ms_, #1                     ' 100ms
014b8     03 62 67 F0 |                 shl     _500ms_, #3                     ' 400ms
014bc     B0 63 03 01 |         _ret_   add     _500ms_, _100ms_                ' 500ms
014c0                 | '        _ret_   mov     _1sec_, save_sysclk
014c0                 | '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
014c0                 | '                ret
014c0                 | {
014c0                 | }
014c0                 | 
014c0                 | '------------------------------------------------------------------------------
014c0                 | ' Parse a configuration descriptor chain to see if the device is a recognized
014c0                 | ' one. If it is, start the task progression that will configure the device for
014c0                 | ' use.
014c0                 | '------------------------------------------------------------------------------
014c0                 | ' On entry:
014c0                 | '   hconfig_base - start address of the cached config descriptor chain.
014c0                 | ' On exit:
014c0                 | '------------------------------------------------------------------------------
014c0                 | hparse_con_desc
014c0     28 F3 03 F6 |                 mov     ptrb, dev_desc_buff_p
014c4     82 71 07 FB |                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
014c8     61 5B 86 F9 |                 altr    hdev_port,#hdev_id
014cc     4E 70 FF F9 |                 movbyts htmp,#%%1032
014d0     86 D3 E6 FA |                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
014d4                 |                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
014d4                 | 
014d4     02 EC 07 F6 |                 mov     pa, #CON_wTotalLen
014d8     6E ED 03 F1 |                 add     pa, hconfig_base
014dc     F6 DF E2 FA |                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
014e0                 |                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
014e0                 | ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
014e0                 | ' that defines a keyboard and/or mouse.
014e0     6E EB C2 FA |                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
014e4                 | .next_intf
014e4     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
014e8     BC 01 90 3D |         if_ae   jmp     #hset_config
014ec     6E F3 03 F6 |                 mov     ptrb, hconfig_base
014f0     75 F3 03 F1 |                 add     ptrb, hnext_desc
014f4     81 71 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
014f8     04 70 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
014fc     0C 00 90 AD |         if_z    jmp     #.intf
01500     80 71 C7 FA |                 rdbyte  htmp, ptrb
01504     B8 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
01508     D8 FF 9F FD |                 jmp     #.next_intf
0150c                 | .intf
0150c     00 8E 07 F6 |                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
01510     00 90 07 F6 |                 mov     hpar3, #0
01514     82 E1 C6 FA |                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
01518     85 E3 C6 FA |                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
0151c     86 E5 C6 FA |                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
01520     87 E7 C6 FA |                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
01524                 |                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
01524                 | 
01524                 | .endp
01524     80 71 C7 FA |                 rdbyte  htmp, ptrb
01528     B8 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
0152c     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
01530     78 00 90 3D |         if_ae   jmp     #.get_device
01534     6E F3 03 F6 |                 mov     ptrb, hconfig_base
01538     75 F3 03 F1 |                 add     ptrb, hnext_desc
0153c     81 71 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
01540     04 70 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
01544     64 00 90 AD |         if_z    jmp     #.get_device
01548     05 70 0F F2 |                 cmp     htmp, #TYPE_ENDPOINT    wz
0154c     04 00 90 AD |         if_z    jmp     #.get_ep
01550     D0 FF 9F FD |                 jmp     #.endp
01554                 | .get_ep
01554     82 87 C7 FA |                 rdbyte  hr1, ptrb[ENDP_bAddress]
01558     07 86 17 F4 |                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
0155c     0F 86 67 F0 |                 shl     hr1, #8 + 7
01560     6C 71 03 F6 |                 mov     htmp, hctrl_ep_addr
01564     3F 00 00 FF 
01568     00 71 07 F5 |                 and     htmp, ##ADDR_MASK
0156c     C3 71 43 F5 |                 or      htmp, hr1                       ' endpoint address
01570     00 8E 0F F2 |                 cmp     hpar2, #0               wz
01574     0C 00 90 8D |  if_z_and_c     jmp     #.in_ep
01578     00 90 0F F2 |                 cmp     hpar3, #0               wz
0157c     18 00 90 2D |  if_z_and_nc    jmp     #.out_ep
01580     A0 FF 9F FD |                 jmp     #.endp
01584                 | .in_ep
01584     B8 8F 03 F6 |                 mov     hpar2, htmp                     ' IN endpoint
01588     84 89 C7 FA |                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
0158c                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
0158c     86 85 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
01590     C2 89 DB F8 |                 setbyte hr2, hr0, #3
01594     8C FF 9F FD |                 jmp     #.endp
01598                 | .out_ep
01598     B8 91 03 F6 |                 mov     hpar3, htmp                     ' OUT endpoint
0159c     84 8B C7 FA |                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
015a0                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
015a0     86 85 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
015a4     C2 8B DB F8 |                 setbyte hr3, hr0, #3
015a8     78 FF 9F FD |                 jmp     #.endp
015ac                 | 
015ac                 | .get_device
015ac     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
015b0     5D E4 0E A2 |         if_z    cmp     hdev_subclass, #$5D     wz
015b4     01 E6 0E A2 |         if_z    cmp     hdev_protocol, #$01     wz
015b8     68 00 90 AD |         if_z    jmp     #.gamepad
015bc     09 E2 0E F2 |                 cmp     hdev_class, #CLASS_HUB  wz
015c0     AC 00 90 AD |         if_z    jmp     #.hub
015c4     03 E2 0E F2 |                 cmp     hdev_class, #CLASS_HID              wz
015c8     18 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No HID class, ignore
015cc     00 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
015d0     00 E6 0E A2 |         if_z    cmp     hdev_protocol, #INTF_PROTO_NONE     wz
015d4     4C 00 90 AD |         if_z    jmp     #.gamepad
015d8     01 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
015dc     04 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
015e0                 | .keyboard
015e0     01 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
015e4                 |         if HAVE_MOUSE
015e4     1C 00 90 5D |         if_nz  jmp      #.mouse                         ' No Keyboard
015e8                 |         else
015e8                 |         end
015e8     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0    wz
015ec     F4 FE 9F 5D |         if_nz   jmp     #.next_intf
015f0     70 6F E2 F8 |                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
015f4     C4 71 FA F8 |                 getbyte kb_interval, hr2, #3
015f8     C4 73 E2 F8 |                 getbyte kb_in_max_pkt, hr2, #0
015fc     C7 F3 02 F6 |                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
01600                 |                 'debug(udec(kb_intf_num))
01600                 |                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
01600     E0 FE 9F FD |                 jmp     #.next_intf
01604                 | if HAVE_MOUSE
01604                 | .mouse
01604     02 E6 0E F2 |                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
01608     D8 FE 9F 5D |         if_nz   jmp     #.next_intf                     ' No Mouse
0160c     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0      wz
01610     D0 FE 9F 5D |         if_nz   jmp     #.next_intf
01614     70 6B E2 F8 |                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
01618                 |                 'getbyte ms_interval, hr2, #3
01618     C4 6D E2 F8 |                 getbyte ms_in_max_pkt, hr2, #0
0161c     C7 F5 02 F6 |                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
01620                 |                 'debug(udec(kb_intf_num))
01620                 |                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
01620     C0 FE 9F FD |                 jmp     #.next_intf
01624                 | end
01624                 | .gamepad
01624     79 71 03 F6 |                 mov     htmp, hkbd_ep_addr
01628     C7 71 63 F5 |                 xor     htmp, hpar2
0162c     3F 00 00 FF 
01630     00 71 0F F5 |                 and     htmp, ##ADDR_MASK       wz
01634     AC FE 9F AD |         if_z    jmp     #.next_intf
01638                 |         if HAVE_MOUSE
01638     7A 71 03 F6 |                 mov     htmp, hmouse_ep_addr
0163c     C7 71 63 F5 |                 xor     htmp, hpar2
01640     3F 00 00 FF 
01644     00 71 0F F5 |                 and     htmp, ##ADDR_MASK       wz
01648     98 FE 9F AD |         if_z    jmp     #.next_intf
0164c                 |         end
0164c     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
01650     00 00 0C F2 |                 cmp     0-0, #0                 wz      ' |
01654     8C FE 9F 5D |         if_nz   jmp     #.next_intf
01658                 | 
01658     70 79 E2 F8 |                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
0165c     C4 7B FA F8 |                 getbyte gp_interval, hr2, #3
01660     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
01664     C7 01 00 F6 |                 mov     0-0, hpar2                      ' IN endpoint address
01668     C8 0B 03 F6 |                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
0166c                 |                 'debug(udec(gp_intf_num))
0166c                 |                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
0166c     74 FE 9F FD |                 jmp     #.next_intf
01670                 | .hub
01670     00 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
01674     6C FE 9F 5D |         if_nz   jmp     #.next_intf
01678     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
0167c     02 E6 0E 52 |         if_nz   cmp     hdev_protocol, #2                   wz
01680     60 FE 9F 5D |         if_nz   jmp     #.next_intf
01684     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
01688     58 FE 9F 5D |         if_nz   jmp     #.next_intf
0168c     70 63 E2 F8 |                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
01690     6C ED 02 F6 |                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
01694     C7 BD 02 F6 |                 mov     ep_addr_pid, hpar2              ' IN endpoint address
01698     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
0169c     5E EF 02 F6 |                 mov     hhub_ep_addr, ep_addr_pid
016a0     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
016a4                 |                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
016a4     3C FE 9F FD |                 jmp     #.next_intf
016a8                 | 
016a8                 | '------------------------------------------------------------------------------
016a8                 | ' If a newly-connected device is recognized, do whatever is needed to configure
016a8                 | ' it according to its function, or functions. In the case of this boot protocol
016a8                 | ' keyboard/mouse class driver:
016a8                 | ' - SetConfiguration(config_num)
016a8                 | ' - SetProtocol(boot)
016a8                 | ' - SetIdle(indefinite)
016a8                 | ' - Enter the device interrupt IN polling task stage.
016a8                 | '------------------------------------------------------------------------------
016a8                 | ' On entry:
016a8                 | ' On exit:
016a8                 | '------------------------------------------------------------------------------
016a8                 | hset_config
016a8                 | '                mov     hkbd_ep_addr, #0                ' DEBUG
016a8                 | '                mov     hmouse_ep_addr, #0              ' DEBUG
016a8     02 74 07 F6 |                 mov     htmp2, #DEV_UNKNOWN
016ac     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
016b0     00 00 0C F2 |                 cmp     0-0, #0                 wz
016b4     00 F2 0E A2 |         if_z    cmp     hkbd_ep_addr, #0        wz
016b8                 |         if HAVE_MOUSE
016b8     00 F4 0E A2 |         if_z    cmp     hmouse_ep_addr, #0      wz
016bc                 |         end
016bc     00 EE 0E A2 |         if_z    cmp     hhub_ep_addr, #0        wz
016c0     4C 03 90 AD |         if_z    jmp     #.notify_client                 ' No known device
016c4                 | .set_config
016c4     6C 0E D0 FE |                 loc     ptra, #set_config
016c8     05 EC 07 F6 |                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
016cc     6E ED 03 F1 |                 add     pa, hconfig_base
016d0     F6 8D C3 FA |                 rdbyte  hpar1, pa
016d4     01 8D 57 FC |                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
016d8     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
016dc     00 EE 07 F6 |                 mov     pb, #0                          ' SetConfiguration() has no data stage
016e0     A0 02 A0 FD |                 call    #control_write
016e4     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
016e8     2D 00 64 5D |         if_nz   ret
016ec                 | .kbd_config
016ec     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0        wz
016f0     98 00 90 AD |         if_z    jmp     #.mouse_config                  ' No keyboard
016f4                 | 
016f4     79 71 03 F6 |                 mov     htmp, hkbd_ep_addr
016f8     5E 71 63 F5 |                 xor     htmp, ep_addr_pid
016fc     3F 00 00 FF 
01700     00 71 0F F5 |                 and     htmp, ##ADDR_MASK       wz
01704     84 00 90 5D |         if_nz   jmp     #.mouse_config                  ' No keyboard
01708                 | 
01708     37 71 E3 F8 |                 getbyte htmp, kb_intf_num, #0
0170c     34 0E D0 FE |                 loc     ptra, #set_protocol
01710     01 01 5C FC |                 wrword  #BOOT_PROTOCOL, ptra[wValue]
01714     02 71 57 FC |                 wrword  htmp, ptra[wIndex]
01718     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
0171c     A0 02 A0 FD |                 call    #control_write
01720     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01724     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
01728     E4 02 90 5D |         if_nz   jmp     #.notify_client
0172c     00 8C 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
01730     37 8F E3 F8 |                 getbyte hpar2, kb_intf_num, #0
01734     30 03 B0 FD |                 call    #hset_idle
01738                 |                 'cmp     retval, #PID_ACK        wz
01738                 |         'if_nz   mov     hkbd_ep_addr, #0
01738                 |         'if_nz   jmp     #.notify_client
01738     A8 99 02 F6 |                 mov     hctwait, _2ms_
0173c     EF 02 A0 FD |                 call    #poll_waitx
01740     00 76 06 F6 |                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
01744     3B F9 02 F6 |                 mov     hkbd_ledstates, kb_led_states
01748     90 17 90 FE |                 loc     pa, #hkbd_led_rep
0174c     F6 F9 42 FC |                 wrbyte  hkbd_ledstates,pa
01750     2C 03 B0 FD |                 call    #hset_kbdled_report
01754     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01758     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
0175c     B0 02 90 5D |         if_nz   jmp     #.notify_client
01760     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
01764     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
01768     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
0176c     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
01770     5E F3 02 F6 |                 mov     hkbd_ep_addr, ep_addr_pid
01774     6C F1 02 F6 |                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
01778     1F F0 46 F4 |                 bitc    hkbd_ctrl_ep, #31
0177c     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
01780     00 F6 06 F6 |                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
01784     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
01788     03 74 07 F6 |                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
0178c                 |         if !!HAVE_MOUSE
0178c                 |         end
0178c                 | 
0178c                 | .mouse_config
0178c                 | if HAVE_MOUSE
0178c     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0        wz
01790     AC 00 90 AD |         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
01794     7A 71 03 F6 |                 mov     htmp, hmouse_ep_addr
01798     5E 71 63 F5 |                 xor     htmp, ep_addr_pid
0179c     3F 00 00 FF 
017a0     00 71 0F F5 |                 and     htmp, ##ADDR_MASK       wz
017a4     98 00 90 5D |         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
017a8                 | 
017a8                 |                 debug("mouse passed addr check")
017a8                 | 
017a8     B0 0D D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
017ac     00 00 80 FF 
017b0     03 01 5E FC |                 wrword  ##HID_DESCR_LEN, ptra[wLength]
017b4     02 6B 56 FC |                 wrword  ms_intf_num,ptra[wIndex]
017b8     1B 01 A0 FD |                 call    #get_hid_descr_buffer
017bc     55 02 A0 FD |                 call    #control_read
017c0     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
017c4     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
017c8     44 02 90 5D |         if_nz   jmp     #.notify_client
017cc     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
017d0     56 01 00 F6 |                 mov     0-0, total_data
017d4     1B 01 A0 FD |                 call    #get_hid_descr_buffer
017d8                 |                 debug(uhex(pb),uhex_byte_array(pb,total_data))
017d8                 | 
017d8     35 71 E3 F8 |                 getbyte htmp, ms_intf_num, #0
017dc     64 0D D0 FE |                 loc     ptra, #set_protocol
017e0     01 01 5C FC |                 wrword  #BOOT_PROTOCOL, ptra[wValue]
017e4     02 71 57 FC |                 wrword  htmp, ptra[wIndex]
017e8     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
017ec     A0 02 A0 FD |                 call    #control_write
017f0     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
017f4     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
017f8     14 02 90 5D |         if_nz   jmp     #.notify_client
017fc                 |                 debug("mouse passed SetProtocol")
017fc     00 8C 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
01800     35 8F E3 F8 |                 getbyte hpar2, ms_intf_num, #0
01804     60 02 B0 FD |                 call    #hset_idle
01808                 |                 'cmp     retval, #PID_ACK        wz
01808                 |         'if_nz   mov     hmouse_ep_addr, #0
01808                 |         'if_nz   jmp     #.notify_client
01808                 |                 debug("mouse passed SetIdle")
01808     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
0180c     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
01810     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
01814     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
01818     5E F5 02 F6 |                 mov     hmouse_ep_addr, ep_addr_pid
0181c     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
01820     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
01824     79 75 03 F6 |                 mov     htmp2, hkbd_ep_addr
01828     7A 75 63 F5 |                 xor     htmp2, hmouse_ep_addr
0182c     3F 00 00 FF 
01830     00 75 0F F5 |                 and     htmp2, ##ADDR_MASK              wz
01834     05 74 07 A6 |         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
01838     04 74 07 56 |         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
0183c     D0 01 90 FD |                 jmp     #.notify_client
01840                 | end
01840                 | .gamepad_config
01840                 | if _HAVE_GAMEPAD
01840     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
01844     00 00 0C F2 |                 cmp     0-0, #0                 wz
01848     58 01 90 AD |         if_z    jmp     #.hub_config                    ' No gamepad
0184c     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
01850     00 70 03 F6 |                 mov     htmp, 0-0
01854     5E 71 63 F5 |                 xor     htmp, ep_addr_pid
01858     3F 00 00 FF 
0185c     00 71 0F F5 |                 and     htmp, ##ADDR_MASK       wz
01860     40 01 90 5D |         if_nz   jmp     #.hub_config                    ' No gamepad
01864                 | 
01864     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
01868     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
0186c     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
01870     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
01874     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
01878     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
0187c     5E 01 00 F6 |                 mov     0-0, ep_addr_pid
01880     85 BD 0A F6 |                 mov     ep_addr_pid, hdev_out_addr  wz
01884     E1 BC C6 58 |         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
01888     BE 00 A0 5D |         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
0188c     09 68 16 54 |         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
01890     1F BC 46 54 |         if_nz   bitc    ep_addr_pid, #31
01894     5E 0B 03 56 |         if_nz   mov     hdev_out_addr, ep_addr_pid
01898     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
0189c                 | 
0189c                 |                 if EMUPAD_MAX_PLAYER > 0
0189c                 |                 
0189c                 | .rule_loop           
0189c                 |                 end
0189c                 | 
0189c     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
018a0     5C 00 90 AD |         if_e    jmp     #.xinput
018a4     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
018a8     00 70 03 F6 |                 mov     htmp,0-0
018ac     01 A6 02 FF 
018b0     68 70 0F F2 |                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
018b4     7C 00 90 AD |         if_e    jmp     #.ps3
018b8                 | 
018b8     A0 0C D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
018bc     00 5A 0E F2 |                 cmp     hdev_port,#0            wz
018c0     00 00 80 5F 
018c4     03 01 5E 5C |         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
018c8     03 00 80 AF 
018cc     03 01 5E AC |         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
018d0     02 01 5C FC |                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
018d4     1B 01 A0 FD |                 call    #get_hid_descr_buffer
018d8     55 02 A0 FD |                 call    #control_read
018dc     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
018e0     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
018e4     00 00 04 56 |         if_nz   mov     0-0, #0
018e8     24 01 90 5D |         if_nz   jmp     #.notify_client
018ec     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
018f0     56 01 00 F6 |                 mov     0-0, total_data
018f4     1B 01 A0 FD |                 call    #get_hid_descr_buffer
018f8                 |                 debug(uhex(pb),uhex_byte_array(pb,total_data))
018f8                 | 
018f8     06 74 07 F6 |                 mov     htmp2, #HID_READY               ' Standard gamepad
018fc     10 01 90 FD |                 jmp     #.notify_client
01900                 | .xinput
01900     B4 0C D0 FE |                 loc     ptra, #xinp_led_cmd             ' Turn on LED
01904     2D EF 03 F6 |                 mov     pb,hdev_port
01908     01 EE E7 F2 |                 cmpsub  pb,#1 ' root device is also player 1
0190c     03 EE 27 F3 |                 fle     pb,#3
01910     06 EE 07 F1 |                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
01914     02 EF 47 FC |                 wrbyte  pb, ptra[2]
01918                 | 
01918     03 B0 06 F6 |                 mov     pkt_data, #3
0191c     03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB
01920     85 BD 02 F6 |                 mov     ep_addr_pid, hdev_out_addr
01924     5A 00 A0 FD |                 call    #txn_out
01928     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr
0192c                 | 
0192c     07 74 07 F6 |                 mov     htmp2, #XINPUT_READY
01930     DC 00 90 FD |                 jmp     #.notify_client
01934                 | .ps3
01934     50 0C D0 FE |                 loc     ptra, #ps3_command_buff         ' Turn on LED
01938     2D EF 03 F6 |                 mov     pb,hdev_port
0193c     01 EE 07 F3 |                 fge     pb,#1 ' root device is also player 1
01940     04 EE 27 F3 |                 fle     pb,#4
01944     F7 EF C3 F9 |                 decod   pb
01948     09 EF 47 FC |                 wrbyte  pb, ptra[9]
0194c                 | 
0194c     3C 71 E3 F8 |                 getbyte htmp, gp_intf_num, #0
01950     00 0C D0 FE |                 loc     ptra, #set_report
01954     01 00 80 FF 
01958     01 03 5C FC |                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
0195c     02 71 57 FC |                 wrword  htmp, ptra[wIndex]
01960     03 61 5C FC |                 wrword  #48, ptra[wLength]
01964     20 0C B0 FE |                 loc     pb, #ps3_command_buff
01968     A0 02 A0 FD |                 call    #control_write
0196c                 | 
0196c     3C 71 E3 F8 |                 getbyte htmp, gp_intf_num, #0
01970     E0 0B D0 FE |                 loc     ptra, #set_report
01974     01 00 80 FF 
01978     01 E9 5F FC |                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
0197c     02 71 57 FC |                 wrword  htmp, ptra[wIndex]
01980     03 09 5C FC |                 wrword  #4, ptra[wLength]
01984     FC 0B B0 FE |                 loc     pb, #ps3_enable_cmd             ' Enable PS3
01988     A0 02 A0 FD |                 call    #control_write
0198c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK    wz
01990     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
01994     00 00 04 56 |         if_nz   mov     0-0, #0
01998     74 00 90 5D |         if_nz   jmp     #.notify_client
0199c                 | 
0199c     08 74 07 F6 |                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
019a0     6C 00 90 FD |                 jmp     #.notify_client
019a4                 | end
019a4                 | 
019a4                 | .hub_config
019a4     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
019a8     64 00 90 AD |         if_z    jmp     #.notify_client                 ' No HUB
019ac     77 71 03 F6 |                 mov     htmp, hhub_ep_addr
019b0     5E 71 63 F5 |                 xor     htmp, ep_addr_pid
019b4     3F 00 00 FF 
019b8     00 71 0F F5 |                 and     htmp, ##ADDR_MASK       wz
019bc     50 00 90 5D |         if_nz   jmp     #.notify_client                 ' No HUB
019c0                 | 
019c0     A0 0B D0 FE |                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
019c4     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]
019c8     26 EF 03 F6 |                 mov     pb, hub_descr_p
019cc     55 02 A0 FD |                 call    #control_read
019d0     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
019d4     00 EE 06 56 |         if_nz   mov     hhub_ep_addr, #0
019d8     34 00 90 5D |         if_nz   jmp     #.notify_client
019dc                 |                 debug(uhex_byte_array(hub_descr_p,total_data))
019dc                 | 
019dc     26 F1 03 F6 |                 mov     ptra, hub_descr_p
019e0     02 77 C7 FA |                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
019e4     07 76 27 F3 |                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
019e8                 |                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
019e8                 | .pwr_loop
019e8     80 0B D0 FE |                 loc     ptra, #set_port_feat            ' Power on ports
019ec     01 11 5C FC |                 wrword  #HUB_PORT_POWER, ptra[wValue]
019f0     02 77 57 FC |                 wrword  htmp3, ptra[wIndex]
019f4     A0 02 A0 FD |                 call    #control_write
019f8     FB 77 6F FB |                 djnz    htmp3, #.pwr_loop
019fc                 | 
019fc     B1 99 02 F6 |                 mov     hctwait, _500ms_
01a00     B0 99 02 F1 |                 add     hctwait, _100ms_
01a04     EF 02 A0 FD |                 call    #poll_waitx
01a08                 | 
01a08     09 74 07 F6 |                 mov     htmp2, #HUB_READY               ' Hub ready
01a0c     00 00 90 FD |                 jmp     #.notify_client
01a10                 | 
01a10                 | .notify_client
01a10     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
01a14     BA 01 C0 F8 |                 setbyte htmp2                           ' Save device ready
01a18                 |                 debug(uhex_long(hdev_type,hdev_type+1))
01a18                 |         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
01a18     2D 00 64 FD |                 ret
01a1c                 | 
01a1c                 | '------------------------------------------------------------------------------
01a1c                 | ' Initialize the keyboard/mouse data area to start-up values.
01a1c                 | '------------------------------------------------------------------------------
01a1c                 | ' On entry:
01a1c                 | ' On exit:
01a1c                 | '------------------------------------------------------------------------------
01a1c                 | init_kbdm_data
01a1c     00 F2 06 F6 |                 mov     hkbd_ep_addr, #0
01a20     00 FA 06 F6 |                 mov     hdev_ep_addr, #0
01a24                 | 
01a24     2A F1 03 F6 |                 mov     ptra, cache_start_p         ' Clear cached data buffers
01a28     2B ED 03 F6 |                 mov     pa, cache_end_p
01a2c                 | .loop
01a2c     61 01 4C FC |                 wrbyte  #0, ptra++
01a30     F6 F1 1B F2 |                 cmp     ptra, pa                wcz
01a34     F4 FF 9F CD |         if_b    jmp     #.loop
01a38                 |         
01a38                 |         if EMUPAD_MAX_PLAYER > 0
01a38                 |         end
01a38                 | 
01a38                 | 
01a38     2D ED 07 F6 |                 mov     pa, #hdev_init_start        ' Clear device data registers
01a3c                 | .regloop
01a3c     00 EC 8F F9 |                 altd    pa
01a40     00 00 04 F6 |                 mov     0-0, #0
01a44     01 EC 07 F1 |                 add     pa, #1
01a48     47 ED 0F F2 |                 cmp     pa, #hdev_init_end      wz
01a4c     EC FF 9F 5D |         if_nz   jmp     #.regloop
01a50                 | 
01a50     E1 E1 61 FF 
01a54     C3 5D 06 F6 |                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
01a58     2E 5F 02 F6 |                 mov     hdev_next_datax + 1,hdev_next_datax
01a5c     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0
01a60     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1
01a64                 | 
01a64     C3 64 06 06 |         _ret_   mov     hub_next_datax, #PID_DATA0
01a68                 | 
01a68                 | '------------------------------------------------------------------------------
01a68                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
01a68                 | ' function.
01a68                 | '------------------------------------------------------------------------------
01a68                 | ' On entry:
01a68                 | '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
01a68                 | '   hpar2 - index number of the target interface.
01a68                 | ' On exit:
01a68                 | '------------------------------------------------------------------------------
01a68                 | hset_idle
01a68     A8 99 02 F6 |                 mov     hctwait, _2ms_
01a6c     EF 02 A0 FD |                 call    #poll_waitx
01a70     D8 0A D0 FE |                 loc     ptra, #set_idle
01a74     01 8D 57 FC |                 wrword  hpar1, ptra[wValue]
01a78     02 8F 57 FC |                 wrword  hpar2, ptra[wIndex]
01a7c     A0 02 80 FD |                 jmp     #control_write
01a80                 | 
01a80                 | '------------------------------------------------------------------------------
01a80                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
01a80                 | ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
01a80                 | '------------------------------------------------------------------------------
01a80                 | ' On entry:
01a80                 | '   ep_addr_pid - device address and enpoint for the request.
01a80                 | ' On exit:
01a80                 | '   retval - transaction result.
01a80                 | '------------------------------------------------------------------------------
01a80                 | hset_kbdled_report
01a80     37 71 E3 F8 |                 getbyte htmp, kb_intf_num, #0
01a84     CC 0A D0 FE |                 loc     ptra, #set_report
01a88     01 00 80 FF 
01a8c     01 01 5C FC |                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
01a90     02 71 57 FC |                 wrword  htmp, ptra[wIndex]
01a94     03 03 5C FC |                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
01a98     27 EF 03 F6 |                 mov     pb, urx_buff_p
01a9c     F7 77 42 FC |                 wrbyte  kb_led_states, pb
01aa0     A0 02 80 FD |                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
01aa4                 | 
01aa4                 | '------------------------------------------------------------------------------
01aa4                 | ' Execute an IN interrupt transaction to poll for keyboard activity.
01aa4                 | '------------------------------------------------------------------------------
01aa4                 | ' On entry:
01aa4                 | ' On exit:
01aa4                 | '------------------------------------------------------------------------------
01aa4                 | hget_kbd_in_report
01aa4     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
01aa8     27 8F 03 F6 |                 mov     hpar2, urx_buff_p
01aac     30 91 E3 F8 |                 getbyte hpar3, kbm_next_datax, #0
01ab0     39 91 2B F9 |                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
01ab4     CF 02 A0 FD |                 call    #do_int_in
01ab8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01abc     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
01ac0                 | 
01ac0     00 90 0F F2 |                 cmp     hpar3, #0               wz
01ac4     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
01ac8                 | 
01ac8     30 71 E3 F8 |                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
01acc     C3 70 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
01ad0     4B 60 C6 A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
01ad4     C3 60 C6 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
01ad8                 | 
01ad8     C8 75 02 F6 |                 mov     kb_max_index, hpar3             ' Save actual bytes read
01adc     18 00 B0 FD |                 call    #hkbd_compare
01ae0                 |         if EMUPAD_MAX_PLAYER > 0
01ae0                 |         end
01ae0                 | 
01ae0                 | .led_check
01ae0     3B 71 03 F6 |                 mov     htmp, kb_led_states
01ae4     B8 F9 0A F2 |                 cmp     hkbd_ledstates, htmp    wz
01ae8     2D 00 64 AD |         if_z    ret                                     ' No toggle key indicator changes, so we're done
01aec     7C 77 02 F6 |                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
01af0     78 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ctrl_ep
01af4     88 FF 9F FD |                 jmp     #hset_kbdled_report             ' Set report and ignore errors
01af8                 | 
01af8                 | '------------------------------------------------------------------------------
01af8                 | ' Compare current and previous keyboard data buffers for keypress changes.
01af8                 | '------------------------------------------------------------------------------
01af8                 | hkbd_compare
01af8     27 F1 03 F6 |                 mov     ptra, urx_buff_p
01afc     D4 13 F0 FE |                 loc     ptrb, #hkbd_report
01b00     61 73 07 FB |                 rdlong  htmp1, ptra++
01b04     E1 75 07 FB |                 rdlong  htmp2, ptrb++
01b08     BA 73 0B F2 |                 cmp     htmp1, htmp2    wz
01b0c     61 73 07 FB |                 rdlong  htmp1, ptra++
01b10     E1 75 07 FB |                 rdlong  htmp2, ptrb++
01b14     BA 73 0B A2 |         if_z    cmp     htmp1, htmp2    wz
01b18     2D 00 64 AD |         if_z    ret
01b1c                 | 
01b1c     B4 13 D0 FE |                 loc     ptra, #hkbd_report
01b20                 | 
01b20                 |                 ' Handle modifiers
01b20     27 8F C3 FA |                 rdbyte  hpar2, urx_buff_p
01b24     00 87 C7 FA |                 rdbyte  hr1, ptra
01b28     C7 87 43 F9 |                 rolword hr1,hpar2,#0
01b2c     63 86 63 FD |                 mergew  hr1
01b30     08 EC 07 F6 |                 mov     pa,#8
01b34                 | .modloop
01b34     6A 86 7B FD |                 rczr    hr1     wcz ' New value in C, old value in Z
01b38     E8 8C 07 F6 |                 mov     hpar1,#$E8
01b3c     F6 8D 83 F1 |                 sub     hpar1,pa
01b40     A0 00 B0 6D |       if_c_ne_z call    #hkbd_translate
01b44     FB ED 6F FB |                 djnz    pa,#.modloop
01b48                 | 
01b48     6F E0 75 FD | .release        modc    _set    wc
01b4c                 |                 'alts    hdev_port, #hid_report_p
01b4c                 |                 'mov     ptra, hid_report_p
01b4c     02 F0 07 F1 |                 add     ptra, #2
01b50     06 EC 07 F6 |                 mov     pa, #6
01b54     61 8D CF FA | .rl1            rdbyte  hpar1, ptra++   wz
01b58     20 00 90 AD |         if_z    jmp     #.rl3
01b5c     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
01b60     02 F2 07 F1 |                 add     ptrb, #2
01b64     06 EE 07 F6 |                 mov     pb, #6
01b68     E1 71 C7 FA | .rl2            rdbyte  htmp, ptrb++
01b6c     B8 8D 0B F2 |                 cmp     hpar1, htmp     wz
01b70     08 00 90 AD |         if_z    jmp     #.rl3
01b74     FC EF 6F FB |                 djnz    pb, #.rl2
01b78     68 00 B0 FD |                 call    #hkbd_translate
01b7c     F5 ED 6F FB | .rl3            djnz    pa, #.rl1
01b80                 | 
01b80     00 90 07 F6 |                 mov     hpar3, #0
01b84     1F 90 27 F4 |                 bith    hpar3, #31
01b88                 | 
01b88     6F 00 74 FD | .press          modc    _clr    wc
01b8c     27 F1 03 F6 |                 mov     ptra, urx_buff_p
01b90     02 F0 07 F1 |                 add     ptra, #2
01b94     06 EC 07 F6 |                 mov     pa, #6
01b98     61 8D CF FA | .pl1            rdbyte  hpar1, ptra++   wz
01b9c     20 00 90 AD |         if_z    jmp     #.pl3
01ba0     30 13 F0 FE |                 loc     ptrb, #hkbd_report
01ba4     02 F2 07 F1 |                 add     ptrb, #2
01ba8     06 EE 07 F6 |                 mov     pb, #6
01bac     E1 71 C7 FA | .pl2            rdbyte  htmp, ptrb++
01bb0     B8 8D 0B F2 |                 cmp     hpar1, htmp     wz
01bb4     08 00 90 AD |         if_z    jmp     #.pl3
01bb8     FC EF 6F FB |                 djnz    pb, #.pl2
01bbc     24 00 B0 FD |                 call    #hkbd_translate
01bc0     F5 ED 6F FB | .pl3            djnz    pa, #.pl1
01bc4                 | 
01bc4     27 F1 03 F6 | .copy           mov     ptra, urx_buff_p
01bc8     08 13 F0 FE |                 loc     ptrb, #hkbd_report
01bcc     28 02 64 FD |                 setq #1
01bd0     61 73 07 FB |                 rdlong  htmp1, ptra++
01bd4     28 02 64 FD |                 setq #1
01bd8     E1 73 67 FC |                 wrlong  htmp1, ptrb++
01bdc     E1 F9 46 FC |                 wrbyte  hkbd_ledstates,ptrb++
01be0                 | 
01be0     2D 00 64 FD |                 ret
01be4                 | 
01be4                 | '------------------------------------------------------------------------------
01be4                 | ' Translate keyboard scancode to ASCII
01be4                 | '------------------------------------------------------------------------------
01be4                 | ' On entry:
01be4                 | '   hpar1 - scancode
01be4                 | '   hpar2 - key modifiers state
01be4                 | '       c - pressed (0) or released (1) flag
01be4                 | ' On exit:
01be4                 | '   hpar1 - bit     31 = 0 pressed, 1 released
01be4                 | '               30..17 = unused
01be4                 | '                   18 = scroll-lock state 
01be4                 | '                   17 = caps-lock state
01be4                 | '                   16 = num-lock state 
01be4                 | '                15..8 = key modifiers state
01be4                 | '                 7..0 = scancode
01be4                 | '------------------------------------------------------------------------------
01be4                 | hkbd_translate
01be4     39 8C 0F F2 |                 cmp     hpar1, #KEY_CAPSLOCK    wz
01be8     01 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
01bec     53 8C 0F F2 |                 cmp     hpar1, #KEY_NUMLOCK     wz
01bf0     00 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
01bf4     47 8C 0F F2 |                 cmp     hpar1, #KEY_SCROLLLOCK  wz
01bf8     02 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
01bfc                 | 
01bfc                 |         if EMUPAD_MAX_PLAYER > 0
01bfc                 | 
01bfc                 |         if EMUPAD_BT0_BIT >= 0
01bfc                 |         end
01bfc                 |         if EMUPAD_BT1_BIT >= 0
01bfc                 |         end
01bfc                 |         if EMUPAD_BT2_BIT >= 0
01bfc                 |         end
01bfc                 |         if EMUPAD_BT3_BIT >= 0
01bfc                 |         end
01bfc                 |         if EMUPAD_BT4_BIT >= 0
01bfc                 |         end
01bfc                 |         if EMUPAD_BT5_BIT >= 0
01bfc                 |         end
01bfc                 |         if EMUPAD_BT6_BIT >= 0
01bfc                 |         end
01bfc                 |         if EMUPAD_BT7_BIT >= 0
01bfc                 |         end
01bfc                 |         if EMUPAD_BT8_BIT >= 0
01bfc                 |         end
01bfc                 |         if EMUPAD_BT9_BIT >= 0
01bfc                 |         end
01bfc                 | 
01bfc                 |         end
01bfc     C7 8D CB F8 |                 setbyte hpar1, hpar2, #1
01c00     7C 8D D3 F8 |                 setbyte hpar1, hkbd_ledstates,#2
01c04     1F 8C 47 F4 |                 bitc    hpar1, #31
01c08                 |         if KEYQUEUE_SIZE > 0
01c08     C4 09 B0 FE |                 loc pb,#keyq_head
01c0c     F7 71 E3 FA |                 rdword htmp,pb
01c10     B8 73 EB F8 |                 getbyte htmp1,htmp,#1 ' tail
01c14     B8 71 E3 F8 |                 getbyte htmp,htmp,#0 ' head
01c18     B8 75 03 F6 |                 mov htmp2,htmp
01c1c     04 74 07 FA |                 mul htmp2,#4
01c20     F7 75 03 F1 |                 add htmp2,pb
01c24     02 74 07 F1 |                 add htmp2,#2
01c28     7F 70 07 F7 |                 incmod htmp,#KEYQUEUE_SIZE - 1
01c2c     B8 73 0B F2 |                 cmp htmp1,htmp wz ' check buffer overflow
01c30     BA 8D 63 5C |         if_nz   wrlong hpar1,htmp2
01c34     F7 71 43 5C |         if_nz   wrbyte htmp,pb
01c38                 |         end
01c38     2D 00 7C FD |                 ret wcz
01c3c                 | 
01c3c                 | if HAVE_MOUSE
01c3c                 | '------------------------------------------------------------------------------
01c3c                 | ' Execute an IN interrupt transaction to poll for mouse activity.
01c3c                 | '------------------------------------------------------------------------------
01c3c                 | ' On entry:
01c3c                 | ' On exit:
01c3c                 | '------------------------------------------------------------------------------
01c3c                 | hget_mouse_in_report
01c3c     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
01c40     27 8F 03 F6 |                 mov     hpar2, urx_buff_p
01c44     30 91 EB F8 |                 getbyte hpar3, kbm_next_datax, #1
01c48     36 91 2B F9 |                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
01c4c     CF 02 A0 FD |                 call    #do_int_in
01c50     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01c54     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
01c58                 | 
01c58     00 90 0F F2 |                 cmp     hpar3, #0               wz
01c5c     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
01c60                 | 
01c60     30 71 EB F8 |                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
01c64     C3 70 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
01c68     4B 60 CE A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
01c6c     C3 60 CE 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
01c70                 | 
01c70     27 F1 03 F6 |                 mov     ptra, urx_buff_p
01c74     05 90 1F F2 |                 cmp     hpar3, #5               wcz     ' Hack: Combo PS/2-USB adapters adds report-id
01c78     01 F0 07 31 |         if_ae   add     ptra, #1                        ' | skip
01c7c     01 90 87 31 |         if_ae   sub     hpar3, #1
01c80                 | 
01c80     40 09 90 FE |                 loc     pa, #mouse_limits
01c84     25 13 F0 FE |                 loc     ptrb, #mouse_xacc
01c88                 | 
01c88                 |                 ' load xacc,yacc,zacc
01c88     28 04 64 FD |                 setq    #3-1
01c8c     80 87 07 FB |                 rdlong  hr1,ptrb
01c90                 |                 ' load limits and outptr
01c90     28 04 64 FD |                 setq    #3-1
01c94     F6 73 03 FB |                 rdlong  htmp1,pa
01c98                 | 
01c98     61 71 C7 FA |                 rdbyte  htmp, ptra++                     ' Button flags
01c9c     8C 71 47 FC |                 wrbyte  htmp, ptrb[12]                    ' write verbatim into extra byte
01ca0     00 70 17 F4 |                 testb   htmp,#0                 wc       ' left button flag
01ca4     8D 03 4C CC |         if_c    wrbyte  #1,ptrb[13]
01ca8     01 70 17 F4 |                 testb   htmp,#1                 wc       ' left button flag
01cac     8E 03 4C CC |         if_c    wrbyte  #1,ptrb[14]
01cb0     02 70 17 F4 |                 testb   htmp,#2                 wc       ' left button flag
01cb4     8F 03 4C CC |         if_c    wrbyte  #1,ptrb[15]
01cb8                 |               
01cb8                 | 
01cb8     61 71 C7 FA |                 rdbyte  htmp, ptra++                     ' X direction and velocity is 8-bit signed
01cbc     07 70 67 F7 |                 signx   htmp, #7
01cc0     B8 87 03 F1 |                 add     hr1,htmp
01cc4     00 72 0F F2 |                 cmp     htmp1,#0 wz
01cc8     B9 87 63 53 |         if_ne   fles    hr1,htmp1
01ccc     00 86 47 53 |         if_ne   fges    hr1,#0
01cd0                 | 
01cd0     61 71 C7 FA |                 rdbyte  htmp, ptra++                     ' Y direction and velocity is 8-bit signed
01cd4     07 70 67 F7 |                 signx   htmp, #7
01cd8     B8 89 03 F1 |                 add     hr2,htmp
01cdc     00 74 0F F2 |                 cmp     htmp2,#0 wz
01ce0     BA 89 63 53 |         if_ne   fles    hr2,htmp2
01ce4     00 88 47 53 |         if_ne   fges    hr2,#0
01ce8                 |                 
01ce8                 | 
01ce8     04 90 0F F2 |                 cmp     hpar3, #4               wz      ' Very few mice send +/- scroll wheel data in boot protocol
01cec     00 71 C7 AA |         if_z    rdbyte  htmp, ptra
01cf0     07 70 67 A7 |         if_z    signx   htmp, #7                        ' If it's there, use it
01cf4     B8 8B 03 A1 |         if_z    add     hr3,htmp
01cf8                 | 
01cf8     90 71 CF FA |                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
01cfc     2D 00 64 5D |         if_nz   ret                                     ' If so, don't write results
01d00                 | 
01d00                 |                 ' write back accumulators
01d00     28 04 64 FD |                 setq    #3-1
01d04     80 87 67 FC |                 wrlong  hr1,ptrb
01d08                 |                 ' if outptr set, write X/Y words
01d08     00 76 0F F2 |                 cmp htmp3,#0                    wz
01d0c     C4 87 2B 59 |         if_nz   setword hr1,hr2,#1
01d10     BB 87 63 5C |         if_nz   wrlong hr1,htmp3
01d14     2D 00 64 FD |                 ret
01d18                 | end
01d18                 | 
01d18                 | '------------------------------------------------------------------------------
01d18                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
01d18                 | '------------------------------------------------------------------------------
01d18                 | ' On entry:
01d18                 | ' On exit:
01d18                 | '------------------------------------------------------------------------------
01d18                 | if _HAVE_GAMEPAD
01d18                 | hget_gp_in_report
01d18     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
01d1c     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
01d20                 | 
01d20     27 8F 03 F6 |                 mov     hpar2, urx_buff_p
01d24     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax
01d28     00 90 E3 F8 |                 getbyte hpar3
01d2c     FF 90 2F F9 |                 setword hpar3, #255, #1                 ' Always ask for max report size
01d30     CF 02 A0 FD |                 call    #do_int_in
01d34     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
01d38     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
01d3c                 | 
01d3c     00 90 0F F2 |                 cmp     hpar3, #0               wz
01d40     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
01d44                 |                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
01d44                 | 
01d44     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
01d48     00 70 E3 F8 |                 getbyte htmp                            ' |
01d4c     C3 70 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
01d50     4B 70 07 A6 |         if_z    mov     htmp, #PID_DATA1                ' |
01d54     C3 70 07 56 |         if_nz   mov     htmp, #PID_DATA0                ' |
01d58     2E 5B 66 F9 |                 altsb   hdev_port, #hdev_next_datax     ' |
01d5c     B8 01 C0 F8 |                 setbyte htmp                            ' |
01d60                 | 
01d60                 | ' Note: the following code compares the current and previous reports
01d60                 | ' and process the data if there are changes to ease the debug output.
01d60                 | ' Actual implementations should remove this block, along with hid_pre_rpt_p and
01d60                 | ' gpPreReport buffer.
01d60                 | 
01d60                 |                 ' ----- start of block to remove
01d60                 |                 {
01d60                 |                 }
01d60                 |                 ' ----- end of block to remove
01d60     F4 04 90 FE |                 loc pa,#hpad_translate
01d64     2A EC 63 FD |                 push pa
01d68                 | 
01d68                 |                 ' FALL THROUGH !!!!
01d68                 | 
01d68                 | '------------------------------------------------------------------------------
01d68                 | ' Decode controller report
01d68                 | '------------------------------------------------------------------------------
01d68                 | hid_decode
01d68                 |                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
01d68     28 1E 64 FD |                 setq #(hidr_end-hidr_start)-1
01d6c     00 04 00 FF 
01d70     00 0C 07 FB |                 rdlong  hidr_start,##$8_0000
01d74                 | 
01d74     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
01d78                 | 
01d78     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
01d7c     00 2A E3 F8 |                 getbyte hidr_type
01d80     07 2A 0F F2 |                 cmp     hidr_type, #XINPUT_READY        wz
01d84     34 02 90 AD |         if_z    jmp     #hpad_xinput
01d88     08 2A 0F F2 |                 cmp     hidr_type, #PS3_READY           wz
01d8c     1C 03 90 AD |         if_z    jmp     #hpad_ps3
01d90     05 2A 0F F2 |                 cmp     hidr_type, #KBM_READY           wz
01d94     04 2A 07 A6 |         if_z    mov     hidr_type,#M_READY
01d98     04 2A 0F F2 |                 cmp     hidr_type, #M_READY             wz
01d9c                 |                 
01d9c                 | 
01d9c                 | '------------------------------------------------------------------------------
01d9c                 | ' Handle HID controller (or mouse now
01d9c                 | ' On entry:
01d9c                 | '   ptrb - controller report
01d9c                 | '------------------------------------------------------------------------------
01d9c                 | hpad_hid
01d9c     1B 01 A0 FD |                 call    #get_hid_descr_buffer
01da0     F7 F1 03 F6 |                 mov     ptra, pb
01da4     3F 5B 96 F9 |                 alts    hdev_port, #gp_descr_len
01da8     00 EC 03 F6 |                 mov     pa, 0-0
01dac                 |                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
01dac     19 2A 3B FF 
01db0     10 0C 07 F6 |                 mov     hidr_usage, ##$76543210
01db4                 | 
01db4                 | .next
01db4     00 EC 5F F2 |                 cmps    pa, #0      wcz
01db8     2D 00 7C ED |         if_be   ret     wcz
01dbc                 | 
01dbc     61 8D C7 FA |                 rdbyte  hpar1, ptra++
01dc0     01 EC 87 F1 |                 sub     pa, #1
01dc4     00 8E 07 F6 |                 mov     hpar2, #0
01dc8                 | 
01dc8     C6 71 03 F6 |                 mov     htmp, hpar1
01dcc     03 70 07 F5 |                 and     htmp, #$03
01dd0     01 70 0F F2 |                 cmp     htmp, #1    wz
01dd4     61 8F C7 AA |         if_z    rdbyte  hpar2, ptra++
01dd8     07 8E 67 A7 |         if_z    signx   hpar2,#7
01ddc     01 EC 87 A1 |         if_z    sub     pa, #1
01de0     02 70 0F F2 |                 cmp     htmp, #2    wz
01de4     61 8F E7 AA |         if_z    rdword  hpar2, ptra++
01de8     0F 8E 67 A7 |         if_z    signx   hpar2,#15
01dec     02 EC 87 A1 |         if_z    sub     pa, #2
01df0     03 70 0F F2 |                 cmp     htmp, #3    wz
01df4     61 8F 07 AB |         if_z    rdlong  hpar2, ptra++
01df8     04 EC 87 A1 |         if_z    sub     pa, #4
01dfc                 | 
01dfc     FC 8C 07 F5 |                 and     hpar1, #$FC
01e00                 |                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
01e00                 | 
01e00     84 8C 0F F2 |                 cmp     hpar1, #HID_REPORT_ID   wz
01e04     0C 01 90 AD |         if_z    jmp     #.report_id
01e08     04 8C 0F F2 |                 cmp     hpar1, #HID_USAGE_PAGE  wz
01e0c     24 01 90 AD |         if_z    jmp     #.usage_page
01e10     08 8C 0F F2 |                 cmp     hpar1, #HID_USAGE       wz
01e14     2C 01 90 AD |         if_z    jmp     #.usage
01e18     14 8C 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MIN wz
01e1c     C7 27 2B A9 |         if_z    setword hidr_lminmax, hpar2, #1
01e20     24 8C 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MAX wz
01e24     C7 27 23 A9 |         if_z    setword hidr_lminmax, hpar2, #0
01e28     34 8C 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MIN wz
01e2c     C7 29 2B A9 |         if_z    setword hidr_pminmax, hpar2, #1
01e30     44 8C 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MAX wz
01e34     C7 29 23 A9 |         if_z    setword hidr_pminmax, hpar2, #0
01e38     74 8C 0F F2 |                 cmp     hpar1, #HID_REPORT_SIZE wz
01e3c     C7 1F 03 A6 |         if_z    mov     hidr_size, hpar2
01e40     94 8C 0F F2 |                 cmp     hpar1, #HID_REPORT_COUNT wz
01e44     C7 21 03 A6 |         if_z    mov     hidr_count, hpar2
01e48     80 8C 0F F2 |                 cmp     hpar1, #HID_INPUT       wz
01e4c     64 FF 9F 5D |         if_nz   jmp     #.next
01e50                 | 
01e50     D8 1D A7 FB |                 tjf     hidr_state,#.next
01e54                 | 
01e54     03 8E 07 F5 |                 and     hpar2, #$03
01e58     02 8E 0F F2 |                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
01e5c     18 00 90 5D |         if_nz   jmp     #.skip
01e60                 | 
01e60     02 1C 0F F2 |                 cmp     hidr_state, #2  wz
01e64     20 00 90 AD |         if_z    jmp     #.axes
01e68     03 1C 0F F2 |                 cmp     hidr_state, #3  wz
01e6c     5C 00 90 AD |         if_z    jmp     #.hats
01e70     04 1C 0F F2 |                 cmp     hidr_state, #4  wz
01e74     70 00 90 AD |         if_z    jmp     #.buttons
01e78                 | .skip
01e78     8F 71 03 F6 |                 mov     htmp, hidr_size
01e7c     90 71 03 FA |                 mul     htmp, hidr_count
01e80     B8 23 03 F1 |                 add     hidr_offset, htmp
01e84     2C FF 9F FD |                 jmp     #.next
01e88                 | .axes
01e88                 |                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count))
01e88     87 85 53 F8 |                 getnib  hr0, hidr_flags, #2
01e8c     90 87 03 F6 |                 mov     hr1, hidr_count
01e90                 | .l1
01e90     91 8D 03 F6 |                 mov     hpar1, hidr_offset
01e94     8F 8F 03 F6 |                 mov     hpar2, hidr_size
01e98     04 03 B0 FD |                 call    #hpad_getbits
01e9c     64 03 B0 FD |                 call    #hpad_normalize
01ea0     06 84 1F F2 |                 cmp     hr0, #6         wcz
01ea4     86 85 5F C9 |         if_b    altgn   hr0, #hidr_usage
01ea8     00 88 43 C8 |         if_b    getnib  hr2
01eac     88 89 77 C9 |         if_b    altsw   hr2, #hidr_axis
01eb0     5F 01 20 C9 |         if_b    setword retval
01eb4     01 84 07 C1 |         if_b    add     hr0, #1
01eb8     8F 23 03 F1 |                 add     hidr_offset, hidr_size
01ebc     F4 87 6F FB |                 djnz    hr1, #.l1
01ec0                 | 
01ec0     C2 0F 13 F8 |                 setnib  hidr_flags, hr0, #2
01ec4     01 1C 07 F6 |                 mov     hidr_state, #1
01ec8     E8 FE 9F FD |                 jmp     #.next
01ecc                 | .hats
01ecc                 |                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
01ecc     91 8D 03 F6 |                 mov     hpar1, hidr_offset
01ed0     8F 8F 03 F6 |                 mov     hpar2, hidr_size
01ed4     C8 02 B0 FD |                 call    #hpad_getbits
01ed8     5F 19 C3 F8 |                 setbyte hidr_hats, retval, #0
01edc     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
01ee0     01 1C 07 F6 |                 mov     hidr_state, #1
01ee4     90 FF 9F FD |                 jmp     #.skip
01ee8                 | .buttons
01ee8                 |                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
01ee8     91 8D 03 F6 |                 mov     hpar1, hidr_offset
01eec     8F 8F 03 F6 |                 mov     hpar2, hidr_size
01ef0     90 8F 03 FA |                 mul     hpar2, hidr_count
01ef4     A8 02 B0 FD |                 call    #hpad_getbits
01ef8     87 71 E3 F8 |                 getbyte htmp, hidr_flags, #0
01efc     B8 BF 62 F0 |                 shl     retval, htmp
01f00     5F 17 43 F5 |                 or      hidr_buttons, retval
01f04     90 71 03 F1 |                 add     htmp, hidr_count
01f08     B8 0F C3 F8 |                 setbyte hidr_flags, htmp, #0
01f0c     01 1C 07 F6 |                 mov     hidr_state, #1
01f10     64 FF 9F FD |                 jmp     #.skip
01f14                 | .report_id
01f14     00 1A 0F F2 |                 cmp     hidr_id, #0     wz
01f18     2D 00 7C 5D |         if_nz   ret     wcz
01f1c     E1 71 C7 FA |                 rdbyte  htmp, ptrb++
01f20     C7 71 0B F2 |                 cmp     htmp, hpar2     wz
01f24     B8 1B 03 A6 |         if_z    mov     hidr_id, htmp
01f28     01 1C 67 56 |         if_nz   neg     hidr_state,#1
01f2c     01 F2 87 51 |         if_nz   sub     ptrb,#1
01f30     80 FE 9F FD |                 jmp     #.next
01f34                 | .usage_page
01f34     09 8E 0F F2 |                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
01f38     01 1C 0F A2 |         if_z    cmp     hidr_state, #1  wz
01f3c     04 1C 07 A6 |         if_z    mov     hidr_state, #4
01f40     70 FE 9F FD |                 jmp     #.next
01f44                 | .usage
01f44     04 8E 0F F2 |                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
01f48     05 8E 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
01f4c     06 2A 0F A2 |         if_z    cmp     hidr_type,#HID_READY        wz
01f50     01 1C 07 A6 |         if_z    mov     hidr_state, #1
01f54     5C FE 9F AD |         if_z    jmp     #.next
01f58     02 8E 0F F2 |                 cmp     hpar2, #HID_USAGE_MOUSE     wz
01f5c     04 2A 0F A2 |         if_z    cmp     hidr_type,#M_READY          wz
01f60     01 1C 07 A6 |         if_z    mov     hidr_state, #1
01f64     4C FE 9F AD |         if_z    jmp     #.next
01f68     30 8E 0F F2 |                 cmp     hpar2, #HID_USAGE_X     wz
01f6c     31 8E 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_Y     wz
01f70     32 8E 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_Z     wz
01f74     33 8E 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_RX    wz
01f78     34 8E 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_RY    wz
01f7c     35 8E 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_RZ    wz
01f80     10 00 90 AD |         if_z    jmp     #.usage_axis
01f84     39 8E 0F F2 |                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
01f88     01 1C 0F A2 |         if_z    cmp     hidr_state, #1      wz
01f8c     03 1C 07 A6 |         if_z    mov     hidr_state, #3
01f90     20 FE 9F FD |                 jmp     #.next
01f94                 | .usage_axis
01f94     01 1C 57 F2 |                 cmps    hidr_state, #1          wc
01f98     18 FE 9F CD |         if_b    jmp     #.next
01f9c     86 25 57 F9 |                 altsn   hidr_usage_idx, #hidr_usage
01fa0     C7 01 00 F8 |                 setnib  hpar2
01fa4                 | 
01fa4     20 8E 87 F1 |                 sub     hpar2, #HID_USAGE_X - 16
01fa8     C7 8F C3 F9 |                 decod   hpar2
01fac     C7 0F 43 F5 |                 or      hidr_flags, hpar2
01fb0                 | 
01fb0     01 24 07 F1 |                 add     hidr_usage_idx, #1
01fb4     02 1C 07 F6 |                 mov     hidr_state, #2
01fb8     F8 FD 9F FD |                 jmp     #.next
01fbc                 | 
01fbc                 | '------------------------------------------------------------------------------
01fbc                 | ' Handle XInput controller
01fbc                 | ' On entry:
01fbc                 | '   ptrb - controller report
01fbc                 | '------------------------------------------------------------------------------
01fbc                 | '   Default implementation translates the report to a pseudo-defacto hid
01fbc                 | '   standard and jumps to hpad_translate for actions.
01fbc                 | '   Implementors may take specific actions for this kind of controller.
01fbc                 | '------------------------------------------------------------------------------
01fbc                 | hpad_xinput
01fbc     80 71 CF FA |                 rdbyte  htmp, ptrb      wz
01fc0     2D 00 64 5D |         if_nz   ret                         ' Ignore message type <> $00
01fc4     81 71 C7 FA |                 rdbyte  htmp, ptrb[1]
01fc8     14 70 0F F2 |                 cmp     htmp, #$14      wz
01fcc     2D 00 64 5D |         if_nz   ret                         ' Ignore report length <> $14 (20)
01fd0                 | 
01fd0                 |                 debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
01fd0                 | 
01fd0     B0 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
01fd4     06 0E 17 F8 |                 setnib  hidr_flags, #6, #2
01fd8                 | 
01fd8     83 11 E7 FA |                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
01fdc     84 BF E6 FA |                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
01fe0     5F BF 22 F6 |                 not     retval
01fe4     5F 11 2B F9 |                 setword hidr_axis, retval, #1
01fe8     85 13 E7 FA |                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
01fec     86 BF E6 FA |                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
01ff0     5F BF 22 F6 |                 not     retval
01ff4     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
01ff8                 | 
01ff8     FF 26 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
01ffc     84 BF C6 FA |                 rdbyte  retval, ptrb[4]     ' left analog trigger
02000     C0 BE 1E F2 |                 cmp     retval, #192    wcz
02004     06 16 27 34 |         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
02008     F8 01 B0 FD |                 call    #hpad_normalize
0200c     5F 13 2B F9 |                 setword hidr_axis+1, retval, #1
02010     85 BF C6 FA |                 rdbyte  retval, ptrb[5]     ' right analog trigger
02014     C0 BE 1E F2 |                 cmp     retval, #192    wcz
02018     07 16 27 34 |         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
0201c     E4 01 B0 FD |                 call    #hpad_normalize
02020     5F 15 23 F9 |                 setword hidr_axis+2, retval, #0
02024                 | 
02024     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
02028     81 BF E6 FA |                 rdword  retval, ptrb[1]
0202c     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
02030     00 16 47 F4 |                 bitc    hidr_buttons, #0
02034     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
02038     01 16 47 F4 |                 bitc    hidr_buttons, #1
0203c     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
02040     02 16 47 F4 |                 bitc    hidr_buttons, #2
02044     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
02048     03 16 47 F4 |                 bitc    hidr_buttons, #3
0204c     08 BE 16 F4 |                 testb   retval, #8      wc  ' LB
02050     04 16 47 F4 |                 bitc    hidr_buttons, #4
02054     09 BE 16 F4 |                 testb   retval, #9      wc  ' RB
02058     05 16 47 F4 |                 bitc    hidr_buttons, #5
0205c     05 BE 16 F4 |                 testb   retval, #5      wc  ' SELECT
02060     08 16 47 F4 |                 bitc    hidr_buttons, #8
02064     04 BE 16 F4 |                 testb   retval, #4      wc  ' START
02068     09 16 47 F4 |                 bitc    hidr_buttons, #9
0206c     06 BE 16 F4 |                 testb   retval, #6      wc  ' L3
02070     0A 16 47 F4 |                 bitc    hidr_buttons, #10
02074     07 BE 16 F4 |                 testb   retval, #7      wc  ' R3
02078     0B 16 47 F4 |                 bitc    hidr_buttons, #11
0207c     0A BE 16 F4 |                 testb   retval, #10     wc  ' XBOX
02080     0C 16 47 F4 |                 bitc    hidr_buttons, #12
02084                 | 
02084     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
02088     5F 71 43 F8 |                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
0208c     7A BB 7A FF 
02090     0F 72 07 F6 |                 mov     htmp1, ##$F576_F40F
02094     F9 FF 7F FF 
02098     12 75 07 F6 |                 mov     htmp2, ##$FFFF_F312
0209c     B9 71 5F F9 |                 altgn   htmp, #htmp1
020a0     00 70 43 F8 |                 getnib  htmp
020a4     B8 19 C3 F8 |                 setbyte hidr_hats, htmp, #0
020a8                 | 
020a8     AC 01 90 FD |                 jmp     #hpad_translate
020ac                 | 
020ac                 | '------------------------------------------------------------------------------
020ac                 | ' Handle PS3 controller
020ac                 | ' On entry:
020ac                 | '   ptrb - controller report
020ac                 | '------------------------------------------------------------------------------
020ac                 | '   Default implementation translates the report to a pseudo-defacto hid
020ac                 | '   standard and jumps to hpad_translate for actions.
020ac                 | '   Implementors may take specific actions for this kind of controller.
020ac                 | '------------------------------------------------------------------------------
020ac                 | hpad_ps3
020ac     E1 71 C7 FA |                 rdbyte  htmp, ptrb++
020b0     01 70 0F F2 |                 cmp     htmp, #$01      wz
020b4     2D 00 64 5D |         if_nz   ret                         ' Ignore report ID <> $01
020b8                 | 
020b8                 |                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
020b8                 | 
020b8     FF 26 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
020bc     85 BF C6 FA |                 rdbyte  retval, ptrb[5]         ' X = left stick X
020c0     40 01 B0 FD |                 call    #hpad_normalize
020c4     5F 11 23 F9 |                 setword hidr_axis, retval, #0
020c8     10 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X
020cc     86 BF C6 FA |                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
020d0     30 01 B0 FD |                 call    #hpad_normalize
020d4     5F 11 2B F9 |                 setword hidr_axis, retval, #1
020d8     11 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_Y
020dc     87 BF C6 FA |                 rdbyte  retval, ptrb[7]         ' Z = right stick X
020e0     20 01 B0 FD |                 call    #hpad_normalize
020e4     5F 13 23 F9 |                 setword hidr_axis+1, retval, #0
020e8     12 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_Z
020ec     88 BF C6 FA |                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
020f0     10 01 B0 FD |                 call    #hpad_normalize
020f4     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
020f8     15 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_RZ
020fc     04 0E 17 F8 |                 setnib  hidr_flags, #4, #2
02100                 | 
02100     08 8C 07 F6 |                 mov     hpar1, #8
02104     13 8E 07 F6 |                 mov     hpar2, #19
02108     94 00 B0 FD |                 call    #hpad_getbits
0210c                 | 
0210c     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
02110     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
02114     00 16 47 F4 |                 bitc    hidr_buttons, #0
02118     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
0211c     01 16 47 F4 |                 bitc    hidr_buttons, #1
02120     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
02124     02 16 47 F4 |                 bitc    hidr_buttons, #2
02128     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
0212c     03 16 47 F4 |                 bitc    hidr_buttons, #3
02130     0A BE 16 F4 |                 testb   retval, #10     wc  ' L1
02134     04 16 47 F4 |                 bitc    hidr_buttons, #4
02138     0B BE 16 F4 |                 testb   retval, #11     wc  ' R1
0213c     05 16 47 F4 |                 bitc    hidr_buttons, #5
02140     08 BE 16 F4 |                 testb   retval, #8      wc  ' L2
02144     06 16 47 F4 |                 bitc    hidr_buttons, #6
02148     09 BE 16 F4 |                 testb   retval, #9      wc  ' R2
0214c     07 16 47 F4 |                 bitc    hidr_buttons, #7
02150     00 BE 16 F4 |                 testb   retval, #0      wc  ' SELECT
02154     08 16 47 F4 |                 bitc    hidr_buttons, #8
02158     03 BE 16 F4 |                 testb   retval, #3      wc  ' START
0215c     09 16 47 F4 |                 bitc    hidr_buttons, #9
02160     01 BE 16 F4 |                 testb   retval, #1      wc  ' LEFT STICK
02164     0A 16 47 F4 |                 bitc    hidr_buttons, #10
02168     02 BE 16 F4 |                 testb   retval, #2      wc  ' RIGHT STICK
0216c     0B 16 47 F4 |                 bitc    hidr_buttons, #11
02170     10 BE 16 F4 |                 testb   retval, #16     wc  ' HOME
02174     0C 16 47 F4 |                 bitc    hidr_buttons, #12
02178                 | 
02178     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
0217c     5F 71 4B F8 |                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
02180     09 FA 79 FF 
02184     0F 72 07 F6 |                 mov     htmp1, ##$F3F4_120F
02188     FF FA 7F FF 
0218c     76 75 07 F6 |                 mov     htmp2, ##$FFF5_FF76
02190     B9 71 5F F9 |                 altgn   htmp, #htmp1
02194     00 70 43 F8 |                 getnib  htmp
02198     B8 19 C3 F8 |                 setbyte hidr_hats, htmp, #0
0219c                 | 
0219c     B8 00 90 FD |                 jmp     #hpad_translate
021a0                 | 
021a0                 | '------------------------------------------------------------------------------
021a0                 | ' Read bits from report data buffer
021a0                 | '------------------------------------------------------------------------------
021a0                 | ' On entry:
021a0                 | '   PTRB - report buffer
021a0                 | '   hpar1 - start bit
021a0                 | '   hpar2 - number of bits
021a0                 | ' On exit:
021a0                 | '   retval - bits
021a0                 | '------------------------------------------------------------------------------
021a0                 | hpad_getbits
021a0     C6 71 03 F6 |                 mov     htmp, hpar1
021a4     03 70 47 F0 |                 shr     htmp, #3        ' byte offset
021a8     F9 71 03 F1 |                 add     htmp, ptrb
021ac     B8 BF 02 FB |                 rdlong  retval, htmp
021b0                 | 
021b0     C6 73 03 F6 |                 mov     htmp1, hpar1
021b4     07 72 07 F5 |                 and     htmp1, #$07     ' shift
021b8     B9 BF 42 F0 |                 shr     retval, htmp1
021bc                 | 
021bc     18 8E 1F F2 |                 cmp     hpar2, #24      wcz
021c0     10 00 90 1D |         if_a    jmp     #.l1
021c4                 | 
021c4     C7 8F C3 F9 |                 decod   hpar2
021c8     01 8E 87 F1 |                 sub     hpar2, #1
021cc     C7 BF 02 F5 |                 and     retval, hpar2
021d0     2D 00 64 FD |                 ret
021d4                 | .l1
021d4     FF 7F 00 FF 
021d8     FF BF 06 F5 |                 and     retval, ##$00_FFFFFF
021dc     03 70 07 F1 |                 add     htmp, #3
021e0     B8 75 03 FB |                 rdlong  htmp2, htmp
021e4     18 8E 87 F1 |                 sub     hpar2, #24
021e8     C7 8F C3 F9 |                 decod   hpar2
021ec     01 8E 87 F1 |                 sub     hpar2, #1
021f0     B9 75 43 F0 |                 shr     htmp2, htmp1
021f4     C7 75 03 F5 |                 and     htmp2, hpar2
021f8     18 74 67 F0 |                 shl     htmp2, #24
021fc     BA BF 42 F5 |                 or      retval, htmp2
02200     2D 00 64 FD |                 ret
02204                 | 
02204                 | '------------------------------------------------------------------------------
02204                 | ' Normalize value to signed word (-32768 / 32767)
02204                 | '------------------------------------------------------------------------------
02204                 | ' On entry:
02204                 | '   retval - value to normalize
02204                 | '   hidr_lminmax - min (word 1) max (word 0) value range
02204                 | '   - or -
02204                 | '   hidr_pminmax - min (word 1) max (word 0) value range
02204                 | '   hidr_size - value bits length
02204                 | ' On exit:
02204                 | '   retval - normalized value
02204                 | '------------------------------------------------------------------------------
02204                 | hpad_normalize
02204     93 71 0B F6 |                 mov     htmp, hidr_lminmax  wz
02208     94 71 0B A6 |         if_z    mov     htmp, hidr_pminmax  wz
0220c     2D 00 64 AD |         if_z    ret
02210     B8 73 3B F9 |                 getword htmp1, htmp, #1     ' htmp1 = min
02214     B8 71 33 F9 |                 getword htmp, htmp, #0      ' htmp = max
02218     0F 72 77 F7 |                 signx   htmp1, #15      wc
0221c     FF 1F 97 C9 |         if_c    alts    hidr_size, #511
02220     00 BE 66 C7 |         if_c    signx   retval, #0-0
02224     B9 71 C3 F1 |                 subs    htmp, htmp1         ' htmp = (max - min)
02228     B9 BF C2 F1 |                 subs    retval, htmp1       ' retval = (retval - min)
0222c     10 BE 66 F0 |                 shl     retval, #16         ' retval = (retval - min) << 16
02230     01 BE C6 F1 |                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
02234     B8 71 53 F6 |                 abs     htmp            wc
02238     1F BE 0E F4 |                 testb   retval, #31     wz
0223c     5F BF 42 F6 |                 abs     retval
02240     B8 BF 12 FD |                 qdiv    retval, htmp
02244     18 BE 62 FD |                 getqx   retval
02248     5F BF 62 66 |     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
0224c     C0 FF 7F FF 
02250     00 BE 46 F1 |                 adds    retval, ##$8000 signx 15
02254     2D 00 64 FD |                 ret
02258                 | 
02258                 | '------------------------------------------------------------------------------
02258                 | ' Perform controller actions
02258                 | ' On entry:
02258                 | '    hidr_id        report id
02258                 | '    hidr_axis      axis value (signed word, 2 axes per long)
02258                 | '                      X = hidr_axis+0, #0
02258                 | '                      Y = hidr_axis+0, #1
02258                 | '                      Z = hidr_axis+1, #0
02258                 | '                     RX = hidr_axis+1, #1
02258                 | '                     RY = hidr_axis+2, #0
02258                 | '                     RZ = hidr_axis+2, #1
02258                 | '    hidr_buttons   buttons state (bits 0 to 31)
02258                 | '    hidr_hats      hats state (byte 0, 1, 2, 3)
02258                 | '
02258                 | '                     -------3 -------2 -------1 -------0 byte
02258                 | '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
02258                 | '    hidr_flags       xxxxxxxx_xxrrrzyx_hhhhaaaa_bbbbbbbb
02258                 | '                                zyx||| |||||||| ++++++++ n. buttons
02258                 | '                                |||||| ||||++++--------- n. axes
02258                 | '                                |||||| ++++------------- n. hats
02258                 | '                                ++++++------------------ valid axes
02258                 | '------------------------------------------------------------------------------
02258                 | hpad_translate
02258                 | 
02258                 | 
02258                 |         if HAVE_HIDPAD
02258     84 0C F0 FE |                 loc     ptrb,#hidpad_report
0225c     2D 71 0B F6 |                 mov     htmp,hdev_port          wz
02260     8D 71 03 A6 |         if_z    mov     htmp,hidr_id
02264     01 70 E7 F2 |                 cmpsub  htmp,#1
02268     07 1A 17 A2 |         if_z    cmp     hidr_id, #MAX_DEVICES   wc
0226c     02 1A 17 52 |         if_nz   cmp     hidr_id, #2             wc
02270     2D 00 7C 3D |         if_ae   ret     wcz
02274     1C 70 07 FA |                 mul     htmp, #HIDPAD_REPORT_SIZE
02278     B8 F3 03 F1 |                 add     ptrb,htmp
0227c     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
02280     00 0C 03 F6 |                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
02284     28 0C 64 FD |                 setq    #7-1
02288     80 0D 67 FC |                 wrlong  hidr_usage,ptrb
0228c                 |         end
0228c                 | 
0228c                 | 
0228c                 |         if EMUPAD_MAX_PLAYER > 0
0228c                 | .emupad_no_hat
0228c                 |         if EMUPAD_BT0_BIT >= 0
0228c                 |         end
0228c                 |         if EMUPAD_BT1_BIT >= 0
0228c                 |         end
0228c                 |         if EMUPAD_BT2_BIT >= 0
0228c                 |         end
0228c                 |         if EMUPAD_BT3_BIT >= 0
0228c                 |         end
0228c                 |         if EMUPAD_BT4_BIT >= 0
0228c                 |         end
0228c                 |         if EMUPAD_BT5_BIT >= 0
0228c                 |         end
0228c                 |         if EMUPAD_BT6_BIT >= 0
0228c                 |         end
0228c                 |         if EMUPAD_BT7_BIT >= 0
0228c                 |         end
0228c                 |         if EMUPAD_BT8_BIT >= 0
0228c                 |         end
0228c                 |         if EMUPAD_BT9_BIT >= 0
0228c                 |         end
0228c                 | .emupad_slot_over
0228c                 |         end
0228c                 | 
0228c                 |         if 0
0228c                 |                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
0228c                 | 
0228c                 |                 debug("    btn: ", ubin_long_(hidr_buttons))
0228c                 | 
0228c                 |         end
0228c     2D 00 64 FD |                 ret
02290                 | end
02290                 | 
02290                 | if EMUPAD_MAX_PLAYER > 0
02290                 | '------------------------------------------------------------------------------
02290                 | ' Clear EmuPad state
02290                 | '------------------------------------------------------------------------------
02290                 | emupad_reset
02290                 | 
02290                 | '------------------------------------------------------------------------------
02290                 | ' Get EmuPad Player number for current device (into retval)
02290                 | ' Z flag is also set if current device is valid
02290                 | ' (Value may be larger than EMUPAD_MAX_PLAYER !)
02290                 | '------------------------------------------------------------------------------
02290                 | emupad_getnum
02290                 | .loop
02290                 | '------------------------------------------------------------------------------
02290                 | ' Handle disconnect of device (call after emupad_getnum returns with Z set)
02290                 | '------------------------------------------------------------------------------
02290                 | emupad_discon
02290                 | .loop         
02290                 |         
02290                 |         ' FALL THROUGH!!!
02290                 | 
02290                 | '------------------------------------------------------------------------------
02290                 | ' Update EmuPad reports (all of them...)
02290                 | '------------------------------------------------------------------------------
02290                 | emupad_write_reports
02290                 | .devloop
02290                 | 
02290                 | end
02290                 | 
02290                 | 
02290                 | '------------------------------------------------------------------------------
02290                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
02290                 | '------------------------------------------------------------------------------
02290                 | ' On entry:
02290                 | ' On exit:
02290                 | '------------------------------------------------------------------------------
02290                 | hget_hub_status
02290     77 BD 02 F6 |                 mov     ep_addr_pid, hhub_ep_addr
02294     27 8F 03 F6 |                 mov     hpar2, urx_buff_p
02298     32 91 23 F9 |                 setword hpar3, hub_next_datax, #0
0229c     01 90 2F F9 |                 setword hpar3, #1, #1
022a0     CF 02 A0 FD |                 call    #do_int_in
022a4     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
022a8     0C 00 90 AD |         if_z    jmp     #.data
022ac     5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
022b0     1A 01 80 5D |         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
022b4     2D 00 64 FD |                 ret
022b8                 | .data
022b8     00 90 0F F2 |                 cmp     hpar3, #0               wz
022bc     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
022c0                 | 
022c0     C3 64 0E F2 |                 cmp     hub_next_datax, #PID_DATA0  wz
022c4     4B 64 06 A6 |         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
022c8     C3 64 06 56 |         if_nz   mov     hub_next_datax, #PID_DATA0
022cc     27 67 02 FB |                 rdlong  hub_status_chg, urx_buff_p
022d0                 |                 debug(ubin_long(hub_status_chg))
022d0                 | 
022d0     01 5A 06 F6 |                 mov     hdev_port, #1
022d4                 | .loop
022d4     2D 67 0A F4 |                 testb   hub_status_chg, hdev_port wz
022d8     0C 00 B0 AD |         if_x1   call    #hub_port_handler
022dc     07 5A 1E F7 |                 incmod  hdev_port, #7           wcz
022e0     F0 FF 9F 3D |         if_nc   jmp     #.loop
022e4     2D 00 64 FD |                 ret
022e8                 | 
022e8                 | hub_port_handler
022e8     76 BD 02 F6 |                 mov     ep_addr_pid, hhub_ctrl_ep
022ec     8C 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
022f0     27 EF 03 F6 |                 mov     pb, urx_buff_p
022f4     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
022f8     55 02 A0 FD |                 call    #control_read
022fc     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
02300                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
02300                 | 
02300     10 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
02304     50 01 90 5D |         if_x0   jmp     #.other
02308     68 02 D0 FE |                 loc     ptra, #clr_port_feat
0230c     01 21 5C FC |                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
02310     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02314     A0 02 A0 FD |                 call    #control_write
02318     00 68 0E F4 |                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
0231c     7C 01 90 5D |         if_x0   jmp     #.disconnect
02320     B0 99 02 F6 |                 mov     hctwait, _100ms_
02324     EF 02 A0 FD |                 call    #poll_waitx
02328                 | 
02328     40 02 D0 FE |                 loc     ptra, #set_port_feat            ' reset port
0232c     01 09 5C FC |                 wrword  #HUB_PORT_RESET, ptra[wValue]
02330     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02334     A0 02 A0 FD |                 call    #control_write
02338                 | 
02338     02 76 07 F6 |                 mov     htmp3, #2
0233c                 | .wait_reset
0233c     AC 99 02 F6 |                 mov     hctwait, _8ms_
02340     EF 02 A0 FD |                 call    #poll_waitx
02344     34 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
02348     27 EF 03 F6 |                 mov     pb, urx_buff_p
0234c     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02350     55 02 A0 FD |                 call    #control_read
02354     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
02358     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
0235c     F7 77 6F 5B |         if_x0   djnz    htmp3, #.wait_reset
02360                 | 
02360     10 02 D0 FE |                 loc     ptra, #clr_port_feat
02364     01 29 5C FC |                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
02368     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
0236c     A0 02 A0 FD |                 call    #control_write
02370                 | 
02370     24 70 07 F6 |                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
02374                 | .wait_recover
02374     A7 99 02 F6 |                 mov     hctwait, _1ms_
02378     EF 02 A0 FD |                 call    #poll_waitx
0237c     FD 71 6F FB |                 djnz    htmp,#.wait_recover
02380                 | 
02380     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
02384     07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
02388     0E 68 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
0238c                 | 
0238c     00 08 00 FF 
02390     00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
02394     8C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
02398     03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
0239c     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
023a0     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
023a4     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
023a8     48 01 90 5D |         if_nz   jmp     #.done
023ac                 | .get_dev_desc
023ac     28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
023b0     07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
023b4     F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
023b8     80 01 D0 FE |                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
023bc     2D 71 03 F6 |                 mov     htmp, hdev_port             ' Address is hub port number
023c0     01 71 57 FC |                 wrword  htmp, ptra[wValue]
023c4     A0 02 A0 FD |                 call    #control_write                  ' Execute SetAddress()
023c8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
023cc     24 01 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
023d0     AC 99 02 F6 |                 mov     hctwait, _8ms_
023d4     EF 02 A0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
023d8     2D BD 02 F6 |                 mov     ep_addr_pid, hdev_port
023dc     08 BC 66 F0 |                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
023e0     BE 00 A0 FD |                 call    #calc_crc5
023e4     3C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
023e8     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
023ec     F7 AD C2 FA |                 rdbyte  total_data, pb
023f0     03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
023f4     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
023f8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
023fc     F4 00 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
02400     5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
02404     28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
02408                 |                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
02408     9F 99 02 F6 |                 mov     hctwait, _500us_
0240c     EF 02 A0 FD |                 call    #poll_waitx
02410     18 01 D0 FE |                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
02414     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
02418     29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
0241c     55 02 A0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
02420     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
02424     CC 00 90 5D |         if_nz   jmp     #.done
02428     29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
0242c     F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
02430     61 85 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
02434     61 87 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
02438     00 71 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
0243c     09 84 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
02440     02 86 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
02444     56 71 1B A2 |         if_z    cmp     htmp, total_data        wcz
02448     0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
0244c     A4 00 90 CD |         if_b    jmp     #.done
02450     6C F0 BF FD |                 call    #hparse_con_desc
02454     9C 00 90 FD |                 jmp     #.done
02458                 | 
02458                 | .other
02458     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz
0245c     01 29 5C AC |         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
02460     28 00 90 AD |         if_x1   jmp     #.reset_feature
02464     11 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
02468     01 23 5C AC |         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
0246c     1C 00 90 AD |         if_x1   jmp     #.reset_feature
02470     12 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
02474     01 25 5C AC |         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
02478     10 00 90 AD |         if_x1   jmp     #.reset_feature
0247c     13 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
02480     01 27 5C AC |         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
02484     04 00 90 AD |         if_x1   jmp     #.reset_feature
02488     68 00 90 FD |                 jmp     #.done
0248c                 | .reset_feature
0248c     E4 00 D0 FE |                 loc     ptra, #clr_port_feat
02490     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02494     A0 02 A0 FD |                 call    #control_write
02498     58 00 90 FD |                 jmp     #.done
0249c                 | .disconnect
0249c                 | 
0249c     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
024a0     00 70 E3 F8 |                 getbyte htmp
024a4     03 70 0F F2 |                 cmp     htmp,#KB_READY wz
024a8     05 70 0F 52 |         if_nz   cmp     htmp,#KBM_READY wz
024ac     00 F2 06 A6 |         if_z    mov     hkbd_ep_addr, #0
024b0     00 F0 06 A6 |         if_z    mov     hkbd_ctrl_ep, #0
024b4     00 76 06 A6 |         if_z    mov     kb_led_states, #0
024b8     3B F9 02 A6 |         if_z    mov     hkbd_ledstates, kb_led_states
024bc                 |         if EMUPAD_MAX_PLAYER > 0
024bc                 |         end
024bc                 |         if HAVE_MOUSE
024bc     04 70 0F F2 |                 cmp     htmp, #M_READY          wz
024c0     05 70 0F 52 |         if_nz   cmp     htmp, #KBM_READY        wz
024c4     00 F4 06 A6 |         if_z    mov     hmouse_ep_addr, #0
024c8                 |         end
024c8                 |         if HAVE_HIDPAD
024c8     14 0A F0 FE |                 loc ptrb,#hidpad_report
024cc     2D 71 03 F6 |                 mov htmp,hdev_port
024d0     01 70 E7 F2 |                 cmpsub htmp,#1
024d4     1C 70 07 FA |                 mul htmp,#HIDPAD_REPORT_SIZE
024d8     B8 F3 03 F1 |                 add ptrb,htmp
024dc     28 0C 64 FD |                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
024e0     80 01 6C FC |                 wrlong #0,ptrb
024e4                 |         end
024e4                 | 
024e4     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
024e8     00 00 C4 F8 |                 setbyte #0
024ec     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
024f0     00 00 04 F6 |                 mov     0-0, #0
024f4                 | 
024f4                 | .done
024f4     0E 68 1F F4 |                 bitl    _usb_h_ls_nco_, #14     wcz
024f8     07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
024fc     22 6D 13 CC |         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
02500     40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
02504     A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
02508     A3 9B 02 F6 |                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
0250c                 | 
0250c     6C 00 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
02510     27 EF 03 F6 |                 mov     pb, urx_buff_p
02514     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
02518     55 02 A0 FD |                 call    #control_read
0251c     00 69 06 FB |                 rdlong  hub_port_status, ptra
02520                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
02520     2D 00 64 FD |                 ret
02524                 | 
02524                 | '------------------------------------------------------------------------------
02524                 | ' Partially populated SETUP packets
02524                 | '------------------------------------------------------------------------------
02524     80          | get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
02525     06          |                 byte    REQ_GET_DESC
02526     00 01       |                 word    TYPE_DEVICE << 8
02528     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
0252a     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
0252c     80          | get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
0252d     06          |                 byte    REQ_GET_DESC
0252e     00 02       |                 word    TYPE_CONFIG << 8
02530     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
02532     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
02534     00          | set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
02535     09          |                 byte    REQ_SET_CONFIG
02536     00 00       |                 word    0       ' Configuration value
02538     00 00       |                 word    0       ' Zero
0253a     00 00       |                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
0253c     00          | set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
0253d     05          |                 byte    REQ_SET_ADDR
0253e     00 00       |                 word    0       ' Zero
02540     00 00       |                 word    0       ' Zero
02542     00 00       |                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
02544                 | '------------------------------------------------------------------------------
02544                 | ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
02544                 | ' wValue field dictates which protocol should be used.
02544                 | '
02544                 | ' When initialized, all devices default to report protocol. However the host
02544                 | ' should not make any assumptions about the device state and should set the
02544                 | ' desired protocol whenever initializing a device.
02544                 | '------------------------------------------------------------------------------
02544     21          | set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
02545     0B          |                 byte    HID_SET_PROTO
02546     00 00       |                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
02548                 |                                                 ' (HID 1.11 Section 7.2.6).
02548     00 00       |                 word    0               ' Interface index number.
0254a     00 00       |                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
0254c                 | '------------------------------------------------------------------------------
0254c     21          | set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
0254d     0A          |                 byte    HID_SET_IDLE
0254e     00 00       |                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
02550                 |                                         ' reporting until a change is detected in the report data
02550                 | 
02550                 |                                         ' (HID 1.11 Section 7.2.4).
02550     00 00       |                 word    0       ' Interface index number.
02552     00 00       |                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
02554     21          | set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
02555     09          |                 byte    HID_SET_REPORT
02556     00 00       |                 word    0       ' Byte1 = report type, byte0 = ReportID.
02558                 |                                         ' (HID 1.11 Section 7.2.2).
02558     00 00       |                 word    0       ' Interface index number.
0255a     00 00       |                 word    0       ' Size of the report, in bytes.
0255c     81          | get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
0255d     06          |                 byte    REQ_GET_DESC
0255e     00 22       |                 word    TYPE_REPORT << 8
02560     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
02562     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
02564                 | '------------------------------------------------------------------------------
02564     A0          | get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
02565     06          |                 byte    REQ_GET_DESC
02566     00 29       |                 word    TYPE_HUB << 8
02568     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
0256a     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
0256c     23          | set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
0256d     03          |                 byte    REQ_SET_FEATURE
0256e     00 00       |                 word    0       ' port power
02570     01 00       |                 word    1       ' Port index number (1+)
02572     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
02574     23          | clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
02575     01          |                 byte    REQ_CLEAR_FEATURE
02576     00 00       |                 word    0       ' port power
02578     01 00       |                 word    1       ' Port index number (1+)
0257a     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
0257c     A3          | get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
0257d     00          |                 byte    REQ_GET_STATUS
0257e     00 00       |                 word    0
02580     01 00       |                 word    1       ' Port index number (1+)
02582     04 00       |                 word    4       ' Number of bytes to transfer if there is a data stage
02584                 | '------------------------------------------------------------------------------
02584                 | if _HAVE_GAMEPAD
02584     42 0C 00 00 | ps3_enable_cmd  byte    $42, $0C, $00, $00
02588                 | ps3_command_buff
02588     00 00 00 00 
0258c     00          |                 byte    $00, $00, $00, $00, $00
0258d     00 00 00 00 
02591     02          |                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
02592     FF 27 10 00 
02596     32          |                 byte    $FF, $27, $10, $00, $32
02597     FF 27 10 00 
0259b     32          |                 byte    $FF, $27, $10, $00, $32
0259c     FF 27 10 00 
025a0     32          |                 byte    $FF, $27, $10, $00, $32
025a1     FF 27 10 00 
025a5     32          |                 byte    $FF, $27, $10, $00, $32
025a6     00 00 00 00 
025aa     00          |                 byte    $00, $00, $00, $00, $00
025ab     00 00 00 00 
025af     00          |                 byte    $00, $00, $00, $00, $00
025b0     00 00 00 00 
025b4     00          |                 byte    $00, $00, $00, $00, $00
025b5     00 00 00    |                 byte    $00, $00, $00
025b8                 | '------------------------------------------------------------------------------
025b8     01 03 06    | xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
025bb                 |                                         ' 0x01 All blinking
025bb                 |                                         ' 0x02 1 flashes, then on
025bb                 |                                         ' 0x03 2 flashes, then on
025bb                 |                                         ' 0x04 3 flashes, then on
025bb                 |                                         ' 0x05 4 flashes, then on
025bb                 |                                         ' 0x06 1 on
025bb                 |                                         ' 0x07 2 on
025bb                 |                                         ' 0x08 3 on
025bb                 |                                         ' 0x09 4 on
025bb                 |                                         ' 0x0A Rotating (e.g. 1-2-4-3)
025bb                 |                                         ' 0x0B Blinking*
025bb                 |                                         ' 0x0C Slow blinking*
025bb                 |                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
025bb     00 08 00    | xinp_rumble_cmd byte    $00, $08, $00
025be     00          |                 byte    $00             ' Left rumble
025bf     00          |                 byte    $00             ' Right rumble
025c0     00 00 00    |                 byte    $00, $00, $00
025c3     00          | end
025c4                 | alignl
025c4                 | 
025c4                 | if HAVE_MOUSE
025c4     00 00 00 00 
025c8     00 00 00 00 | mouse_limits long 0[2]
025cc     00 00 00 00 | mouse_outptr long 0
025d0                 | end
025d0                 | 
025d0                 | if KEYQUEUE_SIZE > 0
025d0     00          | keyq_head byte 0
025d1     00          | keyq_tail byte 0
025d2     00 00 00 00 
      ...             
027ce     00 00 00 00 
027d2     00 00       | keyq_data long 0[KEYQUEUE_SIZE]
027d4                 | alignl
027d4                 | end
027d4                 | 
027d4                 | if EMUPAD_MAX_PLAYER > 0
027d4                 | emupad_rule_buffer
027d4                 | if EMUPAD_BUILTIN_RULES
027d4                 | file "padmap_builtin.dat"
027d4                 | end
027d4                 | byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
027d4                 | '' Default rule directly follows!
027d4                 | byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
027d4                 | end
027d4                 | 
027d4                 | '------------------------------------------------------------------------------
027d4                 | ' The USB data cache area gets zero-filled at every device disconnect
027d4                 | '------------------------------------------------------------------------------
027d4                 | usb_cache_start
027d4                 | 
027d4                 | ' HID descriptor and report buffers
027d4                 | if !!OVERLAP_MEMORY
027d4     00 00 00 00 
      ...             
02ecc     00 00 00 00 
02ed0     00 00 00 00 | hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
02ed4                 | end
02ed4     00 00 00 00 
02ed8     00 00 00 00 | hkbd_report     byte    0[8]
02edc     00 00 00 00 | hkbd_led_rep    byte    0
02ee0                 | alignl
02ee0                 | 
02ee0                 | if HAVE_HIDPAD
02ee0     00 00 00 00 
      ...             
02f9c     00 00 00 00 
02fa0     00 00 00 00 | hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
02fa4                 | end
02fa4                 | 
02fa4                 | ' HUB descriptor
02fa4     00          | hub_descr       byte    0   ' bDescLength
02fa5     00          |                 byte    0   ' bDescriptorType
02fa6     00          |                 byte    0   ' bNbrPorts
02fa7     00 00       |                 word    0   ' wHubCharacteristics
02fa9     00          |                 byte    0   ' bPwrOn2PwrGood
02faa     00          |                 byte    0   ' bHubContrCurrent
02fab     00          |                 byte    0   ' DeviceRemoveable
02fac     00          |                 byte    0   ' PortPwrCtrlMask
02fad                 | 
02fad                 | usb_cache_end
02fad                 | 
02fad                 | if HAVE_MOUSE
02fad     00 00 00 00 | mouse_xacc      long 0
02fb1     00 00 00 00 | mouse_yacc      long 0
02fb5     00 00 00 00 | mouse_zacc      long 0
02fb9     00          | mouse_bstate    byte 0
02fba     00          | mouse_lpending  byte 0
02fbb     00          | mouse_rpending  byte 0
02fbc     00          | mouse_mpending  byte 0
02fbd     00          | mouse_lock      byte 0
02fbe     00 00 00    |                 byte 0[3] ' padding
02fc1                 | end
02fc1                 | 
02fc1     00 00 00 00 
      ...             
03039     00 00 00 00 
0303d     00 00 00 00 | urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
03041     00 00 00 00 
03045     00 00 00 00 
03049     00 00 00 00 
0304d     00 00 00 00 
03051     00 00       | dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
03053     00 00 00 00 
      ...             
0314b     00 00 00 00 
0314f     00 00 00 00 | con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
03153                 | 
03153     00          | driver_cog      byte    0                       ' Current driver cog + 1
03154                 | objmem
03154                 | 	long	0[0]
03154                 | stackspace
03154     00 00 00 00 | 	long	0[1]
03158 0a9             | 	org	COG_BSS_START
03158 0a9             | _var01
03158 0a9             | 	res	1
03158 0aa             | _var02
03158 0aa             | 	res	1
03158 0ab             | arg01
03158 0ab             | 	res	1
03158 0ac             | arg02
03158 0ac             | 	res	1
03158 0ad             | arg03
03158 0ad             | 	res	1
03158 0ae             | arg04
03158 0ae             | 	res	1
03158 0af             | 	fit	480
03158 0af             | 
