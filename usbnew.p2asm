con
	_clkfreq = 20000000
	_clkmode = 16779595
' 
'   DEBUG_DISABLE = true
	DEBUG_DISABLE = -1
' 
'   CLKFREQ_PTR = $14
	CLKFREQ_PTR = 20
' 
'   USB_BASE_PIN  = 16
	USB_BASE_PIN = 16
'   USB_ENABLE_OFFSET = 1 ' Set -1 if not present
	USB_ENABLE_OFFSET = 1
'   USB_DMINUS_OFFSET = 2 ' Must end up on an even pin. D+ is always this +1
	USB_DMINUS_OFFSET = 2
' 
'   ACTIVITY_LED  = -1
	ACTIVITY_LED = -1
'   ERROR_LED     = -1
	ERROR_LED = -1
' 
'   OVERLAP_MEMORY = false ' save memory at cost of making the driver non-reentrant
	OVERLAP_MEMORY = 0
' 
'   KEYQUEUE_SIZE = 128
	KEYQUEUE_SIZE = 128
' 
'   NUMLOCK_DEFAULT_STATE = false
	NUMLOCK_DEFAULT_STATE = 0
' 
'   HAVE_MOUSE = true
	HAVE_MOUSE = -1
' 
'   HAVE_HIDPAD = true ' Set to false to disable HidPad inteface
	HAVE_HIDPAD = -1
'   HIDPAD_REPORT_SIZE = 7*4 ' do not change!
	HIDPAD_REPORT_SIZE = 28
'   HIDPAD_DEVICES = 4 ' do not change!
	HIDPAD_DEVICES = 4
' 
'   EMUPAD_MAX_PLAYER = 0 ' Set to 0 to disable EmuPad interface
	EMUPAD_MAX_PLAYER = 0
'   EMUPAD_MAX_RULES = 32
	EMUPAD_MAX_RULES = 32
'   EMUPAD_BUILTIN_RULES = false
	EMUPAD_BUILTIN_RULES = 0
'   
'     ' EmuPad report format config
'   EMUPAD_TYPE_NIBBLE = 7
	EMUPAD_TYPE_NIBBLE = 7
'   EMUPAD_TYPE_KBD = 1
	EMUPAD_TYPE_KBD = 1
'   EMUPAD_TYPE_PAD = 2
	EMUPAD_TYPE_PAD = 2
' 
'   EMUPAD_UP_BIT = 0
	EMUPAD_UP_BIT = 0
'   EMUPAD_DOWN_BIT = 1
	EMUPAD_DOWN_BIT = 1
'   EMUPAD_LEFT_BIT = 2
	EMUPAD_LEFT_BIT = 2
'   EMUPAD_RIGHT_BIT = 3
	EMUPAD_RIGHT_BIT = 3
'   EMUPAD_BT0_BIT = 4
	EMUPAD_BT0_BIT = 4
'   EMUPAD_BT1_BIT = 5
	EMUPAD_BT1_BIT = 5
'   EMUPAD_BT2_BIT = 6
	EMUPAD_BT2_BIT = 6
'   EMUPAD_BT3_BIT = 7
	EMUPAD_BT3_BIT = 7
'   EMUPAD_BT4_BIT = 8
	EMUPAD_BT4_BIT = 8
'   EMUPAD_BT5_BIT = 9
	EMUPAD_BT5_BIT = 9
'   EMUPAD_BT6_BIT = 10
	EMUPAD_BT6_BIT = 10
'   EMUPAD_BT7_BIT = 11
	EMUPAD_BT7_BIT = 11
'   EMUPAD_BT8_BIT = 12
	EMUPAD_BT8_BIT = 12
'   EMUPAD_BT9_BIT = 13
	EMUPAD_BT9_BIT = 13
' 
' 
'     ' Computed magic values
'   _EMUPAD_UD_MASK = (decod EMUPAD_UP_BIT) | (decod EMUPAD_DOWN_BIT)
	_EMUPAD_UD_MASK = 3
'   _EMUPAD_LR_MASK = (decod EMUPAD_LEFT_BIT) | (decod EMUPAD_RIGHT_BIT)
	_EMUPAD_LR_MASK = 12
'   _EMUPAD_RULE_SIZE = 10+4+1
	_EMUPAD_RULE_SIZE = 15
' 
'   _HAVE_GAMEPAD = HAVE_HIDPAD || (EMUPAD_MAX_PLAYER > 0)
	_HAVE_GAMEPAD = -1
' 
'   MAX_DEVICES = 7 ' DO. NOT. TOUCH.
	MAX_DEVICES = 7
' '------------------------------------------------------------------------------
' ' Smart pin configuration for "long repository" mode with output enabled,
' ' regardless of DIR. This allows one pin to provide a long event code via IN
' ' and also to control the USB port activity LED on/off state vio OUT.
'     SP_REPO1_MODE = %01_00001_0 | 1 << 16    ' %TT_MMMMM_0, P[12:10] != %101
	SP_REPO1_MODE = 65602
' '------------------------------------------------------------------------------
' ' A simple event/cmd system using a smart pin configured in "long repository"
' ' mode. The USB_EVENT_REPO pin defined above is used to allow the USB cog to
' ' signal the client that a particular event has occurred. The client must poll
' ' this smart pin (testp #USB_EVENT_REPO wc) as often as possible in its "main"
' ' loop and process the event IDs you're interested in.
' '------------------------------------------------------------------------------
'     #0, NO_EVENT, USB_ERROR, DEV_UNKNOWN, KB_READY, M_READY, KBM_READY, HID_READY
	NO_EVENT = 0
	USB_ERROR = 1
	DEV_UNKNOWN = 2
	KB_READY = 3
	M_READY = 4
	KBM_READY = 5
	HID_READY = 6
'     XINPUT_READY, PS3_READY, HUB_READY, DEV_DISCONNECT, DBG_DATA, M_DATA, GP_DATA
	XINPUT_READY = 7
	PS3_READY = 8
	HUB_READY = 9
	DEV_DISCONNECT = 10
	DBG_DATA = 11
	M_DATA = 12
	GP_DATA = 13
'     CMD_SUSPEND, CMD_RESUME, CMD_RESET
	CMD_SUSPEND = 14
	CMD_RESUME = 15
	CMD_RESET = 16
' '------------------------------------------------------------------------------
' ' The CMD_* tokens are asynchronous USB commands available to the user, through
' ' the Spin2 usbCommand method of this object. This method will post the cmd
' ' token to the host and when the cmd is complete the host will post the CMD_*
' ' token to byte[0] of the event long. Byte[1] is typically set to one of the
' ' below protocol error codes, with bytes[2..3] available for additional cmd data.
' '------------------------------------------------------------------------------
' ' Protocol error codes:
'     #0, ERR_NONE, ERR_CMD, ERR_URX, ERR_SE1, ERR_PACKET, ERR_TAT, ERR_TXN_RETRY
	ERR_NONE = 0
	ERR_CMD = 1
	ERR_URX = 2
	ERR_SE1 = 3
	ERR_PACKET = 4
	ERR_TAT = 5
	ERR_TXN_RETRY = 6
'     ERR_XFER_RETRY, ERR_NAK, ERR_DATAX_SYNC, ERR_CONFIG_FAIL, ERR_TIMEOUT
	ERR_XFER_RETRY = 7
	ERR_NAK = 8
	ERR_DATAX_SYNC = 9
	ERR_CONFIG_FAIL = 10
	ERR_TIMEOUT = 11
' '------------------------------------------------------------------------------
' ' Keyboard LED output report toggle key bit postions:
'     #0, LED_NUMLKB, LED_CAPSLKB, LED_SCRLKB, LED_COMPOSEB
	LED_NUMLKB = 0
	LED_CAPSLKB = 1
	LED_SCRLKB = 2
	LED_COMPOSEB = 3
'     LED_KANAB, LED_CONST0B, LED_CONST1B, LED_CONST2B
	LED_KANAB = 4
	LED_CONST0B = 5
	LED_CONST1B = 6
	LED_CONST2B = 7
' ' Keyboard LED output report toggle key bitflags:
'     LED_NUMLKF   = decod(LED_NUMLKB)
	LED_NUMLKF = 1
'     LED_CAPSLKF  = decod(LED_CAPSLKB)
	LED_CAPSLKF = 2
'     LED_SCRLKF   = decod(LED_SCRLKB)
	LED_SCRLKF = 4
'     LED_COMPOSEF = decod(LED_COMPOSEB)
	LED_COMPOSEF = 8
'     LED_KANAF    = decod(LED_KANAB)
	LED_KANAF = 16
'     LED_CONST0F  = decod(LED_CONST0B)
	LED_CONST0F = 32
'     LED_CONST1F  = decod(LED_CONST1B)
	LED_CONST1F = 64
'     LED_CONST2F  = decod(LED_CONST2B)
	LED_CONST2F = 128
' ' Keyboard modifier key bit positions:
'     #0, LEFT_CTRLB, LEFT_SHIFTB, LEFT_ALTB, LEFT_GUIB
	LEFT_CTRLB = 0
	LEFT_SHIFTB = 1
	LEFT_ALTB = 2
	LEFT_GUIB = 3
'     RIGHT_CTRLB, RIGHT_SHIFTB, RIGHT_ALTB, RIGHT_GUIB
	RIGHT_CTRLB = 4
	RIGHT_SHIFTB = 5
	RIGHT_ALTB = 6
	RIGHT_GUIB = 7
' ' Keyboard modifier bitflags
'     LEFT_CTRLF   = decod(LEFT_CTRLB)
	LEFT_CTRLF = 1
'     LEFT_SHIFTF  = decod(LEFT_SHIFTB)
	LEFT_SHIFTF = 2
'     LEFT_ALTF    = decod(LEFT_ALTB)
	LEFT_ALTF = 4
'     LEFT_GUIF    = decod(LEFT_GUIB)
	LEFT_GUIF = 8
'     RIGHT_CTRLF  = decod(RIGHT_CTRLB)
	RIGHT_CTRLF = 16
'     RIGHT_SHIFTF = decod(RIGHT_SHIFTB)
	RIGHT_SHIFTF = 32
'     RIGHT_ALTF   = decod(RIGHT_ALTB)
	RIGHT_ALTF = 64
'     RIGHT_GUIF   = decod(RIGHT_GUIB)
	RIGHT_GUIF = 128
' ' Consolidated left/right modkeys. Add the modifier keys you want to trap
' ' together, then add the key scan code e.g. CTRL+ALT+"X" would be: $600 + KEY_X_x.
' ' The key() Spin2 method does this and the rawKey() method returns the key data
' ' as packed by the USB keyboard driver.
' '   SHIFT = $100
' '   CTRL  = $200
' '   ALT   = $400
' '   APP   = $800
' ' L|R key modifier flag combinations:
'     KEYS_APP   = LEFT_GUIF + RIGHT_GUIF
	KEYS_APP = 136
'     KEYS_ALT   = LEFT_ALTF + RIGHT_ALTF
	KEYS_ALT = 68
'     KEYS_CTRL  = LEFT_CTRLF + RIGHT_CTRLF
	KEYS_CTRL = 17
'     KEYS_SHIFT = LEFT_SHIFTF + RIGHT_SHIFTF
	KEYS_SHIFT = 34
' '------------------------------------------------------------------------------
'     _1thou         = 1_000
	_1thou = 1000
'     _1m            = 1_000_000
	_1m = 1000000
'     _1b            = 1_000_000_000
	_1b = 1000000000
'     _12m           = 12_000_000
	_12m = 12000000
'     LSBTns         = 672.0                  ' Low-Speed bit period, in nanoseconds
	LSBTns = 1143472128
'     FSBTns         = 83.54                  ' Full-Speed bit period, in nanoseconds
	FSBTns = 1118246011
'     LSBTns4        = round(LSBTns * 4.0)    ' Low-Speed inter-packet delay, in nanoseconds
	LSBTns4 = 2688
'     LSBTns22       = round(LSBTns * 22.0)   ' Low-Speed turnaround wait time, in nanoseconds
	LSBTns22 = 14784
'     FSBTns4        = round(FSBTns * 4.0)    ' Full-Speed inter-packet delay, in nanoseconds
	FSBTns4 = 334
'     FSBTns28       = round(FSBTns * 28.0)   ' Full-Speed turnaround wait time, in nanoseconds
	FSBTns28 = 2339
' ' NCO baud calculations for low-speed/full-speed:
' '        _1_5Mbps  = round(1_500_000.0 / _FCLKFREQ * 65536.0)  ' = NCO 492 @200MHz, 614 @160
' '        _12Mbps   = round(12_000_000.0 / _FCLKFREQ * 65536.0) ' = NCO 3932 @200MHz, 4915 @160
' ' To configure RevA silicon LS/FS NCO baud: (WXPIN _1_5Mbps, D-) or (WXPIN _12Mbps, D-)
' ' To configure RevA LS/FS host/device: WRPIN appropriate LS/FS mode to D- (lower) and D+ (upper) pins:
'     USB_V1HMODE_LS = %1_11000_0 + 1 << 16   ' Host mode
	USB_V1HMODE_LS = 65648
'     USB_V1DMODE_LS = %1_11010_0 + 1 << 16   ' Device mode
	USB_V1DMODE_LS = 65652
'     USB_V1HMODE_FS = %1_11001_0 + 1 << 16
	USB_V1HMODE_FS = 65650
'     USB_V1DMODE_FS = %1_11011_0 + 1 << 16
	USB_V1DMODE_FS = 65654
' ' On RevB+ the USB smart pin mode is set to the D- and D+ pins via (WRPIN USBMode, pin#):
'     USB_V2_DRVOUT  = %1_11011_0 + 1 << 16
	USB_V2_DRVOUT = 65654
'     USB_V2_SNIFF   = %0_11011_0 + 1 << 16   ' Disable output to create a USB "sniffer"
	USB_V2_SNIFF = 65590
' ' To configure NCO baud, host/device for LS/FS, set the appropriate mode to the D- pin# (WXPIN NCOMode, D-)
' '   USB_H_LS_NCO   = %10 << 14 + _1_5Mbps   ' Host mode at NCO baud
' '   USB_D_LS_NCO   = %00 << 14 + _1_5Mbps   ' Device mode at NCO baud
' '   USB_H_FS_NCO   = %11 << 14 + _12Mbps
' '   USB_D_FS_NCO   = %01 << 14 + _12Mbps
' '------------------------------------------------------------------------------
' ' Time delays and intervals
' ' Useful USB constants and wait intervals:
'     XFER_RETRIES    = 12                    ' Maximum retries before retiring a transfer
	XFER_RETRIES = 12
'     TXN_RETRIES     = 12                    ' Maximum retries before retiring a transaction
	TXN_RETRIES = 12
'     NAK_NOLIMIT     = 0                     ' Unlimited NAK retries
	NAK_NOLIMIT = 0
'     IN_NAK_RETRIES  = 50000                 ' Control transfer IN-NAK retry limit (0 = unlimited)
	IN_NAK_RETRIES = 50000
'     OUT_NAK_RETRIES = 50000                 ' Control transfer OUT-NAK retry limit (0 = unlimited)
	OUT_NAK_RETRIES = 50000
' ' Standard Device request maximum timeout periods (reference):
' {
' }
' '------------------------------------------------------------------------------
' ' Token packet format.
' '------------------------------------------------------------------------------
' '                   CRC5  ENDP ADDRESS PID
'     CRC_MASK     = %11111_0000_0000000_00000000
	CRC_MASK = 16252928
'     EP_MASK      = %00000_1111_0000000_00000000
	EP_MASK = 491520
'     ADDR_MASK    = %00000_0000_1111111_00000000
	ADDR_MASK = 32512
'     EP_ADDR_MASK = %00000_1111_1111111_11111111
	EP_ADDR_MASK = 524287
'     EP_ADDR_ZERO = %00010_0000_0000000_00000000     ' CRC5 = $02 for addr zero, ep zero
	EP_ADDR_ZERO = 1048576
' '------------------------------------------------------------------------------
' ' Packet Identifier Bytes (PID). Notice that the first two LSBits are
' ' identical for each group.
' '------------------------------------------------------------------------------
' ' Token:
'     PID_OUT   = %1110_0001                  ' $e1
	PID_OUT = 225
'     PID_IN    = %0110_1001                  ' $69
	PID_IN = 105
'     PID_SOF   = %1010_0101                  ' $a5
	PID_SOF = 165
'     PID_SETUP = %0010_1101                  ' $2d
	PID_SETUP = 45
' ' Data:
'     PID_DATA0 = %1100_0011                  ' $c3
	PID_DATA0 = 195
'     PID_DATA1 = %0100_1011                  ' $4b
	PID_DATA1 = 75
'     PID_DATA2 = %1000_0111                  ' $87
	PID_DATA2 = 135
'     PID_MDATA = %0000_1111                  ' $0f
	PID_MDATA = 15
' ' Handshake:
'     PID_ACK   = %1101_0010                  ' $d2
	PID_ACK = 210
'     PID_NAK   = %0101_1010                  ' $5a
	PID_NAK = 90
'     PID_STALL = %0001_1110                  ' $1e
	PID_STALL = 30
'     PID_NYET  = %1001_0110                  ' $96
	PID_NYET = 150
' ' Special:
'     PID_PRE   = %0011_1100                  ' $3c
	PID_PRE = 60
'     PID_ERR   = %0011_1100                  ' $3c
	PID_ERR = 60
'     PID_SPLIT = %0111_1000                  ' $78
	PID_SPLIT = 120
'     PID_PING  = %1011_0100                  ' $b4
	PID_PING = 180
'     PID_RESVD = %1111_0000                  ' $f0
	PID_RESVD = 240
' ' Tx, rx and host related constants
' ' USB transmitter WYPIN D line state options:
'     OUT_IDLE = 0
	OUT_IDLE = 0
'     OUT_SE0  = 1
	OUT_SE0 = 1
'     OUT_K    = 2
	OUT_K = 2
'     OUT_J    = 3
	OUT_J = 3
'     OUT_EOP  = 4
	OUT_EOP = 4
'     OUT_SOP  = $80
	OUT_SOP = 128
' ' USB receiver RDPIN status bit positions:
'     #0, J_IDLEB, K_RESUMEB, SE0_RESETB, SE1_BADB, SOPB, EOPB, BUS_ERRB, BYTE_TGLB
	J_IDLEB = 0
	K_RESUMEB = 1
	SE0_RESETB = 2
	SE1_BADB = 3
	SOPB = 4
	EOPB = 5
	BUS_ERRB = 6
	BYTE_TGLB = 7
' ' USB receiver RDPIN status bitflags:
'     J_IDLEF    = decod(J_IDLEB)
	J_IDLEF = 1
'     K_RESUMEF  = decod(K_RESUMEB)
	K_RESUMEF = 2
'     SE0_RESETF = decod(SE0_RESETB)
	SE0_RESETF = 4
'     SE1_BADF   = decod(SE1_BADB)
	SE1_BADF = 8
'     SOPF       = decod(SOPB)
	SOPF = 16
'     EOPF       = decod(EOPB)
	EOPF = 32
'     BUS_ERRF   = decod(BUS_ERRB)
	BUS_ERRF = 64
'     BYTE_TGLF  = decod(BYTE_TGLB)
	BYTE_TGLF = 128
' ' USB CRC constants:
'     USB5_POLY      = %0_0101 rev (5 - 1)    ' USB5 polynomial is reflected when calculating CRC
	USB5_POLY = 20
'     USB5_RESIDUAL  = %0_1100 rev (5 - 1)    ' Expected CRC5 residual value when checking received data
	USB5_RESIDUAL = 6
'     USB16_POLY     = $8005 rev (16 - 1)     ' USB16 polynomial is reflected when calculating CRC
	USB16_POLY = 40961
'     USB16_RESIDUAL = $800d rev (16 - 1)     ' Expected CRC16 residual value when checking received data
	USB16_RESIDUAL = 45057
' ' Host->class driver USB connect speed:
'     #0, USB_SPEED_UNKNOWN, USB_SPEED_LOW, USB_SPEED_FULL
	USB_SPEED_UNKNOWN = 0
	USB_SPEED_LOW = 1
	USB_SPEED_FULL = 2
' ' Host status bit positions. Bit4 and bit5 use the receiver status constants for SOP and EOP:
'     #0, IDLEB, CONNECTEDB, LOW_SPEEDB, DATAx_TGLB[4], DWNSTRM_HUBB, SUSPENDB, KBM_TOGGLEB
	IDLEB = 0
	CONNECTEDB = 1
	LOW_SPEEDB = 2
	DATAx_TGLB = 3
	DWNSTRM_HUBB = 7
	SUSPENDB = 8
	KBM_TOGGLEB = 9
' ' Host status bitflags. Unless otherwise noted, bit states are active high:
'     IDLEF        = decod(IDLEB)             ' Set when USB in idle state
	IDLEF = 1
'     CONNECTEDF   = decod(CONNECTEDB)        ' USB device connected
	CONNECTEDF = 2
'     LOW_SPEEDF   = decod(LOW_SPEEDB)        ' Low-speed device connected, clear if full-speed
	LOW_SPEEDF = 4
'     DATAx_TGLF   = decod(DATAx_TGLB)        ' Cleared if sending DATA0 packet, set if sending DATA1 packet
	DATAx_TGLF = 8
' '   EOPF         = decod(EOPB)              ' Same bit position as the USB rx RDPIN status constants defined above
' '   BUS_ERRF     = decod(BUS_ERRB)          ' Same bit position as the USB rx RDPIN status constants defined above
' '   BYTE_TGLF    = decod(BYTE_TGLB)         ' Same bit position as the USB rx RDPIN status constants defined above
'     DWNSTRM_HUBF = decod(DWNSTRM_HUBB)      ' NYI: downstream hub(s) connected
	DWNSTRM_HUBF = 128
'     SUSPENDF     = decod(SUSPENDB)          ' NYI: command the host to signal a global suspend
	SUSPENDF = 256
' '------------------------------------------------------------------------------
' ' USB References:
' ' Universal Serial Bus Specification, Revision 2.0
' '   www.usb.org/developers/docs/usb20_docs/
' ' Device Class Definition for Human Interface Devices (HID), Version 1.11
' '   www.usb.org/developers/hidpage/
' '------------------------------------------------------------------------------
' ' SETUP packet bmRequestType bit groups (Section 9.3.1, Table 9-2).
' ' Use TYPE_STANDARD for all USB Standard Device Request codes.
' '------------------------------------------------------------------------------
' ' D7 Data direction  | D6:5 Type    | D4:0 Recipient
' '------------------------------------------------------------------------------
' ' 0 - Host-to-device | 0 = Standard | 0 = Device
' ' 1 - Device-to-host | 1 = Class    | 1 = Interface
' '                    | 2 = Vendor   | 2 = Endpoint
' '                    | 3 = Reserved | 3 = Other
' '                    |              | 4 -31 = Reserved
' '------------------------------------------------------------------------------
'     DIR_HOST_TO_DEV = 0 << 7
	DIR_HOST_TO_DEV = 0
'     DIR_DEV_TO_HOST = 1 << 7                ' D7 Data direction
	DIR_DEV_TO_HOST = 128
'     TYPE_STANDARD   = %00 << 5              ' D6:D5 Type (use Standard for all USB Standard Device Requests
	TYPE_STANDARD = 0
'     TYPE_CLASS      = %01 << 5
	TYPE_CLASS = 32
'     TYPE_VENDOR     = %10 << 5
	TYPE_VENDOR = 64
'     TYPE_RESERVED   = %11 << 5
	TYPE_RESERVED = 96
'     RECIP_DEVICE    = %0_0000               ' D4..D0 Recipient
	RECIP_DEVICE = 0
'     RECIP_INTERFACE = %0_0001
	RECIP_INTERFACE = 1
'     RECIP_ENDPOINT  = %0_0010
	RECIP_ENDPOINT = 2
'     RECIP_OTHER     = %0_0011
	RECIP_OTHER = 3
' '    RECIP 4 - 31 = Reserved
' '------------------------------------------------------------------------------
' ' Standard Device Request codes (Section 9.4, Table 9-4):
' '------------------------------------------------------------------------------
'     #$00, REQ_GET_STATUS, REQ_CLEAR_FEATURE, REQ_RESERVED_1, REQ_SET_FEATURE
	REQ_GET_STATUS = 0
	REQ_CLEAR_FEATURE = 1
	REQ_RESERVED_1 = 2
	REQ_SET_FEATURE = 3
'     REQ_RESERVED2, REQ_SET_ADDR, REQ_GET_DESC, REQ_SET_DESC, REQ_GET_CONFIG
	REQ_RESERVED2 = 4
	REQ_SET_ADDR = 5
	REQ_GET_DESC = 6
	REQ_SET_DESC = 7
	REQ_GET_CONFIG = 8
'     REQ_SET_CONFIG, REQ_GET_INTF, REQ_SET_INTF, REQ_SYNC_FRAME
	REQ_SET_CONFIG = 9
	REQ_GET_INTF = 10
	REQ_SET_INTF = 11
	REQ_SYNC_FRAME = 12
' '------------------------------------------------------------------------------
' ' Standard descriptor types (Section 9.4, Table 9-5):
' '------------------------------------------------------------------------------
'     #$01, TYPE_DEVICE, TYPE_CONFIG, TYPE_STRING, TYPE_INTERFACE, TYPE_ENDPOINT
	TYPE_DEVICE = 1
	TYPE_CONFIG = 2
	TYPE_STRING = 3
	TYPE_INTERFACE = 4
	TYPE_ENDPOINT = 5
'     TYPE_QUALIFIER, TYPE_OTHER_SPEED, TYPE_INTERFACE_PWR, TYPE_OTG
	TYPE_QUALIFIER = 6
	TYPE_OTHER_SPEED = 7
	TYPE_INTERFACE_PWR = 8
	TYPE_OTG = 9
' '------------------------------------------------------------------------------
' ' Device/Interface Class Codes (full list at www.usb.org/developers/defined_class):
' '------------------------------------------------------------------------------
'     #$00, CLASS_INFO_INTF, CLASS_AUDIO, CLASS_COMM, CLASS_HID, CLASS_UNDEF0
	CLASS_INFO_INTF = 0
	CLASS_AUDIO = 1
	CLASS_COMM = 2
	CLASS_HID = 3
	CLASS_UNDEF0 = 4
'     CLASS_PHYSICAL, CLASS_IMAGE, CLASS_PRINTER, CLASS_MASS_STORAGE, CLASS_HUB
	CLASS_PHYSICAL = 5
	CLASS_IMAGE = 6
	CLASS_PRINTER = 7
	CLASS_MASS_STORAGE = 8
	CLASS_HUB = 9
'     CLASS_CDC_DATA, CLASS_SMARTCARD, CLASS_UNDEF1, CLASS_CONT_SECURITY, CLASS_VIDEO
	CLASS_CDC_DATA = 10
	CLASS_SMARTCARD = 11
	CLASS_UNDEF1 = 12
	CLASS_CONT_SECURITY = 13
	CLASS_VIDEO = 14
'     CLASS_HEALTH, CLASS_AUDIO_VIDEO, CLASS_BILLBOARD, CLASS_TYPE_C_BRIDGE
	CLASS_HEALTH = 15
	CLASS_AUDIO_VIDEO = 16
	CLASS_BILLBOARD = 17
	CLASS_TYPE_C_BRIDGE = 18
'     CLASS_DIAGNOSTIC_DEV  = $dc
	CLASS_DIAGNOSTIC_DEV = 220
'     CLASS_WIRELESS_CTRL   = $e0
	CLASS_WIRELESS_CTRL = 224
'     CLASS_MISCELLANEOUS   = $ef
	CLASS_MISCELLANEOUS = 239
'     CLASS_APP_SPECIFIC    = $fe
	CLASS_APP_SPECIFIC = 254
'     CLASS_VENDOR_SPECIFIC = $ff
	CLASS_VENDOR_SPECIFIC = 255
' '------------------------------------------------------------------------------
' ' HUB Class Requests
' '------------------------------------------------------------------------------
'     #0, HUB_PORT_CONNECTION, HUB_PORT_ENABLE, HUB_PORT_SUSPEND, HUB_PORT_OVERCURRENT
	HUB_PORT_CONNECTION = 0
	HUB_PORT_ENABLE = 1
	HUB_PORT_SUSPEND = 2
	HUB_PORT_OVERCURRENT = 3
'     HUB_PORT_RESET[4], HUB_PORT_POWER, HUB_PORT_LOWSPEED[7]
	HUB_PORT_RESET = 4
	HUB_PORT_POWER = 8
	HUB_PORT_LOWSPEED = 9
'     HUB_C_PORT_CONNECTION, HUB_C_PORT_ENABLE, HUB_C_PORT_SUSPEND, HUB_C_PORT_OVERCURRENT
	HUB_C_PORT_CONNECTION = 16
	HUB_C_PORT_ENABLE = 17
	HUB_C_PORT_SUSPEND = 18
	HUB_C_PORT_OVERCURRENT = 19
'     HUB_C_PORT_RESET, HUB_PORT_TEST, HUB_PORT_INDICATOR
	HUB_C_PORT_RESET = 20
	HUB_PORT_TEST = 21
	HUB_PORT_INDICATOR = 22
' '------------------------------------------------------------------------------
' ' HID Class Requests (v1.11 HID Device Class Definition, Section 7.2):
' '------------------------------------------------------------------------------
'     #$01, HID_GET_REPORT, HID_GET_IDLE, HID_GET_PROTO[6] ' $04 - $08 reserved
	HID_GET_REPORT = 1
	HID_GET_IDLE = 2
	HID_GET_PROTO = 3
'     HID_SET_REPORT, HID_SET_IDLE, HID_SET_PROTO
	HID_SET_REPORT = 9
	HID_SET_IDLE = 10
	HID_SET_PROTO = 11
' ' HID Descriptor types:
'     #$21, TYPE_HID, TYPE_REPORT, TYPE_PHYSICAL ' HID types $24 - $2f are reserved
	TYPE_HID = 33
	TYPE_REPORT = 34
	TYPE_PHYSICAL = 35
'     #$29, TYPE_HUB
	TYPE_HUB = 41
' '------------------------------------------------------------------------------
' ' HID report types (v1.11 HID Device Class Definition, Section 7.2.1):
' '------------------------------------------------------------------------------
'     #$01, TYPE_INPUT, TYPE_OUTPUT, TYPE_FEATURE ' $04 - $ff are reserved
	TYPE_INPUT = 1
	TYPE_OUTPUT = 2
	TYPE_FEATURE = 3
' '------------------------------------------------------------------------------
' ' HID Interface SubClasses:
' '------------------------------------------------------------------------------
'     #$00, SUBCLASS_INTF_NONE, SUBCLASS_INTF_BOOT
	SUBCLASS_INTF_NONE = 0
	SUBCLASS_INTF_BOOT = 1
' '------------------------------------------------------------------------------
' ' HID Protocol codes:
' '------------------------------------------------------------------------------
'     #$00, INTF_PROTO_NONE, INTF_PROTO_KBD, INTF_PROTO_MOUSE
	INTF_PROTO_NONE = 0
	INTF_PROTO_KBD = 1
	INTF_PROTO_MOUSE = 2
'     #$00, BOOT_PROTOCOL, REPORT_PROTOCOL
	BOOT_PROTOCOL = 0
	REPORT_PROTOCOL = 1
' '------------------------------------------------------------------------------
' ' Other HID buffer lengths:
' '------------------------------------------------------------------------------
'     MAX_HID_REPTS   = 4             ' We have this many HID report buffers
	MAX_HID_REPTS = 4
'     REPT_BUFF_LEN   = 1024          ' HID reports can be quite large
	REPT_BUFF_LEN = 1024
'     REPT_STRUCT_LEN = REPT_BUFF_LEN + 2 ' Struct is wLength, bData[REPT_BUFF_LEN]
	REPT_STRUCT_LEN = 1026
'     LANG_BUFF_LEN   = 128           ' LangID array buffer (in bytes)
	LANG_BUFF_LEN = 128
'     USTR_BUFF_LEN   = 128           ' Unicode string buffer (in bytes)
	USTR_BUFF_LEN = 128
' '------------------------------------------------------------------------------
' ' USB-IF defined language IDs (http://www.usb.org/developers/docs.html)
' '------------------------------------------------------------------------------
'     LANG_ENG_US  = $0409            ' English (United States)
	LANG_ENG_US = 1033
'     LOCAL_LANGID = LANG_ENG_US      ' Set your default langID here
	LOCAL_LANGID = 1033
' '------------------------------------------------------------------------------
' ' SETUP structure member offsets.
' ' NOTE: These offsets are defined in terms of the structure member's data type,
' '       to take advantage of PTRA/B scaled indexing, e.g.:
' '         RDBYTE D,   PTRA[bRequest]
' '         WRWORD D/#, PTRA[wLength]
' '------------------------------------------------------------------------------
'     bmRequestType = 0
	bmRequestType = 0
'     bRequest      = 1
	bRequest = 1
'     wValue        = 1
	wValue = 1
'     wIndex        = 2
	wIndex = 2
'     wLength       = 3
	wLength = 3
' ' SETUP bmRequestType combinations:
' {
' }
' '------------------------------------------------------------------------------
' ' Standard USB descriptor structure sizes in bytes. The values defined are the
' ' minimum size of the descriptor:
' '------------------------------------------------------------------------------
'     SETUP_TXN_LEN = 8
	SETUP_TXN_LEN = 8
'     DEV_DESC_LEN  = 18
	DEV_DESC_LEN = 18
'     CON_DESC_LEN  = 9
	CON_DESC_LEN = 9
'     INTF_DESC_LEN = 9
	INTF_DESC_LEN = 9
'     ENDP_DESC_LEN = 7
	ENDP_DESC_LEN = 7
'     STR0_DESC_LEN = 4
	STR0_DESC_LEN = 4
'     USTR_DESC_LEN = 4
	USTR_DESC_LEN = 4
' '------------------------------------------------------------------------------
' ' Other USB-related buffer sizes:
' '------------------------------------------------------------------------------
'     URX_BUFF_LEN = 128      ' USB receiver scratch buffer
	URX_BUFF_LEN = 128
'     CON_BUFF_LEN = 256      ' Entire configuration descriptor chain
	CON_BUFF_LEN = 256
' '------------------------------------------------------------------------------
' ' CON_bmAttrs member bit positions:
' '------------------------------------------------------------------------------
'     ATTR_RESVB     = 7      ' Reserved (should always be one)
	ATTR_RESVB = 7
'     ATTR_SELF_PWRB = 6      ' Device Self-Powered
	ATTR_SELF_PWRB = 6
'     ATTR_RMT_WAKEB = 5      ' Supports remote wakeup
	ATTR_RMT_WAKEB = 5
' '    bmAttributes bits 4..0 reserved and reset to zero
' '------------------------------------------------------------------------------
' ' Standard USB descriptor struct member offset and member size, in bytes. Note
' ' that the DESC_bLength and DESC_bDescType members are defined in all of the
' ' descriptors (including HID) at the offsets shown.
' '------------------+
' ' !!! IMPORTANT !!!|
' '------------------+
' ' All standard descriptor member offsets are defined in bytes, so if you want
' ' to use PTRA/B indexing for WORD or LONG data, the unscaled PTRx[##index20]
' ' syntax should be used and the compiler will invoke AUGS with RDxxxx/WRxxxx,
' ' e.g.: RDBYTE D,   PTRA[DEV_bMaxPktSize0] is OK when it's a byte member
' '       WRWORD D/#, PTRA[##DEV_bIdProduct] use unscaled if member is word/long.
' ' If PTRA/B unscaled indexing is used with pre/post increment/decrement, one
' ' must be very careful...
' '------------------------------------------------------------------------------
' '       Member          Offset  Size    Value           Description
' '------------------------------------------------------------------------------
'     DESC_bLength     = 0    ' 1     Number          Minimum size of this descriptor in bytes
	DESC_bLength = 0
'     DESC_bDescType   = 1    ' 1     Constant        TYPE_DEVICE
	DESC_bDescType = 1
' ' Device Descriptor (Section 9.6.1, Table 9-8):
'     DEV_bcdUSB       = 2    ' 2     BCD             e.g., 2.10 is $0210
	DEV_bcdUSB = 2
'     DEV_bDevClass    = 4    ' 1     Class           Class code assigned by USB-IF.
	DEV_bDevClass = 4
'     DEV_bDevSubClass = 5    ' 1     SubClass        SubClass Code assigned by USB-IF.
	DEV_bDevSubClass = 5
'     DEV_bProtocol    = 6    ' 1     Protocol        Protocol Code assigned by USB-IF.
	DEV_bProtocol = 6
'     DEV_bMaxPktSize0 = 7    ' 1     Number          Max packet size for endpoint 0. Must be 8 for LS, 16, 32 or 64 for FS.
	DEV_bMaxPktSize0 = 7
'     DEV_idVendor     = 8    ' 2     ID              Vendor ID - must be obtained from USB-IF.
	DEV_idVendor = 8
'     DEV_idProduct    = 10   ' 2     ID              PRoduct ID - must be obtained from USB-IF.
	DEV_idProduct = 10
'     DEV_bcdDevice    = 12   ' 2     BCD             Device release number in BCD.
	DEV_bcdDevice = 12
'     DEV_iMfg         = 14   ' 1     Index           Index of string descriptor describing manufacturer - set to zero if no string.
	DEV_iMfg = 14
'     DEV_iProduct     = 15   ' 1     Index           Index of string descriptor describing product - set to zero if no string.
	DEV_iProduct = 15
'     DEV_iSerialNum   = 16   ' 1     Index           Index of string descriptor describing device serial number - set to zero if no string.
	DEV_iSerialNum = 16
'     DEV_iNumConfigs  = 17   ' 1     Number          Number of possible configurations.
	DEV_iNumConfigs = 17
'   ' Configuration Descriptor (Section 9.6.3, Table 9-10):
' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_CONFIG
'     CON_wTotalLen    = 2    ' 2     Number          See Section 9.6.3, Table 9-10.
	CON_wTotalLen = 2
'     CON_bNumIntf     = 4    ' 1     Number          Number of interfaces supported by this configuration.
	CON_bNumIntf = 4
'     CON_bConfigVal   = 5    ' 1     Number          Value to use as an argument to the SetConfiguration() request to select this configuration.
	CON_bConfigVal = 5
'     CON_iConfig      = 6    ' 1     Index           Index of string descriptor describing this configuration.
	CON_iConfig = 6
'     CON_bmAttrs      = 7    ' 1     Bitmap          See Table 9-10.
	CON_bmAttrs = 7
'     CON_bMaxPower    = 8    ' 1     mA              Expressed in 2MA units (i.e. 50 = 100 mA)
	CON_bMaxPower = 8
' ' Interface Descriptor (Section 9.6.5, Table 9-12):
' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_INTERFACE
'     INTF_bIntfNum    = 2    ' 1     Number          See Table 9-12.
	INTF_bIntfNum = 2
'     INTF_bAltSetting = 3    ' 1     Number          Value used to select this alternate setting for the interface identified in the prior field.
	INTF_bAltSetting = 3
'     INTF_bNumEndpts  = 4    ' 1     Number          See Table 9-12.
	INTF_bNumEndpts = 4
'     INTF_bIntfClass  = 5    ' 1     Class           Class code (assigned by USB-IF). If this field is 0xFF, the interface class is vendor-specific.
	INTF_bIntfClass = 5
'     INTF_bSubClass   = 6    ' 1     SubClass        Subclass code (assigned by USB-IF). These codes are qualified by the value of the
	INTF_bSubClass = 6
'                             '                       bIntfClass field. If the bInterfaceClass field is not set to 0xFF, all values are
'                             '                       reserved for assignment by the USB-IF.
'     INTF_bProtocol   = 7    ' 1     Protocol        Protocol code (assigned by the USB). These codes are qualified by the value of the
	INTF_bProtocol = 7
'                             '                       bIntfClass and the bSubClass fields. If this field is set to 0xFF, the device uses a
'                             '                       vendor-specific protocol for this interface.
'     INTF_iInterface  = 8    ' 1     Index           Index of string descriptor describing this interface.
	INTF_iInterface = 8
' ' Endpoint Descriptor (Section 9.6.6, Table 9-13):
' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_ENDPOINT
'     ENDP_bAddress    = 2    ' 1     Endpoint        See table 9-13.
	ENDP_bAddress = 2
'     ENDP_bmAttrs     = 3    ' 1     Bitmap
	ENDP_bmAttrs = 3
'     ENDP_wMaxPktSize = 4    ' 2     Number
	ENDP_wMaxPktSize = 4
'     ENDP_bInterval   = 6    ' 1     Number
	ENDP_bInterval = 6
' ' String Descriptor Zero (Section 9.6.7, Table 9-15):
' '    DESC_bLength     = 0    ' 1     N + 2
' '    DESC_bDescType   = 1    ' 1     Constant
'     STR0_wLangID     = 2    ' N     LangID[(N - 2) / 2]
	STR0_wLangID = 2
' ' Unicode String Descriptor (Section 9.6.7, Table 9-16):
' '    DESC_bLength     = 0    ' 1     N + 2
' '    DESC_bDescType   = 1    ' 1     Constant
'     USTR_wString     = 2    ' N     wString[(N - 2) / 2]
	USTR_wString = 2
' '------------------------------------------------------------------------------
' ' HID Descriptor (Section 6.2.1)
' '------------------------------------------------------------------------------
' '    DESC_bLength     = 0    ' 1     Number          Minimum size of the descriptor, in bytes
' '    DESC_bDescType   = 1    ' 1     Constant        TYPE_HID
'     HID_bcdHID       = 2    ' 2     BCD             e.g., 1.10 is $0110
	HID_bcdHID = 2
'     HID_bCountryCode = 4    ' 1     Number          Hardware target country
	HID_bCountryCode = 4
'     HID_bNumDesc     = 5    ' 1     Number          Number of HID class descriptors to follow, always at least one.
	HID_bNumDesc = 5
'     HID_bDescType    = 6    ' 1     Constant        Type of HID class descriptor e.g. TYPE_REPORT ($22).
	HID_bDescType = 6
'     HID_wDescLength  = 7    ' 2     Number          Total length of descriptor(s).
	HID_wDescLength = 7
' 
' ' HID Report Items from HID 1.11 Section 6.2.2
'     HID_USAGE_PAGE      = $04
	HID_USAGE_PAGE = 4
'     HID_USAGE           = $08
	HID_USAGE = 8
'     HID_COLLECTION      = $A0
	HID_COLLECTION = 160
'     HID_END_COLLECTION  = $C0
	HID_END_COLLECTION = 192
'     HID_REPORT_COUNT    = $94
	HID_REPORT_COUNT = 148
'     HID_REPORT_SIZE     = $74
	HID_REPORT_SIZE = 116
'     HID_USAGE_MIN       = $18
	HID_USAGE_MIN = 24
'     HID_USAGE_MAX       = $28
	HID_USAGE_MAX = 40
'     HID_LOGICAL_MIN     = $14
	HID_LOGICAL_MIN = 20
'     HID_LOGICAL_MAX     = $24
	HID_LOGICAL_MAX = 36
'     HID_PHYSICAL_MIN    = $34
	HID_PHYSICAL_MIN = 52
'     HID_PHYSICAL_MAX    = $44
	HID_PHYSICAL_MAX = 68
'     HID_INPUT           = $80
	HID_INPUT = 128
'     HID_REPORT_ID       = $84
	HID_REPORT_ID = 132
'     HID_OUTPUT          = $90
	HID_OUTPUT = 144
' 
' ' HID Report Usage Pages from HID Usage Tables 1.12 Section 3, Table 1
'     HID_USAGE_PAGE_GENERIC_DESKTOP = $01
	HID_USAGE_PAGE_GENERIC_DESKTOP = 1
'     HID_USAGE_PAGE_KEY_CODES       = $07
	HID_USAGE_PAGE_KEY_CODES = 7
'     HID_USAGE_PAGE_LEDS            = $08
	HID_USAGE_PAGE_LEDS = 8
'     HID_USAGE_PAGE_BUTTONS         = $09
	HID_USAGE_PAGE_BUTTONS = 9
' 
' ' HID Report Usages from HID Usage Tables 1.12 Section 4, Table 6
'     HID_USAGE_POINTER   = $01
	HID_USAGE_POINTER = 1
'     HID_USAGE_MOUSE     = $02
	HID_USAGE_MOUSE = 2
'     HID_USAGE_JOYSTICK  = $04
	HID_USAGE_JOYSTICK = 4
'     HID_USAGE_GAMEPAD   = $05
	HID_USAGE_GAMEPAD = 5
'     HID_USAGE_KEYBOARD  = $06
	HID_USAGE_KEYBOARD = 6
'     HID_USAGE_X         = $30
	HID_USAGE_X = 48
'     HID_USAGE_Y         = $31
	HID_USAGE_Y = 49
'     HID_USAGE_Z         = $32
	HID_USAGE_Z = 50
'     HID_USAGE_RX        = $33
	HID_USAGE_RX = 51
'     HID_USAGE_RY        = $34
	HID_USAGE_RY = 52
'     HID_USAGE_RZ        = $35
	HID_USAGE_RZ = 53
'     HID_USAGE_SLIDER    = $36
	HID_USAGE_SLIDER = 54
'     HID_USAGE_WHEEL     = $38
	HID_USAGE_WHEEL = 56
'     HID_USAGE_HATSWITCH = $39
	HID_USAGE_HATSWITCH = 57
' 
' ' HID Report Collection Types from HID 1.12 6.2.2.6
'     HID_COLLECTION_PHYSICAL    = 0
	HID_COLLECTION_PHYSICAL = 0
'     HID_COLLECTION_APPLICATION = 1
	HID_COLLECTION_APPLICATION = 1
' 
' ' HID Input/Output/Feature Item Data (attributes) from HID 1.11 6.2.2.5
'     HID_ITEM_CONSTANT = $1
	HID_ITEM_CONSTANT = 1
'     HID_ITEM_VARIABLE = $2
	HID_ITEM_VARIABLE = 2
'     HID_ITEM_RELATIVE = $4
	HID_ITEM_RELATIVE = 4
' 
' ' Keyboard report data buffer lengths (boot protocol):
'     KBD_OUT_RPT_LEN = 1     ' CapsLock, NumLock and ScrollLock status bits
	KBD_OUT_RPT_LEN = 1
'     KBD_IN_RPT_LEN  = 8     ' Maximum keyboard boot protocol IN data packet size
	KBD_IN_RPT_LEN = 8
' ' Gamepad report and descriptor data buffer lengths:
'     HID_IN_RPT_LEN   = 256
	HID_IN_RPT_LEN = 256
'     HID_DESCR_LEN    = 256
	HID_DESCR_LEN = 256
' 
' ' Gamepad axes flag bits
'     HID_AXIS_X   = 16+0
	HID_AXIS_X = 16
'     HID_AXIS_Y   = 16+1
	HID_AXIS_Y = 17
'     HID_AXIS_Z   = 16+2
	HID_AXIS_Z = 18
'     HID_AXIS_RX  = 16+3
	HID_AXIS_RX = 19
'     HID_AXIS_RY  = 16+4
	HID_AXIS_RY = 20
'     HID_AXIS_RZ  = 16+5
	HID_AXIS_RZ = 21
' 
' ' Keyboard keys
' '-------------
' ' The first four scancodes are info/error indicators:
'     #$00, KEY_NO_KEY, KEY_ERR_ROLLOVER, KEY_POST_FAIL, KEY_ERR_UNDEF
	KEY_NO_KEY = 0
	KEY_ERR_ROLLOVER = 1
	KEY_POST_FAIL = 2
	KEY_ERR_UNDEF = 3
' ' Letters:
'     KEY_A         = $04
	KEY_A = 4
'     KEY_B         = $05
	KEY_B = 5
'     KEY_C         = $06
	KEY_C = 6
'     KEY_D         = $07
	KEY_D = 7
'     KEY_E         = $08
	KEY_E = 8
'     KEY_F         = $09
	KEY_F = 9
'     KEY_G         = $0a
	KEY_G = 10
'     KEY_H         = $0b
	KEY_H = 11
'     KEY_I         = $0c
	KEY_I = 12
'     KEY_J         = $0d
	KEY_J = 13
'     KEY_K         = $0e
	KEY_K = 14
'     KEY_L         = $0f
	KEY_L = 15
'     KEY_M         = $10
	KEY_M = 16
'     KEY_N         = $11
	KEY_N = 17
'     KEY_O         = $12
	KEY_O = 18
'     KEY_P         = $13
	KEY_P = 19
'     KEY_Q         = $14
	KEY_Q = 20
'     KEY_R         = $15
	KEY_R = 21
'     KEY_S         = $16
	KEY_S = 22
'     KEY_T         = $17
	KEY_T = 23
'     KEY_U         = $18
	KEY_U = 24
'     KEY_V         = $19
	KEY_V = 25
'     KEY_W         = $1a
	KEY_W = 26
'     KEY_X         = $1b
	KEY_X = 27
'     KEY_Y         = $1c
	KEY_Y = 28
'     KEY_Z         = $1d
	KEY_Z = 29
' ' Number Row:
'     KEY_1         = $1e 
	KEY_1 = 30
'     KEY_2         = $1f 
	KEY_2 = 31
'     KEY_3         = $20 
	KEY_3 = 32
'     KEY_4         = $21 
	KEY_4 = 33
'     KEY_5         = $22 
	KEY_5 = 34
'     KEY_6         = $23 
	KEY_6 = 35
'     KEY_7         = $24 
	KEY_7 = 36
'     KEY_8         = $25 
	KEY_8 = 37
'     KEY_9         = $26 
	KEY_9 = 38
'     KEY_0         = $27 
	KEY_0 = 39
' ' Keyboard return (ENTER), tab, space, etc.:
'     KEY_ENTER     = $28
	KEY_ENTER = 40
'     KEY_ESC       = $29
	KEY_ESC = 41
'     KEY_BACKSPACE = $2a   ' Delete (backspace)
	KEY_BACKSPACE = 42
'     KEY_TAB       = $2b
	KEY_TAB = 43
'     KEY_SPACE     = $2c
	KEY_SPACE = 44
'     KEY_MINUS     = $2d   ' - and _
	KEY_MINUS = 45
'     KEY_EQUAL     = $2e   ' = and +
	KEY_EQUAL = 46
'     KEY_LBRACE    = $2f   ' [ and {
	KEY_LBRACE = 47
'     KEY_RBRACE    = $30   ' ] and }
	KEY_RBRACE = 48
'     KEY_BACKSLASH = $31   ' \ and |
	KEY_BACKSLASH = 49
'     KEY_HASHTILDE = $32   ' None-US # and ~
	KEY_HASHTILDE = 50
'     KEY_SEMICOLON = $33   ' ; and :
	KEY_SEMICOLON = 51
'     KEY_APOST     = $34   ' ' and "
	KEY_APOST = 52
'     KEY_GRAVE     = $35   ' ` and ~
	KEY_GRAVE = 53
'     KEY_COMMA     = $36   ' , and <
	KEY_COMMA = 54
'     KEY_DOT       = $37   ' . and >
	KEY_DOT = 55
'     KEY_SLASH     = $38   ' / and ?
	KEY_SLASH = 56
'     KEY_CAPSLOCK  = $39
	KEY_CAPSLOCK = 57
' ' Function key scancodes:
'     KEY_F1        = $3a
	KEY_F1 = 58
'     KEY_F2        = $3b
	KEY_F2 = 59
'     KEY_F3        = $3c
	KEY_F3 = 60
'     KEY_F4        = $3d
	KEY_F4 = 61
'     KEY_F5        = $3e
	KEY_F5 = 62
'     KEY_F6        = $3f
	KEY_F6 = 63
'     KEY_F7        = $40
	KEY_F7 = 64
'     KEY_F8        = $41
	KEY_F8 = 65
'     KEY_F9        = $42
	KEY_F9 = 66
'     KEY_F10       = $43
	KEY_F10 = 67
'     KEY_F11       = $44
	KEY_F11 = 68
'     KEY_F12       = $45
	KEY_F12 = 69
' ' Special, toggle and movement keys:
'     KEY_PRINTSCREEN = $46
	KEY_PRINTSCREEN = 70
'     KEY_SCROLLLOCK  = $47
	KEY_SCROLLLOCK = 71
'     KEY_PAUSE       = $48
	KEY_PAUSE = 72
'     KEY_INSERT      = $49
	KEY_INSERT = 73
'     KEY_HOME        = $4a
	KEY_HOME = 74
'     KEY_PAGEUP      = $4b
	KEY_PAGEUP = 75
'     KEY_DELETE      = $4c
	KEY_DELETE = 76
'     KEY_END         = $4d
	KEY_END = 77
'     KEY_PAGEDOWN    = $4e
	KEY_PAGEDOWN = 78
'     KEY_RIGHT       = $4f
	KEY_RIGHT = 79
'     KEY_LEFT        = $50
	KEY_LEFT = 80
'     KEY_DOWN        = $51
	KEY_DOWN = 81
'     KEY_UP          = $52
	KEY_UP = 82
' ' Keypad keys:
'     KEY_NUMLOCK   = $53
	KEY_NUMLOCK = 83
'     KEY_NUMSLASH  = $54
	KEY_NUMSLASH = 84
'     KEY_NUMASTER  = $55
	KEY_NUMASTER = 85
'     KEY_NUMMINUS  = $56
	KEY_NUMMINUS = 86
'     KEY_NUMPLUS   = $57
	KEY_NUMPLUS = 87
'     KEY_NUMENTER  = $58
	KEY_NUMENTER = 88
'     KEY_NUM1      = $59
	KEY_NUM1 = 89
'     KEY_NUM2      = $5a
	KEY_NUM2 = 90
'     KEY_NUM3      = $5b
	KEY_NUM3 = 91
'     KEY_NUM4      = $5c
	KEY_NUM4 = 92
'     KEY_NUM5      = $5d
	KEY_NUM5 = 93
'     KEY_NUM6      = $5e
	KEY_NUM6 = 94
'     KEY_NUM7      = $5f
	KEY_NUM7 = 95
'     KEY_NUM8      = $60
	KEY_NUM8 = 96
'     KEY_NUM9      = $61
	KEY_NUM9 = 97
'     KEY_NUM0      = $62
	KEY_NUM0 = 98
'     KEY_DOT_DEL   = $63
	KEY_DOT_DEL = 99
'     KEY_NOUS_SP   = $64   ' Non-US \ and |
	KEY_NOUS_SP = 100
'     KEY_APP       = $65   ' Application key
	KEY_APP = 101
' ' Modifier keys:
'     KEY_LCTRL     = $E0
	KEY_LCTRL = 224
'     KEY_LSHIFT    = $E1
	KEY_LSHIFT = 225
'     KEY_LALT      = $E2
	KEY_LALT = 226
'     KEY_LMETA     = $E3 ' The left "Windows" key
	KEY_LMETA = 227
'     KEY_RCTRL     = $E4
	KEY_RCTRL = 228
'     KEY_RSHIFT    = $E5
	KEY_RSHIFT = 229
'     KEY_RALT      = $E6
	KEY_RALT = 230
'     KEY_RMETA     = $E7 ' The right "Windows" key
	KEY_RMETA = 231
' 
'     ' EmuPad default keyboard map
'     ' You should probably override these
'   EMUPAD_KB_UP    = KEY_UP
	EMUPAD_KB_UP = 82
'   EMUPAD_KB_DOWN  = KEY_DOWN
	EMUPAD_KB_DOWN = 81
'   EMUPAD_KB_LEFT  = KEY_LEFT
	EMUPAD_KB_LEFT = 80
'   EMUPAD_KB_RIGHT = KEY_RIGHT
	EMUPAD_KB_RIGHT = 79
'   EMUPAD_KB_BT0   = KEY_D
	EMUPAD_KB_BT0 = 7
'   EMUPAD_KB_BT1   = KEY_V
	EMUPAD_KB_BT1 = 25
'   EMUPAD_KB_BT2   = KEY_C
	EMUPAD_KB_BT2 = 6
'   EMUPAD_KB_BT3   = KEY_X
	EMUPAD_KB_BT3 = 27
'   EMUPAD_KB_BT4   = KEY_F
	EMUPAD_KB_BT4 = 9
'   EMUPAD_KB_BT5   = KEY_G
	EMUPAD_KB_BT5 = 10
'   EMUPAD_KB_BT6   = KEY_T
	EMUPAD_KB_BT6 = 23
'   EMUPAD_KB_BT7   = KEY_Y
	EMUPAD_KB_BT7 = 28
'   EMUPAD_KB_BT8   = KEY_BACKSPACE
	EMUPAD_KB_BT8 = 42
'   EMUPAD_KB_BT9   = KEY_ENTER
	EMUPAD_KB_BT9 = 40
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 20000000
	long	0 ' clock mode: will default to $100094b
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##16779592
	waitx	##200000
	mov	pa, ##16779595
	hubset	pa
	wrlong	pa, #24
	wrlong	##20000000, #20
	jmp	#skip_clock_set_
	orgf	128
skip_clock_set_
	call	#_start
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    mov	fcache_tmpb_,ptrb
    pop	ptrb
    altd	pa,ret_instr_
    mov	 0-0, ret_instr_
    setq	pa
    rdlong	$0, ptrb++
    push	ptrb
    mov ptrb,fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    _ret_ cmp inb,#0
fcache_tmpb_
    long 0
fcache_load_ptr_
    long FCACHE_LOAD_
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret

objptr
	long	@objmem
ptr__dat__
	long	@_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
COG_BSS_START
	fit	480
	orgh
hubentry

' 
' PUB start() : r
_start
	mov	_var01, #0
'   ifnot driver_cog
	add	ptr__dat__, ##10827
	rdbyte	_var02, ptr__dat__ wz
	sub	ptr__dat__, ##10827
 if_ne	jmp	#LR__0001
'     r := coginit(COGEXEC_NEW,@usb_host_start,0)
	mov	arg02, ptr__dat__
	mov	_var01, #16
	mov	arg03, #0
	setq	arg03
	coginit	_var01, arg02 wc
 if_b	neg	_var01, #1
'     if r >= 0
	cmps	_var01, #0 wc
'       driver_cog := r+1
 if_ae	mov	_var02, _var01
 if_ae	add	_var02, #1
 if_ae	add	ptr__dat__, ##10827
 if_ae	wrbyte	_var02, ptr__dat__
 if_ae	sub	ptr__dat__, ##10827
LR__0001
	mov	result1, _var01
_start_ret
	ret
hubexit
	jmp	#cogexit
	alignl
_dat_
'-'                 org     $000
'-' 
'-' usb_host_start
'-'                 mov     hcog_base_addr, ptrb
	byte	$f9, $8f, $02, $f6
'-' 
'-'                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
	byte	$03, $00, $00, $ff, $d0, $70, $07, $f6
'-'                 shr     htmp, #2                        ' so byte->long for the lut cell count
	byte	$02, $70, $47, $f0
'-'                 loc     pb, #@hlut_start - @usb_host_start
	byte	$b4, $04, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq2   htmp
	byte	$29, $70, $63, $fd
'-'                 rdlong  0, pb                           ' Do the hub->lut copy
	byte	$f7, $01, $00, $fb
'-' 
'-'                 loc     pb, #@usb_host_init - @usb_host_start
	byte	$88, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 jmp     pb                              ' Initialize host and enter main processing loop
	byte	$2c, $ee, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
'-' ' special because the receiving function must not respond with either STALL or
'-' ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
'-' ' non-control endpoint receives a SETUP token, or the function receives a
'-' ' corrupt packet, it must ignore the transaction
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data struct.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error code.
'-' '------------------------------------------------------------------------------
'-' txn_setup
'-'                 setbyte ep_addr_pid, #PID_SETUP, #0
	byte	$2d, $bc, $c6, $f8
'-'                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
	byte	$08, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
	byte	$03, $96, $06, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
	byte	$0c, $a2, $06, $f6
'-'                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
	byte	$f8, $ed, $03, $f6
'-' .setup
'-'                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
	byte	$24, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait
	byte	$7c, $0b, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
	byte	$f6, $f1, $03, $f6
'-'                 jmp     #.setup
	byte	$e0, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' IN/INTERRUPT transaction.
'-' ' Possible function response: STALL or NAK handshake, or DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_in
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$90, $03, $b0, $fd
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #utx_token                      ' Put IN request on the bus
	byte	$bc, $00, $b0, $fd
'-' 
'-'                 ' Fall through to urx_packet
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a packet from a device/function. As host, the only two packet types
'-' ' received are handshakes and IN DATAx.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'-' '     returned.
'-' '------------------------------------------------------------------------------
'-' urx_packet
'-'                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #urx_packet
	byte	$f4, $ff, $9f, $cd
'-'                 getct   hct2
	byte	$1a, $92, $63, $fd
'-'                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
	byte	$4e, $93, $6b, $fa
'-'                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
	byte	$05, $96, $06, $f4
'-'                 mov     newb_flg, #0                    ' Initialize for multi-byte read
	byte	$00, $a8, $06, $f6
'-' .wait_sop
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #.get_pid
	byte	$08, $00, $90, $cd
'-'                 jnct2   #.wait_sop
	byte	$fc, $25, $cc, $fb
'-'         _ret_   mov     retval, #ERR_TAT
	byte	$05, $be, $06, $06
'-' .get_pid
'-'                 call    #urx_next
	byte	$28, $02, $b0, $fd
'-'                 testb   urx, #BUS_ERRB          wc
	byte	$06, $a6, $16, $f4
'-'         if_nc   jmp     #.chk_pid
	byte	$04, $00, $90, $3d
'-'         _ret_   mov     retval, #ERR_URX
	byte	$02, $be, $06, $06
'-' .chk_pid
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $52
'-'         if_nz   cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
	byte	$38, $00, $90, $ad
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
	byte	$03, $96, $16, $f4
'-'                 cmp     retval, #PID_DATA0      wz
	byte	$c3, $be, $0e, $f2
'-'    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
	byte	$28, $01, $90, $2d
'-'    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
	byte	$10, $00, $90, $8d
'-'                 cmp     retval, #PID_DATA1      wz
	byte	$4b, $be, $0e, $f2
'-'    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
	byte	$1c, $01, $90, $8d
'-'    if_z_and_nc  jmp     #.ack_resend
	byte	$04, $00, $90, $2d
'-'         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
	byte	$04, $be, $06, $06
'-' .ack_resend
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.ack_resend
	byte	$f4, $ff, $9f, $3d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 call    #utx_handshake                  ' Send handshake PID and return to caller
	byte	$98, $01, $b0, $fd
'-'         _ret_   mov     retval, #ERR_DATAX_SYNC
	byte	$09, $be, $06, $06
'-' .chk_eop
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
	byte	$1c, $00, $90, $3d
'-'                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
	byte	$c8, $01, $b0, $fd
'-'                 testb   hstatus, #EOPB          wc
	byte	$05, $96, $16, $f4
'-'         if_c    jmp     #.idle                          ' Low-speed EOP seen
	byte	$10, $00, $90, $cd
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
	byte	$04, $be, $06, $36
'-'         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
	byte	$02, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
	byte	$f4, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send a token packet with CRC5 checksum of address and endpoint. It is the
'-' ' responsibility of the caller to append the appropriate inter-packet delay,
'-' ' if one is required.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - packed with the PID, address and endpoint.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_token
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #utx_token
	byte	$f4, $ff, $9f, $3d
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$34, $0d, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync byte
	byte	$70, $01, $b0, $fd
'-'                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
	byte	$5e, $71, $03, $f6
'-'                 mov     pkt_cnt, #3
	byte	$03, $b8, $06, $f6
'-' .next_byte
'-'                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
	byte	$b8, $a5, $e2, $f8
'-'                 shr     htmp, #8                        ' Shift to next byte to send
	byte	$08, $70, $47, $f0
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   utx, dm
	byte	$22, $a5, $22, $fc
'-'         _ret_   djnz    pkt_cnt, #.next_byte
	byte	$f9, $b9, $6e, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP/OUT/INTERRUPT transaction.
'-' ' Possible function response in order of precedence: STALL, ACK, NAK.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' '   PTRA - start address of the data buff/struct that has the bytes to send.
'-' '   pkt_data - count of DATAx payload bytes to send.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_out
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$88, $02, $b0, $fd
'-'                 call    #utx_token                      ' Put SETUP/OUT token on the bus
	byte	$b8, $ff, $bf, $fd
'-'                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
	byte	$00, $00, $c0, $ff, $f8, $01, $78, $fc
'-'                 mov     pkt_cnt, pkt_data
	byte	$58, $b9, $02, $f6
'-' 
'-'                 ' Fall through to utx_data
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
'-' ' calculated while the data byte is being shifted out. Since data stage
'-' ' success/fail is not determined until the status stage of the transaction,
'-' ' this routine is only concerned about the current DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - hub start address of the data to read.
'-' '   pkt_cnt - data payload size.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_data
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #utx_data
	byte	$f4, $ff, $9f, $cd
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
	byte	$2c, $0a, $b0, $fd
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$d8, $0c, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$14, $01, $b0, $fd
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
	byte	$03, $96, $16, $f4
'-'         if_nc   mov     utx, #PID_DATA0
	byte	$c3, $a4, $06, $36
'-'         if_c    mov     utx, #PID_DATA1
	byte	$4b, $a4, $06, $c6
'-'                 call    #utx_byte                       ' No CRC calc done on PID
	byte	$00, $01, $b0, $fd
'-'                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
	byte	$1c, $00, $90, $ad
'-' .read_byte
'-'                 rfbyte  utx                             ' Fetch data byte
	byte	$10, $a4, $62, $fd
'-'                 call    #utx_byte
	byte	$f0, $00, $b0, $fd
'-'                 rev     utx                             ' Calculate CRC while the data is shifting out
	byte	$69, $a4, $62, $fd
'-'                 setq    utx                             ' SETQ left-justifies the reflected data byte
	byte	$28, $a4, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-'                 djnz    pkt_cnt, #.read_byte
	byte	$f9, $b9, $6e, $fb
'-' .send_crc
'-'                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
	byte	$e0, $bb, $e6, $f4
'-'                 getbyte utx, crc, #0
	byte	$5d, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$d0, $00, $b0, $fd
'-'                 getbyte utx, crc, #1
	byte	$5d, $a5, $ea, $f8
'-'                 call    #utx_byte                       ' Last CRC byte out
	byte	$c8, $00, $b0, $fd
'-'                 jmp     #urx_packet                     ' Handle function response/error and back to caller
	byte	$7c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
'-' ' payload bytes are received. The routine reads bytes until EOP is detected and
'-' ' expects that the packet includes at least the CRC word.
'-' '
'-' ' In control transfers, it's possible to recieve fewer data bytes than what
'-' ' was requested, which makes it difficult to determine where the data stops
'-' ' and the CRC word begins. So the CRC calculation is done on every byte of the
'-' ' packet, including the CRC word. The CRC value should then be equal to the
'-' ' USB-16 expected residual value of 0xB001.
'-' '
'-' ' The routine writes the IN packet data to a static max_packet_size buffer
'-' ' so the caller can verify IN success before writing the data to its final
'-' ' destination.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   pkt_data - max byte count expected to be in the packet.
'-' '   newb_flg - signals new byte ready when toggled.
'-' ' On exit:
'-' '   pkt_cnt - actual number of bytes read.
'-' '------------------------------------------------------------------------------
'-' urx_data
'-'                 mov     htmp2, pb
	byte	$f7, $75, $03, $f6
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
	byte	$00, $00, $c0, $ff, $f7, $01, $88, $fc
'-'                 mov     pb, htmp2
	byte	$ba, $ef, $03, $f6
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
	byte	$00, $b8, $06, $f6
'-'                 mov     pkt_tmp, pkt_data
	byte	$58, $83, $03, $f6
'-'                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
	byte	$02, $82, $07, $f1
'-' .wait_byte
'-' ' In-line rx for max speed
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   jmp     #.get_byte                      ' New byte!
	byte	$0c, $00, $90, $5d
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_c    jmp     #.chk_crc                       ' At end-of-packet
	byte	$38, $00, $90, $cd
'-'                 jmp     #.wait_byte
	byte	$dc, $ff, $9f, $fd
'-' .get_byte
'-'                 getbyte retval, urx, #1                 ' New byte from smart pins
	byte	$53, $bf, $ea, $f8
'-'                 wfbyte  retval                          ' Add it to the data buffer
	byte	$15, $be, $62, $fd
'-'                 rev     retval                          ' Calculate CRC while next byte is shifting in
	byte	$69, $be, $62, $fd
'-'                 setq    retval                          ' SETQ left-justifies the reflected data byte
	byte	$28, $be, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-' .end_crc
'-'                 add     pkt_cnt, #1
	byte	$01, $b8, $06, $f1
'-'                 cmp     pkt_cnt, pkt_tmp        wcz
	byte	$c1, $b9, $1a, $f2
'-'         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
	byte	$04, $be, $06, $16
'-'         if_a    ret
	byte	$2d, $00, $64, $1d
'-' ' For full-speed at 80MHz, the time it takes to do the final byte write and
'-' ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
'-' ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
'-' ' to miss it, so cheat a bit and look for SOP clear here.
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
	byte	$a8, $ff, $9f, $3d
'-' ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
'-' .chk_crc
'-'                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
	byte	$02, $b8, $86, $f1
'-'                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
	byte	$58, $00, $00, $ff, $01, $ba, $6e, $f5
'-'         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
	byte	$f0, $fd, $9f, $5d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$34, $09, $b0, $fd
'-' 
'-'                 ' Fall through to utx_handshake
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
'-' ' the appropriate IP delay has been inserted.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - handshake PID to send.
'-' ' On exit:
'-' '   retval unchanged.
'-' '------------------------------------------------------------------------------
'-' utx_handshake
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$e0, $0b, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$1c, $00, $b0, $fd
'-'                 mov     utx, retval
	byte	$5f, $a5, $02, $f6
'-'                 call    #utx_byte                       ' Send handshake PID
	byte	$14, $00, $b0, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
	byte	$f4, $ff, $9f, $3d
'-'                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
	byte	$4e, $99, $02, $f6
'-'                 jmp     #poll_waitx
	byte	$08, $09, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for the USB tx buffer to empty and feed it a new byte.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   utx - byte to transmit.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_byte
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #utx_byte
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
	byte	$1f, $94, $62, $fd
'-'         _ret_   wypin   utx, dm
	byte	$22, $a5, $22, $0c
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Fetch the next data byte of a packet. Always check receiver status for EOP.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the byte read.
'-' '   urx - the receiver status. The caller must check the hstatus reg EOP flag
'-' '     on return. If EOP is set, the byte in reg retval remains as the last byte
'-' '     received.
'-' '------------------------------------------------------------------------------
'-' urx_next
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
	byte	$53, $bf, $ea, $58
'-'         if_nz   ret                                     ' New byte is priority, so return now
	byte	$2d, $00, $64, $5d
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
	byte	$d8, $ff, $9f, $4d
'-'         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
	byte	$05, $96, $26, $34
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
'-' ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
'-' ' length, and the PID is not included in the CRC calculation:
'-' '  CRC5  FRAME_NUMBER SOF (full-speed)
'-' '  CRC5  ENDP ADDRESS PID
'-' ' %00000_1111_1111111_xxxxxxxx
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - stuffed with the function endpoint, address and
'-' '     SETUP/IN/OUT/SOF PID according to the USB standard.
'-' ' On exit:
'-' '   ep_addr_pid - CRC value appended to the packet.
'-' '------------------------------------------------------------------------------
'-' calc_crc5
'-'                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
	byte	$ff, $03, $00, $ff, $ff, $bd, $06, $f5
'-'                 mov     htmp, ep_addr_pid
	byte	$5e, $71, $03, $f6
'-'                 shr     htmp, #8                        ' PID not included in CRC calc
	byte	$08, $70, $47, $f0
'-'                 mov     crc, #$1f                       ' Initial CRC5 value
	byte	$1f, $ba, $06, $f6
'-'                 rev     htmp                            ' Input data reflected
	byte	$69, $70, $63, $fd
'-'                 setq    htmp                            ' CRCNIB setup for data bits 0..7
	byte	$28, $70, $63, $fd
'-'                 crcnib  crc, #USB5_POLY
	byte	$14, $ba, $de, $f9
'-'                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
	byte	$14, $ba, $de, $f9
'-'                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
	byte	$09, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 xor     crc, #$1f                       ' Final XOR value
	byte	$1f, $ba, $66, $f5
'-'                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
	byte	$13, $ba, $66, $f0
'-'         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
	byte	$5d, $bd, $42, $05
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed/low-speed frame timing interrupt service routine.
'-' '------------------------------------------------------------------------------
'-' isr1_fsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6d, $13, $fc
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 mov     utx, #PID_SOF
	byte	$a5, $a4, $06, $f6
'-'                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
	byte	$22, $01, $29, $fc
'-'                 call    #utx_byte                       ' Send token PID byte
	byte	$4c, $ff, $bf, $fd
'-'                 mov     icrc, #$1f                      ' Prime the CRC5 pump
	byte	$1f, $b6, $06, $f6
'-'                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
	byte	$59, $b5, $02, $f6
'-'                 rev     sof_pkt                         ' Input data reflected
	byte	$69, $b4, $62, $fd
'-'                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
	byte	$28, $b4, $62, $fd
'-'                 crcnib  icrc, #USB5_POLY
	byte	$14, $b6, $de, $f9
'-'                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
	byte	$14, $b6, $de, $f9
'-'                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
	byte	$59, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$2c, $ff, $bf, $fd
'-'                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
	byte	$08, $b4, $66, $f0
'-'                 rep     #2, #3                          ' Three data bits left to process
	byte	$03, $04, $dc, $fc
'-'                 shl     sof_pkt, #1             wc
	byte	$01, $b4, $76, $f0
'-'                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
	byte	$14, $b6, $d6, $f9
'-'                 xor     icrc, #$1f                      ' Final XOR value
	byte	$1f, $b6, $66, $f5
'-'                 getbyte utx, frame, #1                  ' Send remaining frame number bits
	byte	$59, $a5, $ea, $f8
'-'                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
	byte	$03, $b6, $66, $f0
'-'                 or      utx, icrc
	byte	$5b, $a5, $42, $f5
'-'                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
	byte	$08, $ff, $bf, $fd
'-'                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
	byte	$a3, $81, $03, $f6
'-'                 jmp     #isr1_wait
	byte	$20, $00, $90, $fd
'-' isr1_lsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
	byte	$22, $09, $28, $fc
'-'                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
	byte	$a2, $81, $03, $f6
'-' isr1_wait
'-'                 rqpin   utx, dm
	byte	$22, $a5, $82, $fa
'-'                 testb   utx, #SOPB                 wc
	byte	$04, $a4, $16, $f4
'-'         if_c    jmp     #isr1_wait
	byte	$f4, $ff, $9f, $cd
'-'                 add     frame, #1                       ' Next frame# and check for wrap around
	byte	$01, $b2, $06, $f1
'-'                 and     frame, ##$7ff
	byte	$03, $00, $00, $ff, $ff, $b3, $06, $f5
'-'                 waitx   isrtmp1                         ' Make sure bus is idle
	byte	$1f, $80, $63, $fd
'-'                 reti1
	byte	$f5, $ff, $3b, $fb
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a window within the 1ms frame boundary that will ensure that a
'-' ' transaction will complete before the next frame is triggered.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' wait_txn_ok
'-'                 getct   htmp2
	byte	$1a, $74, $63, $fd
'-'                 sub     htmp2, iframe_ct_base
	byte	$49, $75, $83, $f1
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    cmp     htmp2, _txn_ok_ls_      wcz
	byte	$a0, $75, $1b, $c2
'-'         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
	byte	$a1, $75, $1b, $32
'-'         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
	byte	$e8, $ff, $9f, $1d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A device connection was detected, or a bus reset was requested by the USB
'-' ' client. Set the appropriate smart pin FS/LS speed mode to match the device
'-' ' and perform a reset sequence prior to device enumeration.
'-' '------------------------------------------------------------------------------
'-' dev_reset
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
	byte	$01, $a6, $16, $f4
'-'         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
	byte	$f4, $03, $b0, $cd
'-'         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
	byte	$e0, $03, $b0, $3d
'-' reset
'-'                 setint1 #0                              ' Don't want frame interrupt while in reset
	byte	$25, $00, $64, $fd
'-'                 wypin   #OUT_SE0, dm                    ' Assert bus reset
	byte	$22, $03, $28, $fc
'-'                 waitx   _reset_hold_                    ' Spec is >= 10ms
	byte	$1f, $5a, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 mov     frame, #0                       ' Reset the frame timespan count
	byte	$00, $b2, $06, $f6
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
	byte	$59, $71, $03, $f6
'-'                 add     htmp, #36
	byte	$24, $70, $07, $f1
'-'                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
	byte	$25, $02, $64, $fd
'-' .framewait
'-'                 cmp     frame, htmp             wcz
	byte	$b8, $b3, $1a, $f2
'-'         if_b    jmp     #.framewait
	byte	$f8, $ff, $9f, $cd
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - source address.
'-' '   PB - destination address.
'-' '   hr0 - length of copy, in bytes.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hmemcpy
'-'                 rdbyte  htmp, ptra++
	byte	$61, $71, $c7, $fa
'-'                 wrbyte  htmp, pb
	byte	$f7, $71, $43, $fc
'-'                 add     pb, #1
	byte	$01, $ee, $07, $f1
'-'         _ret_   djnz    hr0, #hmemcpy
	byte	$fc, $85, $6f, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
'-' ' loop until the errant device is disconnected.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' host_error
'-'           if ERROR_LED >= 0
'-'           end
'-'                 jmp     #host_reset                     ' See if it works...
	byte	$a0, $07, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get HID descriptor buffer for current port
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   PB - HID descriptor buffer pointer
'-' '------------------------------------------------------------------------------
'-' get_hid_descr_buffer
'-'                 mov     pb, hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb, #1
	byte	$01, $ee, $e7, $f2
'-'                 mul     pb, #HID_DESCR_LEN
	byte	$00, $ef, $07, $fa
'-'         _ret_   add     pb, hid_descr_p
	byte	$25, $ef, $03, $01
'-' 
'-' 
'-' usb16_poly_r    long    USB16_POLY
	byte	$01, $a0, $00, $00
'-' 
'-' ' USB commands and error codes
'-' cmd_data        long    0
	byte	$00, $00, $00, $00
'-' usb_err_code    long    ERR_NONE
	byte	$00, $00, $00, $00
'-' 
'-' ' Parameters block assigned at cog startup
'-' dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
	byte	$12, $00, $00, $00
'-' dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
	byte	$13, $00, $00, $00
'-' usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
	byte	$11, $00, $00, $00
'-' if ACTIVITY_LED >= 0
'-' host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
'-' end
'-' if ERROR_LED >= 0
'-' host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
'-' end
'-' hid_descr_p     long    0
	byte	$00, $00, $00, $00
'-' 'hid_report_p    long    0, 0[MAX_DEVICES]
'-' 'hkbd_report_p   long    0
'-' hub_descr_p     long    0
	byte	$00, $00, $00, $00
'-' urx_buff_p      long    0
	byte	$00, $00, $00, $00
'-' dev_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' con_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' cache_start_p   long    0
	byte	$00, $00, $00, $00
'-' cache_end_p     long    0
	byte	$00, $00, $00, $00
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_out_ptr  long    0
'-' end
'-' save_sysclk     long    0         ' Save the current sysclock as the client may change it
	byte	$00, $00, $00, $00
'-' 
'-' hdev_init_start
'-' hdev_port       res     1
'-' hdev_port       res     1
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' kbm_next_datax  res     1
'-' kbm_next_datax  res     1
'-' hub_intf_num    res     1
'-' hub_intf_num    res     1
'-' hub_next_datax  res     1
'-' hub_next_datax  res     1
'-' hub_status_chg  res     1
'-' hub_status_chg  res     1
'-' hub_port_status res     1
'-' hub_port_status res     1
'-' if HAVE_MOUSE
'-' ms_intf_num     res     1
'-' ms_intf_num     res     1
'-' ms_in_max_pkt   res     1
'-' ms_in_max_pkt   res     1
'-' end
'-' kb_intf_num     res     1
'-' kb_intf_num     res     1
'-' kb_interval     res     1
'-' kb_interval     res     1
'-' kb_in_max_pkt   res     1
'-' kb_in_max_pkt   res     1
'-' kb_max_index    res     1
'-' kb_max_index    res     1
'-' kb_led_states   res     1
'-' kb_led_states   res     1
'-' gp_intf_num     res     1
'-' gp_intf_num     res     1
'-' gp_interval     res     1
'-' gp_interval     res     1
'-' gp_max_index    res     1
'-' gp_max_index    res     1
'-' gp_descr_len    res     1+MAX_DEVICES
'-' gp_descr_len    res     1+MAX_DEVICES
'-' hdev_init_end
'-' 
'-' ' Initialized at cog startup:
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' iframe_ct_new   res     1
'-' iframe_ct_new   res     1
'-' iframe_ct_base  res     1
'-' iframe_ct_base  res     1
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' 
'-' ' This register block is reset to zero when a USB device connects
'-' hreg_init_start
'-' hstatus         res     1         ' Host status flags
'-' hstatus         res     1         ' Host status flags
'-' hctwait         res     1         ' Poll-based wait clocks
'-' hctwait         res     1         ' Poll-based wait clocks
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' xfer_retry      res     1         ' Control transfer retry count
'-' xfer_retry      res     1         ' Control transfer retry count
'-' retry           res     1         ' Transaction retry count
'-' retry           res     1         ' Transaction retry count
'-' utx             res     1         ' Byte to transmit on USB
'-' utx             res     1         ' Byte to transmit on USB
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' frame           res     1         ' USB 1ms frame counter value
'-' frame           res     1         ' USB 1ms frame counter value
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' crc             res     1         ' Used for CRC16 calculation
'-' crc             res     1         ' Used for CRC16 calculation
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' retval          res     1         ' Global success/fail return parameter
'-' retval          res     1         ' Global success/fail return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' ' Device stuff
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_bcd        res     1
'-' hdev_bcd        res     1
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' ' Keyboard/mouse stuff
'-' hctrl_ep_addr   res     1
'-' hctrl_ep_addr   res     1
'-' hctrl_max_pkt   res     1
'-' hctrl_max_pkt   res     1
'-' hconfig_base    res     1
'-' hconfig_base    res     1
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_class      res     1
'-' hdev_class      res     1
'-' hdev_subclass   res     1
'-' hdev_subclass   res     1
'-' hdev_protocol   res     1
'-' hdev_protocol   res     1
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' if HAVE_MOUSE
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' end
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_out_addr   res     1
'-' hdev_out_addr   res     1
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
'-' end
'-' 
'-' hreg_init_end
'-' 
'-' hidr_start
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_flags      res     1
'-' hidr_flags      res     1
'-' hidr_axis       res     3
'-' hidr_axis       res     3
'-' hidr_buttons    res     1
'-' hidr_buttons    res     1
'-' hidr_hats       res     1
'-' hidr_hats       res     1
'-' '' Above are actually useful values, 6 longs
'-' hidr_id         res     1
'-' hidr_id         res     1
'-' hidr_state      res     1
'-' hidr_state      res     1
'-' hidr_size       res     1
'-' hidr_size       res     1
'-' hidr_count      res     1
'-' hidr_count      res     1
'-' hidr_offset     res     1
'-' hidr_offset     res     1
'-' hidr_usage_idx  res     1
'-' hidr_usage_idx  res     1
'-' hidr_lminmax    res     1
'-' hidr_lminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_type       res     1
'-' hidr_type       res     1
'-' hidr_end
'-' 
'-' ' Variables dependent on the system freqency
'-' _var_64_lower_  res     1
'-' _var_64_lower_  res     1
'-' _var_64_upper_  res     1
'-' _var_64_upper_  res     1
'-' _12Mbps_        res     1
'-' _12Mbps_        res     1
'-' _1_5Mbps_       res     1
'-' _1_5Mbps_       res     1
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1us_           res     1         ' 1us
'-' _1us_           res     1         ' 1us
'-' _10us_          res     1         ' 10us
'-' _10us_          res     1         ' 10us
'-' _33us_          res     1         ' 33us
'-' _33us_          res     1         ' 33us
'-' _txn_err_       res     1         ' 250us
'-' _txn_err_       res     1         ' 250us
'-' _500us_         res     1         ' 500us
'-' _500us_         res     1         ' 500us
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _preamble_wait_ res     1
'-' _preamble_wait_ res     1
'-' _1ms_           res     1         ' 1ms
'-' _1ms_           res     1         ' 1ms
'-' _2ms_           res     1         ' 2ms
'-' _2ms_           res     1         ' 2ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _4ms_           res     1         ' 4ms
'-' _4ms_           res     1         ' 4ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _reset_hold_    res     1         ' 15ms
'-' _reset_hold_    res     1         ' 15ms
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _21ms_          res     1         ' 21ms
'-' _21ms_          res     1         ' 21ms
'-' _100ms_         res     1         ' 100ms
'-' _100ms_         res     1         ' 100ms
'-' _500ms_         res     1         ' 500ms
'-' _500ms_         res     1         ' 500ms
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' '------------------------------------------------------------------------------
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_d_ls_nco_  res     1
'-' _usb_d_ls_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' '------------------------------------------------------------------------------
'-' ' Scratch registers
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp1           res     1
'-' htmp1           res     1
'-' htmp2           res     1
'-' htmp2           res     1
'-' htmp3           res     1
'-' htmp3           res     1
'-' hrep            res     1         ' Repeat count
'-' hrep            res     1         ' Repeat count
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave1          res     1
'-' hsave1          res     1
'-' hsave2          res     1
'-' hsave2          res     1
'-' isrtmp1         res     1
'-' isrtmp1         res     1
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' hr0             res     1         ' Multi-purpose registers
'-' hr0             res     1         ' Multi-purpose registers
'-' hr1             res     1
'-' hr1             res     1
'-' hr2             res     1
'-' hr2             res     1
'-' hr3             res     1
'-' hr3             res     1
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar2           res     1
'-' hpar2           res     1
'-' hpar3           res     1
'-' hpar3           res     1
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' mod_cnt         res     1         ' Used in idle loops
'-' mod_cnt         res     1         ' Used in idle loops
'-'                 fit     $1F0
'-'                 org     $200
'-' hlut_start
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed is the host's native speed, so all that is needed is to set the FS
'-' ' settings to startup defaults.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: Save/restore caller C flag state if C is changed in this routine!
'-' '------------------------------------------------------------------------------
'-' set_speed_full
'-'                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$d0, $e8, $07, $f6
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
	byte	$a3, $9b, $02, $06
'-' '                ret                             wcz     ' Restore caller flags on exit
'-' 
'-' '------------------------------------------------------------------------------
'-' ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
'-' ' is a downstream hub connected (not yet implemented), the baud generator
'-' ' remains set at the full-speed rate, but signaling is switched to low-speed,
'-' ' which reverses the D-/D+ polarity. The polarity can be changed without
'-' ' putting the smart pins into reset.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: CZ flags restored to caller states
'-' '------------------------------------------------------------------------------
'-' set_speed_low
'-'                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
	byte	$80, $96, $ce, $f7
'-'         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$ed, $e8, $07, $a6
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
	byte	$22, $69, $13, $fc
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a4, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a2, $9b, $02, $f6
'-'                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
	byte	$02, $96, $26, $f4
'-'                 ret                             wcz     ' Restore caller flags on exit
	byte	$2d, $00, $7c, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform configuration stuff required when a device intitially connects.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' on_connect
'-'                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$02, $84, $07, $f6
'-'                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
	byte	$d8, $fb, $bf, $fd
'-' .retry
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
	byte	$01, $8c, $07, $c6
'-'         if_nc   mov     hpar1, #USB_SPEED_FULL
	byte	$02, $8c, $07, $36
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$1c, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$f4, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.get_dev_desc
	byte	$18, $00, $90, $ad
'-'                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$4c, $03, $b0, $fd
'-'                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$01, $84, $8f, $f1
'-'         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
	byte	$f0, $fb, $9f, $ad
'-'                 call    #reset                          ' Try another reset to see if the device responds
	byte	$a4, $fb, $bf, $fd
'-'                 jmp     #.retry
	byte	$b8, $ff, $9f, $fd
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
	byte	$28, $03, $b0, $fd
'-'                 call    #reset
	byte	$88, $fb, $bf, $fd
'-'                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
	byte	$34, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
	byte	$01, $11, $5c, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$d8, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$04, $03, $b0, $fd
'-'                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
	byte	$04, $00, $00, $ff, $00, $bc, $06, $f6
'-'                 call    #calc_crc5
	byte	$34, $fa, $bf, $fd
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
	byte	$1c, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$78, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
	byte	$07, $db, $c6, $fa
'-'                 mov     hctwait, _500us_
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $02, $b0, $fd
'-'                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$24, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$48, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $85, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $87, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $71, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $84, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $86, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $71, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #host_error
	byte	$2c, $fb, $9f, $cd
'-'                 loc     pa, #@init_kbdm_data - @usb_host_start
	byte	$14, $13, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-'                 loc     pa, #@hparse_con_desc - @usb_host_start
	byte	$b8, $0d, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 jmp     pa
	byte	$2c, $ec, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
'-' ' Status reporting is always in the function-to-host direction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data in hub.
'-' '   PB - start address of the buffer/struct to be written to during the IN data
'-' '     stage.
'-' '   ep_addr_pid - device address, endpoint and CRC5.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'-' '     contains the count of data stage bytes actually received, which must
'-' '     always be <= the count requested.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_read
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8d, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $8f, $03, $f6
'-'                 mov     hpar3, pb                       ' Save dest buffer pointer
	byte	$f7, $91, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$c0, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to caller to handle error
	byte	$2d, $00, $64, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$90, $01, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 mov     nak_retry, ##IN_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
	byte	$55, $b1, $02, $16
'-' .nak_retry
'-'                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
	byte	$0c, $a2, $06, $f6
'-' .in_retry
'-'                 call    #txn_in
	byte	$bc, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$28, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$a8, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$14, $02, $b0, $fd
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak_retry                     ' Function not ready to send data
	byte	$dc, $ff, $9f, $ad
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$94, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.in_retry                      ' Bus error retry
	byte	$d0, $ff, $9f, $5d
'-'                 ret                                     ' The transfer has failed
	byte	$2d, $00, $64, $fd
'-' .commit
'-'                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.pre_status                    ' and also end-of-data
	byte	$38, $00, $90, $ad
'-'                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
	byte	$27, $f1, $03, $f6
'-'                 mov     hr0, pkt_cnt
	byte	$5c, $85, $03, $f6
'-'                 cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $f2
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$6c, $fa, $bf, $5d
'-'                 add     stage_data, pkt_cnt             ' Update bytes received on commit
	byte	$5c, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
	byte	$56, $af, $0a, $f2
'-'         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
	byte	$1c, $00, $90, $ad
'-'                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
	byte	$58, $b9, $1a, $f2
'-'         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
	byte	$14, $00, $90, $cd
'-'         if_a    mov     retval, #ERR_PACKET
	byte	$04, $be, $06, $16
'-'         if_a    mov     context_retval, retval          ' In this case overall and context are the same
	byte	$5f, $c1, $02, $16
'-'         if_a    ret                                     ' Caller must handle ERR_PACKET
	byte	$2d, $00, $64, $1d
'-'                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $f4
'-'                 jmp     #.data                          ' Start next IN transaction
	byte	$78, $ff, $9f, $fd
'-' .pre_status
'-'                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
	byte	$57, $ad, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $f8
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-'                 mov     nak_retry, ##OUT_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-' .out_retry
'-'                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
	byte	$34, $f7, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret                                     ' All is good when ACK
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$18, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$84, $01, $b0, $fd
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
	byte	$d8, $ff, $9f, $5d
'-'                 ret                                     ' Caller must handle transfer retirement
	byte	$2d, $00, $64, $fd
'-' ' I've encountered transfer STALL, even though the data looks correct, and
'-' ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
'-' ' ControlRead() transfer gets things unstuck most of the time...
'-' .xfer_retry
'-'                 mov     hctwait, _xfer_wait_
	byte	$ab, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$58, $01, $b0, $fd
'-'                 call    #wait_txn_ok
	byte	$8c, $f9, $bf, $fd
'-'                 mov     ep_addr_pid, hpar1
	byte	$c6, $bd, $02, $f6
'-'                 mov     ptra, hpar2
	byte	$c7, $f1, $03, $f6
'-'                 mov     pb, hpar3
	byte	$c8, $ef, $03, $f6
'-'                 djnz    xfer_retry, #.xfer_start
	byte	$bb, $a1, $6e, $fb
'-'                 mov     context_retval, retval          ' Preserve the USB error code
	byte	$5f, $c1, $02, $f6
'-'         _ret_   mov     retval, #ERR_XFER_RETRY
	byte	$07, $be, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
'-' ' reporting is always in the function-to-host direction. It is assumed that
'-' ' the SETUP data struct is filled with the required values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - points to the start of the struct for the SETUP data.
'-' '   PB - the start address of the struct/buffer to be read for the OUT data
'-' '     stage.
'-' '   ep_addr_pid - the proper CRC'd address and endpoint to use.
'-' ' On exit:
'-' '   retval - used to convey the success/failure of each stage.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_write
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8d, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $8f, $03, $f6
'-'                 mov     hpar3, pb
	byte	$f7, $91, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
	byte	$00, $9e, $06, $f6
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$84, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
	byte	$ec, $00, $90, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$54, $00, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
	byte	$e1, $bc, $c6, $f8
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
	byte	$55, $b1, $02, $16
'-' .out_retry
'-'                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
	byte	$f7, $f1, $03, $f6
'-'                 call    #txn_out
	byte	$88, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit                        ' Function got the data
	byte	$10, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$e0, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry
	byte	$e4, $ff, $9f, $5d
'-'                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
	byte	$a4, $00, $90, $fd
'-' .commit
'-'                 mov     pb, ptra                        ' Save the current buffer/struct location
	byte	$f8, $ef, $03, $f6
'-'                 add     stage_data, pkt_data
	byte	$58, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz
	byte	$56, $af, $0a, $f2
'-'         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $54
'-'         if_nz   jmp     #.data                          ' More data to send
	byte	$bc, $ff, $9f, $5d
'-' pre_status_in
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .status_retry
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 call    #txn_in
	byte	$44, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
	byte	$d2, $be, $0e, $f2
'-'         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
	byte	$00, $b0, $0e, $a2
'-'         if_z    jmp     #dwnstream_reset                ' Control Write finished
	byte	$74, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait                     ' NAK or bus error, so delay a bit
	byte	$98, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.status_retry
	byte	$d8, $ff, $9f, $5d
'-' '               ret                                     ' Caller must handle transfer retirement
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - The function address and endpoint for the IN request.
'-' '   hpar2 - Address of the IN data buffer
'-' '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
'-' ' On exit:
'-' '   retval - the result of the operation.
'-' '   hpar3 - the count of IN data bytes actually received.
'-' '------------------------------------------------------------------------------
'-' do_int_in
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 getword htmp, hpar3, #0
	byte	$c8, $71, $33, $f9
'-'                 cmp     htmp, #PID_DATA0        wz
	byte	$c3, $70, $0f, $f2
'-'                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
	byte	$03, $96, $a6, $f4
'-'                 mov     retry, #TXN_RETRIES
	byte	$0c, $a2, $06, $f6
'-' .retry
'-'                 getword pkt_data, hpar3, #1             ' IN max packet length
	byte	$c8, $b1, $3a, $f9
'-'                 call    #txn_in
	byte	$00, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK if data received
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$1c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
	byte	$5a, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.post_ret                      ' The caller must handle either
	byte	$24, $00, $90, $ad
'-'                 call    #retry_wait
	byte	$54, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    jmp     #.post_ret
	byte	$18, $00, $90, $ad
'-'                 jmp     #.retry
	byte	$d4, $ff, $9f, $fd
'-' .commit
'-'                 mov     ptra, urx_buff_p                ' Copy the rx buffer
	byte	$27, $f1, $03, $f6
'-'                 mov     pb, hpar2                       ' to the destination buffer
	byte	$c7, $ef, $03, $f6
'-'                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
	byte	$5c, $85, $0b, $f6
'-'         if_nz   cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $52
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$c0, $f8, $bf, $5d
'-' .post_ret
'-'                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
	byte	$5c, $91, $03, $f6
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Resets the downstream hub port to FS
'-' '------------------------------------------------------------------------------
'-' dwnstream_reset
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_nc   ret                                     ' No LS device, reset not needed
	byte	$2d, $00, $64, $3d
'-' 
'-'                 bitl    _usb_h_ls_nco_, #14
	byte	$0e, $68, $07, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6d, $13, $fc
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The one millisecond frame timer is implemented as an interrupt service
'-' ' routine. Since this timing is critical, care must be taken to avoid any
'-' ' instructions that can delay the interrupt branch, which will likely upset
'-' ' the timer. WAITX is among those instructions, so any time you're inside
'-' ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hctwait - wait interval in sysclocks.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' poll_waitx
'-'                 getct   hct2
	byte	$1a, $92, $63, $fd
'-'                 addct2  hct2, hctwait
	byte	$4c, $93, $6b, $fa
'-' .wait
'-'                 jnct2   #.wait
	byte	$ff, $25, $cc, $fb
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transaction retry handling for NAK/STALL or bus error.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - transaction response PID or error code.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' retry_wait
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret                                     ' STALL is special case
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak
	byte	$14, $00, $90, $ad
'-'                 mov     hctwait, _txn_err_              ' Transaction error wait...
	byte	$9e, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$d8, $ff, $bf, $fd
'-' .dec
'-'                 sub     retry, #1               wz
	byte	$01, $a2, $8e, $f1
'-'         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
	byte	$06, $be, $06, $a6
'-'                 ret                                     ' Retry result to caller
	byte	$2d, $00, $64, $fd
'-' .nak
'-'                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
	byte	$9d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $ff, $bf, $fd
'-'                 cmp     nak_retry, #NAK_NOLIMIT wz
	byte	$00, $9e, $0e, $f2
'-'         if_z    ret                                     ' Indefinite NAK retries
	byte	$2d, $00, $64, $ad
'-'                 sub     nak_retry, #1           wz
	byte	$01, $9e, $8e, $f1
'-'         if_z    mov     retval, #ERR_NAK
	byte	$08, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' host_reset
'-'                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
	byte	$25, $00, $64, $fd
'-'                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
	byte	$14, $70, $07, $fb
'-' ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
'-'                 cmp     htmp, ##168_000_000     wcz
	byte	$bd, $01, $05, $ff, $00, $70, $1f, $f2
'-'         if_be   mov     utx_tweak, #0
	byte	$00, $94, $06, $e6
'-'         if_a    mov     utx_tweak, #3   '#20
	byte	$03, $94, $06, $16
'-' ' Check to see if the system clock has been changed.
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $71, $0b, $f2
'-'         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $5e
'-'         if_nz   add     pb, hcog_base_addr
	byte	$47, $ef, $03, $51
'-'         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $5d
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-' 
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
	byte	$22, $6d, $13, $fc
'-' .enable
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 waitx   _1us_
	byte	$1f, $36, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 ' Handle Port protection enable and startup delay
'-'                 cmp     usb_enable_pin, #0      wc
	byte	$00, $48, $16, $f2
'-'         if_ae   drvl    usb_enable_pin                 ' disable port
	byte	$58, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Wait a while for everything to turn off
	byte	$1f, $5e, $63, $fd
'-'         if_ae   drvh    usb_enable_pin                  ' Enable the port
	byte	$59, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Hold to let the idle state get settled
	byte	$1f, $5e, $63, $fd
'-' 
'-'                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
	byte	$4b, $ed, $b7, $f9
'-'                 rep     @.regloop,#hreg_init_end - hreg_init_start
	byte	$3b, $04, $dc, $fc
'-'                 alti    pa, #%000_111_000
	byte	$38, $ec, $a7, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' .regloop
'-' 
'-'                 'call #dev_reset ' TODO THINK ABOUT THIS
'-' 
'-' discon_entry
'-'                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
	byte	$03, $96, $07, $f6
'-' 
'-'               
'-'         if HAVE_HIDPAD
'-'                 loc     pb, #@hidpad_report - @usb_host_start
	byte	$d8, $27, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
	byte	$28, $60, $64, $fd
'-'                 wrlong  #0,pb
	byte	$f7, $01, $68, $fc
'-'         end
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-'                 ' Fall through to disconnected loop
'-' 
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' Device connect handling (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
'-' ' device to connect (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' disconnected
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
	byte	$14, $86, $07, $fb
'-'                 cmp     hr1, save_sysclk        wz
	byte	$2c, $87, $0b, $f2
'-'         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
	byte	$6c, $ff, $9f, $5d
'-'                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
	byte	$03, $86, $47, $f0
'-'                 waitx   hr1                             ' it down to smaller wait chunks
	byte	$1f, $86, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
	byte	$e0, $ff, $9f, $ad
'-'         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
	byte	$28, $00, $90, $5d
'-' .se1_test
'-'                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$fc, $fe, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
	byte	$00, $be, $06, $56
'-'         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
	byte	$b0, $ff, $9f, $5d
'-' .se1            'SE1 is a fatal error condition
'-'                 mov     hctwait, _100ms_
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$e4, $fe, $bf, $fd
'-'                 mov     retval, #ERR_SE1
	byte	$03, $be, $06, $f6
'-'                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
	byte	$88, $f7, $bf, $fd
'-' .connect_test                                           ' Test lines until stable J/K state seen
'-'                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
	byte	$1f, $60, $63, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #discon_entry                   ' D+ and D- low
	byte	$90, $ff, $9f, $ad
'-'         if_e    jmp     #.se1_test                      ' D+ and D- high
	byte	$c4, $ff, $9f, $ad
'-' connected
'-'                 bith    hstatus, #CONNECTEDB            ' Device plugged in
	byte	$01, $96, $26, $f4
'-'                 call    #on_connect                     ' Initial device configuration
	byte	$34, $fb, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #discon_entry
	byte	$7c, $ff, $9f, $5d
'-' .set_pulse
'-'                 getct   _pulse_time_
	byte	$1a, $64, $63, $fd
'-'                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
	byte	$b1, $65, $03, $f1
'-' ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
'-' ' of 1ms and make a correction, if necessary.
'-' '                mov     htmp, _1ms_
'-' '                subs    htmp, iframe_delta
'-' '                adds    _frame1ms_clks_, htmp
'-' '                debug(udec(_frame1ms_clks_))
'-' 
'-'                 ' Fall through to idle/processing loop
'-'                 cmp     hdev_port, #MAX_DEVICES wcz
	byte	$07, $5a, $1e, $f2
'-'         if_a    mov     hdev_port, #0 
	byte	$00, $5a, $06, $16
'-' 
'-' hidle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_c    jmp     #.se0_test
	byte	$98, $00, $90, $cd
'-'                 pollct3                         wc
	byte	$24, $06, $70, $fd
'-'         if_nc   jmp     #.nopoll
	byte	$68, $00, $90, $3d
'-'                 getct   hct3
	byte	$1a, $94, $63, $fd
'-'                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
	byte	$a7, $95, $73, $fa
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $70, $e3, $f8
'-' 
'-'                 cmp     htmp, #HUB_READY        wz
	byte	$09, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_hub_status - @usb_host_start
	byte	$88, $1b, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$40, $00, $90, $ad
'-' 
'-'         if _HAVE_GAMEPAD
'-'                 cmp     htmp, #HID_READY        wz
	byte	$06, $70, $0f, $f2
'-'         if_nz   cmp     htmp, #PS3_READY        wz
	byte	$08, $70, $0f, $52
'-'         if_nz   cmp     htmp, #XINPUT_READY     wz
	byte	$07, $70, $0f, $52
'-'         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
	byte	$10, $16, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$2c, $00, $90, $ad
'-'         end
'-' 
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$34, $15, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$20, $00, $90, $ad
'-'         end
'-' 
'-'                 cmp     htmp, #KB_READY         wz
	byte	$03, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$9c, $13, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$14, $00, $90, $ad
'-' 
'-'                 cmp     htmp, #KBM_READY        wz
	byte	$05, $70, $0f, $f2
'-'         if_nz   jmp     #.skip_poll
	byte	$14, $00, $90, $5d
'-'                 bitnot  hstatus, #KBM_TOGGLEB   wcz
	byte	$09, $96, $fe, $f4
'-'         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$9c, $13, $80, $3e
'-'         if HAVE_MOUSE
'-'         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$34, $15, $80, $ce
'-'         else
'-'         end
'-' 
'-' .poll
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-' .skip_poll
'-' 
'-'                 incmod  hdev_port, #MAX_DEVICES
	byte	$07, $5a, $06, $f7
'-' 
'-' .nopoll
'-'                 cmp     cmd_data, #CMD_SUSPEND  wz
	byte	$0e, $40, $0e, $f2
'-'         if_z    jmp     #hsuspend
	byte	$44, $00, $90, $ad
'-'                 cmp     cmd_data, #CMD_RESET    wz
	byte	$10, $40, $0e, $f2
'-'         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
	byte	$00, $40, $06, $a6
'-'         if_z    jmp     #host_reset                     ' See if it works...
	byte	$68, $fe, $9f, $ad
'-'                 getct   hr0
	byte	$1a, $84, $63, $fd
'-'                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
	byte	$b2, $85, $1b, $f2
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'         if_ae   getct   _pulse_time_
	byte	$1a, $64, $63, $3d
'-'         if_ae   add     _pulse_time_, _500ms_
	byte	$b1, $65, $03, $31
'-'                 jmp     #hidle
	byte	$5c, $ff, $9f, $fd
'-' ' Check for extended SE0 state on the bus
'-' .se0_test
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
	byte	$fc, $fd, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_nc   jmp     #hidle                          ' Bus still IDLE
	byte	$48, $ff, $9f, $3d
'-'                 call    #wait_txn_ok
	byte	$24, $f6, $bf, $fd
'-'                 wypin   ##OUT_IDLE, dm                  ' Float USB
	byte	$00, $00, $80, $ff, $22, $01, $28, $fc
'-'                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
'-'                 jmp     #host_reset                     ' Device disconnected
	byte	$30, $fe, $9f, $fd
'-' 
'-' hsuspend
'-'                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
	byte	$14, $f6, $bf, $fd
'-'                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
	byte	$25, $00, $64, $fd
'-'                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
	byte	$1f, $52, $63, $fd
'-'                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
	byte	$22, $01, $28, $fc
'-'                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
	byte	$00, $40, $06, $f6
'-'                 mov     mod_cnt, #0
	byte	$00, $96, $07, $f6
'-' 
'-'                 ' Fall through to resume wait loop
'-' 
'-' hwait_resume
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
	byte	$14, $86, $07, $fb
'-'                 shr     hr1, #2
	byte	$02, $86, $47, $f0
'-'                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
	byte	$1f, $86, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 cmp     cmd_data, #CMD_RESUME   wz
	byte	$0f, $40, $0e, $f2
'-'         if_nz   jmp     #hwait_resume
	byte	$ec, $ff, $9f, $5d
'-'                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
	byte	$14, $70, $07, $fb
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $71, $0b, $f2
'-'         if_z    jmp     #.resume
	byte	$18, $00, $90, $ad
'-'                 loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $fd
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
	byte	$22, $6d, $13, $3c
'-'         if_c    wxpin   _usb_h_ls_nco_, dm
	byte	$22, $69, $13, $cc
'-' .resume
'-'                 wypin   #OUT_K, dm
	byte	$22, $05, $28, $fc
'-'                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
	byte	$1f, $5c, $63, $fd
'-'                 wypin   #OUT_SE0, dm
	byte	$22, $03, $28, $fc
'-'                 mov     htmp, _ip_delay_ls_
	byte	$a2, $71, $03, $f6
'-'                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
	byte	$01, $70, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $70, $63, $fd
'-'                 wypin   #OUT_J, dm
	byte	$22, $07, $28, $fc
'-'                 shr     htmp, #1
	byte	$01, $70, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $70, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 setint1 #1                              ' Enable the 1ms frame ISR
	byte	$25, $02, $64, $fd
'-'                 mov     hctwait, _4ms_
	byte	$aa, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
	byte	$50, $fd, $bf, $fd
'-'         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
	byte	$00, $40, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send preamble to enable low-speed HUB ports
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   USB baud rate set to low-speed
'-' '------------------------------------------------------------------------------
'-' utx_pre
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   #0, dm                          ' Disable smartpin mode
	byte	$22, $01, $08, $fc
'-'                 drvl    dm
	byte	$58, $44, $62, $fd
'-'                 drvh    dp
	byte	$59, $46, $62, $fd
'-' 
'-'                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
	byte	$1e, $00, $00, $ff, $80, $70, $07, $f6
'-' 
'-'                 rep     @.l1, #16 + 1
	byte	$11, $08, $dc, $fc
'-'                 shr     htmp, #1        wc
	byte	$01, $70, $57, $f0
'-'         if_nc   setq    #1
	byte	$28, $02, $64, $3d
'-'         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
	byte	$4f, $44, $62, $3d
'-'                 waitx   _preamble_wait_
	byte	$1f, $4c, $63, $fd
'-' .l1
'-' 
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
	byte	$22, $69, $13, $fc
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a4, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a2, $9b, $02, $06
'-' 
'-' hlut_end
'-'                 fit     $400
'-'                 orgh
'-' if OVERLAP_MEMORY
'-'                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
'-' end
'-' '------------------------------------------------------------------------------
'-' ' Routines called from cog space.
'-' '------------------------------------------------------------------------------
'-' ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'-' '------------------------------------------------------------------------------
'-' 
'-' '------------------------------------------------------------------------------
'-' ' USB host cog initialization.
'-' '------------------------------------------------------------------------------
'-' usb_host_init
'-'                 ' Initialize buffer pointers
'-'         if OVERLAP_MEMORY
'-'         else
'-'                 loc     pb, #hid_descr
	byte	$40, $15, $b0, $fe
'-'         end
'-'                 mov     hid_descr_p, pb
	byte	$f7, $4b, $02, $f6
'-'                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
'-'                 {
'-'                 }
'-'         
'-'                 {
'-'                 }
'-'                 'loc     pb,#hkbd_report
'-'                 'mov     hkbd_report_p,pb
'-' 
'-'                 loc     pb, #hub_descr
	byte	$08, $1d, $b0, $fe
'-'                 mov     hub_descr_p, pb
	byte	$f7, $4d, $02, $f6
'-'                 loc     pb, #urx_buff
	byte	$1d, $1d, $b0, $fe
'-'                 mov     urx_buff_p, pb
	byte	$f7, $4f, $02, $f6
'-'                 loc     pb, #dev_desc_buff
	byte	$95, $1d, $b0, $fe
'-'                 mov     dev_desc_buff_p, pb
	byte	$f7, $51, $02, $f6
'-'                 loc     pb, #con_desc_buff
	byte	$9f, $1d, $b0, $fe
'-'                 mov     con_desc_buff_p, pb
	byte	$f7, $53, $02, $f6
'-'                 loc     pb, #usb_cache_start
	byte	$18, $15, $b0, $fe
'-'                 mov     cache_start_p, pb
	byte	$f7, $55, $02, $f6
'-'                 loc     pb, #usb_cache_end
	byte	$e9, $1c, $b0, $fe
'-'                 mov     cache_end_p, pb
	byte	$f7, $57, $02, $f6
'-' 
'-'         if ERROR_LED >= 0
'-'         end
'-' 
'-'                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
'-'                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
'-'                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
'-' ' Configure and enable the Serial Host USB port.
'-'                 jmp     #host_reset                     ' Initialize host and enter main processing loop
	byte	$03, $03, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Timing calculations happen before any interrupt(s) are enabled.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   htmp - current CLKFREQ value.
'-' '------------------------------------------------------------------------------
'-' hinit_usb_timings
'-' '                getct   htmp2
'-'                 mov     save_sysclk, htmp
	byte	$b8, $59, $02, $f6
'-'                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
	byte	$8d, $5b, $80, $ff, $2c, $01, $2a, $fd
'-'                 getqx   _12Mbps_
	byte	$18, $30, $63, $fd
'-'                 shr     _12Mbps_, #16           wc
	byte	$10, $30, $57, $f0
'-'                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
	byte	$00, $30, $27, $f1
'-'                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
	byte	$03, $6c, $07, $f6
'-'                 shl     _usb_h_fs_nco_, #14
	byte	$0e, $6c, $67, $f0
'-'                 add     _usb_h_fs_nco_, _12Mbps_
	byte	$98, $6d, $03, $f1
'-'                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
	byte	$01, $6e, $07, $f6
'-'                 shl     _usb_d_fs_nco_, #14
	byte	$0e, $6e, $67, $f0
'-'                 add     _usb_d_fs_nco_, _12Mbps_
	byte	$98, $6f, $03, $f1
'-'                 mov     _1_5Mbps_, _12Mbps_
	byte	$98, $33, $03, $f6
'-'                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
	byte	$03, $32, $47, $f0
'-'                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
	byte	$02, $68, $07, $f6
'-'                 shl     _usb_h_ls_nco_, #14
	byte	$0e, $68, $67, $f0
'-'                 add     _usb_h_ls_nco_, _1_5Mbps_
	byte	$99, $69, $03, $f1
'-'                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
	byte	$99, $6b, $03, $f6
'-'                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
	byte	$80, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1b
	byte	$65, $cd, $1d, $ff, $00, $2e, $27, $fd
'-'                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
	byte	$18, $34, $63, $fd
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1m
	byte	$a1, $07, $00, $ff, $40, $2e, $27, $fd
'-'                 getqx   _1us_                           ' 1us as 32,9 fixed point
	byte	$18, $36, $63, $fd
'-'                 mov     hsave0, _1us_                   ' Save it to compute other us values
	byte	$9b, $7b, $03, $f6
'-'                 shr     _1us_, #9               wc
	byte	$09, $36, $57, $f0
'-'                 addx    _1us_, #0                       ' Round to final value
	byte	$00, $36, $27, $f1
'-'                 qmul    hsave0, #10                     ' Calc 10us
	byte	$0a, $7a, $07, $fd
'-'                 getqx   _10us_
	byte	$18, $38, $63, $fd
'-'                 shr     _10us_, #9              wc
	byte	$09, $38, $57, $f0
'-'                 addx    _10us_, #0                      ' 10us
	byte	$00, $38, $27, $f1
'-'                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
	byte	$21, $7a, $07, $fd
'-'                 getqx   _33us_
	byte	$18, $3a, $63, $fd
'-'                 shr     _33us_, #9              wc
	byte	$09, $3a, $57, $f0
'-'                 addx    _33us_, #0                      ' 33us
	byte	$00, $3a, $27, $f1
'-'                 qmul    hsave0, #250                    ' Calc 250us
	byte	$fa, $7a, $07, $fd
'-'                 getqx   _txn_err_
	byte	$18, $3c, $63, $fd
'-'                 shr     _txn_err_, #9           wc
	byte	$09, $3c, $57, $f0
'-'                 addx    _txn_err_, #0                   ' 250us
	byte	$00, $3c, $27, $f1
'-'                 qmul    hsave0, #500                    ' Calc 500us
	byte	$f4, $7b, $07, $fd
'-'                 getqx   _500us_
	byte	$18, $3e, $63, $fd
'-'                 shr     _500us_, #9             wc
	byte	$09, $3e, $57, $f0
'-'                 addx    _500us_, #0                     ' 500us
	byte	$00, $3e, $27, $f1
'-'                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
	byte	$01, $00, $00, $ff, $9a, $7a, $07, $fd
'-'                 getqx   _txn_ok_ls_
	byte	$18, $40, $63, $fd
'-'                 shr     _txn_ok_ls_, #9         wc
	byte	$09, $40, $57, $f0
'-'                 addx    _txn_ok_ls_, #0                 ' 666us
	byte	$00, $40, $27, $f1
'-'                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
	byte	$01, $00, $00, $ff, $52, $7b, $07, $fd
'-'                 getqx   _txn_ok_fs_
	byte	$18, $42, $63, $fd
'-'                 shr     _txn_ok_fs_, #9         wc
	byte	$09, $42, $57, $f0
'-'                 addx    _txn_ok_fs_, #0                 ' 850us
	byte	$00, $42, $27, $f1
'-'                 mov     _ip_delay_ls_, _1ns16fp_
	byte	$9a, $45, $03, $f6
'-'                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
	byte	$05, $00, $00, $ff, $80, $44, $07, $fa
'-'                 shr     _ip_delay_ls_, #16      wc
	byte	$10, $44, $57, $f0
'-'                 addx    _ip_delay_ls_, #0
	byte	$00, $44, $27, $f1
'-'                 mov     _tat_wait_ls_, _1ns16fp_
	byte	$9a, $49, $03, $f6
'-'                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
	byte	$1c, $00, $00, $ff, $c0, $49, $07, $fa
'-'                 shr     _tat_wait_ls_, #16      wc
	byte	$10, $48, $57, $f0
'-'                 addx    _tat_wait_ls_, #0
	byte	$00, $48, $27, $f1
'-'                 mov     _ip_delay_fs_, _1ns16fp_
	byte	$9a, $47, $03, $f6
'-'                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
	byte	$00, $00, $00, $ff, $4e, $47, $07, $fa
'-'                 shr     _ip_delay_fs_, #16      wc
	byte	$10, $46, $57, $f0
'-'                 addx    _ip_delay_fs_, #0
	byte	$00, $46, $27, $f1
'-'                 mov     _tat_wait_fs_, _1ns16fp_
	byte	$9a, $4b, $03, $f6
'-'                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
	byte	$04, $00, $00, $ff, $23, $4b, $07, $fa
'-'                 shr     _tat_wait_fs_, #16      wc
	byte	$10, $4a, $57, $f0
'-'                 addx    _tat_wait_fs_, #0
	byte	$00, $4a, $27, $f1
'-'                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
	byte	$8d, $5b, $00, $ff, $00, $59, $16, $fd
'-'                 getqx   _preamble_wait_
	byte	$18, $4c, $63, $fd
'-'                 sub     _preamble_wait_,# 9 - 1
	byte	$08, $4c, $87, $f1
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1thou
	byte	$01, $00, $00, $ff, $e8, $2f, $27, $fd
'-'                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
	byte	$18, $4e, $63, $fd
'-'                 shr     _1ms_, #9               wc
	byte	$09, $4e, $57, $f0
'-'                 addx    _1ms_, #0                       ' 1ms
	byte	$00, $4e, $27, $f1
'-'                 mov     _frame1ms_clks_, ##-14
	byte	$ff, $ff, $7f, $ff, $f2, $67, $07, $f6
'-'                 adds    _frame1ms_clks_, _1ms_
	byte	$a7, $67, $43, $f1
'-'                 mov     _2ms_, _1ms_
	byte	$a7, $51, $03, $f6
'-'                 shl     _2ms_, #1                       ' 2ms
	byte	$01, $50, $67, $f0
'-'                 mov     _suspend_wait_, _1ms_
	byte	$a7, $53, $03, $f6
'-'                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
	byte	$a7, $53, $03, $f1
'-'                 mov     _4ms_, _1ms_
	byte	$a7, $55, $03, $f6
'-'                 shl     _4ms_, #2                       ' 4ms
	byte	$02, $54, $67, $f0
'-'                 mov     _xfer_wait_, _4ms_
	byte	$aa, $57, $03, $f6
'-'                 add     _xfer_wait_, _1ms_              ' 5ms
	byte	$a7, $57, $03, $f1
'-'                 mov     _reset_hold_, _xfer_wait_       ' 5ms
	byte	$ab, $5b, $03, $f6
'-'                 mov     _resume_hold_, _reset_hold_
	byte	$ad, $5d, $03, $f6
'-'                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
	byte	$02, $5c, $67, $f0
'-'                 mov     _100ms_, _resume_hold_          ' 20ms
	byte	$ae, $61, $03, $f6
'-'                 shl     _100ms_, #1                     ' 40ms
	byte	$01, $60, $67, $f0
'-'                 mov     _8ms_, _1ms_
	byte	$a7, $59, $03, $f6
'-'                 shl     _8ms_, #3                       ' 8ms
	byte	$03, $58, $67, $f0
'-'                 shl     _reset_hold_, #1                ' 10ms
	byte	$01, $5a, $67, $f0
'-'                 add     _100ms_, _reset_hold_           ' 50ms
	byte	$ad, $61, $03, $f1
'-'                 add     _reset_hold_, _xfer_wait_       ' 15ms
	byte	$ab, $5b, $03, $f1
'-'                 mov     _21ms_, _xfer_wait_             ' 5ms
	byte	$ab, $5f, $03, $f6
'-'                 shl     _21ms_, #2                      ' 20ms
	byte	$02, $5e, $67, $f0
'-'                 add     _21ms_, _1ms_                   ' 21ms
	byte	$a7, $5f, $03, $f1
'-'                 mov     _500ms_, _100ms_                ' 50ms
	byte	$b0, $63, $03, $f6
'-'                 shl     _100ms_, #1                     ' 100ms
	byte	$01, $60, $67, $f0
'-'                 shl     _500ms_, #3                     ' 400ms
	byte	$03, $62, $67, $f0
'-'         _ret_   add     _500ms_, _100ms_                ' 500ms
	byte	$b0, $63, $03, $01
'-' '        _ret_   mov     _1sec_, save_sysclk
'-' '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'-' '                ret
'-' {
'-' }
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Parse a configuration descriptor chain to see if the device is a recognized
'-' ' one. If it is, start the task progression that will configure the device for
'-' ' use.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hconfig_base - start address of the cached config descriptor chain.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hparse_con_desc
'-'                 mov     ptrb, dev_desc_buff_p
	byte	$28, $f3, $03, $f6
'-'                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
	byte	$82, $71, $07, $fb
'-'                 altr    hdev_port,#hdev_id
	byte	$61, $5b, $86, $f9
'-'                 movbyts htmp,#%%1032
	byte	$4e, $70, $ff, $f9
'-'                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
	byte	$86, $d3, $e6, $fa
'-'                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
'-' 
'-'                 mov     pa, #CON_wTotalLen
	byte	$02, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
	byte	$f6, $df, $e2, $fa
'-'                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
'-' ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
'-' ' that defines a keyboard and/or mouse.
'-'                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
	byte	$6e, $eb, $c2, $fa
'-' .next_intf
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #hset_config
	byte	$bc, $01, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $70, $0f, $f2
'-'         if_z    jmp     #.intf
	byte	$0c, $00, $90, $ad
'-'                 rdbyte  htmp, ptrb
	byte	$80, $71, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b8, $eb, $02, $f1
'-'                 jmp     #.next_intf
	byte	$d8, $ff, $9f, $fd
'-' .intf
'-'                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
	byte	$00, $8e, $07, $f6
'-'                 mov     hpar3, #0
	byte	$00, $90, $07, $f6
'-'                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
	byte	$82, $e1, $c6, $fa
'-'                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
	byte	$85, $e3, $c6, $fa
'-'                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
	byte	$86, $e5, $c6, $fa
'-'                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
	byte	$87, $e7, $c6, $fa
'-'                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
'-' 
'-' .endp
'-'                 rdbyte  htmp, ptrb
	byte	$80, $71, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b8, $eb, $02, $f1
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #.get_device
	byte	$78, $00, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $70, $0f, $f2
'-'         if_z    jmp     #.get_device
	byte	$64, $00, $90, $ad
'-'                 cmp     htmp, #TYPE_ENDPOINT    wz
	byte	$05, $70, $0f, $f2
'-'         if_z    jmp     #.get_ep
	byte	$04, $00, $90, $ad
'-'                 jmp     #.endp
	byte	$d0, $ff, $9f, $fd
'-' .get_ep
'-'                 rdbyte  hr1, ptrb[ENDP_bAddress]
	byte	$82, $87, $c7, $fa
'-'                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
	byte	$07, $86, $17, $f4
'-'                 shl     hr1, #8 + 7
	byte	$0f, $86, $67, $f0
'-'                 mov     htmp, hctrl_ep_addr
	byte	$6c, $71, $03, $f6
'-'                 and     htmp, ##ADDR_MASK
	byte	$3f, $00, $00, $ff, $00, $71, $07, $f5
'-'                 or      htmp, hr1                       ' endpoint address
	byte	$c3, $71, $43, $f5
'-'                 cmp     hpar2, #0               wz
	byte	$00, $8e, $0f, $f2
'-'  if_z_and_c     jmp     #.in_ep
	byte	$0c, $00, $90, $8d
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'  if_z_and_nc    jmp     #.out_ep
	byte	$18, $00, $90, $2d
'-'                 jmp     #.endp
	byte	$a0, $ff, $9f, $fd
'-' .in_ep
'-'                 mov     hpar2, htmp                     ' IN endpoint
	byte	$b8, $8f, $03, $f6
'-'                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
	byte	$84, $89, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $85, $c7, $fa
'-'                 setbyte hr2, hr0, #3
	byte	$c2, $89, $db, $f8
'-'                 jmp     #.endp
	byte	$8c, $ff, $9f, $fd
'-' .out_ep
'-'                 mov     hpar3, htmp                     ' OUT endpoint
	byte	$b8, $91, $03, $f6
'-'                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8b, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $85, $c7, $fa
'-'                 setbyte hr3, hr0, #3
	byte	$c2, $8b, $db, $f8
'-'                 jmp     #.endp
	byte	$78, $ff, $9f, $fd
'-' 
'-' .get_device
'-'                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
	byte	$ff, $e2, $0e, $f2
'-'         if_z    cmp     hdev_subclass, #$5D     wz
	byte	$5d, $e4, $0e, $a2
'-'         if_z    cmp     hdev_protocol, #$01     wz
	byte	$01, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$68, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HUB  wz
	byte	$09, $e2, $0e, $f2
'-'         if_z    jmp     #.hub
	byte	$ac, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HID              wz
	byte	$03, $e2, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No HID class, ignore
	byte	$18, $ff, $9f, $5d
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_z    cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$4c, $00, $90, $ad
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
	byte	$01, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
	byte	$04, $ff, $9f, $5d
'-' .keyboard
'-'                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
	byte	$01, $e6, $0e, $f2
'-'         if HAVE_MOUSE
'-'         if_nz  jmp      #.mouse                         ' No Keyboard
	byte	$1c, $00, $90, $5d
'-'         else
'-'         end
'-'                 cmp     hkbd_ep_addr, #0    wz
	byte	$00, $f2, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$f4, $fe, $9f, $5d
'-'                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6f, $e2, $f8
'-'                 getbyte kb_interval, hr2, #3
	byte	$c4, $71, $fa, $f8
'-'                 getbyte kb_in_max_pkt, hr2, #0
	byte	$c4, $73, $e2, $f8
'-'                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
	byte	$c7, $f3, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$e0, $fe, $9f, $fd
'-' if HAVE_MOUSE
'-' .mouse
'-'                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
	byte	$02, $e6, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No Mouse
	byte	$d8, $fe, $9f, $5d
'-'                 cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$d0, $fe, $9f, $5d
'-'                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6b, $e2, $f8
'-'                 'getbyte ms_interval, hr2, #3
'-'                 getbyte ms_in_max_pkt, hr2, #0
	byte	$c4, $6d, $e2, $f8
'-'                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
	byte	$c7, $f5, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$c0, $fe, $9f, $fd
'-' end
'-' .gamepad
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $71, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c7, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$ac, $fe, $9f, $ad
'-'         if HAVE_MOUSE
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $71, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c7, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$98, $fe, $9f, $ad
'-'         end
'-'                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz      ' |
	byte	$00, $00, $0c, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$8c, $fe, $9f, $5d
'-' 
'-'                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $79, $e2, $f8
'-'                 getbyte gp_interval, hr2, #3
	byte	$c4, $7b, $fa, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, hpar2                      ' IN endpoint address
	byte	$c7, $01, $00, $f6
'-'                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
	byte	$c8, $0b, $03, $f6
'-'                 'debug(udec(gp_intf_num))
'-'                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
'-'                 jmp     #.next_intf
	byte	$74, $fe, $9f, $fd
'-' .hub
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$6c, $fe, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_nz   cmp     hdev_protocol, #2                   wz
	byte	$02, $e6, $0e, $52
'-'         if_nz   jmp     #.next_intf
	byte	$60, $fe, $9f, $5d
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$58, $fe, $9f, $5d
'-'                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
	byte	$70, $63, $e2, $f8
'-'                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $ed, $02, $f6
'-'                 mov     ep_addr_pid, hpar2              ' IN endpoint address
	byte	$c7, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 mov     hhub_ep_addr, ep_addr_pid
	byte	$5e, $ef, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
	byte	$6c, $bd, $02, $f6
'-'                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
'-'                 jmp     #.next_intf
	byte	$3c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' If a newly-connected device is recognized, do whatever is needed to configure
'-' ' it according to its function, or functions. In the case of this boot protocol
'-' ' keyboard/mouse class driver:
'-' ' - SetConfiguration(config_num)
'-' ' - SetProtocol(boot)
'-' ' - SetIdle(indefinite)
'-' ' - Enter the device interrupt IN polling task stage.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_config
'-' '                mov     hkbd_ep_addr, #0                ' DEBUG
'-' '                mov     hmouse_ep_addr, #0              ' DEBUG
'-'                 mov     htmp2, #DEV_UNKNOWN
	byte	$02, $74, $07, $f6
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $a2
'-'         if HAVE_MOUSE
'-'         if_z    cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $a2
'-'         end
'-'         if_z    cmp     hhub_ep_addr, #0        wz
	byte	$00, $ee, $0e, $a2
'-'         if_z    jmp     #.notify_client                 ' No known device
	byte	$4c, $03, $90, $ad
'-' .set_config
'-'                 loc     ptra, #set_config
	byte	$6c, $0e, $d0, $fe
'-'                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
	byte	$05, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdbyte  hpar1, pa
	byte	$f6, $8d, $c3, $fa
'-'                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
	byte	$01, $8d, $57, $fc
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
	byte	$6c, $bd, $02, $f6
'-'                 mov     pb, #0                          ' SetConfiguration() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-' .kbd_config
'-'                 cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $f2
'-'         if_z    jmp     #.mouse_config                  ' No keyboard
	byte	$98, $00, $90, $ad
'-' 
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.mouse_config                  ' No keyboard
	byte	$84, $00, $90, $5d
'-' 
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $71, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$34, $0e, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$e4, $02, $90, $5d
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8c, $07, $f6
'-'                 getbyte hpar2, kb_intf_num, #0
	byte	$37, $8f, $e3, $f8
'-'                 call    #hset_idle
	byte	$30, $03, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hkbd_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 mov     hctwait, _2ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
	byte	$00, $76, $06, $f6
'-'                 mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $f6
'-'                 loc     pa, #hkbd_led_rep
	byte	$90, $17, $90, $fe
'-'                 wrbyte  hkbd_ledstates,pa
	byte	$f6, $f9, $42, $fc
'-'                 call    #hset_kbdled_report
	byte	$2c, $03, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$b0, $02, $90, $5d
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hkbd_ep_addr, ep_addr_pid
	byte	$5e, $f3, $02, $f6
'-'                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $f1, $02, $f6
'-'                 bitc    hkbd_ctrl_ep, #31
	byte	$1f, $f0, $46, $f4
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
	byte	$00, $f6, $06, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $c6, $f8
'-'                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
	byte	$03, $74, $07, $f6
'-'         if !!HAVE_MOUSE
'-'         end
'-' 
'-' .mouse_config
'-' if HAVE_MOUSE
'-'                 cmp     hmouse_ep_addr, #0        wz
	byte	$00, $f4, $0e, $f2
'-'         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$ac, $00, $90, $ad
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$98, $00, $90, $5d
'-' 
'-'                 debug("mouse passed addr check")
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$b0, $0d, $d0, $fe
'-'                 wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $ff, $03, $01, $5e, $fc
'-'                 wrword  ms_intf_num,ptra[wIndex]
	byte	$02, $6b, $56, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$44, $02, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),uhex_byte_array(pb,total_data))
'-' 
'-'                 getbyte htmp, ms_intf_num, #0
	byte	$35, $71, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$64, $0d, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$14, $02, $90, $5d
'-'                 debug("mouse passed SetProtocol")
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8c, $07, $f6
'-'                 getbyte hpar2, ms_intf_num, #0
	byte	$35, $8f, $e3, $f8
'-'                 call    #hset_idle
	byte	$60, $02, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hmouse_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 debug("mouse passed SetIdle")
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hmouse_ep_addr, ep_addr_pid
	byte	$5e, $f5, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $ce, $f8
'-'                 mov     htmp2, hkbd_ep_addr
	byte	$79, $75, $03, $f6
'-'                 xor     htmp2, hmouse_ep_addr
	byte	$7a, $75, $63, $f5
'-'                 and     htmp2, ##ADDR_MASK              wz
	byte	$3f, $00, $00, $ff, $00, $75, $0f, $f5
'-'         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
	byte	$05, $74, $07, $a6
'-'         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
	byte	$04, $74, $07, $56
'-'                 jmp     #.notify_client
	byte	$d0, $01, $90, $fd
'-' end
'-' .gamepad_config
'-' if _HAVE_GAMEPAD
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    jmp     #.hub_config                    ' No gamepad
	byte	$58, $01, $90, $ad
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     htmp, 0-0
	byte	$00, $70, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.hub_config                    ' No gamepad
	byte	$40, $01, $90, $5d
'-' 
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, ep_addr_pid
	byte	$5e, $01, $00, $f6
'-'                 mov     ep_addr_pid, hdev_out_addr  wz
	byte	$85, $bd, $0a, $f6
'-'         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $58
'-'         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $5d
'-'         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $54
'-'         if_nz   bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $54
'-'         if_nz   mov     hdev_out_addr, ep_addr_pid
	byte	$5e, $0b, $03, $56
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 if EMUPAD_MAX_PLAYER > 0
'-'                 
'-' .rule_loop           
'-'                 end
'-' 
'-'                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
	byte	$ff, $e2, $0e, $f2
'-'         if_e    jmp     #.xinput
	byte	$5c, $00, $90, $ad
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     htmp,0-0
	byte	$00, $70, $03, $f6
'-'                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
	byte	$01, $a6, $02, $ff, $68, $70, $0f, $f2
'-'         if_e    jmp     #.ps3
	byte	$7c, $00, $90, $ad
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$a0, $0c, $d0, $fe
'-'                 cmp     hdev_port,#0            wz
	byte	$00, $5a, $0e, $f2
'-'         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $5f, $03, $01, $5e, $5c
'-'         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
	byte	$03, $00, $80, $af, $03, $01, $5e, $ac
'-'                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
	byte	$02, $01, $5c, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$24, $01, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),uhex_byte_array(pb,total_data))
'-' 
'-'                 mov     htmp2, #HID_READY               ' Standard gamepad
	byte	$06, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$10, $01, $90, $fd
'-' .xinput
'-'                 loc     ptra, #xinp_led_cmd             ' Turn on LED
	byte	$b4, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb,#1 ' root device is also player 1
	byte	$01, $ee, $e7, $f2
'-'                 fle     pb,#3
	byte	$03, $ee, $27, $f3
'-'                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
	byte	$06, $ee, $07, $f1
'-'                 wrbyte  pb, ptra[2]
	byte	$02, $ef, $47, $fc
'-' 
'-'                 mov     pkt_data, #3
	byte	$03, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB
	byte	$03, $96, $06, $f4
'-'                 mov     ep_addr_pid, hdev_out_addr
	byte	$85, $bd, $02, $f6
'-'                 call    #txn_out
	byte	$5a, $00, $a0, $fd
'-'                 mov     ep_addr_pid, hctrl_ep_addr
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 mov     htmp2, #XINPUT_READY
	byte	$07, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$dc, $00, $90, $fd
'-' .ps3
'-'                 loc     ptra, #ps3_command_buff         ' Turn on LED
	byte	$50, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 fge     pb,#1 ' root device is also player 1
	byte	$01, $ee, $07, $f3
'-'                 fle     pb,#4
	byte	$04, $ee, $27, $f3
'-'                 decod   pb
	byte	$f7, $ef, $c3, $f9
'-'                 wrbyte  pb, ptra[9]
	byte	$09, $ef, $47, $fc
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$00, $0c, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $03, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #48, ptra[wLength]
	byte	$03, $61, $5c, $fc
'-'                 loc     pb, #ps3_command_buff
	byte	$20, $0c, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$e0, $0b, $d0, $fe
'-'                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $e9, $5f, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #4, ptra[wLength]
	byte	$03, $09, $5c, $fc
'-'                 loc     pb, #ps3_enable_cmd             ' Enable PS3
	byte	$fc, $0b, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK    wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$74, $00, $90, $5d
'-' 
'-'                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
	byte	$08, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$6c, $00, $90, $fd
'-' end
'-' 
'-' .hub_config
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_z    jmp     #.notify_client                 ' No HUB
	byte	$64, $00, $90, $ad
'-'                 mov     htmp, hhub_ep_addr
	byte	$77, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.notify_client                 ' No HUB
	byte	$50, $00, $90, $5d
'-' 
'-'                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
	byte	$a0, $0b, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, hub_descr_p
	byte	$26, $ef, $03, $f6
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hhub_ep_addr, #0
	byte	$00, $ee, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $00, $90, $5d
'-'                 debug(uhex_byte_array(hub_descr_p,total_data))
'-' 
'-'                 mov     ptra, hub_descr_p
	byte	$26, $f1, $03, $f6
'-'                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
	byte	$02, $77, $c7, $fa
'-'                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
	byte	$07, $76, $27, $f3
'-'                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
'-' .pwr_loop
'-'                 loc     ptra, #set_port_feat            ' Power on ports
	byte	$80, $0b, $d0, $fe
'-'                 wrword  #HUB_PORT_POWER, ptra[wValue]
	byte	$01, $11, $5c, $fc
'-'                 wrword  htmp3, ptra[wIndex]
	byte	$02, $77, $57, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 djnz    htmp3, #.pwr_loop
	byte	$fb, $77, $6f, $fb
'-' 
'-'                 mov     hctwait, _500ms_
	byte	$b1, $99, $02, $f6
'-'                 add     hctwait, _100ms_
	byte	$b0, $99, $02, $f1
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 mov     htmp2, #HUB_READY               ' Hub ready
	byte	$09, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$00, $00, $90, $fd
'-' 
'-' .notify_client
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte htmp2                           ' Save device ready
	byte	$ba, $01, $c0, $f8
'-'                 debug(uhex_long(hdev_type,hdev_type+1))
'-'         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Initialize the keyboard/mouse data area to start-up values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' init_kbdm_data
'-'                 mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $f6
'-'                 mov     hdev_ep_addr, #0
	byte	$00, $fa, $06, $f6
'-' 
'-'                 mov     ptra, cache_start_p         ' Clear cached data buffers
	byte	$2a, $f1, $03, $f6
'-'                 mov     pa, cache_end_p
	byte	$2b, $ed, $03, $f6
'-' .loop
'-'                 wrbyte  #0, ptra++
	byte	$61, $01, $4c, $fc
'-'                 cmp     ptra, pa                wcz
	byte	$f6, $f1, $1b, $f2
'-'         if_b    jmp     #.loop
	byte	$f4, $ff, $9f, $cd
'-'         
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' 
'-'                 mov     pa, #hdev_init_start        ' Clear device data registers
	byte	$2d, $ed, $07, $f6
'-' .regloop
'-'                 altd    pa
	byte	$00, $ec, $8f, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-'                 add     pa, #1
	byte	$01, $ec, $07, $f1
'-'                 cmp     pa, #hdev_init_end      wz
	byte	$47, $ed, $0f, $f2
'-'         if_nz   jmp     #.regloop
	byte	$ec, $ff, $9f, $5d
'-' 
'-'                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
	byte	$e1, $e1, $61, $ff, $c3, $5d, $06, $f6
'-'                 mov     hdev_next_datax + 1,hdev_next_datax
	byte	$2e, $5f, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0
	byte	$c3, $60, $c6, $f8
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1
	byte	$c3, $60, $ce, $f8
'-' 
'-'         _ret_   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
'-' ' function.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'-' '   hpar2 - index number of the target interface.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_idle
'-'                 mov     hctwait, _2ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #set_idle
	byte	$d8, $0a, $d0, $fe
'-'                 wrword  hpar1, ptra[wValue]
	byte	$01, $8d, $57, $fc
'-'                 wrword  hpar2, ptra[wIndex]
	byte	$02, $8f, $57, $fc
'-'                 jmp     #control_write
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
'-' ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - device address and enpoint for the request.
'-' ' On exit:
'-' '   retval - transaction result.
'-' '------------------------------------------------------------------------------
'-' hset_kbdled_report
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$cc, $0a, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
	byte	$01, $00, $80, $ff, $01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
	byte	$03, $03, $5c, $fc
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrbyte  kb_led_states, pb
	byte	$f7, $77, $42, $fc
'-'                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for keyboard activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_kbd_in_report
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #0
	byte	$30, $91, $e3, $f8
'-'                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
	byte	$39, $91, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
	byte	$30, $71, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
	byte	$4b, $60, $c6, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
	byte	$c3, $60, $c6, $58
'-' 
'-'                 mov     kb_max_index, hpar3             ' Save actual bytes read
	byte	$c8, $75, $02, $f6
'-'                 call    #hkbd_compare
	byte	$18, $00, $b0, $fd
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' .led_check
'-'                 mov     htmp, kb_led_states
	byte	$3b, $71, $03, $f6
'-'                 cmp     hkbd_ledstates, htmp    wz
	byte	$b8, $f9, $0a, $f2
'-'         if_z    ret                                     ' No toggle key indicator changes, so we're done
	byte	$2d, $00, $64, $ad
'-'                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
	byte	$7c, $77, $02, $f6
'-'                 mov     ep_addr_pid, hkbd_ctrl_ep
	byte	$78, $bd, $02, $f6
'-'                 jmp     #hset_kbdled_report             ' Set report and ignore errors
	byte	$88, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Compare current and previous keyboard data buffers for keypress changes.
'-' '------------------------------------------------------------------------------
'-' hkbd_compare
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$d4, $13, $f0, $fe
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $75, $07, $fb
'-'                 cmp     htmp1, htmp2    wz
	byte	$ba, $73, $0b, $f2
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $75, $07, $fb
'-'         if_z    cmp     htmp1, htmp2    wz
	byte	$ba, $73, $0b, $a2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-' 
'-'                 loc     ptra, #hkbd_report
	byte	$b4, $13, $d0, $fe
'-' 
'-'                 ' Handle modifiers
'-'                 rdbyte  hpar2, urx_buff_p
	byte	$27, $8f, $c3, $fa
'-'                 rdbyte  hr1, ptra
	byte	$00, $87, $c7, $fa
'-'                 rolword hr1,hpar2,#0
	byte	$c7, $87, $43, $f9
'-'                 mergew  hr1
	byte	$63, $86, $63, $fd
'-'                 mov     pa,#8
	byte	$08, $ec, $07, $f6
'-' .modloop
'-'                 rczr    hr1     wcz ' New value in C, old value in Z
	byte	$6a, $86, $7b, $fd
'-'                 mov     hpar1,#$E8
	byte	$e8, $8c, $07, $f6
'-'                 sub     hpar1,pa
	byte	$f6, $8d, $83, $f1
'-'       if_c_ne_z call    #hkbd_translate
	byte	$a0, $00, $b0, $6d
'-'                 djnz    pa,#.modloop
	byte	$fb, $ed, $6f, $fb
'-' 
'-' .release        modc    _set    wc
	byte	$6f, $e0, $75, $fd
'-'                 'alts    hdev_port, #hid_report_p
'-'                 'mov     ptra, hid_report_p
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .rl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8d, $cf, $fa
'-'         if_z    jmp     #.rl3
	byte	$20, $00, $90, $ad
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .rl2            rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b8, $8d, $0b, $f2
'-'         if_z    jmp     #.rl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.rl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$68, $00, $b0, $fd
'-' .rl3            djnz    pa, #.rl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-'                 mov     hpar3, #0
	byte	$00, $90, $07, $f6
'-'                 bith    hpar3, #31
	byte	$1f, $90, $27, $f4
'-' 
'-' .press          modc    _clr    wc
	byte	$6f, $00, $74, $fd
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .pl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8d, $cf, $fa
'-'         if_z    jmp     #.pl3
	byte	$20, $00, $90, $ad
'-'                 loc     ptrb, #hkbd_report
	byte	$30, $13, $f0, $fe
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .pl2            rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b8, $8d, $0b, $f2
'-'         if_z    jmp     #.pl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.pl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$24, $00, $b0, $fd
'-' .pl3            djnz    pa, #.pl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-' .copy           mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$08, $13, $f0, $fe
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 wrlong  htmp1, ptrb++
	byte	$e1, $73, $67, $fc
'-'                 wrbyte  hkbd_ledstates,ptrb++
	byte	$e1, $f9, $46, $fc
'-' 
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Translate keyboard scancode to ASCII
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - scancode
'-' '   hpar2 - key modifiers state
'-' '       c - pressed (0) or released (1) flag
'-' ' On exit:
'-' '   hpar1 - bit     31 = 0 pressed, 1 released
'-' '               30..17 = unused
'-' '                   18 = scroll-lock state 
'-' '                   17 = caps-lock state
'-' '                   16 = num-lock state 
'-' '                15..8 = key modifiers state
'-' '                 7..0 = scancode
'-' '------------------------------------------------------------------------------
'-' hkbd_translate
'-'                 cmp     hpar1, #KEY_CAPSLOCK    wz
	byte	$39, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
	byte	$01, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_NUMLOCK     wz
	byte	$53, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
	byte	$00, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_SCROLLLOCK  wz
	byte	$47, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
	byte	$02, $f8, $e6, $24
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' 
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' 
'-'         end
'-'                 setbyte hpar1, hpar2, #1
	byte	$c7, $8d, $cb, $f8
'-'                 setbyte hpar1, hkbd_ledstates,#2
	byte	$7c, $8d, $d3, $f8
'-'                 bitc    hpar1, #31
	byte	$1f, $8c, $47, $f4
'-'         if KEYQUEUE_SIZE > 0
'-'                 loc pb,#keyq_head
	byte	$c4, $09, $b0, $fe
'-'                 rdword htmp,pb
	byte	$f7, $71, $e3, $fa
'-'                 getbyte htmp1,htmp,#1 ' tail
	byte	$b8, $73, $eb, $f8
'-'                 getbyte htmp,htmp,#0 ' head
	byte	$b8, $71, $e3, $f8
'-'                 mov htmp2,htmp
	byte	$b8, $75, $03, $f6
'-'                 mul htmp2,#4
	byte	$04, $74, $07, $fa
'-'                 add htmp2,pb
	byte	$f7, $75, $03, $f1
'-'                 add htmp2,#2
	byte	$02, $74, $07, $f1
'-'                 incmod htmp,#KEYQUEUE_SIZE - 1
	byte	$7f, $70, $07, $f7
'-'                 cmp htmp1,htmp wz ' check buffer overflow
	byte	$b8, $73, $0b, $f2
'-'         if_nz   wrlong hpar1,htmp2
	byte	$ba, $8d, $63, $5c
'-'         if_nz   wrbyte htmp,pb
	byte	$f7, $71, $43, $5c
'-'         end
'-'                 ret wcz
	byte	$2d, $00, $7c, $fd
'-' 
'-' if HAVE_MOUSE
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for mouse activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_mouse_in_report
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #1
	byte	$30, $91, $eb, $f8
'-'                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
	byte	$36, $91, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
	byte	$30, $71, $eb, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
	byte	$4b, $60, $ce, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
	byte	$c3, $60, $ce, $58
'-' 
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 cmp     hpar3, #5               wcz     ' Hack: Combo PS/2-USB adapters adds report-id
	byte	$05, $90, $1f, $f2
'-'         if_ae   add     ptra, #1                        ' | skip
	byte	$01, $f0, $07, $31
'-'         if_ae   sub     hpar3, #1
	byte	$01, $90, $87, $31
'-' 
'-'                 loc     pa, #mouse_limits
	byte	$40, $09, $90, $fe
'-'                 loc     ptrb, #mouse_xacc
	byte	$25, $13, $f0, $fe
'-' 
'-'                 ' load xacc,yacc,zacc
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  hr1,ptrb
	byte	$80, $87, $07, $fb
'-'                 ' load limits and outptr
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  htmp1,pa
	byte	$f6, $73, $03, $fb
'-' 
'-'                 rdbyte  htmp, ptra++                     ' Button flags
	byte	$61, $71, $c7, $fa
'-'                 wrbyte  htmp, ptrb[12]                    ' write verbatim into extra byte
	byte	$8c, $71, $47, $fc
'-'                 testb   htmp,#0                 wc       ' left button flag
	byte	$00, $70, $17, $f4
'-'         if_c    wrbyte  #1,ptrb[13]
	byte	$8d, $03, $4c, $cc
'-'                 testb   htmp,#1                 wc       ' left button flag
	byte	$01, $70, $17, $f4
'-'         if_c    wrbyte  #1,ptrb[14]
	byte	$8e, $03, $4c, $cc
'-'                 testb   htmp,#2                 wc       ' left button flag
	byte	$02, $70, $17, $f4
'-'         if_c    wrbyte  #1,ptrb[15]
	byte	$8f, $03, $4c, $cc
'-'               
'-' 
'-'                 rdbyte  htmp, ptra++                     ' X direction and velocity is 8-bit signed
	byte	$61, $71, $c7, $fa
'-'                 signx   htmp, #7
	byte	$07, $70, $67, $f7
'-'                 add     hr1,htmp
	byte	$b8, $87, $03, $f1
'-'                 cmp     htmp1,#0 wz
	byte	$00, $72, $0f, $f2
'-'         if_ne   fles    hr1,htmp1
	byte	$b9, $87, $63, $53
'-'         if_ne   fges    hr1,#0
	byte	$00, $86, $47, $53
'-' 
'-'                 rdbyte  htmp, ptra++                     ' Y direction and velocity is 8-bit signed
	byte	$61, $71, $c7, $fa
'-'                 signx   htmp, #7
	byte	$07, $70, $67, $f7
'-'                 add     hr2,htmp
	byte	$b8, $89, $03, $f1
'-'                 cmp     htmp2,#0 wz
	byte	$00, $74, $0f, $f2
'-'         if_ne   fles    hr2,htmp2
	byte	$ba, $89, $63, $53
'-'         if_ne   fges    hr2,#0
	byte	$00, $88, $47, $53
'-'                 
'-' 
'-'                 cmp     hpar3, #4               wz      ' Very few mice send +/- scroll wheel data in boot protocol
	byte	$04, $90, $0f, $f2
'-'         if_z    rdbyte  htmp, ptra
	byte	$00, $71, $c7, $aa
'-'         if_z    signx   htmp, #7                        ' If it's there, use it
	byte	$07, $70, $67, $a7
'-'         if_z    add     hr3,htmp
	byte	$b8, $8b, $03, $a1
'-' 
'-'                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
	byte	$90, $71, $cf, $fa
'-'         if_nz   ret                                     ' If so, don't write results
	byte	$2d, $00, $64, $5d
'-' 
'-'                 ' write back accumulators
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 wrlong  hr1,ptrb
	byte	$80, $87, $67, $fc
'-'                 ' if outptr set, write X/Y words
'-'                 cmp htmp3,#0                    wz
	byte	$00, $76, $0f, $f2
'-'         if_nz   setword hr1,hr2,#1
	byte	$c4, $87, $2b, $59
'-'         if_nz   wrlong hr1,htmp3
	byte	$bb, $87, $63, $5c
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' hget_gp_in_report
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-' 
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 altgb   hdev_port, #hdev_next_datax
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte hpar3
	byte	$00, $90, $e3, $f8
'-'                 setword hpar3, #255, #1                 ' Always ask for max report size
	byte	$ff, $90, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-'                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte htmp                            ' |
	byte	$00, $70, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    mov     htmp, #PID_DATA1                ' |
	byte	$4b, $70, $07, $a6
'-'         if_nz   mov     htmp, #PID_DATA0                ' |
	byte	$c3, $70, $07, $56
'-'                 altsb   hdev_port, #hdev_next_datax     ' |
	byte	$2e, $5b, $66, $f9
'-'                 setbyte htmp                            ' |
	byte	$b8, $01, $c0, $f8
'-' 
'-' ' Note: the following code compares the current and previous reports
'-' ' and process the data if there are changes to ease the debug output.
'-' ' Actual implementations should remove this block, along with hid_pre_rpt_p and
'-' ' gpPreReport buffer.
'-' 
'-'                 ' ----- start of block to remove
'-'                 {
'-'                 }
'-'                 ' ----- end of block to remove
'-'                 loc pa,#hpad_translate
	byte	$f4, $04, $90, $fe
'-'                 push pa
	byte	$2a, $ec, $63, $fd
'-' 
'-'                 ' FALL THROUGH !!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Decode controller report
'-' '------------------------------------------------------------------------------
'-' hid_decode
'-'                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
'-'                 setq #(hidr_end-hidr_start)-1
	byte	$28, $1e, $64, $fd
'-'                 rdlong  hidr_start,##$8_0000
	byte	$00, $04, $00, $ff, $00, $0c, $07, $fb
'-' 
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte hidr_type
	byte	$00, $2a, $e3, $f8
'-'                 cmp     hidr_type, #XINPUT_READY        wz
	byte	$07, $2a, $0f, $f2
'-'         if_z    jmp     #hpad_xinput
	byte	$34, $02, $90, $ad
'-'                 cmp     hidr_type, #PS3_READY           wz
	byte	$08, $2a, $0f, $f2
'-'         if_z    jmp     #hpad_ps3
	byte	$1c, $03, $90, $ad
'-'                 cmp     hidr_type, #KBM_READY           wz
	byte	$05, $2a, $0f, $f2
'-'         if_z    mov     hidr_type,#M_READY
	byte	$04, $2a, $07, $a6
'-'                 cmp     hidr_type, #M_READY             wz
	byte	$04, $2a, $0f, $f2
'-'                 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle HID controller (or mouse now
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' hpad_hid
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 mov     ptra, pb
	byte	$f7, $f1, $03, $f6
'-'                 alts    hdev_port, #gp_descr_len
	byte	$3f, $5b, $96, $f9
'-'                 mov     pa, 0-0
	byte	$00, $ec, $03, $f6
'-'                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
'-'                 mov     hidr_usage, ##$76543210
	byte	$19, $2a, $3b, $ff, $10, $0c, $07, $f6
'-' 
'-' .next
'-'                 cmps    pa, #0      wcz
	byte	$00, $ec, $5f, $f2
'-'         if_be   ret     wcz
	byte	$2d, $00, $7c, $ed
'-' 
'-'                 rdbyte  hpar1, ptra++
	byte	$61, $8d, $c7, $fa
'-'                 sub     pa, #1
	byte	$01, $ec, $87, $f1
'-'                 mov     hpar2, #0
	byte	$00, $8e, $07, $f6
'-' 
'-'                 mov     htmp, hpar1
	byte	$c6, $71, $03, $f6
'-'                 and     htmp, #$03
	byte	$03, $70, $07, $f5
'-'                 cmp     htmp, #1    wz
	byte	$01, $70, $0f, $f2
'-'         if_z    rdbyte  hpar2, ptra++
	byte	$61, $8f, $c7, $aa
'-'         if_z    signx   hpar2,#7
	byte	$07, $8e, $67, $a7
'-'         if_z    sub     pa, #1
	byte	$01, $ec, $87, $a1
'-'                 cmp     htmp, #2    wz
	byte	$02, $70, $0f, $f2
'-'         if_z    rdword  hpar2, ptra++
	byte	$61, $8f, $e7, $aa
'-'         if_z    signx   hpar2,#15
	byte	$0f, $8e, $67, $a7
'-'         if_z    sub     pa, #2
	byte	$02, $ec, $87, $a1
'-'                 cmp     htmp, #3    wz
	byte	$03, $70, $0f, $f2
'-'         if_z    rdlong  hpar2, ptra++
	byte	$61, $8f, $07, $ab
'-'         if_z    sub     pa, #4
	byte	$04, $ec, $87, $a1
'-' 
'-'                 and     hpar1, #$FC
	byte	$fc, $8c, $07, $f5
'-'                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
'-' 
'-'                 cmp     hpar1, #HID_REPORT_ID   wz
	byte	$84, $8c, $0f, $f2
'-'         if_z    jmp     #.report_id
	byte	$0c, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE_PAGE  wz
	byte	$04, $8c, $0f, $f2
'-'         if_z    jmp     #.usage_page
	byte	$24, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE       wz
	byte	$08, $8c, $0f, $f2
'-'         if_z    jmp     #.usage
	byte	$2c, $01, $90, $ad
'-'                 cmp     hpar1, #HID_LOGICAL_MIN wz
	byte	$14, $8c, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #1
	byte	$c7, $27, $2b, $a9
'-'                 cmp     hpar1, #HID_LOGICAL_MAX wz
	byte	$24, $8c, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #0
	byte	$c7, $27, $23, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MIN wz
	byte	$34, $8c, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #1
	byte	$c7, $29, $2b, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MAX wz
	byte	$44, $8c, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #0
	byte	$c7, $29, $23, $a9
'-'                 cmp     hpar1, #HID_REPORT_SIZE wz
	byte	$74, $8c, $0f, $f2
'-'         if_z    mov     hidr_size, hpar2
	byte	$c7, $1f, $03, $a6
'-'                 cmp     hpar1, #HID_REPORT_COUNT wz
	byte	$94, $8c, $0f, $f2
'-'         if_z    mov     hidr_count, hpar2
	byte	$c7, $21, $03, $a6
'-'                 cmp     hpar1, #HID_INPUT       wz
	byte	$80, $8c, $0f, $f2
'-'         if_nz   jmp     #.next
	byte	$64, $ff, $9f, $5d
'-' 
'-'                 tjf     hidr_state,#.next
	byte	$d8, $1d, $a7, $fb
'-' 
'-'                 and     hpar2, #$03
	byte	$03, $8e, $07, $f5
'-'                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
	byte	$02, $8e, $0f, $f2
'-'         if_nz   jmp     #.skip
	byte	$18, $00, $90, $5d
'-' 
'-'                 cmp     hidr_state, #2  wz
	byte	$02, $1c, $0f, $f2
'-'         if_z    jmp     #.axes
	byte	$20, $00, $90, $ad
'-'                 cmp     hidr_state, #3  wz
	byte	$03, $1c, $0f, $f2
'-'         if_z    jmp     #.hats
	byte	$5c, $00, $90, $ad
'-'                 cmp     hidr_state, #4  wz
	byte	$04, $1c, $0f, $f2
'-'         if_z    jmp     #.buttons
	byte	$70, $00, $90, $ad
'-' .skip
'-'                 mov     htmp, hidr_size
	byte	$8f, $71, $03, $f6
'-'                 mul     htmp, hidr_count
	byte	$90, $71, $03, $fa
'-'                 add     hidr_offset, htmp
	byte	$b8, $23, $03, $f1
'-'                 jmp     #.next
	byte	$2c, $ff, $9f, $fd
'-' .axes
'-'                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 getnib  hr0, hidr_flags, #2
	byte	$87, $85, $53, $f8
'-'                 mov     hr1, hidr_count
	byte	$90, $87, $03, $f6
'-' .l1
'-'                 mov     hpar1, hidr_offset
	byte	$91, $8d, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$8f, $8f, $03, $f6
'-'                 call    #hpad_getbits
	byte	$04, $03, $b0, $fd
'-'                 call    #hpad_normalize
	byte	$64, $03, $b0, $fd
'-'                 cmp     hr0, #6         wcz
	byte	$06, $84, $1f, $f2
'-'         if_b    altgn   hr0, #hidr_usage
	byte	$86, $85, $5f, $c9
'-'         if_b    getnib  hr2
	byte	$00, $88, $43, $c8
'-'         if_b    altsw   hr2, #hidr_axis
	byte	$88, $89, $77, $c9
'-'         if_b    setword retval
	byte	$5f, $01, $20, $c9
'-'         if_b    add     hr0, #1
	byte	$01, $84, $07, $c1
'-'                 add     hidr_offset, hidr_size
	byte	$8f, $23, $03, $f1
'-'                 djnz    hr1, #.l1
	byte	$f4, $87, $6f, $fb
'-' 
'-'                 setnib  hidr_flags, hr0, #2
	byte	$c2, $0f, $13, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $1c, $07, $f6
'-'                 jmp     #.next
	byte	$e8, $fe, $9f, $fd
'-' .hats
'-'                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$91, $8d, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$8f, $8f, $03, $f6
'-'                 call    #hpad_getbits
	byte	$c8, $02, $b0, $fd
'-'                 setbyte hidr_hats, retval, #0
	byte	$5f, $19, $c3, $f8
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $1c, $07, $f6
'-'                 jmp     #.skip
	byte	$90, $ff, $9f, $fd
'-' .buttons
'-'                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$91, $8d, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$8f, $8f, $03, $f6
'-'                 mul     hpar2, hidr_count
	byte	$90, $8f, $03, $fa
'-'                 call    #hpad_getbits
	byte	$a8, $02, $b0, $fd
'-'                 getbyte htmp, hidr_flags, #0
	byte	$87, $71, $e3, $f8
'-'                 shl     retval, htmp
	byte	$b8, $bf, $62, $f0
'-'                 or      hidr_buttons, retval
	byte	$5f, $17, $43, $f5
'-'                 add     htmp, hidr_count
	byte	$90, $71, $03, $f1
'-'                 setbyte hidr_flags, htmp, #0
	byte	$b8, $0f, $c3, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $1c, $07, $f6
'-'                 jmp     #.skip
	byte	$64, $ff, $9f, $fd
'-' .report_id
'-'                 cmp     hidr_id, #0     wz
	byte	$00, $1a, $0f, $f2
'-'         if_nz   ret     wcz
	byte	$2d, $00, $7c, $5d
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     htmp, hpar2     wz
	byte	$c7, $71, $0b, $f2
'-'         if_z    mov     hidr_id, htmp
	byte	$b8, $1b, $03, $a6
'-'         if_nz   neg     hidr_state,#1
	byte	$01, $1c, $67, $56
'-'         if_nz   sub     ptrb,#1
	byte	$01, $f2, $87, $51
'-'                 jmp     #.next
	byte	$80, $fe, $9f, $fd
'-' .usage_page
'-'                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
	byte	$09, $8e, $0f, $f2
'-'         if_z    cmp     hidr_state, #1  wz
	byte	$01, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #4
	byte	$04, $1c, $07, $a6
'-'                 jmp     #.next
	byte	$70, $fe, $9f, $fd
'-' .usage
'-'                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
	byte	$04, $8e, $0f, $f2
'-'         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
	byte	$05, $8e, $0f, $52
'-'         if_z    cmp     hidr_type,#HID_READY        wz
	byte	$06, $2a, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $1c, $07, $a6
'-'         if_z    jmp     #.next
	byte	$5c, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_MOUSE     wz
	byte	$02, $8e, $0f, $f2
'-'         if_z    cmp     hidr_type,#M_READY          wz
	byte	$04, $2a, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $1c, $07, $a6
'-'         if_z    jmp     #.next
	byte	$4c, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_X     wz
	byte	$30, $8e, $0f, $f2
'-'         if_nz   cmp     hpar2, #HID_USAGE_Y     wz
	byte	$31, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_Z     wz
	byte	$32, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_RX    wz
	byte	$33, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_RY    wz
	byte	$34, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_RZ    wz
	byte	$35, $8e, $0f, $52
'-'         if_z    jmp     #.usage_axis
	byte	$10, $00, $90, $ad
'-'                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
	byte	$39, $8e, $0f, $f2
'-'         if_z    cmp     hidr_state, #1      wz
	byte	$01, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #3
	byte	$03, $1c, $07, $a6
'-'                 jmp     #.next
	byte	$20, $fe, $9f, $fd
'-' .usage_axis
'-'                 cmps    hidr_state, #1          wc
	byte	$01, $1c, $57, $f2
'-'         if_b    jmp     #.next
	byte	$18, $fe, $9f, $cd
'-'                 altsn   hidr_usage_idx, #hidr_usage
	byte	$86, $25, $57, $f9
'-'                 setnib  hpar2
	byte	$c7, $01, $00, $f8
'-' 
'-'                 sub     hpar2, #HID_USAGE_X - 16
	byte	$20, $8e, $87, $f1
'-'                 decod   hpar2
	byte	$c7, $8f, $c3, $f9
'-'                 or      hidr_flags, hpar2
	byte	$c7, $0f, $43, $f5
'-' 
'-'                 add     hidr_usage_idx, #1
	byte	$01, $24, $07, $f1
'-'                 mov     hidr_state, #2
	byte	$02, $1c, $07, $f6
'-'                 jmp     #.next
	byte	$f8, $fd, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle XInput controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_xinput
'-'                 rdbyte  htmp, ptrb      wz
	byte	$80, $71, $cf, $fa
'-'         if_nz   ret                         ' Ignore message type <> $00
	byte	$2d, $00, $64, $5d
'-'                 rdbyte  htmp, ptrb[1]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #$14      wz
	byte	$14, $70, $0f, $f2
'-'         if_nz   ret                         ' Ignore report length <> $14 (20)
	byte	$2d, $00, $64, $5d
'-' 
'-'                 debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
	byte	$b0, $0e, $27, $f4
'-'                 setnib  hidr_flags, #6, #2
	byte	$06, $0e, $17, $f8
'-' 
'-'                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
	byte	$83, $11, $e7, $fa
'-'                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
	byte	$84, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
	byte	$85, $13, $e7, $fa
'-'                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
	byte	$86, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $26, $07, $f6
'-'                 rdbyte  retval, ptrb[4]     ' left analog trigger
	byte	$84, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
	byte	$06, $16, $27, $34
'-'                 call    #hpad_normalize
	byte	$f8, $01, $b0, $fd
'-'                 setword hidr_axis+1, retval, #1
	byte	$5f, $13, $2b, $f9
'-'                 rdbyte  retval, ptrb[5]     ' right analog trigger
	byte	$85, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
	byte	$07, $16, $27, $34
'-'                 call    #hpad_normalize
	byte	$e4, $01, $b0, $fd
'-'                 setword hidr_axis+2, retval, #0
	byte	$5f, $15, $23, $f9
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 rdword  retval, ptrb[1]
	byte	$81, $bf, $e6, $fa
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $16, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $16, $47, $f4
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $16, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $16, $47, $f4
'-'                 testb   retval, #8      wc  ' LB
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $16, $47, $f4
'-'                 testb   retval, #9      wc  ' RB
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $16, $47, $f4
'-'                 testb   retval, #5      wc  ' SELECT
	byte	$05, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $16, $47, $f4
'-'                 testb   retval, #4      wc  ' START
	byte	$04, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $16, $47, $f4
'-'                 testb   retval, #6      wc  ' L3
	byte	$06, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $16, $47, $f4
'-'                 testb   retval, #7      wc  ' R3
	byte	$07, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $16, $47, $f4
'-'                 testb   retval, #10     wc  ' XBOX
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $16, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
	byte	$5f, $71, $43, $f8
'-'                 mov     htmp1, ##$F576_F40F
	byte	$7a, $bb, $7a, $ff, $0f, $72, $07, $f6
'-'                 mov     htmp2, ##$FFFF_F312
	byte	$f9, $ff, $7f, $ff, $12, $75, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$b9, $71, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $70, $43, $f8
'-'                 setbyte hidr_hats, htmp, #0
	byte	$b8, $19, $c3, $f8
'-' 
'-'                 jmp     #hpad_translate
	byte	$ac, $01, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle PS3 controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_ps3
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     htmp, #$01      wz
	byte	$01, $70, $0f, $f2
'-'         if_nz   ret                         ' Ignore report ID <> $01
	byte	$2d, $00, $64, $5d
'-' 
'-'                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $26, $07, $f6
'-'                 rdbyte  retval, ptrb[5]         ' X = left stick X
	byte	$85, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$40, $01, $b0, $fd
'-'                 setword hidr_axis, retval, #0
	byte	$5f, $11, $23, $f9
'-'                 bith    hidr_flags, #HID_AXIS_X
	byte	$10, $0e, $27, $f4
'-'                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
	byte	$86, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$30, $01, $b0, $fd
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 bith    hidr_flags, #HID_AXIS_Y
	byte	$11, $0e, $27, $f4
'-'                 rdbyte  retval, ptrb[7]         ' Z = right stick X
	byte	$87, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$20, $01, $b0, $fd
'-'                 setword hidr_axis+1, retval, #0
	byte	$5f, $13, $23, $f9
'-'                 bith    hidr_flags, #HID_AXIS_Z
	byte	$12, $0e, $27, $f4
'-'                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
	byte	$88, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$10, $01, $b0, $fd
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-'                 bith    hidr_flags, #HID_AXIS_RZ
	byte	$15, $0e, $27, $f4
'-'                 setnib  hidr_flags, #4, #2
	byte	$04, $0e, $17, $f8
'-' 
'-'                 mov     hpar1, #8
	byte	$08, $8c, $07, $f6
'-'                 mov     hpar2, #19
	byte	$13, $8e, $07, $f6
'-'                 call    #hpad_getbits
	byte	$94, $00, $b0, $fd
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $16, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $16, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $16, $47, $f4
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $16, $47, $f4
'-'                 testb   retval, #10     wc  ' L1
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $16, $47, $f4
'-'                 testb   retval, #11     wc  ' R1
	byte	$0b, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $16, $47, $f4
'-'                 testb   retval, #8      wc  ' L2
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #6
	byte	$06, $16, $47, $f4
'-'                 testb   retval, #9      wc  ' R2
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #7
	byte	$07, $16, $47, $f4
'-'                 testb   retval, #0      wc  ' SELECT
	byte	$00, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $16, $47, $f4
'-'                 testb   retval, #3      wc  ' START
	byte	$03, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $16, $47, $f4
'-'                 testb   retval, #1      wc  ' LEFT STICK
	byte	$01, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $16, $47, $f4
'-'                 testb   retval, #2      wc  ' RIGHT STICK
	byte	$02, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $16, $47, $f4
'-'                 testb   retval, #16     wc  ' HOME
	byte	$10, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $16, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
	byte	$5f, $71, $4b, $f8
'-'                 mov     htmp1, ##$F3F4_120F
	byte	$09, $fa, $79, $ff, $0f, $72, $07, $f6
'-'                 mov     htmp2, ##$FFF5_FF76
	byte	$ff, $fa, $7f, $ff, $76, $75, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$b9, $71, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $70, $43, $f8
'-'                 setbyte hidr_hats, htmp, #0
	byte	$b8, $19, $c3, $f8
'-' 
'-'                 jmp     #hpad_translate
	byte	$b8, $00, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Read bits from report data buffer
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRB - report buffer
'-' '   hpar1 - start bit
'-' '   hpar2 - number of bits
'-' ' On exit:
'-' '   retval - bits
'-' '------------------------------------------------------------------------------
'-' hpad_getbits
'-'                 mov     htmp, hpar1
	byte	$c6, $71, $03, $f6
'-'                 shr     htmp, #3        ' byte offset
	byte	$03, $70, $47, $f0
'-'                 add     htmp, ptrb
	byte	$f9, $71, $03, $f1
'-'                 rdlong  retval, htmp
	byte	$b8, $bf, $02, $fb
'-' 
'-'                 mov     htmp1, hpar1
	byte	$c6, $73, $03, $f6
'-'                 and     htmp1, #$07     ' shift
	byte	$07, $72, $07, $f5
'-'                 shr     retval, htmp1
	byte	$b9, $bf, $42, $f0
'-' 
'-'                 cmp     hpar2, #24      wcz
	byte	$18, $8e, $1f, $f2
'-'         if_a    jmp     #.l1
	byte	$10, $00, $90, $1d
'-' 
'-'                 decod   hpar2
	byte	$c7, $8f, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $8e, $87, $f1
'-'                 and     retval, hpar2
	byte	$c7, $bf, $02, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .l1
'-'                 and     retval, ##$00_FFFFFF
	byte	$ff, $7f, $00, $ff, $ff, $bf, $06, $f5
'-'                 add     htmp, #3
	byte	$03, $70, $07, $f1
'-'                 rdlong  htmp2, htmp
	byte	$b8, $75, $03, $fb
'-'                 sub     hpar2, #24
	byte	$18, $8e, $87, $f1
'-'                 decod   hpar2
	byte	$c7, $8f, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $8e, $87, $f1
'-'                 shr     htmp2, htmp1
	byte	$b9, $75, $43, $f0
'-'                 and     htmp2, hpar2
	byte	$c7, $75, $03, $f5
'-'                 shl     htmp2, #24
	byte	$18, $74, $67, $f0
'-'                 or      retval, htmp2
	byte	$ba, $bf, $42, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Normalize value to signed word (-32768 / 32767)
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - value to normalize
'-' '   hidr_lminmax - min (word 1) max (word 0) value range
'-' '   - or -
'-' '   hidr_pminmax - min (word 1) max (word 0) value range
'-' '   hidr_size - value bits length
'-' ' On exit:
'-' '   retval - normalized value
'-' '------------------------------------------------------------------------------
'-' hpad_normalize
'-'                 mov     htmp, hidr_lminmax  wz
	byte	$93, $71, $0b, $f6
'-'         if_z    mov     htmp, hidr_pminmax  wz
	byte	$94, $71, $0b, $a6
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 getword htmp1, htmp, #1     ' htmp1 = min
	byte	$b8, $73, $3b, $f9
'-'                 getword htmp, htmp, #0      ' htmp = max
	byte	$b8, $71, $33, $f9
'-'                 signx   htmp1, #15      wc
	byte	$0f, $72, $77, $f7
'-'         if_c    alts    hidr_size, #511
	byte	$ff, $1f, $97, $c9
'-'         if_c    signx   retval, #0-0
	byte	$00, $be, $66, $c7
'-'                 subs    htmp, htmp1         ' htmp = (max - min)
	byte	$b9, $71, $c3, $f1
'-'                 subs    retval, htmp1       ' retval = (retval - min)
	byte	$b9, $bf, $c2, $f1
'-'                 shl     retval, #16         ' retval = (retval - min) << 16
	byte	$10, $be, $66, $f0
'-'                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
	byte	$01, $be, $c6, $f1
'-'                 abs     htmp            wc
	byte	$b8, $71, $53, $f6
'-'                 testb   retval, #31     wz
	byte	$1f, $be, $0e, $f4
'-'                 abs     retval
	byte	$5f, $bf, $42, $f6
'-'                 qdiv    retval, htmp
	byte	$b8, $bf, $12, $fd
'-'                 getqx   retval
	byte	$18, $be, $62, $fd
'-'     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
	byte	$5f, $bf, $62, $66
'-'                 adds    retval, ##$8000 signx 15
	byte	$c0, $ff, $7f, $ff, $00, $be, $46, $f1
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform controller actions
'-' ' On entry:
'-' '    hidr_id        report id
'-' '    hidr_axis      axis value (signed word, 2 axes per long)
'-' '                      X = hidr_axis+0, #0
'-' '                      Y = hidr_axis+0, #1
'-' '                      Z = hidr_axis+1, #0
'-' '                     RX = hidr_axis+1, #1
'-' '                     RY = hidr_axis+2, #0
'-' '                     RZ = hidr_axis+2, #1
'-' '    hidr_buttons   buttons state (bits 0 to 31)
'-' '    hidr_hats      hats state (byte 0, 1, 2, 3)
'-' '
'-' '                     -------3 -------2 -------1 -------0 byte
'-' '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
'-' '    hidr_flags       xxxxxxxx_xxrrrzyx_hhhhaaaa_bbbbbbbb
'-' '                                zyx||| |||||||| ++++++++ n. buttons
'-' '                                |||||| ||||++++--------- n. axes
'-' '                                |||||| ++++------------- n. hats
'-' '                                ++++++------------------ valid axes
'-' '------------------------------------------------------------------------------
'-' hpad_translate
'-' 
'-' 
'-'         if HAVE_HIDPAD
'-'                 loc     ptrb,#hidpad_report
	byte	$84, $0c, $f0, $fe
'-'                 mov     htmp,hdev_port          wz
	byte	$2d, $71, $0b, $f6
'-'         if_z    mov     htmp,hidr_id
	byte	$8d, $71, $03, $a6
'-'                 cmpsub  htmp,#1
	byte	$01, $70, $e7, $f2
'-'         if_z    cmp     hidr_id, #MAX_DEVICES   wc
	byte	$07, $1a, $17, $a2
'-'         if_nz   cmp     hidr_id, #2             wc
	byte	$02, $1a, $17, $52
'-'         if_ae   ret     wcz
	byte	$2d, $00, $7c, $3d
'-'                 mul     htmp, #HIDPAD_REPORT_SIZE
	byte	$1c, $70, $07, $fa
'-'                 add     ptrb,htmp
	byte	$b8, $f3, $03, $f1
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
	byte	$00, $0c, $03, $f6
'-'                 setq    #7-1
	byte	$28, $0c, $64, $fd
'-'                 wrlong  hidr_usage,ptrb
	byte	$80, $0d, $67, $fc
'-'         end
'-' 
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' .emupad_no_hat
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' .emupad_slot_over
'-'         end
'-' 
'-'         if 0
'-'                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
'-' 
'-'                 debug("    btn: ", ubin_long_(hidr_buttons))
'-' 
'-'         end
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' '------------------------------------------------------------------------------
'-' ' Clear EmuPad state
'-' '------------------------------------------------------------------------------
'-' emupad_reset
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get EmuPad Player number for current device (into retval)
'-' ' Z flag is also set if current device is valid
'-' ' (Value may be larger than EMUPAD_MAX_PLAYER !)
'-' '------------------------------------------------------------------------------
'-' emupad_getnum
'-' .loop
'-' '------------------------------------------------------------------------------
'-' ' Handle disconnect of device (call after emupad_getnum returns with Z set)
'-' '------------------------------------------------------------------------------
'-' emupad_discon
'-' .loop         
'-'         
'-'         ' FALL THROUGH!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Update EmuPad reports (all of them...)
'-' '------------------------------------------------------------------------------
'-' emupad_write_reports
'-' .devloop
'-' 
'-' end
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_hub_status
'-'                 mov     ep_addr_pid, hhub_ep_addr
	byte	$77, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 setword hpar3, hub_next_datax, #0
	byte	$32, $91, $23, $f9
'-'                 setword hpar3, #1, #1
	byte	$01, $90, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.data
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
	byte	$1a, $01, $80, $5d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .data
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 cmp     hub_next_datax, #PID_DATA0  wz
	byte	$c3, $64, $0e, $f2
'-'         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
	byte	$4b, $64, $06, $a6
'-'         if_nz   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $56
'-'                 rdlong  hub_status_chg, urx_buff_p
	byte	$27, $67, $02, $fb
'-'                 debug(ubin_long(hub_status_chg))
'-' 
'-'                 mov     hdev_port, #1
	byte	$01, $5a, $06, $f6
'-' .loop
'-'                 testb   hub_status_chg, hdev_port wz
	byte	$2d, $67, $0a, $f4
'-'         if_x1   call    #hub_port_handler
	byte	$0c, $00, $b0, $ad
'-'                 incmod  hdev_port, #7           wcz
	byte	$07, $5a, $1e, $f7
'-'         if_nc   jmp     #.loop
	byte	$f0, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' hub_port_handler
'-'                 mov     ep_addr_pid, hhub_ctrl_ep
	byte	$76, $bd, $02, $f6
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$8c, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-' 
'-'                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
	byte	$10, $68, $0e, $f4
'-'         if_x0   jmp     #.other
	byte	$50, $01, $90, $5d
'-'                 loc     ptra, #clr_port_feat
	byte	$68, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
	byte	$01, $21, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
	byte	$00, $68, $0e, $f4
'-'         if_x0   jmp     #.disconnect
	byte	$7c, $01, $90, $5d
'-'                 mov     hctwait, _100ms_
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 loc     ptra, #set_port_feat            ' reset port
	byte	$40, $02, $d0, $fe
'-'                 wrword  #HUB_PORT_RESET, ptra[wValue]
	byte	$01, $09, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp3, #2
	byte	$02, $76, $07, $f6
'-' .wait_reset
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$34, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
	byte	$14, $68, $0e, $f4
'-'         if_x0   djnz    htmp3, #.wait_reset
	byte	$f7, $77, $6f, $5b
'-' 
'-'                 loc     ptra, #clr_port_feat
	byte	$10, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
	byte	$24, $70, $07, $f6
'-' .wait_recover
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 djnz    htmp,#.wait_recover
	byte	$fd, $71, $6f, $fb
'-' 
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$8c, $01, $d0, $fe
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$48, $01, $90, $5d
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
	byte	$80, $01, $d0, $fe
'-'                 mov     htmp, hdev_port             ' Address is hub port number
	byte	$2d, $71, $03, $f6
'-'                 wrword  htmp, ptra[wValue]
	byte	$01, $71, $57, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$24, $01, $90, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$ef, $02, $a0, $fd
'-'                 mov     ep_addr_pid, hdev_port
	byte	$2d, $bd, $02, $f6
'-'                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
	byte	$08, $bc, $66, $f0
'-'                 call    #calc_crc5
	byte	$be, $00, $a0, $fd
'-'                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
	byte	$3c, $01, $d0, $fe
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$f4, $00, $90, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
'-'                 mov     hctwait, _500us_
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$18, $01, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$cc, $00, $90, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $85, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $87, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $71, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $84, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $86, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $71, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #.done
	byte	$a4, $00, $90, $cd
'-'                 call    #hparse_con_desc
	byte	$6c, $f0, $bf, $fd
'-'                 jmp     #.done
	byte	$9c, $00, $90, $fd
'-' 
'-' .other
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz
	byte	$14, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$28, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
	byte	$11, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
	byte	$01, $23, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$1c, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
	byte	$12, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
	byte	$01, $25, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$10, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
	byte	$13, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
	byte	$01, $27, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$04, $00, $90, $ad
'-'                 jmp     #.done
	byte	$68, $00, $90, $fd
'-' .reset_feature
'-'                 loc     ptra, #clr_port_feat
	byte	$e4, $00, $d0, $fe
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 jmp     #.done
	byte	$58, $00, $90, $fd
'-' .disconnect
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $70, $e3, $f8
'-'                 cmp     htmp,#KB_READY wz
	byte	$03, $70, $0f, $f2
'-'         if_nz   cmp     htmp,#KBM_READY wz
	byte	$05, $70, $0f, $52
'-'         if_z    mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $a6
'-'         if_z    mov     hkbd_ctrl_ep, #0
	byte	$00, $f0, $06, $a6
'-'         if_z    mov     kb_led_states, #0
	byte	$00, $76, $06, $a6
'-'         if_z    mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $a6
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $70, $0f, $f2
'-'         if_nz   cmp     htmp, #KBM_READY        wz
	byte	$05, $70, $0f, $52
'-'         if_z    mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $a6
'-'         end
'-'         if HAVE_HIDPAD
'-'                 loc ptrb,#hidpad_report
	byte	$14, $0a, $f0, $fe
'-'                 mov htmp,hdev_port
	byte	$2d, $71, $03, $f6
'-'                 cmpsub htmp,#1
	byte	$01, $70, $e7, $f2
'-'                 mul htmp,#HIDPAD_REPORT_SIZE
	byte	$1c, $70, $07, $fa
'-'                 add ptrb,htmp
	byte	$b8, $f3, $03, $f1
'-'                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
	byte	$28, $0c, $64, $fd
'-'                 wrlong #0,ptrb
	byte	$80, $01, $6c, $fc
'-'         end
'-' 
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte #0
	byte	$00, $00, $c4, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' 
'-' .done
'-'                 bitl    _usb_h_ls_nco_, #14     wcz
	byte	$0e, $68, $1f, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6d, $13, $cc
'-'                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $f6
'-' 
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$6c, $00, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, ptra
	byte	$00, $69, $06, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Partially populated SETUP packets
'-' '------------------------------------------------------------------------------
'-' get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_DEVICE << 8
	byte	$00, $01
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_CONFIG << 8
	byte	$00, $02
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_CONFIG
	byte	$09
'-'                 word    0       ' Configuration value
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
	byte	$00, $00
'-' set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_ADDR
	byte	$05
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
'-' ' wValue field dictates which protocol should be used.
'-' '
'-' ' When initialized, all devices default to report protocol. However the host
'-' ' should not make any assumptions about the device state and should set the
'-' ' desired protocol whenever initializing a device.
'-' '------------------------------------------------------------------------------
'-' set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_PROTO
	byte	$0b
'-'                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
	byte	$00, $00
'-'                                                 ' (HID 1.11 Section 7.2.6).
'-'                 word    0               ' Interface index number.
	byte	$00, $00
'-'                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_IDLE
	byte	$0a
'-'                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
	byte	$00, $00
'-'                                         ' reporting until a change is detected in the report data
'-' 
'-'                                         ' (HID 1.11 Section 7.2.4).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
	byte	$00, $00
'-' set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_REPORT
	byte	$09
'-'                 word    0       ' Byte1 = report type, byte0 = ReportID.
	byte	$00, $00
'-'                                         ' (HID 1.11 Section 7.2.2).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Size of the report, in bytes.
	byte	$00, $00
'-' get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
	byte	$81
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_REPORT << 8
	byte	$00, $22
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
	byte	$a0
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_HUB << 8
	byte	$00, $29
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_SET_FEATURE
	byte	$03
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_CLEAR_FEATURE
	byte	$01
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
	byte	$a3
'-'                 byte    REQ_GET_STATUS
	byte	$00
'-'                 word    0
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    4       ' Number of bytes to transfer if there is a data stage
	byte	$04, $00
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' ps3_enable_cmd  byte    $42, $0C, $00, $00
	byte	$42, $0c, $00, $00
'-' ps3_command_buff
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
	byte	$00, $00, $00, $00, $02
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' '------------------------------------------------------------------------------
'-' xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
	byte	$01, $03, $06
'-'                                         ' 0x01 All blinking
'-'                                         ' 0x02 1 flashes, then on
'-'                                         ' 0x03 2 flashes, then on
'-'                                         ' 0x04 3 flashes, then on
'-'                                         ' 0x05 4 flashes, then on
'-'                                         ' 0x06 1 on
'-'                                         ' 0x07 2 on
'-'                                         ' 0x08 3 on
'-'                                         ' 0x09 4 on
'-'                                         ' 0x0A Rotating (e.g. 1-2-4-3)
'-'                                         ' 0x0B Blinking*
'-'                                         ' 0x0C Slow blinking*
'-'                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
'-' xinp_rumble_cmd byte    $00, $08, $00
	byte	$00, $08, $00
'-'                 byte    $00             ' Left rumble
	byte	$00
'-'                 byte    $00             ' Right rumble
	byte	$00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' end
	byte	$00
'-' alignl
'-' 
'-' if HAVE_MOUSE
'-' mouse_limits long 0[2]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' mouse_outptr long 0
	byte	$00, $00, $00, $00
'-' end
'-' 
'-' if KEYQUEUE_SIZE > 0
'-' keyq_head byte 0
	byte	$00
'-' keyq_tail byte 0
	byte	$00
'-' keyq_data long 0[KEYQUEUE_SIZE]
	byte	$00[514]
'-' alignl
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_rule_buffer
'-' if EMUPAD_BUILTIN_RULES
'-' file "padmap_builtin.dat"
'-' end
'-' byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
'-' '' Default rule directly follows!
'-' byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The USB data cache area gets zero-filled at every device disconnect
'-' '------------------------------------------------------------------------------
'-' usb_cache_start
'-' 
'-' ' HID descriptor and report buffers
'-' if !!OVERLAP_MEMORY
'-' hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
	byte	$00[1792]
'-' end
'-' hkbd_report     byte    0[8]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' hkbd_led_rep    byte    0
	byte	$00, $00, $00, $00
'-' alignl
'-' 
'-' if HAVE_HIDPAD
'-' hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
	byte	$00[196]
'-' end
'-' 
'-' ' HUB descriptor
'-' hub_descr       byte    0   ' bDescLength
	byte	$00
'-'                 byte    0   ' bDescriptorType
	byte	$00
'-'                 byte    0   ' bNbrPorts
	byte	$00
'-'                 word    0   ' wHubCharacteristics
	byte	$00, $00
'-'                 byte    0   ' bPwrOn2PwrGood
	byte	$00
'-'                 byte    0   ' bHubContrCurrent
	byte	$00
'-'                 byte    0   ' DeviceRemoveable
	byte	$00
'-'                 byte    0   ' PortPwrCtrlMask
	byte	$00
'-' 
'-' usb_cache_end
'-' 
'-' if HAVE_MOUSE
'-' mouse_xacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_yacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_zacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_bstate    byte 0
	byte	$00
'-' mouse_lpending  byte 0
	byte	$00
'-' mouse_rpending  byte 0
	byte	$00
'-' mouse_mpending  byte 0
	byte	$00
'-' mouse_lock      byte 0
	byte	$00
'-'                 byte 0[3] ' padding
	byte	$00, $00, $00
'-' end
'-' 
'-' urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
	byte	$00[128]
'-' dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
	byte	$00[18]
'-' con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
	byte	$00[256]
'-' 
'-' driver_cog      byte    0                       ' Current driver cog + 1
	byte	$00
objmem
	long	0[0]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
	fit	480
