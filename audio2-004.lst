00000                 | 
00000                 | #line 1 "D:/Programowanie/P2-Retromachine-Basic/audio2-004.p2asm"
00000                 | con
00000                 | 	_clkfreq = 20000000
00000                 | 	_clkmode = 16779595
00000                 | ' 
00000                 | ' 
00000                 | ' left= 14
00000                 | 	left = 14
00000                 | ' right=15
00000                 | 	right = 15
00000                 | ' 
00000                 | ' c4=262
00000                 | 	c4 = 262
00000                 | ' d4=294
00000                 | 	d4 = 294
00000                 | ' e4=330
00000                 | 	e4 = 330
00000                 | ' f4=349
00000                 | 	f4 = 349
00000                 | ' g4=392
00000                 | 	g4 = 392
00000                 | ' a4=440
00000                 | 	a4 = 440
00000                 | ' h4=494
00000                 | 	h4 = 494
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 20000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $100094b
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 FA 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 03 90 5D |  if_ne	jmp	#spininit
0040c 002 FC F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 02 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 04 80 80 FF 
00420 007 00 90 66 FD | 	hubset	##16779592
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 04 80 00 FF 
00430 00b 4B ED 07 F6 | 	mov	pa, ##16779595
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 96 98 80 FF 
00440 00f 14 00 6E FC | 	wrlong	##20000000, #20
00444 010 BC 02 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
006fc 0be 00 00 00 00 
00700 0bf 00 00 00 00 | 	orgf	192
00704 0c0             | skip_clock_set_
00704 0c0 00 08 A0 FD | 	call	#_start
00708 0c1             | cogexit
00708 0c1 38 01 80 FF 
0070c 0c2 1F 00 66 FD | 	waitx	##160000
00710 0c3 01 04 62 FD | 	cogid	arg01
00714 0c4 03 04 62 FD | 	cogstop	arg01
00718 0c5             | spininit
00718 0c5 61 F5 05 FB | 	rdlong	objptr, ptra++
0071c 0c6 61 FB 05 FB | 	rdlong	result1, ptra++
00720 0c7 28 06 64 FD | 	setq	#3
00724 0c8 00 05 06 FB | 	rdlong	arg01, ptra
00728 0c9 04 F0 87 F1 | 	sub	ptra, #4
0072c 0ca 2D FA 61 FD | 	call	result1
00730 0cb D4 FF 9F FD | 	jmp	#cogexit
00734 0cc             | FCACHE_LOAD_
00734 0cc F9 AD 01 F6 |     mov	fcache_tmpb_,ptrb
00738 0cd 2B F2 63 FD |     pop	ptrb
0073c 0ce D5 EC 8B F9 |     altd	pa,ret_instr_
00740 0cf D5 00 00 F6 |     mov	 0-0, ret_instr_
00744 0d0 28 EC 63 FD |     setq	pa
00748 0d1 E1 01 04 FB |     rdlong	$0, ptrb++
0074c 0d2 2A F2 63 FD |     push	ptrb
00750 0d3 D6 F2 03 F6 |     mov ptrb,fcache_tmpb_
00754 0d4 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00758 0d5             | ret_instr_
00758 0d5 00 FE 07 02 |     _ret_ cmp inb,#0
0075c 0d6             | fcache_tmpb_
0075c 0d6 00 00 00 00 |     long 0
00760 0d7             | fcache_load_ptr_
00760 0d7 CC 00 00 00 |     long FCACHE_LOAD_
00764 0d8             | builtin_bytefill_
00764 0d8 01 08 56 F0 |         shr	arg03, #1 wc
00768 0d9 02 07 42 CC |  if_c   wrbyte	arg02, arg01
0076c 0da 01 04 06 C1 |  if_c   add	arg01, #1
00770 0db 00 06 FE F9 |         movbyts	arg02, #0
00774 0dc             | builtin_wordfill_
00774 0dc 01 08 56 F0 |         shr	arg03, #1 wc
00778 0dd 02 07 52 CC |  if_c   wrword	arg02, arg01
0077c 0de 02 04 06 C1 |  if_c   add	arg01, #2
00780 0df 03 07 2A F9 |         setword	arg02, arg02, #1
00784 0e0             | builtin_longfill_
00784 0e0 02 01 88 FC |         wrfast	#0,arg01
00788 0e1 00 08 0E F2 |         cmp	arg03, #0 wz
0078c 0e2 04 03 D8 5C |  if_nz  rep	#1, arg03
00790 0e3 17 06 62 5D |  if_nz  wflong	arg02
00794 0e4 2D 00 64 FD |         ret
00798 0e5             | COUNT_
00798 0e5 00 00 00 00 |     long 0
0079c 0e6             | RETADDR_
0079c 0e6 00 00 00 00 |     long 0
007a0 0e7             | fp
007a0 0e7 00 00 00 00 |     long 0
007a4 0e8             | pushregs_
007a4 0e8 2B EC 63 FD |     pop  pa
007a8 0e9 2B CC 61 FD |     pop  RETADDR_
007ac 0ea 03 CA 95 FB |     tjz  COUNT_, #pushregs_done_
007b0 0eb FF CB 8D F9 |     altd  COUNT_, #511
007b4 0ec 28 00 64 FD |     setq #0-0
007b8 0ed 61 0D 66 FC |     wrlong local01, ptra++
007bc 0ee             | pushregs_done_
007bc 0ee 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
007c0 0ef 61 CB 65 FC |     wrlong COUNT_, ptra++
007c4 0f0 F8 CF 01 F6 |     mov    fp, ptra
007c8 0f1 2C EC 63 FD |     jmp  pa
007cc 0f2             |  popregs_
007cc 0f2 2B EC 63 FD |     pop    pa
007d0 0f3 28 04 64 FD |     setq   #2
007d4 0f4 5F CB 05 FB |     rdlong COUNT_, --ptra
007d8 0f5 02 CA 75 FB |     djf    COUNT_, #popregs__ret
007dc 0f6 28 CA 61 FD |     setq   COUNT_
007e0 0f7 5F 0D 06 FB |     rdlong local01, --ptra
007e4 0f8             | popregs__ret
007e4 0f8 2A CC 61 FD |     push   RETADDR_
007e8 0f9 2C EC 63 FD |     jmp    pa
007ec 0fa             | 
007ec 0fa             | objptr
007ec 0fa F4 0E 00 00 | 	long	@objmem
007f0 0fb             | ptr__dat__
007f0 0fb 0C 0B 00 00 | 	long	@_dat_
007f4 0fc             | ptr_stackspace_
007f4 0fc 60 14 00 00 | 	long	@stackspace
007f8 0fd             | result1
007f8 0fd 00 00 00 00 | 	long	0
007fc 0fe             | result2
007fc 0fe 01 00 00 00 | 	long	1
00800 0ff             | COG_BSS_START
00800 0ff             | 	fit	480
00800                 | 	orgh
00800                 | hubentry
00800                 | 
00800                 | ' 
00800                 | ' '--------------------------------------------------------------
00800                 | ' '---------- Init the variables, start the cog. ----------------
00800                 | ' '--------------------------------------------------------------
00800                 | ' 
00800                 | ' pub start(mbox,scope,cache) :cog,base | iii
00800                 | _start
00800     04 CA 05 F6 | 	mov	COUNT_, #4
00804     E8 00 A0 FD | 	call	#pushregs_
00808     02 0D 02 F6 | 	mov	local01, arg01
0080c                 | ' 
0080c                 | ' ' mbox: PSRAM mailbox or 0 if no PSRAM
0080c                 | ' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
0080c                 | ' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
0080c                 | ' 
0080c                 | ' mailboxaddr:=mbox 
0080c     FA 0C 62 FC | 	wrlong	local01, objptr
00810                 | ' scope_ptr:=scope
00810     04 F4 05 F1 | 	add	objptr, #4
00814     FA 06 62 FC | 	wrlong	arg02, objptr
00818                 | ' cache_ptr:=cache
00818     04 F4 05 F1 | 	add	objptr, #4
0081c     FA 08 62 FC | 	wrlong	arg03, objptr
00820                 | ' base:=@channel0[0]
00820     04 F4 05 F1 | 	add	objptr, #4
00824     FA 0E 02 F6 | 	mov	local02, objptr
00828                 | ' 
00828                 | ' repeat iii from 0 to 15
00828     00 10 06 F6 | 	mov	local03, #0
0082c     0C F4 85 F1 | 	sub	objptr, #12
00830     D7 1A 49 FB | 	callpa	#(@LR__0002-@LR__0001)>>2,fcache_load_ptr_
00834                 | LR__0001
00834                 | '   long[base+64*iii]:=0
00834     07 0D 02 F6 | 	mov	local01, local02
00838     08 FD 01 F6 | 	mov	result2, local03
0083c     06 FC 65 F0 | 	shl	result2, #6
00840     FE 0C 02 F1 | 	add	local01, result2
00844     06 01 68 FC | 	wrlong	#0, local01
00848                 | '   long[base+64*iii+4]:=0  		
00848     07 0D 02 F6 | 	mov	local01, local02
0084c     08 FD 01 F6 | 	mov	result2, local03
00850     06 FC 65 F0 | 	shl	result2, #6
00854     FE 0C 02 F1 | 	add	local01, result2
00858     04 0C 06 F1 | 	add	local01, #4
0085c     06 01 68 FC | 	wrlong	#0, local01
00860                 | '   long[base+64*iii+8]:=0
00860     07 13 02 F6 | 	mov	local04, local02
00864     08 0D 02 F6 | 	mov	local01, local03
00868     06 0C 66 F0 | 	shl	local01, #6
0086c     06 13 02 F1 | 	add	local04, local01
00870     08 12 06 F1 | 	add	local04, #8
00874     09 01 68 FC | 	wrlong	#0, local04
00878                 | '   long[base+64*iii+12]:=0
00878     07 13 02 F6 | 	mov	local04, local02
0087c     08 0D 02 F6 | 	mov	local01, local03
00880     06 0C 66 F0 | 	shl	local01, #6
00884     06 13 02 F1 | 	add	local04, local01
00888     0C 12 06 F1 | 	add	local04, #12
0088c     09 01 68 FC | 	wrlong	#0, local04
00890                 | '   long[base+64*iii+16]:=0
00890     07 13 02 F6 | 	mov	local04, local02
00894     08 0D 02 F6 | 	mov	local01, local03
00898     06 0C 66 F0 | 	shl	local01, #6
0089c     06 13 02 F1 | 	add	local04, local01
008a0     10 12 06 F1 | 	add	local04, #16
008a4     09 01 68 FC | 	wrlong	#0, local04
008a8                 | '   long[base+64*iii+20]:=0
008a8     07 13 02 F6 | 	mov	local04, local02
008ac     08 0D 02 F6 | 	mov	local01, local03
008b0     06 0C 66 F0 | 	shl	local01, #6
008b4     06 13 02 F1 | 	add	local04, local01
008b8     14 12 06 F1 | 	add	local04, #20
008bc     09 01 68 FC | 	wrlong	#0, local04
008c0                 | '   long[base+64*iii+24]:=0
008c0     07 13 02 F6 | 	mov	local04, local02
008c4     08 0D 02 F6 | 	mov	local01, local03
008c8     06 0C 66 F0 | 	shl	local01, #6
008cc     06 13 02 F1 | 	add	local04, local01
008d0     18 12 06 F1 | 	add	local04, #24
008d4     09 01 68 FC | 	wrlong	#0, local04
008d8                 | '   long[base+64*iii+28]:=0
008d8     07 13 02 F6 | 	mov	local04, local02
008dc     08 0D 02 F6 | 	mov	local01, local03
008e0     06 0C 66 F0 | 	shl	local01, #6
008e4     06 13 02 F1 | 	add	local04, local01
008e8     1C 12 06 F1 | 	add	local04, #28
008ec     09 01 68 FC | 	wrlong	#0, local04
008f0                 | '   word[base+64*iii+32]:=8192
008f0     07 13 02 F6 | 	mov	local04, local02
008f4     08 0D 02 F6 | 	mov	local01, local03
008f8     06 0C 66 F0 | 	shl	local01, #6
008fc     06 13 02 F1 | 	add	local04, local01
00900     20 12 06 F1 | 	add	local04, #32
00904     10 00 80 FF 
00908     09 01 58 FC | 	wrword	##8192, local04
0090c                 | '   word[base+64*iii+34]:=8192
0090c     07 13 02 F6 | 	mov	local04, local02
00910     08 0D 02 F6 | 	mov	local01, local03
00914     06 0C 66 F0 | 	shl	local01, #6
00918     06 13 02 F1 | 	add	local04, local01
0091c     22 12 06 F1 | 	add	local04, #34
00920     10 00 80 FF 
00924     09 01 58 FC | 	wrword	##8192, local04
00928                 | '   long[base+64*iii+36]:=0
00928     07 13 02 F6 | 	mov	local04, local02
0092c     08 0D 02 F6 | 	mov	local01, local03
00930     06 0C 66 F0 | 	shl	local01, #6
00934     06 13 02 F1 | 	add	local04, local01
00938     24 12 06 F1 | 	add	local04, #36
0093c     09 01 68 FC | 	wrlong	#0, local04
00940                 | '   long[base+64*iii+40]:=0
00940     07 13 02 F6 | 	mov	local04, local02
00944     08 0D 02 F6 | 	mov	local01, local03
00948     06 0C 66 F0 | 	shl	local01, #6
0094c     06 13 02 F1 | 	add	local04, local01
00950     28 12 06 F1 | 	add	local04, #40
00954     09 01 68 FC | 	wrlong	#0, local04
00958                 | '   long[base+64*iii+44]:=0
00958     07 13 02 F6 | 	mov	local04, local02
0095c     08 0D 02 F6 | 	mov	local01, local03
00960     06 0C 66 F0 | 	shl	local01, #6
00964     06 13 02 F1 | 	add	local04, local01
00968     2C 12 06 F1 | 	add	local04, #44
0096c     09 01 68 FC | 	wrlong	#0, local04
00970                 | '   long[base+64*iii+48]:=0
00970     07 13 02 F6 | 	mov	local04, local02
00974     08 0D 02 F6 | 	mov	local01, local03
00978     06 0C 66 F0 | 	shl	local01, #6
0097c     06 13 02 F1 | 	add	local04, local01
00980     30 12 06 F1 | 	add	local04, #48
00984     09 01 68 FC | 	wrlong	#0, local04
00988                 | '   long[base+64*iii+52]:=0
00988     07 13 02 F6 | 	mov	local04, local02
0098c     08 0D 02 F6 | 	mov	local01, local03
00990     06 0C 66 F0 | 	shl	local01, #6
00994     06 13 02 F1 | 	add	local04, local01
00998     34 12 06 F1 | 	add	local04, #52
0099c     09 01 68 FC | 	wrlong	#0, local04
009a0                 | '   freqs[iii]:=440000
009a0     08 13 02 F6 | 	mov	local04, local03
009a4     02 12 66 F0 | 	shl	local04, #2
009a8     02 00 00 FF 
009ac     0C F4 05 F1 | 	add	objptr, ##1036
009b0     FA 12 02 F1 | 	add	local04, objptr
009b4     5B 03 80 FF 
009b8     09 81 69 FC | 	wrlong	##440000, local04
009bc                 | '   delays[iii]:=0
009bc     08 13 02 F6 | 	mov	local04, local03
009c0     01 12 66 F0 | 	shl	local04, #1
009c4     40 F4 05 F1 | 	add	objptr, #64
009c8     FA 12 02 F1 | 	add	local04, objptr
009cc     09 01 58 FC | 	wrword	#0, local04
009d0                 | '   volumes[iii]:=4096
009d0     08 13 02 F6 | 	mov	local04, local03
009d4     01 12 66 F0 | 	shl	local04, #1
009d8     20 F4 05 F1 | 	add	objptr, #32
009dc     FA 12 02 F1 | 	add	local04, objptr
009e0     08 00 80 FF 
009e4     09 01 58 FC | 	wrword	##4096, local04
009e8                 | '   waveforms[iii]:=0
009e8     08 13 02 F6 | 	mov	local04, local03
009ec     02 12 66 F0 | 	shl	local04, #2
009f0     20 F4 05 F1 | 	add	objptr, #32
009f4     FA 12 02 F1 | 	add	local04, objptr
009f8     09 01 68 FC | 	wrlong	#0, local04
009fc                 | '   envelopes[iii]:=0
009fc     08 13 02 F6 | 	mov	local04, local03
00a00     02 12 66 F0 | 	shl	local04, #2
00a04     40 F4 05 F1 | 	add	objptr, #64
00a08     FA 12 02 F1 | 	add	local04, objptr
00a0c     09 01 68 FC | 	wrlong	#0, local04
00a10                 | '   lengths[iii]:=1000
00a10     08 13 02 F6 | 	mov	local04, local03
00a14     01 12 66 F0 | 	shl	local04, #1
00a18     40 F4 05 F1 | 	add	objptr, #64
00a1c     FA 12 02 F1 | 	add	local04, objptr
00a20     01 00 80 FF 
00a24     09 D1 5B FC | 	wrword	##1000, local04
00a28                 | '   pans[iii]:=8192
00a28     08 13 02 F6 | 	mov	local04, local03
00a2c     01 12 66 F0 | 	shl	local04, #1
00a30     20 F4 05 F1 | 	add	objptr, #32
00a34     FA 12 02 F1 | 	add	local04, objptr
00a38     10 00 80 FF 
00a3c     09 01 58 FC | 	wrword	##8192, local04
00a40                 | '   sustains[iii]:=255
00a40     08 13 02 F6 | 	mov	local04, local03
00a44     01 12 66 F0 | 	shl	local04, #1
00a48     20 F4 05 F1 | 	add	objptr, #32
00a4c     FA 12 02 F1 | 	add	local04, objptr
00a50     09 FF 59 FC | 	wrword	#255, local04
00a54     01 10 06 F1 | 	add	local03, #1
00a58     10 10 56 F2 | 	cmps	local03, #16 wc
00a5c     02 00 00 FF 
00a60     4C F5 85 F1 | 	sub	objptr, ##1356
00a64     CC FD 9F CD |  if_b	jmp	#LR__0001
00a68                 | LR__0002
00a68                 | '   
00a68                 | ' cog:=coginit(16,@audio,@mailboxaddr)
00a68     FB 06 02 F6 | 	mov	arg02, ptr__dat__
00a6c     FA 08 02 F6 | 	mov	arg03, objptr
00a70     10 12 06 F6 | 	mov	local04, #16
00a74     28 08 62 FD | 	setq	arg03
00a78     03 13 F2 FC | 	coginit	local04, arg02 wc
00a7c     01 12 66 C6 |  if_b	neg	local04, #1
00a80                 | ' waitms(10)
00a80     0A 04 06 F6 | 	mov	arg01, #10
00a84     18 00 B0 FD | 	call	#__system___waitms
00a88                 | ' return cog,base
00a88     07 FD 01 F6 | 	mov	result2, local02
00a8c     09 FB 01 F6 | 	mov	result1, local04
00a90     E7 F0 03 F6 | 	mov	ptra, fp
00a94     F2 00 A0 FD | 	call	#popregs_
00a98                 | _start_ret
00a98     2D 00 64 FD | 	ret
00a9c                 | hubexit
00a9c     C1 00 80 FD | 	jmp	#cogexit
00aa0                 | 
00aa0                 | __system___waitms
00aa0     02 FF 01 F6 | 	mov	_var01, arg01
00aa4     1A 00 62 FD | 	getct	_var02
00aa8     14 02 06 FB | 	rdlong	_var03, #20
00aac     D7 14 48 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
00ab0                 | LR__0010
00ab0     01 00 00 FF 
00ab4     E8 FF 55 F2 | 	cmps	_var01, ##1000 wc
00ab8     1C 00 90 CD |  if_b	jmp	#LR__0012
00abc     01 01 02 F1 | 	add	_var02, _var03
00ac0     00 05 02 F6 | 	mov	arg01, _var02
00ac4     00 04 66 FA | 	addct1	arg01, #0
00ac8     24 22 60 FD | 	waitct1
00acc     01 00 00 FF 
00ad0     E8 FF 85 F1 | 	sub	_var01, ##1000
00ad4     D8 FF 9F FD | 	jmp	#LR__0010
00ad8                 | LR__0011
00ad8                 | LR__0012
00ad8     01 FE 55 F2 | 	cmps	_var01, #1 wc
00adc     28 00 90 CD |  if_b	jmp	#LR__0013
00ae0     01 FF 01 FD | 	qmul	_var01, _var03
00ae4     01 00 00 FF 
00ae8     E8 09 06 F6 | 	mov	arg03, ##1000
00aec     19 FA 61 FD | 	getqy	result1
00af0     18 04 62 FD | 	getqx	arg01
00af4     28 FA 61 FD | 	setq	result1
00af8     04 05 12 FD | 	qdiv	arg01, arg03
00afc     18 04 62 FD | 	getqx	arg01
00b00     00 05 62 FA | 	addct1	arg01, _var02
00b04     24 22 60 FD | 	waitct1
00b08                 | LR__0013
00b08                 | __system___waitms_ret
00b08     2D 00 64 FD | 	ret
00b0c                 | 	alignl
00b0c                 | _dat_
00b0c                 | 
00b0c                 | audio       	org     0
00b0c                 | 
00b0c     61 73 05 FB |             	rdlong  mailbox2, ptra++     	' get start address of all mailboxes
00b10     61 AB 05 FB |             	rdlong  scbase, ptra++       	' get start address of scope buffer
00b14     61 B7 05 FB |             	rdlong  hubptr, ptra++       	' get start address of PSRAM cache
00b18                 | 
00b18     01 EC 63 FD |             	cogid   pa                   	' compute cogid
00b1c     0C EC 07 FA |             	mul     pa, #12              	' and mailbox spacing
00b20     F6 73 01 F1 |             	add     mailbox2, pa         	' add offset to find this COG's mailbox
00b24     B9 70 01 F6 |             	mov     mailbox, mailbox2     	' we need 2 copies of this to enable switching between hub and psram
00b28                 | 
00b28     0E B4 05 FC |             	wrpin   dac2,#left           	' PWM DACs at 44100@339 MHz
00b2c     0E B8 15 FC |             	wxpin   sr44100,#left      	' 30*256
00b30     0F B4 05 FC |             	wrpin   dac2,#right
00b34     0F B8 15 FC |             	wxpin   sr44100,#right    
00b38     41 9C 64 FD |             	dirh    #left addpins 1
00b3c     20 9C 64 FD |             	setse1  #%001<<6 + left      	' Set the event - DAC empty
00b40                 |   debug(uhex(mailbox))
00b40                 |             
00b40                 | '---------------------------------------------------------------------------------        
00b40                 | '----------------- The main loop -------------------------------------------------
00b40                 | '---------------------------------------------------------------------------------
00b40                 | 
00b40     00 A2 05 F6 | loop       	mov 	    cn,#0 '15 '7
00b44                 |               					'   waitx ##3300000  		'for debug
00b44                 |             
00b44                 | '----------------------------------------------------------------------------------
00b44                 | '------------- Get parameters and execute commands if any -------------------------
00b44                 | '----------------------------------------------------------------------------------
00b44                 | 
00b44                 | 
00b44     D1 6A 01 F6 | p401        	mov     channeladd,cn             	' compute the pointer to channel parameters block
00b48     06 6A 65 F0 |             	shl     channeladd,#6
00b4c     B5 F0 03 F1 |             	add     ptra,channeladd
00b50                 | 
00b50     28 1A 64 FD |             	setq    #13                       	' read parameters
00b54     00 79 05 FB |             	rdlong  pointer0,ptra
00b58     1F 8C 1D F4 | p408        	bitl    command0,#31 wcz	      	' bit #31 command - set the DAC sample rate
00b5c     2C 00 90 3D |     	if_nc   jmp     #p404                     	' if not set, proceed
00b60     C6 6C 01 F6 |             	mov     qq,command0             	' get the new rate
00b64     4E 6C 15 FC |             	wxpin   qq,#left addpins 1        	' and program the pins
00b68     B6 6C E1 F8 |             	getbyte qq,qq,#0 		      	' check if the rate is n*256
00b6c     00 6C 0D F2 |             	cmp     qq,#0 wz                         
00b70     4E B4 05 AC |     	if_z    wrpin   dac2,#left addpins 1      	' if yes, set PWM DAC mode
00b74     4E B2 05 5C |     	if_nz   wrpin   dac,#left addpins 1       	' else set noise DAC mode
00b78                 |                 
00b78     1E 82 1D F4 |                	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
00b7c     00 78 05 A6 |     	if_z    mov     pointer0, #0  
00b80     00 7A 05 A6 |     	if_z    mov     pointer0h, #0  
00b84     00 80 05 A6 |     	if_z    mov     envph0, #0  
00b88     05 83 65 AC |     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
00b8c                 |     	
00b8c     C1 6C 01 F6 | p404        	mov     qq,sstart0		     	' check if start>$80000
00b90     FF FF 03 FF 
00b94     FF 6D 05 F5 | 		and 	qq,##$7FFFFFF 
00b98     00 04 00 FF 
00b9c     00 6C 1D F2 |                 cmp 	qq,##$80000 wcz
00ba0     B9 70 01 36 |     	if_ge   mov     mailbox,mailbox2          	' if yes, use PSRAM
00ba4     00 70 05 C6 |     	if_lt   mov     mailbox,#0                	' if not, use HUB 
00ba8                 |  ''debug(uhex(sstart0,mailbox))
00ba8     C4 9E 39 F9 | p405           	getword apan0,volpan0,#1          	' extract vol,pan from longs 
00bac     C4 9C 31 F9 |     	    	getword avol0,volpan0,#0
00bb0                 |     	   debug(uhex(pointer0,pointer0h,sstart0)) 	
00bb0                 | '----------------------------------------------------------------------------------
00bb0                 | '------------- Compute the envelope, if exists ------------------------------------
00bb0                 | '----------------------------------------------------------------------------------
00bb0                 |             
00bb0     00 8E 1D F2 |             	cmp     envptr0,#0 wcz     		' read the pointer
00bb4     20 00 00 AF 
00bb8     00 EA 05 A6 |     	if_z    mov     envs1,##$4000			' if 0, no envelope, load $4000=1 for scas
00bbc     54 00 90 AD |     	if_z    jmp     #p410				' and run away	
00bc0                 | 
00bc0     C8 80 01 F1 |            	add     envph0,envspd0			' envelope PA update
00bc4                 |            	           
00bc4     C0 E6 01 F6 |       	    	mov     envhi, envph0			' move phase acc to high part of env pointer
00bc8     06 E6 45 F0 | 		shr     envhi,#6			' leave 10 bits in hi
00bcc     F3 E8 31 F9 | 	   	getword envlo,envhi,#0              	' and 16 bit in lo
00bd0     10 E6 45 F0 | 	    	shr     envhi,#16			' move 10 bits of hi to the lower word
00bd4     C9 E6 19 F2 | 	    	cmp     envhi,envlen0 wcz		' compare this to envelope length
00bd8                 | 	    											'debug(udec(envhi,envlen0))
00bd8     C9 E6 01 36 |     	if_ge  	mov     envhi,envlen0			' if greater than, set it at envlen
00bdc     00 E8 05 36 |     	if_ge   mov     envlo,#0
00be0     C9 80 01 36 |     	if_ge   mov     envph0,envlen0             	' and set envph0 at the end of the envelope
00be4     16 80 65 30 |     	if_ge   shl     envph0,#22
00be8                 | 
00be8     F3 EA 01 F6 |             	mov 	envs1,envhi			' 10 high bits of PA is the offset to the envelope entry
00bec     01 EA 65 F0 |             	shl 	envs1,#1                        ' these entries are 16 bit so multiply the offset by 2
00bf0     C7 EA 01 F1 |             	add 	envs1,envptr0                   ' and add it to the pointer
00bf4     F5 EA 01 FB |             	rdlong 	envs1,envs1			' and then read 2 entries in one rdlong
00bf8     F5 EC 39 F9 |             	getword envs2,envs1,#1			' then separate them		
00bfc     F5 EA 31 F9 |            	getword envs1,envs1,#0
00c00     F4 EC 01 FA |             	mul     envs2,envlo                     ' and do linear interpolation based on lower bits of the offset
00c04     F4 E8 21 F6 |             	not     envlo
00c08     F4 EA 01 FA |             	mul     envs1,envlo
00c0c     F6 EA 01 F1 |             	add     envs1,envs2
00c10     12 EA 45 F0 |             	shr     envs1,#18			' we need only 14 bits for scas
00c14                 |               
00c14                 | '----------------------------------------------------------------------------------
00c14                 | '------------- Generate the noise if bit 27 of the pointer is set -----------------
00c14                 | '----------------------------------------------------------------------------------
00c14                 | 
00c14                 | 
00c14                 |     	
00c14                 | '----------------------------------------------------------------------------------
00c14                 | '------------- Get the sample -----------------------------------------------------
00c14                 | '----------------------------------------------------------------------------------    	
00c14                 |  
00c14     BD A0 01 F6 | p410  		mov	oldptrh,pointer0h
00c18     C5 9A F9 F8 |            	getbyte	afreq0,freqskip0,#3         	' the frequency is in 8:24 format, so get integer in afreq0
00c1c     08 8A 65 F0 |            	shl	freqskip0,#8                	' and keep the fractional in freqskip0
00c20     C5 78 19 F1 |            	add     pointer0,freqskip0 wcz      	' compute the pointer to the next sample   
00c24     CD 7A 21 F1 |            	addx	pointer0h,afreq0  
00c28                 |           	
00c28     1B 82 0D F4 |    	   	testb   sstart0, #27 wz
00c2c     10 00 90 5D |     	if_nz	jmp #p412   	
00c30     1B 6E 61 CD |    	if_c  	getrnd  spl
00c34     B7 7E 41 C9 |    	if_c	rolword rawspl0,spl,#0	
00c38     BF 6E 31 F9 |    		getword spl,rawspl0,#0
00c3c     90 00 90 FD |       	        jmp     #p406          	
00c40                 |            	
00c40                 |            	
00c40     D0 7A 19 F2 | p412 		cmp	pointer0h,oldptrh wcz
00c44     58 00 90 AD |  	if_e 	jmp 	#p411				' if the pointer didn't change, no sample has to be read
00c48                 |      	
00c48     1F 82 0D F4 |             	testb   sstart0,#31 wz       	   	' bit 31 : 16 bit sample  
00c4c     01 7A 65 A0 |      	if_z    shl     pointer0h,#1        
00c50     1C 82 0D F4 |             	testb   sstart0,#28 wz  		' bit 28 : interleaved sample         
00c54     01 7A 65 A0 |      	if_z    shl     pointer0h,#1        
00c58                 | 												
00c58     C3 7A 19 F2 |             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
00c5c     C3 7A 81 31 |    	if_ge   sub     pointer0h,lend0       
00c60     C2 7A 01 31 |         if_ge   add     pointer0h,lstart0
00c64     C3 7A 19 F2 |             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
00c68     C3 7A 01 36 |         if_ge   mov	pointer0h,lend0	
00c6c                 |  
00c6c     BD 6C 01 F6 |              	mov     qq,pointer0h              	' compute place in the memory from where the sample will be loaded
00c70     C1 6C 01 F1 |            	add     qq,sstart0            
00c74     FF FF 03 FF 
00c78     FF 6D 05 F5 |            	and  	qq,##$7FF_FFFF
00c7c     FF 71 5D F2 |            	cmps    mailbox,#$1FF wcz          	' the mailbox has to point somewhere not at the start of HUB RAM
00c80     B6 6E E1 EA |     	if_le   rdword  spl,qq                      	' if not, use HUB RAM for samples
00c84     F8 00 B0 1D |     	if_gt   call    #cache_read
00c88     1F 82 0D F4 |                 testb   sstart0,#31 wz 
00c8c     08 6E 65 50 |     	if_nz   shl     spl,#8				' convert 8 to 16 bit if needed
00c90     01 7A 45 A0 |         if_z    shr     pointer0h,#1
00c94     1C 82 0D F4 |                 testb   sstart0,#28 wz            
00c98     01 7A 45 A0 |     	if_z    shr     pointer0h,#1    
00c9c     B7 7E 41 F9 |                 rolword rawspl0,spl,#0			' now rawspl0 has oldsample:newsample in it
00ca0                 |               
00ca0     BF 6E 31 F9 | p411	      	getword spl,rawspl0,#0
00ca4     BF 98 39 F9 | 		getword oldspl,rawspl0,#1		' then separate them		
00ca8                 | 
00ca8                 |           '  debug(uhex(pointer0h,pointer0,spl,oldspl))
00ca8                 | 
00ca8                 | 
00ca8     BC E8 01 F6 | 		mov	envlo,pointer0
00cac     12 E8 45 F0 | 		shr 	envlo,#18
00cb0                 | 	
00cb0     F4 6E 31 FA |             	scas    spl,envlo                   	' and do linear interpolation
00cb4     00 6E 01 F6 |             	mov 	spl,0-0
00cb8     F4 E8 21 F6 |             	not     envlo
00cbc     1F 00 00 FF 
00cc0     FF E9 05 F5 |           	and     envlo,##$3FFF
00cc4     F4 98 31 FA |            	scas    oldspl,envlo
00cc8     00 98 01 F6 |             	mov     oldspl,0-0
00ccc     CC 6E 01 F1 |                 add     spl, oldspl
00cd0                 | 	 
00cd0     F5 6E 31 FA | p406        	scas    spl, envs1
00cd4     00 6E 01 F6 |             	mov     spl,0-0
00cd8     CE 6E 31 FA |             	scas    spl,avol0                 	' apply volume
00cdc     00 6E 01 F6 |             	mov     spl,0-0
00ce0                 |  
00ce0     CF 6E 31 FA |             	scas    spl,apan0                 	' apply pan
00ce4     00 A4 01 F6 |             	mov     ls0,0-0
00ce8     20 00 00 FF 
00cec     00 6C 05 F6 |             	mov     qq,##16384
00cf0     CF 6C 81 F1 |             	sub     qq,apan0
00cf4     B6 6E 31 FA |             	scas    spl,qq
00cf8     00 A6 01 F6 |             	mov     rs0, 0-0
00cfc                 |       
00cfc     D3 7C 29 F9 |                 setword sample0,rs0,#1           	' pack samples into long
00d00     D2 7C 21 F9 |                 setword sample0,ls0,#0
00d04                 |                 
00d04     D2 74 01 F1 |                 add  lsample,ls0
00d08     D3 76 01 F1 |                 add  rsample,rs0
00d0c                 |              
00d0c     1E 82 1D F4 |             	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
00d10     00 78 05 A6 |     	if_z    mov     pointer0, #0  
00d14     00 7A 05 A6 |     	if_z    mov     pointer0h, #0  
00d18     00 80 05 A6 |     	if_z    mov     envph0, #0  
00d1c     05 83 65 AC |     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
00d20                 |             
00d20     28 08 64 FD | p403        	setq #4                          	' write new pointer, sample values and env pointer to the hub
00d24     00 79 65 FC | 	       	wrlong  pointer0,ptra
00d28     B5 F0 83 F1 |             	sub     ptra, channeladd         	' reset the pointer to channel parameters
00d2c                 | 
00d2c     85 A3 7D FB |             	djnf    cn, #p401
00d30                 | 
00d30     0F 76 E5 F4 |             	bitnot rsample, #15
00d34     0F 74 E5 F4 |             	bitnot lsample, #15
00d38                 |   							'           	getct ct2  	'debug
00d38                 |   							'          	sub ct2,ct1
00d38                 |   							'          	debug(udec(ct2))
00d38     24 28 60 FD |             	waitse1
00d3c                 |           
00d3c     0E 74 25 FC |            	wypin   lsample, #left              
00d40     0F 76 25 FC |                 wypin   rsample, #right        
00d44                 | 
00d44     BA A8 21 F9 | 		setword oldsample, lsample,#0		' for oscilloscope
00d48     BB A8 29 F9 | 		setword oldsample, rsample,#1
00d4c                 | 		
00d4c     00 76 05 F6 |             	mov rsample, #0
00d50     00 74 05 F6 |             	mov lsample, #0
00d54                 | 
00d54                 | '----------------------------------------------------------------------------------
00d54                 | '------------- Oscilloscope  -----------------------------------------------------
00d54                 | '----------------------------------------------------------------------------------   
00d54                 | 		
00d54     00 AA 0D F2 | 	    	cmp     scbase,#0 wz
00d58     20 00 90 AD |     	if_z    jmp #p302	   
00d5c                 |  
00d5c     01 B0 15 F7 |             	incmod  scope,#1 wc            		'  todo: scope speed instead of const  
00d60     D6 AE 01 C6 |     	if_c    mov scptr2,scptr
00d64     02 AE 65 C0 |     	if_c    shl scptr2,#2
00d68     D5 AE 01 C1 |     	if_c    add scptr2,scbase     
00d6c     60 AE 65 FC |             	wrlong scptr2,#$60
00d70     D7 A8 61 CC |     	if_c    wrlong oldsample,scptr2
00d74     01 00 00 CF 
00d78     7F AC 05 C7 |     	if_c    incmod scptr,##639
00d7c                 |             
00d7c     C0 FD 9F FD |  p302           jmp     #loop            'loop
00d80                 | 
00d80                 | '----------------------------------------------------------------------------------
00d80                 | '------------- This is the end of the main loop -----------------------------------
00d80                 | '----------------------------------------------------------------------------------
00d80                 | 
00d80                 | '----------------------------------------------------------------------------------
00d80                 | '------------- PSRAM cache ----------- --------------------------------------------
00d80                 | '----------------------------------------------------------------------------------
00d80                 | 
00d80                 | ' There are 16 cache pointers for 16 channels
00d80                 | ' if 24 higher bits of address=cache, then get a word from the cache
00d80                 | ' else load the cache from PSRAM, update the pointer, then read a sample
00d80                 | 
00d80                 | 
00d80     B6 E0 E1 F8 | cache_read  	getbyte addrlo,qq,#0 			' when this is called, qq is the addres of the sample			
00d84                 |          '   debug ("cache")
00d84     B6 E2 01 F6 | 	   	mov     addrhi,qq		
00d88     08 E2 45 F0 | 	    	shr     addrhi,#8		        ' get 24 upper bits
00d8c     DD A2 95 F9 | 	    	alts    cn,#cache1            
00d90     00 E2 09 F2 | 	    	cmp	addrhi,0-0 wz               	' and compare with the cache pointer for the channel
00d94     34 00 90 AD |    	if_z    jmp     #p701	    			' if equal, cache hit, read the sample from it
00d98                 | 
00d98     DD A2 8D F9 | p702	    	altd    cn,#cache1			' cache miss. 
00d9c     F1 00 00 F6 | 	    	mov     0-0,addrhi                  	' update the pointer
00da0                 | 	    ''	 debug(uhex(addrhi))
00da0     F1 DA 01 F6 | 	    	mov     cmd,addrhi			' prepare the mailbox
00da4     08 DA 65 F0 | 	    	shl     cmd,#8
00da8     0B DA 3D F8 |             	setnib  cmd, #%1011, #7             	' read burst from the external memory
00dac     D1 DC 01 F6 |             	mov     hubaddr,cn                  	' to the channel cache
00db0     08 DC 65 F0 |             	shl     hubaddr,#8                  	'
00db4     DB DC 01 F1 |             	add     hubaddr,hubptr 
00db8     00 DF 05 F6 |             	mov     count,#256                  	' 256 bytes
00dbc     28 04 64 FD |             	setq    #2                          	' write 3 longs
00dc0     B8 DA 61 FC |             	wrlong  cmd, mailbox                	' run it
00dc4     B8 DA 01 FB | poll1       	rdlong  cmd, mailbox                	' poll mailbox for result
00dc8     FE DB B5 FB |             	tjs     cmd, #poll1                 	' retry until valid 
00dcc                 |             
00dcc                 | 	
00dcc     D1 6C 01 F6 | p701	    	mov     qq,cn				' cache hit
00dd0     08 6C 65 F0 | 	    	shl     qq,#8				' compute the cache start
00dd4     DB 6C 01 F1 | 	    	add     qq,hubptr
00dd8     F0 6C 01 F1 | 	    	add	qq,addrlo			' add 8 lower bits to the cache addredd
00ddc     B6 6E E1 0A |     	_ret_   rdword  spl,qq                      	' read a long from the cache
00de0                 |           
00de0                 |   
00de0                 | 
00de0                 | 
00de0                 | '---------------------------------------------------------------------------
00de0                 | '------- Variables ---------------------------------------------------------
00de0                 | '---------------------------------------------------------------------------
00de0                 | 
00de0                 | ' constants
00de0                 | 
00de0     00 00 00 00 | channeladd 	long 0
00de4                 | 
00de4                 | ' temporary variables 
00de4                 | 
00de4     00 00 00 00 | qq          	long 0
00de8     00 00 00 00 | spl         	long 0
00dec     00 00 00 00 | mailbox     	long 0
00df0     00 00 00 00 | mailbox2    	long 0
00df4     00 00 00 00 | lsample     	long 0
00df8     00 00 00 00 | rsample     	long 0
00dfc                 | 
00dfc                 | ' channel parameter block
00dfc                 | 
00dfc     00 00 00 00 | pointer0    	long 0   
00e00     00 00 00 00 | pointer0h   	long 0  
00e04     00 00 00 00 | sample0     	long 0
00e08     00 00 00 00 | rawspl0	    	long 0
00e0c     00 00 00 00 | envph0	    	long 0
00e10     00 00 00 00 | sstart0     	long 0     ' start pointer and type at bit 31
00e14     00 00 00 00 | lstart0     	long 0
00e18     00 00 00 00 | lend0       	long 0
00e1c     00 00 00 00 | volpan0     	long 0
00e20     00 00 00 00 | freqskip0   	long 0
00e24     00 00 00 00 | command0    	long 0
00e28     00 00 00 00 | envptr0	    	long 0
00e2c     00 00 00 00 | envspd0	    	long 0
00e30     00 00 00 00 | envlen0	    	long 0
00e34     00 00 00 00 | res5	    	long 0
00e38     00 00 00 00 | res6	    	long 0
00e3c                 | 
00e3c     00 00 00 00 | oldspl		long 0
00e40     00 00 00 00 | afreq0      	long 0
00e44                 | 
00e44     00 00 00 00 | avol0       	long 0
00e48     00 00 00 00 | apan0       	long 0
00e4c     00 00 00 00 | oldptrh	    	long 0
00e50     00 00 00 00 | cn          	long 0
00e54                 | 
00e54                 | ' Samples
00e54                 | 
00e54     00 00 00 00 | ls0         	long 0
00e58     00 00 00 00 | rs0         	long 0
00e5c                 | 
00e5c     00 00 00 00 | oldsample   	long 0
00e60                 | 
00e60     00 00 00 00 | scbase 		long 0
00e64     00 00 00 00 | scptr 		long 0
00e68     00 00 00 00 | scptr2		long 0
00e6c     00 00 00 00 | scope 		long 0
00e70                 | 
00e70     44 00 17 00 | dac         	long %10111_00000000_01_00010_0     	'random dither
00e74     46 00 17 00 | dac2        	long %10111_00000000_01_00011_0     	'pwm
00e78                 | 
00e78     00 18 07 00 | hubptr      	long $71800
00e7c     00 1E 00 00 | sr44100     	long 30*256
00e80                 | 
00e80     00 00 00 00 | cache1      	long 0
00e84     00 00 00 00 | cache2      	long 0
00e88     00 00 00 00 | cache3      	long 0
00e8c     00 00 00 00 | cache4      	long 0
00e90     00 00 00 00 | cache5      	long 0
00e94     00 00 00 00 | cache6      	long 0
00e98     00 00 00 00 | cache7      	long 0
00e9c     00 00 00 00 | cache8      	long 0
00ea0     00 00 00 00 | cache9      	long 0
00ea4     00 00 00 00 | cachea      	long 0
00ea8     00 00 00 00 | cacheb      	long 0
00eac     00 00 00 00 | cachec      	long 0
00eb0     00 00 00 00 | cached      	long 0
00eb4     00 00 00 00 | cachee      	long 0
00eb8     00 00 00 00 | cachef      	long 0
00ebc     00 00 00 00 | cache0      	long 0
00ec0                 | 
00ec0     00 00 00 00 | cmd         	long 0
00ec4     00 00 00 00 | hubaddr    	long 0
00ec8     00 01 00 00 | count       	long 256
00ecc                 | 
00ecc     00 00 00 00 | addrlo 		long 0
00ed0     00 00 00 00 | addrhi 		long 0
00ed4     00 00 00 00 | pointer00 	long 0
00ed8     00 00 00 00 | envhi 		long 0
00edc     00 00 00 00 | envlo 		long 0
00ee0     00 00 00 00 | envs1 		long 0
00ee4     00 00 00 00 | envs2 		long 0
00ee8     00 00 00 00 | noise0 		long 0
00eec                 | 
00eec                 | 'ct1 		long 0
00eec                 | 'ct2 		long 0
00eec                 | 
00eec                 | 		fit 256		'todo: maybe the better interpolation. Or all params in cog
00eec                 | 		fit 256		'todo: maybe the better interpolation. Or all params in cog
00eec     00 00 00 00 
00ef0     00 00 00 00 | null  			long 	0,0           ' for channel reset
00ef4                 | objmem
00ef4     00 00 00 00 
      ...             
01458     00 00 00 00 
0145c     00 00 00 00 | 	long	0[347]
01460                 | stackspace
01460     00 00 00 00 | 	long	0[1]
01464 0ff             | 	org	COG_BSS_START
01464 0ff             | _var01
01464 0ff             | 	res	1
01464 100             | _var02
01464 100             | 	res	1
01464 101             | _var03
01464 101             | 	res	1
01464 102             | arg01
01464 102             | 	res	1
01464 103             | arg02
01464 103             | 	res	1
01464 104             | arg03
01464 104             | 	res	1
01464 105             | arg04
01464 105             | 	res	1
01464 106             | local01
01464 106             | 	res	1
01464 107             | local02
01464 107             | 	res	1
01464 108             | local03
01464 108             | 	res	1
01464 109             | local04
01464 109             | 	res	1
01464 10a             | 	fit	480
01464 10a             | 
