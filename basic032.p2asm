con
	_clkfreq = 340500000
	_clkmode = 27175163
	fbReadOnly = 1
	fbHidden = 2
	fbSystem = 4
	fbDirectory = 16
	fbArchive = 32
	fbNormal = 33
	HEAPSIZE = 96000
	ver = 32
	key_enter = 141
	key_escape = 155
	key_backspace = 136
	key_tab = 137
	key_f1 = 186
	key_f2 = 187
	key_f3 = 188
	key_f4 = 189
	key_f5 = 190
	key_f6 = 191
	key_f7 = 192
	key_f8 = 193
	key_f9 = 194
	key_f10 = 195
	key_f11 = 196
	key_f12 = 197
	key_rightarrow = 206
	key_leftarrow = 207
	key_downarrow = 208
	key_uparrow = 209
	token_plus = 1
	token_minus = 2
	token_or = 3
	token_xor = 4
	token_mul = 5
	token_fdiv = 6
	token_and = 7
	token_div = 8
	token_mod = 9
	token_shl = 10
	token_shr = 11
	token_power = 12
	token_not = 13
	token_at = 14
	token_gt = 15
	token_lt = 16
	token_comma = 17
	token_semicolon = 18
	token_ear = 19
	token_rpar = 20
	token_lpar = 21
	token_colon = 22
	fun_getvar = 17
	fun_getaddr = 18
	fun_getfvar = 19
	fun_getsvar = 20
	fun_negative = 21
	fun_converttoint = 22
	fun_assign = 23
	fun_assign_i = 23
	fun_assign_u = 24
	fun_assign_f = 25
	fun_assign_s = 26
	token_eq = 27
	fun_pushi = 28
	fun_pushu = 29
	fun_pushf = 30
	fun_pushs = 31
	print_mod_empty = 32
	print_mod_comma = 33
	print_mod_semicolon = 34
	token_linenum_major = 35
	token_linenum_minor = 36
	token_nextline_ptr = 37
	token_le = 38
	token_ge = 39
	token_inc = 40
	token_dec = 41
	token_ne = 42
	fun_pushs2 = 43
	token_channel = 44
	token_skip = 45
	token_cls = 64
	token_new = 65
	token_plot = 66
	token_draw = 67
	token_print = 68
	token_circle = 69
	token_fcircle = 70
	token_box = 71
	token_frame = 72
	token_color = 73
	token_for = 74
	token_next = 75
	token_list = 76
	token_run = 77
	token_fast_goto = 78
	token_slow_goto = 79
	token_csave = 80
	token_save = 81
	token_load = 82
	token_find_goto = 83
	token_rnd = 84
	token_pinwrite = 85
	token_waitms = 86
	token_waitvbl = 87
	token_if = 88
	token_brun = 89
	token_else = 90
	token_then = 91
	token_beep = 92
	token_dir = 93
	token_paper = 94
	token_ink = 95
	token_font = 96
	token_mode = 97
	token_gettime = 98
	token_mouse = 99
	token_mousex = 100
	token_mousey = 101
	token_mousek = 102
	token_mousew = 103
	token_cursor = 104
	token_click = 105
	token_stick = 106
	token_sin = 107
	token_defsprite = 108
	token_sprite = 109
	token_strig = 110
	token_getpixel = 111
	token_waitclock = 112
	token_fill = 113
	token_dim = 114
	token_defsnd = 115
	token_defenv = 116
	token_play = 117
	token_rdpin = 118
	token_wxpin = 119
	token_wypin = 120
	token_wrpin = 121
	token_rqpin = 122
	token_pinread = 123
	token_pinfloat = 124
	token_pinlo = 125
	token_pinhi = 126
	token_pinstart = 127
	token_pintoggle = 128
	token_position = 129
	token_cos = 130
	token_tan = 131
	token_asin = 132
	token_acos = 133
	token_atn = 134
	token_sqr = 135
	token_rad = 136
	token_deg = 137
	token_int = 138
	token_setvol = 139
	token_setpan = 140
	token_setlen = 141
	token_setdelay = 142
	token_setwave = 143
	token_setenv = 144
	token_setsustain = 145
	token_release = 146
	token_getenvsustain = 147
	token_getnotevalue = 148
	token_poke = 149
	token_dpoke = 150
	token_lpoke = 151
	token_peek = 152
	token_dpeek = 153
	token_lpeek = 154
	token_adr = 155
	token_fre = 156
	token_inkey = 157
	token_abs = 158
	token_chr = 159
	token_val = 160
	token_str = 161
	token_bin = 162
	token_hex = 163
	token_left = 164
	token_right = 165
	token_mid = 166
	token_asc = 167
	token_len = 168
	token_gosub = 169
	token_return = 170
	token_progend = 171
	token_pop = 172
	token_log = 173
	token_changefreq = 174
	token_changevol = 175
	token_changewave = 176
	token_changepan = 177
	token_shutup = 178
	token_open = 179
	token_close = 180
	token_input = 181
	token_read = 182
	token_data = 183
	token_cload = 184
	token_blit = 185
	token_playsample = 186
	token_get = 187
	token_put = 188
	token_enter = 189
	token_rem = 190
	token_round = 191
	token_coginit = 192
	token_on = 193
	token_delete = 194
	token_cd = 195
	token_copy = 196
	token_framebuf = 197
	token_mkdir = 198
	token_error = 255
	token_end = 510
	token_space = 511
	token_decimal = 512
	token_integer = 513
	token_float = 514
	token_string = 515
	token_name = 516
	token_notename = 768
	result_int = 28
	result_uint = 29
	result_float = 30
	result_string = 31
	result_string2 = 43
	result_array = 114
	result_error = 255
	result_channel = 44
	array_no_type = 256
	array_byte = 257
	array_ubyte = 258
	array_short = 259
	array_ushort = 260
	array_long = 261
	array_ulong = 262
	array_int64 = 263
	array_uint64 = 264
	array_float = 265
	array_double = 266
	array_string = 267
	maxvars = 1024
	maxstack = 512
	maxfor = 64
	maxgosub = 64
	memlo = 524288
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 340500000
	long	0 ' clock mode: will default to $19ea8fb
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##27175160
	waitx	##200000
	mov	pa, ##27175163
	hubset	pa
	wrlong	pa, #24
	wrlong	##340500000, #20
	jmp	#skip_clock_set_
	orgf	128
skip_clock_set_
	call	#_program
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    mov	fcache_tmpb_,ptrb
    pop	ptrb
    altd	pa,ret_instr_
    mov	 0-0, ret_instr_
    setq	pa
    rdlong	$0, ptrb++
    push	ptrb
    mov ptrb,fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    _ret_ cmp inb,#0
fcache_tmpb_
    long 0
fcache_load_ptr_
    long FCACHE_LOAD_
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret
COUNT_
    long 0
RETADDR_
    long 0
fp
    long 0
pushregs_
    pop  pa
    pop  RETADDR_
    tjz  COUNT_, #pushregs_done_
    altd  COUNT_, #511
    setq #0-0
    wrlong local01, ptra++
pushregs_done_
    setq #2 ' push 3 registers starting at COUNT_
    wrlong COUNT_, ptra++
    mov    fp, ptra
    jmp  pa
 popregs_
    pop    pa
    setq   #2
    rdlong COUNT_, --ptra
    djf    COUNT_, #popregs__ret
    setq   COUNT_
    rdlong local01, --ptra
popregs__ret
    push   RETADDR_
    jmp    pa

divide_
       abs     muldivb_,muldivb_     wcz      'abs(y)
       wrc     itmp2_                         'store sign of y
       abs     muldiva_,muldiva_     wc       'abs(x)
       qdiv    muldiva_, muldivb_             'queue divide
 if_c  xor     itmp2_,#1                      'store sign of x
       getqx   muldivb_                       'get quotient
       getqy   muldiva_                       'get remainder
       negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
       testb   itmp2_,#0             wc       'restore sign, division result
 _ret_ negc    muldivb_,muldivb_     
__pc long 0
__setjmp
    pop __pc
    mov result1, #0
    mov result2, #0
    mov abortchain, arg01
    wrlong fp, arg01
    add arg01, #4
    wrlong ptra, arg01
    add arg01, #4
    wrlong objptr, arg01
    add arg01, #4
    wrlong __pc, arg01
    jmp __pc
__unwind_pc long 0
__unwind_stack
   pop  __unwind_pc
__unwind_loop
   cmp  arg01, arg02 wz
  if_z jmp #__unwind_stack_ret
   mov   ptra, arg01
   call  #popregs_
   mov   arg01, fp
   jmp   #__unwind_loop
__unwind_stack_ret
   jmp  __unwind_pc
__longjmp
    pop __pc
    cmp    arg01, #0 wz
 if_z jmp #nocatch
    mov result1, arg02
    mov result2, #1
    rdlong arg02, arg01
    add arg01, #4
    rdlong ptra, arg01
    add arg01, #4
    rdlong objptr, arg01
    add arg01, #4
    rdlong __pc, arg01
    mov arg01, fp
    call #__unwind_stack
__longjmp_ret
    jmp  __pc
nocatch
    cmp arg03, #0 wz
 if_z jmp #cogexit
    jmp #__longjmp_ret

__heap_ptr
	long	@__heap_base
__methods__
	long	@__methodtable__
abortchain
	long	0
entryptr__
	long	@entry
itmp1_
	long	0
itmp2_
	long	0
objptr
	long	@objmem
ptr___system__dat__
	long	@__system__dat_
ptr__audio096_spin2_dat__
	long	@_audio096_spin2_dat_
ptr__dat__
	long	@_dat_
ptr__fatfs_cc_dat__
	long	@_fatfs_cc_dat_
ptr__hg010b_spin2_dat__
	long	@_hg010b_spin2_dat_
ptr__housekeeper_
	long	@_housekeeper
ptr__psram16drv_spin2_dat__
	long	@_psram16drv_spin2_dat_
ptr__psram_spin2_dat__
	long	@_psram_spin2_dat_
ptr__usbnew_spin2_dat__
	long	@_usbnew_spin2_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
result2
	long	1
result3
	long	2
COG_BSS_START
	fit	480
	orgh
hubentry

' 
' '-------------------------------------------------------------------------------------------------------- 
' '------------------------------------ MAIN LOOP END -----------------------------------------------------
' '--------------------------------------------------------------------------------------------------------
' 
' ''-------------------------------------------------------------------------------------------------------
' '                     A full screen editor for programming and entering data
' ''-------------------------------------------------------------------------------------------------------
' 
' function edit() as string
_edit
	mov	COUNT_, #26
	call	#pushregs_
	mov	local01, #0
	mov	local02, #0
	mov	local03, #0
	mov	local04, #0
' rpt=0 : rptcnt=0 : key=0 : key2=0 : key3=0 : key4=0 
' do
LR__0001
	mov	arg01, #1
	call	#_hg010b_spin2_waitvbl
	call	#_usbnew_spin2_get_key
	mov	local05, result1
'   return hkbd_led_rep
	add	ptr__usbnew_spin2_dat__, ##10196
	rdbyte	result1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10196
	add	objptr, ##41968
	wrlong	result1, objptr
	sub	objptr, ##41968
' if key>0 andalso key<4 andalso keyclick=1 then paula.play(7,@atari2_spl,44100,4096,0,1758): waitms(10): paula.stop(7)
	cmp	local05, #1 wc
 if_b	jmp	#LR__0002
	cmp	local05, #4 wc
 if_ae	jmp	#LR__0002
	add	objptr, ##41236
	rdlong	local06, objptr
	sub	objptr, ##41236
	cmp	local06, #1 wz
 if_ne	jmp	#LR__0002
	add	ptr__dat__, ##2212
	mov	local07, ##44100
	decod	local08, #12
	mov	local09, #0
	mov	local10, ##1758
	mov	arg01, #7
	mov	arg02, ptr__dat__
	mov	arg03, ##44100
	decod	arg04, #12
	mov	arg05, #0
	mov	arg06, ##1758
	add	objptr, ##5836
	sub	ptr__dat__, ##2212
	call	#_audio096_spin2_play
	sub	objptr, ##5836
	mov	arg01, #10
	call	#__system___waitms
	mov	local06, #7
	mov	arg01, #7
	add	objptr, ##5836
	call	#_audio096_spin2_stop
	sub	objptr, ##5836
LR__0002
' if key>3 andalso key<$80000000 andalso (key and 255) <$E0 then key2=key : rpt=1 : key3=key2 
	cmp	local05, #4 wc
 if_b	jmp	#LR__0003
	cmp	local05, ##-2147483648 wc
 if_b	mov	local06, local05
 if_b	getbyte	local06, local06, #0
 if_b	cmp	local06, #224 wc
 if_b	mov	local03, local05
 if_b	mov	local01, #1
 if_b	mov	local04, local03
LR__0003
' if key>$80000000 then rptcnt=0 : rpt=0
	cmp	local05, ##-2147483647 wc
 if_ae	mov	local02, #0
 if_ae	mov	local01, #0
' if key=0 andalso rpt=1 then rptcnt+=1
	cmp	local05, #0 wz
 if_e	cmp	local01, #1 wz
 if_e	add	local02, #1
' if key<$80000000 then if rptcnt=25 then key3=key2 : rptcnt=21
	cmp	local05, ##-2147483648 wc
 if_b	cmp	local02, #25 wz
 if_c_and_z	mov	local04, local03
 if_c_and_z	mov	local02, #21
' 
' '' there is a key pressed and it needs to be processed
' 
' if key3<>0 then
	cmp	local04, #0 wz
 if_e	jmp	#LR__0001
'   if keyclick=1 then paula.play(7,keyclick_spl,44100,4096,spl_len)     	' make a click
	add	objptr, ##41236
	rdlong	local06, objptr
	sub	objptr, ##41236
	cmp	local06, #1 wz
 if_ne	jmp	#LR__0004
	add	objptr, ##41912
	rdlong	arg02, objptr
	mov	local07, ##44100
	decod	local08, #12
	sub	objptr, #4
	rdlong	local09, objptr
	neg	local10, #1
	mov	arg01, #7
	mov	arg03, ##44100
	decod	arg04, #12
	mov	arg05, local09
	neg	arg06, #1
	sub	objptr, ##36072
	call	#_audio096_spin2_play
	sub	objptr, ##5836
LR__0004
	mov	arg01, local04
	call	#_scantochar
	mov	local11, result1
'   if leds and 2 = 2 then 						' caps lock
	add	objptr, ##41968
	rdlong	local12, objptr
	sub	objptr, ##41968
	mov	local06, local12 wz
 if_e	jmp	#LR__0012
'     if key4>96 andalso key4<123 then                 
	cmp	local11, #97 wc
 if_b	jmp	#LR__0005
	cmp	local11, #123 wc
 if_b	sub	local11, #32
 if_b	jmp	#LR__0011
LR__0005
	cmp	local11, #65 wc
 if_b	jmp	#LR__0006
	cmp	local11, #91 wc
 if_b	add	local11, #32
 if_b	jmp	#LR__0010
LR__0006
	cmp	local11, #23 wc
 if_b	jmp	#LR__0007
	cmp	local11, #32 wc
 if_b	sub	local11, #9
 if_b	jmp	#LR__0009
LR__0007
	cmp	local11, #14 wc
 if_b	jmp	#LR__0008
	cmp	local11, #23 wc
 if_b	add	local11, #39
LR__0008
LR__0009
LR__0010
LR__0011
LR__0012
'  
'   if key4>0 andalso key4<127 andalso v.cursor_x<254 then		' put the char on the screen 
	cmp	local11, #1 wc
 if_b	jmp	#LR__0017
	cmp	local11, #127 wc
 if_b	add	objptr, #60
 if_b	rdword	local06, objptr
 if_b	sub	objptr, #60
 if_b	cmp	local06, #254 wc
 if_ae	jmp	#LR__0017
'     if do_insert then							' move the characters right
	add	objptr, ##41948
	rdlong	local06, objptr wz
	sub	objptr, ##41948
 if_e	jmp	#LR__0016
'       for i=  v.textbuf_ptr+128*v.cursor_y+127 to v.textbuf_ptr+128*v.cursor_y+(v.cursor_x/2)+1 step -1 : pspoke i,pspeek(i-1) : next i 
	add	objptr, #62
	rdbyte	local07, objptr
	getbyte	local08, local07, #0
	mul	local08, #128
	sub	objptr, #58
	rdlong	local13, objptr
	mov	local14, local13
	add	local14, local08
	add	local14, #127
	getbyte	local07, local07, #0
	mul	local07, #128
	add	local13, local07
	add	objptr, #56
	rdword	local09, objptr
	sub	objptr, #60
	abs	local15, local09 wc
	shr	local15, #1
	sumc	local13, local15
	add	local13, #1
LR__0013
	mov	local16, local14
	sub	local16, #1
	mov	arg01, local16
	call	#_pspeek
	mov	local17, result1
	getbyte	local18, local17, #0
	mov	local19, local18
	mov	arg01, local14
	mov	arg02, local19
	call	#_pspoke
	sub	local14, #1
	cmps	local14, local13 wc
 if_ae	jmp	#LR__0013
	add	objptr, ##41976
	wrlong	#0, objptr
	sub	objptr, ##41914
	rdbyte	local07, objptr
	getbyte	local08, local07, #0
	mul	local08, #128
	sub	objptr, #58
	rdlong	local09, objptr
	mov	local14, local09
	add	local14, local08
	add	objptr, #56
	rdword	local15, objptr
	getword	local10, local15, #0
	abs	local20, local10 wc
	shr	local20, #1
	negc	local20, local20
	add	local14, local20
	getbyte	local07, local07, #0
	mul	local07, #128
	mov	local08, local09
	sub	objptr, #60
	mov	local21, local08
	add	local21, local07
	add	local21, #128
LR__0014
	cmps	local14, local21 wc
 if_ae	jmp	#LR__0015
	add	objptr, #60
	rdword	local06, objptr
	add	objptr, ##41916
	rdlong	local08, objptr
	shl	local08, #1
	add	local06, local08
	sub	objptr, ##41914
	rdbyte	local12, objptr
	sub	objptr, #62
	mul	local12, #16
	add	local12, #4
	mov	arg01, local14
	call	#_pspeek
	getbyte	local07, result1, #0
	add	objptr, #65
	rdlong	local08, objptr
	add	objptr, #4
	rdlong	local10, objptr
	sub	objptr, #69
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local12
	mov	arg03, local07
	mov	arg04, local08
	mov	arg05, local09
	call	#_hg010b_spin2_putcharxycgf
	add	objptr, ##41976
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##41976
	add	local14, #1
	jmp	#LR__0014
LR__0015
LR__0016
	mov	arg01, local11
	call	#_hg010b_spin2_putchar
LR__0017
'   if key4>0 andalso key4<127 andalso v.cursor_x=254 andalso keyclick=1 then paula.play(7,@atari2_spl,44100,4096,0,1758): waitms(300): paula.stop(7) 'end of line reached
	cmp	local11, #1 wc
 if_b	jmp	#LR__0018
	cmp	local11, #127 wc
 if_ae	jmp	#LR__0018
	add	objptr, #60
	rdword	local06, objptr
	sub	objptr, #60
	cmp	local06, #254 wz
 if_e	add	objptr, ##41236
 if_e	rdlong	local08, objptr
 if_e	sub	objptr, ##41236
 if_e	mov	local07, local08
 if_e	cmp	local07, #1 wz
 if_ne	jmp	#LR__0018
	add	ptr__dat__, ##2212
	mov	arg02, ptr__dat__
	sub	ptr__dat__, ##2212
	mov	local07, ##44100
	decod	local08, #12
	mov	local09, #0
	mov	local10, ##1758
	mov	arg01, #7
	mov	arg03, ##44100
	decod	arg04, #12
	mov	arg05, #0
	mov	arg06, ##1758
	add	objptr, ##5836
	call	#_audio096_spin2_play
	sub	objptr, ##5836
	mov	arg01, #300
	call	#__system___waitms
	mov	arg01, #7
	add	objptr, ##5836
	call	#_audio096_spin2_stop
	sub	objptr, ##5836
LR__0018
'  
'   if key4=key_enter then 						' get the line from the  screen and return it
	cmp	local11, #141 wz
 if_ne	jmp	#LR__0022
	mov	local22, ##@LR__5187
'     line$="" 
'     for i=editor_spaces to 127
	add	objptr, ##28212
	rdlong	local14, objptr
	sub	objptr, ##28212
LR__0019
	cmps	local14, #128 wc
 if_ae	jmp	#LR__0020
	add	objptr, #62
	rdbyte	local15, objptr
	mul	local15, #128
	sub	objptr, #58
	rdlong	arg01, objptr
	sub	objptr, #4
	add	arg01, local15
	add	arg01, local14
	call	#_pspeek
	getbyte	arg01, result1, #0
	call	#__system__Chr_S
	mov	arg02, result1
	mov	arg01, local22
	call	#__system___string_concat
	mov	local22, result1
	add	local14, #1
	jmp	#LR__0019
LR__0020
'     if do_insert andalso v.cursor_y<35 then v.scrolldown(v.cursor_y+1)
	add	objptr, ##41948
	rdlong	local06, objptr wz
	sub	objptr, ##41948
 if_e	jmp	#LR__0021
	add	objptr, #62
	rdbyte	local07, objptr
	sub	objptr, #62
	cmp	local07, #35 wc
 if_b	add	objptr, #62
 if_b	rdbyte	arg01, objptr
 if_b	sub	objptr, #62
 if_b	add	arg01, #1
 if_b	call	#_hg010b_spin2_scrolldown
LR__0021
	call	#_hg010b_spin2_crlf
'     v.crlf() 
'     return  line$
	mov	result1, local22
	jmp	#LR__0049
LR__0022
	getbyte	local11, local04, #0
'   
'   if key4 = 43 andalso v.cursor_x>=240 andalso keyclick=1 then paula.play(0,@atari2_spl,44100,16384,0,1758): waitms(300): paula.stop(0)  	' tab
	cmp	local11, #43 wz
 if_ne	jmp	#LR__0023
	add	objptr, #60
	rdword	local06, objptr
	sub	objptr, #60
	cmp	local06, #240 wc
 if_b	jmp	#LR__0023
	add	objptr, ##41236
	rdlong	local08, objptr
	sub	objptr, ##41236
	mov	local07, local08
	cmp	local07, #1 wz
 if_ne	jmp	#LR__0023
	add	ptr__dat__, ##2212
	mov	arg02, ptr__dat__
	sub	ptr__dat__, ##2212
	mov	local07, ##44100
	decod	local08, #14
	mov	local09, #0
	mov	local10, ##1758
	mov	arg01, #0
	mov	arg03, ##44100
	decod	arg04, #14
	mov	arg05, #0
	mov	arg06, ##1758
	add	objptr, ##5836
	call	#_audio096_spin2_play
	sub	objptr, ##5836
	mov	arg01, #300
	call	#__system___waitms
	mov	arg01, #0
	add	objptr, ##5836
	call	#_audio096_spin2_stop
	sub	objptr, ##5836
LR__0023
'   if key4=77 then i=127 : do: 															' end
	cmp	local11, #77 wz
 if_ne	jmp	#LR__0028
	mov	local14, #127
LR__0024
'     if pspeek(v.textbuf_ptr+128*v.cursor_y+i)<>32 then 
	add	objptr, #62
	rdbyte	local09, objptr
	getbyte	local08, local09, #0
	mov	local10, local08
	mul	local10, #128
	sub	objptr, #58
	rdlong	local15, objptr
	sub	objptr, #4
	mov	local07, local15
	add	local07, local10
	add	local07, local14
	mov	arg01, local07
	call	#_pspeek
	getbyte	local06, result1, #0
	cmp	local06, #32 wz
 if_e	jmp	#LR__0026
'       if i<127 then v.setcursorx(2*i+2) else v.setcursorx(254)
	cmps	local14, #127 wc
 if_ae	jmp	#LR__0025
	mov	local07, local14
	shl	local07, #1
	mov	arg01, local07
	add	arg01, #2
	call	#_hg010b_spin2_setcursorx
	jmp	#LR__0027
LR__0025
	mov	arg01, #254
	call	#_hg010b_spin2_setcursorx
	jmp	#LR__0027
LR__0026
	sub	local14, #1
	add	objptr, ##28212
	rdlong	local06, objptr
	sub	objptr, ##28212
	cmp	local14, local06 wz
 if_ne	jmp	#LR__0024
LR__0027
LR__0028
'   if i=editor_spaces then v.setcursorx(2*editor_spaces)
	add	objptr, ##28212
	rdlong	local12, objptr
	sub	objptr, ##28212
	mov	local06, local12
	cmp	local14, local06 wz
 if_ne	jmp	#LR__0029
	add	objptr, ##28212
	rdlong	local08, objptr
	sub	objptr, ##28212
	mov	local07, local08
	mov	local12, local07
	shl	local12, #1
	mov	local06, local12
	mov	arg01, local06
	call	#_hg010b_spin2_setcursorx
LR__0029
'     
'   if key4=74 then v.setcursorx(editor_spaces*2)													' home
	cmp	local11, #74 wz
 if_ne	jmp	#LR__0030
	add	objptr, ##28212
	rdlong	local08, objptr
	sub	objptr, ##28212
	mov	local07, local08
	mov	local12, local07
	shl	local12, #1
	mov	local06, local12
	mov	arg01, local06
	call	#_hg010b_spin2_setcursorx
LR__0030
'   if key4=75 then v.setcursory(0)														' pgup
	cmp	local11, #75 wz
 if_e	mov	local06, #0
 if_e	mov	arg01, #0
 if_e	call	#_hg010b_spin2_setcursory
'   if key4=78 then v.setcursory(36) 														' pgdn, todo: parameter instead 36
	cmp	local11, #78 wz
 if_e	mov	local06, #36
 if_e	mov	arg01, #36
 if_e	call	#_hg010b_spin2_setcursory
'   if key4=76 then 																' del
	cmp	local11, #76 wz
 if_ne	jmp	#LR__0035
'     for i=v.textbuf_ptr+128*v.cursor_y+(v.cursor_x/2) to v.textbuf_ptr+128*v.cursor_y+127 : pspoke i,pspeek(i+1) : next i : pspoke v.textbuf_ptr+128*v.cursor_y+127,32
	add	objptr, #62
	rdbyte	local07, objptr
	getbyte	local08, local07, #0
	mul	local08, #128
	sub	objptr, #58
	rdlong	local23, objptr
	mov	local14, local23
	add	local14, local08
	add	objptr, #56
	rdword	local10, objptr
	abs	local20, local10 wc
	shr	local20, #1
	sumc	local14, local20
	getbyte	local07, local07, #0
	mul	local07, #128
	sub	objptr, #60
	add	local23, local07
	add	local23, #128
LR__0031
	cmps	local14, local23 wc
 if_ae	jmp	#LR__0032
	mov	arg01, local14
	add	arg01, #1
	call	#_pspeek
	getbyte	arg02, result1, #0
	mov	arg01, local14
	call	#_pspoke
	add	local14, #1
	jmp	#LR__0031
LR__0032
	add	objptr, #62
	rdbyte	local09, objptr
	mul	local09, #128
	sub	objptr, #58
	rdlong	arg01, objptr
	sub	objptr, #4
	add	arg01, local09
	add	arg01, #127
	mov	arg02, #32
	call	#_pspoke
	add	objptr, ##41976
	wrlong	#0, objptr
	sub	objptr, ##41914
	rdbyte	local12, objptr
	getbyte	local08, local12, #0
	mul	local08, #128
	sub	objptr, #58
	rdlong	local09, objptr
	mov	local14, local09
	add	local14, local08
	add	objptr, #56
	rdword	local15, objptr
	getword	local10, local15, #0
	abs	local20, local10 wc
	shr	local20, #1
	negc	local20, local20
	add	local14, local20
	getbyte	local06, local12, #0
	mov	local07, local06
	mul	local07, #128
	mov	local08, local09
	sub	objptr, #60
	mov	local24, local08
	add	local24, local07
	add	local24, #128
LR__0033
	cmps	local14, local24 wc
 if_ae	jmp	#LR__0034
	add	objptr, #60
	rdword	local06, objptr
	add	objptr, ##41916
	rdlong	local08, objptr
	shl	local08, #1
	add	local06, local08
	sub	objptr, ##41914
	rdbyte	local12, objptr
	sub	objptr, #62
	mul	local12, #16
	add	local12, #4
	mov	arg01, local14
	call	#_pspeek
	getbyte	local07, result1, #0
	add	objptr, #65
	rdlong	local08, objptr
	add	objptr, #4
	rdlong	local10, objptr
	sub	objptr, #69
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local12
	mov	arg03, local07
	mov	arg04, local08
	mov	arg05, local09
	call	#_hg010b_spin2_putcharxycgf
	add	objptr, ##41976
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##41976
	mov	local06, local14
	mov	local12, local14
	add	local12, #1
	mov	local14, local12
	jmp	#LR__0033
LR__0034
LR__0035
' 
'   if key4 = 42 then  'backspace
	cmp	local11, #42 wz
 if_ne	jmp	#LR__0041
'     if v.cursor_x>editor_spaces*2 then 
	add	objptr, #60
	rdword	local12, objptr
	getword	local06, local12, #0
	add	objptr, ##28152
	rdlong	local09, objptr
	sub	objptr, ##28212
	mov	local08, local09
	mov	local07, local08
	shl	local07, #1
	cmps	local06, local07 wcz
 if_be	jmp	#LR__0039
	add	objptr, #60
	rdword	arg01, objptr
	sub	arg01, #2
	add	objptr, #2
	rdbyte	arg02, objptr
	sub	objptr, #62
	call	#_hg010b_spin2_setcursorpos
'       position v.cursor_x-2,v.cursor_y
'       for i=v.textbuf_ptr+128*v.cursor_y+(v.cursor_x/2) to v.textbuf_ptr+128*v.cursor_y+127 : pspoke i,pspeek(i+1) : next i : pspoke v.textbuf_ptr+128*v.cursor_y+127,32
	add	objptr, #62
	rdbyte	local07, objptr
	getbyte	local08, local07, #0
	mul	local08, #128
	sub	objptr, #58
	rdlong	local25, objptr
	mov	local14, local25
	add	local14, local08
	add	objptr, #56
	rdword	local10, objptr
	abs	local20, local10 wc
	shr	local20, #1
	sumc	local14, local20
	getbyte	local07, local07, #0
	mul	local07, #128
	sub	objptr, #60
	add	local25, local07
	add	local25, #128
LR__0036
	cmps	local14, local25 wc
 if_ae	jmp	#LR__0037
	mov	arg01, local14
	add	arg01, #1
	call	#_pspeek
	getbyte	arg02, result1, #0
	mov	arg01, local14
	call	#_pspoke
	add	local14, #1
	jmp	#LR__0036
LR__0037
	add	objptr, #62
	rdbyte	local09, objptr
	mul	local09, #128
	sub	objptr, #58
	rdlong	arg01, objptr
	sub	objptr, #4
	add	arg01, local09
	add	arg01, #127
	mov	arg02, #32
	call	#_pspoke
	add	objptr, ##41976
	wrlong	#0, objptr
	sub	objptr, ##41914
	rdbyte	local12, objptr
	getbyte	local08, local12, #0
	mul	local08, #128
	sub	objptr, #58
	rdlong	local09, objptr
	mov	local14, local09
	add	local14, local08
	add	objptr, #56
	rdword	local15, objptr
	getword	local10, local15, #0
	abs	local20, local10 wc
	shr	local20, #1
	negc	local20, local20
	add	local14, local20
	getbyte	local06, local12, #0
	mov	local07, local06
	mul	local07, #128
	mov	local08, local09
	sub	objptr, #60
	mov	local26, local08
	add	local26, local07
	add	local26, #128
LR__0038
	cmps	local14, local26 wc
 if_ae	jmp	#LR__0040
	add	objptr, #60
	rdword	local06, objptr
	add	objptr, ##41916
	rdlong	local08, objptr
	shl	local08, #1
	add	local06, local08
	sub	objptr, ##41914
	rdbyte	local12, objptr
	sub	objptr, #62
	mul	local12, #16
	add	local12, #4
	mov	arg01, local14
	call	#_pspeek
	getbyte	local07, result1, #0
	add	objptr, #65
	rdlong	local08, objptr
	add	objptr, #4
	rdlong	local10, objptr
	sub	objptr, #69
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local12
	mov	arg03, local07
	mov	arg04, local08
	mov	arg05, local09
	call	#_hg010b_spin2_putcharxycgf
	add	objptr, ##41976
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##41976
	mov	local06, local14
	mov	local12, local14
	add	local12, #1
	mov	local14, local12
	jmp	#LR__0038
LR__0039
	mov	local22, ##@LR__5188
	mov	local06, #4
	add	objptr, #60
	wrword	#4, objptr
	sub	objptr, #60
LR__0040
LR__0041
' 
'   if key4=82 then 						' arrow up
	cmp	local11, #82 wz
 if_ne	jmp	#LR__0042
' return cursor_y
	add	objptr, #62
	rdbyte	result1, objptr
	sub	result1, #1
	add	objptr, ##41890
	wrlong	result1, objptr
'     cy=v.getcursory()-1 : if cy<0 then cy=0 
	sub	objptr, ##41952
	cmps	result1, #0 wc
 if_b	add	objptr, ##41952
 if_b	wrlong	#0, objptr
 if_b	sub	objptr, ##41952
	add	objptr, ##41952
	rdlong	local12, objptr
	sub	objptr, ##41952
	mov	local06, local12
	mov	arg01, local06
	call	#_hg010b_spin2_setcursory
LR__0042
'   if key4=81 then						' arrow down,  todo: remove hardcoded 36
	cmp	local11, #81 wz
 if_ne	jmp	#LR__0043
' return cursor_y
	add	objptr, #62
	rdbyte	result1, objptr
	add	result1, #1
	add	objptr, ##41890
	wrlong	result1, objptr
'     cy=v.getcursory()+1 : if cy>36  then cy=36
	sub	objptr, ##41952
	cmps	result1, #37 wc
 if_ae	add	objptr, ##41952
 if_ae	wrlong	#36, objptr
 if_ae	sub	objptr, ##41952
	add	objptr, ##41952
	rdlong	local12, objptr
	sub	objptr, ##41952
	mov	local06, local12
	mov	arg01, local06
	call	#_hg010b_spin2_setcursory
LR__0043
'   if key4=80 then
	cmp	local11, #80 wz
 if_ne	jmp	#LR__0044
' return cursor_x
	add	objptr, #60
	rdword	local06, objptr
	sub	local06, #2
	add	objptr, ##41896
	wrlong	local06, objptr
'     cx=v.getcursorx()-2 					' arrow left
'     if cx<editor_spaces then cx=editor_spaces			
	sub	objptr, ##13744
	rdlong	local08, objptr
	sub	objptr, ##28212
	mov	local07, local08
	cmps	local06, local07 wc
 if_b	add	objptr, ##28212
 if_b	rdlong	local06, objptr
 if_b	add	objptr, ##13744
 if_b	wrlong	local06, objptr
 if_b	sub	objptr, ##41956
	add	objptr, ##41956
	rdlong	local12, objptr
	sub	objptr, ##41956
	mov	local06, local12
	mov	arg01, local06
	call	#_hg010b_spin2_setcursorx
LR__0044
'   if key4=79 then						' arrow right
	cmp	local11, #79 wz
 if_ne	jmp	#LR__0045
' return cursor_x
	add	objptr, #60
	rdword	result1, objptr
	add	result1, #2
	add	objptr, ##41896
	wrlong	result1, objptr
'     cx=v.getcursorx()+2 
'     if cx>254  then cx=254 
	sub	objptr, ##41956
	cmps	result1, #255 wc
 if_ae	add	objptr, ##41956
 if_ae	wrlong	#254, objptr
 if_ae	sub	objptr, ##41956
	add	objptr, ##41956
	rdlong	local06, objptr
	sub	objptr, ##41956
	mov	arg01, local06
	call	#_hg010b_spin2_setcursorx
LR__0045
' 
'   if key4=73 then 						' ins
	cmp	local11, #73 wz
 if_ne	jmp	#LR__0048
	add	objptr, ##41948
	rdlong	local06, objptr
	not	local12, local06
	wrlong	local12, objptr
'     if do_insert then v.setcursorshape(14) else  v.setcursorshape(0)
	sub	objptr, ##41948
	cmp	local12, #0 wz
 if_e	jmp	#LR__0046
	mov	local06, #14
	mov	arg01, #14
	call	#_hg010b_spin2_setcursorshape
	jmp	#LR__0047
LR__0046
	mov	local06, #0
	mov	arg01, #0
	call	#_hg010b_spin2_setcursorshape
LR__0047
LR__0048
	mov	local04, #0
	jmp	#LR__0001
LR__0049
	mov	ptra, fp
	call	#popregs_
_edit_ret
	ret

' 
' ''-----------------------------------------------------------------------------------------------------------
' ' 					A housekeepeer.
' ' A dedicated cog that is intended to do things in the background, for example tracking GUI elements
' ' or playing audio tracks in  the background.  In the current version it reads the mouse pointer and
' ' a digital joystick position. It also implements a 200 Hz clock that's ticks are synchronized with vblanks 
' ''-----------------------------------------------------------------------------------------------------------
' 
' sub housekeeper
_housekeeper
' 
' do
LR__0050
'   do: loop until v.vblank=1 : hkcnt+=1 :gethdi
	add	objptr, #73
LR__0051
	rdlong	arg01, objptr
	cmp	arg01, #1 wz
 if_ne	jmp	#LR__0051
	add	objptr, ##41823
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##41896
	call	#_gethdi
	mov	arg01, #5
	call	#__system___waitms
	add	objptr, ##41896
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##41896
	call	#_gethdi
	mov	arg01, #5
	call	#__system___waitms
	add	objptr, ##41896
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##41896
	call	#_gethdi
	mov	arg01, #5
	call	#__system___waitms
	add	objptr, ##41896
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##41896
	call	#_gethdi
	jmp	#LR__0050
_housekeeper_ret
	ret

' 
' '----------------------------------------------------------------------------------------------------------
' ' gethdi is called from the houseekeeper to read HDI related values
' '----------------------------------------------------------------------------------------------------------
' 
' sub gethdi
_gethdi
	mov	COUNT_, #3
	call	#pushregs_
'   x := mouse_xacc
	add	ptr__usbnew_spin2_dat__, ##10405
	rdlong	arg02, ptr__usbnew_spin2_dat__
'   y := mouse_yacc
	add	ptr__usbnew_spin2_dat__, #4
	rdlong	arg01, ptr__usbnew_spin2_dat__
	add	objptr, ##41760
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg01, objptr
'   x := 0
'   y := mouse_zacc
	add	ptr__usbnew_spin2_dat__, #4
	rdlong	result1, ptr__usbnew_spin2_dat__
	add	objptr, #8
	wrlong	result1, objptr
'   return mouse_bstate&7
	add	ptr__usbnew_spin2_dat__, #4
	rdbyte	result1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10417
	and	result1, #7
	sub	objptr, #4
	wrlong	result1, objptr
	sub	objptr, ##41768
	mov	local01, #0
' 
' mousex,mousey=kbm.mouse_xy()
' dummy,mousew=kbm.mouse_scroll()
' mousek=kbm.mouse_buttons()
' i=0:
' for j=0 to 6
	mov	local02, #0
LR__0060
'   if kbm.hidpad_id(j)>0 then
	mov	arg01, local02
	call	#_usbnew_spin2_hidpad_id
	cmps	result1, #1 wc
 if_b	jmp	#LR__0061
	mov	arg01, local02
	mov	arg02, #0
	call	#_usbnew_spin2_hidpad_axis
	mov	local03, result1
	mov	arg01, local02
	mov	arg02, #1
	call	#_usbnew_spin2_hidpad_axis
	add	local03, ##49152
	shr	local03, #15
	mov	arg02, #1
	add	arg02, local03
	add	result1, ##49152
	shr	result1, #15
	mov	arg01, #1
	add	arg01, result1
	mov	local03, local01
	shl	local03, #2
	add	objptr, ##41776
	add	local03, objptr
	shl	arg01, #2
	add	arg02, arg01
	wrlong	arg02, local03
	mov	local03, local01
	shl	local03, #2
	add	objptr, #28
	add	local03, objptr
	mov	arg01, local02
	sub	objptr, ##41804
	call	#_usbnew_spin2_hidpad_buttons
	wrlong	result1, local03
	add	local01, #1
LR__0061
	add	local02, #1
	cmp	local02, #7 wc
 if_b	jmp	#LR__0060
	callpa	#(@LR__0063-@LR__0062)>>2,fcache_load_ptr_
' for j=i to 6 : stick(j)=0 : strig(j)=0 : next j 
LR__0062
	cmp	local01, #7 wc
 if_ae	jmp	#LR__0064
	mov	local03, local01
	shl	local03, #2
	add	objptr, ##41776
	add	local03, objptr
	wrlong	#0, local03
	mov	local03, local01
	shl	local03, #2
	add	objptr, #28
	add	local03, objptr
	wrlong	#0, local03
	add	local01, #1
	sub	objptr, ##41804
	jmp	#LR__0062
LR__0063
LR__0064
	mov	ptra, fp
	call	#popregs_
_gethdi_ret
	ret

' 
' '-------------------------------------------------------------------------------------------------------------
' '---------------------------------- Housekeeper stuff ends here ----------------------------------------------
' '-------------------------------------------------------------------------------------------------------------
' 
' '-------------------------------------------------------------------------------------------------------------
' '
' '                                     LINE INTERPRETER/TOKENIZER
' '
' '-------------------------------------------------------------------------------------------------------------
' 
' 
' sub interpret
_interpret
	mov	COUNT_, #49
	call	#pushregs_
	add	ptra, ##644
	add	objptr, ##28188
	rdlong	arg01, objptr
	sub	objptr, ##28188
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##28192
	wrlong	result1, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	add	objptr, ##13728
	wrlong	#0, objptr
	sub	objptr, ##3912
	wrlong	#0, objptr
	sub	objptr, ##38012
	mov	local01, #0
LR__0070
' 
' ' -------------------------    Pass 1: Split the line to parts, strip unneded spaces, lowercase parts, detect and concatenate strings
' 
' fullline$=trim$(line$): cont=-1  : linenum=0 : lineptr=0 : err=0
' 
' 108 
' for i=0 to 125: separators(i)=0 :next i
	mov	local02, #0
	add	fp, #56
	callpa	#(@LR__0072-@LR__0071)>>2,fcache_load_ptr_
LR__0071
	mov	local03, local02
	shl	local03, #2
	add	local03, fp
	wrlong	#0, local03
	add	local02, #1
	cmps	local02, #126 wc
 if_b	jmp	#LR__0071
LR__0072
	sub	fp, #56
' for i=0 to 125: lparts(i).part$="": lparts(i).token=0: next i
	mov	local02, #0
	add	objptr, ##27148
	callpa	#(@LR__0074-@LR__0073)>>2,fcache_load_ptr_
LR__0073
	mov	local04, local02
	shl	local04, #3
	add	local04, objptr
	mov	arg03, ##@LR__5189
	wrlong	arg03, local04
	mov	local04, local02
	shl	local04, #3
	mov	local05, objptr
	add	local04, objptr
	mov	local06, #0
	add	local04, #4
	wrlong	#0, local04
	add	local02, #1
	cmps	local02, #126 wc
 if_b	jmp	#LR__0073
LR__0074
	add	objptr, ##1040
	rdlong	arg01, objptr
	sub	objptr, ##28188
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##28188
	wrlong	result1, objptr
	mov	local04, ##@LR__5190
	add	objptr, ##13792
	wrlong	local04, objptr
	sub	objptr, ##13792
	rdlong	arg01, objptr
	sub	objptr, ##28188
	mov	local07, arg01
	callpa	#(@LR__0076-@LR__0075)>>2,fcache_load_ptr_
LR__0075
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0075
LR__0076
	sub	local07, arg01 wz
	add	objptr, ##41984
	wrlong	local07, objptr
' if l=0 then goto 101					' empty line,  nothing to do except print "ready"
	sub	objptr, ##41984
 if_e	jmp	#LR__0206
	mov	local08, #0
' d=0							' before we split the line, we have to find colons that are inside a string, 
' for i=1 to len(line$)
	mov	local02, #1
	add	objptr, ##28188
	rdlong	arg01, objptr
	sub	objptr, ##28188
	mov	local07, arg01
	callpa	#(@LR__0078-@LR__0077)>>2,fcache_load_ptr_
LR__0077
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0077
LR__0078
	sub	local07, arg01
	mov	local09, local07
	add	local09, #1
LR__0079
	cmps	local02, local09 wc
 if_ae	jmp	#LR__0081
'   if mid$(line$,i,1)="""" andalso d=0 then 		' they are inside a string if there is an odd number of " before :
	add	objptr, ##28188
	rdlong	arg01, objptr
	sub	objptr, ##28188
	mov	arg02, local02
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__5191
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	cmp	local08, #0 wz
 if_e	mov	local08, #1
 if_e	jmp	#LR__0080
	add	objptr, ##28188
	rdlong	arg01, objptr
	sub	objptr, ##28188
	mov	arg02, local02
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__5192
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	cmp	local08, #1 wz
 if_e	mov	local08, #0
LR__0080
	mov	local04, local02
	shl	local04, #3
	add	objptr, ##27148
	mov	local05, objptr
	add	local04, objptr
	add	local04, #4
	wrlong	local08, local04
	add	local02, #1
	sub	objptr, ##27148
	jmp	#LR__0079
LR__0081
	mov	local02, #1
' i=1: do until (mid$(line$,i,1)=":" andalso lparts(i).token=0)  orelse i>=l : i=i+1 : loop 		' find the first : that is not in a string
LR__0082
	add	objptr, ##28188
	rdlong	arg01, objptr
	sub	objptr, ##28188
	mov	arg02, local02
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	local10, ##@LR__5193
	mov	arg02, local10
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0083
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	mov	local06, objptr
	add	local05, objptr
	add	local05, #4
	rdlong	local11, local05
	sub	local05, #4
	mov	local12, local11 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0084
LR__0083
	add	objptr, ##41984
	rdlong	local13, objptr
	sub	objptr, ##41984
	mov	local14, local13
	cmps	local02, local14 wc
 if_b	add	local02, #1
 if_b	jmp	#LR__0082
LR__0084
' if i<l then let rest$=trim$(right$(line$,len(line$)-i)):line$=trim$(left$(line$,i-1)) else rest$="" 	' and separate the part of the line before the first : from the rest
	add	objptr, ##41984
	rdlong	local04, objptr
	sub	objptr, ##41984
	cmps	local02, local04 wc
 if_ae	jmp	#LR__0087
	add	objptr, ##28188
	rdlong	local06, objptr
	sub	objptr, ##28188
	mov	arg01, local06
	mov	local07, arg01
	callpa	#(@LR__0086-@LR__0085)>>2,fcache_load_ptr_
LR__0085
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0085
LR__0086
	sub	local07, arg01
	mov	local05, local07
	mov	arg02, local05
	sub	arg02, local02
	mov	arg01, local06
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##41988
	wrlong	result1, objptr
	sub	objptr, ##13800
	rdlong	arg01, objptr
	sub	objptr, ##28188
	sub	local02, #1
	mov	arg02, local02
	call	#__system__Left_S
	mov	arg01, result1
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	add	objptr, ##28188
	wrlong	result1, objptr
	sub	objptr, ##28188
	jmp	#LR__0088
LR__0087
	mov	local04, ##@LR__5194
	add	objptr, ##41988
	wrlong	local04, objptr
	sub	objptr, ##41988
LR__0088
' 
' if cont=-1 andalso rest$<>"" then cont=0 : goto 107       	' this is the first and not the last part
	add	objptr, ##28196
	rdlong	local04, objptr
	sub	objptr, ##28196
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0089
	add	objptr, ##41988
	rdlong	arg01, objptr
	sub	objptr, ##41988
	mov	local06, ##@LR__5195
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	objptr, ##28196
 if_ne	wrlong	#0, objptr
 if_ne	sub	objptr, ##28196
 if_ne	jmp	#LR__0093
LR__0089
' if cont=-1 andalso rest$= "" then cont=3 : goto 107		' this is the first AND the last part
	add	objptr, ##28196
	rdlong	local04, objptr
	sub	objptr, ##28196
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0090
	add	objptr, ##41988
	rdlong	arg01, objptr
	sub	objptr, ##41988
	mov	arg02, ##@LR__5196
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##28196
 if_e	wrlong	#3, objptr
 if_e	sub	objptr, ##28196
 if_e	jmp	#LR__0093
LR__0090
' if cont=4  andalso rest$<>"" then cont=1 : goto 107		' this is not the first and not the last part
	add	objptr, ##28196
	rdlong	local04, objptr
	sub	objptr, ##28196
	cmp	local04, #4 wz
 if_ne	jmp	#LR__0091
	add	objptr, ##41988
	rdlong	arg01, objptr
	sub	objptr, ##41988
	mov	arg02, ##@LR__5197
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	objptr, ##28196
 if_ne	wrlong	#1, objptr
 if_ne	sub	objptr, ##28196
 if_ne	jmp	#LR__0093
LR__0091
' if cont=4  andalso rest$= "" then cont=2 : goto 107		' this is the last, and not the first, part
	add	objptr, ##28196
	rdlong	local04, objptr
	sub	objptr, ##28196
	cmp	local04, #4 wz
 if_ne	jmp	#LR__0092
	add	objptr, ##41988
	rdlong	arg01, objptr
	sub	objptr, ##41988
	mov	arg02, ##@LR__5198
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##28196
 if_e	wrlong	#2, objptr
 if_e	sub	objptr, ##28196
LR__0092
LR__0093
	add	fp, #56
	wrlong	#0, fp
	sub	fp, #56
	mov	local02, #0
	mov	local15, #1
' 
' ' 1b: find separators
' 
' 107
' separators(0)=0
' i=0: j=1
' do: 
LR__0094
	add	local02, #1
	add	objptr, ##28188
	rdlong	arg01, objptr
	sub	objptr, ##28188
	mov	arg02, local02
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local16, result1
'   i+=1 : c$=mid$(line$,i,1) : if isseparator(c$) then separators(j)=i: j+=1 
	mov	arg01, local16
	call	#_isseparator
	cmp	result1, #0 wz
 if_e	jmp	#LR__0095
	mov	local03, local15
	shl	local03, #2
	add	fp, #56
	add	local03, fp
	wrlong	local02, local03
	add	local15, #1
	sub	fp, #56
LR__0095
	add	objptr, ##41984
	rdlong	local04, objptr
	sub	objptr, ##41984
	cmps	local02, local04 wcz
 if_be	jmp	#LR__0094
	mov	local03, local15
	shl	local03, #2
	add	fp, #56
	mov	local10, fp
	add	local03, fp
	wrlong	local02, local03
	mov	local17, #0
' for i=0 to j-1 
	mov	local02, #0
	mov	local18, local15
	sub	fp, #56
LR__0096
	cmps	local02, local18 wc
 if_ae	jmp	#LR__0100
	mov	local03, local02
	shl	local03, #2
	add	fp, #56
	add	local03, fp
	rdlong	local05, local03
	add	objptr, ##41996
	wrlong	local05, objptr
	mov	local03, local02
	add	local03, #1
	shl	local03, #2
	mov	local10, fp
	add	local03, fp
	rdlong	local05, local03
	add	objptr, #4
	wrlong	local05, objptr
'   if p1>0 then let p$=mid$(line$,p1,1) : if p$<>"" then lparts(k).part$=p$ : k+=1 
	sub	objptr, #4
	rdlong	local04, objptr
	sub	objptr, ##41996
	cmps	local04, #1 wc
	sub	fp, #56
 if_b	jmp	#LR__0098
	add	objptr, ##28188
	rdlong	arg01, objptr
	add	objptr, ##13808
	rdlong	arg02, objptr
	sub	objptr, ##41996
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local19, result1
	mov	arg02, ##@LR__5199
	mov	arg01, local19
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0097
	mov	local10, local17
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	wrlong	local19, local10
	add	local17, #1
	sub	objptr, ##27148
LR__0097
LR__0098
	add	objptr, ##28188
	rdlong	arg01, objptr
	add	objptr, ##13808
	rdlong	arg02, objptr
	add	arg02, #1
	add	objptr, #4
	rdlong	arg03, objptr
	sub	objptr, #4
	rdlong	local11, objptr
	sub	objptr, ##41996
	mov	local12, local11
	sub	arg03, local12
	sub	arg03, #1
	call	#__system__Mid_S
	mov	local19, result1
'   p$=mid$(line$,p1+1,p2-p1-1) : if p$<>"" then lparts(k).part$=p$ : k+=1 
	mov	arg02, ##@LR__5200
	mov	arg01, local19
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0099
	mov	local10, local17
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	wrlong	local19, local10
	add	local17, #1
	sub	objptr, ##27148
LR__0099
	add	local02, #1
	jmp	#LR__0096
LR__0100
' 
' ' 1d  : first part has to have a line number, if not, add 0 for the immediate line
' 
' if (cont=0 orelse cont=3) andalso (not isdec(lparts(0).part$))  then for i=k to 1 step -1: lparts(i)=lparts(i-1) : next i: lparts(0).part$="0" : k+=1
	add	objptr, ##28196
	rdlong	local04, objptr wz
	sub	objptr, ##28196
 if_ne	add	objptr, ##28196
 if_ne	rdlong	local10, objptr
 if_ne	sub	objptr, ##28196
 if_ne	cmp	local10, #3 wz
 if_ne	jmp	#LR__0103
	add	objptr, ##27148
	rdlong	local11, objptr
	sub	objptr, ##27148
	mov	arg01, local11
	call	#_isdec
	mov	local12, result1
	not	local06, local12
	cmp	local06, #0 wz
 if_e	jmp	#LR__0103
	mov	local02, local17
	add	objptr, ##27148
	callpa	#(@LR__0102-@LR__0101)>>2,fcache_load_ptr_
LR__0101
	mov	local05, local02
	sub	local05, #1
	shl	local05, #3
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local02
	sub	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local02
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local02
	mov	local13, local11
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local02, #1
	cmps	local02, #1 wc
 if_ae	jmp	#LR__0101
LR__0102
	mov	local04, ##@LR__5201
	wrlong	local04, objptr
	sub	objptr, ##27148
	add	local17, #1
LR__0103
	mov	local02, #0
' 
' ' 1e : find strings
' 
' i=0
' do
LR__0104
'   if lparts(i).part$<>"""" then i+=1 : goto 109
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__5202
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0109
	mov	local20, local02
LR__0105
	mov	local10, local02
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	rdlong	local19, local10
	mov	local10, local20
	shl	local10, #3
	add	local10, objptr
	mov	local11, local20
	mov	local14, local11
	shl	local14, #3
	add	local14, objptr
	rdlong	arg01, local14
	mov	local12, local19
	mov	arg02, local12
	sub	objptr, ##27148
	call	#__system___string_concat
	wrlong	result1, local10
	mov	local15, local02
	add	local15, #1
	mov	local21, local17
	add	local21, #1
	callpa	#(@LR__0107-@LR__0106)>>2,fcache_load_ptr_
LR__0106
	cmps	local15, local21 wc
 if_ae	jmp	#LR__0108
	mov	local05, local15
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local15
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local15
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local15
	mov	local13, local11
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	add	local15, #1
	sub	objptr, ##27148
	jmp	#LR__0106
LR__0107
LR__0108
	sub	local17, #1
	mov	arg02, ##@LR__5203
	mov	arg01, local19
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	cmps	local02, local17 wc
 if_c_and_nz	jmp	#LR__0105
'   if p$<>"""" then k+=1:i+=1
	mov	arg02, ##@LR__5204
	mov	arg01, local19
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	add	local17, #1
 if_ne	add	local02, #1
LR__0109
	cmps	local02, local17 wc
 if_b	jmp	#LR__0104
	mov	local02, #0
' 
' ' 1f : concatenate strings if "" detected between
'  
' i=0
' do
LR__0110
'   if right$(lparts(i).part$,1)="""" andalso left$(lparts(i+1).part$,1)=""""  then 
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	mov	local06, objptr
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #1
	sub	objptr, ##27148
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5205
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0116
	mov	local06, local02
	add	local06, #1
	shl	local06, #3
	add	objptr, ##27148
	mov	local12, objptr
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #1
	sub	objptr, ##27148
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5206
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0116
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local14, local02
	shl	local14, #3
	add	local14, objptr
	rdlong	local06, local14
	mov	local13, local02
	add	local13, #1
	shl	local13, #3
	add	local13, objptr
	rdlong	local12, local13
	mov	local22, local02
	add	local22, #1
	mov	local23, local22
	shl	local23, #3
	mov	local24, objptr
	add	local23, objptr
	rdlong	arg01, local23
	sub	objptr, ##27148
	mov	local07, arg01
	callpa	#(@LR__0112-@LR__0111)>>2,fcache_load_ptr_
LR__0111
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0111
LR__0112
	sub	local07, arg01
	mov	local11, local07
	sub	local11, #1
	mov	arg01, local12
	mov	arg02, local11
	call	#__system__Right_S
	mov	local12, result1
	mov	arg01, local06
	mov	arg02, local12
	call	#__system___string_concat
	mov	local06, result1
	wrlong	local06, local10
'     for j=i+1 to k: lparts(j)=lparts(j+1): next j  
	mov	local15, local02
	add	local15, #1
	mov	local25, local17
	add	local25, #1
	callpa	#(@LR__0114-@LR__0113)>>2,fcache_load_ptr_
LR__0113
	cmps	local15, local25 wc
 if_ae	jmp	#LR__0115
	mov	local05, local15
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local15
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local15
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local15
	mov	local13, local11
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	add	local15, #1
	sub	objptr, ##27148
	jmp	#LR__0113
LR__0114
LR__0115
	sub	local02, #1
	sub	local17, #1
LR__0116
	add	local02, #1
	cmps	local02, local17 wc
 if_b	jmp	#LR__0110
	mov	local02, #0
'  
' ' 1g: concatenate >=, <=, ++, --, +=, *=, -=, /=, ^=, <>
'  
' i=0 
' do
LR__0117
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	rdlong	local26, local10
	mov	local10, local02
	add	local10, #1
	shl	local10, #3
	add	local10, objptr
	rdlong	local27, local10
'   s1$=lparts(i).part$ : s2$=lparts(i+1).part$
'   if ((s1$=">" orelse s1$="<" orelse s1$="+" orelse s1$="-" orelse s1$="*" orelse s1$="/" orelse s1$="^") andalso s2$="=") orelse (s1$="+" andalso s2$="+") orelse (s1$="-" andalso s2$="-") orelse (s1$="<" andalso s2$=">") then
	mov	arg02, ##@LR__5207
	mov	arg01, local26
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0118
	mov	arg02, ##@LR__5208
	mov	arg01, local26
	call	#__system___string_cmp
	mov	local03, result1 wz
 if_e	jmp	#LR__0118
	mov	local06, ##@LR__5209
	mov	arg01, local26
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0118
	mov	local12, ##@LR__5210
	mov	arg01, local26
	mov	arg02, local12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0118
	mov	local11, ##@LR__5211
	mov	local12, local11
	mov	arg01, local26
	mov	arg02, local12
	call	#__system___string_cmp
	mov	local06, result1 wz
 if_e	jmp	#LR__0118
	mov	local11, ##@LR__5212
	mov	arg01, local26
	mov	arg02, local11
	call	#__system___string_cmp
	mov	local12, result1 wz
 if_e	jmp	#LR__0118
	mov	local14, ##@LR__5213
	mov	arg01, local26
	mov	arg02, local14
	call	#__system___string_cmp
	mov	local11, result1 wz
 if_ne	jmp	#LR__0119
LR__0118
	mov	local28, ##@LR__5214
	mov	local13, local28
	mov	arg01, local27
	mov	arg02, local13
	call	#__system___string_cmp
	mov	local14, result1 wz
 if_e	jmp	#LR__0122
LR__0119
	mov	local28, ##@LR__5215
	mov	arg01, local26
	mov	arg02, local28
	call	#__system___string_cmp
	mov	local13, result1 wz
 if_ne	jmp	#LR__0120
	mov	local23, ##@LR__5216
	mov	local22, local23
	mov	arg01, local27
	mov	arg02, local22
	call	#__system___string_cmp
	mov	local28, result1 wz
 if_e	jmp	#LR__0122
LR__0120
	mov	local23, ##@LR__5217
	mov	arg01, local26
	mov	arg02, local23
	call	#__system___string_cmp
	mov	local22, result1 wz
 if_ne	jmp	#LR__0121
	mov	local29, ##@LR__5218
	mov	local24, local29
	mov	arg01, local27
	mov	arg02, local24
	call	#__system___string_cmp
	mov	local23, result1 wz
 if_e	jmp	#LR__0122
LR__0121
	mov	local30, ##@LR__5219
	mov	local29, local30
	mov	arg01, local26
	mov	arg02, local29
	call	#__system___string_cmp
	mov	local24, result1 wz
 if_ne	jmp	#LR__0126
	mov	local31, ##@LR__5220
	mov	local30, local31
	mov	arg01, local27
	mov	arg02, local30
	call	#__system___string_cmp
	mov	local29, result1 wz
 if_ne	jmp	#LR__0126
LR__0122
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local12, local27
	mov	arg01, local26
	mov	arg02, local12
	sub	objptr, ##27148
	call	#__system___string_concat
	wrlong	result1, local10
'     lparts(i).part$=s1$+s2$
'     for j=i+1 to k : lparts(j)=lparts(j+1) : next j
	mov	local15, local02
	add	local15, #1
	mov	local32, local17
	add	local32, #1
	callpa	#(@LR__0124-@LR__0123)>>2,fcache_load_ptr_
LR__0123
	cmps	local15, local32 wc
 if_ae	jmp	#LR__0125
	mov	local05, local15
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local15
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local15
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local15
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	mov	local28, objptr
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local13, #4
	add	local15, #1
	sub	objptr, ##27148
	jmp	#LR__0123
LR__0124
LR__0125
	sub	local02, #1
	sub	local17, #1
LR__0126
	add	local02, #1
	cmps	local02, local17 wc
 if_b	jmp	#LR__0117
'  
' ' 1h : now remove parts that are spaces
' 
' for i=0 to k: lparts(i).part$=trim$(lparts(i).part$): next i
	mov	local02, #0
	mov	local33, local17
	add	local33, #1
LR__0127
	cmps	local02, local33 wc
 if_ae	jmp	#LR__0128
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local12, local02
	mov	local11, local12
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##27148
	call	#__system__RTrim_S
	mov	arg01, result1
	call	#__system__LTrim_S
	wrlong	result1, local10
	add	local02, #1
	jmp	#LR__0127
LR__0128
	mov	local02, #0
	callpa	#(@LR__0135-@LR__0129)>>2,fcache_load_ptr_
' i=0
' do 
LR__0129
'   if len(lparts(i).part$)=0 then 
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##27148
	mov	local07, arg01
LR__0130
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0130
	sub	local07, arg01 wz
 if_ne	jmp	#LR__0134
'     if i=k-1 then k-=1  :  exit
	mov	local04, local17
	sub	local04, #1
	cmp	local02, local04 wz
 if_e	sub	local17, #1
 if_e	jmp	#LR__0136
'     if i<k-1 then 
	mov	local04, local17
	sub	local04, #1
	cmps	local02, local04 wc
 if_ae	jmp	#LR__0133
'       for j=i to k-2 : lparts(j)=lparts(j+1): next j: k-=1  
	mov	local15, local02
	mov	local34, local17
	sub	local34, #1
LR__0131
	cmps	local15, local34 wc
 if_ae	jmp	#LR__0132
	mov	local05, local15
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local15
	add	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local10, local15
	mov	local06, local10
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	wrlong	local04, local06
	mov	local11, local15
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	mov	local28, objptr
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local13, #4
	add	local15, #1
	sub	objptr, ##27148
	jmp	#LR__0131
LR__0132
	sub	local17, #1
'       if i>0 then i-=1 
	cmps	local02, #1 wc
 if_ae	sub	local02, #1
LR__0133
LR__0134
	add	local02, #1
	mov	local04, local17
	sub	local04, #1
	cmps	local02, local04 wcz
 if_be	jmp	#LR__0129
LR__0135
LR__0136
' 
' ' 1i: lowercase all that is not a string
' 
' for j=0 to k-1
	mov	local15, #0
	mov	local35, local17
LR__0137
	cmps	local15, local35 wc
 if_ae	jmp	#LR__0140
'   if left$(lparts(j).part$,1)<>"""" orelse right$(lparts(j).part$,1)<>"""" then lparts(j).part$=lcase$(lparts(j).part$) 
	mov	local05, local15
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #1
	sub	objptr, ##27148
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5221
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0138
	mov	local06, local15
	shl	local06, #3
	add	objptr, ##27148
	mov	local12, objptr
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #1
	sub	objptr, ##27148
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5222
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0139
LR__0138
	mov	local10, local15
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local15
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##27148
	call	#__system__LCase_S
	wrlong	result1, local10
LR__0139
	add	local15, #1
	jmp	#LR__0137
LR__0140
' 
' '-------------------------------------------------------- Pass 2: Tokenize the line
' 
' for i=0 to k: lparts(i).token=-1: next i					' initialize all tokens to -1=invalid
	mov	local02, #0
	mov	local36, local17
	add	local36, #1
	callpa	#(@LR__0142-@LR__0141)>>2,fcache_load_ptr_
LR__0141
	cmps	local02, local36 wc
 if_ae	jmp	#LR__0143
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	##-1, local10
	add	local02, #1
	sub	objptr, ##27148
	jmp	#LR__0141
LR__0142
LR__0143
' 
' if isdec(lparts(0).part$) then addptr=1 else addptr=0				' check if the abbreviated command are on the line start, or after linenum, 'then' or 'else'
	add	objptr, ##27148
	rdlong	arg01, objptr
	sub	objptr, ##27148
	call	#_isdec
	cmp	result1, #0 wz
 if_ne	mov	local37, #1
 if_e	mov	local37, #0
' if lparts(0).part$="else" then addptr=1 					' else is always the first
	add	objptr, ##27148
	rdlong	arg01, objptr
	sub	objptr, ##27148
	mov	arg02, ##@LR__5223
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local37, #1
	mov	local02, #0
' i=0 : do 
LR__0144
'   if lparts(i).part$="then" then exit loop 					' try to find 'then'
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__5224
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0145
	add	local02, #1
	cmps	local02, local17 wcz
 if_be	jmp	#LR__0144
LR__0145
' if i<k then addptr=i+1	 							' then found
	cmps	local02, local17 wc
 if_b	mov	local37, local02
 if_b	add	local37, #1
	add	objptr, ##27148
	mov	local06, local37
	shl	local06, #3
	mov	local12, objptr
	add	local06, objptr
	rdlong	arg02, local06
	mov	arg03, ##@LR__5225
	mov	arg01, #1
	sub	objptr, ##27148
	call	#__system__Instr
	mov	local38, result1
' lp$=lparts(addptr).part$ 
' dot=instr(1,lparts(addptr).part$,".")						' find a dot	
' if dot>0 andalso dot<len(lparts(addptr).part$) then 				' split the part
	cmps	local38, #1 wc
 if_b	jmp	#LR__0152
	mov	local05, local37
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##27148
	mov	local07, arg01
	callpa	#(@LR__0147-@LR__0146)>>2,fcache_load_ptr_
LR__0146
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0146
LR__0147
	sub	local07, arg01
	cmps	local38, local07 wc
 if_ae	jmp	#LR__0152
	add	local17, #1
'   k+=1
'   for i=k to addptr+1 step -1 : lparts(i)=lparts(i-1) : next i
	mov	local02, local17
	mov	local39, local37
	add	local39, #1
	add	objptr, ##27148
	callpa	#(@LR__0149-@LR__0148)>>2,fcache_load_ptr_
LR__0148
	mov	local05, local02
	sub	local05, #1
	shl	local05, #3
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local02
	sub	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local02
	shl	local06, #3
	add	local06, objptr
	wrlong	local04, local06
	mov	local13, local02
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local02, #1
	cmps	local02, local39 wc
 if_ae	jmp	#LR__0148
LR__0149
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	local10, objptr
	mov	local14, local37
	shl	local14, #3
	add	local14, objptr
	rdlong	local06, local14
	mov	local28, local37
	mov	local22, local28
	shl	local22, #3
	mov	local23, objptr
	add	local22, objptr
	rdlong	arg01, local22
	sub	objptr, ##27148
	mov	local07, arg01
	callpa	#(@LR__0151-@LR__0150)>>2,fcache_load_ptr_
LR__0150
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0150
LR__0151
	sub	local07, arg01
	mov	arg02, local07
	sub	arg02, local38
	mov	arg01, local06
	call	#__system__Right_S
	wrlong	result1, local10
	mov	local10, local37
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local37
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	mov	local12, local38
	mov	arg02, local12
	sub	objptr, ##27148
	call	#__system__Left_S
	wrlong	result1, local10
LR__0152
' if left$(lparts(addptr).part$,1)="?" andalso len(lparts(addptr).part$)>1 then ' ? is abbreviation of print, but it has no dots, so it has to be treated here
	mov	local05, local37
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #1
	sub	objptr, ##27148
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5226
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0159
	mov	local06, local37
	shl	local06, #3
	add	objptr, ##27148
	mov	local12, objptr
	add	local06, objptr
	rdlong	arg01, local06
	sub	objptr, ##27148
	mov	local07, arg01
	callpa	#(@LR__0154-@LR__0153)>>2,fcache_load_ptr_
LR__0153
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0153
LR__0154
	sub	local07, arg01
	cmps	local07, #2 wc
 if_b	jmp	#LR__0159
	add	local17, #1
'   k+=1
'   for i=k to addptr+1 step -1 : lparts(i)=lparts(i-1) : next i
	mov	local02, local17
	mov	local40, local37
	add	local40, #1
	add	objptr, ##27148
	callpa	#(@LR__0156-@LR__0155)>>2,fcache_load_ptr_
LR__0155
	mov	local05, local02
	sub	local05, #1
	shl	local05, #3
	add	local05, objptr
	rdlong	local04, local05
	mov	local06, local02
	sub	local06, #1
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local06, local02
	shl	local06, #3
	add	local06, objptr
	wrlong	local04, local06
	mov	local13, local02
	shl	local13, #3
	add	local13, objptr
	add	local13, #4
	wrlong	local03, local13
	sub	local02, #1
	cmps	local02, local40 wc
 if_ae	jmp	#LR__0155
LR__0156
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	local10, objptr
	mov	local14, local37
	shl	local14, #3
	add	local14, objptr
	rdlong	local06, local14
	mov	local13, local37
	mov	local28, local13
	mov	local22, local28
	shl	local22, #3
	mov	local23, objptr
	add	local22, objptr
	rdlong	arg01, local22
	sub	objptr, ##27148
	mov	local07, arg01
	callpa	#(@LR__0158-@LR__0157)>>2,fcache_load_ptr_
LR__0157
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0157
LR__0158
	sub	local07, arg01
	mov	local14, local07
	mov	local11, local14
	sub	local11, #1
	mov	local12, local11
	mov	arg01, local06
	mov	arg02, local12
	call	#__system__Right_S
	wrlong	result1, local10
	mov	local10, local37
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local06, ##@LR__5227
	wrlong	local06, local10
	sub	objptr, ##27148
LR__0159
	mov	local10, local37
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	rdlong	local41, local10
' 
' lp$=lparts(addptr).part$ 
' 
' ' process mouse/cursor/click on/off
' 
' if (lp$="mouse" orelse lp$="cursor" orelse lp$="click") then 
	mov	arg02, ##@LR__5228
	mov	arg01, local41
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0160
	mov	arg02, ##@LR__5229
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0160
	mov	arg02, ##@LR__5230
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0163
LR__0160
'   if lparts(addptr+1).part$="on" then lparts(addptr+1).part$="1" :lparts(2).token=token_decimal
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__5231
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0161
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local06, ##@LR__5232
	wrlong	local06, local10
	add	objptr, #20
	wrlong	##512, objptr
	sub	objptr, ##27168
LR__0161
'   if lparts(addptr+1).part$="off" then lparts(addptr+1).part$="0" :lparts(2).token=token_decimal
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__5233
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0162
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local06, ##@LR__5234
	wrlong	local06, local10
	add	objptr, #20
	wrlong	##512, objptr
	sub	objptr, ##27168
LR__0162
LR__0163
' 		
' ' process text constant for 'mode' - TO DO all predefined constants should have # before				
' 
' if (lp$="mode" orelse lp$="m.") then 
	mov	arg02, ##@LR__5235
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0164
	mov	arg02, ##@LR__5236
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0170
LR__0164
'   if lparts(addptr+1).part$="atari" then lparts(addptr+1).part$="0"       
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__5237
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0165
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local06, ##@LR__5238
	wrlong	local06, local10
	sub	objptr, ##27148
LR__0165
'   if lparts(addptr+1).part$="pc_amber" then lparts(addptr+1).part$="1"  
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__5239
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0166
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local06, ##@LR__5240
	wrlong	local06, local10
	sub	objptr, ##27148
LR__0166
'   if lparts(addptr+1).part$="pc_green" then lparts(addptr+1).part$="2"  
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__5241
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0167
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local06, ##@LR__5242
	wrlong	local06, local10
	sub	objptr, ##27148
LR__0167
'   if lparts(addptr+1).part$="pc_white" then lparts(addptr+1).part$="3"  
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__5243
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0168
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local06, ##@LR__5244
	wrlong	local06, local10
	sub	objptr, ##27148
LR__0168
'   if lparts(addptr+1).part$="st" then lparts(addptr+1).part$="4"  
	mov	local05, local37
	add	local05, #1
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, ##@LR__5245
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0169
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local06, ##@LR__5246
	wrlong	local06, local10
	sub	objptr, ##27148
LR__0169
LR__0170
' 
' ' find part types 
' 
' for i=0 to k-1
	mov	local02, #0
	mov	local42, local17
LR__0171
	cmps	local02, local42 wc
 if_ae	jmp	#LR__0183
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##27148
	call	#_isseparator
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isseparator(lparts(i).part$)	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
	sub	objptr, ##27148
 if_ae	jmp	#LR__0182
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##27148
	call	#_isoperator
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isoperator(lparts(i).part$)	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
	sub	objptr, ##27148
 if_ae	jmp	#LR__0182
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##27148
' 
' select case s
	mov	arg02, ##@LR__5331
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isassign(lparts(i).part$) 	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
	sub	objptr, ##27148
 if_ae	jmp	#LR__0182
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##27148
	call	#_iscommand
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=iscommand(lparts(i).part$)	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
	sub	objptr, ##27148
 if_ae	jmp	#LR__0182
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	mov	local13, local14
	shl	local13, #3
	mov	local28, objptr
	add	local13, objptr
	rdlong	arg01, local13
	sub	objptr, ##27148
	call	#_isfunction
	getbyte	result1, result1, #0
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isfunction(lparts(i).part$)	: if lparts(i).token>0 then goto 102
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
	sub	objptr, ##27148
 if_ae	jmp	#LR__0182
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##27148
	call	#_isnotename
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isnotename(lparts(i).part$) 
' if lparts(i).token>0 then 
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	rdlong	local06, local10
	cmps	local06, #1 wc
	sub	objptr, ##27148
 if_b	jmp	#LR__0172
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	add	local05, #4
	rdlong	local12, local05
	mov	arg01, local12
	sub	objptr, ##27148
	call	#_getnoteval
	mov	local43, result1
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	arg01, local43
	sub	objptr, ##27148
	call	#__system__str_S
	wrlong	result1, local10
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	##514, local10
	sub	objptr, ##27148
	jmp	#LR__0182
LR__0172
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local14, local02
	shl	local14, #3
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##27148
	call	#_ischannel
	add	local10, #4
	wrlong	result1, local10
' 
' ' if it is #channel, make it a number from 0 to 9 while setting a token_channel
' 
' lparts(i).token=ischannel(lparts(i).part$) : if lparts(i).token>0 then lparts(i).part$=right$(lparts(i).part$,1) : lparts(i).token=token_channel : goto 102
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	rdlong	local06, local10
	cmps	local06, #1 wc
	sub	objptr, ##27148
 if_b	jmp	#LR__0173
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	mov	local12, #1
	mov	arg02, #1
	sub	objptr, ##27148
	call	#__system__Right_S
	wrlong	result1, local10
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	#44, local10
	sub	objptr, ##27148
	jmp	#LR__0182
LR__0173
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local11, local02
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	sub	objptr, ##27148
	call	#_isconstant
	add	local10, #4
	wrlong	result1, local10
' lparts(i).token=isconstant(lparts(i).part$) : if lparts(i).token>0 then lparts(i).part$=str$(lparts(i).token) : lparts(i).token=token_integer : goto 102
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	rdlong	local12, local10
	cmps	local12, #1 wc
	sub	objptr, ##27148
 if_b	jmp	#LR__0174
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local12, local02
	mov	local11, local12
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	add	local14, #4
	rdlong	arg01, local14
	sub	local14, #4
	sub	objptr, ##27148
	abs	arg01, arg01 wc
 if_b	decod	local44, #31
 if_ae	mov	local44, #0
	call	#__system___float_fromuns
	xor	result1, local44
	mov	arg01, result1
	call	#__system__str_S
	wrlong	result1, local10
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	##513, local10
	sub	objptr, ##27148
	jmp	#LR__0182
LR__0174
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##27148
	call	#_isnum
	mov	local45, result1
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##27148
	call	#_isint
	mov	local46, result1
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##27148
	call	#_isdec
	mov	local47, result1
' 
' b1=isnum(lparts(i).part$) : b2=isint(lparts(i).part$) : b3=isdec(lparts(i).part$)
' if b1 andalso b2 andalso b3 then lparts(i).token=token_decimal 			: goto 102 	' pure decimal for line num
	cmp	local45, #0 wz
 if_ne	cmp	local46, #0 wz
 if_ne	cmp	local47, #0 wz
 if_e	jmp	#LR__0175
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	##512, local10
	sub	objptr, ##27148
	jmp	#LR__0182
LR__0175
' if b1 andalso b2 andalso (not b3) then lparts(i).token=token_integer 		: goto 102 	' integer
	cmp	local45, #0 wz
 if_ne	cmp	local46, #0 wz
 if_ne	not	local04, local47
 if_ne	cmp	local04, #0 wz
 if_e	jmp	#LR__0176
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	##513, local10
	sub	objptr, ##27148
	jmp	#LR__0182
LR__0176
' if b1 andalso (not b2) andalso (not b3) then lparts(i).token=token_float 	: goto 102 	' float
	cmp	local45, #0 wz
 if_ne	not	local04, local46
 if_ne	cmp	local04, #0 wz
 if_ne	not	local03, local47
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__0177
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	##514, local10
	sub	objptr, ##27148
	jmp	#LR__0182
LR__0177
' 
' if isstring(lparts(i).part$) then 
	mov	local05, local02
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##27148
	call	#_isstring
	cmp	result1, #0 wz
 if_e	jmp	#LR__0180
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	##515, local10
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	add	local10, objptr
	mov	local14, local02
	shl	local14, #3
	add	local14, objptr
	rdlong	local06, local14
	mov	local12, #2
	mov	local22, local02
	mov	local23, local22
	shl	local23, #3
	mov	local24, objptr
	add	local23, objptr
	rdlong	arg01, local23
	sub	objptr, ##27148
	mov	local07, arg01
	callpa	#(@LR__0179-@LR__0178)>>2,fcache_load_ptr_
LR__0178
	rdbyte	result1, local07 wz
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0178
LR__0179
	sub	local07, arg01
	mov	local13, local07
	mov	local14, local13
	sub	local14, #2
	mov	local11, local14
	mov	arg01, local06
	mov	arg02, local12
	mov	arg03, local11
	call	#__system__Mid_S
	wrlong	result1, local10
	jmp	#LR__0182
LR__0180
' if isname(lparts(i).part$) then lparts(i).token=token_name : goto 102						' name
	mov	local03, local02
	mov	local05, local03
	shl	local05, #3
	add	objptr, ##27148
	add	local05, objptr
	rdlong	arg01, local05
	sub	objptr, ##27148
	call	#_isname
	mov	local04, result1 wz
 if_e	jmp	#LR__0181
	mov	local04, local02
	mov	local03, local04
	mov	local10, local03
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	##516, local10
	sub	objptr, ##27148
LR__0181
LR__0182
	add	local02, #1
	jmp	#LR__0171
LR__0183
	mov	local10, local17
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	#510, local10
	mov	local10, local17
	shl	local10, #3
	add	local10, objptr
	mov	local06, ##@LR__5247
	wrlong	local06, local10
	add	objptr, ##8276
	wrlong	local17, objptr
	sub	objptr, ##35424
' 
' lparts(k).token=token_end : lparts(k).part$="": tokennum=k
' 
' ' process the case when simple load or save is called without "". This cannot be done earlier, as tokens has to be known                                    					 
'  
' if (lp$="load" orelse lp$="save" orelse lp$="brun" orelse lp$="run" orelse lp$="lo." orelse lp$="s." orelse lp$="br." orelse lp$="enter" orelse lp$="e.") andalso lparts(addptr+1).token=token_name then lparts(addptr+1).token=token_string
	mov	arg02, ##@LR__5248
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0184
	mov	arg02, ##@LR__5249
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0184
	mov	local06, ##@LR__5250
	mov	arg01, local41
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0184
	mov	local12, ##@LR__5251
	mov	local06, local12
	mov	arg01, local41
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0184
	mov	local11, ##@LR__5252
	mov	local12, local11
	mov	arg01, local41
	mov	arg02, local12
	call	#__system___string_cmp
	mov	local06, result1 wz
 if_e	jmp	#LR__0184
	mov	local14, ##@LR__5253
	mov	local11, local14
	mov	arg01, local41
	mov	arg02, local11
	call	#__system___string_cmp
	mov	local12, result1 wz
 if_e	jmp	#LR__0184
	mov	local13, ##@LR__5254
	mov	local14, local13
	mov	arg01, local41
	mov	arg02, local14
	call	#__system___string_cmp
	mov	local11, result1 wz
 if_e	jmp	#LR__0184
	mov	local13, ##@LR__5255
	mov	arg01, local41
	mov	arg02, local13
	call	#__system___string_cmp
	mov	local14, result1 wz
 if_e	jmp	#LR__0184
	mov	local22, ##@LR__5256
	mov	local28, local22
	mov	arg01, local41
	mov	arg02, local28
	call	#__system___string_cmp
	mov	local13, result1 wz
 if_ne	jmp	#LR__0185
LR__0184
	mov	local28, local37
	add	local28, #1
	mov	local22, local28
	mov	local23, local22
	shl	local23, #3
	add	objptr, ##27148
	mov	local24, objptr
	add	local23, objptr
	add	local23, #4
	rdlong	local30, local23
	sub	local23, #4
	mov	local29, local30
	cmp	local29, ##516 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0185
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
	sub	objptr, ##27148
LR__0185
' if (lp$="delete" orelse lp$="mkdir") andalso lparts(addptr+1).token=token_name then lparts(addptr+1).token=token_string
	mov	arg02, ##@LR__5257
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0186
	mov	local05, ##@LR__5258
	mov	arg01, local41
	mov	arg02, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0187
LR__0186
	mov	local05, local37
	add	local05, #1
	mov	local06, local05
	shl	local06, #3
	add	objptr, ##27148
	mov	local12, objptr
	add	local06, objptr
	add	local06, #4
	rdlong	local14, local06
	sub	local06, #4
	mov	local11, local14
	cmp	local11, ##516 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0187
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	mov	local05, objptr
	add	local10, objptr
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
	sub	objptr, ##27148
LR__0187
' 
' ' cd needs special treatment..
' 
' if lp$="cd" then lparts(addptr+1).token=token_string
	mov	arg02, ##@LR__5259
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0188
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	mov	local05, objptr
	add	local10, objptr
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
	sub	objptr, ##27148
LR__0188
' if lp$="cd." andalso lparts(addptr+1).part$="." then lparts(addptr+1).token=token_string : lparts(addptr+1).part$=".." : lparts(addptr).token=token_cd
	mov	arg02, ##@LR__5260
	mov	arg01, local41
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0189
	mov	local06, local37
	add	local06, #1
	shl	local06, #3
	add	objptr, ##27148
	mov	local12, objptr
	add	local06, objptr
	rdlong	arg01, local06
	mov	local05, ##@LR__5261
	mov	arg02, local05
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0189
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	add	local10, #4
	wrlong	##515, local10
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	local10, objptr
	mov	local06, ##@LR__5262
	wrlong	local06, local10
	mov	local10, local37
	shl	local10, #3
	mov	local05, objptr
	add	local10, objptr
	mov	local06, #195
	add	local10, #4
	wrlong	#195, local10
	sub	objptr, ##27148
LR__0189
' if lp$="cd" andalso lparts(addptr+1).part$="/" then lparts(addptr+1).token=token_string : for i=(addptr+2) to k: lparts(addptr+1).part$+=lparts(i).part$ : next i
	mov	local10, ##@LR__5263
	mov	arg01, local41
	mov	arg02, local10
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0192
	mov	local06, local37
	add	local06, #1
	shl	local06, #3
	add	objptr, ##27148
	mov	local12, objptr
	add	local06, objptr
	rdlong	arg01, local06
	mov	local05, ##@LR__5264
	mov	local10, local05
	mov	arg02, local10
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0192
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	add	objptr, ##27148
	mov	local05, objptr
	add	local10, objptr
	mov	local06, ##515
	add	local10, #4
	wrlong	##515, local10
	sub	local10, #4
	mov	local02, local37
	add	local02, #2
	mov	local48, local17
	add	local48, #1
	sub	objptr, ##27148
LR__0190
	cmps	local02, local48 wc
 if_ae	jmp	#LR__0191
	mov	local10, local02
	shl	local10, #3
	add	objptr, ##27148
	add	local10, objptr
	rdlong	local49, local10
	mov	local10, local37
	add	local10, #1
	shl	local10, #3
	mov	local05, objptr
	add	local10, objptr
	mov	local11, local37
	add	local11, #1
	mov	local14, local11
	shl	local14, #3
	mov	local13, objptr
	add	local14, objptr
	rdlong	arg01, local14
	mov	local12, local49
	mov	arg02, local12
	sub	objptr, ##27148
	call	#__system___string_concat
	mov	local06, result1
	wrlong	local06, local10
	add	local02, #1
	jmp	#LR__0190
LR__0191
LR__0192
' 
' ' determine a type of the line and compile it
' 
' if isdec(lparts(0).part$) then linenum=val%(lparts(0).part$)
	add	objptr, ##27148
	rdlong	arg01, objptr
	sub	objptr, ##27148
	call	#_isdec
	cmp	result1, #0 wz
 if_e	jmp	#LR__0193
	add	objptr, ##27148
	rdlong	arg01, objptr
	sub	objptr, ##27148
	mov	arg02, #0
	call	#__system____builtin_atoi
	add	objptr, ##41924
	wrlong	result1, objptr
	sub	objptr, ##41924
LR__0193
' if linenum>0 andalso k=1 andalso cont=3 then deleteline(linenum) : goto 104   ' this was an empty numbered line, delete it
	add	objptr, ##41924
	rdlong	local04, objptr
	sub	objptr, ##41924
	cmp	local04, #1 wc
 if_b	jmp	#LR__0194
	cmp	local17, #1 wz
 if_e	add	objptr, ##28196
 if_e	rdlong	local05, objptr
 if_e	sub	objptr, ##28196
 if_e	mov	local10, local05
 if_e	cmp	local10, #3 wz
 if_ne	jmp	#LR__0194
	add	objptr, ##41924
	rdlong	arg01, objptr
	sub	objptr, ##41924
	call	#_deleteline
	jmp	#LR__0205
LR__0194
' 
' if (cont=0 orelse cont=3) andalso lparts(2).token<>token_eq  then  		' first part, commans
	add	objptr, ##28196
	rdlong	local04, objptr wz
	sub	objptr, ##28196
 if_e	jmp	#LR__0195
	add	objptr, ##28196
	rdlong	local05, objptr
	sub	objptr, ##28196
	mov	local10, local05
	cmp	local10, #3 wz
 if_ne	jmp	#LR__0197
LR__0195
	add	objptr, ##27168
	rdlong	local12, objptr
	sub	objptr, ##27168
	cmp	local12, #27 wz
 if_e	jmp	#LR__0197
	add	objptr, ##41924
	rdlong	arg01, objptr
	sub	objptr, ##13728
	rdlong	arg03, objptr
	sub	objptr, ##28196
	mov	arg02, #0
	call	#_compile
	mov	local01, result1 wz
'   err=compile(linenum,0,cont) 
'   if err<>0 then printerror(err,linenum): goto 101
 if_e	jmp	#LR__0196
	add	objptr, ##41924
	rdlong	arg02, objptr
	sub	objptr, ##41924
	mov	arg01, local01
	call	#_printerror
	jmp	#LR__0206
LR__0196
'   if rest$<>"" then  line$=rest$ : cont=4 : goto 108 else goto 104
	add	objptr, ##41988
	rdlong	arg01, objptr
	sub	objptr, ##41988
	mov	arg02, ##@LR__5265
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0205
	add	objptr, ##41988
	rdlong	local04, objptr
	sub	objptr, ##13800
	wrlong	local04, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##28196
	jmp	#LR__0070
LR__0197
'       							
' if (cont=1 orelse cont=2) andalso lparts(1).token<>token_eq  then 		' not a first part, command
	add	objptr, ##28196
	rdlong	local04, objptr
	sub	objptr, ##28196
	cmp	local04, #1 wz
 if_ne	add	objptr, ##28196
 if_ne	rdlong	local10, objptr
 if_ne	sub	objptr, ##28196
 if_ne	cmp	local10, #2 wz
 if_ne	jmp	#LR__0199
	add	objptr, ##27160
	rdlong	local12, objptr
	sub	objptr, ##27160
	cmp	local12, #27 wz
 if_e	jmp	#LR__0199
	add	objptr, ##41924
	rdlong	arg01, objptr
	sub	objptr, ##13728
	rdlong	arg03, objptr
	sub	objptr, ##28196
	mov	arg02, #0
	call	#_compile
	mov	local01, result1 wz
'   err=compile(linenum,0,cont) 
'   if err<>0 then printerror(err,linenum): goto 101
 if_e	jmp	#LR__0198
	add	objptr, ##41924
	rdlong	arg02, objptr
	sub	objptr, ##41924
	mov	arg01, local01
	call	#_printerror
	jmp	#LR__0206
LR__0198
'   if rest$<>"" then line$=rest$: cont=4 : goto 108 else goto 104  	
	add	objptr, ##41988
	rdlong	arg01, objptr
	sub	objptr, ##41988
	mov	arg02, ##@LR__5266
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0205
	add	objptr, ##41988
	rdlong	local04, objptr
	sub	objptr, ##13800
	wrlong	local04, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##28196
	jmp	#LR__0070
LR__0199
' 							 
' if (cont=0 orelse cont=3) andalso lparts(2).token=token_eq then  		' first part, assign
	add	objptr, ##28196
	rdlong	local04, objptr wz
	sub	objptr, ##28196
 if_ne	add	objptr, ##28196
 if_ne	rdlong	local10, objptr
 if_ne	sub	objptr, ##28196
 if_ne	cmp	local10, #3 wz
 if_e	add	objptr, ##27168
 if_e	rdlong	local12, objptr
 if_e	sub	objptr, ##27168
 if_e	cmp	local12, #27 wz
 if_ne	jmp	#LR__0201
	add	objptr, ##41924
	rdlong	arg01, objptr
	sub	objptr, ##13728
	rdlong	arg03, objptr
	sub	objptr, ##28196
	mov	arg02, #0
	call	#_compile_assign
	mov	local01, result1 wz
'   err=compile_assign(linenum,0,cont)
'   if err<>0 then printerror(err,linenum): goto 101
 if_e	jmp	#LR__0200
	add	objptr, ##41924
	rdlong	arg02, objptr
	sub	objptr, ##41924
	mov	arg01, local01
	call	#_printerror
	jmp	#LR__0206
LR__0200
'   if rest$<>"" then line$=rest$: cont=4 : goto 108 else goto 104
	add	objptr, ##41988
	rdlong	arg01, objptr
	sub	objptr, ##41988
	mov	arg02, ##@LR__5267
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0205
	add	objptr, ##41988
	rdlong	local04, objptr
	sub	objptr, ##13800
	wrlong	local04, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##28196
	jmp	#LR__0070
LR__0201
'     							 
' if (cont=1 orelse cont=2) andalso lparts(1).token=token_eq then 		' not a first part, assign
	add	objptr, ##28196
	rdlong	local04, objptr
	sub	objptr, ##28196
	cmp	local04, #1 wz
 if_ne	add	objptr, ##28196
 if_ne	rdlong	local10, objptr
 if_ne	sub	objptr, ##28196
 if_ne	cmp	local10, #2 wz
 if_e	add	objptr, ##27160
 if_e	rdlong	local12, objptr
 if_e	sub	objptr, ##27160
 if_e	cmp	local12, #27 wz
 if_ne	jmp	#LR__0204
	add	objptr, ##41924
	rdlong	arg01, objptr
	sub	objptr, ##13728
	rdlong	arg03, objptr
	sub	objptr, ##28196
	mov	arg02, #0
	call	#_compile_assign
	mov	local01, result1 wz
'   err=compile_assign(linenum,0,cont) 
'   if err<>0 then printerror(err,linenum): goto 101
 if_e	jmp	#LR__0202
	add	objptr, ##41924
	rdlong	arg02, objptr
	sub	objptr, ##41924
	mov	arg01, local01
	call	#_printerror
	jmp	#LR__0206
LR__0202
'   if rest$<>"" then line$=rest$: cont=4 : goto 108 else goto 104  								 
	add	objptr, ##41988
	rdlong	arg01, objptr
	sub	objptr, ##41988
	mov	arg02, ##@LR__5268
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	jmp	#LR__0203
	add	objptr, ##41988
	rdlong	local04, objptr
	sub	objptr, ##13800
	wrlong	local04, objptr
	add	objptr, #8
	wrlong	#4, objptr
	sub	objptr, ##28196
	jmp	#LR__0070
LR__0203
LR__0204
LR__0205
' 
' 104 if linenum=0 then 								' line 0 is for immediate execution
	add	objptr, ##41924
	rdlong	local04, objptr wz
	sub	objptr, ##41924
 if_ne	jmp	#LR__0209
	mov	arg01, #2
	call	#_execute_line
LR__0206
'   execute_line(2)
' 101 if inload=0 then v.writeln("") : v.writeln("Ready") 
	add	objptr, ##41960
	rdlong	local04, objptr wz
	sub	objptr, ##41960
 if_ne	jmp	#LR__0207
	mov	arg01, ##@LR__5269
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
	mov	arg01, ##@LR__5270
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
LR__0207
'     if inload=1 andalso err>0 then print fullline$
	add	objptr, ##41960
	rdlong	local04, objptr
	sub	objptr, ##41960
	cmp	local04, #1 wz
 if_ne	jmp	#LR__0208
	cmps	local01, #1 wc
 if_b	jmp	#LR__0208
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	add	objptr, ##28192
	rdlong	arg02, objptr
	sub	objptr, ##28192
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__0208
LR__0209
	mov	ptra, fp
	call	#popregs_
_interpret_ret
	ret

' 
' '---------------------------------------------------------------------------------------------------------------------
' '
' '                          END OF TOKENIZER MAIN CODE
' '
' '---------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------
' '-------------------- Helper functions for the tokenizer -------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------
' 
' ' Check if the part is an operator, return a token or 0 if not found
' 
' function isoperator(s as string) as ubyte
_isoperator
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5271
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0210
	mov	arg02, ##@LR__5272
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0211
	mov	arg02, ##@LR__5273
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0212
	mov	arg02, ##@LR__5274
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0213
	mov	arg02, ##@LR__5275
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0214
	mov	arg02, ##@LR__5276
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0215
	mov	arg02, ##@LR__5277
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0216
	mov	arg02, ##@LR__5278
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0217
	mov	arg02, ##@LR__5279
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0218
	mov	arg02, ##@LR__5280
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0219
	mov	arg02, ##@LR__5281
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0220
	mov	arg02, ##@LR__5282
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0221
	mov	arg02, ##@LR__5283
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0222
	mov	arg02, ##@LR__5284
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0223
	mov	arg02, ##@LR__5285
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0224
	mov	arg02, ##@LR__5286
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0225
	mov	arg02, ##@LR__5287
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0226
	mov	arg02, ##@LR__5288
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0227
	mov	arg02, ##@LR__5289
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0228
	mov	arg02, ##@LR__5290
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0229
	mov	arg02, ##@LR__5291
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0230
	mov	arg02, ##@LR__5292
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0231
	jmp	#LR__0232
LR__0210
	mov	result1, #1
	jmp	#LR__0233
LR__0211
	mov	result1, #2
	jmp	#LR__0233
LR__0212
	mov	result1, #3
	jmp	#LR__0233
LR__0213
	mov	result1, #4
	jmp	#LR__0233
LR__0214
	mov	result1, #5
	jmp	#LR__0233
LR__0215
	mov	result1, #6
	jmp	#LR__0233
LR__0216
	mov	result1, #7
	jmp	#LR__0233
LR__0217
	mov	result1, #8
	jmp	#LR__0233
LR__0218
	mov	result1, #9
	jmp	#LR__0233
LR__0219
	mov	result1, #10
	jmp	#LR__0233
LR__0220
	mov	result1, #11
	jmp	#LR__0233
LR__0221
	mov	result1, #12
	jmp	#LR__0233
LR__0222
	mov	result1, #13
	jmp	#LR__0233
LR__0223
	mov	result1, #14
	jmp	#LR__0233
LR__0224
	mov	result1, #27
	jmp	#LR__0233
LR__0225
	mov	result1, #39
	jmp	#LR__0233
LR__0226
	mov	result1, #38
	jmp	#LR__0233
LR__0227
	mov	result1, #16
	jmp	#LR__0233
LR__0228
	mov	result1, #15
	jmp	#LR__0233
LR__0229
	mov	result1, #42
	jmp	#LR__0233
LR__0230
	mov	result1, #40
	jmp	#LR__0233
LR__0231
	mov	result1, #41
	jmp	#LR__0233
LR__0232
	mov	result1, #0
LR__0233
	mov	ptra, fp
	call	#popregs_
_isoperator_ret
	ret

' 
' ' Check if the part is a channel#, return a token or 0 if not found
' 
' function ischannel(s as string) as ulong
_ischannel
	mov	COUNT_, #2
	call	#pushregs_
' if left$(s,1)<>"#" then return 0
	mov	local01, arg01
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5293
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0244
' if len(s)<>2 then return 0
	mov	arg01, local01
	mov	local02, arg01
	callpa	#(@LR__0241-@LR__0240)>>2,fcache_load_ptr_
LR__0240
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0240
LR__0241
	sub	local02, arg01
	mov	result1, local02
	cmp	result1, #2 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0244
' if right$(s,1)<"0" orelse right$(s,1)>"9" then return 0
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5294
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0242
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5295
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0243
LR__0242
	mov	result1, #0
	jmp	#LR__0244
LR__0243
' return token_channel+val(right$(s,1))
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, ##1110441984
	call	#__system___float_add
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
LR__0244
	mov	ptra, fp
	call	#popregs_
_ischannel_ret
	ret

' 
' ' Check if the part is a predefined constant, return a constant or 0 if not found
' ' todo: add spin2/pasm constants for pin control
' 
' function isconstant(s as string) as integer
_isconstant
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5296
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0250
	mov	arg02, ##@LR__5297
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0251
	mov	arg02, ##@LR__5298
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0252
	jmp	#LR__0253
LR__0250
	mov	result1, #1
	jmp	#LR__0254
LR__0251
	mov	result1, #2
	jmp	#LR__0254
LR__0252
	mov	result1, #4
	jmp	#LR__0254
LR__0253
	mov	result1, #0
LR__0254
	mov	ptra, fp
	call	#popregs_
_isconstant_ret
	ret

' 
' ' Check if the part is a predefined music note name, return a token or 0 if not found
' 
' function isnotename(s as string) as ulong
_isnotename
	mov	COUNT_, #7
	call	#pushregs_
' if left$(s,1)<>"#" then return 0
	mov	local01, arg01
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5299
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0283
' if mid$(s,3,1)="#" then s1=mid$(s,2,2) else s1=mid$(s,2,1)
	mov	arg01, local01
	mov	arg02, #3
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__5300
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0260
	mov	arg01, local01
	mov	arg02, #2
	mov	arg03, #2
	call	#__system__Mid_S
	mov	local02, result1
	jmp	#LR__0261
LR__0260
	mov	arg01, local01
	mov	arg02, #2
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local02, result1
LR__0261
' if mid$(s,len(s)-1,1)<>"-" then nn=val(right$(s,1)) else nn=-1*val(right$(s,1))
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__0263-@LR__0262)>>2,fcache_load_ptr_
LR__0262
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__0262
LR__0263
	sub	local03, arg01
	mov	arg02, local03
	sub	arg02, #1
	mov	arg01, local01
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, ##@LR__5301
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0264
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local04, result1
	jmp	#LR__0265
LR__0264
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, ##-1082130432
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local04, result1
LR__0265
' 
' if nn=0 andalso right$(s,1)<>"0" then nn=4
	cmp	local04, #0 wz
 if_ne	jmp	#LR__0266
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5302
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	local04, #4
LR__0266
' 
' select case s1
	mov	local05, local02
	mov	arg02, ##@LR__5303
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0267
	mov	arg02, ##@LR__5304
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0268
	mov	arg02, ##@LR__5305
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0269
	mov	arg02, ##@LR__5306
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0270
	mov	arg02, ##@LR__5307
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0271
	mov	arg02, ##@LR__5308
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0272
	mov	arg02, ##@LR__5309
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0273
	mov	arg02, ##@LR__5310
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0274
	mov	arg02, ##@LR__5311
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0275
	mov	arg02, ##@LR__5312
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0276
	mov	arg02, ##@LR__5313
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0277
	mov	arg02, ##@LR__5314
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0278
	mov	arg02, ##@LR__5315
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0279
	jmp	#LR__0280
LR__0267
	mov	local06, ##768
	jmp	#LR__0281
LR__0268
	mov	local06, ##769
	jmp	#LR__0281
LR__0269
	mov	local06, ##770
	jmp	#LR__0281
LR__0270
	mov	local06, ##771
	jmp	#LR__0281
LR__0271
	mov	local06, ##772
	jmp	#LR__0281
LR__0272
	mov	local06, ##773
	jmp	#LR__0281
LR__0273
	mov	local06, ##774
	jmp	#LR__0281
LR__0274
	mov	local06, ##775
	jmp	#LR__0281
LR__0275
	mov	local06, ##776
	jmp	#LR__0281
LR__0276
	mov	local06, ##777
	jmp	#LR__0281
LR__0277
	mov	local06, ##778
	jmp	#LR__0281
LR__0278
	mov	local06, ##779
	jmp	#LR__0281
LR__0279
	mov	local06, ##779
	jmp	#LR__0281
LR__0280
	mov	result1, #0
	jmp	#LR__0283
LR__0281
' if nn>=-1 andalso nn<10 then token=token+12*nn
	cmps	local04, ##-1 wc
 if_b	jmp	#LR__0282
	cmps	local04, #10 wc
 if_b	mov	local07, local04
 if_b	shl	local07, #1
 if_b	add	local07, local04
 if_b	shl	local07, #2
 if_b	add	local06, local07
LR__0282
' return token
	mov	result1, local06
LR__0283
	mov	ptra, fp
	call	#popregs_
_isnotename_ret
	ret

' 
' ' Check if the part is a separator, return a token or 0 if not found
' 
' function isseparator(s as string) as ubyte
_isseparator
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5316
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0290
	mov	arg02, ##@LR__5317
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0291
	mov	arg02, ##@LR__5318
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0292
	mov	arg02, ##@LR__5319
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0293
	mov	arg02, ##@LR__5320
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0294
	mov	arg02, ##@LR__5321
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0295
	mov	arg02, ##@LR__5322
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0296
	mov	arg02, ##@LR__5323
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0297
	mov	arg02, ##@LR__5324
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0298
	mov	arg02, ##@LR__5325
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0299
	mov	arg02, ##@LR__5326
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0300
	mov	arg02, ##@LR__5327
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0301
	mov	arg02, ##@LR__5328
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0302
	mov	arg02, ##@LR__5329
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0303
	mov	arg02, ##@LR__5330
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0304
	jmp	#LR__0305
LR__0290
	mov	result1, #1
	jmp	#LR__0306
LR__0291
	mov	result1, #2
	jmp	#LR__0306
LR__0292
	mov	result1, #27
	jmp	#LR__0306
LR__0293
	mov	result1, #17
	jmp	#LR__0306
LR__0294
	mov	result1, #5
	jmp	#LR__0306
LR__0295
	mov	result1, #6
	jmp	#LR__0306
LR__0296
	mov	result1, #18
	jmp	#LR__0306
LR__0297
	mov	result1, #19
	jmp	#LR__0306
LR__0298
	mov	result1, #12
	jmp	#LR__0306
LR__0299
	mov	result1, #20
	jmp	#LR__0306
LR__0300
	mov	result1, #21
	jmp	#LR__0306
LR__0301
	mov	result1, #22
	jmp	#LR__0306
LR__0302
	mov	result1, #511
	jmp	#LR__0306
LR__0303
	mov	result1, #15
	jmp	#LR__0306
LR__0304
	mov	result1, #16
	jmp	#LR__0306
LR__0305
	mov	result1, #0
LR__0306
	mov	ptra, fp
	call	#popregs_
_isseparator_ret
	ret

' 
' ' Check if the part is a command than doesn't return a value, return a token or 0 if not found
' 
' function iscommand(s as string) as ubyte
_iscommand
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5332
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0310
	mov	arg02, ##@LR__5333
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0311
	mov	arg02, ##@LR__5334
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0312
	mov	arg02, ##@LR__5335
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0313
	mov	arg02, ##@LR__5336
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0314
	mov	arg02, ##@LR__5337
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0315
	mov	arg02, ##@LR__5338
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0316
	mov	arg02, ##@LR__5339
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0317
	mov	arg02, ##@LR__5340
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0318
	mov	arg02, ##@LR__5341
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0319
	mov	arg02, ##@LR__5342
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0320
	mov	arg02, ##@LR__5343
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0321
	mov	arg02, ##@LR__5344
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0322
	mov	arg02, ##@LR__5345
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0323
	mov	arg02, ##@LR__5346
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0324
	mov	arg02, ##@LR__5347
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0325
	mov	arg02, ##@LR__5348
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0326
	mov	arg02, ##@LR__5349
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0327
	mov	arg02, ##@LR__5350
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0328
	mov	arg02, ##@LR__5351
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0329
	mov	arg02, ##@LR__5352
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0330
	mov	arg02, ##@LR__5353
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0331
	mov	arg02, ##@LR__5354
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0332
	mov	arg02, ##@LR__5355
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0333
	mov	arg02, ##@LR__5356
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0334
	mov	arg02, ##@LR__5357
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0335
	mov	arg02, ##@LR__5358
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0336
	mov	arg02, ##@LR__5359
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0337
	mov	arg02, ##@LR__5360
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0338
	mov	arg02, ##@LR__5361
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0339
	mov	arg02, ##@LR__5362
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0340
	mov	arg02, ##@LR__5363
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0341
	mov	arg02, ##@LR__5364
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0342
	mov	arg02, ##@LR__5365
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0343
	mov	arg02, ##@LR__5366
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0344
	mov	arg02, ##@LR__5367
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0345
	mov	arg02, ##@LR__5368
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0346
	mov	arg02, ##@LR__5369
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0347
	mov	arg02, ##@LR__5370
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0348
	mov	arg02, ##@LR__5371
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0349
	mov	arg02, ##@LR__5372
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0350
	mov	arg02, ##@LR__5373
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0351
	mov	arg02, ##@LR__5374
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0352
	mov	arg02, ##@LR__5375
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0353
	mov	arg02, ##@LR__5376
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0354
	mov	arg02, ##@LR__5377
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0355
	mov	arg02, ##@LR__5378
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0356
	mov	arg02, ##@LR__5379
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0357
	mov	arg02, ##@LR__5380
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0358
	mov	arg02, ##@LR__5381
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0359
	mov	arg02, ##@LR__5382
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0360
	mov	arg02, ##@LR__5383
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0361
	mov	arg02, ##@LR__5384
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0362
	mov	arg02, ##@LR__5385
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0363
	mov	arg02, ##@LR__5386
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0364
	mov	arg02, ##@LR__5387
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0365
	mov	arg02, ##@LR__5388
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0366
	mov	arg02, ##@LR__5389
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0367
	mov	arg02, ##@LR__5390
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0368
	mov	arg02, ##@LR__5391
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0369
	mov	arg02, ##@LR__5392
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0370
	mov	arg02, ##@LR__5393
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0371
	mov	arg02, ##@LR__5394
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0372
	mov	arg02, ##@LR__5395
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0373
	mov	arg02, ##@LR__5396
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0374
	mov	arg02, ##@LR__5397
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0375
	mov	arg02, ##@LR__5398
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0376
	mov	arg02, ##@LR__5399
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0377
	mov	arg02, ##@LR__5400
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0378
	mov	arg02, ##@LR__5401
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0379
	mov	arg02, ##@LR__5402
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0380
	mov	arg02, ##@LR__5403
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0381
	mov	arg02, ##@LR__5404
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0382
	mov	arg02, ##@LR__5405
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0383
	mov	arg02, ##@LR__5406
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0384
	mov	arg02, ##@LR__5407
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0385
	mov	arg02, ##@LR__5408
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0386
	mov	arg02, ##@LR__5409
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0387
	mov	arg02, ##@LR__5410
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0388
	mov	arg02, ##@LR__5411
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0389
	mov	arg02, ##@LR__5412
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0390
	mov	arg02, ##@LR__5413
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0391
	mov	arg02, ##@LR__5414
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0392
	mov	arg02, ##@LR__5415
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0393
	mov	arg02, ##@LR__5416
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0394
	mov	arg02, ##@LR__5417
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0395
	mov	arg02, ##@LR__5418
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0396
	mov	arg02, ##@LR__5419
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0397
	mov	arg02, ##@LR__5420
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0398
	mov	arg02, ##@LR__5421
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0399
	mov	arg02, ##@LR__5422
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0400
	mov	arg02, ##@LR__5423
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0401
	mov	arg02, ##@LR__5424
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0402
	mov	arg02, ##@LR__5425
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0403
	mov	arg02, ##@LR__5426
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0404
	mov	arg02, ##@LR__5427
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0405
	mov	arg02, ##@LR__5428
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0406
	mov	arg02, ##@LR__5429
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0407
	mov	arg02, ##@LR__5430
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0408
	mov	arg02, ##@LR__5431
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0409
	mov	arg02, ##@LR__5432
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0410
	mov	arg02, ##@LR__5433
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0411
	mov	arg02, ##@LR__5434
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0412
	mov	arg02, ##@LR__5435
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0413
	mov	arg02, ##@LR__5436
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0414
	mov	arg02, ##@LR__5437
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0415
	mov	arg02, ##@LR__5438
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0416
	mov	arg02, ##@LR__5439
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0417
	mov	arg02, ##@LR__5440
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0418
	mov	arg02, ##@LR__5441
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0419
	mov	arg02, ##@LR__5442
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0420
	mov	arg02, ##@LR__5443
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0421
	mov	arg02, ##@LR__5444
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0422
	mov	arg02, ##@LR__5445
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0423
	mov	arg02, ##@LR__5446
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0424
	mov	arg02, ##@LR__5447
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0425
	mov	arg02, ##@LR__5448
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0426
	mov	arg02, ##@LR__5449
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0427
	mov	arg02, ##@LR__5450
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0428
	mov	arg02, ##@LR__5451
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0429
	mov	arg02, ##@LR__5452
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0430
	mov	arg02, ##@LR__5453
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0431
	mov	arg02, ##@LR__5454
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0432
	mov	arg02, ##@LR__5455
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0433
	mov	arg02, ##@LR__5456
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0434
	mov	arg02, ##@LR__5457
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0435
	mov	arg02, ##@LR__5458
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0436
	mov	arg02, ##@LR__5459
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0437
	mov	arg02, ##@LR__5460
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0438
	mov	arg02, ##@LR__5461
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0439
	jmp	#LR__0440
LR__0310
	mov	result1, #92
	jmp	#LR__0441
LR__0311
	mov	result1, #92
	jmp	#LR__0441
LR__0312
	mov	result1, #185
	jmp	#LR__0441
LR__0313
	mov	result1, #71
	jmp	#LR__0441
LR__0314
	mov	result1, #89
	jmp	#LR__0441
LR__0315
	mov	result1, #89
	jmp	#LR__0441
LR__0316
	mov	result1, #195
	jmp	#LR__0441
LR__0317
	mov	result1, #174
	jmp	#LR__0441
LR__0318
	mov	result1, #174
	jmp	#LR__0441
LR__0319
	mov	result1, #177
	jmp	#LR__0441
LR__0320
	mov	result1, #177
	jmp	#LR__0441
LR__0321
	mov	result1, #175
	jmp	#LR__0441
LR__0322
	mov	result1, #175
	jmp	#LR__0441
LR__0323
	mov	result1, #176
	jmp	#LR__0441
LR__0324
	mov	result1, #176
	jmp	#LR__0441
LR__0325
	mov	result1, #69
	jmp	#LR__0441
LR__0326
	mov	result1, #69
	jmp	#LR__0441
LR__0327
	mov	result1, #105
	jmp	#LR__0441
LR__0328
	mov	result1, #180
	jmp	#LR__0441
LR__0329
	mov	result1, #64
	jmp	#LR__0441
LR__0330
	mov	result1, #73
	jmp	#LR__0441
LR__0331
	mov	result1, #73
	jmp	#LR__0441
LR__0332
	mov	result1, #80
	jmp	#LR__0441
LR__0333
	mov	result1, #80
	jmp	#LR__0441
LR__0334
	mov	result1, #104
	jmp	#LR__0441
LR__0335
	mov	result1, #115
	jmp	#LR__0441
LR__0336
	mov	result1, #116
	jmp	#LR__0441
LR__0337
	mov	result1, #108
	jmp	#LR__0441
LR__0338
	mov	result1, #108
	jmp	#LR__0441
LR__0339
	mov	result1, #137
	jmp	#LR__0441
LR__0340
	mov	result1, #194
	jmp	#LR__0441
LR__0341
	mov	result1, #114
	jmp	#LR__0441
LR__0342
	mov	result1, #93
	jmp	#LR__0441
LR__0343
	mov	result1, #150
	jmp	#LR__0441
LR__0344
	mov	result1, #67
	jmp	#LR__0441
LR__0345
	mov	result1, #67
	jmp	#LR__0441
LR__0346
	mov	result1, #67
	jmp	#LR__0441
LR__0347
	mov	result1, #90
	jmp	#LR__0441
LR__0348
	mov	result1, #171
	jmp	#LR__0441
LR__0349
	mov	result1, #189
	jmp	#LR__0441
LR__0350
	mov	result1, #189
	jmp	#LR__0441
LR__0351
	mov	result1, #70
	jmp	#LR__0441
LR__0352
	mov	result1, #70
	jmp	#LR__0441
LR__0353
	mov	result1, #113
	jmp	#LR__0441
LR__0354
	mov	result1, #113
	jmp	#LR__0441
LR__0355
	mov	result1, #96
	jmp	#LR__0441
LR__0356
	mov	result1, #74
	jmp	#LR__0441
LR__0357
	mov	result1, #74
	jmp	#LR__0441
LR__0358
	mov	result1, #72
	jmp	#LR__0441
LR__0359
	mov	result1, #72
	jmp	#LR__0441
LR__0360
	mov	result1, #187
	jmp	#LR__0441
LR__0361
	mov	result1, #169
	jmp	#LR__0441
LR__0362
	mov	result1, #78
	jmp	#LR__0441
LR__0363
	mov	result1, #78
	jmp	#LR__0441
LR__0364
	mov	result1, #88
	jmp	#LR__0441
LR__0365
	mov	result1, #95
	jmp	#LR__0441
LR__0366
	mov	result1, #95
	jmp	#LR__0441
LR__0367
	mov	result1, #181
	jmp	#LR__0441
LR__0368
	mov	result1, #76
	jmp	#LR__0441
LR__0369
	mov	result1, #76
	jmp	#LR__0441
LR__0370
	mov	result1, #82
	jmp	#LR__0441
LR__0371
	mov	result1, #82
	jmp	#LR__0441
LR__0372
	mov	result1, #151
	jmp	#LR__0441
LR__0373
	mov	result1, #198
	jmp	#LR__0441
LR__0374
	mov	result1, #97
	jmp	#LR__0441
LR__0375
	mov	result1, #97
	jmp	#LR__0441
LR__0376
	mov	result1, #99
	jmp	#LR__0441
LR__0377
	mov	result1, #65
	jmp	#LR__0441
LR__0378
	mov	result1, #75
	jmp	#LR__0441
LR__0379
	mov	result1, #75
	jmp	#LR__0441
LR__0380
	mov	result1, #193
	jmp	#LR__0441
LR__0381
	mov	result1, #179
	jmp	#LR__0441
LR__0382
	mov	result1, #94
	jmp	#LR__0441
LR__0383
	mov	result1, #94
	jmp	#LR__0441
LR__0384
	mov	result1, #124
	jmp	#LR__0441
LR__0385
	mov	result1, #126
	jmp	#LR__0441
LR__0386
	mov	result1, #125
	jmp	#LR__0441
LR__0387
	mov	result1, #127
	jmp	#LR__0441
LR__0388
	mov	result1, #128
	jmp	#LR__0441
LR__0389
	mov	result1, #85
	jmp	#LR__0441
LR__0390
	mov	result1, #117
	jmp	#LR__0441
LR__0391
	mov	result1, #117
	jmp	#LR__0441
LR__0392
	mov	result1, #66
	jmp	#LR__0441
LR__0393
	mov	result1, #66
	jmp	#LR__0441
LR__0394
	mov	result1, #149
	jmp	#LR__0441
LR__0395
	mov	result1, #172
	jmp	#LR__0441
LR__0396
	mov	result1, #129
	jmp	#LR__0441
LR__0397
	mov	result1, #129
	jmp	#LR__0441
LR__0398
	mov	result1, #68
	jmp	#LR__0441
LR__0399
	mov	result1, #68
	jmp	#LR__0441
LR__0400
	mov	result1, #188
	jmp	#LR__0441
LR__0401
	mov	result1, #136
	jmp	#LR__0441
LR__0402
	mov	result1, #146
	jmp	#LR__0441
LR__0403
	mov	result1, #190
	jmp	#LR__0441
LR__0404
	mov	result1, #190
	jmp	#LR__0441
LR__0405
	mov	result1, #170
	jmp	#LR__0441
LR__0406
	mov	result1, #77
	jmp	#LR__0441
LR__0407
	mov	result1, #81
	jmp	#LR__0441
LR__0408
	mov	result1, #81
	jmp	#LR__0441
LR__0409
	mov	result1, #142
	jmp	#LR__0441
LR__0410
	mov	result1, #142
	jmp	#LR__0441
LR__0411
	mov	result1, #144
	jmp	#LR__0441
LR__0412
	mov	result1, #144
	jmp	#LR__0441
LR__0413
	mov	result1, #141
	jmp	#LR__0441
LR__0414
	mov	result1, #141
	jmp	#LR__0441
LR__0415
	mov	result1, #140
	jmp	#LR__0441
LR__0416
	mov	result1, #140
	jmp	#LR__0441
LR__0417
	mov	result1, #145
	jmp	#LR__0441
LR__0418
	mov	result1, #145
	jmp	#LR__0441
LR__0419
	mov	result1, #139
	jmp	#LR__0441
LR__0420
	mov	result1, #139
	jmp	#LR__0441
LR__0421
	mov	result1, #143
	jmp	#LR__0441
LR__0422
	mov	result1, #143
	jmp	#LR__0441
LR__0423
	mov	result1, #143
	jmp	#LR__0441
LR__0424
	mov	result1, #178
	jmp	#LR__0441
LR__0425
	mov	result1, #178
	jmp	#LR__0441
LR__0426
	mov	result1, #117
	jmp	#LR__0441
LR__0427
	mov	result1, #117
	jmp	#LR__0441
LR__0428
	mov	result1, #109
	jmp	#LR__0441
LR__0429
	mov	result1, #109
	jmp	#LR__0441
LR__0430
	mov	result1, #91
	jmp	#LR__0441
LR__0431
	mov	result1, #86
	jmp	#LR__0441
LR__0432
	mov	result1, #86
	jmp	#LR__0441
LR__0433
	mov	result1, #112
	jmp	#LR__0441
LR__0434
	mov	result1, #112
	jmp	#LR__0441
LR__0435
	mov	result1, #87
	jmp	#LR__0441
LR__0436
	mov	result1, #87
	jmp	#LR__0441
LR__0437
	mov	result1, #121
	jmp	#LR__0441
LR__0438
	mov	result1, #119
	jmp	#LR__0441
LR__0439
	mov	result1, #120
	jmp	#LR__0441
LR__0440
	mov	result1, #0
LR__0441
	mov	ptra, fp
	call	#popregs_
_iscommand_ret
	ret

' 
' ' Check if the part is a function than returns a value, return a token or 0 if not found
' 
' function isfunction(s as string) as ubyte
_isfunction
	mov	COUNT_, #1
	call	#pushregs_
' 
' select case s
	mov	local01, arg01
	mov	arg02, ##@LR__5462
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0450
	mov	arg02, ##@LR__5463
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0451
	mov	arg02, ##@LR__5464
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0452
	mov	arg02, ##@LR__5465
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0453
	mov	arg02, ##@LR__5466
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0454
	mov	arg02, ##@LR__5467
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0455
	mov	arg02, ##@LR__5468
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0456
	mov	arg02, ##@LR__5469
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0457
	mov	arg02, ##@LR__5470
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0458
	mov	arg02, ##@LR__5471
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0459
	mov	arg02, ##@LR__5472
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0460
	mov	arg02, ##@LR__5473
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0461
	mov	arg02, ##@LR__5474
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0462
	mov	arg02, ##@LR__5475
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0463
	mov	arg02, ##@LR__5476
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0464
	mov	arg02, ##@LR__5477
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0465
	mov	arg02, ##@LR__5478
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0466
	mov	arg02, ##@LR__5479
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0467
	mov	arg02, ##@LR__5480
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0468
	mov	arg02, ##@LR__5481
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0469
	mov	arg02, ##@LR__5482
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0470
	mov	arg02, ##@LR__5483
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0471
	mov	arg02, ##@LR__5484
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0472
	mov	arg02, ##@LR__5485
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0473
	mov	arg02, ##@LR__5486
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0474
	mov	arg02, ##@LR__5487
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0475
	mov	arg02, ##@LR__5488
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0476
	mov	arg02, ##@LR__5489
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0477
	mov	arg02, ##@LR__5490
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0478
	mov	arg02, ##@LR__5491
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0479
	mov	arg02, ##@LR__5492
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0480
	mov	arg02, ##@LR__5493
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0481
	mov	arg02, ##@LR__5494
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0482
	mov	arg02, ##@LR__5495
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0483
	mov	arg02, ##@LR__5496
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0484
	mov	arg02, ##@LR__5497
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0485
	mov	arg02, ##@LR__5498
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0486
	mov	arg02, ##@LR__5499
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0487
	mov	arg02, ##@LR__5500
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0488
	mov	arg02, ##@LR__5501
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0489
	mov	arg02, ##@LR__5502
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0490
	mov	arg02, ##@LR__5503
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0491
	mov	arg02, ##@LR__5504
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0492
	mov	arg02, ##@LR__5505
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0493
	mov	arg02, ##@LR__5506
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0494
	mov	arg02, ##@LR__5507
	mov	arg01, local01
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0495
	jmp	#LR__0496
LR__0450
	mov	result1, #158
	jmp	#LR__0497
LR__0451
	mov	result1, #133
	jmp	#LR__0497
LR__0452
	mov	result1, #155
	jmp	#LR__0497
LR__0453
	mov	result1, #155
	jmp	#LR__0497
LR__0454
	mov	result1, #167
	jmp	#LR__0497
LR__0455
	mov	result1, #132
	jmp	#LR__0497
LR__0456
	mov	result1, #134
	jmp	#LR__0497
LR__0457
	mov	result1, #162
	jmp	#LR__0497
LR__0458
	mov	result1, #159
	jmp	#LR__0497
LR__0459
	mov	result1, #130
	jmp	#LR__0497
LR__0460
	mov	result1, #153
	jmp	#LR__0497
LR__0461
	mov	result1, #197
	jmp	#LR__0497
LR__0462
	mov	result1, #197
	jmp	#LR__0497
LR__0463
	mov	result1, #156
	jmp	#LR__0497
LR__0464
	mov	result1, #111
	jmp	#LR__0497
LR__0465
	mov	result1, #111
	jmp	#LR__0497
LR__0466
	mov	result1, #147
	jmp	#LR__0497
LR__0467
	mov	result1, #148
	jmp	#LR__0497
LR__0468
	mov	result1, #98
	jmp	#LR__0497
LR__0469
	mov	result1, #163
	jmp	#LR__0497
LR__0470
	mov	result1, #157
	jmp	#LR__0497
LR__0471
	mov	result1, #138
	jmp	#LR__0497
LR__0472
	mov	result1, #164
	jmp	#LR__0497
LR__0473
	mov	result1, #168
	jmp	#LR__0497
LR__0474
	mov	result1, #173
	jmp	#LR__0497
LR__0475
	mov	result1, #154
	jmp	#LR__0497
LR__0476
	mov	result1, #166
	jmp	#LR__0497
LR__0477
	mov	result1, #102
	jmp	#LR__0497
LR__0478
	mov	result1, #103
	jmp	#LR__0497
LR__0479
	mov	result1, #100
	jmp	#LR__0497
LR__0480
	mov	result1, #101
	jmp	#LR__0497
LR__0481
	mov	result1, #152
	jmp	#LR__0497
LR__0482
	mov	result1, #123
	jmp	#LR__0497
LR__0483
	mov	result1, #118
	jmp	#LR__0497
LR__0484
	mov	result1, #165
	jmp	#LR__0497
LR__0485
	mov	result1, #122
	jmp	#LR__0497
LR__0486
	mov	result1, #191
	jmp	#LR__0497
LR__0487
	mov	result1, #84
	jmp	#LR__0497
LR__0488
	mov	result1, #107
	jmp	#LR__0497
LR__0489
	mov	result1, #135
	jmp	#LR__0497
LR__0490
	mov	result1, #106
	jmp	#LR__0497
LR__0491
	mov	result1, #110
	jmp	#LR__0497
LR__0492
	mov	result1, #161
	jmp	#LR__0497
LR__0493
	mov	result1, #131
	jmp	#LR__0497
LR__0494
	mov	result1, #160
	jmp	#LR__0497
LR__0495
	mov	result1, #155
	jmp	#LR__0497
LR__0496
	mov	result1, #0
LR__0497
	mov	ptra, fp
	call	#popregs_
_isfunction_ret
	ret

' 
' ' Check if the part is a name
' 
' function isname(s as string) as boolean
_isname
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0501-@LR__0500)>>2,fcache_load_ptr_
LR__0500
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0500
LR__0501
	sub	local02, arg01
	mov	result1, local02
	mov	local03, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0513
	mov	arg01, local01
	mov	arg02, #1
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
' m$=mid$(s,1,1) : if (m$<"a" orelse m$>"z")  andalso m$<>"_" then return false
	mov	arg02, ##@LR__5508
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0502
	mov	arg02, ##@LR__5509
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0503
LR__0502
	mov	arg02, ##@LR__5510
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0513
LR__0503
' if l>2 then 
	cmps	local03, #3 wc
 if_b	jmp	#LR__0512
'   for i=2 to l
	mov	local05, #2
	mov	local06, local03
	add	local06, #1
LR__0504
	cmps	local05, local06 wc
 if_ae	jmp	#LR__0511
	mov	arg01, local01
	mov	arg02, local05
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
'     m$=mid$(s,i,1) : if (i<l) andalso (m$<"a" orelse m$>"z") andalso (m$<"0" orelse m$>"9") andalso m$<>"_" andalso m$<>"." then return false 
	cmps	local05, local03 wc
 if_ae	jmp	#LR__0507
	mov	arg02, ##@LR__5511
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0505
	mov	arg02, ##@LR__5512
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0507
LR__0505
	mov	arg02, ##@LR__5513
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0506
	mov	arg02, ##@LR__5514
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0507
LR__0506
	mov	local07, ##@LR__5515
	mov	arg01, local04
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0507
	mov	local08, ##@LR__5516
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local09, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0513
LR__0507
'     if (i=l) andalso (m$<"a" orelse m$>"z") andalso (m$<"0" orelse m$>"9") andalso m$<>"_" andalso m$<>"$" andalso m$<>"%" andalso m$<>"!" then return false
	cmp	local05, local03 wz
 if_ne	jmp	#LR__0510
	mov	local10, ##@LR__5517
	mov	arg01, local04
	mov	arg02, local10
	call	#__system___string_cmp
	mov	local11, result1
	cmps	local11, #0 wc
 if_b	jmp	#LR__0508
	mov	arg02, ##@LR__5518
	mov	arg01, local04
	call	#__system___string_cmp
	mov	local10, result1
	cmps	local10, #1 wc
 if_b	jmp	#LR__0510
LR__0508
	mov	arg02, ##@LR__5519
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0509
	mov	local09, ##@LR__5520
	mov	arg01, local04
	mov	arg02, local09
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0510
LR__0509
	mov	local09, ##@LR__5521
	mov	arg01, local04
	mov	arg02, local09
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	jmp	#LR__0510
	mov	local08, ##@LR__5522
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local09, result1 wz
 if_e	jmp	#LR__0510
	mov	local12, ##@LR__5523
	mov	local08, local12
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local07, result1 wz
 if_e	jmp	#LR__0510
	mov	local13, ##@LR__5524
	mov	local12, local13
	mov	arg01, local04
	mov	arg02, local12
	call	#__system___string_cmp
	mov	local08, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0513
LR__0510
	add	local05, #1
	jmp	#LR__0504
LR__0511
LR__0512
' return true
	neg	result1, #1
LR__0513
	mov	ptra, fp
	call	#popregs_
_isname_ret
	ret

' 
' ' Check if the part is a number.  
' 
' function isnum(s as string) as boolean 
_isnum
	mov	COUNT_, #19
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	mov	local03, #0
	mov	arg01, local01
	mov	local04, arg01
	callpa	#(@LR__0521-@LR__0520)>>2,fcache_load_ptr_
LR__0520
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0520
LR__0521
	sub	local04, arg01
	mov	result1, local04
	mov	local05, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0536
	mov	arg01, local01
	mov	arg02, #1
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local06, result1
' m$=mid$(s,1,1) : if (m$<"0" orelse m$>"9") andalso m$<>"." andalso m$<>"$" andalso m$<>"%" andalso m$<>"-" then return false
	mov	arg02, ##@LR__5525
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0522
	mov	local07, ##@LR__5526
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0523
LR__0522
	mov	local08, ##@LR__5527
	mov	local07, local08
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0523
	mov	local09, ##@LR__5528
	mov	local08, local09
	mov	arg01, local06
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local07, result1 wz
 if_e	jmp	#LR__0523
	mov	local10, ##@LR__5529
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local09
	call	#__system___string_cmp
	mov	local08, result1 wz
 if_e	jmp	#LR__0523
	mov	local11, ##@LR__5530
	mov	local10, local11
	mov	arg01, local06
	mov	arg02, local10
	call	#__system___string_cmp
	mov	local09, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0536
LR__0523
' if m$="." then ds=1
	mov	arg02, ##@LR__5531
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local02, #1
' if m$="$" then hex=1 else hex=0
	mov	arg02, ##@LR__5532
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local12, #1
 if_ne	mov	local12, #0
' if m$="%" then bin=1 else bin=0
	mov	arg02, ##@LR__5533
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local13, #1
 if_ne	mov	local13, #0
' if l>1 then 
	cmps	local05, #2 wc
 if_b	jmp	#LR__0535
'   for i=2 to l
	mov	local14, #2
	mov	local15, local05
	add	local15, #1
LR__0524
	cmps	local14, local15 wc
 if_ae	jmp	#LR__0534
	mov	arg01, local01
	mov	arg02, local14
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local06, result1
	mov	local16, #0
'     m$=mid$(s,i,1) : b=false
'     if m$>="0" andalso m$<="9" then b=true  
	mov	arg02, ##@LR__5534
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0525
	mov	local07, ##@LR__5535
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	neg	local16, #1
LR__0525
'     if m$="_" orelse m$="." orelse m$="E" orelse m$="e" orelse m$="-" then b=true 
	mov	arg02, ##@LR__5536
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0526
	mov	local07, ##@LR__5537
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0526
	mov	local08, ##@LR__5538
	mov	local07, local08
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0526
	mov	local09, ##@LR__5539
	mov	local08, local09
	mov	arg01, local06
	mov	arg02, local08
	call	#__system___string_cmp
	mov	local07, result1 wz
 if_e	jmp	#LR__0526
	mov	local10, ##@LR__5540
	mov	local09, local10
	mov	arg01, local06
	mov	arg02, local09
	call	#__system___string_cmp
	mov	local08, result1 wz
 if_ne	jmp	#LR__0527
LR__0526
	neg	local16, #1
LR__0527
'     if hex=1 andalso m$>="a" andalso m$<="f" then b=true
	cmp	local12, #1 wz
 if_ne	jmp	#LR__0528
	mov	arg02, ##@LR__5541
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0528
	mov	local07, ##@LR__5542
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	neg	local16, #1
LR__0528
'     if bin=1 andalso (m$<"0" orelse m$>"1") andalso m$<>"_" then return false
	cmp	local13, #1 wz
 if_ne	jmp	#LR__0530
	mov	arg02, ##@LR__5543
	mov	arg01, local06
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0529
	mov	local07, ##@LR__5544
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0530
LR__0529
	mov	local08, ##@LR__5545
	mov	local07, local08
	mov	arg01, local06
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0536
LR__0530
'     if not b then return false
	not	local16, local16
	cmp	local16, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0536
'     if m$="-" andalso lcase$(mid$(s,i-1,1))<>"e" then return false
	mov	arg02, ##@LR__5546
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0531
	mov	arg02, local14
	sub	arg02, #1
	mov	arg01, local01
	mov	arg03, #1
	call	#__system__Mid_S
	mov	arg01, result1
	call	#__system__LCase_S
	mov	arg01, result1
	mov	local07, ##@LR__5547
	mov	arg02, local07
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0536
LR__0531
'     if m$="." then ds+=1: if ds>1 then return false
	mov	arg02, ##@LR__5548
	mov	arg01, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	local02, #1
 if_e	cmps	local02, #2 wc
 if_nc_and_z	mov	result1, #0
 if_nc_and_z	jmp	#LR__0536
'     if m$="E" orelse m$="e" then es+=1: if hex=0 andalso es>1 then return false
	mov	local17, ##@LR__5549
	mov	local18, local17
	mov	arg01, local06
	mov	arg02, local18
	call	#__system___string_cmp
	mov	local19, result1 wz
 if_e	jmp	#LR__0532
	mov	local07, ##@LR__5550
	mov	local17, local07
	mov	arg01, local06
	mov	arg02, local17
	call	#__system___string_cmp
	mov	local18, result1 wz
 if_ne	jmp	#LR__0533
LR__0532
	add	local03, #1
	cmp	local12, #0 wz
 if_e	cmps	local03, #2 wc
 if_nc_and_z	mov	result1, #0
 if_nc_and_z	jmp	#LR__0536
LR__0533
	add	local14, #1
	jmp	#LR__0524
LR__0534
LR__0535
' return true
	neg	result1, #1
LR__0536
	mov	ptra, fp
	call	#popregs_
_isnum_ret
	ret

'   
' ' Check if the part is an integer number.    
'   
' function isint(s as string) as boolean
_isint
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0541-@LR__0540)>>2,fcache_load_ptr_
LR__0540
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0540
LR__0541
	sub	local02, arg01
	mov	result1, local02
	mov	local03, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0554
	mov	arg01, local01
	mov	arg02, #1
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
' m$=mid$(s,1,1) : if (m$<"0" orelse m$>"9") andalso m$<>"$" andalso m$<>"%" andalso m$<>"-" then return false
	mov	arg02, ##@LR__5551
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0542
	mov	local05, ##@LR__5552
	mov	arg01, local04
	mov	arg02, local05
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0543
LR__0542
	mov	local06, ##@LR__5553
	mov	local05, local06
	mov	arg01, local04
	mov	arg02, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0543
	mov	local07, ##@LR__5554
	mov	local06, local07
	mov	arg01, local04
	mov	arg02, local06
	call	#__system___string_cmp
	mov	local05, result1 wz
 if_e	jmp	#LR__0543
	mov	local08, ##@LR__5555
	mov	local07, local08
	mov	arg01, local04
	mov	arg02, local07
	call	#__system___string_cmp
	mov	local06, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0554
LR__0543
' if m$="$" then hex=1 else hex=0
	mov	arg02, ##@LR__5556
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local09, #1
 if_ne	mov	local09, #0
' if m$="%" then bin=1 else bin=0
	mov	arg02, ##@LR__5557
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local10, #1
 if_ne	mov	local10, #0
' if l>1 then 
	cmps	local03, #2 wc
 if_b	jmp	#LR__0553
'   for i=2 to l
	mov	local11, #2
	mov	local12, local03
	add	local12, #1
LR__0544
	cmps	local11, local12 wc
 if_ae	jmp	#LR__0552
	mov	arg01, local01
	mov	arg02, local11
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local04, result1
'     m$=mid$(s,i,1) 
'     if hex=0 andalso (m$<"0" orelse m$>"9") andalso m$<>"_"  then return false
	cmp	local09, #0 wz
 if_ne	jmp	#LR__0546
	mov	arg02, ##@LR__5558
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0545
	mov	arg02, ##@LR__5559
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0546
LR__0545
	mov	local06, ##@LR__5560
	mov	arg01, local04
	mov	arg02, local06
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0554
LR__0546
'     if hex=1 andalso (m$<"0" orelse m$>"9") andalso (m$<"a" orelse m$>"f") andalso m$<>"_"  then return false
	cmp	local09, #1 wz
 if_ne	jmp	#LR__0549
	mov	arg02, ##@LR__5561
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0547
	mov	arg02, ##@LR__5562
	mov	arg01, local04
	call	#__system___string_cmp
	mov	local13, result1
	cmps	local13, #1 wc
 if_b	jmp	#LR__0549
LR__0547
	mov	local05, ##@LR__5563
	mov	arg01, local04
	mov	arg02, local05
	call	#__system___string_cmp
	mov	local14, result1
	cmps	local14, #0 wc
 if_b	jmp	#LR__0548
	mov	local07, ##@LR__5564
	mov	arg01, local04
	mov	arg02, local07
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0549
LR__0548
	mov	local08, ##@LR__5565
	mov	arg01, local04
	mov	arg02, local08
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0554
LR__0549
'     if bin=1 andalso (m$<"0" orelse m$>"1") andalso m$<>"_"  then return false
	cmp	local10, #1 wz
 if_ne	jmp	#LR__0551
	mov	arg02, ##@LR__5566
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0550
	mov	arg02, ##@LR__5567
	mov	arg01, local04
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0551
LR__0550
	mov	arg02, ##@LR__5568
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0554
LR__0551
	add	local11, #1
	jmp	#LR__0544
LR__0552
LR__0553
' return true
	neg	result1, #1
LR__0554
	mov	ptra, fp
	call	#popregs_
_isint_ret
	ret

' 
' ' Check if the part is a positive decimal number.  
' 
' function isdec(s as string) as boolean
_isdec
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__0561-@LR__0560)>>2,fcache_load_ptr_
LR__0560
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__0560
LR__0561
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0566
' for i=1 to l
	mov	local03, #1
	mov	local04, local02
	add	local04, #1
LR__0562
	cmps	local03, local04 wc
 if_ae	jmp	#LR__0565
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, #1
	call	#__system__Mid_S
	mov	local05, result1
'     m$=mid$(s,i,1) : if (m$<"0" orelse m$>"9") andalso m$<>"_"  then return false
	mov	arg02, ##@LR__5569
	mov	arg01, local05
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__0563
	mov	arg02, ##@LR__5570
	mov	arg01, local05
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__0564
LR__0563
	mov	arg02, ##@LR__5571
	mov	arg01, local05
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__0566
LR__0564
	add	local03, #1
	jmp	#LR__0562
LR__0565
' return true
	neg	result1, #1
LR__0566
	mov	ptra, fp
	call	#popregs_
_isdec_ret
	ret

' 
' ' Check if the part is a string.  
' 
' function isstring(s as string) as boolean
_isstring
	mov	COUNT_, #1
	call	#pushregs_
' if left$(s,1)="""" andalso right$(s,1)="""" then return true else return false
	mov	local01, arg01
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5572
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_ne	jmp	#LR__0570
	mov	arg01, local01
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5573
	call	#__system___string_cmp
	cmps	result1, #0 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__0571
LR__0570
	mov	result1, #0
LR__0571
	mov	ptra, fp
	call	#popregs_
_isstring_ret
	ret

' 
' ' getnoteval. Returns the frequency of note token
' 
' function getnoteval(token) as single
_getnoteval
	mov	COUNT_, #2
	call	#pushregs_
	sub	arg01, ##768
	abs	arg02, arg01 wc
	qdiv	arg02, #12
	add	objptr, ##10456
	getqy	arg02
	negc	arg02, arg02
	shl	arg02, #2
	add	arg02, objptr
	rdlong	local01, arg02
	abs	arg02, arg01 wc
	qdiv	arg02, #12
	sub	objptr, ##10456
	mov	arg01, #1
' noteexp=1+(note/12) 
' return (2.0^noteexp)*notebase
	getqx	arg02
	sumc	arg01, arg02
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg02, result1
	decod	arg01, #30
	call	#__system____builtin_powf
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_mul
	mov	ptra, fp
	call	#popregs_
_getnoteval_ret
	ret

' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '--------------------- The end of interpreter/tokenizer functions ----------------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '
' '               		REVERSE POLISH NOTATION PRECOMPILER
' '
' ' A precompiler gets the tokenized line at the input, and outputs the precompiled line that uses the reverse Polish notation.
' ' That means the operation is done by firs placing the arguments on the stack, and then do the operation on a top of this stack.
' ' The expression a=b*(c+d) is translated to push c, push d, add, push b, mul, push variable#, assign
' ' If the precompiled line has a number that is >0, then it is added to the program and saved in the PSRAM using the 2-way list structure
' ' If the line number=0, it is not saved, and instead it is immediately executed in the "interpret" function
' ' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' ' Helper functions to manage program lines
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '----- delete a line from a program
' 
' function deleteline(aline as ulong) as integer
_deleteline
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #44
	add	fp, #4
	wrlong	arg01, fp
	add	objptr, ##38024
	rdlong	local01, objptr
	add	fp, #12
	wrlong	local01, fp
	sub	fp, #16
' 
' searchptr=programstart
' do
	sub	objptr, ##32188
LR__0580
	add	fp, #20
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #16
	mov	arg03, #24
	call	#_psram_spin2_read1
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #8
	wrlong	local01, fp
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #24
	wrlong	local01, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #16
	rdlong	arg03, fp
	sub	fp, #4
	cmp	local01, arg03 wc
 if_b	add	fp, #40
 if_b	rdlong	local02, fp
 if_b	sub	fp, #40
 if_b	cmp	local02, ##2147483647 wz
 if_c_and_nz	jmp	#LR__0580
	sub	objptr, ##5836
' if header(0)<>aline then return -1						' if not =, then there is no line, return
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #16
	rdlong	local02, fp
	sub	fp, #4
	cmp	local01, local02 wz
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__0585
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	neg	arg02, #1
	call	#_pslpoke
' pslpoke(lineptr2,$FFFF_FFFF) 							' flag the deleted line
' 
' if header(5)=$7FFF_FFFF andalso header(4)=$FFFF_FFFF then  			' this is one and only line in the program
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmp	local01, ##2147483647 wz
 if_e	add	fp, #36
 if_e	rdlong	local02, fp
 if_e	sub	fp, #36
 if_e	cmp	local02, ##-1 wz
 if_ne	jmp	#LR__0581
	add	objptr, ##38024
	wrlong	##524288, objptr
	sub	objptr, ##3628
	wrlong	##524288, objptr
	add	objptr, ##3632
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	sub	objptr, ##38032
	mov	arg01, #0
	neg	arg02, #1
	call	#_pslpoke
	mov	arg01, #16
	neg	arg02, #1
	call	#_pslpoke
	mov	arg01, #20
	bmask	arg02, #30
	call	#_pslpoke
	add	objptr, ##41144
	wrlong	##524288, objptr
	add	objptr, #4
	wrlong	##524288, objptr
	sub	objptr, ##41148
LR__0581
' 
' if header(5)=$7FFF_FFFF andalso header(4)<>$FFFF_FFFF then 			' this is the last, and not first, line of the program
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmp	local01, ##2147483647 wz
 if_ne	jmp	#LR__0582
	add	fp, #36
	rdlong	local02, fp
	sub	fp, #36
	cmp	local02, ##-1 wz
 if_e	jmp	#LR__0582
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #20
	bmask	arg02, #30
	call	#_pslpoke
	add	fp, #36
	rdlong	local01, fp
	add	objptr, ##38032
	wrlong	local01, objptr
	sub	objptr, ##38032
	rdlong	arg01, fp
	sub	fp, #36
	call	#_pslpeek
	add	objptr, ##38028
	wrlong	result1, objptr
	sub	objptr, ##38028
'   pslpoke(header(4)+20,$7FFF_FFFF) 						' unlink the previous line
'   lastlineptr=header(4)           						' keep the last line pointer to avoid searching while sequentially adding a new line
'   lastline=pslpeek(header(4))
'   return 0
	mov	result1, #0
	jmp	#LR__0585
LR__0582
' 
' if header(5)<>$7FFF_FFFF andalso header(4)=$FFFF_FFFF then 			' this is the first line, but not the last
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmp	local01, ##2147483647 wz
 if_e	jmp	#LR__0583
	add	fp, #36
	rdlong	local02, fp
	sub	fp, #36
	cmp	local02, ##-1 wz
 if_ne	jmp	#LR__0583
	add	fp, #40
	rdlong	arg01, fp
	sub	fp, #40
	add	arg01, #16
	neg	arg02, #1
	call	#_pslpoke
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	add	objptr, ##38024
	wrlong	local01, objptr
	sub	objptr, ##38024
' '   print "deleted first line"
'   pslpoke(header(5)+16,$FFFF_FFFF) 
'   programstart=header(5) 							' adjust the program start to point on the first new line
'   return 0
	mov	result1, #0
	jmp	#LR__0585
LR__0583
' 
' if header(5)<>$7FFF_FFFF andalso header(4)<>$FFFF_FFFF then 			' the line is not first and not last
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmp	local01, ##2147483647 wz
 if_ne	add	fp, #36
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #36
 if_ne	cmp	local02, ##-1 wz
 if_e	jmp	#LR__0584
	add	fp, #40
	rdlong	arg01, fp
	add	arg01, #16
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #36
	call	#_pslpoke
	add	fp, #36
	rdlong	arg01, fp
	add	arg01, #20
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #40
	call	#_pslpoke
'    pslpoke(header(5)+16,header(4))  
'    pslpoke(header(4)+20, header(5))
'    return 0
	mov	result1, #0
	jmp	#LR__0585
LR__0584
	mov	result1, #0
LR__0585
	mov	ptra, fp
	call	#popregs_
_deleteline_ret
	ret

' 
' '----- Save a line to the PSRAM. Called from insertline and add_line_at_end
' 
' sub save_line
_save_line
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, ##38012
	rdlong	arg03, objptr
	add	arg03, #1
	sub	objptr, ##2584
	rdlong	arg02, objptr
	qmul	arg02, arg03
	sub	objptr, ##7236
	rdlong	arg01, objptr
	sub	objptr, ##28192
	mov	local01, arg01
	getqx	local02
	callpa	#(@LR__0591-@LR__0590)>>2,fcache_load_ptr_
LR__0590
	rdbyte	result1, local01 wz
 if_ne	add	local01, #1
 if_ne	jmp	#LR__0590
LR__0591
	sub	local01, arg01
	test	local01, #3 wz
 if_ne	shr	local01, #2
 if_ne	add	local01, #1
 if_ne	shl	local01, #2
	mov	local03, local02
	add	local03, local01
	add	objptr, ##34396
	rdlong	arg03, objptr
	add	arg03, local02
	add	objptr, ##2088
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	local01, objptr
	sub	objptr, #12
	mov	arg01, objptr
	sub	objptr, ##2080
	rdlong	arg02, objptr
	mov	arg03, local02
	sub	objptr, ##28560
	call	#_psram_spin2_write
	add	objptr, ##22356
	rdlong	arg01, objptr
	add	objptr, ##6204
	rdlong	arg02, objptr
	add	arg02, local02
	mov	arg03, local01
	sub	objptr, ##28560
	call	#_psram_spin2_write
	add	objptr, ##28560
	rdlong	local01, objptr
	add	local01, local03
	wrlong	local01, objptr
	sub	objptr, ##34396
	mov	ptra, fp
	call	#popregs_
_save_line_ret
	ret

' 
' '----- Insert a new line into the middle of the program
' 
' function insertline(aline as ulong) as integer
_insertline
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #40
	add	fp, #4
	wrlong	arg01, fp
	add	objptr, ##38024
	rdlong	local01, objptr
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
' 
' do
	sub	objptr, ##32188
LR__0600
	add	fp, #16
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	mov	arg03, #24
	call	#_psram_spin2_read1
	add	fp, #8
	rdlong	local01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #24
	rdlong	local01, fp
	sub	fp, #28
	wrlong	local01, fp
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #12
	rdlong	arg03, fp
	sub	fp, #4
	cmp	local01, arg03 wc
 if_b	add	fp, #36
 if_b	rdlong	local02, fp
 if_b	sub	fp, #36
 if_b	cmp	local02, ##2147483647 wz
 if_c_and_nz	jmp	#LR__0600
	sub	objptr, ##5836
' 
' if header(0)=aline then return -1 				' delete it first
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #12
	rdlong	local02, fp
	sub	fp, #4
	cmp	local01, local02 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__0603
' if header(0)<aline then return -2 				' end of program reached
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #12
	rdlong	arg03, fp
	sub	fp, #4
	cmp	local01, arg03 wc
 if_b	neg	result1, #2
 if_b	jmp	#LR__0603
' 
' if  header(4)=$FFFF_FFFF then 					' this is the first line in the program so the inserted line will be new first
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, ##-1 wz
 if_ne	jmp	#LR__0601
	add	objptr, ##34396
	rdlong	local01, objptr
	add	objptr, ##3628
	wrlong	local01, objptr
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #16
	sub	objptr, ##3628
	rdlong	arg02, objptr
	sub	objptr, ##34396
	call	#_pslpoke
	add	objptr, ##36492
	wrlong	##-1, objptr
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	add	objptr, #4
	wrlong	local01, objptr
	sub	objptr, ##36496
	call	#_save_line
'   programstart=programptr
'   pslpoke(lineptr2+16,programptr)
'   ucompiledline(4)=$FFFF_FFFF
'   ucompiledline(5)=lineptr2
'   save_line
'   return 0
	mov	result1, #0
	jmp	#LR__0603
LR__0601
' 
' if header(4)<>$FFFF_FFFF then 					' this is not first line of the program. It doesn't matter if it is last as we will insert a new line before
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, ##-1 wz
 if_e	jmp	#LR__0602
	add	fp, #32
	rdlong	local01, fp
	add	objptr, ##36492
	wrlong	local01, objptr
	sub	fp, #20
	rdlong	local01, fp
	add	objptr, #4
	wrlong	local01, objptr
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #16
	sub	objptr, ##2100
	rdlong	arg02, objptr
	sub	objptr, ##34396
	call	#_pslpoke
	add	fp, #32
	rdlong	arg01, fp
	sub	fp, #32
	add	arg01, #20
	add	objptr, ##34396
	rdlong	arg02, objptr
	sub	objptr, ##34396
	call	#_pslpoke
	call	#_save_line
'   ucompiledline(4)=header(4)
'   ucompiledline(5)=lineptr2
'   pslpoke(lineptr2+16,programptr)
'   pslpoke(header(4)+20,programptr)
'   save_line
'   return 0
	mov	result1, #0
	jmp	#LR__0603
LR__0602
	mov	result1, #0
LR__0603
	mov	ptra, fp
	call	#popregs_
_insertline_ret
	ret

' 
' '----- Adds a new line at the end of the program
' 
' sub add_line_at_end(aline) 
_add_line_at_end
	add	objptr, ##38028
	wrlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##1540
	wrlong	arg02, objptr
	add	objptr, ##1540
	rdlong	arg01, objptr
	add	arg01, #20
	sub	objptr, ##3636
	rdlong	arg02, objptr
	sub	objptr, ##34396
	call	#_pslpoke
	add	objptr, ##34396
	rdlong	arg02, objptr
	add	objptr, ##3636
	wrlong	arg02, objptr
	sub	objptr, ##1536
	wrlong	##2147483647, objptr
' 
' lastline=aline: ucompiledline(4)=lastlineptr : pslpoke(lastlineptr+20,programptr) : lastlineptr=programptr : ucompiledline(5)=$7FFF_FFFF 
' if programptr=memlo then ucompiledline(4)=$FFFFFFFF ' that is the first line
	sub	objptr, ##2100
	rdlong	arg02, objptr
	sub	objptr, ##34396
	cmp	arg02, ##524288 wz
 if_e	add	objptr, ##36492
 if_e	wrlong	##-1, objptr
 if_e	sub	objptr, ##36492
	call	#_save_line
	add	objptr, ##34396
	rdlong	arg01, objptr
	sub	objptr, ##34396
	neg	arg02, #1
	call	#_pslpoke
_add_line_at_end_ret
	ret

' 
' '--------------------------------------------------------------------------------------------------------------------------
' '---------------------------------- End of line managing helper functions -------------------------------------------------
' '--------------------------------------------------------------------------------------------------------------------------
' 
' '--------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Compilers ------------------------------------------------------------------------
' '--------------------------------------------------------------------------------------------------------------------------
' 
' '--- Do a main compilation task for commands, called from compile(), returns an error code
' 
' function compile_immediate(linetype as ulong, aline as ulong) as integer
_compile_immediate
	mov	COUNT_, #10
	call	#pushregs_
_compile_immediate_enter
	mov	local04, arg01
	mov	local05, arg02
	mov	local06, #0
	mov	local07, #0
	mov	local08, #0
' 
' ' linetype=cont+1
' ' 1 : this is the first part of the line that will continue
' ' 2 - this is the continuation of the line
' ' 3 - this is the last continued line
' ' 4 - this is the one and only part
' ' 5 - continued after if/else
' 
' err=0
' cmd=0
' vars=0
' if linetype=2 orelse linetype=3 then cmd=lparts(0).token : ct=1 
	cmp	local04, #2 wz
 if_ne	cmp	local04, #3 wz
 if_ne	jmp	#LR__0610
	add	objptr, ##27152
	rdlong	local07, objptr
	mov	local09, #1
	add	objptr, ##1076
	wrlong	#1, objptr
	sub	objptr, ##28228
LR__0610
' if linetype=4 orelse linetype=1 then cmd=lparts(1).token : ct=2 : lineptr=2
	cmp	local04, #4 wz
 if_ne	cmp	local04, #1 wz
 if_ne	jmp	#LR__0611
	add	objptr, ##27160
	rdlong	local07, objptr
	mov	local09, #2
	add	objptr, ##1068
	wrlong	#2, objptr
	add	objptr, ##9784
	wrlong	#2, objptr
	sub	objptr, ##38012
LR__0611
' if linetype=5 then cmd=lparts(ct).token : ct+=1 
	cmp	local04, #5 wz
 if_ne	jmp	#LR__0612
	add	objptr, ##28228
	rdlong	result2, objptr
	mov	local09, result2
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	add	local09, #4
	rdlong	local07, local09
	add	result2, #1
	add	objptr, ##1080
	wrlong	result2, objptr
	sub	objptr, ##28228
LR__0612
' 
' 'print  "In compile_immediate cmd=:", cmd
' 451 select case cmd
	cmp	local07, #92 wz
 if_e	jmp	#LR__0613
	cmp	local07, #185 wz
 if_e	jmp	#LR__0614
	cmp	local07, #71 wz
 if_e	jmp	#LR__0615
	cmp	local07, #89 wz
 if_e	jmp	#LR__0616
	cmp	local07, #195 wz
 if_e	jmp	#LR__0617
	cmp	local07, #69 wz
 if_e	jmp	#LR__0618
	cmp	local07, #105 wz
 if_e	jmp	#LR__0619
	cmp	local07, #64 wz
 if_e	jmp	#LR__0691
	cmp	local07, #180 wz
 if_e	jmp	#LR__0620
	cmp	local07, #73 wz
 if_e	jmp	#LR__0621
	cmp	local07, #80 wz
 if_e	jmp	#LR__0622
	cmp	local07, #174 wz
 if_e	jmp	#LR__0623
	cmp	local07, #176 wz
 if_e	jmp	#LR__0624
	cmp	local07, #175 wz
 if_e	jmp	#LR__0625
	cmp	local07, #177 wz
 if_e	jmp	#LR__0626
	cmp	local07, #104 wz
 if_e	jmp	#LR__0627
	cmp	local07, #116 wz
 if_e	jmp	#LR__0628
	cmp	local07, #115 wz
 if_e	jmp	#LR__0629
	cmp	local07, #108 wz
 if_e	jmp	#LR__0630
	cmp	local07, #137 wz
 if_e	jmp	#LR__0691
	cmp	local07, #194 wz
 if_e	jmp	#LR__0631
	cmp	local07, #114 wz
 if_e	jmp	#LR__0632
	cmp	local07, #93 wz
 if_e	jmp	#LR__0633
	cmp	local07, #150 wz
 if_e	jmp	#LR__0634
	cmp	local07, #67 wz
 if_e	jmp	#LR__0635
	cmp	local07, #90 wz
 if_e	jmp	#LR__0636
	cmp	local07, #171 wz
 if_e	jmp	#LR__0691
	cmp	local07, #189 wz
 if_e	jmp	#LR__0637
	cmp	local07, #187 wz
 if_e	jmp	#LR__0638
	cmp	local07, #78 wz
 if_e	jmp	#LR__0639
	cmp	local07, #169 wz
 if_e	jmp	#LR__0641
	cmp	local07, #70 wz
 if_e	jmp	#LR__0643
	cmp	local07, #113 wz
 if_e	jmp	#LR__0644
	cmp	local07, #96 wz
 if_e	jmp	#LR__0645
	cmp	local07, #74 wz
 if_e	jmp	#LR__0646
	cmp	local07, #72 wz
 if_e	jmp	#LR__0647
	cmp	local07, #88 wz
 if_e	jmp	#LR__0648
	cmp	local07, #95 wz
 if_e	jmp	#LR__0649
	cmp	local07, #181 wz
 if_e	jmp	#LR__0650
	cmp	local07, #138 wz
 if_e	jmp	#LR__0651
	cmp	local07, #76 wz
 if_e	jmp	#LR__0652
	cmp	local07, #82 wz
 if_e	jmp	#LR__0653
	cmp	local07, #151 wz
 if_e	jmp	#LR__0654
	cmp	local07, #198 wz
 if_e	jmp	#LR__0655
	cmp	local07, #97 wz
 if_e	jmp	#LR__0656
	cmp	local07, #99 wz
 if_e	jmp	#LR__0657
	cmp	local07, #65 wz
 if_e	jmp	#LR__0691
	cmp	local07, #75 wz
 if_e	jmp	#LR__0658
	cmp	local07, #193 wz
 if_e	jmp	#LR__0659
	cmp	local07, #179 wz
 if_e	jmp	#LR__0660
	cmp	local07, #94 wz
 if_e	jmp	#LR__0661
	cmp	local07, #124 wz
 if_e	jmp	#LR__0662
	cmp	local07, #125 wz
 if_e	jmp	#LR__0663
	cmp	local07, #126 wz
 if_e	jmp	#LR__0664
	cmp	local07, #127 wz
 if_e	jmp	#LR__0665
	cmp	local07, #128 wz
 if_e	jmp	#LR__0666
	cmp	local07, #85 wz
 if_e	jmp	#LR__0667
	cmp	local07, #117 wz
 if_e	jmp	#LR__0668
	cmp	local07, #66 wz
 if_e	jmp	#LR__0669
	cmp	local07, #149 wz
 if_e	jmp	#LR__0670
	cmp	local07, #172 wz
 if_e	jmp	#LR__0691
	cmp	local07, #129 wz
 if_e	jmp	#LR__0671
	cmp	local07, #68 wz
 if_e	jmp	#LR__0672
	cmp	local07, #188 wz
 if_e	jmp	#LR__0673
	cmp	local07, #136 wz
 if_e	jmp	#LR__0691
	cmp	local07, #146 wz
 if_e	jmp	#LR__0674
	cmp	local07, #190 wz
 if_e	jmp	#LR__0692
	cmp	local07, #170 wz
 if_e	jmp	#LR__0691
	cmp	local07, #77 wz
 if_e	jmp	#LR__0675
	cmp	local07, #81 wz
 if_e	jmp	#LR__0676
	cmp	local07, #142 wz
 if_e	jmp	#LR__0677
	cmp	local07, #144 wz
 if_e	jmp	#LR__0678
	cmp	local07, #141 wz
 if_e	jmp	#LR__0679
	cmp	local07, #140 wz
 if_e	jmp	#LR__0680
	cmp	local07, #145 wz
 if_e	jmp	#LR__0681
	cmp	local07, #139 wz
 if_e	jmp	#LR__0682
	cmp	local07, #143 wz
 if_e	jmp	#LR__0683
	cmp	local07, #178 wz
 if_e	jmp	#LR__0684
	cmp	local07, #109 wz
 if_e	jmp	#LR__0685
	cmp	local07, #112 wz
 if_e	jmp	#LR__0691
	cmp	local07, #86 wz
 if_e	jmp	#LR__0686
	cmp	local07, #87 wz
 if_e	jmp	#LR__0691
	cmp	local07, #121 wz
 if_e	jmp	#LR__0687
	cmp	local07, #119 wz
 if_e	jmp	#LR__0688
	cmp	local07, #120 wz
 if_e	jmp	#LR__0689
	cmp	local07, ##516 wz
 if_e	jmp	#LR__0690
	jmp	#LR__0692
LR__0613
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0614
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0615
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0616
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0617
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0618
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0619
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0620
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0621
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0622
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0623
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0624
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0625
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0626
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0627
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0628
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0629
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0630
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0631
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0632
	call	#_compile_dim
	mov	local06, result1
	jmp	#LR__0692
LR__0633
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0634
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0635
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0636
	mov	arg01, local05
	call	#_compile_else
	mov	local06, result1
	jmp	#LR__0692
LR__0637
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0638
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0639
	cmp	local05, #1 wc
 if_b	jmp	#LR__0640
	call	#_compile_goto
	jmp	#LR__0692
LR__0640
	mov	arg01, #25
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__0692
LR__0641
	cmp	local05, #1 wc
 if_b	jmp	#LR__0642
	call	#_compile_gosub
	jmp	#LR__0692
LR__0642
	mov	arg01, #25
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__0692
LR__0643
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0644
	call	#_compile_fun_4p
	mov	local06, result1
	jmp	#LR__0691
LR__0645
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0646
	call	#_compile_for
	mov	local06, result1
	jmp	#LR__0692
LR__0647
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0648
	mov	arg01, local05
	call	#_compile_if
	mov	local06, result1
	jmp	#LR__0692
LR__0649
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0650
	call	#_compile_input
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0651
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0652
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0653
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0654
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0655
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0656
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0657
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0658
	call	#_compile_next
	mov	local06, result1
	jmp	#LR__0692
LR__0659
	call	#_compile_on
	mov	local06, result1
	jmp	#LR__0692
LR__0660
	call	#_compile_fun_3p
	mov	local06, result1
	jmp	#LR__0691
LR__0661
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0662
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0663
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0664
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0665
	call	#_compile_fun_4p
	mov	local06, result1
	jmp	#LR__0691
LR__0666
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0667
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0668
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0669
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0670
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0671
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0672
	call	#_compile_print
	mov	local06, result1
	jmp	#LR__0692
LR__0673
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0674
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0675
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0676
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0677
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0678
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0679
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0680
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0681
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0682
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0683
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0684
	call	#_compile_fun_varp
	mov	local08, result1
	mov	local06, result2
	jmp	#LR__0691
LR__0685
	call	#_compile_fun_3p
	mov	local06, result1
	jmp	#LR__0691
LR__0686
' return expr()
	call	#_expr
	mov	local06, result1
	jmp	#LR__0691
LR__0687
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0688
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0689
	call	#_compile_fun_2p
	mov	local06, result1
	jmp	#LR__0691
LR__0690
	call	#_compile_array_assign
	mov	local06, result1
	cmp	local06, #14 wz
 if_ne	jmp	#LR__0692
' return 23
	mov	local06, #23
	jmp	#LR__0692
' return 23
LR__0691
	mov	local03, local07
	mov	local01, local08
	mov	local09, local01
	mov	local10, local02
	mov	local07, local03
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local08, local01
	shl	local08, #1
	add	local08, local01
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	wrlong	local09, local08
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local10, local09
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local10, local01
	shl	local10, #1
	add	local10, local01
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #8
	wrlong	local07, local10
	add	objptr, ##1536
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##38012
LR__0692
' 
' t3.result_type=cmd : t3.result.uresult=vars : compiledline(lineptr)=t3:  lineptr+=1
' 450 if linetype=3 orelse linetype=4 then compiledline(lineptr).result_type=token_end 				' the last part 
	cmp	local04, #3 wz
 if_ne	cmp	local04, #4 wz
 if_ne	jmp	#LR__0693
	add	objptr, ##38012
	rdlong	local10, objptr
	mov	local01, local10
	shl	local01, #1
	add	local01, local10
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	#510, local01
	sub	objptr, ##36476
LR__0693
' ' if there is token_adr somewhere, change fun_getvar to fun_getaddr
' for i=lineptr to 1 step -1: if compiledline(i).result_type=token_adr andalso compiledline(i-1).result_type=fun_getvar then compiledline(i-1).result_type=fun_getaddr
	add	objptr, ##38012
	rdlong	local01, objptr
	sub	objptr, ##38012
	callpa	#(@LR__0696-@LR__0694)>>2,fcache_load_ptr_
LR__0694
	mov	local10, local01
	shl	local10, #1
	add	local10, local01
	shl	local10, #2
	add	objptr, ##36476
	add	local10, objptr
	add	local10, #8
	rdlong	local10, local10
	cmp	local10, #155 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__0695
	mov	local09, local01
	sub	local09, #1
	mov	local10, local09
	shl	local10, #1
	add	local10, local09
	shl	local10, #2
	add	objptr, ##36476
	add	local10, objptr
	add	local10, #8
	rdlong	local10, local10
	cmp	local10, #17 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__0695
	mov	local09, local01
	sub	local09, #1
	mov	local10, local09
	shl	local10, #1
	add	local10, local09
	shl	local10, #2
	add	objptr, ##36476
	add	local10, objptr
	add	local10, #8
	wrlong	#18, local10
	sub	objptr, ##36476
LR__0695
	sub	local01, #1
	cmps	local01, #1 wc
 if_ae	jmp	#LR__0694
LR__0696
' '''''' print "In compile_immediate:" : for i=0 to lineptr: print compiledline(i).result_type;" ";compiledline(i).result.uresult, compiledline(i).result.twowords(1) : next i
' return err
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
_compile_immediate_ret
	ret

' 
' '--- Do a main compilation task for assigns, called from compile_assign(), returns an error code
' 
' function compile_immediate_assign(linetype as ulong) as ulong
_compile_immediate_assign
	mov	COUNT_, #12
	call	#pushregs_
	mov	local04, arg01
	mov	local03, #255
	neg	local05, #1
	mov	local06, #0
' 
' t1.result_type=result_error : t1.result.uresult=0
' i=-1: j=-1 : err=0
' 
' if linetype=2 orelse linetype=3 then varname2$=lparts(0).part$ : ct=2 ' don't set lineptr
	cmp	local04, #2 wz
 if_ne	cmp	local04, #3 wz
 if_e	add	objptr, ##27148
 if_e	rdlong	local07, objptr
 if_e	add	objptr, ##1080
 if_e	wrlong	#2, objptr
 if_e	sub	objptr, ##28228
' if linetype=4 orelse linetype=1 then varname2$=lparts(1).part$ : ct=3 : lineptr=2
	cmp	local04, #4 wz
 if_ne	cmp	local04, #1 wz
 if_ne	jmp	#LR__0700
	add	objptr, ##27156
	rdlong	local07, objptr
	add	objptr, ##1072
	wrlong	#3, objptr
	add	objptr, ##9784
	wrlong	#2, objptr
	sub	objptr, ##38012
LR__0700
' if linetype=5 then varname2$=lparts(ct).part$ : ct+=2 ' continued after if/else
	cmp	local04, #5 wz
 if_ne	jmp	#LR__0701
	add	objptr, ##28228
	rdlong	result1, objptr
	mov	local07, result1
	shl	local07, #3
	sub	objptr, ##1080
	add	local07, objptr
	rdlong	local07, local07
	add	result1, #2
	add	objptr, ##1080
	wrlong	result1, objptr
	sub	objptr, ##28228
LR__0701
	mov	arg01, local07
	mov	arg02, #1
	call	#__system__Right_S
	mov	local08, result1
	call	#_expr
' 
' suffix2$=right$(varname2$,1)
' expr()
' if varnum>0 then					' try to find a variable
	add	objptr, ##27144
	rdlong	local09, objptr
	sub	objptr, ##27144
	cmps	local09, #1 wc
 if_b	jmp	#LR__0704
'   for i=0 to varnum-1
	mov	local10, #0
	add	objptr, ##27144
	rdlong	local11, objptr
	sub	objptr, ##27144
LR__0702
	cmps	local10, local11 wc
 if_ae	jmp	#LR__0703
'     if variables(i).name=varname2$ then j=i : exit
	mov	local09, local10
	shl	local09, #4
	add	objptr, ##10744
	add	local09, objptr
	rdlong	arg01, local09
	mov	arg02, local07
	sub	objptr, ##10744
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local05, local10
 if_ne	add	local10, #1
 if_ne	jmp	#LR__0702
LR__0703
LR__0704
' if  j=-1 andalso varnum<maxvars then   			' not found, add a new one
	cmp	local05, ##-1 wz
 if_ne	jmp	#LR__0705
	add	objptr, ##27144
	rdlong	local09, objptr
	sub	objptr, ##27144
	cmps	local09, ##1024 wc
 if_ae	jmp	#LR__0705
	add	objptr, ##27144
	rdlong	local11, objptr
	shl	local11, #4
	sub	objptr, ##16400
	add	local11, objptr
	wrlong	local07, local11
	add	objptr, ##16400
	rdlong	local09, objptr
	mov	local05, local09
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##27144
LR__0705
' if varnum>=maxvars then
	add	objptr, ##27144
	rdlong	local09, objptr
	sub	objptr, ##27144
	cmps	local09, ##1024 wc
 if_ae	mov	local06, #45
 if_ae	jmp	#LR__0710
	mov	local01, local05
	mov	local03, #23
	mov	local09, local01
	mov	local12, local02
	mov	local01, local03
	add	objptr, ##38012
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	wrlong	local09, local10
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local11, local09
	shl	local11, #1
	add	local11, local09
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #4
	wrlong	local12, local11
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local12, local09
	shl	local12, #1
	add	local12, local09
	shl	local12, #2
	sub	objptr, ##1536
	add	local12, objptr
	add	local12, #8
	wrlong	local01, local12
	add	objptr, ##1536
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##38012
'   t1.result.uresult=j: t1.result_type=fun_assign  
'   compiledline(lineptr)=t1:  lineptr+=1 
'   if linetype=3 orelse linetype=4 then compiledline(lineptr).result_type=token_end
	cmp	local04, #3 wz
 if_ne	cmp	local04, #4 wz
 if_ne	jmp	#LR__0706
	add	objptr, ##38012
	rdlong	local12, objptr
	mov	local01, local12
	shl	local01, #1
	add	local01, local12
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	#510, local01
	sub	objptr, ##36476
LR__0706
'   for i=lineptr to 1 step -1: if compiledline(i).result_type=token_adr andalso compiledline(i-1).result_type=fun_getvar then compiledline(i-1).result_type=fun_getaddr
	add	objptr, ##38012
	rdlong	local10, objptr
	sub	objptr, ##38012
	callpa	#(@LR__0709-@LR__0707)>>2,fcache_load_ptr_
LR__0707
	mov	local12, local10
	shl	local12, #1
	add	local12, local10
	shl	local12, #2
	add	objptr, ##36476
	add	local12, objptr
	add	local12, #8
	rdlong	local12, local12
	cmp	local12, #155 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__0708
	mov	local12, local10
	sub	local12, #1
	mov	local01, local12
	shl	local01, #1
	add	local01, local12
	shl	local01, #2
	add	objptr, ##36476
	add	local01, objptr
	add	local01, #8
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__0708
	mov	local12, local10
	sub	local12, #1
	mov	local01, local12
	shl	local01, #1
	add	local01, local12
	shl	local01, #2
	add	objptr, ##36476
	add	local01, objptr
	add	local01, #8
	wrlong	#18, local01
	sub	objptr, ##36476
LR__0708
	sub	local10, #1
	cmps	local10, #1 wc
 if_ae	jmp	#LR__0707
LR__0709
LR__0710
' return err
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
_compile_immediate_assign_ret
	ret

' 
' ' ------------------ compile the line that is calling a command, and save it if linenum>0, called from the interpreter 
' 
' function compile (alinemajor as ulong, alineminor=0 as ulong, cont=0 as ulong) as ulong
_compile
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	add	objptr, ##36476
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, ##36480
	mov	arg01, local02
	add	arg01, #1
	mov	arg02, local01
	call	#_compile_immediate
	mov	local03, result1 wz
' 'line header: num major, num minor,list start, list length, prev, next. That implements 2-way list of program lines 
' ucompiledline(0)=alinemajor
' ucompiledline(1)=alineminor		' this is for the future when maybe linenums will be optional.
' 
' ' cont: 
' ' 0 - this is the first part of the line that will continue
' ' 1 - this is the continuation of the line
' ' 2 - this is the last continued line
' ' 3 - this is the one and only part
' 
' err=compile_immediate(cont+1,alinemajor) 
' if err=0 andalso alinemajor>0 then
 if_ne	jmp	#LR__0725
	cmp	local01, #1 wc
 if_b	jmp	#LR__0725
'   if cont=3 orelse cont=2 then 
	cmp	local02, #3 wz
 if_ne	cmp	local02, #2 wz
 if_ne	jmp	#LR__0724
'     if alinemajor >lastline then 
	add	objptr, ##38028
	rdlong	arg02, objptr
	sub	objptr, ##38028
	cmp	local01, arg02 wcz
 if_be	jmp	#LR__0720
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0723
LR__0720
	mov	arg01, local01
	call	#_deleteline
'       deleteline(alinemajor)  
'       if alinemajor>lastline then add_line_at_end(alinemajor)  else insertline(alinemajor)   ' TODO: that's not optimal    
	add	objptr, ##38028
	rdlong	arg02, objptr
	sub	objptr, ##38028
	cmp	local01, arg02 wcz
 if_be	jmp	#LR__0721
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0722
LR__0721
	mov	arg01, local01
	call	#_insertline
LR__0722
LR__0723
LR__0724
LR__0725
' return err
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_compile_ret
	ret

' 
' ' ------------------ compile the line that is assigning to a variable and save it if linenum>0, called from the interpreter 
' 
' function compile_assign (alinemajor as ulong, alineminor=0 as ulong, cont=0 as ulong)  as ulong
_compile_assign
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	add	objptr, ##36476
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, ##36480
	mov	arg01, local02
	add	arg01, #1
	call	#_compile_immediate_assign
	mov	local03, result1
' 
' ucompiledline(0)=alinemajor
' ucompiledline(1)=alineminor
' 
' err=compile_immediate_assign(cont+1) 
' if alinemajor>0 then
	cmp	local01, #1 wc
 if_b	jmp	#LR__0735
'   if cont=3 orelse cont=2 then 
	cmp	local02, #3 wz
 if_ne	cmp	local02, #2 wz
 if_ne	jmp	#LR__0734
'     if alinemajor >lastline then 
	add	objptr, ##38028
	rdlong	arg02, objptr
	sub	objptr, ##38028
	cmp	local01, arg02 wcz
 if_be	jmp	#LR__0730
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0733
LR__0730
	mov	arg01, local01
	call	#_deleteline
'       deleteline(alinemajor)  
'       if alinemajor>lastline then add_line_at_end(alinemajor) else insertline(alinemajor)   
	add	objptr, ##38028
	rdlong	arg02, objptr
	sub	objptr, ##38028
	cmp	local01, arg02 wcz
 if_be	jmp	#LR__0731
	mov	arg01, local01
	call	#_add_line_at_end
	jmp	#LR__0732
LR__0731
	mov	arg01, local01
	call	#_insertline
LR__0732
LR__0733
LR__0734
LR__0735
' return err
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_compile_assign_ret
	ret

' 
' '----- A function that prepares 2 parameters for a 2-parameter command
' 
' function compile_fun_2p() as ulong
_compile_fun_2p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0740
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##28228
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##27148
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0740
	add	objptr, ##28228
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##28228
	call	#_expr
' err=expr() : if err>0 then return err
	cmp	result1, #1 wc
' return 0
 if_b	mov	result1, #0
LR__0740
	mov	ptra, fp
	call	#popregs_
_compile_fun_2p_ret
	ret

' 
' '----- A function that prepares 3 parameters for a 3-parameter command
' 
' function compile_fun_3p() as ulong
_compile_fun_3p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0750
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##28228
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##27148
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0750
	add	objptr, ##28228
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##28228
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0750
' if lparts(ct).token<> token_comma then return 21 else ct+=1 ' todo error
	add	objptr, ##28228
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##27148
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0750
	add	objptr, ##28228
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##28228
	call	#_expr
' err=expr() : if err>0 then return err
	cmp	result1, #1 wc
' return 0
 if_b	mov	result1, #0
LR__0750
	mov	ptra, fp
	call	#popregs_
_compile_fun_3p_ret
	ret

' 
' '----- A function that prepares 4 parameters for a 4-parameter command
' 
' function compile_fun_4p() as ulong
_compile_fun_4p
	mov	COUNT_, #1
	call	#pushregs_
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0760
' if lparts(ct).token<> token_comma then return 21 else ct+=1 
	add	objptr, ##28228
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##27148
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0760
	add	objptr, ##28228
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##28228
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0760
' if lparts(ct).token<> token_comma then return 21 else ct+=1 
	add	objptr, ##28228
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##27148
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0760
	add	objptr, ##28228
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##28228
	call	#_expr
	mov	local01, result1
' err=expr() : if err>0 then return err
	cmp	local01, #1 wc
 if_ae	mov	result1, local01
 if_ae	jmp	#LR__0760
' if lparts(ct).token<> token_comma then return 21 else ct+=1  
	add	objptr, ##28228
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	local01, #17 wz
	sub	objptr, ##27148
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0760
	add	objptr, ##28228
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##28228
	call	#_expr
' err=expr() : if err>0 then return err
	cmp	result1, #1 wc
' return 0
 if_b	mov	result1, #0
LR__0760
	mov	ptra, fp
	call	#popregs_
_compile_fun_4p_ret
	ret

' 
' '----  Compile a command that can have variable number of parameters. Return num of params and error code
' 
' function compile_fun_varp() as ulong,ulong 
_compile_fun_varp
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, #0
' 
' i=0 : err=0
' if lparts(ct).token<>token_end then
	add	objptr, ##28228
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #510 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0771
'   do
LR__0770
	call	#_expr
	add	local01, #1
'     expr()
'     i+=1
'     if lparts(ct).token=token_comma then ct+=1
	add	objptr, ##28228
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #17 wz
	sub	objptr, ##27148
 if_e	add	objptr, ##28228
 if_e	rdlong	local03, objptr
 if_e	add	local03, #1
 if_e	wrlong	local03, objptr
 if_e	sub	objptr, ##28228
'     if lparts(ct).token=token_end then exit loop
	add	objptr, ##28228
	rdlong	local02, objptr
	shl	local02, #3
	sub	objptr, ##1080
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	cmp	local02, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0770
LR__0771
' return i,err
	mov	result1, local01
	mov	result2, #0
	mov	ptra, fp
	call	#popregs_
_compile_fun_varp_ret
	ret

' 
' '----  Compile input. The same as compile_varp() except these has to be variables, and not expressions, and also we need getaddr and not getvar
' 
' function compile_input() as ulong,ulong 
_compile_input
	mov	COUNT_, #11
	call	#pushregs_
' 
' if lparts(ct).token=token_string then
	add	objptr, ##28228
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	result2, arg03
	cmp	result2, ##515 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0786
	add	objptr, ##28228
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	sub	objptr, ##27148
	mov	local04, arg01
	callpa	#(@LR__0781-@LR__0780)>>2,fcache_load_ptr_
LR__0780
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0780
LR__0781
	sub	local04, arg01
	mov	result1, local04
	add	objptr, ##41984
	wrlong	result1, objptr
	sub	objptr, #84
	rdlong	arg01, objptr
	sub	arg01, result1
	sub	arg01, #4
	andn	arg01, #3
	wrlong	arg01, objptr
	add	objptr, #84
	rdlong	arg02, objptr
	sub	objptr, ##41984
	call	#_pslpoke
'   pslpoke memtop,l
'   for i=1 to l : pspoke memtop+3+i, asc(mid$(lparts(ct).part$,i,1)) : next i
	mov	local05, #1
	add	objptr, ##41984
	rdlong	local06, objptr
	sub	objptr, ##41984
	add	local06, #1
LR__0782
	cmps	local05, local06 wc
 if_ae	jmp	#LR__0783
	add	objptr, ##41900
	rdlong	local04, objptr
	add	local04, #3
	add	local04, local05
	sub	objptr, ##13672
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	mov	arg02, local05
	mov	arg03, #1
	sub	objptr, ##27148
	call	#__system__Mid_S
	rdbyte	arg02, result1
	mov	arg01, local04
	call	#_pspoke
	add	local05, #1
	jmp	#LR__0782
LR__0783
	add	objptr, ##41900
	rdlong	local01, objptr
	mov	local03, #43
	mov	local07, local01
	mov	local08, local02
	mov	arg02, local03
	sub	objptr, ##3888
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	wrlong	local07, local05
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #4
	wrlong	local08, local06
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local08, local07
	shl	local08, #1
	add	local08, local07
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	add	local08, #8
	wrlong	arg02, local08
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##9784
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
'   t1.result.uresult=memtop
'   t1.result_type=result_string2  
'   compiledline(lineptr)=t1: lineptr+=1 :ct+=1
'   if lparts(ct).token=token_comma then t1.result_type=print_mod_comma : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	shl	local07, #3
	sub	objptr, ##1080
	add	local07, objptr
	add	local07, #4
	rdlong	local07, local07
	cmp	local07, #17 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0784
	mov	local03, #33
	mov	local07, local01
	mov	local08, local02
	mov	local09, local03
	add	objptr, ##38012
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	wrlong	local07, local05
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local07, local10
	shl	local07, #1
	add	local07, local10
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	add	local07, #4
	wrlong	local08, local07
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local11, local07
	shl	local11, #1
	add	local11, local07
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local09, local11
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	mov	local03, #68
	mov	local07, local01
	mov	local08, local02
	mov	local09, local03
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	wrlong	local07, local10
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local08, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local09, local11
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##38012
LR__0784
'   if lparts(ct).token=token_semicolon then t1.result_type=print_mod_semicolon : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##28228
	rdlong	local07, objptr
	shl	local07, #3
	sub	objptr, ##1080
	add	local07, objptr
	add	local07, #4
	rdlong	local11, local07
	cmp	local11, #18 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0785
	mov	local03, #34
	mov	local07, local01
	mov	local08, local02
	mov	local09, local03
	add	objptr, ##38012
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	wrlong	local07, local10
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local07, local11
	shl	local07, #1
	add	local07, local11
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	add	local07, #4
	wrlong	local08, local07
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local11, local07
	shl	local11, #1
	add	local11, local07
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local09, local11
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	mov	local03, #68
	mov	local07, local01
	mov	local08, local02
	mov	local09, local03
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	wrlong	local07, local10
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local08, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local09, local11
	add	objptr, ##1536
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##38012
LR__0785
	add	objptr, ##28228
	rdlong	local07, objptr
	add	local07, #1
	wrlong	local07, objptr
	sub	objptr, ##28228
LR__0786
	mov	local05, #0
	mov	local11, #0
' 
' i=0 : err=0
' if lparts(ct).token<>token_end then
	add	objptr, ##28228
	rdlong	local10, objptr
	shl	local10, #3
	sub	objptr, ##1080
	add	local10, objptr
	add	local10, #4
	rdlong	local10, local10
	cmp	local10, #510 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0788
'   do
LR__0787
	call	#_getaddr
	mov	local11, result1
	add	objptr, ##28228
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	add	local05, #1
'     err=getaddr() :ct+=1
'     i+=1 
'     if lparts(ct).token=token_comma then ct+=1 
	shl	local10, #3
	sub	objptr, ##1080
	add	local10, objptr
	add	local10, #4
	rdlong	local10, local10
	cmp	local10, #17 wz
	sub	objptr, ##27148
 if_e	add	objptr, ##28228
 if_e	rdlong	local07, objptr
 if_e	add	local07, #1
 if_e	wrlong	local07, objptr
 if_e	sub	objptr, ##28228
'     if lparts(ct).token=token_end then exit loop
	add	objptr, ##28228
	rdlong	local10, objptr
	shl	local10, #3
	sub	objptr, ##1080
	add	local10, objptr
	add	local10, #4
	rdlong	local10, local10
	cmp	local10, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0787
LR__0788
' return i,err
	mov	result1, local05
	mov	result2, local11
	mov	ptra, fp
	call	#popregs_
_compile_input_ret
	ret

' 
' '----- compile assign to an array element
' 
' function compile_array_assign() as ulong 
_compile_array_assign
	mov	COUNT_, #11
	call	#pushregs_
	mov	local04, #0
	mov	local05, #0
	add	objptr, ##28228
	rdlong	local06, objptr
	mov	result1, local06
	sub	result1, #1
	shl	result1, #3
	sub	objptr, ##1080
	add	result1, objptr
	rdlong	local07, result1
' numpar=0 : err=0
' varname$=lparts(ct-1).part$
' if lparts(ct).token=token_lpar then
	shl	local06, #3
	add	local06, objptr
	add	local06, #4
	rdlong	local06, local06
	cmp	local06, #21 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0794
	add	objptr, ##28228
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##28228
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__0790
	call	#_expr
	add	objptr, ##28228
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	add	local04, #1
	sub	local06, #1
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	add	local06, #4
	rdlong	local08, local06
	cmp	local08, #20 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0791
	add	objptr, ##28228
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local08, local08
	cmp	local08, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0790
LR__0791
	add	objptr, ##28228
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##28228
	call	#_expr
	neg	local09, #1
	mov	local10, #0
'   ct+=1 : expr()
'   j=-1 : i=0 
'   do 
LR__0792
'     if variables(i).name=varname$ then j=i: exit loop
	mov	local06, local10
	shl	local06, #4
	add	objptr, ##10744
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, local07
	sub	objptr, ##10744
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local09, local10
 if_e	jmp	#LR__0793
	add	local10, #1
	add	objptr, ##27144
	rdlong	local08, objptr
	sub	objptr, ##27144
	cmps	local10, local08 wcz
 if_be	jmp	#LR__0792
LR__0793
	mov	local01, local09
	mov	local02, local04
	mov	local03, #23
	mov	local08, local01
	mov	local11, local02
	mov	local07, local03
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local08, local09
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local11, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local01, local11
	shl	local01, #1
	add	local01, local11
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	local07, local01
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
'   t1.result.twowords(0)=j: t1.result.twowords(1)=numpar : t1.result_type=fun_assign : compiledline(lineptr)=t1: lineptr +=1 
'   if numpar>3 then err=45
	cmp	local04, #4 wc
 if_ae	mov	local05, #45
'   if i>varnum then err=20
	sub	objptr, ##10868
	rdlong	local08, objptr
	sub	objptr, ##27144
	cmps	local10, local08 wcz
 if_a	mov	local05, #20
	jmp	#LR__0795
LR__0794
	mov	local05, #14
LR__0795
' return err
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
_compile_array_assign_ret
	ret

' 
' '----- compile print command with its ";" and "," modifiers
' 
' function compile_print() as ulong ' todo reconfigurable editor start position
_compile_print
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, #0
	mov	local03, #29
' t1.result.uresult=0 : t1.result_type=result_uint
' if lparts(ct).token=token_end then t1.result_type=print_mod_empty: compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1 :return 0 	'print without parameters
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0800
	mov	local03, #32
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##38012
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local10, local05
	shl	local10, #1
	add	local10, local05
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local11, local05
	shl	local11, #1
	add	local11, local05
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##38012
	mov	result1, #0
	jmp	#LR__0807
LR__0800
' do
LR__0801
	call	#_expr
'   expr()  ': print "In compile_print token= "; lparts(ct).token; " part$= "; lparts(ct).part$ :
'   if lparts(ct).token=token_comma then t1.result_type=print_mod_comma : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #17 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0802
	mov	local03, #33
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##38012
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local11, local05
	shl	local11, #1
	add	local11, local05
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##38012
LR__0802
'   if lparts(ct).token=token_semicolon then  t1.result_type=print_mod_semicolon : compiledline(lineptr)=t1:  lineptr+=1 : t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #18 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0803
	mov	local03, #34
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##38012
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local11, local05
	shl	local11, #1
	add	local11, local05
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##38012
LR__0803
'   if lparts(ct).token=token_end then t1.result_type=token_print : compiledline(lineptr)=t1:  lineptr+=1
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0804
	mov	local03, #68
	mov	local05, local01
	mov	local06, local02
	mov	local07, local03
	add	objptr, ##38012
	rdlong	local08, objptr
	mov	local09, local08
	shl	local09, #1
	add	local09, local08
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local05, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #4
	wrlong	local06, local10
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local11, local10
	shl	local11, #1
	add	local11, local10
	shl	local11, #2
	sub	objptr, ##1536
	add	local11, objptr
	add	local11, #8
	wrlong	local07, local11
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##38012
LR__0804
'   if lparts(ct).token <>token_comma andalso lparts(ct).token <>token_semicolon andalso lparts(ct).token <>token_end then return 22
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #17 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0805
	add	objptr, ##28228
	rdlong	local08, objptr
	shl	local08, #3
	sub	objptr, ##1080
	add	local08, objptr
	add	local08, #4
	rdlong	local08, local08
	cmp	local08, #18 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0805
	add	objptr, ##28228
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local11, local11
	cmp	local11, #510 wz
	sub	objptr, ##27148
 if_ne	mov	result1, #22
 if_ne	jmp	#LR__0807
LR__0805
	add	objptr, ##28228
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local08, local04
	cmp	local08, #510 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0806
	add	objptr, ##28228
	rdlong	local11, objptr
	add	objptr, ##7196
	rdlong	local10, objptr
	sub	objptr, ##35424
	cmps	local11, local10 wc
 if_b	jmp	#LR__0801
LR__0806
' return 0
	mov	result1, #0
LR__0807
	mov	ptra, fp
	call	#popregs_
_compile_print_ret
	ret

' 
' '----- compile 'if' command. Gets the linenum as it can call compile_immediate() and compile_immediate_assign()
' 
' function compile_if(aline as ulong) as ulong  
_compile_if
	mov	COUNT_, #9
	call	#pushregs_
_compile_if_enter
	mov	local04, arg01
' return expr()
	call	#_expr
	add	objptr, ##28228
	rdlong	arg02, objptr
	mov	local05, arg02
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local05, local05
	add	arg02, #1
	add	objptr, ##1080
	wrlong	arg02, objptr
	sub	objptr, ##28228
' 
' err=compile_fun_1p()
' cmd=lparts(ct).token : ct+=1 : if cmd<>token_then then return 52
	cmp	local05, #91 wz
 if_ne	mov	result1, #52
 if_ne	jmp	#LR__0812
	mov	local03, #88
	mov	local06, local01
	mov	local07, local02
	mov	arg02, local03
	add	objptr, ##38012
	rdlong	arg01, objptr
	mov	local08, arg01
	shl	local08, #1
	add	local08, arg01
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	wrlong	local06, local08
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	arg01, local06
	shl	arg01, #1
	add	arg01, local06
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	add	arg01, #4
	wrlong	local07, arg01
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	arg01, local06
	shl	arg01, #1
	add	arg01, local06
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	add	arg01, #8
	wrlong	arg02, arg01
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
' t1.result_type=token_if : compiledline(lineptr)=t1:  lineptr+=1
' if isassign(lparts(ct+1).part$) then err=compile_immediate_assign(5) else err=compile_immediate(5,aline)
	sub	objptr, ##9784
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	sub	objptr, ##27148
' 
' select case s
	mov	arg02, ##@LR__5331
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0810
	mov	arg01, #5
	call	#_compile_immediate_assign
	mov	local09, result1
	jmp	#LR__0811
LR__0810
	mov	arg01, #5
	mov	arg02, local04
	call	#_compile_immediate
	mov	local09, result1
LR__0811
' return err
	mov	result1, local09
LR__0812
	mov	ptra, fp
	call	#popregs_
_compile_if_ret
	ret

' 
' '----- compile 'else' command. Gets the linenum as it can call compile_immediate() and compile_immediate_assign()
' 
' function compile_else(aline as ulong) as ulong  
_compile_else
	mov	COUNT_, #7
	call	#pushregs_
_compile_else_enter
	mov	local04, arg01
	mov	local03, #90
	mov	local05, local01
	mov	local06, local02
	mov	local01, local03
	add	objptr, ##38012
	rdlong	arg02, objptr
	mov	arg01, arg02
	shl	arg01, #1
	add	arg01, arg02
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	wrlong	local05, arg01
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	arg02, local05
	shl	arg02, #1
	add	arg02, local05
	shl	arg02, #2
	sub	objptr, ##1536
	add	arg02, objptr
	add	arg02, #4
	wrlong	local06, arg02
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #8
	wrlong	local01, local05
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
' t1.result_type=token_else : compiledline(lineptr)=t1:  lineptr+=1
' if isassign(lparts(ct+1).part$) then err=compile_immediate_assign(5) else err=compile_immediate(5,aline)
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	rdlong	arg01, local06
	sub	objptr, ##27148
' 
' select case s
	mov	arg02, ##@LR__5331
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0820
	mov	arg01, #5
	call	#_compile_immediate_assign
	mov	local07, result1
	jmp	#LR__0821
LR__0820
	mov	arg01, #5
	mov	arg02, local04
	call	#_compile_immediate
	mov	local07, result1
LR__0821
' return err
	mov	result1, local07
	mov	ptra, fp
	call	#popregs_
_compile_else_ret
	ret

' 
' '----- compile 'dim' command. Also it allocates the psram for an aray from the top of the memory
' 
' function compile_dim() as ulong  
_compile_dim
	mov	COUNT_, #17
	call	#pushregs_
	mov	local01, #1
	mov	local02, #1
	mov	local03, #1
' 
' dims(0)=1: dims(1)=1: dims(2)=1
' if isname(lparts(ct).part$) then 
	add	objptr, ##28228
	rdlong	arg04, objptr
	shl	arg04, #3
	sub	objptr, ##1080
	add	arg04, objptr
	rdlong	arg01, arg04
	sub	objptr, ##27148
	call	#_isname
	cmp	result1, #0 wz
 if_e	jmp	#LR__0853
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	local05, local04
	neg	local06, #1
'   varname2$=lparts(ct).part$ 
'   j=-1
'   if varnum>0 then
	sub	objptr, #4
	rdlong	local07, objptr
	sub	objptr, ##27144
	cmps	local07, #1 wc
 if_b	jmp	#LR__0832
'     for i=0 to varnum-1
	mov	local08, #0
	add	objptr, ##27144
	rdlong	local09, objptr
	sub	objptr, ##27144
LR__0830
	cmps	local08, local09 wc
 if_ae	jmp	#LR__0831
'       if variables(i).name=varname2$ then j=i : exit
	mov	local04, local08
	shl	local04, #4
	add	objptr, ##10744
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, local05
	sub	objptr, ##10744
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local06, local08
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0830
LR__0831
LR__0832
'   if j=-1 then j=varnum else print "Dim: at line ";linenum;": warning: the variable existed."
	cmp	local06, ##-1 wz
 if_e	add	objptr, ##27144
 if_e	rdlong	local06, objptr
 if_e	sub	objptr, ##27144
 if_e	jmp	#LR__0833
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5574
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##41924
	rdlong	arg02, objptr
	sub	objptr, ##41924
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg02, ##@LR__5575
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__0833
'   if lparts(ct+1).part$ <>"(" andalso lparts(ct+1).part$<>"as" then return 43
	add	objptr, ##28228
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, ##@LR__5576
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0834
	add	objptr, ##28228
	rdlong	local09, objptr
	add	local09, #1
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	rdlong	arg01, local09
	mov	arg02, ##@LR__5577
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #43
 if_ne	jmp	#LR__0855
LR__0834
'   if lparts(ct+1).part$ = "as" then l=ct+1: goto 1350	' allocate a typed array
	add	objptr, ##28228
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, ##@LR__5578
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##28228
 if_e	rdlong	local10, objptr
 if_e	sub	objptr, ##28228
 if_e	add	local10, #1
 if_e	jmp	#LR__0839
	add	objptr, ##28228
	rdlong	local10, objptr
	sub	objptr, ##28228
	add	local10, #2
	mov	local11, #0
'   l=ct+2 : m=0 : do
LR__0835
'   if isdec(lparts(l).part$) then 
	mov	local04, local10
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	rdlong	arg01, local04
	sub	objptr, ##27148
	call	#_isdec
	cmp	result1, #0 wz
 if_e	jmp	#LR__0836
	mov	local12, local11
	add	local12, #local01
	mov	local09, local10
	shl	local09, #3
	add	objptr, ##27148
	add	local09, objptr
	rdlong	arg01, local09
	mov	arg02, #0
	sub	objptr, ##27148
	call	#__system____builtin_atoi
	mov	local13, result1
	'.live	local13
	'.live	local12
	altd	local12, #0
	mov	local12, local13
	add	local11, #1
	jmp	#LR__0837
LR__0836
'     return(17)
	mov	result1, #17
	jmp	#LR__0855
LR__0837
'   if (lparts(l+1).part$<>"," andalso lparts(l+1).part$<>")" ) then return 44 
	mov	local04, local10
	add	local04, #1
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__5579
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0838
	mov	local13, local10
	add	local13, #1
	shl	local13, #3
	add	objptr, ##27148
	add	local13, objptr
	rdlong	arg01, local13
	mov	arg02, ##@LR__5580
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #44
 if_ne	jmp	#LR__0855
LR__0838
	add	local10, #2
	mov	local04, local10
	sub	local04, #1
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__5581
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	cmps	local11, #3 wc
 if_c_and_nz	jmp	#LR__0835
'   if m>3 then return 45
	cmps	local11, #4 wc
 if_ae	mov	result1, #45
 if_ae	jmp	#LR__0855
	mov	local14, #256
	mov	local15, #12
LR__0839
'   arraytype=array_no_type : esize=12
' 1350 
'   if lparts(l).part$="as" then
	mov	local04, local10
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__5582
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0854
'     select case lparts(l+1).part$
	mov	local12, local10
	add	local12, #1
	shl	local12, #3
	add	objptr, ##27148
	add	local12, objptr
	rdlong	local16, local12
	mov	arg02, ##@LR__5583
	mov	arg01, local16
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0840
	mov	arg02, ##@LR__5584
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0841
	mov	arg02, ##@LR__5585
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0842
	mov	arg02, ##@LR__5586
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0843
	mov	arg02, ##@LR__5587
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0844
	mov	arg02, ##@LR__5588
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0845
	mov	arg02, ##@LR__5589
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0846
	mov	arg02, ##@LR__5590
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0847
	mov	arg02, ##@LR__5591
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0848
	mov	arg02, ##@LR__5592
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0849
	mov	arg02, ##@LR__5593
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0850
	mov	arg02, ##@LR__5594
	mov	arg01, local16
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0851
	jmp	#LR__0852
LR__0840
	mov	local14, #257
	mov	local15, #1
	jmp	#LR__0854
LR__0841
	mov	local14, #258
	mov	local15, #1
	jmp	#LR__0854
LR__0842
	mov	local14, #259
	mov	local15, #2
	jmp	#LR__0854
LR__0843
	mov	local14, #260
	mov	local15, #2
	jmp	#LR__0854
LR__0844
	mov	local14, #261
	mov	local15, #4
	jmp	#LR__0854
LR__0845
	mov	local14, #261
	mov	local15, #4
	jmp	#LR__0854
LR__0846
	mov	local14, #262
	mov	local15, #4
	jmp	#LR__0854
LR__0847
	mov	local14, #263
	mov	local15, #8
	jmp	#LR__0854
LR__0848
	mov	local14, #264
	mov	local15, #8
	jmp	#LR__0854
LR__0849
	mov	local14, #265
	mov	local15, #4
	jmp	#LR__0854
LR__0850
	mov	local14, #266
	mov	local15, #8
	jmp	#LR__0854
LR__0851
	mov	local14, #267
	mov	local15, #4
	jmp	#LR__0854
LR__0852
	mov	result1, #47
	jmp	#LR__0855
LR__0853
'   return 46
	mov	result1, #46
	jmp	#LR__0855
LR__0854
	qmul	local15, local01
	getqx	local07
	qmul	local07, local02
	getqx	local16
	qmul	local16, local03
	add	objptr, ##41900
	rdlong	local17, objptr
	mov	arg02, local14
	getqx	local16
	sub	local17, local16
	sub	local17, #16
	andn	local17, #15
	wrlong	local17, objptr
	sub	objptr, ##41900
	mov	arg01, local17
	call	#_psdpoke
	mov	arg01, local17
	add	arg01, #2
	mov	arg02, local15
	call	#_psdpoke
	mov	arg01, local17
	add	arg01, #4
	mov	arg02, local01
	call	#_pslpoke
	mov	arg01, local17
	add	arg01, #8
	mov	arg02, local02
	call	#_pslpoke
	mov	arg01, local17
	add	arg01, #12
	mov	arg02, local03
	call	#_pslpoke
	mov	local12, local06
	shl	local12, #4
	add	objptr, ##10744
	add	local12, objptr
	wrlong	local05, local12
	mov	local12, local06
	shl	local12, #4
	add	local12, objptr
	add	local12, #4
	wrlong	local17, local12
	mov	local12, local06
	shl	local12, #4
	add	local12, objptr
	add	local12, #12
	wrlong	local14, local12
' memtop=arrayptr
' psdpoke arrayptr,arraytype 
' psdpoke arrayptr+2,esize 
' pslpoke arrayptr+4,dims(0)
' pslpoke arrayptr+8,dims(1)
' pslpoke arrayptr+12,dims(2)
' variables(j).name=varname2$
' variables(j).value.uresult=arrayptr
' variables(j).vartype=arraytype
' if j=varnum then varnum+=1
	add	objptr, ##16400
	rdlong	local07, objptr
	sub	objptr, ##27144
	cmp	local06, local07 wz
 if_e	add	objptr, ##27144
 if_e	rdlong	local07, objptr
 if_e	add	local07, #1
 if_e	wrlong	local07, objptr
 if_e	sub	objptr, ##27144
' return 0
	mov	result1, #0
LR__0855
	mov	ptra, fp
	call	#popregs_
_compile_dim_ret
	ret

' 
' '----- compile 'for' command. 
' 
' function compile_for() as ulong  
_compile_for
	mov	COUNT_, #5
	call	#pushregs_
' 
' if isassign(lparts(ct+1).part$) then compile_immediate_assign(5) else return 32
	add	objptr, ##28228
	rdlong	arg02, objptr
	add	arg02, #1
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	sub	objptr, ##27148
' 
' select case s
	mov	arg02, ##@LR__5331
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #27
 if_ne	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__0860
	mov	arg01, #5
	call	#_compile_immediate_assign
	jmp	#LR__0861
LR__0860
	mov	result1, #32
	jmp	#LR__0865
LR__0861
	add	objptr, ##38012
	rdlong	arg02, objptr
	mov	arg01, arg02
	sub	arg01, #1
	mov	local04, arg01
	shl	local04, #1
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	rdlong	local01, local04
	add	local04, #4
	rdlong	local04, local04
	sub	arg02, #1
	mov	arg01, arg02
	shl	arg01, #1
	add	arg01, arg02
	shl	arg01, #2
	add	arg01, objptr
	add	arg01, #8
	rdlong	arg02, arg01
	mov	local02, local04
	mov	local03, arg02
' t1=compiledline(lineptr-1): if t1.result_type<>fun_assign  then  return 34'		' after this we should have fun_assign_i or fun_assign_u with var# as uresult.
	cmp	local03, #23 wz
	sub	objptr, ##36476
 if_ne	mov	result1, #34
 if_ne	jmp	#LR__0865
	mov	local05, local01
' varnum=t1.result.uresult
' if lparts(ct).part$<>"to" then return 33
	add	objptr, ##28228
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	rdlong	arg01, local01
	mov	arg02, ##@LR__5595
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	mov	result1, #33
 if_ne	jmp	#LR__0865
	add	objptr, ##28228
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##28228
	call	#_expr
' ct+=1
' expr()  										' there is "to" value pushed on the stack
' if lparts(ct).part$="step" orelse lparts(ct).part$="s." then
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__5596
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__0862
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, ##@LR__5597
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0863
LR__0862
	add	objptr, ##28228
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##28228
	call	#_expr
	jmp	#LR__0864
LR__0863
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local04, local01
	shl	local04, #1
	add	local04, local01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#28, local04
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local04, local01
	shl	local04, #1
	add	local04, local01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	#1, local04
	add	objptr, ##1536
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
	sub	objptr, ##38012
LR__0864
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local04, local01
	shl	local04, #1
	add	local04, local01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#28, local04
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local04, local01
	shl	local04, #1
	add	local04, local01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	local05, local04
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	mov	local01, local05
	shl	local01, #1
	add	local01, local05
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #8
	wrlong	#74, local01
	add	objptr, ##1536
	rdlong	local05, objptr
	mov	local01, local05
	shl	local01, #1
	add	local01, local05
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	wrlong	#0, local01
	add	objptr, ##1536
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	sub	objptr, ##38012
' compiledline(lineptr).result_type=result_int : compiledline(lineptr).result.iresult=varnum :lineptr+=1
' compiledline(lineptr).result_type=token_for : compiledline(lineptr).result.iresult=0 :lineptr+=1
' return 0
	mov	result1, #0
LR__0865
	mov	ptra, fp
	call	#popregs_
_compile_for_ret
	ret

' 
' '----- compile 'next' command. 
' 
' function compile_next() as ulong
_compile_next
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, ##28228
	rdlong	arg02, objptr
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	local01, arg02
' 
' varname$=lparts(ct).part$ 
' if varnum=0 then return 35
	sub	objptr, #4
	rdlong	arg02, objptr wz
	sub	objptr, ##27144
 if_e	mov	result1, #35
 if_e	jmp	#LR__0872
	neg	local02, #1
' j=-1
' for i=0 to varnum-1
	mov	local03, #0
	add	objptr, ##27144
	rdlong	local04, objptr
	sub	objptr, ##27144
LR__0870
	cmp	local03, local04 wc
 if_ae	jmp	#LR__0871
'   if variables(i).name=varname$ then j=i : exit
	mov	arg02, local03
	shl	arg02, #4
	add	objptr, ##10744
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, local01
	sub	objptr, ##10744
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local02, local03
 if_ne	add	local03, #1
 if_ne	jmp	#LR__0870
LR__0871
' if j=-1 then return 35
	cmp	local02, ##-1 wz
 if_e	mov	result1, #35
 if_e	jmp	#LR__0872
	add	objptr, ##38012
	rdlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	add	local03, #8
	wrlong	#28, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	wrlong	local02, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	add	local03, #8
	wrlong	#75, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	mov	local03, local04
	shl	local03, #1
	add	local03, local04
	shl	local03, #2
	sub	objptr, ##1536
	add	local03, objptr
	wrlong	#0, local03
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##38012
' compiledline(lineptr).result_type=result_int : compiledline(lineptr).result.iresult=j :lineptr+=1
' compiledline(lineptr).result_type=token_next : compiledline(lineptr).result.iresult=0 :lineptr+=1
' return 0
	mov	result1, #0
LR__0872
	mov	ptra, fp
	call	#popregs_
_compile_next_ret
	ret

' 
' '----- compile 'gosub' command. Gosub is "goto" that saves the return address, so add token_gosub, then compile goto
' 
' function compile_gosub() as ulong
_compile_gosub
	mov	COUNT_, #2
	call	#pushregs_
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	local02, #8
	wrlong	#169, local02
	add	objptr, ##1536
	rdlong	local02, objptr
	add	local02, #1
	wrlong	local02, objptr
	sub	objptr, ##38012
	call	#_compile_goto
' compiledline(lineptr).result_type=token_gosub
' lineptr+=1
' err=compile_goto()
' return err
	mov	ptra, fp
	call	#popregs_
_compile_gosub_ret
	ret

' 
' '----- compile 'goto' 
' 
' function compile_goto() as ulong
_compile_goto
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #52
' if lparts(ct).token=token_decimal andalso lparts(ct+1).token=token_end then 	' we have a goto to a constant
	add	objptr, ##28228
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg03, arg03
	cmp	arg03, ##512 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0885
	add	objptr, ##28228
	rdlong	arg03, objptr
	add	arg03, #1
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg03, arg03
	cmp	arg03, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0885
	add	objptr, ##28228
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	mov	arg02, #0
	sub	objptr, ##27148
	call	#__system____builtin_atoi
	add	fp, #4
	wrlong	result1, fp
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	local02, #8
	wrlong	#78, local02
	add	objptr, ##1548
	rdlong	local03, objptr
	sub	objptr, ##38024
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #8
'   gotoline=val%(lparts(ct).part$) 
'   compiledline(lineptr).result_type=token_fast_goto
'   gotoptr=programstart 							    	' now try to find a pointer to goto
'   do
LR__0880
	add	fp, #16
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	mov	arg03, #24
	add	objptr, ##5836
	call	#_psram_spin2_read1
	sub	objptr, ##5836
'     psram.read1(varptr(gotoheader),gotoptr,24)  : 
'     if gotoheader(0)<>$FFFFFFFF then
	add	fp, #16
	rdlong	local03, fp
	sub	fp, #16
	cmp	local03, ##-1 wz
 if_e	jmp	#LR__0881
	add	fp, #8
	rdlong	local03, fp
	add	fp, #4
	wrlong	local03, fp
	add	fp, #24
	rdlong	local03, fp
	sub	fp, #28
	wrlong	local03, fp
	sub	fp, #8
LR__0881
	add	fp, #36
	rdlong	local03, fp
	sub	fp, #36
	cmp	local03, ##2147483647 wz
 if_ne	add	fp, #16
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #16
 if_ne	cmp	local01, ##-1 wz
 if_e	jmp	#LR__0882
	add	fp, #16
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local02, fp
	sub	fp, #4
	cmp	local03, local02 wz
 if_ne	jmp	#LR__0880
LR__0882
'   if gotoheader(0)=gotoline then
	add	fp, #16
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #4
	cmp	local03, local01 wz
 if_ne	jmp	#LR__0883
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, local02
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	sub	fp, #8
	rdlong	local03, fp
	sub	fp, #4
	add	local02, #4
	wrlong	local03, local02
	sub	objptr, ##36476
	jmp	#LR__0884
LR__0883
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	wrlong	##-2147483648, local02
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local02, #4
	wrlong	local03, local02
	add	objptr, ##1536
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	local02, #8
	wrlong	#83, local02
	sub	objptr, ##36476
LR__0884
	add	objptr, ##38012
	rdlong	local03, objptr
	add	local03, #1
	wrlong	local03, objptr
	sub	objptr, ##38012
	jmp	#LR__0886
LR__0885
	call	#_expr
	add	fp, #48
	wrlong	#79, fp
	sub	fp, #8
	wrlong	#0, fp
	add	fp, #4
	rdlong	local03, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #48
	add	objptr, ##38012
	rdlong	local02, objptr
	mov	arg03, local02
	shl	arg03, #1
	add	arg03, local02
	shl	arg03, #2
	sub	objptr, ##1536
	add	arg03, objptr
	wrlong	#0, arg03
	add	objptr, ##1536
	rdlong	local02, objptr
	mov	arg03, local02
	shl	arg03, #1
	add	arg03, local02
	shl	arg03, #2
	sub	objptr, ##1536
	add	arg03, objptr
	add	arg03, #4
	wrlong	local03, arg03
	add	objptr, ##1536
	rdlong	local03, objptr
	mov	local02, local03
	shl	local02, #1
	add	local02, local03
	shl	local02, #2
	sub	objptr, ##1536
	add	local02, objptr
	add	local02, #8
	wrlong	local01, local02
	add	objptr, ##1536
	rdlong	local03, objptr
	add	local03, #1
	wrlong	local03, objptr
	sub	objptr, ##38012
LR__0886
' return 0
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_compile_goto_ret
	ret

' 
' '----- compile 'on' (on..goto, on..gosub) 
' 
' function compile_on() as ulong
_compile_on
	mov	COUNT_, #4
	call	#pushregs_
	call	#_expr
	mov	local01, #0
	add	objptr, ##38012
	rdlong	arg02, objptr
	mov	arg01, arg02
	shl	arg01, #1
	add	arg01, arg02
	shl	arg01, #2
	sub	objptr, ##1536
	add	arg01, objptr
	add	arg01, #8
	wrlong	#193, arg01
	add	objptr, ##1536
	rdlong	arg02, objptr
	mov	local02, arg02
	add	arg02, #1
	wrlong	arg02, objptr
' expr()
' 'print lparts(ct).part$ 'ok
' numpar=0
' compiledline(lineptr).result_type=token_on : onlineptr=lineptr : lineptr+=1' we need onlineptr to save param# there
' if lparts(ct).part$="goto" then
	sub	objptr, ##9784
	rdlong	arg02, objptr
	shl	arg02, #3
	sub	objptr, ##1080
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, ##@LR__5598
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0895
	add	objptr, ##28228
	rdlong	local03, objptr
	sub	objptr, ##28228
	add	local03, #1
'   i=ct+1
'   do
LR__0890
'     if lparts(i).token=token_decimal then
	mov	result1, local03
	shl	result1, #3
	add	objptr, ##27148
	add	result1, objptr
	add	result1, #4
	rdlong	result1, result1
	cmp	result1, ##512 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0891
	add	objptr, ##38012
	rdlong	result1, objptr
	mov	arg02, result1
	shl	arg02, #1
	add	arg02, result1
	shl	arg02, #2
	sub	objptr, ##1536
	add	arg02, objptr
	wrlong	##-2147483648, arg02
	add	objptr, ##1536
	rdlong	arg02, objptr
	mov	local04, arg02
	shl	local04, #1
	add	local04, arg02
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	mov	arg02, local03
	shl	arg02, #3
	sub	objptr, ##9328
	add	arg02, objptr
	rdlong	arg01, arg02
	mov	arg02, #0
	sub	objptr, ##27148
	call	#__system____builtin_atoi
	add	local04, #4
	wrlong	result1, local04
	add	objptr, ##38012
	rdlong	arg02, objptr
	mov	local04, arg02
	shl	local04, #1
	add	local04, arg02
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#83, local04
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##38012
	add	local01, #1
	jmp	#LR__0892
LR__0891
'       return 17
	mov	result1, #17
	jmp	#LR__0905
LR__0892
	add	local03, #1
'     i+=1
'     if lparts(i).token<>token_comma andalso lparts(i).token<>token_end then return 21
	mov	local04, local03
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #17 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0893
	mov	local04, local03
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #510 wz
	sub	objptr, ##27148
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0905
LR__0893
'     if lparts(i).token=token_end then exit loop
	mov	local04, local03
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #510 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0894
	add	local03, #1
	mov	local04, local03
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0890
LR__0894
	mov	local04, local02
	shl	local04, #1
	add	local04, local02
	shl	local04, #2
	add	objptr, ##36476
	add	local04, objptr
	add	local04, #4
	wrlong	#1, local04
	sub	objptr, ##36476
LR__0895
' 
' if lparts(ct).part$="gosub" then
	add	objptr, ##28228
	rdlong	local03, objptr
	shl	local03, #3
	sub	objptr, ##1080
	add	local03, objptr
	rdlong	arg01, local03
	mov	arg02, ##@LR__5599
	sub	objptr, ##27148
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0901
	add	objptr, ##28228
	rdlong	local03, objptr
	sub	objptr, ##28228
	add	local03, #1
'   i=ct+1
'   do
LR__0896
'     if lparts(i).token=token_decimal then
	mov	local04, local03
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, ##512 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0897
	add	objptr, ##38012
	rdlong	result1, objptr
	mov	local04, result1
	shl	local04, #1
	add	local04, result1
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#169, local04
	add	objptr, ##1536
	rdlong	result1, objptr
	add	result1, #1
	wrlong	result1, objptr
	mov	local04, result1
	shl	local04, #1
	add	local04, result1
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	##-2147483648, local04
	add	objptr, ##1536
	rdlong	result1, objptr
	mov	local04, result1
	shl	local04, #1
	add	local04, result1
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	mov	arg01, local03
	shl	arg01, #3
	sub	objptr, ##9328
	add	arg01, objptr
	rdlong	arg01, arg01
	mov	arg02, #0
	sub	objptr, ##27148
	call	#__system____builtin_atoi
	add	local04, #4
	wrlong	result1, local04
	add	objptr, ##38012
	rdlong	arg01, objptr
	mov	local04, arg01
	shl	local04, #1
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#83, local04
	add	objptr, ##1536
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	add	local01, #1
	mov	local04, arg01
	shl	local04, #1
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #8
	wrlong	#45, local04
	add	objptr, ##1536
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##38012
	jmp	#LR__0898
LR__0897
'       return 17
	mov	result1, #17
	jmp	#LR__0905
LR__0898
	add	local03, #1
'     i+=1
'     if lparts(i).token<>token_comma andalso lparts(i).token<>token_end then return 21
	mov	local04, local03
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #17 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0899
	mov	local04, local03
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #510 wz
	sub	objptr, ##27148
 if_ne	mov	result1, #21
 if_ne	jmp	#LR__0905
LR__0899
'     if lparts(i).token=token_end then exit loop
	mov	local04, local03
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #510 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0900
	add	local03, #1
	mov	local04, local03
	shl	local04, #3
	add	objptr, ##27148
	add	local04, objptr
	add	local04, #4
	rdlong	local04, local04
	cmp	local04, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0896
LR__0900
	mov	local04, local02
	shl	local04, #1
	add	local04, local02
	shl	local04, #2
	add	objptr, ##36476
	add	local04, objptr
	add	local04, #4
	wrlong	#3, local04
	sub	objptr, ##36476
LR__0901
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #2
	add	objptr, ##36476
	add	local03, objptr
	wrlong	local01, local03
' compiledline(onlineptr).result.uresult=numpar
' for i=lineptr to onlineptr step -1 : if compiledline(i).result_type=token_skip then compiledline(i).result.uresult=lineptr-2
	add	objptr, ##1536
	rdlong	local03, objptr
	sub	objptr, ##38012
	callpa	#(@LR__0904-@LR__0902)>>2,fcache_load_ptr_
LR__0902
	mov	local04, local03
	shl	local04, #1
	add	local04, local03
	shl	local04, #2
	add	objptr, ##36476
	add	local04, objptr
	add	local04, #8
	rdlong	local04, local04
	cmp	local04, #45 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__0903
	mov	local04, local03
	shl	local04, #1
	add	local04, local03
	shl	local04, #2
	add	objptr, ##36476
	add	local04, objptr
	add	objptr, ##1536
	rdlong	local01, objptr
	sub	objptr, ##38012
	sub	local01, #2
	wrlong	local01, local04
LR__0903
	sub	local03, #1
	cmps	local03, local02 wc
 if_ae	jmp	#LR__0902
LR__0904
' return 0
	mov	result1, #0
LR__0905
	mov	ptra, fp
	call	#popregs_
_compile_on_ret
	ret

' 
' '----- A helper for compile_input and compile_read
'  
' function getaddr() as ulong
_getaddr
	mov	COUNT_, #11
	call	#pushregs_
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	rdlong	local05, local04
	neg	local06, #1
' 
' varname$=lparts(ct).part$
' j=-1
' 
' for i=0 to varnum-1
	mov	local07, #0
	sub	objptr, #4
	rdlong	local08, objptr
	sub	objptr, ##27144
LR__0910
	cmps	local07, local08 wc
 if_ae	jmp	#LR__0911
'   if variables(i).name=varname$ then j=i : exit
	mov	local04, local07
	shl	local04, #4
	add	objptr, ##10744
	add	local04, objptr
	rdlong	arg01, local04
	mov	arg02, local05
	sub	objptr, ##10744
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local06, local07
 if_ne	add	local07, #1
 if_ne	jmp	#LR__0910
LR__0911
' if  j=-1 andalso varnum<maxvars then   
	cmp	local06, ##-1 wz
 if_ne	jmp	#LR__0912
	add	objptr, ##27144
	rdlong	local08, objptr
	sub	objptr, ##27144
	cmps	local08, ##1024 wc
 if_ae	jmp	#LR__0912
	add	objptr, ##27144
	rdlong	local04, objptr
	shl	local04, #4
	sub	objptr, ##16400
	add	local04, objptr
	wrlong	local05, local04
	add	objptr, ##16400
	rdlong	local04, objptr
	shl	local04, #4
	sub	objptr, ##16400
	add	local04, objptr
	add	local04, #4
	wrlong	#0, local04
	add	objptr, ##16400
	rdlong	local04, objptr
	shl	local04, #4
	sub	objptr, ##16400
	add	local04, objptr
	add	local04, #12
	wrlong	#28, local04
	add	objptr, ##16400
	rdlong	local08, objptr
	mov	local06, local08
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##27144
LR__0912
	mov	local08, #0
' numpar=0
' if lparts(ct+1).token=token_lpar then								' check if it is an array
	add	objptr, ##28228
	rdlong	local04, objptr
	add	local04, #1
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local07, local04
	cmp	local07, #21 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0917
	add	objptr, ##28228
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##28228
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__0913
	add	objptr, ##28228
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
'     ct+=1  											': print "In getfun, ct=",ct,"lparts(ct).token=",lparts(ct).token, "part$=",lparts(ct).part$
'     if lparts(ct).token=token_lpar then ct+=1 : err=expr() : ct+=1 else err=expr()
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local09, local04
	cmp	local09, #21 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0914
	add	objptr, ##28228
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##28228
	call	#_expr
	mov	local10, result1
	add	objptr, ##28228
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##28228
	jmp	#LR__0915
LR__0914
	call	#_expr
	mov	local10, result1
LR__0915
'     if err>0 then return err
	cmps	local10, #1 wc
 if_ae	mov	result1, local10
 if_ae	jmp	#LR__0918
	add	local08, #1
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local10, local04
	cmp	local10, #20 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0916
	add	objptr, ##28228
	rdlong	local10, objptr
	shl	local10, #3
	sub	objptr, ##1080
	add	local10, objptr
	add	local10, #4
	rdlong	local10, local10
	cmp	local10, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0913
LR__0916
'     if lparts(ct).token=token_end then return 14
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local10, local04
	cmp	local10, #510 wz
	sub	objptr, ##27148
 if_e	mov	result1, #14
 if_e	jmp	#LR__0918
LR__0917
	mov	local02, local08
	mov	local03, #18
	mov	local01, local06
	mov	local09, local01
	mov	local11, local02
	mov	local01, local03
	add	objptr, ##38012
	rdlong	local10, objptr
	mov	local08, local10
	shl	local08, #1
	add	local08, local10
	shl	local08, #2
	sub	objptr, ##1536
	add	local08, objptr
	wrlong	local09, local08
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local11, local09
	add	objptr, ##1536
	rdlong	local11, objptr
	mov	local10, local11
	shl	local10, #1
	add	local10, local11
	shl	local10, #2
	sub	objptr, ##1536
	add	local10, objptr
	add	local10, #8
	wrlong	local01, local10
	add	objptr, ##1536
	rdlong	local09, objptr
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##38012
' t2.result.twowords(1)=numpar
' t2.result_type=fun_getaddr:t2.result.twowords(0)=j
' compiledline(lineptr)=t2: lineptr+=1   ' if t2.result.uresult=-1, generate error
' return 0
	mov	result1, #0
LR__0918
	mov	ptra, fp
	call	#popregs_
_getaddr_ret
	ret

' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------------- 
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '------------------------------------------ The end of the precompiler  ----------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '
' '     			   	    COMPILE TIME EXPRESSION DECODER/EVALUATOR
' '
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' function expr() as ulong 
_expr
	mov	COUNT_, #7
	call	#pushregs_
_expr_enter
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' 
' op=lparts(ct).token : if op=token_end then t3.result.uresult=29 : t3.result_type=result_error : compiledline(lineptr)=t3 : lineptr+=1: return 29
	cmp	local05, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0920
	mov	local01, #29
	mov	local03, #255
	mov	local06, local01
	mov	local07, local02
	mov	local01, local03
	add	objptr, ##38012
	rdlong	local05, objptr
	mov	local04, local05
	shl	local04, #1
	add	local04, local05
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	local06, local04
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #4
	wrlong	local07, local05
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local01, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##38012
	mov	result1, #29
	jmp	#LR__0923
LR__0920
	mov	local01, #0
	call	#_addsub
' t3.result.uresult=0
' err=addsub()             			' call higher priority operator check. It will itself call muldiv, which then calls getval/getvar 
' if err>0 then return err
	cmp	result1, #1 wc
 if_ae	jmp	#LR__0923
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' op = lparts(ct).token				' Lowest priority : comparison operators
' do while (op = token_eq orelse op = token_gt orelse op = token_lt orelse op=token_ge orelse op=token_le orelse op=token_ne)
	sub	objptr, ##27148
LR__0921
	cmp	local05, #27 wz
 if_ne	cmp	local05, #15 wz
 if_ne	cmp	local05, #16 wz
 if_ne	cmp	local05, #39 wz
 if_ne	cmp	local05, #38 wz
 if_ne	cmp	local05, #42 wz
 if_ne	jmp	#LR__0922
	add	objptr, ##28228
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
	call	#_addsub
'   ct+=1
'   err=addsub() : if err>0 then return err
	cmp	result1, #1 wc
 if_ae	jmp	#LR__0923
	mov	local03, local05
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38012
	rdlong	local04, objptr
	mov	result1, local04
	shl	result1, #1
	add	result1, local04
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local06, result1
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local04, local06
	shl	local04, #1
	add	local04, local06
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local07, local04
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
	sub	objptr, ##27148
	jmp	#LR__0921
LR__0922
' return 0  
	mov	result1, #0
LR__0923
	mov	ptra, fp
	call	#popregs_
_expr_ret
	ret

' 
' ' Second level operators : add, sub, logic
' 
' function addsub() as ulong
_addsub
	mov	COUNT_, #7
	call	#pushregs_
_addsub_enter
	mov	local01, #0
	call	#_muldiv
' 
' t3.result.uresult=0
' err=muldiv() : if err>0 then return err           			 
	cmp	result1, #1 wc
 if_ae	jmp	#LR__0932
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' op = lparts(ct).token				 
' do while (op = token_plus orelse op = token_minus orelse op = token_and orelse op=token_or)
	sub	objptr, ##27148
LR__0930
	cmp	local05, #1 wz
 if_ne	cmp	local05, #2 wz
 if_ne	cmp	local05, #7 wz
 if_ne	cmp	local05, #3 wz
 if_ne	jmp	#LR__0931
	add	objptr, ##28228
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##28228
	call	#_muldiv
'   ct+=1
'   err=muldiv() : if err>0 then return err   
	cmp	result1, #1 wc
 if_ae	jmp	#LR__0932
	mov	local03, local05
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38012
	rdlong	local04, objptr
	mov	result1, local04
	shl	result1, #1
	add	result1, local04
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local06, result1
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local04, local06
	shl	local04, #1
	add	local04, local06
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local07, local04
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
	sub	objptr, ##27148
	jmp	#LR__0930
LR__0931
' return 0
	mov	result1, #0
LR__0932
	mov	ptra, fp
	call	#popregs_
_addsub_ret
	ret

' 
' ' Third level operators : mul,div,shift,power
' 
' function muldiv() as ulong
_muldiv
	mov	COUNT_, #7
	call	#pushregs_
_muldiv_enter
	mov	local01, #0
	call	#_getvalue
' 
' t3.result.uresult=0
' err=getvalue() : if err>0 then return err     
	cmp	result1, #1 wc
 if_ae	jmp	#LR__0942
	add	objptr, ##28228
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
' op = lparts(ct).token
' do while (op = token_mul orelse op = token_div orelse op = token_fdiv orelse op=token_mod orelse op=token_shl orelse op=token_shr orelse op=token_power)
	sub	objptr, ##27148
LR__0940
	cmp	local05, #5 wz
 if_ne	cmp	local05, #8 wz
 if_ne	cmp	local05, #6 wz
 if_ne	cmp	local05, #9 wz
 if_ne	cmp	local05, #10 wz
 if_ne	cmp	local05, #11 wz
 if_ne	cmp	local05, #12 wz
 if_ne	jmp	#LR__0941
	add	objptr, ##28228
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##28228
	call	#_getvalue
'   ct+=1
'   err=getvalue() :if err>0 then return err   
	cmp	result1, #1 wc
 if_ae	jmp	#LR__0942
	mov	local03, local05
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38012
	rdlong	local04, objptr
	mov	result1, local04
	shl	result1, #1
	add	result1, local04
	shl	result1, #2
	sub	objptr, ##1536
	add	result1, objptr
	wrlong	local06, result1
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local04, local06
	shl	local04, #1
	add	local04, local06
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	add	local04, #4
	wrlong	local07, local04
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local04, objptr
	shl	local04, #3
	sub	objptr, ##1080
	add	local04, objptr
	add	local04, #4
	rdlong	local05, local04
	sub	objptr, ##27148
	jmp	#LR__0940
LR__0941
' return 0
	mov	result1, #0
LR__0942
	mov	ptra, fp
	call	#popregs_
_muldiv_ret
	ret

' 
' ' Get a value for operations
' 
' function getvalue()  as ulong
_getvalue
	mov	COUNT_, #11
	call	#pushregs_
_getvalue_enter
	mov	local04, #1
	mov	local01, #0
	mov	local03, #29
	add	objptr, ##28228
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	add	arg03, #4
	rdlong	local05, arg03
' 
' m=1											' for negative numbers
' t1.result.uresult=0: t1.result_type=result_uint
' op=lparts(ct).token
' if op=token_minus then m=-1: ct+=1 : op=lparts(ct).token				' '-' operator found
	cmp	local05, #2 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0950
	neg	local04, #1
	add	objptr, ##28228
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local05, local05
	sub	objptr, ##27148
LR__0950
' select case op
	cmp	local05, ##512 wz
 if_e	jmp	#LR__0951
	cmp	local05, ##513 wz
 if_e	jmp	#LR__0954
	cmp	local05, ##514 wz
 if_e	jmp	#LR__0961
	cmp	local05, ##515 wz
 if_e	jmp	#LR__0964
	cmp	local05, #44 wz
 if_e	jmp	#LR__0969
	cmp	local05, ##516 wz
 if_e	jmp	#LR__0970
	cmp	local05, #21 wz
 if_e	jmp	#LR__0971
	jmp	#LR__0972
LR__0951
'     if m=1 then t1.result.uresult=m*val%(lparts(ct).part$): t1.result_type=result_int  
	cmp	local04, #1 wz
 if_ne	jmp	#LR__0952
	add	objptr, ##28228
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #0
	sub	objptr, ##27148
	call	#__system____builtin_atoi
	qmul	local04, result1
	getqx	local01
	mov	local03, #28
LR__0952
'     if m=-1 then t1.result.iresult=m*val%(lparts(ct).part$): t1.result_type=result_int 	' todo token_int64?
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0953
	add	objptr, ##28228
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, #0
	sub	objptr, ##27148
	call	#__system____builtin_atoi
	qmul	local04, result1
	getqx	local01
	mov	local03, #28
LR__0953
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local04, local01
	shl	local04, #1
	add	local04, local01
	shl	local04, #2
	sub	objptr, ##1536
	add	local04, objptr
	wrlong	local06, local04
	add	objptr, ##1536
	rdlong	local06, objptr
	mov	local01, local06
	shl	local01, #1
	add	local01, local06
	shl	local01, #2
	sub	objptr, ##1536
	add	local01, objptr
	add	local01, #4
	wrlong	local07, local01
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local05, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
	jmp	#LR__0973
LR__0954
'     if left$(lparts(ct).part$,1)="$" then lparts(ct).part$="&h"+right$(lparts(ct).part$,len(lparts(ct).part$)-1)
	add	objptr, ##28228
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	mov	arg02, #1
	sub	objptr, ##27148
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5600
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0957
	add	objptr, ##28228
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	mov	local05, ##@LR__5601
	shl	local07, #3
	add	local07, objptr
	rdlong	local07, local07
	add	objptr, ##1080
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	rdlong	arg01, local01
	sub	objptr, ##27148
	mov	local08, arg01
	callpa	#(@LR__0956-@LR__0955)>>2,fcache_load_ptr_
LR__0955
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0955
LR__0956
	sub	local08, arg01
	mov	arg02, local08
	sub	arg02, #1
	mov	arg01, local07
	call	#__system__Right_S
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___string_concat
	wrlong	result1, local06
LR__0957
'     if left$(lparts(ct).part$,1)="%" then lparts(ct).part$="&b"+right$(lparts(ct).part$,len(lparts(ct).part$)-1)
	add	objptr, ##28228
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	mov	arg02, #1
	sub	objptr, ##27148
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5602
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0960
	add	objptr, ##28228
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	mov	local05, ##@LR__5603
	shl	local07, #3
	add	local07, objptr
	rdlong	local07, local07
	add	objptr, ##1080
	rdlong	local01, objptr
	shl	local01, #3
	sub	objptr, ##1080
	add	local01, objptr
	rdlong	arg01, local01
	sub	objptr, ##27148
	mov	local08, arg01
	callpa	#(@LR__0959-@LR__0958)>>2,fcache_load_ptr_
LR__0958
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0958
LR__0959
	sub	local08, arg01
	mov	arg02, local08
	sub	arg02, #1
	mov	arg01, local07
	call	#__system__Right_S
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___string_concat
	wrlong	result1, local06
LR__0960
	add	objptr, ##28228
	rdlong	local06, objptr
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #0
	sub	objptr, ##27148
	call	#__system____builtin_atoi
	qmul	local04, result1
	add	objptr, ##38012
	rdlong	local06, objptr
	mov	local09, local06
	shl	local09, #1
	add	local09, local06
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	objptr, ##1536
	getqx	local01
	mov	local03, #28
	mov	local06, local01
	mov	local07, local02
	wrlong	local06, local09
	mov	local09, local03
	rdlong	local06, objptr
	mov	local05, local06
	shl	local05, #1
	add	local05, local06
	shl	local05, #2
	sub	objptr, ##1536
	add	local05, objptr
	add	local05, #4
	wrlong	local07, local05
	add	objptr, ##1536
	rdlong	local07, objptr
	mov	local06, local07
	shl	local06, #1
	add	local06, local07
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #8
	wrlong	local09, local06
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
	jmp	#LR__0973
LR__0961
'     if m=1 then t1.result.fresult=1.0*val(lparts(ct).part$): t1.result_type=result_float  
	cmp	local04, #1 wz
 if_ne	jmp	#LR__0962
	mov	local06, ##1065353216
	add	objptr, ##28228
	rdlong	local09, objptr
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	rdlong	arg01, local09
	sub	objptr, ##27148
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	mov	local01, result1
	mov	local03, #30
LR__0962
'     if m=-1 then t1.result.fresult=-1.0*val(lparts(ct).part$): t1.result_type=result_float
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0963
	mov	local06, ##-1082130432
	add	objptr, ##28228
	rdlong	local09, objptr
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	rdlong	arg01, local09
	sub	objptr, ##27148
	call	#__system____builtin_atof
	mov	arg02, result1
	mov	arg01, local06
	call	#__system___float_mul
	mov	local01, result1
	mov	local03, #30
LR__0963
	mov	local06, local01
	mov	local07, local02
	mov	local05, local03
	add	objptr, ##38012
	rdlong	local01, objptr
	mov	local09, local01
	shl	local09, #1
	add	local09, local01
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local06, local09
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local06, local09
	shl	local06, #1
	add	local06, local09
	shl	local06, #2
	sub	objptr, ##1536
	add	local06, objptr
	add	local06, #4
	wrlong	local07, local06
	add	objptr, ##1536
	rdlong	local09, objptr
	mov	local07, local09
	shl	local07, #1
	add	local07, local09
	shl	local07, #2
	sub	objptr, ##1536
	add	local07, objptr
	add	local07, #8
	wrlong	local05, local07
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
	jmp	#LR__0973
LR__0964
	add	objptr, ##28228
	rdlong	arg03, objptr
	shl	arg03, #3
	sub	objptr, ##1080
	add	arg03, objptr
	rdlong	arg01, arg03
	sub	objptr, ##27148
	mov	local08, arg01
	callpa	#(@LR__0966-@LR__0965)>>2,fcache_load_ptr_
LR__0965
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0965
LR__0966
	sub	local08, arg01
	mov	result1, local08
	add	objptr, ##41984
	wrlong	result1, objptr
	sub	objptr, #84
	rdlong	arg01, objptr
	sub	arg01, result1
	sub	arg01, #4
	andn	arg01, #3
	wrlong	arg01, objptr
	add	objptr, #84
	rdlong	arg02, objptr
	sub	objptr, ##41984
	call	#_pslpoke
'     pslpoke memtop,l
'     for i=1 to l : pspoke memtop+3+i, asc(mid$(lparts(ct).part$,i,1)) : next i
	mov	local10, #1
	add	objptr, ##41984
	rdlong	local11, objptr
	sub	objptr, ##41984
	add	local11, #1
LR__0967
	cmps	local10, local11 wc
 if_ae	jmp	#LR__0968
	add	objptr, ##41900
	rdlong	local07, objptr
	add	local07, #3
	add	local07, local10
	sub	objptr, ##13672
	rdlong	local09, objptr
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	rdlong	arg01, local09
	mov	arg02, local10
	mov	arg03, #1
	sub	objptr, ##27148
	call	#__system__Mid_S
	rdbyte	arg02, result1
	mov	arg01, local07
	call	#_pspoke
	add	local10, #1
	jmp	#LR__0967
LR__0968
	add	objptr, ##41900
	rdlong	local01, objptr
	mov	local03, #43
	mov	local06, local01
	mov	local07, local02
	mov	local11, local03
	sub	objptr, ##3888
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local06, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local07, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #8
	wrlong	local11, local09
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
	jmp	#LR__0973
LR__0969
	mov	local03, #44
	add	objptr, ##28228
	rdlong	local06, objptr
	shl	local06, #3
	sub	objptr, ##1080
	add	local06, objptr
	rdlong	arg01, local06
	mov	arg02, #0
	sub	objptr, ##27148
	call	#__system____builtin_atoi
	mov	local01, result1
	mov	local06, local01
	mov	local07, local02
	mov	local11, local03
	add	objptr, ##38012
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	wrlong	local06, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #4
	wrlong	local07, local09
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	shl	local09, #2
	sub	objptr, ##1536
	add	local09, objptr
	add	local09, #8
	wrlong	local11, local09
	add	objptr, ##1536
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##9784
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
	jmp	#LR__0973
LR__0970
	mov	arg01, local04
	call	#_getvar
	add	objptr, ##28228
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
'     err=getvar(m) : ct+=1 : if err>0 then return err 
	cmps	result1, #1 wc
 if_ae	jmp	#LR__0974
	jmp	#LR__0973
LR__0971
	add	objptr, ##28228
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
	call	#_expr
'     ct+=1
'     err=expr() : if err>0 then return err 
	cmps	result1, #1 wc
 if_ae	jmp	#LR__0974
'     if lparts(ct).token=token_rpar then ct+=1
	add	objptr, ##28228
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local11, local11
	cmp	local11, #20 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0973
	add	objptr, ##28228
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
	jmp	#LR__0973
LR__0972
	mov	arg01, local04
	call	#_getfun
	add	objptr, ##28228
	rdlong	local06, objptr
	add	local06, #1
	wrlong	local06, objptr
	sub	objptr, ##28228
'     err=getfun(m) : ct+=1 : if err>0 then return err 
	cmps	result1, #1 wc
 if_ae	jmp	#LR__0974
LR__0973
' return 0  
	mov	result1, #0
LR__0974
	mov	ptra, fp
	call	#popregs_
_getvalue_ret
	ret

' 
' ' Get a function result 
' 
' function getfun(m as integer) as ulong
_getfun
	mov	COUNT_, #15
	call	#pushregs_
_getfun_enter
	mov	local04, arg01
	add	objptr, ##28228
	rdlong	local05, objptr
	mov	local06, local05
	mov	local07, #0
' oldct=ct
' numpar=0
' if lparts(ct+1).token=token_lpar then
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local05, local05
	cmp	local05, #21 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0984
	add	objptr, ##28228
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##28228
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__0980
	add	objptr, ##28228
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
'     ct+=1  											': print "In getfun, ct=",ct,"lparts(ct).token=",lparts(ct).token, "part$=",lparts(ct).part$
'     if lparts(ct).token=token_lpar then ct+=1 : err=expr() : ct+=1 else err=expr()
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local08, local05
	cmp	local08, #21 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0981
	add	objptr, ##28228
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##28228
	call	#_expr
	mov	local09, result1
	add	objptr, ##28228
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##28228
	jmp	#LR__0982
LR__0981
	call	#_expr
	mov	local09, result1
LR__0982
'     if err>0 then return err
	cmp	local09, #1 wc
 if_ae	mov	result1, local09
 if_ae	jmp	#LR__0986
	add	local07, #1
	add	objptr, ##28228
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local09, local05
	cmp	local09, #20 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0983
	add	objptr, ##28228
	rdlong	local09, objptr
	shl	local09, #3
	sub	objptr, ##1080
	add	local09, objptr
	add	local09, #4
	rdlong	local09, local09
	cmp	local09, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0980
LR__0983
'   if lparts(ct).token=token_end then return 14
	add	objptr, ##28228
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local09, local05
	cmp	local09, #510 wz
	sub	objptr, ##27148
 if_e	mov	result1, #14
 if_e	jmp	#LR__0986
LR__0984
	mov	local01, local07
	shl	local06, #3
	add	objptr, ##27148
	add	local06, objptr
	add	local06, #4
	rdlong	local03, local06
	mov	local08, local01
	mov	local10, local02
	mov	local11, local03
	add	objptr, ##10864
	rdlong	local12, objptr
	mov	local13, local12
	shl	local13, #1
	add	local13, local12
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	wrlong	local08, local13
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local14, local08
	shl	local14, #1
	add	local14, local08
	shl	local14, #2
	sub	objptr, ##1536
	add	local14, objptr
	add	local14, #4
	wrlong	local10, local14
	add	objptr, ##1536
	rdlong	local08, objptr
	mov	local15, local08
	shl	local15, #1
	add	local15, local08
	shl	local15, #2
	sub	objptr, ##1536
	add	local15, objptr
	add	local15, #8
	wrlong	local11, local15
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##38012
' t2.result.uresult=numpar
' t2.result_type=lparts(oldct).token  ' todo here: expression lists..... 
' compiledline(lineptr)=t2: lineptr+=1   ' if t2.result.uresult=-1, generate error
' if m=-1 then t2.result_type=fun_negative: compiledline(lineptr)=t2: lineptr+=1
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0985
	mov	local03, #21
	mov	local08, local01
	mov	local10, local02
	mov	local11, local03
	add	objptr, ##38012
	rdlong	local12, objptr
	mov	local13, local12
	shl	local13, #1
	add	local13, local12
	shl	local13, #2
	sub	objptr, ##1536
	add	local13, objptr
	wrlong	local08, local13
	add	objptr, ##1536
	rdlong	local15, objptr
	mov	local14, local15
	shl	local14, #1
	add	local14, local15
	shl	local14, #2
	sub	objptr, ##1536
	add	local14, objptr
	add	local14, #4
	wrlong	local10, local14
	add	objptr, ##1536
	rdlong	local14, objptr
	mov	local15, local14
	shl	local15, #1
	add	local15, local14
	shl	local15, #2
	sub	objptr, ##1536
	add	local15, objptr
	add	local15, #8
	wrlong	local11, local15
	add	objptr, ##1536
	rdlong	local08, objptr
	add	local08, #1
	wrlong	local08, objptr
	sub	objptr, ##38012
LR__0985
' return 0
	mov	result1, #0
LR__0986
	mov	ptra, fp
	call	#popregs_
_getfun_ret
	ret

'   
'   
' function getvar(m as integer) as ulong
_getvar
	mov	COUNT_, #17
	call	#pushregs_
_getvar_enter
	mov	local04, arg01
	add	objptr, ##28228
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	rdlong	local06, local05
	neg	local07, #1
' 
' varname$=lparts(ct).part$
' j=-1
' 
' for i=0 to varnum-1
	mov	local08, #0
	sub	objptr, #4
	rdlong	local09, objptr
	sub	objptr, ##27144
LR__0990
	cmps	local08, local09 wc
 if_ae	jmp	#LR__0991
'   if variables(i).name=varname$ then j=i : exit
	mov	local05, local08
	shl	local05, #4
	add	objptr, ##10744
	add	local05, objptr
	rdlong	arg01, local05
	mov	arg02, local06
	sub	objptr, ##10744
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local07, local08
 if_ne	add	local08, #1
 if_ne	jmp	#LR__0990
LR__0991
' if  j=-1 andalso varnum<maxvars then   
	cmp	local07, ##-1 wz
 if_ne	jmp	#LR__0992
	add	objptr, ##27144
	rdlong	local09, objptr
	sub	objptr, ##27144
	cmps	local09, ##1024 wc
 if_ae	jmp	#LR__0992
	add	objptr, ##27144
	rdlong	local05, objptr
	shl	local05, #4
	sub	objptr, ##16400
	add	local05, objptr
	wrlong	local06, local05
	add	objptr, ##16400
	rdlong	local05, objptr
	shl	local05, #4
	sub	objptr, ##16400
	add	local05, objptr
	add	local05, #4
	wrlong	#0, local05
	add	objptr, ##16400
	rdlong	local05, objptr
	shl	local05, #4
	sub	objptr, ##16400
	add	local05, objptr
	add	local05, #12
	wrlong	#28, local05
	add	objptr, ##16400
	rdlong	local09, objptr
	mov	local07, local09
	add	local09, #1
	wrlong	local09, objptr
	sub	objptr, ##27144
LR__0992
	mov	local09, #0
' numpar=0
' if lparts(ct+1).token=token_lpar then								' check if it is an array
	add	objptr, ##28228
	rdlong	local05, objptr
	add	local05, #1
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local08, local05
	cmp	local08, #21 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0997
	add	objptr, ##28228
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##28228
'   ct+=1 											' omit this lpar, this is for expr list
'   do
LR__0993
	add	objptr, ##28228
	rdlong	local05, objptr
	add	local05, #1
	wrlong	local05, objptr
'     ct+=1  											': print "In getfun, ct=",ct,"lparts(ct).token=",lparts(ct).token, "part$=",lparts(ct).part$
'     if lparts(ct).token=token_lpar then ct+=1 : err=expr() : ct+=1 else err=expr()
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local10, local05
	cmp	local10, #21 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0994
	add	objptr, ##28228
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##28228
	call	#_expr
	mov	local11, result1
	add	objptr, ##28228
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##28228
	jmp	#LR__0995
LR__0994
	call	#_expr
	mov	local11, result1
LR__0995
'     if err>0 then return err
	cmps	local11, #1 wc
 if_ae	mov	result1, local11
 if_ae	jmp	#LR__0999
	add	local09, #1
	add	objptr, ##28228
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local11, local05
	cmp	local11, #20 wz
	sub	objptr, ##27148
 if_e	jmp	#LR__0996
	add	objptr, ##28228
	rdlong	local11, objptr
	shl	local11, #3
	sub	objptr, ##1080
	add	local11, objptr
	add	local11, #4
	rdlong	local11, local11
	cmp	local11, #510 wz
	sub	objptr, ##27148
 if_ne	jmp	#LR__0993
LR__0996
'     if lparts(ct).token=token_end then return 14
	add	objptr, ##28228
	rdlong	local05, objptr
	shl	local05, #3
	sub	objptr, ##1080
	add	local05, objptr
	add	local05, #4
	rdlong	local11, local05
	cmp	local11, #510 wz
	sub	objptr, ##27148
 if_e	mov	result1, #14
 if_e	jmp	#LR__0999
LR__0997
	mov	local02, local09
	mov	local03, #17
	mov	local01, local07
	mov	local10, local01
	mov	local12, local02
	mov	local13, local03
	add	objptr, ##38012
	rdlong	local14, objptr
	mov	local15, local14
	shl	local15, #1
	add	local15, local14
	shl	local15, #2
	sub	objptr, ##1536
	add	local15, objptr
	wrlong	local10, local15
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local16, local10
	shl	local16, #1
	add	local16, local10
	shl	local16, #2
	sub	objptr, ##1536
	add	local16, objptr
	add	local16, #4
	wrlong	local12, local16
	add	objptr, ##1536
	rdlong	local10, objptr
	mov	local17, local10
	shl	local17, #1
	add	local17, local10
	shl	local17, #2
	sub	objptr, ##1536
	add	local17, objptr
	add	local17, #8
	wrlong	local13, local17
	add	objptr, ##1536
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##38012
' t2.result.twowords(1)=numpar
' t2.result_type=fun_getvar:t2.result.twowords(0)=j
' compiledline(lineptr)=t2: lineptr+=1   ' if t2.result.uresult=-1, generate error
' if m=-1 then t2.result_type=fun_negative: compiledline(lineptr)=t2: lineptr+=1
	cmp	local04, ##-1 wz
 if_ne	jmp	#LR__0998
	mov	local03, #21
	mov	local10, local01
	mov	local12, local02
	mov	local13, local03
	add	objptr, ##38012
	rdlong	local14, objptr
	mov	local15, local14
	shl	local15, #1
	add	local15, local14
	shl	local15, #2
	sub	objptr, ##1536
	add	local15, objptr
	wrlong	local10, local15
	add	objptr, ##1536
	rdlong	local17, objptr
	mov	local16, local17
	shl	local16, #1
	add	local16, local17
	shl	local16, #2
	sub	objptr, ##1536
	add	local16, objptr
	add	local16, #4
	wrlong	local12, local16
	add	objptr, ##1536
	rdlong	local16, objptr
	mov	local17, local16
	shl	local17, #1
	add	local17, local16
	shl	local17, #2
	sub	objptr, ##1536
	add	local17, objptr
	add	local17, #8
	wrlong	local13, local17
	add	objptr, ##1536
	rdlong	local10, objptr
	add	local10, #1
	wrlong	local10, objptr
	sub	objptr, ##38012
LR__0998
' return 0
	mov	result1, #0
LR__0999
	mov	ptra, fp
	call	#popregs_
_getvar_ret
	ret

' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------------- End of expression evaluator --------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '                                                                                                                                       -
' '                                              RUNTIME STARTS HERE                                                                      - 
' '                                                                                                                                       -
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' '---------------------------------------------------------------------------------------------------------------------------------------
' '----------------------------------------- A main execute line function ----------------------------------------------------------------
' '---------------------------------------------------------------------------------------------------------------------------------------
' 
' function execute_line (astart=0 as integer) as integer
_execute_line
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, ##41148
	wrlong	#0, objptr
' 
' runptr2=0
' for lineptr_e=astart to lineptr-1
	sub	objptr, ##3132
	wrlong	arg01, objptr
	sub	objptr, #4
	rdlong	local01, objptr
	sub	objptr, ##38012
LR__1000
	add	objptr, ##38016
	rdlong	result1, objptr
	sub	objptr, ##38016
	cmps	result1, local01 wc
 if_ae	jmp	#LR__1001
	add	objptr, ##38016
	rdlong	result1, objptr
	mov	local02, result1
	shl	local02, #1
	add	local02, result1
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	local02, #8
	rdlong	local02, local02
	getbyte	local02, local02, #0
	shl	local02, #2
	sub	objptr, ##2076
	add	local02, objptr
	rdlong	local02, local02
	mov	local03, local02
	zerox	local02, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	sub	objptr, ##34400
	mov	local04, objptr
	mov	objptr, local02
	call	local03
	mov	objptr, local04
	add	objptr, ##38016
	rdlong	local04, objptr
	add	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##38016
	jmp	#LR__1000
LR__1001
' return runptr2
	add	objptr, ##41148
	rdlong	result1, objptr
	sub	objptr, ##41148
	mov	ptra, fp
	call	#popregs_
_execute_line_ret
	ret

' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Runtime helper functions -----------------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' ' ------------------- pop and push functions called by do_xxx functions to pop arguments and push results
' 
' function pop() as expr_result
_pop
' if stackpointer=0 then
	add	objptr, ##34392
	rdlong	result1, objptr wz
	sub	objptr, ##34392
 if_e	mov	_var03, #255
 if_e	mov	_var01, #24
 if_e	jmp	#LR__1010
	add	objptr, ##34392
	rdlong	result1, objptr
	sub	result1, #1
	wrlong	result1, objptr
	mov	result3, result1
	shl	result3, #1
	add	result3, result1
	shl	result3, #2
	sub	objptr, ##6156
	add	result3, objptr
	rdlong	_var01, result3
	add	result3, #4
	rdlong	result3, result3
	mov	result2, result1
	shl	result2, #1
	add	result2, result1
	shl	result2, #2
	add	result2, objptr
	add	result2, #8
	rdlong	result1, result2
	mov	_var02, result3
	mov	_var03, result1
	sub	objptr, ##28236
LR__1010
' return t1
	mov	result2, _var02
	mov	result3, _var03
	mov	result1, _var01
_pop_ret
	ret

' 
' sub push(t1 as expr_result )
_push
' if stackpointer<maxstack then 
	add	objptr, ##34392
	rdlong	_var01, objptr
	sub	objptr, ##34392
	cmps	_var01, ##512 wc
 if_ae	jmp	#LR__1020
	rdlong	_var01, arg01
	add	arg01, #4
	rdlong	_var02, arg01
	add	arg01, #4
	rdlong	arg01, arg01
	add	objptr, ##34392
	rdlong	_var03, objptr
	mov	_var04, _var03
	shl	_var04, #1
	add	_var04, _var03
	shl	_var04, #2
	sub	objptr, ##6156
	add	_var04, objptr
	wrlong	_var01, _var04
	add	objptr, ##6156
	rdlong	_var04, objptr
	mov	_var03, _var04
	shl	_var03, #1
	add	_var03, _var04
	shl	_var03, #2
	sub	objptr, ##6156
	add	_var03, objptr
	add	_var03, #4
	wrlong	_var02, _var03
	add	objptr, ##6156
	rdlong	_var04, objptr
	mov	_var03, _var04
	shl	_var03, #1
	add	_var03, _var04
	shl	_var03, #2
	sub	objptr, ##6156
	add	_var03, objptr
	add	_var03, #8
	wrlong	arg01, _var03
	add	objptr, ##6156
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##34392
LR__1020
_push_ret
	ret

' 
' ' -------------------------------- Runtime converting functions
' 
' ' converts the PSRAM based string to 'normal' string. A PSRAM pointer at input, a string at output
' 
' function  convertstring(psaddr as ulong) as string
_convertstring
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	call	#_pslpeek
	mov	local02, result1
	mov	local03, ##@LR__5604
' l=pslpeek(psaddr)
' s="" 
' for i=1 to l : s+=chr$(pspeek(psaddr+3+i)) :next i
	mov	local04, #1
	add	local02, #1
LR__1030
	cmps	local04, local02 wc
 if_ae	jmp	#LR__1031
	mov	arg01, local01
	add	arg01, #3
	add	arg01, local04
	call	#_pspeek
	getbyte	arg01, result1, #0
	call	#__system__Chr_S
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___string_concat
	mov	local03, result1
	add	local04, #1
	jmp	#LR__1030
LR__1031
' return s
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_convertstring_ret
	ret

' 
' ' converts a variable to an integer
' 
' function converttoint (t1 as expr_result) as integer 
_converttoint
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' 
' select case t1.result_type
	add	local01, #8
	rdlong	local02, local01
	sub	local01, #8
	cmp	local02, #28 wz
 if_e	jmp	#LR__1040
	cmp	local02, #29 wz
 if_e	jmp	#LR__1041
	cmp	local02, #30 wz
 if_e	jmp	#LR__1042
	cmp	local02, #31 wz
 if_e	jmp	#LR__1043
	cmp	local02, #43 wz
 if_e	jmp	#LR__1044
	cmp	local02, #44 wz
 if_e	jmp	#LR__1045
	jmp	#LR__1046
LR__1040
	rdlong	result1, local01
	jmp	#LR__1047
LR__1041
	rdlong	result1, local01
	jmp	#LR__1047
LR__1042
	rdlong	arg01, local01
	mov	arg02, #1
	call	#__system___float_tointeger
	jmp	#LR__1047
LR__1043
	rdlong	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	jmp	#LR__1047
LR__1044
	rdlong	arg01, local01
	call	#_convertstring
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	jmp	#LR__1047
LR__1045
	rdlong	result1, local01
	jmp	#LR__1047
LR__1046
	mov	result1, #0
LR__1047
	mov	ptra, fp
	call	#popregs_
_converttoint_ret
	ret

' 
' ' converts a variable to float
' 
' function converttofloat (t1 as expr_result) as single
_converttofloat
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' select case t1.result_type
	add	local01, #8
	rdlong	local02, local01
	sub	local01, #8
	cmp	local02, #28 wz
 if_e	jmp	#LR__1050
	cmp	local02, #29 wz
 if_e	jmp	#LR__1051
	cmp	local02, #30 wz
 if_e	jmp	#LR__1052
	cmp	local02, #31 wz
 if_e	jmp	#LR__1053
	cmp	local02, #43 wz
 if_e	jmp	#LR__1054
	jmp	#LR__1055
LR__1050
	rdlong	arg01, local01
	abs	arg01, arg01 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	jmp	#LR__1056
LR__1051
	rdlong	arg01, local01
	call	#__system___float_fromuns
	jmp	#LR__1056
LR__1052
	rdlong	result1, local01
	jmp	#LR__1056
LR__1053
	rdlong	arg01, local01
	call	#__system____builtin_atof
	jmp	#LR__1056
LR__1054
	rdlong	arg01, local01
	call	#_convertstring
	mov	arg01, result1
	call	#__system____builtin_atof
	jmp	#LR__1056
LR__1055
	mov	result1, #0
LR__1056
	mov	ptra, fp
	call	#popregs_
_converttofloat_ret
	ret

' 
' '----------------- End of converting 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '----- A nostalgic experiment with saving the program on a cassette tape ----------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' sub csave_block(address as ulong)
_csave_block
	mov	_var01, arg01
' 
' for i=0 to 63 step 2
	mov	_var02, #0
LR__1060
'   do: loop until lpeek(base+64*7)>32768
	add	objptr, ##28176
	callpa	#(@LR__1062-@LR__1061)>>2,fcache_load_ptr_
LR__1061
	rdlong	arg01, objptr
	add	arg01, #448
	rdlong	result1, arg01
	cmps	result1, ##32769 wc
 if_b	jmp	#LR__1061
LR__1062
	mov	arg01, _var01
	mov	_var03, _var02
	shl	_var03, #2
	add	arg01, _var03
	rdlong	_var04, arg01
	add	objptr, ##13832
	wrlong	_var04, objptr
	sub	objptr, ##42008
'   q=lpeek(address+4*i)
'      for bit=0 to 31
	mov	_var05, #0
	callpa	#(@LR__1067-@LR__1063)>>2,fcache_load_ptr_
LR__1063
'       if (q and (1 shl bit)) then sample(4*bit)=127: sample(4*bit+1)=128 : sample(4*bit+2)=127 : sample (4*bit+3)=128 else sample(4*bit)=128: sample(4*bit+1)=128 : sample(4*bit+2)=127 : sample (4*bit+3)=127
	add	objptr, ##42008
	rdlong	_var04, objptr
	sub	objptr, ##42008
	decod	_var03, _var05
	test	_var04, _var03 wz
 if_e	jmp	#LR__1064
	mov	_var03, _var05
	shl	_var03, #2
	add	objptr, ##39860
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #1
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #2
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #3
	add	_var03, objptr
	wrbyte	#128, _var03
	sub	objptr, ##39860
	jmp	#LR__1065
LR__1064
	mov	_var03, _var05
	shl	_var03, #2
	add	objptr, ##39860
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #1
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #2
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var03, _var05
	shl	_var03, #2
	add	_var03, #3
	add	_var03, objptr
	wrbyte	#127, _var03
	sub	objptr, ##39860
LR__1065
	add	_var05, #1
	cmps	_var05, #32 wc
 if_b	jmp	#LR__1063
'   do: loop until lpeek(base+64*7)<32768
	add	objptr, ##28176
LR__1066
	rdlong	arg01, objptr
	add	arg01, #448
	rdlong	result1, arg01
	cmps	result1, ##32768 wc
 if_ae	jmp	#LR__1066
LR__1067
	mov	arg01, _var01
	add	arg01, #4
	mov	_var03, _var02
	shl	_var03, #2
	add	arg01, _var03
	rdlong	_var04, arg01
	add	objptr, ##13832
	wrlong	_var04, objptr
	sub	objptr, ##42008
'   q=lpeek(address+4+4*i)
'      for bit=0 to 31
	mov	_var05, #0
	callpa	#(@LR__1071-@LR__1068)>>2,fcache_load_ptr_
LR__1068
'       if (q and (1 shl bit)) then sample(128+4*bit)=127: sample(128+4*bit+1)=128 : sample(128+4*bit+2)=127 : sample (128+4*bit+3)=128 else sample(128+4*bit)=128: sample(128+4*bit+1)=128 : sample(128+4*bit+2)=127 : sample (128+4*bit+3)=127
	add	objptr, ##42008
	rdlong	_var04, objptr
	sub	objptr, ##42008
	decod	_var03, _var05
	test	_var04, _var03 wz
 if_e	jmp	#LR__1069
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	objptr, ##39860
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #1
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #2
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #3
	add	_var03, objptr
	wrbyte	#128, _var03
	sub	objptr, ##39860
	jmp	#LR__1070
LR__1069
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	objptr, ##39860
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #1
	add	_var03, objptr
	wrbyte	#128, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #2
	add	_var03, objptr
	wrbyte	#127, _var03
	mov	_var06, _var05
	shl	_var06, #2
	mov	_var03, #128
	add	_var03, _var06
	add	_var03, #3
	add	_var03, objptr
	wrbyte	#127, _var03
	sub	objptr, ##39860
LR__1070
	add	_var05, #1
	cmps	_var05, #32 wc
 if_b	jmp	#LR__1068
LR__1071
	add	_var02, #2
	cmps	_var02, #64 wc
 if_b	jmp	#LR__1060
' do: loop until lpeek(base+64*7)>32768
	add	objptr, ##28176
	callpa	#(@LR__1080-@LR__1072)>>2,fcache_load_ptr_
LR__1072
	rdlong	arg01, objptr
	add	arg01, #448
	rdlong	result1, arg01
	cmps	result1, ##32769 wc
 if_b	jmp	#LR__1072
	sub	objptr, ##28176
' for i=0 to 127: if i mod 8 < 4 then sample(i)=127 else sample(i)=128 
	mov	_var02, #0
LR__1073
	abs	_var04, _var02 wc
	and	_var04, #7
	negc	_var04, _var04
	cmps	_var04, #4 wc
 if_ae	jmp	#LR__1074
	mov	_var06, _var02
	add	objptr, ##39860
	add	_var06, objptr
	wrbyte	#127, _var06
	sub	objptr, ##39860
	jmp	#LR__1075
LR__1074
	mov	_var06, _var02
	add	objptr, ##39860
	add	_var06, objptr
	wrbyte	#128, _var06
	sub	objptr, ##39860
LR__1075
	add	_var02, #1
	cmps	_var02, #128 wc
 if_b	jmp	#LR__1073
' 
' do: loop until lpeek(base+64*7)<32768
	add	objptr, ##28176
LR__1076
	rdlong	arg01, objptr
	add	arg01, #448
	rdlong	result1, arg01
	cmps	result1, ##32768 wc
 if_ae	jmp	#LR__1076
	sub	objptr, ##28176
' for i=128 to 255: if i mod 8 < 4 then sample(i)=127 else sample(i)=128 
	mov	_var02, #128
LR__1077
	abs	_var04, _var02 wc
	and	_var04, #7
	negc	_var04, _var04
	cmps	_var04, #4 wc
 if_ae	jmp	#LR__1078
	mov	_var06, _var02
	add	objptr, ##39860
	add	_var06, objptr
	wrbyte	#127, _var06
	sub	objptr, ##39860
	jmp	#LR__1079
LR__1078
	mov	_var06, _var02
	add	objptr, ##39860
	add	_var06, objptr
	wrbyte	#128, _var06
	sub	objptr, ##39860
LR__1079
	add	_var02, #1
	cmp	_var02, #256 wc
 if_b	jmp	#LR__1077
LR__1080
_csave_block_ret
	ret

' 
' sub csave_addtoblock(d as ubyte, force as ubyte)
_csave_addtoblock
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' if force=0 then
	zerox	arg02, #7 wz
 if_ne	jmp	#LR__1090
	add	objptr, ##41140
	rdlong	arg02, objptr
	sub	objptr, ##1024
	add	arg02, objptr
	wrbyte	local01, arg02
	add	objptr, ##1024
	rdlong	local01, objptr
	add	local01, #1
	wrlong	local01, objptr
'   block(blockptr)=d
'   blockptr+=1
'   if blockptr>=255 then
	sub	objptr, ##41140
	cmp	local01, #255 wc
 if_b	jmp	#LR__1094
	add	objptr, ##40116
	mov	arg01, objptr
	sub	objptr, ##40116
	call	#_csave_block
	add	objptr, ##41140
	wrlong	#0, objptr
	sub	objptr, ##41140
	mov	arg01, #300
	call	#__system___waitms
	jmp	#LR__1094
LR__1090
	add	objptr, ##41140
	rdlong	local02, objptr
	sub	objptr, ##1024
	add	local02, objptr
	wrbyte	local01, local02
'   block(blockptr)=d
'   if blockptr<255 then for i=blockptr to 255 : block(i)=0 : next i 
	add	objptr, ##1024
	rdlong	local03, objptr
	sub	objptr, ##41140
	cmp	local03, #255 wc
 if_ae	jmp	#LR__1093
	add	objptr, ##41140
	rdlong	local04, objptr
	sub	objptr, ##41140
LR__1091
	cmps	local04, #256 wc
 if_ae	jmp	#LR__1092
	mov	local02, local04
	add	objptr, ##40116
	add	local02, objptr
	wrbyte	#0, local02
	add	local04, #1
	sub	objptr, ##40116
	jmp	#LR__1091
LR__1092
LR__1093
	add	objptr, ##40116
	mov	arg01, objptr
	sub	objptr, ##40116
	call	#_csave_block
	add	objptr, ##41140
	wrlong	#0, objptr
	sub	objptr, ##41140
	mov	arg01, #300
	call	#__system___waitms
LR__1094
	mov	ptra, fp
	call	#popregs_
_csave_addtoblock_ret
	ret

' 
' '----------------------- csave
' 
' sub test_csave
_test_csave
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #192
' 'dim fileheader,savestart, saveptr as ulong
' 
' if pslpeek(programstart)=$FFFFFFFF then printerror(27): return
	add	objptr, ##38024
	rdlong	arg01, objptr
	sub	objptr, ##38024
	call	#_pslpeek
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__1100
	mov	arg01, #27
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1114
LR__1100
	call	#_pop
	add	fp, #144
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type<>result_string then name$=loadname else name$=t1.result.sresult
	sub	fp, #152
	cmp	result3, #31 wz
 if_e	jmp	#LR__1101
	add	objptr, ##41944
	rdlong	arg06, objptr
	sub	objptr, ##41944
	add	fp, #140
	wrlong	arg06, fp
	sub	fp, #140
	jmp	#LR__1102
LR__1101
	add	fp, #144
	rdlong	arg06, fp
	sub	fp, #4
	wrlong	arg06, fp
	sub	fp, #140
LR__1102
' 
' ' prepare 1 kHz header wave
' 
' for i=0 to 255: if i mod 8 < 4 then sample(i)=127 else sample(i)=128 
	wrlong	#0, fp
	callpa	#(@LR__1106-@LR__1103)>>2,fcache_load_ptr_
LR__1103
	rdlong	arg06, fp
	abs	arg05, arg06 wc
	and	arg05, #7
	negc	arg05, arg05
	cmps	arg05, #4 wc
 if_ae	jmp	#LR__1104
	rdlong	arg05, fp
	add	objptr, ##39860
	add	arg05, objptr
	wrbyte	#127, arg05
	sub	objptr, ##39860
	jmp	#LR__1105
LR__1104
	rdlong	arg05, fp
	add	objptr, ##39860
	add	arg05, objptr
	wrbyte	#128, arg05
	sub	objptr, ##39860
LR__1105
	rdlong	arg05, fp
	add	arg05, #1
	wrlong	arg05, fp
	cmps	arg05, #256 wc
 if_b	jmp	#LR__1103
LR__1106
	add	objptr, ##39860
	mov	arg02, objptr
	mov	arg01, #7
	mov	arg03, ##8000
	decod	arg04, #14
	mov	arg05, #256
	mov	arg06, #0
	sub	objptr, ##34024
	call	#_audio096_spin2_play8
	sub	objptr, ##5836
	mov	arg01, ##3000
	call	#__system___waitms
	add	objptr, ##41140
	wrlong	#0, objptr
	sub	objptr, ##41140
	mov	arg01, #114
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #98
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #97
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #13
	mov	arg02, #0
	call	#_csave_addtoblock
' paula.play8(7,varptr(sample),8000,16384,256,0)
' waitms 3000 
' 
' blockptr=0
' csave_addtoblock($72,0): csave_addtoblock($62,0): csave_addtoblock($61,0): csave_addtoblock($0D,0) ' rba+ver(13)
' for i=1 to len(name$): csave_addtoblock(asc(mid$(name$,i,1)),0) : next i : csave_addtoblock(0,0) 
	wrlong	#1, fp
	add	fp, #140
	rdlong	arg01, fp
	sub	fp, #140
	mov	local01, arg01
	callpa	#(@LR__1108-@LR__1107)>>2,fcache_load_ptr_
LR__1107
	rdbyte	result1, local01 wz
 if_ne	add	local01, #1
 if_ne	jmp	#LR__1107
LR__1108
	sub	local01, arg01
	mov	local02, local01
	add	local02, #1
LR__1109
	rdlong	arg05, fp
	cmps	arg05, local02 wc
 if_ae	jmp	#LR__1110
	add	fp, #140
	rdlong	arg01, fp
	sub	fp, #140
	rdlong	arg02, fp
	mov	arg03, #1
	call	#__system__Mid_S
	rdbyte	arg01, result1
	mov	arg02, #0
	call	#_csave_addtoblock
	rdlong	arg05, fp
	add	arg05, #1
	wrlong	arg05, fp
	jmp	#LR__1109
LR__1110
	mov	arg01, #0
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #114
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #98
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #115
	mov	arg02, #0
	call	#_csave_addtoblock
	mov	arg01, #13
	mov	arg02, #0
	call	#_csave_addtoblock
	add	objptr, ##38024
	rdlong	local03, objptr
	sub	objptr, ##38024
	add	fp, #156
	wrlong	local03, fp
	sub	fp, #156
' csave_addtoblock($72,0): csave_addtoblock($62,0): csave_addtoblock($73,0): csave_addtoblock($0D,0) ' rbs+ver(13)
' 
' saveptr=programstart
' do
LR__1111
	add	fp, #160
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #156
	mov	arg03, #24
	add	objptr, ##5836
	call	#_psram_spin2_read1
	add	fp, #12
	mov	arg01, fp
	add	fp, #156
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #172
	call	#_psram_spin2_read1
	sub	objptr, ##5836
	add	fp, #172
	rdlong	arg01, fp
	sub	fp, #172
	mov	arg02, #0
	call	#_csave_addtoblock
' 
'   psram.read1(varptr(header(0)),saveptr,24)
'   psram.read1(varptr(linebuf(0)),header(2),header(3))  
'   csave_addtoblock(header(3),0) ' that's always <255
'   for i=0 to header(3)-1: csave_addtoblock(linebuf(i),0)  :next i
	wrlong	#0, fp
	add	fp, #172
	rdlong	local04, fp
	sub	fp, #172
LR__1112
	rdlong	local03, fp
	cmps	local03, local04 wc
 if_ae	jmp	#LR__1113
	rdlong	local03, fp
	add	fp, #12
	add	local03, fp
	rdbyte	arg01, local03
	mov	arg02, #0
	sub	fp, #12
	call	#_csave_addtoblock
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	jmp	#LR__1112
LR__1113
	add	fp, #180
	rdlong	local03, fp
	sub	fp, #24
	wrlong	local03, fp
	add	fp, #24
	rdlong	local03, fp
	sub	fp, #180
	cmp	local03, ##2147483647 wz
 if_ne	jmp	#LR__1111
	mov	arg01, #0
	mov	arg02, #1
	call	#_csave_addtoblock
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	add	arg01, #468
	wrword	#0, arg01
LR__1114
	mov	ptra, fp
	call	#popregs_
_test_csave_ret
	ret

' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '----- End of cassette procedures -------------------------------------------------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Runtime functions ------------------------------------------------------------------------------
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' '-------------------- abs
' 
' sub do_abs
_do_abs
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
' 
' t1=pop()
' if t1.result_type=result_int then 
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	rdlong	arg01, fp
 if_e	abs	local01, arg01
 if_e	wrlong	local01, fp
 if_e	jmp	#LR__1120
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	rdlong	result1, fp
 if_e	bitl	result1, #31
 if_e	wrlong	result1, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	wrlong	#40, fp
LR__1120
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_abs_ret
	ret

' 
' '-------------------- acos
' 
' sub do_acos
_do_acos
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "acos: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1130
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5605
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1131
LR__1130
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	call	#__system____builtin_acosf
	mov	arg01, result1
	add	objptr, ##41920
	rdlong	arg02, objptr
	sub	objptr, ##41920
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1131
	mov	ptra, fp
	call	#popregs_
_do_acos_ret
	ret

' 
' '-------------------- asc
' 
' sub do_asc
_do_asc
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "asc: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1140
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5606
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1143
LR__1140
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1141
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1141
' if t1.result_type<>result_string then print "asc: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1142
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5607
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1143
LR__1142
	rdlong	local01, fp
	rdbyte	local01, local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1143
	mov	ptra, fp
	call	#popregs_
_do_asc_ret
	ret

' 
' '-------------------- asin
' 
' sub do_asin
_do_asin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "asin: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1150
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5608
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1151
LR__1150
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	call	#__system____builtin_asinf
	mov	arg01, result1
	add	objptr, ##41920
	rdlong	arg02, objptr
	sub	objptr, ##41920
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1151
	mov	ptra, fp
	call	#popregs_
_do_asin_ret
	ret

' 
' '-------------------- atn
' 
' sub do_atn
_do_atn
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "atn: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1160
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5609
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1161
LR__1160
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	mov	arg02, ##1065353216
	call	#__system____builtin_atan2f
	mov	arg01, result1
	add	objptr, ##41920
	rdlong	arg02, objptr
	sub	objptr, ##41920
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1161
	mov	ptra, fp
	call	#popregs_
_do_atn_ret
	ret

' 
' '-------------------- beep
' 
' sub do_beep
_do_beep
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	local01, result1
	mov	arg06, result2
	mov	local02, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	arg06, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) then freq=t1.result.iresult else freq=converttoint(t1)
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local02, #29 wz
 if_e	rdlong	local01, fp
 if_e	add	fp, #24
 if_e	wrlong	local01, fp
 if_e	sub	fp, #24
 if_e	jmp	#LR__1170
	mov	arg01, fp
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #24
LR__1170
	add	fp, #28
	wrbyte	#127, fp
	add	fp, #1
	wrbyte	#128, fp
	sub	fp, #1
	mov	arg02, fp
	sub	fp, #4
	rdlong	arg03, fp
	sub	fp, #24
	shl	arg03, #1
	mov	arg01, #7
	decod	arg04, #14
	mov	arg05, #2
	mov	arg06, #0
	add	objptr, ##5836
	call	#_audio096_spin2_play8
	sub	objptr, ##5836
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_push
	call	#_do_waitms
	mov	arg01, #7
	add	objptr, ##5836
	call	#_audio096_spin2_stop
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_do_beep_ret
	ret

' 
' '-------------------- blit
' 
' ' blit buf1,x1,y1,x2,y2,s1,buf2,x2,y2,s2
' sub do_blit
_do_blit
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #60
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg10, local01
	shl	arg10, #1
	add	arg10, local01
	shl	arg10, #2
	sub	objptr, ##1540
	add	arg10, objptr
	rdlong	arg10, arg10
	add	fp, #56
	wrlong	arg10, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>10 andalso numpar<>6 then print "blit: "; : printerror (39,runheader(0)) : return
	sub	fp, #56
	cmp	arg10, #10 wz
	sub	objptr, ##36476
 if_ne	add	fp, #56
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #56
 if_ne	cmp	local01, #6 wz
 if_e	jmp	#LR__1180
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5610
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	objptr, ##41200
	rdlong	arg02, objptr
	sub	objptr, ##41200
	mov	arg01, #39
	call	#_printerror
	jmp	#LR__1185
LR__1180
' for i=numpar-1 to 0 step -1: t1=pop() : p(i)=converttoint(t1): next i
	add	fp, #56
	rdlong	local02, fp
	sub	local02, #1
	sub	fp, #4
	wrlong	local02, fp
	sub	fp, #52
LR__1181
	add	fp, #56
	rdlong	local01, fp
	sub	local01, #1
	sub	fp, #4
	rdlong	arg10, fp
	sub	fp, #52
	cmp	arg10, local01 wcz
 if_a	jmp	#LR__1182
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	add	fp, #44
	rdlong	local02, fp
	shl	local02, #2
	sub	fp, #40
	add	local02, fp
	sub	fp, #12
	mov	arg01, fp
	call	#_converttoint
	wrlong	result1, local02
	add	fp, #52
	rdlong	local02, fp
	sub	local02, #1
	wrlong	local02, fp
	sub	fp, #52
	jmp	#LR__1181
LR__1182
' if numpar=10 then 
	add	fp, #56
	rdlong	local02, fp
	sub	fp, #56
	cmp	local02, #10 wz
 if_ne	jmp	#LR__1183
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg05, fp
	add	fp, #4
	rdlong	arg06, fp
	add	fp, #4
	rdlong	arg07, fp
	add	fp, #4
	rdlong	arg08, fp
	add	fp, #4
	rdlong	arg09, fp
	add	fp, #4
	rdlong	arg10, fp
	sub	fp, #48
	call	#_hg010b_spin2_blit
	jmp	#LR__1184
LR__1183
	rdlong	arg07, objptr
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg05, fp
	add	fp, #4
	rdlong	arg08, fp
	add	fp, #4
	rdlong	arg09, fp
	sub	fp, #32
	mov	arg01, arg07
	decod	arg06, #10
	decod	arg10, #10
	call	#_hg010b_spin2_blit
LR__1184
LR__1185
	mov	ptra, fp
	call	#popregs_
_do_blit_ret
	ret

' 
' 
' '-------------------- bin$
' 
' sub do_bin
_do_bin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>2 orelse numpar=0 then print "bin$: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #3 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1190
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5611
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1193
LR__1190
' if numpar=2 then t1=pop() : num=converttoint(t1) else num=0
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #2 wz
 if_ne	jmp	#LR__1191
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	jmp	#LR__1192
LR__1191
	add	fp, #20
	wrlong	#0, fp
	sub	fp, #20
LR__1192
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
	mov	arg01, result1
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #20
	mov	arg03, #2
	call	#__system__Number_S
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1193
	mov	ptra, fp
	call	#popregs_
_do_bin_ret
	ret

' 
' '-------------------- box
' 
' sub do_box
_do_box
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #36
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #44
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #24
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #32
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t4=pop()
' t3=pop()
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) andalso (t2.result_type=result_int orelse t2.result_type=result_uint) andalso (t3.result_type=result_int orelse t3.result_type=result_uint) andalso (t4.result_type=result_int orelse t4.result_type=result_uint) then
	mov	arg05, result3
	sub	fp, #8
	cmp	arg05, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1200
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #28 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1200
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, #28 wz
 if_ne	add	fp, #32
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #32
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1200
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #44
	cmp	local01, #28 wz
 if_ne	add	fp, #44
 if_ne	rdlong	arg05, fp
 if_ne	sub	fp, #44
 if_ne	cmp	arg05, #29 wz
 if_ne	jmp	#LR__1200
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #12
	rdlong	arg03, fp
	add	fp, #12
	rdlong	arg04, fp
	sub	fp, #36
	add	objptr, ##28200
	rdlong	arg05, objptr
	sub	objptr, ##28200
	call	#_hg010b_spin2_box
'    v.box(t1.result.iresult,t2.result.iresult,t3.result.iresult,t4.result.iresult,plot_color) : return
	jmp	#LR__1201
LR__1200
	mov	arg01, fp
	call	#_converttoint
	mov	local02, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local03, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	local01, result1
	add	fp, #36
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	arg04, result1
	add	objptr, ##28200
	rdlong	arg05, objptr
	sub	objptr, ##28200
	mov	arg01, local02
	mov	arg02, local03
	mov	arg03, local01
	call	#_hg010b_spin2_box
LR__1201
	mov	ptra, fp
	call	#popregs_
_do_box_ret
	ret

' 
' '-------------------- brun
' 
' sub do_brun
_do_brun
	mov	COUNT_, #8
	call	#pushregs_
	call	#_pop
	mov	arg05, result2
	mov	arg04, result3
	mov	local01, result1
	mov	local02, arg05
	mov	local03, arg04
' 
' t1=pop() 
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult): t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1210
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1210
' if t1.result_type=result_string then
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1214
	mov	local04, local01
'   filename=t1.result.sresult
'   if left$(filename,1)="/" then 
	mov	arg01, local04
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5612
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	local05, local04
 if_e	jmp	#LR__1211
	mov	arg01, ##@LR__5613
	mov	arg02, local04
	call	#__system___string_concat
	mov	local05, result1
LR__1211
'   open fullfilename for input as #9
	mov	arg01, #9
	mov	arg02, local05
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'   r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return
 if_e	jmp	#LR__1212
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5614
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5615
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, local06
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1215
LR__1212
	mov	local07, #1
	mov	local08, #0
'   do
LR__1213
'     get #9,pos,block(0),1024,r : pos+=r	
	add	objptr, ##40116
	mov	arg03, objptr
	sub	objptr, ##40116
	mov	arg01, #9
	mov	arg02, local07
	decod	arg04, #10
	mov	arg05, #1
	call	#__system___basic_get
	mov	local06, result1
	add	local07, result1
	add	objptr, ##40116
	mov	arg01, objptr
	mov	arg02, local08
	decod	arg03, #10
	sub	objptr, ##34280
	call	#_psram_spin2_write
	sub	objptr, ##5836
	add	local08, local06
	cmp	local06, ##1024 wz
 if_e	cmps	local08, ##507904 wc
 if_c_and_z	jmp	#LR__1213
	add	objptr, ##28156
	rdlong	arg01, objptr
	cogstop	arg01
	add	objptr, #4
	rdlong	arg01, objptr
	cogstop	arg01
	add	objptr, #4
	rdlong	arg01, objptr
	cogstop	arg01
	add	objptr, ##13076
	rdlong	arg01, objptr
	cogstop	arg01
	add	ptr__dat__, ##12492
	mov	arg02, ptr__dat__
	sub	ptr__dat__, ##12492
	sub	objptr, ##13068
	mov	local08, #30
	setq	objptr
	coginit	local08, arg02 wc
 if_b	neg	local08, #1
	add	objptr, ##13852
	wrlong	local08, objptr
	sub	objptr, ##42024
	mov	arg01, #0
	cogid	arg01
	cogstop	arg01
LR__1214
LR__1215
	mov	ptra, fp
	call	#popregs_
_do_brun_ret
	ret

' 
' '-------------------- cd
' 
' sub do_cd
_do_cd
	mov	COUNT_, #6
	call	#pushregs_
	mov	arg01, ##@LR__5616
	mov	arg02, #49
	call	#__system___basic_dir
	call	#_pop
	mov	arg04, result2
	mov	arg03, result3
	mov	local01, result1
	mov	local02, arg04
	mov	local03, arg03
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1220
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1220
' if t1.result_type<>result_string then printerror(15): return
	cmp	local03, #31 wz
 if_e	jmp	#LR__1221
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1239
LR__1221
	mov	local04, local01
' newdir$=t1.result.sresult
' if newdir$=".." then 
	mov	arg02, ##@LR__5617
	mov	arg01, local04
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1228
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	local05, arg01
	callpa	#(@LR__1223-@LR__1222)>>2,fcache_load_ptr_
LR__1222
	rdbyte	result1, local05 wz
 if_ne	add	local05, #1
 if_ne	jmp	#LR__1222
LR__1223
	subr	arg01, local05
	add	objptr, ##38036
	rdlong	arg02, objptr
	sub	objptr, ##38036
	mov	arg03, ##@LR__5618
	call	#__system__InstrRev
	mov	local04, result1
'   if slash>1 then newdir$=left$(currentdir$,slash-1) else newdir$="/"
	cmps	local04, #2 wc
 if_b	jmp	#LR__1224
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	sub	local04, #1
	mov	arg02, local04
	call	#__system__Left_S
	mov	local04, result1
	jmp	#LR__1225
LR__1224
	mov	local04, ##@LR__5619
LR__1225
	mov	arg01, local04
	call	#__system___chdir
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'   chdir newdir$
'   err=geterr() : if err<>0 andalso err<>5 then print "System error ";err;": " ;errors$(53) : chdir(currentdir$) else currentdir$=newdir$
 if_ne	cmp	local06, #5 wz
 if_e	jmp	#LR__1226
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5620
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5621
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##35664
	rdlong	arg02, objptr
	sub	objptr, ##35664
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	call	#__system___chdir
	jmp	#LR__1227
LR__1226
	add	objptr, ##38036
	wrlong	local04, objptr
	sub	objptr, ##38036
LR__1227
'   print "Current directory: ";currentdir$
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5622
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##38036
	rdlong	arg02, objptr
	sub	objptr, ##38036
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
'   return
	jmp	#LR__1239
LR__1228
' if left$(newdir$,1)="/" then 
	mov	arg01, local04
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5623
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1231
	mov	arg01, local04
	call	#__system___chdir
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'   chdir(newdir$)
'   err=geterr() : if err<>0 andalso err<>5 then print "System error ";err;": " ;errors$(53) : chdir(currentdir$) else currentdir$=newdir$
 if_ne	cmp	local06, #5 wz
 if_e	jmp	#LR__1229
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5624
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5625
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##35664
	rdlong	arg02, objptr
	sub	objptr, ##35664
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	call	#__system___chdir
	jmp	#LR__1230
LR__1229
	add	objptr, ##38036
	wrlong	local04, objptr
	sub	objptr, ##38036
LR__1230
'   print "Current directory: ";currentdir$
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5626
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##38036
	rdlong	arg02, objptr
	sub	objptr, ##38036
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
'   return
	jmp	#LR__1239
LR__1231
'   if currentdir$<>"/" then newdir$=currentdir$+"/"+newdir$ else newdir$=currentdir$+newdir$ 
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5627
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1232
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5628
	call	#__system___string_concat
	mov	arg01, result1
	mov	arg02, local04
	call	#__system___string_concat
	mov	local04, result1
	jmp	#LR__1233
LR__1232
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, local04
	call	#__system___string_concat
	mov	local04, result1
LR__1233
'   if right$(newdir$,1)="/" then newdir$=left$(newdir$,len(newdir$)-1)
	mov	arg01, local04
	mov	arg02, #1
	call	#__system__Right_S
	mov	arg01, result1
	mov	arg02, ##@LR__5629
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1236
	mov	arg01, local04
	mov	local05, arg01
	callpa	#(@LR__1235-@LR__1234)>>2,fcache_load_ptr_
LR__1234
	rdbyte	result1, local05 wz
 if_ne	add	local05, #1
 if_ne	jmp	#LR__1234
LR__1235
	sub	local05, arg01
	mov	arg02, local05
	sub	arg02, #1
	mov	arg01, local04
	call	#__system__Left_S
	mov	local04, result1
LR__1236
	mov	arg01, local04
	call	#__system___chdir
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local06, result1 wz
'   chdir(newdir$)
'   err=geterr() : if err<>0 andalso err<>5 then print "System error ";err;": " ;errors$(53) : chdir(currentdir$) else currentdir$=newdir$
 if_ne	cmp	local06, #5 wz
 if_e	jmp	#LR__1237
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5630
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local06
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5631
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##35664
	rdlong	arg02, objptr
	sub	objptr, ##35664
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	call	#__system___chdir
	jmp	#LR__1238
LR__1237
	add	objptr, ##38036
	wrlong	local04, objptr
	sub	objptr, ##38036
LR__1238
'   print "Current directory: ";currentdir$
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5632
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##38036
	rdlong	arg02, objptr
	sub	objptr, ##38036
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1239
	mov	ptra, fp
	call	#popregs_
_do_cd_ret
	ret

' 
' '-------------------- changefreq
' 
' sub do_changefreq
_do_changefreq
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #40
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	add	fp, #36
	wrlong	result1, fp
	sub	fp, #36
	mov	arg02, result1
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	mov	local01, result1
	decod	arg02, #30
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	add	fp, #16
	wrlong	result1, fp
	decod	local01, #30
	mov	arg01, result1
	sub	fp, #16
	add	arg01, #5
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg02, result1
	mov	arg01, local01
	call	#__system____builtin_powf
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #20
	wrlong	result1, fp
' skip=round(2^(lfreq+5))
' if skip>32768 then i=skip/32768: skip=32768 else i=1
	sub	fp, #20
	cmps	result1, ##32769 wc
 if_b	jmp	#LR__1240
	add	fp, #20
	rdlong	local01, fp
	abs	local01, local01 wc
	shr	local01, #15
	negc	local01, local01
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #4
	wrlong	##32768, fp
	sub	fp, #20
	jmp	#LR__1241
LR__1240
	add	fp, #24
	wrlong	#1, fp
	sub	fp, #24
LR__1241
	add	fp, #36
	rdlong	arg02, fp
	sub	fp, #36
	mov	arg01, ##1247312956
	call	#__system___float_div
	mov	local01, result1
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #24
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	local03, result1
	decod	local04, #30
	mov	arg01, #13
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #16
	sub	arg01, arg02
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg02, result1
	mov	arg01, local04
	call	#__system____builtin_powf
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local01, result1
	add	fp, #28
	wrlong	local01, fp
	sub	fp, #28
	call	#_pop
	mov	local04, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local04, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	local03, result1 wc
	and	local03, #7
	negc	local03, local03
	add	fp, #12
	wrlong	local03, fp
	add	fp, #8
	rdlong	local01, fp
	shl	local01, #16
	add	fp, #8
	rdlong	local04, fp
	add	local01, local04
	add	fp, #4
	wrlong	local01, fp
' if (lpeek(base+64*channel+8) and $0800_0000)=0 then 
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	sub	fp, #20
	rdlong	local04, fp
	sub	fp, #12
	shl	local04, #6
	add	arg01, local04
	add	arg01, #8
	rdlong	result1, arg01
	testbn	result1, #27 wz
 if_ne	jmp	#LR__1242
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	add	fp, #12
	rdlong	local04, fp
	shl	local04, #6
	add	arg01, local04
	add	arg01, #24
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #32
	wrlong	arg02, arg01
	jmp	#LR__1243
LR__1242
	add	objptr, ##28176
	rdlong	local01, objptr
	sub	objptr, ##28176
	add	fp, #12
	rdlong	local04, fp
	shl	local04, #6
	add	local01, local04
	add	local01, #24
	add	fp, #24
	rdlong	arg02, fp
	sub	fp, #36
	mov	arg01, ##1247312956
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local01
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	add	fp, #12
	rdlong	local04, fp
	sub	fp, #12
	shl	local04, #6
	add	arg01, local04
	add	arg01, #26
	wrword	#256, arg01
LR__1243
	mov	ptra, fp
	call	#popregs_
_do_changefreq_ret
	ret

' 
' '-------------------- changepan
' 
' sub do_changepan
_do_changepan
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	local01, ##1174405120
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	decod	local01, #13
	add	local01, result1
	add	fp, #16
	wrlong	local01, fp
' 
' t1=pop()
' pan=8192+round(8192*converttofloat(t1)) 
' if pan<0 then pan=0
	sub	fp, #16
	cmps	local01, #0 wc
 if_b	add	fp, #16
 if_b	wrlong	#0, fp
 if_b	sub	fp, #16
' if pan>16384 then pan=16384
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmps	local01, ##16385 wc
 if_ae	add	fp, #16
 if_ae	wrlong	##16384, fp
 if_ae	sub	fp, #16
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	local01, result1 wc
	and	local01, #7
	negc	local01, local01
	add	fp, #12
	wrlong	local01, fp
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	shl	local01, #6
	add	arg01, local01
	add	arg01, #22
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #16
	wrword	arg02, arg01
	mov	ptra, fp
	call	#popregs_
_do_changepan_ret
	ret

' 
' '-------------------- changevol
' 
' sub do_changevol
_do_changevol
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	mov	arg02, ##1148846080
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	abs	arg02, result1 wc
	zerox	arg02, #13
	negc	arg02, arg02
	add	fp, #16
	wrlong	arg02, fp
	sub	fp, #16
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	arg02, result1 wc
	and	arg02, #7
	negc	arg02, arg02
	add	fp, #12
	wrlong	arg02, fp
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	shl	arg02, #6
	add	arg01, arg02
	add	arg01, #20
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #16
	wrword	arg02, arg01
	mov	ptra, fp
	call	#popregs_
_do_changevol_ret
	ret

' 
' '-------------------- changewav
' 
' sub do_changewav
_do_changewav
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
' 
' t1=pop()
' wave=converttoint(t1)
' if wave<0 then wave=0
	mov	arg02, result1
	sub	fp, #16
	cmps	arg02, #0 wc
 if_b	add	fp, #16
 if_b	wrlong	#0, fp
 if_b	sub	fp, #16
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	arg02, result1 wc
	and	arg02, #7
	negc	arg02, arg02
	add	fp, #12
	wrlong	arg02, fp
' if wave <32 then 
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #16
	cmps	arg02, #32 wc
 if_ae	jmp	#LR__1250
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	add	fp, #12
	rdlong	arg02, fp
	shl	arg02, #6
	add	arg01, arg02
	add	arg01, #8
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #16
	shl	arg02, #11
	add	arg02, ##-2147483648
	wrlong	arg02, arg01
	jmp	#LR__1251
LR__1250
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	shl	arg02, #6
	add	arg01, arg02
	add	arg01, #8
	wrlong	##-2013265920, arg01
LR__1251
	mov	ptra, fp
	call	#popregs_
_do_changewav_ret
	ret

' 
' '-------------------- chr$
' 
' sub do_chr
_do_chr
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "chr$: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1260
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5633
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1261
LR__1260
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
	mov	arg01, result1
	sub	fp, #16
	call	#__system__Chr_S
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1261
	mov	ptra, fp
	call	#popregs_
_do_chr_ret
	ret

' 
' '-------------------- circle
' 
' sub do_circle
_do_circle
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #36
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	arg02, result3
	add	fp, #24
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #32
	call	#_pop
	mov	arg04, result1
	mov	arg03, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t3=pop()
' t2=pop()
' t1=pop()
' if (t1.result_type=result_int orelse t1.result_type=result_uint) andalso (t2.result_type=result_int orelse t2.result_type=result_uint) andalso (t3.result_type=result_int orelse t3.result_type=result_uint) then
	mov	arg04, result3
	sub	fp, #8
	cmp	arg04, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1270
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #28 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1270
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmp	local01, #28 wz
 if_ne	add	fp, #32
 if_ne	rdlong	arg04, fp
 if_ne	sub	fp, #32
 if_ne	cmp	arg04, #29 wz
 if_ne	jmp	#LR__1270
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #12
	rdlong	arg03, fp
	sub	fp, #24
	add	objptr, ##28200
	rdlong	arg04, objptr
	sub	objptr, ##28200
	call	#_hg010b_spin2_circle
'    v.circle(t1.result.iresult,t2.result.iresult,t3.result.iresult,plot_color) : return
	jmp	#LR__1271
LR__1270
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	arg03, result1
	add	objptr, ##28200
	rdlong	arg04, objptr
	sub	objptr, ##28200
	mov	arg01, local01
	mov	arg02, local02
	call	#_hg010b_spin2_circle
LR__1271
	mov	ptra, fp
	call	#popregs_
_do_circle_ret
	ret

' 
' '-------------------- click
' 
' sub do_click
_do_click
	call	#_pop
	cmps	result1, #0 wz
' 
' t1=pop()
' if t1.result.uresult=0 then keyclick=0 else keyclick=1
 if_e	add	objptr, ##41236
 if_e	wrlong	#0, objptr
	sumz	objptr, ##41236
 if_ne	wrlong	#1, objptr
 if_ne	sub	objptr, ##41236
_do_click_ret
	ret

' 
' '-------------------- close
' 
' sub do_close
_do_close
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	arg03, result3
	mov	local02, result2
	mov	local03, arg03
' 
' numpar=compiledline(lineptr_e).result.uresult
' t1=pop()
' if t1.result_type<>result_channel then print "channel# expected" : return  
	cmp	local03, #44 wz
 if_e	jmp	#LR__1280
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5634
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	jmp	#LR__1281
LR__1280
' channel  = t1.result.iresult
' close #channel
	mov	arg01, local01
	call	#__system__close
LR__1281
	mov	ptra, fp
	call	#popregs_
_do_close_ret
	ret

' 
' '-------------------- cls
' 
' sub do_cls
_do_cls
	add	objptr, ##28220
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##28216
	call	#_hg010b_spin2_cls
	add	objptr, ##28220
	rdlong	arg02, objptr
	sub	objptr, #20
	wrlong	arg02, objptr
	sub	objptr, ##28200
_do_cls_ret
	ret

' 
' '-------------------- color
' 
' sub do_color
_do_color
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	objptr, ##28200
	wrlong	local01, objptr
	sub	objptr, ##28200
	mov	ptra, fp
	call	#popregs_
_do_color_ret
	ret

' 
' '-------------------- cos
' 
' sub do_cos
_do_cos
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "cos: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1290
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5635
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1291
LR__1290
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##41916
	rdlong	local01, objptr
	sub	objptr, ##41916
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, ##1070141403
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system____builtin_sinf
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1291
	mov	ptra, fp
	call	#popregs_
_do_cos_ret
	ret

' 
' '-------------------- cursor
' 
' sub do_cursor
_do_cursor
	call	#_pop
	cmps	result1, #0 wz
' t1=pop()
' if t1.result.uresult=0 then  v.setspritesize(17,0,0) else v.setspritesize(17,8,16) 
 if_ne	jmp	#LR__1300
	mov	arg01, #17
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritesize
	jmp	#LR__1301
LR__1300
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_hg010b_spin2_setspritesize
LR__1301
_do_cursor_ret
	ret

' 
' '-------------------- defenv
' 
' sub do_defenv
_do_defenv
	mov	COUNT_, #8
	call	#pushregs_
	add	ptra, #88
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg05, local01
	shl	arg05, #1
	add	arg05, local01
	shl	arg05, #2
	sub	objptr, ##1540
	add	arg05, objptr
	rdlong	arg05, arg05
	add	fp, #16
	wrlong	arg05, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>2 andalso numpar<>5 then return 			' TODO and print error
	sub	fp, #16
	cmp	arg05, #2 wz
	sub	objptr, ##36476
 if_ne	add	fp, #16
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #16
 if_ne	cmp	local01, #5 wz
 if_ne	jmp	#LR__1331
' 
' if numpar=2 then						' env from .h2 or from a pointer
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #2 wz
 if_ne	jmp	#LR__1323
	call	#_pop
	mov	arg05, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
'   t1=pop()
'   if t1.result_type=result_string2 then 
	sub	fp, #72
	cmp	arg05, #43 wz
 if_ne	jmp	#LR__1310
	add	fp, #64
	rdlong	arg01, fp
	sub	fp, #64
	call	#_convertstring
	add	fp, #76
	wrlong	result1, fp
	sub	fp, #76
	jmp	#LR__1313
LR__1310
	add	fp, #72
	rdlong	local01, fp
	sub	fp, #72
	cmp	local01, #31 wz
 if_ne	jmp	#LR__1311
	add	fp, #64
	rdlong	local01, fp
	add	fp, #12
	wrlong	local01, fp
	sub	fp, #76
	jmp	#LR__1312
LR__1311
	mov	local01, ##@LR__5636
	add	fp, #76
	wrlong	local01, fp
	sub	fp, #12
	mov	arg01, fp
	sub	fp, #64
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
LR__1312
LR__1313
'   if s1<>"" then 
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	mov	arg02, ##@LR__5637
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1317
	call	#_pop
	mov	local01, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #24
'     t1=pop()
'     channel=converttoint(t1) 
'     close #9 : open "/sd/media/h/"+s1 for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	mov	arg01, ##@LR__5638
	add	fp, #76
	rdlong	arg02, fp
	sub	fp, #76
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	sub	ptr___system__dat__, #32
	add	fp, #12
	wrlong	result1, fp
'     r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return   
	sub	fp, #12
 if_e	jmp	#LR__1314
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5639
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5640
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local01, #0
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1331
LR__1314
'     get #9,17,envbuf8(channel,0),256
	add	fp, #24
	rdlong	arg05, fp
	sub	fp, #24
	mov	arg03, arg05
	shl	arg03, #9
	add	arg03, arg05
	add	objptr, ##6360
	add	arg03, objptr
	mov	arg01, #9
	mov	arg02, #17
	mov	arg04, #256
	mov	arg05, #1
	sub	objptr, ##6360
	call	#__system___basic_get
'     for i=255 to 0 step -1 : envbuf(channel,i)=envbuf8(channel,i)*256 : next i
	add	fp, #20
	wrlong	#255, fp
	sub	fp, #20
	add	objptr, ##6360
	callpa	#(@LR__1316-@LR__1315)>>2,fcache_load_ptr_
LR__1315
	add	fp, #24
	rdlong	arg03, fp
	mov	local01, arg03
	shl	local01, #9
	add	local01, objptr
	sub	fp, #4
	rdlong	arg05, fp
	mov	arg04, arg05
	shl	arg04, #1
	add	arg04, local01
	mov	local01, arg03
	shl	local01, #9
	add	local01, arg03
	add	local01, objptr
	add	arg05, local01
	rdbyte	local01, arg05
	mul	local01, #256
	wrword	local01, arg04
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #20
	cmps	local01, #0 wc
 if_ae	jmp	#LR__1315
LR__1316
	sub	objptr, ##6360
'     close #9
	mov	arg01, #9
	call	#__system__close
	add	fp, #24
	rdlong	local01, fp
	sub	fp, #24
	shl	local01, #9
	add	objptr, ##6360
	add	local01, objptr
	add	local01, #510
	wrword	#0, local01
'     envbuf(channel,255)=0                                                              
'     return
	sub	objptr, ##6360
	jmp	#LR__1331
LR__1317
'     if wptr < $80000 then 
	add	fp, #28
	rdlong	local02, fp
	sub	fp, #28
	cmps	local02, ##524288 wc
 if_ae	jmp	#LR__1320
'       for i=0 to 255: envbuf(channel,i)=dpeek(wptr+2*i): next i
	add	fp, #20
	wrlong	#0, fp
	sub	fp, #20
	add	objptr, ##6360
	callpa	#(@LR__1319-@LR__1318)>>2,fcache_load_ptr_
LR__1318
	add	fp, #24
	rdlong	local02, fp
	shl	local02, #9
	add	local02, objptr
	sub	fp, #4
	rdlong	local01, fp
	mov	arg05, local01
	shl	arg05, #1
	add	arg05, local02
	add	fp, #8
	rdlong	arg01, fp
	shl	local01, #1
	add	arg01, local01
	rdword	result1, arg01
	wrword	result1, arg05
	sub	fp, #8
	rdlong	local02, fp
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #20
	cmps	local02, #256 wc
 if_b	jmp	#LR__1318
LR__1319
	sub	objptr, ##6360
	jmp	#LR__1322
LR__1320
'       for i=0 to 255: envbuf(channel,i)=psdpeek(wptr+2*i) : next i
	add	fp, #20
	wrlong	#0, fp
	sub	fp, #20
LR__1321
	add	fp, #24
	rdlong	local02, fp
	shl	local02, #9
	add	objptr, ##6360
	add	local02, objptr
	sub	fp, #4
	rdlong	local01, fp
	mov	local03, local01
	shl	local03, #1
	add	local03, local02
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #28
	shl	local01, #1
	add	arg01, local01
	sub	objptr, ##6360
	call	#_psdpeek
	wrword	result1, local03
	add	fp, #20
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #20
	cmps	local03, #256 wc
 if_b	jmp	#LR__1321
LR__1322
	add	fp, #24
	rdlong	local03, fp
	sub	fp, #24
	shl	local03, #9
	add	objptr, ##6360
	add	local03, objptr
	add	local03, #510
	wrword	#0, local03
'     envbuf(channel,255)=0
'     return   
	sub	objptr, ##6360
	jmp	#LR__1331
LR__1323
' 
' if numpar=5 then   						 'simple adsr
	add	fp, #16
	rdlong	local02, fp
	sub	fp, #16
	cmp	local02, #5 wz
 if_ne	jmp	#LR__1330
	call	#_pop
	mov	local01, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttofloat
	mov	local02, result1
	add	fp, #44
	wrlong	local02, fp
	sub	fp, #44
	call	#_pop
	mov	local01, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttofloat
	mov	local02, result1
	add	fp, #40
	wrlong	local02, fp
	sub	fp, #40
	call	#_pop
	mov	local01, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttofloat
	mov	local02, result1
	add	fp, #36
	wrlong	local02, fp
	sub	fp, #36
	call	#_pop
	mov	local01, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttofloat
	mov	local02, result1
	add	fp, #32
	wrlong	local02, fp
	sub	fp, #32
	call	#_pop
	mov	local01, result3
	add	fp, #64
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #64
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
'   t1=pop() : rr=converttofloat(t1)
'   t1=pop() : ss=converttofloat(t1) 
'   t1=pop() : dd=converttofloat(t1)
'   t1=pop() : aa=converttofloat(t1)
'   t1=pop() : channel=converttoint(t1)
'   if ss<0.0 then ss=0.0 
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #40
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	add	fp, #40
 if_b	wrlong	#0, fp
 if_b	sub	fp, #40
'   if ss>1.0 then ss=1.0
	add	fp, #40
	rdlong	arg01, fp
	sub	fp, #40
	mov	arg02, ##1065353216
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	add	fp, #40
 if_ae	wrlong	##1065353216, fp
 if_ae	sub	fp, #40
	add	fp, #32
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #36
	call	#__system___float_add
	mov	arg01, result1
	add	fp, #44
	rdlong	arg02, fp
	sub	fp, #44
	call	#__system___float_add
	add	fp, #48
	wrlong	result1, fp
	mov	arg02, result1
	sub	fp, #48
	mov	arg01, ##1132462080
	call	#__system___float_div
	add	fp, #52
	wrlong	result1, fp
	sub	fp, #20
	rdlong	arg01, fp
	mov	arg02, result1
	sub	fp, #32
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	wrlong	result1, fp
	add	fp, #36
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #52
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #4
	wrlong	result1, fp
	add	fp, #40
	rdlong	arg01, fp
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #52
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	mov	local02, ##1199566848
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	add	fp, #56
	wrlong	result1, fp
	mov	local02, ##1199566848
	sub	fp, #16
	rdlong	arg02, fp
	sub	fp, #40
	mov	arg01, ##1199566848
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local02
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local02, result1
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	add	fp, #36
	wrlong	result1, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #40
	mov	arg01, ##1199566848
	call	#__system___float_mul
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	add	fp, #60
	wrlong	result1, fp
	sub	fp, #36
	rdlong	local05, fp
	sub	fp, #24
	shl	local05, #1
	add	objptr, ##41928
	add	local05, objptr
	rdlong	local06, fp
	add	fp, #4
	rdlong	local03, fp
	add	local06, local03
	wrword	local06, local05
	add	fp, #28
	wrlong	#0, fp
'   fulltime=aa+dd+rr
'   timeunit=256/fulltime : a=round(aa*timeunit) : d=round(dd*timeunit) : r=round(rr*timeunit)  
'   da=65520.0/a : dd=(65520.0-65520.0*ss)/d : dr=(65520.0*ss)/r  
'   suspoints(channel)=a+d
'   aa=0.0 : for i=0 to a-1  : envbuf(channel,i)=round(aa): aa+=da : next i
	sub	fp, #12
	wrlong	#0, fp
	sub	fp, #20
	rdlong	local07, fp
	sub	objptr, ##41928
LR__1324
	add	fp, #20
	rdlong	local02, fp
	sub	fp, #20
	cmps	local02, local07 wc
 if_ae	jmp	#LR__1325
	add	fp, #24
	rdlong	local06, fp
	shl	local06, #9
	add	objptr, ##6360
	add	local06, objptr
	sub	fp, #4
	rdlong	local05, fp
	shl	local05, #1
	add	local05, local06
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #32
	sub	objptr, ##6360
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local05
	add	fp, #32
	rdlong	arg01, fp
	add	fp, #24
	rdlong	arg02, fp
	sub	fp, #56
	call	#__system___float_add
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #12
	rdlong	local06, fp
	add	local06, #1
	wrlong	local06, fp
	sub	fp, #20
	jmp	#LR__1324
LR__1325
'   for i=a to (a+d-1) : envbuf(channel,i)=round(aa) : aa=aa-dd : if aa<0.0 then aa=0.0
	rdlong	local02, fp
	add	fp, #20
	wrlong	local02, fp
	sub	fp, #20
	rdlong	local08, fp
	add	fp, #4
	rdlong	local02, fp
	sub	fp, #4
	add	local08, local02
LR__1326
	add	fp, #20
	rdlong	local02, fp
	sub	fp, #20
	cmps	local02, local08 wc
 if_ae	jmp	#LR__1327
	add	fp, #24
	rdlong	local07, fp
	shl	local07, #9
	add	objptr, ##6360
	add	local07, objptr
	sub	fp, #4
	rdlong	local06, fp
	shl	local06, #1
	add	local06, local07
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #32
	sub	objptr, ##6360
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local06
	add	fp, #32
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #36
	bitnot	arg02, #31
	call	#__system___float_add
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	mov	arg01, result1
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	add	fp, #32
 if_b	wrlong	#0, fp
 if_b	sub	fp, #32
	add	fp, #20
	rdlong	local07, fp
	add	local07, #1
	wrlong	local07, fp
	sub	fp, #20
	jmp	#LR__1326
LR__1327
'   for i=(a+d) to 255 : envbuf(channel,i)=round(aa): aa=aa-dr : if aa<0.0 then aa=0.0
	rdlong	local02, fp
	add	fp, #4
	rdlong	local08, fp
	add	local02, local08
	add	fp, #16
	wrlong	local02, fp
	sub	fp, #20
LR__1328
	add	fp, #20
	rdlong	local05, fp
	sub	fp, #20
	cmps	local05, #256 wc
 if_ae	jmp	#LR__1329
	add	fp, #24
	rdlong	local08, fp
	shl	local08, #9
	add	objptr, ##6360
	add	local08, objptr
	sub	fp, #4
	rdlong	local07, fp
	shl	local07, #1
	add	local07, local08
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #32
	sub	objptr, ##6360
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local07
	add	fp, #32
	rdlong	arg01, fp
	add	fp, #28
	rdlong	arg02, fp
	sub	fp, #60
	bitnot	arg02, #31
	call	#__system___float_add
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	mov	arg01, result1
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	add	fp, #32
 if_b	wrlong	#0, fp
 if_b	sub	fp, #32
	add	fp, #20
	rdlong	local08, fp
	add	local08, #1
	wrlong	local08, fp
	sub	fp, #20
	jmp	#LR__1328
LR__1329
	add	fp, #24
	rdlong	local05, fp
	sub	fp, #24
	shl	local05, #9
	add	objptr, ##6360
	add	local05, objptr
	add	local05, #510
	wrword	#0, local05
	sub	objptr, ##6360
LR__1330
	add	fp, #24
	rdlong	local05, fp
	sub	fp, #24
	shl	local05, #9
	add	objptr, ##6360
	add	local05, objptr
	add	local05, #510
	wrword	#0, local05
	sub	objptr, ##6360
LR__1331
	mov	ptra, fp
	call	#popregs_
_do_defenv_ret
	ret

' 
' '-------------------- defsnd
' 
' sub do_defsnd
_do_defsnd
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #136
	add	objptr, ##38016
	rdlong	arg05, objptr
	mov	arg04, arg05
	shl	arg04, #1
	add	arg04, arg05
	shl	arg04, #2
	sub	objptr, ##1540
	add	arg04, objptr
	rdlong	arg05, arg04
	wrlong	arg05, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' 
' ' defsnd channel, string - tries to load from /media/s an s2 file from PC-Softsynth
' ' defsnd channel, h1,h2.... h15 - defines harmonics
' ' defsnd channel, negfloat, negfloat - defines even and odd harmonics dampening
' ' defsnd channel, oneint - loads the wave from the pointer
' 
' if numpar<2 then return
	cmps	arg05, #2 wc
	sub	objptr, ##36476
 if_b	jmp	#LR__1363
'  
' if numpar=2 then
	rdlong	arg05, fp
	cmp	arg05, #2 wz
 if_ne	jmp	#LR__1350
	call	#_pop
	mov	arg05, result3
	add	fp, #44
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
'   t1=pop()
'   if t1.result_type=result_string2 then 
	sub	fp, #52
	cmp	arg05, #43 wz
 if_ne	jmp	#LR__1340
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #44
	call	#_convertstring
	add	fp, #56
	wrlong	result1, fp
	sub	fp, #56
	jmp	#LR__1343
LR__1340
	add	fp, #52
	rdlong	arg05, fp
	sub	fp, #52
	cmp	arg05, #31 wz
 if_ne	jmp	#LR__1341
	add	fp, #44
	rdlong	arg05, fp
	add	fp, #12
	wrlong	arg05, fp
	sub	fp, #56
	jmp	#LR__1342
LR__1341
	mov	arg05, ##@LR__5641
	add	fp, #56
	wrlong	arg05, fp
	sub	fp, #12
	mov	arg01, fp
	sub	fp, #44
	call	#_converttoint
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
LR__1342
LR__1343
'   if s<>"" then 
	add	fp, #56
	rdlong	arg01, fp
	sub	fp, #56
	mov	arg02, ##@LR__5642
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1346
	call	#_pop
	mov	arg05, result3
	add	fp, #44
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #44
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
'     t1=pop()
'     channel=converttoint(t1) : if channel>31 then return
	mov	arg05, result1
	sub	fp, #16
	cmps	arg05, #32 wc
 if_ae	jmp	#LR__1363
'     close #9 : open "/sd/media/s/"+s for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	mov	arg01, ##@LR__5643
	add	fp, #56
	rdlong	arg02, fp
	sub	fp, #56
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	sub	ptr___system__dat__, #32
	add	objptr, ##42016
	wrlong	result1, objptr
'     r=geterr() : if r then print "System error ";r;": ";strerror$(r) :close #9 : return   
	sub	objptr, ##42016
 if_e	jmp	#LR__1344
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5644
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##42016
	rdlong	arg02, objptr
	sub	objptr, ##42016
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5645
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local01, #0
	add	objptr, ##42016
	rdlong	arg01, objptr
	sub	objptr, ##42016
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1363
LR__1344
'     for i=0 to 1024 : get #9,17+2*i,sample,1 : psdpoke 2048*channel+2*i, sample : next i
	add	fp, #4
	wrlong	#0, fp
LR__1345
	rdlong	local01, fp
	shl	local01, #1
	mov	arg02, #17
	add	arg02, local01
	add	fp, #120
	mov	arg03, fp
	sub	fp, #124
	mov	arg01, #9
	mov	arg04, #1
	mov	arg05, #2
	call	#__system___basic_get
	add	fp, #16
	rdlong	arg01, fp
	shl	arg01, #11
	sub	fp, #12
	rdlong	local01, fp
	shl	local01, #1
	add	arg01, local01
	add	fp, #120
	rdword	arg02, fp
	sub	fp, #124
	signx	arg02, #15
	call	#_psdpoke
	add	fp, #4
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	cmps	local01, ##1025 wc
 if_b	jmp	#LR__1345
	sub	fp, #4
'     close #9
	mov	arg01, #9
	call	#__system__close
'     return
	jmp	#LR__1363
LR__1346
'     if wptr < ($80000 - 2048) then 
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmps	local01, ##522240 wc
 if_ae	jmp	#LR__1348
'       for i=0 to 1023: psdpoke 2048*channel+2*i,dpeek(wptr+2*i): next i
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__1347
	add	fp, #16
	rdlong	local01, fp
	shl	local01, #11
	sub	fp, #12
	rdlong	arg05, fp
	mov	arg04, arg05
	shl	arg04, #1
	add	local01, arg04
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	shl	arg05, #1
	add	arg01, arg05
	rdword	arg02, arg01
	mov	arg01, local01
	call	#_psdpoke
	add	fp, #4
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	sub	fp, #4
	cmps	local01, ##1024 wc
 if_b	jmp	#LR__1347
	jmp	#LR__1363
LR__1348
'       for i=0 to 1023 : psdpoke 2048*channel+2*i,psdpeek(wptr+2*i) : next i
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__1349
	add	fp, #16
	rdlong	local01, fp
	shl	local01, #11
	sub	fp, #12
	rdlong	arg05, fp
	mov	arg04, arg05
	shl	arg04, #1
	add	local01, arg04
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	shl	arg05, #1
	add	arg01, arg05
	call	#_psdpeek
	mov	arg02, result1
	mov	arg01, local01
	call	#_psdpoke
	add	fp, #4
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	sub	fp, #4
	cmps	local01, ##1024 wc
 if_b	jmp	#LR__1349
'     return 
	jmp	#LR__1363
'   return
LR__1350
' for i=0 to 15 : harm(i)=0: next i  
	add	fp, #4
	wrlong	#0, fp
	callpa	#(@LR__1352-@LR__1351)>>2,fcache_load_ptr_
LR__1351
	rdlong	local01, fp
	shl	local01, #2
	add	fp, #56
	add	local01, fp
	wrlong	#0, local01
	sub	fp, #56
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	cmps	local01, #16 wc
 if_b	jmp	#LR__1351
LR__1352
	sub	fp, #4
' for i=numpar to 2 step -1 
	rdlong	local01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #4
LR__1353
	call	#_pop
	add	fp, #44
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #48
	rdlong	local01, fp
	sub	local01, #2
	shl	local01, #2
	add	fp, #56
	add	local01, fp
	sub	fp, #16
	mov	arg01, fp
	sub	fp, #44
	call	#_converttofloat
	wrlong	result1, local01
	add	fp, #4
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #4
	cmps	local01, #2 wc
 if_ae	jmp	#LR__1353
	call	#_pop
	mov	local01, result3
	add	fp, #44
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #44
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
' t1=pop()
' channel=converttoint(t1) : : if channel>31 then return
	mov	local01, result1
	sub	fp, #16
	cmps	local01, #32 wc
 if_ae	jmp	#LR__1363
	add	fp, #32
	wrlong	#0, fp
' max=0
' if harm(0)<0 then
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__1356
	add	fp, #60
	rdlong	result1, fp
	bitl	result1, #31
	sub	fp, #36
	wrlong	result1, fp
	add	fp, #40
	rdlong	result1, fp
	bitl	result1, #31
	sub	fp, #36
	wrlong	result1, fp
	add	fp, #32
	wrlong	##1065353216, fp
	sub	fp, #36
	rdlong	local01, fp
	add	fp, #40
	wrlong	local01, fp
	sub	fp, #36
	rdlong	local01, fp
	add	fp, #40
	wrlong	local01, fp
'   harm(0)=1
'   harm(1)=even
'   harm(2)=odd
'   for i=3 to 15 step 2 : harm(i)=harm(i-2)*even : next i
	sub	fp, #64
	wrlong	#3, fp
LR__1354
	rdlong	arg05, fp
	mov	local02, arg05
	shl	local02, #2
	add	fp, #56
	add	local02, fp
	sub	arg05, #2
	shl	arg05, #2
	add	arg05, fp
	rdlong	arg01, arg05
	sub	fp, #36
	rdlong	arg02, fp
	sub	fp, #24
	call	#__system___float_mul
	wrlong	result1, local02
	add	fp, #4
	rdlong	local03, fp
	add	local03, #2
	wrlong	local03, fp
	cmps	local03, #16 wc
 if_b	jmp	#LR__1354
'   for i=4 to 14 step 2 : harm(i)=harm(i-2)*odd : next i
	wrlong	#4, fp
LR__1355
	rdlong	local03, fp
	mov	local02, local03
	shl	local02, #2
	add	fp, #56
	add	local02, fp
	sub	local03, #2
	shl	local03, #2
	add	local03, fp
	rdlong	arg01, local03
	sub	fp, #32
	rdlong	arg02, fp
	sub	fp, #28
	call	#__system___float_mul
	wrlong	result1, local02
	add	fp, #4
	rdlong	local03, fp
	add	local03, #2
	wrlong	local03, fp
	cmps	local03, #15 wc
 if_b	jmp	#LR__1355
	sub	fp, #4
LR__1356
' if harm(0)>=0 then ' synthesize with harmonics
	add	fp, #60
	rdlong	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1362
'   for i=0 to 1023
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__1357
	add	fp, #36
	wrlong	#0, fp
'     spl=0
'     for j=0 to 15 : spl+=harm(j)*sin((1.0/512)*3.14159265359*i*(j+1)) : next j 
	sub	fp, #28
	wrlong	#0, fp
LR__1358
	rdlong	local02, fp
	shl	local02, #2
	add	fp, #52
	add	local02, fp
	rdlong	local03, local02
	mov	local02, ##1003032539
	sub	fp, #56
	rdlong	arg01, fp
	sub	fp, #4
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_mul
	mov	local02, result1
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_mul
	mov	arg02, result1
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	call	#__system___float_add
	add	fp, #36
	wrlong	result1, fp
	sub	fp, #28
	rdlong	arg03, fp
	add	arg03, #1
	wrlong	arg03, fp
	cmps	arg03, #16 wc
 if_b	jmp	#LR__1358
'     if abs(spl)>max then max=abs(spl)  
	add	fp, #28
	rdlong	arg01, fp
	bitl	arg01, #31
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #32
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1359
	add	fp, #36
	rdlong	result1, fp
	bitl	result1, #31
	sub	fp, #4
	wrlong	result1, fp
	sub	fp, #32
LR__1359
	add	fp, #4
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #4
	cmps	local03, ##1024 wc
 if_b	jmp	#LR__1357
'   for i=0 to 1023
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #4
LR__1360
	add	fp, #36
	wrlong	#0, fp
'     spl=0
'     for j=0 to 15: spl+=harm(j)*(32600.0/max)*sin(1.0/512*3.14159265359*i*(j+1)) :next j 
	sub	fp, #28
	wrlong	#0, fp
LR__1361
	rdlong	local03, fp
	shl	local03, #2
	add	fp, #52
	add	local03, fp
	rdlong	local03, local03
	sub	fp, #28
	rdlong	arg02, fp
	sub	fp, #32
	mov	arg01, ##1191096320
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_mul
	mov	local03, result1
	mov	local02, ##1003032539
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_mul
	mov	local02, result1
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_mul
	mov	arg02, result1
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	call	#__system___float_add
	add	fp, #36
	wrlong	result1, fp
	sub	fp, #28
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	cmps	local03, #16 wc
 if_b	jmp	#LR__1361
	add	fp, #8
	rdlong	local03, fp
	shl	local03, #11
	sub	fp, #12
	rdlong	local02, fp
	shl	local02, #1
	add	local03, local02
	add	fp, #32
	rdlong	arg01, fp
	sub	fp, #36
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	arg02, result1
	mov	arg01, local03
	call	#_psdpoke
	add	fp, #4
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #4
	cmps	local03, ##1024 wc
 if_b	jmp	#LR__1360
LR__1362
LR__1363
	mov	ptra, fp
	call	#popregs_
_do_defsnd_ret
	ret

' 
' '-------------------- defsprite
' 
' sub do_defsprite
_do_defsprite
	mov	COUNT_, #7
	call	#pushregs_
	add	ptra, #96
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #48
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #56
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #36
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #44
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #60
	wrlong	result1, fp
	sub	fp, #48
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #64
	wrlong	result1, fp
	sub	fp, #40
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	add	fp, #68
	wrlong	result1, fp
	sub	fp, #32
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	add	fp, #72
	wrlong	result1, fp
	sub	fp, #24
	mov	arg01, fp
	sub	fp, #48
	call	#_converttoint
	add	fp, #76
	wrlong	result1, fp
' 
' t5=pop()
' t4=pop()
' t3=pop()
' t2=pop()
' t1=pop()
' a1=converttoint(t1) : a2=converttoint(t2) : a3=converttoint(t3) : a4=converttoint(t4) : a5=converttoint(t5) ' do convert, defsprite is not a racing command
' if sprite(a1)<> nil then delete(sprite(a1))	' todo: check parameters for limits
	sub	fp, #16
	rdlong	arg03, fp
	sub	fp, #60
	shl	arg03, #2
	add	objptr, ##41832
	add	arg03, objptr
	rdlong	arg03, arg03 wz
	sub	objptr, ##41832
 if_e	jmp	#LR__1370
	add	fp, #60
	rdlong	arg03, fp
	sub	fp, #60
	shl	arg03, #2
	add	objptr, ##41832
	add	arg03, objptr
	rdlong	arg01, arg03
	sub	objptr, ##41832
	call	#__system___gc_free
LR__1370
	add	fp, #60
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg02, fp
	qmul	arg03, arg02
	shl	local01, #2
	add	objptr, ##41832
	add	local01, objptr
	sub	fp, #76
	sub	objptr, ##41832
	getqx	arg01
	call	#__system___gc_alloc_managed
	wrlong	result1, local01
' for y=a3 to a3+a5-1
	add	fp, #68
	rdlong	local02, fp
	add	fp, #12
	wrlong	local02, fp
	sub	fp, #12
	rdlong	local03, fp
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #76
	add	local03, local04
LR__1371
	add	fp, #80
	rdlong	local02, fp
	sub	fp, #80
	cmps	local02, local03 wc
 if_ae	jmp	#LR__1374
'   for x=a2 to a4+a2-1
	add	fp, #64
	rdlong	local01, fp
	add	fp, #20
	wrlong	local01, fp
	sub	fp, #12
	rdlong	local05, fp
	sub	fp, #8
	rdlong	local06, fp
	sub	fp, #64
	add	local05, local06
LR__1372
	add	fp, #84
	rdlong	local01, fp
	sub	fp, #84
	cmps	local01, local05 wc
 if_ae	jmp	#LR__1373
	add	fp, #60
	rdlong	local06, fp
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #20
	rdlong	local02, fp
	add	fp, #16
	rdlong	local01, fp
	mov	arg03, local01
	sub	fp, #12
	rdlong	arg02, fp
	sub	arg03, arg02
	add	fp, #4
	rdlong	arg02, fp
	qmul	arg03, arg02
	shl	local06, #2
	add	objptr, ##41832
	add	local06, objptr
	rdlong	local06, local06
	mov	local07, local04
	sub	local07, local02
	sub	objptr, ##41832
	rdlong	arg01, objptr
	add	arg01, local04
	sub	fp, #72
	shl	local01, #10
	add	arg01, local01
	getqx	local04
	add	local07, local04
	add	local07, local06
	call	#_pspeek
	wrbyte	result1, local07
	add	fp, #84
	rdlong	local07, fp
	add	local07, #1
	wrlong	local07, fp
	sub	fp, #84
	jmp	#LR__1372
LR__1373
	add	fp, #80
	rdlong	local07, fp
	add	local07, #1
	wrlong	local07, fp
	sub	fp, #80
	jmp	#LR__1371
LR__1374
	add	fp, #60
	rdlong	local07, fp
	mov	arg01, local07
	sub	fp, #60
	shl	local07, #2
	add	objptr, ##41832
	add	local07, objptr
	rdlong	arg02, local07
	sub	objptr, ##41832
	call	#_hg010b_spin2_setspriteptr
	add	fp, #60
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #76
	call	#_hg010b_spin2_setspritesize
	mov	ptra, fp
	call	#popregs_
_do_defsprite_ret
	ret

' 
' '-------------------- deg
' 
' sub do_deg
_do_deg
	add	objptr, ##41916
	wrlong	##1016003125, objptr
	add	objptr, #4
	wrlong	##1113927393, objptr
	sub	objptr, ##41920
_do_deg_ret
	ret

' 
' '-------------------- delete
' 
' sub do_delete
_do_delete
	mov	COUNT_, #5
	call	#pushregs_
	call	#_pop
	mov	arg04, result2
	mov	arg03, result3
	mov	local01, result1
	mov	local02, arg04
	mov	local03, arg03
' 
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1380
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1380
' if t1.result_type<>result_string then printerror(15): return
	cmp	local03, #31 wz
 if_e	jmp	#LR__1381
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1385
LR__1381
' if currentdir$<>"/" then filename$=currentdir$+"/"+t1.result.sresult else filename$="/"+t1.result.sresult
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5646
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1382
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5647
	call	#__system___string_concat
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___string_concat
	mov	local04, result1
	jmp	#LR__1383
LR__1382
	mov	arg01, ##@LR__5648
	mov	arg02, local01
	call	#__system___string_concat
	mov	local04, result1
LR__1383
	mov	arg01, local04
	call	#__system___remove
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	local05, result1 wz
' kill filename$
' err=geterr() : if err<>0 then print "Cannot delete file or file doesn't exist: system error "; err
 if_e	jmp	#LR__1384
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5649
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local05
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1384
LR__1385
	mov	ptra, fp
	call	#popregs_
_do_delete_ret
	ret

' 
' '-------------------- dir
' 
' sub do_dir
_do_dir
	mov	COUNT_, #19
	call	#pushregs_
	add	ptra, ##568
' 
' print "Current directory: "; currentdir$ 
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5650
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##38036
	rdlong	arg02, objptr
	sub	objptr, ##38036
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local01, #1
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	local02, #0
	mov	local03, #0
' px=0
' for i=0 to 127: filelist(i)="" : next i
	mov	local04, #0
	add	fp, #28
	callpa	#(@LR__1391-@LR__1390)>>2,fcache_load_ptr_
LR__1390
	mov	local05, local04
	shl	local05, #2
	add	local05, fp
	mov	local06, ##@LR__5651
	wrlong	local06, local05
	add	local04, #1
	cmps	local04, #128 wc
 if_b	jmp	#LR__1390
LR__1391
	sub	fp, #28
	mov	arg01, ##@LR__5652
	mov	arg02, #16
	call	#__system___basic_dir
	mov	local07, result1
	mov	local08, #0
' filename=dir$("*", fbDirectory)
' n=0
' while filename <> "" andalso filename <> nil andalso n<128
LR__1392
	mov	local09, ##@LR__5653
	mov	arg01, local07
	mov	arg02, local09
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1393
	mov	local09, #0
	mov	arg01, local07
	mov	arg02, #0
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1393
	cmps	local08, #128 wc
 if_ae	jmp	#LR__1393
	mov	arg01, ##@LR__5654
	mov	arg02, local07
	call	#__system___string_concat
	mov	local07, result1
	mov	local05, local08
	shl	local05, #2
	add	fp, #28
	add	local05, fp
	wrlong	local07, local05
	add	local08, #1
	mov	local05, #0
	mov	arg01, #0
	mov	arg02, #0
	sub	fp, #28
	call	#__system___basic_dir
	mov	local07, result1
	jmp	#LR__1392
LR__1393
' for i=0 to n-1			' now sort this
	mov	local04, #0
	mov	local10, local08
LR__1394
	cmps	local04, local10 wc
 if_ae	jmp	#LR__1398
	mov	local11, #0
'   swapped=false
'   for j=0 to n-i-2
	mov	local12, #0
	mov	local13, local08
	sub	local13, local04
	sub	local13, #1
LR__1395
	cmps	local12, local13 wc
 if_ae	jmp	#LR__1397
'     if filelist(j) > filelist(j+1) then
	mov	local09, local12
	shl	local09, #2
	add	fp, #28
	add	local09, fp
	rdlong	arg01, local09
	mov	local09, local12
	add	local09, #1
	mov	local06, local09
	shl	local06, #2
	mov	local01, fp
	add	local06, fp
	rdlong	local05, local06
	mov	arg02, local05
	sub	fp, #28
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1396
	mov	local09, local12
	add	local09, #1
	shl	local09, #2
	add	fp, #28
	add	local09, fp
	rdlong	local11, local09
	mov	local06, local12
	shl	local06, #2
	add	local06, fp
	rdlong	local05, local06
	mov	local09, local12
	mov	local06, local09
	shl	local06, #2
	mov	local01, fp
	add	local06, fp
	wrlong	local11, local06
	mov	local02, local12
	add	local02, #1
	mov	local14, local02
	shl	local14, #2
	mov	local15, fp
	add	local14, fp
	wrlong	local05, local14
	neg	local11, #1
	sub	fp, #28
LR__1396
	add	local12, #1
	jmp	#LR__1395
LR__1397
' if not swapped then exit for
	not	local16, local11
	cmp	local16, #0 wz
 if_e	add	local04, #1
 if_e	jmp	#LR__1394
LR__1398
' for i=0 to n-1
	mov	local04, #0
	mov	local17, local08
LR__1399
	cmps	local04, local17 wc
 if_ae	jmp	#LR__1401
'   print filelist(i); : px=px+64: v.setcursorx(px) : if px>255 then px=0: print
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	local02, local04
	shl	local02, #2
	add	fp, #28
	mov	local14, fp
	add	local02, fp
	rdlong	arg02, local02
	mov	local01, #0
	mov	arg01, #0
	mov	arg03, #0
	sub	fp, #28
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	local03, #64
	mov	arg01, local03
	call	#_hg010b_spin2_setcursorx
	cmps	local03, #256 wc
 if_b	jmp	#LR__1400
	mov	local03, #0
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1400
	add	local04, #1
	jmp	#LR__1399
LR__1401
' if n>=128  then print "More than 128 entries found: clean your directory"
	cmps	local08, #128 wc
 if_b	jmp	#LR__1402
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5655
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	local01, #0
LR__1402
' print
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	local06, #0
	mov	local08, #0
	mov	local03, #0
' return cursor_y
	add	objptr, #62
	rdbyte	local18, objptr
	sub	objptr, #62
	mov	arg01, ##@LR__5656
	mov	arg02, #33
	call	#__system___basic_dir
	mov	local07, result1
' n=0
' px=0: py=v.getcursory()
' filename = dir$("*", fbNormal )   
' do while filename <> "" andalso filename <> nil andalso n<128
LR__1403
	mov	local09, ##@LR__5657
	mov	arg01, local07
	mov	arg02, local09
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1404
	mov	local09, #0
	mov	arg01, local07
	mov	arg02, #0
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__1404
	cmps	local08, #128 wc
 if_ae	jmp	#LR__1404
	mov	local05, local08
	shl	local05, #2
	add	fp, #28
	add	local05, fp
	wrlong	local07, local05
	add	local08, #1
	mov	local05, #0
	mov	arg01, #0
	mov	arg02, #0
	sub	fp, #28
	call	#__system___basic_dir
	mov	local07, result1
	jmp	#LR__1403
LR__1404
' for i =0 to n-1
	mov	local04, #0
LR__1405
	cmps	local04, local08 wc
 if_ae	jmp	#LR__1409
	mov	local11, #0
'   swapped=false
'   for j=0 to n-i-2
	mov	local12, #0
	mov	local19, local08
	sub	local19, local04
	sub	local19, #1
LR__1406
	cmps	local12, local19 wc
 if_ae	jmp	#LR__1408
'     if filelist(j) > filelist(j+1) then
	mov	local09, local12
	shl	local09, #2
	add	fp, #28
	add	local09, fp
	rdlong	arg01, local09
	mov	local09, local12
	add	local09, #1
	mov	local06, local09
	shl	local06, #2
	mov	local01, fp
	add	local06, fp
	rdlong	local05, local06
	mov	arg02, local05
	sub	fp, #28
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1407
	mov	local09, local12
	add	local09, #1
	shl	local09, #2
	add	fp, #28
	add	local09, fp
	rdlong	local16, local09
	mov	local06, local12
	shl	local06, #2
	add	local06, fp
	rdlong	local05, local06
	mov	local09, local12
	mov	local06, local09
	shl	local06, #2
	mov	local01, fp
	add	local06, fp
	wrlong	local16, local06
	mov	local14, local12
	add	local14, #1
	shl	local14, #2
	mov	local15, fp
	add	local14, fp
	wrlong	local05, local14
	neg	local11, #1
	sub	fp, #28
LR__1407
	add	local12, #1
	jmp	#LR__1406
LR__1408
' if not swapped then exit for
	not	local16, local11
	cmp	local16, #0 wz
 if_e	add	local04, #1
 if_e	jmp	#LR__1405
LR__1409
' for i=0 to n-1
	mov	local04, #0
LR__1410
	cmps	local04, local08 wc
 if_ae	jmp	#LR__1412
'   print filelist(i); : px=px+64: v.setcursorx(px) : if px>255 then px=0: print
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	local02, local04
	shl	local02, #2
	add	fp, #28
	add	local02, fp
	rdlong	arg02, local02
	mov	arg01, #0
	mov	arg03, #0
	sub	fp, #28
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	local03, #64
	mov	arg01, local03
	call	#_hg010b_spin2_setcursorx
	cmps	local03, #256 wc
 if_b	jmp	#LR__1411
	mov	local03, #0
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1411
	add	local04, #1
	jmp	#LR__1410
LR__1412
' if n>=128  then print "More than 128 entries found: clean your directory"
	cmps	local08, #128 wc
 if_b	jmp	#LR__1413
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5658
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1413
' print
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	ptra, fp
	call	#popregs_
_do_dir_ret
	ret

' 
' '-------------------- dpeek
' 
' sub do_dpeek
_do_dpeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #12
	wrlong	result1, fp
' 
' t1=pop()
' a=converttoint(t1)
' if a<$80000 then r=dpeek(a) else r=psdpeek(a)
	sub	fp, #12
	cmp	result1, ##524288 wc
 if_ae	jmp	#LR__1420
	add	fp, #12
	rdlong	arg01, fp
	rdword	result1, arg01
	add	fp, #4
	wrlong	result1, fp
	sub	fp, #16
	jmp	#LR__1421
LR__1420
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_psdpeek
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
LR__1421
	add	fp, #8
	wrlong	#29, fp
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #16
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_dpeek_ret
	ret

' 
' '-------------------- dpoke
' 
' sub do_dpoke
_do_dpoke
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #24
	mov	arg01, fp
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
' 
' t1=pop() 'value
' t2=pop() 
' a=converttoint(t2) : v=converttoint(t1)
' if a<$80000 then dpoke a,v else psdpoke a,v
	sub	fp, #4
	rdlong	local01, fp
	sub	fp, #24
	cmp	local01, ##524288 wc
 if_ae	jmp	#LR__1430
	add	fp, #24
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	wrword	arg02, arg01
	jmp	#LR__1431
LR__1430
	add	fp, #24
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	call	#_psdpoke
LR__1431
	mov	ptra, fp
	call	#popregs_
_do_dpoke_ret
	ret

' '-------------------- draw
' 
' sub do_draw
_do_draw
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg05, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #12
	wrlong	arg05, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #20
	call	#_pop
	mov	arg05, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
	add	objptr, ##28204
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	fp, #4
	rdlong	arg03, fp
	mov	arg04, result1
	sub	fp, #24
	sub	objptr, #8
	rdlong	arg05, objptr
	sub	objptr, ##28200
	call	#_hg010b_spin2_draw
	add	fp, #24
	rdlong	arg05, fp
	add	objptr, ##28204
	wrlong	arg05, objptr
	add	fp, #4
	rdlong	arg05, fp
	sub	fp, #28
	add	objptr, #4
	wrlong	arg05, objptr
	sub	objptr, ##28208
	mov	ptra, fp
	call	#popregs_
_do_draw_ret
	ret

' 
' '-------------------- else
' 
' sub do_else
_do_else
	add	objptr, ##38012
	rdlong	_var01, objptr
	sub	_var01, #1
	add	objptr, #4
	wrlong	_var01, objptr
	sub	objptr, ##38016
_do_else_ret
	ret

' 
' '-------------------- end
' 
' sub do_end
_do_end
	add	objptr, ##38012
	rdlong	_var01, objptr
	sub	_var01, #1
	add	objptr, #4
	wrlong	_var01, objptr
	add	objptr, ##3128
	wrlong	##2147483647, objptr
	sub	objptr, ##41144
_do_end_ret
	ret

' 
' '-------------------- enter
' 
' sub do_enter
_do_enter
	mov	arg01, ##1234
	call	#_do_load
_do_enter_ret
	ret

' 
' '------------------- error processing
' 
' sub do_error
_do_error
	mov	COUNT_, #1
	call	#pushregs_
	add	objptr, ##38016
	rdlong	arg04, objptr
	mov	arg03, arg04
	shl	arg03, #1
	add	arg03, arg04
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	local01, arg03
' r=compiledline(lineptr_e).result.uresult
' print "Error ";r;": ";errors$(r)
	mov	arg01, #0
	sub	objptr, ##36476
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5659
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg02, ##@LR__5660
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	shl	local01, #2
	add	objptr, ##35452
	add	local01, objptr
	rdlong	arg02, local01
	mov	arg01, #0
	mov	arg03, #0
	sub	objptr, ##35452
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	ptra, fp
	call	#popregs_
_do_error_ret
	ret

' 
' '-------------------- fcircle
' 
' sub do_fcircle
_do_fcircle
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #36
	call	#_pop
	mov	arg02, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #24
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #32
	call	#_pop
	mov	arg02, result1
	mov	arg04, result2
	mov	arg03, result3
	add	fp, #12
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #20
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	arg03, result1
	add	objptr, ##28200
	rdlong	arg04, objptr
	sub	objptr, ##28200
	mov	arg01, local01
	mov	arg02, local02
	call	#_hg010b_spin2_fcircle
	mov	ptra, fp
	call	#popregs_
_do_fcircle_ret
	ret

' 
' '-------------------- fill
' 
' sub do_fill
_do_fill
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #36
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #44
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	local03, result1
	add	fp, #36
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	arg04, result1
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local03
	call	#_hg010b_spin2_fill
	mov	ptra, fp
	call	#popregs_
_do_fill_ret
	ret

' 
' '-------------------- font
' 
' sub do_font
_do_font
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' 
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1440
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1440
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1441
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1441
	add	objptr, ##28224
	wrlong	local01, objptr
	sub	objptr, ##28224
	shl	local01, #2
	mov	arg01, local01
	call	#_hg010b_spin2_setfontfamily
	mov	ptra, fp
	call	#popregs_
_do_font_ret
	ret

' 
' '-------------------- for
' 
' sub do_for()
_do_for
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##41224
	rdlong	arg01, objptr
	add	arg01, #1
	wrlong	arg01, objptr
	sub	objptr, ##41224
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##41224
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	rdlong	arg01, fp
	add	local01, #8
	wrlong	arg01, local01
	sub	objptr, ##38040
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##41224
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##38040
	call	#_converttoint
	mov	arg01, result1
	add	local01, #12
	wrlong	arg01, local01
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##41224
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##38040
	call	#_converttoint
	add	local01, #16
	wrlong	result1, local01
' fortop+=1
' t1=pop() : fortable(fortop).varnum=t1.result.iresult
' t1=pop() : fortable(fortop).stepval=converttoint(t1)
' t1=pop() : fortable(fortop).endval=converttoint(t1)
' if compiledline(lineptr_e).result_type=token_end then	' end of line after for, set the pointer to the start of the next line
	add	objptr, ##38016
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #1
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	add	local01, #8
	rdlong	local01, local01
	cmp	local01, #510 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__1450
	add	objptr, ##41224
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	add	objptr, ##3104
	rdlong	arg01, objptr
	wrlong	arg01, local01
	add	objptr, #80
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	add	local01, #4
	wrlong	#0, local01
	sub	objptr, ##38040
	jmp	#LR__1451
LR__1450
	add	objptr, ##41224
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	add	objptr, ##3112
	rdlong	arg01, objptr
	wrlong	arg01, local01
	add	objptr, #72
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #2
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	sub	objptr, #24
	rdlong	arg01, objptr
	sub	objptr, ##38016
	add	arg01, #1
	add	local01, #4
	wrlong	arg01, local01
LR__1451
	mov	ptra, fp
	call	#popregs_
_do_for_ret
	ret

' 
' '-------------------- frame
' 
' sub do_frame
_do_frame
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg05, result3
	add	fp, #36
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #44
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg05, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg05, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	local03, result1
	add	fp, #36
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	arg04, result1
	add	objptr, ##28200
	rdlong	arg05, objptr
	sub	objptr, ##28200
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local03
	call	#_hg010b_spin2_frame
	mov	ptra, fp
	call	#popregs_
_do_frame_ret
	ret

' 
' '-------------------- framebuf
' 
' sub do_framebuf
_do_framebuf
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	rdlong	arg01, objptr
	sub	fp, #8
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_framebuf_ret
	ret

' '-------------------- fre
' 
' sub do_fre
_do_fre
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #12
	add	objptr, ##41900
	rdlong	arg01, objptr
	sub	objptr, ##7504
	rdlong	local01, objptr
	sub	arg01, local01
	add	objptr, ##7620
	wrlong	arg01, objptr
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	rdlong	local01, objptr
	sub	objptr, ##42016
	wrlong	local01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_fre_ret
	ret

' 
' '-------------------- get
' 
' sub do_get		' get  #chn,addr,(amount,(pos))
_do_get
	mov	COUNT_, #9
	call	#pushregs_
	add	ptra, #64
	add	objptr, ##38016
	rdlong	arg05, objptr
	mov	arg04, arg05
	shl	arg04, #1
	add	arg04, arg05
	shl	arg04, #2
	sub	objptr, ##1540
	add	arg04, objptr
	rdlong	arg05, arg04
	wrlong	arg05, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=4  then t1=pop() : pos=converttoint(t1)   else pos=-1
	cmp	arg05, #4 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__1460
	call	#_pop
	mov	arg05, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	objptr, ##42012
	wrlong	result1, objptr
	sub	objptr, ##42012
	jmp	#LR__1461
LR__1460
	add	objptr, ##42012
	wrlong	##-1, objptr
	sub	objptr, ##42012
LR__1461
' if numpar>=3  then t1=pop() : amount=converttoint(t1) else amount=1
	rdlong	arg03, fp
	cmps	arg03, #3 wc
 if_b	jmp	#LR__1462
	call	#_pop
	mov	arg03, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	jmp	#LR__1463
LR__1462
	add	fp, #8
	wrlong	#1, fp
	sub	fp, #8
LR__1463
' if numpar>=2  then t1=pop() : adr=converttoint(t1)
	rdlong	arg03, fp
	cmps	arg03, #2 wc
 if_b	jmp	#LR__1464
	call	#_pop
	mov	arg03, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__1464
	call	#_pop
	mov	arg03, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	fp, #4
	wrlong	result1, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #20
	shl	arg03, #2
	add	objptr, ##41156
	mov	local01, objptr
	add	arg03, objptr
	wrlong	#0, arg03
' t1=pop() : channel=converttoint(t1)
' getres(j)=0
' if pos>=0 then
	add	objptr, ##856
	rdlong	local02, objptr
	sub	objptr, ##42012
	cmps	local02, #0 wc
 if_b	jmp	#LR__1471
'   for i=0 to  amount/1024
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	abs	local04, local03 wc
	shr	local04, #10
	negc	local04, local04
	add	local04, #1
LR__1465
	add	fp, #16
	rdlong	local03, fp
	sub	fp, #16
	cmps	local03, local04 wc
 if_ae	jmp	#LR__1479
'     get #channel,pos+1,block(0),amount,r
	add	fp, #4
	rdlong	arg01, fp
	add	objptr, ##42012
	rdlong	arg02, objptr
	add	arg02, #1
	sub	objptr, ##1896
	mov	arg03, objptr
	sub	objptr, ##40116
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #8
	mov	arg05, #1
	call	#__system___basic_get
	add	fp, #24
	wrlong	result1, fp
'     if adr<$80000 then for j=0 to r-1 : poke adr+1024*i+j,block(j):  next j else  for j=0 to r-1 : pspoke adr+1024*i+j,block(j):  next j  
	sub	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	cmps	local02, ##524288 wc
 if_ae	jmp	#LR__1467
	add	fp, #20
	wrlong	#0, fp
	add	fp, #4
	rdlong	local05, fp
	sub	fp, #24
LR__1466
	add	fp, #20
	rdlong	local02, fp
	sub	fp, #20
	cmps	local02, local05 wc
 if_ae	jmp	#LR__1470
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	rdlong	local03, fp
	shl	local03, #10
	add	arg01, local03
	add	fp, #4
	rdlong	local03, fp
	add	arg01, local03
	add	objptr, ##40116
	add	local03, objptr
	rdbyte	arg02, local03
	wrbyte	arg02, arg01
	sub	objptr, ##40116
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #20
	jmp	#LR__1466
LR__1467
	add	fp, #20
	wrlong	#0, fp
	add	fp, #4
	rdlong	local06, fp
	sub	fp, #24
LR__1468
	add	fp, #20
	rdlong	local02, fp
	sub	fp, #20
	cmps	local02, local06 wc
 if_ae	jmp	#LR__1469
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	rdlong	local05, fp
	shl	local05, #10
	add	arg01, local05
	add	fp, #4
	rdlong	local05, fp
	add	arg01, local05
	sub	fp, #20
	add	objptr, ##40116
	add	local05, objptr
	rdbyte	arg02, local05
	sub	objptr, ##40116
	call	#_pspoke
	add	fp, #20
	rdlong	local05, fp
	add	local05, #1
	wrlong	local05, fp
	sub	fp, #20
	jmp	#LR__1468
LR__1469
LR__1470
	add	fp, #20
	rdlong	local06, fp
	mov	local03, local06
	shl	local03, #2
	add	objptr, ##41156
	add	local03, objptr
	shl	local06, #2
	add	local06, objptr
	rdlong	local06, local06
	add	fp, #4
	rdlong	local05, fp
	add	local06, local05
	wrlong	local06, local03
	sub	fp, #8
	rdlong	local06, fp
	add	local06, #1
	wrlong	local06, fp
	sub	fp, #16
	sub	objptr, ##41156
	jmp	#LR__1465
LR__1471
'   for i=0 to  amount/1024
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	abs	local07, local03 wc
	shr	local07, #10
	negc	local07, local07
	add	local07, #1
LR__1472
	add	fp, #16
	rdlong	local03, fp
	sub	fp, #16
	cmps	local03, local07 wc
 if_ae	jmp	#LR__1478
'     get #channel,,block(0),amount,r
	add	fp, #4
	rdlong	arg01, fp
	add	objptr, ##40116
	mov	arg03, objptr
	sub	objptr, ##40116
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #8
	mov	arg02, #0
	mov	arg05, #1
	call	#__system___basic_get
	add	fp, #24
	wrlong	result1, fp
'     if adr<$80000 then for j=0 to r-1 : poke adr+1024*i+j,block(j):  next j else  for j=0 to r-1 : pspoke adr+1024*i+j,block(j):  next j  
	sub	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	cmps	local02, ##524288 wc
 if_ae	jmp	#LR__1474
	add	fp, #20
	wrlong	#0, fp
	add	fp, #4
	rdlong	local08, fp
	sub	fp, #24
LR__1473
	add	fp, #20
	rdlong	local02, fp
	sub	fp, #20
	cmps	local02, local08 wc
 if_ae	jmp	#LR__1477
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	rdlong	local06, fp
	shl	local06, #10
	add	arg01, local06
	add	fp, #4
	rdlong	local06, fp
	add	arg01, local06
	add	objptr, ##40116
	add	local06, objptr
	rdbyte	arg02, local06
	wrbyte	arg02, arg01
	sub	objptr, ##40116
	rdlong	local06, fp
	add	local06, #1
	wrlong	local06, fp
	sub	fp, #20
	jmp	#LR__1473
LR__1474
	add	fp, #20
	wrlong	#0, fp
	add	fp, #4
	rdlong	local09, fp
	sub	fp, #24
LR__1475
	add	fp, #20
	rdlong	local02, fp
	sub	fp, #20
	cmps	local02, local09 wc
 if_ae	jmp	#LR__1476
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	rdlong	local08, fp
	shl	local08, #10
	add	arg01, local08
	add	fp, #4
	rdlong	local08, fp
	add	arg01, local08
	sub	fp, #20
	add	objptr, ##40116
	add	local08, objptr
	rdbyte	arg02, local08
	sub	objptr, ##40116
	call	#_pspoke
	add	fp, #20
	rdlong	local08, fp
	add	local08, #1
	wrlong	local08, fp
	sub	fp, #20
	jmp	#LR__1475
LR__1476
LR__1477
	add	fp, #20
	rdlong	local09, fp
	mov	local06, local09
	shl	local06, #2
	add	objptr, ##41156
	add	local06, objptr
	shl	local09, #2
	add	local09, objptr
	rdlong	local09, local09
	add	fp, #4
	rdlong	local08, fp
	add	local09, local08
	wrlong	local09, local06
	sub	fp, #8
	rdlong	local09, fp
	add	local09, #1
	wrlong	local09, fp
	sub	fp, #16
	sub	objptr, ##41156
	jmp	#LR__1472
LR__1478
LR__1479
	mov	ptra, fp
	call	#popregs_
_do_get_ret
	ret

' 
' '-------------------- getenvsustain
' 
' sub do_getenvsustain
_do_getenvsustain
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "getenvsustain: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1480
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5661
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1481
LR__1480
	call	#_pop
	mov	local01, result1
	mov	arg03, result2
	wrlong	local01, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	local01, result1
	shl	local01, #1
	add	objptr, ##41928
	add	local01, objptr
	rdword	local01, local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	sub	objptr, ##41928
	call	#_push
LR__1481
	mov	ptra, fp
	call	#popregs_
_do_getenvsustain_ret
	ret

' 
' '-------------------- getnotevalue
' 
' sub do_getnotevalue
_do_getnotevalue
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #28
	call	#_pop
	mov	arg02, result3
	add	fp, #16
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #16
	call	#_converttoint
	abs	arg02, result1 wc
	qdiv	arg02, #12
	add	fp, #12
	wrlong	result1, fp
	add	objptr, ##10456
	sub	fp, #8
	getqy	arg02
	negc	arg02, arg02
	shl	arg02, #2
	add	arg02, objptr
	rdlong	arg02, arg02
	wrlong	arg02, fp
	add	fp, #8
	rdlong	arg02, fp
	abs	arg02, arg02 wc
	qdiv	arg02, #12
	sub	fp, #12
	sub	objptr, ##10456
	getqx	arg02
	negc	arg01, arg02
	abs	arg01, arg01 wc
 if_b	decod	local01, #31
 if_ae	mov	local01, #0
	call	#__system___float_fromuns
	xor	result1, local01
	add	fp, #8
	wrlong	result1, fp
	mov	arg02, result1
	sub	fp, #8
	decod	arg01, #30
	call	#__system____builtin_powf
	mov	arg01, result1
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #16
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #16
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_getnotevalue_ret
	ret

' 
' '-------------------- getpixel
' 
' sub do_getpixel
_do_getpixel
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #36
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
	add	fp, #24
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>2 then print "getpixel: "; : printerror(39) : return
	sub	fp, #24
	cmp	arg03, #2 wz
	sub	objptr, ##36476
 if_e	jmp	#LR__1490
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5662
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1491
LR__1490
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #16
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	arg03, result1
	add	fp, #32
	wrlong	arg03, fp
	rdlong	arg01, objptr
	sub	fp, #4
	rdlong	result3, fp
	add	arg01, result3
	sub	fp, #28
	shl	arg03, #10
	add	arg01, arg03
	call	#_pspeek
	getbyte	result1, result1, #0
	wrlong	result1, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1491
	mov	ptra, fp
	call	#popregs_
_do_getpixel_ret
	ret

' 
' '-------------------- gettime
' 
' sub do_gettime
_do_gettime
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #20
' 
' const asm 
	getct	local01 wc
	getct	local02
' return hi1, lo1
	mov	result2, local02
	wrlong	local01, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #12
	wrlong	#29, fp
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #4
	mov	arg01, fp
	sub	fp, #8
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_gettime_ret
	ret

' 
' '-------------------- gosub
' 
' sub do_gosub()
_do_gosub
	add	objptr, ##41228
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
' gosubtop+=1
' if compiledline(lineptr_e+1).result_type=token_end then
	sub	objptr, ##3212
	rdlong	_var01, objptr
	add	_var01, #1
	mov	_var02, _var01
	shl	_var02, #1
	add	_var02, _var01
	shl	_var02, #2
	sub	objptr, ##1540
	add	_var02, objptr
	add	_var02, #8
	rdlong	_var02, _var02
	cmp	_var02, #510 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__1500
	add	objptr, ##41228
	rdlong	_var02, objptr
	shl	_var02, #3
	sub	objptr, ##1888
	add	_var02, objptr
	add	objptr, ##1804
	rdlong	_var01, objptr
	wrlong	_var01, _var02
	add	objptr, #84
	rdlong	_var02, objptr
	shl	_var02, #3
	sub	objptr, ##1888
	add	_var02, objptr
	add	_var02, #4
	wrlong	#0, _var02
	sub	objptr, ##39340
	jmp	#LR__1501
LR__1500
	add	objptr, ##41228
	rdlong	_var02, objptr
	shl	_var02, #3
	sub	objptr, ##1888
	add	_var02, objptr
	add	objptr, ##1812
	rdlong	_var01, objptr
	wrlong	_var01, _var02
	add	objptr, #76
	rdlong	_var02, objptr
	shl	_var02, #3
	sub	objptr, ##1888
	add	_var02, objptr
	sub	objptr, ##1324
	rdlong	_var01, objptr
	sub	objptr, ##38016
	add	_var01, #2
	add	_var02, #4
	wrlong	_var01, _var02
LR__1501
_do_gosub_ret
	ret

' 
' '--------------------- goto
' 
' '------- fast goto
' 
' sub do_fast_goto
_do_fast_goto
	mov	COUNT_, #2
	call	#pushregs_
_do_fast_goto_enter
	add	objptr, ##38016
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #1
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	rdlong	local02, local01
	mov	arg01, local02
	sub	objptr, ##36476
	call	#_pslpeek
	mov	arg01, result1
' 
' testptr=compiledline(lineptr_e).result.uresult
' flag=pslpeek(testptr)' :print " In goto:",flag , testptr : waitms(1000)
' if flag=compiledline(lineptr_e).result.twowords(1) then
	add	objptr, ##38016
	rdlong	result1, objptr
	mov	local01, result1
	shl	local01, #1
	add	local01, result1
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	cmp	arg01, local01 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__1510
	add	objptr, ##41144
	wrlong	local02, objptr
	sub	objptr, ##3132
	rdlong	local02, objptr
	sub	local02, #1
	add	objptr, #4
	wrlong	local02, objptr
'   runptr=testptr
'   lineptr_e=lineptr-1
'   if runheader(5)=$7FFF_FFFF  then runheader(5)=0
	add	objptr, ##3204
	rdlong	local02, objptr
	sub	objptr, ##41220
	cmp	local02, ##2147483647 wz
 if_e	add	objptr, ##41220
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##41220
	jmp	#LR__1511
LR__1510
	call	#_do_find_goto
LR__1511
	mov	ptra, fp
	call	#popregs_
_do_fast_goto_ret
	ret

' 
' '------- find goto  
' 
' sub do_find_goto
_do_find_goto
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #36
_do_find_goto_enter
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	local02, #4
	rdlong	local02, local02
	wrlong	local02, fp
	add	objptr, ##1548
	rdlong	local03, objptr
	sub	objptr, ##38024
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #4
' 
' gotoline=compiledline(lineptr_e).result.twowords(1)
' gotoptr=programstart
' do
LR__1520
	add	fp, #12
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #24
	add	objptr, ##5836
	call	#_psram_spin2_read1
	sub	objptr, ##5836
'   psram.read1(varptr(gotoheader),gotoptr,24)  : 
'   if gotoheader(0)<>$FFFFFFFF then
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local03, ##-1 wz
 if_e	jmp	#LR__1521
	add	fp, #4
	rdlong	local03, fp
	add	fp, #4
	wrlong	local03, fp
	add	fp, #24
	rdlong	local03, fp
	sub	fp, #28
	wrlong	local03, fp
	sub	fp, #4
LR__1521
	add	fp, #32
	rdlong	local03, fp
	sub	fp, #32
	cmp	local03, ##2147483647 wz
 if_ne	add	fp, #12
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #12
 if_ne	cmp	local01, ##-1 wz
 if_e	jmp	#LR__1522
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local02, fp
	cmp	local03, local02 wz
 if_ne	jmp	#LR__1520
LR__1522
' 
' if gotoheader(0)=gotoline then
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local01, fp
	cmp	local03, local01 wz
 if_ne	jmp	#LR__1523
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	fp, #8
	rdlong	local03, fp
	wrlong	local03, local02
	add	objptr, ##1540
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	add	local02, #8
	wrlong	#78, local02
	add	objptr, ##1540
	rdlong	local02, objptr
	mov	arg01, local02
	shl	arg01, #1
	add	arg01, local02
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	add	objptr, ##4676
	rdlong	arg02, objptr
	mov	local03, #2
	add	local03, local02
	sub	objptr, ##5724
	rdlong	arg03, objptr
	qmul	local03, arg03
	sub	fp, #8
	sub	objptr, ##29592
	getqx	local03
	add	arg02, local03
	call	#_psram_spin2_write
	sub	objptr, ##5836
	call	#_do_fast_goto
	jmp	#LR__1524
LR__1523
	mov	arg01, #38
	mov	arg02, #0
	call	#_printerror
LR__1524
	mov	ptra, fp
	call	#popregs_
_do_find_goto_ret
	ret

' 
' '------- slow goto  
' 
' sub do_slow_goto
_do_slow_goto
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	local01, result3
	add	fp, #36
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	wrlong	result1, fp
	add	objptr, ##38024
	rdlong	local02, objptr
	sub	objptr, ##38024
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #4
' 
' t1=pop() : gotoline=converttoint(t1)
' gotoptr=programstart
' do
LR__1530
	add	fp, #12
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #24
	add	objptr, ##5836
	call	#_psram_spin2_read1
	sub	objptr, ##5836
'   psram.read1(varptr(gotoheader),gotoptr,24)  : 
'   if gotoheader(0)<>$FFFFFFFF then
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	cmp	local02, ##-1 wz
 if_e	jmp	#LR__1531
	add	fp, #4
	rdlong	local02, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #24
	rdlong	local02, fp
	sub	fp, #28
	wrlong	local02, fp
	sub	fp, #4
LR__1531
	add	fp, #32
	rdlong	local02, fp
	sub	fp, #32
	cmp	local02, ##2147483647 wz
 if_ne	add	fp, #12
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #12
 if_ne	cmp	local01, ##-1 wz
 if_e	jmp	#LR__1532
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	rdlong	arg03, fp
	cmp	local02, arg03 wz
 if_ne	jmp	#LR__1530
LR__1532
' if gotoheader(0)=gotoline then  
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	rdlong	local01, fp
	cmp	local02, local01 wz
 if_ne	jmp	#LR__1533
	add	fp, #8
	rdlong	local02, fp
	sub	fp, #8
	add	objptr, ##41144
	wrlong	local02, objptr
	sub	objptr, ##3132
	rdlong	local02, objptr
	sub	local02, #1
	add	objptr, #4
	wrlong	local02, objptr
'    runptr=oldgotoptr
'    lineptr_e=lineptr-1
'   if runheader(5)=$7FFF_FFFF  then runheader(5)=0 
	add	objptr, ##3204
	rdlong	local02, objptr
	sub	objptr, ##41220
	cmp	local02, ##2147483647 wz
 if_e	add	objptr, ##41220
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##41220
LR__1533
	mov	ptra, fp
	call	#popregs_
_do_slow_goto_ret
	ret

' 
' ' ----------------  hex$
' 
' sub do_hex
_do_hex
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>2 orelse numpar=0 then print "hex$: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #3 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1540
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5663
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1543
LR__1540
' if numpar=2 then t1=pop() : num=converttoint(t1) else num=8
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #2 wz
 if_ne	jmp	#LR__1541
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	jmp	#LR__1542
LR__1541
	add	fp, #20
	wrlong	#8, fp
	sub	fp, #20
LR__1542
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
	mov	arg01, result1
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #20
	mov	arg03, #16
	call	#__system__Number_S
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1543
	mov	ptra, fp
	call	#popregs_
_do_hex_ret
	ret

' 
' ' ----------------  if
' 
' sub do_if
_do_if
	mov	COUNT_, #5
	call	#pushregs_
	call	#_pop
	mov	local01, result1 wz
	mov	local02, result2
	mov	local03, result3
' t1=pop()
' ' if uresult=0, jump over else
' if t1.result.uresult = 0 then 
 if_ne	jmp	#LR__1552
'   for i=lineptr_e to lineptr-1
	add	objptr, ##38016
	rdlong	local04, objptr
	sub	objptr, #4
	rdlong	local05, objptr
	sub	objptr, ##38012
LR__1550
	cmps	local04, local05 wc
 if_ae	jmp	#LR__1551
	mov	result3, local04
	shl	result3, #1
	add	result3, local04
	shl	result3, #2
	add	objptr, ##36476
	add	result3, objptr
	rdlong	local01, result3
	add	result3, #4
	rdlong	result2, result3
	mov	result3, local04
	shl	result3, #1
	add	result3, local04
	shl	result3, #2
	add	result3, objptr
	add	result3, #8
	rdlong	result3, result3
	mov	local02, result2
	mov	local03, result3
'     t1=compiledline(i)
'     if t1.result_type=token_else then lineptr_e=i : return
	cmp	local03, #90 wz
	sub	objptr, ##36476
 if_e	add	objptr, ##38016
 if_e	wrlong	local04, objptr
 if_e	sub	objptr, ##38016
 if_e	jmp	#LR__1553
	add	local04, #1
	jmp	#LR__1550
LR__1551
	add	objptr, ##38012
	rdlong	local05, objptr
	sub	local05, #1
	add	objptr, #4
	wrlong	local05, objptr
	sub	objptr, ##38016
LR__1552
LR__1553
	mov	ptra, fp
	call	#popregs_
_do_if_ret
	ret

' 
' ' ----------------  inkey$
' 
' sub do_inkey
_do_inkey
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #12
	call	#_usbnew_spin2_get_key
	add	objptr, ##35444
	wrlong	result1, objptr
' if key<>0 andalso key<$80000000 andalso (key and 255) <$E0 then  
	sub	objptr, ##35444
	cmp	result1, #0 wz
 if_e	jmp	#LR__1561
	add	objptr, ##35444
	rdlong	arg06, objptr
	sub	objptr, ##35444
	cmp	arg06, ##-2147483648 wc
 if_b	add	objptr, ##35444
 if_b	rdlong	local01, objptr
 if_b	sub	objptr, ##35444
 if_b	getbyte	local01, local01, #0
 if_b	cmp	local01, #224 wc
 if_ae	jmp	#LR__1561
'   if keyclick=1 then paula.play(7,keyclick_spl,44100,4096,spl_len) 
	add	objptr, ##41236
	rdlong	arg06, objptr
	sub	objptr, ##41236
	cmp	arg06, #1 wz
 if_ne	jmp	#LR__1560
	add	objptr, ##41912
	rdlong	arg02, objptr
	sub	objptr, #4
	rdlong	arg05, objptr
	mov	arg01, #7
	mov	arg03, ##44100
	decod	arg04, #12
	neg	arg06, #1
	sub	objptr, ##36072
	call	#_audio096_spin2_play
	sub	objptr, ##5836
LR__1560
LR__1561
' if key<>0 andalso key<$80000000 andalso (key and 255) <$E0 then
	add	objptr, ##35444
	rdlong	arg06, objptr wz
	sub	objptr, ##35444
 if_e	jmp	#LR__1570
	add	objptr, ##35444
	rdlong	arg06, objptr
	sub	objptr, ##35444
	cmp	arg06, ##-2147483648 wc
 if_b	add	objptr, ##35444
 if_b	rdlong	local01, objptr
 if_b	sub	objptr, ##35444
 if_b	getbyte	local01, local01, #0
 if_b	cmp	local01, #224 wc
 if_ae	jmp	#LR__1570
'   if leds and 2 = 2 then 
	add	objptr, ##41968
	rdlong	local01, objptr wz
	sub	objptr, ##41968
 if_e	jmp	#LR__1569
'     if key>96 andalso key<123 then
	add	objptr, ##35444
	rdlong	local01, objptr
	sub	objptr, ##35444
	cmp	local01, #97 wc
 if_b	jmp	#LR__1562
	add	objptr, ##35444
	rdlong	local01, objptr
	sub	objptr, ##35444
	cmp	local01, #123 wc
 if_ae	jmp	#LR__1562
	add	objptr, ##35444
	rdlong	local01, objptr
	sub	local01, #32
	wrlong	local01, objptr
	sub	objptr, ##35444
	jmp	#LR__1568
LR__1562
	add	objptr, ##35444
	rdlong	local01, objptr
	sub	objptr, ##35444
	cmp	local01, #65 wc
 if_b	jmp	#LR__1563
	add	objptr, ##35444
	rdlong	local01, objptr
	sub	objptr, ##35444
	cmp	local01, #91 wc
 if_ae	jmp	#LR__1563
	add	objptr, ##35444
	rdlong	local01, objptr
	add	local01, #32
	wrlong	local01, objptr
	sub	objptr, ##35444
	jmp	#LR__1567
LR__1563
	add	objptr, ##35444
	rdlong	local01, objptr
	sub	objptr, ##35444
	cmp	local01, #23 wc
 if_b	jmp	#LR__1564
	add	objptr, ##35444
	rdlong	local01, objptr
	sub	objptr, ##35444
	cmp	local01, #32 wc
 if_ae	jmp	#LR__1564
	add	objptr, ##35444
	rdlong	local01, objptr
	sub	local01, #9
	wrlong	local01, objptr
	sub	objptr, ##35444
	jmp	#LR__1566
LR__1564
	add	objptr, ##35444
	rdlong	local02, objptr
	sub	objptr, ##35444
	cmp	local02, #14 wc
 if_b	jmp	#LR__1565
	add	objptr, ##35444
	rdlong	local01, objptr
	sub	objptr, ##35444
	cmp	local01, #23 wc
 if_b	add	objptr, ##41972
 if_b	rdlong	local02, objptr
 if_b	add	local02, #39
 if_b	wrlong	local02, objptr
 if_b	sub	objptr, ##41972
LR__1565
LR__1566
LR__1567
LR__1568
LR__1569
	add	objptr, ##35444
	rdlong	arg01, objptr
	sub	objptr, ##35444
	call	#_scantochar
	mov	arg01, result1
	call	#__system__Chr_S
	wrlong	result1, fp
	jmp	#LR__1571
LR__1570
	mov	local02, ##@LR__5664
	wrlong	local02, fp
LR__1571
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_inkey_ret
	ret

' 
' ' ----------------  ink
' 
' sub do_ink
_do_ink
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	objptr, ##28220
	wrlong	result1, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##28151
	wrlong	result1, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	add	objptr, ##28151
	rdlong	arg01, objptr
	sub	objptr, ##28220
	call	#_hg010b_spin2_setcursorcolor
	mov	ptra, fp
	call	#popregs_
_do_ink_ret
	ret

' 
' ' ----------------  int
' 
' sub do_int
_do_int
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #16
	call	#_pop
	mov	local01, result2
	mov	local02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
' 
' t1=pop()
' select case t1.result_type
	sub	fp, #8
	cmp	local02, #30 wz
 if_e	jmp	#LR__1580
	cmp	local02, #31 wz
 if_e	jmp	#LR__1581
	cmp	local02, #43 wz
 if_e	jmp	#LR__1582
	jmp	#LR__1583
LR__1580
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
	jmp	#LR__1583
LR__1581
	rdlong	arg01, fp
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
	jmp	#LR__1583
LR__1582
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
LR__1583
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_int_ret
	ret

' 
' ' ----------------  input
' 
' sub do_input
_do_input
	add	objptr, ##36476
	sub	objptr, ##36476
_do_input_ret
	ret

' 
' ' ----------------  left$
' 
' sub do_left
_do_left
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>2  then print "left$: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wz
	sub	objptr, ##36476
 if_e	jmp	#LR__1590
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5665
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1593
LR__1590
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg03, result1
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #16
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : arg=converttoint(t1)
' t1=pop(): if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1591
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1591
' if t1.result_type<>result_string then print "left$: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1592
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5666
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1593
LR__1592
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #16
	call	#__system__Left_S
	wrlong	result1, fp
	mov	arg01, fp
	call	#_push
LR__1593
	mov	ptra, fp
	call	#popregs_
_do_left_ret
	ret

' 
' ' ----------------  len
' 
' sub do_len
_do_len
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "len: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1600
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5667
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1605
LR__1600
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1601
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1601
' if t1.result_type<>result_string then print "len: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1602
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5668
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1605
LR__1602
	rdlong	arg01, fp
	mov	local02, arg01
	callpa	#(@LR__1604-@LR__1603)>>2,fcache_load_ptr_
LR__1603
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__1603
LR__1604
	sub	local02, arg01
	wrlong	local02, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1605
	mov	ptra, fp
	call	#popregs_
_do_len_ret
	ret

' 
' ' ----------------  list
' 
' sub do_list
_do_list
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #184
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	##2147483647, fp
	sub	fp, #8
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	wrlong	arg03, fp
' 
' startline=0 : endline=$7FFFFFFF
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=1 then t1=pop() : startline=converttoint(t1)
	cmp	arg03, #1 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__1610
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #4
	wrlong	result1, fp
	sub	fp, #4
LR__1610
' if numpar=2 then t1=pop() : endline=converttoint(t1) : t1=pop() : startline=converttoint(t1)
	rdlong	arg03, fp
	cmp	arg03, #2 wz
 if_ne	jmp	#LR__1611
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	add	fp, #8
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #4
	wrlong	result1, fp
	sub	fp, #4
LR__1611
' 
' 
' print
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	objptr, ##38024
	rdlong	local02, objptr
	add	objptr, ##4004
	wrlong	local02, objptr
	sub	objptr, ##42028
' do 
LR__1612
	add	fp, #32
	mov	arg01, fp
	sub	fp, #32
	add	objptr, ##42028
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##36192
	call	#_psram_spin2_read1
	sub	objptr, ##5836
'   psram.read1(varptr(header),listptr,24) ': print header(0),header(1),header(2),header(3),header(4),header(5), programstart : waitms 7000 : waitms 7000 : waitms 7000
'   
'   if header(0)<> $FFFFFFFF then
	add	fp, #32
	rdlong	local02, fp
	sub	fp, #32
	cmp	local02, ##-1 wz
 if_e	jmp	#LR__1614
	add	fp, #56
	mov	arg03, #63
	setq	arg03
	wrlong	#0, fp
	mov	arg01, fp
	sub	fp, #16
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #44
	add	objptr, ##5836
	call	#_psram_spin2_read1
	sub	objptr, ##5836
'     longfill(linebuf,0,64)
'     psram.read1(varptr(linebuf),header(2),header(3))
'     if header(0)>=startline andalso header(0)<=endline then v.writeln(varptr(linebuf))  
	add	fp, #32
	rdlong	local02, fp
	sub	fp, #28
	rdlong	local01, fp
	sub	fp, #4
	cmps	local02, local01 wc
 if_b	jmp	#LR__1613
	add	fp, #32
	rdlong	local02, fp
	sub	fp, #24
	rdlong	arg03, fp
	sub	fp, #8
	cmps	local02, arg03 wcz
 if_a	jmp	#LR__1613
	add	fp, #56
	mov	arg01, fp
	sub	fp, #56
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
LR__1613
	add	fp, #52
	rdlong	local02, fp
	sub	fp, #52
	add	objptr, ##42028
	wrlong	local02, objptr
	sub	objptr, ##42028
LR__1614
	add	fp, #52
	rdlong	local02, fp
	sub	fp, #52
	cmp	local02, ##2147483647 wz
 if_ne	add	fp, #32
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #32
 if_ne	cmp	local01, ##-1 wz
 if_ne	jmp	#LR__1612
	mov	ptra, fp
	call	#popregs_
_do_list_ret
	ret

' 
' '-------------------- load
' 
' sub do_load(amode=0 as integer)  
_do_load
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #172
	wrlong	arg01, fp
	add	objptr, ##41960
	wrlong	#1, objptr
	sub	objptr, ##3944
	rdlong	arg02, objptr
	mov	arg01, arg02
	shl	arg01, #1
	add	arg01, arg02
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	arg02, arg01
	add	fp, #28
	wrlong	arg02, fp
	add	fp, #140
	mov	arg01, fp
	sub	objptr, ##36476
	sub	fp, #128
	wrlong	fp, arg01
' 
' inload=1
' numpar=compiledline(lineptr_e).result.uresult
' lpoke varptr(line2$),varptr(line2)
' if numpar>0 then t1=pop() else t1.result.sresult=loadname : t1.result_type=result_string 
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #28
	cmps	local01, #1 wc
 if_b	jmp	#LR__1620
	call	#_pop
	add	fp, #4
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #12
	jmp	#LR__1621
LR__1620
	add	objptr, ##41944
	rdlong	local01, objptr
	sub	objptr, ##41944
	add	fp, #4
	wrlong	local01, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #12
LR__1621
' 'print "popped "; t1.result.uresult, t1.result_type
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult): t1.result_type=result_string ': print t1.result.sresult
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #43 wz
 if_ne	jmp	#LR__1622
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	call	#_convertstring
	add	fp, #4
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #12
LR__1622
' if t1.result_type=result_string then
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #31 wz
 if_ne	jmp	#LR__1628
'   if amode<>1234 then do_new
	rdlong	local01, fp
	cmp	local01, ##1234 wz
 if_ne	call	#_do_new
'   if t1.result.sresult="" then t1.result.sresult=loadname else loadname=t1.result.sresult
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, ##@LR__5669
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1623
	add	objptr, ##41944
	rdlong	local01, objptr
	sub	objptr, ##41944
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #4
	jmp	#LR__1624
LR__1623
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	objptr, ##41944
	wrlong	local01, objptr
	sub	objptr, ##41944
LR__1624
'   close #9: open currentdir$+"/"+t1.result.sresult for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5670
	call	#__system___string_concat
	mov	arg01, result1
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	sub	ptr___system__dat__, #32
	add	fp, #20
	wrlong	result1, fp
'   r=geterr() 
'   if r then 
	sub	fp, #20
 if_e	jmp	#LR__1626
'     close #9: open currentdir$+"/"+t1.result.sresult+".bas" for input as #9 
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5671
	call	#__system___string_concat
	mov	arg01, result1
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	call	#__system___string_concat
	mov	arg01, result1
	mov	arg02, ##@LR__5672
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__ wz
	sub	ptr___system__dat__, #32
	add	fp, #20
	wrlong	result1, fp
'     r=geterr() 
'     if r then 
	sub	fp, #20
 if_e	jmp	#LR__1625
'       print "System error ";r;": ";strerror$(r) :close #9 : return
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5673
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg02, ##@LR__5674
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local01, #0
	add	fp, #20
	rdlong	arg01, fp
	sub	fp, #20
	call	#__system___strerror
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1630
LR__1625
	add	objptr, ##41944
	rdlong	arg01, objptr
	sub	objptr, ##41944
	mov	arg02, ##@LR__5675
	call	#__system___string_concat
	add	objptr, ##41944
	wrlong	result1, objptr
	sub	objptr, ##41944
LR__1626
'   close #9: open currentdir$+"/"+loadname for input as #9
	mov	arg01, #9
	call	#__system__close
	mov	local01, #9
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5676
	call	#__system___string_concat
	mov	arg01, result1
	add	objptr, ##41944
	rdlong	arg02, objptr
	sub	objptr, ##41944
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_open_string
'   do
LR__1627
	mov	arg01, #9
	call	#__system___basic_read_line
	mov	local01, result1
	add	objptr, ##28188
	wrlong	local01, objptr
	sub	objptr, ##28188
	call	#_interpret
	add	objptr, ##28188
	rdlong	arg01, objptr
	sub	objptr, ##28188
	mov	arg02, ##@LR__5677
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1627
'   close #9   
	mov	arg01, #9
	call	#__system__close
	jmp	#LR__1629
LR__1628
	mov	arg01, #30
	mov	arg02, #0
	call	#_printerror
LR__1629
' print "Loaded ";currentdir$+"/"+loadname
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5678
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local01, #0
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5679
	call	#__system___string_concat
	mov	arg01, result1
	add	objptr, ##41944
	rdlong	arg02, objptr
	sub	objptr, ##41944
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	objptr, ##41960
	wrlong	#0, objptr
	sub	objptr, ##41960
LR__1630
	mov	ptra, fp
	call	#popregs_
_do_load_ret
	ret

' 
' '-------------------- log
' 
' sub do_log
_do_log
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03 wz
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=0 orelse numpar>2 then print "log: "; : printerror(39) : return
	sub	fp, #12
	sub	objptr, ##36476
 if_ne	add	fp, #12
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #12
 if_ne	cmp	local01, #3 wc
 if_c_and_nz	jmp	#LR__1640
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5680
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1643
LR__1640
' if numpar=2 then 
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #2 wz
 if_ne	jmp	#LR__1641
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	jmp	#LR__1642
LR__1641
	add	fp, #16
	wrlong	##1065353216, fp
	sub	fp, #16
LR__1642
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	mov	arg01, result1
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #16
	call	#__system___float_div
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1643
	mov	ptra, fp
	call	#popregs_
_do_log_ret
	ret

' 
' '-------------------- lpeek
' 
' sub do_lpeek
_do_lpeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #12
	wrlong	result1, fp
' 
' t1=pop()
' a=converttoint(t1)
' if a<$80000 then r=lpeek(a) else r=pslpeek(a)
	sub	fp, #12
	cmp	result1, ##524288 wc
 if_ae	jmp	#LR__1650
	add	fp, #12
	rdlong	arg01, fp
	rdlong	result1, arg01
	add	fp, #4
	wrlong	result1, fp
	sub	fp, #16
	jmp	#LR__1651
LR__1650
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_pslpeek
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
LR__1651
	add	fp, #8
	wrlong	#29, fp
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #16
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_lpeek_ret
	ret

' 
' '-------------------- lpoke
' 
' sub do_lpoke
_do_lpoke
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #24
	mov	arg01, fp
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
' 
' t1=pop() 'value
' t2=pop() 
' a=converttoint(t2) : v=converttoint(t1)
' if a<$80000 then lpoke a,v else pslpoke a,v
	sub	fp, #4
	rdlong	local01, fp
	sub	fp, #24
	cmp	local01, ##524288 wc
 if_ae	jmp	#LR__1660
	add	fp, #24
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	wrlong	arg02, arg01
	jmp	#LR__1661
LR__1660
	add	fp, #24
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	call	#_pslpoke
LR__1661
	mov	ptra, fp
	call	#popregs_
_do_lpoke_ret
	ret

' 
' '-------------------- mid$
' 
' sub do_mid
_do_mid
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>3  then print "mid$: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #3 wz
	sub	objptr, ##36476
 if_e	jmp	#LR__1670
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5681
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1673
LR__1670
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg03, result1
	add	fp, #20
	wrlong	arg03, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg03, result1
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #16
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : arg2=converttoint(t1)
' t1=pop() : arg1=converttoint(t1)
' t1=pop(): if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1671
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1671
' if t1.result_type<>result_string then print "mid$: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1672
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5682
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1673
LR__1672
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #20
	call	#__system__Mid_S
	wrlong	result1, fp
	mov	arg01, fp
	call	#_push
LR__1673
	mov	ptra, fp
	call	#popregs_
_do_mid_ret
	ret

' 
' '-------------------- mkdir
' 
' sub do_mkdir
_do_mkdir
	mov	COUNT_, #4
	call	#pushregs_
	call	#_pop
	mov	arg04, result2
	mov	arg03, result3
	mov	local01, result1
	mov	local02, arg04
	mov	local03, arg03
' 
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1680
	mov	arg01, local01
	call	#_convertstring
	mov	local01, result1
	mov	local03, #31
LR__1680
' if t1.result_type<>result_string then printerror(15): return
	cmp	local03, #31 wz
 if_e	jmp	#LR__1681
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1683
LR__1681
	mov	arg01, local01
	call	#__system___mkdir
	mov	local04, result1 wz
' filename$=t1.result.sresult
' err=mkdir(filename$)
' 'err=geterr() : 
' if err<>0 then print "Cannot create a directory: system error "; err
 if_e	jmp	#LR__1682
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5683
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, local04
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1682
LR__1683
	mov	ptra, fp
	call	#popregs_
_do_mkdir_ret
	ret

' 
' '-------------------- mode
' 
' sub do_mode
_do_mode
	mov	COUNT_, #5
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1690
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1690
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1691
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1691
' select case t1.result.iresult
	mov	local04, local01
	fle	local04, #5
	jmprel	local04
LR__1692
	jmp	#LR__1693
	jmp	#LR__1694
	jmp	#LR__1695
	jmp	#LR__1696
	jmp	#LR__1697
	jmp	#LR__1698
LR__1693
	add	objptr, ##28224
	wrlong	#1, objptr
	sub	objptr, #4
	wrlong	#154, objptr
	add	objptr, ##13016
	wrlong	#1, objptr
	sub	objptr, ##13020
	wrlong	#147, objptr
	sub	objptr, ##28216
	mov	arg01, #4
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##28220
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##28151
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	add	ptr__dat__, ##512
	add	objptr, ##41843
	wrlong	ptr__dat__, objptr
	sub	objptr, #4
	wrlong	##1688, objptr
	sub	objptr, ##41908
	sub	ptr__dat__, ##512
	jmp	#LR__1698
LR__1694
	add	objptr, ##28224
	wrlong	#0, objptr
	sub	objptr, #4
	wrlong	#23, objptr
	add	objptr, ##13016
	wrlong	#0, objptr
	sub	objptr, ##13020
	wrlong	#0, objptr
	sub	objptr, ##28216
	mov	arg01, #0
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##28220
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##28151
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #69
	jmp	#LR__1698
LR__1695
	add	objptr, ##28224
	wrlong	#0, objptr
	sub	objptr, #4
	wrlong	#181, objptr
	add	objptr, ##13016
	wrlong	#0, objptr
	sub	objptr, ##13020
	wrlong	#0, objptr
	sub	objptr, ##28216
	mov	arg01, #0
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##28220
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##28151
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #69
	jmp	#LR__1698
LR__1696
	add	objptr, ##28224
	wrlong	#0, objptr
	sub	objptr, #4
	wrlong	#15, objptr
	add	objptr, ##13016
	wrlong	#0, objptr
	sub	objptr, ##13020
	wrlong	#0, objptr
	sub	objptr, ##28216
	mov	arg01, #0
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##28220
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##28151
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #69
	jmp	#LR__1698
LR__1697
	add	objptr, ##28224
	wrlong	#1, objptr
	sub	objptr, #4
	wrlong	#1, objptr
	add	objptr, ##13016
	wrlong	#1, objptr
	sub	objptr, ##13020
	wrlong	#14, objptr
	sub	objptr, ##28216
	mov	arg01, #4
	call	#_hg010b_spin2_setfontfamily
	add	objptr, ##28220
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
' 
' write_color:=ff
	sub	objptr, ##28151
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	arg02, objptr
	add	ptr__dat__, ##3970
	add	objptr, ##41843
	wrlong	ptr__dat__, objptr
	sub	objptr, #4
	wrlong	##1688, objptr
	sub	objptr, ##41908
	sub	ptr__dat__, ##3970
LR__1698
	add	objptr, ##41904
	wrlong	local01, objptr
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, ##7504
	rdlong	local05, objptr
	sub	objptr, ##34396
	sub	arg01, local05
	mov	arg02, #0
	mov	arg03, #10
	call	#__system__Number_S
	mov	arg01, result1
	mov	arg02, ##@LR__5684
	call	#__system___string_concat
	add	objptr, ##41232
	wrlong	result1, objptr
	sub	objptr, ##13012
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##28216
	call	#_hg010b_spin2_cls
	mov	arg01, ##@LR__5685
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
	add	ptr__dat__, ##12608
	rdlong	arg01, ptr__dat__
	sub	ptr__dat__, ##12608
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
	add	objptr, ##41232
	rdlong	arg01, objptr
	sub	objptr, ##41232
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
	mov	ptra, fp
	call	#popregs_
_do_mode_ret
	ret

' 
' '-------------------- mouse
' 
' sub do_mouse
_do_mouse
	call	#_pop
	cmps	result1, #0 wz
' 
' t1=pop()
' if t1.result.uresult=0 then v.setspritesize(16,0,0) else v.setspritesize(16,32,32)
 if_ne	jmp	#LR__1700
	mov	arg01, #16
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritesize
	jmp	#LR__1701
LR__1700
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_hg010b_spin2_setspritesize
LR__1701
_do_mouse_ret
	ret

' 
' '-------------------- mousek
' 
' sub do_mousek
_do_mousek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	add	objptr, ##41768
	rdlong	arg01, objptr
	sub	objptr, ##41768
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousek_ret
	ret

' 
' '-------------------- mousew
' 
' sub do_mousew
_do_mousew
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	add	objptr, ##41772
	rdlong	arg01, objptr
	sub	objptr, ##41772
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousew_ret
	ret

' 
' '-------------------- mousex
' 
' sub do_mousex
_do_mousex
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	add	objptr, ##41760
	rdlong	arg01, objptr
	sub	objptr, ##41760
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousex_ret
	ret

' 
' '-------------------- mousey
' 
' sub do_mousey
_do_mousey
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	add	objptr, ##41764
	rdlong	arg01, objptr
	sub	objptr, ##41764
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mousey_ret
	ret

' 
' '------------------ new
' 
' sub do_new
_do_new
	mov	COUNT_, #3
	call	#pushregs_
' 
' if inrun=1 then inrun=2
	add	objptr, ##41196
	rdlong	arg03, objptr
	sub	objptr, ##41196
	cmp	arg03, #1 wz
 if_e	add	objptr, ##41196
 if_e	wrlong	#2, objptr
 if_e	sub	objptr, ##41196
	decod	arg01, #19
	neg	arg02, #1
	call	#_pslpoke
	add	objptr, ##27144
	wrlong	#0, objptr
' pslpoke(memlo,$FFFFFFFF)
' varnum=0 : for i=0 to maxvars: variables(i).name="" : variables(i).vartype=0: next i
	mov	local01, #0
	sub	objptr, ##16400
	callpa	#(@LR__1711-@LR__1710)>>2,fcache_load_ptr_
LR__1710
	mov	arg03, local01
	shl	arg03, #4
	add	arg03, objptr
	mov	arg02, ##@LR__5686
	wrlong	arg02, arg03
	mov	local02, local01
	shl	local02, #4
	add	local02, objptr
	add	local02, #12
	wrlong	#0, local02
	add	local01, #1
	cmps	local01, ##1025 wc
 if_b	jmp	#LR__1710
LR__1711
	add	objptr, ##27280
	wrlong	##524288, objptr
	add	objptr, ##3120
	wrlong	##524288, objptr
	add	objptr, #4
	wrlong	##524288, objptr
	sub	objptr, ##6756
	wrlong	#0, objptr
	add	objptr, ##3620
	wrlong	#0, objptr
	sub	objptr, ##3616
	wrlong	##524288, objptr
	add	objptr, ##3632
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	add	objptr, ##3192
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	#0, objptr
' programstart=memlo :runptr=memlo : runptr2=memlo
' stackpointer=0
' lineptr=0 
' programptr=memlo ': stringptr=0
' 
' lastline=0 : lastlineptr=-1 :fortop=0 :gosubtop=0
' for i=0 to maxfor: fortable(i).varnum=-1 : next i
	mov	local01, #0
	sub	objptr, ##3188
	callpa	#(@LR__1713-@LR__1712)>>2,fcache_load_ptr_
LR__1712
	mov	local02, local01
	shl	local02, #2
	add	local02, local01
	shl	local02, #2
	add	local02, objptr
	add	local02, #8
	wrlong	##-1, local02
	add	local01, #1
	cmps	local01, #65 wc
 if_b	jmp	#LR__1712
LR__1713
	sub	objptr, ##38040
' for i=0 to 15: if sprite(i)<> nil then v.setspritesize(i,0,0) : delete(sprite(i)) 
	mov	local01, #0
LR__1714
	mov	local02, local01
	shl	local02, #2
	add	objptr, ##41832
	add	local02, objptr
	rdlong	local03, local02 wz
	sub	objptr, ##41832
 if_e	jmp	#LR__1715
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritesize
	mov	local02, local01
	shl	local02, #2
	add	objptr, ##41832
	add	local02, objptr
	rdlong	arg01, local02
	sub	objptr, ##41832
	call	#__system___gc_free
LR__1715
	add	local01, #1
	cmps	local01, #16 wc
 if_b	jmp	#LR__1714
	add	objptr, ##41916
	wrlong	##1065353216, objptr
	add	objptr, #4
	wrlong	##1065353216, objptr
	sub	objptr, ##41916
	rdlong	local03, objptr
	add	objptr, ##41896
	wrlong	local03, objptr
	sub	objptr, ##41900
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_hg010b_spin2_setspritesize
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_hg010b_spin2_setspritesize
	mov	local03, ##@LR__5687
	add	objptr, ##41944
	wrlong	local03, objptr
	sub	objptr, ##41944
	call	#_init_audio
	mov	ptra, fp
	call	#popregs_
_do_new_ret
	ret

' 
' '-------------------- next
' 
' sub do_next()
_do_next
	mov	COUNT_, #4
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() :varnum=t1.result.uresult
' if fortable(fortop).varnum<>t1.result.uresult then printerror(37) : return
	add	objptr, ##41224
	rdlong	arg02, objptr
	mov	arg01, arg02
	shl	arg01, #2
	add	arg01, arg02
	shl	arg01, #2
	sub	objptr, ##3184
	add	arg01, objptr
	add	arg01, #8
	rdlong	arg02, arg01
	cmp	arg02, local01 wz
	sub	objptr, ##38040
 if_e	jmp	#LR__1720
	mov	arg01, #37
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1727
LR__1720
' if variables(varnum).vartype=result_float then variables(varnum).vartype=result_int : variables(varnum).value.iresult=round(variables(varnum).value.fresult)
	mov	arg02, local01
	shl	arg02, #4
	add	objptr, ##10744
	add	arg02, objptr
	add	arg02, #12
	rdlong	arg02, arg02
	cmp	arg02, #30 wz
	sub	objptr, ##10744
 if_ne	jmp	#LR__1721
	mov	arg02, local01
	shl	arg02, #4
	add	objptr, ##10744
	add	arg02, objptr
	add	arg02, #12
	wrlong	#28, arg02
	mov	local04, local01
	shl	local04, #4
	add	local04, objptr
	mov	arg02, local01
	shl	arg02, #4
	add	arg02, objptr
	add	arg02, #4
	rdlong	arg01, arg02
	sub	objptr, ##10744
	mov	arg02, #1
	call	#__system___float_tointeger
	add	local04, #4
	wrlong	result1, local04
LR__1721
	add	objptr, ##41224
	rdlong	local04, objptr
	mov	arg02, local04
	shl	arg02, #2
	add	arg02, local04
	shl	arg02, #2
	sub	objptr, ##3184
	add	arg02, objptr
	add	arg02, #12
	rdlong	result3, arg02
	mov	local04, local01
	shl	local04, #4
	sub	objptr, ##27296
	add	local04, objptr
	mov	arg02, local01
	shl	arg02, #4
	add	arg02, objptr
	add	arg02, #4
	rdlong	arg01, arg02
	add	arg01, result3
	add	local04, #4
	wrlong	arg01, local04
' variables(varnum).value.iresult+=fortable(fortop).stepval 
' if fortable(fortop).stepval>=0 then
	add	objptr, ##30480
	rdlong	local04, objptr
	mov	arg01, local04
	shl	arg01, #2
	add	arg01, local04
	shl	arg01, #2
	sub	objptr, ##3184
	add	arg01, objptr
	add	arg01, #12
	rdlong	arg01, arg01
	cmps	arg01, #0 wc
	sub	objptr, ##38040
 if_b	jmp	#LR__1722
'   if variables(varnum).value.iresult>fortable(fortop).endval then fortop-=1 : return ' do nothing 
	shl	local01, #4
	add	objptr, ##10744
	add	local01, objptr
	add	objptr, ##30480
	rdlong	arg01, objptr
	mov	local04, arg01
	shl	local04, #2
	add	local04, arg01
	shl	local04, #2
	sub	objptr, ##3184
	add	local04, objptr
	add	local01, #4
	rdlong	local01, local01
	add	local04, #16
	rdlong	local04, local04
	cmps	local01, local04 wcz
	sub	objptr, ##38040
 if_be	jmp	#LR__1724
	add	objptr, ##41224
	rdlong	local04, objptr
	sub	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##41224
	jmp	#LR__1727
LR__1722
'   if variables(varnum).value.iresult<fortable(fortop).endval then fortop -=1 : return ' do nothing 
	mov	local04, local01
	shl	local04, #4
	add	objptr, ##10744
	add	local04, objptr
	add	objptr, ##30480
	rdlong	local01, objptr
	mov	arg01, local01
	shl	arg01, #2
	add	arg01, local01
	shl	arg01, #2
	sub	objptr, ##3184
	add	arg01, objptr
	add	local04, #4
	rdlong	local04, local04
	add	arg01, #16
	rdlong	arg01, arg01
	cmps	local04, arg01 wc
	sub	objptr, ##38040
 if_ae	jmp	#LR__1723
	add	objptr, ##41224
	rdlong	local04, objptr
	sub	local04, #1
	wrlong	local04, objptr
	sub	objptr, ##41224
	jmp	#LR__1727
LR__1723
LR__1724
' ' if not returned, goto pointer 
' if inrun>0 andalso runptr<>fortable(fortop).lineptr then
	add	objptr, ##41196
	rdlong	local04, objptr
	sub	objptr, ##41196
	cmp	local04, #1 wc
 if_b	jmp	#LR__1725
	add	objptr, ##41224
	rdlong	local04, objptr
	mov	local01, local04
	shl	local01, #2
	add	local01, local04
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	add	objptr, ##3104
	rdlong	local04, objptr
	sub	objptr, ##41144
	rdlong	local01, local01
	cmp	local04, local01 wz
 if_e	jmp	#LR__1725
	add	objptr, ##41224
	rdlong	local04, objptr
	mov	local01, local04
	shl	local01, #2
	add	local01, local04
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	rdlong	local01, local01
	add	objptr, ##3104
	wrlong	local01, objptr
	add	objptr, #80
	rdlong	local04, objptr
	mov	local01, local04
	shl	local01, #2
	add	local01, local04
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	add	objptr, ##3108
	wrlong	local01, objptr
	sub	objptr, ##3136
	rdlong	local04, objptr
	sub	local04, #1
	add	objptr, #4
	wrlong	local04, objptr
	sub	objptr, ##38016
	jmp	#LR__1726
LR__1725
	add	objptr, ##41224
	rdlong	local04, objptr
	mov	local01, local04
	shl	local01, #2
	add	local01, local04
	shl	local01, #2
	sub	objptr, ##3184
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	sub	local01, #1
	sub	objptr, #24
	wrlong	local01, objptr
	sub	objptr, ##38016
LR__1726
LR__1727
	mov	ptra, fp
	call	#popregs_
_do_next_ret
	ret

' 
' '-------------------- no command (print "Unknown command")
' 
' sub do_no_command
_do_no_command
	mov	arg01, #23
	mov	arg02, #0
	call	#_printerror
_do_no_command_ret
	ret

' 
' '-------------------- nothing
' 
' sub do_nothing					' a placeholder for tokens that don't do anything by themselves
_do_nothing
_do_nothing_ret
	ret

' 
' '-------------------- on
' 
' sub do_on
_do_on
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38016
	rdlong	arg01, objptr
	mov	result2, arg01
	shl	result2, #1
	add	result2, arg01
	shl	result2, #2
	sub	objptr, ##1540
	add	result2, objptr
	rdlong	arg01, result2
	add	fp, #20
	wrlong	arg01, fp
	add	objptr, ##1540
	rdlong	arg01, objptr
	mov	local01, arg01
	shl	local01, #1
	add	local01, arg01
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	add	local01, #4
	rdlong	local01, local01
	sub	fp, #8
	wrlong	local01, fp
	sub	fp, #12
	sub	objptr, ##36476
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #16
	wrlong	result1, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' skip=compiledline(lineptr_e).result.twowords(1)
' t1=pop()
' t=converttoint(t1)
' if t<1 orelse t>numpar then return
	sub	fp, #16
	cmps	result1, #1 wc
 if_b	jmp	#LR__1730
	add	fp, #16
	rdlong	local01, fp
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #20
	cmps	local01, arg01 wcz
 if_a	jmp	#LR__1730
	add	fp, #16
	rdlong	local01, fp
	sub	local01, #1
	sub	fp, #4
	rdlong	arg01, fp
	qmul	arg01, local01
	add	objptr, ##38016
	rdlong	local01, objptr
	sub	fp, #12
	getqx	arg01
	add	local01, arg01
	wrlong	local01, objptr
	sub	objptr, ##38016
LR__1730
	mov	ptra, fp
	call	#popregs_
_do_on_ret
	ret

' 
' '-------------------- open
' 
' sub do_open
_do_open
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #32
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #16
	sub	objptr, ##36476
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' 
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1740
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1740
' if t1.result_type<>result_string then  print "filename expected" : return  ' error here
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1741
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5688
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	jmp	#LR__1752
LR__1741
	rdlong	arg03, fp
	add	fp, #12
	wrlong	arg03, fp
	sub	fp, #12
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' filename=t1.result.sresult
' t1=pop()
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1742
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1742
	add	fp, #20
	wrlong	#0, fp
' mode=0
' if t1.result_type=result_string then
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #31 wz
 if_ne	jmp	#LR__1743
'   if t1.result.sresult="read" then mode=1
	rdlong	arg01, fp
	mov	arg02, ##@LR__5689
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	fp, #20
 if_e	wrlong	#1, fp
 if_e	sub	fp, #20
'   if t1.result.sresult="write" then mode=2
	rdlong	arg01, fp
	mov	arg02, ##@LR__5690
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	fp, #20
 if_e	wrlong	#2, fp
 if_e	sub	fp, #20
'   if t1.result.sresult="append" then mode=4
	rdlong	arg01, fp
	mov	arg02, ##@LR__5691
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	fp, #20
 if_e	wrlong	#4, fp
 if_e	sub	fp, #20
	jmp	#LR__1744
LR__1743
	mov	arg01, fp
	call	#_converttoint
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
LR__1744
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop()
' if t1.result_type<>result_channel then print "channel# expected" : return  
	sub	fp, #8
	cmp	arg03, #44 wz
 if_e	jmp	#LR__1745
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5692
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	jmp	#LR__1752
LR__1745
	rdlong	local01, fp
	add	fp, #24
	wrlong	local01, fp
' channel  = t1.result.iresult
' select case  mode
	sub	fp, #4
	rdlong	local02, fp
	sub	fp, #20
	sub	local02, #1
	fle	local02, #4
	jmprel	local02
LR__1746
	jmp	#LR__1747
	jmp	#LR__1748
	jmp	#LR__1750
	jmp	#LR__1749
	jmp	#LR__1750
LR__1747
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #0
	call	#__system___basic_open_string
	jmp	#LR__1751
LR__1748
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #13
	call	#__system___basic_open_string
	jmp	#LR__1751
LR__1749
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #37
	call	#__system___basic_open_string
	jmp	#LR__1751
LR__1750
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5693
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1751
LR__1752
	mov	ptra, fp
	call	#popregs_
_do_open_ret
	ret

' 
' '-------------------- paper
' 
' sub do_paper
_do_paper
	mov	COUNT_, #3
	call	#pushregs_
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
' t1=pop() 
' if t1.result_type=result_float then t1.result.iresult=t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1760
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1760
' if t1.result_type=result_string then t1.result.iresult=val(t1.result.sresult)
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1761
	mov	arg01, local01
	call	#__system____builtin_atof
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local01, result1
LR__1761
	add	objptr, ##28216
	wrlong	local01, objptr
	add	objptr, #4
	rdlong	arg01, objptr
' 
' write_color:=ff
	sub	objptr, ##28155
	wrlong	arg01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	local01, objptr
	sub	objptr, #69
	mov	ptra, fp
	call	#popregs_
_do_paper_ret
	ret

' 
' '-------------------- peek
' 
' sub do_peek
_do_peek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #12
	wrlong	result1, fp
' 
' t1=pop()
' a=converttoint(t1)
' if a<$80000 then r=peek(a) else r=pspeek(a)
	sub	fp, #12
	cmp	result1, ##524288 wc
 if_ae	jmp	#LR__1770
	add	fp, #12
	rdlong	arg01, fp
	rdbyte	result1, arg01
	add	fp, #4
	wrlong	result1, fp
	sub	fp, #16
	jmp	#LR__1771
LR__1770
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_pspeek
	getbyte	result1, result1, #0
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
LR__1771
	add	fp, #8
	wrlong	#29, fp
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #16
	wrlong	arg01, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_peek_ret
	ret

' 
' '-------------------- pinfloat
' 
' sub do_pinfloat
_do_pinfloat
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	fltl	result1
	mov	ptra, fp
	call	#popregs_
_do_pinfloat_ret
	ret

' 
' '-------------------- pinhi
' 
' sub do_pinhi
_do_pinhi
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	drvh	result1
	mov	ptra, fp
	call	#popregs_
_do_pinhi_ret
	ret

' 
' '-------------------- pinlo
' 
' sub do_pinlo
_do_pinlo
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	drvl	result1
	mov	ptra, fp
	call	#popregs_
_do_pinlo_ret
	ret

' 
' '-------------------- pinread
' 
' sub do_pinread
_do_pinread
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
	test	arg01, #32 wz
 if_ne	mov	result1, inb
 if_e	mov	result1, ina
	shr	result1, arg01
	shr	arg01, #6
	zerox	result1, arg01
	add	objptr, ##42016
	wrlong	result1, objptr
	sub	objptr, ##42016
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	#4, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_pinread_ret
	ret

' 
' '-------------------- pinstart
' 
' sub do_pinstart
_do_pinstart
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg04, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result3
	add	fp, #36
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #36
	call	#_converttoint
	mov	local01, result1
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	mov	local02, result1
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local03, result1
	mov	arg01, fp
	call	#_converttoint
	dirl	local01
	wrpin	local02, local01
	wxpin	local03, local01
	wypin	result1, local01
	dirh	local01
	mov	ptra, fp
	call	#popregs_
_do_pinstart_ret
	ret

' 
' '-------------------- pintoggle
' 
' sub do_pintoggle
_do_pintoggle
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	drvnot	result1
	mov	ptra, fp
	call	#popregs_
_do_pintoggle_ret
	ret

' 
' '-------------------- pinwrite
' 
' sub do_pinwrite
_do_pinwrite
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___pinwrite
	mov	ptra, fp
	call	#popregs_
_do_pinwrite_ret
	ret

' 
' '-------------------- play
' 
' sub do_play
_do_play
	mov	COUNT_, #8
	call	#pushregs_
	add	ptra, #124
	add	fp, #104
	wrlong	##1134096318, fp
' speed_coeff=305.873
' 
' for i=0 to 8 : params(i)=-2.0 : next i
	sub	fp, #100
	wrlong	#0, fp
	callpa	#(@LR__1781-@LR__1780)>>2,fcache_load_ptr_
LR__1780
	rdlong	arg03, fp
	shl	arg03, #2
	add	fp, #52
	add	arg03, fp
	wrlong	##-1073741824, arg03
	sub	fp, #52
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	cmps	local01, #9 wc
 if_b	jmp	#LR__1780
LR__1781
	sub	fp, #4
	add	objptr, ##38016
	rdlong	local02, objptr
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #2
	sub	objptr, ##1540
	add	local03, objptr
	rdlong	local04, local03
	wrlong	local04, fp
' numpar=compiledline(lineptr_e).result.uresult
' for i=numpar to 1 step -1 
	add	fp, #4
	wrlong	local04, fp
	sub	fp, #4
	sub	objptr, ##36476
LR__1782
	call	#_pop
	add	fp, #92
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #96
	rdlong	local03, fp
	sub	local03, #1
	shl	local03, #2
	add	fp, #52
	add	local03, fp
	add	fp, #36
	mov	local05, fp
	mov	arg01, local05
	sub	fp, #92
	call	#_converttofloat
	wrlong	result1, local03
	add	fp, #4
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #4
	cmps	local01, #1 wc
 if_ae	jmp	#LR__1782
' 
' if params(0)<0 then channel=0 else channel=round(params(0)) mod 8
	add	fp, #56
	rdlong	arg01, fp
	sub	fp, #56
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	add	fp, #12
 if_b	wrlong	#0, fp
 if_b	sub	fp, #12
 if_b	jmp	#LR__1783
	add	fp, #56
	rdlong	arg01, fp
	sub	fp, #56
	mov	arg02, #1
	call	#__system___float_tointeger
	abs	local01, result1 wc
	and	local01, #7
	negc	local01, local01
	add	fp, #12
	wrlong	local01, fp
	sub	fp, #12
LR__1783
' if params(1)<0 then freq=channels(channel).freq else freq=params(1) : channels(channel).freq=freq
	add	fp, #60
	rdlong	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__1784
	add	fp, #12
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	rdlong	local06, local03
	add	fp, #96
	wrlong	local06, fp
	sub	fp, #108
	sub	objptr, ##10552
	jmp	#LR__1785
LR__1784
	add	fp, #60
	rdlong	local04, fp
	add	fp, #48
	wrlong	local04, fp
	sub	fp, #96
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	sub	fp, #12
	wrlong	local04, local03
	sub	objptr, ##10552
LR__1785
' if params(2)<0 orelse params(2)>10000.0 then delay=channels(channel).delay else delay=round(params(2)) : channels(channel).delay=delay
	add	fp, #64
	rdlong	arg01, fp
	sub	fp, #64
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1786
	add	fp, #64
	rdlong	arg01, fp
	sub	fp, #64
	mov	arg02, ##1176256512
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1787
LR__1786
	add	fp, #12
	rdlong	local03, fp
	mov	local07, local03
	shl	local07, #1
	add	local07, local03
	shl	local07, #3
	add	objptr, ##10552
	add	local07, objptr
	add	local07, #6
	rdword	local05, local07
	getword	local04, local05, #0
	add	fp, #28
	wrlong	local04, fp
	sub	fp, #40
	sub	objptr, ##10552
	jmp	#LR__1788
LR__1787
	add	fp, #64
	rdlong	arg01, fp
	sub	fp, #64
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #28
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	sub	fp, #12
	add	local03, #6
	wrword	result1, local03
	sub	objptr, ##10552
LR__1788
' if params(3)<0 orelse params(3)>16.384 then vol=channels(channel).vol else vol=params(3) : channels(channel).vol=vol
	add	fp, #68
	rdlong	arg01, fp
	sub	fp, #68
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1789
	add	fp, #68
	rdlong	arg01, fp
	sub	fp, #68
	mov	arg02, ##1099108975
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1790
LR__1789
	add	fp, #12
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	add	local03, #12
	rdlong	local06, local03
	add	fp, #104
	wrlong	local06, fp
	sub	fp, #116
	sub	objptr, ##10552
	jmp	#LR__1791
LR__1790
	add	fp, #68
	rdlong	local04, fp
	add	fp, #48
	wrlong	local04, fp
	sub	fp, #104
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	sub	fp, #12
	add	local03, #12
	wrlong	local04, local03
	sub	objptr, ##10552
LR__1791
' if params(4)<0 orelse params(4)>32 then wave=channels(channel).wave else wave=round(params(4)) : channels(channel).wave=wave
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #72
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1792
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #72
	mov	arg02, ##1107296256
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1793
LR__1792
	add	fp, #12
	rdlong	local03, fp
	mov	local07, local03
	shl	local07, #1
	add	local07, local03
	shl	local07, #3
	add	objptr, ##10552
	add	local07, objptr
	add	local07, #4
	rdbyte	local05, local07
	getbyte	local04, local05, #0
	add	fp, #20
	wrlong	local04, fp
	sub	fp, #32
	sub	objptr, ##10552
	jmp	#LR__1794
LR__1793
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #72
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #20
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	sub	fp, #12
	add	local03, #4
	wrbyte	result1, local03
	sub	objptr, ##10552
LR__1794
' if params(5)<0 orelse params(5)>8.0 then env=channels(channel).env else env=round(params(5)) : channels(channel).env=env
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1795
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	mov	arg02, ##1090519040
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1796
LR__1795
	add	fp, #12
	rdlong	local03, fp
	mov	local07, local03
	shl	local07, #1
	add	local07, local03
	shl	local07, #3
	add	objptr, ##10552
	add	local07, objptr
	add	local07, #5
	rdbyte	local05, local07
	getbyte	local04, local05, #0
	add	fp, #24
	wrlong	local04, fp
	sub	fp, #36
	sub	objptr, ##10552
	jmp	#LR__1797
LR__1796
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #36
	wrlong	result1, fp
	sub	fp, #24
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	sub	fp, #12
	add	local03, #5
	wrbyte	result1, local03
	sub	objptr, ##10552
LR__1797
' if params(6)<0 orelse params(6)>1000.0 then slen=channels(channel).length else slen=params(6) : channels(channel).length=slen
	add	fp, #80
	rdlong	arg01, fp
	sub	fp, #80
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1798
	add	fp, #80
	rdlong	arg01, fp
	sub	fp, #80
	mov	arg02, ##1148846080
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1799
LR__1798
	add	fp, #12
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	add	local03, #8
	rdlong	local06, local03
	add	fp, #108
	wrlong	local06, fp
	sub	fp, #120
	sub	objptr, ##10552
	jmp	#LR__1800
LR__1799
	add	fp, #80
	rdlong	local06, fp
	add	fp, #40
	wrlong	local06, fp
	sub	fp, #108
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	sub	fp, #12
	add	local03, #8
	wrlong	local06, local03
	sub	objptr, ##10552
LR__1800
' if params(7)<-1.0 orelse params(7)>1.0 then pan=channels(channel).pan else pan= params(7) : channels(channel).pan=pan
	add	fp, #84
	rdlong	arg01, fp
	sub	fp, #84
	mov	arg02, ##-1082130432
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1801
	add	fp, #84
	rdlong	arg01, fp
	sub	fp, #84
	mov	arg02, ##1065353216
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1802
LR__1801
	add	fp, #12
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	add	local03, #16
	rdlong	local06, local03
	add	fp, #100
	wrlong	local06, fp
	sub	fp, #112
	sub	objptr, ##10552
	jmp	#LR__1803
LR__1802
	add	fp, #84
	rdlong	local06, fp
	add	fp, #28
	wrlong	local06, fp
	sub	fp, #100
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	sub	fp, #12
	add	local03, #16
	wrlong	local06, local03
	sub	objptr, ##10552
LR__1803
' if params(8)<0 orelse params(8)>255 then sus=channels(channel).sus else sus= round(params(8)) : channels(channel).sus=sus
	add	fp, #88
	rdlong	arg01, fp
	sub	fp, #88
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	jmp	#LR__1804
	add	fp, #88
	rdlong	arg01, fp
	sub	fp, #88
	mov	arg02, ##1132396544
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__1805
LR__1804
	add	fp, #12
	rdlong	local03, fp
	mov	local07, local03
	shl	local07, #1
	add	local07, local03
	shl	local07, #3
	add	objptr, ##10552
	add	local07, objptr
	add	local07, #20
	rdword	local04, local07
	add	fp, #32
	wrlong	local04, fp
	sub	fp, #44
	sub	objptr, ##10552
	jmp	#LR__1806
LR__1805
	add	fp, #88
	rdlong	arg01, fp
	sub	fp, #88
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #44
	wrlong	result1, fp
	sub	fp, #32
	rdlong	local02, fp
	mov	local03, local02
	shl	local03, #1
	add	local03, local02
	shl	local03, #3
	add	objptr, ##10552
	add	local03, objptr
	sub	fp, #12
	add	local03, #20
	wrword	result1, local03
	sub	objptr, ##10552
LR__1806
	add	fp, #108
	rdlong	arg02, fp
	sub	fp, #108
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	mov	local04, result1
	decod	arg02, #30
	mov	arg01, ##1076754516
	call	#__system____builtin_logbase
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	add	fp, #48
	wrlong	result1, fp
	decod	local04, #30
	mov	arg01, result1
	sub	fp, #48
	add	arg01, #5
	abs	arg01, arg01 wc
 if_b	decod	local08, #31
 if_ae	mov	local08, #0
	call	#__system___float_fromuns
	xor	result1, local08
	mov	arg02, result1
	mov	arg01, local04
	call	#__system____builtin_powf
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #16
	wrlong	result1, fp
' skip=round(2^(lfreq+5))
' if skip>32768 then i=skip/32768: skip=32768 else i=1
	sub	fp, #16
	cmps	result1, ##32769 wc
 if_b	jmp	#LR__1807
	add	fp, #16
	rdlong	local01, fp
	abs	local04, local01 wc
	shr	local04, #15
	negc	local04, local04
	sub	fp, #12
	wrlong	local04, fp
	add	fp, #12
	wrlong	##32768, fp
	sub	fp, #16
	jmp	#LR__1808
LR__1807
	add	fp, #4
	wrlong	#1, fp
	sub	fp, #4
LR__1808
	add	fp, #108
	rdlong	arg02, fp
	sub	fp, #108
	mov	arg01, ##1247312956
	call	#__system___float_div
	mov	local04, result1
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	abs	arg01, arg01 wc
 if_b	decod	local08, #31
 if_ae	mov	local08, #0
	call	#__system___float_fromuns
	xor	result1, local08
	mov	local01, result1
	decod	local02, #30
	mov	arg01, #13
	add	fp, #48
	rdlong	local06, fp
	sub	fp, #48
	sub	arg01, local06
	abs	arg01, arg01 wc
 if_b	decod	local08, #31
 if_ae	mov	local08, #0
	call	#__system___float_fromuns
	xor	result1, local08
	mov	arg02, result1
	mov	arg01, local02
	call	#__system____builtin_powf
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #52
	wrlong	result1, fp
	add	fp, #52
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #120
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	local04, result1
	add	fp, #20
	wrlong	local04, fp
	add	fp, #92
	rdlong	arg02, fp
	sub	fp, #112
	mov	arg01, ##1174405120
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	decod	local04, #13
	add	local04, result1
	add	fp, #24
	wrlong	local04, fp
	add	fp, #92
	rdlong	arg02, fp
	sub	fp, #116
	mov	arg01, ##1148846080
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	add	fp, #28
	wrlong	result1, fp
	add	objptr, ##28176
	rdlong	local04, objptr
	sub	objptr, ##28176
	sub	fp, #16
	rdlong	local02, fp
	shl	local02, #6
	add	local04, local02
	sub	fp, #4
	wrlong	local04, fp
' period=round((3546895/freq)/(i*(2^(13-lfreq))))
' speed=round(speed_coeff/slen)
' ipan=8192+round(8192*pan)
' ivol=round(1000.0*vol)
' base2=base+64*channel
' if wave <32 then 
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #32
	cmps	local04, #32 wc
 if_ae	jmp	#LR__1809
	add	fp, #8
	rdlong	arg01, fp
	add	arg01, #8
	add	fp, #24
	rdlong	arg02, fp
	sub	fp, #32
	shl	arg02, #11
	add	arg02, ##-1073741824
	wrlong	arg02, arg01
	jmp	#LR__1810
LR__1809
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #8
	wrlong	##-939524096, arg01
LR__1810
	add	fp, #8
	rdlong	arg01, fp
	add	arg01, #16
	wrlong	##2048, arg01
	rdlong	arg01, fp
	add	arg01, #12
	wrlong	#0, arg01
	rdlong	arg01, fp
	add	arg01, #20
	add	fp, #20
	rdlong	arg02, fp
	wrword	arg02, arg01
	sub	fp, #20
	rdlong	arg01, fp
	add	arg01, #22
	add	fp, #16
	rdlong	arg02, fp
	wrword	arg02, arg01
' lpoke base2+16,2048
' lpoke base2+12,0
' dpoke base2+20,ivol 
' dpoke base2+22,ipan 
' if wave<32 then
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #32
	cmps	local04, #32 wc
 if_ae	jmp	#LR__1811
	add	fp, #8
	rdlong	arg01, fp
	add	arg01, #24
	add	fp, #44
	rdlong	arg02, fp
	wrword	arg02, arg01
	sub	fp, #44
	rdlong	arg01, fp
	add	arg01, #26
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #16
	wrword	arg02, arg01
	jmp	#LR__1812
LR__1811
	add	fp, #8
	rdlong	local04, fp
	add	local04, #24
	add	fp, #100
	rdlong	arg02, fp
	sub	fp, #108
	mov	arg01, ##1247312956
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local04
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #26
	wrword	#256, arg01
LR__1812
	add	fp, #8
	rdlong	arg01, fp
	add	arg01, #28
	wrlong	#0, arg01
	rdlong	arg01, fp
	add	arg01, #32
	wrlong	#0, arg01
' lpoke base2+28,$0000_0000
' lpoke base2+32,0 
' if env=8 then lpoke base2+36,0 else lpoke base2+36,varptr(envbuf(env,0))
	add	fp, #28
	rdlong	local04, fp
	sub	fp, #36
	cmp	local04, #8 wz
 if_ne	jmp	#LR__1813
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #8
	add	arg01, #36
	wrlong	#0, arg01
	jmp	#LR__1814
LR__1813
	add	fp, #8
	rdlong	arg01, fp
	add	arg01, #36
	add	fp, #28
	rdlong	arg02, fp
	sub	fp, #36
	shl	arg02, #9
	add	objptr, ##6360
	add	arg02, objptr
	sub	objptr, ##6360
	wrlong	arg02, arg01
LR__1814
	add	fp, #8
	rdlong	arg01, fp
	add	arg01, #40
	add	fp, #12
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #12
	rdlong	arg01, fp
	add	arg01, #44
	add	fp, #36
	rdlong	arg02, fp
	wrlong	arg02, arg01
' lpoke base2+40,speed 
' lpoke base2+44,sus 
' if delay>0 then waitms(delay) 
	sub	fp, #4
	rdlong	local04, fp
	sub	fp, #40
	cmps	local04, #1 wc
 if_ae	add	fp, #40
 if_ae	rdlong	arg01, fp
 if_ae	sub	fp, #40
 if_ae	call	#__system___waitms
	mov	ptra, fp
	call	#popregs_
_do_play_ret
	ret

' 
' '-------------------- plot
' 
' sub do_plot
_do_plot
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	objptr, ##28204
	wrlong	arg03, objptr
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	add	objptr, #4
	wrlong	arg02, objptr
	sub	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	objptr, ##28200
	call	#_hg010b_spin2_putpixel
	mov	ptra, fp
	call	#popregs_
_do_plot_ret
	ret

' 
' '-------------------- poke
' 
' sub do_poke
_do_poke
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #32
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #24
	mov	arg01, fp
	call	#_converttoint
	add	fp, #28
	wrlong	result1, fp
' t1=pop() 'value
' t2=pop() 
' a=converttoint(t2) : v=converttoint(t1)
' if a<$80000 then poke a,v else pspoke a,v
	sub	fp, #4
	rdlong	local01, fp
	sub	fp, #24
	cmp	local01, ##524288 wc
 if_ae	jmp	#LR__1820
	add	fp, #24
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	wrbyte	arg02, arg01
	jmp	#LR__1821
LR__1820
	add	fp, #24
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #28
	call	#_pspoke
LR__1821
	mov	ptra, fp
	call	#popregs_
_do_poke_ret
	ret

' 
' '-------------------- pop
' 
' sub do_pop()
_do_pop
' if gosubtop>0 then  gosubtop -=1 
	add	objptr, ##41228
	rdlong	_var01, objptr
	sub	objptr, ##41228
	cmps	_var01, #1 wc
 if_ae	add	objptr, ##41228
 if_ae	rdlong	_var01, objptr
 if_ae	sub	_var01, #1
 if_ae	wrlong	_var01, objptr
 if_ae	sub	objptr, ##41228
_do_pop_ret
	ret

' 
' '-------------------- position
' 
' sub do_position
_do_position
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	mov	arg02, result1
	mov	arg01, local01
	call	#_hg010b_spin2_setcursorpos
	mov	ptra, fp
	call	#popregs_
_do_position_ret
	ret

' 
' '-------------------- print
' 
' sub do_print  
_do_print
	mov	COUNT_, #11
	call	#pushregs_
	mov	local04, #0
	call	#_pop
	mov	local05, result1
	mov	local06, result2
	mov	local07, result3
	mov	local01, local05
	mov	local02, local06
	mov	local03, local07
'  
' r=0
' t1=pop() 
' if t1.result_type=print_mod_comma orelse t1.result_type=print_mod_semicolon then r=t1.result_type :  t1=pop()
	cmp	local03, #33 wz
 if_ne	cmp	local03, #34 wz
 if_ne	jmp	#LR__1830
	mov	local04, local03
	call	#_pop
	mov	local05, result1
	mov	local06, result2
	mov	local07, result3
	mov	local01, local05
	mov	local02, local06
	mov	local03, local07
LR__1830
' if t1.result_type=print_mod_empty then r=t1.result_type 
	cmp	local03, #32 wz
 if_e	mov	local04, local03
' if t1.result_type=result_error then printerror(t1.result.uresult): goto 811
	cmp	local03, #255 wz
 if_ne	jmp	#LR__1831
	mov	arg01, local01
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1850
LR__1831
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult)  :  t1.result_type=result_string  
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1832
	mov	arg01, local01
	call	#_convertstring
	mov	local05, result1
	mov	local01, local05
	mov	local03, #31
LR__1832
' 
' if t1.result_type=token_channel then print "Print to channel (not yet implemented)"; t1.result.iresult : t1=pop()
	cmp	local03, #44 wz
 if_ne	jmp	#LR__1833
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5694
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local08, #10
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	local09, result1
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local10, #1
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	local11, #0
	call	#_pop
	mov	local05, result1
	mov	local06, result2
	mov	local07, result3
	mov	local01, local05
	mov	local02, local06
	mov	local03, local07
LR__1833
' 
' if r=print_mod_comma  then
	cmp	local04, #33 wz
 if_ne	jmp	#LR__1838
'   if t1.result_type=result_int then print t1.result.iresult,
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1834
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local11, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__1834
'   if t1.result_type=result_uint then print t1.result.uresult,
	cmp	local03, #29 wz
 if_ne	jmp	#LR__1835
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local11, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__1835
'   if t1.result_type=result_float then print t1.result.fresult,
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1836
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local11, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__1836
'   if t1.result_type=result_string then print t1.result.sresult,
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1837
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	local11, #0
	mov	arg01, #0
	mov	arg02, #9
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	local09, result1
	add	local05, result1
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	result1, #0
	mov	local10, #0
LR__1837
LR__1838
' if r=print_mod_semicolon then 
	cmp	local04, #34 wz
 if_ne	jmp	#LR__1843
'   if t1.result_type=result_int then print t1.result.iresult;
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1839
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	local10, #0
	mov	local11, #10
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	result1, #0
	mov	local09, #0
LR__1839
'   if t1.result_type=result_uint then print t1.result.uresult;
	cmp	local03, #29 wz
 if_ne	jmp	#LR__1840
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	local06, #0
	mov	local10, #0
	mov	local11, #10
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	local07, result1
	mov	local05, local06
	add	local05, local07
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	result1, #0
	mov	local09, #0
LR__1840
'   if t1.result_type=result_float then print t1.result.fresult;
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1841
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1841
'   if t1.result_type=result_string then print t1.result.sresult;
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1842
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1842
LR__1843
' if r=0 then 
	cmp	local04, #0 wz
 if_ne	jmp	#LR__1848
'   if t1.result_type=result_int then print t1.result.iresult
	cmp	local03, #28 wz
 if_ne	jmp	#LR__1844
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1844
'   if t1.result_type=result_uint then print t1.result.uresult
	cmp	local03, #29 wz
 if_ne	jmp	#LR__1845
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1845
'   if t1.result_type=result_float then print t1.result.fresult
	cmp	local03, #30 wz
 if_ne	jmp	#LR__1846
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	mov	arg04, #35
	call	#__system___basic_print_float
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1846
'   if t1.result_type=result_string then print t1.result.sresult
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1847
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, local01
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1847
LR__1848
' if r=print_mod_empty then print
	cmp	local04, #32 wz
 if_ne	jmp	#LR__1849
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1849
LR__1850
	mov	ptra, fp
	call	#popregs_
_do_print_ret
	ret

' 
' ' ------------------- push a variable on the stack. No command for this, a variable is a command
' 
' sub do_push
_do_push
' if stackpointer<maxstack then 
	add	objptr, ##34392
	rdlong	_var01, objptr
	sub	objptr, ##34392
	cmps	_var01, ##512 wc
 if_ae	jmp	#LR__1860
	add	objptr, ##38016
	rdlong	_var02, objptr
	mov	_var03, _var02
	shl	_var03, #1
	add	_var03, _var02
	shl	_var03, #2
	sub	objptr, ##1540
	add	_var03, objptr
	rdlong	_var01, _var03
	add	_var03, #4
	rdlong	_var04, _var03
	mov	_var03, _var02
	shl	_var03, #1
	add	_var03, _var02
	shl	_var03, #2
	add	_var03, objptr
	add	_var03, #8
	rdlong	_var02, _var03
	sub	objptr, ##2084
	rdlong	_var03, objptr
	mov	_var05, _var03
	shl	_var05, #1
	add	_var05, _var03
	shl	_var05, #2
	sub	objptr, ##6156
	add	_var05, objptr
	wrlong	_var01, _var05
	add	objptr, ##6156
	rdlong	_var05, objptr
	mov	_var03, _var05
	shl	_var03, #1
	add	_var03, _var05
	shl	_var03, #2
	sub	objptr, ##6156
	add	_var03, objptr
	add	_var03, #4
	wrlong	_var04, _var03
	add	objptr, ##6156
	rdlong	_var05, objptr
	mov	_var04, _var05
	shl	_var04, #1
	add	_var04, _var05
	shl	_var04, #2
	sub	objptr, ##6156
	add	_var04, objptr
	add	_var04, #8
	wrlong	_var02, _var04
	add	objptr, ##6156
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##34392
LR__1860
_do_push_ret
	ret

' 
' '-------------------- put
' 
' sub do_put			' put  #chn,addr,(amount,(pos))
_do_put
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #40
	add	objptr, ##38016
	rdlong	arg05, objptr
	mov	arg04, arg05
	shl	arg04, #1
	add	arg04, arg05
	shl	arg04, #2
	sub	objptr, ##1540
	add	arg04, objptr
	rdlong	arg05, arg04
	wrlong	arg05, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=4  then t1=pop() : pos=converttoint(t1)   else pos=-1
	cmp	arg05, #4 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__1870
	call	#_pop
	mov	arg05, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	objptr, ##42012
	wrlong	result1, objptr
	sub	objptr, ##42012
	jmp	#LR__1871
LR__1870
	add	objptr, ##42012
	wrlong	##-1, objptr
	sub	objptr, ##42012
LR__1871
' if numpar>=3 then t1=pop() : amount=converttoint(t1) else amount=1
	rdlong	arg05, fp
	cmps	arg05, #3 wc
 if_b	jmp	#LR__1872
	call	#_pop
	mov	arg05, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg05, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	jmp	#LR__1873
LR__1872
	add	fp, #8
	wrlong	#1, fp
	sub	fp, #8
LR__1873
' if numpar>=2 then t1=pop() : adr=converttoint(t1)
	rdlong	arg04, fp
	cmps	arg04, #2 wc
 if_b	jmp	#LR__1874
	call	#_pop
	mov	arg04, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__1874
	call	#_pop
	mov	arg04, result3
	add	fp, #28
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #28
	call	#_converttoint
	add	fp, #4
	wrlong	result1, fp
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #20
	shl	local01, #2
	add	objptr, ##41156
	add	local01, objptr
	wrlong	#0, local01
' t1=pop() : channel=converttoint(t1)
' getres(j)=0
' if pos>=0 then
	add	objptr, ##856
	rdlong	local02, objptr
	sub	objptr, ##42012
	cmps	local02, #0 wc
 if_b	jmp	#LR__1880
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #16
'    i=0: do
LR__1875
	add	fp, #20
	wrlong	#0, fp
	sub	fp, #20
'    j=0: do    
LR__1876
'    if adr<$80000 then block(j)=peek(adr+1024*i+j) else block(j)=pspeek(adr+1024*i+j)
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	cmps	local02, ##524288 wc
 if_ae	jmp	#LR__1877
	add	fp, #20
	rdlong	local02, fp
	mov	local01, local02
	add	objptr, ##40116
	add	local01, objptr
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg04, fp
	shl	arg04, #10
	add	arg01, arg04
	sub	fp, #16
	add	arg01, local02
	rdbyte	result1, arg01
	sub	objptr, ##40116
	wrbyte	result1, local01
	jmp	#LR__1878
LR__1877
	add	fp, #20
	rdlong	local02, fp
	mov	local01, local02
	add	objptr, ##40116
	add	local01, objptr
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg04, fp
	shl	arg04, #10
	add	arg01, arg04
	sub	fp, #16
	add	arg01, local02
	sub	objptr, ##40116
	call	#_pspeek
	wrbyte	result1, local01
LR__1878
	add	fp, #20
	rdlong	local02, fp
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #20
	cmps	local02, ##1024 wc
 if_ae	jmp	#LR__1879
	add	fp, #16
	rdlong	local01, fp
	shl	local01, #10
	add	fp, #4
	rdlong	local02, fp
	add	local01, local02
	sub	fp, #12
	rdlong	local02, fp
	sub	fp, #8
	cmps	local01, local02 wcz
 if_be	jmp	#LR__1876
LR__1879
'    put #channel, pos+1,block(0),amount, r : getres(channel)=r
	add	fp, #4
	rdlong	arg01, fp
	add	objptr, ##42012
	rdlong	arg02, objptr
	add	arg02, #1
	sub	objptr, ##1896
	mov	arg03, objptr
	sub	objptr, ##40116
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #8
	mov	arg05, #1
	call	#__system___basic_put
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #20
	rdlong	local01, fp
	shl	local01, #2
	add	objptr, ##41156
	add	local01, objptr
	wrlong	result1, local01
'    if 1024*i+j>amount then exit loop
	add	fp, #12
	rdlong	local02, fp
	shl	local02, #10
	add	fp, #4
	rdlong	local01, fp
	add	local02, local01
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #8
	cmps	local02, local01 wcz
	sub	objptr, ##41156
 if_a	jmp	#LR__1887
	add	fp, #16
	rdlong	local02, fp
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #16
	jmp	#LR__1875
LR__1880
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #16
'    i=0: do
LR__1881
	add	fp, #20
	wrlong	#0, fp
	sub	fp, #20
'    j=0: do  
LR__1882
'    if adr<$80000 then block(j)=peek(adr+1024*i+j) else block(j)=pspeek(adr+1024*i+j)
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	cmps	local02, ##524288 wc
 if_ae	jmp	#LR__1883
	add	fp, #20
	rdlong	local02, fp
	mov	local01, local02
	add	objptr, ##40116
	add	local01, objptr
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg04, fp
	shl	arg04, #10
	add	arg01, arg04
	sub	fp, #16
	add	arg01, local02
	rdbyte	result1, arg01
	sub	objptr, ##40116
	wrbyte	result1, local01
	jmp	#LR__1884
LR__1883
	add	fp, #20
	rdlong	local02, fp
	mov	local01, local02
	add	objptr, ##40116
	add	local01, objptr
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg04, fp
	shl	arg04, #10
	add	arg01, arg04
	sub	fp, #16
	add	arg01, local02
	sub	objptr, ##40116
	call	#_pspeek
	wrbyte	result1, local01
LR__1884
	add	fp, #20
	rdlong	local02, fp
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #20
	cmps	local02, ##1024 wc
 if_ae	jmp	#LR__1885
	add	fp, #16
	rdlong	local01, fp
	shl	local01, #10
	add	fp, #4
	rdlong	local02, fp
	add	local01, local02
	sub	fp, #12
	rdlong	local02, fp
	sub	fp, #8
	cmps	local01, local02 wcz
 if_be	jmp	#LR__1882
LR__1885
'    put #channel,,block(0),amount, r : getres(channel)=r
	add	fp, #4
	rdlong	arg01, fp
	add	objptr, ##40116
	mov	arg03, objptr
	sub	objptr, ##40116
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #8
	mov	arg02, #0
	mov	arg05, #1
	call	#__system___basic_put
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #20
	rdlong	local01, fp
	shl	local01, #2
	add	objptr, ##41156
	add	local01, objptr
	wrlong	result1, local01
'    if 1024*i+j>amount then exit loop
	add	fp, #12
	rdlong	local02, fp
	shl	local02, #10
	add	fp, #4
	rdlong	local01, fp
	add	local02, local01
	sub	fp, #12
	rdlong	local03, fp
	sub	fp, #8
	cmps	local02, local03 wcz
	sub	objptr, ##41156
 if_a	jmp	#LR__1886
	add	fp, #16
	rdlong	local02, fp
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #16
	jmp	#LR__1881
LR__1886
LR__1887
	mov	ptra, fp
	call	#popregs_
_do_put_ret
	ret

' 
' '-------------------- rad
' 
' sub do_rad
_do_rad
	add	objptr, ##41916
	wrlong	##1065353216, objptr
	add	objptr, #4
	wrlong	##1065353216, objptr
	sub	objptr, ##41920
_do_rad_ret
	ret

' 
' '-------------------- rdpin
' 
' sub do_rdpin
_do_rdpin
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	rdpin	result1, result1
	add	objptr, ##42016
	wrlong	result1, objptr
	sub	objptr, ##42016
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	#4, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_rdpin_ret
	ret

' 
' '------------------- release
' 
' sub do_release
_do_release
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	call	#_pop
	mov	arg02, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #12
	wrlong	result1, fp
' 
' t1=pop()
' channel=converttoint(t1)
' if channel>=0 andalso channel<=7 then lpoke base+64*channel+44,255  
	sub	fp, #12
	cmps	result1, #0 wc
 if_b	jmp	#LR__1890
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	cmps	arg02, #8 wc
 if_ae	jmp	#LR__1890
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	shl	arg02, #6
	add	arg01, arg02
	add	arg01, #44
	wrlong	#255, arg01
LR__1890
	mov	ptra, fp
	call	#popregs_
_do_release_ret
	ret

' 
' '------------------- return
' 
' sub do_return()
_do_return
' if gosubtop>0 then
	add	objptr, ##41228
	rdlong	_var01, objptr
	sub	objptr, ##41228
	cmps	_var01, #1 wc
 if_b	jmp	#LR__1900
	add	objptr, ##41228
	rdlong	_var01, objptr
	shl	_var01, #3
	sub	objptr, ##1888
	add	_var01, objptr
	rdlong	_var01, _var01
	add	objptr, ##1804
	wrlong	_var01, objptr
	add	objptr, #84
	rdlong	_var01, objptr
	shl	_var01, #3
	sub	objptr, ##1888
	add	_var01, objptr
	add	_var01, #4
	rdlong	_var01, _var01
	add	objptr, ##1808
	wrlong	_var01, objptr
	sub	objptr, ##3136
	rdlong	_var01, objptr
	sub	_var01, #1
	add	objptr, #4
	wrlong	_var01, objptr
	add	objptr, ##3212
	rdlong	_var01, objptr
	sub	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##41228
LR__1900
_do_return_ret
	ret

' 
' '------------------- right$
' 
' sub do_right
_do_right
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar<>2  then print "right$: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wz
	sub	objptr, ##36476
 if_e	jmp	#LR__1910
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5695
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1913
LR__1910
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg03, result1
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #16
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : arg=converttoint(t1)
' t1=pop(): if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__1911
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1911
' if t1.result_type<>result_string then print "right$: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__1912
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5696
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1913
LR__1912
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #16
	call	#__system__Right_S
	wrlong	result1, fp
	mov	arg01, fp
	call	#_push
LR__1913
	mov	ptra, fp
	call	#popregs_
_do_right_ret
	ret

' 
' '------------------- rnd
' 
' sub do_rnd
_do_rnd
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "rnd: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	jmp	#LR__1920
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5697
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1927
LR__1920
' if numpar=0 then
	add	fp, #12
	rdlong	result3, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__1921
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	getrnd	result1
	wrlong	result1, fp
	mov	arg01, fp
	call	#_push
	jmp	#LR__1926
LR__1921
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
'   t1=pop()
'   if t1.result_type=result_int orelse t1.result_type=result_uint then
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1922
	getrnd	result1
	rdlong	local01, fp
	qdiv	result1, local01
	mov	arg01, fp
	getqy	local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	call	#_push
	jmp	#LR__1925
LR__1922
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_ne	jmp	#LR__1923
	rdlong	arg01, fp
	mov	arg02, ##1233125376
	call	#__system___float_div
	mov	local01, result1
	getrnd	arg01
	bitl	arg01, #372
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	jmp	#LR__1924
LR__1923
'     print "rnd: "; : printerror(40) 
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5698
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #40
	mov	arg02, #0
	call	#_printerror
	mov	arg01, fp
	call	#_push
LR__1924
LR__1925
LR__1926
LR__1927
	mov	ptra, fp
	call	#popregs_
_do_rnd_ret
	ret

' 
' '-------------------- round
' 
' sub do_round
_do_round
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	wrlong	result1, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_round_ret
	ret

' 
' '-------------------- rqpin
' 
' sub do_rqpin
_do_rqpin
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	mov	arg01, result1
	mov	result1, #0
	rqpin	result1, arg01
	add	objptr, ##42016
	wrlong	result1, objptr
	sub	objptr, ##42016
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	wrlong	#4, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_rqpin_ret
	ret

' 
' ' ------------------ run
' 
' sub do_run
_do_run
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, ##38016
	rdlong	local01, objptr
	add	objptr, ##3128
	rdlong	local02, objptr
	add	objptr, #4
	rdlong	local03, objptr
	mov	arg04, local01
	mov	arg03, arg04
	shl	arg03, #1
	add	arg03, arg04
	shl	arg03, #2
	sub	objptr, ##4672
	add	arg03, objptr
	rdlong	arg02, arg03
' 
' r_lineptr_e=lineptr_e
' r_runptr=runptr
' r_runptr2=runptr2
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=1 then do_load ' todo also run linenum so check the param
	cmp	arg02, #1 wz
	sub	objptr, ##36476
 if_e	mov	arg01, #0
 if_e	call	#_do_load
	add	objptr, ##38024
	rdlong	arg04, objptr
	add	objptr, ##3120
	wrlong	arg04, objptr
	add	objptr, #4
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	##-1, objptr
' runptr=programstart : runptr2=0 : oldrunptr=-1
' if inrun>0 then 
	add	objptr, #44
	rdlong	arg04, objptr
	sub	objptr, ##41196
	cmp	arg04, #1 wc
 if_b	jmp	#LR__1930
	add	objptr, ##41200
	mov	arg01, objptr
	sub	objptr, #56
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##35308
	call	#_psram_spin2_read1
	sub	objptr, ##5836
'   psram.read1(varptr(runheader),runptr,24)  
'   return
	jmp	#LR__1937
LR__1930
	add	objptr, ##41196
	wrlong	#1, objptr
	add	objptr, #4
	mov	arg01, objptr
	sub	objptr, #56
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##35308
	call	#_psram_spin2_read1
' inrun=1
' psram.read1(varptr(runheader),runptr,24) 
' if runheader(0)=$FFFFFFFF then inrun=0: return 
	add	objptr, ##35364
	rdlong	local04, objptr
	sub	objptr, ##41200
	cmp	local04, ##-1 wz
 if_e	add	objptr, ##41196
 if_e	wrlong	#0, objptr
 if_e	sub	objptr, ##41196
 if_e	jmp	#LR__1937
' do 
LR__1931
'   if runptr<>oldrunptr then
	add	objptr, ##41144
	rdlong	local04, objptr
	add	objptr, #8
	rdlong	arg04, objptr
	sub	objptr, ##41152
	cmp	local04, arg04 wz
 if_e	jmp	#LR__1932
	add	objptr, ##41200
	mov	arg01, objptr
	sub	objptr, #56
	rdlong	arg02, objptr
	mov	arg03, #24
	sub	objptr, ##35308
	call	#_psram_spin2_read1
	add	objptr, ##30640
	mov	arg01, objptr
	add	objptr, ##4668
	rdlong	arg02, objptr
	sub	objptr, ##5716
	rdlong	local04, objptr
	shl	local04, #1
	add	arg02, local04
	add	objptr, ##5780
	rdlong	arg03, objptr
	sub	objptr, #64
	rdlong	local04, objptr
	sub	arg03, local04
	sub	objptr, ##35308
	call	#_psram_spin2_read1
	add	objptr, ##35372
	rdlong	local04, objptr
	sub	objptr, #64
	rdlong	arg02, objptr
	sub	local04, arg02
	sub	objptr, ##5716
	rdlong	arg02, objptr
	qdiv	local04, arg02
	add	objptr, ##2584
	getqx	local04
	sub	local04, #3
	wrlong	local04, objptr
	add	objptr, ##3132
	rdlong	local04, objptr
	add	objptr, #8
	wrlong	local04, objptr
	sub	objptr, ##41152
LR__1932
	add	objptr, ##41220
	rdlong	local04, objptr
	sub	objptr, #76
	wrlong	local04, objptr
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, ##41148
	call	#_execute_line
	add	objptr, ##41148
	wrlong	result1, objptr
	sub	objptr, #4
	rdlong	local04, objptr
	sub	objptr, ##41144
	cmp	local04, ##2147483647 wz
 if_e	jmp	#LR__1935
	mov	arg01, #224
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1933
	mov	arg01, #228
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_e	jmp	#LR__1934
LR__1933
	mov	arg01, #6
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_ne	jmp	#LR__1935
LR__1934
	add	objptr, ##41196
	rdlong	local04, objptr
	sub	objptr, ##41196
	cmp	local04, #2 wz
 if_ne	jmp	#LR__1931
LR__1935
'   ''do whatever kbm.peek_latest_key()=$106 
' if runptr<>$7FFF_FFFF andalso inrun=1 then 
	add	objptr, ##41144
	rdlong	local04, objptr
	sub	objptr, ##41144
	cmp	local04, ##2147483647 wz
 if_e	jmp	#LR__1936
	add	objptr, ##41196
	rdlong	local04, objptr
	sub	objptr, ##41196
	cmp	local04, #1 wz
 if_ne	jmp	#LR__1936
'   print: print "Stopped at line ";runheader(0) 
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5699
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	add	objptr, ##41200
	rdlong	arg02, objptr
	sub	objptr, ##41200
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_unsigned
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1936
	add	objptr, ##41196
	wrlong	#0, objptr
	sub	objptr, ##3180
	wrlong	local01, objptr
	add	objptr, ##3128
	wrlong	local02, objptr
	add	objptr, #4
	wrlong	local03, objptr
	sub	objptr, ##41148
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_hg010b_spin2_setspritesize
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_hg010b_spin2_setspritesize
LR__1937
	mov	ptra, fp
	call	#popregs_
_do_run_ret
	ret

' 
' ' ------------------ save
' 
' sub do_save                        
_do_save
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #184
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	rdlong	local03, local02
	add	fp, #16
	wrlong	local03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>0 then t1=pop() else t1.result.sresult=loadname : t1.result_type=result_string 
	sub	fp, #16
	cmps	local03, #1 wc
	sub	objptr, ##36476
 if_b	jmp	#LR__1940
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	jmp	#LR__1941
LR__1940
	add	objptr, ##41944
	rdlong	local03, objptr
	sub	objptr, ##41944
	wrlong	local03, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1941
' if pslpeek(programstart)=$FFFFFFFF then printerror(27): return
	add	objptr, ##38024
	rdlong	arg01, objptr
	sub	objptr, ##38024
	call	#_pslpeek
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__1942
	mov	arg01, #27
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1948
LR__1942
' if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult): t1.result_type=result_string
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #43 wz
 if_ne	jmp	#LR__1943
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__1943
' if t1.result_type=result_string then
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	jmp	#LR__1947
'   if t1.result.sresult="" then t1.result.sresult=loadname else loadname=t1.result.sresult
	rdlong	arg01, fp
	mov	arg02, ##@LR__5700
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	add	objptr, ##41944
 if_e	rdlong	local03, objptr
 if_e	wrlong	local03, fp
 if_e	sub	objptr, ##41944
 if_ne	rdlong	local03, fp
 if_ne	add	objptr, ##41944
 if_ne	wrlong	local03, objptr
 if_ne	sub	objptr, ##41944
'   close #9: open currentdir$+"/"+t1.result.sresult for output as #9
	mov	arg01, #9
	call	#__system__close
	mov	local03, #9
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5701
	call	#__system___string_concat
	mov	arg01, result1
	rdlong	arg02, fp
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local03
	mov	arg03, #13
	call	#__system___basic_open_string
	add	objptr, ##38024
	rdlong	local03, objptr
	sub	objptr, ##38024
	add	fp, #176
	wrlong	local03, fp
	sub	fp, #176
'   saveptr=programstart
'   do
LR__1944
	add	fp, #20
	mov	arg01, fp
	add	fp, #156
	rdlong	arg02, fp
	sub	fp, #176
	mov	arg03, #24
	add	objptr, ##5836
	call	#_psram_spin2_read1
	add	fp, #44
	mov	arg01, fp
	sub	fp, #16
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #32
	call	#_psram_spin2_read1
	sub	objptr, ##5836
	mov	local03, ##@LR__5702
	add	fp, #172
	wrlong	local03, fp
'     psram.read1(varptr(header(0)),saveptr,24)
'     psram.read1(varptr(linebuf(0)),header(2),header(3)) 
'     saveline$="" : for i=1 to header(3) : saveline$=saveline$+chr$(linebuf(i-1)) : next i 
	sub	fp, #160
	wrlong	#1, fp
	add	fp, #20
	rdlong	local04, fp
	sub	fp, #32
	add	local04, #1
LR__1945
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local03, local04 wc
 if_ae	jmp	#LR__1946
	add	fp, #172
	rdlong	local01, fp
	sub	fp, #160
	rdlong	local03, fp
	sub	local03, #1
	add	fp, #32
	add	local03, fp
	rdbyte	arg01, local03
	sub	fp, #44
	call	#__system__Chr_S
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	add	fp, #172
	wrlong	result1, fp
	sub	fp, #160
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #12
	jmp	#LR__1945
LR__1946
'     print #9, saveline$
	mov	arg01, #9
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	add	fp, #172
	rdlong	arg02, fp
	sub	fp, #172
	mov	arg01, #9
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #9
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #9
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	fp, #40
	rdlong	local03, fp
	add	fp, #136
	wrlong	local03, fp
	sub	fp, #136
	rdlong	local03, fp
	sub	fp, #40
	cmp	local03, ##2147483647 wz
 if_ne	jmp	#LR__1944
'   close #9  
	mov	arg01, #9
	call	#__system__close
'   print "Saved as ";currentdir$+"/"+loadname
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5703
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	local02, #0
	add	objptr, ##38036
	rdlong	arg01, objptr
	sub	objptr, ##38036
	mov	arg02, ##@LR__5704
	call	#__system___string_concat
	mov	arg01, result1
	add	objptr, ##41944
	rdlong	arg02, objptr
	sub	objptr, ##41944
	call	#__system___string_concat
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
LR__1947
LR__1948
	mov	ptra, fp
	call	#popregs_
_do_save_ret
	ret

' 
' ' ------------------ setdelay
' 
' sub do_setdelay
_do_setdelay
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	mov	local01, local02
	shl	local01, #1
	add	local01, local02
	shl	local01, #3
	add	objptr, ##10552
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##10552
	call	#_converttoint
	add	local01, #6
	wrword	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setdelay_ret
	ret

' 
' ' ------------------ setenv
' 
' sub do_setenv
_do_setenv
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	mov	local01, local02
	shl	local01, #1
	add	local01, local02
	shl	local01, #3
	add	objptr, ##10552
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##10552
	call	#_converttoint
	add	local01, #5
	wrbyte	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setenv_ret
	ret

' 
' ' ------------------ setlen
' 
' sub do_setlen
_do_setlen
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	mov	local01, local02
	shl	local01, #1
	add	local01, local02
	shl	local01, #3
	add	objptr, ##10552
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##10552
	call	#_converttofloat
	add	local01, #8
	wrlong	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setlen_ret
	ret

' 
' ' ------------------ setpan
' 
' sub do_setpan
_do_setpan
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	mov	local01, local02
	shl	local01, #1
	add	local01, local02
	shl	local01, #3
	add	objptr, ##10552
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##10552
	call	#_converttofloat
	add	local01, #16
	wrlong	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setpan_ret
	ret

' 
' ' ------------------ setsustain
' 
' sub do_setsustain
_do_setsustain
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	mov	local01, local02
	shl	local01, #1
	add	local01, local02
	shl	local01, #3
	add	objptr, ##10552
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##10552
	call	#_converttoint
	add	local01, #20
	wrword	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setsustain_ret
	ret

' 
' ' ------------------ setvol
' 
' sub do_setvol
_do_setvol
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	mov	local01, local02
	shl	local01, #1
	add	local01, local02
	shl	local01, #3
	add	objptr, ##10552
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##10552
	call	#_converttofloat
	add	local01, #12
	wrlong	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setvol_ret
	ret

' 
' ' ------------------ setwave
' 
' sub do_setwave
_do_setwave
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #8
	call	#_pop
	mov	local02, result1
	add	fp, #12
	wrlong	local02, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local02, result1
	mov	local01, local02
	shl	local01, #1
	add	local01, local02
	shl	local01, #3
	add	objptr, ##10552
	add	local01, objptr
	mov	arg01, fp
	sub	objptr, ##10552
	call	#_converttoint
	add	local01, #4
	wrbyte	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_setwave_ret
	ret

' 
' ' ------------------ shutup
' 
' sub do_shutup
_do_shutup
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	local02, local01
	shl	local02, #1
	add	local02, local01
	shl	local02, #2
	sub	objptr, ##1540
	add	local02, objptr
	rdlong	local03, local02 wz
	add	fp, #20
	wrlong	local03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar=0 then
	sub	fp, #20
	sub	objptr, ##36476
 if_ne	jmp	#LR__1952
'   for i=0 to 7 : dpoke base+64*i+20,0 : next i
	add	fp, #16
	wrlong	#0, fp
	add	objptr, ##28176
	callpa	#(@LR__1951-@LR__1950)>>2,fcache_load_ptr_
LR__1950
	rdlong	arg01, objptr
	rdlong	local03, fp
	shl	local03, #6
	add	arg01, local03
	add	arg01, #20
	wrword	#0, arg01
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	cmps	local03, #8 wc
 if_b	jmp	#LR__1950
LR__1951
	sub	objptr, ##28176
	sub	fp, #16
	jmp	#LR__1953
LR__1952
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	abs	local03, result1 wc
	and	local03, #7
	negc	local02, local03
	add	fp, #12
	wrlong	local02, fp
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	sub	fp, #12
	shl	local02, #6
	add	arg01, local02
	add	arg01, #20
	wrword	#0, arg01
LR__1953
	mov	ptra, fp
	call	#popregs_
_do_shutup_ret
	ret

' 
' ' ------------------ sin
' 
' sub do_sin
_do_sin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "sin: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1960
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5705
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1961
LR__1960
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##41916
	rdlong	local01, objptr
	sub	objptr, ##41916
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_sinf
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1961
	mov	ptra, fp
	call	#popregs_
_do_sin_ret
	ret

' 
' ' ------------------ skip
' ' A helper token for on-gosub: skips the rest of gosubs
' 
' sub do_skip
_do_skip
	add	objptr, ##38016
	rdlong	_var01, objptr
	mov	_var02, _var01
	shl	_var02, #1
	add	_var02, _var01
	shl	_var02, #2
	sub	objptr, ##1540
	add	_var02, objptr
	rdlong	_var02, _var02
	sub	_var02, #1
	add	objptr, ##1540
	wrlong	_var02, objptr
	sub	objptr, ##38016
_do_skip_ret
	ret

' 
' ' ------------------ sprite
' 
' sub do_sprite
_do_sprite
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #48
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #24
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #32
	call	#_pop
	mov	arg03, result1
	mov	arg02, result2
	mov	arg01, result3
	add	fp, #12
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #20
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #36
	wrlong	result1, fp
	sub	fp, #24
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #16
	mov	arg01, fp
	sub	fp, #24
	call	#_converttoint
	add	fp, #44
	wrlong	result1, fp
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	mov	arg03, result1
	sub	fp, #40
	call	#_hg010b_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_do_sprite_ret
	ret

' 
' ' ------------------ sqr
' 
' sub do_sqr
_do_sqr
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "sqr: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__1970
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5706
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1971
LR__1970
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttofloat
	mov	arg01, result1
	call	#__system___float_sqrt
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__1971
	mov	ptra, fp
	call	#popregs_
_do_sqr_ret
	ret

' 
' ' ------------------ stick
' 
' sub do_stick
_do_stick
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "stick: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	jmp	#LR__1980
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5707
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1984
LR__1980
' if numpar=0 then t1.result.uresult=stick(0) : t1.result_type=result_uint : push t1 : return
	add	fp, #12
	rdlong	result3, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__1981
	add	objptr, ##41776
	rdlong	local01, objptr
	sub	objptr, ##41776
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	jmp	#LR__1984
LR__1981
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1983
	rdlong	local01, fp
	add	objptr, ##42008
	wrlong	local01, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##42008
	cmps	local01, #7 wc
 if_ae	jmp	#LR__1982
	add	objptr, ##42008
	rdlong	local01, objptr
	shl	local01, #2
	sub	objptr, #232
	add	local01, objptr
	rdlong	local01, local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	sub	objptr, ##41776
	call	#_push
'     t1.result.uresult=stick(q) : t1.result_type=result_uint : push t1 : return 
	jmp	#LR__1984
LR__1982
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1984
LR__1983
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1984
	mov	ptra, fp
	call	#popregs_
_do_stick_ret
	ret

' 
' ' ------------------ strig
' 
' sub do_strig
_do_strig
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 then print "strig: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	jmp	#LR__1990
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5708
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__1994
LR__1990
' if numpar=0 then t1.result.uresult=strig(0) : t1.result_type=result_uint : push t1 : return
	add	fp, #12
	rdlong	result3, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__1991
	add	objptr, ##41804
	rdlong	local01, objptr
	sub	objptr, ##41804
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	jmp	#LR__1994
LR__1991
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' t1=pop()
' if t1.result_type=result_int orelse t1.result_type=result_uint then  
	sub	fp, #8
	cmp	result3, #28 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local01, #29 wz
 if_ne	jmp	#LR__1993
	rdlong	local01, fp
	add	objptr, ##42008
	wrlong	local01, objptr
'   q=t1.result.uresult
'   if q<7 then 
	sub	objptr, ##42008
	cmps	local01, #7 wc
 if_ae	jmp	#LR__1992
	add	objptr, ##42008
	rdlong	local01, objptr
	shl	local01, #2
	sub	objptr, #204
	add	local01, objptr
	rdlong	local01, local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	sub	objptr, ##41804
	call	#_push
'     t1.result.uresult=strig(q) : t1.result_type=result_uint : push t1 : return 
	jmp	#LR__1994
LR__1992
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
'      printerror(41) : return
	jmp	#LR__1994
LR__1993
	mov	arg01, #41
	mov	arg02, #0
	call	#_printerror
LR__1994
	mov	ptra, fp
	call	#popregs_
_do_strig_ret
	ret

' 
' ' ------------------ tan
' 
' sub do_tan
_do_tan
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	rdlong	arg03, arg03
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "tan: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__2000
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5709
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2001
LR__2000
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	add	objptr, ##41916
	rdlong	local01, objptr
	sub	objptr, ##41916
	mov	arg01, fp
	call	#_converttofloat
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_tanf
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
LR__2001
	mov	ptra, fp
	call	#popregs_
_do_tan_ret
	ret

' 
' ' ------------------ val
' 
' sub do_val
_do_val
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #32
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	local01, arg03
	shl	local01, #1
	add	local01, arg03
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	rdlong	arg03, local01
	add	fp, #12
	wrlong	arg03, fp
' 
' numpar=compiledline(lineptr_e).result.uresult
' if numpar>1 orelse numpar=0 then print "val: "; : printerror(39) : return
	sub	fp, #12
	cmp	arg03, #2 wc
	sub	objptr, ##36476
 if_b	add	fp, #12
 if_b	rdlong	local01, fp wz
 if_b	sub	fp, #12
 if_c_and_nz	jmp	#LR__2010
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5710
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #39
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2023
LR__2010
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
' t1=pop() : if t1.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult) : t1.result_type=result_string
	sub	fp, #8
	cmp	arg03, #43 wz
 if_ne	jmp	#LR__2011
	rdlong	arg01, fp
	call	#_convertstring
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
LR__2011
' if t1.result_type<>result_string then print "val: "; : printerror(15) : return 
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #31 wz
 if_e	jmp	#LR__2012
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5711
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg01, #15
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2023
LR__2012
' if left$(t1.result.sresult,1)="$" then t1.result.sresult="&h"+right$(t1.result.sresult,len(t1.result.sresult)-1)
	rdlong	arg01, fp
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5712
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2015
	mov	local01, ##@LR__5713
	rdlong	arg03, fp
	mov	arg01, arg03
	mov	local02, arg01
	callpa	#(@LR__2014-@LR__2013)>>2,fcache_load_ptr_
LR__2013
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__2013
LR__2014
	sub	local02, arg01
	mov	arg02, local02
	sub	arg02, #1
	mov	arg01, arg03
	call	#__system__Right_S
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	wrlong	result1, fp
LR__2015
' if left$(t1.result.sresult,1)="%" then t1.result.sresult="&b"+right$(t1.result.sresult,len(t1.result.sresult)-1)
	rdlong	arg01, fp
	mov	arg02, #1
	call	#__system__Left_S
	mov	arg01, result1
	mov	arg02, ##@LR__5714
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2018
	mov	local01, ##@LR__5715
	rdlong	arg03, fp
	mov	arg01, arg03
	mov	local02, arg01
	callpa	#(@LR__2017-@LR__2016)>>2,fcache_load_ptr_
LR__2016
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__2016
LR__2017
	sub	local02, arg01
	mov	arg02, local02
	sub	arg02, #1
	mov	arg01, arg03
	call	#__system__Right_S
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	wrlong	result1, fp
LR__2018
	rdlong	arg01, fp
	call	#__system____builtin_atof
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system____builtin_atoi
	add	fp, #24
	wrlong	result1, fp
' fval=val(t1.result.sresult)
' ival=val%(t1.result.sresult)
' if fval=ival then
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #28
	abs	arg01, result1 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local01
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2019
	add	fp, #24
	rdlong	local01, fp
	sub	fp, #24
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2022
LR__2019
'   if fval=0 andalso ival<>0 then
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #28
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2020
	add	fp, #24
	rdlong	local01, fp wz
	sub	fp, #24
 if_e	jmp	#LR__2020
	add	fp, #24
	rdlong	local01, fp
	sub	fp, #24
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2021
LR__2020
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	wrlong	local01, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
LR__2021
LR__2022
	mov	arg01, fp
	call	#_push
LR__2023
	mov	ptra, fp
	call	#popregs_
_do_val_ret
	ret

' 
' ' ------------------ waitclock
' 
' sub do_waitclock
_do_waitclock
	add	objptr, ##41896
	rdlong	_var01, objptr
' c=hkcnt
' do: loop until hkcnt<>c
LR__2030
	rdlong	_var02, objptr
	cmp	_var02, _var01 wz
 if_e	jmp	#LR__2030
	sub	objptr, ##41896
_do_waitclock_ret
	ret

' 
' ' ------------------ waitms
' 
' sub do_waitms
_do_waitms
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #12
	wrlong	result1, fp
' 
' t1=pop()  
' t=converttoint(t1)
' if t<0 then return
	sub	fp, #12
	cmps	result1, #0 wc
 if_b	jmp	#LR__2046
' if t < 1000 then 
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	cmps	arg01, ##1000 wc
 if_ae	jmp	#LR__2040
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___waitms
	jmp	#LR__2045
LR__2040
	add	fp, #16
	wrlong	#1, fp
	sub	fp, #4
	rdlong	arg01, fp
	abs	arg01, arg01 wc
	qdiv	arg01, ##1000
'   for i=1 to t/1000
	sub	fp, #12
	getqx	local01
	negc	local01, local01
	add	local01, #1
LR__2041
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	cmps	arg01, local01 wc
 if_ae	jmp	#LR__2044
	mov	arg01, ##1000
	call	#__system___waitms
'     waitms(1000)
'     if ((kbm.keystate(kbm.KEY_LCTRL) orelse kbm.keystate(kbm.KEY_RCTRL)) andalso kbm.keystate(kbm.KEY_C)) then return
	mov	arg01, #224
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2042
	mov	arg01, #228
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_e	jmp	#LR__2043
LR__2042
	mov	arg01, #6
	call	#_usbnew_spin2_keystate
	cmp	result1, #0 wz
 if_ne	jmp	#LR__2046
LR__2043
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, #1
	wrlong	arg01, fp
	sub	fp, #16
	jmp	#LR__2041
LR__2044
	add	fp, #12
	rdlong	local01, fp
	abs	local01, local01 wc
	qdiv	local01, ##1000
	sub	fp, #12
	getqy	local01
	negc	arg01, local01
	call	#__system___waitms
LR__2045
LR__2046
	mov	ptra, fp
	call	#popregs_
_do_waitms_ret
	ret

' 
' ' ------------------ waitvbl
' 
' sub do_waitvbl
_do_waitvbl
	mov	arg01, #1
	call	#_hg010b_spin2_waitvbl
_do_waitvbl_ret
	ret

' 
' ' ------------------ wrpin
' 
' sub do_wrpin
_do_wrpin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	wrpin	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_wrpin_ret
	ret

' 
' ' ------------------ wxpin
' 
' sub do_wxpin
_do_wxpin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	wxpin	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_wxpin_ret
	ret

' 
' ' ------------------ wypin
' 
' sub do_wypin
_do_wypin
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	call	#_pop
	mov	local01, result3
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	mov	local01, result1
	mov	arg01, fp
	call	#_converttoint
	wypin	result1, local01
	mov	ptra, fp
	call	#popregs_
_do_wypin_ret
	ret

' 
' 
' 
' 
' 
' 
' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Runtime variable processing--------------------------------------------------------------------- 
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' 
' '------------------ Assign
' 
' sub do_assign
_do_assign
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #68
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg02, arg02
	add	fp, #24
	wrlong	arg02, fp
' 
' varnum=compiledline(lineptr_e).result.uresult ' numpar is in twowords(1), pop numpar 
' if variables(varnum).vartype<array_no_type then 
	sub	fp, #24
	shl	arg02, #4
	sub	objptr, ##25732
	add	arg02, objptr
	add	arg02, #12
	rdlong	arg03, arg02
	cmp	arg03, #256 wc
	sub	objptr, ##10744
 if_ae	jmp	#LR__2050
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #20
	rdlong	arg01, fp
	shl	arg01, #4
	add	objptr, ##10744
	add	arg01, objptr
	add	arg01, #4
	wrlong	arg03, arg01
	rdlong	arg03, fp
	shl	arg03, #4
	add	arg03, objptr
	add	arg03, #8
	wrlong	arg02, arg03
	rdlong	arg03, fp
	shl	arg03, #4
	add	arg03, objptr
	sub	fp, #16
	rdlong	arg02, fp
	add	arg03, #12
	wrlong	arg02, arg03
'   t1=pop() 
'   variables(varnum).value=t1.result : variables(varnum).vartype=t1.result_type 
'   if variables(varnum).vartype<>result_string2 then return
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #24
	shl	arg03, #4
	add	arg03, objptr
	add	arg03, #12
	rdlong	arg03, arg03
	cmp	arg03, #43 wz
	sub	objptr, ##10744
 if_ne	jmp	#LR__2073
	add	fp, #24
	rdlong	arg03, fp
	mov	local01, arg03
	shl	local01, #4
	add	objptr, ##10744
	add	local01, objptr
	sub	fp, #24
	shl	arg03, #4
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg01, arg03
	sub	objptr, ##10744
	call	#_convertstring
	add	local01, #4
	wrlong	result1, local01
	add	fp, #24
	rdlong	local01, fp
	sub	fp, #24
	shl	local01, #4
	add	objptr, ##10744
	add	local01, objptr
	add	local01, #12
	wrlong	#31, local01
'   variables(varnum).value.sresult=convertstring(variables(varnum).value.uresult)
'   variables(varnum).vartype=result_string
'   return
	sub	objptr, ##10744
	jmp	#LR__2073
LR__2050
' for i=0 to 2 : arrid(i)=0 : next i
	add	fp, #28
	wrlong	#0, fp
	callpa	#(@LR__2052-@LR__2051)>>2,fcache_load_ptr_
LR__2051
	rdlong	local01, fp
	shl	local01, #2
	add	fp, #24
	add	local01, fp
	wrlong	#0, local01
	sub	fp, #24
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	cmp	local01, #3 wc
 if_b	jmp	#LR__2051
LR__2052
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	local01, arg03
	shl	local01, #1
	add	local01, arg03
	shl	local01, #2
	sub	objptr, ##1540
	add	local01, objptr
	add	local01, #4
	rdlong	local02, local01
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #32
	sub	objptr, ##36476
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' numpar=compiledline(lineptr_e).result.twowords(1) 
' t1=pop() ' var value
' if numpar>0 then
	add	fp, #24
	rdlong	local03, fp
	sub	fp, #32
	cmp	local03, #1 wc
 if_b	jmp	#LR__2055
'   for i=numpar to 1 step -1
	add	fp, #32
	rdlong	local04, fp wz
	sub	fp, #4
	wrlong	local04, fp
	sub	fp, #28
 if_e	jmp	#LR__2054
LR__2053
	call	#_pop
	add	fp, #12
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	add	fp, #8
	rdlong	local03, fp
	sub	local03, #1
	shl	local03, #2
	add	fp, #24
	add	local03, fp
	sub	fp, #40
	mov	arg01, fp
	sub	fp, #12
	call	#_converttoint
	wrlong	result1, local03
	add	fp, #28
	rdlong	local04, fp
	sub	local04, #1 wz
	wrlong	local04, fp
	sub	fp, #28
 if_ne	jmp	#LR__2053
LR__2054
LR__2055
	add	fp, #24
	rdlong	local01, fp
	shl	local01, #4
	add	objptr, ##10744
	add	local01, objptr
	add	local01, #4
	rdlong	arg01, local01
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #36
	sub	objptr, ##10744
	call	#_pslpeek
	getword	local04, result1, #0
	add	fp, #40
	wrlong	local04, fp
	sub	fp, #4
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #2
	call	#_pspeek
	getbyte	result1, result1, #0
	add	fp, #44
	wrlong	result1, fp
' esize=pspeek(arrptr+2)
' if arrid(0)>=pslpeek(arrptr+4) orelse arrid(1)>=pslpeek(arrptr+8) orelse arrid(2)>=pslpeek(arrptr+12) then printerror(49) : return
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #4
	call	#_pslpeek
	mov	local04, result1
	add	fp, #52
	rdlong	local01, fp
	sub	fp, #52
	cmp	local01, local04 wc
 if_ae	jmp	#LR__2056
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #8
	call	#_pslpeek
	mov	local01, result1
	add	fp, #56
	rdlong	local04, fp
	sub	fp, #56
	cmp	local04, local01 wc
 if_ae	jmp	#LR__2056
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #12
	call	#_pslpeek
	add	fp, #60
	rdlong	local04, fp
	sub	fp, #60
	cmp	local04, result1 wc
 if_b	jmp	#LR__2057
LR__2056
	mov	arg01, #49
	mov	arg02, #0
	call	#_printerror
	jmp	#LR__2073
LR__2057
	add	fp, #36
	rdlong	arg01, fp
	mov	local04, arg01
	add	local04, #16
	sub	fp, #36
	add	arg01, #4
	call	#_pslpeek
	mov	local01, result1
	add	fp, #56
	rdlong	local02, fp
	qmul	local01, local02
	sub	fp, #4
	rdlong	local03, fp
	sub	fp, #16
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #8
	getqx	local02
	add	local03, local02
	call	#_pslpeek
	mov	local02, result1
	add	fp, #36
	rdlong	arg01, fp
	sub	fp, #36
	add	arg01, #4
	call	#_pslpeek
	qmul	local02, result1
	add	fp, #60
	rdlong	local02, fp
	getqx	local01
	qmul	local01, local02
	sub	fp, #16
	rdlong	local02, fp
	getqx	local01
	add	local03, local01
	qmul	local02, local03
	add	fp, #4
' 
' arridx=arrptr+16+esize*(arrid(0)+pslpeek(arrptr+4)*arrid(1)+pslpeek(arrptr+8)*pslpeek(arrptr+4)*arrid(2))
' select case arrtype
	getqx	local03
	add	local04, local03
	wrlong	local04, fp
	sub	fp, #8
	rdlong	local05, fp
	sub	fp, #40
	sub	local05, #256
	fle	local05, #12
	jmprel	local05
LR__2058
	jmp	#LR__2059
	jmp	#LR__2060
	jmp	#LR__2061
	jmp	#LR__2062
	jmp	#LR__2063
	jmp	#LR__2064
	jmp	#LR__2065
	jmp	#LR__2066
	jmp	#LR__2067
	jmp	#LR__2068
	jmp	#LR__2069
	jmp	#LR__2070
	jmp	#LR__2071
LR__2059
	mov	arg01, fp
	add	fp, #48
	rdlong	arg02, fp
	sub	fp, #48
	mov	arg03, #12
	add	objptr, ##5836
	call	#_psram_spin2_write
	sub	objptr, ##5836
	jmp	#LR__2072
LR__2060
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pspoke
	jmp	#LR__2072
LR__2061
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pspoke
	jmp	#LR__2072
LR__2062
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pspoke
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	add	arg01, #1
	rdlong	arg02, fp
	shr	arg02, #8
	call	#_pspoke
	jmp	#LR__2072
LR__2063
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pspoke
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	add	arg01, #1
	rdlong	arg02, fp
	shr	arg02, #8
	call	#_pspoke
	jmp	#LR__2072
LR__2064
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pslpoke
	jmp	#LR__2072
LR__2065
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pslpoke
	jmp	#LR__2072
LR__2066
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pslpoke
	jmp	#LR__2072
LR__2067
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pslpoke
	jmp	#LR__2072
LR__2068
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pslpoke
	jmp	#LR__2072
LR__2069
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pslpoke
	jmp	#LR__2072
LR__2070
	add	fp, #48
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	call	#_pslpoke
	jmp	#LR__2072
LR__2071
	mov	arg01, #50
	mov	arg02, #0
	call	#_printerror
LR__2072
LR__2073
	mov	ptra, fp
	call	#popregs_
_do_assign_ret
	ret

' 
' 
' '------------------ getvar.  Read a variable and push it to the RPN stack
' 
' sub do_getvar
_do_getvar
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #60
' if compiledline(lineptr_e).result.twowords(1)=0 then
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg03, local01
	shl	arg03, #1
	add	arg03, local01
	shl	arg03, #2
	sub	objptr, ##1540
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg03, arg03 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__2081
	add	objptr, ##38016
	rdlong	local01, objptr
	mov	arg01, local01
	shl	arg01, #1
	add	arg01, local01
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	local01, arg01
	shl	local01, #4
	sub	objptr, ##25732
	add	local01, objptr
	add	local01, #4
	rdlong	arg01, local01
	add	local01, #4
	rdlong	local01, local01
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	objptr, ##27272
	rdlong	local01, objptr
	mov	arg01, local01
	shl	arg01, #1
	add	arg01, local01
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	local01, arg01
	shl	local01, #4
	sub	objptr, ##25732
	add	local01, objptr
	add	local01, #12
	rdlong	local01, local01
	add	fp, #4
	wrlong	local01, fp
'   t1.result=variables(compiledline(lineptr_e).result.uresult).value
'   t1.result_type=variables(compiledline(lineptr_e).result.uresult).vartype
'   if t1.result_type<array_no_type then push t1 : return else goto 2100
	sub	fp, #8
	cmp	local01, #256 wc
	sub	objptr, ##10744
 if_ae	jmp	#LR__2080
	mov	arg01, fp
	call	#_push
	jmp	#LR__2102
LR__2080
LR__2081
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	rdlong	arg03, arg02
	shl	arg03, #4
	sub	objptr, ##25732
	add	arg03, objptr
	add	arg03, #4
	rdlong	arg01, arg03
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #12
	sub	objptr, ##10744
	call	#_pslpeek
	getword	result1, result1, #0
	add	fp, #16
	wrlong	result1, fp
	add	objptr, ##38016
	rdlong	arg03, objptr
	mov	arg02, arg03
	shl	arg02, #1
	add	arg02, arg03
	shl	arg02, #2
	sub	objptr, ##1540
	add	arg02, objptr
	add	arg02, #4
	rdlong	arg03, arg02
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #2
	sub	objptr, ##36476
	call	#_pspeek
	getbyte	result1, result1, #0
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #4
	call	#_pslpeek
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #16
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #8
	call	#_pslpeek
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #20
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #12
	call	#_pslpeek
	add	fp, #36
	wrlong	result1, fp
' numpar=compiledline(lineptr_e).result.twowords(1) ':print "in do_getvar numpar=",numpar
' esize=pspeek(arrptr+2)
' dim1=pslpeek(arrptr+4) ' todo :do one read from psram for speed
' dim2=pslpeek(arrptr+8) ' todo :do one read from psram for speed
' dim3=pslpeek(arrptr+12) ' todo :do one read from psram for speed
' if numpar>2 then t1=pop() : i3=converttoint(t1)   else i3=0 
	sub	fp, #16
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, #3 wc
 if_b	jmp	#LR__2082
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #48
	wrlong	result1, fp
	sub	fp, #48
	jmp	#LR__2083
LR__2082
	add	fp, #48
	wrlong	#0, fp
	sub	fp, #48
LR__2083
' if numpar>1 then t1=pop() : i2=converttoint(t1)   else i2=0 
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, #2 wc
 if_b	jmp	#LR__2084
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #44
	wrlong	result1, fp
	sub	fp, #44
	jmp	#LR__2085
LR__2084
	add	fp, #44
	wrlong	#0, fp
	sub	fp, #44
LR__2085
' if numpar>0 then t1=pop() : i1=converttoint(t1)   else i1=0 
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, #1 wc
 if_b	jmp	#LR__2086
	call	#_pop
	mov	arg03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #40
	jmp	#LR__2087
LR__2086
	add	fp, #40
	wrlong	#0, fp
	sub	fp, #40
LR__2087
	add	fp, #12
	rdlong	local02, fp
	add	fp, #28
	rdlong	local03, fp
	add	fp, #4
	rdlong	result2, fp
	sub	fp, #16
	rdlong	result3, fp
	qmul	result2, result3
	add	local02, #16
	add	fp, #20
	rdlong	result2, fp
	getqx	result1
	qmul	result2, result3
	add	local03, result1
	sub	fp, #16
	rdlong	result3, fp
	getqx	result2
	qmul	result2, result3
	sub	fp, #8
	rdlong	result3, fp
	getqx	result2
	add	local03, result2
	qmul	local03, result3
	add	fp, #28
' 
' varidx=arrptr+16+(i1+i2*dim1+i3*dim1*dim2)*esize 
' 
' select case vartype
	getqx	result2
	add	local02, result2
	wrlong	local02, fp
	sub	fp, #36
	rdlong	local04, fp
	sub	fp, #16
	sub	local04, #256
	fle	local04, #12
	jmprel	local04
LR__2088
	jmp	#LR__2089
	jmp	#LR__2090
	jmp	#LR__2091
	jmp	#LR__2092
	jmp	#LR__2093
	jmp	#LR__2094
	jmp	#LR__2095
	jmp	#LR__2096
	jmp	#LR__2097
	jmp	#LR__2098
	jmp	#LR__2099
	jmp	#LR__2100
	jmp	#LR__2101
LR__2089
	mov	arg01, fp
	add	fp, #52
	rdlong	arg02, fp
	sub	fp, #52
	mov	arg03, #12
	add	objptr, ##5836
	call	#_psram_spin2_read1
	sub	objptr, ##5836
	jmp	#LR__2101
LR__2090
	add	fp, #8
	wrlong	#28, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pspeek
	getbyte	result1, result1, #0
	wrlong	result1, fp
	cmp	result1, #128 wc
 if_ae	neg	local01, #256
 if_ae	rdlong	local03, fp
 if_ae	or	local01, local03
 if_ae	wrlong	local01, fp
	jmp	#LR__2101
LR__2091
	add	fp, #8
	wrlong	#29, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pspeek
	getbyte	result1, result1, #0
	wrlong	result1, fp
	jmp	#LR__2101
LR__2092
	add	fp, #8
	wrlong	#28, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	getword	result1, result1, #0
	wrlong	result1, fp
	cmp	result1, ##32768 wc
 if_ae	mov	local01, ##16776960
 if_ae	rdlong	local03, fp
 if_ae	or	local01, local03
 if_ae	wrlong	local01, fp
	jmp	#LR__2101
LR__2093
	add	fp, #8
	wrlong	#29, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	getword	result1, result1, #0
	wrlong	result1, fp
	jmp	#LR__2101
LR__2094
	add	fp, #8
	wrlong	#28, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	wrlong	result1, fp
	jmp	#LR__2101
LR__2095
	add	fp, #8
	wrlong	#29, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	wrlong	result1, fp
	jmp	#LR__2101
LR__2096
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
	wrlong	#48, fp
	jmp	#LR__2101
LR__2097
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
	wrlong	#48, fp
	jmp	#LR__2101
LR__2098
	add	fp, #8
	wrlong	#30, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	wrlong	result1, fp
	jmp	#LR__2101
LR__2099
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
	wrlong	#48, fp
	jmp	#LR__2101
LR__2100
	add	fp, #8
	wrlong	#31, fp
	add	fp, #44
	rdlong	arg01, fp
	sub	fp, #52
	call	#_pslpeek
	wrlong	result1, fp
	cmp	result1, ##524288 wc
 if_ae	add	fp, #8
 if_ae	wrlong	#43, fp
 if_ae	sub	fp, #8
LR__2101
	mov	arg01, fp
	call	#_push
LR__2102
	mov	ptra, fp
	call	#popregs_
_do_getvar_ret
	ret

' 
' '------------------ getaddr.  Get a pointer to a variable and push it to the RPN stack
' 
' sub do_getaddr
_do_getaddr
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #56
' 'print "in do_getvar, compiledline(lineptr_e) rt,ttw0,tw1="; compiledline(lineptr_e).result_type, compiledline(lineptr_e).result.twowords(0),compiledline(lineptr_e).result.twowords(1)
' if compiledline(lineptr_e).result.twowords(1)=0 then
	add	objptr, ##38016
	rdlong	arg01, objptr
	mov	result2, arg01
	shl	result2, #1
	add	result2, arg01
	shl	result2, #2
	sub	objptr, ##1540
	add	result2, objptr
	add	result2, #4
	rdlong	result2, result2 wz
	sub	objptr, ##36476
 if_ne	jmp	#LR__2110
	add	objptr, ##38016
	rdlong	arg01, objptr
	mov	result2, arg01
	shl	result2, #1
	add	result2, arg01
	shl	result2, #2
	sub	objptr, ##1540
	add	result2, objptr
	rdlong	arg01, result2
	shl	arg01, #4
	sub	objptr, ##25732
	add	arg01, objptr
	add	arg01, #12
	rdlong	arg01, arg01
	add	fp, #8
	wrlong	arg01, fp
'   t1.result_type=variables(compiledline(lineptr_e).result.uresult).vartype
'    if t1.result_type>=array_no_type then goto 2200
	sub	fp, #8
	cmp	arg01, #256 wc
	sub	objptr, ##10744
 if_ae	jmp	#LR__2111
	add	objptr, ##38016
	rdlong	arg01, objptr
	mov	result1, arg01
	shl	result1, #1
	add	result1, arg01
	shl	result1, #2
	sub	objptr, ##1540
	add	result1, objptr
	rdlong	result1, result1
	shl	result1, #4
	sub	objptr, ##25732
	add	result1, objptr
	add	result1, #4
	sub	objptr, ##10744
	wrlong	result1, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	#29, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
'   t1.result.uresult=varptr(variables(compiledline(lineptr_e).result.uresult).value)
'   t1.result.twowords(1)=0
'   t1.result_type=result_uint
'   push t1 : return
	jmp	#LR__2120
LR__2110
LR__2111
	add	objptr, ##38016
	rdlong	result3, objptr
	mov	result2, result3
	shl	result2, #1
	add	result2, result3
	shl	result2, #2
	sub	objptr, ##1540
	add	result2, objptr
	rdlong	result3, result2
	shl	result3, #4
	sub	objptr, ##25732
	add	result3, objptr
	add	result3, #4
	rdlong	result3, result3
	add	fp, #12
	wrlong	result3, fp
	add	objptr, ##27272
	rdlong	result3, objptr
	mov	arg01, result3
	shl	arg01, #1
	add	arg01, result3
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	rdlong	arg01, arg01
	shl	arg01, #4
	sub	objptr, ##25732
	add	arg01, objptr
	add	arg01, #12
	rdlong	arg01, arg01
	sub	fp, #8
	wrlong	arg01, fp
	add	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	sub	objptr, ##10744
	call	#_pslpeek
	getword	result1, result1, #0
	add	fp, #16
	wrlong	result1, fp
	add	objptr, ##38016
	rdlong	result3, objptr
	mov	arg01, result3
	shl	arg01, #1
	add	arg01, result3
	shl	arg01, #2
	sub	objptr, ##1540
	add	arg01, objptr
	add	arg01, #4
	rdlong	arg01, arg01
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #2
	sub	objptr, ##36476
	call	#_pspeek
	getbyte	result1, result1, #0
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #4
	call	#_pslpeek
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #16
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #8
	call	#_pslpeek
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #20
	rdlong	arg01, fp
	sub	fp, #12
	add	arg01, #12
	call	#_pslpeek
	add	fp, #36
	wrlong	result1, fp
' numpar=compiledline(lineptr_e).result.twowords(1) ':print "in do_getvar numpar=",numpar
' esize=pspeek(arrptr+2)
' dim1=pslpeek(arrptr+4) ' todo :do one read from psram for speed
' dim2=pslpeek(arrptr+8) ' todo :do one read from psram for speed
' dim3=pslpeek(arrptr+12) ' todo :do one read from psram for speed
' if numpar>2 then t1=pop() : i3=converttoint(t1)   else i3=0 
	sub	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	cmp	arg01, #3 wc
 if_b	jmp	#LR__2112
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #48
	wrlong	result1, fp
	sub	fp, #48
	jmp	#LR__2113
LR__2112
	add	fp, #48
	wrlong	#0, fp
	sub	fp, #48
LR__2113
' if numpar>1 then t1=pop() : i2=converttoint(t1)   else i2=0 
	add	fp, #20
	rdlong	arg01, fp
	sub	fp, #20
	cmp	arg01, #2 wc
 if_b	jmp	#LR__2114
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #44
	wrlong	result1, fp
	sub	fp, #44
	jmp	#LR__2115
LR__2114
	add	fp, #44
	wrlong	#0, fp
	sub	fp, #44
LR__2115
' if numpar>0 then t1=pop() : i1=converttoint(t1)   else i1=0 
	add	fp, #20
	rdlong	arg01, fp
	sub	fp, #20
	cmp	arg01, #1 wc
 if_b	jmp	#LR__2116
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_converttoint
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #40
	jmp	#LR__2117
LR__2116
	add	fp, #40
	wrlong	#0, fp
	sub	fp, #40
LR__2117
' 'print "dim1=",dim1,"dim2=",dim2,"dim3=",dim3, "esize=",esize, "i1=", i1,"i2=", i2, "i3=", i3
' if numpar>0 then
	add	fp, #20
	rdlong	result3, fp
	sub	fp, #20
	cmp	result3, #1 wc
 if_b	jmp	#LR__2118
	add	fp, #12
	rdlong	result2, fp
	add	fp, #28
	rdlong	result3, fp
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #16
	rdlong	result1, fp
	qmul	arg01, result1
	add	result2, #16
	add	fp, #20
	rdlong	local01, fp
	getqx	arg01
	qmul	local01, result1
	add	result3, arg01
	sub	fp, #16
	rdlong	local01, fp
	getqx	result1
	qmul	result1, local01
	sub	fp, #8
	rdlong	local01, fp
	getqx	result1
	add	result3, result1
	qmul	result3, local01
	add	fp, #28
	getqx	local01
	add	result2, local01
	wrlong	result2, fp
	sub	fp, #44
	wrlong	#29, fp
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #52
	wrlong	local01, fp
	jmp	#LR__2119
LR__2118
	add	fp, #8
	wrlong	#29, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #12
	wrlong	local01, fp
LR__2119
	mov	arg01, fp
	call	#_push
LR__2120
	mov	ptra, fp
	call	#popregs_
_do_getaddr_ret
	ret

' 
' 
' 
' '----------------------------------------------------------------------------------------------------------------------------------------
' '--------------------------------------- Operators ------------------------------------------------------------------------------------- 
' '----------------------------------------------------------------------------------------------------------------------------------------
' 
' '--------------------------------- AND 
' 
' sub do_and 
_do_and
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	add	fp, #12
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local03, #28 wz
 if_e	rdlong	local03, fp
 if_e	wrlong	local03, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #28 wz
 if_ne	jmp	#LR__2130
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #20
LR__2130
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1060
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local03, #30 wz
 if_ne	add	fp, #20
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2131
	rdlong	local03, fp
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	and	local03, local01
	wrlong	local03, fp
LR__2131
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_and_ret
	ret

' 
' '--------------------------------- DIV (integer divide)
' 
' sub do_div 
_do_div
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	muldivb_, result1
	mov	muldiva_, result2
	mov	local01, result3
	add	fp, #12
	wrlong	muldivb_, fp
	add	fp, #4
	wrlong	muldiva_, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=10: t1.result_type=result_error: goto 1090
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg01, #31 wz
 if_e	wrlong	#10, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2146
' if t1.result_type=result_float then t1.result_type=result_int : t1.result.iresult=cast(integer,t1.result.fresult)
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__2140
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
LR__2140
' if t2.result_type=result_float then t2.result_type=result_int : t2.result.iresult=cast(integer,t2.result.fresult)
	add	fp, #20
	rdlong	muldivb_, fp
	sub	fp, #20
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__2141
	add	fp, #20
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	mov	arg02, #0
	call	#__system___float_tointeger
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__2141
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult/=t2.result.uresult :goto 1090
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #29 wz
 if_ne	jmp	#LR__2142
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	muldivb_, fp
	qdiv	muldivb_, local01
	getqx	local01
	wrlong	local01, fp
	jmp	#LR__2146
LR__2142
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult/t2.result.iresult: t1.result_type=result_int :goto 1090
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #28 wz
 if_ne	jmp	#LR__2143
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	muldivb_, fp
	qdiv	muldivb_, local01
	getqx	local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2146
LR__2143
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult/=t2.result.uresult :goto 1090
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #29 wz
 if_ne	jmp	#LR__2144
	rdlong	muldiva_, fp
	add	fp, #12
	rdlong	muldivb_, fp
	sub	fp, #12
	call	#divide_
	wrlong	muldivb_, fp
	jmp	#LR__2146
LR__2144
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult=t1.result.iresult/t2.result.iresult: goto 1090
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #28 wz
 if_ne	jmp	#LR__2145
	rdlong	muldiva_, fp
	add	fp, #12
	rdlong	muldivb_, fp
	sub	fp, #12
	call	#divide_
	wrlong	muldivb_, fp
	jmp	#LR__2146
LR__2145
	wrlong	#11, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2146
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_div_ret
	ret

' 
' '--------------------------------- equal (=)
' 
' sub do_eq
_do_eq
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult=t2.result.sresult) : goto 1150
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2150
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2163
LR__2150
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult=t2.result.fresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2151
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2163
LR__2151
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult=t2.result.iresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2152
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2163
LR__2152
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult=t2.result.uresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2153
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2163
LR__2153
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult=t2.result.fresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2154
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2163
LR__2154
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult=t2.result.iresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2155
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_e	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2163
LR__2155
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult=t2.result.uresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2156
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_e	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2163
LR__2156
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult=t2.result.fresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #30 wz
 if_ne	jmp	#LR__2157
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2163
LR__2157
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult=t2.result.iresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2158
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_e	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2163
LR__2158
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult=t2.result.uresult) : goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2159
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_e	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2163
LR__2159
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)=t2.result.sresult):goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2160
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2163
LR__2160
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult=convertstring(t2.result.uresult)) :goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2161
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2163
LR__2161
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)=convertstring(t2.result.uresult)) :goto 1150
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2162
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2163
LR__2162
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2163
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_eq_ret
	ret

' 
' '--------------------------------- fdiv (/) - float divide
' 
' sub do_fdiv 
_do_fdiv
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=10: t1.result_type=result_error: goto 1100
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local01, #31 wz
 if_e	wrlong	#10, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2175
' if t1.result_type=result_int then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.iresult) 
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__2170
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	wrlong	result1, fp
LR__2170
' if t1.result_type=result_uint then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.uresult)
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__2171
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	call	#__system___float_fromuns
	wrlong	result1, fp
LR__2171
' if t2.result_type=result_int then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.iresult) 
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__2172
	add	fp, #20
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__2172
' if t2.result_type=result_uint then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.uresult) 
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__2173
	add	fp, #20
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__2173
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult/=t2.result.fresult: goto 1100
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #30 wz
 if_ne	jmp	#LR__2174
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_div
	wrlong	result1, fp
	jmp	#LR__2175
LR__2174
	wrlong	#11, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2175
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_fdiv_ret
	ret

' 
' '--------------------------------- greater or equal (>=)
' 
' sub do_ge
_do_ge
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult>=t2.result.sresult) : goto 1180
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2180
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2193
LR__2180
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult>=t2.result.fresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2181
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2193
LR__2181
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult>=t2.result.iresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2182
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2193
LR__2182
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult>=t2.result.uresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2183
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2193
LR__2183
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult>=t2.result.fresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2184
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2193
LR__2184
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult>=t2.result.iresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2185
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
 if_ae	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2193
LR__2185
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult>=t2.result.uresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2186
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
 if_ae	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2193
LR__2186
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult>=t2.result.fresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2187
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2193
LR__2187
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult>=t2.result.iresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #28 wz
 if_ne	jmp	#LR__2188
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
 if_ae	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2193
LR__2188
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult>=t2.result.uresult) : goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2189
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wc
 if_ae	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2193
LR__2189
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)>=t2.result.sresult):goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2190
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2193
LR__2190
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult>=convertstring(t2.result.uresult)) :goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2191
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2193
LR__2191
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)>=convertstring(t2.result.uresult)) :goto 1180
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2192
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2193
LR__2192
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2193
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
' 1180 t1.result_type=result_int : if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
	rdlong	local01, fp wz
 if_ne	wrlong	#1, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_ge_ret
	ret

' 
' '--------------------------------- greater than (>)
' 
' sub do_gt
_do_gt
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult>t2.result.sresult) : goto 1160
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2200
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2213
LR__2200
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult>t2.result.fresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2201
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2213
LR__2201
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult>t2.result.iresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2202
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2213
LR__2202
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult>t2.result.uresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2203
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2213
LR__2203
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult>t2.result.fresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2204
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2213
LR__2204
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult>t2.result.iresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2205
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_a	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2213
LR__2205
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult>t2.result.uresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2206
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_a	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2213
LR__2206
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult>t2.result.fresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #30 wz
 if_ne	jmp	#LR__2207
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2213
LR__2207
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult>t2.result.iresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2208
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_a	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2213
LR__2208
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult>t2.result.uresult) : goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2209
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wcz
 if_a	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2213
LR__2209
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)>t2.result.sresult):goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2210
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2213
LR__2210
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult>convertstring(t2.result.uresult)) :goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2211
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2213
LR__2211
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)>convertstring(t2.result.uresult)) :goto 1160
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2212
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_ae	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2213
LR__2212
	wrlong	#0, fp
LR__2213
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
' t1.result.uresult=0
' 1160 t1.result_type=result_int : if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
	rdlong	local01, fp wz
 if_ne	wrlong	#1, fp
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_gt_ret
	ret

' 
' '--------------------------------- less or equal (<=)
' 
' sub do_le
_do_le
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult<=t2.result.sresult) : goto 1190
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2220
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2233
LR__2220
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult<=t2.result.fresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2221
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2233
LR__2221
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult<=t2.result.iresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2222
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2233
LR__2222
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult<=t2.result.uresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2223
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2233
LR__2223
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult<=t2.result.fresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2224
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2233
LR__2224
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult<=t2.result.iresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2225
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_be	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2233
LR__2225
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult<=t2.result.uresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2226
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_be	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2233
LR__2226
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult<=t2.result.fresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #30 wz
 if_ne	jmp	#LR__2227
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2233
LR__2227
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult<=t2.result.iresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2228
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wcz
 if_be	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2233
LR__2228
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult<=t2.result.uresult) : goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2229
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wcz
 if_be	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2233
LR__2229
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)<=t2.result.sresult):goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2230
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2233
LR__2230
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult<=convertstring(t2.result.uresult)) :goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2231
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2233
LR__2231
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)<=convertstring(t2.result.uresult)) :goto 1190
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2232
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #1 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2233
LR__2232
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2233
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_le_ret
	ret

' 
' '--------------------------------- less than (<)
' 
' sub do_lt
_do_lt
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult<t2.result.sresult) : goto 1170
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2240
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2253
LR__2240
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult<t2.result.fresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2241
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2253
LR__2241
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult<t2.result.iresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2242
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2253
LR__2242
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult<t2.result.uresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2243
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2253
LR__2243
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult<t2.result.fresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2244
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2253
LR__2244
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult<t2.result.iresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2245
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
	subx	local01, local01
	wrlong	local01, fp
	jmp	#LR__2253
LR__2245
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult<t2.result.uresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2246
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
	subx	local01, local01
	wrlong	local01, fp
	jmp	#LR__2253
LR__2246
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult<t2.result.fresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #30 wz
 if_ne	jmp	#LR__2247
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2253
LR__2247
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult<t2.result.iresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2248
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmps	local02, local03 wc
	subx	local01, local01
	wrlong	local01, fp
	jmp	#LR__2253
LR__2248
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult<t2.result.uresult) : goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2249
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wc
	subx	local01, local01
	wrlong	local01, fp
	jmp	#LR__2253
LR__2249
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)<t2.result.sresult):goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2250
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2253
LR__2250
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult<convertstring(t2.result.uresult)) :goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2251
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2253
LR__2251
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)<convertstring(t2.result.uresult)) :goto 1170
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2252
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmps	result1, #0 wc
 if_b	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2253
LR__2252
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2253
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_lt_ret
	ret

' 
' '--------------------------------- minus (-)
' 
' sub do_minus
_do_minus
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_uint andalso t2.result_type=result_uint then 
	sub	fp, #8
	cmp	local03, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2261
'     if t2.result.uresult<t1.result.uresult then  t1.result.uresult-=t2.result.uresult : goto 1050 else t1.result.iresult=t1.result.uresult-t2.result.uresult : t1.result_type=result_int : goto 1050
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	local03, fp
	cmp	local01, local03 wc
 if_ae	jmp	#LR__2260
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	jmp	#LR__2270
LR__2260
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2270
LR__2261
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult-t2.result.iresult: t1.result_type=result_int :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2262
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2270
LR__2262
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.uresult)-t2.result.fresult: t1.result_type=result_float :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2263
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2270
LR__2263
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult-=t2.result.uresult:goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2264
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	jmp	#LR__2270
LR__2264
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult-=t2.result.iresult:goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #28 wz
 if_ne	jmp	#LR__2265
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	sub	local01, local02
	wrlong	local01, fp
	jmp	#LR__2270
LR__2265
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.iresult)-t2.result.fresult: t1.result_type=result_float :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2266
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2270
LR__2266
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.fresult=t1.result.fresult-cast(single,t2.result.uresult) :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2267
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2270
LR__2267
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.fresult=t1.result.fresult-cast(single,t2.result.iresult) :goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2268
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2270
LR__2268
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult-=t2.result.fresult:goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2269
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	bitnot	arg02, #31
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2270
LR__2269
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=3: t1.result_type=result_error: goto 1050
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#3, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	wrlong	#5, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
LR__2270
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_minus_ret
	ret

' 
' '--------------------------------- negative (-), one argument negative
' 
' sub do_negative
_do_negative
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #12
	call	#_pop
	mov	local01, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local01, fp
' 
' t1=pop()
' if t1.result_type=result_int then 
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	rdlong	local02, fp
 if_e	neg	local01, local02
 if_e	wrlong	local01, fp
 if_e	jmp	#LR__2282
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_ne	jmp	#LR__2280
	rdlong	local02, fp
	neg	local01, local02
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2281
LR__2280
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	rdlong	result1, fp
 if_e	bitnot	result1, #31
 if_e	wrlong	result1, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	wrlong	#40, fp
LR__2281
LR__2282
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_negative_ret
	ret

' 
' '--------------------------------- MOD (modulo)
' 
' sub do_mod 
_do_mod
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	muldivb_, result1
	mov	muldiva_, result2
	mov	local01, result3
	add	fp, #12
	wrlong	muldivb_, fp
	add	fp, #4
	wrlong	muldiva_, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=10: t1.result_type=result_error: goto 1110
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	arg01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	arg01, #31 wz
 if_e	wrlong	#10, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2296
' if t1.result_type=result_float then t1.result_type=result_int : t1.result.iresult=cast(integer,t1.result.fresult)
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__2290
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	mov	arg02, #0
	call	#__system___float_tointeger
	wrlong	result1, fp
LR__2290
' if t2.result_type=result_float then t2.result_type=result_int : t2.result.iresult=cast(integer,t2.result.fresult)
	add	fp, #20
	rdlong	muldivb_, fp
	sub	fp, #20
	cmp	muldivb_, #30 wz
 if_ne	jmp	#LR__2291
	add	fp, #20
	wrlong	#28, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	mov	arg02, #0
	call	#__system___float_tointeger
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__2291
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=t1.result.uresult mod t2.result.uresult :goto 1110
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #29 wz
 if_ne	jmp	#LR__2292
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	muldivb_, fp
	qdiv	muldivb_, local01
	getqy	local01
	wrlong	local01, fp
	jmp	#LR__2296
LR__2292
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult mod t2.result.iresult: t1.result_type=result_int :goto 1110
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #28 wz
 if_ne	jmp	#LR__2293
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	rdlong	muldivb_, fp
	qdiv	muldivb_, local01
	getqy	local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2296
LR__2293
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult=t1.result.iresult mod t2.result.uresult :goto 1110
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #29 wz
 if_ne	jmp	#LR__2294
	rdlong	muldiva_, fp
	add	fp, #12
	rdlong	muldivb_, fp
	sub	fp, #12
	call	#divide_
	wrlong	muldiva_, fp
	jmp	#LR__2296
LR__2294
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult=t1.result.iresult mod t2.result.iresult: goto 1110
	add	fp, #8
	rdlong	muldivb_, fp
	sub	fp, #8
	cmp	muldivb_, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #28 wz
 if_ne	jmp	#LR__2295
	rdlong	muldiva_, fp
	add	fp, #12
	rdlong	muldivb_, fp
	sub	fp, #12
	call	#divide_
	wrlong	muldiva_, fp
	jmp	#LR__2296
LR__2295
	wrlong	#11, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2296
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mod_ret
	ret

' 
' '--------------------------------- mul (*)
' 
' sub do_mul
_do_mul
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult*=t2.result.uresult :goto 1080
	sub	fp, #8
	cmp	local03, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2300
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	qmul	local02, local03
	sub	fp, #12
	getqx	local01
	wrlong	local01, fp
	jmp	#LR__2309
LR__2300
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult*t2.result.iresult: t1.result_type=result_int :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2301
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	qmul	local02, local03
	sub	fp, #12
	getqx	local01
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2309
LR__2301
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.uresult)*t2.result.fresult: t1.result_type=result_float :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2302
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2309
LR__2302
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult*=t2.result.uresult:goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2303
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	qmul	local02, local03
	sub	fp, #12
	getqx	local01
	wrlong	local01, fp
	jmp	#LR__2309
LR__2303
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult*=t2.result.iresult:goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #28 wz
 if_ne	jmp	#LR__2304
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	qmul	local02, local03
	sub	fp, #12
	getqx	local01
	wrlong	local01, fp
	jmp	#LR__2309
LR__2304
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.iresult)*t2.result.fresult: t1.result_type=result_float :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2305
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_mul
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2309
LR__2305
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.fresult=t1.result.fresult*cast(single,t2.result.uresult) :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2306
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	wrlong	result1, fp
	jmp	#LR__2309
LR__2306
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.fresult=t1.result.fresult*cast(single,t2.result.iresult) :goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2307
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_mul
	wrlong	result1, fp
	jmp	#LR__2309
LR__2307
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult*=t2.result.fresult:goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2308
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_mul
	wrlong	result1, fp
	jmp	#LR__2309
LR__2308
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=8: t1.result_type=result_error: goto 1080
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local03, #31 wz
 if_e	wrlong	#8, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_ne	wrlong	#9, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
LR__2309
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_mul_ret
	ret

' 
' '--------------------------------- not equal (<>)
' 
' sub do_ne
_do_ne
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.uresult=(t1.result.sresult<>t2.result.sresult) : goto 1192
	sub	fp, #8
	cmp	local03, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2310
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2323
LR__2310
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.uresult=(t1.result.fresult<>t2.result.fresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2311
	mov	local01, #0
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2323
LR__2311
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.uresult=(t1.result.fresult<>t2.result.iresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2312
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2323
LR__2312
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.fresult<>t2.result.uresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2313
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2323
LR__2313
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.uresult=(t1.result.iresult<>t2.result.fresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2314
	mov	local01, #0
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2323
LR__2314
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.uresult=(t1.result.iresult<>t2.result.iresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2315
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_ne	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2323
LR__2315
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.iresult<>t2.result.uresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2316
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_ne	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2323
LR__2316
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.uresult=(t1.result.uresult<>t2.result.fresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #30 wz
 if_ne	jmp	#LR__2317
	mov	local01, #0
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2323
LR__2317
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.uresult=(t1.result.uresult<>t2.result.iresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2318
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_ne	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2323
LR__2318
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult=(t1.result.uresult<>t2.result.uresult) : goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2319
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local02, local03 wz
 if_ne	neg	local01, #1
	wrlong	local01, fp
	jmp	#LR__2323
LR__2319
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.uresult=(convertstring(t1.result.uresult)<>t2.result.sresult):goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2320
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2323
LR__2320
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.uresult=(t1.result.sresult<>convertstring(t2.result.uresult)) :goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2321
	mov	local01, #0
	rdlong	local02, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2323
LR__2321
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.uresult=(convertstring(t1.result.uresult)<>convertstring(t2.result.uresult)) :goto 1192
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2322
	mov	local01, #0
	rdlong	arg01, fp
	call	#_convertstring
	mov	local02, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_ne	not	local01, #0
	wrlong	local01, fp
	jmp	#LR__2323
LR__2322
	wrlong	#0, fp
' t1.result.uresult=0: if t1.result.uresult<>0 then t1.result.uresult=1 ' for Atari Basic on.. goto compatibility
LR__2323
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_ne_ret
	ret

' 
' '--------------------------------- OR
' 
' sub do_or 
_do_or
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	add	fp, #12
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local03, #28 wz
 if_e	rdlong	local03, fp
 if_e	wrlong	local03, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #28 wz
 if_ne	jmp	#LR__2330
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #20
LR__2330
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1070
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local03, #30 wz
 if_ne	add	fp, #20
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2331
	rdlong	local03, fp
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	or	local03, local01
	wrlong	local03, fp
LR__2331
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_or_ret
	ret

' 
' '--------------------------------- plus (+)
' 
' sub do_plus 
_do_plus
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	local01, result1
	mov	local02, result2
	mov	local03, result3
	add	fp, #12
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	add	fp, #4
	wrlong	local03, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_uint andalso t2.result_type=result_uint then t1.result.uresult+=t2.result.uresult :goto 1040
	sub	fp, #8
	cmp	local03, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2340
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local01, local02
	wrlong	local01, fp
	jmp	#LR__2355
LR__2340
' if t1.result_type=result_uint andalso t2.result_type=result_int then t1.result.iresult=t1.result.uresult+t2.result.iresult: t1.result_type=result_int :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2341
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local01, local02
	wrlong	local01, fp
	add	fp, #8
	wrlong	#28, fp
	sub	fp, #8
	jmp	#LR__2355
LR__2341
' if t1.result_type=result_uint andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.uresult)+t2.result.fresult: t1.result_type=result_float :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #29 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2342
	rdlong	arg01, fp
	call	#__system___float_fromuns
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2355
LR__2342
' if t1.result_type=result_int andalso t2.result_type=result_uint then t1.result.iresult+=t2.result.uresult: goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2343
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local01, local02
	wrlong	local01, fp
	jmp	#LR__2355
LR__2343
' if t1.result_type=result_int andalso t2.result_type=result_int then t1.result.iresult+=t2.result.iresult:goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2344
	rdlong	local01, fp
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	add	local01, local02
	wrlong	local01, fp
	jmp	#LR__2355
LR__2344
' if t1.result_type=result_int andalso t2.result_type=result_float then t1.result.fresult=cast(single,t1.result.iresult)+t2.result.fresult: t1.result_type=result_float :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #28 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #30 wz
 if_ne	jmp	#LR__2345
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_add
	wrlong	result1, fp
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	jmp	#LR__2355
LR__2345
' if t1.result_type=result_float andalso t2.result_type=result_uint then t1.result.fresult=t1.result.fresult+cast(single,t2.result.uresult) :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #29 wz
 if_ne	jmp	#LR__2346
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2355
LR__2346
' if t1.result_type=result_float andalso t2.result_type=result_int then t1.result.fresult=t1.result.fresult+cast(single,t2.result.iresult) :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	mov	local03, local04
 if_e	cmp	local03, #28 wz
 if_ne	jmp	#LR__2347
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2355
LR__2347
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult+=t2.result.fresult:goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local04, fp
 if_e	sub	fp, #20
 if_e	cmp	local04, #30 wz
 if_ne	jmp	#LR__2348
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___float_add
	wrlong	result1, fp
	jmp	#LR__2355
LR__2348
' if t1.result_type=result_string andalso t2.result_type<>result_string then t1.result.uresult=2 :t1.result_type=result_error:goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_ne	jmp	#LR__2349
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #31 wz
 if_ne	wrlong	#2, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__2355
LR__2349
' if t2.result_type=result_string andalso t1.result_type<>result_string then t1.result.uresult=2 :t1.result_type=result_error:goto 1040
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #20
	cmp	local01, #31 wz
 if_ne	jmp	#LR__2350
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	wrlong	#2, fp
 if_ne	add	fp, #8
 if_ne	wrlong	#255, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__2355
LR__2350
' if t1.result_type=result_string andalso t2.result_type=result_string then t1.result.sresult=t1.result.sresult+t2.result.sresult :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2351
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_concat
	wrlong	result1, fp
	jmp	#LR__2355
LR__2351
' if t1.result_type=result_string2 andalso t2.result_type=result_string then t1.result.sresult=convertstring(t1.result.uresult)+t2.result.sresult : t1.result_type=result_string:goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #31 wz
 if_ne	jmp	#LR__2352
	rdlong	arg01, fp
	call	#_convertstring
	mov	arg01, result1
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system___string_concat
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	jmp	#LR__2355
LR__2352
' if t1.result_type=result_string andalso t2.result_type=result_string2 then t1.result.sresult=t1.result.sresult+convertstring(t2.result.uresult) :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #31 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2353
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	wrlong	result1, fp
	jmp	#LR__2355
LR__2353
' if t1.result_type=result_string2 andalso t2.result_type=result_string2 then t1.result.sresult=convertstring(t1.result.uresult)+convertstring(t2.result.uresult) : t1.result_type=result_string :goto 1040
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	cmp	local01, #43 wz
 if_e	add	fp, #20
 if_e	rdlong	local03, fp
 if_e	sub	fp, #20
 if_e	cmp	local03, #43 wz
 if_ne	jmp	#LR__2354
	rdlong	arg01, fp
	call	#_convertstring
	mov	local01, result1
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_convertstring
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___string_concat
	wrlong	result1, fp
	add	fp, #8
	wrlong	#31, fp
	sub	fp, #8
	jmp	#LR__2355
LR__2354
	wrlong	#4, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2355
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_plus_ret
	ret

' 
' '--------------------------------- power (^)
' 
' sub do_power 
_do_power
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg02, result1
	mov	arg01, result2
	mov	local01, result3
	add	fp, #12
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
	call	#_pop
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	result3, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_string orelse t2.result_type=result_string then t1.result.uresult=12: t1.result_type=result_error: goto 1140
	sub	fp, #8
	cmp	result3, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local01, #31 wz
 if_e	wrlong	#12, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2365
' if t1.result_type=result_int then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.iresult) 
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__2360
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	wrlong	result1, fp
LR__2360
' if t1.result_type=result_uint then t1.result_type=result_float : t1.result.fresult=cast(single,t1.result.uresult) 
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__2361
	add	fp, #8
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	call	#__system___float_fromuns
	wrlong	result1, fp
LR__2361
' if t2.result_type=result_int then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.iresult) 
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	cmp	arg02, #28 wz
 if_ne	jmp	#LR__2362
	add	fp, #20
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__2362
' if t2.result_type=result_uint then t2.result_type=result_float : t2.result.fresult=cast(single,t2.result.uresult) 
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #20
	cmp	arg02, #29 wz
 if_ne	jmp	#LR__2363
	add	fp, #20
	wrlong	#30, fp
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system___float_fromuns
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__2363
' if t1.result_type=result_float andalso t2.result_type=result_float then t1.result.fresult=t1.result.fresult^t2.result.fresult: goto 1140
	add	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	cmp	arg02, #30 wz
 if_e	add	fp, #20
 if_e	rdlong	local01, fp
 if_e	sub	fp, #20
 if_e	cmp	local01, #30 wz
 if_ne	jmp	#LR__2364
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system____builtin_powf
	wrlong	result1, fp
	jmp	#LR__2365
LR__2364
	wrlong	#13, fp
	add	fp, #8
	wrlong	#255, fp
	sub	fp, #8
LR__2365
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_power_ret
	ret

' 
' '--------------------------------- SHL
' 
' sub do_shl 
_do_shl
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	add	fp, #12
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local03, #28 wz
 if_e	rdlong	local03, fp
 if_e	wrlong	local03, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #28 wz
 if_ne	jmp	#LR__2370
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #20
LR__2370
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1120
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local03, #30 wz
 if_ne	add	fp, #20
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2371
	rdlong	local03, fp
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	shl	local03, local01
	wrlong	local03, fp
LR__2371
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_shl_ret
	ret

' 
' '--------------------------------- SHR
' 
' sub do_shr 
_do_shr
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #24
	call	#_pop
	mov	arg01, result1
	mov	local01, result2
	mov	local02, result3
	add	fp, #12
	wrlong	arg01, fp
	add	fp, #4
	wrlong	local01, fp
	add	fp, #4
	wrlong	local02, fp
	sub	fp, #20
	call	#_pop
	mov	local03, result3
	wrlong	result1, fp
	add	fp, #4
	wrlong	result2, fp
	add	fp, #4
	wrlong	local03, fp
' 
' t2=pop()
' t1=pop()
' if t1.result_type=result_int then t1.result.uresult=cast(ulong,t1.result.iresult) : t1.result_type=result_uint
	sub	fp, #8
	cmp	local03, #28 wz
 if_e	rdlong	local03, fp
 if_e	wrlong	local03, fp
 if_e	add	fp, #8
 if_e	wrlong	#29, fp
 if_e	sub	fp, #8
' if t2.result_type=result_int then t2.result.uresult=cast(ulong,t2.result.iresult) : t2.result_type=result_uint
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, #28 wz
 if_ne	jmp	#LR__2380
	add	fp, #12
	rdlong	local03, fp
	wrlong	local03, fp
	add	fp, #8
	wrlong	#29, fp
	sub	fp, #20
LR__2380
' if t1.result_type=result_string orelse t2.result_type=result_string orelse t1.result_type=result_float orelse t2.result_type=result_float then t1.result.uresult=6: t1.result_type=result_error: goto 1130
	add	fp, #8
	rdlong	local03, fp
	sub	fp, #8
	cmp	local03, #31 wz
 if_ne	add	fp, #20
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #31 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #8
 if_ne	cmp	local03, #30 wz
 if_ne	add	fp, #20
 if_ne	sub	fp, #20
 if_ne	cmp	local02, #30 wz
 if_e	wrlong	#6, fp
 if_e	add	fp, #8
 if_e	wrlong	#255, fp
 if_e	sub	fp, #8
 if_e	jmp	#LR__2381
	rdlong	local03, fp
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	shr	local03, local01
	wrlong	local03, fp
LR__2381
	mov	arg01, fp
	call	#_push
	mov	ptra, fp
	call	#popregs_
_do_shr_ret
	ret

' 
' '--------------------------- THE END OF THE MAIN PROGRAM ------------------------------------------------------
' 
' ''----------------------------------------------------------------------------------------------------
' ''------------------ Initialization procedures and helper procedures ---------------------------------
' ''----------------------------------------------------------------------------------------------------
' 
' ''--------------------------- Command function pointers
' 
' sub init_commands
_init_commands
' 
' for i=0 to 255 : commands(i)=@do_no_command : next i
	mov	_var01, #0
	callpa	#(@LR__2391-@LR__2390)>>2,fcache_load_ptr_
LR__2390
	mov	result1, _var01
	shl	result1, #2
	add	objptr, ##34400
	add	result1, objptr
	sub	objptr, ##34400
	wrlong	objptr, result1
	add	_var01, #1
	cmps	_var01, #256 wc
 if_b	jmp	#LR__2390
LR__2391
	mov	result1, objptr
	bith	result1, #20
	add	objptr, ##34404
	wrlong	result1, objptr
	sub	objptr, ##34404
	mov	result1, objptr
	bith	result1, #21
	add	objptr, ##34408
	wrlong	result1, objptr
	sub	objptr, ##34408
	mov	result1, objptr
	bith	result1, #52
	add	objptr, ##34412
	wrlong	result1, objptr
	sub	objptr, ##34412
	mov	result1, objptr
	bith	result1, #22
	add	objptr, ##34420
	wrlong	result1, objptr
	sub	objptr, ##34420
	mov	result1, objptr
	or	result1, ##5242880
	add	objptr, ##34424
	wrlong	result1, objptr
	sub	objptr, ##34424
	mov	result1, objptr
	bith	result1, #53
	add	objptr, ##34428
	wrlong	result1, objptr
	sub	objptr, ##34428
	mov	result1, objptr
	bith	result1, #84
	add	objptr, ##34432
	wrlong	result1, objptr
	sub	objptr, ##34432
	mov	result1, objptr
	bith	result1, #23
	add	objptr, ##34436
	wrlong	result1, objptr
	sub	objptr, ##34436
	mov	result1, objptr
	or	result1, ##9437184
	add	objptr, ##34440
	wrlong	result1, objptr
	sub	objptr, ##34440
	mov	result1, objptr
	or	result1, ##10485760
	add	objptr, ##34444
	wrlong	result1, objptr
	sub	objptr, ##34444
	mov	result1, objptr
	or	result1, ##11534336
	add	objptr, ##34448
	wrlong	result1, objptr
	sub	objptr, ##34448
	mov	result1, objptr
	bith	result1, #54
	add	objptr, ##34468
	wrlong	result1, objptr
	sub	objptr, ##34468
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##34516
	wrlong	result1, objptr
	sub	objptr, ##34516
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##34512
	wrlong	result1, objptr
	sub	objptr, ##34512
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##34520
	wrlong	result1, objptr
	sub	objptr, ##34520
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##34524
	wrlong	result1, objptr
	sub	objptr, ##34524
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##34572
	wrlong	result1, objptr
	sub	objptr, ##34572
	mov	result1, objptr
	bith	result1, #85
	add	objptr, ##34492
	wrlong	result1, objptr
	sub	objptr, ##34492
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##34576
	wrlong	result1, objptr
	sub	objptr, ##34576
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##34528
	wrlong	result1, objptr
	sub	objptr, ##34528
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##34532
	wrlong	result1, objptr
	sub	objptr, ##34532
	mov	result1, objptr
	or	result1, ##13631488
	add	objptr, ##34536
	wrlong	result1, objptr
	sub	objptr, ##34536
	mov	result1, objptr
	bith	result1, #116
	add	objptr, ##34656
	wrlong	result1, objptr
	sub	objptr, ##34656
	mov	result1, objptr
	bith	result1, #24
	add	objptr, ##34660
	wrlong	result1, objptr
	sub	objptr, ##34660
	mov	result1, objptr
	or	result1, ##17825792
	add	objptr, ##34664
	wrlong	result1, objptr
	sub	objptr, ##34664
	mov	result1, objptr
	or	result1, ##18874368
	add	objptr, ##34668
	wrlong	result1, objptr
	sub	objptr, ##34668
	mov	result1, objptr
	or	result1, ##19922944
	add	objptr, ##34672
	wrlong	result1, objptr
	sub	objptr, ##34672
	mov	result1, objptr
	or	result1, ##20971520
	add	objptr, ##34676
	wrlong	result1, objptr
	sub	objptr, ##34676
	mov	result1, objptr
	or	result1, ##22020096
	add	objptr, ##34680
	wrlong	result1, objptr
	sub	objptr, ##34680
	mov	result1, objptr
	or	result1, ##23068672
	add	objptr, ##34684
	wrlong	result1, objptr
	sub	objptr, ##34684
	mov	result1, objptr
	or	result1, ##24117248
	add	objptr, ##34688
	wrlong	result1, objptr
	sub	objptr, ##34688
	mov	result1, objptr
	bith	result1, #55
	add	objptr, ##34692
	wrlong	result1, objptr
	sub	objptr, ##34692
	mov	result1, objptr
	or	result1, ##26214400
	add	objptr, ##34696
	wrlong	result1, objptr
	sub	objptr, ##34696
	mov	result1, objptr
	or	result1, ##27262976
	add	objptr, ##34700
	wrlong	result1, objptr
	sub	objptr, ##34700
	mov	result1, objptr
	or	result1, ##28311552
	add	objptr, ##34704
	wrlong	result1, objptr
	sub	objptr, ##34704
	mov	result1, objptr
	bith	result1, #86
	add	objptr, ##34708
	wrlong	result1, objptr
	sub	objptr, ##34708
	mov	result1, objptr
	or	result1, ##30408704
	add	objptr, ##35420
	wrlong	result1, objptr
	sub	objptr, ##35420
	mov	result1, objptr
	bith	result1, #117
	add	objptr, ##34712
	wrlong	result1, objptr
	sub	objptr, ##34712
	mov	result1, objptr
	bith	result1, #148
	add	objptr, ##34732
	wrlong	result1, objptr
	sub	objptr, ##34732
	mov	result1, objptr
	bith	result1, #25
	add	objptr, ##34716
	wrlong	result1, objptr
	sub	objptr, ##34716
	mov	result1, objptr
	or	result1, ##34603008
	add	objptr, ##34488
	wrlong	result1, objptr
	sub	objptr, ##34488
	mov	result1, objptr
	or	result1, ##35651584
	add	objptr, ##34720
	wrlong	result1, objptr
	sub	objptr, ##34720
	mov	result1, objptr
	or	result1, ##36700160
	add	objptr, ##34724
	wrlong	result1, objptr
	sub	objptr, ##34724
	mov	result1, objptr
	or	result1, ##37748736
	add	objptr, ##34728
	wrlong	result1, objptr
	sub	objptr, ##34728
	mov	result1, objptr
	or	result1, ##38797312
	add	objptr, ##34740
	wrlong	result1, objptr
	sub	objptr, ##34740
	mov	result1, objptr
	or	result1, ##39845888
	add	objptr, ##34744
	wrlong	result1, objptr
	sub	objptr, ##34744
	mov	result1, objptr
	or	result1, ##40894464
	add	objptr, ##34748
	wrlong	result1, objptr
	sub	objptr, ##34748
	mov	result1, objptr
	or	result1, ##41943040
	add	objptr, ##34752
	wrlong	result1, objptr
	sub	objptr, ##34752
	mov	result1, objptr
	or	result1, ##42991616
	add	objptr, ##34760
	wrlong	result1, objptr
	sub	objptr, ##34760
	mov	result1, objptr
	or	result1, ##34603008
	add	objptr, ##34764
	wrlong	result1, objptr
	sub	objptr, ##34764
	mov	result1, objptr
	or	result1, ##44040192
	add	objptr, ##34508
	wrlong	result1, objptr
	sub	objptr, ##34508
	mov	result1, objptr
	or	result1, ##45088768
	add	objptr, ##34556
	wrlong	result1, objptr
	sub	objptr, ##34556
	mov	result1, objptr
	or	result1, ##46137344
	add	objptr, ##34552
	wrlong	result1, objptr
	sub	objptr, ##34552
	mov	result1, objptr
	or	result1, ##47185920
	add	objptr, ##34460
	wrlong	result1, objptr
	sub	objptr, ##34460
	mov	result1, objptr
	or	result1, ##48234496
	add	objptr, ##34464
	wrlong	result1, objptr
	sub	objptr, ##34464
	mov	result1, objptr
	or	result1, ##49283072
	add	objptr, ##34568
	wrlong	result1, objptr
	sub	objptr, ##34568
	mov	result1, objptr
	bith	result1, #56
	add	objptr, ##34736
	wrlong	result1, objptr
	sub	objptr, ##34736
	mov	result1, objptr
	or	result1, ##51380224
	add	objptr, ##34756
	wrlong	result1, objptr
	sub	objptr, ##34756
	mov	result1, objptr
	or	result1, ##52428800
	add	objptr, ##34768
	wrlong	result1, objptr
	sub	objptr, ##34768
	mov	result1, objptr
	or	result1, ##53477376
	add	objptr, ##34772
	wrlong	result1, objptr
	sub	objptr, ##34772
	mov	result1, objptr
	or	result1, ##54525952
	add	objptr, ##34776
	wrlong	result1, objptr
	sub	objptr, ##34776
	mov	result1, objptr
	or	result1, ##55574528
	add	objptr, ##34780
	wrlong	result1, objptr
	sub	objptr, ##34780
	mov	result1, objptr
	or	result1, ##56623104
	add	objptr, ##34784
	wrlong	result1, objptr
	sub	objptr, ##34784
	mov	result1, objptr
	or	result1, ##57671680
	add	objptr, ##34788
	wrlong	result1, objptr
	sub	objptr, ##34788
	mov	result1, objptr
	bith	result1, #148
	add	objptr, ##34732
	wrlong	result1, objptr
	sub	objptr, ##34732
	mov	result1, objptr
	bith	result1, #87
	add	objptr, ##34796
	wrlong	result1, objptr
	sub	objptr, ##34796
	mov	result1, objptr
	or	result1, ##59768832
	add	objptr, ##34792
	wrlong	result1, objptr
	sub	objptr, ##34792
	mov	result1, objptr
	or	result1, ##60817408
	add	objptr, ##34816
	wrlong	result1, objptr
	sub	objptr, ##34816
	mov	result1, objptr
	or	result1, ##61865984
	add	objptr, ##34820
	wrlong	result1, objptr
	sub	objptr, ##34820
	mov	result1, objptr
	bith	result1, #118
	add	objptr, ##34800
	wrlong	result1, objptr
	sub	objptr, ##34800
	mov	result1, objptr
	or	result1, ##63963136
	add	objptr, ##34804
	wrlong	result1, objptr
	sub	objptr, ##34804
	mov	result1, objptr
	bith	result1, #149
	add	objptr, ##34808
	wrlong	result1, objptr
	sub	objptr, ##34808
	mov	result1, objptr
	bith	result1, #180
	add	objptr, ##34812
	wrlong	result1, objptr
	sub	objptr, ##34812
	mov	result1, objptr
	bith	result1, #26
	add	objptr, ##34828
	wrlong	result1, objptr
	sub	objptr, ##34828
	mov	result1, objptr
	or	result1, ##68157440
	add	objptr, ##34824
	wrlong	result1, objptr
	sub	objptr, ##34824
	mov	result1, objptr
	or	result1, ##69206016
	add	objptr, ##34840
	wrlong	result1, objptr
	sub	objptr, ##34840
	mov	result1, objptr
	or	result1, ##70254592
	add	objptr, ##34836
	wrlong	result1, objptr
	sub	objptr, ##34836
	mov	result1, objptr
	or	result1, ##71303168
	add	objptr, ##34832
	wrlong	result1, objptr
	sub	objptr, ##34832
	mov	result1, objptr
	or	result1, ##72351744
	add	objptr, ##34844
	wrlong	result1, objptr
	sub	objptr, ##34844
	mov	result1, objptr
	or	result1, ##73400320
	add	objptr, ##34848
	wrlong	result1, objptr
	sub	objptr, ##34848
	mov	result1, objptr
	or	result1, ##74448896
	add	objptr, ##34484
	wrlong	result1, objptr
	sub	objptr, ##34484
	mov	result1, objptr
	or	result1, ##75497472
	add	objptr, ##34872
	wrlong	result1, objptr
	sub	objptr, ##34872
	mov	result1, objptr
	or	result1, ##76546048
	add	objptr, ##34888
	wrlong	result1, objptr
	sub	objptr, ##34888
	mov	result1, objptr
	or	result1, ##77594624
	add	objptr, ##34892
	wrlong	result1, objptr
	sub	objptr, ##34892
	mov	result1, objptr
	or	result1, ##78643200
	add	objptr, ##34884
	wrlong	result1, objptr
	sub	objptr, ##34884
	mov	result1, objptr
	or	result1, ##79691776
	add	objptr, ##34876
	wrlong	result1, objptr
	sub	objptr, ##34876
	mov	result1, objptr
	or	result1, ##80740352
	add	objptr, ##34880
	wrlong	result1, objptr
	sub	objptr, ##34880
	mov	result1, objptr
	or	result1, ##81788928
	add	objptr, ##34896
	wrlong	result1, objptr
	sub	objptr, ##34896
	mov	result1, objptr
	or	result1, ##82837504
	add	objptr, ##34900
	wrlong	result1, objptr
	sub	objptr, ##34900
	mov	result1, objptr
	or	result1, ##83886080
	add	objptr, ##34904
	wrlong	result1, objptr
	sub	objptr, ##34904
	mov	result1, objptr
	or	result1, ##84934656
	add	objptr, ##34908
	wrlong	result1, objptr
	sub	objptr, ##34908
	mov	result1, objptr
	or	result1, ##85983232
	add	objptr, ##34912
	wrlong	result1, objptr
	sub	objptr, ##34912
	mov	result1, objptr
	or	result1, ##87031808
	add	objptr, ##34916
	wrlong	result1, objptr
	sub	objptr, ##34916
	mov	result1, objptr
	or	result1, ##88080384
	add	objptr, ##34920
	wrlong	result1, objptr
	sub	objptr, ##34920
	mov	result1, objptr
	or	result1, ##89128960
	add	objptr, ##34924
	wrlong	result1, objptr
	sub	objptr, ##34924
	mov	result1, objptr
	or	result1, ##90177536
	add	objptr, ##34936
	wrlong	result1, objptr
	sub	objptr, ##34936
	mov	result1, objptr
	or	result1, ##91226112
	add	objptr, ##34928
	wrlong	result1, objptr
	sub	objptr, ##34928
	mov	result1, objptr
	or	result1, ##92274688
	add	objptr, ##34932
	wrlong	result1, objptr
	sub	objptr, ##34932
	mov	result1, objptr
	or	result1, ##93323264
	add	objptr, ##34940
	wrlong	result1, objptr
	sub	objptr, ##34940
	mov	result1, objptr
	or	result1, ##94371840
	add	objptr, ##34852
	wrlong	result1, objptr
	sub	objptr, ##34852
	mov	result1, objptr
	or	result1, ##95420416
	add	objptr, ##34860
	wrlong	result1, objptr
	sub	objptr, ##34860
	mov	result1, objptr
	or	result1, ##96468992
	add	objptr, ##34864
	wrlong	result1, objptr
	sub	objptr, ##34864
	mov	result1, objptr
	or	result1, ##97517568
	add	objptr, ##34944
	wrlong	result1, objptr
	sub	objptr, ##34944
	mov	result1, objptr
	or	result1, ##98566144
	add	objptr, ##34948
	wrlong	result1, objptr
	sub	objptr, ##34948
	mov	result1, objptr
	or	result1, ##99614720
	add	objptr, ##34952
	wrlong	result1, objptr
	sub	objptr, ##34952
	mov	result1, objptr
	bith	result1, #57
	add	objptr, ##34868
	wrlong	result1, objptr
	sub	objptr, ##34868
	mov	result1, objptr
	or	result1, ##101711872
	add	objptr, ##34968
	wrlong	result1, objptr
	sub	objptr, ##34968
	mov	result1, objptr
	or	result1, ##102760448
	add	objptr, ##34976
	wrlong	result1, objptr
	sub	objptr, ##34976
	mov	result1, objptr
	or	result1, ##103809024
	add	objptr, ##34964
	wrlong	result1, objptr
	sub	objptr, ##34964
	mov	result1, objptr
	or	result1, ##104857600
	add	objptr, ##34960
	wrlong	result1, objptr
	sub	objptr, ##34960
	mov	result1, objptr
	or	result1, ##105906176
	add	objptr, ##34956
	wrlong	result1, objptr
	sub	objptr, ##34956
	mov	result1, objptr
	or	result1, ##106954752
	add	objptr, ##34972
	wrlong	result1, objptr
	sub	objptr, ##34972
	mov	result1, objptr
	or	result1, ##108003328
	add	objptr, ##34980
	wrlong	result1, objptr
	sub	objptr, ##34980
	mov	result1, objptr
	or	result1, ##109051904
	add	objptr, ##34984
	wrlong	result1, objptr
	sub	objptr, ##34984
	mov	result1, objptr
	or	result1, ##110100480
	add	objptr, ##34988
	wrlong	result1, objptr
	sub	objptr, ##34988
	mov	result1, objptr
	or	result1, ##111149056
	add	objptr, ##34996
	wrlong	result1, objptr
	sub	objptr, ##34996
	mov	result1, objptr
	or	result1, ##112197632
	add	objptr, ##35000
	wrlong	result1, objptr
	sub	objptr, ##35000
	mov	result1, objptr
	or	result1, ##113246208
	add	objptr, ##35004
	wrlong	result1, objptr
	sub	objptr, ##35004
	mov	result1, objptr
	or	result1, ##114294784
	add	objptr, ##35008
	wrlong	result1, objptr
	sub	objptr, ##35008
	mov	result1, objptr
	or	result1, ##115343360
	add	objptr, ##35012
	wrlong	result1, objptr
	sub	objptr, ##35012
	mov	result1, objptr
	or	result1, ##116391936
	add	objptr, ##35016
	wrlong	result1, objptr
	sub	objptr, ##35016
	mov	result1, objptr
	or	result1, ##34603008
	add	objptr, ##35020
	wrlong	result1, objptr
	sub	objptr, ##35020
	mov	result1, objptr
	bith	result1, #88
	add	objptr, ##35024
	wrlong	result1, objptr
	sub	objptr, ##35024
	mov	result1, objptr
	or	result1, ##118489088
	add	objptr, ##34992
	wrlong	result1, objptr
	sub	objptr, ##34992
	mov	result1, objptr
	or	result1, ##119537664
	add	objptr, ##34472
	wrlong	result1, objptr
	sub	objptr, ##34472
	mov	result1, objptr
	or	result1, ##120586240
	add	objptr, ##35028
	wrlong	result1, objptr
	sub	objptr, ##35028
	mov	result1, objptr
	or	result1, ##121634816
	add	objptr, ##35032
	wrlong	result1, objptr
	sub	objptr, ##35032
	mov	result1, objptr
	or	result1, ##122683392
	add	objptr, ##35052
	wrlong	result1, objptr
	sub	objptr, ##35052
	mov	result1, objptr
	or	result1, ##123731968
	add	objptr, ##35048
	wrlong	result1, objptr
	sub	objptr, ##35048
	mov	result1, objptr
	or	result1, ##124780544
	add	objptr, ##35040
	wrlong	result1, objptr
	sub	objptr, ##35040
	mov	result1, objptr
	bith	result1, #119
	add	objptr, ##35036
	wrlong	result1, objptr
	sub	objptr, ##35036
	mov	result1, objptr
	or	result1, ##126877696
	add	objptr, ##35068
	wrlong	result1, objptr
	sub	objptr, ##35068
	mov	result1, objptr
	or	result1, ##127926272
	add	objptr, ##35056
	wrlong	result1, objptr
	sub	objptr, ##35056
	mov	result1, objptr
	or	result1, ##128974848
	add	objptr, ##35060
	wrlong	result1, objptr
	sub	objptr, ##35060
	mov	result1, objptr
	bith	result1, #150
	add	objptr, ##35064
	wrlong	result1, objptr
	sub	objptr, ##35064
	mov	result1, objptr
	or	result1, ##131072000
	add	objptr, ##35072
	wrlong	result1, objptr
	sub	objptr, ##35072
	mov	result1, objptr
	bith	result1, #181
	add	objptr, ##35076
	wrlong	result1, objptr
	sub	objptr, ##35076
	mov	result1, objptr
	bith	result1, #212
	add	objptr, ##35080
	wrlong	result1, objptr
	sub	objptr, ##35080
	mov	result1, objptr
	bith	result1, #27
	add	objptr, ##35084
	wrlong	result1, objptr
	sub	objptr, ##35084
	mov	result1, objptr
	or	result1, ##135266304
	add	objptr, ##35088
	wrlong	result1, objptr
	sub	objptr, ##35088
	mov	result1, objptr
	or	result1, ##136314880
	add	objptr, ##35092
	wrlong	result1, objptr
	sub	objptr, ##35092
	mov	result1, objptr
	or	result1, ##137363456
	add	objptr, ##35100
	wrlong	result1, objptr
	sub	objptr, ##35100
	mov	result1, objptr
	or	result1, ##138412032
	add	objptr, ##35104
	wrlong	result1, objptr
	sub	objptr, ##35104
	mov	result1, objptr
	or	result1, ##139460608
	add	objptr, ##35108
	wrlong	result1, objptr
	sub	objptr, ##35108
	mov	result1, objptr
	or	result1, ##140509184
	add	objptr, ##35096
	wrlong	result1, objptr
	sub	objptr, ##35096
	mov	result1, objptr
	or	result1, ##141557760
	add	objptr, ##35112
	wrlong	result1, objptr
	sub	objptr, ##35112
	mov	result1, objptr
	or	result1, ##142606336
	add	objptr, ##35164
	wrlong	result1, objptr
	sub	objptr, ##35164
	mov	result1, objptr
	or	result1, ##143654912
	add	objptr, ##35156
	wrlong	result1, objptr
	sub	objptr, ##35156
	mov	result1, objptr
	or	result1, ##144703488
	add	objptr, ##35116
	wrlong	result1, objptr
	sub	objptr, ##35116
	mov	result1, objptr
	or	result1, ##145752064
	add	objptr, ##35120
	wrlong	result1, objptr
	sub	objptr, ##35120
	mov	result1, objptr
	or	result1, ##146800640
	add	objptr, ##35148
	wrlong	result1, objptr
	sub	objptr, ##35148
	mov	result1, objptr
	or	result1, ##147849216
	add	objptr, ##35152
	wrlong	result1, objptr
	sub	objptr, ##35152
	mov	result1, objptr
	or	result1, ##148897792
	add	objptr, ##35180
	wrlong	result1, objptr
	sub	objptr, ##35180
	mov	result1, objptr
	or	result1, ##149946368
	add	objptr, ##35176
	wrlong	result1, objptr
	sub	objptr, ##35176
	mov	result1, objptr
	or	result1, ##150994944
	add	objptr, ##35192
	wrlong	result1, objptr
	sub	objptr, ##35192
	mov	result1, objptr
	or	result1, ##152043520
	add	objptr, ##35140
	wrlong	result1, objptr
	sub	objptr, ##35140
	mov	result1, objptr
	or	result1, ##153092096
	add	objptr, ##35188
	wrlong	result1, objptr
	sub	objptr, ##35188
	mov	result1, objptr
	or	result1, ##154140672
	add	objptr, ##35172
	wrlong	result1, objptr
	sub	objptr, ##35172
	mov	result1, objptr
	or	result1, ##155189248
	add	objptr, ##34580
	wrlong	result1, objptr
	sub	objptr, ##34580
	mov	result1, objptr
	or	result1, ##156237824
	add	objptr, ##35124
	wrlong	result1, objptr
	sub	objptr, ##35124
_init_commands_ret
	ret

' 
' ''-------------------------------- Audio subsystem init  -------------------------------------
' 
' sub init_audio
_init_audio
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, ##1065353216
' 
' for i=0 to 1023 : psdpoke       2*i,round(32600*sin(i*3.1415926535/512.0)) : next i               		' 0 : sinewave  
	mov	local02, #0
LR__2400
	mov	local03, local02
	shl	local03, #1
	mov	local04, ##1191096320
	abs	arg01, local02 wc
 if_b	decod	local05, #31
 if_ae	mov	local05, #0
	call	#__system___float_fromuns
	xor	result1, local05
	mov	arg01, result1
	mov	arg02, ##1078530011
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, ##1140850688
	call	#__system___float_div
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local04
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	mov	arg02, result1
	mov	arg01, local03
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__2400
' for i=0 to 511  : psdpoke  2048+2*i, -32512+127*i: psdpoke 2048+2*(512+i),32512-127*i : next i   		' 1 : triangle 
	mov	local02, #0
LR__2401
	mov	arg02, local02
	shl	arg02, #1
	decod	arg01, #11
	add	arg01, arg02
	mov	local04, local02
	shl	local04, #7
	sub	local04, local02
	mov	arg02, ##-32512
	add	arg02, local04
	call	#_psdpoke
	decod	local04, #9
	add	local04, local02
	shl	local04, #1
	decod	arg01, #11
	add	arg01, local04
	mov	local05, local02
	shl	local05, #7
	sub	local05, local02
	mov	arg02, ##32512
	sub	arg02, local05
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##512 wc
 if_b	jmp	#LR__2401
' for i=0 to 1023 : psdpoke  4096+2*i, -32256+63*i : next i 							' 2 saw 4 sqr 8 noise 3567 
	mov	local02, #0
LR__2402
	mov	local05, local02
	shl	local05, #1
	decod	arg01, #12
	add	arg01, local05
	mov	local05, local02
	shl	local05, #6
	sub	local05, local02
	mov	arg02, ##-32256
	add	arg02, local05
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__2402
' for i=0 to 127  : psdpoke  6144+2*i, -32600 : next i : for i=128 to 1023 :  psdpoke 6144+2*i, 32600 : next i 	' 3 pulse 12.5%
	mov	local02, #0
LR__2403
	mov	local05, local02
	shl	local05, #1
	mov	arg01, ##6144
	add	arg01, local05
	mov	arg02, ##-32600
	call	#_psdpoke
	add	local02, #1
	cmps	local02, #128 wc
 if_b	jmp	#LR__2403
	mov	local02, #128
LR__2404
	mov	local05, local02
	shl	local05, #1
	mov	arg01, ##6144
	add	arg01, local05
	mov	arg02, ##32600
	call	#_psdpoke
	add	local02, #1
	cmp	local02, ##1024 wc
 if_b	jmp	#LR__2404
' for i=0 to 511  : psdpoke  8192+2*i, -32600 : next i : for i=512 to 1023 :  psdpoke 8192+2*i, 32600 : next i 	' 4 square
	mov	local02, #0
LR__2405
	mov	local05, local02
	shl	local05, #1
	decod	arg01, #13
	add	arg01, local05
	mov	arg02, ##-32600
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##512 wc
 if_b	jmp	#LR__2405
	decod	local02, #9
LR__2406
	mov	local05, local02
	shl	local05, #1
	decod	arg01, #13
	add	arg01, local05
	mov	arg02, ##32600
	call	#_psdpoke
	add	local02, #1
	cmp	local02, ##1024 wc
 if_b	jmp	#LR__2406
' for i=0 to 255  : psdpoke 10240+2*i, -32600 : next i : for i=256 to 1023 : psdpoke 10240+2*i, 32600 : next i 	' 5 pulse 25%
	mov	local02, #0
LR__2407
	mov	local05, local02
	shl	local05, #1
	mov	arg01, ##10240
	add	arg01, local05
	mov	arg02, ##-32600
	call	#_psdpoke
	add	local02, #1
	cmps	local02, #256 wc
 if_b	jmp	#LR__2407
	mov	local02, #256
LR__2408
	mov	local05, local02
	shl	local05, #1
	mov	arg01, ##10240
	add	arg01, local05
	mov	arg02, ##32600
	call	#_psdpoke
	add	local02, #1
	cmp	local02, ##1024 wc
 if_b	jmp	#LR__2408
' for i=12288 to 61436 step 4 : pslpoke i,0 : next i 
	mov	local02, ##12288
LR__2409
	mov	arg01, local02
	mov	arg02, #0
	call	#_pslpoke
	add	local02, #4
	cmps	local02, ##61437 wc
 if_b	jmp	#LR__2409
' for i=0 to 1023 : psdpoke 61440+2*i, dpeek(varptr(atari12)+16+2*i) : next i 				' 6 pokey waveform 12	
	mov	local02, #0
LR__2410
	mov	local05, local02
	shl	local05, #1
	mov	local03, ##61440
	add	local03, local05
	add	ptr__dat__, ##9402
	mov	arg01, ptr__dat__
	sub	ptr__dat__, ##9402
	add	arg01, #16
	mov	arg02, local02
	shl	arg02, #1
	add	arg01, arg02
	rdword	arg02, arg01
	mov	arg01, local03
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__2410
' for i=0 to 1023 : psdpoke 63488+2*i, dpeek(varptr(atari2)+16+2*i) : next i 				' 7 pokey waveform 2	
	mov	local02, #0
LR__2411
	mov	local05, local02
	shl	local05, #1
	mov	local03, ##63488
	add	local03, local05
	add	ptr__dat__, ##7338
	mov	arg01, ptr__dat__
	sub	ptr__dat__, ##7338
	add	arg01, #16
	mov	arg02, local02
	shl	arg02, #1
	add	arg01, arg02
	rdword	arg02, arg01
	mov	arg01, local03
	call	#_psdpoke
	add	local02, #1
	cmps	local02, ##1024 wc
 if_b	jmp	#LR__2411
' for i=0 to 255 : envbuf(0,i)=65280-256*i : next i							' instant attack, linear release	
	mov	local02, #0
	add	objptr, ##6360
	callpa	#(@LR__2413-@LR__2412)>>2,fcache_load_ptr_
LR__2412
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local03, local02
	shl	local03, #8
	mov	local06, ##65280
	sub	local06, local03
	wrword	local06, local05
	add	local02, #1
	cmps	local02, #256 wc
 if_b	jmp	#LR__2412
LR__2413
	sub	objptr, ##6360
' for i=0 to 255 : envbuf(1,i)=round(65280.0*k) : k=k*0.975 :  next i : envbuf(1,255)=0			' instant attack, log release
	mov	local02, #0
LR__2414
	mov	local05, local02
	shl	local05, #1
	add	objptr, ##6872
	add	local05, objptr
	mov	arg01, ##1199505408
	mov	arg02, local01
	sub	objptr, ##6872
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #1
	call	#__system___float_tointeger
	wrword	result1, local05
	mov	arg01, local01
	mov	arg02, ##1064933786
	call	#__system___float_mul
	mov	local01, result1
	add	local02, #1
	cmps	local02, #256 wc
 if_b	jmp	#LR__2414
	add	objptr, ##7382
	wrword	#0, objptr
' for i=0 to 254 : envbuf(2,i)=65280 : next i : envbuf(2,255)=0						' instant attack, instant release
	mov	local02, #0
	add	objptr, #2
	callpa	#(@LR__2416-@LR__2415)>>2,fcache_load_ptr_
LR__2415
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	wrword	##65280, local05
	add	local02, #1
	cmps	local02, #255 wc
 if_b	jmp	#LR__2415
LR__2416
	add	objptr, #510
	wrword	#0, objptr
' for i=0 to 15 :  envbuf(3,i)=4096*i : next i 
	mov	local02, #0
	add	objptr, #2
	callpa	#(@LR__2421-@LR__2417)>>2,fcache_load_ptr_
LR__2417
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local06, local02
	shl	local06, #12
	wrword	local06, local05
	add	local02, #1
	cmps	local02, #16 wc
 if_b	jmp	#LR__2417
' for i=16 to 239: envbuf(3,i)=65280 : next i
	mov	local02, #16
LR__2418
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	wrword	##65280, local05
	add	local02, #1
	cmp	local02, #240 wc
 if_b	jmp	#LR__2418
' for i=240 to 255 : envbuf(3,i)=4096*(255-i) : next i							' smooth attack, smooth release
	mov	local02, #240
LR__2419
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local03, #255
	sub	local03, local02
	shl	local03, #12
	wrword	local03, local05
	add	local02, #1
	cmp	local02, #256 wc
 if_b	jmp	#LR__2419
' for i=0 to 255 : envbuf(4,i)=256*i : next i : envbuf(4,255)=0						' slow attack, instant release
	mov	local02, #0
	add	objptr, ##512
LR__2420
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local06, local02
	shl	local06, #8
	wrword	local06, local05
	add	local02, #1
	cmps	local02, #256 wc
 if_b	jmp	#LR__2420
LR__2421
	add	objptr, #510
	wrword	#0, objptr
' for i=0 to 239 : envbuf(5,i)=272*i : next i : for i=240 to 255 : envbuf(5,i)=4096*(255-i) : next i	' slow attack, smooth release
	mov	local02, #0
	add	objptr, #2
	callpa	#(@LR__2426-@LR__2422)>>2,fcache_load_ptr_
LR__2422
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local06, local02
	shl	local06, #4
	add	local06, local02
	shl	local06, #4
	wrword	local06, local05
	add	local02, #1
	cmps	local02, #240 wc
 if_b	jmp	#LR__2422
	mov	local02, #240
LR__2423
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local03, #255
	sub	local03, local02
	shl	local03, #12
	wrword	local03, local05
	add	local02, #1
	cmp	local02, #256 wc
 if_b	jmp	#LR__2423
' for i=0 to 127 : envbuf(6,i)=512*i : envbuf(6,255-i)=512*i : next i 					' triangle
	mov	local02, #0
	add	objptr, ##512
LR__2424
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local06, local02
	shl	local06, #9
	wrword	local06, local05
	mov	local05, #255
	sub	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local06, local02
	shl	local06, #9
	wrword	local06, local05
	add	local02, #1
	cmps	local02, #128 wc
 if_b	jmp	#LR__2424
' for i=0 to 7: envbuf(7,i)=8192*i : next i
	mov	local02, #0
	add	objptr, ##512
LR__2425
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local06, local02
	shl	local06, #13
	wrword	local06, local05
	add	local02, #1
	cmps	local02, #8 wc
 if_b	jmp	#LR__2425
LR__2426
' for i=8 to 23 : envbuf(7,i)=65280-2048*(i-8) : next i 	
	mov	local02, #8
	callpa	#(@LR__2430-@LR__2427)>>2,fcache_load_ptr_
LR__2427
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local01, local02
	sub	local01, #8
	shl	local01, #11
	mov	local06, ##65280
	sub	local06, local01
	wrword	local06, local05
	add	local02, #1
	cmp	local02, #24 wc
 if_b	jmp	#LR__2427
' for i=24 to 128 : envbuf(7,i)=32768 : next i
	mov	local02, #24
LR__2428
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	wrword	##32768, local05
	add	local02, #1
	cmp	local02, #129 wc
 if_b	jmp	#LR__2428
' for i=129 to 255: envbuf(7,i)=256*(255-i) : next i : suspoints(7)=128							' classic adsr
	mov	local02, #129
LR__2429
	mov	local05, local02
	shl	local05, #1
	add	local05, objptr
	mov	local03, #255
	sub	local03, local02
	shl	local03, #8
	wrword	local03, local05
	add	local02, #1
	cmp	local02, #256 wc
 if_b	jmp	#LR__2429
LR__2430
	add	objptr, ##31998
	wrword	#128, objptr
	sub	objptr, ##41942
' for i=0 to 7
	mov	local02, #0
	callpa	#(@LR__2432-@LR__2431)>>2,fcache_load_ptr_
LR__2431
	mov	local05, local02
	shl	local05, #1
	add	local05, local02
	shl	local05, #3
	add	objptr, ##10552
	add	local05, objptr
	wrlong	##1138491392, local05
	mov	local05, local02
	shl	local05, #1
	add	local05, local02
	shl	local05, #3
	add	local05, objptr
	add	local05, #4
	wrbyte	local02, local05
	mov	local05, local02
	shl	local05, #1
	add	local05, local02
	shl	local05, #3
	add	local05, objptr
	add	local05, #5
	wrbyte	local02, local05
	mov	local05, local02
	shl	local05, #1
	add	local05, local02
	shl	local05, #3
	add	local05, objptr
	add	local05, #6
	wrword	#0, local05
	mov	local05, local02
	shl	local05, #1
	add	local05, local02
	shl	local05, #3
	add	local05, objptr
	add	local05, #8
	wrlong	##1065353216, local05
	mov	local05, local02
	shl	local05, #1
	add	local05, local02
	shl	local05, #3
	add	local05, objptr
	add	local05, #12
	wrlong	##1082130432, local05
	mov	local05, local02
	shl	local05, #1
	add	local05, local02
	shl	local05, #3
	add	local05, objptr
	add	local05, #16
	wrlong	#0, local05
	mov	local05, local02
	shl	local05, #1
	add	local05, local02
	shl	local05, #3
	add	local05, objptr
	add	local05, #20
	wrword	#255, local05
	mov	local05, local02
	shl	local05, #1
	add	objptr, ##31376
	add	local05, objptr
	wrword	#255, local05
	add	local02, #1
	cmps	local02, #8 wc
	sub	objptr, ##41928
 if_b	jmp	#LR__2431
LR__2432
	mov	local06, ##1088159744
' a=6.875 : for i=1 to 3 : a=a*(2.0^(1.0/12.0)) : next i : for i=0 to 11 : notetable(i) = a : a=a*(2.0^(1.0/12.0)) : next i
	mov	local05, #3
LR__2433
	mov	arg01, local06
	mov	arg02, ##1065852029
	call	#__system___float_mul
	mov	local06, result1
	djnz	local05, #LR__2433
	mov	local02, #0
LR__2434
	mov	local04, local02
	shl	local04, #2
	add	objptr, ##10456
	add	local04, objptr
	wrlong	local06, local04
	mov	arg01, local06
	mov	arg02, ##1065852029
	sub	objptr, ##10456
	call	#__system___float_mul
	mov	local06, result1
	add	local02, #1
	cmps	local02, #12 wc
 if_b	jmp	#LR__2434
	add	objptr, ##10504
	wrlong	#424, objptr
	add	objptr, #4
	wrlong	#400, objptr
	add	objptr, #4
	wrlong	#377, objptr
	add	objptr, #4
	wrlong	#356, objptr
	add	objptr, #4
	wrlong	#336, objptr
	add	objptr, #4
	wrlong	#317, objptr
	add	objptr, #4
	wrlong	#300, objptr
	add	objptr, #4
	wrlong	#283, objptr
	add	objptr, #4
	wrlong	#267, objptr
	add	objptr, #4
	wrlong	#252, objptr
	add	objptr, #4
	wrlong	#238, objptr
	add	objptr, #4
	wrlong	#224, objptr
	add	objptr, ##31394
	wrword	#128, objptr
	sub	objptr, #2
	wrword	#128, objptr
	sub	objptr, ##41940
	mov	ptra, fp
	call	#popregs_
_init_audio_ret
	ret

' 
' '------------------- Error messages
' 
' sub init_error_strings
_init_error_strings
	mov	_var01, ##@LR__5716
	add	objptr, ##35452
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5717
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5718
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5719
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5720
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5721
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5722
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5723
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5724
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5725
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5726
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5727
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5728
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5729
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5730
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5731
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5732
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5733
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5734
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5735
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5736
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5737
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5738
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5739
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5740
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5741
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5742
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5743
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5744
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5745
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5746
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5747
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5748
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5749
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5750
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5751
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5752
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5753
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5754
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5755
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5756
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5757
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5758
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5759
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5760
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5761
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5762
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5763
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5764
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5765
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5766
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5767
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5768
	add	objptr, #4
	wrlong	_var01, objptr
	mov	_var01, ##@LR__5769
	add	objptr, #4
	wrlong	_var01, objptr
	sub	objptr, ##35664
_init_error_strings_ret
	ret

'         
' sub printerror(err as integer, linenum=0 as integer)
_printerror
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, ##@LR__5770
	call	#_hg010b_spin2_write
	mov	arg01, local01
	call	#_hg010b_spin2_inttostr
	mov	arg01, result1
	call	#_hg010b_spin2_write
	mov	arg01, ##@LR__5771
	call	#_hg010b_spin2_write
	shl	local01, #2
	add	objptr, ##35452
	add	local01, objptr
	rdlong	arg01, local01
	sub	objptr, ##35452
	call	#_hg010b_spin2_write
' v.write("Error " ): v.write(v.inttostr(err)) : v.write(" - ")  : v.write(errors$(err))
' if linenum>0 then v.write(" in line " ): v.writeln(v.inttostr(linenum))
	cmps	local02, #1 wc
 if_b	jmp	#LR__2440
	mov	arg01, ##@LR__5772
	call	#_hg010b_spin2_write
	mov	arg01, local02
	call	#_hg010b_spin2_inttostr
	mov	arg01, result1
' 
' write(text)
	call	#_hg010b_spin2_write
' crlf
	call	#_hg010b_spin2_crlf
LR__2440
	mov	ptra, fp
	call	#popregs_
_printerror_ret
	ret

' 
' '' ------------------------------- Hardware start/stop/initialization 
' 
' sub startpsram
_startpsram
	mov	arg01, #0
	decod	arg02, #10
	mov	arg03, #11
	mov	arg04, #7
	add	objptr, ##5836
	call	#_psram_spin2_startx
	add	objptr, ##22332
	wrlong	result1, objptr
'     return $7FF00 + cog*12
	add	objptr, #12
	wrlong	##524032, objptr
	sub	objptr, ##28180
_startpsram_ret
	ret

' 
' function startvideo(mode=64, pin=0, mb=0) 'todo return a cog#
_startvideo
	mov	COUNT_, #1
	call	#pushregs_
	add	objptr, ##28180
	rdlong	arg04, objptr
	sub	objptr, ##28180
	mov	arg01, arg02
	mov	arg02, arg04
	call	#_hg010b_spin2_start
	add	objptr, ##28160
	wrlong	result1, objptr
' 
' videocog=v.start(pin,mbox)
' for thecog=0 to 7:psram.setQos(thecog, 80 << 16) :next thecog
	mov	local01, #0
	sub	objptr, ##22324
LR__2450
	mov	arg01, local01
	mov	arg02, ##5242880
	call	#_psram_spin2_setQos
	add	local01, #1
	cmps	local01, #8 wc
 if_b	jmp	#LR__2450
	add	objptr, ##22324
	rdlong	arg01, objptr
	mov	arg02, ##67171328
	sub	objptr, ##22324
	call	#_psram_spin2_setQos
	sub	objptr, ##5836
' psram.setQoS(videocog, $0400f400) 
' open SendRecvDevice(@v.putchar, nil, nil) as #0
	mov	arg02, objptr
	or	arg02, ##157286400
	mov	arg03, #0
	mov	arg04, #0
	mov	arg01, #0
	call	#__system___basic_open
' return videocog
	add	objptr, ##28160
	rdlong	result1, objptr
	sub	objptr, ##28160
	mov	ptra, fp
	call	#popregs_
_startvideo_ret
	ret

' 
' 
' 
' '' ------------------------------- Convenient psram peek/poke
' 
' sub pslpoke(addr as ulong,value as ulong)
_pslpoke
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	mov	arg03, #4
	add	objptr, ##5836
	call	#_psram_spin2_write
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_pslpoke_ret
	ret

' 
' sub psdpoke(addr as ulong,value as ulong)
_psdpoke
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	mov	arg03, #2
	add	objptr, ##5836
	call	#_psram_spin2_write
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_psdpoke_ret
	ret

' 
' sub pspoke(addr as ulong,value as ulong)
_pspoke
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	mov	arg03, #1
	add	objptr, ##5836
	call	#_psram_spin2_write
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_pspoke_ret
	ret

' 
' function pspeek(adr as ulong) as ubyte
_pspeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #1
	add	objptr, ##5836
	call	#_psram_spin2_read1
	sub	objptr, ##5836
' psram.read1(varptr(res),adr,1)
' return res
	add	fp, #8
	rdbyte	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_pspeek_ret
	ret

' 
' function pslpeek(adr as ulong) as ulong
_pslpeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #4
	add	objptr, ##5836
	call	#_psram_spin2_read1
	sub	objptr, ##5836
' psram.read1(varptr(res),adr,4)
' return res
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_pslpeek_ret
	ret

' 
' function psdpeek(adr as ulong) as ulong
_psdpeek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg01, fp
	sub	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #2
	add	objptr, ##5836
	call	#_psram_spin2_read1
	sub	objptr, ##5836
' psram.read1(varptr(res),adr,2)
' return res
	add	fp, #8
	rdword	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_psdpeek_ret
	ret

' 
' '' ------------------------------- USB keyboard scan to char translator
' 
' function scantochar(key)
_scantochar
' 
' select case (key shr 8) and 255
	mov	_var01, arg01
	sar	_var01, #8
	and	_var01, #255 wz
 if_e	jmp	#LR__2460
	cmp	_var01, #2 wz
 if_ne	cmp	_var01, #32 wz
 if_e	jmp	#LR__2461
	cmp	_var01, #64 wz
 if_e	jmp	#LR__2462
	cmp	_var01, #66 wz
 if_ne	cmp	_var01, #96 wz
 if_ne	jmp	#LR__2464
	jmp	#LR__2463
LR__2460
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__2461
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #1
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__2462
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #2
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__2463
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #3
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__2464
_scantochar_ret
	ret

_program
	mov	COUNT_, #1
	call	#pushregs_
	call	#_startpsram
	mov	arg01, #64
	mov	arg02, #0
	mov	arg03, #0
	call	#_startvideo
	add	objptr, ##28180
	rdlong	arg01, objptr
	mov	arg02, #0
	mov	arg03, ##521984
	sub	objptr, ##22344
	call	#_audio096_spin2_start
	mov	arg03, result2
	add	objptr, ##22320
	wrlong	result1, objptr
	add	objptr, #20
	wrlong	arg03, objptr
	sub	objptr, ##28176
	mov	arg01, #50
	call	#__system___waitms
	add	objptr, ##28176
	rdlong	arg01, objptr
	sub	objptr, ##28176
	add	arg01, #20
	wrword	##16384, arg01
	call	#_usbnew_spin2_start
	add	objptr, ##28164
	wrlong	result1, objptr
'   mouse_limits[0] := xlim
	add	ptr__usbnew_spin2_dat__, ##7868
	wrlong	##1023, ptr__usbnew_spin2_dat__
'   mouse_limits[1] := ylim
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	##599, ptr__usbnew_spin2_dat__
	sub	objptr, ##27891
	mov	arg01, objptr
	sub	objptr, #273
	add	arg01, #196
'   mouse_outptr := ptr
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	arg01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7876
	add	ptr__dat__, ##11466
	mov	arg02, ptr__dat__
	sub	ptr__dat__, ##11466
	mov	arg01, #16
	call	#_hg010b_spin2_setspriteptr
	mov	arg01, #16
	mov	arg02, #32
	mov	arg03, #32
	call	#_hg010b_spin2_setspritesize
	decod	arg01, #9
	mov	arg02, #300
	call	#_usbnew_spin2_mouse_move
	mov	arg03, objptr
	add	objptr, ##41244
	mov	arg02, objptr
	wrlong	arg03, arg02
	add	arg02, #4
	wrlong	ptr__housekeeper_, arg02
	mov	arg02, entryptr__
	mov	result1, #30
	setq	objptr
	coginit	result1, arg02 wc
 if_b	neg	result1, #1
	sub	objptr, #4
	wrlong	result1, objptr
	add	objptr, ##656
	wrlong	#0, objptr
	sub	objptr, ##13684
	wrlong	#2, objptr
	add	objptr, #4
	wrlong	#147, objptr
	add	objptr, #4
	wrlong	#154, objptr
	add	objptr, #4
	wrlong	#4, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	objptr, #20
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	#0, objptr
	add	objptr, #4
	wrlong	#0, objptr
	add	objptr, ##13028
	wrlong	#1, objptr
	add	objptr, ##668
	wrlong	#0, objptr
	add	ptr__dat__, ##512
	add	objptr, #8
	wrlong	ptr__dat__, objptr
	sub	objptr, #4
	wrlong	##1694, objptr
	sub	objptr, ##6480
	wrlong	#12, objptr
	sub	objptr, ##35428
	sub	ptr__dat__, ##512
	call	#_init_commands
	call	#_init_error_strings
	call	#_init_audio
	call	#_do_new
	add	objptr, ##28220
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##28216
	call	#_hg010b_spin2_cls
	add	objptr, ##28224
	rdlong	arg01, objptr
	sub	objptr, ##28224
	call	#_hg010b_spin2_setfontfamily
' 
' leading_spaces:=amount
	add	objptr, ##694
	wrlong	#2, objptr
	sub	objptr, ##694
	mov	local01, ##@LR__5773
	mov	arg01, #61
	mov	arg02, #60
	mov	arg03, #59
	mov	arg04, #58
	call	#__system___vfs_open_sdcardx
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___mount
	mov	arg01, ##@LR__5774
	call	#__system___chdir
	mov	local01, ##@LR__5775
	add	objptr, ##38036
	wrlong	local01, objptr
	sub	objptr, ##9824
	rdlong	arg01, objptr
	sub	objptr, ##28212
	shl	arg01, #1
	mov	arg02, #1
	call	#_hg010b_spin2_setcursorpos
' init_commands
' init_error_strings
' init_audio
' do_new
' cls(ink, paper)
' v.setfontfamily(font) 				' use ST Mono font
' v.setleadingspaces(2)
' mount "/sd", _vfs_open_sdcard()
' chdir "/sd/bas"
' currentdir$="/sd/bas"
' position 2*editor_spaces,1 : print ver$
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	add	ptr__dat__, ##12608
	rdlong	arg02, ptr__dat__
	sub	ptr__dat__, ##12608
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	objptr, ##41900
	rdlong	arg01, objptr
	sub	objptr, ##7504
	rdlong	local01, objptr
	sub	objptr, ##34396
	sub	arg01, local01
	mov	arg02, #0
	mov	arg03, #10
	call	#__system__Number_S
	mov	arg01, result1
	mov	arg02, ##@LR__5776
	call	#__system___string_concat
	mov	local01, result1
	add	objptr, ##41232
	wrlong	local01, objptr
	sub	objptr, ##41232
' free$=decuns$(memtop-programptr)+" BASIC bytes free" : print free$
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	add	objptr, ##41232
	rdlong	arg02, objptr
	sub	objptr, ##41232
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	add	objptr, ##28212
	rdlong	arg01, objptr
	sub	objptr, ##28212
	shl	arg01, #1
	mov	arg02, #4
	call	#_hg010b_spin2_setcursorpos
' position 2*editor_spaces,4 : print "Ready"
	mov	arg01, #0
	call	#__system___getiolock_0558
	mov	arg01, result1
	call	#__system___lockmem
	mov	arg02, ##@LR__5777
	mov	arg01, #0
	mov	arg03, #0
	call	#__system___basic_print_string
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0558
	wrlong	#0, result1
	mov	arg02, #0
	test	arg02, #1 wc
	drvc	#38
	test	arg02, #1 wc
	drvc	#39
	mov	local01, ##@LR__5778
	add	objptr, ##41944
	wrlong	local01, objptr
	add	objptr, #4
	wrlong	##-1, objptr
	add	objptr, #12
	wrlong	#0, objptr
	sub	objptr, ##41960
' pinwrite 38,0 : pinwrite 39,0 ' LEDs off
' loadname="noname.bas"
' do_insert=-1
' inload=0
' 
' open "/sd/bas/autorun.bas" for input as #9
	mov	arg02, ##@LR__5779
	mov	arg01, #9
	mov	arg03, #0
	call	#__system___basic_open_string
	add	ptr___system__dat__, #32
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #32
	add	objptr, ##41964
	wrlong	result1, objptr
	sub	objptr, ##41964
' err=geterr()
' close #9
	mov	arg01, #9
	call	#__system__close
' if err=0 then line$="run autorun.bas" : interpret
	add	objptr, ##41964
	rdlong	local01, objptr wz
	sub	objptr, ##41964
 if_e	mov	local01, ##@LR__5780
 if_e	add	objptr, ##28188
 if_e	wrlong	local01, objptr
 if_e	sub	objptr, ##28188
 if_e	call	#_interpret
' 
' 
' '-------------------------------------------------------------------------------------------------------- 
' '-------------------------------------- MAIN LOOP -------------------------------------------------------
' '--------------------------------------------------------------------------------------------------------
' 
' do
LR__2470
	call	#_edit
	mov	local01, result1
	add	objptr, ##28188
	wrlong	local01, objptr
	sub	objptr, ##28188
	call	#_interpret
	mov	local01, ##@LR__5781
	add	objptr, ##28188
	wrlong	local01, objptr
	sub	objptr, ##28188
	jmp	#LR__2470
	mov	ptra, fp
	call	#popregs_
_program_ret
	ret

' '' this is not a main program.
' 
' '****************************************************************************************************************
' '                                                                                                             	*
' 'Start the driver  at pins 'base'                            					rev 20230829 	*
' '                                                                                                            	*
' ' base - HDMI base pin												*
' ' mb - PSRAM mailbox pointer, 0 if no PSRAM									*
' '														*
' '														*
' '****************************************************************************************************************
' 
' pub start(base,mb):result |i
_hg010b_spin2_start
' 
' '--------------------------- initialize pointers and variables
' 
' border_ptr:=@bordercolor					' Initial border color pointer, can be changed via DL
	add	objptr, #52
	mov	result1, objptr
	sub	objptr, #40
	wrlong	result1, objptr
' 'font_ptr:=@amiga_font						' Initial 8x16 font definition
' hdmibase:=base							' HDMI base pin, 8*n
	add	objptr, #24
	wrlong	arg01, objptr
' mailbox_ptr:=mb		
	add	objptr, #4
	wrlong	arg02, objptr
' mailbox0:=mb				' PSRAM mailbox pointer
	add	objptr, #449
	wrlong	arg02, objptr
' sprite_ptr:=@spr1ptr
	sub	objptr, #216
	mov	result1, objptr
	sub	objptr, #229
	wrlong	result1, objptr
' 
' 		'
' word[spr1ptr+17*12+4]:=8				' spr18w
	add	objptr, #229
	rdlong	result1, objptr
	add	result1, #208
	wrword	#8, result1
' word[spr1ptr+17*12+6]:=16				' for a blinking cursor
	rdlong	arg03, objptr
	add	arg03, #210
	wrword	#16, arg03
' leading_spaces:=0				'
	add	objptr, #421
	wrlong	#0, objptr
' 
' emptydl[0]:=%0100_0000_0000_0000_0000_0000_0000_0111
	sub	objptr, #153
	wrlong	##1073741831, objptr
' emptydl[1]:=0
	add	objptr, #4
	wrlong	#0, objptr
' 
' '---------------------------- the mode has to be set here to enable computing the buffer length
' 
' s_debug:=debugger						' check if debug mode defined (eats 16 kB upper RAM so don't use it)					' 
	sub	objptr, #296
	wrlong	#1, objptr
' if s_debug<>0
'   s_debug:=16384						' the buffers adresses will be corrected to not interfere with the debugger
	wrlong	##16384, objptr
	sub	objptr, #249
' setmode()							' set the mode, see below
	call	#_hg010b_spin2_setmode
' vblank_ptr:=@vblank						' set pointers before starting the driver
	add	objptr, #73
	mov	result1, objptr
	sub	objptr, #53
	wrlong	result1, objptr
' cursor_ptr:=@cursor_x						
	add	objptr, #40
	mov	arg03, objptr
	sub	objptr, #44
	wrlong	arg03, objptr
' fontnum:=0  							' start with a PC type font 
	add	objptr, #85
	wrlong	#0, objptr
' bytemove(@colors,@vgacolors,16)					' prepare standard DOS VGA colors
	add	objptr, #28
	mov	arg01, objptr
	sub	objptr, #129
	add	ptr__hg010b_spin2_dat__, ##8320
	mov	arg02, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##8320
	mov	arg03, #16
	call	#__system____builtin_memmove
' leading_spaces:=0
	add	objptr, ##694
	wrlong	#0, objptr
	sub	objptr, ##694
' '---------------------------- initialize a cursor (MSDOS type)
' 
' initcursor(154)
	mov	arg01, #154
	call	#_hg010b_spin2_initcursor
' 
' '---------------------------- start the cog
' 
' cog:=coginit(16,@hdmi, @vblank_ptr)				' start the driver cog			
	add	ptr__hg010b_spin2_dat__, ##8336
	mov	arg02, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##8336
	add	objptr, #20
	mov	result1, #16
	setq	objptr
	coginit	result1, arg02 wc
 if_b	neg	result1, #1
	add	objptr, #28
	wrlong	result1, objptr
	sub	objptr, #48
' waitms(40)							' wait for stabilize
	mov	arg01, #40
	call	#__system___waitms
' return cog							' return the driver's cog #
	add	objptr, #48
	rdlong	result1, objptr
	sub	objptr, #48
_hg010b_spin2_start_ret
	ret

' 
' 
' '**************************************************************************************************************** 
' '                                                                                                             	*
' '  Simple standard mode setting                                                             	rev. 20220319 	*
' '  Mode number - see start() above or bits below								*
' '                                                                                                             	*
' '****************************************************************************************************************
' 
' '---------------------------- initialize a cursor (MSDOS type)
' pub initcursor(color) |i
_hg010b_spin2_initcursor
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' cursor_x:=0							' place the cursor at 0:0
	add	objptr, #60
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' repeat i from 0 to 111
	mov	local02, #0
	add	objptr, #504
	callpa	#(@LR__2482-@LR__2480)>>2,fcache_load_ptr_
LR__2480
'   cursor[i]:=0
	mov	local03, local02
	add	local03, objptr
	wrbyte	#0, local03
	add	local02, #1
	cmps	local02, #112 wc
 if_b	jmp	#LR__2480
' repeat i from 112 to 127
	mov	local02, #112
LR__2481
'   cursor[i]:=color  
	mov	local03, local02
	add	local03, objptr
	wrbyte	local01, local03
	add	local02, #1
	cmp	local02, #128 wc
 if_b	jmp	#LR__2481
LR__2482
' 'repeat i from 0 to 127
' '  if ((i/8)//2)
' '    cursor[i]:=15
' '  else
' '    cursor[i]:=0
' '  if i>=120    
' '    cursor[i]:=40
' setspriteptr(17,@cursor)
	mov	arg02, objptr
	sub	objptr, ##566
	mov	arg01, #17
	call	#_hg010b_spin2_setspriteptr
' setspritesize(17,8,16)
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_hg010b_spin2_setspritesize
' setspritepos(17,0,0)
	mov	arg01, #17
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritepos
' cursorshape:=14
	add	objptr, ##5830
	wrlong	#14, objptr
' cursorcolor:=color
	sub	objptr, #4
	wrlong	local01, objptr
	sub	objptr, ##5826
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_initcursor_ret
	ret

' 
' pub setcursorshape(shape) | i
_hg010b_spin2_setcursorshape
' 
' cursorshape:=shape
	add	objptr, ##5830
	wrlong	arg01, objptr
' repeat i from 0 to (8*cursorshape)-1
	mov	_var01, #0
	mov	_var02, arg01
	shl	_var02, #3
	sub	_var02, #1
	cmps	_var02, #0 wc
	negc	_var03, #1
	mov	_var04, _var03
	add	_var02, _var03
	sub	objptr, ##5264
	callpa	#(@LR__2491-@LR__2490)>>2,fcache_load_ptr_
LR__2490
'   cursor[i]:=0
	mov	_var03, _var01
	add	_var03, objptr
	wrbyte	#0, _var03
	add	_var01, _var04
	cmp	_var01, _var02 wz
 if_ne	jmp	#LR__2490
LR__2491
' repeat i from 8*cursorshape to 127
	add	objptr, ##5264
	rdlong	_var04, objptr
	mov	_var01, _var04
	shl	_var01, #3
	sub	objptr, ##5830
	shl	_var04, #3
	cmps	_var04, #128 wc
	negnc	_var03, #1
	mov	_var02, #127
	add	_var02, _var03
	callpa	#(@LR__2493-@LR__2492)>>2,fcache_load_ptr_
LR__2492
'   cursor[i]:=cursorcolor
	mov	_var04, _var01
	add	objptr, ##566
	add	_var04, objptr
	add	objptr, ##5260
	rdlong	arg01, objptr
	sub	objptr, ##5826
	wrbyte	arg01, _var04
	add	_var01, _var03
	cmp	_var01, _var02 wz
 if_ne	jmp	#LR__2492
LR__2493
_hg010b_spin2_setcursorshape_ret
	ret

' 
' pub setcursorcolor(color) | i
_hg010b_spin2_setcursorcolor
' 
' cursorcolor:=color
	add	objptr, ##5826
	wrlong	arg01, objptr
' repeat i from 0 to (8*cursorshape)-1
	mov	arg01, #0
	add	objptr, #4
	rdlong	_var01, objptr
	shl	_var01, #3
	sub	_var01, #1
	cmps	_var01, #0 wc
	negc	_var02, #1
	mov	_var03, _var02
	add	_var01, _var02
	sub	objptr, ##5264
	callpa	#(@LR__2501-@LR__2500)>>2,fcache_load_ptr_
LR__2500
'   cursor[i]:=0
	mov	_var02, arg01
	add	_var02, objptr
	wrbyte	#0, _var02
	add	arg01, _var03
	cmp	arg01, _var01 wz
 if_ne	jmp	#LR__2500
LR__2501
' repeat i from 8*cursorshape to 127
	add	objptr, ##5264
	rdlong	_var03, objptr
	mov	arg01, _var03
	shl	arg01, #3
	sub	objptr, ##5830
	shl	_var03, #3
	cmps	_var03, #128 wc
	negnc	_var02, #1
	mov	_var01, #127
	add	_var01, _var02
	callpa	#(@LR__2503-@LR__2502)>>2,fcache_load_ptr_
LR__2502
'   cursor[i]:=cursorcolor
	mov	_var03, arg01
	add	objptr, ##566
	add	_var03, objptr
	add	objptr, ##5260
	rdlong	_var04, objptr
	sub	objptr, ##5826
	wrbyte	_var04, _var03
	add	arg01, _var02
	cmp	arg01, _var01 wz
 if_ne	jmp	#LR__2502
LR__2503
_hg010b_spin2_setcursorcolor_ret
	ret

'   
'   
'   
' pub setmode() | i', 'xzoom, yzoom, azoom
_hg010b_spin2_setmode
	mov	COUNT_, #2
	call	#pushregs_
' 
' 
' dl_ptr:=@emptydl[0]
	add	objptr, ##541
	mov	arg05, objptr
	sub	objptr, #509
	wrlong	arg05, objptr
' 
' if cog>0 
	add	objptr, #16
	rdlong	arg05, objptr
	sub	objptr, #48
	cmps	arg05, #1 wc
'    waitvbl(1)						    	' if the driver is active, wait for vblank to set the new mode and DL	
 if_ae	mov	arg01, #1
 if_ae	call	#_hg010b_spin2_waitvbl
' xres:=1024
	add	objptr, ##550
	wrlong	##1024, objptr
' yres:=600
	add	objptr, #4
	wrlong	##600, objptr
' ppl:=(timings[3])
	add	ptr__hg010b_spin2_dat__, ##8268
	rdlong	arg05, ptr__hg010b_spin2_dat__
	sub	objptr, #337
	wrlong	arg05, objptr
' cpl:=timings[7]<<1                                      	' now cpl is longs per line
	add	ptr__hg010b_spin2_dat__, #16
	rdlong	local01, ptr__hg010b_spin2_dat__
	shl	local01, #1
	sub	objptr, #128
	wrlong	local01, objptr
' cpl1:=cpl '' todo remove
	add	objptr, #4
	wrlong	local01, objptr
' palette_ptr:=@ataripalette				    	' use 256-colors palettr
	sub	ptr__hg010b_spin2_dat__, ##1052
	sub	objptr, #65
	wrlong	ptr__hg010b_spin2_dat__, objptr
' repeat i from 0 to 3
	mov	local02, #0
	add	ptr__hg010b_spin2_dat__, ##1024
	add	objptr, #8
	callpa	#(@LR__2511-@LR__2510)>>2,fcache_load_ptr_
LR__2510
'   timings[i]:=timings[i]+hdmibase<<17+ timingsxxt          	' add a streamer config (imm->pins) to horizontal timings 
	mov	local01, local02
	shl	local01, #2
	add	local01, ptr__hg010b_spin2_dat__
	rdlong	arg05, objptr
	shl	arg05, #17
	rdlong	local01, local01
	add	local01, arg05
	add	local01, ##1887502336
	mov	arg05, local02
	shl	arg05, #2
	add	arg05, ptr__hg010b_spin2_dat__
	wrlong	local01, arg05
	add	local02, #1
	cmps	local02, #4 wc
 if_b	jmp	#LR__2510
LR__2511
	sub	objptr, #36
' clkfreq:=timings[9]					    	' set the clock frequency for the mode
	add	ptr__hg010b_spin2_dat__, #36
	rdlong	local01, ptr__hg010b_spin2_dat__
	wrlong	local01, #20
' hubset(timings[10])
	add	ptr__hg010b_spin2_dat__, #4
	rdlong	arg01, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##8296
	hubset	arg01
' waitms(1)                                                   	' wait for stabilization
	mov	arg01, #1
	call	#__system___waitms
	add	ptr__hg010b_spin2_dat__, ##8300
	rdlong	local02, ptr__hg010b_spin2_dat__
	add	objptr, #97
	wrlong	local02, objptr
	abs	local01, local02 wc
	shr	local01, #4
	negc	local01, local01
	add	objptr, #156
	wrlong	local01, objptr
	sub	objptr, #164
	rdlong	local02, objptr
	add	objptr, #8
	rdlong	local01, objptr
	qmul	local02, local01
' lines:=timings[11]
' t_lines:=lines/16
' buflen:=cpl*lines						' framebuffer length in longs
	sub	objptr, #41
	decod	local01, #25
	sub	ptr__hg010b_spin2_dat__, #16
	getqx	local02
	wrlong	local02, objptr
	sub	objptr, #56
	shl	local02, #2
	sub	local01, local02
	wrlong	local01, objptr
	add	objptr, #253
	rdlong	local02, objptr
	rdlong	arg05, ptr__hg010b_spin2_dat__
	qmul	local02, arg05
' buf_ptr:=$2000000-4*buflen                          	     	' todo: get a PSRAM real himem 
' textbuf_ptr:=buf_ptr-t_lines*timings[7]
	sub	objptr, #249
' mode_ptr:=@timings						' set pointers to timings
	sub	ptr__hg010b_spin2_dat__, #28
' graphmode:=1024+512+192+48							' det global variable
' makedl(graphmode)							' make a DL for the mode
	mov	arg01, ##1776
	getqx	local02
	sub	local01, local02
	wrlong	local01, objptr
	add	objptr, #20
	wrlong	ptr__hg010b_spin2_dat__, objptr
	add	objptr, #121
	wrlong	##1776, objptr
	sub	objptr, #145
	sub	ptr__hg010b_spin2_dat__, ##8256
	call	#_hg010b_spin2_makedl
' s_buf_ptr:=buf_ptr						' secondary copies of main framebuffer parameters 
	rdlong	local01, objptr
	add	objptr, #221
	wrlong	local01, objptr
' s_font_ptr:=font_ptr
	sub	objptr, #213
	rdlong	local01, objptr
	add	objptr, #217
	wrlong	local01, objptr
' s_lines:=lines
	sub	objptr, #128
	rdlong	local01, objptr
	add	objptr, #132
	wrlong	local01, objptr
' s_buflen:=buflen
	sub	objptr, #173
	rdlong	local01, objptr
	add	objptr, #181
	wrlong	local01, objptr
' s_cpl:=cpl
	sub	objptr, #148
	rdlong	local01, objptr
	add	objptr, #144
	wrlong	local01, objptr
' s_cpl1:=cpl
	sub	objptr, #144
	rdlong	local01, objptr
	add	objptr, #152
	wrlong	local01, objptr
' st_lines:=t_lines
	add	objptr, #12
	rdlong	local01, objptr
	add	objptr, #4
	wrlong	local01, objptr
' ppl:=ppl/xzoom  
	sub	objptr, #40
	rdlong	muldiva_, objptr
	add	objptr, #44
	rdlong	muldivb_, objptr
	sub	objptr, #261
	call	#divide_
	add	objptr, #217
	wrlong	muldivb_, objptr
' s_ppl:=ppl
	add	objptr, #28
	wrlong	muldivb_, objptr
	sub	objptr, #245
' waitms(20)							' wait 
	mov	arg01, #20
	call	#__system___waitms
' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	arg03, arg01
	mov	arg02, #32
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5836
	call	#_psram_spin2_fill
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_setmode_ret
	ret

' 
' '****************************************************************************************************************
' '                                                                                                             	*
' '  Make a display list for simple standard modes                                             	rev.20220319    *
' '                                                                                                             	*
' '****************************************************************************************************************
' 
' pub makedl(mode) |i,vzoom,border,psbuf,lines2
_hg010b_spin2_makedl
' 
' psbuf:=$80000-s_debug-1024                                                     ' HUB line buffer on the top of HUB RAM (-16 kB if debug enabled)
' vzoom:=1<<((mode>>2) & 3)                                                      ' real vzoom from mode#
' repeat i from 0 to 11                                                           ' clear DL
	mov	_var01, #0
	add	objptr, #493
	callpa	#(@LR__2521-@LR__2520)>>2,fcache_load_ptr_
LR__2520
'   displaylist[i]:=0 
	mov	_var02, _var01
	shl	_var02, #2
	add	_var02, objptr
	wrlong	#0, _var02
	add	_var01, #1
	cmps	_var01, #12 wc
 if_b	jmp	#LR__2520
LR__2521
'                         ' 
' displaylist[0]:=lines<<20+(0)<<16+%0001+ (0+(cpl1<<2)) <<4             
	sub	objptr, #396
	rdlong	_var02, objptr
	shl	_var02, #20
	add	_var02, #1
	sub	objptr, #4
	rdlong	_var01, objptr
	shl	_var01, #2
	shl	_var01, #4
	add	_var02, _var01
	add	objptr, #400
	wrlong	_var02, objptr
	sub	objptr, #493
' displaylist[1]:=buf_ptr<<4+%10  
	rdlong	_var02, objptr
	shl	_var02, #4
	add	_var02, #2
	add	objptr, #497
	wrlong	_var02, objptr
' dl_ptr:=@displaylist[0] 						      ' tell the driver where to find the DL
	sub	objptr, #4
	mov	_var02, objptr
	sub	objptr, #461
	wrlong	_var02, objptr
	sub	objptr, #32
_hg010b_spin2_makedl_ret
	ret

' 
' 
' '****************************************************************************************************************
' '                                                                        					*
' '  Graphic primitives                                                    					*
' '                                                                        					*
' '****************************************************************************************************************
' 
' pub setspriteptr(num,ptr)
_hg010b_spin2_setspriteptr
' long[@spr1ptr+12*num]:=ptr
	add	objptr, #273
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	wrlong	arg02, _var01
	sub	objptr, #273
_hg010b_spin2_setspriteptr_ret
	ret

' 
' pub setspritepos(num,x,y)
_hg010b_spin2_setspritepos
' if y>601
	cmps	arg03, ##602 wc
'   y:=601
 if_ae	mov	arg03, ##601
' if x>1024
	cmps	arg02, ##1025 wc
'   x:=1024
 if_ae	decod	arg02, #10
' word[@spr1ptr+12*num+4]:=x
	add	objptr, #273
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #4
	wrword	arg02, _var01
' word[@spr1ptr+12*num+6]:=y
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #6
	wrword	arg03, _var01
	sub	objptr, #273
_hg010b_spin2_setspritepos_ret
	ret

' 
' pub setspritesize(num,w,h)
_hg010b_spin2_setspritesize
' word[@spr1ptr+12*num+8]:=w
	add	objptr, #273
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #8
	wrword	arg02, _var01
' word[@spr1ptr+12*num+10]:=h
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #10
	wrword	arg03, _var01
	sub	objptr, #273
_hg010b_spin2_setspritesize_ret
	ret

' 
' 
' ''---------- putpixel - put a pixel on the screen - a mother of all graphic functions ---------------------------
' 
' 
' pub putpixel(x,y,c)
_hg010b_spin2_putpixel
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' if ((x>=0) & (x<4*s_cpl) & (y>=0) & (y<s_lines))
	mov	local02, #0
	cmps	local01, #0 wc
 if_ae	neg	local02, #1
	add	objptr, #233
	rdlong	arg05, objptr
	shl	arg05, #2
	cmps	local01, arg05 wc
	subx	local03, local03
	and	local02, local03
	mov	local03, #0
	cmps	arg02, #0 wc
 if_ae	neg	local03, #1
	and	local02, local03
	sub	objptr, #4
	rdlong	local03, objptr
	sub	objptr, #229
	cmps	arg02, local03 wc
	subx	local04, local04
	test	local02, local04 wz
 if_e	jmp	#LR__2530
	add	objptr, #221
	rdlong	arg01, objptr
	add	objptr, #20
	rdlong	local04, objptr
	shl	local04, #2
	qmul	local04, arg02
'   ram.fill(s_buf_ptr+(4*s_cpl1*y+x),c,1,0,1)
	mov	arg02, arg03
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5595
	getqx	local04
	add	local04, local01
	add	arg01, local04
	call	#_psram_spin2_fill
	sub	objptr, ##5836
LR__2530
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putpixel_ret
	ret

' 
' pub putpixel2(x,y,c)
_hg010b_spin2_putpixel2
	mov	COUNT_, #2
	call	#pushregs_
	add	objptr, #221
	rdlong	local01, objptr
	add	objptr, #20
	rdlong	arg05, objptr
	shl	arg05, #2
	qmul	arg05, arg02
' ram.fill(s_buf_ptr+(4*s_cpl1*y+x),c,1,0,1)
	mov	arg02, arg03
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5595
	getqx	local02
	add	local02, arg01
	add	local01, local02
	mov	arg01, local01
	call	#_psram_spin2_fill
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putpixel2_ret
	ret

' 
' pub getpixel2(x,y): c 
_hg010b_spin2_getpixel2
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	wrlong	#0, fp
	mov	arg01, fp
	add	objptr, #221
	rdlong	arg02, objptr
	add	objptr, #20
	rdlong	arg03, objptr
	shl	arg03, #2
	add	fp, #8
	rdlong	result1, fp
	qmul	arg03, result1
' 
' ram.read1(@c,s_buf_ptr+(4*s_cpl1*y+x),1)
	sub	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	mov	arg03, #1
	add	objptr, ##5595
	getqx	local02
	add	local02, local01
	add	arg02, local02
	call	#_psram_spin2_read1
	sub	objptr, ##5836
' return c
	rdlong	result1, fp
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_getpixel2_ret
	ret

'   
' '----------- A line drawing family. BASIC doesn't like the name, so it is named "draw" and aliased  -----------------------------
' 
' pub fastline(x1,x2,y,c)									' a fast 8bpp horizontal line
_hg010b_spin2_fastline
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' if y<0 || y>=yres || (x1<0 && x2<0) || (x1>xres && x2>xres)
	cmps	arg03, #0 wc
 if_b	jmp	#LR__2540
	add	objptr, ##554
	rdlong	arg05, objptr
	sub	objptr, ##554
	cmps	arg03, arg05 wc
 if_ae	jmp	#LR__2540
	cmps	local01, #0 wc
 if_b	cmps	local02, #0 wc
 if_b	jmp	#LR__2540
	add	objptr, ##550
	rdlong	arg05, objptr
	sub	objptr, ##550
	cmps	local01, arg05 wcz
 if_a	add	objptr, ##550
 if_a	rdlong	arg01, objptr
 if_a	sub	objptr, ##550
 if_a	cmps	local02, arg01 wcz
'   return
 if_a	jmp	#LR__2540
	cmps	local01, local02 wcz
 if_a	mov	arg05, local01
 if_a	mov	local01, local02
 if_a	mov	local02, arg05
	cmps	local01, #0 wc
 if_b	mov	local01, #0
	add	objptr, ##550
	rdlong	arg05, objptr
	sub	objptr, ##550
	cmps	local02, arg05 wc
 if_ae	add	objptr, ##550
 if_ae	rdlong	local02, objptr
 if_ae	sub	objptr, ##550
	add	objptr, #221
	rdlong	arg01, objptr
	add	objptr, #20
	rdlong	arg05, objptr
	shl	arg05, #2
	qmul	arg05, arg03
' if x1>x2
'   x1,x2:=x2,x1
' if x1<0 
'   x1:=0
' if x2>=xres
'   x2:=xres-1  
 if_ae	sub	local02, #1
' ram.fill(s_buf_ptr+(4*s_cpl1*y+x1),c,1+x2-x1,0,1)
	mov	arg03, #1
	add	arg03, local02
	sub	arg03, local01
	mov	arg02, arg04
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5595
	getqx	local02
	add	local02, local01
	add	arg01, local02
	call	#_psram_spin2_fill
	sub	objptr, ##5836
LR__2540
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_fastline_ret
	ret

' 
' pub draw(x1,y1,x2,y2,c) | d,dx,dy,ai,bi,xi,yi,x,y					' I had to rename the function for BASIC	
_hg010b_spin2_draw
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' if (y1==y2)
	cmp	local02, local04 wz
 if_ne	jmp	#LR__2550
'   fastline(x1,x2,y1,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local02
	mov	arg04, local05
	call	#_hg010b_spin2_fastline
	jmp	#LR__2556
LR__2550
' else  
'   x:=x1
	mov	local06, local01
'   y:=y1
	mov	local07, local02
' 
'   if (x1<x2) 
	cmps	local01, local03 wc
'     xi:=1
 if_b	mov	local08, #1
'     dx:=x2-x1
 if_b	mov	local09, local03
 if_b	sub	local09, local01
'   else
'     xi:=-1
 if_ae	neg	local08, #1
'     dx:=x1-x2
 if_ae	sub	local01, local03
 if_ae	mov	local09, local01
'   
'   if (y1<y2) 
	cmps	local02, local04 wc
'     yi:=1
 if_b	mov	local10, #1
'     dy:=y2-y1
 if_b	mov	local11, local04
 if_b	sub	local11, local02
'   else
'     yi:=-1
 if_ae	neg	local10, #1
'     dy:=y1-y2
 if_ae	sub	local02, local04
 if_ae	mov	local11, local02
' 
'   putpixel(x,y,c)
	mov	arg03, local05
	mov	arg01, local06
	mov	arg02, local07
	call	#_hg010b_spin2_putpixel
' 
'   if (dx>dy)
	cmps	local09, local11 wcz
 if_be	jmp	#LR__2552
'     ai:=(dy-dx)*2
	mov	local12, local11
	sub	local12, local09
	shl	local12, #1
'     bi:=dy*2
	shl	local11, #1
	mov	local13, local11
'     d:= bi-dx
	mov	local14, local13
	sub	local14, local09
'     repeat while (x<>x2) 
LR__2551
	cmp	local06, local03 wz
 if_e	jmp	#LR__2555
'       if (d>=0) 
	cmps	local14, #0 wc
'         x+=xi
 if_ae	add	local06, local08
'         y+=yi
 if_ae	add	local07, local10
'         d+=ai
 if_ae	add	local14, local12
'       else
'         d+=bi
 if_b	add	local14, local13
'         x+=xi
 if_b	add	local06, local08
'       putpixel(x,y,c)
	mov	arg01, local06
	mov	arg02, local07
	mov	arg03, local05
	call	#_hg010b_spin2_putpixel
	jmp	#LR__2551
LR__2552
'   else
'     ai:=(dx-dy)*2
	mov	local12, local09
	sub	local12, local11
	shl	local12, #1
'     bi:=dx*2
	shl	local09, #1
	mov	local13, local09
'     d:=bi-dy
	mov	local14, local13
	sub	local14, local11
'     repeat while (y<>y2)
LR__2553
	cmp	local07, local04 wz
 if_e	jmp	#LR__2554
'       if (d>=0)
	cmps	local14, #0 wc
'         x+=xi
 if_ae	add	local06, local08
'         y+=yi
 if_ae	add	local07, local10
'         d+=ai
 if_ae	add	local14, local12
'       else
'         d+=bi
 if_b	add	local14, local13
'         y+=yi
 if_b	add	local07, local10
'       putpixel(x, y,c)
	mov	arg01, local06
	mov	arg02, local07
	mov	arg03, local05
	call	#_hg010b_spin2_putpixel
	jmp	#LR__2553
LR__2554
LR__2555
LR__2556
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_draw_ret
	ret

'  
' pub fillpush(val) 
_hg010b_spin2_fillpush
' fillstack[fillptr]:=val
	add	objptr, ##5818
	rdlong	_var01, objptr
	shl	_var01, #2
	sub	objptr, ##5120
	add	_var01, objptr
	wrlong	arg01, _var01
' fillptr+=1   
	add	objptr, ##5120
	rdlong	_var01, objptr
	add	_var01, #1
	wrlong	_var01, objptr
	sub	objptr, ##5818
_hg010b_spin2_fillpush_ret
	ret

' 
'     
' pub fillpop() : val
_hg010b_spin2_fillpop
' 
' fillptr-=1
	add	objptr, ##5818
	rdlong	result1, objptr
	sub	result1, #1
	wrlong	result1, objptr
' if fillptr<0
	sub	objptr, ##5818
	cmps	result1, #0 wc
'   fillptr:=0
 if_b	add	objptr, ##5818
 if_b	wrlong	#0, objptr
 if_b	sub	objptr, ##5818
'   val:=-12345
 if_b	mov	_var01, ##-12345
 if_b	jmp	#LR__2560
' else 
'   val:=fillstack[fillptr]
	add	objptr, ##5818
	rdlong	_var01, objptr
	shl	_var01, #2
	sub	objptr, ##5120
	add	_var01, objptr
	rdlong	_var01, _var01
	sub	objptr, ##698
LR__2560
' return val
	mov	result1, _var01
_hg010b_spin2_fillpop_ret
	ret

' 
'       
' pub fill(x,y,newcolor,oldcolor) | x1, spanabove, spanbelow, ov
_hg010b_spin2_fill
	mov	COUNT_, #11
	call	#pushregs_
' 
' newcolor:=newcolor & 255
	getbyte	local01, arg03, #0
' oldcolor:=oldcolor & 255
	getbyte	local02, arg04, #0
' 
' if (oldcolor == newcolor) 
	cmp	local02, local01 wz
'   return
 if_e	jmp	#LR__2579
' 
' fillptr:=0
	add	objptr, ##5818
	wrlong	#0, objptr
' fillmax:=0
	add	objptr, #4
	wrlong	#0, objptr
	sub	objptr, ##5822
' fillpush(x)
	call	#_hg010b_spin2_fillpush
' fillpush(y)
	mov	arg01, arg02
	call	#_hg010b_spin2_fillpush
' y:=fillpop()
	call	#_hg010b_spin2_fillpop
	mov	local03, result1
' x:=fillpop()
	call	#_hg010b_spin2_fillpop
	mov	local04, result1
' 'pinhigh(38)
' repeat while (x>-1)       
LR__2570
	cmps	local04, #0 wc
 if_b	jmp	#LR__2578
'  ' pintoggle(39)
'   x1 := x
	mov	local05, local04
'   repeat while((x1 >= 0) && (getpixel2(x1,y) == oldColor))
LR__2571
	mov	local06, #0
	mov	local07, #0
	cmps	local05, #0 wc
 if_ae	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
'     x1--
 if_ne	sub	local05, #1
 if_ne	jmp	#LR__2571
'   x1++
	add	local05, #1
'   spanabove := 0
	mov	local10, #0
'   spanbelow := 0
	mov	local11, #0
'   repeat while ((x1 < 1024) && getpixel2(x1,y) == oldColor)
LR__2572
	mov	local06, #0
	cmps	local05, ##1024 wc
 if_b	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
 if_e	jmp	#LR__2577
'     putpixel2 (x1,y, newcolor & 255)
	getbyte	arg03, local01, #0
	mov	arg01, local05
	mov	arg02, local03
	call	#_hg010b_spin2_putpixel2
'     if ((spanabove == 0) && (y > 0) && (getpixel2(x1,y-1)== oldColor))
	mov	local06, #0
	mov	local07, #0
	cmp	local10, #0 wz
 if_e	cmps	local03, #1 wc
 if_nc_and_z	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	sub	arg02, #1
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
 if_e	jmp	#LR__2573
'       fillpush(x1)
	mov	arg01, local05
	call	#_hg010b_spin2_fillpush
'       fillpush(y-1)
	mov	arg01, local03
	sub	arg01, #1
	call	#_hg010b_spin2_fillpush
'       spanabove := 1 
	mov	local10, #1
	jmp	#LR__2574
LR__2573
'     elseif ((spanabove<>0) && (y > 0) && (getpixel2(x1,y-1)<> oldColor))
	mov	local06, #0
	mov	local07, #0
	cmp	local10, #0 wz
 if_ne	cmps	local03, #1 wc
 if_a	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	sub	arg02, #1
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_ne	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
'       spanabove := 0 
 if_ne	mov	local10, #0
LR__2574
'     if((spanbelow == 0 ) && (y < 575) && getpixel2(x1,y+1) == oldColor)
	mov	local06, #0
	mov	local07, #0
	cmp	local11, #0 wz
 if_e	cmps	local03, ##575 wc
 if_c_and_z	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	add	arg02, #1
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_e	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
 if_e	jmp	#LR__2575
'       fillpush(x1)
	mov	arg01, local05
	call	#_hg010b_spin2_fillpush
'       fillpush(y + 1)
	mov	arg01, local03
	add	arg01, #1
	call	#_hg010b_spin2_fillpush
'       spanBelow := 1
	mov	local11, #1
	jmp	#LR__2576
LR__2575
'     elseif((spanbelow<>0) && (y < 575) && (getpixel2(x1,y + 1)<> oldColor))
	mov	local06, #0
	mov	local07, #0
	cmp	local11, #0 wz
 if_ne	cmps	local03, ##575 wc
 if_c_and_nz	neg	local07, #1
	cmp	local07, #0 wz
 if_ne	not	local06, #0
	mov	local08, #0
	mov	local09, #0
	mov	arg02, local03
	add	arg02, #1
	mov	arg01, local05
	call	#_hg010b_spin2_getpixel2
	cmp	result1, local02 wz
 if_ne	not	local09, #0
	cmp	local09, #0 wz
 if_ne	not	local08, #0
	test	local06, local08 wz
'       spanbelow := 0
 if_ne	mov	local11, #0
LR__2576
'     x1++
	add	local05, #1
	jmp	#LR__2572
LR__2577
'   y:=fillpop()
	call	#_hg010b_spin2_fillpop
	mov	local03, result1
'   x:=fillpop()
	call	#_hg010b_spin2_fillpop
	mov	local04, result1
	jmp	#LR__2570
LR__2578
LR__2579
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_fill_ret
	ret

' 'pinlow(38)    
' 
' '-- A filled circle -----------------------------------------------------
' 
' pub fcircle(x0,y0,r,c) | d,x,y,da,db
_hg010b_spin2_fcircle
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg03
	qmul	local01, ##-2
	mov	local02, arg01
	mov	local03, arg02
	mov	local04, arg04
' 
' d:=5-4*r
	mov	arg04, local01
	shl	arg04, #2
	mov	local05, #5
	sub	local05, arg04
' x:=0
	mov	local06, #0
' y:=r
' da:=(-2*r+5)*4
' db:=3*4
	mov	local07, #12
' repeat while (x<=y) 
	getqx	local08
	add	local08, #5
	shl	local08, #2
LR__2580
	cmps	local06, local01 wcz
 if_a	jmp	#LR__2582
'   fastline(x0-x,x0+x,y0-y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local02
	add	arg02, local06
	mov	arg03, local03
	sub	arg03, local01
	mov	arg04, local04
	call	#_hg010b_spin2_fastline
'   fastline(x0-x,x0+x,y0+y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local02
	add	arg02, local06
	mov	arg03, local03
	add	arg03, local01
	mov	arg04, local04
	call	#_hg010b_spin2_fastline
'   fastline(x0-y,x0+y,y0-x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local02
	add	arg02, local01
	mov	arg03, local03
	sub	arg03, local06
	mov	arg04, local04
	call	#_hg010b_spin2_fastline
'   fastline(x0-y,x0+y,y0+x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local02
	add	arg02, local01
	mov	arg03, local03
	add	arg03, local06
	mov	arg04, local04
	call	#_hg010b_spin2_fastline
'   if d>0 
	cmps	local05, #1 wc
 if_b	jmp	#LR__2581
'     d+=da
	add	local05, local08
'     y-=1
	sub	local01, #1
'     x+=1
	add	local06, #1
'     da+=4*4
	add	local08, #16
'     db+=2*4
	add	local07, #8
	jmp	#LR__2580
LR__2581
'   else
'     d+=db
	add	local05, local07
'     x+=1
	add	local06, #1
'     da+=2*4
	add	local08, #8
'     db+=2*4
	add	local07, #8
	jmp	#LR__2580
LR__2582
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_fcircle_ret
	ret

'  
' '-- A circle ------------------------------------------------------------ 
'  
' pub circle(x0,y0,r,c) | d,x,y,da,db
_hg010b_spin2_circle
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg03
	qmul	local01, ##-2
	mov	local02, arg01
	mov	local03, arg02
	mov	local04, arg04
' 
'  
' d:=5-4*r
	mov	arg04, local01
	shl	arg04, #2
	mov	local05, #5
	sub	local05, arg04
' x:=0
	mov	local06, #0
' y:=r
' da:=(-2*r+5)*4
' db:=3*4
	mov	local07, #12
' repeat while (x<=y) 
	getqx	local08
	add	local08, #5
	shl	local08, #2
LR__2590
	cmps	local06, local01 wcz
 if_a	jmp	#LR__2592
'   putpixel(x0-x,y0-y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local03
	sub	arg02, local01
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0-x,y0+y,c)
	mov	arg01, local02
	sub	arg01, local06
	mov	arg02, local03
	add	arg02, local01
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0+x,y0-y,c)
	mov	arg01, local02
	add	arg01, local06
	mov	arg02, local03
	sub	arg02, local01
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0+x,y0+y,c)
	mov	arg01, local02
	add	arg01, local06
	mov	arg02, local03
	add	arg02, local01
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0-y,y0-x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local03
	sub	arg02, local06
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0-y,y0+x,c)
	mov	arg01, local02
	sub	arg01, local01
	mov	arg02, local03
	add	arg02, local06
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0+y,y0-x,c)
	mov	arg01, local02
	add	arg01, local01
	mov	arg02, local03
	sub	arg02, local06
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   putpixel(x0+y,y0+x,c)
	mov	arg01, local02
	add	arg01, local01
	mov	arg02, local03
	add	arg02, local06
	mov	arg03, local04
	call	#_hg010b_spin2_putpixel
'   if d>0 
	cmps	local05, #1 wc
 if_b	jmp	#LR__2591
'     d+=da
	add	local05, local08
'     y-=1
	sub	local01, #1
'     x+=1
	add	local06, #1
'     da+=4*4
	add	local08, #16
'     db+=2*4
	add	local07, #8
	jmp	#LR__2590
LR__2591
'   else
'     d+=db
	add	local05, local07
'     x+=1
	add	local06, #1
'     da+=2*4
	add	local08, #8
'     db+=2*4
	add	local07, #8
	jmp	#LR__2590
LR__2592
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_circle_ret
	ret

'     
' '-- A frame (an empty rectangle) ---------------------------------------
' 
' pub frame(x1,y1,x2,y2,c)
_hg010b_spin2_frame
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' fastline(x1,x2,y1,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local02
	mov	arg04, local05
	call	#_hg010b_spin2_fastline
' fastline(x1,x2,y2,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local05
	call	#_hg010b_spin2_fastline
' line(x1,y1,x1,y2,c)
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local01
	mov	arg04, local04
	mov	arg05, local05
' draw(x1,y1,x2,y2,c)
	call	#_hg010b_spin2_draw
' line(x2,y1,x2,y2,c)
	mov	arg01, local03
	mov	arg02, local02
	mov	arg03, local03
	mov	arg04, local04
	mov	arg05, local05
' draw(x1,y1,x2,y2,c)
	call	#_hg010b_spin2_draw
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_frame_ret
	ret

' 
' '-- A box (a filled rectangle) ----------------------------------------
' 
' pub box(x1,y1,x2,y2,c) |yy
_hg010b_spin2_box
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
' 
' repeat yy from y1 to y2
	cmps	local04, local02 wc
	negc	local06, #1
	add	local04, local06
LR__2600
'   fastline(x1,x2,yy,c)
	mov	arg01, local01
	mov	arg02, local03
	mov	arg04, local05
	mov	arg03, local02
	call	#_hg010b_spin2_fastline
	add	local02, local06
	cmp	local02, local04 wz
 if_ne	jmp	#LR__2600
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_box_ret
	ret

'       
' pub putcharxycgf(x,y,achar,f,b) |xx, yy,bb,c1,c2
_hg010b_spin2_putcharxycgf
' 
'  
' repeat yy from 0 to 15
	mov	_var01, #0
	callpa	#(@LR__2612-@LR__2610)>>2,fcache_load_ptr_
LR__2610
' 
'   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
	add	objptr, #149
	rdlong	_var02, objptr
	shl	_var02, #10
	mov	_var03, ptr__hg010b_spin2_dat__
	add	_var03, _var02
	mov	_var02, arg03
	shl	_var02, #4
	add	_var03, _var02
	add	_var03, _var01
	rdbyte	_var03, _var03
'   asm
	testb	_var03, #0 wz
 if_e	setbyte	_var04, arg04, #0
 if_ne	setbyte	_var04, arg05, #0
	testb	_var03, #1 wz
 if_e	setbyte	_var04, arg04, #1
 if_ne	setbyte	_var04, arg05, #1
	testb	_var03, #2 wz
 if_e	setbyte	_var04, arg04, #2
 if_ne	setbyte	_var04, arg05, #2
	testb	_var03, #3 wz
 if_e	setbyte	_var04, arg04, #3
 if_ne	setbyte	_var04, arg05, #3
	testb	_var03, #4 wz
 if_e	setbyte	_var05, arg04, #0
 if_ne	setbyte	_var05, arg05, #0
	testb	_var03, #5 wz
 if_e	setbyte	_var05, arg04, #1
 if_ne	setbyte	_var05, arg05, #1
	testb	_var03, #6 wz
 if_e	setbyte	_var05, arg04, #2
 if_ne	setbyte	_var05, arg05, #2
	testb	_var03, #7 wz
 if_e	setbyte	_var05, arg04, #3
 if_ne	setbyte	_var05, arg05, #3
'   
'   ccc[0]:=c1
	add	objptr, #409
	wrlong	_var04, objptr
'   ccc[1]:=c2 
	add	objptr, #4
	wrlong	_var05, objptr
'   long[mailbox0][2]:=8
	sub	objptr, #73
	rdlong	_var03, objptr
	add	_var03, #8
	wrlong	#8, _var03
'   long[mailbox0][1]:=@ccc
	add	objptr, #69
	mov	_var03, objptr
	sub	objptr, #69
	rdlong	_var02, objptr
	add	_var02, #4
	wrlong	_var03, _var02
'   long[mailbox0]:= s_buf_ptr+((y+yy)<<10+x<<2)+$f0000000   
	sub	objptr, #268
	rdlong	_var03, objptr
	mov	_var02, arg02
	add	_var02, _var01
	shl	_var02, #10
	mov	_var06, arg01
	shl	_var06, #2
	add	_var02, _var06
	add	_var03, _var02
	add	_var03, ##-268435456
	add	objptr, #268
	rdlong	_var06, objptr
	wrlong	_var03, _var06
'   repeat
LR__2611
	rdlong	_var03, objptr
	rdlong	_var02, _var03
	cmps	_var02, #0 wc
 if_b	jmp	#LR__2611
	sub	objptr, #489
	add	_var01, #1
	cmps	_var01, #16 wc
 if_b	jmp	#LR__2610
LR__2612
_hg010b_spin2_putcharxycgf_ret
	ret

' 
' 
' '**********************************************************************r***
' '                                                                        *
' ' Font related functions                                                 *
' '                                                                        *
' '*************************************************************************
' 
' ''--------- Set a font offset. TODO: remove, use byte#1 instead
' 
' pub setfontfamily(afontnum)
_hg010b_spin2_setfontfamily
' 
' font_family:=afontnum
	add	objptr, #149
	wrlong	arg01, objptr
	sub	objptr, #149
' 'if afontnum==8
' '  font_ptr:=@amiga_font
' 
' if afontnum==4
	cmp	arg01, #4 wz
'   font_ptr:=@st_font
 if_e	add	ptr__hg010b_spin2_dat__, ##4096
 if_e	add	objptr, #8
 if_e	wrlong	ptr__hg010b_spin2_dat__, objptr
 if_e	sub	objptr, #8
 if_e	sub	ptr__hg010b_spin2_dat__, ##4096
' if afontnum==0
	cmp	arg01, #0 wz
'   font_ptr:=@vga_font
 if_e	add	objptr, #8
 if_e	wrlong	ptr__hg010b_spin2_dat__, objptr
 if_e	sub	objptr, #8
_hg010b_spin2_setfontfamily_ret
	ret

' 
' '*************************************************************************
' '                                                                        *
' '  Cursor functions                                                      *
' '                                                                        *
' '*************************************************************************
' 
' 
' pub setcursorpos(x,y)
_hg010b_spin2_setcursorpos
' 
' ''---------- Set the (x,y) position of cursor
' 
' cursor_x:=x
	add	objptr, #60
	wrword	arg01, objptr
' cursor_y:=y
	add	objptr, #2
	wrbyte	arg02, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	sub	objptr, #2
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
_hg010b_spin2_setcursorpos_ret
	ret

' 
' pub setcursorx(x)
_hg010b_spin2_setcursorx
' cursor_x:=x
	add	objptr, #60
	wrword	arg01, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
_hg010b_spin2_setcursorx_ret
	ret

' 
' pub setcursory(y) 
_hg010b_spin2_setcursory
' cursor_y:=y
	add	objptr, #62
	wrbyte	arg01, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4)
	sub	objptr, #2
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
_hg010b_spin2_setcursory_ret
	ret

' 
' '*************************************************************************
' '                                                                        *
' '  VBlank functions                                                      *
' '                                                                        *
' '*************************************************************************
' 
' pub waitvbl(amount) | i
_hg010b_spin2_waitvbl
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' ''---------- Wait for start of vblank. Amount=delay in frames
' 
' repeat i from 1 to amount
	mov	local02, #1
	cmps	local01, #1 wc
	negc	local03, #1
	add	local01, local03
LR__2620
'   repeat until vblank==0
LR__2621
	add	objptr, #73
	rdlong	arg01, objptr wz
	sub	objptr, #73
 if_e	jmp	#LR__2622
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__2621
LR__2622
'   repeat until vblank==1
LR__2623
	add	objptr, #73
	rdlong	arg01, objptr
	sub	objptr, #73
	cmp	arg01, #1 wz
 if_e	jmp	#LR__2624
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__2623
LR__2624
	add	local02, local03
	cmp	local02, local01 wz
 if_ne	jmp	#LR__2620
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_waitvbl_ret
	ret

' 
' 
' pub cls(fc,bc)   :c,i
_hg010b_spin2_cls
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' c:=bc
' ram.fill(s_buf_ptr,c,4*buflen,0,1)  
	add	objptr, #221
	rdlong	arg01, objptr
	sub	objptr, #165
	rdlong	arg03, objptr
	shl	arg03, #2
	mov	arg02, local02
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5780
	call	#_psram_spin2_fill
' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
	sub	objptr, ##5832
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	arg03, arg01
	mov	arg02, #32
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5836
	call	#_psram_spin2_fill
' setwritecolors(fc,bc)
' 
' write_color:=ff
	sub	objptr, ##5771
	wrlong	local01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	local02, objptr
' cursor_x:=0
	sub	objptr, #9
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	sub	objptr, #2
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
' setcursorcolor(fc)
	mov	arg01, local01
	call	#_hg010b_spin2_setcursorcolor
	mov	result1, local02
	mov	result2, #0
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_cls_ret
	ret

' 
' ''---------- Output a char at the cursor position, move the cursor 
' 
' pub putchar(achar) | c,x,y,l,newcpl
_hg010b_spin2_putchar
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' 
' if achar==10
	cmp	local01, #10 wz
'   crlf()
 if_e	call	#_hg010b_spin2_crlf
' if achar==9
	cmp	local01, #9 wz
 if_ne	jmp	#LR__2630
'   cursor_x:=(cursor_x& %11110000)+16
	add	objptr, #60
	rdword	arg03, objptr
	and	arg03, #240
	add	arg03, #16
	wrword	arg03, objptr
	sub	objptr, #60
LR__2630
'   
' if (achar<>9) && (achar<>10) 
	cmp	local01, #9 wz
 if_ne	cmp	local01, #10 wz
 if_e	jmp	#LR__2631
'   putcharxycgf(cursor_x,16*cursor_y+4,achar,write_color,write_background)
	add	objptr, #60
	rdword	arg01, objptr
	add	objptr, #2
	rdbyte	arg02, objptr
	shl	arg02, #4
	add	arg02, #4
	add	objptr, #3
	rdlong	arg04, objptr
	add	objptr, #4
	rdlong	arg05, objptr
	sub	objptr, #69
	mov	arg03, local01
	call	#_hg010b_spin2_putcharxycgf
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__hg010b_spin2_dat__, ##8284
	rdlong	arg03, ptr__hg010b_spin2_dat__
	add	objptr, #58
	rdbyte	arg05, objptr
	qmul	arg03, arg05
'   ram.fill(textbuf_ptr+(timings[7]*cursor_y+(cursor_x>>1)),achar,1,0,1)
	sub	ptr__hg010b_spin2_dat__, ##8284
	sub	objptr, #2
	rdword	local02, objptr
	shr	local02, #1
	mov	arg02, local01
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5776
	getqx	local01
	add	local01, local02
	add	arg01, local01
	call	#_psram_spin2_fill
'   cursor_x+=2
	sub	objptr, ##5776
	rdword	local02, objptr
	add	local02, #2
	wrword	local02, objptr
	sub	objptr, #60
LR__2631
' 
' if cursor_x>=256
	add	objptr, #60
	rdword	local02, objptr
	sub	objptr, #60
	cmps	local02, #256 wc
 if_b	jmp	#LR__2633
'   cursor_x:=0
	add	objptr, #60
	wrword	#0, objptr
'   cursor_y+=1
	add	objptr, #2
	rdbyte	local02, objptr
	add	local02, #1
	wrbyte	local02, objptr
'   if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	rdbyte	arg03, objptr
	sub	objptr, #62
	cmps	arg03, local02 wcz
 if_be	jmp	#LR__2632
'     scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup2
'     cursor_y:=st_lines-1
	add	objptr, #257
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	wrbyte	local02, objptr
	sub	objptr, #62
LR__2632
LR__2633
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putchar_ret
	ret

'     
' ''---------- Output a char at the cursor position, move the cursor, don't react for tab or lf 
' 
' pub putchar2(achar) | c,x,y,l,newcpl
_hg010b_spin2_putchar2
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' 
' putcharxycgf(cursor_x,16*cursor_y+4,achar,write_color,write_background)
	add	objptr, #60
	rdword	arg01, objptr
	add	objptr, #2
	rdbyte	arg02, objptr
	shl	arg02, #4
	add	arg02, #4
	add	objptr, #3
	rdlong	arg04, objptr
	add	objptr, #4
	rdlong	arg05, objptr
	sub	objptr, #69
	mov	arg03, local01
	call	#_hg010b_spin2_putcharxycgf
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__hg010b_spin2_dat__, ##8284
	rdlong	arg03, ptr__hg010b_spin2_dat__
	add	objptr, #58
	rdbyte	arg05, objptr
	qmul	arg03, arg05
' ram.fill(textbuf_ptr+(timings[7]*cursor_y+(cursor_x>>1)),achar,1,0,1)
	sub	ptr__hg010b_spin2_dat__, ##8284
	sub	objptr, #2
	rdword	local02, objptr
	shr	local02, #1
	mov	arg02, local01
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5776
	getqx	local01
	add	local01, local02
	add	arg01, local01
	call	#_psram_spin2_fill
' 
' cursor_x+=2
	sub	objptr, ##5776
	rdword	local02, objptr
	add	local02, #2
	wrword	local02, objptr
' if cursor_x>=256
	rdword	local02, objptr
	sub	objptr, #60
	cmps	local02, #256 wc
 if_b	jmp	#LR__2641
'   cursor_x:=0
	add	objptr, #60
	wrword	#0, objptr
'   cursor_y+=1
	add	objptr, #2
	rdbyte	local02, objptr
	add	local02, #1
	wrbyte	local02, objptr
'   if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	rdbyte	arg03, objptr
	sub	objptr, #62
	cmps	arg03, local02 wcz
 if_be	jmp	#LR__2640
'     scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup2
'     cursor_y:=st_lines-1
	add	objptr, #257
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	wrbyte	local02, objptr
	sub	objptr, #62
LR__2640
LR__2641
' setspritepos(17,4*cursor_x,16*cursor_y+4 ) 
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putchar2_ret
	ret

' ''--------- Output a string at the cursor position, move the cursor  
' 
' pub write(text) | iii,c,ncx,ncy
_hg010b_spin2_write
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' repeat iii from 0 to strsize(text)-1
	mov	local02, #0
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__2651-@LR__2650)>>2,fcache_load_ptr_
LR__2650
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__2650
LR__2651
	sub	local03, arg01
	sub	local03, #1
	cmps	local03, #0 wc
	negc	local04, #1
	add	local03, local04
LR__2652
'   putchar2(byte[text+iii])
	mov	arg01, local01
	add	arg01, local02
	rdbyte	arg01, arg01
	call	#_hg010b_spin2_putchar2
	add	local02, local04
	cmp	local02, local03 wz
 if_ne	jmp	#LR__2652
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_write_ret
	ret

'    
' ' a version for text scrolling in Basic shifted 4 lines down
' 
' pub scrollup2(start=0, end=600 , amount=16) | i
_hg010b_spin2_scrollup2
	mov	COUNT_, #3
	call	#pushregs_
' 	
' repeat i from 4 to 579 
	mov	local01, #4
LR__2660
	add	objptr, #249
	rdlong	arg05, objptr
	sub	objptr, #28
	rdlong	arg02, objptr
	mov	arg04, local01
	add	arg04, #16
	shl	arg04, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg04, arg03
'   ram.read1($80000-4096-1024-s_debug, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
	mov	arg01, ##519168
	sub	arg01, arg05
	shl	arg03, #2
	add	objptr, ##5595
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_read1
	sub	objptr, ##5587
	rdlong	arg05, objptr
	sub	objptr, #28
	rdlong	arg02, objptr
	mov	arg04, local01
	shl	arg04, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg04, arg03
'   ram.write($80000-4096-1024-s_debug, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
	mov	arg01, ##519168
	sub	arg01, arg05
	shl	arg03, #2
	add	objptr, ##5595
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_write
	sub	objptr, ##5836
	add	local01, #1
	cmp	local01, ##580 wc
 if_b	jmp	#LR__2660
' 
' repeat i from 580 to 599
	mov	local01, ##580
LR__2661
'    fastline(0,1023,i,write_background)   
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local01
	call	#_hg010b_spin2_fastline
	add	local01, #1
	cmp	local01, ##600 wc
 if_b	jmp	#LR__2661
' repeat i from 0 to 3
	mov	local01, #0
LR__2662
'    fastline(0,1023,i,write_background)      
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local01
	call	#_hg010b_spin2_fastline
	add	local01, #1
	cmps	local01, #4 wc
 if_b	jmp	#LR__2662
' 
' repeat i from 0 to 35
	mov	local01, #0
LR__2663
	mov	arg05, local01
	add	arg05, #1
	add	ptr__hg010b_spin2_dat__, ##8284
	rdlong	arg03, ptr__hg010b_spin2_dat__
	qmul	arg05, arg03
'   ram.read1($80000-4096-1024-s_debug, textbuf_ptr+(i+1)*timings[7], timings[7])
	mov	arg01, ##519168
	add	objptr, #249
	rdlong	arg05, objptr
	sub	arg01, arg05
	sub	objptr, #245
	rdlong	arg02, objptr
	sub	ptr__hg010b_spin2_dat__, ##8284
	add	objptr, ##5832
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_read1
	add	ptr__hg010b_spin2_dat__, ##8284
	rdlong	arg03, ptr__hg010b_spin2_dat__
	qmul	local01, arg03
'   ram.write($80000-4096-1024-s_debug, textbuf_ptr+i*timings[7], timings[7])
	mov	arg01, ##519168
	sub	objptr, ##5587
	rdlong	arg05, objptr
	sub	arg01, arg05
	sub	objptr, #245
	rdlong	arg02, objptr
	sub	ptr__hg010b_spin2_dat__, ##8284
	add	objptr, ##5832
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_write
	sub	objptr, ##5836
	add	local01, #1
	cmps	local01, #36 wc
 if_b	jmp	#LR__2663
' repeat i from 0 to timings[7]-1
	mov	local01, #0
	add	ptr__hg010b_spin2_dat__, ##8284
	rdlong	local02, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##8284
	sub	local02, #1
	cmps	local02, #0 wc
	negc	local03, #1
	add	local02, local03
LR__2664
'   ram.fill(textbuf_ptr+(36*timings[7]+i),32,1,0,1) 
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__hg010b_spin2_dat__, ##8284
	rdlong	arg05, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##8284
	mov	arg04, arg05
	shl	arg04, #3
	add	arg04, arg05
	shl	arg04, #2
	add	arg04, local01
	add	arg01, arg04
	mov	arg02, #32
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5832
	call	#_psram_spin2_fill
	sub	objptr, ##5836
	add	local01, local03
	cmp	local01, local02 wz
 if_ne	jmp	#LR__2664
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_scrollup2_ret
	ret

'  
' ''----------- Scroll the screen one line down 
' 
' pub scrolldown(start=0) | i
_hg010b_spin2_scrolldown
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
' 
' repeat i from 579 to (start*16)+4
	mov	local02, ##579
	mov	local03, local01
	shl	local03, #4
	add	local03, #4
	cmps	local03, ##579 wc
	negc	local04, #1
	mov	local05, local04
	add	local03, local04
LR__2670
	add	objptr, #249
	rdlong	local04, objptr
	sub	objptr, #28
	rdlong	arg02, objptr
	mov	arg05, local02
	shl	arg05, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg05, arg03
'   ram.read1($80000-4096-1024-s_debug, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
	mov	arg01, ##519168
	sub	arg01, local04
	shl	arg03, #2
	add	objptr, ##5595
	getqx	local04
	add	arg02, local04
	call	#_psram_spin2_read1
	sub	objptr, ##5587
	rdlong	local04, objptr
	sub	objptr, #28
	rdlong	arg02, objptr
	mov	arg05, local02
	add	arg05, #16
	shl	arg05, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg05, arg03
'   ram.write($80000-4096-1024-s_debug, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
	mov	arg01, ##519168
	sub	arg01, local04
	shl	arg03, #2
	add	objptr, ##5595
	getqx	local04
	add	arg02, local04
	call	#_psram_spin2_write
	sub	objptr, ##5836
	add	local02, local05
	cmp	local02, local03 wz
 if_ne	jmp	#LR__2670
' 
' repeat i from (start*16)+4 to (start*16)+19
	mov	local02, local01
	shl	local02, #4
	add	local02, #4
	mov	local05, local01
	shl	local05, #4
	add	local05, #19
	mov	local04, local01
	shl	local04, #4
	add	local04, #4
	cmps	local05, local04 wc
	negc	local04, #1
	mov	local03, local04
	add	local05, local04
LR__2671
'    fastline(0,1023,i,write_background)    
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local02
	call	#_hg010b_spin2_fastline
	add	local02, local03
	cmp	local02, local05 wz
 if_ne	jmp	#LR__2671
'    
' repeat i from 35 to start
	mov	local02, #35
	cmps	local01, #35 wc
	negc	local04, #1
	mov	local05, local01
	add	local05, local04
LR__2672
'   ram.read1($80000-4096-1024-s_debug, textbuf_ptr+(i*128), 128)
	mov	arg01, ##519168
	add	objptr, #249
	rdlong	local03, objptr
	sub	arg01, local03
	sub	objptr, #245
	rdlong	arg02, objptr
	mov	local03, local02
	shl	local03, #7
	add	arg02, local03
	mov	arg03, #128
	add	objptr, ##5832
	call	#_psram_spin2_read1
'   ram.write($80000-4096-1024-s_debug, textbuf_ptr+(i+1)*128,128)
	mov	arg01, ##519168
	sub	objptr, ##5587
	rdlong	local03, objptr
	sub	arg01, local03
	sub	objptr, #245
	rdlong	arg02, objptr
	mov	local03, local02
	add	local03, #1
	shl	local03, #7
	add	arg02, local03
	mov	arg03, #128
	add	objptr, ##5832
	call	#_psram_spin2_write
	sub	objptr, ##5836
	add	local02, local04
	cmp	local02, local05 wz
 if_ne	jmp	#LR__2672
' repeat i from 0 to 127
	mov	local02, #0
LR__2673
'   ram.fill((textbuf_ptr+start*128+i),32,1,0,1)      
	add	objptr, #4
	rdlong	arg01, objptr
	mov	local05, local01
	shl	local05, #7
	add	arg01, local05
	add	arg01, local02
	mov	arg02, #32
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5832
	call	#_psram_spin2_fill
	sub	objptr, ##5836
	add	local02, #1
	cmps	local02, #128 wc
 if_b	jmp	#LR__2673
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_scrolldown_ret
	ret

' 
' ''----------- Set cursor at the first character in a new line, scroll if needed 
' 
' pub crlf()
_hg010b_spin2_crlf
' 
' cursor_x:=leading_spaces*2
	add	objptr, ##694
	rdlong	arg03, objptr
	shl	arg03, #1
	sub	objptr, ##634
	wrword	arg03, objptr
' cursor_y+=1
	add	objptr, #2
	rdbyte	arg03, objptr
	add	arg03, #1
	wrbyte	arg03, objptr
' if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #195
	rdbyte	arg02, objptr
	sub	objptr, #62
	cmps	arg02, arg03 wcz
 if_be	jmp	#LR__2680
'   scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup2
'   cursor_y:=st_lines-1
	add	objptr, #257
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #195
	wrbyte	arg03, objptr
	sub	objptr, #62
LR__2680
' setspritepos(17,4*cursor_x,16*cursor_y+4 )  
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
_hg010b_spin2_crlf_ret
	ret

' 
' 
' '*************************************************************************
' '                                                                        *
' '  Conversions                                                           *
' '                                                                        *
' '*************************************************************************
' 
' ''---------- Convert a integer to dec string, return a pointer
' 
' pub inttostr(i):result |q,pos,k,j
_hg010b_spin2_inttostr
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01 wz
' 
' j:=i
' pos:=10
	mov	local02, #10
' k:=0
	mov	local03, #0
' 
' if (j==0)
 if_ne	jmp	#LR__2690
'   n_string[0]:=48
	add	objptr, #77
	wrbyte	#48, objptr
'   n_string[1]:=0
	add	objptr, #1
	wrbyte	#0, objptr
	sub	objptr, #78
	jmp	#LR__2697
LR__2690
' 
' else
'   if (j<0)
	abs	local01, local01 wc
'     j:=0-j
'     k:=45
 if_b	mov	local03, #45
' 
'   n_string[11]:=0
	add	objptr, #88
	wrbyte	#0, objptr
	sub	objptr, #88
	callpa	#(@LR__2692-@LR__2691)>>2,fcache_load_ptr_
'   repeat while (pos>-1)
LR__2691
	cmps	local02, #0 wc
 if_b	jmp	#LR__2693
	abs	result1, local01 wc
	qdiv	result1, #10
'     q:=j//10
	getqy	result1
	negc	result1, result1
	abs	local01, local01 wc
	qdiv	local01, #10
'     q:=48+q
	add	result1, #48
'     n_string[pos]:=q
	mov	local01, local02
	add	objptr, #77
	add	local01, objptr
	wrbyte	result1, local01
'     j:=j/10
	sub	objptr, #77
'     pos-=1
	sub	local02, #1
	getqx	local01
	negc	local01, local01
	jmp	#LR__2691
LR__2692
LR__2693
'   repeat while n_string[0]==48
LR__2694
	add	objptr, #77
	rdbyte	arg03, objptr
	sub	objptr, #77
	cmp	arg03, #48 wz
 if_ne	jmp	#LR__2695
'     bytemove(@n_string,@n_string+1,12)
	add	objptr, #77
	mov	arg01, objptr
	mov	arg02, objptr
	sub	objptr, #77
	add	arg02, #1
	mov	arg03, #12
	call	#__system____builtin_memmove
	jmp	#LR__2694
LR__2695
' 
'   if k==45
	cmp	local03, #45 wz
 if_ne	jmp	#LR__2696
'      bytemove(@n_string+1,@n_string,12)
	add	objptr, #77
	mov	arg01, objptr
	add	arg01, #1
	mov	arg02, objptr
	sub	objptr, #77
	mov	arg03, #12
	call	#__system____builtin_memmove
'      n_string[0]:=k
	add	objptr, #77
	wrbyte	local03, objptr
	sub	objptr, #77
LR__2696
LR__2697
' 
' q:=@n_string
	add	objptr, #77
	mov	result1, objptr
	sub	objptr, #77
' return q
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_inttostr_ret
	ret

' 
' '**********************************************************************************
' '
' '        Blitting
' '
' '**********************************************************************************
' 
' pub blit(f,x1a,y1a,x2a,y2a,s1,t,x1b,y1b,s2) | y
_hg010b_spin2_blit
	mov	COUNT_, #24
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
	mov	local06, arg06
	mov	local07, arg07
	mov	local08, arg08
	mov	local09, arg09
	mov	local10, arg10
' 
' if ((f>=$80000) && (t>=$80000)) ' todo: check if the fields overlap and reorder the move
	cmps	local01, ##524288 wc
 if_ae	cmps	local07, ##524288 wc
 if_b	jmp	#LR__2704
	cmps	local02, local04 wcz
 if_a	mov	local11, local02
 if_a	mov	local02, local04
 if_a	mov	local04, local11
	cmps	local03, local05 wcz
 if_a	mov	local11, local03
 if_a	mov	local03, local05
	qmul	local03, local06
'   if x1a>x2a
'     x1a,x2a:=x2a,x1a
'   if y1a>y2a
'     y1a,y2a:=y2a,y1a  
 if_a	mov	local05, local11
' 
'   if t+x1a+y1a*s1>f+x1b+y1b*s2
	mov	local12, local07
	add	local12, local02
	getqx	local11
	qmul	local09, local10
	add	local12, local11
	mov	local13, local01
	add	local13, local08
	getqx	local11
	add	local13, local11
	cmps	local12, local13 wcz
 if_be	jmp	#LR__2701
'     repeat y from y1a to y2a
	mov	local14, local03
	cmps	local05, local03 wc
	negc	local15, #1
	mov	local16, local05
	add	local16, local15
	add	objptr, ##5836
LR__2700
	qmul	local14, local06
'   '    writeln(string("I am here"))
'       ram.read1($80000-4096-1024, f+(y)*s1+x1a, x2a-x1a+1)
	mov	arg02, local01
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	mov	arg01, ##519168
	getqx	local13
	add	arg02, local13
	add	arg02, local02
	call	#_psram_spin2_read1
	mov	local13, local09
	sub	local13, local03
	add	local13, local14
	qmul	local13, local10
'       ram.write($80000-4096-1024, t+(y1b-y1a+y)*s2+x1b, x2a-x1a+1)
	mov	arg02, local07
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	mov	arg01, ##519168
	getqx	local13
	add	arg02, local13
	add	arg02, local08
	call	#_psram_spin2_write
	add	local14, local15
	cmp	local14, local16 wz
 if_ne	jmp	#LR__2700
	sub	objptr, ##5836
	jmp	#LR__2703
LR__2701
'   else
'     repeat y from y2a to y1a
	mov	local14, local05
	cmps	local03, local05 wc
	negc	local17, #1
	mov	local18, local03
	add	local18, local17
	add	objptr, ##5836
LR__2702
	qmul	local14, local06
'  '     writeln(string("I am there"))
'       ram.read1($80000-4096-1024, f+(y)*s1+x1a, x2a-x1a+1)
	mov	arg02, local01
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	mov	arg01, ##519168
	getqx	local16
	add	arg02, local16
	add	arg02, local02
	call	#_psram_spin2_read1
	mov	local16, local09
	sub	local16, local03
	add	local16, local14
	qmul	local16, local10
'       ram.write($80000-4096-1024, t+(y1b-y1a+y)*s2+x1b, x2a-x1a+1)     
	mov	arg02, local07
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	mov	arg01, ##519168
	getqx	local16
	add	arg02, local16
	add	arg02, local08
	call	#_psram_spin2_write
	add	local14, local17
	cmp	local14, local18 wz
 if_ne	jmp	#LR__2702
	sub	objptr, ##5836
LR__2703
LR__2704
'     
' if ((f>=$80000) && (t<$80000)) 
	cmps	local01, ##524288 wc
 if_b	jmp	#LR__2706
	cmps	local07, ##524288 wc
 if_ae	jmp	#LR__2706
'   repeat y from y1a to y2a
	mov	local14, local03
	cmps	local05, local03 wc
	negc	local19, #1
	mov	local20, local05
	add	local20, local19
	add	objptr, ##5836
LR__2705
	mov	local18, local09
	sub	local18, local03
	add	local18, local14
	qmul	local18, local10
'     ram.read1(t+(y1b-y1a+y)*s2+x1b,f+(y)*s1+x1a,x2a-x1a+1)
	mov	arg01, local07
	getqx	local18
	qmul	local14, local06
	add	arg01, local18
	add	arg01, local08
	mov	arg02, local01
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	getqx	local18
	add	arg02, local18
	add	arg02, local02
	call	#_psram_spin2_read1
	add	local14, local19
	cmp	local14, local20 wz
 if_ne	jmp	#LR__2705
	sub	objptr, ##5836
LR__2706
'     
' if ((f<$80000) && (t>=$80000)) 
	cmps	local01, ##524288 wc
 if_ae	jmp	#LR__2708
	cmps	local07, ##524288 wc
 if_b	jmp	#LR__2708
'   t:=t & $FFFFFFF
	bitl	local07, #124
'   repeat y from y1a to y2a
	mov	local14, local03
	cmps	local05, local03 wc
	negc	local21, #1
	mov	local22, local05
	add	local22, local21
	add	objptr, ##5836
LR__2707
	qmul	local14, local06
'     ram.write(f+(y)*s1+x1a,t+(y1b-y1a+y)*s2+x1b,x2a-x1a+1)
	mov	arg01, local01
	mov	local20, local09
	sub	local20, local03
	add	local20, local14
	getqx	local19
	qmul	local20, local10
	add	arg01, local19
	add	arg01, local02
	mov	arg02, local07
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	getqx	local20
	add	arg02, local20
	add	arg02, local08
	call	#_psram_spin2_write
	add	local14, local21
	cmp	local14, local22 wz
 if_ne	jmp	#LR__2707
	sub	objptr, ##5836
LR__2708
'     
' if ((f<$80000) && (t<$80000)) 
	cmps	local01, ##524288 wc
 if_b	cmps	local07, ##524288 wc
 if_ae	jmp	#LR__2710
'   repeat y from y1a to y2a
	mov	local14, local03
	cmps	local05, local03 wc
	negc	local23, #1
	mov	local24, local05
	add	local24, local23
LR__2709
	qmul	local14, local06
'     bytemove (f+(y)*s1+x1a,t+(y1b-y1a+y)*s2+x1b,x2a-x1a+1)
	mov	arg01, local01
	mov	local22, local09
	sub	local22, local03
	add	local22, local14
	getqx	local21
	qmul	local22, local10
	add	arg01, local21
	add	arg01, local02
	mov	arg02, local07
	mov	arg03, local04
	sub	arg03, local02
	add	arg03, #1
	getqx	local22
	add	arg02, local22
	add	arg02, local08
	call	#__system____builtin_memmove
	add	local14, local23
	cmp	local14, local24 wz
 if_ne	jmp	#LR__2709
LR__2710
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_blit_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB startx(freq, burst, delay, desiredcog) : result | driverAddr
_psram_spin2_startx
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	mov	local03, arg04
'     stop() ' restart driver if required
	call	#_psram_spin2_stop
	cmp	local01, #0 wz
 if_e	rdlong	local01, #20
	abs	arg02, local01 wc
	qdiv	arg02, ##1000000
' 
'     ' use current frequency if none specified
' 
'     if freq == 0 
'         freq := clkfreq 
' 
'     ' compute the device burst size including overheads to keep CS low time below 8us
' 
'     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
'     if burst < 0
'         return ERR_TOO_SLOW ' P2 frequency is too low for any 8us transfers
	getqx	arg02
	negc	arg04, arg02
	shl	arg04, #3
	sub	arg04, #132
	shr	arg04, #4
	shl	arg04, #4
	cmps	arg04, #0 wc
 if_b	neg	result1, #14
 if_b	jmp	#LR__2723
' 
'     ' compute the input delay
' 
'     if delay <= 0
	cmps	local02, #1 wc
 if_ae	jmp	#LR__2720
'         delay := lookupDelay(freq)
	mov	arg01, local01
	call	#_psram_spin2_lookupDelay
	mov	local02, result1
	jmp	#LR__2721
LR__2720
'     else
'         delay <#= $f ' limit to 15
	fles	local02, #15
LR__2721
' 
'     ' create our lock
' 
'     driverlock := LOCKNEW()  
	mov	result1, #0
	locknew	result1
	add	ptr__psram_spin2_dat__, #260
	wrlong	result1, ptr__psram_spin2_dat__
'     if driverlock == -1
	sub	ptr__psram_spin2_dat__, #260
	cmp	result1, ##-1 wz
'         return ERR_NO_LOCK
 if_e	neg	result1, #26
 if_e	jmp	#LR__2723
' 
'     ' patch in the proper data and HUB addresses to the startup structure
' 
'     long[@startupData][0]:=clkfreq
	rdlong	local01, #20
	add	ptr__psram_spin2_dat__, #296
	wrlong	local01, ptr__psram_spin2_dat__
' '    long[@startupData][1]:=$1000_0000
'     long[@startupData][5]:=@deviceData
	add	ptr__psram_spin2_dat__, #32
	mov	local01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #32
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #20
	wrlong	local01, arg02
'     long[@startupData][6]:=@qosData
	add	ptr__psram_spin2_dat__, #160
	mov	local01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #160
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #24
	wrlong	local01, arg02
'     long[@startupData][7]:=$7FF00
	mov	local01, ptr__psram_spin2_dat__
	add	local01, #28
	wrlong	##524032, local01
' 
'     ' setup some default bank and QoS parameter values
' 
'     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
	add	ptr__psram_spin2_dat__, #32
	mov	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #328
	shl	arg04, #16
	shl	local02, #12
	or	arg04, local02
	or	arg04, #24
	mov	arg02, arg04
	mov	arg03, #2
	call	#\builtin_longfill_
'     longfill(@qosData, $FFFF0000, 8)
	add	ptr__psram_spin2_dat__, #456
	mov	arg03, #7
	setq	arg03
	wrlong	##-65536, ptr__psram_spin2_dat__
' 
'     ' get the address of the PSRAM memory driver so we can start it
' 
'     driverAddr:= driver.getDriverAddr()
'     return @driver_start
	add	ptr__psram16drv_spin2_dat__, #32
	mov	arg02, ptr__psram16drv_spin2_dat__
	sub	ptr__psram16drv_spin2_dat__, #32
' 
'     ' start the PSRAM memory driver and wait for it to complete initialization
' 
'     if desiredcog < 0
	cmps	local03, #0 wc
'         desiredcog := NEWCOG
 if_b	mov	local03, #16
'     drivercog := coginit(desiredcog, driverAddr, @startupData)
	sub	ptr__psram_spin2_dat__, #160
	mov	local04, local03
	setq	ptr__psram_spin2_dat__
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
	sub	ptr__psram_spin2_dat__, #40
	wrlong	local04, ptr__psram_spin2_dat__
'     repeat until long[@startupData] == 0 
	add	ptr__psram_spin2_dat__, #40
LR__2722
	rdlong	local04, ptr__psram_spin2_dat__ wz
 if_ne	jmp	#LR__2722
' 
'     return drivercog
	sub	ptr__psram_spin2_dat__, #40
	rdlong	result1, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
LR__2723
	mov	ptra, fp
	call	#popregs_
_psram_spin2_startx_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB stop() : i
_psram_spin2_stop
	mov	_var01, #0
'     if drivercog <> -1
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	arg01, ##-1 wz
 if_e	jmp	#LR__2733
'         cogstop(drivercog) ' a rather brutal stop
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cogstop	arg01
	callpa	#(@LR__2732-@LR__2730)>>2,fcache_load_ptr_
'         repeat i from 0 to 7
LR__2730
'             if long[$7FF00][i*3] < 0
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##524032
	rdlong	result1, result1
	cmps	result1, #0 wc
 if_ae	jmp	#LR__2731
'                 long[$7FF00][i*3] := -ERR_ABORTED ' abort request
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##524032
	wrlong	#16, result1
LR__2731
	add	_var01, #1
	cmps	_var01, #8 wc
 if_b	jmp	#LR__2730
LR__2732
'         drivercog := -1
	add	ptr__psram_spin2_dat__, #256
	wrlong	##-1, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
LR__2733
'     if driverlock <> -1
	add	ptr__psram_spin2_dat__, #260
	rdlong	_var02, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #260
	cmp	_var02, ##-1 wz
'         LOCKRET(driverlock)
 if_ne	add	ptr__psram_spin2_dat__, #260
 if_ne	rdlong	arg01, ptr__psram_spin2_dat__
 if_ne	lockret	arg01
'         driverlock := -1
 if_ne	wrlong	##-1, ptr__psram_spin2_dat__
 if_ne	sub	ptr__psram_spin2_dat__, #260
	mov	result1, _var01
_psram_spin2_stop_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB read1(dstHubAddr, srcAddr, count) : result | mailbox
_psram_spin2_read1
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__2741
'     if count == 0 ' don't even bother reading
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__2741
'     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	mov	_var02, ##524032
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__2741
'     long[mailbox][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox][1] := dstHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox] := driver.R_READBURST + (srcAddr & $1ffffff) ' trigger burst read operation
	mov	_var03, arg02
	bitl	_var03, #217
	mov	_var01, ##-1342177280
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__2740
'         result := long[mailbox]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__2740
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__2741
_psram_spin2_read1_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB write(srcHubAddr, dstAddr, count) : result | mailbox
_psram_spin2_write
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__2751
'     if count == 0 ' don't even bother writing
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__2751
'     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	mov	_var02, ##524032
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__2751
'     long[mailbox][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox][1] := srcHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
	mov	_var03, arg02
	bitl	_var03, #217
	mov	_var01, ##-268435456
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__2750
'         result := long[mailbox]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__2750
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__2751
_psram_spin2_write_ret
	ret

' 
' ' generalized fill
' PUB fill(addr, pattern, count, listPtr, datasize) : r | mailbox, req
_psram_spin2_fill
	mov	_var01, arg01
	mov	_var02, arg02
	mov	_var03, arg03
	mov	_var04, arg05
'     case datasize 
	sub	_var04, #1
	fle	_var04, #4
	jmprel	_var04
LR__2760
	jmp	#LR__2761
	jmp	#LR__2762
	jmp	#LR__2764
	jmp	#LR__2763
	jmp	#LR__2764
LR__2761
'         1: req := driver.R_WRITEBYTE
	mov	_var05, ##-1073741824
	jmp	#LR__2765
LR__2762
'         2: req := driver.R_WRITEWORD
	mov	_var05, ##-805306368
	jmp	#LR__2765
LR__2763
'         4: req := driver.R_WRITELONG
	mov	_var05, ##-536870912
	jmp	#LR__2765
LR__2764
'         other : return ERR_INVALID
	neg	result1, #6
	jmp	#LR__2767
LR__2765
'     if count == 0   ' nothing to do
	cmp	_var03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__2767
'     if drivercog == -1
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var04, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var04, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__2767
'     mailbox := $7FF00 + 12*cogid() ' get mailbox base address for this COG
	mov	result1, #0
	cogid	result1
	mov	_var04, result1
	shl	_var04, #1
	add	_var04, result1
	shl	_var04, #2
	mov	_var06, ##524032
	add	_var06, _var04
'     if long[mailbox] < 0
	rdlong	_var04, _var06
	cmps	_var04, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__2767
'     long[mailbox][2] := count
	add	_var06, #8
	wrlong	_var03, _var06
'     long[mailbox][1] := pattern
	sub	_var06, #4
	wrlong	_var02, _var06
	sub	_var06, #4
'     long[mailbox] := req + (addr & $1ffffff)
	mov	_var07, _var05
	mov	_var08, _var01
	bitl	_var08, #217
	add	_var07, _var08
	wrlong	_var07, _var06
'     repeat
LR__2766
'         r := long[mailbox]
	rdlong	_var08, _var06
	cmps	_var08, #0 wc
 if_b	jmp	#LR__2766
'     while r < 0
'     return -r                  ' return 0 for success or negated error code
	neg	result1, _var08
LR__2767
_psram_spin2_fill_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB setQos(cog, qos) : result | mailbox
_psram_spin2_setQos
	mov	_var01, arg01
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var02, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var02, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__2774
'     if cog < 0 or cog > 7 ' enforce cog id range
	cmps	_var01, #0 wc
 if_b	jmp	#LR__2770
	cmps	_var01, #8 wc
 if_b	jmp	#LR__2771
LR__2770
'         return ERR_INVALID
	neg	result1, #6
	jmp	#LR__2774
LR__2771
'     long[@qosData][cog] := qos & !$1ff
	andn	arg02, #511
	add	ptr__psram_spin2_dat__, #456
	shl	_var01, #2
	add	_var01, ptr__psram_spin2_dat__
	wrlong	arg02, _var01
'     mailbox := $7FF00 + drivercog*12
	sub	ptr__psram_spin2_dat__, #200
	rdlong	_var03, ptr__psram_spin2_dat__
	mov	_var04, _var03
	shl	_var04, #1
	add	_var04, _var03
	shl	_var04, #2
	mov	_var05, ##524032
	add	_var05, _var04
'     repeat until LOCKTRY(driverlock)
	add	ptr__psram_spin2_dat__, #4
LR__2772
	rdlong	arg01, ptr__psram_spin2_dat__
	locktry	arg01 wc
 if_ae	jmp	#LR__2772
	sub	ptr__psram_spin2_dat__, #260
'     long[mailbox] := driver.R_CONFIG + cogid()
	mov	_var04, #0
	cogid	_var04
	mov	_var02, ##-268435456
	add	_var02, _var04
	wrlong	_var02, _var05
'     repeat while long[mailbox] < 0
LR__2773
	rdlong	_var02, _var05
	cmps	_var02, #0 wc
 if_b	jmp	#LR__2773
'     LOCKREL(driverlock)
	add	ptr__psram_spin2_dat__, #260
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #260
	lockrel	arg01 wc
	mov	result1, #0
LR__2774
_psram_spin2_setQos_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PRI lookupDelay(freq) : delay | profile
_psram_spin2_lookupDelay
'     profile := @delayTable
	add	ptr__psram_spin2_dat__, #264
	mov	_var01, ptr__psram_spin2_dat__
'     delay := long[profile][0]
	rdlong	_var02, _var01
'     repeat while long[profile][1] 
	sub	ptr__psram_spin2_dat__, #264
	callpa	#(@LR__2781-@LR__2780)>>2,fcache_load_ptr_
LR__2780
	add	_var01, #4
	rdlong	result1, _var01 wz
	sub	_var01, #4
 if_e	jmp	#LR__2782
'         if freq +< long[profile][1] 
	add	_var01, #4
	rdlong	result1, _var01
	sub	_var01, #4
	cmp	arg01, result1 wc
'             quit
'         profile += 4
 if_ae	add	_var01, #4
'         delay++
 if_ae	add	_var02, #1
 if_ae	jmp	#LR__2780
LR__2781
LR__2782
	mov	result1, _var02
_psram_spin2_lookupDelay_ret
	ret

' 
' PUB start() : r
_usbnew_spin2_start
	mov	_var01, #0
'   ifnot driver_cog
	add	ptr__usbnew_spin2_dat__, ##10827
	rdbyte	_var02, ptr__usbnew_spin2_dat__ wz
	sub	ptr__usbnew_spin2_dat__, ##10827
 if_ne	jmp	#LR__2790
'     r := coginit(COGEXEC_NEW,@usb_host_start,0)
	mov	arg02, ptr__usbnew_spin2_dat__
	mov	_var01, #16
	mov	arg03, #0
	setq	arg03
	coginit	_var01, arg02 wc
 if_b	neg	_var01, #1
'     if r >= 0
	cmps	_var01, #0 wc
'       driver_cog := r+1
 if_ae	mov	_var02, _var01
 if_ae	add	_var02, #1
 if_ae	add	ptr__usbnew_spin2_dat__, ##10827
 if_ae	wrbyte	_var02, ptr__usbnew_spin2_dat__
 if_ae	sub	ptr__usbnew_spin2_dat__, ##10827
LR__2790
	mov	result1, _var01
_usbnew_spin2_start_ret
	ret

'     '' (Always enabled)
' 
' '' Get current pressed state of a keyboard key
' PUB keystate(key) : r | buf[2],tmp
_usbnew_spin2_keystate
	mov	_var03, #0
'   if key >= $E0 && key < $E8
	cmps	arg01, #224 wc
 if_b	jmp	#LR__2800
	cmps	arg01, #232 wc
 if_ae	jmp	#LR__2800
'     return not not (hkbd_report.byte[0] >> (key-$E0))
	mov	result1, #0
	add	ptr__usbnew_spin2_dat__, ##10188
	mov	_var04, arg01
	sub	_var04, #224
	rdbyte	_var05, ptr__usbnew_spin2_dat__
	shr	_var05, _var04 wz
	sub	ptr__usbnew_spin2_dat__, ##10188
 if_ne	neg	result1, #1
	jmp	#_usbnew_spin2_keystate_ret
LR__2800
'   else
'     '' Do this in inline ASM to ensure atomicity
'     tmp := @hkbd_report
	add	ptr__usbnew_spin2_dat__, ##10188
	mov	_var05, ptr__usbnew_spin2_dat__
'     org
	sub	ptr__usbnew_spin2_dat__, ##10188
	callpa	#(@LR__2802-@LR__2801)>>2,fcache_load_ptr_
LR__2801
	org	0
	setq	#1
	rdlong	_var01, _var05
	getbyte	_var06, _var01, #2
	cmp	_var06, arg01 wz
	getbyte	_var06, _var01, #3
 if_ne	cmp	_var06, arg01 wz
	getbyte	_var06, _var02, #0
 if_ne	cmp	_var06, arg01 wz
	getbyte	_var06, _var02, #1
 if_ne	cmp	_var06, arg01 wz
	getbyte	_var06, _var02, #2
 if_ne	cmp	_var06, arg01 wz
	getbyte	_var06, _var02, #3
 if_ne	cmp	_var06, arg01 wz
 if_e	neg	_var03, #1
LR__2802
	orgh
	mov	result1, _var03
_usbnew_spin2_keystate_ret
	ret

'     '' Set KEYQUEUE_SIZE to enable (recommended value: 32)
' 
' '' Return key event from buffer if there is one
' PUB get_key() : r | tail
_usbnew_spin2_get_key
'   tail := keyq_tail
	add	ptr__usbnew_spin2_dat__, ##7881
	rdbyte	_var01, ptr__usbnew_spin2_dat__
'   if keyq_head == tail
	sub	ptr__usbnew_spin2_dat__, #1
	rdbyte	_var02, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7880
	cmp	_var02, _var01 wz
'     return 0 ' No event
 if_e	mov	result1, #0
 if_e	jmp	#_usbnew_spin2_get_key_ret
'   r := keyq_data[tail]
	mov	_var02, _var01
	shl	_var02, #2
	add	ptr__usbnew_spin2_dat__, ##7882
	add	_var02, ptr__usbnew_spin2_dat__
	rdlong	result1, _var02
'   if ++tail == KEYQUEUE_SIZE
	add	_var01, #1
	cmp	_var01, #128 wz
'     tail := 0
 if_e	mov	_var01, #0
'   keyq_tail := tail
	sub	ptr__usbnew_spin2_dat__, #1
	wrbyte	_var01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7881
_usbnew_spin2_get_key_ret
	ret

' 
' '' Emulate mouse movement
' PUB mouse_move(x,y)
_usbnew_spin2_mouse_move
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
'   mouse_lock := 1
	add	ptr__usbnew_spin2_dat__, ##10421
	wrbyte	#1, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10421
'   waitus(2) ' hope driver is now done
	mov	arg01, #2
	call	#__system___waitus
'   mouse_xacc := x
	add	ptr__usbnew_spin2_dat__, ##10405
	wrlong	local01, ptr__usbnew_spin2_dat__
'   mouse_yacc := y
	add	ptr__usbnew_spin2_dat__, #4
	wrlong	local02, ptr__usbnew_spin2_dat__
'   if mouse_outptr
	sub	ptr__usbnew_spin2_dat__, ##2533
	rdlong	arg02, ptr__usbnew_spin2_dat__ wz
	sub	ptr__usbnew_spin2_dat__, ##7876
 if_e	jmp	#LR__2810
'     long[mouse_outptr] := y << 16 | x & $FFFF
	shl	local02, #16
	getword	local01, local01, #0
	or	local02, local01
	add	ptr__usbnew_spin2_dat__, ##7876
	rdlong	local01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7876
	wrlong	local02, local01
LR__2810
'   mouse_lock := 0
	add	ptr__usbnew_spin2_dat__, ##10421
	wrbyte	#0, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##10421
	mov	ptra, fp
	call	#popregs_
_usbnew_spin2_mouse_move_ret
	ret

'     '' Set HAVE_HIDPAD to enable.
'     '' Warning: never pass a device ID larger or equal than MAX_DEVICES
' 
' '' Get VID/PID pair for connected device. 0 means disconnected
' PUB hidpad_id(dev) : r
_usbnew_spin2_hidpad_id
'   return long[@hidpad_report+dev*HIDPAD_REPORT_SIZE][0]
	add	ptr__usbnew_spin2_dat__, ##10200
	mov	result1, ptr__usbnew_spin2_dat__
	mov	_var01, arg01
	shl	_var01, #3
	sub	_var01, arg01
	shl	_var01, #2
	add	result1, _var01
	rdlong	result1, result1
	sub	ptr__usbnew_spin2_dat__, ##10200
_usbnew_spin2_hidpad_id_ret
	ret

' 
' '' Get all button states for a device
' PUB hidpad_buttons(dev) : r 
_usbnew_spin2_hidpad_buttons
'   return long[@hidpad_report+dev*HIDPAD_REPORT_SIZE][5]
	add	ptr__usbnew_spin2_dat__, ##10200
	mov	result1, ptr__usbnew_spin2_dat__
	mov	_var01, arg01
	shl	_var01, #3
	sub	_var01, arg01
	shl	_var01, #2
	add	result1, _var01
	add	result1, #20
	rdlong	result1, result1
	sub	ptr__usbnew_spin2_dat__, ##10200
_usbnew_spin2_hidpad_buttons_ret
	ret

' 
' '' Get state of an axis (normalized between -32768 and 32767)
' PUB hidpad_axis(dev,axnum) : r
_usbnew_spin2_hidpad_axis
'   if axnum +>= 6
	cmp	arg02, #6 wc
'     return 0
 if_ae	mov	result1, #0
 if_ae	jmp	#_usbnew_spin2_hidpad_axis_ret
'   else 
'     return word[@hidpad_report+dev*HIDPAD_REPORT_SIZE][4+axnum] signx 15
	add	ptr__usbnew_spin2_dat__, ##10200
	mov	result1, ptr__usbnew_spin2_dat__
	mov	_var01, arg01
	shl	_var01, #3
	sub	_var01, arg01
	shl	_var01, #2
	add	result1, _var01
	mov	_var01, #4
	add	_var01, arg02
	shl	_var01, #1
	add	_var01, result1
	rdword	result1, _var01
	signx	result1, #15
	sub	ptr__usbnew_spin2_dat__, ##10200
_usbnew_spin2_hidpad_axis_ret
	ret

' 
' 
' '--------------------------------------------------------------
' '---------- Init the variables, start the cog. ----------------
' '--------------------------------------------------------------
' 
' pub start(mbox,scope,cache) :cog,base | iii
_audio096_spin2_start
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' ' mbox: PSRAM mailbox or 0 if no PSRAM
' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
' 
' mailboxaddr:=mbox 
	wrlong	local01, objptr
' scope_ptr:=scope
	add	objptr, #4
	wrlong	arg02, objptr
' cache_ptr:=cache
	add	objptr, #4
	wrlong	arg03, objptr
' base:=@channel1[0]
	add	objptr, #4
	mov	local02, objptr
' long[$40]:=mbox
	wrlong	local01, #64
' repeat iii from 0 to 7
	mov	local03, #0
	add	ptr__audio096_spin2_dat__, ##1184
	sub	objptr, #12
	callpa	#(@LR__2821-@LR__2820)>>2,fcache_load_ptr_
LR__2820
'   long[base+64*iii]:=0
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	wrlong	#0, local01
'   long[base+64*iii+4]:=0
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	add	local01, #4
	wrlong	#0, local01
'   long[base+64*iii+12]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #12
	wrlong	#0, local04
'   long[base+64*iii+16]:=2 
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #16
	wrlong	#2, local04
'   word[base+64*iii+20]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #20
	wrword	#0, local04
'   word[base+64*iii+22]:=8192
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #22
	wrword	##8192, local04
'   word[base+64*iii+24]:=4000+2*iii
	mov	local04, local03
	shl	local04, #1
	mov	local01, ##4000
	add	local01, local04
	mov	local04, local02
	mov	result2, local03
	shl	result2, #6
	add	local04, result2
	add	local04, #24
	wrword	local01, local04
'   word[base+64*iii+26]:=2
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #26
	wrword	#2, local04
'   long [base+64*iii+8]:=@null | $C0000000
	mov	local01, ptr__audio096_spin2_dat__
	bith	local01, #62
	mov	local04, local02
	mov	arg03, local03
	shl	arg03, #6
	add	local04, arg03
	add	local04, #8
	wrlong	local01, local04
'   long[base+64*iii+32]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #32
	wrlong	#0, local04
'   long[base+64*iii+36]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #36
	wrlong	#0, local04
'   long[base+64*iii+40]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #40
	wrlong	#0, local04
'   long[base+64*iii+44]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #44
	wrlong	#0, local04
'   long[base+64*iii+28]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #28
	wrlong	#0, local04
	add	local03, #1
	cmps	local03, #8 wc
 if_b	jmp	#LR__2820
LR__2821
	sub	ptr__audio096_spin2_dat__, ##1184
'   
' cog:=coginit(16,@audio,@mailboxaddr)
	mov	arg02, ptr__audio096_spin2_dat__
	mov	arg03, objptr
	mov	local04, #16
	setq	arg03
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
' waitms(100)
	mov	arg01, #100
	call	#__system___waitms
' return cog,base
	mov	result2, local02
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_audio096_spin2_start_ret
	ret

' 
' ' a simple play procedure to not poke everything. 
' 
' pub play(channel,sample,splfreq,vol,len,loop=-1) |base2
_audio096_spin2_play
	add	objptr, #12
	mov	_var01, objptr
	shl	arg01, #6
	add	_var01, arg01
	mov	arg01, _var01
	add	arg01, #12
	wrlong	arg05, arg01
	cmps	arg06, #0 wc
 if_ae	mov	arg01, _var01
 if_ae	add	arg01, #16
 if_ae	wrlong	arg06, arg01
 if_b	add	arg05, #2
 if_b	mov	arg01, _var01
 if_b	add	arg01, #16
 if_b	wrlong	arg05, arg01
	abs	arg01, arg03 wc
	qdiv	##3546895, arg01
' 
' base2:=@channel1[0]+64*channel
' 
' 
' long[base2+12]:= len
' if loop >=0 
'   long[base2+16]:= loop
	sub	objptr, #12
' else
'   long[base2+16]:= len+2
' word[base2+20]:=vol
	mov	arg01, _var01
	add	arg01, #20
	wrword	arg04, arg01
' word[base2+24]:= 3546895/splfreq 
	mov	arg04, _var01
	add	arg04, #24
' word[base2+26]:=256 ' todo: use skip to make accurate sample rate
' long[base2+28]:=$40000000    
' long[base2+32]:=0    
' long[base2+36]:=0    
' long[base2+40]:=0    
' long[base2+44]:=0    
' long[base2+8]:=sample+$C0000000     
	add	arg02, ##-1073741824
	getqx	arg01
	negc	arg01, arg01
	wrword	arg01, arg04
	mov	arg01, _var01
	add	arg01, #26
	wrword	#256, arg01
	mov	arg01, _var01
	add	arg01, #28
	wrlong	##1073741824, arg01
	mov	arg01, _var01
	add	arg01, #32
	wrlong	#0, arg01
	mov	arg01, _var01
	add	arg01, #36
	wrlong	#0, arg01
	mov	arg01, _var01
	add	arg01, #40
	wrlong	#0, arg01
	mov	arg01, _var01
	add	arg01, #44
	wrlong	#0, arg01
	add	_var01, #8
	wrlong	arg02, _var01
_audio096_spin2_play_ret
	ret

' 
' pub play8(channel,sample,splfreq,vol,len,loop=-1) |base2,i
_audio096_spin2_play8
' 
' base2:=@channel1[0]+64*channel
	add	objptr, #12
	mov	_var01, objptr
	shl	arg01, #6
	add	_var01, arg01
' long[base2]:=0
	wrlong	#0, _var01
' long[base2+8]:=sample+$40000000 
	add	arg02, ##1073741824
	mov	arg01, _var01
	add	arg01, #8
	wrlong	arg02, arg01
' if loop>=0
	cmps	arg06, #0 wc
	sub	objptr, #12
 if_b	jmp	#LR__2830
'   long[base2+12]:=loop
	mov	arg02, _var01
	add	arg02, #12
	wrlong	arg06, arg02
'   long[base2+16]:= len
	mov	arg06, _var01
	add	arg06, #16
	wrlong	arg05, arg06
	jmp	#LR__2831
LR__2830
' else
'   long[base2+12]:= len
	mov	arg06, _var01
	add	arg06, #12
	wrlong	arg05, arg06
'   long[base2+16]:= len+1
	add	arg05, #1
	mov	arg01, _var01
	add	arg01, #16
	wrlong	arg05, arg01
LR__2831
	abs	arg03, arg03 wc
	qdiv	##3546895, arg03
' word[base2+20]:=vol
	mov	arg03, _var01
	add	arg03, #20
	wrword	arg04, arg03
' word[base2+24]:= 3546895 /splfreq 
	mov	arg01, _var01
	add	arg01, #24
' word[base2+26]:=256 ' todo: use skip to make accurate sample rate
	add	_var01, #26
	getqx	arg04
	negc	arg04, arg04
	wrword	arg04, arg01
	wrword	#256, _var01
_audio096_spin2_play8_ret
	ret

' 'long[base2+28]:=$40000000
' 
'     
' pub stop(channel) 'silence it
_audio096_spin2_stop
' 
' word[@channel1[0]+64*channel+20]:=0
	add	objptr, #12
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #6
	add	_var01, _var02
	add	_var01, #20
	wrword	#0, _var01
' word[@channel1[0]+64*channel+20]:=0
	mov	_var01, objptr
	shl	arg01, #6
	add	_var01, arg01
	add	_var01, #20
	wrword	#0, _var01
	sub	objptr, #12
_audio096_spin2_stop_ret
	ret
hubexit
	jmp	#cogexit

__system___setbaud
	rdlong	muldiva_, #20
	mov	muldivb_, arg01
	call	#divide_
	callpa	#(@LR__2841-@LR__2840)>>2,fcache_load_ptr_
LR__2840
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__2840
LR__2841
	dirl	#62
	dirl	#63
	wrlong	muldivb_, ptr___system__dat__
	shl	muldivb_, #16
	mov	arg02, #7
	add	arg02, muldivb_
	wrpin	#124, #62
	wxpin	arg02, #62
	wrpin	#62, #63
	add	arg02, #20
	wxpin	arg02, #63
	dirh	#62
	dirh	#63
__system___setbaud_ret
	ret

__system___txraw
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	callpa	#(@LR__2851-@LR__2850)>>2,fcache_load_ptr_
LR__2850
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__2850
LR__2851
	rdlong	result1, ptr___system__dat__ wz
 if_e	mov	arg01, ##230400
 if_e	call	#__system___setbaud
	drvl	#62
	wypin	local01, #62
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___txraw_ret
	ret

__system___rxraw
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, ptr___system__dat__ wz
 if_e	mov	arg01, ##230400
 if_e	call	#__system___setbaud
	cmp	local01, #0 wz
 if_e	jmp	#LR__2860
	rdlong	local03, #20
	shr	local03, #10
	qmul	local01, local03
	getct	result1
	getqx	local04
	add	result1, local04
	mov	local05, result1
	jmp	#LR__2861
LR__2860
	mov	local05, #0
LR__2861
	neg	local06, #1
	mov	local07, #63
	mov	local08, #0
	add	ptr___system__dat__, #4
	rdlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
LR__2862
	testb	local09, #8 wc
	testbn	local09, #9 andc
	shr	local09, #10
 if_b	mov	local08, #1
 if_ae	testp	#63 wz
 if_nc_and_z	mov	local08, #1
 if_nc_and_z	rdpin	local09, #63
 if_nc_and_z	shr	local09, #4
LR__2863
	mov	local02, #0
	cmp	local08, #0 wz
 if_ne	neg	local02, #1
	mov	local10, #0
	mov	local03, #0
	cmp	local01, #0 wz
 if_ne	neg	local03, #1
	mov	local04, #0
	mov	local11, #0
	mov	local12, local05
	getct	result1
	mov	local13, result1
	sub	local12, local13
	cmps	local12, #0 wc
 if_b	not	local11, #0
	cmp	local11, #0 wz
 if_ne	not	local04, #0
	test	local03, local04 wz
 if_ne	not	local10, #0
	or	local02, local10 wz
 if_e	jmp	#LR__2862
	cmp	local08, #0 wz
 if_ne	mov	local06, local09
 if_ne	getbyte	local06, local06, #0
	add	ptr___system__dat__, #4
	wrlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___rxraw_ret
	ret

__system___getus
	getct	result2 wc
	getct	_var01
	add	ptr___system__dat__, #16
	rdlong	_var02, ptr___system__dat__ wz
	sub	ptr___system__dat__, #16
 if_ne	jmp	#LR__2870
	rdlong	_var02, #20
	qdiv	_var02, ##1000000
	add	ptr___system__dat__, #16
	getqx	result1
	mov	_var02, result1
	wrlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #16
LR__2870
	qdiv	result2, _var02
	getqy	result2
	setq	result2
	qdiv	_var01, _var02
	getqx	result1
__system___getus_ret
	ret

__system____builtin_memmove
	mov	_var01, arg01
	cmps	arg01, arg02 wc
 if_b	jmp	#LR__2880
	mov	_var02, arg02
	add	_var02, arg03
	cmps	arg01, _var02 wc
 if_b	jmp	#LR__2886
LR__2880
	mov	_var03, arg03
	shr	_var03, #2 wz
 if_e	jmp	#LR__2885
	callpa	#(@LR__2883-@LR__2881)>>2,fcache_load_ptr_
LR__2881
	rep	@LR__2884, _var03
LR__2882
	rdlong	_var03, arg02
	wrlong	_var03, arg01
	add	arg01, #4
	add	arg02, #4
LR__2883
LR__2884
LR__2885
	test	arg03, #2 wz
 if_ne	rdword	_var02, arg02
 if_ne	wrword	_var02, arg01
 if_ne	add	arg01, #2
 if_ne	add	arg02, #2
	test	arg03, #1 wz
 if_ne	rdbyte	_var02, arg02
 if_ne	wrbyte	_var02, arg01
	jmp	#LR__2892
LR__2886
	add	arg01, arg03
	add	arg02, arg03
	mov	_var04, arg03 wz
 if_e	jmp	#LR__2891
	callpa	#(@LR__2889-@LR__2887)>>2,fcache_load_ptr_
LR__2887
	rep	@LR__2890, _var04
LR__2888
	sub	arg01, #1
	sub	arg02, #1
	rdbyte	_var02, arg02
	wrbyte	_var02, arg01
LR__2889
LR__2890
LR__2891
LR__2892
	mov	result1, _var01
__system____builtin_memmove_ret
	ret

__system____builtin_strcpy
	mov	_var01, arg01
	callpa	#(@LR__2901-@LR__2900)>>2,fcache_load_ptr_
LR__2900
	rdbyte	result1, arg02 wz
	wrbyte	result1, arg01
	add	arg02, #1
	add	arg01, #1
 if_ne	jmp	#LR__2900
LR__2901
	mov	result1, _var01
__system____builtin_strcpy_ret
	ret

__system____topofstack
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	add	fp, #4
	wrlong	arg01, fp
	mov	result1, fp
	sub	fp, #4
	mov	ptra, fp
	call	#popregs_
__system____topofstack_ret
	ret

__system___lockmem
	mov	result1, #0
	cogid	result1
	add	result1, #256
LR__2910
	rdlong	_var01, arg01 wz
 if_e	wrlong	result1, arg01
 if_e	rdlong	_var01, arg01
 if_e	rdlong	_var01, arg01
	cmp	_var01, result1 wz
 if_ne	jmp	#LR__2910
__system___lockmem_ret
	ret

__system___string_cmp
	callpa	#(@LR__2921-@LR__2920)>>2,fcache_load_ptr_
LR__2920
	rdbyte	_var01, arg01
	rdbyte	_var02, arg02
	mov	_var03, _var01
	sub	_var03, _var02 wz
	add	arg01, #1
	add	arg02, #1
 if_ne	jmp	#LR__2922
	cmp	_var01, #0 wz
 if_ne	cmp	_var02, #0 wz
 if_ne	jmp	#LR__2920
LR__2921
LR__2922
	mov	result1, _var03
__system___string_cmp_ret
	ret

__system___string_concat
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__2931-@LR__2930)>>2,fcache_load_ptr_
LR__2930
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__2930
LR__2931
	sub	local03, arg01
	mov	local04, local03
	mov	arg01, local02
	mov	local03, arg01
	callpa	#(@LR__2933-@LR__2932)>>2,fcache_load_ptr_
LR__2932
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__2932
LR__2933
	sub	local03, arg01
	mov	arg01, local04
	add	arg01, local03
	add	arg01, #1
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__2934
	mov	arg01, local05
	mov	arg02, local01
	mov	arg03, local04
	call	#__system____builtin_memmove
	mov	arg01, local05
	add	arg01, local04
	add	local03, #1
	mov	arg02, local02
	mov	arg03, local03
	call	#__system____builtin_memmove
LR__2934
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
__system___string_concat_ret
	ret

__system___tx
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	cmp	local01, #10 wz
 if_ne	jmp	#LR__2940
	add	ptr___system__dat__, #8
	rdlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	local02, #2 wz
 if_ne	mov	arg01, #13
 if_ne	call	#__system___txraw
LR__2940
	mov	arg01, local01
	call	#__system___txraw
	mov	ptra, fp
	call	#popregs_
__system___tx_ret
	ret

__system___rx
	mov	COUNT_, #1
	call	#pushregs_
LR__2950
	mov	arg01, #0
	call	#__system___rxraw
	mov	local01, result1
	cmp	local01, ##-1 wz
 if_e	jmp	#LR__2950
	cmp	local01, #13 wz
 if_ne	jmp	#LR__2951
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	result1, #2 wz
 if_ne	mov	local01, #10
LR__2951
	add	ptr___system__dat__, #8
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	arg01, #1 wz
 if_e	jmp	#LR__2954
	cmp	local01, #127 wz
 if_ne	jmp	#LR__2952
	mov	arg01, #8
	call	#__system___tx
	jmp	#LR__2953
LR__2952
	mov	arg01, local01
	call	#__system___tx
LR__2953
LR__2954
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system___rx_ret
	ret

__system___pinwrite
	mov	_var01, arg01
	and	_var01, #31
	test	arg01, #32 wz
	shr	arg01, #6
	bmask	arg01, arg01
	shl	arg01, _var01
	shl	arg02, _var01
 if_e	jmp	#LR__2960
	or	dirb, arg01
	mov	_var01, outb
	andn	_var01, arg01
	and	arg02, arg01
	or	_var01, arg02
	mov	outb, _var01
	jmp	#LR__2961
LR__2960
	or	dira, arg01
	mov	_var01, outa
	andn	_var01, arg01
	and	arg02, arg01
	or	_var01, arg02
	mov	outa, _var01
LR__2961
__system___pinwrite_ret
	ret

__system___basic_read_line
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	mov	local03, #24
	mov	local04, #0
	mov	arg01, #24
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__2973
LR__2970
	mov	arg01, local01
	call	#__system___basic_get_char
	mov	local06, result1
	cmps	local06, #1 wc
 if_b	jmp	#LR__2972
	cmp	local06, #10 wz
 if_ne	jmp	#LR__2971
	cmp	local04, #0 wz
 if_ne	cmps	local02, #1 wc
 if_a	sub	local02, #1
	jmp	#LR__2972
LR__2971
	cmp	local06, #13 wz
 if_e	mov	local04, #1
 if_ne	mov	local04, #0
	cmp	local06, #8 wz
 if_ne	cmp	local06, #127 wz
 if_e	cmps	local02, #1 wc
 if_nc_and_z	sub	local02, #1
 if_e	jmp	#LR__2970
	mov	arg03, local05
	add	arg03, local02
	wrbyte	local06, arg03
	add	local02, #1
	cmp	local02, local03 wz
 if_ne	jmp	#LR__2970
	mov	arg01, local03
	add	arg01, #32
	call	#__system___gc_alloc_managed
	mov	local06, result1 wz
 if_e	mov	result1, local06
 if_e	jmp	#LR__2973
	mov	arg01, local06
	mov	arg02, local05
	mov	arg03, local03
	call	#__system____builtin_memmove
	add	local03, #32
	mov	arg01, local05
	call	#__system___gc_free
	mov	local05, local06
	jmp	#LR__2970
LR__2972
	mov	local06, local05
	add	local06, local02
	wrbyte	#0, local06
	mov	result1, local05
LR__2973
	mov	ptra, fp
	call	#popregs_
__system___basic_read_line_ret
	ret

__system___waitms
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__2981-@LR__2980)>>2,fcache_load_ptr_
LR__2980
	cmps	_var01, ##1000 wc
 if_b	jmp	#LR__2982
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000
	jmp	#LR__2980
LR__2981
LR__2982
	cmps	_var01, #1 wc
 if_b	jmp	#LR__2983
	qmul	_var01, _var03
	mov	arg03, ##1000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	arg01
	addct1	arg01, _var02
	waitct1
LR__2983
__system___waitms_ret
	ret

__system___waitus
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__2991-@LR__2990)>>2,fcache_load_ptr_
LR__2990
	cmps	_var01, ##1000000 wc
 if_b	jmp	#LR__2992
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000000
	jmp	#LR__2990
LR__2991
LR__2992
	cmps	_var01, #1 wc
 if_b	jmp	#LR__2993
	qmul	_var01, _var03
	mov	arg03, ##1000000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	result1
	addct1	_var02, result1
	waitct1
LR__2993
__system___waitus_ret
	ret

__system___mount
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	neg	local03, #1
 if_e	neg	result1, #1
 if_e	jmp	#LR__3015
	rdbyte	result1, local01
	cmp	result1, #47 wz
 if_ne	jmp	#LR__3002
	mov	arg01, local01
	mov	local04, arg01
	callpa	#(@LR__3001-@LR__3000)>>2,fcache_load_ptr_
LR__3000
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3000
LR__3001
	sub	local04, arg01
	mov	result1, local04
	cmps	result1, #16 wc
 if_b	jmp	#LR__3003
LR__3002
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__3015
LR__3003
	mov	local05, #0
LR__3004
	cmps	local05, #4 wc
 if_ae	jmp	#LR__3009
	mov	arg01, local05
	shl	arg01, #2
	add	ptr___system__dat__, #100
	add	arg01, ptr___system__dat__
	rdlong	result1, arg01 wz
	sub	ptr___system__dat__, #100
 if_e	cmps	local03, #0 wc
 if_c_and_z	mov	local03, local05
 if_c_and_z	jmp	#LR__3008
	mov	arg01, local05
	shl	arg01, #2
	add	ptr___system__dat__, #100
	add	arg01, ptr___system__dat__
	rdlong	arg01, arg01
	sub	ptr___system__dat__, #100
	mov	local04, arg01
	callpa	#(@LR__3006-@LR__3005)>>2,fcache_load_ptr_
LR__3005
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3005
LR__3006
	sub	local04, arg01
	mov	local06, local04
	mov	arg01, local06
	add	arg01, local01
	rdbyte	result1, arg01
	cmp	result1, #47 wz
 if_ne	mov	local07, local06
 if_ne	add	local07, local01
 if_ne	rdbyte	arg01, local07 wz
 if_ne	jmp	#LR__3007
	mov	arg03, local05
	shl	arg03, #2
	add	ptr___system__dat__, #100
	add	arg03, ptr___system__dat__
	rdlong	arg02, arg03
	mov	arg01, local01
	mov	arg03, local06
	sub	ptr___system__dat__, #100
	call	#__system__strncmp
	cmp	result1, #0 wz
 if_e	mov	local03, local05
 if_e	jmp	#LR__3009
LR__3007
LR__3008
	add	local05, #1
	jmp	#LR__3004
LR__3009
	cmp	local03, ##-1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#11, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__3015
	mov	local05, local03
	mov	local07, local05
	shl	local07, #2
	add	ptr___system__dat__, #116
	add	local07, ptr___system__dat__
	rdlong	local06, local07 wz
	sub	ptr___system__dat__, #116
 if_e	jmp	#LR__3010
	add	local06, #76
	rdlong	local07, local06 wz
	sub	local06, #76
 if_e	jmp	#LR__3010
	add	local06, #76
	rdlong	local07, local06
	mov	local03, local07
	zerox	local07, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	local06, local05
	shl	local06, #2
	add	ptr___system__dat__, #100
	add	local06, ptr___system__dat__
	rdlong	arg01, local06
	mov	local06, objptr
	mov	objptr, local07
	sub	ptr___system__dat__, #100
	call	local03
	mov	objptr, local06
LR__3010
	mov	local08, local05
	shl	local08, #2
	add	ptr___system__dat__, #116
	add	local08, ptr___system__dat__
	wrlong	local02, local08
	cmp	local02, #0 wz
	sub	ptr___system__dat__, #116
 if_ne	jmp	#LR__3011
	shl	local05, #2
	add	ptr___system__dat__, #100
	add	local05, ptr___system__dat__
	wrlong	#0, local05
	sub	ptr___system__dat__, #100
	jmp	#LR__3014
LR__3011
	mov	local09, local05
	shl	local09, #4
	add	ptr___system__dat__, #36
	add	local09, ptr___system__dat__
	mov	arg01, local09
	mov	arg02, local01
	mov	arg03, #16
	sub	ptr___system__dat__, #36
	call	#__system__strncpy
	add	local02, #72
	rdlong	local08, local02 wz
	sub	local02, #72
 if_e	jmp	#LR__3013
	add	local02, #72
	rdlong	local08, local02
	mov	local10, local08
	zerox	local08, #19
	shr	local10, #20
	shl	local10, #2
	add	local10, __methods__
	rdlong	local10, local10
	mov	arg01, local09
	mov	local11, objptr
	mov	objptr, local08
	call	local10
	mov	objptr, local11
	mov	arg01, result1 wz
 if_e	jmp	#LR__3012
	mov	local08, local05
	shl	local08, #2
	add	ptr___system__dat__, #116
	add	local08, ptr___system__dat__
	wrlong	#0, local08
	shl	local05, #2
	sub	ptr___system__dat__, #16
	add	local05, ptr___system__dat__
	wrlong	#0, local05
	neg	arg01, arg01 wz
	sub	ptr___system__dat__, #68
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__3015
LR__3012
LR__3013
	shl	local05, #2
	add	ptr___system__dat__, #100
	add	local05, ptr___system__dat__
	wrlong	local09, local05
	sub	ptr___system__dat__, #100
LR__3014
	mov	result1, #0
LR__3015
	mov	ptra, fp
	call	#popregs_
__system___mount_ret
	ret

__system___chdir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #64
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg02, fp
	sub	fp, #8
	call	#__system__stat
	add	fp, #60
	wrlong	result1, fp
	sub	fp, #60
	cmp	result1, #0 wz
 if_ne	add	fp, #60
 if_ne	rdlong	result1, fp
 if_ne	sub	fp, #60
 if_ne	jmp	#LR__3022
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #16
	and	arg01, ##61440
	cmp	arg01, ##4096 wz
 if_ne	add	ptr___system__dat__, #32
 if_ne	wrlong	#13, ptr___system__dat__
 if_ne	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_ne	jmp	#LR__3022
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	rdbyte	arg03, arg03
	cmp	arg03, #47 wz
 if_ne	jmp	#LR__3020
	add	ptr___system__dat__, #132
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #132
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	mov	arg03, #256
	call	#__system__strncpy
	jmp	#LR__3021
LR__3020
	add	ptr___system__dat__, #388
	mov	arg01, ptr___system__dat__
	add	fp, #56
	wrlong	arg01, fp
	sub	fp, #56
	sub	ptr___system__dat__, #256
	mov	arg02, ptr___system__dat__
	sub	ptr___system__dat__, #132
	mov	arg03, #256
	call	#__system__strncpy
	add	fp, #56
	rdlong	arg01, fp
	sub	fp, #52
	rdlong	arg02, fp
	sub	fp, #4
	add	ptr___system__dat__, #132
	mov	arg03, ptr___system__dat__
	sub	ptr___system__dat__, #132
	call	#__system____getvfsforfile
LR__3021
	mov	result1, #0
LR__3022
	mov	ptra, fp
	call	#popregs_
__system___chdir_ret
	ret

__system____getvfsforfile
	mov	COUNT_, #14
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	callpa	#(@LR__3031-@LR__3030)>>2,fcache_load_ptr_
LR__3030
	rdbyte	result1, local02
	cmp	result1, #47 wz
 if_e	add	local02, #1
 if_e	rdbyte	local04, local02
 if_e	sub	local02, #1
 if_e	cmp	local04, #47 wz
 if_e	add	local02, #1
 if_e	jmp	#LR__3030
LR__3031
	rdbyte	local04, local02
	cmp	local04, #47 wz
 if_ne	jmp	#LR__3032
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncpy
	jmp	#LR__3034
LR__3032
	add	ptr___system__dat__, #132
	mov	arg02, ptr___system__dat__
	sub	ptr___system__dat__, #132
	mov	arg01, local01
	mov	arg03, #256
	call	#__system__strncpy
	rdbyte	local04, local02 wz
 if_e	jmp	#LR__3033
	rdbyte	local04, local02
	cmp	local04, #46 wz
 if_e	add	local02, #1
 if_e	rdbyte	local05, local02
 if_e	sub	local02, #1
 if_e	mov	local06, local05
 if_e	zerox	local06, #7 wz
 if_e	jmp	#LR__3033
	rdbyte	local05, local01
	cmp	local05, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local04, local01
 if_e	sub	local01, #1
 if_e	cmps	local04, #0 wz
 if_ne	mov	arg02, ##@LR__5160
 if_ne	mov	arg01, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncat
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #256
	call	#__system__strncat
LR__3033
LR__3034
	mov	arg01, local01
	call	#__system___normalizeName
	rdbyte	local04, local01 wz
 if_e	jmp	#LR__3035
	rdbyte	local04, local01
	cmp	local04, #47 wz
 if_e	add	local01, #1
 if_e	rdbyte	local06, local01
 if_e	sub	local01, #1
 if_e	cmps	local06, #0 wz
 if_ne	jmp	#LR__3036
LR__3035
	add	ptr___system__dat__, ##644
	mov	result1, ptr___system__dat__
	sub	ptr___system__dat__, ##644
	jmp	#LR__3050
LR__3036
	mov	local07, #0
LR__3037
	cmps	local07, #4 wc
 if_ae	jmp	#LR__3049
	mov	local06, local07
	shl	local06, #2
	add	ptr___system__dat__, #100
	add	local06, ptr___system__dat__
	rdlong	local06, local06 wz
	sub	ptr___system__dat__, #100
 if_e	jmp	#LR__3048
	mov	local04, local07
	shl	local04, #2
	add	ptr___system__dat__, #100
	add	local04, ptr___system__dat__
	rdlong	arg01, local04
	sub	ptr___system__dat__, #100
	mov	local08, arg01
	callpa	#(@LR__3039-@LR__3038)>>2,fcache_load_ptr_
LR__3038
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__3038
LR__3039
	sub	local08, arg01
	mov	local09, local08
	mov	local04, local09
	add	local04, local01
	rdbyte	local06, local04
	cmp	local06, #47 wz
 if_ne	mov	local10, local09
 if_ne	add	local10, local01
 if_ne	rdbyte	local05, local10 wz
 if_ne	jmp	#LR__3047
	mov	arg03, local07
	shl	arg03, #2
	add	ptr___system__dat__, #100
	add	arg03, ptr___system__dat__
	rdlong	arg02, arg03
	mov	arg03, local09
	mov	arg01, local01
	sub	ptr___system__dat__, #100
	call	#__system__strncmp
	cmps	result1, #0 wz
 if_ne	jmp	#LR__3047
	mov	local11, local07
	shl	local11, #2
	add	ptr___system__dat__, #116
	add	local11, ptr___system__dat__
	rdlong	local12, local11
	sub	ptr___system__dat__, #116
	callpa	#(@LR__3041-@LR__3040)>>2,fcache_load_ptr_
LR__3040
	mov	local06, local09
	add	local06, #1
	add	local06, local01
	rdbyte	local11, local06
	cmp	local11, #46 wz
 if_ne	jmp	#LR__3042
	mov	local11, local09
	add	local11, #2
	add	local11, local01
	rdbyte	local10, local11
	cmp	local10, #47 wz
 if_ne	mov	local13, local09
 if_ne	add	local13, #2
 if_ne	add	local13, local01
 if_ne	rdbyte	local14, local13 wz
 if_e	add	local09, #1
 if_e	jmp	#LR__3040
LR__3041
LR__3042
	cmp	local03, #0 wz
 if_ne	mov	arg01, local03
 if_ne	mov	arg02, local01
 if_ne	mov	arg03, #256
 if_ne	call	#__system__strncpy
	mov	arg02, local01
	add	arg02, local09
	add	arg02, #1
	mov	arg01, local01
	call	#__system____builtin_strcpy
	mov	arg01, local01
	mov	local08, arg01
	callpa	#(@LR__3044-@LR__3043)>>2,fcache_load_ptr_
LR__3043
	rdbyte	result1, local08 wz
 if_ne	add	local08, #1
 if_ne	jmp	#LR__3043
LR__3044
	sub	local08, arg01
	mov	local09, local08
LR__3045
	cmps	local09, #1 wc
 if_b	jmp	#LR__3046
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #47 wz
 if_e	mov	local11, local09
 if_e	add	local11, local01
 if_e	wrbyte	#0, local11
 if_e	sub	local09, #1
 if_e	jmp	#LR__3045
	mov	local04, local09
	add	local04, local01
	rdbyte	local11, local04
	cmp	local11, #46 wz
 if_ne	jmp	#LR__3046
	cmps	local09, #2 wc
 if_b	jmp	#LR__3046
	mov	local14, local09
	sub	local14, #1
	add	local14, local01
	rdbyte	local05, local14
	cmp	local05, #47 wz
 if_ne	jmp	#LR__3046
	mov	local04, local09
	sub	local04, #1
	add	local04, local01
	wrbyte	#0, local04
	sub	local09, #2
	jmp	#LR__3045
LR__3046
	mov	result1, local12
	jmp	#LR__3050
LR__3047
LR__3048
	add	local07, #1
	jmp	#LR__3037
LR__3049
	add	ptr___system__dat__, ##1312
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, ##1312
LR__3050
	mov	ptra, fp
	call	#popregs_
__system____getvfsforfile_ret
	ret

__system___basic_open
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	mov	local04, #0
	call	#__system____getftab
	mov	local05, result1 wz
 if_ne	jmp	#LR__3060
	mov	arg01, abortchain
	mov	arg02, #12
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__3069
LR__3060
	add	local05, #8
	rdlong	result1, local05 wz
	sub	local05, #8
 if_ne	mov	arg01, local05
 if_ne	call	#__system___closeraw
	cmp	local01, #0 wz
 if_e	cmp	local02, #0 wz
 if_e	cmp	local03, #0 wz
 if_e	jmp	#LR__3062
	mov	arg01, #12
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_ne	jmp	#LR__3061
	mov	arg01, abortchain
	mov	arg02, #7
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__3069
LR__3061
	wrlong	#0, local04
	add	local04, #4
	wrlong	#0, local04
	sub	local04, #4
	wrlong	local04, local05
LR__3062
	cmp	local01, #0 wz
 if_e	jmp	#LR__3063
	wrlong	local01, local04
	mov	result1, local04
	or	result1, ##158334976
	add	local05, #28
	wrlong	result1, local05
	sub	local05, #28
	jmp	#LR__3064
LR__3063
	add	local05, #28
	wrlong	#0, local05
	sub	local05, #28
LR__3064
	cmp	local02, #0 wz
 if_e	jmp	#LR__3065
	add	local04, #4
	wrlong	local02, local04
	sub	local04, #4
	mov	result1, local04
	or	result1, ##159383552
	add	local05, #32
	wrlong	result1, local05
	sub	local05, #32
	jmp	#LR__3066
LR__3065
	add	local05, #32
	wrlong	#0, local05
	sub	local05, #32
LR__3066
	cmp	local03, #0 wz
 if_e	jmp	#LR__3067
	add	local04, #8
	wrlong	local03, local04
	sub	local04, #8
	or	local04, ##160432128
	add	local05, #36
	wrlong	local04, local05
	sub	local05, #36
	jmp	#LR__3068
LR__3067
	add	local05, #36
	wrlong	#0, local05
	sub	local05, #36
LR__3068
	add	local05, #8
	wrlong	#7, local05
	mov	result1, #0
LR__3069
	mov	ptra, fp
	call	#popregs_
__system___basic_open_ret
	ret

__system___basic_open_string
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	call	#__system____getftab
	mov	local03, result1 wz
 if_ne	jmp	#LR__3070
	mov	arg01, abortchain
	mov	arg02, #12
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__3072
LR__3070
	add	local03, #8
	rdlong	arg04, local03 wz
	sub	local03, #8
 if_ne	mov	arg01, local03
 if_ne	call	#__system___closeraw
	mov	arg02, local01
	mov	arg03, local02
	mov	arg01, local03
	mov	arg04, #438
	call	#__system___openraw
	mov	local04, result1
	cmps	local04, #0 wc
 if_ae	jmp	#LR__3071
	add	ptr___system__dat__, #32
	rdlong	arg02, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	arg01, abortchain
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__3072
LR__3071
	mov	result1, local04
LR__3072
	mov	ptra, fp
	call	#popregs_
__system___basic_open_string_ret
	ret

__system___basic_print_char
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	call	#__system___gettxfunc
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3080
	mov	local03, local02
	zerox	local02, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local02
	call	local03
	mov	objptr, local01
	mov	result1, #1
LR__3080
	mov	ptra, fp
	call	#popregs_
__system___basic_print_char_ret
	ret

__system___basic_print_string
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	call	#__system___gettxfunc
	mov	local03, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3090
	cmp	local01, #0 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local03
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	call	#__system___fmtstr
LR__3090
	mov	ptra, fp
	call	#popregs_
__system___basic_print_string_ret
	ret

__system___basic_print_integer
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	call	#__system___gettxfunc
	mov	local04, result1 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local04
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	mov	arg04, local03
 if_ne	call	#__system___fmtnum
	mov	ptra, fp
	call	#popregs_
__system___basic_print_integer_ret
	ret

__system___basic_print_unsigned
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	call	#__system___gettxfunc
	mov	arg01, result1 wz
 if_e	mov	result1, #0
 if_ne	bith	local02, #58
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	mov	arg04, local03
 if_ne	call	#__system___fmtnum
	mov	ptra, fp
	call	#popregs_
__system___basic_print_unsigned_ret
	ret

__system___basic_get_char
	mov	COUNT_, #3
	call	#pushregs_
	call	#__system___getrxfunc
	mov	local01, result1 wz
 if_e	neg	result1, #1
 if_e	jmp	#LR__3100
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
LR__3100
	mov	ptra, fp
	call	#popregs_
__system___basic_get_char_ret
	ret

__system___basic_put
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg05
	qmul	arg04, local01
	mov	local02, arg01
	mov	local03, arg03
	cmp	arg02, #0 wz
 if_ne	sub	arg02, #1
 if_ne	mov	arg01, local02
 if_ne	mov	arg03, #0
	getqx	local04
 if_ne	call	#__system__lseek
	mov	arg02, local03
	mov	arg03, local04
	mov	arg01, local02
	call	#__system__write
	mov	local04, result1
	cmps	local04, #1 wc
 if_b	jmp	#LR__3110
	mov	muldiva_, local04
	mov	muldivb_, local01
	call	#divide_
	mov	local04, muldivb_
LR__3110
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
__system___basic_put_ret
	ret

__system___basic_get
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg05
	qmul	arg04, local01
	mov	local02, arg01
	mov	local03, arg03
	cmp	arg02, #0 wz
 if_ne	sub	arg02, #1
 if_ne	mov	arg01, local02
 if_ne	mov	arg03, #0
	getqx	local04
 if_ne	call	#__system__lseek
	mov	arg02, local03
	mov	arg03, local04
	mov	arg01, local02
	call	#__system__read
	mov	local04, result1
	cmps	local04, #1 wc
 if_b	jmp	#LR__3120
	mov	muldiva_, local04
	mov	muldivb_, local01
	call	#divide_
	mov	local04, muldivb_
LR__3120
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
__system___basic_get_ret
	ret

__system___fmtchar
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	getbyte	arg03, arg03, #0
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #4
	mov	arg03, fp
	sub	fp, #12
	call	#__system___fmtstr
	mov	ptra, fp
	call	#popregs_
__system___fmtchar_ret
	ret

__system___fmtstr
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg04, local02, #0
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__3131-@LR__3130)>>2,fcache_load_ptr_
LR__3130
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3130
LR__3131
	sub	local04, arg01
	cmp	arg04, #0 wz
 if_ne	fles	local04, arg04 wcz
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #2
	call	#__system___fmtpad
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	mov	result1, local05
 if_b	jmp	#LR__3134
	cmps	local04, #1 wc
 if_b	jmp	#LR__3133
	mov	local06, local04
LR__3132
	mov	local07, local01
	mov	local08, local01
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	rdbyte	arg01, local03
	mov	local09, objptr
	mov	objptr, local07
	add	local03, #1
	call	local08
	mov	objptr, local09
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_b	jmp	#LR__3134
	add	local05, local09
	djnz	local06, #LR__3132
LR__3133
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #1
	call	#__system___fmtpad
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_ae	add	local05, local09
 if_ae	mov	result1, local05
LR__3134
	mov	ptra, fp
	call	#popregs_
__system___fmtstr_ret
	ret

__system___fmtnum
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, ptra
	mov	local06, local05
	mov	local07, #0
	mov	local08, local02
	shr	local08, #16
	and	local08, #63
	getbyte	local09, local02, #0
	mov	local10, local02
	shr	local10, #26
	and	local10, #3
	mov	local11, local10
	cmps	local08, #1 wc
	add	ptra, #68
 if_ae	sub	local08, #1
	cmps	local09, #65 wc
 if_b	cmp	local09, #0 wz
 if_nc_or_z	mov	local09, #64
	cmp	local11, #3 wz
 if_e	mov	local11, #0
 if_ne	cmps	local03, #0 wc
 if_c_and_nz	mov	local11, #4
 if_c_and_nz	neg	local03, local03
	cmp	local11, #0 wz
 if_e	jmp	#LR__3143
	mov	local07, #1
	cmp	local08, local09 wz
 if_ne	jmp	#LR__3141
	djnz	local08, #LR__3140
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #35
	call	#__system___fmtchar
	jmp	#LR__3147
LR__3140
LR__3141
	cmp	local11, #2 wz
 if_e	mov	local10, local06
 if_e	add	local06, #1
 if_e	wrbyte	#32, local10
 if_e	jmp	#LR__3142
	cmp	local11, #4 wz
 if_e	wrbyte	#45, local06
 if_e	add	local06, #1
 if_ne	wrbyte	#43, local06
 if_ne	add	local06, #1
LR__3142
LR__3143
	mov	arg01, local06
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local08
	mov	arg05, #0
	testbn	local02, #29 wz
 if_ne	mov	arg05, #1
	call	#__system___uitoa
	add	local07, result1
	cmps	local07, local09 wcz
 if_be	jmp	#LR__3146
	callpa	#(@LR__3145-@LR__3144)>>2,fcache_load_ptr_
LR__3144
	mov	local10, local09
	cmps	local10, #1 wc
	sub	local09, #1
 if_ae	mov	local10, local06
 if_ae	add	local06, #1
 if_ae	wrbyte	#35, local10
 if_ae	jmp	#LR__3144
LR__3145
	wrbyte	#0, local06
LR__3146
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local05
	call	#__system___fmtstr
LR__3147
	mov	ptra, fp
	call	#popregs_
__system___fmtnum_ret
	ret

__system___fmtfloat
	mov	COUNT_, #16
	call	#pushregs_
	add	ptra, #292
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg04, fp
	add	fp, #12
	wrlong	#10, fp
	add	fp, #8
	wrlong	#0, fp
	add	fp, #8
	wrlong	#0, fp
	add	fp, #8
	wrlong	#0, fp
	add	fp, #4
	wrlong	#2, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #4
	wrlong	#0, fp
	add	fp, #24
	wrlong	#0, fp
	add	fp, #104
	mov	local01, fp
	sub	fp, #8
	wrlong	local01, fp
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #188
	rdlong	local01, fp
	shr	local01, #16
	and	local01, #63
	add	fp, #176
	wrlong	local01, fp
	sub	fp, #176
	rdlong	local01, fp
	shr	local01, #28
	and	local01, #1
	add	fp, #264
	wrlong	local01, fp
	sub	fp, #88
	rdlong	local01, fp wz
	sub	fp, #184
 if_ne	jmp	#LR__3151
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #97 wz
 if_ne	jmp	#LR__3150
	add	fp, #184
	wrlong	#13, fp
	sub	fp, #132
	wrlong	#1, fp
	sub	fp, #52
	jmp	#LR__3152
LR__3150
	add	fp, #184
	wrlong	#6, fp
	sub	fp, #184
	jmp	#LR__3152
LR__3151
	add	fp, #184
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #184
LR__3152
	add	fp, #8
	rdlong	local01, fp
	shr	local01, #22
	and	local01, #3
	add	fp, #260
	wrlong	local01, fp
	sub	fp, #260
	rdlong	local01, fp
	shr	local01, #29
	and	local01, #1
	add	fp, #180
	wrlong	local01, fp
	sub	fp, #180
	rdlong	local01, fp
	getbyte	local01, local01, #1
	add	fp, #96
	wrlong	local01, fp
	sub	fp, #96
	rdlong	local01, fp
	getbyte	local01, local01, #0
	add	fp, #100
	wrlong	local01, fp
	mov	local01, #0
	sub	fp, #92
	rdlong	arg05, fp
	cmp	arg05, #101 wz
 if_e	mov	local01, #1
	add	fp, #20
	wrlong	local01, fp
	add	fp, #152
	rdlong	local02, fp wz
 if_ne	mov	local01, #69
 if_e	mov	local01, #101
	sub	fp, #140
	wrlong	local01, fp
	sub	fp, #32
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #97 wz
 if_ne	jmp	#LR__3153
	add	fp, #36
	wrlong	#1, fp
	add	fp, #152
	rdlong	local02, fp wz
 if_ne	mov	local01, #80
 if_e	mov	local01, #112
	sub	fp, #140
	wrlong	local01, fp
	sub	fp, #20
	wrlong	#2, fp
	add	fp, #28
	wrlong	#1, fp
	add	fp, #132
	rdlong	local02, fp wz
 if_ne	mov	local01, #88
 if_e	mov	local01, #120
	sub	fp, #124
	wrlong	local01, fp
	sub	fp, #64
LR__3153
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #35 wz
 if_ne	jmp	#LR__3156
	add	fp, #72
	wrlong	#1, fp
	add	fp, #200
	rdlong	local01, fp wz
	sub	fp, #272
 if_e	jmp	#LR__3154
	add	fp, #16
	wrlong	#102, fp
	add	fp, #256
	wrlong	#0, fp
	sub	fp, #272
	jmp	#LR__3155
LR__3154
	add	fp, #272
	wrlong	#1, fp
	sub	fp, #272
LR__3155
LR__3156
	add	fp, #8
	rdlong	local01, fp
	shr	local01, #26
	and	local01, #3
	add	fp, #92
	wrlong	local01, fp
	sub	fp, #88
	rdlong	result1, fp
	sub	fp, #12
	shr	result1, #31 wz
 if_e	jmp	#LR__3157
	add	fp, #44
	wrlong	#45, fp
	sub	fp, #32
	rdlong	result1, fp
	bitnot	result1, #31
	wrlong	result1, fp
	sub	fp, #12
	jmp	#LR__3159
LR__3157
	add	fp, #100
	rdlong	local01, fp
	sub	fp, #100
	cmp	local01, #1 wz
 if_e	add	fp, #44
 if_e	wrlong	#43, fp
 if_e	sub	fp, #44
 if_e	jmp	#LR__3158
	add	fp, #100
	rdlong	local01, fp
	sub	fp, #100
	cmp	local01, #2 wz
 if_e	add	fp, #44
 if_e	wrlong	#32, fp
 if_e	sub	fp, #44
LR__3158
LR__3159
	add	fp, #8
	rdlong	local01, fp
	shr	local01, #24
	and	local01, #3
	add	fp, #60
	wrlong	local01, fp
	mov	local01, #0
	sub	fp, #24
	rdlong	local03, fp wz
	sub	fp, #44
 if_ne	jmp	#LR__3160
	add	fp, #28
	rdlong	local04, fp
	sub	fp, #28
	mov	local05, local04
	cmp	local05, #10 wz
 if_e	jmp	#LR__3161
LR__3160
	xor	local01, #1
LR__3161
	add	fp, #60
	wrlong	local01, fp
	sub	fp, #60
	cmp	local01, #0 wz
 if_e	jmp	#LR__3163
	add	fp, #68
	rdlong	local05, fp
	sub	fp, #68
	mov	local03, local05
	cmp	local03, #2 wz
 if_ne	jmp	#LR__3163
	add	fp, #268
	rdlong	local06, fp
	sub	fp, #268
	mov	local04, local06
	cmp	local04, #2 wz
 if_e	jmp	#LR__3163
	add	fp, #192
	rdlong	arg01, fp
	sub	fp, #148
	rdlong	arg02, fp
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #64
	call	#__system__emitsign_0518
	add	fp, #276
	wrlong	result1, fp
	sub	fp, #276
	cmps	result1, #0 wc
 if_b	add	fp, #276
 if_b	rdlong	result1, fp
 if_b	sub	fp, #276
 if_b	jmp	#LR__3213
	add	fp, #192
	rdlong	local01, fp
	add	fp, #84
	rdlong	local05, fp
	mov	local03, local05
	add	local01, local05
	sub	fp, #84
	wrlong	local01, fp
	sub	fp, #88
	rdlong	local01, fp wz
	sub	fp, #104
 if_e	jmp	#LR__3162
	add	fp, #104
	rdlong	local01, fp
	add	fp, #172
	rdlong	local03, fp
	sub	local01, local03
	sub	fp, #172
	wrlong	local01, fp
	sub	fp, #104
	cmps	local01, #0 wc
 if_b	add	fp, #104
 if_b	wrlong	#0, fp
 if_b	sub	fp, #104
	add	fp, #8
	rdlong	local01, fp
	bitl	local01, #232
	wrlong	local01, fp
	add	fp, #96
	rdlong	local05, fp
	mov	local03, local05
	shl	local03, #8
	or	local01, local03
	sub	fp, #96
	wrlong	local01, fp
	sub	fp, #8
LR__3162
	add	fp, #60
	wrlong	#0, fp
	sub	fp, #60
LR__3163
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#__system____builtin_ilogb
	cmp	result1, ##2147483647 wz
 if_ne	jmp	#LR__3165
	add	fp, #44
	rdlong	local01, fp wz
	sub	fp, #44
 if_e	jmp	#LR__3164
	add	fp, #192
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #148
	rdlong	local04, fp
	sub	fp, #44
	wrbyte	local04, local02
LR__3164
	add	fp, #192
	rdlong	arg01, fp
	sub	fp, #192
	mov	arg02, ##@LR__5161
	call	#__system____builtin_strcpy
	jmp	#LR__3201
LR__3165
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	mov	arg01, local02
	call	#__system____builtin_ilogb
	cmp	result1, ##-2147483648 wz
 if_ne	jmp	#LR__3167
	add	fp, #44
	rdlong	local01, fp wz
	sub	fp, #44
 if_e	jmp	#LR__3166
	add	fp, #192
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #148
	rdlong	local04, fp
	sub	fp, #44
	wrbyte	local04, local02
LR__3166
	add	fp, #192
	rdlong	arg01, fp
	sub	fp, #192
	mov	arg02, ##@LR__5162
	call	#__system____builtin_strcpy
	jmp	#LR__3201
LR__3167
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #103 wz
 if_ne	add	fp, #16
 if_ne	rdlong	local03, fp
 if_ne	sub	fp, #16
 if_ne	cmp	local03, #35 wz
 if_ne	jmp	#LR__3172
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	add	fp, #152
	rdlong	arg04, fp
	sub	fp, #156
	rdlong	arg05, fp
	sub	fp, #28
	call	#__system__disassemble_0516
	add	fp, #16
	rdlong	local01, fp
	sub	fp, #16
	cmp	local01, #35 wz
 if_ne	jmp	#LR__3169
	add	fp, #32
	rdlong	local01, fp
	add	fp, #152
	rdlong	local03, fp
	sub	fp, #184
	cmps	local01, local03 wcz
 if_a	add	fp, #36
 if_a	wrlong	#1, fp
 if_a	sub	fp, #36
 if_a	jmp	#LR__3175
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmps	local01, #0 wc
 if_ae	jmp	#LR__3168
	add	fp, #184
	rdlong	local01, fp
	neg	local01, local01
	sub	fp, #152
	rdlong	local03, fp
	sub	fp, #32
	cmps	local03, local01 wcz
 if_be	add	fp, #36
 if_be	wrlong	#1, fp
 if_be	sub	fp, #36
	jmp	#LR__3175
LR__3168
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmps	local01, #1 wc
 if_b	jmp	#LR__3175
	add	fp, #184
	rdlong	local01, fp
	sub	fp, #152
	rdlong	local03, fp
	sub	local01, local03
	add	fp, #152
	wrlong	local01, fp
	sub	fp, #184
	jmp	#LR__3175
LR__3169
	mov	local01, #0
	add	fp, #8
	rdlong	local02, fp
	shr	local02, #28
	and	local02, #1 wz
 if_e	mov	local01, #1
	add	fp, #44
	wrlong	local01, fp
	sub	fp, #20
	rdlong	local01, fp
	add	fp, #152
	rdlong	local03, fp
	sub	fp, #184
	cmps	local01, local03 wc
 if_ae	jmp	#LR__3170
	add	fp, #32
	rdlong	local04, fp
	sub	fp, #32
	cmps	local04, ##-4 wc
 if_ae	jmp	#LR__3171
LR__3170
	add	fp, #36
	wrlong	#1, fp
	sub	fp, #36
	jmp	#LR__3175
LR__3171
	add	fp, #184
	rdlong	local04, fp
	sub	fp, #152
	rdlong	local03, fp
	sub	local04, local03
	add	fp, #152
	wrlong	local04, fp
	sub	fp, #172
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	neg	arg04, local04
	sub	fp, #4
	rdlong	arg05, fp
	sub	fp, #28
	call	#__system__disassemble_0516
	jmp	#LR__3175
LR__3172
	add	fp, #36
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__3173
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	add	fp, #152
	rdlong	arg04, fp
	sub	fp, #156
	rdlong	arg05, fp
	sub	fp, #28
	call	#__system__disassemble_0516
	jmp	#LR__3174
LR__3173
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	add	fp, #12
	mov	arg03, fp
	add	fp, #152
	rdlong	local04, fp
	add	local04, #1
	neg	arg04, local04
	sub	fp, #156
	rdlong	arg05, fp
	sub	fp, #28
	call	#__system__disassemble_0516
LR__3174
LR__3175
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	cmp	local01, #2 wz
 if_ne	jmp	#LR__3178
	add	fp, #28
	wrlong	#16, fp
	sub	fp, #28
LR__3176
	add	fp, #20
	rdlong	local01, fp wz
	sub	fp, #20
 if_e	jmp	#LR__3177
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #20
	cmp	local03, ##16777216 wc
 if_ae	jmp	#LR__3177
	add	fp, #20
	rdlong	local01, fp
	shl	local01, #1
	wrlong	local01, fp
	sub	fp, #20
	jmp	#LR__3176
LR__3177
LR__3178
	add	fp, #112
	mov	arg01, fp
	sub	fp, #92
	rdlong	arg02, fp
	add	fp, #8
	rdlong	arg03, fp
	add	fp, #160
	rdlong	arg05, fp
	sub	fp, #188
	mov	arg04, #1
	call	#__system___uitoa
	add	fp, #88
	wrlong	result1, fp
	sub	fp, #56
	rdlong	local01, fp
	sub	fp, #32
	cmps	local01, #0 wc
 if_ae	jmp	#LR__3179
	add	fp, #96
	wrlong	#45, fp
	add	fp, #80
	mov	arg01, fp
	sub	fp, #144
	rdlong	local03, fp
	neg	arg02, local03
	add	fp, #24
	rdlong	arg04, fp
	add	fp, #132
	rdlong	local06, fp
	sub	fp, #188
	mov	local04, local06
	mov	arg03, #10
	mov	arg05, local04
	call	#__system___uitoa
	add	fp, #92
	wrlong	result1, fp
	sub	fp, #92
	jmp	#LR__3180
LR__3179
	add	fp, #96
	wrlong	#43, fp
	add	fp, #80
	mov	arg01, fp
	sub	fp, #144
	rdlong	arg02, fp
	add	fp, #24
	rdlong	arg04, fp
	add	fp, #132
	rdlong	local06, fp
	sub	fp, #188
	mov	local04, local06
	mov	arg03, #10
	mov	arg05, local04
	call	#__system___uitoa
	add	fp, #92
	wrlong	result1, fp
	sub	fp, #92
LR__3180
	add	fp, #36
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__3181
	add	fp, #80
	wrlong	#0, fp
	sub	fp, #4
	wrlong	#0, fp
	add	fp, #108
	rdlong	local01, fp
	add	local01, #1
	sub	fp, #100
	wrlong	local01, fp
	sub	fp, #84
	jmp	#LR__3184
LR__3181
	add	fp, #32
	rdlong	local01, fp
	sub	fp, #32
	cmps	local01, #0 wc
 if_ae	jmp	#LR__3182
	add	fp, #32
	rdlong	local02, fp
	add	fp, #48
	wrlong	local02, fp
	sub	fp, #4
	wrlong	local02, fp
	sub	fp, #44
	rdlong	local01, fp
	add	fp, #152
	rdlong	local03, fp
	add	local01, local03
	add	local01, #1
	sub	fp, #100
	wrlong	local01, fp
	sub	fp, #84
	jmp	#LR__3183
LR__3182
	add	fp, #76
	wrlong	#0, fp
	sub	fp, #44
	rdlong	local01, fp
	add	fp, #48
	wrlong	local01, fp
	add	fp, #104
	rdlong	local03, fp
	add	local01, local03
	add	local01, #1
	sub	fp, #100
	wrlong	local01, fp
	sub	fp, #84
LR__3183
LR__3184
	add	fp, #84
	rdlong	local01, fp
	sub	fp, #8
	rdlong	local03, fp
	sub	local01, local03
	add	local01, #1
	sub	fp, #36
	wrlong	local01, fp
	add	fp, #4
	rdlong	local01, fp wz
	sub	fp, #44
 if_ne	add	fp, #40
 if_ne	rdlong	local03, fp
 if_ne	add	local03, #1
 if_ne	wrlong	local03, fp
 if_ne	sub	fp, #40
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	cmp	local01, #16 wz
 if_e	add	fp, #40
 if_e	rdlong	local01, fp
 if_e	add	local01, #2
 if_e	wrlong	local01, fp
 if_e	sub	fp, #40
	add	fp, #36
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__3185
	add	fp, #40
	rdlong	local01, fp
	mov	local03, #2
	add	fp, #52
	rdlong	local05, fp
	add	local03, local05
	add	local01, local03
	sub	fp, #52
	wrlong	local01, fp
	sub	fp, #40
LR__3185
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #40
	cmps	local01, #65 wc
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__3213
	add	fp, #60
	rdlong	local01, fp wz
	sub	fp, #60
 if_e	jmp	#LR__3186
	add	fp, #192
	rdlong	arg01, fp
	sub	fp, #148
	rdlong	arg02, fp
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #64
	call	#__system__emitsign_0518
	add	fp, #280
	wrlong	result1, fp
	sub	fp, #280
	cmps	result1, #0 wc
 if_b	add	fp, #280
 if_b	rdlong	result1, fp
 if_b	sub	fp, #280
 if_b	jmp	#LR__3213
	add	fp, #192
	rdlong	local01, fp
	add	fp, #88
	rdlong	local03, fp
	add	local01, local03
	sub	fp, #88
	wrlong	local01, fp
	sub	fp, #192
LR__3186
	add	fp, #76
	rdlong	local01, fp
	sub	fp, #52
	wrlong	local01, fp
	sub	fp, #24
	callpa	#(@LR__3192-@LR__3187)>>2,fcache_load_ptr_
LR__3187
	add	fp, #24
	rdlong	local02, fp
	add	fp, #60
	rdlong	local05, fp
	sub	fp, #84
	cmps	local02, local05 wc
 if_ae	jmp	#LR__3193
	add	fp, #24
	rdlong	local06, fp
	sub	fp, #24
	cmps	local06, #0 wc
 if_b	jmp	#LR__3188
	add	fp, #24
	rdlong	local06, fp
	add	fp, #64
	rdlong	local07, fp
	sub	fp, #88
	cmps	local06, local07 wc
 if_ae	jmp	#LR__3188
	add	fp, #192
	rdlong	local08, fp
	mov	local07, local08
	add	local07, #1
	wrlong	local07, fp
	sub	fp, #168
	rdlong	local07, fp
	mov	local09, local07
	add	fp, #88
	mov	local10, fp
	add	local09, fp
	rdbyte	local11, local09
	wrbyte	local11, local08
	sub	fp, #112
	jmp	#LR__3189
LR__3188
	add	fp, #192
	rdlong	local08, fp
	mov	local09, local08
	add	local09, #1
	wrlong	local09, fp
	sub	fp, #192
	mov	local09, #48
	wrbyte	#48, local08
LR__3189
	add	fp, #24
	rdlong	local06, fp
	add	fp, #56
	rdlong	local12, fp
	sub	fp, #80
	cmp	local06, local12 wz
 if_ne	jmp	#LR__3191
	add	fp, #272
	rdlong	local07, fp
	sub	fp, #272
	mov	local09, local07 wz
 if_ne	jmp	#LR__3190
	add	fp, #84
	rdlong	local11, fp
	mov	local10, local11
	sub	local10, #1
	sub	fp, #60
	rdlong	local13, fp
	sub	fp, #24
	mov	local14, local13
	cmps	local14, local10 wc
 if_ae	jmp	#LR__3191
LR__3190
	add	fp, #192
	rdlong	local08, fp
	mov	local12, local08
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #192
	mov	local09, #46
	wrbyte	#46, local08
LR__3191
	add	fp, #24
	rdlong	local15, fp
	mov	local12, local15
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #24
	jmp	#LR__3187
LR__3192
LR__3193
	add	fp, #52
	rdlong	local01, fp wz
	sub	fp, #52
 if_e	jmp	#LR__3197
	add	fp, #192
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #192
	callpa	#(@LR__3195-@LR__3194)>>2,fcache_load_ptr_
LR__3194
	add	fp, #192
	rdlong	local01, fp
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #196
	cmps	local01, local03 wcz
 if_be	jmp	#LR__3196
	add	fp, #192
	rdlong	local06, fp
	sub	fp, #192
	rdbyte	local04, local06
	cmp	local04, #48 wz
 if_ne	jmp	#LR__3196
	add	fp, #192
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #192
	jmp	#LR__3194
LR__3195
LR__3196
	add	fp, #192
	rdlong	local02, fp
	sub	fp, #192
	rdbyte	local01, local02
	cmp	local01, #46 wz
 if_e	add	fp, #192
 if_e	rdlong	local01, fp
 if_e	sub	local01, #1
 if_e	wrlong	local01, fp
 if_e	sub	fp, #192
	add	fp, #192
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #192
LR__3197
	add	fp, #36
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__3200
	add	fp, #192
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #144
	rdlong	local04, fp
	wrbyte	local04, local02
	add	fp, #144
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #96
	rdlong	local04, fp
	wrbyte	local04, local02
	sub	fp, #72
	wrlong	#0, fp
	sub	fp, #24
LR__3198
	add	fp, #24
	rdlong	local02, fp
	add	fp, #68
	rdlong	local05, fp
	sub	fp, #92
	cmps	local02, local05 wc
 if_ae	jmp	#LR__3199
	add	fp, #192
	rdlong	local08, fp
	mov	local12, local08
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #168
	rdlong	local07, fp
	mov	local09, local07
	add	fp, #152
	mov	local10, fp
	add	local09, fp
	rdbyte	local11, local09
	wrbyte	local11, local08
	sub	fp, #152
	rdlong	local12, fp
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #24
	jmp	#LR__3198
LR__3199
LR__3200
	add	fp, #192
	rdlong	local01, fp
	sub	fp, #192
	wrbyte	#0, local01
LR__3201
	add	fp, #108
	rdlong	local01, fp wz
	sub	fp, #108
 if_e	jmp	#LR__3212
	add	fp, #72
	rdlong	local03, fp wz
	sub	fp, #72
 if_e	jmp	#LR__3212
	add	fp, #196
	rdlong	arg01, fp
	sub	fp, #196
	mov	local16, arg01
	callpa	#(@LR__3203-@LR__3202)>>2,fcache_load_ptr_
LR__3202
	rdbyte	result1, local16 wz
 if_ne	add	local16, #1
 if_ne	jmp	#LR__3202
LR__3203
	sub	local16, arg01
	mov	local04, local16
	add	fp, #108
	rdlong	local06, fp
	sub	fp, #108
	cmps	local04, local06 wcz
 if_be	jmp	#LR__3212
	add	fp, #196
	rdlong	local01, fp
	add	fp, #92
	wrlong	local01, fp
	sub	fp, #252
	rdlong	local01, fp wz
	sub	fp, #36
 if_e	jmp	#LR__3204
	add	fp, #184
	wrlong	#0, fp
	sub	fp, #76
	rdlong	local01, fp
	add	fp, #176
	wrlong	local01, fp
	sub	fp, #284
	jmp	#LR__3205
LR__3204
	add	fp, #108
	rdlong	local01, fp
	sub	local01, #1
	add	fp, #76
	rdlong	local03, fp
	sub	local01, local03
	add	fp, #100
	wrlong	local01, fp
	sub	fp, #284
LR__3205
	callpa	#(@LR__3207-@LR__3206)>>2,fcache_load_ptr_
LR__3206
	add	fp, #284
	rdlong	local01, fp wz
	sub	fp, #284
 if_e	jmp	#LR__3208
	add	fp, #288
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	wrbyte	#42, local02
	sub	fp, #4
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #284
	jmp	#LR__3206
LR__3207
LR__3208
	add	fp, #184
	rdlong	local01, fp wz
	sub	fp, #184
 if_e	jmp	#LR__3211
	add	fp, #288
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	wrbyte	#46, local02
	sub	fp, #4
	wrlong	#0, fp
	sub	fp, #284
LR__3209
	add	fp, #284
	rdlong	local02, fp
	sub	fp, #100
	rdlong	local05, fp
	sub	fp, #184
	cmps	local02, local05 wc
 if_ae	jmp	#LR__3210
	add	fp, #288
	rdlong	local08, fp
	mov	local12, local08
	add	local12, #1
	wrlong	local12, fp
	wrbyte	#42, local08
	sub	fp, #4
	rdlong	local12, fp
	add	local12, #1
	wrlong	local12, fp
	sub	fp, #284
	jmp	#LR__3209
LR__3210
LR__3211
	add	fp, #288
	rdlong	local02, fp
	mov	local03, local02
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #288
	wrbyte	#0, local02
LR__3212
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #188
	rdlong	arg03, fp
	sub	fp, #196
	call	#__system___fmtstr
LR__3213
	mov	ptra, fp
	call	#popregs_
__system___fmtfloat_ret
	ret

__system__Left_S
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	cmps	local02, #1 wc
 if_b	mov	result1, ##@LR__5163
 if_b	jmp	#LR__3223
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__3221-@LR__3220)>>2,fcache_load_ptr_
LR__3220
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__3220
LR__3221
	sub	local03, arg01
	mov	result1, local03
	cmps	result1, local02 wcz
 if_be	mov	result1, local01
 if_be	jmp	#LR__3223
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_e	jmp	#LR__3222
	mov	arg01, local04
	mov	arg02, local01
	mov	arg03, local02
	call	#__system____builtin_memmove
	add	local02, local04
	wrbyte	#0, local02
LR__3222
	mov	result1, local04
LR__3223
	mov	ptra, fp
	call	#popregs_
__system__Left_S_ret
	ret

__system__Right_S
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	cmps	local02, #1 wc
 if_b	mov	result1, ##@LR__5164
 if_b	jmp	#LR__3233
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__3231-@LR__3230)>>2,fcache_load_ptr_
LR__3230
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__3230
LR__3231
	sub	local03, arg01
	mov	result1, local03
	mov	local04, result1
	cmps	local04, local02 wcz
 if_be	mov	result1, local01
 if_be	jmp	#LR__3233
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__3232
	sub	local04, local02
	add	local04, local01
	add	local02, #1
	mov	arg01, local05
	mov	arg02, local04
	mov	arg03, local02
	call	#__system____builtin_memmove
LR__3232
	mov	result1, local05
LR__3233
	mov	ptra, fp
	call	#popregs_
__system__Right_S_ret
	ret

__system__Mid_S
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	cmps	arg03, #1 wc
 if_b	mov	result1, ##@LR__5165
 if_b	jmp	#LR__3243
	sub	local02, #1
	fges	local02, #0 wc
	mov	arg01, local01
	mov	local03, arg01
	callpa	#(@LR__3241-@LR__3240)>>2,fcache_load_ptr_
LR__3240
	rdbyte	result1, local03 wz
 if_ne	add	local03, #1
 if_ne	jmp	#LR__3240
LR__3241
	sub	local03, arg01
	mov	result1, local03
	mov	arg02, result1
	cmps	arg02, local02 wc
 if_b	mov	result1, ##@LR__5166
 if_b	jmp	#LR__3243
	mov	local04, arg02
	sub	local04, local02
	cmps	local04, arg03 wcz
 if_a	mov	local04, arg03
	mov	arg01, local04
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__3242
	add	local02, local01
	mov	arg01, local05
	mov	arg02, local02
	mov	arg03, local04
	call	#__system____builtin_memmove
	add	local04, local05
	wrbyte	#0, local04
LR__3242
	mov	result1, local05
LR__3243
	mov	ptra, fp
	call	#popregs_
__system__Mid_S_ret
	ret

__system__Chr_S
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #3
	call	#__system___gc_alloc_managed
	cmps	result1, #0 wz
 if_ne	wrbyte	local01, result1
 if_ne	add	result1, #1
 if_ne	wrbyte	#0, result1
 if_ne	sub	result1, #1
	mov	ptra, fp
	call	#popregs_
__system__Chr_S_ret
	ret

__system__str_S
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #16
	call	#__system___gc_alloc_managed
	mov	local02, result1 wz
 if_e	jmp	#LR__3250
	mov	arg01, ptra
	add	ptra, #8
	wrlong	local02, arg01
	add	arg01, #4
	wrlong	#0, arg01
	sub	arg01, #4
	or	arg01, ##163577856
	mov	arg02, #0
	mov	arg03, local01
	mov	arg04, #103
	call	#__system___fmtfloat
LR__3250
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
__system__str_S_ret
	ret

__system__Number_S
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	mov	local03, arg03
 if_ne	jmp	#LR__3262
	mov	local02, #1
	mov	local04, local03
	mov	local05, #1
	callpa	#(@LR__3261-@LR__3260)>>2,fcache_load_ptr_
LR__3260
	mov	local06, #0
	cmp	local04, local01 wcz
 if_be	neg	local06, #1
	cmp	local05, local04 wc
	subx	local07, local07
	test	local06, local07 wz
 if_ne	qmul	local04, local03
 if_ne	mov	local05, local04
 if_ne	add	local02, #1
 if_ne	getqx	local04
 if_ne	jmp	#LR__3260
LR__3261
LR__3262
	fle	local02, #32 wc
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local06, result1
	mov	local07, local02
	add	local07, local06
	wrbyte	#0, local07
	callpa	#(@LR__3264-@LR__3263)>>2,fcache_load_ptr_
LR__3263
	cmp	local02, #1 wc
 if_b	jmp	#LR__3265
	qdiv	local01, local03
	sub	local02, #1
	mov	local07, local02
	add	local07, local06
	getqy	local08
	cmp	local08, #10 wc
 if_b	add	local08, #48
 if_ae	add	local08, #55
	wrbyte	local08, local07
	getqx	local01
	jmp	#LR__3263
LR__3264
LR__3265
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system__Number_S_ret
	ret

__system__LCase_S
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__3271-@LR__3270)>>2,fcache_load_ptr_
LR__3270
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__3270
LR__3271
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, ##@LR__5167
 if_e	jmp	#LR__3277
	mov	arg01, local02
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local03, result1 wz
 if_e	jmp	#LR__3276
	neg	local04, #1
	callpa	#(@LR__3275-@LR__3272)>>2,fcache_load_ptr_
LR__3272
	add	local04, #1
	mov	local05, local04
	add	local05, local01
	rdbyte	local06, local05
	cmps	local06, #65 wc
 if_b	jmp	#LR__3273
	cmps	local06, #91 wc
 if_b	mov	local07, local04
 if_b	add	local07, local03
 if_b	add	local06, #32
 if_b	wrbyte	local06, local07
 if_b	jmp	#LR__3274
LR__3273
	mov	local07, local04
	add	local07, local03
	wrbyte	local06, local07
LR__3274
	mov	local06, local02
	sub	local06, #1
	cmp	local04, local06 wz
 if_ne	jmp	#LR__3272
LR__3275
	add	local02, local03
	wrbyte	#0, local02
	mov	result1, local03
	jmp	#LR__3277
LR__3276
	mov	result1, local03
LR__3277
	mov	ptra, fp
	call	#popregs_
__system__LCase_S_ret
	ret

__system__LTrim_S
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__3281-@LR__3280)>>2,fcache_load_ptr_
LR__3280
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__3280
LR__3281
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, ##@LR__5168
 if_e	jmp	#LR__3286
	mov	local03, #0
	mov	local04, local02
LR__3282
	cmps	local03, local04 wc
 if_ae	jmp	#LR__3285
	mov	arg03, local03
	add	arg03, local01
	rdbyte	arg03, arg03
	cmp	arg03, #32 wz
 if_e	jmp	#LR__3284
	mov	arg01, local02
	sub	arg01, local03
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local05, result1 wz
 if_e	jmp	#LR__3283
	mov	arg02, local03
	add	arg02, local01
	mov	arg03, local02
	sub	arg03, local03
	mov	arg01, local05
	call	#__system____builtin_memmove
	sub	local02, local03
	add	local02, local05
	wrbyte	#0, local02
	mov	result1, local05
	jmp	#LR__3286
LR__3283
	mov	result1, local05
	jmp	#LR__3286
LR__3284
	add	local03, #1
	jmp	#LR__3282
LR__3285
	mov	result1, local01
LR__3286
	mov	ptra, fp
	call	#popregs_
__system__LTrim_S_ret
	ret

__system__RTrim_S
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__3291-@LR__3290)>>2,fcache_load_ptr_
LR__3290
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__3290
LR__3291
	sub	local02, arg01
	mov	result1, local02
	mov	local02, result1 wz
 if_e	mov	result1, ##@LR__5169
 if_e	jmp	#LR__3295
	mov	local03, local02
	sub	local03, #1
LR__3292
	mov	arg02, local03
	add	arg02, local01
	rdbyte	local02, arg02
	cmp	local02, #32 wz
 if_e	jmp	#LR__3294
	mov	arg01, local03
	add	arg01, #2
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_e	jmp	#LR__3293
	mov	arg03, local03
	add	arg03, #1
	mov	arg01, local04
	mov	arg02, local01
	call	#__system____builtin_memmove
	add	local03, #1
	add	local03, local04
	wrbyte	#0, local03
	mov	result1, local04
	jmp	#LR__3295
LR__3293
	mov	result1, local04
	jmp	#LR__3295
LR__3294
	sub	local03, #1
	cmps	local03, #0 wc
 if_ae	jmp	#LR__3292
	mov	result1, ##@LR__5170
LR__3295
	mov	ptra, fp
	call	#popregs_
__system__RTrim_S_ret
	ret

__system__Instr
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__3301-@LR__3300)>>2,fcache_load_ptr_
LR__3300
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3300
LR__3301
	sub	local04, arg01
	mov	local05, local04
	mov	arg01, local02
	mov	local04, arg01
	callpa	#(@LR__3303-@LR__3302)>>2,fcache_load_ptr_
LR__3302
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3302
LR__3303
	sub	local04, arg01
	mov	result1, local04
	mov	arg04, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3307
	cmp	local05, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3307
	cmps	local01, arg04 wcz
 if_a	mov	result1, #0
 if_a	jmp	#LR__3307
	cmps	local01, #1 wc
 if_b	mov	local01, #1
	rdbyte	local06, local03
	cmp	local05, #1 wz
 if_ne	jmp	#LR__3304
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local01
	mov	arg04, #0
	call	#__system____ScanForChar
	jmp	#LR__3307
LR__3304
	mov	local07, local01
LR__3305
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local07
	mov	arg04, #0
	call	#__system____ScanForChar
	mov	local07, result1 wz
 if_e	jmp	#LR__3306
	mov	arg03, local05
	mov	arg01, local02
	mov	arg02, local07
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, local03
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__3307
	add	local07, local05
	jmp	#LR__3305
LR__3306
	mov	result1, #0
LR__3307
	mov	ptra, fp
	call	#popregs_
__system__Instr_ret
	ret

__system__InstrRev
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__3311-@LR__3310)>>2,fcache_load_ptr_
LR__3310
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3310
LR__3311
	sub	local04, arg01
	mov	local05, local04
	mov	arg01, local02
	mov	local04, arg01
	callpa	#(@LR__3313-@LR__3312)>>2,fcache_load_ptr_
LR__3312
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__3312
LR__3313
	sub	local04, arg01
	mov	result1, local04
	mov	arg04, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3317
	cmp	local05, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3317
	cmps	local01, arg04 wcz
 if_a	mov	local01, arg04
	cmps	local01, #1 wc
 if_b	mov	local01, #1
	rdbyte	local06, local03
	cmp	local05, #1 wz
 if_ne	jmp	#LR__3314
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local01
	mov	arg04, #1
	call	#__system____ScanForChar
	jmp	#LR__3317
LR__3314
	mov	local07, local05
	sub	local07, #1
LR__3315
	mov	arg01, local02
	mov	arg02, local06
	mov	arg03, local07
	mov	arg04, #1
	call	#__system____ScanForChar
	mov	local07, result1 wz
 if_e	jmp	#LR__3316
	mov	arg03, local05
	mov	arg01, local02
	mov	arg02, local07
	call	#__system__Mid_S
	mov	arg01, result1
	mov	arg02, local03
	call	#__system___string_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__3317
	sub	local07, local05
	jmp	#LR__3315
LR__3316
	mov	result1, #0
LR__3317
	mov	ptra, fp
	call	#popregs_
__system__InstrRev_ret
	ret

__system___remove
	mov	COUNT_, #6
	call	#pushregs_
	add	ptr___system__dat__, #388
	mov	local01, ptr___system__dat__
	mov	arg02, arg01
	mov	arg01, local01
	mov	arg03, #0
	sub	ptr___system__dat__, #388
	call	#__system____getvfsforfile
	mov	local02, result1 wz
 if_e	jmp	#LR__3320
	add	local02, #32
	rdlong	arg01, local02 wz
	sub	local02, #32
 if_ne	jmp	#LR__3321
LR__3320
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__3324
LR__3321
	add	local02, #64
	rdlong	local03, local02
	mov	local04, local03
	sub	local02, #64
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local06, result1
	cmp	local06, ##-14 wz
 if_ne	jmp	#LR__3322
	add	local02, #60
	rdlong	local06, local02
	mov	local03, local06
	zerox	local06, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local06
	call	local03
	mov	objptr, local05
	mov	local06, result1
LR__3322
	cmp	local06, #0 wz
 if_e	jmp	#LR__3323
	neg	arg01, local06 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__3324
LR__3323
	mov	result1, #0
LR__3324
	mov	ptra, fp
	call	#popregs_
__system___remove_ret
	ret

__system___mkdir
	mov	COUNT_, #5
	call	#pushregs_
	add	ptr___system__dat__, #388
	mov	local01, ptr___system__dat__
	mov	arg02, arg01
	mov	arg01, local01
	mov	arg03, #0
	sub	ptr___system__dat__, #388
	call	#__system____getvfsforfile
	mov	local02, result1 wz
 if_e	jmp	#LR__3330
	add	local02, #32
	rdlong	arg02, local02 wz
	sub	local02, #32
 if_ne	jmp	#LR__3331
LR__3330
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__3333
LR__3331
	add	local02, #56
	rdlong	local03, local02
	mov	local04, local03
	zerox	local03, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #511
	mov	local05, objptr
	mov	objptr, local03
	call	local04
	mov	objptr, local05
	mov	arg01, result1 wz
 if_e	jmp	#LR__3332
	neg	arg01, arg01 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__3333
LR__3332
	mov	result1, #0
LR__3333
	mov	ptra, fp
	call	#popregs_
__system___mkdir_ret
	ret

__system___strerror
	cmps	arg01, #0 wc
 if_b	jmp	#LR__3340
	cmps	arg01, #26 wc
 if_b	jmp	#LR__3341
LR__3340
	mov	arg01, #25
LR__3341
	shl	arg01, #2
	add	ptr___system__dat__, ##728
	add	arg01, ptr___system__dat__
	rdlong	result1, arg01
	sub	ptr___system__dat__, ##728
__system___strerror_ret
	ret

__system___int64_shl
	test	arg03, #32 wz
 if_ne	mov	arg02, arg01
 if_ne	mov	arg01, #0
	test	arg03, #31 wz
 if_e	jmp	#LR__3350
	shl	arg02, arg03
	mov	result1, arg01
	neg	result2, arg03
	shr	result1, result2
	or	arg02, result1
	shl	arg01, arg03
LR__3350
	mov	result2, arg02
	mov	result1, arg01
__system___int64_shl_ret
	ret

__system___usepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #20
	test	arg01, _var01 wz
 if_e	add	ptr___system__dat__, #24
 if_e	rdlong	_var02, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #24
 if_e	test	arg02, _var02 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___usepins_ret
	add	ptr___system__dat__, #20
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg01
	wrlong	_var02, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var02, ptr___system__dat__
	or	_var02, arg02
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #24
	neg	result1, #1
__system___usepins_ret
	ret

__system___freepins
	add	ptr___system__dat__, #20
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg01
	wrlong	_var01, ptr___system__dat__
	add	ptr___system__dat__, #4
	rdlong	_var01, ptr___system__dat__
	andn	_var01, arg02
	wrlong	_var01, ptr___system__dat__
	sub	ptr___system__dat__, #24
__system___freepins_ret
	ret

__system___float_fromuns
	mov	arg03, arg01 wz
 if_e	mov	result1, arg03
 if_e	jmp	#LR__3360
	encod	arg02, arg03 wc
 if_b	add	arg02, #1
	sub	arg02, #1
	mov	arg01, #31
	sub	arg01, arg02
	shl	arg03, arg01
	shr	arg03, #2
	mov	arg01, #0
	call	#__system___float_Pack
LR__3360
__system___float_fromuns_ret
	ret

__system___float_add
	mov	COUNT_, #15
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	mov	local04, local01
	mov	local05, local04
	zerox	local05, #22
	mov	local06, local04
	shl	local06, #1
	shr	local06, #24
	shr	local04, #31
	mov	arg01, local02
	mov	result1, arg01
	mov	local07, result1
	mov	local08, local07
	zerox	local08, #22
	mov	local09, local07
	shl	local09, #1
	shr	local09, #24
	mov	local10, local09
	shr	local07, #31
	mov	local11, #0
	mov	local12, #0
	cmp	local06, local10 wc
 if_ae	cmp	local06, local10 wz
 if_a	jmp	#LR__3370
 if_ae	cmp	local05, local08 wc
 if_ae	jmp	#LR__3370
	mov	local13, local05
	mov	local05, local08
	mov	local08, local13
	mov	local13, local06
	mov	local06, local10
	mov	local10, local13
	mov	local13, local04
	mov	local04, local07
	mov	local07, local13
LR__3370
	cmp	local06, #255 wz
 if_e	jmp	#LR__3385
	cmp	local06, #0 wz
 if_e	jmp	#LR__3387
	bith	local05, #23
LR__3371
	cmp	local10, #0 wz
 if_e	jmp	#LR__3391
	bith	local08, #23
LR__3372
	sub	local06, #127
	sub	local10, #127
	mov	local14, local06
	sub	local14, local10
	callpa	#(@LR__3374-@LR__3373)>>2,fcache_load_ptr_
LR__3373
	cmps	local14, #32 wc
 if_b	jmp	#LR__3375
	mov	local09, local08
	cmp	local11, #0 wz
	wrnz	local11
	or	local09, local11
	mov	local11, local09
	mov	local08, #0
	sub	local14, #32
	jmp	#LR__3373
LR__3374
LR__3375
	cmp	local14, #0 wz
 if_e	jmp	#LR__3376
	mov	local13, local08
	mov	local10, #32
	sub	local10, local14
	shl	local13, local10
	mov	local10, local11
	mov	local09, #32
	sub	local09, local14
	shl	local10, local09 wz
	shr	local11, local14
	shr	local08, local14
	or	local11, local13
	mov	local15, #0
 if_ne	mov	local15, #1
	or	local11, local15
LR__3376
	mov	local15, local04
	xor	local15, local07
	test	local15, #1 wz
 if_e	jmp	#LR__3377
	not	local08, local08
	not	local11, local11
	add	local11, #1 wz
	mov	local15, #0
 if_e	mov	local15, #1
	add	local08, local15
LR__3377
	add	local12, local11 wc
	addx	local05, local08
	cmps	local05, #0 wc
 if_ae	jmp	#LR__3378
	xor	local04, #1
	not	local05, local05
	not	local12, local12
	add	local12, #1 wz
	mov	local15, #0
 if_e	mov	local15, #1
	add	local05, local15
LR__3378
	cmp	local05, ##16777216 wc
 if_b	jmp	#LR__3379
	add	local06, #1
	mov	local14, local12
	and	local14, #1
	shr	local12, #1
	mov	local15, local05
	shl	local15, #31
	or	local12, local15
	or	local12, local14
	shr	local05, #1
	jmp	#LR__3384
LR__3379
	cmp	local05, ##8388608 wc
 if_ae	jmp	#LR__3383
	cmp	local05, #0 wz
 if_e	cmp	local12, #0 wz
 if_e	or	local04, #8
 if_e	andn	local04, #1
 if_e	jmp	#LR__3382
LR__3380
	cmp	local05, ##8388608 wc
 if_ae	jmp	#LR__3381
	add	local12, local12 wc
	addx	local05, local05
	sub	local06, #1
	jmp	#LR__3380
LR__3381
LR__3382
LR__3383
LR__3384
	mov	arg01, local05
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	call	#__system__pack_0630
	jmp	#LR__3395
LR__3385
	cmp	local10, #255 wz
 if_ne	jmp	#LR__3386
	cmp	local07, local04 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__3395
LR__3386
	cmp	local05, #0 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__3395
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	or	arg04, #2
	mov	arg01, local05
	call	#__system__pack_0630
	jmp	#LR__3395
LR__3387
	cmp	local05, #0 wz
 if_e	jmp	#LR__3390
	shl	local05, #1
	callpa	#(@LR__3389-@LR__3388)>>2,fcache_load_ptr_
LR__3388
	cmp	local05, ##8388608 wc
 if_b	mov	local15, local06
 if_b	sub	local15, #1
 if_b	mov	local06, local15
 if_b	shl	local05, #1
 if_b	jmp	#LR__3388
LR__3389
	jmp	#LR__3371
LR__3390
	and	local04, local07
	mov	arg04, local04
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0630
	jmp	#LR__3395
LR__3391
	cmp	local08, #0 wz
 if_e	jmp	#LR__3394
	shl	local08, #1
	callpa	#(@LR__3393-@LR__3392)>>2,fcache_load_ptr_
LR__3392
	cmp	local08, ##8388608 wc
 if_b	mov	local15, local10
 if_b	sub	local15, #1
 if_b	mov	local10, local15
 if_b	shl	local08, #1
 if_b	jmp	#LR__3392
LR__3393
	jmp	#LR__3372
LR__3394
	sub	local06, #127
	mov	arg01, local05
	mov	arg02, local12
	mov	arg03, local06
	mov	arg04, local04
	call	#__system__pack_0630
LR__3395
	mov	ptra, fp
	call	#popregs_
__system___float_add_ret
	ret

__system___float_sqrt
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	result1, arg01
	mov	local02, result1
	mov	local03, local02
	zerox	local03, #22
	mov	local04, local02
	shl	local04, #1
	shr	local04, #24 wz
	shr	local02, #31
 if_e	jmp	#LR__3401
	bith	local03, #23
LR__3400
	cmp	local02, #0 wz
 if_ne	mov	result1, ##2146435072
 if_ne	jmp	#LR__3404
	cmp	local04, #255 wz
 if_e	mov	result1, local01
 if_e	jmp	#LR__3404
	sub	local04, #127
	test	local04, #1 wz
 if_ne	shl	local03, #1
	shl	local03, #5
	qsqrt	#0, local03
 if_ne	sub	local04, #1
	abs	local04, local04 wc
	shr	local04, #1
	negc	arg03, local04
	mov	arg04, local02
	getqx	arg01
	mov	arg02, arg01
	shl	arg02, #25
	shr	arg01, #7
	cmp	arg01, ##16777217 wc
 if_ae	add	arg03, #1
 if_ae	shr	arg01, #1
	call	#__system__pack_0630
	jmp	#LR__3404
LR__3401
	cmp	local03, #0 wz
 if_e	mov	result1, local01
 if_e	jmp	#LR__3404
	shl	local03, #1
	callpa	#(@LR__3403-@LR__3402)>>2,fcache_load_ptr_
LR__3402
	cmp	local03, ##8388608 wc
 if_b	sub	local04, #1
 if_b	shl	local03, #1
 if_b	jmp	#LR__3402
LR__3403
	jmp	#LR__3400
LR__3404
	mov	ptra, fp
	call	#popregs_
__system___float_sqrt_ret
	ret

__system___float_mul
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, local01
	mov	local04, local03
	zerox	local04, #22
	mov	local05, local03
	shl	local05, #1
	shr	local05, #24
	shr	local03, #31
	mov	result1, local02
	mov	local06, result1
	mov	local07, local06
	zerox	local07, #22
	mov	local08, local06
	shl	local08, #1
	shr	local08, #24
	shr	local06, #31
	xor	local03, local06
	cmp	local05, #255 wz
 if_e	jmp	#LR__3413
	cmp	local08, #255 wz
 if_e	jmp	#LR__3415
	cmp	local05, #0 wz
 if_e	jmp	#LR__3416
	bith	local04, #23
LR__3410
	cmp	local08, #0 wz
 if_e	jmp	#LR__3420
	bith	local07, #23
LR__3411
	mov	local02, local04
	shl	local02, #4
	mov	local06, local07
	shl	local06, #5
	qmul	local02, local06
	add	local05, local08
	sub	local05, #254
	mov	local09, local05
	shl	local04, #4
	shl	local07, #5
	getqx	local10
	qmul	local04, local07
	getqy	local11
	cmp	local11, ##16777216 wc
 if_b	jmp	#LR__3412
	add	local09, #1
	shr	local10, #1
	mov	local08, local11
	shl	local08, #31
	or	local10, local08
	shr	local11, #1
LR__3412
	mov	arg01, local11
	mov	arg02, local10
	mov	arg03, local09
	mov	arg04, local03
	call	#__system__pack_0630
	jmp	#LR__3424
LR__3413
	cmp	local04, #0 wz
 if_ne	mov	result1, local01
 if_ne	jmp	#LR__3424
	cmps	local08, #255 wc
 if_b	cmp	local08, #0 wz
 if_c_and_z	cmp	local07, #0 wz
 if_c_and_nz	jmp	#LR__3414
 if_b	mov	result1, ##2146435072
 if_b	jmp	#LR__3424
	cmp	local07, #0 wz
 if_ne	mov	result1, local02
 if_ne	jmp	#LR__3424
LR__3414
	or	local03, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, local05
	mov	arg04, local03
	call	#__system__pack_0630
	jmp	#LR__3424
LR__3415
	cmp	local05, #0 wz
 if_e	cmp	local04, #0 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__3424
	cmp	local07, #0 wz
 if_ne	mov	result1, local02
 if_ne	jmp	#LR__3424
	mov	arg03, local08
	mov	arg04, local03
	or	arg04, #2
	mov	arg01, #0
	mov	arg02, #0
	call	#__system__pack_0630
	jmp	#LR__3424
LR__3416
	cmp	local04, #0 wz
 if_e	jmp	#LR__3419
	shl	local04, #1
	callpa	#(@LR__3418-@LR__3417)>>2,fcache_load_ptr_
LR__3417
	cmp	local04, ##8388608 wc
 if_b	sub	local05, #1
 if_b	shl	local04, #1
 if_b	jmp	#LR__3417
LR__3418
	jmp	#LR__3410
LR__3419
	or	local03, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local03
	call	#__system__pack_0630
	jmp	#LR__3424
LR__3420
	cmp	local07, #0 wz
 if_e	jmp	#LR__3423
	shl	local07, #1
	callpa	#(@LR__3422-@LR__3421)>>2,fcache_load_ptr_
LR__3421
	cmp	local07, ##8388608 wc
 if_b	sub	local08, #1
 if_b	shl	local07, #1
 if_b	jmp	#LR__3421
LR__3422
	jmp	#LR__3411
LR__3423
	or	local03, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local03
	call	#__system__pack_0630
LR__3424
	mov	ptra, fp
	call	#popregs_
__system___float_mul_ret
	ret

__system___float_div
	mov	COUNT_, #14
	call	#pushregs_
	mov	local03, arg01
	mov	local04, arg02
	mov	local05, local03
	mov	local06, local05
	zerox	local06, #22
	mov	local07, local05
	shl	local07, #1
	shr	local07, #24
	shr	local05, #31
	mov	result1, local04
	mov	local08, result1
	mov	local09, local08
	zerox	local09, #22
	mov	local10, local08
	shl	local10, #1
	shr	local10, #24
	shr	local08, #31
	xor	local05, local08
	cmp	local07, #255 wz
 if_e	jmp	#LR__3435
	cmp	local10, #255 wz
 if_e	jmp	#LR__3436
	cmp	local07, #0 wz
 if_e	jmp	#LR__3437
	bith	local06, #23
LR__3430
	cmp	local10, #0 wz
 if_e	jmp	#LR__3441
	bith	local09, #23
LR__3431
	sub	local07, local10
	mov	local11, local07
	mov	arg01, local06
	shr	arg01, #2
	shl	local06, #30
	mov	arg02, local06
	mov	arg03, local09
	setq	arg01
	qdiv	arg02, arg03
	mov	local12, #0
	getqx	local01
	getqy	result2
	mov	local02, result2
	mov	local13, local01
	cmps	local02, #0 wz
	mov	local14, local13
	shl	local14, #25
 if_ne	mov	local12, #1
	or	local14, local12
	shr	local13, #7
	cmp	local13, ##16777216 wc
 if_b	jmp	#LR__3432
	add	local11, #1
	shr	local14, #1
	mov	local12, local13
	shl	local12, #31
	or	local14, local12
	shr	local13, #1
	jmp	#LR__3434
LR__3432
	cmp	local13, ##8388608 wc
 if_ae	jmp	#LR__3433
	sub	local11, #1
	shl	local13, #1
	mov	local12, local14
	shr	local12, #31
	or	local13, local12
	shl	local14, #1
LR__3433
LR__3434
	mov	arg01, local13
	mov	arg02, local14
	mov	arg03, local11
	mov	arg04, local05
	call	#__system__pack_0630
	jmp	#LR__3445
LR__3435
	cmp	local06, #0 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__3445
	cmp	local10, #255 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__3445
	or	local05, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, local07
	mov	arg04, local05
	call	#__system__pack_0630
	jmp	#LR__3445
LR__3436
	cmp	local09, #0 wz
 if_ne	mov	result1, local04
 if_ne	jmp	#LR__3445
	mov	arg04, local05
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0630
	jmp	#LR__3445
LR__3437
	cmp	local06, #0 wz
 if_e	jmp	#LR__3440
	shl	local06, #1
	callpa	#(@LR__3439-@LR__3438)>>2,fcache_load_ptr_
LR__3438
	cmp	local06, ##8388608 wc
 if_b	sub	local07, #1
 if_b	shl	local06, #1
 if_b	jmp	#LR__3438
LR__3439
	jmp	#LR__3430
LR__3440
	cmp	local10, #0 wz
 if_e	cmp	local09, #0 wz
 if_e	mov	result1, ##2146435072
 if_e	jmp	#LR__3445
	mov	arg04, local05
	or	arg04, #8
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	call	#__system__pack_0630
	jmp	#LR__3445
LR__3441
	cmp	local09, #0 wz
 if_e	jmp	#LR__3444
	shl	local09, #1
	callpa	#(@LR__3443-@LR__3442)>>2,fcache_load_ptr_
LR__3442
	cmp	local09, ##8388608 wc
 if_b	sub	local10, #1
 if_b	shl	local09, #1
 if_b	jmp	#LR__3442
LR__3443
	jmp	#LR__3431
LR__3444
	or	local05, #2
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, local05
	call	#__system__pack_0630
LR__3445
	mov	ptra, fp
	call	#popregs_
__system___float_div_ret
	ret

__system___float_cmp
	cmps	arg01, ##2139095041 wc
 if_b	cmps	arg02, ##2139095041 wc
 if_ae	mov	result1, arg03
 if_ae	jmp	#__system___float_cmp_ret
	cmp	arg01, ##-8388607 wc
 if_b	cmp	arg01, ##-8388607 wc
 if_ae	mov	result1, arg03
 if_ae	jmp	#__system___float_cmp_ret
	cmps	arg01, #0 wc
 if_ae	jmp	#LR__3450
	cmps	arg02, #0 wc
 if_b	mov	result1, arg02
 if_b	sub	result1, arg01
 if_b	jmp	#__system___float_cmp_ret
	cmp	arg02, #0 wz
 if_e	cmp	arg01, ##-2147483648 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system___float_cmp_ret
	neg	result1, #1
	jmp	#__system___float_cmp_ret
LR__3450
	cmps	arg02, #0 wc
 if_ae	jmp	#LR__3451
	cmp	arg01, #0 wz
 if_e	cmp	arg02, ##-2147483648 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system___float_cmp_ret
	mov	result1, #1
	jmp	#__system___float_cmp_ret
LR__3451
	sub	arg01, arg02
	mov	result1, arg01
__system___float_cmp_ret
	ret

__system___float_tointeger
	mov	COUNT_, #2
	call	#pushregs_
	call	#__system___float_Unpack
	cmps	result2, ##-1 wc
 if_b	jmp	#LR__3460
	cmps	result2, #31 wc
 if_ae	jmp	#LR__3460
	shl	result3, #2
	mov	local01, #30
	sub	local01, result2
	shr	result3, local01
	mov	local02, result3
	add	local02, arg02
	shr	local02, #1
	cmp	result1, #0 wz
 if_ne	neg	local02, local02
	mov	result1, local02
	jmp	#LR__3461
LR__3460
	mov	result1, #0
LR__3461
	mov	ptra, fp
	call	#popregs_
__system___float_tointeger_ret
	ret

__system___float_Unpack
	mov	_var01, arg01
	shr	_var01, #31
	mov	_var02, arg01
	shl	_var02, #1
	shr	_var02, #24 wz
	bitl	arg01, #279
 if_ne	shl	arg01, #6
 if_ne	bith	arg01, #29
 if_ne	jmp	#LR__3470
	encod	_var03, arg01 wc
 if_b	add	_var03, #1
	sub	_var03, #23
	mov	_var02, _var03
	mov	result2, #7
	sub	result2, _var03
	shl	arg01, result2
LR__3470
	sub	_var02, #127
	mov	result3, arg01
	mov	result1, _var01
	mov	result2, _var02
__system___float_Unpack_ret
	ret

__system___float_Pack
	mov	_var01, #0
	cmp	arg03, #0 wz
 if_e	jmp	#LR__3481
	encod	_var02, arg03 wc
 if_b	add	_var02, #1
	mov	_var01, #33
	sub	_var01, _var02
	shl	arg03, _var01
	mov	_var02, #3
	sub	_var02, _var01
	add	arg02, _var02
	mov	_var03, arg02
	add	arg03, #256
	mov	_var02, arg03
	andn	_var02, #255 wz
 if_e	add	_var03, #1
	add	_var03, #127
	fges	_var03, ##-23
	fles	_var03, #255
	cmps	_var03, #1 wc
 if_ae	jmp	#LR__3480
	shr	arg03, #1
	decod	_var02, #31
	add	_var02, arg03
	neg	_var03, _var03
	shr	_var02, _var03
	mov	arg03, _var02
	mov	_var03, #0
LR__3480
	mov	result1, arg01
	shl	result1, #31
	mov	_var02, _var03
	shl	_var02, #23
	or	result1, _var02
	mov	_var04, arg03
	shr	_var04, #9
	or	result1, _var04
	jmp	#__system___float_Pack_ret
LR__3481
	mov	result1, _var01
__system___float_Pack_ret
	ret

__system___basic_print_float
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03 wz
	mov	local04, arg04
 if_ne	jmp	#LR__3490
	cmp	local04, #35 wz
 if_e	mov	local05, ##537198592
 if_ne	decod	local05, #29
	mov	local03, local05
LR__3490
	mov	arg01, local01
	call	#__system___gettxfunc
	mov	local05, result1 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local05
 if_ne	mov	arg02, local03
 if_ne	mov	arg03, local02
 if_ne	mov	arg04, local04
 if_ne	call	#__system___fmtfloat
	mov	ptra, fp
	call	#popregs_
__system___basic_print_float_ret
	ret

__system____builtin_atoi
	mov	COUNT_, #7
	call	#pushregs_
__system____builtin_atoi_enter
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	mov	local04, #0
	mov	local05, #0
	callpa	#(@LR__3502-@LR__3500)>>2,fcache_load_ptr_
LR__3500
	rdbyte	local06, local01
	cmp	local06, #32 wz
 if_e	add	local01, #1
 if_e	jmp	#LR__3500
	rdbyte	local07, local01
LR__3501
	cmp	local07, #45 wz
 if_ne	cmp	local07, #43 wz
 if_ne	jmp	#LR__3503
	add	local01, #1
	cmp	local07, #45 wz
 if_e	mov	local06, #1
 if_e	subr	local05, local06
	rdbyte	local07, local01
	jmp	#LR__3501
LR__3502
LR__3503
	cmp	local02, #0 wz
 if_ne	jmp	#LR__3505
	cmp	local07, #36 wz
 if_e	mov	local02, #16
 if_e	add	local01, #1
 if_e	jmp	#LR__3504
	cmp	local07, #37 wz
 if_e	mov	local02, #2
 if_e	add	local01, #1
LR__3504
LR__3505
	callpa	#(@LR__3513-@LR__3506)>>2,fcache_load_ptr_
LR__3506
LR__3507
	rdbyte	local07, local01
	cmp	local07, #95 wz
	add	local01, #1
 if_e	jmp	#LR__3507
	cmp	local07, #48 wz
 if_ne	cmp	local07, #38 wz
 if_e	mov	local04, #0
 if_e	jmp	#LR__3512
	cmps	local07, #49 wc
 if_b	jmp	#LR__3508
	cmps	local07, #58 wc
 if_b	mov	local04, local07
 if_b	sub	local04, #48
 if_b	cmp	local02, #0 wz
 if_c_and_z	mov	local02, #10
 if_b	jmp	#LR__3511
LR__3508
	cmps	local02, #11 wc
 if_ae	cmps	local07, #97 wc
 if_b	jmp	#LR__3509
	cmps	local07, #103 wc
 if_b	sub	local07, #97
 if_b	mov	local04, #10
 if_b	add	local04, local07
 if_b	jmp	#LR__3510
LR__3509
	cmps	local02, #11 wc
 if_ae	cmps	local07, #65 wc
 if_b	jmp	#LR__3514
	cmps	local07, #71 wc
 if_b	sub	local07, #65
 if_b	mov	local04, #10
 if_b	add	local04, local07
 if_ae	jmp	#LR__3514
LR__3510
LR__3511
LR__3512
	qmul	local02, local03
	getqx	local03
	add	local03, local04
	jmp	#LR__3506
LR__3513
LR__3514
	cmp	local02, #0 wz
 if_ne	jmp	#LR__3520
	cmp	local07, #120 wz
 if_ne	cmp	local07, #104 wz
 if_ne	cmp	local07, #88 wz
 if_ne	cmp	local07, #72 wz
 if_ne	jmp	#LR__3515
	mov	arg01, local01
	mov	arg02, #16
	call	#__system____builtin_atoi
	mov	local03, result1
	jmp	#LR__3519
LR__3515
	cmp	local07, #98 wz
 if_ne	cmp	local07, #66 wz
 if_ne	jmp	#LR__3516
	mov	arg01, local01
	mov	arg02, #2
	call	#__system____builtin_atoi
	mov	local03, result1
	jmp	#LR__3518
LR__3516
	cmp	local07, #111 wz
 if_ne	cmp	local07, #79 wz
 if_ne	jmp	#LR__3517
	mov	arg01, local01
	mov	arg02, #8
	call	#__system____builtin_atoi
	mov	local03, result1
LR__3517
LR__3518
LR__3519
LR__3520
	cmp	local05, #0 wz
 if_ne	neg	local03, local03
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
__system____builtin_atoi_ret
	ret

__system____builtin_atof
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	mov	local03, #0
	mov	local04, #0
	mov	local05, #0
	callpa	#(@LR__3531-@LR__3530)>>2,fcache_load_ptr_
LR__3530
	rdbyte	arg03, local01
	cmp	arg03, #32 wz
 if_e	add	local01, #1
 if_e	jmp	#LR__3530
LR__3531
	rdbyte	local06, local01
LR__3532
	cmp	local06, #43 wz
 if_ne	cmp	local06, #45 wz
 if_ne	jmp	#LR__3533
	cmp	local06, #45 wz
 if_e	bitnot	local04, #31
	add	local01, #1
	rdbyte	local06, local01
	jmp	#LR__3532
LR__3533
LR__3534
	callpa	#(@LR__3536-@LR__3535)>>2,fcache_load_ptr_
LR__3535
	rdbyte	local06, local01
	cmp	local06, #95 wz
	add	local01, #1
 if_e	jmp	#LR__3535
LR__3536
	cmp	local06, #0 wz
 if_e	jmp	#LR__3538
	cmps	local06, #48 wc
 if_b	jmp	#LR__3537
	cmps	local06, #58 wc
 if_ae	jmp	#LR__3537
	mov	arg01, local02
	mov	arg02, ##1092616192
	call	#__system___float_mul
	mov	local02, result1
	sub	local06, #48
	mov	arg01, local06
	call	#__system___float_fromuns
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_add
	mov	local02, result1
	cmp	local05, #0 wz
 if_ne	sub	local03, #1
	jmp	#LR__3534
LR__3537
	cmp	local06, #46 wz
 if_e	cmp	local05, #0 wz
 if_e	mov	local05, #1
 if_e	jmp	#LR__3534
LR__3538
	cmp	local06, #69 wz
 if_ne	cmp	local06, #101 wz
 if_ne	jmp	#LR__3539
	mov	arg01, local01
	mov	arg02, #0
	call	#__system____builtin_atoi
	add	result1, local03
	mov	local07, result1
	jmp	#LR__3540
LR__3539
	mov	local07, local03
LR__3540
	mov	arg03, local07
	mov	arg01, local02
	mov	arg02, ##1092616192
	call	#__system___float_pow_n
	xor	result1, local04
	mov	ptra, fp
	call	#popregs_
__system____builtin_atof_ret
	ret

__system____builtin_ilogb
	call	#__system___float_Unpack
	cmp	result3, #0 wz
 if_e	mov	result1, ##-2147483647
 if_e	jmp	#LR__3551
	cmp	result2, #128 wz
 if_ne	jmp	#LR__3550
	cmp	result3, ##536870912 wz
 if_e	bmask	result1, #30
 if_e	jmp	#LR__3551
	decod	result1, #31
	jmp	#LR__3551
LR__3550
	mov	result1, result2
LR__3551
__system____builtin_ilogb_ret
	ret

__system____builtin_sinf
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, ##1086918619
	call	#__system___float_div
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	arg03, result1 wz
 if_e	jmp	#LR__3560
	abs	arg01, arg03 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg01, result1
	decod	arg02, #30
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, ##1078530011
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local01, result1
LR__3560
	mov	arg01, local01
	mov	arg02, ##1036831949
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__3561
	mov	arg01, local01
	mov	arg02, ##-1110651699
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #1 wc
 if_b	jmp	#LR__3561
	mov	arg01, local01
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, ##1086324736
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local03, result1
	jmp	#LR__3562
LR__3561
	mov	arg01, local01
	mov	arg02, ##1294137731
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	shl	result1, #2
	qrotate	##1073741824, result1
	getqy	arg01
	abs	arg01, arg01 wc
 if_b	decod	local02, #31
 if_ae	mov	local02, #0
	call	#__system___float_fromuns
	xor	result1, local02
	mov	arg01, result1
	mov	arg02, ##1317011456
	call	#__system___float_div
	mov	local03, result1
LR__3562
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
__system____builtin_sinf_ret
	ret

__system____builtin_tanf
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	call	#__system____builtin_sinf
	mov	local02, result1
	mov	arg02, local01
	mov	arg01, ##1070141403
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system____builtin_sinf
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	mov	ptra, fp
	call	#popregs_
__system____builtin_tanf_ret
	ret

__system____builtin_asinf
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, local01
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, ##1065353216
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system___float_sqrt
	mov	arg02, result1
	mov	arg01, local01
	call	#__system____builtin_atan2f
	mov	ptra, fp
	call	#popregs_
__system____builtin_asinf_ret
	ret

__system____builtin_acosf
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, local01
	mov	arg01, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, ##1065353216
	bitnot	arg02, #31
	call	#__system___float_add
	mov	arg01, result1
	call	#__system___float_sqrt
	mov	arg01, result1
	mov	arg02, local01
	call	#__system____builtin_atan2f
	mov	ptra, fp
	call	#popregs_
__system____builtin_acosf_ret
	ret

__system____builtin_atan2f
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3570
	mov	arg01, local02
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	result1, ##-1068953637
 if_b	jmp	#LR__3571
	mov	result1, #0
	jmp	#LR__3571
LR__3570
	mov	arg01, local02
	mov	arg02, local02
	call	#__system___float_mul
	mov	local03, result1
	mov	arg01, local01
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_add
	mov	arg01, result1
	call	#__system___float_sqrt
	mov	local03, result1
	mov	arg01, local02
	mov	arg02, local03
	call	#__system___float_div
	mov	local02, result1
	mov	arg01, local01
	mov	arg02, local03
	call	#__system___float_div
	mov	local01, result1
	mov	arg01, ##1317011456
	mov	arg02, local02
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local03, result1
	mov	arg01, ##1317011456
	mov	arg02, local01
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	qvector	local03, result1
	mov	local03, ##1078530011
	getqy	arg01
	sar	arg01, #1
	abs	arg01, arg01 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg01, result1
	mov	arg02, ##1317011456
	call	#__system___float_div
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___float_mul
LR__3571
	mov	ptra, fp
	call	#popregs_
__system____builtin_atan2f_ret
	ret

__system____builtin_exp2f
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, ##1123942400
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	mov	result1, ##2139095040
 if_ae	jmp	#LR__3581
	mov	arg01, local01
	mov	arg02, ##-1023541248
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__3581
	mov	arg01, local01
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local02, result1
	abs	arg01, local02 wc
 if_b	decod	local03, #31
 if_ae	mov	local03, #0
	call	#__system___float_fromuns
	xor	result1, local03
	mov	arg02, result1
	mov	arg01, local01
	bitnot	arg02, #31
	call	#__system___float_add
	mov	local04, result1
	mov	arg01, local04
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	jmp	#LR__3580
	mov	arg01, local04
	mov	arg02, ##1065353216
	call	#__system___float_add
	mov	local04, result1
	sub	local02, #1
LR__3580
	add	local02, #127
	shl	local02, #23
	mov	arg01, local04
	mov	arg02, ##1291845632
	call	#__system___float_mul
	mov	arg01, result1
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local04, result1 wz
 if_e	mov	result1, local02
 if_e	jmp	#LR__3581
	bith	local04, #62
	qexp	local04
	mov	arg01, local02
	getqx	arg02
	add	arg02, #1
	shr	arg02, #1
	add	arg02, ##1056964608
	call	#__system___float_mul
LR__3581
	mov	ptra, fp
	call	#popregs_
__system____builtin_exp2f_ret
	ret

__system____builtin_log2f
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01 wz
 if_ne	cmp	local02, ##-2147483648 wz
 if_e	neg	result1, ##8388608
 if_e	jmp	#LR__3594
	cmps	local02, #0 wc
 if_b	mov	result1, ##2143289344
 if_b	jmp	#LR__3594
	mov	arg01, local01
	mov	arg02, ##1092616192
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, ##1079286392
 if_e	jmp	#LR__3594
	mov	arg01, local01
	mov	arg02, ##1076754516
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, ##1069066811
 if_e	jmp	#LR__3594
	mov	local03, local02
	shr	local03, #23
	getbyte	local03, local03, #0
	bitl	local02, #279
	mov	local04, local02
	cmp	local03, #255 wz
 if_ne	jmp	#LR__3590
	cmp	local04, #0 wz
 if_ne	mov	local05, ##2139095040
 if_e	mov	local05, ##2143289344
	mov	result1, local05
	jmp	#LR__3594
LR__3590
	cmp	local03, #0 wz
 if_ne	bith	local04, #23
 if_ne	sub	local03, #127
 if_ne	jmp	#LR__3593
	cmp	local04, #0 wz
 if_e	neg	result1, ##8388608
 if_e	jmp	#LR__3594
	neg	local03, #126
	callpa	#(@LR__3592-@LR__3591)>>2,fcache_load_ptr_
LR__3591
	testbn	local04, #23 wz
 if_e	shl	local04, #1
 if_e	add	local03, #1
 if_e	jmp	#LR__3591
LR__3592
LR__3593
	qlog	local04
	sub	local03, #1
	abs	arg01, local03 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	getqx	local05
	bitl	local05, #155
	add	local05, #8
	shr	local05, #4
	add	local05, ##1065353216
	call	#__system___float_fromuns
	xor	result1, local06
	mov	arg02, result1
	mov	arg01, local05
	call	#__system___float_add
LR__3594
	mov	ptra, fp
	call	#popregs_
__system____builtin_log2f_ret
	ret

__system____builtin_powf
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local02
	mov	arg02, #0
	call	#__system___float_tointeger
	mov	local03, result1
	abs	arg01, local03 wc
 if_b	decod	local04, #31
 if_ae	mov	local04, #0
	call	#__system___float_fromuns
	xor	result1, local04
	mov	arg01, result1
	mov	arg02, local02
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3600
	mov	arg01, ##1065353216
	mov	arg02, local01
	mov	arg03, local03
	call	#__system___float_pow_n
	jmp	#LR__3601
LR__3600
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	mov	result1, ##2143289344
 if_b	jmp	#LR__3601
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3601
	mov	arg01, local01
	call	#__system____builtin_log2f
	mov	arg01, result1
	mov	arg02, local02
	call	#__system___float_mul
	mov	arg01, result1
	call	#__system____builtin_exp2f
LR__3601
	mov	ptra, fp
	call	#popregs_
__system____builtin_powf_ret
	ret

__system____builtin_logbase
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, arg02
	call	#__system____builtin_log2f
	mov	local02, result1
	mov	arg01, local01
	call	#__system____builtin_log2f
	mov	arg02, result1
	mov	arg01, local02
	call	#__system___float_div
	mov	ptra, fp
	call	#popregs_
__system____builtin_logbase_ret
	ret

__system___float_pow_n
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	cmps	local03, #0 wc
 if_ae	jmp	#LR__3610
	mov	local04, #1
	neg	local03, local03
	cmps	local03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__3618
	jmp	#LR__3611
LR__3610
	mov	local04, #0
LR__3611
	mov	local05, ##1065353216
LR__3612
	cmps	local03, #1 wc
 if_b	jmp	#LR__3614
	test	local03, #1 wz
 if_e	jmp	#LR__3613
	mov	arg01, local05
	mov	arg02, local02
	call	#__system___float_mul
	mov	local05, result1
LR__3613
	sar	local03, #1
	mov	arg01, local02
	mov	arg02, local02
	call	#__system___float_mul
	mov	local02, result1
	jmp	#LR__3612
LR__3614
	cmp	local04, #0 wz
 if_e	jmp	#LR__3615
	mov	arg01, local01
	mov	arg02, local05
	call	#__system___float_div
	mov	local05, result1
	jmp	#LR__3617
LR__3615
	mov	arg01, local01
	mov	arg02, ##1065353216
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__3616
	mov	arg01, local01
	mov	arg02, local05
	call	#__system___float_mul
	mov	local05, result1
LR__3616
LR__3617
	mov	result1, local05
LR__3618
	mov	ptra, fp
	call	#popregs_
__system___float_pow_n_ret
	ret

__system___gc_ptrs
	mov	_var01, __heap_ptr
	mov	_var02, _var01
	add	_var02, ##95992
	rdlong	result2, _var01 wz
 if_ne	jmp	#LR__3620
	mov	result2, _var02
	sub	result2, _var01
	wrword	#1, _var01
	mov	result1, _var01
	add	result1, #2
	wrword	##27792, result1
	mov	result1, _var01
	add	result1, #4
	wrword	#0, result1
	mov	result1, _var01
	add	result1, #6
	wrword	#1, result1
	add	_var01, #16
	abs	result2, result2 wc
	shr	result2, #4
	negc	result2, result2
	wrword	result2, _var01
	mov	result2, _var01
	add	result2, #2
	wrword	##27791, result2
	mov	result2, _var01
	add	result2, #4
	wrword	#0, result2
	mov	result2, _var01
	add	result2, #6
	wrword	#0, result2
	sub	_var01, #16
LR__3620
	mov	result1, _var01
	mov	result2, _var02
__system___gc_ptrs_ret
	ret

__system___gc_tryalloc
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
	mov	local05, local03
	mov	local06, #0
	callpa	#(@LR__3631-@LR__3630)>>2,fcache_load_ptr_
LR__3630
	mov	local07, local05
	add	local05, #6
	rdword	arg02, local05 wz
	mov	arg01, local03
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local05, result1 wz
 if_ne	rdword	local06, local05
	cmp	local05, #0 wz
 if_ne	cmps	local05, local04 wc
 if_a	jmp	#LR__3632
 if_ne	cmps	local01, local06 wcz
 if_a	jmp	#LR__3630
LR__3631
LR__3632
	cmp	local05, #0 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__3635
	mov	result2, local05
	add	result2, #6
	rdword	local08, result2
	cmps	local01, local06 wc
 if_ae	jmp	#LR__3634
	wrword	local01, local05
	mov	arg01, local05
	mov	local08, local01
	shl	local08, #4
	add	arg01, local08
	sub	local06, local01
	wrword	local06, arg01
	mov	local08, arg01
	add	local08, #2
	wrword	##27791, local08
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, arg01
	add	local08, #4
	wrword	result1, local08
	mov	local08, local05
	add	local08, #6
	mov	arg02, arg01
	rdword	local08, local08
	add	arg02, #6
	wrword	local08, arg02
	mov	local09, arg01
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, result1
	rdword	local10, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local10, #4
 if_ne	add	arg01, local10
 if_ne	mov	result1, arg01
	mov	local11, result1 wz
 if_e	jmp	#LR__3633
	cmps	local11, local04 wc
 if_ae	jmp	#LR__3633
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local11, #4
	wrword	result1, local11
LR__3633
LR__3634
	add	local07, #6
	wrword	local08, local07
	mov	local09, ##27776
	or	local09, local02
	mov	result1, #0
	cogid	result1
	or	local09, result1
	mov	local11, local05
	add	local11, #2
	wrword	local09, local11
	mov	local09, local03
	add	local09, #8
	mov	local11, local05
	rdword	local09, local09
	add	local11, #6
	wrword	local09, local11
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local03, #8
	wrword	result1, local03
	add	local05, #8
	mov	result1, local05
LR__3635
	mov	ptra, fp
	call	#popregs_
__system___gc_tryalloc_ret
	ret

__system___gc_alloc_managed
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, #0
	call	#__system___gc_doalloc
	mov	arg02, result1 wz
 if_e	cmps	local01, #1 wc
 if_nc_and_z	mov	result1, #0
 if_c_or_nz	mov	result1, arg02
	mov	ptra, fp
	call	#popregs_
__system___gc_alloc_managed_ret
	ret

__system___gc_doalloc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, arg02
 if_e	mov	result1, #0
 if_e	jmp	#LR__3647
	add	local01, #23
	andn	local01, #15
	shr	local01, #4
	add	ptr___system__dat__, #28
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #28
	call	#__system___lockmem
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1 wz
 if_ne	jmp	#LR__3640
	call	#__system___gc_docollect
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1
LR__3640
	add	ptr___system__dat__, #28
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #28
	wrlong	#0, arg01
	cmp	local03, #0 wz
 if_e	jmp	#LR__3646
	shl	local01, #4
	sub	local01, #8
	abs	local04, local01 wc
	shr	local04, #2
	negc	local05, local04 wz
	mov	local06, local03
 if_e	jmp	#LR__3645
	callpa	#(@LR__3643-@LR__3641)>>2,fcache_load_ptr_
LR__3641
	rep	@LR__3644, local05
LR__3642
	wrlong	#0, local06
	add	local06, #4
LR__3643
LR__3644
LR__3645
LR__3646
	mov	result1, local03
LR__3647
	mov	ptra, fp
	call	#popregs_
__system___gc_doalloc_ret
	ret

__system___gc_isvalidptr
	bitl	arg03, #248
	sub	arg03, #8
	cmps	arg03, arg01 wc
 if_b	jmp	#LR__3650
	cmps	arg03, arg02 wc
 if_b	jmp	#LR__3651
LR__3650
	mov	result1, #0
	jmp	#__system___gc_isvalidptr_ret
LR__3651
	mov	_var01, arg03
	xor	_var01, arg01
	test	_var01, #15 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___gc_isvalidptr_ret
	mov	_var01, arg03
	add	_var01, #2
	rdword	_var01, _var01
	and	_var01, ##65472
	cmp	_var01, ##27776 wz
 if_ne	mov	result1, #0
 if_e	mov	result1, arg03
__system___gc_isvalidptr_ret
	ret

__system___gc_free
	mov	arg03, arg01
	call	#__system___gc_ptrs
	mov	arg01, result1
	mov	arg02, result2
	call	#__system___gc_isvalidptr
	mov	arg02, result1 wz
 if_e	jmp	#LR__3660
	add	ptr___system__dat__, #28
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #28
	call	#__system___lockmem
	mov	arg01, arg02
	call	#__system___gc_dofree
	add	ptr___system__dat__, #28
	mov	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #28
	wrlong	#0, arg01
LR__3660
__system___gc_free_ret
	ret

__system___gc_dofree
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	call	#__system___gc_ptrs
	mov	local02, result1
	mov	local03, result2
	mov	arg02, local01
	add	arg02, #2
	wrword	##27791, arg02
	mov	local04, local01
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	callpa	#(@LR__3671-@LR__3670)>>2,fcache_load_ptr_
LR__3670
	add	local04, #4
	rdword	arg02, local04 wz
	mov	arg01, local02
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_e	jmp	#LR__3672
	mov	arg01, local04
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__3670
LR__3671
LR__3672
	cmp	local04, #0 wz
 if_e	mov	local04, local02
	mov	arg02, local04
	add	arg02, #6
	mov	arg01, local01
	rdword	arg02, arg02
	add	arg01, #6
	wrword	arg02, arg01
	mov	arg02, local01 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local04
	add	arg02, #6
	wrword	result1, arg02
	cmp	local04, local02 wz
 if_e	jmp	#LR__3675
	mov	arg01, local04
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	cmp	result1, local01 wz
 if_ne	jmp	#LR__3674
	rdword	local06, local04
	rdword	arg02, local01
	add	local06, arg02
	wrword	local06, local04
	mov	local06, local01
	add	local06, #2
	wrword	#0, local06
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	cmps	local06, local03 wc
 if_ae	jmp	#LR__3673
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local06
	add	arg02, #4
	wrword	result1, arg02
LR__3673
	mov	arg02, local01
	add	arg02, #6
	mov	result2, local04
	rdword	arg02, arg02
	add	result2, #6
	wrword	arg02, result2
	add	local01, #6
	wrword	#0, local01
	mov	local01, local04
LR__3674
LR__3675
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	arg02, result1 wz
 if_e	jmp	#LR__3677
	cmps	arg02, local03 wc
 if_ae	jmp	#LR__3677
	mov	arg01, arg02
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__3677
	mov	local04, local01
	rdword	local06, local04
	mov	arg01, arg02
	rdword	local01, arg01
	add	local06, local01
	wrword	local06, local04
	mov	local06, arg01
	add	local06, #6
	mov	local01, local04
	rdword	local06, local06
	add	local01, #6
	wrword	local06, local01
	mov	local06, arg01
	add	local06, #2
	wrword	#170, local06
	mov	local06, arg01
	add	local06, #6
	wrword	#0, local06
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1 wz
 if_e	jmp	#LR__3676
	cmps	local06, local03 wc
 if_ae	jmp	#LR__3676
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local04, local06
	add	local04, #4
	wrword	result1, local04
LR__3676
LR__3677
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___gc_dofree_ret
	ret

__system___gc_docollect
	mov	COUNT_, #5
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result2
	mov	local02, result1
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
	mov	result1, #0
	cogid	result1
	mov	local05, result1
 if_e	jmp	#LR__3682
	callpa	#(@LR__3681-@LR__3680)>>2,fcache_load_ptr_
LR__3680
	cmps	local04, local01 wc
 if_ae	jmp	#LR__3682
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	andn	arg02, #32
	mov	arg01, local04
	add	arg01, #2
	wrword	arg02, arg01
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_ne	jmp	#LR__3680
LR__3681
LR__3682
	mov	local03, #0
	mov	arg01, #0
	call	#__system____topofstack
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___gc_markhub
	call	#__system___gc_markcog
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1 wz
 if_e	jmp	#LR__3686
LR__3683
	mov	local04, local02
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	test	arg02, #32 wz
 if_e	test	arg02, #16 wz
 if_ne	jmp	#LR__3685
	getnib	arg02, arg02, #0
	cmp	arg02, local05 wz
 if_ne	cmp	arg02, #14 wz
 if_ne	jmp	#LR__3684
	mov	arg01, local04
	call	#__system___gc_dofree
	mov	local02, result1
LR__3684
LR__3685
	cmp	local02, #0 wz
 if_ne	cmps	local02, local01 wc
 if_c_and_nz	jmp	#LR__3683
LR__3686
	mov	ptra, fp
	call	#popregs_
__system___gc_docollect_ret
	ret

__system___gc_markhub
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
LR__3690
	cmps	local01, local02 wc
 if_ae	jmp	#LR__3691
	rdlong	arg03, local01
	add	local01, #4
	mov	arg02, local04
	mov	arg01, local03
	call	#__system___gc_isvalidptr
	mov	arg03, result1 wz
 if_e	jmp	#LR__3690
	mov	arg01, arg03
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_ne	jmp	#LR__3690
	mov	result2, arg03
	add	result2, #2
	rdword	result2, result2
	andn	result2, #15
	or	result2, #46
	add	arg03, #2
	wrword	result2, arg03
	jmp	#LR__3690
LR__3691
	mov	ptra, fp
	call	#popregs_
__system___gc_markhub_ret
	ret

__system___gc_markcog
	mov	COUNT_, #4
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result1
	mov	local02, result2
	mov	local03, #495
LR__3700
	'.live	local03
	alts	local03, #0
	mov	local04, local03
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local04
	call	#__system___gc_isvalidptr
	cmp	result1, #0 wz
 if_e	jmp	#LR__3701
	mov	local04, result1
	add	local04, #2
	rdword	local04, local04
	or	local04, #32
	add	result1, #2
	wrword	local04, result1
LR__3701
	sub	local03, #1
	cmps	local03, #0 wc
 if_ae	jmp	#LR__3700
	mov	ptra, fp
	call	#popregs_
__system___gc_markcog_ret
	ret

__system__opendir
	mov	COUNT_, #6
	call	#pushregs_
	add	ptr___system__dat__, #388
	mov	local01, ptr___system__dat__
	mov	arg02, arg01
	mov	arg01, local01
	mov	arg03, #0
	sub	ptr___system__dat__, #388
	call	#__system____getvfsforfile
	mov	local02, result1 wz
 if_e	jmp	#LR__3710
	add	local02, #40
	rdlong	arg03, local02 wz
	sub	local02, #40
 if_ne	jmp	#LR__3711
LR__3710
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__3713
LR__3711
	mov	arg01, #92
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	mov	result1, #0
 if_e	jmp	#LR__3713
	add	local02, #40
	rdlong	local04, local02
	mov	local05, local04
	sub	local02, #40
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local03
	mov	arg02, local01
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	mov	arg03, result1 wz
 if_e	jmp	#LR__3712
	cmps	arg03, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg03, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	arg01, local03
	call	#__system___gc_free
	mov	result1, #0
	jmp	#LR__3713
LR__3712
	wrlong	local02, local03
	mov	result1, local03
LR__3713
	mov	ptra, fp
	call	#popregs_
__system__opendir_ret
	ret

__system__closedir
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	rdlong	arg01, local01
	add	arg01, #44
	rdlong	local02, arg01
	mov	local03, local02
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg01, local01
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
	mov	local04, result1
	mov	arg01, local01
	call	#__system___gc_free
	cmps	local04, #0 wz
	add	ptr___system__dat__, #32
	wrlong	local04, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system__closedir_ret
	ret

__system__readdir
	mov	COUNT_, #4
	call	#pushregs_
	rdlong	arg02, arg01 wz
	add	arg01, #8
	mov	local01, arg01
	sub	arg01, #8
 if_e	mov	result1, #0
 if_e	jmp	#LR__3721
	add	arg02, #48
	rdlong	local02, arg02
	mov	local03, local02
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg02, local01
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
	cmps	result1, #0 wz
 if_e	jmp	#LR__3720
	cmps	result1, #1 wc
 if_ae	cmps	result1, #0 wz
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	result1, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__3721
LR__3720
	mov	result1, local01
LR__3721
	mov	ptra, fp
	call	#popregs_
__system__readdir_ret
	ret

__system___openraw
	mov	COUNT_, #21
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, #4
	mov	local06, local01
	mov	local07, #0
	add	ptr___system__dat__, #388
	mov	local08, ptr___system__dat__
	mov	arg01, local08
	mov	arg02, local02
	mov	arg03, #0
	sub	ptr___system__dat__, #388
	call	#__system____getvfsforfile
	mov	local09, result1 wz
 if_e	jmp	#LR__3730
	add	local09, #32
	rdlong	result1, local09 wz
	sub	local09, #32
 if_ne	jmp	#LR__3731
LR__3730
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__3744
LR__3731
	mov	arg01, local06
	mov	arg02, #0
	mov	arg03, #52
	mov	local10, arg01
	call	#\builtin_bytefill_
	add	local09, #32
	rdlong	local11, local09
	mov	local12, local11
	mov	local13, local11
	sub	local09, #32
	mov	local14, local13
	zerox	local12, #19
	shr	local14, #20
	shl	local14, #2
	add	local14, __methods__
	rdlong	local14, local14
	mov	local15, local06
	mov	local16, local08
	mov	local17, local03
	mov	arg01, local15
	mov	arg02, local16
	mov	arg03, local17
	mov	local18, objptr
	mov	objptr, local12
	call	local14
	mov	objptr, local18
	mov	local19, result1 wz
 if_ne	test	local03, #4 wz
 if_e	jmp	#LR__3732
	add	local09, #36
	rdlong	local11, local09
	mov	local12, local11
	mov	local13, local11
	sub	local09, #36
	mov	local14, local13
	zerox	local12, #19
	shr	local14, #20
	shl	local14, #2
	add	local14, __methods__
	rdlong	local14, local14
	mov	local15, local06
	mov	local16, local08
	mov	local17, local04
	mov	arg01, local15
	mov	arg02, local16
	mov	arg03, local17
	mov	local18, objptr
	mov	objptr, local12
	call	local14
	mov	objptr, local18
	mov	local19, result1
LR__3732
	cmp	local19, #0 wz
 if_ne	jmp	#LR__3742
	mov	local20, local03
	and	local20, #3 wz
 if_ne	or	local05, #2
	cmp	local20, #1 wz
 if_ne	or	local05, #1
	test	local03, #32 wz
 if_ne	or	local05, #192
	add	local06, #8
	wrlong	local05, local06
	add	local06, #12
	rdlong	local21, local06 wz
	sub	local06, #20
 if_ne	jmp	#LR__3733
	add	local09, #4
	rdlong	local21, local09
	sub	local09, #4
	add	local06, #20
	wrlong	local21, local06
	sub	local06, #20
LR__3733
	add	local06, #24
	rdlong	local21, local06 wz
	sub	local06, #24
 if_ne	jmp	#LR__3734
	add	local09, #8
	rdlong	local21, local09
	sub	local09, #8
	add	local06, #24
	wrlong	local21, local06
	sub	local06, #24
LR__3734
	add	local06, #36
	rdlong	local21, local06 wz
	sub	local06, #36
 if_e	rdlong	local21, local09
 if_e	add	local06, #36
 if_e	wrlong	local21, local06
 if_e	sub	local06, #36
	add	local06, #40
	rdlong	local21, local06 wz
	sub	local06, #40
 if_ne	jmp	#LR__3735
	add	local09, #16
	rdlong	local21, local09
	sub	local09, #16
	add	local06, #40
	wrlong	local21, local06
	sub	local06, #40
LR__3735
	add	local06, #48
	rdlong	local21, local06 wz
	sub	local06, #48
 if_ne	jmp	#LR__3736
	add	local09, #12
	rdlong	local21, local09
	sub	local09, #12
	add	local06, #48
	wrlong	local21, local06
	sub	local06, #48
LR__3736
	add	local06, #28
	rdlong	local21, local06 wz
	sub	local06, #28
 if_ne	jmp	#LR__3737
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##168820736
	add	local06, #28
	wrlong	arg01, local06
	sub	local06, #28
LR__3737
	add	local06, #32
	rdlong	local21, local06 wz
	sub	local06, #32
 if_ne	jmp	#LR__3738
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##169869312
	add	local06, #32
	wrlong	arg01, local06
	sub	local06, #32
LR__3738
	add	local06, #44
	rdlong	local21, local06 wz
	sub	local06, #44
 if_ne	jmp	#LR__3741
	add	local09, #20
	rdlong	local21, local09 wz
	sub	local09, #20
 if_e	jmp	#LR__3739
	add	local09, #20
	rdlong	local21, local09
	add	local06, #44
	wrlong	local21, local06
	sub	local06, #44
	jmp	#LR__3740
LR__3739
	mov	local07, #1
	mov	arg01, objptr
	or	arg01, ##170917888
	add	local06, #44
	wrlong	arg01, local06
	sub	local06, #44
LR__3740
LR__3741
LR__3742
	cmp	local07, #0 wz
 if_ne	mov	arg01, local06
 if_ne	call	#__system____default_buffer_init
	cmp	local19, #0 wz
 if_e	mov	arg01, #0
 if_ne	jmp	#LR__3743
	cmps	arg01, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
LR__3743
	mov	result1, local19
LR__3744
	mov	ptra, fp
	call	#popregs_
__system___openraw_ret
	ret

__system___closeraw
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__3752
	add	local01, #44
	rdlong	result1, local01 wz
	sub	local01, #44
 if_e	jmp	#LR__3750
	add	local01, #44
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #44
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
LR__3750
	add	local01, #36
	rdlong	local05, local01 wz
	sub	local01, #36
 if_e	jmp	#LR__3751
	add	local01, #36
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #36
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local02, result1
LR__3751
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
	mov	result1, local02
LR__3752
	mov	ptra, fp
	call	#popregs_
__system___closeraw_ret
	ret

__system___vfs_open_sdcardx
	mov	COUNT_, #11
	call	#pushregs_
	mov	local03, arg01
	mov	local04, arg02
	mov	local05, arg03
	mov	local06, arg04
	mov	arg01, ##548
	call	#__system___gc_alloc_managed
	mov	local07, result1
	mov	arg01, ##564
	call	#__system___gc_alloc_managed
	mov	local08, result1
	mov	arg04, local03
	sar	arg04, #31
	mov	arg03, local03
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	local01, result1
	mov	local09, result2
	mov	arg04, local04
	sar	arg04, #31
	mov	arg03, local04
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local09, result2
	mov	arg04, local05
	sar	arg04, #31
	mov	arg03, local05
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	or	local01, result1
	or	local09, result2
	mov	arg04, local06
	sar	arg04, #31
	mov	arg03, local06
	mov	arg01, #1
	mov	arg02, #0
	call	#__system___int64_shl
	mov	arg02, local09
	or	local01, result1
	or	result2, arg02
	mov	local02, result2
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___usepins
	cmp	result1, #0 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#22, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	mov	result1, #0
 if_e	jmp	#LR__3762
	mov	local10, local01
	mov	local09, local02
	add	local07, ##520
	wrlong	local10, local07
	add	local07, #4
	wrlong	local09, local07
	sub	local07, ##524
	mov	arg05, local06
	mov	arg01, #0
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local05
	mov	local10, objptr
	mov	objptr, local07
	call	#_fatfs_cc_disk_setpins
	mov	objptr, local10
	mov	local11, result1 wz
 if_ne	jmp	#LR__3760
	mov	arg02, ##@LR__5177
	mov	arg01, local08
	mov	arg03, #0
	mov	local11, objptr
	mov	objptr, local07
	call	#_fatfs_cc_f_mount
	mov	objptr, local11
	mov	local11, result1
LR__3760
	cmp	local11, #0 wz
 if_e	jmp	#LR__3761
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___freepins
	neg	arg01, local11 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
	mov	result1, #0
	jmp	#LR__3762
LR__3761
	mov	arg01, local07
	mov	local11, objptr
	mov	objptr, local07
	call	#_fatfs_cc_get_vfs
	mov	objptr, local11
LR__3762
	mov	ptra, fp
	call	#popregs_
__system___vfs_open_sdcardx_ret
	ret

__system____default_getc
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #8
	rdlong	local03, local02
	test	local03, #2 wz
 if_ne	mov	arg01, local01
 if_ne	call	#__system____default_flush
	rdlong	local03, local02
	or	local03, #1
	wrlong	local03, local02
	sub	local02, #8
	rdlong	local03, local02 wz
 if_ne	jmp	#LR__3770
	mov	arg01, local01
	call	#__system____default_filbuf
	mov	local03, result1
LR__3770
	cmps	local03, #1 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__3771
	sub	local03, #1
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	rdbyte	result1, local03
	add	local03, #1
	wrlong	local03, local02
LR__3771
	mov	ptra, fp
	call	#popregs_
__system____default_getc_ret
	ret

__system____default_putc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local02
	add	local03, #8
	rdlong	result1, local03
	test	result1, #1 wz
 if_ne	mov	arg01, local02
 if_ne	call	#__system____default_flush
	rdlong	local04, local03
	or	local04, #2
	wrlong	local04, local03
	sub	local03, #8
	rdlong	local05, local03
	add	local03, #16
	rdlong	arg02, local03
	sub	local03, #16
	mov	result1, local05
	add	result1, arg02
	wrbyte	local01, result1
	getbyte	local01, local01, #0
	add	local05, #1
	wrlong	local05, local03
	add	local02, #6
	rdword	local06, local02 wz
	sub	local02, #6
 if_ne	add	local03, #12
 if_ne	rdlong	local04, local03
 if_ne	cmp	local05, local04 wz
 if_e	jmp	#LR__3780
	cmp	local01, #10 wz
 if_e	cmp	local06, #1 wz
 if_ne	jmp	#LR__3781
LR__3780
	mov	arg01, local02
	call	#__system____default_flush
	cmp	result1, #0 wz
 if_ne	neg	local01, #1
LR__3781
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system____default_putc_ret
	ret

__system____default_flush
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	rdlong	local03, local02
	add	local02, #8
	rdlong	result1, local02
	sub	local02, #8
	test	result1, #2 wz
 if_e	jmp	#LR__3792
	cmps	local03, #1 wc
 if_b	jmp	#LR__3794
	add	local01, #8
	rdlong	result1, local01
	sub	local01, #8
	test	result1, #64 wz
 if_e	jmp	#LR__3791
	add	local01, #8
	rdlong	arg03, local01
	sub	local01, #8
	test	arg03, #128 wz
 if_e	jmp	#LR__3790
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #2
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	add	local01, #8
	rdlong	local06, local01
	andn	local06, #128
	wrlong	local06, local01
	sub	local01, #8
LR__3790
LR__3791
	add	local01, #24
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #24
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	add	local02, #16
	rdlong	arg02, local02
	sub	local02, #16
	mov	arg01, local01
	mov	arg03, local03
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	jmp	#LR__3794
LR__3792
	add	local02, #8
	rdlong	local06, local02
	sub	local02, #8
	test	local06, #1 wz
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__3793
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	neg	arg02, local03
	mov	arg03, #1
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
LR__3793
LR__3794
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system____default_flush_ret
	ret

__system____default_buffer_init
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	call	#__system___isatty
	cmp	result1, #0 wz
 if_ne	add	local01, #6
 if_ne	wrword	#5, local01
 if_e	add	local01, #6
 if_e	wrword	#6, local01
	add	local02, #20
	mov	local01, local02
	sub	local02, #4
	wrlong	local01, local02
	sub	local02, #4
	wrlong	##1024, local02
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system____default_buffer_init_ret
	ret

__system__stat
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	add	ptr___system__dat__, #388
	mov	local02, ptr___system__dat__
	mov	arg02, arg01
	mov	arg01, local02
	mov	arg03, #0
	sub	ptr___system__dat__, #388
	call	#__system____getvfsforfile
	mov	local03, result1 wz
 if_e	jmp	#LR__3800
	add	local03, #52
	rdlong	arg03, local03 wz
	sub	local03, #52
 if_ne	jmp	#LR__3801
LR__3800
	add	ptr___system__dat__, #32
	wrlong	#16, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
	jmp	#LR__3802
LR__3801
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #48
	mov	local04, arg01
	call	#\builtin_bytefill_
	mov	result1, local04
	rdbyte	arg01, local02 wz
 if_e	add	local01, #8
 if_e	wrlong	##4607, local01
 if_e	mov	result1, #0
 if_e	jmp	#LR__3802
	add	local03, #52
	rdlong	local03, local03
	mov	local04, local03
	zerox	local03, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local02
	mov	arg02, local01
	mov	local02, objptr
	mov	objptr, local03
	call	local04
	mov	objptr, local02
LR__3802
	mov	ptra, fp
	call	#popregs_
__system__stat_ret
	ret

__system__write
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__3810
	qmul	arg01, #52
	add	ptr___system__dat__, ##1316
	getqx	arg01
	add	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1316
	call	#__system___vfswrite
LR__3810
__system__write_ret
	ret

__system__read
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__3820
	qmul	arg01, #52
	add	ptr___system__dat__, ##1316
	getqx	arg01
	add	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1316
	call	#__system___vfsread
LR__3820
__system__read_ret
	ret

__system__close
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__3830
	qmul	arg01, #52
	add	ptr___system__dat__, ##1316
	getqx	arg01
	add	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1316
	call	#__system___closeraw
LR__3830
__system__close_ret
	ret

__system__lseek
	mov	COUNT_, #6
	call	#pushregs_
	cmp	arg01, #10 wc
 if_ae	add	ptr___system__dat__, #32
 if_ae	wrlong	#5, ptr___system__dat__
 if_ae	sub	ptr___system__dat__, #32
 if_ae	neg	result1, #1
 if_ae	jmp	#LR__3841
	qmul	arg01, #52
	add	ptr___system__dat__, ##1316
	getqx	local01
	add	local01, ptr___system__dat__
	add	local01, #48
	rdlong	arg01, local01 wz
	sub	local01, #48
	sub	ptr___system__dat__, ##1316
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#16, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__3841
	add	local01, #8
	rdlong	local02, local01
	sub	local01, #8
	test	local02, #64 wz
 if_ne	add	local01, #8
 if_ne	rdlong	local02, local01
 if_ne	or	local02, #128
 if_ne	wrlong	local02, local01
 if_ne	sub	local01, #8
	add	local01, #48
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #48
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local06, result1
	cmps	local06, #0 wc
 if_ae	jmp	#LR__3840
	neg	arg01, local06 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__3841
LR__3840
	mov	result1, local06
LR__3841
	mov	ptra, fp
	call	#popregs_
__system__lseek_ret
	ret

__system___ioctl
	mov	COUNT_, #3
	call	#pushregs_
	cmps	arg01, #0 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__3851
	add	arg01, #40
	rdlong	local01, arg01
	mov	local02, local01
	sub	arg01, #40
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	arg01, result1 wz
 if_e	jmp	#LR__3850
	cmps	arg01, #0 wz
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__3851
LR__3850
	mov	result1, #0
LR__3851
	mov	ptra, fp
	call	#popregs_
__system___ioctl_ret
	ret

__system___isatty
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #12
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg03, fp
	sub	fp, #8
	mov	arg02, #256
	call	#__system___ioctl
	cmp	result1, #0 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system___isatty_ret
	ret

__system____getftab
	cmp	arg01, #10 wc
 if_b	qmul	arg01, #52
 if_ae	mov	result1, #0
 if_b	add	ptr___system__dat__, ##1316
 if_b	getqx	result1
 if_b	add	result1, ptr___system__dat__
 if_b	sub	ptr___system__dat__, ##1316
__system____getftab_ret
	ret

__system__strncpy
	mov	_var01, arg01
LR__3860
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_b	jmp	#LR__3861
	rdbyte	result1, arg02
	wrbyte	result1, _var01
	add	arg02, #1
	rdbyte	result1, _var01 wz
	add	_var01, #1
 if_ne	jmp	#LR__3860
LR__3861
	callpa	#(@LR__3863-@LR__3862)>>2,fcache_load_ptr_
LR__3862
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_ae	mov	_var02, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	#0, _var02
 if_ae	jmp	#LR__3862
LR__3863
	mov	result1, arg01
__system__strncpy_ret
	ret

__system__strncat
	cmps	arg02, #0 wz
 if_e	jmp	#LR__3874
	cmp	arg03, #1 wc
 if_b	jmp	#LR__3874
	mov	_var01, arg01
	callpa	#(@LR__3872-@LR__3870)>>2,fcache_load_ptr_
LR__3870
	rdbyte	result1, _var01 wz
 if_ne	add	_var01, #1
 if_ne	jmp	#LR__3870
	mov	_var02, arg03
LR__3871
	rdbyte	_var03, arg02
	mov	_var04, _var03
	zerox	_var04, #7 wz
	add	arg02, #1
 if_e	jmp	#LR__3873
	sub	_var02, #1
	cmps	_var02, #0 wc
 if_ae	mov	_var04, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	_var03, _var04
 if_ae	jmp	#LR__3871
LR__3872
LR__3873
	wrbyte	#0, _var01
LR__3874
	mov	result1, arg01
__system__strncat_ret
	ret

__system__strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__3880
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#__system__strncmp_ret
LR__3880
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#__system__strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__3882-@LR__3881)>>2,fcache_load_ptr_
LR__3881
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__3883
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__3881
LR__3882
LR__3883
	cmps	_var03, #0 wc
 if_b	mov	result1, #0
 if_b	jmp	#__system__strncmp_ret
	cmp	_var04, _var06 wz
 if_e	mov	result1, #0
 if_e	jmp	#__system__strncmp_ret
	cmp	_var04, #0 wz
 if_e	neg	result1, #1
 if_e	jmp	#__system__strncmp_ret
	cmp	_var06, #0 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
__system__strncmp_ret
	ret

__system____root_opendir
	add	ptr___system__dat__, #100
	add	arg01, #4
	wrlong	ptr___system__dat__, arg01
	mov	result1, #0
	sub	ptr___system__dat__, #100
__system____root_opendir_ret
	ret

__system____root_readdir
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	add	local01, #4
	rdlong	local03, local01
	sub	local01, #4
LR__3890
	add	ptr___system__dat__, #116
	cmp	local03, ptr___system__dat__ wz
	sub	ptr___system__dat__, #116
 if_e	neg	result1, #1
 if_e	jmp	#LR__3891
	rdlong	arg03, local03 wz
 if_e	add	local03, #4
 if_e	jmp	#LR__3890
	rdlong	arg02, local03
	add	arg02, #1
	mov	arg01, local02
	mov	arg03, #64
	call	#__system__strncpy
	add	local02, #80
	wrbyte	#1, local02
	sub	local02, #8
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local03, #4
	add	local01, #4
	wrlong	local03, local01
	mov	result1, #0
LR__3891
	mov	ptra, fp
	call	#popregs_
__system____root_readdir_ret
	ret

__system____root_closedir
	mov	result1, #0
__system____root_closedir_ret
	ret

__system____root_stat
	mov	_var01, arg02
	mov	arg01, _var01
	mov	arg02, #0
	mov	arg03, #48
	call	#\builtin_bytefill_
	add	_var01, #8
	wrlong	##4607, _var01
	mov	result1, #0
__system____root_stat_ret
	ret

__system___normalizeName
	mov	_var01, #0
	mov	_var02, arg01
	mov	_var03, _var02
LR__3900
	rdbyte	_var04, _var02 wz
 if_e	jmp	#LR__3919
	cmp	_var01, #0 wz
 if_ne	mov	_var04, _var03
 if_ne	add	_var03, #1
 if_ne	wrbyte	#47, _var04
 if_ne	mov	_var01, #0
	rdbyte	_var04, _var02
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__3912
	add	_var02, #1
	rdbyte	_var04, _var02
	sub	_var02, #1
	cmp	_var04, #47 wz
 if_e	jmp	#LR__3901
	add	_var02, #1
	rdbyte	_var05, _var02
	sub	_var02, #1
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__3902
LR__3901
	mov	_var07, _var02
	add	_var07, #1
	mov	_var02, _var07
	jmp	#LR__3916
LR__3902
	add	_var02, #1
	rdbyte	_var07, _var02
	sub	_var02, #1
	getbyte	_var04, _var07, #0
	cmp	_var04, #46 wz
 if_ne	jmp	#LR__3911
	add	_var02, #2
	rdbyte	_var07, _var02
	sub	_var02, #2
	getbyte	_var04, _var07, #0
	cmp	_var04, #47 wz
 if_e	jmp	#LR__3903
	add	_var02, #2
	rdbyte	_var05, _var02
	sub	_var02, #2
	mov	_var06, _var05
	zerox	_var06, #7 wz
 if_ne	jmp	#LR__3910
LR__3903
	add	_var02, #2
	cmps	_var03, arg01 wcz
 if_be	jmp	#LR__3909
	mov	_var08, _var03
	sub	_var08, #1
LR__3904
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__3905
	cmps	_var08, arg01 wcz
 if_a	sub	_var08, #1
 if_a	jmp	#LR__3904
LR__3905
	callpa	#(@LR__3907-@LR__3906)>>2,fcache_load_ptr_
LR__3906
	cmps	_var08, arg01 wcz
 if_be	jmp	#LR__3908
	rdbyte	_var04, _var08
	cmp	_var04, #47 wz
 if_ne	sub	_var08, #1
 if_ne	jmp	#LR__3906
LR__3907
LR__3908
	mov	_var03, _var08
LR__3909
	mov	_var01, #1
	jmp	#LR__3916
LR__3910
LR__3911
LR__3912
	callpa	#(@LR__3914-@LR__3913)>>2,fcache_load_ptr_
LR__3913
	rdbyte	_var04, _var02 wz
 if_ne	rdbyte	_var07, _var02
 if_ne	cmp	_var07, #47 wz
 if_e	jmp	#LR__3915
	mov	_var06, _var02
	mov	_var05, _var02
	add	_var05, #1
	rdbyte	_var09, _var06
	mov	_var02, _var05
	wrbyte	_var09, _var03
	add	_var03, #1
	jmp	#LR__3913
LR__3914
LR__3915
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_ne	jmp	#LR__3900
	mov	_var01, #1
LR__3916
	callpa	#(@LR__3918-@LR__3917)>>2,fcache_load_ptr_
LR__3917
	rdbyte	_var04, _var02
	cmp	_var04, #47 wz
 if_e	mov	_var07, _var02
 if_e	add	_var07, #1
 if_e	mov	_var02, _var07
 if_e	jmp	#LR__3917
LR__3918
	jmp	#LR__3900
LR__3919
	wrbyte	#0, _var03
__system___normalizeName_ret
	ret

__system___strrev
	rdbyte	_var01, arg01 wz
 if_e	jmp	#__system___strrev_ret
	mov	_var02, arg01
	callpa	#(@LR__3922-@LR__3920)>>2,fcache_load_ptr_
LR__3920
	rdbyte	_var01, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__3920
	sub	_var02, #1
LR__3921
	cmps	_var02, arg01 wcz
 if_be	jmp	#LR__3923
	rdbyte	_var01, arg01
	rdbyte	_var03, _var02
	wrbyte	_var03, arg01
	wrbyte	_var01, _var02
	add	arg01, #1
	sub	_var02, #1
	jmp	#LR__3921
LR__3922
LR__3923
__system___strrev_ret
	ret

__system___fmtpad
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg01, local02, #1
	shr	local02, #22
	and	local02, #3 wz
	mov	local04, #0
 if_e	mov	local02, #1
	test	local02, arg04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__3933
	subr	local03, arg01
	cmps	local03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__3933
	cmp	local02, #3 wz
 if_ne	jmp	#LR__3930
	cmp	arg04, #1 wz
	wrz	local02
	add	local03, local02
	abs	local03, local03 wc
	shr	local03, #1
	negc	local03, local03
LR__3930
	cmps	local03, #1 wc
 if_b	jmp	#LR__3932
	mov	local05, local03
LR__3931
	mov	local02, local01
	mov	local06, local01
	zerox	local02, #19
	shr	local06, #20
	shl	local06, #2
	add	local06, __methods__
	rdlong	local06, local06
	mov	arg01, #32
	mov	local03, objptr
	mov	objptr, local02
	call	local06
	mov	objptr, local03
	mov	local06, result1
	cmps	local06, #0 wc
 if_b	mov	result1, local06
 if_b	jmp	#LR__3933
	add	local04, local06
	djnz	local05, #LR__3931
LR__3932
	mov	result1, local04
LR__3933
	mov	ptra, fp
	call	#popregs_
__system___fmtpad_ret
	ret

__system___uitoa
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	cmps	arg05, #0 wz
	mov	arg05, local01
	mov	local02, #0
 if_ne	mov	local03, #55
 if_e	mov	local03, #87
LR__3940
	qdiv	arg02, arg03
	getqy	local04
	qdiv	arg02, arg03
	cmp	local04, #10 wc
 if_b	add	local04, #48
 if_ae	add	local04, local03
	wrbyte	local04, arg05
	add	arg05, #1
	add	local02, #1
	getqx	arg02
	cmp	arg02, #0 wz
 if_ne	jmp	#LR__3940
	cmp	local02, arg04 wc
 if_b	jmp	#LR__3940
	wrbyte	#0, arg05
	mov	arg01, local01
	call	#__system___strrev
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
__system___uitoa_ret
	ret

__system__disassemble_0516
	mov	COUNT_, #16
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, arg05
	abs	arg01, local05 wc
 if_b	decod	local06, #31
 if_ae	mov	local06, #0
	call	#__system___float_fromuns
	xor	result1, local06
	mov	local07, result1
	mov	local08, #0
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #1
	call	#__system___float_cmp
	cmp	result1, #0 wz
 if_e	mov	local09, #0
 if_e	wrlong	#0, local02
 if_e	wrlong	local09, local03
 if_e	jmp	#LR__3962
	mov	arg01, local01
	call	#__system____builtin_ilogb
	mov	local10, result1
	cmp	local05, #10 wz
 if_ne	jmp	#LR__3950
	mov	local09, local10
	shl	local09, #1
	add	local09, local10
	abs	local10, local09 wc
	qdiv	local10, #10
	mov	local11, #9
	getqx	local10
	negc	local10, local10
	jmp	#LR__3951
LR__3950
	mov	local11, #24
LR__3951
LR__3952
	cmps	local08, #8 wc
	add	local08, #1
 if_ae	jmp	#LR__3953
	mov	arg01, ##1065353216
	mov	arg02, local07
	mov	arg03, local10
	call	#__system___float_pow_n
	mov	arg02, result1
	mov	arg01, local01
	call	#__system___float_div
	mov	local12, result1
	mov	arg01, local12
	mov	arg02, ##1065353216
	mov	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_b	sub	local10, #1
 if_b	jmp	#LR__3952
	mov	arg02, local07
	mov	arg01, local12
	neg	arg03, #1
	call	#__system___float_cmp
	cmps	result1, #0 wc
 if_ae	add	local10, #1
 if_ae	jmp	#LR__3952
LR__3953
	mov	arg01, local12
	call	#__system____builtin_ilogb
	mov	local13, result1
	mov	local14, local12
	bitl	local14, #279
	bith	local14, #23
	shl	local14, local13
	cmp	local05, #2 wz
 if_e	shl	local04, #2
	mov	local15, #0
	cmps	local04, #0 wc
 if_ae	jmp	#LR__3954
	subr	local04, local10
	cmps	local04, #0 wc
 if_b	jmp	#LR__3961
	jmp	#LR__3955
LR__3954
	add	local04, #1
LR__3955
	fles	local04, local11 wcz
	mov	local16, #1
	callpa	#(@LR__3957-@LR__3956)>>2,fcache_load_ptr_
LR__3956
	cmp	local15, ##8388608 wc
 if_ae	jmp	#LR__3958
	cmps	local04, #1 wc
	sub	local04, #1
 if_b	jmp	#LR__3958
	qmul	local15, local05
	mov	local13, local14
	shr	local13, #23
	bitl	local14, #279
	getqx	local15
	qmul	local16, local05
	getqx	local16
	qmul	local14, local05
	add	local15, local13
	getqx	local14
	jmp	#LR__3956
LR__3957
LR__3958
	mov	local09, local05
	shl	local09, #23
	abs	local13, local09 wc
	shr	local13, #1
	negc	local13, local13
	cmp	local14, local13 wcz
 if_a	jmp	#LR__3959
	shl	local05, #23
	abs	local13, local05 wc
	shr	local13, #1
	negc	local13, local13
	cmp	local14, local13 wz
 if_ne	jmp	#LR__3960
	test	local15, #1 wz
 if_e	jmp	#LR__3960
LR__3959
	add	local15, #1
	cmp	local15, local16 wz
 if_e	add	local10, #1
LR__3960
LR__3961
	wrlong	local15, local02
	wrlong	local10, local03
LR__3962
	mov	ptra, fp
	call	#popregs_
__system__disassemble_0516_ret
	ret

__system__emitsign_0518
	mov	result1, #0
	cmp	arg02, #0 wz
 if_ne	mov	_var01, arg01
 if_ne	add	arg01, #1
 if_ne	wrbyte	arg02, _var01
 if_ne	mov	result1, #1
	cmp	arg03, #0 wz
 if_ne	wrbyte	#48, arg01
 if_ne	add	arg01, #1
 if_ne	wrbyte	arg03, arg01
 if_ne	add	result1, #2
__system__emitsign_0518_ret
	ret

__system___gettxfunc
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__3970
	add	local01, #8
	rdlong	arg02, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__3971
LR__3970
	mov	result1, #0
	jmp	#LR__3972
LR__3971
	or	local01, ##161480704
	mov	result1, local01
LR__3972
	mov	ptra, fp
	call	#popregs_
__system___gettxfunc_ret
	ret

__system___getrxfunc
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__3980
	add	local01, #8
	rdlong	arg02, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__3981
LR__3980
	mov	result1, #0
	jmp	#LR__3982
LR__3981
	or	local01, ##162529280
	mov	result1, local01
LR__3982
	mov	ptra, fp
	call	#popregs_
__system___getrxfunc_ret
	ret

__system___getiolock_0558
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__3990
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__3991
LR__3990
	add	ptr___system__dat__, ##724
	mov	result1, ptr___system__dat__
	sub	ptr___system__dat__, ##724
	jmp	#LR__3992
LR__3991
	add	local01, #12
	mov	result1, local01
LR__3992
	mov	ptra, fp
	call	#popregs_
__system___getiolock_0558_ret
	ret

__system____ScanForChar
	mov	_var01, arg01
	mov	_var02, arg01
	callpa	#(@LR__4001-@LR__4000)>>2,fcache_load_ptr_
LR__4000
	rdbyte	result1, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__4000
LR__4001
	sub	_var02, arg01
	mov	result1, _var02
	mov	arg01, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4008
	mov	_var03, arg02
	zerox	_var03, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4008
	cmp	arg03, #1 wc
 if_b	cmp	arg04, #0 wz
 if_c_and_z	mov	arg03, #1
 if_c_and_nz	mov	result1, #0
 if_c_and_nz	jmp	#LR__4008
	cmp	arg03, arg01 wcz
 if_be	jmp	#LR__4002
	cmp	arg04, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4008
	mov	arg03, arg01
LR__4002
	sub	arg03, #1
	cmp	arg04, #0 wz
 if_ne	jmp	#LR__4004
	mov	_var04, arg03
	mov	_var05, arg01
LR__4003
	cmp	_var04, _var05 wc
 if_ae	jmp	#LR__4007
	mov	_var03, _var04
	add	_var03, _var01
	rdbyte	_var03, _var03
	getbyte	arg04, arg02, #0
	cmp	_var03, arg04 wz
 if_e	add	_var04, #1
 if_e	mov	result1, _var04
 if_e	jmp	#LR__4008
	add	_var04, #1
	jmp	#LR__4003
LR__4004
	mov	_var04, arg03
LR__4005
	cmp	_var04, arg03 wcz
 if_a	jmp	#LR__4006
	mov	_var05, _var04
	add	_var05, _var01
	rdbyte	_var03, _var05
	getbyte	_var05, arg02, #0
	cmp	_var03, _var05 wz
 if_e	add	_var04, #1
 if_e	mov	result1, _var04
 if_e	jmp	#LR__4008
	sub	_var04, #1
	jmp	#LR__4005
LR__4006
LR__4007
	mov	result1, #0
LR__4008
__system____ScanForChar_ret
	ret

__system___basic_dir
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #76
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg02, fp wz
	sub	fp, #4
 if_ne	add	fp, #4
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #4
 if_ne	rdbyte	local02, local01 wz
 if_e	jmp	#LR__4010
	add	ptr___system__dat__, ##1836
	rdlong	local02, ptr___system__dat__ wz
	sub	ptr___system__dat__, ##1836
 if_ne	add	ptr___system__dat__, ##1836
 if_ne	rdlong	arg01, ptr___system__dat__
 if_ne	sub	ptr___system__dat__, ##1836
 if_ne	call	#__system__closedir
	mov	arg01, ##@LR__5178
	call	#__system__opendir
	add	ptr___system__dat__, ##1836
	wrlong	result1, ptr___system__dat__
	add	fp, #8
	rdlong	local02, fp
	add	ptr___system__dat__, #4
	wrlong	local02, ptr___system__dat__
	sub	fp, #4
	rdlong	local02, fp
	sub	fp, #4
	add	ptr___system__dat__, #4
	wrlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, ##1844
LR__4010
	add	ptr___system__dat__, ##1836
	rdlong	local02, ptr___system__dat__ wz
	sub	ptr___system__dat__, ##1836
 if_e	mov	result1, ##@LR__5179
 if_e	jmp	#LR__4023
LR__4011
	add	ptr___system__dat__, ##1836
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1836
	call	#__system__readdir
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4012
	add	ptr___system__dat__, ##1836
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, ##1836
	call	#__system__closedir
	add	ptr___system__dat__, ##1836
	wrlong	#0, ptr___system__dat__
	sub	ptr___system__dat__, ##1836
	mov	result1, ##@LR__5180
	jmp	#LR__4023
LR__4012
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	add	ptr___system__dat__, ##1844
	rdlong	arg02, ptr___system__dat__
	sub	ptr___system__dat__, ##1844
	call	#__system___pat_match
	cmp	result1, #0 wz
 if_e	jmp	#LR__4011
	add	ptr___system__dat__, ##1840
	rdlong	local02, ptr___system__dat__ wz
	sub	ptr___system__dat__, ##1840
 if_e	jmp	#LR__4019
	add	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	mov	arg02, fp
	sub	fp, #16
	call	#__system__stat
	add	fp, #64
	wrlong	result1, fp
	sub	fp, #64
	cmp	result1, #0 wz
 if_ne	mov	result1, ##@LR__5181
 if_ne	jmp	#LR__4023
	add	fp, #24
	rdlong	local02, fp
	and	local02, ##61440
	add	fp, #44
	wrlong	local02, fp
	sub	fp, #56
	rdlong	local02, fp
	sub	fp, #12
	rdbyte	local02, local02
	cmp	local02, #46 wz
 if_e	add	fp, #8
 if_e	wrlong	#2, fp
	sumz	fp, #8
 if_ne	wrlong	#0, fp
 if_ne	sub	fp, #8
	add	fp, #68
	rdlong	local02, fp
	sub	fp, #68
	cmp	local02, ##4096 wz
 if_ne	jmp	#LR__4013
	add	fp, #8
	rdlong	local02, fp
	or	local02, #16
	wrlong	local02, fp
	sub	fp, #8
	jmp	#LR__4018
LR__4013
	add	fp, #68
	rdlong	local02, fp
	sub	fp, #68
	cmp	local02, ##8192 wz
 if_ne	add	fp, #68
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #68
 if_ne	cmp	local01, ##12288 wz
 if_ne	add	fp, #68
 if_ne	mov	local03, local01
 if_ne	sub	fp, #68
 if_ne	cmp	local03, ##16384 wz
 if_ne	jmp	#LR__4014
	add	fp, #8
	rdlong	local02, fp
	or	local02, #4
	wrlong	local02, fp
	sub	fp, #8
	jmp	#LR__4017
LR__4014
	add	fp, #24
	rdlong	local02, fp
	sub	fp, #24
	test	local02, #146 wz
 if_ne	jmp	#LR__4015
	add	fp, #8
	rdlong	local02, fp
	or	local02, #1
	wrlong	local02, fp
	sub	fp, #8
	jmp	#LR__4016
LR__4015
	add	fp, #68
	rdlong	local04, fp
	sub	fp, #68
	cmp	local04, ##4096 wz
 if_ne	add	fp, #8
 if_ne	rdlong	local04, fp
 if_ne	or	local04, #32
 if_ne	wrlong	local04, fp
 if_ne	sub	fp, #8
LR__4016
LR__4017
LR__4018
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #8
	add	ptr___system__dat__, ##1840
	rdlong	local01, ptr___system__dat__
	sub	ptr___system__dat__, ##1840
	test	local04, local01 wz
 if_e	jmp	#LR__4011
LR__4019
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	mov	local05, arg01
	callpa	#(@LR__4021-@LR__4020)>>2,fcache_load_ptr_
LR__4020
	rdbyte	result1, local05 wz
 if_ne	add	local05, #1
 if_ne	jmp	#LR__4020
LR__4021
	subr	arg01, local05
	add	arg01, #1
	call	#__system___gc_alloc_managed
	add	fp, #72
	wrlong	result1, fp
	sub	fp, #72
	cmp	result1, #0 wz
 if_e	jmp	#LR__4022
	add	fp, #72
	rdlong	arg01, fp
	sub	fp, #60
	rdlong	arg02, fp
	sub	fp, #12
	call	#__system____builtin_strcpy
LR__4022
	add	fp, #72
	rdlong	result1, fp
	sub	fp, #72
LR__4023
	mov	ptra, fp
	call	#popregs_
__system___basic_dir_ret
	ret

__system__pack_0630
	mov	_var01, arg01
	add	arg03, #127
	test	arg04, #4 wz
 if_e	jmp	#LR__4030
	cmp	_var01, #0 wz
 if_e	decod	_var01, #22
	bith	_var01, #247
	jmp	#LR__4039
LR__4030
	test	arg04, #2 wz
 if_ne	mov	_var01, ##2139095040
 if_ne	mov	arg02, #0
 if_ne	jmp	#LR__4038
	test	arg04, #8 wz
 if_ne	mov	_var01, #0
 if_ne	jmp	#LR__4037
	cmps	arg03, #255 wc
 if_ae	mov	_var01, ##2139095040
 if_ae	mov	arg02, #0
 if_ae	jmp	#LR__4036
	cmps	arg03, #1 wc
 if_ae	jmp	#LR__4034
	shr	arg02, #1
	mov	_var02, _var01
	and	_var02, #1
	shl	_var02, #31
	or	arg02, _var02
	shr	_var01, #1
	callpa	#(@LR__4032-@LR__4031)>>2,fcache_load_ptr_
LR__4031
	cmps	arg03, #0 wc
 if_ae	jmp	#LR__4033
	cmp	_var01, #0 wz
 if_e	jmp	#LR__4033
	mov	arg01, arg02
	and	arg01, #1
	add	arg03, #1
	shr	arg02, #1
	mov	_var02, _var01
	and	_var02, #1
	shl	_var02, #31
	or	arg02, _var02
	or	arg02, arg01
	shr	_var01, #1
	jmp	#LR__4031
LR__4032
LR__4033
	cmps	arg03, #0 wc
 if_ae	jmp	#LR__4035
	cmp	arg02, #0 wz
	wrnz	arg02
	jmp	#LR__4035
LR__4034
	bitl	_var01, #279
	shl	arg03, #23
	or	_var01, arg03
LR__4035
LR__4036
LR__4037
LR__4038
LR__4039
	test	_var01, #1 wz
 if_ne	or	arg02, #1
	mov	arg03, arg02
	mov	_var02, #0
	add	arg02, ##2147483647
	cmp	arg02, arg03 wc
 if_b	mov	_var02, #1
	add	_var01, _var02
	test	arg04, #1 wz
 if_ne	bith	_var01, #31
	mov	result1, _var01
__system__pack_0630_ret
	ret

__system___rxtxioctl_0720
	cmp	arg02, #256 wz
 if_e	jmp	#LR__4040
	cmp	arg02, #257 wz
 if_e	jmp	#LR__4041
	jmp	#LR__4042
LR__4040
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	wrlong	result1, arg03
	mov	result1, #0
	jmp	#LR__4043
LR__4041
	rdlong	arg01, arg03
	add	ptr___system__dat__, #8
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	mov	result1, #0
	jmp	#LR__4043
LR__4042
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
LR__4043
__system___rxtxioctl_0720_ret
	ret

__system____dummy_flush_0721
	mov	result1, #0
__system____dummy_flush_0721_ret
	ret

__system___vfswrite
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, local02
	add	local01, #8
	rdlong	arg01, local01
	sub	local01, #8
	test	arg01, #2 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4056
	add	local01, #8
	rdlong	result1, local01
	sub	local01, #8
	test	result1, #64 wz
 if_e	jmp	#LR__4051
	add	local01, #8
	rdlong	arg02, local01
	sub	local01, #8
	test	arg02, #128 wz
 if_e	jmp	#LR__4050
	add	local01, #48
	rdlong	local05, local01
	mov	local06, local05
	sub	local01, #48
	zerox	local06, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #2
	mov	local07, objptr
	mov	objptr, local06
	call	local05
	mov	objptr, local07
	add	local01, #8
	rdlong	local07, local01
	andn	local07, #128
	wrlong	local07, local01
	sub	local01, #8
LR__4050
LR__4051
	add	local01, #24
	rdlong	local07, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__4053
	add	local01, #24
	rdlong	local05, local01
	mov	local06, local05
	sub	local01, #24
	zerox	local06, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	arg02, local02
	mov	arg03, local03
	mov	arg01, local01
	mov	local07, objptr
	mov	objptr, local06
	call	local05
	mov	objptr, local07
	mov	local08, result1
	cmps	local08, #0 wc
 if_ae	jmp	#LR__4052
	add	local01, #8
	rdlong	local07, local01
	or	local07, #32
	wrlong	local07, local01
	cmps	local08, #0 wz
	add	ptr___system__dat__, #32
	wrlong	local08, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__4056
LR__4052
	mov	result1, local08
	jmp	#LR__4056
LR__4053
	add	local01, #28
	rdlong	local09, local01 wz
	sub	local01, #28
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4056
	mov	local08, #0
LR__4054
	cmp	local03, #1 wc
 if_b	jmp	#LR__4055
	mov	local06, local09
	mov	local05, local09
	zerox	local06, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	rdbyte	arg01, local04
	mov	arg02, local01
	mov	local07, objptr
	mov	objptr, local06
	add	local04, #1
	call	local05
	mov	objptr, local07
	add	local08, result1
	sub	local03, #1
	jmp	#LR__4054
LR__4055
	mov	result1, local08
LR__4056
	mov	ptra, fp
	call	#popregs_
__system___vfswrite_ret
	ret

__system___vfsread
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #40
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #4
	rdlong	result1, fp
	add	fp, #20
	wrlong	result1, fp
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #28
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #8
	rdlong	result1, arg01
	test	result1, #1 wz
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4066
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #20
	rdlong	result1, arg01 wz
 if_e	jmp	#LR__4061
	add	fp, #4
	rdlong	arg01, fp
	mov	arg03, arg01
	add	arg03, #20
	rdlong	local01, arg03
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #12
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmps	result1, #0 wc
 if_ae	jmp	#LR__4060
	add	fp, #4
	rdlong	local03, fp
	mov	local01, local03
	add	local03, #8
	rdlong	local02, local03
	or	local02, #32
	add	local01, #8
	wrlong	local02, local01
	add	fp, #12
	rdlong	arg01, fp wz
	sub	fp, #16
	add	ptr___system__dat__, #32
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
	jmp	#LR__4066
LR__4060
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
	jmp	#LR__4066
LR__4061
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #32
	rdlong	arg01, arg01 wz
	add	fp, #20
	wrlong	arg01, fp
	sub	fp, #24
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#6, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4066
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #40
	rdlong	local02, local03 wz
 if_e	jmp	#LR__4063
	add	fp, #4
	rdlong	arg01, fp
	mov	local03, arg01
	add	local03, #40
	rdlong	local01, local03
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	add	fp, #32
	mov	arg03, fp
	sub	fp, #36
	mov	arg02, #256
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	add	fp, #16
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #16
 if_ne	jmp	#LR__4062
	add	fp, #36
	rdlong	local02, fp
	sub	fp, #36
	test	local02, #2 wz
 if_ne	add	fp, #32
 if_ne	wrlong	#1, fp
 if_ne	sub	fp, #32
LR__4062
LR__4063
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #16
LR__4064
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	cmp	local03, #1 wc
 if_b	jmp	#LR__4065
	add	fp, #24
	rdlong	local02, fp
	mov	local03, local02
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	sub	fp, #20
	rdlong	arg01, fp
	sub	fp, #4
	mov	local01, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local01
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmps	result1, #0 wc
 if_b	jmp	#LR__4065
	add	fp, #28
	rdlong	local03, fp
	mov	local02, local03
	add	local02, #1
	wrlong	local02, fp
	sub	fp, #8
	rdlong	local02, fp
	wrbyte	local02, local03
	sub	fp, #4
	rdlong	local03, fp
	add	local03, #1
	wrlong	local03, fp
	sub	fp, #4
	rdlong	local03, fp
	sub	local03, #1
	wrlong	local03, fp
	add	fp, #20
	rdlong	local03, fp wz
	sub	fp, #32
 if_e	jmp	#LR__4064
	add	fp, #20
	rdlong	local02, fp
	sub	fp, #20
	cmp	local02, #10 wz
 if_ne	jmp	#LR__4064
LR__4065
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
LR__4066
	mov	ptra, fp
	call	#popregs_
__system___vfsread_ret
	ret

__system____default_filbuf
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #12
	rdlong	result1, local02 wz
	sub	local02, #12
 if_ne	jmp	#LR__4070
	add	local02, #20
	mov	result1, local02
	sub	local02, #4
	wrlong	result1, local02
	sub	local02, #4
	wrlong	##1024, local02
	sub	local02, #12
LR__4070
	add	local01, #20
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #20
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	add	local02, #16
	rdlong	arg02, local02
	sub	local02, #4
	rdlong	arg03, local02
	sub	local02, #12
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local01
	mov	local04, result1
	cmps	local04, #0 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__4071
	wrlong	local04, local02
	add	local02, #16
	rdlong	local03, local02
	sub	local02, #12
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	or	local03, #1
	wrlong	local03, local02
	mov	result1, local04
LR__4071
	mov	ptra, fp
	call	#popregs_
__system____default_filbuf_ret
	ret

__system__getlower_1110
	cmps	arg01, #65 wc
 if_b	jmp	#LR__4080
	cmps	arg01, #91 wc
 if_b	mov	result1, arg01
 if_b	add	result1, #32
 if_b	jmp	#__system__getlower_1110_ret
LR__4080
	mov	result1, arg01
__system__getlower_1110_ret
	ret

__system___pat_match
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
LR__4090
	rdbyte	arg01, arg02 wz
 if_ne	rdbyte	arg01, local01 wz
 if_ne	rdbyte	local02, arg02
 if_ne	cmp	local02, #42 wz
 if_e	jmp	#LR__4091
	rdbyte	arg01, arg02
	call	#__system__getlower_1110
	mov	local03, result1
	rdbyte	arg01, local01
	call	#__system__getlower_1110
	cmp	result1, local03 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4099
	add	local01, #1
	add	arg02, #1
	jmp	#LR__4090
LR__4091
	rdbyte	local03, arg02
	cmp	local03, #42 wz
 if_ne	jmp	#LR__4098
	add	arg02, #1
	rdbyte	local02, arg02
	sub	arg02, #1
	cmp	local02, #46 wz
 if_ne	jmp	#LR__4092
	add	arg02, #2
	rdbyte	local02, arg02
	sub	arg02, #2
	cmp	local02, #42 wz
 if_e	add	arg02, #3
 if_e	rdbyte	local04, arg02
 if_e	sub	arg02, #3
 if_e	mov	local05, local04 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4099
LR__4092
	add	arg02, #1
	mov	local06, #0
	callpa	#(@LR__4095-@LR__4093)>>2,fcache_load_ptr_
LR__4093
	mov	local07, local06
	add	local07, arg02
	rdbyte	local07, local07 wz
 if_ne	mov	local05, local06
 if_ne	add	local05, #1
 if_ne	mov	local06, local05
 if_ne	jmp	#LR__4093
	mov	local08, #0
LR__4094
	mov	local07, local08
	add	local07, local01
	rdbyte	local07, local07 wz
 if_ne	mov	local05, local08
 if_ne	add	local05, #1
 if_ne	mov	local08, local05
 if_ne	jmp	#LR__4094
LR__4095
	cmps	local08, local06 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__4099
	mov	local02, local08
	sub	local02, local06
	add	local01, local02
LR__4096
	cmps	local06, #1 wc
 if_b	jmp	#LR__4097
	rdbyte	arg01, local01
	call	#__system__getlower_1110
	mov	local08, result1
	rdbyte	arg01, arg02
	call	#__system__getlower_1110
	cmp	local08, result1 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4099
	add	local01, #1
	add	arg02, #1
	sub	local06, #1
	jmp	#LR__4096
LR__4097
LR__4098
	rdbyte	local08, arg02 wz
 if_e	rdbyte	local07, local01 wz
 if_e	mov	result1, #1
 if_ne	mov	result1, #0
LR__4099
	mov	ptra, fp
	call	#popregs_
__system___pat_match_ret
	ret

_fatfs_cc_ff_uni2oem
	mov	_var01, #0
	cmp	arg01, #128 wc
 if_b	mov	_var01, arg01
 if_b	jmp	#LR__4104
	cmp	arg01, ##65536 wc
 if_ae	jmp	#LR__4103
	getword	result1, arg02, #0
	cmp	result1, ##850 wz
 if_ne	jmp	#LR__4103
' 			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
	mov	_var01, #0
	callpa	#(@LR__4101-@LR__4100)>>2,fcache_load_ptr_
LR__4100
	getword	result1, _var01, #0
	cmp	result1, #128 wc
 if_ae	jmp	#LR__4102
	getword	result1, _var01, #0
	shl	result1, #1
	add	result1, ptr__fatfs_cc_dat__
	rdword	result1, result1
	cmp	arg01, result1 wz
 if_ne	add	_var01, #1
 if_ne	jmp	#LR__4100
LR__4101
LR__4102
	getword	_var01, _var01, #0
	add	_var01, #128
	getbyte	_var01, _var01, #0
LR__4103
LR__4104
' 			c = (c + 0x80) & 0xFF;
' 		}
' 	}
' 
' 	return c;
	mov	result1, _var01
_fatfs_cc_ff_uni2oem_ret
	ret

_fatfs_cc_ff_oem2uni
	mov	_var01, #0
	getword	result1, arg01, #0
	cmp	result1, #128 wc
 if_b	mov	_var01, arg01
 if_b	jmp	#LR__4111
	getword	arg02, arg02, #0
	cmp	arg02, ##850 wz
 if_ne	jmp	#LR__4110
	getword	result1, arg01, #0
	cmp	result1, #256 wc
 if_b	getword	arg01, arg01, #0
 if_b	sub	arg01, #128
 if_b	shl	arg01, #1
 if_b	add	arg01, ptr__fatfs_cc_dat__
 if_b	rdword	_var01, arg01
LR__4110
LR__4111
' 		}
' 	}
' 
' 	return c;
	mov	result1, _var01
_fatfs_cc_ff_oem2uni_ret
	ret

_fatfs_cc_ff_wtoupper
	mov	_var01, arg01
	cmp	_var01, ##65536 wc
 if_ae	jmp	#LR__4133
	mov	_var02, _var01
	getword	_var01, _var02, #0
	cmp	_var01, ##4096 wc
 if_b	add	ptr__fatfs_cc_dat__, #256
 if_b	mov	_var03, ptr__fatfs_cc_dat__
 if_b	sub	ptr__fatfs_cc_dat__, #256
 if_ae	add	ptr__fatfs_cc_dat__, ##754
 if_ae	mov	_var03, ptr__fatfs_cc_dat__
 if_ae	sub	ptr__fatfs_cc_dat__, ##754
	mov	_var04, _var03
' 		uc = (WORD)uni;
' 		p = uc < 0x1000 ? cvt1 : cvt2;
' 		for (;;) {
LR__4120
	rdword	_var05, _var04
	mov	_var03, _var05
	zerox	_var03, #15 wz
	add	_var04, #2
 if_e	jmp	#LR__4132
	getword	_var03, _var02, #0
	getword	_var01, _var05, #0
	cmp	_var03, _var01 wc
 if_b	jmp	#LR__4132
	rdword	_var06, _var04
	getword	_var07, _var06, #0
	shr	_var07, #8
	getword	_var06, _var06, #0
	getbyte	_var06, _var06, #0
	getword	_var03, _var02, #0
	getword	_var08, _var05, #0
	getword	_var01, _var06, #0
	add	_var08, _var01
	cmps	_var03, _var08 wc
	add	_var04, #2
 if_ae	jmp	#LR__4131
' 				switch (cmd) {
	getword	_var09, _var07, #0
	fle	_var09, #9
	jmprel	_var09
LR__4121
	jmp	#LR__4122
	jmp	#LR__4123
	jmp	#LR__4124
	jmp	#LR__4125
	jmp	#LR__4126
	jmp	#LR__4127
	jmp	#LR__4128
	jmp	#LR__4129
	jmp	#LR__4130
	jmp	#LR__4132
LR__4122
	getword	_var02, _var02, #0
	getword	_var05, _var05, #0
	sub	_var02, _var05
	shl	_var02, #1
	add	_var02, _var04
	rdword	_var02, _var02
	jmp	#LR__4132
LR__4123
	getword	_var03, _var02, #0
	getword	_var02, _var02, #0
	getword	_var05, _var05, #0
	sub	_var02, _var05
	and	_var02, #1
	subr	_var02, _var03
	jmp	#LR__4132
LR__4124
	getword	_var02, _var02, #0
	sub	_var02, #16
	jmp	#LR__4132
LR__4125
	getword	_var02, _var02, #0
	sub	_var02, #32
	jmp	#LR__4132
LR__4126
	getword	_var02, _var02, #0
	sub	_var02, #48
	jmp	#LR__4132
LR__4127
	getword	_var02, _var02, #0
	sub	_var02, #26
	jmp	#LR__4132
LR__4128
	getword	_var02, _var02, #0
	add	_var02, #8
	jmp	#LR__4132
LR__4129
	getword	_var02, _var02, #0
	sub	_var02, #80
	jmp	#LR__4132
LR__4130
	getword	_var02, _var02, #0
	sub	_var02, ##7264
' 				}
' 				break;
	jmp	#LR__4132
LR__4131
	zerox	_var07, #15 wz
 if_e	mul	_var06, #2
 if_e	add	_var04, _var06
	jmp	#LR__4120
LR__4132
	getword	_var01, _var02, #0
LR__4133
' 		}
' 		uni = uc;
' 	}
' 
' 	return uni;
	mov	result1, _var01
_fatfs_cc_ff_wtoupper_ret
	ret

_fatfs_cc_strncpy
	mov	_var01, arg01
	callpa	#(@LR__4141-@LR__4140)>>2,fcache_load_ptr_
' 
' 	dscan = dst;
' 	sscan = src;
' 	count = n;
' 	while (--count >= 0 && (*dscan++ = *sscan++) != '\0')
LR__4140
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_b	jmp	#LR__4142
	rdbyte	result1, arg02
	wrbyte	result1, _var01
	add	arg02, #1
	rdbyte	result1, _var01 wz
' 		continue;
	add	_var01, #1
 if_ne	jmp	#LR__4140
LR__4141
LR__4142
	callpa	#(@LR__4144-@LR__4143)>>2,fcache_load_ptr_
' 	while (--count >= 0)
LR__4143
	sub	arg03, #1
	cmps	arg03, #0 wc
 if_ae	mov	_var02, _var01
 if_ae	add	_var01, #1
 if_ae	wrbyte	#0, _var02
 if_ae	jmp	#LR__4143
LR__4144
' 		*dscan++ = '\0';
' 	return(dst);
	mov	result1, arg01
_fatfs_cc_strncpy_ret
	ret

_fatfs_cc_memcmp
' 	for (n = size; n > 0; n--)
	cmp	arg03, #0 wz
 if_e	jmp	#LR__4151
LR__4150
	rdbyte	_var01, arg01
	rdbyte	_var02, arg02
	cmp	_var01, _var02 wz
 if_e	add	arg01, #1
 if_e	add	arg02, #1
' 			return( ((unsigned char)(*scan1))  -  ((unsigned char)(*scan2)) );
 if_ne	rdbyte	result1, arg01
 if_ne	rdbyte	_var02, arg02
 if_ne	sub	result1, _var02
 if_ne	jmp	#_fatfs_cc_memcmp_ret
	djnz	arg03, #LR__4150
LR__4151
' 
' 	return(0);
	mov	result1, #0
_fatfs_cc_memcmp_ret
	ret

_fatfs_cc_strncmp
	mov	_var01, arg01 wz
 if_ne	jmp	#LR__4160
' 		return scan2 ? -1 : 0;
	cmp	arg02, #0 wz
 if_ne	neg	_var02, #1
 if_e	mov	_var02, #0
	mov	result1, _var02
	jmp	#_fatfs_cc_strncmp_ret
LR__4160
	cmp	arg02, #0 wz
 if_e	mov	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	mov	_var03, arg03
	callpa	#(@LR__4162-@LR__4161)>>2,fcache_load_ptr_
' 	count = n;
' 	do {
LR__4161
	rdbyte	_var04, _var01
	mov	_var05, arg02
	rdbyte	_var06, _var05
	sub	_var03, #1
	cmps	_var03, #0 wc
	add	_var01, #1
	add	arg02, #1
 if_ae	cmp	_var04, #0 wz
 if_nc_and_z	jmp	#LR__4163
 if_ae	cmp	_var04, _var06 wz
 if_nc_and_z	jmp	#LR__4161
LR__4162
LR__4163
	cmps	_var03, #0 wc
' 		return(0);
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, _var06 wz
' 		return(0);
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var04, #0 wz
' 		return(-1);
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_strncmp_ret
	cmp	_var06, #0 wz
' 		return(1);
 if_e	mov	result1, #1
' 		return(c1 - c2);
 if_ne	mov	result1, _var04
 if_ne	sub	result1, _var06
_fatfs_cc_strncmp_ret
	ret

_fatfs_cc_strchr
' #line 16 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/libc/string/strchr.c"
' 	while ((c = *s++) != (char) charwanted)
LR__4170
	mov	_var01, arg01
	rdbyte	_var02, _var01
	getbyte	_var03, _var02, #0
	getbyte	_var04, arg02, #0
	cmp	_var03, _var04 wz
	add	arg01, #1
 if_e	jmp	#LR__4171
	mov	_var03, _var02
	zerox	_var03, #7 wz
 if_e	mov	result1, #0
 if_e	jmp	#_fatfs_cc_strchr_ret
	jmp	#LR__4170
LR__4171
' 	return((char *)--s);
	sub	arg01, #1
	mov	result1, arg01
_fatfs_cc_strchr_ret
	ret

_fatfs_cc_disk_initialize
	mov	COUNT_, #4
	call	#pushregs_
	add	ptra, #64
	add	fp, #4
	wrbyte	arg01, fp
	add	objptr, ##532
	rdlong	arg04, objptr
	add	fp, #44
	wrlong	arg04, fp
	sub	objptr, #4
	rdlong	arg04, objptr
	add	fp, #4
	wrlong	arg04, fp
	add	objptr, #8
	rdlong	arg04, objptr
	add	fp, #4
	wrlong	arg04, fp
	add	objptr, #4
	rdlong	arg04, objptr
	add	fp, #4
	wrlong	arg04, fp
	add	objptr, #4
	wrbyte	#1, objptr
	sub	objptr, ##544
	sub	fp, #56
	rdbyte	arg04, fp wz
	sub	fp, #4
' #line 531 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/sdmm.cc"
'             return RES_NOTRDY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4198
	mov	arg01, ##10000
	call	#__system___waitus
	add	fp, #48
	rdlong	arg01, fp
	wrpin	#0, arg01
	add	fp, #4
	rdlong	arg01, fp
	wrpin	#0, arg01
	add	fp, #4
	rdlong	arg01, fp
	wrpin	#0, arg01
	add	fp, #4
	rdlong	arg01, fp
	wrpin	##4608, arg01
	sub	fp, #12
	rdlong	arg01, fp
	drvh	arg01
	add	fp, #4
	rdlong	arg01, fp
	drvh	arg01
	add	fp, #4
	rdlong	arg01, fp
	drvh	arg01
	add	fp, #4
	rdlong	arg01, fp
	drvh	arg01
	sub	fp, #32
	wrlong	##524304, fp
	add	fp, #4
	wrlong	##409672, fp
	add	fp, #20
	rdlong	local01, fp
	sub	fp, #24
	rdlong	arg03, fp
	dirl	local01
	wrpin	##475208, local01
	wxpin	arg03, local01
	wypin	#0, local01
	dirh	local01
	add	fp, #28
	rdlong	local02, fp
	sub	local01, local02
	and	local01, #7
	shl	local01, #24
	mov	arg02, #120
	or	arg02, local01
	sub	fp, #20
	wrlong	arg02, fp
	add	fp, #20
	rdlong	arg01, fp
	bith	arg02, #16
	dirl	arg01
	wrpin	arg02, arg01
	wxpin	#31, arg01
	wypin	##-1, arg01
	dirh	arg01
	sub	fp, #4
	rdlong	arg02, fp
	add	fp, #8
	rdlong	local03, fp
	sub	arg02, local03
	and	arg02, #7
	shl	arg02, #24
	sub	fp, #20
	wrlong	arg02, fp
	or	arg02, ##21114
	wrlong	arg02, fp
	add	fp, #20
	rdlong	arg01, fp
	dirl	arg01
	wrpin	arg02, arg01
	wxpin	#39, arg01
	wypin	#0, arg01
	dirh	arg01
	sub	fp, #40
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #10
	call	#_fatfs_cc_rcvr_mmc_1144
	mov	arg01, #0
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1168
	call	#_fatfs_cc_deselect_1154
	mov	arg01, #100
	call	#__system___waitus
	add	fp, #20
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #10
	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #12
	wrbyte	#0, fp
	sub	fp, #12
	mov	arg01, #0
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1168
	getbyte	arg04, result1, #0
	cmp	arg04, #1 wz
 if_ne	jmp	#LR__4197
	mov	arg01, #8
	mov	arg02, #426
	call	#_fatfs_cc_send_cmd_1168
	getbyte	result1, result1, #0
	cmp	result1, #1 wz
 if_ne	jmp	#LR__4183
	add	fp, #20
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #4
	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #22
	rdbyte	local04, fp
	sub	fp, #22
	cmp	local04, #1 wz
 if_e	add	fp, #23
 if_e	rdbyte	local03, fp
 if_e	sub	fp, #23
 if_e	cmp	local03, #170 wz
 if_ne	jmp	#LR__4196
' 				for (tmr = 1000; tmr; tmr--) {
	add	fp, #24
	wrlong	##1000, fp
	sub	fp, #24
LR__4180
	add	fp, #24
	rdlong	local01, fp wz
	sub	fp, #24
 if_e	jmp	#LR__4181
	mov	arg01, #169
	decod	arg02, #30
	call	#_fatfs_cc_send_cmd_1168
	mov	local04, result1
	zerox	local04, #7 wz
 if_e	jmp	#LR__4181
	mov	arg01, ##1000
	call	#__system___waitus
	add	fp, #24
	rdlong	local04, fp
	sub	local04, #1
	wrlong	local04, fp
	sub	fp, #24
	jmp	#LR__4180
LR__4181
	add	fp, #24
	rdlong	local04, fp wz
	sub	fp, #24
 if_e	jmp	#LR__4182
	mov	arg01, #58
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1168
	mov	local03, result1
	zerox	local03, #7 wz
 if_ne	jmp	#LR__4182
	add	fp, #20
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #4
	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #20
	rdbyte	local01, fp
	test	local01, #64 wz
 if_ne	mov	local04, #12
 if_e	mov	local04, #4
	sub	fp, #8
	wrbyte	local04, fp
	sub	fp, #12
LR__4182
	rdlong	local04, #20
	add	fp, #24
	wrlong	local04, fp
	add	fp, #12
	rdlong	local04, fp
	bith	local04, #27
	wrlong	local04, fp
	sub	fp, #12
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##150000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##131076, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__4196
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##200000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##131077, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__4196
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##280000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##131078, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__4196
	add	fp, #28
	wrlong	##196616, fp
	sub	fp, #28
	jmp	#LR__4196
LR__4183
	mov	arg01, #169
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1168
	getbyte	local04, result1, #0
	cmp	local04, #2 wc
 if_ae	jmp	#LR__4184
	add	fp, #12
	wrbyte	#2, fp
	add	fp, #4
	wrbyte	#169, fp
	sub	fp, #16
	jmp	#LR__4185
LR__4184
	add	fp, #12
	wrbyte	#1, fp
	add	fp, #4
	wrbyte	#1, fp
	sub	fp, #16
LR__4185
' 				ty =  0x01 ; cmd =  (1) ;
' 			}
' 			for (tmr = 1000; tmr; tmr--) {
	add	fp, #24
	wrlong	##1000, fp
	sub	fp, #24
LR__4186
	add	fp, #24
	rdlong	local03, fp wz
	sub	fp, #24
 if_e	jmp	#LR__4187
	add	fp, #16
	rdbyte	arg01, fp
	sub	fp, #16
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1168
	mov	local04, result1
	zerox	local04, #7 wz
 if_e	jmp	#LR__4187
	mov	arg01, ##1000
	call	#__system___waitus
	add	fp, #24
	rdlong	local04, fp
	sub	local04, #1
	wrlong	local04, fp
	sub	fp, #24
	jmp	#LR__4186
LR__4187
	add	fp, #24
	rdlong	local04, fp wz
	sub	fp, #24
 if_e	jmp	#LR__4188
	mov	arg01, #16
	decod	arg02, #9
	call	#_fatfs_cc_send_cmd_1168
	zerox	result1, #7 wz
 if_e	jmp	#LR__4189
LR__4188
	add	fp, #12
	wrbyte	#0, fp
	sub	fp, #12
LR__4189
	rdlong	local04, #20
	add	fp, #24
	wrlong	local04, fp
	sub	fp, #24
	cmp	local04, ##100000001 wc
 if_ae	jmp	#LR__4190
	add	fp, #36
	rdlong	local04, fp
	bith	local04, #27
	wrlong	local04, fp
	sub	fp, #36
	jmp	#LR__4191
LR__4190
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##200000001 wc
 if_b	add	fp, #36
 if_b	rdlong	local04, fp
 if_b	or	local04, ##134283264
 if_b	wrlong	local04, fp
 if_b	sub	fp, #36
LR__4191
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##100000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##131076, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__4195
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##150000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##196614, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__4194
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##200000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##262152, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__4193
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##250000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##327690, fp
 if_b	sub	fp, #28
 if_b	jmp	#LR__4192
	add	fp, #24
	rdlong	local04, fp
	sub	fp, #24
	cmp	local04, ##300000001 wc
 if_b	add	fp, #28
 if_b	wrlong	##393228, fp
	sumc	fp, #28
 if_ae	wrlong	##458766, fp
 if_ae	sub	fp, #28
LR__4192
LR__4193
LR__4194
LR__4195
LR__4196
LR__4197
	add	fp, #12
	rdbyte	local04, fp
	add	objptr, ##545
	wrbyte	local04, objptr
	rdbyte	local01, fp wz
 if_ne	mov	local04, #0
 if_e	mov	local04, #1
	add	fp, #32
	wrbyte	local04, fp
	rdbyte	local04, fp
	sub	fp, #44
	sub	objptr, #1
	wrbyte	local04, objptr
	sub	objptr, ##544
	call	#_fatfs_cc_deselect_1154
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #24
	rdlong	arg02, fp
	wxpin	arg02, arg01
	add	fp, #28
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	wrpin	arg02, arg01
' 
' 		}
' 	}
' #line 631 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/sdmm.cc"
' 	CardType = ty;
' 	s = ty ? 0 :  0x01 ;
' 	Stat = s;
' 
' 	deselect();
' 
' 
' 	_wxpin( PIN_CLK, ck_div );
' 	_wrpin( PIN_DI, spm_tx );
' #line 644 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/sdmm.cc"
' 	return s;
	add	fp, #8
	rdbyte	result1, fp
	sub	fp, #44
LR__4198
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_initialize_ret
	ret

_fatfs_cc_disk_read
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4202
	add	objptr, ##545
	rdbyte	local04, objptr
	sub	objptr, ##545
	test	local04, #8 wz
 if_e	shl	local02, #9
	cmp	local03, #2 wc
 if_ae	mov	local04, #18
 if_b	mov	local04, #17
	mov	arg02, local02
	mov	arg01, local04
	call	#_fatfs_cc_send_cmd_1168
	mov	local05, result1
	zerox	local05, #7 wz
 if_ne	jmp	#LR__4201
' 		do {
LR__4200
	mov	arg01, local01
	decod	arg02, #9
	call	#_fatfs_cc_rcvr_datablock_1162
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local03, #LR__4200
	getbyte	local04, local04, #0
	cmp	local04, #18 wz
 if_e	mov	arg01, #12
 if_e	mov	arg02, #0
 if_e	call	#_fatfs_cc_send_cmd_1168
LR__4201
	call	#_fatfs_cc_deselect_1154
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local03, #0 wz
 if_ne	mov	local05, #1
 if_e	mov	local05, #0
	mov	result1, local05
LR__4202
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_read_ret
	ret

_fatfs_cc_disk_write
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg04
	mov	local03, arg03
	cmp	arg01, #0 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4214
	add	objptr, ##545
	rdbyte	arg03, objptr
	sub	objptr, ##545
	test	arg03, #8 wz
 if_e	shl	local03, #9
	cmp	local02, #1 wz
 if_ne	jmp	#LR__4210
	mov	arg01, #24
	mov	arg02, local03
	call	#_fatfs_cc_send_cmd_1168
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__4213
	mov	arg01, local01
	mov	arg02, #254
	call	#_fatfs_cc_xmit_datablock_1164
	cmp	result1, #0 wz
 if_ne	mov	local02, #0
	jmp	#LR__4213
LR__4210
	add	objptr, ##545
	rdbyte	local04, objptr
	sub	objptr, ##545
	test	local04, #6 wz
 if_ne	mov	arg01, #151
 if_ne	mov	arg02, local02
 if_ne	call	#_fatfs_cc_send_cmd_1168
	mov	arg02, local03
	mov	arg01, #25
	call	#_fatfs_cc_send_cmd_1168
	mov	local04, result1
	zerox	local04, #7 wz
 if_ne	jmp	#LR__4212
' 			do {
LR__4211
	mov	arg01, local01
	mov	arg02, #252
	call	#_fatfs_cc_xmit_datablock_1164
	cmp	result1, #0 wz
 if_ne	add	local01, ##512
 if_ne	djnz	local02, #LR__4211
	mov	arg01, #0
	mov	arg02, #253
	call	#_fatfs_cc_xmit_datablock_1164
	cmp	result1, #0 wz
 if_e	mov	local02, #1
LR__4212
LR__4213
	call	#_fatfs_cc_deselect_1154
' 				count = 1;
' 		}
' 	}
' 	deselect();
' 
' 	return count ? RES_ERROR : RES_OK;
	cmp	local02, #0 wz
 if_ne	mov	local04, #1
 if_e	mov	local04, #0
	mov	result1, local04
LR__4214
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_write_ret
	ret

_fatfs_cc_disk_ioctl
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #48
	add	fp, #4
	wrbyte	arg01, fp
	add	fp, #4
	wrbyte	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdbyte	arg01, fp wz
	sub	fp, #4
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	result1, result1, #0
	test	result1, #1 wz
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4228
	add	fp, #16
	wrlong	#1, fp
' 
' 	res = RES_ERROR;
' 	switch (ctrl) {
	sub	fp, #8
	rdbyte	local01, fp
	sub	fp, #8
	fle	local01, #4
	jmprel	local01
LR__4220
	jmp	#LR__4221
	jmp	#LR__4222
	jmp	#LR__4226
	jmp	#LR__4225
	jmp	#LR__4226
LR__4221
	call	#_fatfs_cc_select_1158
	cmp	result1, #0 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#0, fp
 if_ne	sub	fp, #16
' 			break;
	jmp	#LR__4227
LR__4222
	mov	arg01, #9
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1168
	mov	local01, result1
	zerox	local01, #7 wz
 if_ne	jmp	#LR__4227
	add	fp, #24
	mov	arg01, fp
	sub	fp, #24
	mov	arg02, #16
	call	#_fatfs_cc_rcvr_datablock_1162
	cmp	result1, #0 wz
 if_e	jmp	#LR__4227
	add	fp, #24
	rdbyte	local01, fp
	sub	fp, #24
	shr	local01, #6
	cmp	local01, #1 wz
 if_ne	jmp	#LR__4223
	add	fp, #33
	rdbyte	local01, fp
	sub	fp, #1
	rdbyte	result1, fp
	getword	result1, result1, #0
	shl	result1, #8
	add	local01, result1
	sub	fp, #1
	rdbyte	result1, fp
	and	result1, #63
	shl	result1, #16
	add	local01, result1
	add	local01, #1
	add	fp, #9
	wrlong	local01, fp
	sub	fp, #28
	rdlong	local01, fp
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #40
	shl	result1, #10
	wrlong	result1, local01
	jmp	#LR__4224
LR__4223
	add	fp, #29
	rdbyte	local01, fp
	getnib	local01, local01, #0
	add	fp, #5
	rdbyte	result1, fp
	and	result1, #128
	sar	result1, #7
	add	local01, result1
	sub	fp, #1
	rdbyte	result1, fp
	and	result1, #3
	shl	result1, #1
	add	local01, result1
	add	local01, #2
	sub	fp, #13
	wrbyte	local01, fp
	add	fp, #12
	rdbyte	local01, fp
	shr	local01, #6
	sub	fp, #1
	rdbyte	result1, fp
	getword	result1, result1, #0
	shl	result1, #2
	add	local01, result1
	sub	fp, #1
	rdbyte	result1, fp
	and	result1, #3
	getword	result1, result1, #0
	shl	result1, #10
	add	local01, result1
	add	local01, #1
	add	fp, #10
	wrlong	local01, fp
	sub	fp, #28
	rdlong	local01, fp
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #20
	rdbyte	arg03, fp
	sub	fp, #20
	sub	arg03, #9
	shl	result1, arg03
	wrlong	result1, local01
LR__4224
	add	fp, #16
	wrlong	#0, fp
	sub	fp, #16
' 					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
' 					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
' 					*(LBA_t*)buff = cs << (n - 9);
' 				}
' 				res = RES_OK;
' 			}
' 			break;
	jmp	#LR__4227
LR__4225
	add	fp, #12
	rdlong	local01, fp
	wrlong	#128, local01
	add	fp, #4
	wrlong	#0, fp
	sub	fp, #16
' 			*(DWORD*)buff = 128;
' 			res = RES_OK;
' 			break;
	jmp	#LR__4227
LR__4226
	add	fp, #16
	wrlong	#4, fp
	sub	fp, #16
LR__4227
	call	#_fatfs_cc_deselect_1154
' 			res = RES_PARERR;
' 	}
' 
' 	deselect();
' 
' 	return res;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
LR__4228
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_ioctl_ret
	ret

_fatfs_cc_disk_setpins
	cmp	arg01, #0 wz
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_disk_setpins_ret
	add	objptr, ##528
	wrlong	arg02, objptr
	add	objptr, #4
	wrlong	arg03, objptr
	add	objptr, #4
	wrlong	arg04, objptr
	add	objptr, #4
	wrlong	arg05, objptr
	sub	objptr, ##540
	mov	result1, #0
_fatfs_cc_disk_setpins_ret
	ret

_fatfs_cc_tchar2uni
	rdlong	_var01, arg01
	mov	_var02, _var01
	add	_var01, #1
	mov	_var03, _var01
	rdbyte	_var04, _var02
	test	_var04, #128 wz
 if_e	jmp	#LR__4237
	mov	_var05, _var04
	and	_var05, #224
	cmp	_var05, #192 wz
 if_e	and	_var04, #31
 if_e	mov	_var06, #1
 if_e	jmp	#LR__4231
	mov	_var05, _var04
	and	_var05, #240
	cmp	_var05, #224 wz
 if_e	getnib	_var04, _var04, #0
 if_e	mov	_var06, #2
 if_e	jmp	#LR__4230
	mov	_var05, _var04
	and	_var05, #248
	cmp	_var05, #240 wz
 if_e	and	_var04, #7
 if_e	mov	_var06, #3
' 			return 0xFFFFFFFF;
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_tchar2uni_ret
LR__4230
LR__4231
' 		}
' 		do {
LR__4232
	rdbyte	_var07, _var03
	getbyte	_var05, _var07, #0
	and	_var05, #192
	cmp	_var05, #128 wz
	add	_var03, #1
 if_ne	neg	result1, #1
 if_ne	jmp	#_fatfs_cc_tchar2uni_ret
	shl	_var04, #6
	getbyte	_var02, _var07, #0
	and	_var02, #63
	or	_var04, _var02
	djnz	_var06, #LR__4232
	cmp	_var04, #128 wc
 if_b	jmp	#LR__4234
	cmp	_var04, ##55296 wc
 if_b	jmp	#LR__4233
	cmp	_var04, ##57344 wc
 if_b	jmp	#LR__4234
LR__4233
	cmp	_var04, ##1114112 wc
 if_b	jmp	#LR__4235
LR__4234
	neg	result1, #1
	jmp	#_fatfs_cc_tchar2uni_ret
LR__4235
	cmp	_var04, ##65536 wc
 if_b	jmp	#LR__4236
	mov	_var02, _var04
	sub	_var02, ##65536
	shl	_var02, #6
	and	_var02, ##67043328
	mov	_var05, ##-671032320
	or	_var05, _var02
	zerox	_var04, #9
	or	_var04, _var05
LR__4236
LR__4237
	wrlong	_var03, arg01
' 	}
' #line 811 "ff.c"
' 	*str = p;
' 	return uc;
	mov	result1, _var04
_fatfs_cc_tchar2uni_ret
	ret

_fatfs_cc_put_utf
	cmp	arg01, #128 wc
 if_ae	jmp	#LR__4240
	cmp	arg03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	wrbyte	arg01, arg02
' 		*buf = (TCHAR)chr;
' 		return 1;
	mov	result1, #1
	jmp	#_fatfs_cc_put_utf_ret
LR__4240
	cmp	arg01, ##2048 wc
 if_ae	jmp	#LR__4241
	cmp	arg03, #2 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	mov	result1, arg01
	shr	result1, #6
	and	result1, #31
	mov	arg03, #192
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	arg01, #63
	mov	result1, #128
	or	result1, arg01
	wrbyte	result1, arg02
' 		*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 		return 2;
	mov	result1, #2
	jmp	#_fatfs_cc_put_utf_ret
LR__4241
	cmp	arg01, ##65536 wc
 if_ae	jmp	#LR__4244
	cmp	arg03, #3 wc
 if_b	jmp	#LR__4242
	cmp	arg01, ##55296 wc
 if_b	jmp	#LR__4243
	cmp	arg01, ##57344 wc
 if_ae	jmp	#LR__4243
LR__4242
	mov	result1, #0
	jmp	#_fatfs_cc_put_utf_ret
LR__4243
	getnib	result1, arg01, #3
	mov	arg03, #224
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, arg01
	shr	result1, #6
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	arg01, #63
	mov	result1, #128
	or	result1, arg01
	wrbyte	result1, arg02
' 		*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 		return 3;
	mov	result1, #3
	jmp	#_fatfs_cc_put_utf_ret
LR__4244
	cmp	arg03, #4 wc
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc_put_utf_ret
	mov	_var01, arg01
	bitl	_var01, #480
	sub	_var01, ##-671088640
	shr	_var01, #6
	getword	arg01, arg01, #0
	sub	arg01, ##56320
	cmp	_var01, ##1048576 wc
 if_b	cmp	arg01, ##1024 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#_fatfs_cc_put_utf_ret
	or	_var01, arg01
	add	_var01, ##65536
	mov	result1, _var01
	shr	result1, #18
	and	result1, #7
	mov	arg03, #240
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, _var01
	shr	result1, #12
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	mov	result1, _var01
	shr	result1, #6
	and	result1, #63
	mov	arg03, #128
	or	arg03, result1
	wrbyte	arg03, arg02
	add	arg02, #1
	and	_var01, #63
	mov	result1, #128
	or	result1, _var01
	wrbyte	result1, arg02
' 	chr = (hc | chr) + 0x10000;
' 	*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
' 	*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
' 	return 4;
	mov	result1, #4
_fatfs_cc_put_utf_ret
	ret

_fatfs_cc_sync_window
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #3
	rdbyte	result1, local01 wz
	sub	local01, #3
 if_e	jmp	#LR__4252
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #48
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4250
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #45
	rdlong	result1, local01
	sub	local01, #12
	rdlong	arg04, local01
	sub	result1, arg04
	sub	local01, #8
	rdlong	arg04, local01
	sub	local01, #28
	cmp	result1, arg04 wc
 if_ae	jmp	#LR__4251
	add	local01, #2
	rdbyte	arg04, local01
	sub	local01, #2
	cmp	arg04, #2 wz
 if_ne	jmp	#LR__4251
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	sub	local01, #4
	rdlong	arg03, local01
	sub	local01, #20
	rdlong	local01, local01
	add	arg03, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	jmp	#LR__4251
LR__4250
	mov	local02, #1
LR__4251
LR__4252
' 			res = FR_DISK_ERR;
' 		}
' 	}
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_window_ret
	ret

_fatfs_cc_move_window
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #0
	add	local01, #48
	rdlong	arg04, local01
	sub	local01, #48
	cmp	local02, arg04 wz
 if_e	jmp	#LR__4261
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__4260
	add	local01, #1
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	mov	arg03, local02
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	neg	local02, #1
 if_ne	mov	local03, #1
	sub	local01, #4
	wrlong	local02, local01
LR__4260
LR__4261
' 				sect = (LBA_t)0 - 1;
' 				res = FR_DISK_ERR;
' 			}
' 			fs->winsect = sect;
' 		}
' 	}
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_move_window_ret
	ret

_fatfs_cc_sync_fs
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	call	#_fatfs_cc_sync_window
	mov	local02, result1 wz
 if_ne	jmp	#LR__4271
	rdbyte	arg04, local01
	cmp	arg04, #3 wz
 if_e	add	local01, #4
 if_e	rdbyte	arg04, local01
 if_e	sub	local01, #4
 if_e	cmp	arg04, #1 wz
 if_ne	jmp	#LR__4270
	add	local01, #52
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	arg01, local01
	add	arg01, #510
	wrword	##43605, arg01
	wrlong	##1096897106, local01
	mov	arg01, local01
	add	arg01, #484
	wrlong	##1631679090, arg01
	mov	arg01, local01
	add	arg01, #488
	sub	local01, #32
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #32
	mov	arg01, local01
	add	arg01, #492
	sub	local01, #36
	rdlong	arg02, local01
	wrlong	arg02, arg01
	add	local01, #16
	rdlong	arg03, local01
	add	arg03, #1
	add	local01, #16
	wrlong	arg03, local01
	sub	local01, #47
	rdbyte	arg01, local01
	add	local01, #51
	mov	arg02, local01
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	sub	local01, #48
	wrbyte	#0, local01
	sub	local01, #4
LR__4270
	add	local01, #1
	rdbyte	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	call	#_fatfs_cc_disk_ioctl
	cmp	result1, #0 wz
 if_ne	mov	local02, #1
LR__4271
' 	}
' 
' 	return res;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_sync_fs_ret
	ret

_fatfs_cc_clst2sect
	sub	arg02, #2
	add	arg01, #24
	rdlong	_var01, arg01
	sub	arg01, #24
	sub	_var01, #2
	cmp	arg02, _var01 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#_fatfs_cc_clst2sect_ret
	add	arg01, #10
	rdword	_var01, arg01
	qmul	_var01, arg02
' 	return fs->database + (LBA_t)fs->csize * clst;
	add	arg01, #34
	rdlong	result1, arg01
	getqx	_var01
	add	result1, _var01
_fatfs_cc_clst2sect_ret
	ret

_fatfs_cc_get_fat
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg02
	rdlong	local02, arg01
	cmp	local01, #2 wc
 if_b	jmp	#LR__4280
	add	local02, #24
	rdlong	local03, local02
	sub	local02, #24
	cmp	local01, local03 wc
 if_b	jmp	#LR__4281
LR__4280
	mov	local04, #1
	jmp	#LR__4288
LR__4281
	neg	local04, #1
' 		val = 0xFFFFFFFF;
' 
' 		switch (fs->fs_type) {
	rdbyte	local05, local02
	sub	local05, #1
	fle	local05, #3
	jmprel	local05
LR__4282
	jmp	#LR__4283
	jmp	#LR__4284
	jmp	#LR__4285
	jmp	#LR__4286
LR__4283
	mov	local05, local01
	mov	arg01, local01
	shr	arg01, #1
	add	local05, arg01
	mov	arg01, local02
	mov	local06, local05
	shr	local06, #9
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4287
	mov	local06, local05
	and	local06, #511
	add	local02, #52
	add	local06, local02
	rdbyte	local07, local06
	sub	local02, #52
	mov	arg01, local02
	add	local05, #1
	mov	local06, local05
	shr	local06, #9
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4287
	and	local05, #511
	add	local02, #52
	add	local05, local02
	rdbyte	local06, local05
	shl	local06, #8
	or	local07, local06
	test	local01, #1 wz
 if_ne	shr	local07, #4
 if_ne	mov	local03, local07
 if_e	zerox	local07, #11
 if_e	mov	local03, local07
	mov	local04, local03
' 			wc |= fs->win[bc %  ((UINT) 512 ) ] << 8;
' 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
' 			break;
	jmp	#LR__4287
LR__4284
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #8
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4287
	add	local02, #52
	shl	local01, #1
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, local02
	getword	local04, result1, #0
' 			val = ld_word(fs->win + clst * 2 %  ((UINT) 512 ) );
' 			break;
	jmp	#LR__4287
LR__4285
	mov	arg01, local02
	mov	local06, local01
	shr	local06, #7
	add	local02, #36
	rdlong	arg02, local02
	sub	local02, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4287
	add	local02, #52
	shl	local01, #2
	and	local01, #511
	add	local02, local01
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local04, local02
	bitl	local04, #124
' 			val = ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0x0FFFFFFF;
' 			break;
	jmp	#LR__4287
LR__4286
	mov	local04, #1
LR__4287
LR__4288
' 			val = 1;
' 		}
' 	}
' 
' 	return val;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_fat_ret
	ret

_fatfs_cc_put_fat
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, #2
	cmp	local02, #2 wc
 if_b	jmp	#LR__4297
	add	local01, #24
	rdlong	local05, local01
	sub	local01, #24
	cmp	local02, local05 wc
 if_ae	jmp	#LR__4297
' 		switch (fs->fs_type) {
	rdbyte	local06, local01
	sub	local06, #1
	fle	local06, #3
	jmprel	local06
LR__4290
	jmp	#LR__4291
	jmp	#LR__4294
	jmp	#LR__4295
	jmp	#LR__4296
LR__4291
	mov	local07, local02
	mov	local05, local02
	shr	local05, #1
	add	local07, local05
	mov	arg01, local01
	mov	local06, local07
	shr	local06, #9
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local06
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4296
	add	local01, #52
	mov	local08, local01
	mov	local05, local07
	and	local05, #511
	add	local08, local05
	test	local02, #1 wz
	sub	local01, #52
	add	local07, #1
 if_e	jmp	#LR__4292
	rdbyte	local05, local08
	getnib	local05, local05, #0
	getbyte	local06, local03, #0
	shl	local06, #4
	or	local05, local06
	jmp	#LR__4293
LR__4292
	mov	local05, local03
LR__4293
	wrbyte	local05, local08
	add	local01, #3
	wrbyte	#1, local01
	sub	local01, #3
	mov	arg01, local01
	mov	local08, local07
	shr	local08, #9
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4296
	add	local01, #52
	mov	local08, local01
	and	local07, #511
	add	local08, local07
	test	local02, #1 wz
 if_ne	shr	local03, #4
 if_ne	mov	local05, local03
 if_e	rdbyte	local05, local08
 if_e	and	local05, #240
 if_e	getbyte	local03, local03, #1
 if_e	getnib	local03, local03, #0
 if_e	or	local05, local03
	wrbyte	local05, local08
	sub	local01, #49
	wrbyte	#1, local01
' 			p = fs->win + bc %  ((UINT) 512 ) ;
' 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__4296
LR__4294
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #8
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4296
	add	local01, #52
	mov	arg01, local01
	shl	local02, #1
	and	local02, #511
	add	arg01, local02
	wrword	local03, arg01
	sub	local01, #49
	wrbyte	#1, local01
' 			st_word(fs->win + clst * 2 %  ((UINT) 512 ) , (WORD)val);
' 			fs->wflag = 1;
' 			break;
	jmp	#LR__4296
LR__4295
	mov	arg01, local01
	mov	local08, local02
	shr	local08, #7
	add	local01, #36
	rdlong	arg02, local01
	sub	local01, #36
	add	arg02, local08
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4296
	bitl	local03, #124
	add	local01, #52
	mov	local08, local02
	shl	local08, #2
	and	local08, #511
	mov	arg01, local01
	add	arg01, local08
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	local08, arg01
	and	local08, ##-268435456
	or	local03, local08
	mov	arg01, local01
	shl	local02, #2
	and	local02, #511
	add	arg01, local02
	wrlong	local03, arg01
	sub	local01, #49
	wrbyte	#1, local01
' 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0xF0000000);
' 			}
' 			st_dword(fs->win + clst * 4 %  ((UINT) 512 ) , val);
' 			fs->wflag = 1;
' 			break;
LR__4296
LR__4297
' 		}
' 	}
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_put_fat_ret
	ret

_fatfs_cc_remove_chain
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	rdlong	local04, local01
	cmp	local02, #2 wc
 if_b	jmp	#LR__4300
	add	local04, #24
	rdlong	result1, local04
	sub	local04, #24
	cmp	local02, result1 wc
 if_b	jmp	#LR__4301
LR__4300
	mov	result1, #2
	jmp	#LR__4306
LR__4301
	cmp	local03, #0 wz
 if_e	jmp	#LR__4302
	mov	arg02, local03
	mov	arg01, local04
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4306
LR__4302
' 	}
' 
' 
' 	do {
LR__4303
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1 wz
 if_e	jmp	#LR__4305
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__4306
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4306
	mov	arg02, local02
	mov	arg01, local04
	mov	arg03, #0
	call	#_fatfs_cc_put_fat
	mov	local03, result1 wz
 if_ne	mov	result1, local03
 if_ne	jmp	#LR__4306
	add	local04, #24
	rdlong	local03, local04
	sub	local03, #2
	sub	local04, #4
	rdlong	local02, local04
	sub	local04, #20
	cmp	local02, local03 wc
 if_ae	jmp	#LR__4304
	add	local04, #20
	rdlong	local03, local04
	add	local03, #1
	wrlong	local03, local04
	sub	local04, #16
	rdbyte	local03, local04
	or	local03, #1
	wrbyte	local03, local04
	sub	local04, #4
LR__4304
	mov	local02, local05
	add	local04, #24
	rdlong	local05, local04
	sub	local04, #24
	cmp	local02, local05 wc
 if_b	jmp	#LR__4303
LR__4305
' #line 1500 "ff.c"
' 	return FR_OK;
	mov	result1, #0
LR__4306
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_remove_chain_ret
	ret

_fatfs_cc_create_chain
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02 wz
	rdlong	local03, local01
 if_ne	jmp	#LR__4310
	add	local03, #16
	rdlong	local04, local03 wz
	sub	local03, #16
 if_ne	add	local03, #24
 if_ne	rdlong	local05, local03
 if_ne	sub	local03, #24
 if_ne	cmp	local04, local05 wc
 if_c_and_nz	jmp	#LR__4311
	mov	local04, #1
	jmp	#LR__4311
LR__4310
	mov	arg02, local02
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, #2 wc
 if_b	mov	result1, #1
 if_b	jmp	#LR__4321
	cmp	local04, ##-1 wz
 if_e	mov	result1, local04
 if_e	jmp	#LR__4321
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local04, local05 wc
 if_b	mov	result1, local04
 if_b	jmp	#LR__4321
	mov	local04, local02
LR__4311
	add	local03, #20
	rdlong	local05, local03 wz
	sub	local03, #20
 if_e	mov	result1, #0
 if_e	jmp	#LR__4321
	mov	local06, #0
	cmp	local04, local02 wz
 if_ne	jmp	#LR__4314
	mov	local06, local04
	add	local06, #1
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #1 wz
 if_ne	cmp	local05, ##-1 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__4321
	cmp	local05, #0 wz
 if_e	jmp	#LR__4313
	add	local03, #16
	rdlong	local07, local03
	sub	local03, #16
	cmp	local07, #2 wc
 if_b	jmp	#LR__4312
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local07, local05 wc
 if_b	mov	local04, local07
LR__4312
	mov	local06, #0
LR__4313
LR__4314
	cmp	local06, #0 wz
 if_ne	jmp	#LR__4317
	mov	local06, local04
' 			ncl = scl;
' 			for (;;) {
LR__4315
	add	local06, #1
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local06, local05 wc
 if_ae	mov	local06, #2
 if_ae	cmp	local06, local04 wcz
 if_a	mov	result1, #0
 if_a	jmp	#LR__4321
	mov	arg02, local06
	mov	arg01, local01
	call	#_fatfs_cc_get_fat
	mov	local07, result1 wz
 if_e	jmp	#LR__4316
	cmp	local07, #1 wz
 if_ne	cmp	local07, ##-1 wz
 if_e	mov	result1, local07
 if_e	jmp	#LR__4321
	cmp	local06, local04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__4321
	jmp	#LR__4315
LR__4316
LR__4317
	mov	arg01, local03
	mov	arg02, local06
	neg	arg03, #1
	call	#_fatfs_cc_put_fat
	mov	local08, result1 wz
 if_ne	jmp	#LR__4318
	cmp	local02, #0 wz
 if_e	jmp	#LR__4318
	mov	arg01, local03
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_put_fat
	mov	local08, result1
LR__4318
	cmp	local08, #0 wz
 if_ne	jmp	#LR__4319
	add	local03, #16
	wrlong	local06, local03
	add	local03, #8
	rdlong	local05, local03
	sub	local05, #2
	sub	local03, #4
	rdlong	local09, local03
	sub	local03, #20
	cmp	local09, local05 wcz
 if_be	add	local03, #20
 if_be	rdlong	local09, local03
 if_be	sub	local09, #1
 if_be	wrlong	local09, local03
 if_be	sub	local03, #20
	add	local03, #4
	rdbyte	local05, local03
	or	local05, #1
	wrbyte	local05, local03
	jmp	#LR__4320
LR__4319
	cmp	local08, #1 wz
	negz	local06, #1
LR__4320
' 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
' 	}
' 
' 	return ncl;
	mov	result1, local06
LR__4321
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_chain_ret
	ret

_fatfs_cc_dir_clear
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	call	#_fatfs_cc_sync_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__4332
	mov	arg01, local01
	mov	arg02, local02
	call	#_fatfs_cc_clst2sect
	mov	local03, result1
	add	local01, #48
	wrlong	local03, local01
	add	local01, #4
	mov	arg01, local01
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	mov	local04, local01
' #line 1667 "ff.c"
' 	{
' 		ibuf = fs->win; szb = 1;
' 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
	mov	local05, #0
	sub	local01, #52
LR__4330
	add	local01, #10
	rdword	local06, local01
	sub	local01, #10
	cmp	local05, local06 wc
 if_ae	jmp	#LR__4331
	add	local01, #1
	rdbyte	arg01, local01
	sub	local01, #1
	mov	arg02, local04
	mov	arg03, local03
	add	arg03, local05
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	add	local05, #1
 if_e	jmp	#LR__4330
LR__4331
' 	}
' 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
	add	local01, #10
	rdword	local04, local01
	cmp	local05, local04 wz
 if_e	mov	local06, #0
 if_ne	mov	local06, #1
	mov	result1, local06
LR__4332
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_clear_ret
	ret

_fatfs_cc_dir_sdi
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	cmp	local02, ##2097152 wc
 if_b	test	local02, #31 wz
' 		return FR_INT_ERR;
 if_nc_or_nz	mov	result1, #2
 if_nc_or_nz	jmp	#LR__4346
	add	local01, #16
	wrlong	local02, local01
	sub	local01, #8
	rdlong	local04, local01 wz
	sub	local01, #8
 if_e	rdbyte	local05, local03
 if_e	cmp	local05, #3 wc
 if_nc_and_z	add	local03, #40
 if_nc_and_z	rdlong	local04, local03
 if_nc_and_z	sub	local03, #40
	cmp	local04, #0 wz
 if_ne	jmp	#LR__4340
	mov	local05, local02
	shr	local05, #5
	add	local03, #8
	rdword	arg02, local03
	sub	local03, #8
	cmp	local05, arg02 wc
 if_ae	mov	result1, #2
 if_ae	jmp	#LR__4346
	add	local03, #40
	rdlong	local05, local03
	sub	local03, #40
	add	local01, #24
	wrlong	local05, local01
	sub	local01, #24
	jmp	#LR__4345
LR__4340
	add	local03, #10
	rdword	local06, local03
	sub	local03, #10
	shl	local06, #9
' 		csz = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 		while (ofs >= csz) {
LR__4341
	cmp	local02, local06 wc
 if_b	jmp	#LR__4344
	mov	arg01, local01
	mov	arg02, local04
	call	#_fatfs_cc_get_fat
	mov	local04, result1
	cmp	local04, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4346
	cmp	local04, #2 wc
 if_b	jmp	#LR__4342
	add	local03, #24
	rdlong	local05, local03
	sub	local03, #24
	cmp	local04, local05 wc
 if_b	jmp	#LR__4343
LR__4342
	mov	result1, #2
	jmp	#LR__4346
LR__4343
	sub	local02, local06
	jmp	#LR__4341
LR__4344
	mov	arg01, local03
	mov	arg02, local04
	call	#_fatfs_cc_clst2sect
	add	local01, #24
	wrlong	result1, local01
	sub	local01, #24
LR__4345
	add	local01, #20
	wrlong	local04, local01
	add	local01, #4
	rdlong	local05, local01 wz
	sub	local01, #24
 if_e	mov	result1, #2
 if_e	jmp	#LR__4346
	mov	local06, local02
	shr	local06, #9
	add	local01, #24
	rdlong	local05, local01
	add	local05, local06
	wrlong	local05, local01
	add	local03, #52
	and	local02, #511
	add	local03, local02
	add	local01, #4
	wrlong	local03, local01
' 	dp->sect += ofs /  ((UINT) 512 ) ;
' 	dp->dir = fs->win + (ofs %  ((UINT) 512 ) );
' 
' 	return FR_OK;
	mov	result1, #0
LR__4346
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_sdi_ret
	ret

_fatfs_cc_dir_next
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	add	local01, #16
	rdlong	local04, local01
	sub	local01, #16
	add	local04, #32
	cmp	local04, ##2097152 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
 if_ae	sub	local01, #24
	add	local01, #24
	rdlong	arg02, local01 wz
	sub	local01, #24
 if_e	mov	result1, #4
 if_e	jmp	#LR__4355
	test	local04, #511 wz
 if_ne	jmp	#LR__4354
	add	local01, #24
	rdlong	arg02, local01
	add	arg02, #1
	wrlong	arg02, local01
	sub	local01, #4
	rdlong	arg02, local01 wz
	sub	local01, #20
 if_ne	jmp	#LR__4350
	mov	arg02, local04
	shr	arg02, #5
	add	local03, #8
	rdword	local02, local03
	sub	local03, #8
	cmp	arg02, local02 wc
 if_ae	add	local01, #24
 if_ae	wrlong	#0, local01
' 				dp->sect = 0; return FR_NO_FILE;
 if_ae	mov	result1, #4
 if_ae	jmp	#LR__4355
	jmp	#LR__4353
LR__4350
	mov	arg01, local04
	shr	arg01, #9
	add	local03, #10
	rdword	arg02, local03
	sub	local03, #10
	sub	arg02, #1
	test	arg01, arg02 wz
 if_ne	jmp	#LR__4352
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_get_fat
	mov	local05, result1
	cmp	local05, #2 wc
 if_b	mov	result1, #2
 if_b	jmp	#LR__4355
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4355
	add	local03, #24
	rdlong	arg02, local03
	sub	local03, #24
	cmp	local05, arg02 wc
 if_b	jmp	#LR__4351
	cmp	local02, #0 wz
 if_e	add	local01, #24
 if_e	wrlong	#0, local01
' 						dp->sect = 0; return FR_NO_FILE;
 if_e	mov	result1, #4
 if_e	jmp	#LR__4355
	mov	arg01, local01
	add	local01, #20
	rdlong	arg02, local01
	sub	local01, #20
	call	#_fatfs_cc_create_chain
	mov	local05, result1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__4355
	cmp	local05, #1 wz
 if_e	mov	result1, #2
 if_e	jmp	#LR__4355
	cmp	local05, ##-1 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4355
	mov	arg02, local05
	mov	arg01, local03
	call	#_fatfs_cc_dir_clear
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__4355
LR__4351
	add	local01, #20
	wrlong	local05, local01
	mov	arg01, local03
	mov	arg02, local05
	call	#_fatfs_cc_clst2sect
	add	local01, #4
	wrlong	result1, local01
	sub	local01, #24
LR__4352
LR__4353
LR__4354
	add	local01, #16
	wrlong	local04, local01
	add	local03, #52
	and	local04, #511
	add	local03, local04
	add	local01, #12
	wrlong	local03, local01
' #line 1771 "ff.c"
' 				}
' 				dp->clust = clst;
' 				dp->sect = clst2sect(fs, clst);
' 			}
' 		}
' 	}
' 	dp->dptr = ofs;
' 	dp->dir = fs->win + ofs %  ((UINT) 512 ) ;
' 
' 	return FR_OK;
	mov	result1, #0
LR__4355
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_next_ret
	ret

_fatfs_cc_dir_alloc
	mov	COUNT_, #8
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	mov	local04, result1 wz
 if_ne	jmp	#LR__4364
	mov	local05, #0
' 		n = 0;
' 		do {
LR__4360
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local03
	call	#_fatfs_cc_move_window
	mov	local04, result1 wz
 if_ne	jmp	#LR__4363
	add	local01, #28
	rdlong	local06, local01
	sub	local01, #28
	rdbyte	local06, local06
	cmp	local06, #229 wz
 if_ne	add	local01, #28
 if_ne	rdlong	local07, local01
 if_ne	sub	local01, #28
 if_ne	rdbyte	local08, local07 wz
 if_ne	jmp	#LR__4361
	add	local05, #1
	cmp	local05, local02 wz
 if_e	jmp	#LR__4363
	jmp	#LR__4362
LR__4361
	mov	local05, #0
LR__4362
	mov	arg01, local01
	mov	arg02, #1
	call	#_fatfs_cc_dir_next
	mov	local04, result1 wz
 if_e	jmp	#LR__4360
LR__4363
LR__4364
	cmp	local04, #4 wz
 if_e	mov	local04, #7
' 	return res;
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_alloc_ret
	ret

_fatfs_cc_ld_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	arg01, result1, #0
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
' {
' 
' 	return *((WORD*)ptr);
 if_e	rdword	result1, arg02
 if_e	shl	result1, #16
 if_e	or	arg01, result1
' 		cl |= (DWORD)ld_word(dir +  20 ) << 16;
' 	}
' 
' 	return cl;
	mov	result1, arg01
_fatfs_cc_ld_clust_ret
	ret

_fatfs_cc_st_clust
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
	wrword	arg03, arg01
	rdbyte	_var01, _var01
	cmp	_var01, #3 wz
 if_e	add	arg02, #20
 if_e	shr	arg03, #16
 if_e	wrword	arg03, arg02
_fatfs_cc_st_clust_ret
	ret

_fatfs_cc_cmp_lfn
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4376
	rdbyte	local02, arg02
	and	local02, #63
	sub	local02, #1
	qmul	local02, #13
' 
' 	i = ((dir[ 0 ] & 0x3F) - 1) * 13;
' 
' 	for (wc = 1, s = 0; s < 13; s++) {
	mov	local03, #1
	mov	local04, #0
	getqx	local05
LR__4370
	cmp	local04, #13 wc
 if_ae	jmp	#LR__4375
	mov	arg01, arg02
	mov	local02, local04
	add	ptr__fatfs_cc_dat__, ##942
	add	local02, ptr__fatfs_cc_dat__
	rdbyte	local02, local02
	mul	local02, #1
	add	arg01, local02
	sub	ptr__fatfs_cc_dat__, ##942
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local06, result1
	mov	local02, local03
	zerox	local02, #15 wz
 if_e	jmp	#LR__4373
	cmp	local05, #256 wc
 if_ae	jmp	#LR__4371
	getword	arg01, local06, #0
	call	#_fatfs_cc_ff_wtoupper
	mov	local02, result1
	mov	local03, local05
	shl	local03, #1
	add	local03, local01
	rdword	arg01, local03
	add	local05, #1
	call	#_fatfs_cc_ff_wtoupper
	cmp	local02, result1 wz
 if_e	jmp	#LR__4372
LR__4371
' 				return 0;
	mov	result1, #0
	jmp	#LR__4376
LR__4372
	mov	local03, local06
	jmp	#LR__4374
LR__4373
	getword	local06, local06, #0
	cmp	local06, ##65535 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4376
LR__4374
	add	local04, #1
	jmp	#LR__4370
LR__4375
	rdbyte	local02, arg02
	test	local02, #64 wz
 if_ne	cmp	local03, #0 wz
 if_ne	shl	local05, #1
 if_ne	add	local05, local01
 if_ne	rdword	local07, local05 wz
 if_ne	mov	result1, #0
' 
' 	return 1;
 if_e	mov	result1, #1
LR__4376
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_cmp_lfn_ret
	ret

_fatfs_cc_pick_lfn
	mov	_var01, arg01
	mov	arg01, arg02
	add	arg01, #26
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4385
	rdbyte	_var02, arg02
	andn	_var02, #64
	sub	_var02, #1
	qmul	_var02, #13
' 
' 	i = ((dir[ 0 ] & ~ 0x40 ) - 1) * 13;
' 
' 	for (wc = 1, s = 0; s < 13; s++) {
	mov	_var03, #1
	mov	_var04, #0
	getqx	_var05
LR__4380
	cmp	_var04, #13 wc
 if_ae	jmp	#LR__4383
	mov	arg01, arg02
	mov	_var02, _var04
	add	ptr__fatfs_cc_dat__, ##942
	add	_var02, ptr__fatfs_cc_dat__
	rdbyte	_var02, _var02
	mul	_var02, #1
	add	arg01, _var02
	sub	ptr__fatfs_cc_dat__, ##942
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	_var06, result1
	mov	_var02, _var03
	zerox	_var02, #15 wz
 if_e	jmp	#LR__4381
	cmp	_var05, #256 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#LR__4385
	mov	_var02, _var05
	shl	_var02, #1
	add	_var02, _var01
	mov	_var03, _var06
	wrword	_var03, _var02
	add	_var05, #1
	jmp	#LR__4382
LR__4381
	getword	_var06, _var06, #0
	cmp	_var06, ##65535 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4385
LR__4382
	add	_var04, #1
	jmp	#LR__4380
LR__4383
	rdbyte	_var02, arg02
	test	_var02, #64 wz
 if_ne	mov	_var07, _var03
 if_ne	zerox	_var07, #15 wz
 if_e	jmp	#LR__4384
	cmp	_var05, #256 wc
 if_ae	mov	result1, #0
 if_ae	jmp	#LR__4385
	shl	_var05, #1
	add	_var05, _var01
	wrword	#0, _var05
LR__4384
' 		lfnbuf[i] = 0;
' 	}
' 
' 	return 1;
	mov	result1, #1
LR__4385
_fatfs_cc_pick_lfn_ret
	ret

_fatfs_cc_put_lfn
	add	arg02, #13
	wrbyte	arg04, arg02
	getbyte	arg04, arg03, #0
	sub	arg04, #1
	qmul	arg04, #13
	mov	_var01, arg01
	sub	arg02, #2
	wrbyte	#15, arg02
	add	arg02, #1
	wrbyte	#0, arg02
	sub	arg02, #12
	mov	arg01, arg02
	add	arg01, #26
	wrword	#0, arg01
	mov	_var02, #0
	mov	_var03, #0
' 	BYTE* dir,
' 	BYTE ord,
' 	BYTE sum
' )
' {
' 	UINT i, s;
' 	WCHAR wc;
' 
' 
' 	dir[ 13 ] = sum;
' 	dir[ 11 ] =  0x0F ;
' 	dir[ 12 ] = 0;
' 	st_word(dir +  26 , 0);
' 
' 	i = (ord - 1) * 13;
' 	s = wc = 0;
' 	do {
	add	ptr__fatfs_cc_dat__, ##942
	getqx	_var04
	callpa	#(@LR__4391-@LR__4390)>>2,fcache_load_ptr_
LR__4390
	getword	arg04, _var02, #0
	cmp	arg04, ##65535 wz
 if_ne	mov	arg01, _var04
 if_ne	add	_var04, #1
 if_ne	shl	arg01, #1
 if_ne	add	arg01, _var01
 if_ne	rdword	_var02, arg01
	mov	arg01, arg02
	mov	arg04, _var03
	add	arg04, ptr__fatfs_cc_dat__
	rdbyte	arg04, arg04
	mul	arg04, #1
	add	arg01, arg04
	wrword	_var02, arg01
	mov	arg04, _var02
	zerox	arg04, #15 wz
 if_e	bmask	_var02, #15
	add	_var03, #1
	cmp	_var03, #13 wc
 if_b	jmp	#LR__4390
LR__4391
	sub	ptr__fatfs_cc_dat__, ##942
	getword	_var02, _var02, #0
	cmp	_var02, ##65535 wz
 if_ne	shl	_var04, #1
 if_ne	add	_var04, _var01
 if_ne	rdword	_var04, _var04 wz
 if_e	getbyte	arg03, arg03, #0
 if_e	or	arg03, #64
	wrbyte	arg03, arg02
_fatfs_cc_put_lfn_ret
	ret

_fatfs_cc_gen_numname
	mov	COUNT_, #8
	call	#pushregs_
	add	ptra, #44
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #11
	call	#__system____builtin_memmove
	cmp	local04, #6 wc
 if_b	jmp	#LR__4405
	mov	local05, local04
	callpa	#(@LR__4403-@LR__4400)>>2,fcache_load_ptr_
' 		sreg = seq;
' 		while (*lfn) {
LR__4400
	rdword	local06, local03 wz
 if_e	jmp	#LR__4404
	rdword	local07, local03
' 			wc = *lfn++;
' 			for (i = 0; i < 16; i++) {
	add	local03, #2
	rep	@LR__4402, #16
LR__4401
	shl	local05, #1
	getword	local06, local07, #0
	and	local06, #1
	add	local05, local06
	getword	local07, local07, #0
	shr	local07, #1
	testbn	local05, #16 wz
 if_ne	xor	local05, ##69665
LR__4402
	jmp	#LR__4400
LR__4403
LR__4404
	mov	local04, local05
LR__4405
	mov	local07, #7
' 			}
' 		}
' 		seq = (UINT)sreg;
' 	}
' 
' 
' 	i = 7;
' 	do {
	add	fp, #16
	callpa	#(@LR__4407-@LR__4406)>>2,fcache_load_ptr_
LR__4406
	getnib	local05, local04, #0
	add	local05, #48
	shr	local04, #4
	getbyte	local06, local05, #0
	cmp	local06, #58 wc
 if_ae	getbyte	local05, local05, #0
 if_ae	add	local05, #7
	mov	local06, local07
	sub	local07, #1 wz
	add	local06, fp
	wrbyte	local05, local06
 if_ne	cmp	local04, #0 wz
 if_ne	jmp	#LR__4406
LR__4407
	mov	local06, local07
	add	local06, fp
	wrbyte	#126, local06
' 	ns[i] = '~';
' 
' 
' 	for (j = 0; j < i && dst[j] != ' '; j++) {
	mov	local05, #0
	sub	fp, #16
	callpa	#(@LR__4410-@LR__4408)>>2,fcache_load_ptr_
LR__4408
	cmp	local05, local07 wc
 if_ae	jmp	#LR__4411
	mov	local06, local05
	add	local06, local01
	rdbyte	local06, local06
	cmp	local06, #32 wz
 if_e	jmp	#LR__4411
	mov	arg01, local05
	add	arg01, local01
	rdbyte	arg01, arg01 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__4409
	mov	local06, local07
	sub	local06, #1
	cmp	local05, local06 wz
 if_e	jmp	#LR__4411
	add	local05, #1
LR__4409
	add	local05, #1
	jmp	#LR__4408
LR__4410
LR__4411
	callpa	#(@LR__4415-@LR__4412)>>2,fcache_load_ptr_
' 			j++;
' 		}
' 	}
' 	do {
LR__4412
	mov	local06, local05
	add	local06, local01
	cmp	local07, #8 wc
	add	local05, #1
 if_ae	jmp	#LR__4413
	mov	local04, local07
	add	fp, #16
	add	local04, fp
	rdbyte	local08, local04
	add	local07, #1
	sub	fp, #16
	jmp	#LR__4414
LR__4413
	mov	local08, #32
LR__4414
	wrbyte	local08, local06
	cmp	local05, #8 wc
 if_b	jmp	#LR__4412
LR__4415
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_gen_numname_ret
	ret

_fatfs_cc_sum_sfn
	mov	_var01, #0
' )
' {
' 	BYTE sum = 0;
' 	UINT n = 11;
' 
' 	do {
	callpa	#(@LR__4422-@LR__4420)>>2,fcache_load_ptr_
LR__4420
	rep	@LR__4423, #11
LR__4421
	getbyte	result1, _var01, #0
	shr	result1, #1
	getbyte	_var01, _var01, #0
	shl	_var01, #7
	add	result1, _var01
	rdbyte	_var01, arg01
	add	_var01, result1
	add	arg01, #1
LR__4422
LR__4423
' 	return sum;
	mov	result1, _var01
_fatfs_cc_sum_sfn_ret
	ret

_fatfs_cc_dir_read
	mov	COUNT_, #12
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, #4
	rdlong	local04, local01
	mov	local05, #255
	mov	local06, #255
' )
' {
' 	FRESULT res = FR_NO_FILE;
' 	FATFS *fs = dp->obj.fs;
' 	BYTE attr, b;
' 
' 	BYTE ord = 0xFF, sum = 0xFF;
' 
' 
' 	while (dp->sect) {
LR__4430
	add	local01, #24
	rdlong	result1, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__4440
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local04
	call	#_fatfs_cc_move_window
	mov	local03, result1 wz
 if_ne	jmp	#LR__4440
	add	local01, #28
	rdlong	result1, local01
	sub	local01, #28
	rdbyte	local07, result1
	mov	result1, local07
	zerox	result1, #7 wz
 if_e	mov	local03, #4
' 			res = FR_NO_FILE; break;
 if_e	jmp	#LR__4440
	add	local01, #28
	rdlong	local08, local01
	add	local08, #11
	rdbyte	local09, local08
	and	local09, #63
	sub	local01, #22
	wrbyte	local09, local01
	sub	local01, #6
	getbyte	result1, local07, #0
	cmp	result1, #229 wz
 if_ne	mov	local08, local07
 if_ne	getbyte	local08, local08, #0
 if_ne	cmp	local08, #46 wz
 if_e	jmp	#LR__4431
	mov	local10, #0
	getbyte	local08, local09, #0
	andn	local08, #32
	cmp	local08, #8 wz
 if_e	mov	local10, #1
	cmp	local10, local02 wz
 if_e	jmp	#LR__4432
LR__4431
	mov	local05, #255
	jmp	#LR__4439
LR__4432
	getbyte	local09, local09, #0
	cmp	local09, #15 wz
 if_ne	jmp	#LR__4436
	getbyte	local11, local07, #0
	test	local11, #64 wz
 if_e	jmp	#LR__4433
	add	local01, #28
	rdlong	local11, local01
	add	local11, #13
	rdbyte	local06, local11
	getbyte	local07, local07, #0
	and	local07, #191
	mov	local05, local07
	sub	local01, #12
	rdlong	local11, local01
	add	local01, #28
	wrlong	local11, local01
	sub	local01, #44
LR__4433
	getbyte	local08, local07, #0
	getbyte	local10, local05, #0
	cmp	local08, local10 wz
 if_ne	jmp	#LR__4434
	getbyte	local10, local06, #0
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	add	local09, #13
	rdbyte	local08, local09
	getbyte	local09, local08, #0
	cmp	local10, local09 wz
 if_ne	jmp	#LR__4434
	add	local04, #12
	rdlong	arg01, local04
	sub	local04, #12
	add	local01, #28
	rdlong	local12, local01
	sub	local01, #28
	mov	arg02, local12
	call	#_fatfs_cc_pick_lfn
	cmps	result1, #0 wz
 if_ne	mov	local12, local05
 if_ne	getbyte	local12, local12, #0
 if_ne	sub	local12, #1
 if_ne	mov	local11, local12
 if_ne	jmp	#LR__4435
LR__4434
	mov	local11, #255
LR__4435
	mov	local05, local11
	jmp	#LR__4438
LR__4436
	mov	local11, local05
	zerox	local11, #7 wz
 if_ne	jmp	#LR__4437
	getbyte	local06, local06, #0
	add	local01, #28
	rdlong	arg01, local01
	sub	local01, #28
	call	#_fatfs_cc_sum_sfn
	getbyte	result1, result1, #0
	cmp	local06, result1 wz
 if_e	jmp	#LR__4440
LR__4437
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
' 						dp->blk_ofs = 0xFFFFFFFF;
' 					}
' 					break;
	jmp	#LR__4440
LR__4438
LR__4439
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local03, result1 wz
 if_e	jmp	#LR__4430
LR__4440
	cmp	local03, #0 wz
 if_ne	add	local01, #24
 if_ne	wrlong	#0, local01
' 	return res;
	mov	result1, local03
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_read_ret
	ret

_fatfs_cc_dir_find
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4462
	mov	local03, #255
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
' #line 2404 "ff.c"
' 	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;
' 
' 	do {
LR__4450
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local05, result1 wz
 if_ne	jmp	#LR__4461
	add	local01, #28
	rdlong	arg03, local01
	sub	local01, #28
	rdbyte	local06, arg03
	mov	arg03, local06
	zerox	arg03, #7 wz
 if_e	mov	local05, #4
 if_e	jmp	#LR__4461
	add	local01, #28
	rdlong	local07, local01
	mov	arg03, local07
	add	arg03, #11
	rdbyte	local08, arg03
	and	local08, #63
	sub	local01, #22
	wrbyte	local08, local01
	sub	local01, #6
	getbyte	arg03, local06, #0
	cmp	arg03, #229 wz
 if_e	jmp	#LR__4451
	getbyte	arg03, local08, #0
	test	arg03, #8 wz
 if_ne	mov	local07, local08
 if_ne	getbyte	local07, local07, #0
 if_ne	cmp	local07, #15 wz
 if_e	jmp	#LR__4452
LR__4451
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
	jmp	#LR__4460
LR__4452
	getbyte	local08, local08, #0
	cmp	local08, #15 wz
 if_ne	jmp	#LR__4456
	add	local01, #43
	rdbyte	local08, local01
	sub	local01, #43
	test	local08, #64 wz
 if_ne	jmp	#LR__4459
	getbyte	local09, local06, #0
	test	local09, #64 wz
 if_e	jmp	#LR__4453
	add	local01, #28
	rdlong	local09, local01
	add	local09, #13
	rdbyte	local03, local09
	getbyte	local06, local06, #0
	and	local06, #191
	mov	local04, local06
	sub	local01, #12
	rdlong	local09, local01
	add	local01, #28
	wrlong	local09, local01
	sub	local01, #44
LR__4453
	getbyte	local10, local06, #0
	getbyte	local07, local04, #0
	cmp	local10, local07 wz
 if_ne	jmp	#LR__4454
	getbyte	local08, local03, #0
	add	local01, #28
	rdlong	local07, local01
	sub	local01, #28
	add	local07, #13
	rdbyte	local06, local07
	getbyte	local07, local06, #0
	cmp	local08, local07 wz
 if_ne	jmp	#LR__4454
	add	local02, #12
	rdlong	arg01, local02
	sub	local02, #12
	add	local01, #28
	rdlong	local11, local01
	sub	local01, #28
	mov	arg02, local11
	call	#_fatfs_cc_cmp_lfn
	cmps	result1, #0 wz
 if_ne	mov	local11, local04
 if_ne	getbyte	local11, local11, #0
 if_ne	sub	local11, #1
 if_ne	mov	local09, local11
 if_ne	jmp	#LR__4455
LR__4454
	mov	local09, #255
LR__4455
	mov	local04, local09
	jmp	#LR__4459
LR__4456
	mov	local09, local04
	zerox	local09, #7 wz
 if_ne	jmp	#LR__4457
	getbyte	local10, local03, #0
	add	local01, #28
	rdlong	arg01, local01
	sub	local01, #28
	call	#_fatfs_cc_sum_sfn
	getbyte	result1, result1, #0
	cmp	local10, result1 wz
 if_e	jmp	#LR__4461
LR__4457
	add	local01, #43
	rdbyte	local09, local01
	sub	local01, #43
	test	local09, #1 wz
 if_ne	jmp	#LR__4458
	add	local01, #28
	rdlong	arg01, local01
	add	local01, #4
	mov	arg02, local01
	sub	local01, #32
	mov	arg03, #11
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
 if_e	jmp	#LR__4461
LR__4458
	mov	local04, #255
	add	local01, #44
	wrlong	##-1, local01
	sub	local01, #44
LR__4459
LR__4460
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local05, result1 wz
 if_e	jmp	#LR__4450
LR__4461
' 
' 	return res;
	mov	result1, local05
LR__4462
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_find_ret
	ret

_fatfs_cc_dir_register
	mov	COUNT_, #10
	call	#pushregs_
	add	ptra, #44
	add	fp, #4
	wrlong	arg01, fp
	rdlong	local01, arg01
	add	fp, #8
	wrlong	local01, fp
	sub	fp, #8
	rdlong	local02, fp
	sub	fp, #4
	add	local02, #43
	rdbyte	local02, local02
	test	local02, #160 wz
 if_ne	mov	result1, #6
 if_ne	jmp	#LR__4485
' 	for (len = 0; fs->lfnbuf[len]; len++) ;
	add	fp, #20
	wrlong	#0, fp
	sub	fp, #20
	callpa	#(@LR__4471-@LR__4470)>>2,fcache_load_ptr_
LR__4470
	add	fp, #12
	rdlong	local02, fp
	add	local02, #12
	rdlong	local03, local02
	add	fp, #8
	rdlong	local04, fp
	sub	fp, #20
	shl	local04, #1
	add	local04, local03
	rdword	local02, local04 wz
 if_e	jmp	#LR__4472
	add	fp, #20
	rdlong	local05, fp
	mov	local06, local05
	mov	local07, local05
	mov	local08, local07
	add	local08, #1
	wrlong	local08, fp
	sub	fp, #20
	jmp	#LR__4470
LR__4471
LR__4472
	add	fp, #28
	mov	arg01, fp
	sub	fp, #24
	rdlong	arg02, fp
	sub	fp, #4
	add	arg02, #32
	mov	arg03, #12
	call	#__system____builtin_memmove
	add	fp, #39
	rdbyte	local09, fp
	sub	fp, #39
	test	local09, #1 wz
 if_e	jmp	#LR__4475
	add	fp, #4
	rdlong	local10, fp
	add	local10, #43
	wrbyte	#64, local10
' 		dp->fn[ 11 ] =  0x40 ;
' 		for (n = 1; n < 100; n++) {
	add	fp, #12
	wrlong	#1, fp
	sub	fp, #16
LR__4473
	add	fp, #16
	rdlong	local02, fp
	sub	fp, #16
	cmp	local02, #100 wc
 if_ae	jmp	#LR__4474
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #32
	add	fp, #24
	mov	arg02, fp
	sub	fp, #16
	rdlong	local10, fp
	add	local10, #12
	rdlong	arg03, local10
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #16
	call	#_fatfs_cc_gen_numname
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	call	#_fatfs_cc_dir_find
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__4474
	add	fp, #16
	rdlong	local10, fp
	add	local10, #1
	wrlong	local10, fp
	sub	fp, #16
	jmp	#LR__4473
LR__4474
	add	fp, #16
	rdlong	local10, fp
	sub	fp, #16
	cmp	local10, #100 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__4485
	add	fp, #8
	rdlong	local10, fp
	sub	fp, #8
	cmp	local10, #4 wz
 if_ne	add	fp, #8
 if_ne	rdlong	result1, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__4485
	add	fp, #4
	rdlong	local10, fp
	add	fp, #35
	rdbyte	local01, fp
	sub	fp, #39
	add	local10, #43
	wrbyte	local01, local10
LR__4475
	add	fp, #39
	rdbyte	local02, fp
	sub	fp, #39
	test	local02, #2 wz
 if_e	jmp	#LR__4476
	add	fp, #20
	rdlong	local10, fp
	add	local10, #12
	qdiv	local10, #13
	sub	fp, #20
	getqx	local10
	add	local10, #1
	jmp	#LR__4477
LR__4476
	mov	local10, #1
LR__4477
	add	fp, #24
	wrlong	local10, fp
	sub	fp, #20
	rdlong	arg01, fp
	mov	arg02, local10
	sub	fp, #4
	call	#_fatfs_cc_dir_alloc
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4482
	add	fp, #24
	rdlong	local10, fp
	sub	local10, #1 wz
	wrlong	local10, fp
	sub	fp, #24
 if_e	jmp	#LR__4482
	add	fp, #4
	rdlong	local10, fp
	mov	arg01, local10
	add	fp, #20
	rdlong	arg04, fp
	sub	fp, #24
	shl	arg04, #5
	add	local10, #16
	rdlong	arg02, local10
	sub	arg02, arg04
	call	#_fatfs_cc_dir_sdi
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4481
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #32
	call	#_fatfs_cc_sum_sfn
	mov	local10, result1
	add	fp, #40
	wrbyte	local10, fp
	sub	fp, #40
' 			sum = sum_sfn(dp->fn);
' 			do {
LR__4478
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #8
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #24
	rdlong	arg02, local01
	call	#_fatfs_cc_move_window
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__4480
	add	fp, #12
	rdlong	local02, fp
	add	local02, #12
	rdlong	arg01, local02
	sub	fp, #8
	rdlong	local01, fp
	add	local01, #28
	rdlong	arg02, local01
	add	fp, #20
	rdlong	arg03, fp
	add	fp, #16
	rdbyte	arg04, fp
	sub	fp, #40
	call	#_fatfs_cc_put_lfn
	add	fp, #12
	rdlong	local10, fp
	add	local10, #3
	wrbyte	#1, local10
	sub	fp, #8
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__4479
	add	fp, #24
	rdlong	local10, fp
	sub	local10, #1 wz
	wrlong	local10, fp
	sub	fp, #24
 if_ne	jmp	#LR__4478
LR__4479
LR__4480
LR__4481
LR__4482
	add	fp, #8
	rdlong	local10, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__4484
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #8
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #24
	rdlong	arg02, local01
	call	#_fatfs_cc_move_window
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4483
	add	fp, #4
	rdlong	local02, fp
	sub	fp, #4
	add	local02, #28
	rdlong	arg01, local02
	mov	arg02, #0
	mov	arg03, #32
	call	#\builtin_bytefill_
	add	fp, #4
	rdlong	arg02, fp
	mov	local01, arg02
	add	local01, #28
	rdlong	arg01, local01
	sub	fp, #4
	add	arg02, #32
	mov	arg03, #11
	call	#__system____builtin_memmove
	add	fp, #4
	rdlong	local09, fp
	mov	local10, local09
	add	local10, #28
	rdlong	local01, local10
	add	local09, #43
	rdbyte	local10, local09
	and	local10, #24
	add	local01, #12
	wrbyte	local10, local01
	add	fp, #8
	rdlong	local10, fp
	sub	fp, #12
	add	local10, #3
	wrbyte	#1, local10
LR__4483
LR__4484
' 			__builtin_memset(dp->dir, 0, 32 ) ;
' 			__builtin_memcpy(dp->dir + 0 , dp->fn, 11) ;
' 
' 			dp->dir[ 12 ] = dp->fn[ 11 ] & ( 0x08  |  0x10 );
' 
' 			fs->wflag = 1;
' 		}
' 	}
' 
' 	return res;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
LR__4485
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_register_ret
	ret

_fatfs_cc_dir_remove
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #16
	rdlong	local03, local01
	add	local01, #28
	rdlong	arg02, local01
	sub	local01, #44
	cmp	arg02, ##-1 wz
 if_e	mov	local04, #0
 if_e	jmp	#LR__4490
	mov	arg01, local01
	add	local01, #44
	rdlong	arg02, local01
	sub	local01, #44
	call	#_fatfs_cc_dir_sdi
	mov	local04, result1
LR__4490
	mov	local05, local04 wz
 if_ne	jmp	#LR__4493
' 		do {
LR__4491
	add	local01, #24
	rdlong	arg02, local01
	sub	local01, #24
	mov	arg01, local02
	call	#_fatfs_cc_move_window
	mov	local05, result1 wz
 if_ne	jmp	#LR__4492
	add	local01, #28
	rdlong	local04, local01
	wrbyte	#229, local04
	add	local02, #3
	wrbyte	#1, local02
	sub	local02, #3
	sub	local01, #12
	rdlong	local04, local01
	sub	local01, #16
	cmp	local04, local03 wc
 if_ae	jmp	#LR__4492
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	mov	local05, result1 wz
 if_e	jmp	#LR__4491
LR__4492
	cmp	local05, #4 wz
 if_e	mov	local05, #2
LR__4493
' 	}
' #line 2590 "ff.c"
' 	return res;
	mov	result1, local05
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_dir_remove_ret
	ret

_fatfs_cc_get_fileinfo
	mov	COUNT_, #15
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local01
	add	local02, #28
	wrbyte	#0, local02
	sub	local02, #28
	add	local01, #24
	rdlong	local04, local01 wz
	sub	local01, #24
 if_e	jmp	#LR__4514
	add	local01, #44
	rdlong	local04, local01
	sub	local01, #44
	cmp	local04, ##-1 wz
 if_e	jmp	#LR__4503
	mov	local05, #0
	mov	local06, #0
	mov	local07, #0
' 			si = di = 0;
' 			hs = 0;
' 			while (fs->lfnbuf[si] != 0) {
LR__4500
	add	local03, #12
	rdlong	local04, local03
	sub	local03, #12
	mov	local08, local06
	shl	local08, #1
	add	local08, local04
	rdword	local04, local08 wz
 if_e	jmp	#LR__4502
	add	local03, #12
	rdlong	local09, local03
	sub	local03, #12
	mov	local10, local06
	shl	local10, #1
	add	local10, local09
	rdword	local11, local10
	mov	local04, local07
	zerox	local04, #15 wz
	add	local06, #1
 if_ne	jmp	#LR__4501
	getword	local12, local11, #0
	cmp	local12, ##55296 wc
 if_b	jmp	#LR__4501
	getword	local13, local11, #0
	cmp	local13, ##57344 wc
 if_b	mov	local07, local11
' 					hs = wc; continue;
 if_b	jmp	#LR__4500
LR__4501
	getword	arg01, local07, #0
	shl	arg01, #16
	getword	local11, local11, #0
	or	arg01, local11
	mov	arg02, local05
	add	local02, #28
	add	arg02, local02
	mov	arg03, #255
	sub	arg03, local05
	sub	local02, #28
	call	#_fatfs_cc_put_utf
	mov	local14, result1 wz
 if_e	mov	local05, #0
 if_ne	add	local05, local14
 if_ne	mov	local07, #0
 if_ne	jmp	#LR__4500
LR__4502
	mov	local04, local07
	zerox	local04, #15 wz
 if_ne	mov	local05, #0
	add	local02, #28
	add	local05, local02
	wrbyte	#0, local05
	sub	local02, #28
LR__4503
	mov	local05, #0
	mov	local06, #0
' 			fno->fname[di] = 0;
' 		}
' 	}
' 
' 	si = di = 0;
' 	while (si < 11) {
LR__4504
	cmp	local06, #11 wc
 if_ae	jmp	#LR__4507
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	mov	local10, local06
	add	local10, local09
	rdbyte	local11, local10
	getword	local04, local11, #0
	cmp	local04, #32 wz
	add	local06, #1
 if_e	jmp	#LR__4504
	getword	local04, local11, #0
	cmp	local04, #5 wz
 if_e	mov	local11, #229
	cmp	local06, #9 wz
 if_ne	jmp	#LR__4505
	cmp	local05, #12 wc
 if_ae	jmp	#LR__4505
	mov	local13, local05
	add	local02, #12
	add	local13, local02
	wrbyte	#46, local13
	add	local05, #1
	sub	local02, #12
LR__4505
	getword	arg01, local11, #0
	zerox	arg01, #7 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_ne	cmp	local06, #8 wz
 if_ne	cmp	local06, #11 wz
 if_e	jmp	#LR__4506
	add	local01, #28
	rdlong	local10, local01
	sub	local01, #28
	mov	local08, local06
	add	local08, local10
	rdbyte	arg01, local08 wz
 if_ne	mov	result1, #0
' 
' 	return 0;
 if_e	mov	result1, #0
	cmp	result1, #0 wz
 if_e	jmp	#LR__4506
	getword	local11, local11, #0
	shl	local11, #8
	add	local01, #28
	rdlong	local14, local01
	sub	local01, #28
	mov	local09, local06
	add	local09, local14
	rdbyte	local12, local09
	or	local11, local12
	add	local06, #1
LR__4506
	mov	arg01, local11
	mov	arg02, ##850
	call	#_fatfs_cc_ff_oem2uni
	mov	local11, result1
	mov	local04, local11
	zerox	local04, #15 wz
 if_e	mov	local05, #0
 if_e	jmp	#LR__4507
	getword	arg01, local11, #0
	mov	arg02, local05
	add	local02, #12
	add	arg02, local02
	mov	arg03, #12
	sub	arg03, local05
	sub	local02, #12
	call	#_fatfs_cc_put_utf
	mov	local14, result1 wz
 if_e	mov	local05, #0
 if_ne	add	local05, local14
 if_ne	jmp	#LR__4504
LR__4507
	mov	local04, local05
	add	local02, #12
	add	local04, local02
	wrbyte	#0, local04
	add	local02, #16
	rdbyte	local04, local02 wz
	sub	local02, #28
 if_ne	jmp	#LR__4513
	cmp	local05, #0 wz
 if_ne	jmp	#LR__4508
	mov	local13, local05
	add	local02, #28
	add	local13, local02
	wrbyte	#63, local13
	add	local05, #1
	sub	local02, #28
	jmp	#LR__4512
LR__4508
' 			for (si = di = 0, lcf =  0x08 ; fno->altname[si]; si++, di++) {
	mov	local05, #0
	mov	local06, #0
	mov	local15, #8
LR__4509
	mov	local04, local06
	add	local02, #12
	add	local04, local02
	rdbyte	local13, local04 wz
	sub	local02, #12
 if_e	jmp	#LR__4511
	mov	local08, local06
	add	local02, #12
	add	local08, local02
	rdbyte	local11, local08
	getword	local14, local11, #0
	cmp	local14, #46 wz
	sub	local02, #12
 if_e	mov	local15, #16
	getword	local14, local11, #0
	cmp	local14, #65 wc
 if_b	jmp	#LR__4510
	getword	local08, local11, #0
	cmp	local08, #91 wc
 if_ae	jmp	#LR__4510
	add	local01, #28
	rdlong	local09, local01
	sub	local01, #28
	add	local09, #12
	rdbyte	local10, local09
	getbyte	local14, local15, #0
	test	local10, local14 wz
 if_ne	getword	local11, local11, #0
 if_ne	add	local11, #32
LR__4510
	mov	local14, local05
	add	local02, #28
	add	local14, local02
	getword	local11, local11, #0
	wrbyte	local11, local14
	add	local06, #1
	add	local05, #1
	sub	local02, #28
	jmp	#LR__4509
LR__4511
LR__4512
	add	local02, #28
	add	local05, local02
	wrbyte	#0, local05
	add	local01, #28
	rdlong	local04, local01
	sub	local01, #28
	add	local04, #12
	rdbyte	local13, local04 wz
	sub	local02, #28
 if_e	add	local02, #12
 if_e	wrbyte	#0, local02
 if_e	sub	local02, #12
LR__4513
	add	local01, #28
	rdlong	local12, local01
	add	local12, #11
	rdbyte	local04, local12
	and	local04, #63
	add	local02, #8
	wrbyte	local04, local02
	sub	local02, #8
	rdlong	arg01, local01
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	wrlong	result1, local02
	rdlong	arg01, local01
	add	arg01, #22
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	local02, #6
	wrword	result1, local02
	rdlong	arg01, local01
	add	arg01, #24
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	local02, #2
	wrword	result1, local02
LR__4514
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_fileinfo_ret
	ret

_fatfs_cc_create_name
	mov	COUNT_, #13
	call	#pushregs_
	add	ptra, #52
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	rdlong	result1, arg02
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #44
	rdlong	result1, fp
	rdlong	local01, result1
	add	local01, #12
	rdlong	local02, local01
	add	fp, #20
	wrlong	local02, fp
	add	fp, #20
	wrlong	#0, fp
	sub	fp, #44
' 
' 
' 
' 	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
' 	for (;;) {
LR__4520
	add	fp, #48
	mov	arg01, fp
	sub	fp, #48
	call	#_fatfs_cc_tchar2uni
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	cmp	result1, ##-1 wz
 if_e	mov	result1, #6
 if_e	jmp	#LR__4560
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #28
	cmp	local01, ##65536 wc
 if_b	jmp	#LR__4521
	add	fp, #24
	rdlong	local03, fp
	add	fp, #20
	rdlong	local01, fp
	mov	local04, local01
	add	local04, #1
	wrlong	local04, fp
	shl	local01, #1
	add	local01, local03
	sub	fp, #16
	rdlong	local05, fp
	sub	fp, #28
	mov	local06, local05
	shr	local06, #16
	wrword	local06, local01
LR__4521
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #8
	wrword	local01, fp
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #32 wc
 if_b	jmp	#LR__4523
	add	fp, #20
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #47 wz
 if_ne	add	fp, #20
 if_ne	rdword	local04, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local04, #92 wz
 if_e	jmp	#LR__4523
	add	fp, #20
	rdword	arg01, fp
	sub	fp, #20
	cmp	arg01, #128 wc
 if_ae	jmp	#LR__4522
	mov	arg01, ##@LR__5182
	add	fp, #20
	rdword	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_strchr
	cmp	result1, #0 wz
 if_ne	mov	result1, #6
 if_ne	jmp	#LR__4560
LR__4522
	add	fp, #44
	rdlong	local06, fp
	sub	fp, #44
	cmp	local06, #255 wc
 if_ae	mov	result1, #6
 if_ae	jmp	#LR__4560
	add	fp, #24
	rdlong	local03, fp
	add	fp, #20
	rdlong	local02, fp
	mov	local04, local02
	add	local04, #1
	wrlong	local04, fp
	mov	local01, local02
	shl	local01, #1
	add	local01, local03
	sub	fp, #24
	rdword	local06, fp
	sub	fp, #20
	wrword	local06, local01
	jmp	#LR__4520
LR__4523
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #32 wc
 if_b	add	fp, #16
 if_b	wrbyte	#4, fp
 if_b	sub	fp, #16
 if_b	jmp	#LR__4528
	callpa	#(@LR__4526-@LR__4524)>>2,fcache_load_ptr_
' 		while ( ((*p) == '/' || (*p) == '\\') ) p++;
LR__4524
	add	fp, #48
	rdlong	local04, fp
	sub	fp, #48
	rdbyte	local07, local04
	cmp	local07, #47 wz
 if_e	jmp	#LR__4525
	add	fp, #48
	rdlong	local04, fp
	sub	fp, #48
	rdbyte	local02, local04
	cmp	local02, #92 wz
 if_ne	jmp	#LR__4527
LR__4525
	add	fp, #48
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	sub	fp, #48
	jmp	#LR__4524
LR__4526
LR__4527
	add	fp, #16
	wrbyte	#0, fp
	add	fp, #32
	rdlong	local06, fp
	sub	fp, #48
	rdbyte	local07, local06
	cmp	local07, #32 wc
 if_b	add	fp, #16
 if_b	wrbyte	#4, fp
 if_b	sub	fp, #16
LR__4528
	add	fp, #8
	rdlong	local07, fp
	add	fp, #40
	rdlong	local01, fp
	sub	fp, #48
	wrlong	local01, local07
	callpa	#(@LR__4530-@LR__4529)>>2,fcache_load_ptr_
' 	}
' 	*path = p;
' #line 2862 "ff.c"
' 	while (di) {
LR__4529
	add	fp, #44
	rdlong	local07, fp wz
	sub	fp, #44
 if_e	jmp	#LR__4531
	add	fp, #24
	rdlong	local06, fp
	add	fp, #20
	rdlong	local04, fp
	sub	local04, #1
	shl	local04, #1
	add	local04, local06
	rdword	local06, local04
	sub	fp, #24
	wrword	local06, fp
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #32 wz
 if_ne	add	fp, #20
 if_ne	rdword	local01, fp
 if_ne	sub	fp, #20
 if_ne	cmp	local01, #46 wz
 if_ne	jmp	#LR__4531
	add	fp, #44
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #44
	jmp	#LR__4529
LR__4530
LR__4531
	add	fp, #24
	rdlong	local08, fp
	add	fp, #20
	rdlong	local04, fp
	shl	local04, #1
	add	local04, local08
	wrword	#0, local04
	rdlong	local07, fp wz
	sub	fp, #44
 if_e	mov	result1, #6
 if_e	jmp	#LR__4560
' 
' 
' 	for (si = 0; lfn[si] == ' '; si++) ;
	add	fp, #40
	wrlong	#0, fp
	sub	fp, #40
	callpa	#(@LR__4533-@LR__4532)>>2,fcache_load_ptr_
LR__4532
	add	fp, #24
	rdlong	local09, fp
	add	fp, #16
	rdlong	local10, fp
	sub	fp, #40
	shl	local10, #1
	add	local10, local09
	rdword	local11, local10
	cmp	local11, #32 wz
 if_ne	jmp	#LR__4534
	add	fp, #40
	rdlong	local12, fp
	mov	local05, local12
	add	local05, #1
	wrlong	local05, fp
	sub	fp, #40
	jmp	#LR__4532
LR__4533
LR__4534
	add	fp, #40
	rdlong	local07, fp
	sub	fp, #40
	cmp	local07, #1 wc
 if_ae	jmp	#LR__4535
	add	fp, #24
	rdlong	local03, fp
	add	fp, #16
	rdlong	local09, fp
	sub	fp, #40
	shl	local09, #1
	add	local09, local03
	rdword	local01, local09
	cmp	local01, #46 wz
 if_ne	jmp	#LR__4536
LR__4535
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #3
	wrbyte	local07, fp
	sub	fp, #16
LR__4536
	callpa	#(@LR__4538-@LR__4537)>>2,fcache_load_ptr_
' 	while (di > 0 && lfn[di - 1] != '.') di--;
LR__4537
	add	fp, #44
	rdlong	local07, fp
	sub	fp, #44
	cmp	local07, #1 wc
 if_b	jmp	#LR__4539
	add	fp, #24
	rdlong	local06, fp
	add	fp, #20
	rdlong	local03, fp
	sub	fp, #44
	sub	local03, #1
	shl	local03, #1
	add	local03, local06
	rdword	local01, local03
	cmp	local01, #46 wz
 if_e	jmp	#LR__4539
	add	fp, #44
	rdlong	local01, fp
	sub	local01, #1
	wrlong	local01, fp
	sub	fp, #44
	jmp	#LR__4537
LR__4538
LR__4539
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #32
	mov	arg02, #32
	mov	arg03, #11
	mov	local13, arg01
	call	#\builtin_bytefill_
	mov	result1, local13
	add	fp, #12
	wrbyte	#0, fp
	rdbyte	local07, fp
	add	fp, #20
	wrlong	local07, fp
	add	fp, #4
	wrlong	#8, fp
	sub	fp, #36
' 
' 	__builtin_memset(dp->fn, ' ', 11) ;
' 	i = b = 0; ni = 8;
' 	for (;;) {
LR__4540
	add	fp, #24
	rdlong	local03, fp
	add	fp, #16
	rdlong	local09, fp
	mov	local04, local09
	add	local04, #1
	wrlong	local04, fp
	shl	local09, #1
	add	local09, local03
	rdword	local06, local09
	sub	fp, #20
	wrword	local06, fp
	rdword	local07, fp wz
	sub	fp, #20
 if_e	jmp	#LR__4556
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #32 wz
 if_e	jmp	#LR__4541
	add	fp, #20
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #46 wz
 if_ne	jmp	#LR__4542
	add	fp, #40
	rdlong	local04, fp
	add	fp, #4
	rdlong	local10, fp
	sub	fp, #44
	cmp	local04, local10 wz
 if_e	jmp	#LR__4542
LR__4541
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #3
	wrbyte	local07, fp
	sub	fp, #16
' 			cf |=  0x01  |  0x02 ;
' 			continue;
	jmp	#LR__4540
LR__4542
	add	fp, #32
	rdlong	local07, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #36
	cmp	local07, local01 wc
 if_ae	jmp	#LR__4543
	add	fp, #40
	rdlong	local08, fp
	add	fp, #4
	rdlong	local10, fp
	sub	fp, #44
	cmp	local08, local10 wz
 if_ne	jmp	#LR__4545
LR__4543
	add	fp, #36
	rdlong	local07, fp
	sub	fp, #36
	cmp	local07, #11 wz
 if_ne	jmp	#LR__4544
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #3
	wrbyte	local07, fp
	sub	fp, #16
' 				cf |=  0x01  |  0x02 ;
' 				break;
	jmp	#LR__4556
LR__4544
	add	fp, #40
	rdlong	local07, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #44
	cmp	local07, local01 wz
 if_ne	add	fp, #16
 if_ne	rdbyte	local07, fp
 if_ne	or	local07, #3
 if_ne	wrbyte	local07, fp
 if_ne	sub	fp, #16
	add	fp, #40
	rdlong	local07, fp
	add	fp, #4
	rdlong	local02, fp
	sub	fp, #44
	cmp	local07, local02 wcz
 if_a	jmp	#LR__4556
	add	fp, #44
	rdlong	local07, fp
	sub	fp, #4
	wrlong	local07, fp
	sub	fp, #8
	wrlong	#8, fp
	add	fp, #4
	wrlong	#11, fp
	sub	fp, #24
	rdbyte	local11, fp
	getbyte	local07, local11, #0
	shl	local07, #2
	wrbyte	local07, fp
	sub	fp, #12
' 			si = di; i = 8; ni = 11; b <<= 2;
' 			continue;
	jmp	#LR__4540
LR__4545
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #128 wc
 if_b	jmp	#LR__4547
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #2
	wrbyte	local07, fp
	add	fp, #4
	rdword	arg01, fp
	sub	fp, #20
	mov	arg02, ##850
	call	#_fatfs_cc_ff_uni2oem
	add	fp, #20
	wrword	result1, fp
	rdword	local07, fp
	sub	fp, #20
	test	local07, #128 wz
 if_e	jmp	#LR__4546
	add	fp, #20
	rdword	local02, fp
	and	local02, #127
	add	ptr__fatfs_cc_dat__, ##955
	add	local02, ptr__fatfs_cc_dat__
	rdbyte	local07, local02
	wrword	local07, fp
	sub	fp, #20
	sub	ptr__fatfs_cc_dat__, ##955
LR__4546
LR__4547
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #256 wc
 if_b	jmp	#LR__4549
	add	fp, #36
	rdlong	local07, fp
	sub	local07, #1
	sub	fp, #4
	rdlong	local02, fp
	sub	fp, #32
	cmp	local02, local07 wc
 if_b	jmp	#LR__4548
	add	fp, #16
	rdbyte	local11, fp
	getbyte	local07, local11, #0
	or	local07, #3
	wrbyte	local07, fp
	add	fp, #20
	rdlong	local07, fp
	sub	fp, #4
	wrlong	local07, fp
	sub	fp, #32
' 				cf |=  0x01  |  0x02 ;
' 				i = ni; continue;
	jmp	#LR__4540
LR__4548
	add	fp, #4
	rdlong	local09, fp
	add	fp, #28
	rdlong	local10, fp
	mov	local04, local10
	add	local04, #1
	wrlong	local04, fp
	add	local09, #32
	add	local10, local09
	sub	fp, #12
	rdword	local03, fp
	sub	fp, #20
	shr	local03, #8
	wrbyte	local03, local10
	jmp	#LR__4555
LR__4549
	add	fp, #20
	rdword	local07, fp wz
	sub	fp, #20
 if_e	jmp	#LR__4550
	mov	arg01, ##@LR__5183
	add	fp, #20
	rdword	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_strchr
	cmp	result1, #0 wz
 if_e	jmp	#LR__4551
LR__4550
	add	fp, #20
	wrword	#95, fp
	sub	fp, #4
	rdbyte	local07, fp
	or	local07, #3
	wrbyte	local07, fp
	sub	fp, #16
	jmp	#LR__4554
LR__4551
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #65 wc
 if_b	jmp	#LR__4552
	add	fp, #20
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #91 wc
 if_b	add	fp, #12
 if_b	rdbyte	local07, fp
 if_b	or	local07, #2
 if_b	wrbyte	local07, fp
 if_b	sub	fp, #12
LR__4552
	add	fp, #20
	rdword	local07, fp
	sub	fp, #20
	cmp	local07, #97 wc
 if_b	jmp	#LR__4553
	add	fp, #20
	rdword	local01, fp
	sub	fp, #20
	cmp	local01, #123 wc
 if_ae	jmp	#LR__4553
	add	fp, #12
	rdbyte	local07, fp
	or	local07, #1
	wrbyte	local07, fp
	add	fp, #8
	rdword	local07, fp
	sub	local07, #32
	wrword	local07, fp
	sub	fp, #20
LR__4553
LR__4554
LR__4555
	add	fp, #4
	rdlong	local11, fp
	mov	local09, local11
	add	fp, #28
	rdlong	local02, fp
	mov	local04, local02
	add	local04, #1
	wrlong	local04, fp
	mov	local10, local02
	add	local09, #32
	add	local10, local09
	sub	fp, #12
	rdword	local03, fp
	sub	fp, #20
	wrbyte	local03, local10
	jmp	#LR__4540
LR__4556
	add	fp, #4
	rdlong	local11, fp
	sub	fp, #4
	add	local11, #32
	rdbyte	local07, local11
	cmp	local07, #229 wz
 if_e	add	fp, #4
 if_e	rdlong	local07, fp
 if_e	sub	fp, #4
 if_e	add	local07, #32
 if_e	wrbyte	#5, local07
	add	fp, #36
	rdlong	local07, fp
	sub	fp, #36
	cmp	local07, #8 wz
 if_e	add	fp, #12
 if_e	rdbyte	local07, fp
 if_e	shl	local07, #2
 if_e	wrbyte	local07, fp
 if_e	sub	fp, #12
	add	fp, #12
	rdbyte	local07, fp
	sub	fp, #12
	and	local07, #12
	cmp	local07, #12 wz
 if_e	jmp	#LR__4557
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	and	local01, #3
	cmp	local01, #3 wz
 if_ne	jmp	#LR__4558
LR__4557
	add	fp, #16
	rdbyte	local07, fp
	or	local07, #2
	wrbyte	local07, fp
	sub	fp, #16
LR__4558
	add	fp, #16
	rdbyte	local07, fp
	sub	fp, #16
	test	local07, #2 wz
 if_ne	jmp	#LR__4559
	add	fp, #12
	rdbyte	local07, fp
	sub	fp, #12
	test	local07, #1 wz
 if_ne	add	fp, #16
 if_ne	rdbyte	local07, fp
 if_ne	or	local07, #16
 if_ne	wrbyte	local07, fp
 if_ne	sub	fp, #16
	add	fp, #12
	rdbyte	local07, fp
	sub	fp, #12
	test	local07, #4 wz
 if_ne	add	fp, #16
 if_ne	rdbyte	local07, fp
 if_ne	or	local07, #8
 if_ne	wrbyte	local07, fp
 if_ne	sub	fp, #16
LR__4559
	add	fp, #4
	rdlong	local07, fp
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #16
	add	local07, #43
	wrbyte	local01, local07
' 	}
' 
' 	dp->fn[ 11 ] = cf;
' 
' 	return FR_OK;
	mov	result1, #0
LR__4560
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_create_name_ret
	ret

_fatfs_cc_follow_path
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #24
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	result1, fp
	rdlong	local01, result1
	add	fp, #16
	wrlong	local01, fp
	sub	fp, #20
	callpa	#(@LR__4572-@LR__4570)>>2,fcache_load_ptr_
' )
' {
' 	FRESULT res;
' 	BYTE ns;
' 	FATFS *fs = dp->obj.fs;
' #line 3034 "ff.c"
' 	{
' 		while ( ((*path) == '/' || (*path) == '\\') ) path++;
LR__4570
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	rdbyte	local01, local01
	cmp	local01, #47 wz
 if_e	jmp	#LR__4571
	add	fp, #8
	rdlong	local01, fp
	sub	fp, #8
	rdbyte	local01, local01
	cmp	local01, #92 wz
 if_ne	jmp	#LR__4573
LR__4571
	add	fp, #8
	rdlong	local01, fp
	add	local01, #1
	wrlong	local01, fp
	sub	fp, #8
	jmp	#LR__4570
LR__4572
LR__4573
	add	fp, #4
	rdlong	local01, fp
	add	local01, #8
	wrlong	#0, local01
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #8
	rdbyte	local01, local01
	cmp	local01, #32 wc
 if_ae	jmp	#LR__4574
	add	fp, #4
	rdlong	local01, fp
	add	local01, #43
	wrbyte	#128, local01
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	jmp	#LR__4578
LR__4574
' 		for (;;) {
LR__4575
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	mov	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_create_name
	add	fp, #12
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #12
 if_ne	jmp	#LR__4577
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	call	#_fatfs_cc_dir_find
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #8
	rdlong	local01, fp
	add	local01, #43
	rdbyte	local01, local01
	add	fp, #12
	wrbyte	local01, fp
	sub	fp, #4
	rdlong	local01, fp wz
	sub	fp, #12
 if_e	jmp	#LR__4576
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #4 wz
 if_ne	jmp	#LR__4577
	add	fp, #16
	rdbyte	local01, fp
	sub	fp, #16
	test	local01, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#5, fp
 if_e	sub	fp, #12
' 					}
' 				}
' 				break;
	jmp	#LR__4577
LR__4576
	add	fp, #16
	rdbyte	local01, fp
	sub	fp, #16
	test	local01, #4 wz
 if_ne	jmp	#LR__4577
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #6
	rdbyte	local01, local01
	test	local01, #16 wz
 if_e	add	fp, #12
 if_e	wrlong	#5, fp
 if_e	sub	fp, #12
' 				res = FR_NO_PATH; break;
 if_e	jmp	#LR__4577
	add	fp, #4
	rdlong	local02, fp
	mov	local01, local02
	add	fp, #16
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg02, #52
	sub	fp, #20
	add	local02, #16
	rdlong	local02, local02
	and	local02, #511
	add	arg02, local02
	call	#_fatfs_cc_ld_clust
	add	local01, #8
	wrlong	result1, local01
	jmp	#LR__4575
LR__4577
LR__4578
' 			}
' #line 3090 "ff.c"
' 			{
' 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr %  ((UINT) 512 ) );
' 			}
' 		}
' 	}
' 
' 	return res;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_follow_path_ret
	ret

_fatfs_cc_get_ldnumber
	neg	_var01, #1
	rdlong	_var02, arg01 wz
	mov	_var03, _var02
 if_e	neg	result1, #1
 if_e	jmp	#_fatfs_cc_get_ldnumber_ret
	callpa	#(@LR__4581-@LR__4580)>>2,fcache_load_ptr_
' 	do tc = *tt++; while (! ((UINT)(tc) < ( 1 ? ' ' : '!'))  && tc != ':');
LR__4580
	rdbyte	_var04, _var03
	getbyte	result1, _var04, #0
	cmp	result1, #32 wc
	add	_var03, #1
 if_ae	mov	_var05, _var04
 if_ae	getbyte	_var05, _var05, #0
 if_ae	cmp	_var05, #58 wz
 if_a	jmp	#LR__4580
LR__4581
	getbyte	_var04, _var04, #0
	cmp	_var04, #58 wz
 if_ne	jmp	#LR__4583
	mov	_var06, #1
	rdbyte	_var05, _var02
	cmp	_var05, #48 wc
 if_b	jmp	#LR__4582
	rdbyte	_var05, _var02
	cmp	_var05, #58 wc
 if_b	mov	_var07, _var02
 if_b	add	_var07, #2
 if_b	cmp	_var07, _var03 wz
 if_c_and_z	rdbyte	_var06, _var02
 if_c_and_z	sub	_var06, #48
LR__4582
	cmps	_var06, #1 wc
 if_b	mov	_var01, _var06
 if_b	wrlong	_var03, arg01
' 			vol = i;
' 			*path = tt;
' 		}
' 		return vol;
	mov	result1, _var01
	jmp	#_fatfs_cc_get_ldnumber_ret
LR__4583
' 	}
' #line 3170 "ff.c"
' 	vol = 0;
' 
' 	return vol;
	mov	result1, #0
_fatfs_cc_get_ldnumber_ret
	ret

_fatfs_cc_check_fs
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	add	local01, #3
	wrbyte	#0, local01
	add	local01, #45
	wrlong	##-1, local01
	sub	local01, #48
	mov	arg01, local01
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	mov	result1, #4
 if_ne	jmp	#LR__4594
	add	local01, #52
	mov	arg01, local01
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	local02, arg01
	rdbyte	local03, local01
	sub	local01, #52
	getbyte	local04, local03, #0
	cmp	local04, #235 wz
 if_ne	mov	arg03, local03
 if_ne	getbyte	arg03, arg03, #0
 if_ne	cmp	arg03, #233 wz
 if_ne	getbyte	local03, local03, #0
 if_ne	cmp	local03, #232 wz
 if_ne	jmp	#LR__4593
	getword	local04, local02, #0
	cmp	local04, ##43605 wz
 if_ne	jmp	#LR__4590
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #82
	mov	arg02, ##@LR__5184
	mov	arg03, #8
	call	#_fatfs_cc_memcmp
	cmp	result1, #0 wz
' 			return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__4594
LR__4590
	add	local01, #52
	mov	arg01, local01
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	add	local01, #13
	rdbyte	local03, local01
	sub	local01, #65
	getword	local04, result1, #0
	getword	arg02, result1, #0
	sub	arg02, #1
	test	local04, arg02 wz
 if_ne	jmp	#LR__4592
	getword	arg02, result1, #0
	cmp	arg02, ##512 wc
 if_b	jmp	#LR__4592
	getword	arg02, result1, #0
	cmp	arg02, ##513 wc
 if_ae	jmp	#LR__4592
	mov	arg01, local03
	zerox	arg01, #7 wz
 if_e	jmp	#LR__4592
	getbyte	arg01, local03, #0
	getbyte	local03, local03, #0
	sub	local03, #1
	test	arg01, local03 wz
 if_ne	jmp	#LR__4592
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #14
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__4592
	add	local01, #68
	rdbyte	arg01, local01
	sub	local01, #68
	sub	arg01, #1
	cmp	arg01, #2 wc
 if_ae	jmp	#LR__4592
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #17
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_e	jmp	#LR__4592
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #19
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local03, result1, #0
	cmp	local03, #128 wc
 if_ae	jmp	#LR__4591
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #32
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	cmp	result1, ##65536 wc
 if_b	jmp	#LR__4592
LR__4591
	add	local01, #74
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, local01 wz
' 			&& b != 0 && (b & (b - 1)) == 0
' 			&& ld_word(fs->win +  14 ) != 0
' 			&& (UINT)fs->win[ 16 ] - 1 <= 1
' 			&& ld_word(fs->win +  17 ) != 0
' 			&& (ld_word(fs->win +  19 ) >= 128 || ld_dword(fs->win +  32 ) >= 0x10000)
' 			&& ld_word(fs->win +  22 ) != 0) {
' 				return 0;
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__4594
LR__4592
LR__4593
' 		}
' 	}
' 	return sign == 0xAA55 ? 2 : 3;
	getword	local03, local02, #0
	cmp	local03, ##43605 wz
 if_e	mov	local04, #2
 if_ne	mov	local04, #3
	mov	result1, local04
LR__4594
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_check_fs_ret
	ret

_fatfs_cc_find_volume
	mov	COUNT_, #5
	call	#pushregs_
	add	ptra, #36
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, local01
	mov	arg02, #0
	call	#_fatfs_cc_check_fs
	cmp	result1, #2 wz
 if_e	jmp	#LR__4600
	cmp	result1, #3 wc
 if_b	cmp	local02, #0 wz
 if_nc_or_z	jmp	#LR__4608
LR__4600
' 	for (i = 0; i < 4; i++) {
	mov	local03, #0
	callpa	#(@LR__4602-@LR__4601)>>2,fcache_load_ptr_
LR__4601
	cmp	local03, #4 wc
 if_ae	jmp	#LR__4603
	mov	local04, local03
	shl	local04, #2
	add	fp, #20
	add	local04, fp
	add	local01, #52
	mov	arg01, local01
	sub	local01, #52
	add	arg01, #446
	mov	arg02, local03
	shl	arg02, #4
	add	arg01, arg02
	add	arg01, #8
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	fp, #20
	wrlong	result1, local04
	add	local03, #1
	jmp	#LR__4601
LR__4602
LR__4603
	cmp	local02, #0 wz
 if_ne	mov	local04, local02
 if_ne	sub	local04, #1
 if_e	mov	local04, #0
	mov	local03, local04
' 		mbr_pt[i] = ld_dword(fs->win +  446  + i *  16  +  8 );
' 	}
' 	i = part ? part - 1 : 0;
' 	do {
LR__4604
	mov	local04, local03
	shl	local04, #2
	add	fp, #20
	add	local04, fp
	rdlong	local04, local04 wz
	sub	fp, #20
 if_e	jmp	#LR__4605
	mov	local04, local03
	shl	local04, #2
	add	fp, #20
	add	local04, fp
	rdlong	arg02, local04
	mov	arg01, local01
	sub	fp, #20
	call	#_fatfs_cc_check_fs
	mov	local04, result1
	jmp	#LR__4606
LR__4605
	mov	local04, #3
LR__4606
	mov	local05, local04
	cmp	local02, #0 wz
 if_e	cmp	local05, #2 wc
 if_c_and_z	jmp	#LR__4607
 if_e	add	local03, #1
 if_e	cmp	local03, #4 wc
 if_c_and_z	jmp	#LR__4604
LR__4607
' 	return fmt;
	mov	result1, local05
LR__4608
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_find_volume_ret
	ret

_fatfs_cc_mount_volume
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	wrlong	#0, local01
	call	#_fatfs_cc_get_ldnumber
	mov	local03, result1
	cmps	local03, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__4620
	mov	arg03, local03
	shl	arg03, #2
	add	arg03, objptr
	rdlong	local04, arg03 wz
 if_e	mov	result1, #12
 if_e	jmp	#LR__4620
	wrlong	local04, local01
	getbyte	local02, local02, #0
	and	local02, #254
	rdbyte	arg03, local04 wz
 if_e	jmp	#LR__4611
	add	local04, #1
	rdbyte	arg01, local04 wz
	sub	local04, #1
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	arg03, result1, #0
	test	arg03, #1 wz
 if_ne	jmp	#LR__4610
	cmp	local02, #0 wz
 if_ne	getbyte	result1, result1, #0
 if_ne	test	result1, #4 wz
' 				return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__4620
' 			}
' 			return FR_OK;
	mov	result1, #0
	jmp	#LR__4620
LR__4610
LR__4611
	wrbyte	#0, local04
	add	local04, #1
	wrbyte	local03, local04
	rdbyte	arg01, local04
	sub	local04, #1
	call	#_fatfs_cc_disk_initialize
	mov	arg03, result1
	getbyte	local05, arg03, #0
	test	local05, #1 wz
' 		return FR_NOT_READY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__4620
	cmp	local02, #0 wz
 if_ne	mov	local05, arg03
 if_ne	getbyte	local05, local05, #0
 if_ne	test	local05, #4 wz
' 		return FR_WRITE_PROTECTED;
 if_ne	mov	result1, #10
 if_ne	jmp	#LR__4620
	mov	arg01, local04
	mov	arg02, #0
	call	#_fatfs_cc_find_volume
	mov	arg01, result1
	cmp	arg01, #4 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__4620
	cmp	arg01, #2 wc
 if_ae	mov	result1, #13
 if_ae	jmp	#LR__4620
	add	local04, #48
	rdlong	local06, local04
	add	local04, #4
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #11
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	cmp	result1, ##512 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__4620
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #22
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local07, result1 wz
 if_ne	jmp	#LR__4612
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #36
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	mov	local07, result1
LR__4612
	add	local04, #28
	wrlong	local07, local04
	add	local04, #40
	rdbyte	local05, local04
	sub	local04, #66
	wrbyte	local05, local04
	rdbyte	local05, local04
	sub	local04, #2
	cmp	local05, #1 wz
 if_ne	add	local04, #2
 if_ne	rdbyte	local05, local04
 if_ne	sub	local04, #2
 if_ne	cmp	local05, #2 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__4620
	add	local04, #2
	rdbyte	local05, local04
	qmul	local07, local05
	add	local04, #63
	rdbyte	local05, local04
	sub	local04, #55
	wrword	local05, local04
	rdword	local05, local04 wz
	sub	local04, #10
	getqx	local07
 if_e	jmp	#LR__4613
	add	local04, #10
	rdword	local05, local04
	getword	local03, local05, #0
	sub	local04, #10
	getword	local05, local05, #0
	sub	local05, #1
	test	local03, local05 wz
 if_e	jmp	#LR__4614
LR__4613
	mov	result1, #13
	jmp	#LR__4620
LR__4614
	add	local04, #52
	mov	arg01, local04
	add	arg01, #17
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	sub	local04, #44
	wrword	result1, local04
	rdword	local05, local04
	sub	local04, #8
	abs	arg01, local05 wc
	getnib	arg01, arg01, #0
	negc	arg01, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__4620
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #19
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	local08, result1 wz
 if_e	add	local04, #52
 if_e	mov	arg01, local04
 if_e	sub	local04, #52
 if_e	add	arg01, #32
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	local08, arg01
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #14
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	mov	arg01, result1
	mov	local05, arg01
	zerox	local05, #15 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__4620
	getword	local09, arg01, #0
	add	local09, local07
	add	local04, #8
	rdword	local05, local04
	sub	local04, #8
	abs	local05, local05 wc
	shr	local05, #4
	sumc	local09, local05
	cmp	local08, local09 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__4620
	sub	local08, local09
	add	local04, #10
	rdword	local05, local04
	qdiv	local08, local05
	sub	local04, #10
	getqx	local05
	cmp	local05, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__4620
	mov	local10, #0
	cmp	local05, ##268435446 wc
 if_b	mov	local10, #3
	cmp	local05, ##65526 wc
 if_b	mov	local10, #2
	cmp	local05, ##4086 wc
 if_b	mov	local10, #1
	cmp	local10, #0 wz
 if_e	mov	result1, #13
 if_e	jmp	#LR__4620
	add	local05, #2
	add	local04, #24
	wrlong	local05, local04
	add	local04, #8
	wrlong	local06, local04
	mov	local05, local06
	getword	arg01, arg01, #0
	add	local05, arg01
	add	local04, #4
	wrlong	local05, local04
	mov	local05, local06
	add	local05, local09
	add	local04, #8
	wrlong	local05, local04
	sub	local04, #44
	cmp	local10, #3 wz
 if_ne	jmp	#LR__4615
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #42
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01 wz
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__4620
	add	local04, #8
	rdword	local05, local04 wz
	sub	local04, #8
 if_ne	mov	result1, #13
 if_ne	jmp	#LR__4620
	add	local04, #52
	mov	arg01, local04
	add	arg01, #44
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local04, #12
	wrlong	result1, local04
	sub	local04, #16
	rdlong	local11, local04
	sub	local04, #24
	shl	local11, #2
	jmp	#LR__4617
LR__4615
	add	local04, #8
	rdword	local05, local04 wz
	sub	local04, #8
 if_e	mov	result1, #13
 if_e	jmp	#LR__4620
	add	local04, #36
	rdlong	local05, local04
	add	local05, local07
	add	local04, #4
	wrlong	local05, local04
	sub	local04, #40
	cmp	local10, #2 wz
 if_e	add	local04, #24
 if_e	rdlong	local05, local04
 if_e	sub	local04, #24
 if_e	shl	local05, #1
 if_e	jmp	#LR__4616
	add	local04, #24
	rdlong	local11, local04
	mov	local05, local11
	shl	local05, #1
	add	local05, local11
	shr	local05, #1
	sub	local04, #24
	and	local11, #1
	add	local05, local11
LR__4616
	mov	local11, local05
LR__4617
	add	local11, #511
	shr	local11, #9
	add	local04, #28
	rdlong	arg03, local04
	sub	local04, #28
	cmp	arg03, local11 wc
 if_b	mov	result1, #13
 if_b	jmp	#LR__4620
	add	local04, #20
	wrlong	##-1, local04
	sub	local04, #4
	wrlong	##-1, local04
	sub	local04, #12
	wrbyte	#128, local04
	sub	local04, #4
	cmp	local10, #3 wz
 if_ne	jmp	#LR__4619
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #48
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local05, result1, #0
	cmp	local05, #1 wz
 if_ne	jmp	#LR__4619
	add	local06, #1
	mov	arg01, local04
	mov	arg02, local06
	call	#_fatfs_cc_move_window
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4619
	add	local04, #4
	wrbyte	#0, local04
	add	local04, #48
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #510
' {
' 
' 	return *((WORD*)ptr);
	rdword	result1, arg01
	getword	local05, result1, #0
	cmp	local05, ##43605 wz
 if_e	add	local04, #52
 if_e	mov	arg01, local04
 if_e	sub	local04, #52
' {
' 
' 	return *((DWORD*)ptr);
 if_e	rdlong	result1, arg01
 if_e	cmp	result1, ##1096897106 wz
 if_ne	jmp	#LR__4618
	add	local04, #52
	mov	arg01, local04
	sub	local04, #52
	add	arg01, #484
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	cmp	result1, ##1631679090 wz
 if_ne	jmp	#LR__4618
	add	local04, #52
	mov	arg01, local04
	add	arg01, #488
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local04, #32
	wrlong	result1, local04
	add	local04, #32
	mov	arg01, local04
	add	arg01, #492
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	sub	local04, #36
	wrlong	result1, local04
	sub	local04, #16
LR__4618
LR__4619
	wrbyte	local10, local04
	add	objptr, #4
	rdword	local05, objptr
	add	local05, #1
	wrword	local05, objptr
	rdword	local11, objptr
	add	local04, #6
	wrword	local11, local04
	add	objptr, #4
	add	local04, #6
	wrlong	objptr, local04
' 				&& ld_dword(fs->win +  0 ) == 0x41615252
' 				&& ld_dword(fs->win +  484 ) == 0x61417272)
' 			{
' 
' 				fs->free_clst = ld_dword(fs->win +  488 );
' 
' 
' 				fs->last_clst = ld_dword(fs->win +  492 );
' 
' 			}
' 		}
' 
' 
' 	}
' 
' 	fs->fs_type = (BYTE)fmt;
' 	fs->id = ++Fsid;
' 
' 	fs->lfnbuf = LfnBuf;
' #line 3567 "ff.c"
' 	return FR_OK;
	mov	result1, #0
	sub	objptr, #8
LR__4620
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mount_volume_ret
	ret

_fatfs_cc_validate
	mov	_var01, arg01 wz
	mov	_var02, #9
 if_ne	rdlong	_var03, _var01 wz
 if_ne	rdbyte	_var04, _var03 wz
 if_e	jmp	#LR__4630
	add	_var01, #4
	rdword	_var04, _var01
	sub	_var01, #4
	rdlong	arg01, _var01
	add	arg01, #6
	rdword	result1, arg01
	cmp	_var04, result1 wz
 if_ne	jmp	#LR__4630
	rdlong	_var04, _var01
	add	_var04, #1
	rdbyte	arg01, _var04 wz
 if_ne	mov	result1, #1
' 
' 	return Stat;
 if_e	add	objptr, ##544
 if_e	rdbyte	result1, objptr
 if_e	sub	objptr, ##544
	getbyte	_var03, result1, #0
	test	_var03, #1 wz
 if_e	mov	_var02, #0
LR__4630
	cmp	_var02, #0 wz
 if_e	rdlong	_var03, _var01
 if_ne	mov	_var03, #0
	wrlong	_var03, arg02
' 			res = FR_OK;
' 		}
' 
' 	}
' 	*rfs = (res == FR_OK) ? obj->fs : 0;
' 	return res;
	mov	result1, _var02
_fatfs_cc_validate_ret
	ret

_fatfs_cc_f_mount
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #32
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrbyte	arg03, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	fp, #20
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #28
	call	#_fatfs_cc_get_ldnumber
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmps	result1, #0 wc
 if_b	mov	result1, #11
 if_b	jmp	#LR__4641
	add	fp, #20
	rdlong	arg03, fp
	shl	arg03, #2
	add	arg03, objptr
	rdlong	arg03, arg03 wz
	sub	fp, #4
	wrlong	arg03, fp
	sub	fp, #16
 if_e	jmp	#LR__4640
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #16
	add	arg03, #1
	rdbyte	arg01, arg03
	call	#_fatfs_cc_disk_deinitialize
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #16
	wrbyte	#0, arg03
LR__4640
	add	fp, #4
	rdlong	local01, fp wz
	sub	fp, #4
 if_ne	add	fp, #4
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #4
 if_ne	wrbyte	#0, local01
	add	fp, #20
	rdlong	local01, fp
	shl	local01, #2
	add	local01, objptr
	sub	fp, #16
	rdlong	arg03, fp
	wrlong	arg03, local01
	add	fp, #8
	rdbyte	local01, fp wz
	sub	fp, #12
 if_e	mov	result1, #0
 if_e	jmp	#LR__4641
	add	fp, #8
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, fp
	sub	fp, #4
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	add	fp, #24
	wrlong	result1, fp
' 
' 	res = mount_volume(&path, &fs, 0);
' 	return res ;
	sub	fp, #24
LR__4641
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mount_ret
	ret

_fatfs_cc_f_open
	mov	COUNT_, #2
	call	#pushregs_
	add	ptra, #96
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrbyte	arg03, fp
	sub	fp, #8
	rdlong	arg04, fp wz
	sub	fp, #4
 if_e	mov	result1, #9
 if_e	jmp	#LR__4667
	add	fp, #12
	rdbyte	arg04, fp
	and	arg04, #63
	wrbyte	arg04, fp
	sub	fp, #4
	mov	arg01, fp
	add	fp, #60
	mov	arg02, fp
	sub	fp, #56
	rdbyte	arg03, fp
	sub	fp, #12
	call	#_fatfs_cc_mount_volume
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4666
	add	fp, #68
	rdlong	arg04, fp
	sub	fp, #48
	wrlong	arg04, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	local01, fp
	sub	fp, #8
	mov	arg02, local01
	call	#_fatfs_cc_follow_path
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4650
	add	fp, #63
	rdbyte	arg04, fp
	sub	fp, #63
	test	arg04, #128 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #16
LR__4650
	add	fp, #12
	rdbyte	arg04, fp
	sub	fp, #12
	test	arg04, #28 wz
 if_e	jmp	#LR__4655
	add	fp, #16
	rdlong	local01, fp wz
	sub	fp, #16
 if_e	jmp	#LR__4652
	add	fp, #16
	rdlong	arg04, fp
	sub	fp, #16
	cmp	arg04, #4 wz
 if_ne	jmp	#LR__4651
	add	fp, #20
	mov	arg01, fp
	sub	fp, #20
	call	#_fatfs_cc_dir_register
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
LR__4651
	add	fp, #12
	rdbyte	local01, fp
	or	local01, #8
	wrbyte	local01, fp
	sub	fp, #12
	jmp	#LR__4654
LR__4652
	add	fp, #26
	rdbyte	local01, fp
	sub	fp, #26
	test	local01, #17 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#7, fp
 if_ne	sub	fp, #16
 if_ne	jmp	#LR__4653
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	test	local01, #4 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#8, fp
 if_ne	sub	fp, #16
LR__4653
LR__4654
	add	fp, #16
	rdlong	local01, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__4658
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	test	local01, #8 wz
 if_e	jmp	#LR__4658
	call	#_fatfs_cc__get_fattime
	add	fp, #84
	wrlong	result1, fp
	sub	fp, #36
	rdlong	arg01, fp
	add	arg01, #14
	wrlong	result1, arg01
	rdlong	arg01, fp
	add	arg01, #22
	add	fp, #36
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	add	fp, #72
	wrlong	result1, fp
	sub	fp, #24
	rdlong	local01, fp
	add	local01, #11
	wrbyte	#32, local01
	add	fp, #20
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	mov	arg03, #0
	call	#_fatfs_cc_st_clust
	add	fp, #48
	rdlong	arg01, fp
	add	arg01, #28
	wrlong	#0, arg01
	add	fp, #20
	rdlong	local01, fp
	add	local01, #3
	wrbyte	#1, local01
	add	fp, #4
	rdlong	local01, fp wz
	sub	fp, #72
 if_e	jmp	#LR__4658
	add	fp, #68
	rdlong	local01, fp
	add	local01, #48
	rdlong	local01, local01
	add	fp, #20
	wrlong	local01, fp
	sub	fp, #68
	mov	arg01, fp
	add	fp, #52
	rdlong	arg02, fp
	sub	fp, #72
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4658
	add	fp, #68
	rdlong	arg01, fp
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #88
	call	#_fatfs_cc_move_window
	add	fp, #16
	wrlong	result1, fp
	add	fp, #52
	rdlong	arg04, fp
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #72
	sub	local01, #1
	add	arg04, #16
	wrlong	local01, arg04
	jmp	#LR__4658
LR__4655
	add	fp, #16
	rdlong	arg04, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__4657
	add	fp, #26
	rdbyte	arg04, fp
	sub	fp, #26
	test	arg04, #16 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#4, fp
 if_ne	sub	fp, #16
 if_ne	jmp	#LR__4656
	add	fp, #12
	rdbyte	arg04, fp
	sub	fp, #12
	test	arg04, #2 wz
 if_ne	add	fp, #26
 if_ne	rdbyte	local01, fp
 if_ne	sub	fp, #26
 if_ne	test	local01, #1 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#7, fp
 if_ne	sub	fp, #16
LR__4656
LR__4657
LR__4658
	add	fp, #16
	rdlong	local01, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__4659
	add	fp, #12
	rdbyte	local02, fp
	sub	fp, #12
	test	local02, #8 wz
 if_ne	add	fp, #12
 if_ne	rdbyte	local02, fp
 if_ne	or	local02, #64
 if_ne	wrbyte	local02, fp
 if_ne	sub	fp, #12
	add	fp, #4
	rdlong	local02, fp
	add	fp, #64
	rdlong	local01, fp
	add	local01, #48
	rdlong	local01, local01
	add	local02, #32
	wrlong	local01, local02
	sub	fp, #64
	rdlong	local02, fp
	add	fp, #44
	rdlong	local01, fp
	sub	fp, #48
	add	local02, #36
	wrlong	local01, local02
LR__4659
	add	fp, #16
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__4665
	add	fp, #4
	rdlong	local02, fp
	add	fp, #64
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #48
	call	#_fatfs_cc_ld_clust
	add	local02, #8
	wrlong	result1, local02
	add	fp, #4
	rdlong	local02, fp
	add	fp, #44
	rdlong	arg01, fp
	add	arg01, #28
' {
' 
' 	return *((DWORD*)ptr);
	rdlong	result1, arg01
	add	local02, #12
	wrlong	result1, local02
	sub	fp, #44
	rdlong	local02, fp
	add	fp, #64
	rdlong	local01, fp
	wrlong	local01, local02
	sub	fp, #64
	rdlong	local02, fp
	add	fp, #64
	rdlong	local01, fp
	add	local01, #6
	rdword	local01, local01
	add	local02, #4
	wrword	local01, local02
	sub	fp, #64
	rdlong	local02, fp
	add	fp, #8
	rdbyte	local01, fp
	add	local02, #16
	wrbyte	local01, local02
	sub	fp, #8
	rdlong	local02, fp
	add	local02, #17
	wrbyte	#0, local02
	rdlong	local02, fp
	add	local02, #28
	wrlong	#0, local02
	rdlong	local02, fp
	add	local02, #20
	wrlong	#0, local02
	rdlong	arg01, fp
	sub	fp, #4
	add	arg01, #40
	mov	arg02, #0
	decod	arg03, #9
	call	#\builtin_bytefill_
	add	fp, #12
	rdbyte	local02, fp
	sub	fp, #12
	test	local02, #32 wz
 if_e	jmp	#LR__4664
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #12
	rdlong	local02, local01
	cmp	local02, #1 wc
 if_b	jmp	#LR__4664
	add	fp, #4
	rdlong	local01, fp
	mov	local02, local01
	add	local01, #12
	rdlong	local01, local01
	add	local02, #20
	wrlong	local01, local02
	add	fp, #64
	rdlong	local02, fp
	add	local02, #10
	rdword	local02, local02
	shl	local02, #9
	add	fp, #8
	wrlong	local02, fp
	sub	fp, #72
	rdlong	local02, fp
	add	local02, #8
	rdlong	local01, local02
	add	fp, #76
	wrlong	local01, fp
' 				fp->fptr = fp->obj.objsize;
' 				bcs = (DWORD)fs->csize *  ((UINT) 512 ) ;
' 				clst = fp->obj.sclust;
' 				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
	sub	fp, #76
	rdlong	local02, fp
	add	local02, #12
	rdlong	local01, local02
	add	fp, #88
	wrlong	local01, fp
	sub	fp, #92
LR__4660
	add	fp, #16
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__4661
	add	fp, #92
	rdlong	local02, fp
	sub	fp, #16
	rdlong	local01, fp
	sub	fp, #76
	cmp	local02, local01 wcz
 if_be	jmp	#LR__4661
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #76
	rdlong	arg02, fp
	sub	fp, #80
	call	#_fatfs_cc_get_fat
	add	fp, #80
	wrlong	result1, fp
	sub	fp, #80
	cmp	result1, #2 wc
 if_b	add	fp, #16
 if_b	wrlong	#2, fp
 if_b	sub	fp, #16
	add	fp, #80
	rdlong	local02, fp
	sub	fp, #80
	cmp	local02, ##-1 wz
 if_e	add	fp, #16
 if_e	wrlong	#1, fp
 if_e	sub	fp, #16
	add	fp, #92
	rdlong	local02, fp
	sub	fp, #16
	rdlong	local01, fp
	sub	local02, local01
	add	fp, #16
	wrlong	local02, fp
	sub	fp, #92
	jmp	#LR__4660
LR__4661
	add	fp, #4
	rdlong	local02, fp
	add	fp, #76
	rdlong	local01, fp
	add	local02, #24
	wrlong	local01, local02
	sub	fp, #64
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	jmp	#LR__4663
	add	fp, #92
	rdlong	local01, fp
	sub	fp, #92
	test	local01, #511 wz
 if_e	jmp	#LR__4663
	add	fp, #68
	rdlong	arg01, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #80
	call	#_fatfs_cc_clst2sect
	add	fp, #88
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #88
 if_e	add	fp, #16
 if_e	wrlong	#2, fp
 if_e	sub	fp, #16
 if_e	jmp	#LR__4662
	add	fp, #4
	rdlong	local02, fp
	add	fp, #84
	rdlong	local01, fp
	add	fp, #4
	rdlong	arg04, fp
	shr	arg04, #9
	add	local01, arg04
	add	local02, #28
	wrlong	local01, local02
	sub	fp, #24
	rdlong	local02, fp
	add	local02, #1
	rdbyte	arg01, local02
	sub	fp, #64
	rdlong	local02, fp
	mov	arg02, local02
	add	arg02, #40
	sub	fp, #4
	add	local02, #28
	rdlong	arg03, local02
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_ne	add	fp, #16
 if_ne	wrlong	#1, fp
 if_ne	sub	fp, #16
LR__4662
LR__4663
LR__4664
LR__4665
LR__4666
	add	fp, #16
	rdlong	local02, fp wz
	sub	fp, #16
 if_ne	add	fp, #4
 if_ne	rdlong	local02, fp
 if_ne	sub	fp, #4
 if_ne	wrlong	#0, local02
' 
' 	return res ;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
LR__4667
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_open_ret
	ret

_fatfs_cc_f_read
	mov	COUNT_, #14
	call	#pushregs_
	add	ptra, #56
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	rdlong	result1, fp
	add	fp, #44
	wrlong	result1, fp
	sub	fp, #36
	rdlong	result1, fp
	wrlong	#0, result1
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #20
	mov	arg02, fp
	sub	fp, #24
	call	#_fatfs_cc_validate
	add	fp, #20
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #20
 if_ne	jmp	#LR__4670
	add	fp, #4
	rdlong	arg02, fp
	add	arg02, #17
	rdbyte	arg02, arg02 wz
	add	fp, #16
	wrlong	arg02, fp
	sub	fp, #20
 if_e	jmp	#LR__4671
LR__4670
	add	fp, #20
	rdlong	result1, fp
	sub	fp, #20
	jmp	#LR__4690
LR__4671
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #1 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__4690
	add	fp, #4
	rdlong	local01, fp
	mov	local02, local01
	add	local02, #12
	rdlong	local03, local02
	add	local01, #20
	rdlong	local01, local01
	sub	local03, local01
	add	fp, #32
	wrlong	local03, fp
	sub	fp, #24
	rdlong	local04, fp
	sub	fp, #12
	cmp	local04, local03 wcz
 if_a	add	fp, #36
 if_a	rdlong	local04, fp
 if_a	sub	fp, #24
 if_a	wrlong	local04, fp
 if_a	sub	fp, #12
' 
' 	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
LR__4672
	add	fp, #12
	rdlong	local02, fp
	sub	fp, #12
	mov	local04, local02
	cmp	local04, #1 wc
 if_b	jmp	#LR__4689
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #20
	rdlong	local03, local03
	test	local03, #511 wz
 if_ne	jmp	#LR__4687
	add	fp, #4
	rdlong	local01, fp
	add	local01, #20
	rdlong	local03, local01
	shr	local03, #9
	add	fp, #20
	rdlong	local05, fp
	mov	local06, local05
	add	local06, #10
	rdword	local07, local06
	sub	local06, #10
	getword	local08, local07, #0
	sub	local08, #1
	and	local03, local08 wz
	add	fp, #24
	wrlong	local03, fp
	sub	fp, #48
 if_ne	jmp	#LR__4677
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #20
	rdlong	local03, local03 wz
 if_ne	jmp	#LR__4673
	add	fp, #4
	rdlong	local03, fp
	add	local03, #8
	rdlong	local03, local03
	add	fp, #24
	wrlong	local03, fp
	sub	fp, #28
	jmp	#LR__4674
LR__4673
	add	fp, #4
	rdlong	local08, fp
	mov	arg01, local08
	sub	fp, #4
	add	local08, #24
	rdlong	arg02, local08
	call	#_fatfs_cc_get_fat
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
LR__4674
	add	fp, #28
	rdlong	local03, fp
	sub	fp, #28
	cmp	local03, #2 wc
 if_ae	jmp	#LR__4675
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#2, local03
	mov	result1, #2
	jmp	#LR__4690
LR__4675
	add	fp, #28
	rdlong	local03, fp
	sub	fp, #28
	cmp	local03, ##-1 wz
 if_ne	jmp	#LR__4676
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__4690
LR__4676
	add	fp, #4
	rdlong	local03, fp
	add	fp, #24
	rdlong	local08, fp
	sub	fp, #28
	add	local03, #24
	wrlong	local08, local03
LR__4677
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #24
	rdlong	arg02, local03
	call	#_fatfs_cc_clst2sect
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4678
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#2, local03
	mov	result1, #2
	jmp	#LR__4690
LR__4678
	add	fp, #32
	rdlong	local03, fp
	add	fp, #16
	rdlong	local08, fp
	add	local03, local08
	sub	fp, #16
	wrlong	local03, fp
	sub	fp, #20
	rdlong	local03, fp
	shr	local03, #9
	add	fp, #32
	wrlong	local03, fp
	sub	fp, #44
	cmp	local03, #1 wc
 if_b	jmp	#LR__4682
	add	fp, #48
	rdlong	local03, fp
	sub	fp, #4
	rdlong	local08, fp
	add	local03, local08
	sub	fp, #20
	rdlong	local08, fp
	sub	fp, #24
	add	local08, #10
	rdword	local08, local08
	cmp	local03, local08 wcz
 if_be	jmp	#LR__4679
	add	fp, #24
	rdlong	local01, fp
	add	local01, #10
	rdword	local03, local01
	add	fp, #24
	rdlong	local08, fp
	sub	local03, local08
	sub	fp, #4
	wrlong	local03, fp
	sub	fp, #44
LR__4679
	add	fp, #24
	rdlong	local01, fp
	add	local01, #1
	rdbyte	arg01, local01
	add	fp, #28
	rdlong	arg02, fp
	sub	fp, #20
	rdlong	arg03, fp
	add	fp, #12
	rdlong	arg04, fp
	sub	fp, #44
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_e	jmp	#LR__4680
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__4690
LR__4680
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #16
	rdbyte	local03, local01
	test	local03, #128 wz
 if_e	jmp	#LR__4681
	add	fp, #4
	rdlong	local08, fp
	add	local08, #28
	rdlong	local08, local08
	add	fp, #28
	rdlong	local09, fp
	sub	local08, local09
	add	fp, #12
	rdlong	local10, fp
	sub	fp, #44
	mov	local11, local10
	cmp	local08, local11 wc
 if_ae	jmp	#LR__4681
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	arg02, fp
	mov	local11, arg02
	add	local11, #28
	rdlong	local09, local11
	add	fp, #28
	rdlong	local05, fp
	sub	local09, local05
	shl	local09, #9
	mov	local11, local09
	add	arg01, local09
	sub	fp, #32
	add	arg02, #40
	decod	arg03, #9
	call	#__system____builtin_memmove
LR__4681
	add	fp, #44
	rdlong	local03, fp
	shl	local03, #9
	sub	fp, #4
	wrlong	local03, fp
	sub	fp, #40
' 					__builtin_memcpy(rbuff + ((fp->sect - sect) * ((UINT) 512 ) ), fp->buf, ((UINT) 512 ) ) ;
' 				}
' 
' 
' 				rcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__4688
LR__4682
	add	fp, #4
	rdlong	local03, fp
	add	local03, #28
	rdlong	local03, local03
	add	fp, #28
	rdlong	local01, fp
	sub	fp, #32
	cmp	local03, local01 wz
 if_e	jmp	#LR__4686
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #16
	rdbyte	local03, local01
	test	local03, #128 wz
 if_e	jmp	#LR__4684
	add	fp, #24
	rdlong	local01, fp
	add	local01, #1
	rdbyte	arg01, local01
	sub	fp, #20
	rdlong	local03, fp
	mov	arg02, local03
	add	arg02, #40
	sub	fp, #4
	add	local03, #28
	rdlong	arg03, local03
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__4683
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__4690
LR__4683
	add	fp, #4
	rdlong	local11, fp
	mov	local03, local11
	sub	fp, #4
	add	local11, #16
	rdbyte	local11, local11
	and	local11, #127
	add	local03, #16
	wrbyte	local11, local03
LR__4684
	add	fp, #24
	rdlong	local01, fp
	add	local01, #1
	rdbyte	arg01, local01
	sub	fp, #20
	rdlong	arg02, fp
	add	arg02, #40
	add	fp, #28
	rdlong	arg03, fp
	sub	fp, #32
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_e	jmp	#LR__4685
	add	fp, #4
	rdlong	local03, fp
	sub	fp, #4
	add	local03, #17
	wrbyte	#1, local03
	mov	result1, #1
	jmp	#LR__4690
LR__4685
LR__4686
	add	fp, #4
	rdlong	local03, fp
	add	fp, #28
	rdlong	local11, fp
	sub	fp, #32
	add	local03, #28
	wrlong	local11, local03
LR__4687
	add	fp, #4
	rdlong	local01, fp
	add	local01, #20
	rdlong	local11, local01
	and	local11, #511
	decod	local03, #9
	sub	local03, local11
	add	fp, #36
	wrlong	local03, fp
	sub	fp, #28
	rdlong	local11, fp
	sub	fp, #12
	cmp	local03, local11 wcz
 if_a	add	fp, #12
 if_a	rdlong	local03, fp
 if_a	add	fp, #28
 if_a	wrlong	local03, fp
 if_a	sub	fp, #40
	add	fp, #52
	rdlong	arg01, fp
	sub	fp, #48
	rdlong	local06, fp
	mov	arg02, local06
	add	arg02, #40
	add	local06, #20
	rdlong	local11, local06
	mov	local09, local11
	mov	local10, local09
	and	local10, #511
	add	arg02, local10
	add	fp, #36
	rdlong	arg03, fp
	sub	fp, #40
	call	#__system____builtin_memmove
LR__4688
	add	fp, #12
	rdlong	local03, fp
	add	fp, #28
	rdlong	local08, fp
	sub	local03, local08
	sub	fp, #28
	wrlong	local03, fp
	add	fp, #4
	rdlong	local01, fp
	rdlong	local07, local01
	add	fp, #24
	rdlong	local08, fp
	add	local07, local08
	wrlong	local07, local01
	add	fp, #12
	rdlong	local03, fp
	sub	fp, #12
	rdlong	local12, fp
	add	local03, local12
	add	fp, #12
	wrlong	local03, fp
	sub	fp, #48
	rdlong	local13, fp
	mov	local03, local13
	add	local13, #20
	rdlong	local14, local13
	add	fp, #36
	rdlong	local06, fp
	sub	fp, #40
	add	local14, local06
	add	local03, #20
	wrlong	local14, local03
	jmp	#LR__4672
LR__4689
' 
' 
' 
' 
' 		__builtin_memcpy(rbuff, fp->buf + fp->fptr % ((UINT) 512 ) , rcnt) ;
' 
' 	}
' 
' 	return FR_OK ;
	mov	result1, #0
LR__4690
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_read_ret
	ret

_fatfs_cc_f_write
	mov	COUNT_, #21
	call	#pushregs_
	add	ptra, #52
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	add	fp, #4
	wrlong	arg04, fp
	sub	fp, #8
	rdlong	result1, fp
	add	fp, #40
	wrlong	result1, fp
	sub	fp, #32
	rdlong	result1, fp
	wrlong	#0, result1
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #20
	mov	arg02, fp
	sub	fp, #24
	call	#_fatfs_cc_validate
	add	fp, #20
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #20
 if_ne	jmp	#LR__4700
	add	fp, #4
	rdlong	arg02, fp
	add	arg02, #17
	rdbyte	arg02, arg02 wz
	add	fp, #16
	wrlong	arg02, fp
	sub	fp, #20
 if_e	jmp	#LR__4701
LR__4700
	add	fp, #20
	rdlong	result1, fp
	sub	fp, #20
	jmp	#LR__4723
LR__4701
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #4
	add	arg02, #16
	rdbyte	arg02, arg02
	test	arg02, #2 wz
 if_e	mov	result1, #7
 if_e	jmp	#LR__4723
	add	fp, #4
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg01, #20
	rdlong	arg01, arg01
	add	fp, #8
	rdlong	result1, fp
	add	arg01, result1
	sub	fp, #12
	add	arg02, #20
	rdlong	result1, arg02
	cmp	arg01, result1 wc
 if_ae	jmp	#LR__4702
	add	fp, #4
	rdlong	arg02, fp
	neg	result1, #1
	add	arg02, #20
	rdlong	arg02, arg02
	sub	result1, arg02
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #12
LR__4702
' 		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
' 	}
' 
' 	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
LR__4703
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	cmp	result1, #1 wc
 if_b	jmp	#LR__4722
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #20
	rdlong	result1, result1
	test	result1, #511 wz
 if_ne	jmp	#LR__4718
	add	fp, #4
	rdlong	result1, fp
	add	result1, #20
	rdlong	result1, result1
	shr	result1, #9
	add	fp, #20
	rdlong	arg02, fp
	add	arg02, #10
	rdword	arg04, arg02
	getword	arg02, arg04, #0
	sub	arg02, #1
	and	result1, arg02 wz
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #44
 if_ne	jmp	#LR__4709
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #20
	rdlong	arg02, result1 wz
 if_ne	jmp	#LR__4704
	add	fp, #4
	rdlong	arg02, fp
	add	arg02, #8
	rdlong	arg02, arg02 wz
	add	fp, #24
	wrlong	arg02, fp
	sub	fp, #28
 if_ne	jmp	#LR__4705
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	jmp	#LR__4705
LR__4704
	add	fp, #4
	rdlong	arg04, fp
	mov	arg01, arg04
	sub	fp, #4
	add	arg04, #24
	rdlong	arg02, arg04
	call	#_fatfs_cc_create_chain
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
LR__4705
	add	fp, #28
	rdlong	result1, fp wz
	sub	fp, #28
 if_e	jmp	#LR__4722
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #28
	cmp	result1, #1 wz
 if_ne	jmp	#LR__4706
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#2, result1
	mov	result1, #2
	jmp	#LR__4723
LR__4706
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #28
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__4707
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#1, result1
	mov	result1, #1
	jmp	#LR__4723
LR__4707
	add	fp, #4
	rdlong	result1, fp
	add	fp, #24
	rdlong	arg04, fp
	add	result1, #24
	wrlong	arg04, result1
	sub	fp, #24
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #8
	rdlong	result1, result1 wz
 if_ne	jmp	#LR__4708
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #28
	add	arg04, #8
	wrlong	result1, arg04
LR__4708
LR__4709
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #128 wz
 if_e	jmp	#LR__4711
	add	fp, #24
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	sub	fp, #20
	rdlong	arg04, fp
	mov	arg02, arg04
	add	arg02, #40
	sub	fp, #4
	add	arg04, #28
	rdlong	arg03, arg04
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__4710
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#1, result1
	mov	result1, #1
	jmp	#LR__4723
LR__4710
	add	fp, #4
	rdlong	arg04, fp
	mov	result1, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	result1, #16
	wrbyte	arg04, result1
LR__4711
	add	fp, #24
	rdlong	arg01, fp
	sub	fp, #20
	rdlong	arg02, fp
	sub	fp, #4
	add	arg02, #24
	rdlong	arg02, arg02
	call	#_fatfs_cc_clst2sect
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4712
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	add	result1, #17
	wrbyte	#2, result1
	mov	result1, #2
	jmp	#LR__4723
LR__4712
	add	fp, #32
	rdlong	result1, fp
	add	fp, #12
	rdlong	local01, fp
	add	result1, local01
	sub	fp, #12
	wrlong	result1, fp
	sub	fp, #20
	rdlong	result1, fp
	shr	result1, #9
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #40
	cmp	result1, #1 wc
 if_b	jmp	#LR__4716
	add	fp, #44
	rdlong	result1, fp
	sub	fp, #4
	rdlong	arg04, fp
	add	result1, arg04
	sub	fp, #16
	rdlong	arg04, fp
	sub	fp, #24
	add	arg04, #10
	rdword	arg04, arg04
	cmp	result1, arg04 wcz
 if_be	jmp	#LR__4713
	add	fp, #24
	rdlong	result1, fp
	add	result1, #10
	rdword	result1, result1
	add	fp, #20
	rdlong	arg04, fp
	sub	result1, arg04
	sub	fp, #4
	wrlong	result1, fp
	sub	fp, #40
LR__4713
	add	fp, #24
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	add	fp, #24
	rdlong	arg02, fp
	sub	fp, #16
	rdlong	arg03, fp
	add	fp, #8
	rdlong	arg04, fp
	sub	fp, #40
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__4714
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #4
	add	local01, #17
	wrbyte	#1, local01
	mov	result1, #1
	jmp	#LR__4723
LR__4714
	add	fp, #4
	rdlong	result1, fp
	add	result1, #28
	rdlong	result1, result1
	add	fp, #28
	rdlong	local02, fp
	sub	result1, local02
	add	fp, #8
	rdlong	arg04, fp
	sub	fp, #40
	cmp	result1, arg04 wc
 if_ae	jmp	#LR__4715
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #40
	add	fp, #44
	rdlong	arg02, fp
	sub	fp, #44
	rdlong	result1, fp
	add	result1, #28
	rdlong	local03, result1
	add	fp, #28
	rdlong	arg04, fp
	sub	fp, #32
	sub	local03, arg04
	shl	local03, #9
	add	arg02, local03
	decod	arg03, #9
	call	#__system____builtin_memmove
	add	fp, #4
	rdlong	arg04, fp
	mov	result1, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	result1, #16
	wrbyte	arg04, result1
LR__4715
	add	fp, #40
	rdlong	result1, fp
	shl	result1, #9
	sub	fp, #4
	wrlong	result1, fp
	sub	fp, #36
' 					__builtin_memcpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT) 512 ) ), ((UINT) 512 ) ) ;
' 					fp->flag &= (BYTE)~ 0x80 ;
' 				}
' 
' 
' 				wcnt =  ((UINT) 512 )  * cc;
' 				continue;
	jmp	#LR__4719
LR__4716
	add	fp, #4
	rdlong	local02, fp
	add	local02, #28
	rdlong	result1, local02
	add	fp, #28
	rdlong	local02, fp
	sub	fp, #32
	cmp	result1, local02 wz
 if_e	jmp	#LR__4717
	add	fp, #4
	rdlong	result1, fp
	mov	local03, result1
	sub	fp, #4
	add	local03, #20
	rdlong	local03, local03
	add	result1, #12
	rdlong	local04, result1
	mov	local05, local04
	cmp	local03, local05 wc
 if_ae	jmp	#LR__4717
	add	fp, #24
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	sub	fp, #20
	rdlong	local06, fp
	add	local06, #40
	mov	local07, local06
	add	fp, #28
	rdlong	local08, fp
	sub	fp, #32
	mov	local09, #1
	mov	arg02, local07
	mov	arg03, local08
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	mov	local10, result1 wz
 if_e	jmp	#LR__4717
	add	fp, #4
	rdlong	local10, fp
	sub	fp, #4
	add	local10, #17
	wrbyte	#1, local10
' 				fp->fptr < fp->obj.objsize &&
' 				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
' 					{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR ; } ;
	mov	result1, #1
	jmp	#LR__4723
LR__4717
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #28
	rdlong	result1, fp
	sub	fp, #32
	add	arg04, #28
	wrlong	result1, arg04
LR__4718
	add	fp, #4
	rdlong	result1, fp
	add	result1, #20
	rdlong	result1, result1
	and	result1, #511
	decod	local11, #9
	sub	local11, result1
	add	fp, #32
	wrlong	local11, fp
	sub	fp, #24
	rdlong	result1, fp
	sub	fp, #12
	cmp	local11, result1 wcz
 if_a	add	fp, #12
 if_a	rdlong	local11, fp
 if_a	add	fp, #24
 if_a	wrlong	local11, fp
 if_a	sub	fp, #36
	add	fp, #4
	rdlong	local11, fp
	mov	arg01, local11
	add	arg01, #40
	add	local11, #20
	rdlong	local11, local11
	and	local11, #511
	add	arg01, local11
	add	fp, #44
	rdlong	arg02, fp
	sub	fp, #12
	rdlong	arg03, fp
	sub	fp, #36
	call	#__system____builtin_memmove
	add	fp, #4
	rdlong	result1, fp
	mov	local11, result1
	sub	fp, #4
	add	result1, #16
	rdbyte	result1, result1
	or	result1, #128
	add	local11, #16
	wrbyte	result1, local11
LR__4719
	add	fp, #12
	rdlong	local11, fp
	add	fp, #24
	rdlong	result1, fp
	sub	local11, result1
	sub	fp, #24
	wrlong	local11, fp
	add	fp, #4
	rdlong	local12, fp
	rdlong	local11, local12
	add	fp, #20
	rdlong	local13, fp
	add	local11, local13
	wrlong	local11, local12
	add	fp, #12
	rdlong	local11, fp
	sub	fp, #12
	rdlong	local14, fp
	add	local11, local14
	add	fp, #12
	wrlong	local11, fp
	sub	fp, #44
	rdlong	local15, fp
	mov	local11, local15
	add	local15, #20
	rdlong	local15, local15
	add	fp, #32
	rdlong	local16, fp
	add	local15, local16
	add	local11, #20
	wrlong	local15, local11
	sub	fp, #32
	rdlong	local17, fp
	mov	local11, local17
	mov	local18, local17
	sub	fp, #4
	add	local17, #20
	rdlong	local19, local17
	add	local18, #12
	rdlong	local20, local18
	cmp	local19, local20 wcz
 if_be	jmp	#LR__4720
	add	fp, #4
	rdlong	local05, fp
	sub	fp, #4
	mov	local03, local05
	add	local03, #20
	rdlong	local04, local03
	sub	local03, #20
	mov	local21, local04
	jmp	#LR__4721
LR__4720
	add	fp, #4
	rdlong	local07, fp
	sub	fp, #4
	mov	local10, local07
	add	local10, #12
	rdlong	local08, local10
	sub	local10, #12
	mov	local21, local08
LR__4721
	add	local11, #12
	wrlong	local21, local11
	jmp	#LR__4703
LR__4722
	add	fp, #4
	rdlong	local12, fp
	mov	local01, local12
	sub	fp, #4
	add	local12, #16
	rdbyte	local11, local12
	or	local11, #64
	add	local01, #16
	wrbyte	local11, local01
' 
' 
' 
' 
' 
' 		__builtin_memcpy(fp->buf + fp->fptr % ((UINT) 512 ) , wbuff, wcnt) ;
' 		fp->flag |=  0x80 ;
' 
' 	}
' 
' 	fp->flag |=  0x40 ;
' 
' 	return FR_OK ;
	mov	result1, #0
LR__4723
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_write_ret
	ret

_fatfs_cc_f_sync
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #24
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_validate
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4733
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #64 wz
 if_e	jmp	#LR__4732
	add	fp, #4
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	test	arg04, #128 wz
 if_e	jmp	#LR__4730
	add	fp, #12
	rdlong	arg04, fp
	add	arg04, #1
	rdbyte	arg01, arg04
	sub	fp, #8
	rdlong	arg04, fp
	mov	arg02, arg04
	add	arg02, #40
	sub	fp, #4
	add	arg04, #28
	rdlong	arg03, arg04
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__4734
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	arg03, #16
	wrbyte	arg04, arg03
LR__4730
	call	#_fatfs_cc__get_fattime
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #4
	rdlong	arg01, fp
	sub	fp, #8
	rdlong	arg04, fp
	sub	fp, #4
	add	arg04, #32
	rdlong	arg02, arg04
	call	#_fatfs_cc_move_window
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4731
	add	fp, #4
	rdlong	arg04, fp
	add	arg04, #36
	rdlong	arg04, arg04
	add	fp, #16
	wrlong	arg04, fp
	mov	arg03, arg04
	add	arg03, #11
	rdbyte	arg03, arg03
	or	arg03, #32
	add	arg04, #11
	wrbyte	arg03, arg04
	sub	fp, #16
	rdlong	arg04, fp
	rdlong	arg01, arg04
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #20
	add	arg04, #8
	rdlong	arg03, arg04
	call	#_fatfs_cc_st_clust
	add	fp, #20
	rdlong	arg01, fp
	add	arg01, #28
	sub	fp, #16
	rdlong	arg04, fp
	add	arg04, #12
	rdlong	arg02, arg04
	wrlong	arg02, arg01
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, #22
	sub	fp, #4
	rdlong	arg02, fp
	wrlong	arg02, arg01
	add	fp, #4
	rdlong	arg01, fp
	add	arg01, #18
	wrword	#0, arg01
	sub	fp, #8
	rdlong	arg04, fp
	add	arg04, #3
	wrbyte	#1, arg04
	rdlong	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc_sync_fs
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #191
	add	arg03, #16
	wrbyte	arg04, arg03
LR__4731
LR__4732
LR__4733
' 					dir = fp->dir_ptr;
' 					dir[ 11 ] |=  0x20 ;
' 					st_clust(fp->obj.fs, dir, fp->obj.sclust);
' 					st_dword(dir +  28 , (DWORD)fp->obj.objsize);
' 					st_dword(dir +  22 , tm);
' 					st_word(dir +  18 , 0);
' 					fs->wflag = 1;
' 					res = sync_fs(fs);
' 					fp->flag &= (BYTE)~ 0x40 ;
' 				}
' 			}
' 		}
' 	}
' 
' 	return res ;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
LR__4734
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_sync_ret
	ret

_fatfs_cc_f_close
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	sub	fp, #4
	call	#_fatfs_cc_f_sync
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4740
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_validate
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_e	add	fp, #4
 if_e	rdlong	local01, fp
 if_e	sub	fp, #4
 if_e	wrlong	#0, local01
LR__4740
' 
' 
' 
' 
' 			fp->obj.fs = 0;
' #line 4192 "ff.c"
' 		}
' 	}
' 	return res;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_close_ret
	ret

_fatfs_cc_f_lseek
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #36
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc_validate
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4750
	add	fp, #4
	rdlong	arg04, fp
	add	arg04, #17
	rdbyte	arg04, arg04
	add	fp, #8
	wrlong	arg04, fp
	sub	fp, #12
LR__4750
	add	fp, #12
	rdlong	arg04, fp wz
	sub	fp, #12
 if_ne	add	fp, #12
 if_ne	rdlong	result1, fp
 if_ne	sub	fp, #12
 if_ne	jmp	#LR__4773
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #8
	add	arg04, #12
	rdlong	arg04, arg04
	cmp	arg03, arg04 wcz
 if_be	jmp	#LR__4751
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #16
	rdbyte	arg03, arg03
	getbyte	arg03, arg03, #0
	test	arg03, #2 wz
 if_ne	jmp	#LR__4751
	add	fp, #4
	rdlong	arg03, fp
	add	arg03, #12
	rdlong	arg03, arg03
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
LR__4751
	add	fp, #4
	rdlong	arg03, fp
	add	arg03, #20
	rdlong	arg03, arg03
	add	fp, #28
	wrlong	arg03, fp
	sub	fp, #28
	rdlong	arg03, fp
	add	fp, #24
	wrlong	#0, fp
	add	arg03, #20
	wrlong	#0, arg03
	sub	fp, #20
	rdlong	arg03, fp
	sub	fp, #8
	cmp	arg03, #1 wc
 if_b	jmp	#LR__4767
	add	fp, #16
	rdlong	arg03, fp
	add	arg03, #10
	rdword	arg04, arg03
	shl	arg04, #9
	add	fp, #8
	wrlong	arg04, fp
	add	fp, #8
	rdlong	arg04, fp
	sub	fp, #32
	cmp	arg04, #1 wc
 if_b	jmp	#LR__4752
	add	fp, #8
	rdlong	arg04, fp
	sub	arg04, #1
	add	fp, #16
	rdlong	arg03, fp
	qdiv	arg04, arg03
	add	fp, #8
	rdlong	result1, fp
	sub	result1, #1
	getqx	arg04
	qdiv	result1, arg03
	sub	fp, #32
	getqx	arg03
	cmp	arg04, arg03 wc
 if_b	jmp	#LR__4752
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #28
	rdlong	result1, fp
	sub	result1, #1
	sub	fp, #8
	rdlong	arg04, fp
	sub	arg04, #1
	andn	result1, arg04
	add	arg03, #20
	wrlong	result1, arg03
	sub	fp, #16
	rdlong	arg03, fp
	sub	fp, #4
	rdlong	arg04, fp
	add	arg04, #20
	rdlong	arg04, arg04
	sub	arg03, arg04
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	arg03, #24
	rdlong	arg03, arg03
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #20
	jmp	#LR__4756
LR__4752
	add	fp, #4
	rdlong	arg03, fp
	add	arg03, #8
	rdlong	arg03, arg03 wz
	add	fp, #16
	wrlong	arg03, fp
	sub	fp, #20
 if_ne	jmp	#LR__4755
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmp	result1, #1 wz
 if_ne	jmp	#LR__4753
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#2, arg03
	mov	result1, #2
	jmp	#LR__4773
LR__4753
	add	fp, #20
	rdlong	result1, fp
	sub	fp, #20
	cmp	result1, ##-1 wz
 if_ne	jmp	#LR__4754
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__4773
LR__4754
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #16
	rdlong	arg04, fp
	sub	fp, #20
	add	arg03, #8
	wrlong	arg04, arg03
LR__4755
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #16
	rdlong	arg04, fp
	sub	fp, #20
	add	arg03, #24
	wrlong	arg04, arg03
LR__4756
	add	fp, #20
	rdlong	arg03, fp wz
	sub	fp, #20
 if_e	jmp	#LR__4766
' 				while (ofs > bcs) {
LR__4757
	add	fp, #8
	rdlong	arg04, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #24
	cmp	arg04, arg03 wcz
 if_be	jmp	#LR__4763
	add	fp, #8
	rdlong	arg04, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	arg04, arg03
	sub	fp, #16
	wrlong	arg04, fp
	sub	fp, #4
	rdlong	arg04, fp
	mov	result1, arg04
	add	arg04, #20
	rdlong	arg04, arg04
	add	fp, #20
	rdlong	arg03, fp
	add	arg04, arg03
	add	result1, #20
	wrlong	arg04, result1
	sub	fp, #20
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #16
	rdbyte	arg03, arg03
	test	arg03, #2 wz
 if_e	jmp	#LR__4758
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_create_chain
	add	fp, #20
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #20
 if_e	add	fp, #8
 if_e	wrlong	#0, fp
 if_e	sub	fp, #8
' 							ofs = 0; break;
 if_e	jmp	#LR__4763
	jmp	#LR__4759
LR__4758
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #16
	rdlong	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_get_fat
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
LR__4759
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, ##-1 wz
 if_ne	jmp	#LR__4760
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__4773
LR__4760
	add	fp, #20
	rdlong	arg03, fp
	sub	fp, #20
	cmp	arg03, #2 wc
 if_b	jmp	#LR__4761
	add	fp, #16
	rdlong	arg04, fp
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #20
	add	arg04, #24
	rdlong	arg04, arg04
	cmp	arg03, arg04 wc
 if_b	jmp	#LR__4762
LR__4761
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#2, arg03
	mov	result1, #2
	jmp	#LR__4773
LR__4762
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #16
	rdlong	arg03, fp
	sub	fp, #20
	add	arg04, #24
	wrlong	arg03, arg04
	jmp	#LR__4757
LR__4763
	add	fp, #4
	rdlong	arg03, fp
	mov	arg01, arg03
	add	arg03, #20
	rdlong	arg02, arg03
	add	fp, #4
	rdlong	arg03, fp
	add	arg02, arg03
	add	arg01, #20
	wrlong	arg02, arg01
	rdlong	arg03, fp
	sub	fp, #8
	test	arg03, #511 wz
 if_e	jmp	#LR__4765
	add	fp, #16
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #20
	call	#_fatfs_cc_clst2sect
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4764
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#2, arg03
	mov	result1, #2
	jmp	#LR__4773
LR__4764
	add	fp, #28
	rdlong	arg04, fp
	sub	fp, #20
	rdlong	arg03, fp
	shr	arg03, #9
	add	arg04, arg03
	add	fp, #20
	wrlong	arg04, fp
	sub	fp, #28
LR__4765
LR__4766
LR__4767
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg03, #20
	rdlong	arg03, arg03
	add	arg04, #12
	rdlong	arg04, arg04
	cmp	arg03, arg04 wcz
 if_be	jmp	#LR__4768
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	add	arg04, #20
	rdlong	arg04, arg04
	add	arg03, #12
	wrlong	arg04, arg03
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	or	arg04, #64
	add	arg03, #16
	wrbyte	arg04, arg03
LR__4768
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #20
	rdlong	arg03, arg03
	test	arg03, #511 wz
 if_e	jmp	#LR__4772
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #24
	rdlong	arg03, fp
	sub	fp, #28
	add	arg04, #28
	rdlong	arg04, arg04
	cmp	arg03, arg04 wz
 if_e	jmp	#LR__4772
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #16
	rdbyte	arg03, arg03
	test	arg03, #128 wz
 if_e	jmp	#LR__4770
	add	fp, #16
	rdlong	arg03, fp
	add	arg03, #1
	rdbyte	arg01, arg03
	sub	fp, #12
	rdlong	arg03, fp
	mov	arg02, arg03
	add	arg02, #40
	sub	fp, #4
	add	arg03, #28
	rdlong	arg03, arg03
	mov	arg04, #1
	call	#_fatfs_cc_disk_write
	cmp	result1, #0 wz
 if_e	jmp	#LR__4769
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__4773
LR__4769
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	sub	fp, #4
	add	arg04, #16
	rdbyte	arg04, arg04
	and	arg04, #127
	add	arg03, #16
	wrbyte	arg04, arg03
LR__4770
	add	fp, #16
	rdlong	arg03, fp
	add	arg03, #1
	rdbyte	arg01, arg03
	sub	fp, #12
	rdlong	arg02, fp
	add	arg02, #40
	add	fp, #24
	rdlong	arg03, fp
	sub	fp, #28
	mov	arg04, #1
	call	#_fatfs_cc_disk_read
	cmp	result1, #0 wz
 if_e	jmp	#LR__4771
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #17
	wrbyte	#1, arg03
	mov	result1, #1
	jmp	#LR__4773
LR__4771
	add	fp, #4
	rdlong	arg04, fp
	add	fp, #24
	rdlong	arg03, fp
	sub	fp, #28
	add	arg04, #28
	wrlong	arg03, arg04
LR__4772
' 
' 			fp->sect = nsect;
' 		}
' 	}
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
LR__4773
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_lseek_ret
	ret

_fatfs_cc_f_opendir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #20
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg03, fp wz
	sub	fp, #4
 if_e	mov	result1, #9
 if_e	jmp	#LR__4786
	add	fp, #8
	mov	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4785
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #12
	rdlong	result1, fp
	wrlong	result1, arg03
	sub	fp, #12
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4784
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #43
	rdbyte	arg03, arg03
	test	arg03, #128 wz
 if_ne	jmp	#LR__4782
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #4
	add	arg03, #6
	rdbyte	arg03, arg03
	test	arg03, #16 wz
 if_e	jmp	#LR__4780
	add	fp, #4
	rdlong	arg03, fp
	mov	local01, arg03
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #16
	add	arg03, #28
	rdlong	arg02, arg03
	call	#_fatfs_cc_ld_clust
	add	local01, #8
	wrlong	result1, local01
	jmp	#LR__4781
LR__4780
	add	fp, #12
	wrlong	#5, fp
	sub	fp, #12
LR__4781
LR__4782
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__4783
	add	fp, #4
	rdlong	local01, fp
	add	fp, #12
	rdlong	arg03, fp
	add	arg03, #6
	rdword	arg03, arg03
	add	local01, #4
	wrword	arg03, local01
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__4783
LR__4784
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#5, fp
 if_e	sub	fp, #12
LR__4785
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	add	fp, #4
 if_ne	rdlong	local01, fp
 if_ne	sub	fp, #4
 if_ne	wrlong	#0, local01
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
LR__4786
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_opendir_ret
	ret

_fatfs_cc_f_closedir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_validate
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_e	add	fp, #4
 if_e	rdlong	result1, fp
 if_e	sub	fp, #4
 if_e	wrlong	#0, result1
' 
' 
' 
' 
' 		dp->obj.fs = 0;
' #line 4633 "ff.c"
' 	}
' 	return res;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_closedir_ret
	ret

_fatfs_cc_f_readdir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc_validate
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4793
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__4790
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	jmp	#LR__4792
LR__4790
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#0, fp
 if_e	sub	fp, #12
	add	fp, #12
	rdlong	result1, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__4791
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_get_fileinfo
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	mov	arg02, #0
	call	#_fatfs_cc_dir_next
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #4 wz
 if_e	add	fp, #12
 if_e	wrlong	#0, fp
 if_e	sub	fp, #12
LR__4791
LR__4792
LR__4793
' 			}
' 			;
' 		}
' 	}
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_readdir_ret
	ret

_fatfs_cc_f_stat
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #64
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #0
	call	#_fatfs_cc_mount_volume
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4803
	add	fp, #16
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4802
	add	fp, #59
	rdbyte	result1, fp
	sub	fp, #59
	test	result1, #128 wz
 if_ne	add	fp, #12
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #12
 if_ne	jmp	#LR__4801
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_e	jmp	#LR__4800
	add	fp, #16
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_get_fileinfo
LR__4800
LR__4801
LR__4802
LR__4803
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_stat_ret
	ret

_fatfs_cc_f_unlink
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #116
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #104
	wrlong	#0, fp
	sub	fp, #104
	mov	arg01, fp
	add	fp, #108
	mov	arg02, fp
	sub	fp, #112
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4818
	add	fp, #112
	rdlong	arg03, fp
	sub	fp, #100
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__4817
	add	fp, #55
	rdbyte	result1, fp
	sub	fp, #55
	test	result1, #128 wz
 if_ne	add	fp, #8
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #8
 if_ne	jmp	#LR__4810
	add	fp, #18
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #1 wz
 if_ne	add	fp, #8
 if_ne	wrlong	#7, fp
 if_ne	sub	fp, #8
LR__4810
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__4813
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #72
	rdlong	arg02, fp
	sub	fp, #40
	call	#_fatfs_cc_ld_clust
	add	fp, #108
	wrlong	result1, fp
	sub	fp, #90
	rdbyte	result1, fp
	sub	fp, #18
	test	result1, #16 wz
 if_e	jmp	#LR__4812
	add	fp, #112
	rdlong	result1, fp
	sub	fp, #52
	wrlong	result1, fp
	add	fp, #48
	rdlong	arg03, fp
	sub	fp, #40
	wrlong	arg03, fp
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_dir_sdi
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4811
	add	fp, #60
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_dir_read
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_e	add	fp, #8
 if_e	wrlong	#7, fp
 if_e	sub	fp, #8
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	cmp	result1, #4 wz
 if_e	add	fp, #8
 if_e	wrlong	#0, fp
 if_e	sub	fp, #8
LR__4811
LR__4812
LR__4813
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__4816
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc_dir_remove
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4814
	add	fp, #108
	rdlong	result1, fp wz
	sub	fp, #108
 if_e	jmp	#LR__4814
	add	fp, #12
	mov	arg01, fp
	add	fp, #96
	rdlong	arg02, fp
	sub	fp, #108
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
LR__4814
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__4815
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	call	#_fatfs_cc_sync_fs
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
LR__4815
LR__4816
LR__4817
LR__4818
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_unlink_ret
	ret

_fatfs_cc_f_mkdir
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #92
	add	fp, #4
	wrlong	arg01, fp
	mov	arg01, fp
	add	fp, #72
	mov	arg02, fp
	sub	fp, #76
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4825
	add	fp, #76
	rdlong	arg03, fp
	sub	fp, #64
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #8
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_e	add	fp, #8
 if_e	wrlong	#8, fp
 if_e	sub	fp, #8
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	cmp	result1, #4 wz
 if_ne	jmp	#LR__4824
	add	fp, #76
	rdlong	arg03, fp
	sub	fp, #16
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #60
	mov	arg02, #0
	call	#_fatfs_cc_create_chain
	add	fp, #80
	wrlong	result1, fp
	sub	fp, #72
	wrlong	#0, fp
	add	fp, #72
	rdlong	result1, fp wz
	sub	fp, #80
 if_e	add	fp, #8
 if_e	wrlong	#7, fp
 if_e	sub	fp, #8
	add	fp, #80
	rdlong	result1, fp
	sub	fp, #80
	cmp	result1, #1 wz
 if_e	add	fp, #8
 if_e	wrlong	#2, fp
 if_e	sub	fp, #8
	add	fp, #80
	rdlong	arg03, fp
	sub	fp, #80
	cmp	arg03, ##-1 wz
 if_e	add	fp, #8
 if_e	wrlong	#1, fp
 if_e	sub	fp, #8
	call	#_fatfs_cc__get_fattime
	add	fp, #88
	wrlong	result1, fp
	sub	fp, #80
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__4821
	add	fp, #76
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #80
	call	#_fatfs_cc_dir_clear
	add	fp, #8
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #8
 if_ne	jmp	#LR__4820
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	add	arg01, #52
	mov	arg02, #32
	mov	arg03, #11
	call	#\builtin_bytefill_
	add	fp, #76
	rdlong	result1, fp
	add	result1, #52
	wrbyte	#46, result1
	rdlong	arg03, fp
	add	arg03, #63
	wrbyte	#16, arg03
	rdlong	arg01, fp
	add	arg01, #74
	add	fp, #12
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #12
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg02, #52
	add	fp, #4
	rdlong	arg03, fp
	sub	fp, #80
	call	#_fatfs_cc_st_clust
	add	fp, #76
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg01, #84
	sub	fp, #76
	add	arg02, #52
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #76
	rdlong	arg03, fp
	add	arg03, #85
	wrbyte	#46, arg03
	sub	fp, #56
	rdlong	arg03, fp
	add	fp, #64
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg02, fp
	mov	arg01, arg02
	add	arg02, #84
	sub	fp, #76
	call	#_fatfs_cc_st_clust
	add	fp, #76
	rdlong	arg03, fp
	add	arg03, #3
	wrbyte	#1, arg03
	sub	fp, #64
	mov	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc_dir_register
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
LR__4820
LR__4821
	add	fp, #8
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__4822
	add	fp, #40
	rdlong	arg01, fp
	add	arg01, #22
	add	fp, #48
	rdlong	arg02, fp
	wrlong	arg02, arg01
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #36
	rdlong	arg02, fp
	add	fp, #40
	rdlong	arg03, fp
	sub	fp, #80
	call	#_fatfs_cc_st_clust
	add	fp, #40
	rdlong	result1, fp
	add	result1, #11
	wrbyte	#16, result1
	add	fp, #36
	rdlong	result1, fp
	add	result1, #3
	wrbyte	#1, result1
	sub	fp, #68
	rdlong	result1, fp wz
	sub	fp, #8
 if_ne	jmp	#LR__4823
	add	fp, #76
	rdlong	arg01, fp
	sub	fp, #76
	call	#_fatfs_cc_sync_fs
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #8
	jmp	#LR__4823
LR__4822
	add	fp, #60
	mov	arg01, fp
	add	fp, #20
	rdlong	arg02, fp
	sub	fp, #80
	mov	arg03, #0
	call	#_fatfs_cc_remove_chain
LR__4823
LR__4824
LR__4825
' 				remove_chain(&sobj, dcl, 0);
' 			}
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #8
	rdlong	result1, fp
	sub	fp, #8
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_mkdir_ret
	ret

_fatfs_cc_f_rename
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #156
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #8
	call	#_fatfs_cc_get_ldnumber
	add	fp, #4
	mov	arg01, fp
	add	fp, #108
	mov	arg02, fp
	sub	fp, #112
	mov	arg03, #2
	call	#_fatfs_cc_mount_volume
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4843
	add	fp, #112
	rdlong	arg03, fp
	sub	fp, #96
	wrlong	arg03, fp
	mov	arg01, fp
	sub	fp, #12
	rdlong	arg02, fp
	sub	fp, #4
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #12
 if_ne	jmp	#LR__4830
	add	fp, #59
	rdbyte	result1, fp
	sub	fp, #59
	test	result1, #160 wz
 if_ne	add	fp, #12
 if_ne	wrlong	#6, fp
 if_ne	sub	fp, #12
LR__4830
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__4842
	add	fp, #116
	mov	arg01, fp
	sub	fp, #72
	rdlong	arg02, fp
	sub	fp, #44
	mov	arg03, #32
	call	#__system____builtin_memmove
	add	fp, #64
	mov	arg01, fp
	sub	fp, #48
	mov	arg02, fp
	sub	fp, #16
	mov	arg03, #48
	call	#__system____builtin_memmove
	add	fp, #64
	mov	arg01, fp
	sub	fp, #56
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_follow_path
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4833
	add	fp, #72
	rdlong	result1, fp
	sub	fp, #48
	rdlong	arg03, fp
	sub	fp, #24
	cmp	result1, arg03 wz
 if_ne	jmp	#LR__4831
	add	fp, #80
	rdlong	result1, fp
	sub	fp, #48
	rdlong	arg03, fp
	sub	fp, #32
	cmp	result1, arg03 wz
 if_e	mov	local01, #4
 if_e	jmp	#LR__4832
LR__4831
	mov	local01, #8
LR__4832
	add	fp, #12
	wrlong	local01, fp
	sub	fp, #12
LR__4833
	add	fp, #12
	rdlong	local01, fp
	sub	fp, #12
	cmp	local01, #4 wz
 if_ne	jmp	#LR__4839
	add	fp, #64
	mov	arg01, fp
	sub	fp, #64
	call	#_fatfs_cc_dir_register
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4838
	add	fp, #92
	rdlong	arg01, fp
	add	fp, #56
	wrlong	arg01, fp
	add	arg01, #13
	sub	fp, #32
	mov	arg02, fp
	sub	fp, #116
	add	arg02, #13
	mov	arg03, #19
	call	#__system____builtin_memmove
	add	fp, #148
	rdlong	local01, fp
	sub	fp, #21
	rdbyte	result1, fp
	add	local01, #11
	wrbyte	result1, local01
	add	fp, #21
	rdlong	local01, fp
	sub	fp, #148
	add	local01, #11
	rdbyte	local01, local01
	test	local01, #16 wz
 if_ne	jmp	#LR__4834
	add	fp, #148
	rdlong	result1, fp
	mov	local01, result1
	sub	fp, #148
	add	result1, #11
	rdbyte	result1, result1
	or	result1, #32
	add	local01, #11
	wrbyte	result1, local01
LR__4834
	add	fp, #112
	rdlong	local01, fp
	add	local01, #3
	wrbyte	#1, local01
	add	fp, #36
	rdlong	local01, fp
	sub	fp, #148
	add	local01, #11
	rdbyte	local01, local01
	test	local01, #16 wz
 if_e	jmp	#LR__4837
	add	fp, #24
	rdlong	arg03, fp
	add	fp, #48
	rdlong	local01, fp
	sub	fp, #72
	cmp	arg03, local01 wz
 if_e	jmp	#LR__4837
	add	fp, #112
	rdlong	arg01, fp
	mov	local01, arg01
	add	fp, #36
	rdlong	arg02, fp
	sub	fp, #148
	call	#_fatfs_cc_ld_clust
	mov	arg02, result1
	mov	arg01, local01
	call	#_fatfs_cc_clst2sect
	add	fp, #152
	wrlong	result1, fp
	cmps	result1, #0 wz
	sub	fp, #152
 if_e	add	fp, #12
 if_e	wrlong	#2, fp
 if_e	sub	fp, #12
 if_e	jmp	#LR__4836
	add	fp, #112
	rdlong	arg01, fp
	add	fp, #40
	rdlong	arg02, fp
	sub	fp, #152
	call	#_fatfs_cc_move_window
	add	fp, #12
	wrlong	result1, fp
	add	fp, #100
	rdlong	local01, fp
	add	local01, #84
	add	fp, #36
	wrlong	local01, fp
	sub	fp, #136
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__4835
	add	fp, #148
	rdlong	local01, fp
	sub	fp, #148
	add	local01, #1
	rdbyte	local01, local01
	cmp	local01, #46 wz
 if_ne	jmp	#LR__4835
	add	fp, #112
	rdlong	arg01, fp
	add	fp, #36
	rdlong	arg02, fp
	sub	fp, #76
	rdlong	arg03, fp
	sub	fp, #72
	call	#_fatfs_cc_st_clust
	add	fp, #112
	rdlong	local01, fp
	sub	fp, #112
	add	local01, #3
	wrbyte	#1, local01
LR__4835
LR__4836
LR__4837
LR__4838
LR__4839
	add	fp, #12
	rdlong	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__4841
	add	fp, #16
	mov	arg01, fp
	sub	fp, #16
	call	#_fatfs_cc_dir_remove
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	cmp	result1, #0 wz
 if_ne	jmp	#LR__4840
	add	fp, #112
	rdlong	arg01, fp
	sub	fp, #112
	call	#_fatfs_cc_sync_fs
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__4840
LR__4841
LR__4842
LR__4843
' 					res = sync_fs(fs);
' 				}
' 			}
' 
' 		}
' 		;
' 	}
' 
' 	return res ;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_f_rename_ret
	ret

_fatfs_cc_time
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	mov	arg01, fp
	sub	fp, #8
	mov	arg02, #0
	call	#_fatfs_cc_gettimeofday
	add	fp, #8
	rdlong	result1, fp
	add	fp, #8
	wrlong	result1, fp
	sub	fp, #12
	rdlong	result1, fp wz
	sub	fp, #4
 if_e	jmp	#LR__4850
	add	fp, #4
	rdlong	result1, fp
	add	fp, #12
	rdlong	arg02, fp
	sub	fp, #16
	wrlong	arg02, result1
LR__4850
'         *tp = now;
'     return now;
	add	fp, #16
	rdlong	result1, fp
	sub	fp, #16
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_time_ret
	ret

_fatfs_cc_mktime
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	add	local01, #20
	rdlong	arg01, local01
	sub	local01, #20
	cmps	arg01, #70 wc
'                 return (time_t) -1;
 if_b	neg	result1, #1
 if_b	jmp	#LR__4864
	mov	local02, ##1900
	add	local01, #20
	rdlong	result1, local01
	add	local02, result1
	sub	local01, #8
	rdlong	local03, local01
	sub	local03, #1
	add	local01, #4
	rdlong	arg01, local01
	sub	local01, #16
	shl	arg01, #2
	add	ptr__fatfs_cc_dat__, ##1224
	add	arg01, ptr__fatfs_cc_dat__
	rdlong	result1, arg01
	add	local03, result1
	mov	arg01, local02
	sub	ptr__fatfs_cc_dat__, ##1224
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_e	jmp	#LR__4860
	mov	local04, #0
	add	local01, #16
	rdlong	result1, local01
	sub	local01, #16
	cmps	result1, #2 wc
 if_ae	mov	local04, #1
	jmp	#LR__4861
LR__4860
	mov	local04, #0
LR__4861
	add	local01, #4
	rdlong	result1, local01
	sub	local01, #4
	rdlong	local05, local01
	add	local01, #8
	rdlong	arg01, local01
	qmul	arg01, ##3600
	add	local03, local04
	mov	local04, result1
	shl	local04, #4
	sub	local04, result1
	shl	local04, #2
	add	local05, local04
	sub	local01, #8
	getqx	local04
	qmul	local03, ##86400
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1970
	getqx	local04
	qmul	local03, ##31536000
	add	local05, local04
	mov	local03, local02
	sub	local03, ##1969
	abs	local06, local03 wc
	shr	local06, #2
	negc	local06, local06
	cmps	local02, ##2001 wc
	getqx	local04
	add	local05, local04
 if_b	jmp	#LR__4862
	sub	local02, ##2000
	abs	local04, local02 wc
	qdiv	local04, #100
	getqx	local04
	sumnc	local06, local04
LR__4862
	qmul	local06, ##86400
	getqx	local06
	add	local05, local06
	call	#_fatfs_cc__tzset
	add	ptr__fatfs_cc_dat__, ##1172
	rdlong	local06, ptr__fatfs_cc_dat__
	add	local05, local06
	add	ptr__fatfs_cc_dat__, #104
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1276
	cmp	local03, #1 wz
 if_ne	jmp	#LR__4863
	mov	arg01, local01
	call	#_fatfs_cc___indst
	cmp	result1, #0 wz
 if_ne	sub	local05, ##3600
LR__4863
'                 s -=  (3600L) ;
' 
'         return s;
	mov	result1, local05
LR__4864
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_mktime_ret
	ret

_fatfs_cc__gmtime_r
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, arg01
	qdiv	local01, ##86400
	getqx	result1
	add	result1, #4
	qdiv	result1, #7
	add	arg02, #24
	cmp	local01, ##1325376000 wc
 if_ae	sub	local01, ##1325376000
 if_ae	mov	local02, ##2012
 if_b	mov	local02, ##1970
' 	  year = 1970;
' 	}
' 
' 	for(;;) {
	getqy	result1
	wrlong	result1, arg02
	sub	arg02, #24
LR__4870
	mov	arg01, local02
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, ##31622400
 if_e	mov	local03, ##31536000
	cmp	local01, local03 wc
' 	    break;
 if_ae	add	local02, #1
 if_ae	sub	local01, local03
 if_ae	jmp	#LR__4870
	qdiv	local01, ##86400
	mov	local03, local02
	sub	local03, ##1900
	add	arg02, #20
	wrlong	local03, arg02
	add	arg02, #8
	mov	arg01, local02
	getqx	local02
	wrlong	local02, arg02
	sub	arg02, #28
	call	#_fatfs_cc__is_leap_year
	cmp	result1, #0 wz
 if_ne	mov	local03, #29
 if_e	mov	local03, #28
	add	ptr__fatfs_cc_dat__, ##1180
	wrlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1180
' 
'         days_per_mth[1] = _is_leap_year(year) ? 29 : 28;
'         for (i = 0; mday >= days_per_mth[i]; i++)
	mov	arg01, #0
	callpa	#(@LR__4872-@LR__4871)>>2,fcache_load_ptr_
LR__4871
	mov	local03, arg01
	shl	local03, #2
	add	ptr__fatfs_cc_dat__, ##1176
	add	local03, ptr__fatfs_cc_dat__
	rdlong	local03, local03
	cmps	local02, local03 wc
	sub	ptr__fatfs_cc_dat__, ##1176
 if_b	jmp	#LR__4873
	mov	local03, arg01
	shl	local03, #2
	add	ptr__fatfs_cc_dat__, ##1176
	add	local03, ptr__fatfs_cc_dat__
	rdlong	local03, local03
	sub	local02, local03
	add	arg01, #1
	sub	ptr__fatfs_cc_dat__, ##1176
	jmp	#LR__4871
LR__4872
LR__4873
	qdiv	local01, ##86400
	add	arg02, #16
	wrlong	arg01, arg02
	add	local02, #1
	sub	arg02, #4
	wrlong	local02, arg02
	getqy	local01
	qdiv	local01, ##3600
	getqx	local03
	qdiv	local01, ##3600
	sub	arg02, #4
	wrlong	local03, arg02
	getqy	local01
	qdiv	local01, #60
	getqx	local03
	qdiv	local01, #60
	sub	arg02, #4
	wrlong	local03, arg02
	sub	arg02, #4
'         stm->tm_isdst = 0;
' 
' ;
'         return stm;
	mov	result1, arg02
	getqy	local03
	wrlong	local03, arg02
	add	arg02, #32
	wrlong	#0, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__gmtime_r_ret
	ret

_fatfs_cc__tzset
	mov	arg01, ##@LR__5185
	call	#_fatfs_cc_getenv
	mov	arg01, result1
	add	ptr__fatfs_cc_dat__, ##1276
	mov	arg02, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1276
	call	#_fatfs_cc___tzoffset
	add	ptr__fatfs_cc_dat__, ##1172
	wrlong	result1, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1172
_fatfs_cc__tzset_ret
	ret

_fatfs_cc_getenv
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg01
	callpa	#(@LR__4881-@LR__4880)>>2,fcache_load_ptr_
LR__4880
	rdbyte	result1, local02 wz
 if_ne	add	local02, #1
 if_ne	jmp	#LR__4880
LR__4881
	sub	local02, arg01
	mov	result1, local02
	add	ptr__fatfs_cc_dat__, ##1356
	rdlong	arg03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1356
'             return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__4884
' 
' 	for (var = _environ_ptr; (name = *var) != 0; var++) {
	add	ptr__fatfs_cc_dat__, ##1356
	rdlong	local03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1356
LR__4882
	rdlong	local04, local03 wz
 if_e	jmp	#LR__4883
	mov	arg01, local04
	mov	arg02, local01
	mov	arg03, local02
	call	#_fatfs_cc_strncmp
	cmp	result1, #0 wz
 if_e	mov	local05, local02
 if_e	add	local05, local04
 if_e	rdbyte	local06, local05
 if_e	cmp	local06, #61 wz
' 			return name+len+1;
 if_e	add	local04, local02
 if_e	add	local04, #1
 if_e	mov	result1, local04
 if_e	jmp	#LR__4884
	add	local03, #4
	jmp	#LR__4882
LR__4883
' 	}
' 	return 0;
	mov	result1, #0
LR__4884
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_getenv_ret
	ret

_fatfs_cc__get_fattime
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #52
	mov	arg01, #0
	call	#_fatfs_cc_time
	add	fp, #4
	wrlong	result1, fp
	mov	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc__gmtime_r
	add	fp, #36
	rdlong	arg02, fp
	sub	arg02, #80
	shl	arg02, #9
	sub	fp, #4
	rdlong	result1, fp
	add	result1, #1
	shl	result1, #5
	or	arg02, result1
	sub	fp, #4
	rdlong	result1, fp
	or	arg02, result1
	sub	fp, #20
	wrlong	arg02, fp
	add	fp, #16
	rdlong	arg02, fp
	shl	arg02, #11
	sub	fp, #4
	rdlong	result1, fp
	shl	result1, #5
	or	arg02, result1
	sub	fp, #4
	rdlong	result1, fp
	or	arg02, result1
	sub	fp, #4
	wrlong	arg02, fp
' 
'     now = time(0);
'     _gmtime_r (&now, &date);
'     ffdate = ((date.tm_year - 80) << 9) | ((date.tm_mon + 1) << 5) | ((date.tm_mday));
'     fftime = (date.tm_hour << 11) | (date.tm_min << 5) | (date.tm_sec);
'     return (ffdate << 16) | fftime;
	sub	fp, #4
	rdlong	result1, fp
	shl	result1, #16
	sub	fp, #8
	or	result1, arg02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc__get_fattime_ret
	ret

_fatfs_cc_unixtime_0984
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #52
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg02, fp
	shr	arg02, #9
	and	arg02, #127
	mov	result1, #80
	add	result1, arg02
	add	fp, #32
	wrlong	result1, fp
	sub	fp, #32
	rdlong	result1, fp
	shr	result1, #5
	getnib	result1, result1, #0
	sub	result1, #1
	add	fp, #28
	wrlong	result1, fp
	sub	fp, #28
	rdlong	result1, fp
	and	result1, #31
	add	fp, #24
	wrlong	result1, fp
	sub	fp, #20
	rdlong	result1, fp
	shr	result1, #11
	and	result1, #31
	add	fp, #16
	wrlong	result1, fp
	sub	fp, #16
	rdlong	result1, fp
	shr	result1, #5
	and	result1, #63
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
	rdlong	arg02, fp
	and	arg02, #31
	shl	arg02, #1
	add	fp, #8
	wrlong	arg02, fp
	mov	arg01, fp
	sub	fp, #16
	call	#_fatfs_cc_mktime
	add	fp, #12
	wrlong	result1, fp
' 
'     date.tm_year = 80 + ((dosdate >> 9) & 0x7f);
'     date.tm_mon = ((dosdate >> 5) & 0xf) - 1;
'     date.tm_mday = (dosdate & 0x1f);
'     date.tm_hour = (dostime >> 11) & 0x1f;
'     date.tm_min = (dostime >> 5) & 0x3f;
'     date.tm_sec = (dostime & 0x1f) << 1;
' 
'     t = mktime(&date);
' #line 60 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return t;
	sub	fp, #12
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_unixtime_0984_ret
	ret

_fatfs_cc__set_dos_error_0986
	mov	_var01, arg01
' #line 74 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     switch (derr) {
	fle	_var01, #20
	jmprel	_var01
LR__4890
	jmp	#LR__4891
	jmp	#LR__4905
	jmp	#LR__4906
	jmp	#LR__4907
	jmp	#LR__4892
	jmp	#LR__4893
	jmp	#LR__4894
	jmp	#LR__4895
	jmp	#LR__4897
	jmp	#LR__4900
	jmp	#LR__4896
	jmp	#LR__4901
	jmp	#LR__4902
	jmp	#LR__4903
	jmp	#LR__4908
	jmp	#LR__4908
	jmp	#LR__4908
	jmp	#LR__4898
	jmp	#LR__4904
	jmp	#LR__4899
	jmp	#LR__4908
LR__4891
	mov	_var02, #0
'         r = 0;
'         break;
	jmp	#LR__4909
LR__4892
LR__4893
LR__4894
	mov	_var02, #4
'         r =  4 ;
'         break;
	jmp	#LR__4909
LR__4895
LR__4896
	mov	_var02, #6
'         r =  6 ;
'         break;
	jmp	#LR__4909
LR__4897
	mov	_var02, #9
'         r =  9 ;
'         break;
	jmp	#LR__4909
LR__4898
	mov	_var02, #7
'         r =  7 ;
'         break;
	jmp	#LR__4909
LR__4899
LR__4900
LR__4901
LR__4902
LR__4903
	mov	_var02, #10
'         r =  10 ;
'         break;
	jmp	#LR__4909
LR__4904
	mov	_var02, #11
'         r =  11 ;
'         break;
	jmp	#LR__4909
LR__4905
LR__4906
LR__4907
LR__4908
	mov	_var02, #12
'         r =  12 ;
'         break;
LR__4909
'     }
'     return _seterror(r);
	cmps	_var02, #0 wz
	add	ptr___system__dat__, #32
	wrlong	_var02, ptr___system__dat__
	sub	ptr___system__dat__, #32
 if_ne	neg	result1, #1
 if_e	mov	result1, #0
_fatfs_cc__set_dos_error_0986_ret
	ret

_fatfs_cc_v_creat
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, ##1596
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4911
	mov	arg01, local03
	mov	arg02, #0
	mov	arg03, ##1596
	call	#\builtin_bytefill_
	add	local03, ##1044
	mov	arg01, local03
	sub	local03, ##1044
	mov	arg02, local02
	mov	arg03, #7
	call	#_fatfs_cc_f_open
	mov	local04, result1 wz
 if_e	jmp	#LR__4910
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_0986
	jmp	#LR__4911
LR__4910
	wrlong	local03, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__4911
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_creat_ret
	ret

_fatfs_cc_v_close
	mov	COUNT_, #2
	call	#pushregs_
	rdlong	local01, arg01
	add	local01, ##1044
	mov	arg01, local01
	sub	local01, ##1044
	call	#_fatfs_cc_f_close
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
'     FAT_FIL *f = fil->vfsdata;
'     r=f_close(&f->fil);
'     free(f);
'     return _set_dos_error(r);
	mov	arg01, local02
	call	#_fatfs_cc__set_dos_error_0986
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_close_ret
	ret

_fatfs_cc_v_opendir
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	arg01, #48
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local03, result1 wz
' #line 158 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/fatfs.cc"
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4921
	mov	arg02, local02
	mov	arg01, local03
	call	#_fatfs_cc_f_opendir
	mov	local04, result1 wz
 if_e	jmp	#LR__4920
	mov	arg01, local03
'     return _gc_free(ptr);
	call	#__system___gc_free
'         free(f);
'         return _set_dos_error(r);
	mov	arg01, local04
	call	#_fatfs_cc__set_dos_error_0986
	jmp	#LR__4921
LR__4920
	add	local01, #4
	wrlong	local03, local01
'     }
'     dir->vfsdata = f;
'     return 0;
	mov	result1, #0
LR__4921
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_opendir_ret
	ret

_fatfs_cc_v_closedir
	mov	COUNT_, #2
	call	#pushregs_
	add	arg01, #4
	rdlong	local01, arg01
	mov	arg01, local01
	call	#_fatfs_cc_f_closedir
	mov	local02, result1
	mov	arg01, local01
'     return _gc_free(ptr);
	call	#__system___gc_free
	cmp	local02, #0 wz
 if_ne	mov	arg01, local02
 if_ne	call	#_fatfs_cc__set_dos_error_0986
'     return r;
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_closedir_ret
	ret

_fatfs_cc_v_readdir
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #300
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdlong	arg03, fp
	add	arg03, #4
	rdlong	arg01, arg03
	add	fp, #8
	mov	arg02, fp
	sub	fp, #12
	call	#_fatfs_cc_f_readdir
	add	fp, #296
	wrlong	result1, fp
	sub	fp, #296
	cmp	result1, #0 wz
 if_e	jmp	#LR__4930
'         return _set_dos_error(r);
	add	fp, #296
	rdlong	arg01, fp
	sub	fp, #296
	call	#_fatfs_cc__set_dos_error_0986
	jmp	#LR__4933
LR__4930
	add	fp, #40
	rdbyte	arg03, fp wz
	sub	fp, #40
'         return -1;
 if_e	neg	result1, #1
 if_e	jmp	#LR__4933
	add	fp, #8
	rdlong	arg01, fp
	add	fp, #32
	mov	arg02, fp
	sub	fp, #40
	mov	arg03, #63
	call	#_fatfs_cc_strncpy
	add	fp, #8
	rdlong	arg03, fp
	add	arg03, #63
	wrbyte	#0, arg03
	add	fp, #12
	rdbyte	arg03, fp
	sub	fp, #20
	test	arg03, #16 wz
 if_e	jmp	#LR__4931
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	add	arg03, #80
	wrbyte	#1, arg03
	jmp	#LR__4932
LR__4931
	add	fp, #8
	rdlong	arg03, fp
	sub	fp, #8
	add	arg03, #80
	wrbyte	#0, arg03
LR__4932
	add	fp, #8
	rdlong	arg03, fp
	add	fp, #4
	rdlong	arg02, fp
	add	arg03, #72
	wrlong	arg02, arg03
	sub	fp, #4
	rdlong	local01, fp
	add	fp, #8
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #18
	call	#_fatfs_cc_unixtime_0984
	add	local01, #76
	wrlong	result1, local01
'         ent->d_type =  (0) ;
'     }
'     ent->d_size = finfo.fsize;
'     ent->d_mtime = unixtime(finfo.fdate, finfo.ftime);
'     return 0;
	mov	result1, #0
LR__4933
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_readdir_ret
	ret

_fatfs_cc_v_stat
	mov	COUNT_, #3
	call	#pushregs_
	add	ptra, #304
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #8
	mov	arg01, arg02
	mov	arg02, #0
	mov	arg03, #48
	call	#\builtin_bytefill_
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	rdbyte	result1, result1 wz
 if_e	jmp	#LR__4940
	add	fp, #4
	rdlong	result1, fp
	sub	fp, #4
	rdbyte	result1, result1
	cmp	result1, #46 wz
 if_e	add	fp, #4
 if_e	rdlong	local01, fp
 if_e	sub	fp, #4
 if_e	add	local01, #1
 if_e	rdbyte	local02, local01 wz
 if_ne	jmp	#LR__4941
LR__4940
	add	fp, #24
	wrbyte	#16, fp
	sub	fp, #12
	wrlong	#0, fp
	sub	fp, #12
	jmp	#LR__4942
LR__4941
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #12
	mov	arg02, fp
	sub	fp, #16
	call	#_fatfs_cc_f_stat
	add	fp, #12
	wrlong	result1, fp
	sub	fp, #12
LR__4942
	add	fp, #12
	rdlong	local02, fp wz
	sub	fp, #12
 if_e	jmp	#LR__4943
'         return _set_dos_error(r);
	add	fp, #12
	rdlong	arg01, fp
	sub	fp, #12
	call	#_fatfs_cc__set_dos_error_0986
	jmp	#LR__4944
LR__4943
	add	fp, #300
	wrlong	#292, fp
	sub	fp, #276
	rdbyte	local03, fp
	sub	fp, #24
	test	local03, #1 wz
 if_e	add	fp, #300
 if_e	rdlong	local03, fp
 if_e	or	local03, #146
 if_e	wrlong	local03, fp
 if_e	sub	fp, #300
	add	fp, #24
	rdbyte	local03, fp
	sub	fp, #24
	test	local03, #16 wz
 if_ne	add	fp, #300
 if_ne	rdlong	local03, fp
 if_ne	or	local03, ##4169
 if_ne	wrlong	local03, fp
 if_ne	sub	fp, #300
	add	fp, #8
	rdlong	local03, fp
	add	fp, #292
	rdlong	local02, fp
	add	local03, #8
	wrlong	local02, local03
	sub	fp, #292
	rdlong	local03, fp
	add	local03, #12
	wrlong	#1, local03
	rdlong	local03, fp
	add	fp, #8
	rdlong	local02, fp
	add	local03, #24
	wrlong	local02, local03
	sub	fp, #8
	rdlong	local03, fp
	add	local03, #28
	wrlong	##512, local03
	rdlong	local02, fp
	mov	local03, local02
	add	local02, #24
	rdlong	local02, local02
	add	local02, #511
	abs	local02, local02 wc
	shr	local02, #9
	negc	local02, local02
	add	local03, #32
	wrlong	local02, local03
	rdlong	local02, fp
	mov	local03, local02
	mov	local01, local02
	add	fp, #12
	rdword	arg01, fp
	add	fp, #2
	rdword	arg02, fp
	sub	fp, #22
	call	#_fatfs_cc_unixtime_0984
	add	local01, #44
	wrlong	result1, local01
	add	local02, #40
	wrlong	result1, local02
	add	local03, #36
	wrlong	result1, local03
'         mode |=  0010000  |  0100  |  0010  |  0001 ;
'     }
'     buf->st_mode = mode;
'     buf->st_nlink = 1;
'     buf->st_size = finfo.fsize;
'     buf->st_blksize = 512;
'     buf->st_blocks = (buf->st_size + 511) / 512;
'     buf->st_atime = buf->st_mtime = buf->st_ctime = unixtime(finfo.fdate, finfo.ftime);
' #line 249 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return r;
	add	fp, #12
	rdlong	result1, fp
	sub	fp, #12
LR__4944
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_stat_ret
	ret

_fatfs_cc_v_read
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #28
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	rdlong	arg01, arg01 wz
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #16
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4952
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, ##1044
	sub	fp, #8
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #12
	mov	arg04, fp
	sub	fp, #24
	call	#_fatfs_cc_f_read
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmp	result1, #0 wz
 if_e	jmp	#LR__4950
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	add	arg04, #8
	rdlong	arg04, arg04
	or	arg04, #32
	add	arg03, #8
	wrlong	arg04, arg03
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	call	#_fatfs_cc__set_dos_error_0986
	jmp	#LR__4952
LR__4950
	add	fp, #24
	rdlong	result1, fp wz
	sub	fp, #24
 if_ne	jmp	#LR__4951
	add	fp, #4
	rdlong	result1, fp
	mov	arg04, result1
	sub	fp, #4
	add	result1, #8
	rdlong	result1, result1
	or	result1, #16
	add	arg04, #8
	wrlong	result1, arg04
LR__4951
'         fil->state |=  (0x10) ;
'     }
'     return x;
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #24
LR__4952
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_read_ret
	ret

_fatfs_cc_v_write
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #28
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	rdlong	arg01, arg01 wz
	add	fp, #12
	wrlong	arg01, fp
	sub	fp, #16
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4961
	add	fp, #16
	rdlong	arg01, fp
	add	arg01, ##1044
	sub	fp, #8
	rdlong	arg02, fp
	add	fp, #4
	rdlong	arg03, fp
	add	fp, #12
	mov	arg04, fp
	sub	fp, #24
	call	#_fatfs_cc_f_write
	add	fp, #20
	wrlong	result1, fp
	sub	fp, #20
	cmp	result1, #0 wz
 if_e	jmp	#LR__4960
	add	fp, #4
	rdlong	arg04, fp
	mov	arg03, arg04
	add	arg04, #8
	rdlong	arg04, arg04
	or	arg04, #32
	add	arg03, #8
	wrlong	arg04, arg03
'         fil->state |=  (0x20) ;
'         return _set_dos_error(r);
	add	fp, #16
	rdlong	arg01, fp
	sub	fp, #20
	call	#_fatfs_cc__set_dos_error_0986
	jmp	#LR__4961
LR__4960
'     }
'     return x;
	add	fp, #24
	rdlong	result1, fp
	sub	fp, #24
LR__4961
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_write_ret
	ret

_fatfs_cc_v_lseek
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	rdlong	local03, arg01
	add	local03, ##1044 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4972
	cmp	local02, #0 wz
 if_e	jmp	#LR__4970
	cmp	local02, #1 wz
 if_e	add	local03, #20
 if_e	rdlong	local04, local03
 if_e	sub	local03, #20
 if_e	add	local01, local04
 if_ne	add	local03, #12
 if_ne	rdlong	local04, local03
 if_ne	sub	local03, #12
 if_ne	add	local01, local04
LR__4970
	mov	arg02, local01
	mov	arg01, local03
	call	#_fatfs_cc_f_lseek
	mov	arg01, result1 wz
 if_e	jmp	#LR__4971
'         return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_0986
	jmp	#LR__4972
LR__4971
'     }
'     return offset;
	mov	result1, local01
LR__4972
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_lseek_ret
	ret

_fatfs_cc_v_ioctl
' {
'     return _seterror( 10 );
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
_fatfs_cc_v_ioctl_ret
	ret

_fatfs_cc_v_mkdir
	call	#_fatfs_cc_f_mkdir
	mov	arg01, result1
' 
'     r = f_mkdir(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0986
_fatfs_cc_v_mkdir_ret
	ret

_fatfs_cc_v_remove
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0986
_fatfs_cc_v_remove_ret
	ret

_fatfs_cc_v_rmdir
	call	#_fatfs_cc_f_unlink
	mov	arg01, result1
' 
'     r = f_unlink(name);
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0986
_fatfs_cc_v_rmdir_ret
	ret

_fatfs_cc_v_rename
	call	#_fatfs_cc_f_rename
	mov	arg01, result1
'     return _set_dos_error(r);
	call	#_fatfs_cc__set_dos_error_0986
_fatfs_cc_v_rename_ret
	ret

_fatfs_cc_v_open
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	arg01, ##1596
'     return _gc_alloc(size);
	mov	arg02, #16
	call	#__system___gc_doalloc
	mov	local04, result1 wz
'       return _seterror( 7 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#7, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4986
	mov	arg01, local04
	mov	arg02, #0
	mov	arg03, ##1596
	call	#\builtin_bytefill_
'   switch (flags & 3) {
	mov	local05, local03
	and	local05, #3 wz
 if_e	jmp	#LR__4980
	cmp	local05, #1 wz
 if_e	jmp	#LR__4981
	jmp	#LR__4982
LR__4980
	mov	local06, #1
'       fs_flags =  0x01 ;
'       break;
	jmp	#LR__4983
LR__4981
	mov	local06, #2
'       fs_flags =  0x02 ;
'       break;
	jmp	#LR__4983
LR__4982
	mov	local06, #3
'       fs_flags =  0x01  |  0x02 ;
'       break;
LR__4983
	test	local03, #8 wz
 if_ne	or	local06, #24
 if_ne	jmp	#LR__4984
	test	local03, #32 wz
 if_ne	or	local06, #48
LR__4984
	add	local04, ##1044
	mov	arg01, local04
	sub	local04, ##1044
	mov	arg02, local02
	mov	arg03, local06
	call	#_fatfs_cc_f_open
	mov	local07, result1 wz
 if_e	jmp	#LR__4985
	mov	arg01, local04
'     return _gc_free(ptr);
	call	#__system___gc_free
'     free(f);
' #line 417 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(r);
	mov	arg01, local07
	call	#_fatfs_cc__set_dos_error_0986
	jmp	#LR__4986
LR__4985
	wrlong	local04, local01
'   }
'   fil->vfsdata = f;
'   return 0;
	mov	result1, #0
LR__4986
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_v_open_ret
	ret

_fatfs_cc_v_flush
	rdlong	arg01, arg01
	add	arg01, ##1044 wz
'         return _seterror( 5 );
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__4990
	call	#_fatfs_cc_f_sync
	mov	arg01, result1
'     }
' #line 437 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     result = f_sync(f);
' #line 441 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     return _set_dos_error(result);
	call	#_fatfs_cc__set_dos_error_0986
LR__4990
_fatfs_cc_v_flush_ret
	ret

_fatfs_cc_v_init
' {
'     return 0;
	mov	result1, #0
_fatfs_cc_v_init_ret
	ret

_fatfs_cc_v_deinit
	mov	arg02, ##@LR__5186
	mov	arg01, #0
	mov	arg03, #0
	call	#_fatfs_cc_f_mount
	add	objptr, ##520
	rdlong	arg01, objptr
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##524
	call	#__system___freepins
' #line 462 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/fatfs.cc"
'     _freepins(f_pinmask);
'     return 0;
	mov	result1, #0
_fatfs_cc_v_deinit_ret
	ret

_fatfs_cc_get_vfs
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg01, #80
	call	#__system___gc_alloc_managed
	mov	arg01, result1
	mov	result1, objptr
	or	result1, ##171966464
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##173015040
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##174063616
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##175112192
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##176160768
	add	arg01, #4
	wrlong	result1, arg01
	add	arg01, #4
	wrlong	#0, arg01
	add	arg01, #4
	wrlong	local01, arg01
	add	arg01, #4
	wrlong	#0, arg01
	mov	result1, objptr
	or	result1, ##177209344
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##178257920
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##179306496
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##180355072
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##181403648
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##182452224
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##183500800
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##184549376
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##185597952
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##186646528
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##187695104
	add	arg01, #4
	wrlong	result1, arg01
	mov	result1, objptr
	or	result1, ##188743680
	add	arg01, #4
	wrlong	result1, arg01
	sub	arg01, #76
' 
'     v->close = &v_close;
'     v->read = &v_read;
'     v->write = &v_write;
'     v->lseek = &v_lseek;
'     v->ioctl = &v_ioctl;
'     v->flush = 0;
'     v->vfs_data = ptr;
'     v->reserved = 0;
' 
'     v->open = &v_open;
'     v->creat = &v_creat;
'     v->opendir = &v_opendir;
'     v->closedir = &v_closedir;
'     v->readdir = &v_readdir;
'     v->stat = &v_stat;
' 
'     v->mkdir = &v_mkdir;
'     v->rmdir = &v_rmdir;
' 
'     v->remove = &v_remove;
'     v->rename = &v_rename;
' 
'     v->init = &v_init;
'     v->deinit = &v_deinit;
' 
'     return v;
	mov	result1, arg01
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_get_vfs_ret
	ret

_fatfs_cc_xmit_mmc_1137
	add	objptr, ##528
	rdlong	_var01, objptr
	add	objptr, #8
	rdlong	_var02, objptr
	sub	objptr, ##536
	dirl	_var02
	setq	#1
	rdlong	_var03, arg01
	rev	_var03
	movbyts	_var03, #27
	wypin	_var03, _var02
	mov	_var03, arg02
	shr	arg02, #2 wz
	shl	_var03, #3
	wypin	_var03, _var01
	dirh	_var02
	add	arg01, #8
	rev	_var04
	movbyts	_var04, #27
LR__5000
 if_ne	wypin	_var04, _var02
 if_ne	rdlong	_var04, arg01
 if_ne	add	arg01, #4
 if_ne	rev	_var04
 if_ne	movbyts	_var04, #27
LR__5001
 if_ne	testp	_var02 wc
 if_a	jmp	#LR__5001
 if_ne	djnz	arg02, #LR__5000
LR__5002
	testp	_var01 wc
 if_ae	jmp	#LR__5002
	dirl	_var02
	wypin	##-1, _var02
	dirh	_var02
_fatfs_cc_xmit_mmc_1137_ret
	ret

_fatfs_cc_rcvr_mmc_1144
	add	objptr, ##528
	rdlong	_var01, objptr
	add	objptr, #12
	rdlong	_var02, objptr
	sub	objptr, ##540
	akpin	_var02
	mov	_var03, arg02 wz
	shr	_var03, #2 wz
 if_e	jmp	#LR__5012
	mov	_var04, _var03
	shl	_var04, #5
	wypin	_var04, _var01
	wxpin	#63, _var02
LR__5010
LR__5011
	testp	_var02 wc
 if_ae	jmp	#LR__5011
	rdpin	_var04, _var02
	rev	_var04
	movbyts	_var04, #27
	wrlong	_var04, arg01
	add	arg01, #4
	djnz	_var03, #LR__5010
LR__5012
	and	arg02, #3 wz
 if_e	jmp	#LR__5015
	wxpin	#39, _var02
LR__5013
	wypin	#8, _var01
LR__5014
	testp	_var02 wc
 if_ae	jmp	#LR__5014
	rdpin	_var04, _var02
	rev	_var04
	wrbyte	_var04, arg01
	add	arg01, #1
	djnz	arg02, #LR__5013
LR__5015
_fatfs_cc_rcvr_mmc_1144_ret
	ret

_fatfs_cc_wait_ready_1148
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #16
	getct	result1
	add	fp, #8
	wrlong	result1, fp
	rdlong	local01, #20
	shr	local01, #1
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #12
' {
' 	BYTE d;
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 1;
' 	for(;;) {
LR__5020
	add	fp, #4
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #4
	rdbyte	local01, fp
	sub	fp, #4
	cmp	local01, #255 wz
 if_e	mov	result1, #1
 if_e	jmp	#LR__5021
	getct	result1
	add	fp, #8
	rdlong	local01, fp
	sub	result1, local01
	add	fp, #4
	rdlong	local01, fp
	sub	fp, #12
	cmp	result1, local01 wc
 if_ae	mov	result1, #0
 if_b	jmp	#LR__5020
LR__5021
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_wait_ready_1148_ret
	ret

_fatfs_cc_deselect_1154
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #20
	add	objptr, ##532
	rdlong	arg02, objptr
	add	fp, #4
	wrlong	arg02, fp
	sub	objptr, #4
	rdlong	arg02, objptr
	add	fp, #4
	wrlong	arg02, fp
	add	objptr, #8
	rdlong	arg02, objptr
	add	fp, #4
	wrlong	arg02, fp
	add	objptr, #4
	rdlong	arg02, objptr
	sub	objptr, ##540
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #12
	rdlong	arg01, fp
	sub	fp, #4
	drvh	arg01
	waitx	#16
	mov	arg01, fp
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1144
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_deselect_1154_ret
	ret

_fatfs_cc_select_1158
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	objptr, ##532
	rdlong	arg02, objptr
	add	fp, #8
	wrlong	arg02, fp
	add	objptr, #8
	rdlong	arg01, objptr
	sub	objptr, ##540
	add	fp, #4
	wrlong	arg01, fp
	fltl	arg01
	sub	fp, #4
	rdlong	arg01, fp
	drvl	arg01
	waitx	#16
	add	fp, #4
	rdlong	arg01, fp
	dirh	arg01
	sub	fp, #8
	mov	arg01, fp
	sub	fp, #4
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1144
	call	#_fatfs_cc_wait_ready_1148
	cmp	result1, #0 wz
 if_ne	mov	result1, #1
 if_ne	jmp	#LR__5030
	call	#_fatfs_cc_deselect_1154
' 
' 	deselect();
' 	return 0;
	mov	result1, #0
LR__5030
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_select_1158_ret
	ret

_fatfs_cc_rcvr_datablock_1162
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #24
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	getct	result1
	add	fp, #8
	wrlong	result1, fp
	rdlong	local01, #20
	shr	local01, #3
	add	fp, #4
	wrlong	local01, fp
	sub	fp, #20
' 	BYTE *buff,
' 	UINT btr
' )
' {
' 	BYTE d[2];
' 	UINT tmr, tmout;
' 
' 	tmr = _cnt();
' 	tmout =  (*(uint32_t *)0x14)  >> 3;
' 	for(;;) {
LR__5040
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	cmp	local01, #255 wz
 if_ne	jmp	#LR__5041
	getct	result1
	mov	local01, result1
	add	fp, #16
	rdlong	arg02, fp
	sub	local01, arg02
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #20
	cmp	local01, arg02 wc
 if_b	jmp	#LR__5040
LR__5041
	add	fp, #12
	rdbyte	local01, fp
	sub	fp, #12
	cmp	local01, #254 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__5042
	add	fp, #4
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #2
	call	#_fatfs_cc_rcvr_mmc_1144
' 
' 	rcvr_mmc(buff, btr);
' 	rcvr_mmc(d, 2);
' 
' 	return 1;
	mov	result1, #1
LR__5042
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_rcvr_datablock_1162_ret
	ret

_fatfs_cc_xmit_datablock_1164
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrbyte	arg02, fp
	sub	fp, #8
	call	#_fatfs_cc_wait_ready_1148
	cmp	result1, #0 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__5051
	add	fp, #8
	rdbyte	arg02, fp
	add	fp, #4
	wrbyte	arg02, fp
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #1
	call	#_fatfs_cc_xmit_mmc_1137
	add	fp, #8
	rdbyte	arg02, fp
	sub	fp, #8
	cmp	arg02, #253 wz
 if_e	jmp	#LR__5050
	add	fp, #4
	rdlong	arg01, fp
	sub	fp, #4
	decod	arg02, #9
	call	#_fatfs_cc_xmit_mmc_1137
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #2
	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #12
	mov	arg01, fp
	sub	fp, #12
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #12
	rdbyte	arg02, fp
	sub	fp, #12
	and	arg02, #31
	cmp	arg02, #5 wz
' 			return 0;
 if_ne	mov	result1, #0
 if_ne	jmp	#LR__5051
LR__5050
' 	}
' 
' 	return 1;
	mov	result1, #1
LR__5051
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_xmit_datablock_1164_ret
	ret

_fatfs_cc_send_cmd_1168
	mov	COUNT_, #1
	call	#pushregs_
	add	ptra, #28
_fatfs_cc_send_cmd_1168_enter
	add	fp, #4
	wrbyte	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	sub	fp, #4
	rdbyte	result1, fp
	sub	fp, #4
	test	result1, #128 wz
 if_e	jmp	#LR__5060
	add	fp, #4
	rdbyte	arg02, fp
	and	arg02, #127
	wrbyte	arg02, fp
	sub	fp, #4
	mov	arg01, #55
	mov	arg02, #0
	call	#_fatfs_cc_send_cmd_1168
	add	fp, #12
	wrbyte	result1, fp
	rdbyte	arg02, fp
	sub	fp, #12
	cmp	arg02, #2 wc
 if_ae	add	fp, #12
 if_ae	rdbyte	result1, fp
 if_ae	sub	fp, #12
 if_ae	jmp	#LR__5064
LR__5060
	add	fp, #4
	rdbyte	arg02, fp
	sub	fp, #4
	cmp	arg02, #12 wz
 if_e	jmp	#LR__5061
	call	#_fatfs_cc_deselect_1154
	call	#_fatfs_cc_select_1158
	cmp	result1, #0 wz
 if_e	mov	result1, #255
 if_e	jmp	#LR__5064
LR__5061
	add	fp, #4
	rdbyte	arg02, fp
	mov	result1, #64
	or	result1, arg02
	add	fp, #16
	wrbyte	result1, fp
	sub	fp, #12
	rdlong	result1, fp
	shr	result1, #24
	add	fp, #13
	wrbyte	result1, fp
	sub	fp, #13
	rdlong	result1, fp
	shr	result1, #16
	add	fp, #14
	wrbyte	result1, fp
	sub	fp, #14
	rdlong	result1, fp
	shr	result1, #8
	add	fp, #15
	wrbyte	result1, fp
	sub	fp, #15
	rdlong	result1, fp
	add	fp, #16
	wrbyte	result1, fp
	sub	fp, #12
	wrbyte	#1, fp
	sub	fp, #8
	rdbyte	result1, fp wz
	sub	fp, #4
 if_e	add	fp, #12
 if_e	wrbyte	#149, fp
 if_e	sub	fp, #12
	add	fp, #4
	rdbyte	result1, fp
	sub	fp, #4
	cmp	result1, #8 wz
 if_e	add	fp, #12
 if_e	wrbyte	#135, fp
 if_e	sub	fp, #12
	add	fp, #12
	rdbyte	arg02, fp
	add	fp, #13
	wrbyte	arg02, fp
	sub	fp, #5
	mov	arg01, fp
	sub	fp, #20
	mov	arg02, #6
	call	#_fatfs_cc_xmit_mmc_1137
	add	fp, #4
	rdbyte	local01, fp
	sub	fp, #4
	cmp	local01, #12 wz
 if_e	add	fp, #16
 if_e	mov	arg01, fp
 if_e	sub	fp, #16
 if_e	mov	arg02, #1
 if_e	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #12
	wrbyte	#10, fp
	sub	fp, #12
' 	n = 10;
' 	do
LR__5062
	add	fp, #16
	mov	arg01, fp
	sub	fp, #16
	mov	arg02, #1
	call	#_fatfs_cc_rcvr_mmc_1144
	add	fp, #16
	rdbyte	local01, fp
	sub	fp, #16
	test	local01, #128 wz
 if_e	jmp	#LR__5063
	add	fp, #12
	rdbyte	local01, fp
	sub	local01, #1
	wrbyte	local01, fp
	rdbyte	local01, fp wz
	sub	fp, #12
 if_ne	jmp	#LR__5062
LR__5063
' 
' 	return d;
	add	fp, #16
	rdbyte	result1, fp
	sub	fp, #16
LR__5064
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_send_cmd_1168_ret
	ret

_fatfs_cc_disk_deinitialize
	mov	COUNT_, #3
	call	#pushregs_
	cmps	arg01, #0 wz
	add	objptr, ##532
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	local01, objptr
	add	objptr, #8
	rdlong	local02, objptr
	add	objptr, #4
	rdlong	local03, objptr
	sub	objptr, ##540
' #line 799 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/sdmm.cc"
'         return RES_NOTRDY;
 if_ne	mov	result1, #3
 if_ne	jmp	#LR__5070
	fltl	arg01
	wrpin	#0, arg01
	fltl	local01
	wrpin	#0, local01
	fltl	local02
	wrpin	#0, local02
	fltl	local03
	wrpin	#0, local03
	mov	arg01, #10
	call	#__system___waitms
'     }
' #line 805 "C:/Users/Piotr/Downloads/flexprop-6.4.0/flexprop/include/filesys/fatfs/sdmm.cc"
'     _pinclear(PIN_SS);
'     _pinclear(PIN_CLK);
'     _pinclear(PIN_DI);
'     _pinclear(PIN_DO);
' 
'     _waitms(10);
' 
'     return 0;
	mov	result1, #0
LR__5070
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_disk_deinitialize_ret
	ret

_fatfs_cc_gettimeofday
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	call	#__system___getus
	mov	arg01, result1
	add	ptr__fatfs_cc_dat__, ##1368
	rdlong	local02, ptr__fatfs_cc_dat__
	mov	result1, arg01
	sub	result1, local02
	qdiv	result1, ##1000000
	sub	ptr__fatfs_cc_dat__, ##1368
	getqx	local02
	qdiv	result1, ##1000000
	cmp	local02, #0 wz
	getqy	local03
 if_e	jmp	#LR__5080
	add	ptr__fatfs_cc_dat__, ##1364
	rdlong	local04, ptr__fatfs_cc_dat__
	add	local04, local02
	wrlong	local04, ptr__fatfs_cc_dat__
	sub	arg01, local03
	add	ptr__fatfs_cc_dat__, #4
	wrlong	arg01, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1368
LR__5080
	add	ptr__fatfs_cc_dat__, ##1364
	rdlong	local04, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1364
	wrlong	local04, local01
	add	local01, #4
	wrlong	local03, local01
'         lastsec += secs;
'         lastus = now - leftover;
'     }
'     tv->tv_sec = lastsec;
'     tv->tv_usec = leftover;
'     return 0;
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
_fatfs_cc_gettimeofday_ret
	ret

_fatfs_cc__is_leap_year
	abs	result1, arg01 wc
	and	result1, #3
	negc	result1, result1 wz
 if_ne	jmp	#LR__5091
	abs	result1, arg01 wc
	qdiv	result1, #100
	getqy	result1
	negc	result1, result1 wz
 if_ne	jmp	#LR__5090
	abs	result1, arg01 wc
	qdiv	result1, #400
'       return (0 == y % 400);
	mov	result1, #0
	getqy	_var01
	negc	_var01, _var01 wz
 if_e	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__5090
'     return 1;
	mov	result1, #1
	jmp	#_fatfs_cc__is_leap_year_ret
LR__5091
'   }
'   return 0;
	mov	result1, #0
_fatfs_cc__is_leap_year_ret
	ret

_fatfs_cc___tzoffset
	mov	_var01, arg01 wz
	wrlong	##-1, arg02
	mov	_var02, #1
 if_ne	rdbyte	_var03, _var01 wz
'                 return 0;
 if_e	mov	result1, #0
 if_e	jmp	#LR__5117
	wrlong	#0, arg02
	add	ptr__fatfs_cc_dat__, ##1324
	mov	_var04, ptr__fatfs_cc_dat__
' 
'        *hasdst = 0;
' 
' 	n = stdname;
'         while (*s && isalpha(*s)) {
	sub	ptr__fatfs_cc_dat__, ##1324
	callpa	#(@LR__5101-@LR__5100)>>2,fcache_load_ptr_
LR__5100
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__5102
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, ##1372
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #12 wz
 if_e	jmp	#LR__5102
	mov	_var05, _var01
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var05
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__5100
LR__5101
LR__5102
	wrbyte	#0, _var04
	mov	_var08, #0
	rdbyte	_var03, _var01
	cmp	_var03, #45 wz
 if_e	neg	_var02, #1
 if_e	add	_var01, #1
	callpa	#(@LR__5104-@LR__5103)>>2,fcache_load_ptr_
'                 sgn = -1;
'                 s++;
'         }
'         while (isdigit(*s)) {
LR__5103
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, ##1372
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #2 wz
 if_e	jmp	#LR__5105
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__5103
LR__5104
LR__5105
	qmul	_var08, ##3600
	rdbyte	_var03, _var01
	cmp	_var03, #58 wz
	getqx	_var09
 if_ne	jmp	#LR__5109
	mov	_var08, #0
	add	_var01, #1
	callpa	#(@LR__5107-@LR__5106)>>2,fcache_load_ptr_
'                 x = 0;
'                 s++;
'                 while (isdigit(*s)) {
LR__5106
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & 0x02 ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, ##1372
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #2 wz
 if_e	jmp	#LR__5108
	mov	_var03, _var08
	shl	_var03, #2
	add	_var03, _var08
	shl	_var03, #1
	rdbyte	_var05, _var01
	sub	_var05, #48
	add	_var03, _var05
	mov	_var08, _var03
	add	_var01, #1
	jmp	#LR__5106
LR__5107
LR__5108
	mov	_var07, _var08
	shl	_var07, #4
	sub	_var07, _var08
	shl	_var07, #2
	add	_var09, _var07
LR__5109
	add	ptr__fatfs_cc_dat__, ##1333
	mov	_var04, ptr__fatfs_cc_dat__
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, #39
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #12 wz
 if_e	jmp	#LR__5112
	wrlong	#1, arg02
'                 *hasdst = 1;
' 		while (*s && isalpha(*s)) *n++ = *s++;
LR__5110
	rdbyte	_var03, _var01 wz
 if_e	jmp	#LR__5111
	rdbyte	arg01, _var01
' {
'   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
	fle	arg01, #128 wc
'     return __ctype[c];
	add	ptr__fatfs_cc_dat__, ##1372
	add	arg01, ptr__fatfs_cc_dat__
	rdbyte	result1, arg01
	sub	ptr__fatfs_cc_dat__, ##1372
	test	result1, #12 wz
 if_e	jmp	#LR__5111
	mov	_var06, _var01
	add	_var06, #1
	rdbyte	_var07, _var01
	mov	_var01, _var06
	wrbyte	_var07, _var04
	add	_var04, #1
	jmp	#LR__5110
LR__5111
LR__5112
	wrbyte	#0, _var04
	add	ptr__fatfs_cc_dat__, ##1324
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1324
 if_e	jmp	#LR__5113
	add	ptr__fatfs_cc_dat__, ##1324
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #8
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1316
	jmp	#LR__5114
LR__5113
	add	ptr__fatfs_cc_dat__, ##1342
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #26
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1316
LR__5114
	add	ptr__fatfs_cc_dat__, ##1333
	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
	sub	ptr__fatfs_cc_dat__, ##1333
 if_e	jmp	#LR__5115
	add	ptr__fatfs_cc_dat__, ##1333
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #13
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1320
	jmp	#LR__5116
LR__5115
	add	ptr__fatfs_cc_dat__, ##1324
	mov	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, #4
	wrlong	_var03, ptr__fatfs_cc_dat__
	sub	ptr__fatfs_cc_dat__, ##1320
LR__5116
	qmul	_var02, _var09
' 		_tzname[1] = stdname;
' 
'         return sgn * off;
	getqx	result1
LR__5117
_fatfs_cc___tzoffset_ret
	ret

_fatfs_cc___indst
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #2 wz
 if_ne	jmp	#LR__5120
	mov	_var01, #7
	add	arg01, #24
	rdlong	_var02, arg01
	add	_var01, _var02
	sub	arg01, #12
	rdlong	_var03, arg01
	sub	_var01, _var03
	cmps	_var01, #0 wc
'                         return 1;
 if_b	mov	result1, #1
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 0;
	mov	result1, #0
	jmp	#_fatfs_cc___indst_ret
LR__5120
	add	arg01, #16
	rdlong	_var01, arg01
	sub	arg01, #16
	cmp	_var01, #10 wz
 if_ne	jmp	#LR__5121
	add	arg01, #24
	rdlong	_var01, arg01
	sub	arg01, #12
	rdlong	_var04, arg01
	sub	_var01, _var04
	cmps	_var01, #0 wc
'                         return 0;
 if_b	mov	result1, #0
 if_b	jmp	#_fatfs_cc___indst_ret
'                 return 1;
	mov	result1, #1
	jmp	#_fatfs_cc___indst_ret
LR__5121
'         }
' 
'         return (t->tm_mon > 2 && t->tm_mon < 10);
	mov	_var01, #0
	add	arg01, #16
	rdlong	_var02, arg01
	sub	arg01, #16
	cmps	_var02, #3 wc
 if_b	jmp	#LR__5122
	add	arg01, #16
	rdlong	_var03, arg01
	cmps	_var03, #10 wc
 if_b	mov	_var01, #1
LR__5122
	mov	result1, _var01
_fatfs_cc___indst_ret
	ret

' 	
' 	FUNCTION pfunc(c as integer) as integer
___strs_cl_pfunc
' 		if (i < 16) then
	add	objptr, #4
	rdlong	result1, objptr
	sub	objptr, #4
	cmps	result1, #16 wc
 if_ae	jmp	#LR__5130
	rdlong	result1, objptr
	add	objptr, #4
	rdlong	_var01, objptr
	add	_var01, result1
	wrbyte	arg01, _var01
	rdlong	result1, objptr
	add	result1, #1
	wrlong	result1, objptr
	sub	objptr, #4
' 			p(i) = c
' 			i = i+1
' 			return 1
	mov	result1, #1
	jmp	#___strs_cl_pfunc_ret
LR__5130
' 			return -1
	neg	result1, #1
___strs_cl_pfunc_ret
	ret

__struct__s_vfs_file_t_putchar
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, #28
	rdlong	local01, objptr wz
	sub	objptr, #28
 if_e	mov	result1, #0
 if_e	jmp	#LR__5140
	add	objptr, #28
	rdlong	local02, objptr
	mov	local03, local02
	sub	objptr, #28
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg02, objptr
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
'     return (i < 0) ? 0 : 1;
	cmps	result1, #0 wc
 if_b	mov	local01, #0
 if_ae	mov	local01, #1
	mov	result1, local01
LR__5140
	mov	ptra, fp
	call	#popregs_
__struct__s_vfs_file_t_putchar_ret
	ret

__struct__s_vfs_file_t_getchar
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #32
	rdlong	arg01, objptr wz
	sub	objptr, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__5150
'     return getcf(__this);
	add	objptr, #32
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #32
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	arg01, objptr
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
LR__5150
	mov	ptra, fp
	call	#popregs_
__struct__s_vfs_file_t_getchar_ret
	ret

__struct___bas_wrap_sender_tx
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, objptr
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__struct___bas_wrap_sender_tx_ret
	ret

__struct___bas_wrap_sender_rx
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #4
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #4
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__struct___bas_wrap_sender_rx_ret
	ret

__struct___bas_wrap_sender_close
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #8
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #8
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__struct___bas_wrap_sender_close_ret
	ret

LR__5160
	byte	"/"
	byte	0
LR__5161
	byte	"inf"
	byte	0
LR__5162
	byte	"nan"
	byte	0
LR__5163
	byte	
	byte	0
LR__5164
	byte	
	byte	0
LR__5165
	byte	
	byte	0
LR__5166
	byte	
	byte	0
LR__5167
	byte	
	byte	0
LR__5168
	byte	
	byte	0
LR__5169
	byte	
	byte	0
LR__5170
	byte	
	byte	0
LR__5171
	byte	0
	byte	0
LR__5172
	byte	0
	byte	0
LR__5173
	byte	0
	byte	0
LR__5174
	byte	" !!! corrupted heap??? !!! "
	byte	0
LR__5175
	byte	" !!! out of heap memory !!! "
	byte	0
LR__5176
	byte	" !!! corrupted heap !!! "
	byte	0
LR__5177
	byte	0
	byte	0
LR__5178
	byte	"."
	byte	0
LR__5179
	byte	0
	byte	0
LR__5180
	byte	0
	byte	0
LR__5181
	byte	0
	byte	0
LR__5182
	byte	"*:<>|",34,"?",127
	byte	0
LR__5183
	byte	"+,;=[]"
	byte	0
LR__5184
	byte	"FAT32   "
	byte	0
LR__5185
	byte	"TZ"
	byte	0
LR__5186
	byte	0
	byte	0
LR__5187
	byte	
	byte	0
LR__5188
	byte	
	byte	0
LR__5189
	byte	
	byte	0
LR__5190
	byte	
	byte	0
LR__5191
	byte	34
	byte	0
LR__5192
	byte	34
	byte	0
LR__5193
	byte	":"
	byte	0
LR__5194
	byte	
	byte	0
LR__5195
	byte	
	byte	0
LR__5196
	byte	
	byte	0
LR__5197
	byte	
	byte	0
LR__5198
	byte	
	byte	0
LR__5199
	byte	
	byte	0
LR__5200
	byte	
	byte	0
LR__5201
	byte	"0"
	byte	0
LR__5202
	byte	34
	byte	0
LR__5203
	byte	34
	byte	0
LR__5204
	byte	34
	byte	0
LR__5205
	byte	34
	byte	0
LR__5206
	byte	34
	byte	0
LR__5207
	byte	">"
	byte	0
LR__5208
	byte	"<"
	byte	0
LR__5209
	byte	"+"
	byte	0
LR__5210
	byte	"-"
	byte	0
LR__5211
	byte	"*"
	byte	0
LR__5212
	byte	"/"
	byte	0
LR__5213
	byte	"^"
	byte	0
LR__5214
	byte	"="
	byte	0
LR__5215
	byte	"+"
	byte	0
LR__5216
	byte	"+"
	byte	0
LR__5217
	byte	"-"
	byte	0
LR__5218
	byte	"-"
	byte	0
LR__5219
	byte	"<"
	byte	0
LR__5220
	byte	">"
	byte	0
LR__5221
	byte	34
	byte	0
LR__5222
	byte	34
	byte	0
LR__5223
	byte	"else"
	byte	0
LR__5224
	byte	"then"
	byte	0
LR__5225
	byte	"."
	byte	0
LR__5226
	byte	"?"
	byte	0
LR__5227
	byte	"?"
	byte	0
LR__5228
	byte	"mouse"
	byte	0
LR__5229
	byte	"cursor"
	byte	0
LR__5230
	byte	"click"
	byte	0
LR__5231
	byte	"on"
	byte	0
LR__5232
	byte	"1"
	byte	0
LR__5233
	byte	"off"
	byte	0
LR__5234
	byte	"0"
	byte	0
LR__5235
	byte	"mode"
	byte	0
LR__5236
	byte	"m."
	byte	0
LR__5237
	byte	"atari"
	byte	0
LR__5238
	byte	"0"
	byte	0
LR__5239
	byte	"pc_amber"
	byte	0
LR__5240
	byte	"1"
	byte	0
LR__5241
	byte	"pc_green"
	byte	0
LR__5242
	byte	"2"
	byte	0
LR__5243
	byte	"pc_white"
	byte	0
LR__5244
	byte	"3"
	byte	0
LR__5245
	byte	"st"
	byte	0
LR__5246
	byte	"4"
	byte	0
LR__5247
	byte	
	byte	0
LR__5248
	byte	"load"
	byte	0
LR__5249
	byte	"save"
	byte	0
LR__5250
	byte	"brun"
	byte	0
LR__5251
	byte	"run"
	byte	0
LR__5252
	byte	"lo."
	byte	0
LR__5253
	byte	"s."
	byte	0
LR__5254
	byte	"br."
	byte	0
LR__5255
	byte	"enter"
	byte	0
LR__5256
	byte	"e."
	byte	0
LR__5257
	byte	"delete"
	byte	0
LR__5258
	byte	"mkdir"
	byte	0
LR__5259
	byte	"cd"
	byte	0
LR__5260
	byte	"cd."
	byte	0
LR__5261
	byte	"."
	byte	0
LR__5262
	byte	".."
	byte	0
LR__5263
	byte	"cd"
	byte	0
LR__5264
	byte	"/"
	byte	0
LR__5265
	byte	
	byte	0
LR__5266
	byte	
	byte	0
LR__5267
	byte	
	byte	0
LR__5268
	byte	
	byte	0
LR__5269
	byte	
	byte	0
LR__5270
	byte	"Ready"
	byte	0
LR__5271
	byte	"+"
	byte	0
LR__5272
	byte	"-"
	byte	0
LR__5273
	byte	"or"
	byte	0
LR__5274
	byte	"xor"
	byte	0
LR__5275
	byte	"*"
	byte	0
LR__5276
	byte	"/"
	byte	0
LR__5277
	byte	"and"
	byte	0
LR__5278
	byte	"div"
	byte	0
LR__5279
	byte	"mod"
	byte	0
LR__5280
	byte	"shl"
	byte	0
LR__5281
	byte	"shr"
	byte	0
LR__5282
	byte	"^"
	byte	0
LR__5283
	byte	"not"
	byte	0
LR__5284
	byte	"@"
	byte	0
LR__5285
	byte	"="
	byte	0
LR__5286
	byte	">="
	byte	0
LR__5287
	byte	"<="
	byte	0
LR__5288
	byte	"<"
	byte	0
LR__5289
	byte	">"
	byte	0
LR__5290
	byte	"<>"
	byte	0
LR__5291
	byte	"++"
	byte	0
LR__5292
	byte	"--"
	byte	0
LR__5293
	byte	"#"
	byte	0
LR__5294
	byte	"0"
	byte	0
LR__5295
	byte	"9"
	byte	0
LR__5296
	byte	"#read"
	byte	0
LR__5297
	byte	"#write"
	byte	0
LR__5298
	byte	"#append"
	byte	0
LR__5299
	byte	"#"
	byte	0
LR__5300
	byte	"#"
	byte	0
LR__5301
	byte	"-"
	byte	0
LR__5302
	byte	"0"
	byte	0
LR__5303
	byte	"c"
	byte	0
LR__5304
	byte	"c#"
	byte	0
LR__5305
	byte	"d"
	byte	0
LR__5306
	byte	"d#"
	byte	0
LR__5307
	byte	"e"
	byte	0
LR__5308
	byte	"f"
	byte	0
LR__5309
	byte	"f#"
	byte	0
LR__5310
	byte	"g"
	byte	0
LR__5311
	byte	"g#"
	byte	0
LR__5312
	byte	"a"
	byte	0
LR__5313
	byte	"a#"
	byte	0
LR__5314
	byte	"h"
	byte	0
LR__5315
	byte	"b"
	byte	0
LR__5316
	byte	"+"
	byte	0
LR__5317
	byte	"-"
	byte	0
LR__5318
	byte	"="
	byte	0
LR__5319
	byte	","
	byte	0
LR__5320
	byte	"*"
	byte	0
LR__5321
	byte	"/"
	byte	0
LR__5322
	byte	";"
	byte	0
LR__5323
	byte	34
	byte	0
LR__5324
	byte	"^"
	byte	0
LR__5325
	byte	")"
	byte	0
LR__5326
	byte	"("
	byte	0
LR__5327
	byte	":"
	byte	0
LR__5328
	byte	" "
	byte	0
LR__5329
	byte	">"
	byte	0
LR__5330
	byte	"<"
	byte	0
LR__5331
	byte	"="
	byte	0
LR__5332
	byte	"beep"
	byte	0
LR__5333
	byte	"b."
	byte	0
LR__5334
	byte	"blit"
	byte	0
LR__5335
	byte	"box"
	byte	0
LR__5336
	byte	"brun"
	byte	0
LR__5337
	byte	"br."
	byte	0
LR__5338
	byte	"cd"
	byte	0
LR__5339
	byte	"changefreq"
	byte	0
LR__5340
	byte	"cf."
	byte	0
LR__5341
	byte	"changepan"
	byte	0
LR__5342
	byte	"cp."
	byte	0
LR__5343
	byte	"changevol"
	byte	0
LR__5344
	byte	"cv."
	byte	0
LR__5345
	byte	"changewave"
	byte	0
LR__5346
	byte	"cw."
	byte	0
LR__5347
	byte	"circle"
	byte	0
LR__5348
	byte	"ci."
	byte	0
LR__5349
	byte	"click"
	byte	0
LR__5350
	byte	"close"
	byte	0
LR__5351
	byte	"cls"
	byte	0
LR__5352
	byte	"color"
	byte	0
LR__5353
	byte	"c."
	byte	0
LR__5354
	byte	"csave"
	byte	0
LR__5355
	byte	"cs."
	byte	0
LR__5356
	byte	"cursor"
	byte	0
LR__5357
	byte	"defsnd"
	byte	0
LR__5358
	byte	"defenv"
	byte	0
LR__5359
	byte	"defsprite"
	byte	0
LR__5360
	byte	"ds."
	byte	0
LR__5361
	byte	"deg"
	byte	0
LR__5362
	byte	"delete"
	byte	0
LR__5363
	byte	"dim"
	byte	0
LR__5364
	byte	"dir"
	byte	0
LR__5365
	byte	"dpoke"
	byte	0
LR__5366
	byte	"draw"
	byte	0
LR__5367
	byte	"drawto"
	byte	0
LR__5368
	byte	"dr."
	byte	0
LR__5369
	byte	"else"
	byte	0
LR__5370
	byte	"end"
	byte	0
LR__5371
	byte	"enter"
	byte	0
LR__5372
	byte	"e."
	byte	0
LR__5373
	byte	"fcircle"
	byte	0
LR__5374
	byte	"fc."
	byte	0
LR__5375
	byte	"fill"
	byte	0
LR__5376
	byte	"fi."
	byte	0
LR__5377
	byte	"font"
	byte	0
LR__5378
	byte	"for"
	byte	0
LR__5379
	byte	"f."
	byte	0
LR__5380
	byte	"frame"
	byte	0
LR__5381
	byte	"fr."
	byte	0
LR__5382
	byte	"get"
	byte	0
LR__5383
	byte	"gosub"
	byte	0
LR__5384
	byte	"goto"
	byte	0
LR__5385
	byte	"g."
	byte	0
LR__5386
	byte	"if"
	byte	0
LR__5387
	byte	"ink"
	byte	0
LR__5388
	byte	"i."
	byte	0
LR__5389
	byte	"input"
	byte	0
LR__5390
	byte	"list"
	byte	0
LR__5391
	byte	"l."
	byte	0
LR__5392
	byte	"load"
	byte	0
LR__5393
	byte	"lo."
	byte	0
LR__5394
	byte	"lpoke"
	byte	0
LR__5395
	byte	"mkdir"
	byte	0
LR__5396
	byte	"mode"
	byte	0
LR__5397
	byte	"m."
	byte	0
LR__5398
	byte	"mouse"
	byte	0
LR__5399
	byte	"new"
	byte	0
LR__5400
	byte	"next"
	byte	0
LR__5401
	byte	"n."
	byte	0
LR__5402
	byte	"on"
	byte	0
LR__5403
	byte	"open"
	byte	0
LR__5404
	byte	"paper"
	byte	0
LR__5405
	byte	"pa."
	byte	0
LR__5406
	byte	"pinfloat"
	byte	0
LR__5407
	byte	"pinhi"
	byte	0
LR__5408
	byte	"pinlo"
	byte	0
LR__5409
	byte	"pinstart"
	byte	0
LR__5410
	byte	"pintoggle"
	byte	0
LR__5411
	byte	"pinwrite"
	byte	0
LR__5412
	byte	"play"
	byte	0
LR__5413
	byte	"p."
	byte	0
LR__5414
	byte	"plot"
	byte	0
LR__5415
	byte	"pl."
	byte	0
LR__5416
	byte	"poke"
	byte	0
LR__5417
	byte	"pop"
	byte	0
LR__5418
	byte	"position"
	byte	0
LR__5419
	byte	"pos."
	byte	0
LR__5420
	byte	"print"
	byte	0
LR__5421
	byte	"?"
	byte	0
LR__5422
	byte	"put"
	byte	0
LR__5423
	byte	"rad"
	byte	0
LR__5424
	byte	"release"
	byte	0
LR__5425
	byte	"rem"
	byte	0
LR__5426
	byte	"'"
	byte	0
LR__5427
	byte	"return"
	byte	0
LR__5428
	byte	"run"
	byte	0
LR__5429
	byte	"save"
	byte	0
LR__5430
	byte	"s."
	byte	0
LR__5431
	byte	"setdelay"
	byte	0
LR__5432
	byte	"sd."
	byte	0
LR__5433
	byte	"setenv"
	byte	0
LR__5434
	byte	"se."
	byte	0
LR__5435
	byte	"setlen"
	byte	0
LR__5436
	byte	"sl."
	byte	0
LR__5437
	byte	"setpan"
	byte	0
LR__5438
	byte	"sp."
	byte	0
LR__5439
	byte	"setsustain"
	byte	0
LR__5440
	byte	"ss."
	byte	0
LR__5441
	byte	"setvol"
	byte	0
LR__5442
	byte	"sv."
	byte	0
LR__5443
	byte	"setwave"
	byte	0
LR__5444
	byte	"sw."
	byte	0
LR__5445
	byte	"setwav"
	byte	0
LR__5446
	byte	"shutup"
	byte	0
LR__5447
	byte	"sh."
	byte	0
LR__5448
	byte	"sound"
	byte	0
LR__5449
	byte	"so."
	byte	0
LR__5450
	byte	"sprite"
	byte	0
LR__5451
	byte	"spr."
	byte	0
LR__5452
	byte	"then"
	byte	0
LR__5453
	byte	"waitms"
	byte	0
LR__5454
	byte	"w."
	byte	0
LR__5455
	byte	"waitclock"
	byte	0
LR__5456
	byte	"wc."
	byte	0
LR__5457
	byte	"waitvbl"
	byte	0
LR__5458
	byte	"wv."
	byte	0
LR__5459
	byte	"wrpin"
	byte	0
LR__5460
	byte	"wxpin"
	byte	0
LR__5461
	byte	"wypin"
	byte	0
LR__5462
	byte	"abs"
	byte	0
LR__5463
	byte	"acos"
	byte	0
LR__5464
	byte	"adr"
	byte	0
LR__5465
	byte	"addr"
	byte	0
LR__5466
	byte	"asc"
	byte	0
LR__5467
	byte	"asin"
	byte	0
LR__5468
	byte	"atn"
	byte	0
LR__5469
	byte	"bin$"
	byte	0
LR__5470
	byte	"chr$"
	byte	0
LR__5471
	byte	"cos"
	byte	0
LR__5472
	byte	"dpeek"
	byte	0
LR__5473
	byte	"framebuf"
	byte	0
LR__5474
	byte	"fb."
	byte	0
LR__5475
	byte	"fre"
	byte	0
LR__5476
	byte	"getpixel"
	byte	0
LR__5477
	byte	"ge."
	byte	0
LR__5478
	byte	"getenvsustain"
	byte	0
LR__5479
	byte	"getnotevalue"
	byte	0
LR__5480
	byte	"gettime"
	byte	0
LR__5481
	byte	"hex$"
	byte	0
LR__5482
	byte	"inkey$"
	byte	0
LR__5483
	byte	"int"
	byte	0
LR__5484
	byte	"left$"
	byte	0
LR__5485
	byte	"len"
	byte	0
LR__5486
	byte	"log"
	byte	0
LR__5487
	byte	"lpeek"
	byte	0
LR__5488
	byte	"mid$"
	byte	0
LR__5489
	byte	"mousek"
	byte	0
LR__5490
	byte	"mousew"
	byte	0
LR__5491
	byte	"mousex"
	byte	0
LR__5492
	byte	"mousey"
	byte	0
LR__5493
	byte	"peek"
	byte	0
LR__5494
	byte	"pinread"
	byte	0
LR__5495
	byte	"rdpin"
	byte	0
LR__5496
	byte	"right$"
	byte	0
LR__5497
	byte	"rqpin"
	byte	0
LR__5498
	byte	"round"
	byte	0
LR__5499
	byte	"rnd"
	byte	0
LR__5500
	byte	"sin"
	byte	0
LR__5501
	byte	"sqr"
	byte	0
LR__5502
	byte	"stick"
	byte	0
LR__5503
	byte	"strig"
	byte	0
LR__5504
	byte	"str$"
	byte	0
LR__5505
	byte	"tan"
	byte	0
LR__5506
	byte	"val"
	byte	0
LR__5507
	byte	"varptr"
	byte	0
LR__5508
	byte	"a"
	byte	0
LR__5509
	byte	"z"
	byte	0
LR__5510
	byte	"_"
	byte	0
LR__5511
	byte	"a"
	byte	0
LR__5512
	byte	"z"
	byte	0
LR__5513
	byte	"0"
	byte	0
LR__5514
	byte	"9"
	byte	0
LR__5515
	byte	"_"
	byte	0
LR__5516
	byte	"."
	byte	0
LR__5517
	byte	"a"
	byte	0
LR__5518
	byte	"z"
	byte	0
LR__5519
	byte	"0"
	byte	0
LR__5520
	byte	"9"
	byte	0
LR__5521
	byte	"_"
	byte	0
LR__5522
	byte	"$"
	byte	0
LR__5523
	byte	"%"
	byte	0
LR__5524
	byte	"!"
	byte	0
LR__5525
	byte	"0"
	byte	0
LR__5526
	byte	"9"
	byte	0
LR__5527
	byte	"."
	byte	0
LR__5528
	byte	"$"
	byte	0
LR__5529
	byte	"%"
	byte	0
LR__5530
	byte	"-"
	byte	0
LR__5531
	byte	"."
	byte	0
LR__5532
	byte	"$"
	byte	0
LR__5533
	byte	"%"
	byte	0
LR__5534
	byte	"0"
	byte	0
LR__5535
	byte	"9"
	byte	0
LR__5536
	byte	"_"
	byte	0
LR__5537
	byte	"."
	byte	0
LR__5538
	byte	"E"
	byte	0
LR__5539
	byte	"e"
	byte	0
LR__5540
	byte	"-"
	byte	0
LR__5541
	byte	"a"
	byte	0
LR__5542
	byte	"f"
	byte	0
LR__5543
	byte	"0"
	byte	0
LR__5544
	byte	"1"
	byte	0
LR__5545
	byte	"_"
	byte	0
LR__5546
	byte	"-"
	byte	0
LR__5547
	byte	"e"
	byte	0
LR__5548
	byte	"."
	byte	0
LR__5549
	byte	"E"
	byte	0
LR__5550
	byte	"e"
	byte	0
LR__5551
	byte	"0"
	byte	0
LR__5552
	byte	"9"
	byte	0
LR__5553
	byte	"$"
	byte	0
LR__5554
	byte	"%"
	byte	0
LR__5555
	byte	"-"
	byte	0
LR__5556
	byte	"$"
	byte	0
LR__5557
	byte	"%"
	byte	0
LR__5558
	byte	"0"
	byte	0
LR__5559
	byte	"9"
	byte	0
LR__5560
	byte	"_"
	byte	0
LR__5561
	byte	"0"
	byte	0
LR__5562
	byte	"9"
	byte	0
LR__5563
	byte	"a"
	byte	0
LR__5564
	byte	"f"
	byte	0
LR__5565
	byte	"_"
	byte	0
LR__5566
	byte	"0"
	byte	0
LR__5567
	byte	"1"
	byte	0
LR__5568
	byte	"_"
	byte	0
LR__5569
	byte	"0"
	byte	0
LR__5570
	byte	"9"
	byte	0
LR__5571
	byte	"_"
	byte	0
LR__5572
	byte	34
	byte	0
LR__5573
	byte	34
	byte	0
LR__5574
	byte	"Dim: at line "
	byte	0
LR__5575
	byte	": warning: the variable existed."
	byte	0
LR__5576
	byte	"("
	byte	0
LR__5577
	byte	"as"
	byte	0
LR__5578
	byte	"as"
	byte	0
LR__5579
	byte	","
	byte	0
LR__5580
	byte	")"
	byte	0
LR__5581
	byte	")"
	byte	0
LR__5582
	byte	"as"
	byte	0
LR__5583
	byte	"byte"
	byte	0
LR__5584
	byte	"ubyte"
	byte	0
LR__5585
	byte	"short"
	byte	0
LR__5586
	byte	"ushort"
	byte	0
LR__5587
	byte	"long"
	byte	0
LR__5588
	byte	"integer"
	byte	0
LR__5589
	byte	"ulong"
	byte	0
LR__5590
	byte	"int64"
	byte	0
LR__5591
	byte	"uint64"
	byte	0
LR__5592
	byte	"single"
	byte	0
LR__5593
	byte	"double"
	byte	0
LR__5594
	byte	"string"
	byte	0
LR__5595
	byte	"to"
	byte	0
LR__5596
	byte	"step"
	byte	0
LR__5597
	byte	"s."
	byte	0
LR__5598
	byte	"goto"
	byte	0
LR__5599
	byte	"gosub"
	byte	0
LR__5600
	byte	"$"
	byte	0
LR__5601
	byte	"&h"
	byte	0
LR__5602
	byte	"%"
	byte	0
LR__5603
	byte	"&b"
	byte	0
LR__5604
	byte	
	byte	0
LR__5605
	byte	"acos: "
	byte	0
LR__5606
	byte	"asc: "
	byte	0
LR__5607
	byte	"asc: "
	byte	0
LR__5608
	byte	"asin: "
	byte	0
LR__5609
	byte	"atn: "
	byte	0
LR__5610
	byte	"blit: "
	byte	0
LR__5611
	byte	"bin$: "
	byte	0
LR__5612
	byte	"/"
	byte	0
LR__5613
	byte	"/sd/bin/"
	byte	0
LR__5614
	byte	"System error "
	byte	0
LR__5615
	byte	": "
	byte	0
LR__5616
	byte	"*"
	byte	0
LR__5617
	byte	".."
	byte	0
LR__5618
	byte	"/"
	byte	0
LR__5619
	byte	"/"
	byte	0
LR__5620
	byte	"System error "
	byte	0
LR__5621
	byte	": "
	byte	0
LR__5622
	byte	"Current directory: "
	byte	0
LR__5623
	byte	"/"
	byte	0
LR__5624
	byte	"System error "
	byte	0
LR__5625
	byte	": "
	byte	0
LR__5626
	byte	"Current directory: "
	byte	0
LR__5627
	byte	"/"
	byte	0
LR__5628
	byte	"/"
	byte	0
LR__5629
	byte	"/"
	byte	0
LR__5630
	byte	"System error "
	byte	0
LR__5631
	byte	": "
	byte	0
LR__5632
	byte	"Current directory: "
	byte	0
LR__5633
	byte	"chr$: "
	byte	0
LR__5634
	byte	"channel# expected"
	byte	0
LR__5635
	byte	"cos: "
	byte	0
LR__5636
	byte	
	byte	0
LR__5637
	byte	
	byte	0
LR__5638
	byte	"/sd/media/h/"
	byte	0
LR__5639
	byte	"System error "
	byte	0
LR__5640
	byte	": "
	byte	0
LR__5641
	byte	
	byte	0
LR__5642
	byte	
	byte	0
LR__5643
	byte	"/sd/media/s/"
	byte	0
LR__5644
	byte	"System error "
	byte	0
LR__5645
	byte	": "
	byte	0
LR__5646
	byte	"/"
	byte	0
LR__5647
	byte	"/"
	byte	0
LR__5648
	byte	"/"
	byte	0
LR__5649
	byte	"Cannot delete file or file doesn't exist: system error "
	byte	0
LR__5650
	byte	"Current directory: "
	byte	0
LR__5651
	byte	
	byte	0
LR__5652
	byte	"*"
	byte	0
LR__5653
	byte	
	byte	0
LR__5654
	byte	"[dir] "
	byte	0
LR__5655
	byte	"More than 128 entries found: clean your directory"
	byte	0
LR__5656
	byte	"*"
	byte	0
LR__5657
	byte	
	byte	0
LR__5658
	byte	"More than 128 entries found: clean your directory"
	byte	0
LR__5659
	byte	"Error "
	byte	0
LR__5660
	byte	": "
	byte	0
LR__5661
	byte	"getenvsustain: "
	byte	0
LR__5662
	byte	"getpixel: "
	byte	0
LR__5663
	byte	"hex$: "
	byte	0
LR__5664
	byte	
	byte	0
LR__5665
	byte	"left$: "
	byte	0
LR__5666
	byte	"left$: "
	byte	0
LR__5667
	byte	"len: "
	byte	0
LR__5668
	byte	"len: "
	byte	0
LR__5669
	byte	
	byte	0
LR__5670
	byte	"/"
	byte	0
LR__5671
	byte	"/"
	byte	0
LR__5672
	byte	".bas"
	byte	0
LR__5673
	byte	"System error "
	byte	0
LR__5674
	byte	": "
	byte	0
LR__5675
	byte	".bas"
	byte	0
LR__5676
	byte	"/"
	byte	0
LR__5677
	byte	
	byte	0
LR__5678
	byte	"Loaded "
	byte	0
LR__5679
	byte	"/"
	byte	0
LR__5680
	byte	"log: "
	byte	0
LR__5681
	byte	"mid$: "
	byte	0
LR__5682
	byte	"mid$: "
	byte	0
LR__5683
	byte	"Cannot create a directory: system error "
	byte	0
LR__5684
	byte	" BASIC bytes free"
	byte	0
LR__5685
	byte	
	byte	0
LR__5686
	byte	
	byte	0
LR__5687
	byte	"noname.bas"
	byte	0
LR__5688
	byte	"filename expected"
	byte	0
LR__5689
	byte	"read"
	byte	0
LR__5690
	byte	"write"
	byte	0
LR__5691
	byte	"append"
	byte	0
LR__5692
	byte	"channel# expected"
	byte	0
LR__5693
	byte	"Open: invalid mode"
	byte	0
LR__5694
	byte	"Print to channel (not yet implemented)"
	byte	0
LR__5695
	byte	"right$: "
	byte	0
LR__5696
	byte	"right$: "
	byte	0
LR__5697
	byte	"rnd: "
	byte	0
LR__5698
	byte	"rnd: "
	byte	0
LR__5699
	byte	"Stopped at line "
	byte	0
LR__5700
	byte	
	byte	0
LR__5701
	byte	"/"
	byte	0
LR__5702
	byte	
	byte	0
LR__5703
	byte	"Saved as "
	byte	0
LR__5704
	byte	"/"
	byte	0
LR__5705
	byte	"sin: "
	byte	0
LR__5706
	byte	"sqr: "
	byte	0
LR__5707
	byte	"stick: "
	byte	0
LR__5708
	byte	"strig: "
	byte	0
LR__5709
	byte	"tan: "
	byte	0
LR__5710
	byte	"val: "
	byte	0
LR__5711
	byte	"val: "
	byte	0
LR__5712
	byte	"$"
	byte	0
LR__5713
	byte	"&h"
	byte	0
LR__5714
	byte	"%"
	byte	0
LR__5715
	byte	"&b"
	byte	0
LR__5716
	byte	
	byte	0
LR__5717
	byte	"Expected number, got something else"
	byte	0
LR__5718
	byte	"Cannot add a number to a string"
	byte	0
LR__5719
	byte	"Cannot substract strings"
	byte	0
LR__5720
	byte	"Unknown error while adding"
	byte	0
LR__5721
	byte	"Unknown error while substracting"
	byte	0
LR__5722
	byte	"Cannot do logic operation on string or float"
	byte	0
LR__5723
	byte	"Unknown error while doing logic operation"
	byte	0
LR__5724
	byte	"Cannot multiply strings"
	byte	0
LR__5725
	byte	"Unknown error while multiplying"
	byte	0
LR__5726
	byte	"Cannot divide strings"
	byte	0
LR__5727
	byte	"Unknown error while dividing"
	byte	0
LR__5728
	byte	"Cannot compute a power of a string"
	byte	0
LR__5729
	byte	"Unknown error while computing a power"
	byte	0
LR__5730
	byte	"Right parenthesis expected"
	byte	0
LR__5731
	byte	"Expected string"
	byte	0
LR__5732
	byte	"Expected float"
	byte	0
LR__5733
	byte	"Expected unsigned integer"
	byte	0
LR__5734
	byte	"Expected integer"
	byte	0
LR__5735
	byte	"No more variable slots"
	byte	0
LR__5736
	byte	"Variable not found"
	byte	0
LR__5737
	byte	"Comma expected"
	byte	0
LR__5738
	byte	"Comma or semicolon expected"
	byte	0
LR__5739
	byte	"Unknown command"
	byte	0
LR__5740
	byte	"Stack underflow"
	byte	0
LR__5741
	byte	"Cannot execute goto or gosub in the immediate mode"
	byte	0
LR__5742
	byte	"Cannot load from this file"
	byte	0
LR__5743
	byte	"The program is empty"
	byte	0
LR__5744
	byte	"If after if"
	byte	0
LR__5745
	byte	"Empty expression"
	byte	0
LR__5746
	byte	"String expected"
	byte	0
LR__5747
	byte	"Interpreter internal error"
	byte	0
LR__5748
	byte	"Expected assign"
	byte	0
LR__5749
	byte	"Expected 'to'"
	byte	0
LR__5750
	byte	"Expected integer variable"
	byte	0
LR__5751
	byte	"Uninitialized variable in 'next', use 'for' before"
	byte	0
LR__5752
	byte	"No more slots for 'for'"
	byte	0
LR__5753
	byte	"'Next' doesn't match 'for'"
	byte	0
LR__5754
	byte	"'Goto' target line not found"
	byte	0
LR__5755
	byte	"Bad number of parameters"
	byte	0
LR__5756
	byte	"Function undefined for strings"
	byte	0
LR__5757
	byte	"Bad parameter"
	byte	0
LR__5758
	byte	"Cannot declare an array: the variable exists"
	byte	0
LR__5759
	byte	"Expected '('"
	byte	0
LR__5760
	byte	"Expected ')' or ','"
	byte	0
LR__5761
	byte	"No more than 3 dimensions supported"
	byte	0
LR__5762
	byte	"Variable name expected"
	byte	0
LR__5763
	byte	"Type name expected"
	byte	0
LR__5764
	byte	"Type not supported yet"
	byte	0
LR__5765
	byte	"Array index out of range"
	byte	0
LR__5766
	byte	"Bad type while assigning to array"
	byte	0
LR__5767
	byte	"Too many variables"
	byte	0
LR__5768
	byte	"'Then' expected"
	byte	0
LR__5769
	byte	"Directory doesn't exist"
	byte	0
LR__5770
	byte	"Error "
	byte	0
LR__5771
	byte	" - "
	byte	0
LR__5772
	byte	" in line "
	byte	0
LR__5773
	byte	"/sd"
	byte	0
LR__5774
	byte	"/sd/bas"
	byte	0
LR__5775
	byte	"/sd/bas"
	byte	0
LR__5776
	byte	" BASIC bytes free"
	byte	0
LR__5777
	byte	"Ready"
	byte	0
LR__5778
	byte	"noname.bas"
	byte	0
LR__5779
	byte	"/sd/bas/autorun.bas"
	byte	0
LR__5780
	byte	"run autorun.bas"
	byte	0
LR__5781
	byte	
	byte	0
	alignl
_dat_
	byte	$00[16]
	byte	$61, $41, $17, $0e, $62, $42, $00, $00, $63, $43, $19, $10, $64, $44, $00, $00
	byte	$65, $45, $18, $0f, $66, $46, $00, $00, $67, $47, $00, $00, $68, $48, $00, $00
	byte	$69, $49, $00, $00, $6a, $4a, $00, $00, $6b, $4b, $00, $00, $6c, $4c, $1f, $16
	byte	$6d, $4d, $00, $00, $6e, $4e, $1a, $11, $6f, $4f, $1e, $15, $70, $50, $00, $00
	byte	$71, $51, $00, $00, $72, $52, $00, $00, $73, $53, $1b, $12, $74, $54, $00, $00
	byte	$75, $55, $00, $00, $76, $56, $00, $00, $77, $57, $00, $00, $78, $58, $1c, $13
	byte	$79, $59, $00, $00, $7a, $5a, $1d, $14, $31, $21, $04, $00, $32, $40, $05, $00
	byte	$33, $23, $06, $00, $34, $24, $07, $00, $35, $25, $08, $00, $36, $5e, $09, $00
	byte	$37, $26, $0a, $00, $38, $2a, $0b, $00, $39, $28, $0c, $00, $30, $29, $0d, $00
	byte	$8d, $8d, $00, $00, $9b, $9b, $00, $00, $88, $88, $00, $00, $89, $89, $00, $00
	byte	$20, $20, $00, $00, $2d, $5f, $00, $00, $3d, $2b, $00, $00, $5b, $7b, $00, $00
	byte	$5d, $7d, $00, $00, $5c, $7c, $00, $00, $23, $7e, $00, $00, $3b, $3a, $00, $00
	byte	$27, $22, $00, $00, $60, $7e, $03, $00, $2c, $3c, $00, $00, $2e, $3e, $00, $00
	byte	$2f, $3f, $00, $00, $b9, $b9, $00, $00, $ba, $00, $00, $00, $bb, $00, $00, $00
	byte	$bc, $00, $00, $00, $bd, $00, $00, $00, $be, $00, $00, $00, $bf, $00, $00, $00
	byte	$c0, $00, $00, $00, $c1, $00, $00, $00, $c2, $00, $00, $00, $c3, $00, $00, $00
	byte	$c4, $00, $00, $00, $c5, $00, $00, $00, $c6, $00, $00, $00, $c7, $00, $00, $00
	byte	$c8, $00, $00, $00, $c9, $00, $00, $00, $ca, $00, $00, $00, $cb, $00, $00, $00
	byte	$7f, $7f, $00, $00, $cc, $00, $00, $00, $cd, $00, $00, $00, $ce, $00, $00, $00
	byte	$cf, $00, $00, $00, $d0, $00, $00, $00, $d1, $00, $00, $00, $d2, $00, $00, $00
	byte	$2f, $2f, $00, $00, $2a, $2a, $00, $00, $2d, $2d, $00, $00, $2b, $2b, $00, $00
	byte	$8d, $8d, $00, $00, $31, $31, $00, $00, $32, $32, $00, $00, $33, $33, $00, $00
	byte	$34, $34, $00, $00, $35, $35, $00, $00, $36, $36, $00, $00, $37, $37, $00, $00
	byte	$38, $38, $00, $00, $39, $39, $00, $00, $30, $30, $00, $00, $2e, $7f, $00, $00
	byte	$5c, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3d, $3d, $00, $00
	byte	$00[96]
'-' atari_spl file "atari.spl"
	byte	$2b, $00, $a6, $f2, $24, $a7, $09, $80, $5b, $88, $4d, $89, $80, $88, $a5, $88
	byte	$6d, $88, $b8, $88, $80, $88, $cb, $88, $92, $88, $a5, $88, $a5, $88, $b8, $88
	byte	$a5, $88, $ca, $88, $a6, $88, $dd, $88, $b8, $88, $ab, $89, $42, $87, $32, $84
	byte	$c8, $ad, $c6, $f1, $91, $06, $b6, $ff, $13, $00, $4a, $00, $71, $00, $5e, $00
	byte	$5d, $00, $5e, $00, $5d, $00, $5e, $00, $5e, $00, $5d, $00, $5e, $00, $71, $00
	byte	$38, $00, $83, $00, $25, $00, $83, $00, $c3, $fe, $d1, $04, $96, $00, $27, $c3
	byte	$48, $88, $38, $85, $41, $8a, $cb, $88, $28, $89, $b8, $88, $28, $89, $f0, $88
	byte	$15, $89, $03, $89, $02, $89, $15, $89, $16, $89, $15, $89, $15, $89, $28, $89
	byte	$15, $89, $3a, $89, $72, $89, $e3, $89, $52, $83, $ad, $97, $c3, $dc, $a3, $06
	byte	$0c, $02, $b6, $ff, $e1, $00, $a8, $00, $f3, $00, $a8, $00, $e0, $00, $bb, $00
	byte	$ce, $00, $cd, $00, $cd, $00, $ba, $00, $e1, $00, $bb, $00, $f2, $00, $a8, $00
	byte	$df, $00, $c9, $ff, $e6, $01, $b6, $06, $ee, $dd, $8d, $98, $53, $83, $f5, $89
	byte	$97, $89, $73, $89, $3b, $89, $60, $89, $60, $89, $60, $89, $73, $89, $72, $89
	byte	$73, $89, $72, $89, $85, $89, $73, $89, $aa, $89, $60, $89, $bd, $89, $72, $89
	byte	$e8, $8a, $18, $86, $92, $88, $a5, $c2, $e0, $00, $c3, $05, $7d, $ff, $50, $01
	byte	$f2, $00, $64, $01, $06, $01, $3e, $01, $2b, $01, $2b, $01, $2b, $01, $2b, $01
	byte	$2b, $01, $2a, $01, $2b, $01, $2b, $01, $2b, $01, $18, $01, $cd, $00, $5d, $00
	byte	$39, $07, $61, $f3, $c0, $af, $37, $85, $0f, $88, $8b, $8a, $ab, $89, $d0, $89
	byte	$ab, $89, $d0, $89, $ab, $89, $d0, $89, $d0, $89, $cf, $89, $d0, $89, $e3, $89
	byte	$d0, $89, $f5, $89, $bd, $89, $08, $8a, $cf, $89, $e8, $8a, $5a, $88, $82, $85
	byte	$53, $b3, $0d, $f8, $f4, $07, $38, $00, $63, $01, $63, $01, $9a, $01, $75, $01
	byte	$88, $01, $88, $01, $76, $01, $88, $01, $88, $01, $89, $01, $89, $01, $88, $01
	byte	$75, $01, $ae, $01, $76, $01, $88, $01, $4a, $00, $46, $06, $d0, $fd, $bf, $c0
	byte	$08, $8a, $9a, $86, $33, $8b, $08, $8a, $2d, $8a, $f5, $89, $2e, $8a, $08, $8a
	byte	$2d, $8a, $2d, $8a, $2e, $8a, $1b, $8a, $40, $8a, $2d, $8a, $53, $8a, $40, $8a
	byte	$2e, $8a, $79, $8a, $66, $8a, $c8, $8b, $72, $82, $2b, $97, $9a, $e2, $49, $0a
	byte	$1d, $02, $05, $01, $f8, $01, $c0, $01, $0b, $02, $c0, $01, $0b, $02, $d3, $01
	byte	$f9, $01, $d3, $01, $f8, $01, $d3, $01, $f8, $01, $d2, $01, $f8, $01, $d2, $01
	byte	$e6, $01, $2b, $01, $8e, $02, $5f, $07, $f7, $e2, $ed, $9c, $9c, $83, $d6, $8a
	byte	$e8, $8a, $78, $8a, $78, $8a, $65, $8a, $8b, $8a, $78, $8a, $9e, $8a, $8b, $8a
	byte	$8b, $8a, $9d, $8a, $9d, $8a, $8b, $8a, $c2, $8a, $78, $8a, $e8, $8a, $78, $8a
	byte	$70, $8c, $18, $86, $8b, $8a, $23, $c9, $cb, $03, $c4, $05, $e0, $00, $68, $02
	byte	$0b, $02, $7b, $02, $1e, $02, $55, $02, $30, $02, $43, $02, $43, $02, $43, $02
	byte	$43, $02, $44, $02, $43, $02, $30, $02, $68, $02, $31, $02, $31, $02, $3e, $01
	byte	$07, $08, $3f, $f7, $73, $b2, $13, $85, $15, $89, $ed, $8b, $9d, $8a, $fb, $8a
	byte	$b0, $8a, $fb, $8a, $d5, $8a, $fa, $8a, $e8, $8a, $fb, $8a, $fb, $8a, $0e, $8b
	byte	$e8, $8a, $21, $8b, $e7, $8a, $33, $8b, $e8, $8a, $26, $8c, $be, $89, $ff, $84
	byte	$8d, $b0, $27, $f6, $9c, $08, $ad, $01, $7b, $02, $8d, $02, $c6, $02, $8e, $02
	byte	$a1, $02, $a0, $02, $a1, $02, $a0, $02, $a0, $02, $a0, $02, $8e, $02, $b4, $02
	byte	$7b, $02, $d8, $02, $7b, $02, $c6, $02, $3e, $01, $c3, $05, $f6, $04, $0f, $cc
	byte	$00, $8c, $2a, $86, $e0, $8c, $fa, $8a, $6a, $8b, $fb, $8a, $58, $8b, $33, $8b
	byte	$45, $8b, $45, $8b, $45, $8b, $6b, $8b, $46, $8b, $59, $8b, $58, $8b, $6b, $8b
	byte	$6b, $8b, $6b, $8b, $6b, $8b, $6b, $8b, $7d, $8b, $7d, $8b, $7d, $8b, $7d, $8b
	byte	$90, $8b, $91, $8b, $90, $8b, $90, $8b, $a3, $8b, $a3, $8b, $a3, $8b, $a3, $8b
	byte	$b5, $8b, $b6, $8b, $b5, $8b, $b5, $8b, $b6, $8b, $c8, $8b, $c9, $8b, $c8, $8b
	byte	$c8, $8b, $da, $8b, $db, $8b, $db, $8b, $db, $8b, $dc, $8b, $ee, $8b, $ee, $8b
	byte	$ee, $8b, $ee, $8b, $00, $8c, $01, $8c, $00, $8c, $01, $8c, $00, $8c, $13, $8c
	byte	$12, $8c, $13, $8c, $13, $8c, $26, $8c, $26, $8c, $26, $8c, $26, $8c, $39, $8c
	byte	$38, $8c, $38, $8c, $38, $8c, $38, $8c, $4b, $8c, $4b, $8c, $4b, $8c, $4c, $8c
	byte	$5e, $8c, $5e, $8c, $5e, $8c, $5e, $8c, $70, $8c, $70, $8c, $71, $8c, $70, $8c
	byte	$70, $8c, $83, $8c, $83, $8c, $83, $8c, $83, $8c, $96, $8c, $95, $8c, $96, $8c
	byte	$95, $8c, $a9, $8c, $a9, $8c, $a8, $8c, $a8, $8c, $a8, $8c, $bb, $8c, $bb, $8c
	byte	$bb, $8c, $bb, $8c, $bb, $8c, $ce, $8c, $ce, $8c, $ce, $8c, $ce, $8c, $e0, $8c
	byte	$e0, $8c, $e1, $8c, $e1, $8c, $e0, $8c, $f4, $8c, $f2, $8c, $f2, $8c, $f3, $8c
	byte	$05, $8d, $05, $8d, $06, $8d, $06, $8d, $19, $8d, $19, $8d, $18, $8d, $18, $8d
	byte	$18, $8d, $2b, $8d, $2b, $8d, $2b, $8d, $2a, $8d, $3e, $8d, $3e, $8d, $3f, $8d
	byte	$3e, $8d, $51, $8d, $50, $8d, $50, $8d, $50, $8d, $51, $8d, $62, $8d, $62, $8d
	byte	$63, $8d, $64, $8d, $76, $8d, $75, $8d, $75, $8d, $76, $8d, $89, $8d, $89, $8d
	byte	$88, $8d, $88, $8d, $89, $8d, $9b, $8d, $9a, $8d, $9b, $8d, $9b, $8d, $af, $8d
	byte	$ad, $8d, $ae, $8d, $ad, $8d, $ae, $8d, $c1, $8d, $c1, $8d, $c0, $8d, $c1, $8d
	byte	$d3, $8d, $d3, $8d, $d3, $8d, $d3, $8d, $d3, $8d, $e6, $8d, $e6, $8d, $e6, $8d
	byte	$e6, $8d, $e6, $8d, $f9, $8d, $f9, $8d, $f9, $8d, $f8, $8d, $0b, $8e, $0b, $8e
	byte	$0b, $8e, $0b, $8e, $1d, $8e, $1d, $8e, $1e, $8e, $1e, $8e, $1e, $8e, $30, $8e
	byte	$31, $8e, $31, $8e, $31, $8e, $42, $8e, $43, $8e, $43, $8e, $43, $8e, $43, $8e
	byte	$56, $8e, $56, $8e, $55, $8e, $56, $8e, $68, $8e, $69, $8e, $68, $8e, $68, $8e
	byte	$69, $8e, $7b, $8e, $7c, $8e, $7b, $8e, $7b, $8e, $8d, $8e, $8e, $8e, $8e, $8e
	byte	$8d, $8e, $a1, $8e, $a0, $8e, $a1, $8e, $a1, $8e, $a0, $8e, $b3, $8e, $b3, $8e
	byte	$b3, $8e, $b3, $8e, $c6, $8e, $c5, $8e, $c6, $8e, $c6, $8e, $c6, $8e, $d8, $8e
	byte	$d8, $8e, $d9, $8e, $d8, $8e, $ec, $8e, $eb, $8e, $ec, $8e, $eb, $8e, $eb, $8e
	byte	$fe, $8e, $fe, $8e, $fe, $8e, $fe, $8e, $10, $8f, $10, $8f, $11, $8f, $11, $8f
	byte	$11, $8f, $23, $8f, $24, $8f, $23, $8f, $24, $8f, $37, $8f, $37, $8f, $36, $8f
	byte	$36, $8f, $36, $8f, $48, $8f, $49, $8f, $49, $8f, $49, $8f, $5b, $8f, $5b, $8f
	byte	$5b, $8f, $5c, $8f, $5b, $8f, $6e, $8f, $6e, $8f, $6e, $8f, $6e, $8f, $6e, $8f
	byte	$81, $8f, $81, $8f, $81, $8f, $81, $8f, $93, $8f, $93, $8f, $94, $8f, $93, $8f
	byte	$93, $8f, $a6, $8f, $a6, $8f, $a6, $8f, $a6, $8f, $b9, $8f, $b9, $8f, $b9, $8f
	byte	$b9, $8f, $b9, $8f, $cc, $8f, $cb, $8f, $cb, $8f, $cc, $8f, $de, $8f, $de, $8f
	byte	$df, $8f, $de, $8f, $de, $8f, $f1, $8f, $f1, $8f, $f1, $8f, $f0, $8f, $04, $90
	byte	$03, $90, $04, $90, $04, $90, $04, $90, $16, $90, $17, $90, $16, $90, $16, $90
	byte	$29, $90, $28, $90, $29, $90, $28, $90, $29, $90, $3c, $90, $3c, $90, $3b, $90
	byte	$3c, $90, $4f, $90, $4e, $90, $4e, $90, $4e, $90, $4e, $90, $61, $90, $60, $90
	byte	$61, $90, $61, $90, $73, $90, $74, $90, $74, $90, $74, $90, $74, $90, $86, $90
	byte	$87, $90, $86, $90, $87, $90, $86, $90, $99, $90, $99, $90, $99, $90, $99, $90
	byte	$ab, $90, $ab, $90, $ac, $90, $ab, $90, $ab, $90, $bf, $90, $be, $90, $be, $90
	byte	$be, $90, $d1, $90, $d0, $90, $d1, $90, $d1, $90, $d1, $90, $e3, $90, $e3, $90
	byte	$e3, $90, $e4, $90, $f6, $90, $f6, $90, $f6, $90, $f6, $90, $f6, $90, $08, $91
	byte	$09, $91, $0a, $91, $0a, $91, $1c, $91, $1c, $91, $1c, $91, $1b, $91, $1c, $91
	byte	$2f, $91, $2e, $91, $2f, $91, $2f, $91, $2e, $91, $41, $91, $41, $91, $41, $91
	byte	$41, $91, $53, $91, $54, $91, $54, $91, $53, $91, $54, $91, $67, $91, $66, $91
	byte	$67, $91, $67, $91, $79, $91, $7a, $91, $79, $91, $78, $91, $7a, $91, $8b, $91
	byte	$8c, $91, $8b, $91, $8c, $91, $8c, $91, $9e, $91, $9e, $91, $9e, $91, $9e, $91
	byte	$b1, $91, $b1, $91, $b2, $91, $b1, $91, $b1, $91, $c4, $91, $c4, $91, $c5, $91
	byte	$c4, $91, $d6, $91, $d7, $91, $d7, $91, $d7, $91, $d6, $91, $e9, $91, $ea, $91
	byte	$ea, $91, $ea, $91, $ea, $91, $fc, $91, $fc, $91, $fb, $91, $fc, $91, $0e, $92
	byte	$0e, $92, $0f, $92, $0f, $92, $0e, $92, $21, $92, $21, $92, $22, $92, $21, $92
	byte	$21, $92, $34, $92, $33, $92, $34, $92, $34, $92, $47, $92, $47, $92, $46, $92
	byte	$46, $92, $47, $92, $59, $92, $59, $92, $59, $92, $59, $92, $59, $92, $6c, $92
	byte	$6c, $92, $6c, $92, $6b, $92, $7e, $92, $7e, $92, $7e, $92, $7f, $92, $7e, $92
	byte	$92, $92, $91, $92, $91, $92, $90, $92, $91, $92, $a4, $92, $a4, $92, $a4, $92
	byte	$a3, $92, $b6, $92, $b6, $92, $b7, $92, $b7, $92, $b6, $92, $c9, $92, $c9, $92
	byte	$ca, $92, $c9, $92, $ca, $92, $dc, $92, $dc, $92, $dc, $92, $db, $92, $ee, $92
	byte	$ef, $92, $ef, $92, $ef, $92, $ef, $92, $01, $93, $01, $93, $01, $93, $02, $93
	byte	$15, $93, $14, $93, $14, $93, $14, $93, $14, $93, $27, $93, $26, $93, $27, $93
	byte	$27, $93, $39, $93, $3a, $93, $39, $93, $39, $93, $39, $93, $4c, $93, $4c, $93
	byte	$4b, $93, $4c, $93, $5f, $93, $5f, $93, $5f, $93, $5e, $93, $5e, $93, $71, $93
	byte	$5f, $93, $84, $93, $4c, $93, $96, $93, $5f, $93, $ae, $94, $e4, $90, $29, $90
	byte	$7b, $c1, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
'-' atari2_spl file "atari2.spl" '1758
	byte	$7a, $d7, $00, $80, $87, $8a, $48, $8f, $ec, $8c, $76, $8d, $f2, $8c, $c0, $8d
	byte	$3c, $8d, $82, $8d, $42, $8d, $88, $8d, $8c, $8d, $8e, $8d, $92, $8d, $d8, $8d
	byte	$97, $8d, $de, $8d, $e1, $8d, $f1, $8e, $d8, $8c, $a3, $83, $45, $c0, $be, $3d
	byte	$65, $71, $c9, $65, $fc, $64, $c4, $65, $c1, $65, $bf, $65, $bc, $65, $fc, $65
	byte	$b6, $65, $b4, $65, $b2, $65, $ae, $65, $ac, $65, $ed, $65, $64, $65, $e7, $65
	byte	$5e, $65, $25, $66, $fa, $62, $23, $6b, $b5, $6c, $61, $0a, $d2, $94, $04, $85
	byte	$5d, $90, $be, $8d, $47, $8e, $c3, $8d, $09, $8e, $c9, $8d, $10, $8e, $13, $8e
	byte	$15, $8e, $19, $8e, $1b, $8e, $62, $8e, $64, $8e, $68, $8e, $28, $8e, $b2, $8e
	byte	$b5, $8e, $4c, $90, $fa, $84, $3c, $9d, $98, $13, $79, $6d, $18, $6b, $3a, $64
	byte	$d9, $66, $50, $66, $d4, $66, $4b, $66, $8c, $66, $46, $66, $86, $66, $84, $66
	byte	$81, $66, $3a, $66, $7c, $66, $36, $66, $76, $66, $30, $66, $71, $66, $1d, $65
	byte	$6b, $66, $88, $72, $bf, $37, $e7, $b7, $75, $83, $8b, $8e, $57, $8f, $90, $8e
	byte	$94, $8e, $96, $8e, $dd, $8e, $9c, $8e, $e2, $8e, $a2, $8e, $e9, $8e, $ec, $8e
	byte	$ee, $8e, $ae, $8e, $38, $8f, $b5, $8e, $3f, $8f, $fd, $8e, $1c, $91, $0f, $8b
	byte	$a5, $87, $1e, $e3, $6d, $5d, $fa, $71, $41, $64, $25, $67, $de, $66, $63, $67
	byte	$d9, $66, $1a, $67, $18, $67, $15, $67, $12, $67, $0f, $67, $0c, $67, $0a, $67
	byte	$07, $67, $c0, $66, $01, $67, $bc, $66, $b8, $66, $de, $64, $b8, $70, $40, $59
	byte	$43, $e5, $1f, $8b, $14, $8a, $f1, $90, $1c, $8f, $63, $8f, $df, $8e, $69, $8f
	byte	$29, $8f, $6e, $8f, $72, $8f, $75, $8f, $34, $8f, $be, $8f, $7e, $8f, $c3, $8f
	byte	$84, $8f, $87, $8f, $cc, $8f, $56, $90, $67, $91, $49, $80, $f5, $b3, $59, $3e
	byte	$46, $77, $a6, $66, $e8, $66, $b0, $67, $ad, $67, $ed, $67, $64, $67, $e9, $67
	byte	$a2, $67, $e3, $67, $9d, $67, $9a, $67, $98, $67, $94, $67, $92, $67, $d2, $67
	byte	$49, $67, $cd, $67, $28, $65, $5f, $6e, $82, $67, $3a, $01, $6c, $95, $fd, $87
	byte	$c2, $91, $a9, $8f, $ef, $8f, $ae, $8f, $f4, $8f, $b5, $8f, $f9, $8f, $fd, $8f
	byte	$01, $90, $03, $90, $07, $90, $09, $90, $0c, $90, $53, $90, $12, $90, $9c, $90
	byte	$18, $90, $44, $93, $85, $84, $d6, $9d, $87, $1f, $2f, $75, $e5, $6a, $23, $66
	byte	$c4, $68, $f6, $67, $be, $68, $f1, $67, $76, $68, $2e, $68, $6f, $68, $29, $68
	byte	$27, $68, $24, $68, $64, $68, $1e, $68, $5f, $68, $19, $68, $5a, $68, $06, $67
	byte	$dc, $68, $56, $72, $7e, $36, $c2, $b8, $d7, $84, $73, $90, $41, $91, $79, $90
	byte	$7b, $90, $7f, $90, $82, $90, $84, $90, $cb, $90, $8b, $90, $8e, $90, $90, $90
	byte	$d7, $90, $96, $90, $20, $91, $59, $90, $25, $91, $a2, $90, $8c, $93, $62, $8b
	byte	$d0, $89, $40, $ee, $12, $64, $c4, $71, $29, $66, $0c, $69, $82, $68, $4a, $69
	byte	$c0, $68, $02, $69, $fe, $68, $fb, $68, $f9, $68, $f6, $68, $f2, $68, $f1, $68
	byte	$ee, $68, $a8, $68, $2c, $69, $5f, $68, $e2, $68, $81, $66, $4c, $71, $5e, $5f
	byte	$1e, $eb, $a6, $8a, $73, $8b, $5e, $93, $7b, $90, $48, $91, $81, $90, $4e, $91
	byte	$0d, $91, $11, $91, $14, $91, $16, $91, $5c, $91, $1c, $91, $63, $91, $66, $91
	byte	$68, $91, $af, $91, $2a, $91, $b5, $91, $75, $91, $1a, $94, $ba, $87, $b7, $9a
	byte	$70, $0e, $cb, $6c, $5d, $6e, $c4, $67, $99, $69, $54, $69, $d8, $69, $4e, $69
	byte	$d2, $69, $49, $69, $89, $69, $86, $69, $40, $69, $c4, $69, $3b, $69, $bf, $69
	byte	$35, $69, $76, $69, $58, $67, $eb, $6d, $e9, $6d, $89, $0f, $73, $99, $46, $87
	byte	$33, $94, $94, $91, $d9, $91, $56, $91, $e0, $91, $9f, $91, $e5, $91, $e8, $91
	byte	$ec, $91, $ee, $91, $f1, $91, $f4, $91, $f7, $91, $3d, $92, $fc, $91, $42, $92
	byte	$46, $92, $21, $94, $11, $89, $a4, $9d, $fd, $0e, $8f, $6c, $73, $6f, $0e, $68
	byte	$28, $6a, $e1, $69, $65, $6a, $1f, $6a, $5f, $6a, $1a, $6a, $17, $6a, $13, $6a
	byte	$54, $6a, $0f, $6a, $4f, $6a, $09, $6a, $06, $6a, $03, $6a, $00, $6a, $76, $69
	byte	$23, $68, $69, $77, $3a, $4d, $38, $ca, $38, $86, $4e, $91, $6d, $93, $1e, $92
	byte	$64, $92, $24, $92, $6a, $92, $2a, $92, $70, $92, $30, $92, $76, $92, $79, $92
	byte	$7b, $92, $7e, $92, $c5, $92, $84, $92, $cb, $92, $8a, $92, $a9, $94, $9b, $8e
	byte	$4d, $8d, $f9, $e2, $97, $59, $fe, $74, $db, $68, $6d, $6a, $ae, $6a, $ef, $6a
	byte	$a8, $6a, $a5, $6a, $a3, $6a, $9f, $6a, $9d, $6a, $9b, $6a, $98, $6a, $95, $6a
	byte	$d6, $6a, $8f, $6a, $cf, $6a, $46, $6a, $ca, $6a, $e1, $67, $34, $73, $10, $67
	byte	$d3, $f7, $15, $92, $90, $8c, $bf, $94, $a6, $92, $eb, $92, $68, $92, $36, $93
	byte	$b1, $92, $f7, $92, $fa, $92, $fd, $92, $00, $93, $02, $93, $06, $93, $4c, $93
	byte	$4f, $93, $52, $93, $54, $93, $22, $94, $5a, $93, $8f, $88, $e9, $ba, $f7, $39
	byte	$1c, $77, $07, $6c, $e8, $69, $7a, $6b, $34, $6b, $75, $6b, $2e, $6b, $6f, $6b
	byte	$29, $6b, $26, $6b, $24, $6b, $21, $6b, $1d, $6b, $5e, $6b, $18, $6b, $59, $6b
	byte	$12, $6b, $52, $6b, $34, $69, $34, $6e, $ba, $73, $a4, $24, $99, $aa, $de, $88
	byte	$7a, $94, $b3, $93, $72, $93, $31, $93, $78, $93, $7a, $93, $7e, $93, $81, $93
	byte	$83, $93, $86, $93, $89, $93, $d0, $93, $d2, $93, $d5, $93, $94, $93, $1e, $94
	byte	$dd, $93, $40, $96, $30, $8b, $99, $9c, $52, $10, $94, $71, $91, $71, $63, $69
	byte	$46, $6c, $79, $6b, $40, $6c, $b7, $6b, $f7, $6b, $b1, $6b, $f1, $6b, $ef, $6b
	byte	$ec, $6b, $a5, $6b, $a2, $6b, $9f, $6b, $9d, $6b, $9a, $6b, $97, $6b, $0d, $6b
	byte	$c8, $6a, $e4, $76, $20, $4b, $f9, $ce, $2e, $8a, $1a, $92, $46, $95, $b5, $93
	byte	$fb, $93, $ba, $93, $01, $94, $03, $94, $4a, $94, $09, $94, $0c, $94, $0e, $94
	byte	$55, $94, $14, $94, $9e, $94, $1a, $94, $61, $94, $20, $94, $fa, $95, $5b, $93
	byte	$3e, $87, $e5, $cd, $5f, $50, $6c, $78, $b5, $6a, $04, $6c, $45, $6c, $85, $6c
	byte	$83, $6c, $7f, $6c, $7c, $6c, $36, $6c, $76, $6c, $74, $6c, $71, $6c, $6f, $6c
	byte	$6b, $6c, $25, $6c, $66, $6c, $1f, $6c, $1d, $6c, $41, $6a, $ff, $73, $48, $66
	byte	$ba, $fa, $fc, $94, $5b, $8d, $97, $96, $3b, $94, $c5, $94, $40, $94, $ca, $94
	byte	$89, $94, $8c, $94, $8f, $94, $92, $94, $94, $94, $db, $94, $9b, $94, $e1, $94
	byte	$e4, $94, $e7, $94, $2d, $95, $74, $95, $c8, $96, $15, $89, $e4, $ab, $5c, $29
	byte	$cb, $75, $31, $6f, $7e, $6b, $10, $6d, $c9, $6c, $0a, $6d, $c3, $6c, $05, $6d
	byte	$bd, $6c, $ff, $6c, $fb, $6c, $f9, $6c, $b2, $6c, $f3, $6c, $ac, $6c, $ed, $6c
	byte	$a7, $6c, $e8, $6c, $0d, $6b, $85, $6f, $c7, $74, $10, $28, $2e, $ac, $21, $89
	byte	$96, $96, $47, $95, $06, $95, $0a, $95, $0c, $95, $0f, $95, $12, $95, $14, $95
	byte	$17, $95, $5e, $95, $61, $95, $63, $95, $22, $95, $ac, $95, $28, $95, $b1, $95
	byte	$72, $95, $17, $98, $59, $8e, $01, $96, $cf, $fc, $5a, $68, $fe, $74, $7e, $6b
	byte	$96, $6d, $50, $6d, $d5, $6d, $4a, $6d, $8c, $6d, $89, $6d, $85, $6d, $82, $6d
	byte	$80, $6d, $3a, $6d, $7a, $6d, $77, $6d, $75, $6d, $71, $6d, $2b, $6d, $e5, $6c
	byte	$18, $6c, $bc, $78, $9a, $4f, $7e, $cf, $1f, $89, $f1, $93, $1e, $97, $48, $95
	byte	$d2, $95, $4e, $95, $d7, $95, $53, $95, $dd, $95, $e0, $95, $e3, $95, $e5, $95
	byte	$a5, $95, $eb, $95, $ee, $95, $f0, $95, $37, $96, $b3, $95, $3c, $96, $3f, $96
	byte	$1a, $98, $d5, $8d, $c5, $9f, $cd, $0f, $0f, $71, $f3, $73, $c3, $6b, $63, $6e
	byte	$d9, $6d, $5e, $6e, $d3, $6d, $58, $6e, $12, $6e, $0f, $6e, $0c, $6e, $08, $6e
	byte	$49, $6e, $bf, $6d, $87, $6e, $76, $6d, $81, $6e, $11, $6b, $48, $74, $01, $74
	byte	$3f, $09, $44, $95, $e5, $8d, $3f, $99, $d4, $95, $a2, $96, $da, $95, $64, $96
	byte	$23, $96, $69, $96, $6b, $96, $6e, $96, $71, $96, $74, $96, $77, $96, $7a, $96
	byte	$bf, $96, $3c, $96, $c6, $96, $c8, $96, $a3, $98, $51, $8d, $51, $a5, $ee, $1b
	byte	$cf, $75, $29, $73, $90, $6c, $ec, $6e, $62, $6e, $e7, $6e, $5c, $6e, $e0, $6e
	byte	$9a, $6e, $98, $6e, $95, $6e, $91, $6e, $8e, $6e, $cf, $6e, $45, $6e, $c9, $6e
	byte	$40, $6e, $c3, $6e, $e8, $6c, $45, $6f, $a5, $7b, $c9, $35, $4e, $b3, $76, $8a
	byte	$2d, $98, $23, $97, $e1, $96, $a0, $96, $a4, $96, $ea, $96, $a9, $96, $ef, $96
	byte	$af, $96, $f4, $96, $f8, $96, $3e, $97, $fd, $96, $43, $97, $bf, $96, $8c, $97
	byte	$08, $97, $6b, $99, $d6, $92, $88, $91, $d8, $ee, $84, $66, $be, $79, $8e, $6c
	byte	$2e, $6f, $e7, $6e, $6c, $6f, $24, $6f, $21, $6f, $1f, $6f, $1c, $6f, $1a, $6f
	byte	$17, $6f, $13, $6f, $54, $6f, $0e, $6f, $0b, $6f, $4b, $6f, $c0, $6e, $bf, $6e
	byte	$27, $6d, $1c, $7b, $19, $59, $9f, $db, $66, $8e, $bc, $94, $b3, $98, $20, $97
	byte	$67, $97, $26, $97, $6d, $97, $2b, $97, $72, $97, $32, $97, $78, $97, $7a, $97
	byte	$c1, $97, $7f, $97, $c6, $97, $85, $97, $cb, $97, $ce, $97, $df, $98, $17, $98
	byte	$ec, $8a, $c4, $c6, $68, $4c, $f4, $7d, $63, $6e, $e8, $6e, $b0, $6f, $ac, $6f
	byte	$ed, $6f, $a7, $6f, $e7, $6f, $a0, $6f, $e1, $6f, $9b, $6f, $97, $6f, $94, $6f
	byte	$d5, $6f, $8f, $6f, $ce, $6f, $45, $6f, $86, $6f, $68, $6d, $09, $75, $dc, $71
	byte	$c0, $13, $ad, $a2, $a7, $8e, $79, $99, $e6, $97, $e8, $97, $a8, $97, $ee, $97
	byte	$f1, $97, $f3, $97, $f6, $97, $f9, $97, $fb, $97, $fe, $97, $01, $98, $04, $98
	byte	$4a, $98, $0a, $98, $93, $98, $0f, $98, $7f, $9b, $bf, $8c, $d8, $a1, $6d, $21
	byte	$91, $7b, $62, $73, $1a, $6e, $b9, $70, $eb, $6f, $b3, $70, $e6, $6f, $6a, $70
	byte	$25, $70, $20, $70, $1e, $70, $1b, $70, $18, $70, $15, $70, $12, $70, $0f, $70
	byte	$0d, $70, $09, $70, $07, $70, $03, $70, $01, $70, $fd, $6f, $fa, $6f, $f7, $6f
	byte	$f6, $6f, $f2, $6f, $ef, $6f, $ec, $6f, $2c, $70, $e6, $6f, $27, $70, $9d, $6f
	byte	$dd, $6f, $97, $6f, $d7, $6f, $84, $6e, $8f, $6f, $3f, $7d, $b7, $3d
'-' atarist_spl file "atarist.spl" '512
	byte	$ff[6]
	byte	$00[10]
	byte	$17, $7f, $f2, $7f, $b2, $7f, $72, $7f, $33, $7f, $f4, $7e, $b4, $7e, $75, $7e
	byte	$36, $7e, $f5, $7d, $e9, $51, $f2, $0d, $8e, $00, $f3, $fd, $72, $fd, $5a, $fd
	byte	$57, $fd, $58, $fd, $5b, $fd, $5c, $fd, $5c, $fd, $60, $7d, $52, $7d, $14, $7d
	byte	$d6, $7c, $98, $7c, $59, $7c, $1a, $7c, $dc, $7b, $9e, $7b, $61, $7b, $72, $34
	byte	$f3, $05, $00, $fd, $41, $fb, $ea, $fa, $d9, $fa, $db, $fa, $de, $fa, $e1, $fa
	byte	$e4, $fa, $9b, $36, $f8, $7a, $c0, $7a, $84, $7a, $45, $7a, $08, $7a, $cd, $79
	byte	$8e, $79, $51, $79, $15, $79, $d7, $78, $3c, $1f, $eb, $ff, $cf, $f9, $a5, $f8
	byte	$6d, $f8, $65, $f8, $68, $f8, $6d, $f8, $70, $f8, $74, $f8, $84, $57, $db, $60
	byte	$ab, $60, $79, $60, $4b, $60, $1a, $60, $e9, $5f, $b9, $5f, $89, $5f, $5a, $5f
	byte	$fb, $59, $b2, $0b, $92, $fa, $3a, $f7, $96, $f6, $79, $f6, $79, $f6, $7c, $f6
	byte	$82, $f6, $86, $f6, $8c, $f6, $db, $5d, $f1, $5e, $c1, $5e, $92, $5e, $63, $5e
	byte	$34, $5e, $04, $5e, $d6, $5d, $a6, $5d, $78, $5d, $d4, $3e, $11, $03, $63, $f7
	byte	$27, $f5, $ba, $f4, $ab, $f4, $ad, $f4, $b2, $f4, $b8, $f4, $be, $f4, $c3, $f4
	byte	$26, $5d, $2b, $5d, $fc, $5c, $cd, $5c, $9f, $5c, $70, $5c, $42, $5c, $15, $5c
	byte	$e5, $5b, $b8, $5b, $db, $24, $a7, $fc, $d1, $f4, $4d, $f3, $05, $f3, $fd, $f2
	byte	$04, $f3, $0b, $f3, $11, $f3, $16, $f3, $de, $18, $98, $5b, $73, $5b, $99, $54
	byte	$4e, $4a, $29, $48, $a0, $47, $6a, $47, $43, $47, $20, $47, $fd, $46, $35, $0d
	byte	$e2, $f6, $98, $f2, $c5, $f1, $a3, $f1, $a3, $f1, $a8, $f1, $b0, $f1, $b8, $f1
	byte	$bf, $f1, $00, $3d, $ef, $46, $cd, $46, $aa, $46, $86, $46, $63, $46, $3f, $46
	byte	$1c, $46, $f9, $45, $d7, $45, $ee, $43, $de, $02, $e8, $f3, $01, $f1, $76, $f0
	byte	$61, $f0, $65, $f0, $6d, $f0, $74, $f0, $7c, $f0, $84, $f0, $39, $44, $b1, $45
	byte	$8e, $45, $6d, $45, $49, $45, $27, $45, $05, $45, $e1, $44, $bf, $44, $9d, $44
	byte	$f1, $2f, $a9, $fb, $8b, $f1, $9b, $ef, $40, $ef, $36, $ef, $3d, $ef, $46, $ef
	byte	$4d, $ef, $56, $ef, $5e, $ef, $7b, $44, $8c, $44, $69, $44, $47, $44, $26, $44
	byte	$03, $44, $e1, $43, $c0, $43, $f5, $37, $69, $33, $0f, $11, $f0, $f4, $70, $ef
	byte	$66, $ee, $37, $ee, $38, $ee, $40, $ee, $48, $ee, $51, $ee, $5b, $ee, $18, $01
	byte	$7d, $32, $6a, $32, $51, $32, $37, $32, $1f, $32, $05, $32, $eb, $31, $d2, $31
	byte	$b9, $31, $a1, $31, $f1, $04, $f4, $f1, $50, $ee, $a0, $ed, $85, $ed, $88, $ed
	byte	$93, $ed, $9a, $ed, $a4, $ed, $ad, $ed, $f4, $27, $c1, $31, $a9, $31, $90, $31
	byte	$78, $31, $5f, $31, $46, $31, $2e, $31, $15, $31, $fc, $30, $e4, $30, $9b, $fc
	byte	$c4, $ef, $4a, $ed, $dc, $ec, $cb, $ec, $d2, $ec, $da, $ec, $e6, $ec, $ef, $ec
	byte	$f9, $ec, $64, $2f, $0a, $31, $f1, $30, $d9, $30, $c0, $30, $a7, $30, $91, $30
	byte	$78, $30, $5f, $30, $46, $30, $38, $23, $a6, $f6, $19, $ee, $70, $ec, $25, $ec
	byte	$20, $ec, $28, $ec, $32, $ec, $3c, $ec, $47, $ec, $51, $ec, $93, $22, $b5, $22
	byte	$a3, $22, $93, $22, $7f, $22, $6e, $22, $5d, $22, $4c, $22, $3c, $22, $2b, $22
	byte	$77, $09, $76, $f1, $cc, $ec, $f0, $eb, $cd, $eb, $ce, $eb, $d7, $eb, $e3, $eb
	byte	$ed, $eb, $f5, $eb, $3e, $f6, $6b, $22, $5f, $22, $4e, $22, $3d, $22, $2c, $22
	byte	$1b, $22, $0b, $22, $fa, $21, $e9, $21, $d8, $21, $4d, $ff, $44, $ef, $25, $ec
	byte	$92, $eb, $7b, $eb, $82, $eb, $8c, $eb, $97, $eb, $a1, $eb, $ab, $eb, $2e, $16
	byte	$15, $22, $04, $22, $f3, $21, $e3, $21, $d2, $21, $c0, $21, $af, $21, $9e, $21
	byte	$8e, $21, $7d, $21, $9a, $f8, $a4, $ed, $8e, $eb, $2f, $eb, $24, $eb, $2d, $eb
	byte	$37, $eb, $42, $eb, $4c, $eb, $57, $eb, $b2, $17, $22, $19, $15, $19, $0a, $19
	byte	$fd, $18, $ef, $18, $e3, $18, $d6, $18, $ca, $18, $bd, $18, $49, $12, $92, $f2
	byte	$60, $ec, $35, $eb, $01, $eb, $01, $eb, $0c, $eb, $16, $eb, $20, $eb, $2b, $eb
	byte	$34, $eb, $d0, $18, $00, $19, $f4, $18, $e8, $18, $da, $18, $cf, $18, $c2, $18
	byte	$b6, $18, $a9, $18, $9d, $18, $91, $05, $f0, $ef, $ca, $eb, $02, $eb, $e6, $ea
	byte	$e8, $ea, $f2, $ea, $fe, $ea, $07, $eb, $12, $eb, $c2, $ef, $e9, $18, $e6, $18
	byte	$d9, $18, $cd, $18, $c0, $18, $b3, $18, $a7, $18, $9b, $18, $8e, $18, $83, $18
	byte	$b8, $fc, $30, $ee, $61, $eb, $dc, $ea, $cd, $ea, $d2, $ea, $de, $ea, $e7, $ea
	byte	$f3, $ea, $fe, $ea, $d2, $09, $d1, $18, $c3, $18, $17, $18, $c7, $12, $a5, $11
	byte	$66, $11, $52, $11, $49, $11, $41, $11, $38, $11, $e0, $f4, $a5, $ec, $13, $eb
	byte	$c9, $ea, $c5, $ea, $cf, $ea, $db, $ea, $e6, $ea, $ef, $ea, $fb, $ea, $0e, $10
	byte	$89, $11, $80, $11, $78, $11, $6e, $11, $67, $11, $5d, $11, $54, $11, $4c, $11
	byte	$43, $11, $32, $0d, $9c, $f1, $07, $ec, $f8, $ea, $cd, $ea, $cc, $ea, $d8, $ea
	byte	$e4, $ea, $ed, $ea, $f8, $ea, $02, $eb, $55, $11, $91, $11, $89, $11, $80, $11
	byte	$75, $11, $6e, $11, $64, $11, $5e, $11, $54, $11, $4a, $11, $bc, $02, $5e, $ef
	byte	$a8, $eb, $f1, $ea, $d9, $ea, $dc, $ea, $e8, $ea, $f1, $ea, $fc, $ea, $06, $eb
	byte	$a6, $eb, $9e, $11, $a0, $11, $96, $11, $8d, $11, $85, $11, $7b, $11, $72, $11
	byte	$6a, $11, $ca, $0d, $36, $0b, $57, $f8, $6c, $ed, $57, $eb, $f8, $ea, $ee, $ea
	byte	$f4, $ea, $ff, $ea, $09, $eb, $15, $eb, $1e, $eb, $1a, $fd, $f9, $0a, $f2, $0a
	byte	$ed, $0a, $e8, $0a, $e2, $0a, $dc, $0a, $d6, $0a, $d1, $0a, $cd, $0a, $c7, $0a
	byte	$f8, $f3, $bc, $ec, $57, $eb, $1e, $eb, $18, $eb, $24, $eb, $2d, $eb, $39, $eb
	byte	$42, $eb, $4d, $eb, $08, $09, $20, $0b, $1a, $0b, $14, $0b, $0f, $0b, $09, $0b
	byte	$04, $0b, $fe, $0a, $f9, $0a, $f2, $0a, $84, $08, $3a, $f1, $4f, $ec, $66, $eb
	byte	$42, $eb, $42, $eb, $4e, $eb, $57, $eb, $62, $eb, $6b, $eb, $77, $eb, $06, $0b
	byte	$48, $0b, $43, $0b, $3c, $0b, $36, $0b, $31, $0b, $2c, $0b, $26, $0b, $20, $0b
	byte	$1b, $0b, $5c, $00, $6a, $ef, $1b, $ec, $81, $eb, $6a, $eb, $6f, $eb, $79, $eb
	byte	$85, $eb, $8e, $eb, $99, $eb, $a3, $eb, $dd, $05, $e5, $05, $e1, $05, $df, $05
	byte	$db, $05, $d8, $05, $d5, $05, $d1, $05, $d0, $05, $cb, $05, $63, $f7, $da, $ed
	byte	$0c, $ec, $bb, $eb, $b3, $eb, $bb, $eb, $c5, $eb, $d0, $eb, $d9, $eb, $e3, $eb
	byte	$e4, $f7, $2c, $06, $28, $06, $24, $06, $22, $06, $1f, $06, $1c, $06, $1a, $06
	byte	$16, $06, $14, $06, $0f, $06, $d0, $f3, $65, $ed, $2d, $ec, $f9, $eb, $f6, $eb
	byte	$01, $ec, $0a, $ec, $14, $ec, $1e, $ec, $29, $ec, $fb, $03, $6a, $06, $67, $06
	byte	$63, $06, $60, $06, $5e, $06, $59, $06, $58, $06, $54, $06, $50, $06, $12, $05
	byte	$69, $f1, $21, $ed, $55, $ec, $33, $ec, $36, $ec, $40, $ec, $49, $ec, $53, $ec
	byte	$5c, $ec, $68, $ec, $92, $02, $d9, $02, $d7, $02, $d7, $02, $d5, $02, $d3, $02
	byte	$d1, $02, $d1, $02, $ce, $02, $cd, $02, $5d, $fc, $80, $ef, $07, $ed, $90, $ec
	byte	$83, $ec, $8a, $ec, $93, $ec, $9c, $ec, $a5, $ec, $b1, $ec, $ba, $ec, $24, $03
	byte	$2b, $03, $2a, $03, $29, $03, $26, $03, $25, $03, $24, $03, $22, $03, $20, $03
	byte	$1f, $03, $70, $f7, $d0, $ee, $27, $ed, $db, $ec, $d4, $ec, $dd, $ec, $e7, $ec
	byte	$f0, $ec, $fa, $ec, $02, $ed, $f9, $f4, $7b, $03, $7c, $03, $7a, $03, $78, $03
	byte	$75, $03, $73, $03, $72, $03, $70, $03, $6d, $03, $6c, $03, $4f, $f4, $70, $ee
	byte	$54, $ed, $22, $ed, $22, $ed, $2c, $ed, $35, $ed, $3f, $ed, $48, $ed, $52, $ed
	byte	$14, $01, $c3, $03, $c1, $03, $c0, $03, $5f, $01, $a5, $00, $82, $00, $7b, $00
	byte	$7b, $00, $7c, $00, $20, $00, $85, $f1, $2a, $ee, $89, $ed, $73, $ed, $76, $ed
	byte	$80, $ed, $87, $ed, $90, $ed, $9a, $ed, $a3, $ed, $73, $00, $d2, $00, $d2, $00
	byte	$d0, $00, $d0, $00, $d0, $00, $d0, $00, $d0, $00, $cf, $00, $ce, $00, $48, $fc
	byte	$80, $f0, $3d, $ee, $d5, $ed, $c7, $ed, $cd, $ed, $d6, $ed, $df, $ed, $e9, $ed
	byte	$f2, $ed, $fa, $ed, $1d, $01, $29, $01, $27, $01, $27, $01, $27, $01, $25, $01
	byte	$25, $01, $26, $01, $26, $01, $23, $01, $d0, $f7, $ec, $ef, $65, $ee, $23, $ee
	byte	$1c, $ee, $24, $ee, $2d, $ee, $37, $ee, $40, $ee, $47, $ee, $6e, $f3, $7a, $01
	byte	$7d, $01, $7b, $01, $7a, $01, $7a, $01, $79, $01, $78, $01, $79, $01, $62, $00
	byte	$84, $fe, $de, $f3, $6c, $ef, $93, $ee, $72, $ee, $72, $ee, $7a, $ee, $85, $ee
	byte	$8b, $ee, $95, $ee, $9e, $ee, $15, $fc, $67, $fe, $67, $fe, $69, $fe, $69, $fe
	byte	$6b, $fe, $6b, $fe, $6d, $fe, $6d, $fe, $6d, $fe, $6f, $fe, $63, $f2, $6d, $ef
	byte	$df, $ee, $cc, $ee, $cf, $ee, $d9, $ee, $e1, $ee, $ea, $ee, $f2, $ee, $fc, $ee
	byte	$5a, $fe, $c4, $fe, $c3, $fe, $c5, $fe, $c6, $fe, $c6, $fe, $c6, $fe, $c7, $fe
	byte	$c8, $fe, $c7, $fe, $da, $fb, $85, $f1, $8d, $ef, $31, $ef, $25, $ef, $2d, $ef
	byte	$34, $ef, $3e, $ef, $46, $ef, $4f, $ef, $57, $ef, $0d, $ff, $1f, $ff, $1f, $ff
	byte	$1f, $ff, $1f, $ff, $21, $ff, $21, $ff, $21, $ff, $21, $ff, $23, $ff, $10, $f8
	byte	$15, $f1, $be, $ef, $84, $ef, $7e, $ef, $88, $ef, $8f, $ef, $97, $ef, $a0, $ef
	byte	$a9, $ef, $06, $f2, $a6, $fc, $ab, $fc, $ad, $fc, $ae, $fc, $b0, $fc, $b2, $fc
	byte	$b2, $fc, $b4, $fc, $b6, $fc, $b7, $fc, $8b, $f4, $bd, $f0, $01, $f0, $e3, $ef
	byte	$e4, $ef, $ee, $ef, $f6, $ef, $fd, $ef, $04, $f0, $0e, $f0, $11, $fa, $09, $fd
	byte	$0b, $fd, $0d, $fd, $0f, $fd, $11, $fd, $11, $fd, $13, $fd, $14, $fd, $17, $fd
	byte	$17, $fd, $64, $f3, $cd, $f0, $52, $f0, $41, $f0, $45, $f0, $4c, $f0, $55, $f0
	byte	$5b, $f0, $64, $f0, $6d, $f0, $fb, $fc, $65, $fd, $68, $fd, $69, $fd, $6c, $fd
	byte	$6c, $fd, $6d, $fd, $6f, $fd, $70, $fd, $72, $fd, $b3, $fb, $b1, $f2, $f4, $f0
	byte	$a4, $f0, $99, $f0, $a0, $f0, $a8, $f0, $ae, $f0, $b9, $f0, $c1, $f0, $c8, $f0
	byte	$cb, $fb, $dd, $fb, $de, $fb, $e0, $fb, $e3, $fb, $e3, $fb, $e5, $fb, $e8, $fb
	byte	$e9, $fb, $ec, $fb, $62, $f7, $27, $f2, $2a, $f1, $ff, $f0, $fd, $f0, $05, $f1
	byte	$0c, $f1, $13, $f1, $1b, $f1, $23, $f1, $33, $f2, $3c, $fc, $3e, $fc, $40, $fc
	byte	$42, $fc, $45, $fc, $47, $fc, $48, $fc, $4a, $fc, $4c, $fc, $4e, $fc, $a5, $f5
	byte	$20, $f2, $77, $f1, $5c, $f1, $5f, $f1, $64, $f1, $6c, $f1, $73, $f1, $7c, $f1
	byte	$83, $f1, $dc, $f8, $9a, $fc, $9a, $fc, $9b, $fc, $9e, $fc, $9f, $fc, $a1, $fc
	byte	$a3, $fc, $a4, $fc, $a6, $fc, $a9, $fc, $90, $f4, $33, $f2, $c5, $f1, $b6, $f1
	byte	$ba, $f1, $bf, $f1, $c7, $f1, $ce, $f1, $d6, $f1, $dc, $f1, $79, $fc, $f0, $fc
	byte	$f3, $fc, $f5, $fc, $fe, $fb, $79, $fb, $62, $fb, $5f, $fb, $61, $fb, $63, $fb
	byte	$6f, $fa, $af, $f3, $53, $f2, $12, $f2, $0f, $f2, $15, $f2, $1d, $f2, $24, $f2
	byte	$2a, $f2, $32, $f2, $38, $f2, $9a, $fb, $af, $fb, $b1, $fb, $b3, $fb, $b4, $fb
	byte	$b7, $fb, $b8, $fb, $ba, $fb, $bc, $fb, $c1, $fb, $3b, $f8, $7e, $f3, $96, $f2
	byte	$6e, $f2, $6c, $f2, $74, $f2, $7a, $f2, $81, $f2, $87, $f2, $8e, $f2, $a7, $f2
	byte	$06, $fc, $09, $fc, $0c, $fc, $0e, $fc, $0f, $fc, $12, $fc, $13, $fc, $16, $fc
	byte	$17, $fc, $1a, $fc, $b2, $f6, $7b, $f3, $dd, $f2, $c5, $f2, $c7, $f2, $cf, $f2
	byte	$d4, $f2, $db, $f2, $e0, $f2, $e8, $f2, $28, $f8, $60, $fc, $61, $fc, $62, $fc
	byte	$64, $fc, $66, $fc, $68, $fc, $6a, $fc, $6d, $fc, $52, $fc, $19, $fb, $4a, $f5
	byte	$78, $f3, $24, $f3, $1a, $f3, $1e, $f3, $24, $f3, $2a, $f3, $31, $f3, $38, $f3
	byte	$3d, $f3, $80, $fa, $0c, $fb, $0f, $fb, $10, $fb, $14, $fb, $15, $fb, $17, $fb
	byte	$1b, $fb, $1d, $fb, $1f, $fb, $92, $fa, $de, $f4, $ae, $f3, $79, $f3, $72, $f3
	byte	$79, $f3, $7e, $f3, $84, $f3, $8c, $f3, $92, $f3, $97, $f3, $52, $fb, $65, $fb
	byte	$67, $fb, $69, $fb, $6b, $fb, $6f, $fb, $71, $fb, $72, $fb, $74, $fb, $76, $fb
	byte	$e3, $f8, $ba, $f4, $ee, $f3, $cc, $f3, $ca, $f3, $cf, $f3, $d5, $f3, $dd, $f3
	byte	$e2, $f3, $e8, $f3, $ed, $f3, $b7, $fb, $bc, $fb, $be, $fb, $c0, $fb, $c1, $fb
	byte	$c4, $fb, $c6, $fb, $c8, $fb, $c9, $fb, $cc, $fb, $8f, $f7, $b9, $f4, $33, $f4
	byte	$1e, $f4, $1e, $f4, $24, $f4, $2a, $f4, $30, $f4, $38, $f4, $3e, $f4, $1f, $f7
	byte	$ad, $fa, $b1, $fa, $b4, $fa, $b6, $fa, $ba, $fa, $bb, $fa, $be, $fa, $c1, $fa
	byte	$c2, $fa, $c6, $fa, $55, $f6, $c6, $f4, $7d, $f4, $72, $f4, $78, $f4, $7e, $f4
	byte	$83, $f4, $89, $f4, $8f, $f4, $94, $f4, $66, $fa, $03, $fb, $07, $fb, $08, $fb
	byte	$0a, $fb, $0e, $fb, $10, $fb, $11, $fb, $16, $fb, $18, $fb, $d0, $fa, $02, $f6
	byte	$f9, $f4, $ca, $f4, $c5, $f4, $cb, $f4, $d1, $f4, $d7, $f4, $dc, $f4, $e1, $f4
	byte	$e8, $f4, $3f, $fb, $56, $fb, $58, $fb, $5a, $fb, $5e, $fb, $5f, $fb, $61, $fb
	byte	$64, $fb, $64, $fb, $69, $fb, $99, $f9, $e9, $f5, $33, $f5, $17, $f5, $17, $f5
	byte	$1d, $f5, $22, $f5, $27, $f5, $2e, $f5, $32, $f5, $37, $f5, $b3, $fa, $b6, $fa
	byte	$bc, $fa, $bc, $fa, $c1, $fa, $c2, $fa, $c4, $fa, $c8, $fa, $ca, $fa, $ce, $fa
	byte	$f9, $f7, $db, $f5, $78, $f5, $69, $f5, $6a, $f5, $70, $f5, $75, $f5, $7b, $f5
	byte	$7f, $f5, $85, $f5, $6e, $f7, $06, $fb, $0a, $fb, $0b, $fb, $0d, $fb, $12, $fb
	byte	$14, $fb, $15, $fb, $18, $fb, $1b, $fb, $1d, $fb, $70, $f7, $01, $f6, $c0, $f5
	byte	$b6, $f5, $bb, $f5, $c0, $f5, $c6, $f5, $ca, $f5, $cf, $f5, $d4, $f5, $a8, $fa
	byte	$54, $fb, $56, $fb, $5a, $fb, $5b, $fb, $5e, $fb, $5f, $fb, $63, $fb, $65, $fb
	byte	$67, $fb, $52, $fb, $29, $f7, $33, $f6, $06, $f6, $02, $f6, $08, $f6, $0b, $f6
	byte	$10, $f6, $16, $f6, $1a, $f6, $1f, $f6, $81, $fb, $9f, $fb, $a2, $fb, $a4, $fb
	byte	$51, $fb, $f2, $fa, $e3, $fa, $e3, $fa, $e5, $fa, $e9, $fa, $d2, $f9, $f0, $f6
	byte	$64, $f6, $4d, $f6, $4d, $f6, $53, $f6, $57, $f6, $5c, $f6, $60, $f6, $66, $f6
	byte	$6a, $f6, $19, $fb, $1e, $fb, $22, $fb, $23, $fb, $24, $fb, $26, $fb, $2a, $fb
	byte	$2c, $fb, $2e, $fb, $32, $fb, $f0, $f8, $01, $f7, $a5, $f6, $98, $f6, $9a, $f6
	byte	$9f, $f6, $a3, $f6, $a6, $f6, $ac, $f6, $b0, $f6, $eb, $f7, $65, $fb, $68, $fb
	byte	$68, $fb, $6c, $fb, $6e, $fb, $71, $fb, $72, $fb, $74, $fb, $78, $fb, $7a, $fb
	byte	$71, $f8, $21, $f7, $e5, $f6, $dd, $f6, $e1, $f6, $e6, $f6, $ea, $f6, $ef, $f6
	byte	$f5, $f6, $f7, $f6, $f7, $fa, $ab, $fb, $ad, $fb, $af, $fb, $b0, $fb, $b5, $fb
	byte	$b6, $fb, $b9, $fb, $bb, $fb, $bc, $fb, $21, $fb, $07, $f8, $46, $f7, $23, $f7
	byte	$22, $f7, $26, $f7, $2b, $f7, $2e, $f7, $34, $f7, $38, $f7, $3c, $f7, $f7, $fa
	byte	$13, $fb, $16, $fb, $17, $fb, $1b, $fb, $1e, $fb, $20, $fb, $23, $fb, $25, $fb
	byte	$26, $fb, $77, $fa, $f3, $f7, $7c, $f7, $67, $f7, $6a, $f7, $6d, $f7, $70, $f7
	byte	$74, $f7, $7a, $f7, $7e, $f7, $82, $f7, $53, $fb, $5a, $fb, $5b, $fb, $5d, $fb
	byte	$5f, $fb, $63, $fb, $65, $fb, $67, $fb, $69, $fb, $6a, $fb, $b9, $f9, $03, $f8
	byte	$b5, $f7, $a9, $f7, $ad, $f7, $b0, $f7, $b5, $f7, $b8, $f7, $be, $f7, $c3, $f7
	byte	$6e, $f8, $99, $fb, $9c, $fb, $9d, $fb, $9f, $fb, $a4, $fb, $a5, $fb, $a8, $fb
	byte	$a9, $fb, $ab, $fb, $ad, $fb, $46, $f9, $26, $f8, $f0, $f7, $ea, $f7, $f0, $f7
	byte	$f4, $f7, $f8, $f7, $fb, $f7, $ff, $f7, $03, $f8, $65, $fa, $26, $fb, $29, $fb
	byte	$2b, $fb, $2f, $fb, $30, $fb, $32, $fb, $34, $fb, $38, $fb, $39, $fb, $3b, $fb
	byte	$e9, $f8, $4a, $f8, $2e, $f8, $2c, $f8, $2f, $f8, $36, $f8, $3a, $f8, $3e, $f8
	byte	$41, $f8, $44, $f8, $4a, $fb, $67, $fb, $68, $fb, $6b, $fb, $6f, $fb, $70, $fb
	byte	$73, $fb, $74, $fb, $78, $fb, $7a, $fb, $14, $fb, $e7, $f8, $7d, $f8, $6d, $f8
	byte	$6d, $f8, $70, $f8, $73, $f8, $78, $f8, $7c, $f8, $80, $f8, $84, $f8, $9f, $fb
	byte	$a6, $fb, $a7, $fb, $a9, $fb, $ac, $fb, $af, $fb, $b1, $fb, $b3, $fb, $b4, $fb
	byte	$b7, $fb, $73, $fa, $f8, $f8, $b4, $f8, $a9, $f8, $ab, $f8, $af, $f8, $b1, $f8
	byte	$b4, $f8, $b8, $f8, $bb, $f8, $fa, $f8, $64, $fb, $65, $fb, $67, $fb, $6b, $fb
	byte	$6d, $fb, $6f, $fb, $70, $fb, $74, $fb, $77, $fb, $77, $fb, $e4, $f9, $0f, $f9
	byte	$e9, $f8, $e4, $f8, $e8, $f8, $eb, $f8, $ee, $f8, $f2, $f8, $f7, $f8, $fb, $f8
	byte	$b5, $fa, $9f, $fb, $a1, $fb, $a4, $fb, $a5, $fb, $a9, $fb, $ab, $fb, $ae, $fb
	byte	$ae, $fb, $b1, $fb, $b2, $fb, $c7, $f9, $39, $f9, $22, $f9, $20, $f9, $22, $f9
	byte	$26, $f9, $2a, $f9, $2e, $f9, $32, $f9, $33, $f9, $ba, $fb, $d8, $fb, $db, $fb
	byte	$de, $fb, $e1, $fb, $e2, $fb, $e4, $fb, $e5, $fb, $e7, $fb, $e9, $fb, $a7, $fb
	byte	$c5, $f9, $67, $f9, $57, $f9, $56, $f9, $5b, $f9, $5f, $f9, $62, $f9, $66, $f9
	byte	$68, $f9, $6c, $f9, $0b, $fc, $11, $fc, $14, $fc, $15, $fc, $07, $fc, $c2, $fb
	byte	$b5, $fb, $b5, $fb, $b6, $fb, $b8, $fb, $e9, $fa, $c8, $f9, $94, $f9, $8d, $f9
	byte	$90, $f9, $94, $f9, $95, $f9, $99, $f9, $9d, $f9, $9f, $f9, $a3, $f9, $dd, $fb
	byte	$de, $fb, $df, $fb, $e2, $fb, $e4, $fb, $e6, $fb, $e8, $fb, $e9, $fb, $ed, $fb
	byte	$ef, $fb, $ac, $fa, $e9, $f9, $c7, $f9, $c3, $f9, $c8, $f9, $ca, $f9, $cc, $f9
	byte	$d0, $f9, $d4, $f9, $d6, $f9, $0e, $fb, $11, $fc, $13, $fc, $16, $fc, $17, $fc
	byte	$19, $fc, $1b, $fc, $1d, $fc, $1e, $fc, $21, $fc, $22, $fc, $8d, $fa, $0f, $fa
	byte	$f7, $f9, $f7, $f9, $fb, $f9, $fe, $f9, $00, $fa, $03, $fa, $07, $fa, $0b, $fa
	byte	$1b, $fc, $45, $fc, $46, $fc, $48, $fc, $4a, $fc, $4b, $fc, $4e, $fc, $50, $fc
	byte	$52, $fc, $54, $fc, $f3, $fb, $82, $fa, $35, $fa, $28, $fa, $2a, $fa, $2d, $fa
	byte	$31, $fa, $32, $fa, $37, $fa, $37, $fa, $3c, $fa, $00, $fc, $06, $fc, $09, $fc
	byte	$09, $fc, $0b, $fc, $0f, $fc, $12, $fc, $12, $fc, $15, $fc, $17, $fc, $84, $fb
	byte	$8d, $fa, $60, $fa, $5b, $fa, $5c, $fa, $60, $fa, $61, $fa, $66, $fa, $67, $fa
	byte	$6c, $fa, $6d, $fa, $37, $fc, $3a, $fc, $3b, $fc, $3d, $fc, $3e, $fc, $41, $fc
	byte	$43, $fc, $44, $fc, $45, $fc, $47, $fc, $51, $fb, $ab, $fa, $8e, $fa, $8b, $fa
	byte	$8e, $fa, $91, $fa, $93, $fa, $95, $fa, $98, $fa, $9b, $fa, $64, $fb, $67, $fc
	byte	$68, $fc, $6a, $fc, $6c, $fc, $6e, $fc, $70, $fc, $72, $fc, $74, $fc, $74, $fc
	byte	$76, $fc, $3b, $fb, $d0, $fa, $bb, $fa, $b9, $fa, $bd, $fa, $bf, $fa, $c2, $fa
	byte	$c4, $fa, $c6, $fa, $ca, $fa, $13, $fc, $3a, $fc, $3a, $fc, $3e, $fc, $3e, $fc
	byte	$41, $fc, $43, $fc, $44, $fc, $47, $fc, $48, $fc, $3c, $fc, $2b, $fb, $f0, $fa
	byte	$e6, $fa, $e8, $fa, $eb, $fa, $ee, $fa, $f0, $fa, $f2, $fa, $f6, $fa, $f7, $fa
	byte	$61, $fc, $66, $fc, $68, $fc, $6b, $fc, $6c, $fc, $6e, $fc, $70, $fc, $72, $fc
	byte	$73, $fc, $75, $fc, $13, $fc, $3f, $fb, $17, $fb, $12, $fb, $16, $fb, $18, $fb
	byte	$1a, $fb, $1d, $fb, $1f, $fb, $20, $fb, $23, $fb, $92, $fc, $94, $fc, $96, $fc
	byte	$96, $fc, $97, $fc, $9a, $fc, $9c, $fc, $9e, $fc, $9f, $fc, $a1, $fc, $e7, $fb
	byte	$5a, $fb, $41, $fb, $3e, $fb, $41, $fb
'-' atari2 file "atari2.s2"
	byte	$73, $32, $00, $04, $00, $00, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $44, $87, $44, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $42, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87
	byte	$44, $87, $44, $87, $43, $87, $44, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$44, $87, $43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87
	byte	$42, $87, $43, $87, $44, $87, $42, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $5c, $87, $ee, $86, $ac, $87, $4c, $7c, $a3, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bd, $78, $bc, $78, $bb, $78, $bd, $78, $bb, $78, $bc, $78
	byte	$bb, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $a0, $78, $4c, $7c, $11, $7a, $29, $89, $5f, $87, $44, $87
	byte	$44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $42, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $ed, $85, $71, $85, $52, $79, $43, $7a, $b9, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $a0, $78, $cf, $7a, $b9, $81, $9d, $80, $5f, $87
	byte	$44, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $5a, $87, $39, $81, $f4, $83, $52, $79
	byte	$a5, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bd, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $8f, $79, $17, $77, $ac, $87
	byte	$09, $85, $47, $87, $43, $87, $43, $87, $42, $87, $42, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $43, $87, $42, $87, $43, $87, $43, $87, $43, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $fd, $85, $2f, $86
	byte	$94, $78, $55, $7a, $b9, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bd, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $2f, $79
	byte	$94, $78, $b3, $84, $36, $84, $4a, $87, $43, $87, $43, $87, $44, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $45, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $44, $87, $44, $87, $43, $87, $43, $87, $44, $87, $43, $87
	byte	$43, $87, $42, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87
	byte	$54, $87, $3c, $82, $36, $83, $52, $79, $c6, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bd, $78, $ed, $78, $1b, $79, $f4, $83, $4d, $83, $4e, $87, $42, $87, $44, $87
	byte	$44, $87, $43, $87, $42, $87, $44, $87, $43, $87, $42, $87, $44, $87, $43, $87
	byte	$43, $87, $54, $87, $26, $82, $b3, $84, $d6, $77, $bb, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bb, $78, $bb, $78, $bb, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $26, $79, $18, $75, $36, $83, $1f, $84, $4a, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $42, $87, $44, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87, $44, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$44, $87, $44, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $19, $87, $7d, $86, $ac, $87, $cb, $7c
	byte	$b1, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bd, $78, $bc, $78, $b7, $78, $3b, $7b, $cf, $7a, $6a, $88
	byte	$96, $86, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$44, $87, $44, $87, $43, $87, $44, $87, $43, $87, $44, $87, $44, $87, $44, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $40, $87, $76, $83
	byte	$36, $83, $cf, $7a, $ab, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bd, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bd, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bd, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bd, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bc, $78, $9f, $78, $52, $79, $b3, $84, $2f, $86, $60, $87, $44, $87, $43, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$44, $87, $44, $87, $5e, $87, $bc, $80, $fb, $80, $94, $78, $a2, $78, $bb, $78
	byte	$bd, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $6b, $79, $d6, $77, $ac, $87, $c6, $84, $48, $87
	byte	$43, $87, $44, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87
	byte	$43, $87, $44, $87, $43, $87, $5c, $87, $e7, $80, $00, $80, $52, $79, $a1, $78
	byte	$bc, $78, $bd, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $a0, $78, $8d, $7b, $11, $7a, $29, $89
	byte	$60, $87, $43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $43, $87
	byte	$44, $87, $43, $87, $43, $87, $43, $87, $44, $87, $73, $86, $0e, $91, $11, $7a
	byte	$51, $7b, $b6, $78, $bc, $78, $bd, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bd, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78, $bb, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $60, $79, $51, $71
	byte	$22, $8c, $af, $84, $48, $87, $43, $87, $44, $87, $43, $87, $44, $87, $44, $87
	byte	$43, $87, $42, $87, $43, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $43, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87, $44, $87
	byte	$43, $87, $43, $87, $43, $87, $43, $87, $44, $87, $43, $87, $44, $87, $c8, $86
	byte	$9f, $8b, $d6, $77, $16, $7c, $b3, $78, $bc, $78, $bb, $78, $bb, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bc, $78, $bb, $78, $bc, $78, $bb, $78, $bb, $78
	byte	$bb, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bd, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bd, $78, $bb, $78, $bc, $78, $bb, $78, $ba, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$a8, $78, $54, $7e, $f4, $83, $17, $82, $50, $87, $43, $87, $43, $87, $43, $87
	byte	$44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $44, $87, $44, $87, $43, $87
	byte	$43, $87, $28, $87, $20, $85, $cf, $7a, $70, $7d, $ad, $78, $bd, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bb, $78, $bb, $78, $bd, $78
	byte	$bb, $78, $b2, $78, $9a, $7c, $cf, $7a, $4a, $87, $0d, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $43, $87, $43, $87, $43, $87, $42, $87
	byte	$44, $87, $43, $87, $28, $87, $51, $85, $11, $7a, $1e, $7d, $af, $78, $bb, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bd, $78, $bb, $78, $bb, $78, $bb, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bd, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bb, $78, $bb, $78, $bb, $78, $bc, $78, $b6, $78, $48, $7d, $78, $82, $f7, $81
	byte	$56, $87, $43, $87, $42, $87, $44, $87, $44, $87, $43, $87, $43, $87, $43, $87
	byte	$43, $87, $44, $87, $43, $87, $44, $87, $4c, $87, $7e, $83, $f4, $83, $47, $78
	byte	$f7, $78, $bc, $78, $bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78
	byte	$bb, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bc, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bb, $78, $bb, $78, $bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78
	byte	$bc, $78, $bc, $78, $bb, $78, $bc, $78, $bc, $78, $bc, $78, $b0, $78, $c1, $7b
'-' atari12 file "atari12.s2"
	byte	$73, $32, $00, $04, $00, $00, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6b
	byte	$00, $6b, $00, $6b, $00, $6b, $00, $6b, $00, $6a, $00, $9d, $00, $9d, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e
	byte	$00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9e, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $6e, $00, $6e
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a1, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6c, $00, $a0, $00, $9f, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $a1
	byte	$00, $a1, $00, $a1, $00, $a1, $00, $a1, $00, $6e, $00, $6e, $00, $6e, $00, $6e
	byte	$00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e
	byte	$00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e
	byte	$00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e, $00, $6e
	byte	$00, $6e, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d, $00, $6d
	byte	$00, $6d, $00, $6d, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $6c
	byte	$00, $6c, $00, $6c, $00, $6c, $00, $6c, $00, $9d, $00, $9f, $00, $9f, $00, $9f
	byte	$00, $9f, $00, $9f, $00, $9f, $00, $9f, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
	byte	$00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0, $00, $a0
'-' mouse  file "mouse2.def"
	byte	$01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0b, $01, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0d, $0c, $0d, $0d, $03, $01, $01, $01, $01, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0d, $0c, $01, $09, $0d, $03, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0d, $0c, $01, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $0c, $01, $00, $00, $01, $0a, $0d, $01, $00, $00, $00, $00, $00, $00, $00
	byte	$00[16]
	byte	$01, $01, $00, $00, $00, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00
	byte	$00[22]
	byte	$01, $0b, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[425]
'-' 
'-'              	org
	byte	$00, $00
'-' loadcog      	cogid   t11              		' get a cogid
	byte	$01, $2c, $60, $fd
'-'                 mul     t11, #12                        ' compute the offset to PSRAM mailbox 
	byte	$0c, $2c, $04, $fa
'-'                 add     mailbox, t11                     ' add offset to find this COG's mailbox
	byte	$16, $2e, $00, $f1
'-' 
'-'                 mov     psramaddr,#0
	byte	$00, $30, $04, $f6
'-' 
'-' p101            mov     buf1,psramaddr			' psramaddr=hubaddr
	byte	$18, $36, $00, $f6
'-'                 mov     buf2,##16384			' loading size
	byte	$20, $00, $00, $ff, $00, $38, $04, $f6
'-'                 mov     cmd,psramaddr                   ' set the address for reading
	byte	$18, $34, $00, $f6
'-'                 setnib  cmd, #%1011, #7                 ' attach the command - read burst
	byte	$0b, $34, $3c, $f8
'-'                 setq    #2			 	' write 3 longs to the mailbox
	byte	$28, $04, $64, $fd
'-'                 wrlong  cmd, mailbox			' read the PSRAM
	byte	$17, $34, $60, $fc
'-' p102            rdlong  cmd, mailbox                	' poll mailbox for result
	byte	$17, $34, $00, $fb
'-'                 tjs     cmd, #p102                 	' retry until valid 
	byte	$fe, $35, $b4, $fb
'-' 
'-'                 add 	psramaddr,##16384
	byte	$20, $00, $00, $ff, $00, $30, $04, $f1
'-' 		cmp 	psramaddr,##$7C000 wcz
	byte	$e0, $03, $00, $ff, $00, $30, $1c, $f2
'-' 	if_lt	jmp 	#p101				' loop until full hub loaded
	byte	$c8, $ff, $9f, $cd
'-' 
'-'                 
'-'                 cogstop #7				' stop psram driver
	byte	$03, $0e, $64, $fd
'-'     
'-'                 cogid 	t11				' get id
	byte	$01, $2c, $60, $fd
'-'                 coginit #0,#0				' start the new program
	byte	$00, $00, $ec, $fc
'-'                 cogstop t11				' stop the loader
	byte	$03, $2c, $60, $fd
'-' 
'-' t11 		long 	0
	byte	$00, $00, $00, $00
'-' mailbox 	long 	$7FF00
	byte	$00, $ff, $07, $00
'-' psramaddr 	long 	0
	byte	$00, $00, $00, $00
'-' pslockval	long 	0
	byte	$00, $00, $00, $00
'-' cmd             long    0
	byte	$00, $00, $00, $00
'-' buf1            long    0
	byte	$00, $00, $00, $00
'-' buf2            long    16384
	byte	$00, $40, $00, $00
	long	@@@_dat_ + 12612
	byte	$50, $32, $20, $52, $65, $74, $72, $6f, $6d, $61, $63, $68, $69, $6e, $65, $20
	byte	$42, $41, $53, $49, $43, $20, $76, $65, $72, $73, $69, $6f, $6e, $20, $30, $2e
	byte	$33, $32, $00, $00
	alignl
_hg010b_spin2_dat_
'-' 
'-' vga_font       file "vgafont.def"
	byte	$00[19]
	byte	$7e, $81, $a5, $81, $81, $bd, $99, $81, $81, $7e, $00, $00, $00, $00, $00, $00
	byte	$7e, $ff, $db, $ff, $ff, $c3, $e7, $ff, $ff, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $7f, $7f, $7f, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $3e, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $3c, $e7, $e7, $e7, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $ff, $ff, $7e, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $3c, $3c, $18, $00, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $ff, $e7, $c3, $c3, $e7, $ff, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$00, $00, $3c, $66, $42, $42, $66, $3c, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $c3, $99, $bd, $bd, $99, $c3, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$78, $70, $58, $4c, $1e, $33, $33, $33, $33, $1e, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$fc, $cc, $fc, $0c, $0c, $0c, $0c, $0e, $0f, $07, $00, $00, $00, $00, $00, $00
	byte	$fe, $c6, $fe, $c6, $c6, $c6, $c6, $e6, $e7, $67, $03, $00, $00, $00, $00, $00
	byte	$18, $18, $db, $3c, $e7, $3c, $db, $18, $18, $00, $00, $00, $00, $00, $00, $01
	byte	$03, $07, $0f, $1f, $7f, $1f, $0f, $07, $03, $01, $00, $00, $00, $00, $00, $40
	byte	$60, $70, $78, $7c, $7f, $7c, $78, $70, $60, $40, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $18, $18, $18, $7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$00, $66, $66, $00, $00, $00, $00, $00, $00, $fe, $db, $db, $db, $de, $d8, $d8
	byte	$d8, $d8, $d8, $00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c
	byte	$30, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $7f, $7f, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $7e
	byte	$3c, $18, $7e, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $18
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $18, $30, $7f, $30, $18
	byte	$00[11]
	byte	$0c, $06, $7f, $06, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $03, $03, $03, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$14, $36, $7f, $36, $14, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $1c, $3e, $3e, $7f, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $3e, $3e, $1c, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[14]
	byte	$18, $3c, $3c, $3c, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $66, $66
	byte	$66, $24, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $18, $18
	byte	$3e, $63, $43, $03, $3e, $60, $60, $61, $63, $3e, $18, $18, $00, $00, $00, $00
	byte	$00, $00, $43, $63, $30, $18, $0c, $06, $63, $61, $00, $00, $00, $00, $00, $00
	byte	$1c, $36, $36, $1c, $6e, $3b, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00
	byte	$0c, $0c, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $30, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f, $00, $00
	byte	$00[16]
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $40, $60, $30, $18, $0c, $06
	byte	$03, $01, $00, $00, $00, $00, $00, $00, $1c, $36, $63, $63, $6b, $6b, $63, $63
	byte	$36, $1c, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18, $18
	byte	$18, $7e, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $30, $18, $0c, $06, $03
	byte	$63, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $60, $3c, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30, $30
	byte	$30, $78, $00, $00, $00, $00, $00, $00, $7f, $03, $03, $03, $3f, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $1c, $06, $03, $03, $3f, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $7f, $63, $60, $60, $30, $18, $0c, $0c
	byte	$0c, $0c, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $3e, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $7e, $60, $60, $60
	byte	$30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $60, $30, $18, $0c, $06, $0c, $18
	byte	$30, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00, $7e, $00
	byte	$00[9]
	byte	$06, $0c, $18, $30, $60, $30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $3e
	byte	$63, $63, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $63, $7b, $7b, $7b, $3b, $03, $3e, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3f
	byte	$66, $66, $66, $3e, $66, $66, $66, $66, $3f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00, $00, $1f
	byte	$36, $66, $66, $66, $66, $66, $66, $36, $1f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $7b, $63, $63, $66, $5c, $00, $00, $00, $00, $00, $00, $63
	byte	$63, $63, $63, $7f, $63, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3c
	byte	$18[8]
	byte	$3c, $00, $00, $00, $00, $00, $00, $78, $30, $30, $30, $30, $30, $33, $33, $33
	byte	$1e, $00, $00, $00, $00, $00, $00, $67, $66, $66, $36, $1e, $1e, $36, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $7f, $6b, $63, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $06, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $6b, $7b
	byte	$3e, $30, $70, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $36, $1c
	byte	$08, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $6b, $6b, $6b, $7f, $77
	byte	$36, $00, $00, $00, $00, $00, $00, $63, $63, $36, $3e, $1c, $1c, $3e, $36, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $01, $03, $07, $0e, $1c, $38, $70, $60
	byte	$40, $00, $00, $00, $00, $00, $00, $3c, $30, $30, $30, $30, $30, $30, $30, $30
	byte	$3c, $00, $00, $00, $1c, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$ff, $00, $00, $0c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $07, $06, $06
	byte	$1e, $36, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $30, $30
	byte	$3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $7f, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $6c, $4c
	byte	$0c, $1e, $0c, $0c, $0c, $0c, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$6e, $33, $33, $33, $33, $33, $3e, $30, $33, $1e, $00, $00, $00, $07, $06, $06
	byte	$36, $6e, $66, $66, $66, $66, $67, $00, $00, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $60, $60, $00
	byte	$70, $60, $60, $60, $60, $60, $60, $66, $66, $3c, $00, $00, $00, $07, $06, $06
	byte	$66, $36, $1e, $1e, $36, $66, $67, $00, $00, $00, $00, $00, $00, $1c, $18, $18
	byte	$18[6]
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $6b, $6b, $6b
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$3e, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $6e, $33, $33, $33, $33, $33
	byte	$3e, $30, $30, $78, $00, $00, $00, $00, $00, $00, $3b, $6e, $66, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36
	byte	$1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $6b, $6b, $6b, $7f
	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $1c, $36
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63
	byte	$7e, $60, $30, $1f, $00, $00, $00, $00, $00, $00, $7f, $33, $18, $0c, $06, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18, $18
	byte	$70, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18, $18
	byte	$0e, $00, $00, $00, $6e, $3b, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[10]
	byte	$08, $1c, $36, $63, $63, $63, $7f, $00, $00, $00, $00, $00, $00, $3c, $66, $43
	byte	$03, $03, $03, $03, $43, $66, $3c, $18, $30, $1e, $00, $00, $00, $00, $33, $00
	byte	$33[6]
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $33, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $1c, $36, $1c, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $18, $30, $1e, $00, $00, $00, $1c, $58, $78, $38, $18, $1c, $1e, $1a, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $66, $33, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $cc, $66, $33, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $18, $3c, $66, $00, $1c, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $63, $00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63
	byte	$63, $00, $00, $00, $30, $18, $00, $3c, $66, $43, $03, $03, $03, $03, $43, $66
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66
	byte	$7f, $00, $00, $00, $0c, $06, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $6f, $46, $26, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $6e, $4c, $2c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$1e, $00, $00, $00, $30, $18, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $6c, $38, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $60, $48, $2c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $0f, $26, $36, $1e, $0e, $07, $07, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36, $63, $00
	byte	$00[6]
	byte	$36, $1c, $08, $00, $3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63, $63, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $1e, $30, $3e, $33, $33, $33, $6e, $18, $0c, $78, $36, $1c
	byte	$00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00
	byte	$00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66, $7f, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $7f, $03, $03, $63, $3e, $18, $0c, $78, $00, $00
	byte	$00, $3c, $66, $03, $1f, $03, $0f, $03, $03, $66, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $6c, $38
	byte	$00, $3c, $66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63, $3e, $18, $30, $1e, $00, $00
	byte	$00[6]
	byte	$6c, $36, $1b, $36, $6c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$1b, $36, $6c, $36, $1b, $00, $00, $00, $88, $22, $88, $22, $88, $22, $88, $22
	byte	$88, $22, $88, $22, $88, $22, $88, $22, $aa, $55, $aa, $55, $aa, $55, $aa, $55
	byte	$aa, $55, $aa, $55, $aa, $55, $aa, $55, $bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee
	byte	$bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18[15]
	byte	$1f, $18, $18, $18, $18, $18, $18, $18, $18, $30, $18, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $1c, $36, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $36, $1c, $00, $7f, $66, $46, $16
	byte	$1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06
	byte	$1c, $30, $60, $63, $63, $3e, $18, $30, $1e, $6c, $6c, $6c, $6c, $6c, $6f, $60
	byte	$6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6c[9]
	byte	$00[5]
	byte	$7f, $60, $6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6f, $60, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $7f, $63
	byte	$61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00, $00, $18, $18
	byte	$00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $63, $3e, $00, $08, $1c
	byte	$36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $63, $3e
	byte	$00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $fc, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$fc, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$63, $3e, $63, $63, $63, $63, $3e, $63, $00, $00, $00, $00, $00, $00, $30, $7e
	byte	$30, $3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $1f, $36
	byte	$66, $66, $6f, $66, $66, $66, $36, $1f, $00, $00, $00, $36, $1c, $00, $1f, $36
	byte	$66[6]
	byte	$36, $1f, $00, $00, $00, $00, $63, $00, $7f, $66, $46, $16, $1e, $16, $06, $46
	byte	$66, $7f, $00, $00, $00, $6c, $38, $00, $38, $30, $30, $3c, $36, $33, $33, $33
	byte	$33, $6e, $00, $00, $00, $36, $1c, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63
	byte	$63, $63, $00, $00, $00, $30, $18, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $3c, $66, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $00, $00, $36, $1c, $08, $00, $3e, $63, $7f, $03, $03
	byte	$63, $3e, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $1f, $00, $00, $00
	byte	$00[12]
	byte	$f8, $18, $18, $18, $18, $18, $18, $18, $18, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	byte	$ff[9]
	byte	$00[7]
	byte	$ff[9]
	byte	$00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18, $3c, $18, $30, $1e
	byte	$1c, $36, $1c, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$ff[7]
	byte	$00[9]
	byte	$30, $18, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $00, $1e, $33, $33, $33, $1b, $33, $63, $63, $63, $33, $00, $00, $00
	byte	$1c, $36, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63, $63, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$36, $1c, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3e, $63, $06, $1c, $30, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00
	byte	$30, $18, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00
	byte	$66, $33, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $63, $63, $63, $63, $63, $63, $7e, $60, $30, $1f
	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18, $3c, $00, $00, $00
	byte	$00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c, $38, $18, $30, $1e
	byte	$30, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $66, $33, $00, $00, $00, $00, $00, $00
	byte	$00[21]
	byte	$0c, $06, $3c, $36, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c, $30, $63, $3e
	byte	$00[8]
	byte	$18, $00, $7e, $00, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $30, $1e, $00, $00, $00, $1c, $36, $36, $1c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[5]
	byte	$cc, $66, $33, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $36, $1c
	byte	$00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $7e, $7e, $7e, $7e, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' 'vga_font       file "vgafont.def"
'-' st_font        file "st4font.def"
	byte	$00[55]
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$18[9]
	byte	$00[7]
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $00, $00, $18, $3c, $7e, $66, $66
	byte	$66, $7e, $7e, $66, $66, $66, $66, $30, $18, $00, $00, $7e, $7e, $06, $06, $3e
	byte	$3e, $06, $06, $06, $06, $7e, $7e, $18, $0c, $30, $18, $3c, $7e, $66, $66, $06
	byte	$06, $06, $06, $66, $66, $7e, $3c, $00, $00, $30, $18, $66, $66, $66, $6e, $6e
	byte	$7e, $7e, $76, $76, $66, $66, $66, $00, $00, $30, $18, $7c, $7e, $06, $06, $0e
	byte	$1c, $38, $70, $60, $60, $7e, $3e, $00, $00, $30, $18, $7e, $7e, $30, $30, $18
	byte	$18, $0c, $0c, $06, $06, $7e, $7e, $00, $00, $18, $18, $00, $7e, $7e, $30, $30
	byte	$18, $18, $0c, $0c, $06, $7e, $7e, $00, $00, $30, $18, $3c, $7e, $66, $66, $66
	byte	$66[5]
	byte	$7e, $3c, $00, $00, $00, $00, $06, $06, $06, $06, $16, $1e, $0e, $06, $06, $06
	byte	$7e, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $7c, $60, $7c, $7e, $66, $66
	byte	$7e, $7c, $30, $18, $00, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $06, $06
	byte	$7e, $7c, $18, $0c, $00, $00, $30, $18, $00, $3c, $3e, $06, $06, $06, $06, $06
	byte	$7e, $7c, $00, $00, $00, $00, $30, $18, $00, $3e, $7e, $66, $66, $66, $66, $66
	byte	$66, $66, $00, $00, $00, $00, $30, $18, $00, $7c, $7e, $06, $0e, $3c, $70, $60
	byte	$7e, $3e, $00, $00, $00, $00, $30, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $18, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $00, $3c, $7e, $66, $66, $66, $66, $66
	byte	$7e, $3c, $00, $00, $00, $00, $1c, $1c, $18, $18, $38, $3c, $1c, $18, $18, $18
	byte	$3c, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[8]
	byte	$00, $00, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $00, $00, $00, $00
	byte	$00[9]
	byte	$66, $66, $ff, $ff, $66, $66, $ff, $ff, $66, $66, $00, $00, $00, $00, $18, $18
	byte	$7c, $7e, $06, $06, $3e, $7c, $60, $60, $7e, $3e, $18, $18, $00, $00, $00, $66
	byte	$66, $30, $30, $18, $18, $0c, $0c, $66, $66, $00, $00, $00, $00, $00, $3c, $7e
	byte	$66, $66, $3c, $1c, $1c, $fc, $fe, $66, $66, $fe, $fc, $00, $00, $00, $00, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $30
	byte	$18, $1c, $0c, $0c, $0c, $0c, $0c, $0c, $1c, $18, $30, $00, $00, $00, $00, $0c
	byte	$18, $38, $30, $30, $30, $30, $30, $30, $38, $18, $0c, $00, $00, $00, $00, $00
	byte	$66, $66, $3c, $3c, $ff, $ff, $3c, $3c, $66, $66, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $18, $7e, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[5]
	byte	$0c, $04, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00[13]
	byte	$18, $18, $18, $00, $00, $00, $00, $60, $60, $60, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $76, $6e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $18, $18, $1c, $1c, $18, $18, $18, $18, $18
	byte	$18, $7e, $7e, $00, $00, $00, $00, $3c, $7e, $66, $66, $30, $30, $18, $18, $0c
	byte	$0c, $7e, $7e, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $30, $30, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $30, $30, $38, $38, $3c, $3c, $36, $36, $7e
	byte	$7e, $30, $30, $00, $00, $00, $00, $7e, $7e, $06, $06, $3e, $7e, $60, $60, $60
	byte	$66, $7e, $3c, $00, $00, $00, $00, $38, $3c, $0e, $06, $06, $3e, $7e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $7e, $7e, $60, $60, $30, $30, $18, $18, $0c
	byte	$0c, $0c, $0c, $00, $00, $00, $00, $3c, $7e, $66, $66, $3c, $3c, $66, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $7c, $60, $60, $60
	byte	$70, $3c, $1c, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $18
	byte	$18, $18, $18, $0c, $04, $00, $00, $00, $70, $38, $1c, $0e, $07, $0e, $1c, $38
	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $7e, $7e
	byte	$00[8]
	byte	$0e, $1c, $38, $70, $e0, $70, $38, $1c, $0e, $00, $00, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $30, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $66, $66, $36, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $18
	byte	$3c, $7e, $66, $66, $66, $7e, $7e, $66, $66, $66, $66, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $7e, $3e, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $06, $06, $06, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $66, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $7e, $7e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $7c
	byte	$7e, $06, $06, $76, $76, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $66
	byte	$66, $66, $66, $7e, $7e, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $7e
	byte	$7e, $18, $18, $18, $18, $18, $18, $18, $18, $7e, $7e, $00, $00, $00, $00, $60
	byte	$60[7]
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $36, $36, $1e, $1e, $36, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $06, $06, $06, $06, $06, $06, $06, $06
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $c6, $c6, $ee, $ee, $fe, $d6, $d6, $c6
	byte	$c6, $c6, $c6, $c6, $00, $00, $00, $00, $66, $66, $66, $6e, $6e, $7e, $7e, $76
	byte	$76, $66, $66, $66, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $66, $7e, $3e
	byte	$06, $06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $56, $3e, $6c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $7e, $3e, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $7c, $7e, $06, $06, $0e, $1c, $38, $70
	byte	$60, $60, $7e, $3e, $00, $00, $00, $00, $7e, $7e, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$3c, $3c, $18, $18, $00, $00, $00, $00, $c6, $c6, $c6, $c6, $c6, $d6, $d6, $fe
	byte	$fe, $ee, $c6, $82, $00, $00, $00, $00, $66, $66, $66, $3c, $3c, $18, $18, $3c
	byte	$3c, $66, $66, $66, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $3c, $3c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$0c, $0c, $3c, $3c, $00, $00, $00, $00, $06, $06, $0c, $0c, $18, $18, $30, $30
	byte	$60, $60, $c0, $c0, $00, $00, $00, $00, $3c, $3c, $30, $30, $30, $30, $30, $30
	byte	$30, $30, $3c, $3c, $00, $00, $00, $00, $18, $18, $3c, $3c, $66, $66, $00, $00
	byte	$00[18]
	byte	$fe, $fe, $00, $00, $00, $00, $0c, $0c, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$3c, $7c, $60, $7c, $7e, $66, $66, $7e, $7c, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $3e, $06, $06, $06, $06, $06, $7e, $7c, $00, $00, $00, $00, $60, $60, $60
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $7e, $06, $06, $7e, $7c, $00, $00, $00, $00, $70, $78, $18
	byte	$18, $7e, $7e, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $7e, $7c, $60, $7e, $3e, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $1c, $18, $18, $18, $18, $18, $3c, $3c, $00, $00, $00, $00, $30, $30, $00
	byte	$30[9]
	byte	$3e, $1e, $00, $00, $06, $06, $06, $36, $36, $1e, $1e, $1e, $36, $36, $66, $66
	byte	$00, $00, $00, $00, $1c, $1c, $18, $18, $18, $18, $18, $18, $18, $18, $3c, $3c
	byte	$00[7]
	byte	$6c, $fe, $fe, $d6, $d6, $c6, $c6, $c6, $c6, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $06, $06, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $60, $60, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $06, $0e, $3c, $70, $60, $7e, $3e, $00, $00, $00, $00, $00, $18, $18
	byte	$7e, $7e, $18, $18, $18, $18, $18, $78, $70, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$7e, $7c, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $c6, $c6, $d6, $d6, $fe, $fe, $ee
	byte	$c6, $82, $00, $00, $00, $00, $00, $00, $00, $66, $66, $3c, $3c, $18, $3c, $3c
	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $7e
	byte	$7c, $60, $7e, $3e, $00, $00, $00, $00, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $18, $18, $18, $0c, $0c, $18, $18, $18
	byte	$18, $30, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $0c, $18, $18, $18, $18, $30, $30, $18, $18, $18
	byte	$18, $0c, $00, $00, $00, $00, $6c, $7e, $36, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
'-' 'amiga_font     file "amigafont.def"
'-' a8_font        file "atari8.fnt"
	byte	$00, $6c, $fe, $fe, $7c, $38, $10, $00, $18, $18, $18, $f8, $f8, $18, $18, $18
	byte	$c0[8]
	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
	byte	$0f[8]
	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
	byte	$66[5]
	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
	byte	$08, $00
'-' vga16          long  $00000000,$00008000,$00800000,$00808000,$80000000,$80008000,$80400000,$AAAAAA00,$55555500,$0000FF00,$00FF0000,$00FFFF00,$FF000000,$FF00FF00,$FFFF0000,$FFFFFF00
	byte	$00[5]
	byte	$80, $00, $00, $00, $00, $80, $00, $00, $80, $80, $00, $00, $00, $00, $80, $00
	byte	$80, $00, $80, $00, $00, $40, $80, $00, $aa, $aa, $aa, $00, $55, $55, $55, $00
	byte	$ff, $00, $00, $00, $00, $ff, $00, $00, $ff, $ff, $00, $00, $00, $00, $ff, $00
	byte	$ff, $00, $ff, $00, $00, $ff, $ff, $00, $ff, $ff, $ff
'-' ataripalette   file "ataripalettep2.def"
	byte	$00[5]
	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
'-' 
'-' '**********************************************************************************
'-' '
'-' '        Timings and colors definitions
'-' '
'-' '**********************************************************************************
'-' 
'-' '                      bf.hs, hs,  bf.vis  visible, up p., vsync, down p.,  cpl, total lines, clock,       hubset                                scanlines  ud bord mode reserved
'-' timings         long   8,     60,  8,       1024,   7,     4,     1,        128, 600,         340500000,   %1_100111__10_1010_1000__1111_1011,   600,        0,     192, 0, 0
	byte	$08, $00, $00, $00, $3c, $00, $00, $00, $08, $00, $00, $00, $00, $04, $00, $00
	byte	$07, $00, $00, $00, $04, $00, $00, $00, $01, $00, $00, $00, $80, $00, $00, $00
	byte	$58, $02, $00, $00, $20, $9e, $4b, $14, $fb, $a8, $9e, $01, $58, $02, $00, $00
	byte	$00, $00, $00, $00, $c0, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' 'timings        long   16,    80,  12,      1024,   8,     4,     8,        128, 576,         336956522,   %1_101101__11_0000_0110__1111_1011,   576,        0,     192, 0, 0
'-' vgacolors       byte   0, 117, 199, 151, 39, 71, 246, 10, 5, 121, 203, 155, 43, 75, 234, 15
	byte	$00, $75, $c7, $97, $27, $47, $f6, $0a, $05, $79, $cb, $9b, $2b, $4b, $ea, $0f
'-' 
'-' ''--------  Initialization  ----------------------------------------------------------------
'-' 
'-' hdmi            setq    #6
	byte	$28, $0c, $64, $fd
'-'                 rdlong  vblankptr,  ptra                   ' read pointers
	byte	$00, $a5, $05, $fb
'-'                 setq    #8
	byte	$28, $10, $64, $fd
'-'                 rdlong  m_bs,modeptr                       ' read timings
	byte	$d3, $8a, $01, $fb
'-' 
'-'                 bitl    hbase, #31 wcz                     ' if pin 31 is set, use full strength for Adafruit Pico HDMI board
	byte	$1f, $ac, $1d, $f4
'-'                 setcmod #$100                              ' enable HDMI mode
	byte	$3c, $00, $66, $fd
'-'                 mov     t1,#448                            ' 7 << 6          
	byte	$c0, $c7, $05, $f6
'-'                 add     t1,hbase
	byte	$d6, $c6, $01, $f1
'-'                 drvl    t1                                 ' #7<<6 + hdmi_base      ' enable HDMI pins
	byte	$58, $c6, $61, $fd
'-'         if_z    wrpin   #0, t1  '#7<<6 + hdmi_base         ' for Adafruit breakout board - full logic as in Pico, the board has 220 Ohm resistors on it
	byte	$e3, $00, $08, $ac
'-' 	if_nz   wrpin   ##%10110_1111_0111_10_00000_0, t1  ' #7<<6 + hdmi_base      ' a '123 ohm BITDAC for Parallax breakout board
	byte	$7b, $0b, $80, $5f, $e3, $00, $0b, $5c
'-'                 setxfrq ##$0CCCCCCC+1                      ' set streamer freq to 1/10th clk
	byte	$66, $66, $86, $ff, $1d, $9a, $65, $fd
'-' '
'-'                 mov 	t1,hbase			   '
	byte	$d6, $c6, $01, $f6
'-'                 shl 	t1,#17                             '
	byte	$11, $c6, $65, $f0
'-'                 add 	lutg8,t1                           ' add the pin base to he streamer constant
	byte	$e3, $a2, $01, $f1
'-'                 sub 	i_upporch,#2			   ' the driver will call 2 blank lines itself to preload the buffer, so sub #2 from up porch time
	byte	$02, $92, $85, $f1
'-' 
'-'                 cogid   t1              		   ' get a cogid
	byte	$01, $c6, $61, $fd
'-'                 mul     t1, #12                            ' compute the offset to PSRAM mailbox 
	byte	$0c, $c6, $05, $fa
'-'                 add     mailbox, t1                        ' add offset to find this COG's mailbox
	byte	$e3, $ae, $01, $f1
'-' 
'-' ''--------  frame rendering main loop  ---------------------------------------------------
'-' 
'-' p101            setq 	#3
	byte	$28, $06, $64, $fd
'-' 		rdlong  vblankptr,ptra
	byte	$00, $a5, $05, $fb
'-'                 setq    #47+6				   ' read sprite data
	byte	$28, $6a, $64, $fd
'-' 	 	rdlong  sprite1pointer,spriteptr
	byte	$d8, $dc, $01, $fb
'-' 		mov     spriteline,#0                      ' init the sprite line variable
	byte	$00, $4a, $06, $f6
'-'                 mov     dlinum, #0
	byte	$00, $a0, $05, $f6
'-'                 add     frames,#1			   ' increment the frame counter
	byte	$01, $9e, $05, $f1
'-'                 mov     dlptr2,dlptr			   ' init the temporary DL pointer
	byte	$d5, $b8, $01, $f6
'-' 
'-' 
'-'                 mov     linenum,#0			   ' init the current line #
	byte	$00, $9c, $05, $f6
'-'                 mov     rcnt,#0			   	   ' init the DL repeat counter
	byte	$00, $ce, $05, $f6
'-'                 mov     rcnt2a,affffffff 		   ' why?!                
	byte	$ed, $d2, $01, $f6
'-'                 
'-' 
'-' 
'-' '' ------- reload the palette. If bit31 set, don't reload, to prevent blinking while modifying the palette
'-'   
'-'                 testb   paletteptr,#31 wc
	byte	$1f, $a8, $15, $f4
'-'          if_nc  setq2   #255
	byte	$29, $fe, $65, $3d
'-'          if_nc  rdlong  $000, paletteptr                   'read palette
	byte	$d4, $00, $00, $3b
'-' 
'-' '' -----   up porch (before the picture)
'-' 
'-'                 mov     hsync0,sync_000      	           ' init constants for sync
	byte	$c0, $c2, $01, $f6
'-'                 mov     hsync1,sync_001	
	byte	$c1, $c4, $01, $f6
'-'                 callpa  i_upporch ,#blank                  ' call the porch line i_upporch (-2) times
	byte	$40, $92, $45, $fb
'-'                 wrlong  #0,vblankptr                       ' the vblank time ends here
	byte	$d2, $00, $68, $fc
'-'  
'-'    
'-'  
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'          	     call    #dli	                  ' call DL interpreter for line #0 at line #(-2) - 2 lines earlier, so it can start preloading data from PSRAM
	byte	$60, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                          rdfast  #64,buf1d                          ' prepare the HUB buffer for 4 scanlines
	byte	$df, $80, $78, $fc
'-' 
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-' 		call    #dli
	byte	$48, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                  call    #sprite				   ' sprites for line #0
	byte	$20, $01, $b0, $fd
'-'                 	
'-'                 
'-' 
'-'  
'-' '' ------- the main screen drawing starts here
'-' 
'-' p301            xcont   m_bs,hsync0   			  ' make a right porch
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1                       ' make hsync
	byte	$e2, $8c, $b1, $fc
'-'                 call    #dli                              ' process the DL for line+2                
	byte	$30, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   lutg8,#0			  ' display the line 
	byte	$00, $a2, $c5, $fc
'-'                  add     linenum,#1                        ' increment the current line number 
	byte	$01, $9c, $05, $f1
'-'                  call    #sprite                           ' process sprites for line+1             
	byte	$04, $01, $b0, $fd
'-'               
'-' 
'-'                 cmp     linenum,i_totalvis  wz            ' check if all lines displayed
	byte	$cd, $9c, $09, $f2
'-'     if_nz       jmp     #p301                             ' if not, display the next line
	byte	$dc, $ff, $9f, $5d
'-' 
'-' ' ---------------- All visible lines displayed now, start vblank  
'-' 
'-' p112            wrlong  #1,vblankptr                       ' tell the system that the vblank started
	byte	$d2, $02, $68, $fc
'-'                 callpa  i_downporch ,#blank                ' bottom blanks
	byte	$28, $96, $45, $fb
'-'                 mov     hsync0,sync_222                    ' vsync on
	byte	$c2, $c2, $01, $f6
'-'                 mov     hsync1,sync_223
	byte	$c3, $c4, $01, $f6
'-'                 callpa  i_vsync,#blank                     ' vertical sync blanks
	byte	$25, $94, $45, $fb
'-'                 jmp     #p101                              ' return to the main loop
	byte	$4c, $ff, $9f, $fd
'-' 
'-' '' --------------- END of frame rendering loop ---------------------------------------------------------------------------
'-' 
'-' '' --------------- Display list interpreter ---------------------------------------------------------------------------
'-' 
'-' dli             cmp     rcnt,#0 wz			   ' check the DL repeat counter 
	byte	$00, $ce, $0d, $f2
'-' 
'-'     if_z        rdlong  dl,dlptr2				
	byte	$dc, $ba, $01, $ab
'-'     if_z        add     dlptr2,#4
	byte	$04, $b8, $05, $a1
'-'     if_z        jmp     #p307                              ' no repeat, goto read and interpret the next DL entry
	byte	$14, $00, $90, $ad
'-' 
'-'                 sub     rcnt,#1 wz                         ' decrement the repeat counter
	byte	$01, $ce, $8d, $f1
'-'     if_nz       mov     dl,rdl                             ' restore repeating DL entry from temporary buffer
	byte	$eb, $ba, $01, $56
'-'                 incmod  rcnt2a,rcnt2 wcz                   ' address update counter
	byte	$e8, $d2, $19, $f7
'-'     if_c        add     dl,roffset                         ' if it rollovers, add the offset to the data address
	byte	$ea, $ba, $01, $c1
'-'                 mov     rdl,dl                             ' save the result
	byte	$dd, $d6, $01, $f6
'-' 
'-' p307	        mov     framebuf2,dl wcz                   ' move this to framebuf2. If normal DL entry, the frame buffer start will be extracted from this
	byte	$dd, $c0, $19, $f6
'-'                 getnib  t1,dl,#0
	byte	$dd, $c6, $41, $f8
'-'                 cmp     t1,#%0010 wz			   ' 0010 - display a normal graphics line, preload it from the PSRAM
	byte	$02, $c6, $0d, $f2
'-'     if_z        jmp     #preload
	byte	$70, $00, $90, $ad
'-'     		cmp     t1,#%0000 wz			   ' 0000 - display a line from a PSRAM list
	byte	$00, $c6, $0d, $f2
'-'     if_z        jmp     #preload2
	byte	$94, $00, $90, $ad
'-'                 cmp     t1,#%0001 wz			   ' 0001 - repeat
	byte	$01, $c6, $0d, $f2
'-'     if_z        jmp     #p390
	byte	$0c, $00, $90, $ad
'-'                 cmp     t1,#%0011 wz			   ' 0011 - palette reload
	byte	$03, $c6, $0d, $f2
'-'     if_z        jmp     #p391  
	byte	$28, $00, $90, $ad
'-' 
'-' p308            ret
	byte	$2d, $00, $64, $fd
'-'    
'-' p390            rdlong  rdl,dlptr2                         ' read the next DL entry to repeat
	byte	$dc, $d6, $01, $fb
'-'                 getword rcnt,framebuf2,#1                  ' read the repeat count
	byte	$e0, $ce, $39, $f9
'-'                 shr     rcnt,#4                            ' from 12 upper bits
	byte	$04, $ce, $45, $f0
'-'                 mov     rcnt2a,affffffff                   ' I still don't know why?
	byte	$ed, $d2, $01, $f6
'-'                 getnib  rcnt2,framebuf2,#4                 ' read the pointer update counter
	byte	$e0, $d0, $61, $f8
'-'                 getword roffset,framebuf2,#0               ' read the offset to add
	byte	$e0, $d4, $31, $f9
'-'                 shr     roffset,#4                         ' clean the command field from offset
	byte	$04, $d4, $45, $f0
'-'                 shl     roffset,#4                         ' and make it ready to add to the DL entry (address=20 upper bits)
	byte	$04, $d4, $65, $f0
'-'                 jmp     #dli                               ' now start repeating 
	byte	$8c, $ff, $9f, $fd
'-'  
'-' '' --------  Reload palette. To do 
'-' 
'-' p391           	getnib  t1,framebuf2,#2			   ' get a bank (0..15) of 16 colors
	byte	$e0, $c6, $51, $f8
'-'          	shl     t1,#4				   ' compute the LUT address
	byte	$04, $c6, $65, $f0
'-'         	shr     framebuf2,#12			   ' compute the HUB address of 16 new colors
	byte	$0c, $c0, $45, $f0
'-'          	setq2   #15				   ' load 16 entries
	byte	$29, $1e, $64, $fd
'-'          	altd    t1                                 ' from t1 LUT address
	byte	$00, $c6, $8d, $f9
'-'         	rdlong  $000, framebuf2         	
	byte	$e0, $00, $00, $fb
'-'         	jmp     #dli                
	byte	$70, $ff, $9f, $fd
'-'       
'-' '' --------------- A display list interpreter end ------------------------------------------------------------------------    
'-' 
'-' 
'-' '' --------------- Blank and vsync procedures called via callpa have to be in the middle of the code ---------------------
'-' 
'-' blank           xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'         _ret_   djnz    pa,#blank
	byte	$fb, $ed, $6f, $0b
'-'         
'-' '' -------------- Preload a line from PSRAM        
'-'         
'-' preload         mov     buf1c,dlinum			   ' preload a line buffer #dlinum (0..3)
	byte	$d0, $bc, $01, $f6
'-'                 shl     buf1c,#10		           ' 1024 bytes per line
	byte	$0a, $bc, $65, $f0
'-'                 add     buf1c,buf1d			   ' add the start address (himem-debug-4096) : Todo: debug variable!
	byte	$df, $bc, $01, $f1
'-'                 mov     buf1,buf1c
	byte	$de, $b4, $01, $f6
'-'                 incmod  dlinum,#3
	byte	$03, $a0, $05, $f7
'-' 
'-'                 shr     framebuf2,#4                      ' get the PSRAM start address from DL - Todo: use new DL format
	byte	$04, $c0, $45, $f0
'-'                 mov     buf2,a1024
	byte	$32, $b7, $01, $f6
'-'                 mov     cmd,framebuf2                      ' set the address
	byte	$e0, $b2, $01, $f6
'-'                 setnib  cmd, #%1011, #7                    ' attach the command - read burst from the external memory
	byte	$0b, $b2, $3d, $f8
'-'                 setq    #2				   ' write 3 longs to the mailbox
	byte	$28, $04, $64, $fd
'-'     _ret_       wrlong  cmd,mailbox			   ' read the PSRAM
	byte	$d7, $b2, $61, $0c
'-'  
'-'  
'-' preload2      '  incmod  dlinum,#3
'-'                 shr 	framebuf2,#4
	byte	$04, $c0, $45, $f0
'-'                 mov 	cmd,affffffff
	byte	$ed, $b2, $01, $f6
'-'                 mov 	buf1,framebuf2
	byte	$e0, $b4, $01, $f6
'-'                 setq	#1
	byte	$28, $02, $64, $fd
'-'     _ret_	wrlong  cmd,mailbox
	byte	$d7, $b2, $61, $0c
'-'                 
'-' 
'-' '' -------------- Draw sprites
'-' 
'-' sprite          mov t8,frames
	byte	$cf, $5c, $02, $f6
'-' 		and t8,#16 wz
	byte	$10, $5c, $0e, $f5
'-'                 mov     spritenum,#17			' 16 +2 sprites. Todo: this should be a parameter
	byte	$11, $48, $06, $f6
'-' 	if_z    mov spritenum, #16	
	byte	$10, $48, $06, $a6
'-' 		
'-' 
'-' p802            mov     t5,spritenum		   	' prepare a pointer to load sprite data
	byte	$24, $57, $02, $f6
'-'                 mul     t5,#3          			' one sprite data set needs 3 longs
	byte	$03, $56, $06, $fa
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_y,0-0,#1		        ' get a sprite y
	byte	$00, $4e, $3a, $f9
'-'                 signx	sprite_y,#15			' they can be negative
	byte	$0f, $4e, $66, $f7
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_x,0-0,#0                 ' and x
	byte	$00, $4c, $32, $f9
'-'                 signx	sprite_x,#15
	byte	$0f, $4c, $66, $f7
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_h,0-0,#1		       	' get a sprite height
	byte	$00, $52, $3a, $f9
'-'                 sub     sprite_h,#1
	byte	$01, $52, $86, $f1
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_w,0-0,#0                 ' and width
	byte	$00, $50, $32, $f9
'-' 
'-' 
'-'                	cmps	sprite_x,a1024 wcz	         
	byte	$32, $4d, $5a, $f2
'-'      if_ge	jmp 	#p801                           ' go out if >1023
	byte	$bc, $00, $90, $3d
'-'               	cmps	sprite_w,#0 wcz	         
	byte	$00, $50, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if w=0
	byte	$b4, $00, $90, $ad
'-'               	cmps	sprite_h,#0 wcz	         
	byte	$00, $52, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if h=0
	byte	$ac, $00, $90, $ad
'-'                 mov 	t9,#0
	byte	$00, $5e, $06, $f6
'-'                 sub 	t9,sprite_w                      	
	byte	$28, $5f, $82, $f1
'-'      		cmps  	sprite_x,t9 wcz   		'
	byte	$2f, $4d, $5a, $f2
'-'      if_le	jmp 	#p801	                        ' go out if sprite out of screen at right
	byte	$9c, $00, $90, $ed
'-'      
'-'   		mov     t2,linenum			' display line # to check if sprite has to be displayed
	byte	$ce, $c8, $01, $f6
'-'   		subs    t2,sprite_y wcz                 ' check if the sprite has to be displayed
	byte	$27, $c9, $d9, $f1
'-'      if_c       jmp     #p801				' if not, go out
	byte	$90, $00, $90, $cd
'-'                 cmp     t2,sprite_h wcz		    	' we have now the sprite line #, check, if it is not >= sprite height
	byte	$29, $c9, $19, $f2
'-'      if_gt      jmp     #p801				' if yes, go out
	byte	$88, $00, $90, $1d
'-'                 
'-'                 mov     t3,spriteline			' compute the line buffer addres where to put the sprite line
	byte	$25, $cb, $01, $f6
'-'                 shl     t3,#10			       	' =1024*spriteline where spriteline=0..3		' 
	byte	$0a, $ca, $65, $f0
'-'                 add     t3,buf1d			' line buffer addr
	byte	$df, $ca, $01, $f1
'-'   		
'-'   		testb	sprite_x,#31 wc 		' check if sprite pos <0
	byte	$1f, $4c, $16, $f4
'-'      if_nc      add     t3,sprite_x   			' if >=0 add xpos. If <0, the address is the start of the line  - now we have the address to where wmlong the sprite
	byte	$26, $cb, $01, $31
'-' 
'-'                 mul 	t2,sprite_w			' compute the offset to the sprite line data
	byte	$28, $c9, $01, $fa
'-'      if_c	add     sprite_w,sprite_x		' if sprite_x negative, shorten the width
	byte	$26, $51, $02, $c1
'-'      if_c	sub 	t2,sprite_x			' and add the offset (sub negative) to the sprite data offset
	byte	$26, $c9, $81, $c1
'-'  
'-'                 alts    t5,#sprite1pointer		' get the pointer to the sprite (3 longs per sprite data)
	byte	$ee, $56, $96, $f9
'-'                 add     t2,0-0				' then add the offset
	byte	$00, $c8, $01, $f1
'-'      if_c 	jmp     #p899		
	byte	$10, $00, $90, $cd
'-' 	
'-' 	
'-' 		mov 	t4,sprite_x	'
	byte	$26, $cd, $01, $f6
'-' 		add	t4,sprite_w
	byte	$28, $cd, $01, $f1
'-' 		sub     t4,a1024 wcz			' check if the sprite goes right off the screen
	byte	$32, $cd, $99, $f1
'-' 
'-' 	if_nc	sub	sprite_w,t4			' if yes, make it narrower
	byte	$e6, $50, $82, $31
'-' 
'-' p899		mov 	t6,sprite_w
	byte	$28, $59, $02, $f6
'-' 	 	sub     t6,#1
	byte	$01, $58, $86, $f1
'-' 	 	shr	t6,#2				' bytes to longs
	byte	$02, $58, $46, $f0
'-' 
'-'                 setq   	t6
	byte	$28, $58, $62, $fd
'-'                 rdlong 368,t2				' read sprite data to the cog
	byte	$e4, $e0, $02, $fb
'-'                 mov t8,sprite_w
	byte	$28, $5d, $02, $f6
'-'                 and t8,#3 wz				' if width mod 4=0 we have full longs, nothing to do
	byte	$03, $5c, $0e, $f5
'-'         if_z    jmp #p898
	byte	$24, $00, $90, $ad
'-'          
'-'         
'-'                 mov  t9,#368
	byte	$70, $5f, $06, $f6
'-'                 add t9,t6				' find the last long of the sprite
	byte	$2c, $5f, $02, $f1
'-' 
'-'                 subr t8,#4				' if modulo4=1, mask 3 bytes, if 2, mask 2, if 1, mask 3
	byte	$04, $5c, $c6, $f2
'-'                 mul t8,#8				' bits to shr
	byte	$08, $5c, $06, $fa
'-'                 mov t7,##-1				' full of 1s
	byte	$ff, $ff, $7f, $ff, $ff, $5b, $06, $f6
'-'                 shr t7,t8				' SHR to make 0s for masking
	byte	$2e, $5b, $42, $f0
'-'                 altd t9,#0				' and mask 
	byte	$00, $5e, $8e, $f9
'-'                 and 0-0, t7
	byte	$2d, $01, $00, $f5
'-'                
'-' 
'-' p898            setq   t6				' write the sprite data to the line buffer
	byte	$28, $58, $62, $fd
'-'                 wmlong 368,t3				
	byte	$e5, $e0, $7a, $fa
'-'                 
'-' p801            djnf spritenum,#p802			' get the next sprite
	byte	$c1, $49, $7e, $fb
'-'                 incmod spriteline,#3			' prepare to fill the next line
	byte	$03, $4a, $06, $f7
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 	
'-' 	
'-'                
'-'  
'-' '' -------------- Graphics line ------------------------------------------------------------
'-'  
'-' 
'-' '' consts and vars
'-' 
'-' sync_000        long    %1101010100_1101010100_1101010100_10    '
	byte	$52, $4d, $35, $d5
'-' sync_001        long    %1101010100_1101010100_0010101011_10    '        hsync
	byte	$ae, $42, $35, $d5
'-' sync_222        long    %0101010100_0101010100_0101010100_10    'vsync
	byte	$52, $45, $15, $55
'-' sync_223        long    %0101010100_0101010100_1010101011_10    'vsync + hsync
	byte	$ae, $4a, $15, $55
'-' 
'-' border          long    %00000000_00011010_00101100_00000000
	byte	$00, $2c, $1a, $00
'-' 
'-' '------ these longs will be set by setmode function
'-' 
'-' m_bs            long    0        'blanks before sync
	byte	$00, $00, $00, $00
'-' m_sn            long    0        'sync
	byte	$00, $00, $00, $00
'-' m_bv            long    0        'blanks before visible
	byte	$00, $00, $00, $00
'-' m_vi            long    0        'visible pixels #
	byte	$00, $00, $00, $00
'-' 'm_border        long    0        'left/right borders
'-' i_upporch       long    0        'up porch lines
	byte	$00, $00, $00, $00
'-' i_vsync         long    0        'vsync lines
	byte	$00, $00, $00, $00
'-' i_downporch     long    0        'down porch lines
	byte	$00, $00, $00, $00
'-' i_cpl           long    0        'chars/longs per line
	byte	$00, $00, $00, $00
'-' i_totalvis      long    0
	byte	$00, $00, $00, $00
'-' 
'-' '-------------------------------------
'-'  
'-' linenum         long    0
	byte	$00, $00, $00, $00
'-' frames          long    0
	byte	$00, $00, $00, $00
'-' dlinum long 0
	byte	$00, $00, $00, $00
'-' lutg8           long    $70880400 ' 0111_0000_1000_1000
	byte	$00, $04, $88, $70
'-' 
'-' vblankptr       long    0
	byte	$00, $00, $00, $00
'-' modeptr         long    0
	byte	$00, $00, $00, $00
'-' paletteptr      long    0
	byte	$00, $00, $00, $00
'-' dlptr           long    0
	byte	$00, $00, $00, $00
'-' hbase           long    1
	byte	$01, $00, $00, $00
'-' mailbox         long    0
	byte	$00, $00, $00, $00
'-' spriteptr          long 0
	byte	$00, $00, $00, $00
'-' 
'-' cmd             long    0
	byte	$00, $00, $00, $00
'-' buf1            long    $80000-16384-4096
	byte	$00, $b0, $07, $00
'-' buf2            long    1024
	byte	$00, $04, $00, $00
'-' dlptr2          long    1
	byte	$01, $00, $00, $00
'-' dl              long    1
	byte	$01, $00, $00, $00
'-' 
'-' buf1c long 0
	byte	$00, $00, $00, $00
'-' buf1d            long    $80000-16384-4096
	byte	$00, $b0, $07, $00
'-' framebuf2       long    1
	byte	$01, $00, $00, $00
'-' hsync0          long    1
	byte	$01, $00, $00, $00
'-' hsync1          long    1
	byte	$01, $00, $00, $00
'-' 
'-' t1              long    1
	byte	$01, $00, $00, $00
'-' t2 long 0
	byte	$00, $00, $00, $00
'-' t3 long 0
	byte	$00, $00, $00, $00
'-' t4 long 0
	byte	$00, $00, $00, $00
'-' 
'-' rcnt            long    0  'dl repeat count
	byte	$00, $00, $00, $00
'-' rcnt2           long    0
	byte	$00, $00, $00, $00
'-' rcnt2a          long    0
	byte	$00, $00, $00, $00
'-' roffset         long    0
	byte	$00, $00, $00, $00
'-' rdl             long    0  'dl repeat line
	byte	$00, $00, $00, $00
'-' dlc             long    0  'dl command
	byte	$00, $00, $00, $00
'-' 
'-' affffffff       long    $ffffffff
	byte	$ff, $ff, $ff, $ff
'-' sprite1pointer long 0
	byte	$00, $00, $00, $00
'-' sprite1xy      long 0
	byte	$00, $00, $00, $00
'-' sprite1wh      long 0
	byte	$00, $00, $00, $00
'-' sprite2pointer long 0
	byte	$00, $00, $00, $00
'-' sprite2xy      long 0
	byte	$00, $00, $00, $00
'-' sprite2wh      long 0
	byte	$00, $00, $00, $00
'-' sprite3pointer long 0
	byte	$00, $00, $00, $00
'-' sprite3xy      long 0
	byte	$00, $00, $00, $00
'-' sprite3wh      long 0
	byte	$00, $00, $00, $00
'-' sprite4pointer long 0
	byte	$00, $00, $00, $00
'-' sprite4xy      long 0
	byte	$00, $00, $00, $00
'-' sprite4wh      long 0
	byte	$00, $00, $00, $00
'-' sprite5pointer long 0
	byte	$00, $00, $00, $00
'-' sprite5xy      long 0
	byte	$00, $00, $00, $00
'-' sprite5wh      long 0
	byte	$00, $00, $00, $00
'-' sprite6pointer long 0
	byte	$00, $00, $00, $00
'-' sprite6xy      long 0
	byte	$00, $00, $00, $00
'-' sprite6wh      long 0
	byte	$00, $00, $00, $00
'-' sprite7pointer long 0
	byte	$00, $00, $00, $00
'-' sprite7xy      long 0
	byte	$00, $00, $00, $00
'-' sprite7wh      long 0
	byte	$00, $00, $00, $00
'-' sprite8pointer long 0
	byte	$00, $00, $00, $00
'-' sprite8xy      long 0
	byte	$00, $00, $00, $00
'-' sprite8wh      long 0
	byte	$00, $00, $00, $00
'-' sprite9pointer long 0
	byte	$00, $00, $00, $00
'-' sprite9xy      long 0
	byte	$00, $00, $00, $00
'-' sprite9wh      long 0
	byte	$00, $00, $00, $00
'-' sprite10pointer long 0
	byte	$00, $00, $00, $00
'-' sprite10xy      long 0
	byte	$00, $00, $00, $00
'-' sprite10wh      long 0
	byte	$00, $00, $00, $00
'-' sprite11pointer long 0
	byte	$00, $00, $00, $00
'-' sprite11xy      long 0
	byte	$00, $00, $00, $00
'-' sprite11wh      long 0
	byte	$00, $00, $00, $00
'-' sprite12pointer long 0
	byte	$00, $00, $00, $00
'-' sprite12xy      long 0
	byte	$00, $00, $00, $00
'-' sprite12wh      long 0
	byte	$00, $00, $00, $00
'-' sprite13pointer long 0
	byte	$00, $00, $00, $00
'-' sprite13xy      long 0
	byte	$00, $00, $00, $00
'-' sprite13wh      long 0
	byte	$00, $00, $00, $00
'-' sprite14pointer long 0
	byte	$00, $00, $00, $00
'-' sprite14xy      long 0
	byte	$00, $00, $00, $00
'-' sprite14wh      long 0
	byte	$00, $00, $00, $00
'-' sprite15pointer long 0
	byte	$00, $00, $00, $00
'-' sprite15xy      long 0
	byte	$00, $00, $00, $00
'-' sprite15wh      long 0
	byte	$00, $00, $00, $00
'-' sprite16pointer long 0
	byte	$00, $00, $00, $00
'-' sprite16xy      long 0
	byte	$00, $00, $00, $00
'-' sprite16wh      long 0
	byte	$00, $00, $00, $00
'-' sprite17pointer long 0
	byte	$00, $00, $00, $00
'-' sprite17xy      long 0
	byte	$00, $00, $00, $00
'-' sprite17wh      long 0
	byte	$00, $00, $00, $00
'-' sprite18pointer long 0
	byte	$00, $00, $00, $00
'-' sprite18xy      long 0
	byte	$00, $00, $00, $00
'-' sprite18wh      long 0
	byte	$00, $00, $00, $00
'-' spritenum long 0
	byte	$00, $00, $00, $00
'-' 
'-' spriteline long 0
	byte	$00, $00, $00, $00
'-' sprite_x long 900
	byte	$84, $03, $00, $00
'-' sprite_y long 0
	byte	$00, $00, $00, $00
'-' sprite_w long 16
	byte	$10, $00, $00, $00
'-' sprite_h long 64
	byte	$40, $00, $00, $00
'-' l2 long 0
	byte	$00, $00, $00, $00
'-' t5 long 0
	byte	$00, $00, $00, $00
'-' t6 long 0
	byte	$00, $00, $00, $00
'-' t7 long 0
	byte	$00, $00, $00, $00
'-' t8 long 0
	byte	$00, $00, $00, $00
'-' t9 long 0
	byte	$00, $00, $00, $00
'-' preloadaddr long 0
	byte	$00, $00, $00, $00
'-' preloadlineaddr long 0
	byte	$00, $00, $00, $00
'-' a1024 long 1024
	byte	$00, $04, $00, $00
'-' 
'-' aa long 992
	byte	$e0, $03, $00, $00
'-' a1023 long 1023
	byte	$ff, $03, $00, $00
'-' a4096 long 4096
	byte	$00, $10, $00, $00
'-'  fit 368
	alignl
_psram_spin2_dat_
'-'     listdata long 0[8*8]
	byte	$00[256]
'-'             orgh
'-' 
'-' ' driver state
'-' drivercog   long    -1  ' COG id of driver
	byte	$ff, $ff, $ff, $ff
'-' driverlock  long    -1  ' LOCK id of driver
	byte	$ff, $ff, $ff, $ff
'-' 
'-' ' delay profile
'-' delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
	byte	$07, $00, $00, $00, $00, $cf, $7b, $05, $80, $d1, $f0, $08, $80, $4f, $47, $0c
	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
'-' 
'-' ' data to be passed to driver when starting it
'-' startupData
'-'     long    0           ' current frequency
	byte	$00, $00, $00, $00
'-'     long    FLAGS       ' optional flags for driver
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port A for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port B for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    DATABUS     ' PSRAM data bus start pin
	byte	$28, $00, $00, $00
'-'     long    deviceData  ' address of devices data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 328
'-'     long    qosData     ' address of QoS data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 456
'-'     long    mailboxes   ' address of mailbox structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 488
'-' 
'-' ' data for memory
'-' deviceData
'-'     ' 16 bank parameters follow (16MB per bank)
'-'     long    0[16]                               ' banks 0-15
	byte	$00[64]
'-'     ' 16 banks of pin parameters follow
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
	byte	$39, $38, $00, $00
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
	byte	$39, $38, $00, $00
'-'     long    -1[14]                              ' banks 2-15
	byte	$ff[56]
'-' 
'-' ' data for COG polling
'-' qosData 
'-'     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
'-'     
'-' ' mailbox storage
'-' 
'-' mailboxes
'-'     long    0[8*3]          ' 3 longs per mailbox per COG
	byte	$00[96]
	alignl
_psram16drv_spin2_dat_
'-'                             orgh
'-' scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
	byte	$00[32]
'-' 
'-' driver_start
'-'                             org
'-' '..................................................................................................
'-' ' Memory layout for COG RAM once operational:
'-' '
'-' '  COG RAM address      Usage
'-' '  ---------------      ----
'-' '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
'-' '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
'-' '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
'-' '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
'-' '   $100-$197           Mailbox poller, error handlers, and all driver management code
'-' '  ~$198-$1F3           State and register variables
'-' '
'-' ' Also during driver COG startup:
'-' '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
'-' ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
'-' '..................................................................................................
'-'                             
'-' ' Mailbox storage after vector initialization
'-' 
'-' req0                        call    #init                   'do HW setup/initialization
	byte	$fc, $01, $b0, $fd
'-' data0                       rdlut   c, b wz                 'read bank info          
	byte	$f0, $e3, $ab, $fa
'-' count0                      mov     a, b                    'set COGRAM address low nibble
	byte	$f0, $df, $03, $f6
'-' req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
	byte	$68, $f0, $07, $a6
'-' data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
	byte	$0a, $e2, $17, $f4
'-' count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
	byte	$50, $f0, $07, $16
'-' req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
	byte	$58, $f0, $07, $46
'-' data2                       mov     c, #$8                  'setup vector base to $80
	byte	$08, $e2, $07, $f6
'-' count2                      setnib  a, c, #1                'prepare vector base address for bank
	byte	$f1, $df, $0b, $f8
'-' req3                        altd    a, #0                   'prepare COG destination read address
	byte	$00, $de, $8f, $f9
'-' data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
	byte	$61, $01, $a4, $fa
'-' count3                      incmod  c, #15 wz               'next vector
	byte	$0f, $e2, $0f, $f7
'-' req4        if_nz           jmp     #count2                 'repeat
	byte	$ec, $ff, $9f, $5d
'-' data4                       incmod  b, #15 wz               'next bank
	byte	$0f, $e0, $0f, $f7
'-' count4      if_nz           jmp     #data0                  'repeat
	byte	$c8, $ff, $9f, $5d
'-' req5                        mov     ptra, #$20              'setup base LUT address to clear
	byte	$20, $f0, $07, $f6
'-' data5                       rep     #5, #80                 'update next 80 longs      
	byte	$50, $0a, $dc, $fc
'-' count5                      cmp     ptra, header wc         'check if LUT address range 
	byte	$e2, $f1, $13, $f2
'-' req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
	byte	$e3, $f1, $93, $32
'-' data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
	byte	$61, $01, $3c, $cc
'-' count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
	byte	$61, $b1, $37, $3c
'-' req7        if_nc           add     $-1, const512           'increment source of LUT write data
	byte	$a5, $29, $00, $31
'-' data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
	byte	$ff, $c0, $03, $f6
'-' count7      _ret_           mov     255, #dolist            'setup list address, return to notify
	byte	$26, $ff, $05, $06
'-' 
'-' ' Mailbox parameter addresses per COG once patched
'-'                             
'-' cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
	byte	$04, $00, $00, $00
'-' cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
	byte	$10, $00, $00, $00
'-' cog2mboxdata                long    2*12+4                  '...
	byte	$1c, $00, $00, $00
'-' cog3mboxdata                long    3*12+4
	byte	$28, $00, $00, $00
'-' cog4mboxdata                long    4*12+4
	byte	$34, $00, $00, $00
'-' cog5mboxdata                long    5*12+4
	byte	$40, $00, $00, $00
'-' cog6mboxdata                long    6*12+4
	byte	$4c, $00, $00, $00
'-' cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
	byte	$58, $00, $00, $00
'-' 
'-' '..................................................................................................
'-' ' Per COG request and state setup and service branching
'-'         
'-' cog0                 
'-'                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
	byte	$20, $f0, $07, $f6
'-'                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
	byte	$18, $f2, $03, $f6
'-'                             mov     id, id0                 'get COG0 state
	byte	$d0, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG0 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$30, $04, $90, $5d
'-'                             mov     addr1, req0             'get mailbox request parameter for COG0
	byte	$00, $b0, $03, $f6
'-'                             mov     hubdata, data0          'get COG0 mailbox data parameter
	byte	$01, $b2, $03, $f6
'-'                             mov     count, count0           'get COG0 mailbox count parameter
	byte	$02, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog1                        
'-'                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
	byte	$2a, $f0, $07, $f6
'-'                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
	byte	$19, $f2, $03, $f6
'-'                             mov     id, id1                 'get COG1 state
	byte	$d1, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG1 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$00, $04, $90, $5d
'-'                             mov     addr1, req1             'get mailbox request parameter for COG1
	byte	$03, $b0, $03, $f6
'-'                             mov     hubdata, data1          'get COG1 mailbox data parameter
	byte	$04, $b2, $03, $f6
'-'                             mov     count, count1           'get COG1 mailbox count parameter
	byte	$05, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog2                         
'-'                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
	byte	$34, $f0, $07, $f6
'-'                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
	byte	$1a, $f2, $03, $f6
'-'                             mov     id, id2                 'get COG2 state
	byte	$d2, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG2 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$d0, $03, $90, $5d
'-'                             mov     addr1, req2             'get mailbox request parameter for COG2
	byte	$06, $b0, $03, $f6
'-'                             mov     hubdata, data2          'get COG2 mailbox data parameter
	byte	$07, $b2, $03, $f6
'-'                             mov     count, count2           'get COG2 mailbox count parameter
	byte	$08, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog3                        
'-'                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
	byte	$3e, $f0, $07, $f6
'-'                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
	byte	$1b, $f2, $03, $f6
'-'                             mov     id, id3                 'get COG3 state
	byte	$d3, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG3 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$a0, $03, $90, $5d
'-'                             mov     addr1, req3             'get mailbox request parameter for COG3
	byte	$09, $b0, $03, $f6
'-'                             mov     hubdata, data3          'get COG3 mailbox data parameter
	byte	$0a, $b2, $03, $f6
'-'                             mov     count, count3           'get COG3 mailbox count parameter
	byte	$0b, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog4                        
'-'                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
	byte	$48, $f0, $07, $f6
'-'                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
	byte	$1c, $f2, $03, $f6
'-'                             mov     id, id4                 'get COG4 state
	byte	$d4, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG4 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$70, $03, $90, $5d
'-'                             mov     addr1, req4             'get mailbox request parameter for COG4
	byte	$0c, $b0, $03, $f6
'-'                             mov     hubdata, data4          'get COG4 mailbox data parameter
	byte	$0d, $b2, $03, $f6
'-'                             mov     count, count4           'get COG4 mailbox count parameter
	byte	$0e, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog5                        
'-'                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
	byte	$52, $f0, $07, $f6
'-'                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
	byte	$1d, $f2, $03, $f6
'-'                             mov     id, id5                 'get COG5 state
	byte	$d5, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG5 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$40, $03, $90, $5d
'-'                             mov     addr1, req5             'get mailbox request parameter for COG5
	byte	$0f, $b0, $03, $f6
'-'                             mov     hubdata, data5          'get COG5 mailbox data parameter
	byte	$10, $b2, $03, $f6
'-'                             mov     count, count5           'get COG5 mailbox count parameter
	byte	$11, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog6                        
'-'                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
	byte	$5c, $f0, $07, $f6
'-'                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
	byte	$1e, $f2, $03, $f6
'-'                             mov     id, id6                 'get COG6 state
	byte	$d6, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG6 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$10, $03, $90, $5d
'-'                             mov     addr1, req6             'get mailbox request parameter for COG6
	byte	$12, $b0, $03, $f6
'-'                             mov     hubdata, data6          'get COG6 mailbox data parameter
	byte	$13, $b2, $03, $f6
'-'                             mov     count, count6           'get COG6 mailbox count parameter
	byte	$14, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog7                        
'-'                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
	byte	$66, $f0, $07, $f6
'-'                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
	byte	$1f, $f2, $03, $f6
'-'                             mov     id, id7                 'get COG7 state
	byte	$d7, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG7 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$e0, $02, $90, $5d
'-'                             mov     addr1, req7             'get mailbox request parameter for COG7
	byte	$15, $b0, $03, $f6
'-'                             mov     hubdata, data7          'get COG7 mailbox data parameter
	byte	$16, $b2, $03, $f6
'-'                             mov     count, count7           'get COG7 mailbox count parameter
	byte	$17, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-'                             fit     128
'-' 
'-'                             fit     128
'-' pad                         long    0[128-$]                'align init code to $80
'-' 
'-' '..................................................................................................
'-' 
'-' ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
'-' 
'-' init                        
'-'                             ' get driver scratch long address in hub
'-'                             cogid   hubscratch              'get cogid
	byte	$01, $da, $63, $fd
'-'                             add     hubscratch, #1          'increase by 1 from 1-8
	byte	$01, $da, $07, $f1
'-'                             mul     hubscratch, #4          'multiply by 4 to get 4-32
	byte	$04, $da, $07, $fa
'-'                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
	byte	$f9, $db, $c3, $f2
'-'                     
'-'                             ' read in the additional LUT RAM code
'-'                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
	byte	$f9, $41, $03, $f1
'-'                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
	byte	$29, $9e, $67, $fd
'-'                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
	byte	$a0, $61, $00, $fb
'-' 
'-'                             ' read the startup parameters
'-'                             setq    #8-1                    'read 8 longs from hub
	byte	$28, $0e, $64, $fd
'-'                             rdlong  startupparams, ptra     '.. as the startup parameters 
	byte	$00, $41, $07, $fb
'-' 
'-'                             ' setup some of the config flag dependent state and patch LUTRAM
'-'                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
	byte	$1c, $42, $0f, $f4
'-' 
'-'             if_z            add     expansion, ptrb         'compensate for HUB address
	byte	$f9, $71, $03, $a1
'-'             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
	byte	$01, $00, $00, $5f, $fb, $70, $07, $56
'-'                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
	byte	$1d, $42, $17, $f4
'-'             if_nc           or      clkconfig, registered   'enable this if so
	byte	$aa, $57, $43, $35
'-'             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
	byte	$00, $58, $07, $36
'-' 
'-'                             ' setup data pin modes and data bus pin group in streamer commands
'-'                             and     datapins, #%111000      'compute base pin
	byte	$38, $48, $07, $f5
'-'                             or      datapins, ##(15<<6)     'configure 16 pins total
	byte	$01, $00, $00, $ff, $c0, $49, $47, $f5
'-'                             mov     a, datapins             'get data pin base
	byte	$a4, $df, $03, $f6
'-'                             wrpin   registered, datapins    'prepare data pins for address phase transfer
	byte	$a4, $55, $03, $fc
'-'                             shr     a, #3                   'determine data pin group
	byte	$03, $de, $47, $f0
'-'                             and     a, #7                   'ignore the unwanted bits
	byte	$07, $de, $07, $f5
'-'                             or      a, #8
	byte	$08, $de, $47, $f5
'-'                             setnib  ximm8lut, a, #5         'setup bus group in streamer
	byte	$ef, $2f, $2b, $f8
'-'                             setnib  xrecvlo8, a, #5
	byte	$ef, $31, $2b, $f8
'-'                             setnib  xrecvdata, a, #5
	byte	$ef, $35, $2b, $f8
'-'                             setnib  xsenddata, a, #5
	byte	$ef, $37, $2b, $f8
'-'                             setnib  xsendimm, a, #5
	byte	$ef, $39, $2b, $f8
'-'                             add     a, #1
	byte	$01, $de, $07, $f1
'-'                             setnib  xrecvhi8, a, #5         ' increase port by one
	byte	$ef, $33, $2b, $f8
'-'  
'-'                             ' setup device control pin states
'-'                             setq2   #32-1                   'read 32 longs to LUTRAM
	byte	$29, $3e, $64, $fd
'-'                             rdlong  $000, devicelist        'read bank/pin data for all banks    
	byte	$a5, $01, $00, $fb
'-'                             mov     const512, ##512         'prepare constant
	byte	$01, $00, $00, $ff, $00, $4a, $07, $f6
'-' 
'-'                             mov     ptrb, #16               'point to bank pin config data
	byte	$10, $f2, $07, $f6
'-'                             rep     @pinloop, #16           'iterate through 16 banks
	byte	$10, $14, $dc, $fc
'-'                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
	byte	$e1, $cf, $b7, $fa
'-'                             and     pinconfig, pinmask      'save us from invalid bits in args
	byte	$af, $cf, $03, $f5
'-'             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
	byte	$e7, $53, $e3, $38
'-'             if_nc           wrpin   #0, cspin               'clear smart pin mode
	byte	$a9, $01, $08, $3c
'-'             if_nc           drvh    cspin                   'setup pins for all banks
	byte	$59, $52, $63, $3d
'-'             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
	byte	$e7, $51, $eb, $38
'-'             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
	byte	$50, $50, $63, $3d
'-'             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
	byte	$a8, $57, $03, $3c
'-'             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
	byte	$a8, $03, $18, $3c
'-'             if_nc           drvl    clkpin                  'set clk state low
	byte	$58, $50, $63, $3d
'-' pinloop
'-'                             ' generate minimum CE high time before access
'-'                             qdiv    frequency, ##1000000    'convert from Hz to MHz
	byte	$a1, $07, $00, $ff, $40, $40, $17, $fd
'-'                             getqx   c                       'get P2 clocks per microsecond
	byte	$18, $e2, $63, $fd
'-'                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
	byte	$96, $de, $07, $f6
'-'                             mul     a, c                    'convert microseconds to clocks
	byte	$f1, $df, $03, $fa
'-'                             waitx   a                       'delay
	byte	$1f, $de, $63, $fd
'-'                             call    #hwinit                 'setup HW into QSPI mode
	byte	$e8, $05, $b0, $fd
'-' 
'-'                             ' setup the COG mailboxes and addresses 
'-'                             rep     #2, #8                  'setup loop to patch mailbox addresses
	byte	$08, $04, $dc, $fc
'-'                             alti    $+1, #%111_000          'increase D field
	byte	$38, $70, $a5, $f9
'-'                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
	byte	$a7, $31, $00, $f1
'-' 
'-'                             setq    #24-1
	byte	$28, $2e, $64, $fd
'-'                             wrlong  #0, mbox                'clear out mailboxes ????
	byte	$a7, $01, $68, $fc
'-' 
'-'                             ' setup the polling loop for active COGs 
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             alts    id, #id0                'determine id register of control COG
	byte	$d0, $c3, $97, $f9
'-'                             setd    patchid, #0             'patch into destination address
	byte	$00, $90, $b6, $f9
'-'                             push    ptra                    'save ptra before we lose it
	byte	$2a, $f0, $63, $fd
'-'                             mov     ptra, #10
	byte	$0a, $f0, $07, $f6
'-'                             mul     ptra, id
	byte	$e1, $f1, $03, $fa
'-'                             add     ptra, #$20              'prep ptra for reloadcogs
	byte	$20, $f0, $07, $f1
'-'                             alts    id, #cog0_handler       'add to handler base
	byte	$b0, $c3, $97, $f9
'-'                             sets    ctrlpollinst, #0-0      'patch into jump instruction
	byte	$00, $48, $be, $f9
'-'                             mul     id, #3
	byte	$03, $c2, $07, $fa
'-'                             setd    ctrlpollinst, id
	byte	$e1, $49, $b2, $f9
'-'                             rdlut   id, ptra[9]             'save original value
	byte	$09, $c3, $a7, $fa
'-'                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
	byte	$09, $c1, $37, $fc
'-'                             call    #reloadcogs
	byte	$d8, $01, $b0, $fd
'-'                             wrlut   id, ptra[9]             'restore original value
	byte	$09, $c3, $37, $fc
'-'                             pop     ptra                    'restore original ptra
	byte	$2b, $f0, $63, $fd
'-'                             ' move LUT control vectors into temporary location to avoid clobbering them later
'-'                             setd    d, #addr1
	byte	$d8, $e5, $b7, $f9
'-'                             sets    d, #(ctrl_vect & $1ff)
	byte	$60, $e4, $bf, $f9
'-'                             rep     #2, #8
	byte	$08, $04, $dc, $fc
'-'                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
	byte	$3f, $e4, $a7, $f9
'-'                             rdlut   addr1-0, #$60-0
	byte	$60, $b0, $a7, $fa
'-' 
'-'                             'setup control COG service handling, we need to patch 5 instructions
'-'                             'one existing instruction is moved earlier and four instructions get replaced
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             mov     a, #(cog1-cog0)         'get code separation of handlers
	byte	$0c, $de, $07, $f6
'-'                             mul     a, id                   'scale ID by separation
	byte	$e1, $df, $03, $fa
'-'                             add     a, #cog0+4              'add to base for COG0 and offset
	byte	$24, $de, $07, $f1
'-'                             setd    d, a                    'set this as the destination
	byte	$ef, $e5, $b3, $f9
'-'                             add     a, #2                   'increment COG address
	byte	$02, $de, $07, $f1
'-'                             sets    d, a                    'set this as the source
	byte	$ef, $e5, $bb, $f9
'-'                             alti    d, #%111_100             
	byte	$3c, $e4, $a7, $f9
'-'                             mov     0-0, 0-0                'move instruction
	byte	$00, $00, $00, $f6
'-'                             sets    d, #controlpatch        'set source of patched instructions
	byte	$ee, $e4, $bf, $f9
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             add     d, const512             'skip two instructions
	byte	$a5, $e5, $03, $f1
'-'                             add     d, const512
	byte	$a5, $e5, $03, $f1
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             
'-'                             ' setup register values for control vector loop setup after we return
'-'                             mov     header, id              'get cog ID
	byte	$e1, $c5, $03, $f6
'-'                             mul     header, #10             'multiply by size of state memory per COG
	byte	$0a, $c4, $07, $fa
'-'                             add     header, #$20            'add to COG state base address in LUT
	byte	$20, $c4, $07, $f1
'-'                             mov     trailer, header         'determine start/end LUT address
	byte	$e2, $c7, $03, $f6
'-'                             add     trailer, #9             '...for control region
	byte	$09, $c6, $07, $f1
'-'                             or      id, initctrl            'set id field for control COG
	byte	$e0, $c3, $43, $f5
'-'                             altd    id, #id0
	byte	$d0, $c3, $8f, $f9
'-'                             mov     0-0, id                 'setup id field for notification
	byte	$e1, $01, $00, $f6
'-'                             mov     ptrb, ptra              'get startup parameter address
	byte	$f8, $f3, $03, $f6
'-'                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
	byte	$04, $f2, $07, $f1
'-'                             mov     b, #0                   'prepare b for upcoming loop
	byte	$00, $e0, $07, $f6
'-'                 _ret_       push    #notify                 'continue init in mailbox area
	byte	$2a, $14, $66, $0d
'-'  
'-' controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
	byte	$d8, $cb, $7b, $f8
'-'                             and     request, #7
	byte	$07, $ca, $07, $f5
'-'                             add     request, ptra           'add request vector offset
	byte	$f8, $cb, $03, $f1
'-'                             rdlut   request, request        'lookup jump vector service table 
	byte	$e5, $cb, $a3, $fa
'-'                             fit     $100                    'ensure all init code fits this space
'-' 
'-'                             fit     $100                    'ensure all init code fits this space
'-' 
'-'                             long    0[$100-$]               'pad more if required until table ends
	byte	$00[56]
'-' 
'-' '..................................................................................................
'-' ' Error result handling and COG notification of request completion
'-' 
'-' unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
	byte	$04, $04, $4c, $fb
'-' invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
	byte	$03, $02, $4c, $fb
'-' invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
	byte	$02, $06, $4c, $fb
'-' alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
	byte	$01, $08, $4c, $fb
'-' busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
	byte	$05, $ec, $07, $f6
'-' err                         altd    id, #id0                'adjust for the running COG
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
	byte	$09, $00, $04, $f4
'-'                             wrlut   #0, ptra[8]             'cancel any resume state
	byte	$08, $01, $3c, $fc
'-'                             skipf   #%10                    'dont notify with success code 0 below
	byte	$32, $04, $64, $fd
'-'                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
	byte	$bf, $ed, $67, $fc
'-' notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
	byte	$bf, $01, $6c, $fc
'-'                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
	byte	$0b, $c2, $0f, $f4
'-'                             decod   a, id                   'convert COG ID to bitmask
	byte	$e1, $df, $c3, $f9
'-'             if_z            cogatn  a                       'notify COG via ATN
	byte	$3f, $de, $63, $ad
'-' ' Poller re-starts here after a COG is serviced
'-' poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
	byte	$0f, $c2, $0f, $f4
'-'             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
	byte	$e6, $5f, $03, $57
'-'                             bmask   mask, rrcounter         'generate a RR skip mask from the count
	byte	$af, $45, $cb, $f9
'-' ' Main dynamic polling loop repeats until a request arrives
'-' polling_loop                rep     #0-0, #0                'repeat until we get a request for something
	byte	$00, $00, $dc, $fc
'-'                             setq    #24-1                   'read 24 longs
	byte	$28, $2e, $64, $fd
'-'                             rdlong  req0, mbox              'get all mailbox requests and data longs
	byte	$a7, $01, $00, $fb
'-' 
'-' polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
	byte	$b0, $01, $b0, $fb
'-'                             skipf   mask                    ']after all priority COG handlers if present
	byte	$32, $44, $63, $fd
'-'                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']based on the active COGs being polled
	byte	$b6, $25, $b0, $fb
'-'                             tjs     req7, cog7_handler      ']and whether priority or round robin.
	byte	$b7, $2b, $b0, $fb
'-'                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']have changed.
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
	byte	$b6, $25, $b0, $fb
'-' pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
	byte	$b7, $2b, $b0, $fb
'-' 
'-' ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
	byte	$b0, $01, $b0, $fb
'-' skipfinst                   skipf   mask                    'instruction template for skipf
	byte	$32, $44, $63, $fd
'-'  
'-' '..................................................................................................
'-' ' List handler                               
'-' 
'-' dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
	byte	$01, $b0, $a7, $fb
'-'                             execf   burstwrite              'otherwise do a burst write to this bank
	byte	$33, $c0, $63, $fd
'-' real_list                   setq    #8-1                    'read 8 longs (largest request size)
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, hubdata          '..to update the request state
	byte	$d9, $b1, $03, $fb
'-'                             tjns    addr1, #invalidlist     'error if request list item not valid
	byte	$d7, $b1, $bf, $fb
'-'                             altd    id, #id0                'get COG state
	byte	$d0, $c3, $8f, $f9
'-'                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
	byte	$09, $00, $3c, $f4
'-'                             bith    id, #LIST_BIT           'retain fact that we are in a list
	byte	$09, $c2, $27, $f4
'-'             if_z            jmp     #unsupported            'no list recursion is allowed!
	byte	$44, $ff, $9f, $ad
'-'                             getbyte request, addr1, #3      'get upper byte of this request
	byte	$d8, $cb, $fb, $f8
'-' service_request             altd    request, #0             'get request address in COG RAM
	byte	$00, $ca, $8f, $f9
'-'                             execf   0-0                     'process the request 
	byte	$33, $00, $60, $fd
'-' 
'-' '..................................................................................................
'-' ' Restoring per COG state and resuming where we left off
'-' 
'-' restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
	byte	$00, $b1, $a7, $fa
'-'                             rdlut   hubdata, ptra[1]
	byte	$01, $b3, $a7, $fa
'-'                             rdlut   count, ptra[2]
	byte	$02, $b5, $a7, $fa
'-'                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
	byte	$03, $b7, $b7, $fa
'-'                             getbyte request, addr1, #3
	byte	$d8, $cb, $fb, $f8
'-'             if_nc           execf   resume                  'if not extended then resume immediately
	byte	$33, $d2, $63, $3d
'-'                             rdlut   total, ptra[4]          'we need to read the extended parameters
	byte	$04, $b9, $a7, $fa
'-'                             rdlut   offset1, ptra[5]
	byte	$05, $bb, $a7, $fa
'-'                             rdlut   offset2, ptra[6]
	byte	$06, $bd, $a7, $fa
'-'                             rdlut   link, ptra[7]
	byte	$07, $bf, $a7, $fa
'-'                             rdlut   orighubsize, ptra[9]
	byte	$09, $d5, $a7, $fa
'-'                             execf   resume                  'then resume what we were doing last time
	byte	$33, $d2, $63, $fd
'-'                    
'-' '..................................................................................................
'-' ' Re-configuration of QoS settings and custom polling loop sequence generator
'-' 
'-' reconfig                    push    #notify                 'setup return addr, then reload 
	byte	$2a, $14, $66, $fd
'-' reloadcogs                  setq    #8-1                    'reload all per COG QoS params
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
	byte	$a6, $b1, $03, $fb
'-'                             setd    a, #id0
	byte	$d0, $df, $b7, $f9
'-'                             sets    a, #addr1
	byte	$d8, $df, $bf, $f9
'-'                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
	byte	$fe, $ff, $ff, $ff, $28, $00, $66, $fd
'-'                             rep     #2, #8                  'repeat for 8 COGs
	byte	$08, $04, $dc, $fc
'-'                             alti    a, #%111_111 
	byte	$3f, $de, $a7, $f9
'-'                             muxq    0-0, 0-0
	byte	$00, $00, $f0, $f9
'-' patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
	byte	$09, $01, $a4, $fa
'-'                             cogid   c
	byte	$01, $e2, $63, $fd
'-'                             decod   excludedcogs, c         'exclude driver cog initially
	byte	$f1, $41, $c3, $f9
'-'                             mov     a, #$8                  'a iterates through prio levels 8=lowest
	byte	$08, $de, $07, $f6
'-'                             neg     pa, #1                  'start with all ones
	byte	$01, $ec, $67, $f6
'-' fillprio                    mov     c, #7                   'c iterates through cogs
	byte	$07, $e2, $07, $f6
'-' prioloop                    alts    c, #id0
	byte	$d0, $e3, $97, $f9
'-'                             mov     b, 0-0
	byte	$00, $e0, $03, $f6
'-'                             getword d, b, #1                'get burst field
	byte	$f0, $e5, $3b, $f9
'-'                             test    d wz                    'if burst=0 
	byte	$f2, $e5, $cb, $f7
'-'             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
	byte	$f1, $41, $23, $a4
'-'             if_z            jmp     #excluded               
	byte	$0c, $00, $90, $ad
'-'                             getnib  d, b, #3                'get RR/PRI flag & priority
	byte	$f0, $e5, $5b, $f8
'-'                             cmp     d, a wz                 'compare against current priority level
	byte	$ef, $e5, $0b, $f2
'-'             if_z            rolnib  pa, c, #0               'if matches include COG at this level
	byte	$f1, $ed, $83, $a8
'-' excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
	byte	$f6, $e3, $7f, $fb
'-'                             incmod  a, #15 wz               'next level
	byte	$0f, $de, $0f, $f7
'-'             if_nz           jmp     #fillprio 
	byte	$cc, $ff, $9f, $5d
'-' 
'-' 'determine priority cogs and build instructions for the polling sequence
'-'                             mov     pb, #0                  'clear out set of priority COGs
	byte	$00, $ee, $07, $f6
'-'                             mov     a, #3                   'start with no COGs being polled + 3 instructions
	byte	$03, $de, $07, $f6
'-'                             setd    d, #polling_code        'initialize COGRAM write position
	byte	$14, $e5, $b7, $f9
'-' 
'-'                             rep     @endprioloop, #8        'test all 8 priority slots
	byte	$08, $18, $dc, $fc
'-'                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
	byte	$03, $ec, $17, $f4
'-'                             getnib  c, pa, #0               'get cogid ID at this priority level
	byte	$f6, $e3, $43, $f8
'-'             if_nc           testb   pb, c wz                'check if already exists as priority COG
	byte	$f1, $ef, $0b, $34
'-'             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
	byte	$f1, $ef, $23, $14
'-'             if_nc_and_nz    add     a, #1                   'add another COG to poll 
	byte	$01, $de, $07, $11
'-'             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
	byte	$b0, $e3, $97, $19
'-'             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $19
'-'             if_nc_and_nz    mul     c, #3
	byte	$03, $e2, $07, $1a
'-'             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
	byte	$f1, $47, $b2, $19
'-'             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $19
'-'             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $16
'-'                             ror     pa, #4                  'advance to next priority
	byte	$04, $ec, $07, $f0
'-' endprioloop
'-'                             xor     pb, #$ff                'invert to find all the non-priority COGs
	byte	$ff, $ee, $67, $f5
'-'                             andn    pb, excludedcogs        'and remove any other excluded COGs
	byte	$a0, $ef, $23, $f5
'-'                             ones    rrlimit, pb wz          'count the number of RR COGs
	byte	$f7, $cd, $ab, $f7
'-'                             add     a, rrlimit              'account for this number of RR COGs to poll
	byte	$e6, $df, $03, $f1
'-'                             sub     rrlimit, #1             'setup last RR count value for incmod
	byte	$01, $cc, $87, $f1
'-'                             alti    d, #%111_000            'generate the control polling instruction
	byte	$38, $e4, $a7, $f9
'-'                             mov     0-0, ctrlpollinst       'write the instruction
	byte	$24, $01, $00, $f6
'-'             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
	byte	$38, $e4, $a7, $59
'-'             if_nz           mov     0-0, skipfinst          'add the skipf instruction
	byte	$25, $01, $00, $56
'-'             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
	byte	$02, $de, $07, $51
'-'                             setd    polling_loop, a         'save it as the repeat count
	byte	$ef, $23, $b2, $f9
'-'             if_z            ret                             'we are done now, if no round robin COGs
	byte	$2d, $00, $64, $ad
'-' 
'-' ' populate the round robin COG polling instructions
'-'                             mov     rrcounter, #2           'fill the RR poll instruction list twice
	byte	$02, $5e, $07, $f6
'-' rrloop                      mov     b, pb                   'get the set of RR COGs
	byte	$f7, $e1, $03, $f6
'-'                             mov     c, #0                   'start at COG ID = 0
	byte	$00, $e2, $07, $f6
'-'                             mov     a, #0                   'req mailbox COGRAM address for COG 0
	byte	$00, $de, $07, $f6
'-' nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
	byte	$01, $e0, $5f, $f0
'-'             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
	byte	$ef, $47, $b2, $c9
'-'             if_c            alts    c, #cog0_handler        'determine jump address
	byte	$b0, $e3, $97, $c9
'-'             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $c9
'-'             if_c            alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $c9
'-'             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $c6
'-'                             add     c, #1                   'increment the COG ID
	byte	$01, $e2, $07, $f1
'-'                             add     a, #3                   'increase the request address
	byte	$03, $de, $07, $f1
'-'             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
	byte	$dc, $ff, $9f, $5d
'-'             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
	byte	$f3, $5f, $6f, $0b
'-' '..................................................................................................
'-' ' Code to get/set driver settings per bank or to dump COG/LUT state
'-' 
'-' set_latency                                                 '            (a) set latency
'-' get_latency                                                 '            (b) get latency
'-' set_burst                                                   '            (c) set burst size of bank
'-' get_burst                                                   '            (d) get burst size of bank
'-'                                                             '            (e) dump state
'-'                             getnib  b, addr1, #6            ' a b c d    get bank address
	byte	$d8, $e1, $73, $f8
'-' dump_state                  setq    #511                    ' | | | | e  prepare burst write
	byte	$28, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                                                             ' | | | | e  account for following AUGS
'-'                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
	byte	$04, $00, $00, $ff, $00, $b2, $07, $f1
'-'                             setq2   #511                    ' | | | | e  prepare burst write
	byte	$29, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                             add     b, #16                  ' a b | | |  point to latency params
	byte	$10, $e0, $07, $f1
'-'                             rdlut   a, b                    ' a b c d |  read data for bank
	byte	$f0, $df, $a3, $fa
'-'                             setbyte a, hubdata, #3          ' a | | | |  patch latency
	byte	$d9, $df, $db, $f8
'-'                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
	byte	$d9, $df, $03, $f6
'-'                             wrlut   a, b                    ' a | c | |  if setting, save bank data
	byte	$f0, $df, $33, $fc
'-'                             getbyte a, a, #3                ' | b | | |  extract latency field only
	byte	$ef, $df, $fb, $f8
'-'                             wrlong  a, ptrb                 ' | b | d |  write result          
	byte	$80, $df, $67, $fc
'-'                             jmp     #notify                 ' a b c d e  return success
	byte	$dc, $fd, $9f, $fd
'-' 
'-' '..................................................................................................
'-' ' Misc EXECF code
'-' 
'-' start_read_exec             execf   newburstr
	byte	$33, $72, $63, $fd
'-' start_write_exec            execf   resumewrites
	byte	$33, $7c, $63, $fd
'-' continue_read_exec          execf   lockedreads
	byte	$33, $78, $63, $fd
'-' continue_write_exec         execf   lockedwrites
	byte	$33, $7a, $63, $fd
'-' 
'-' '..................................................................................................
'-' ' Variables
'-' 
'-' ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
	byte	$08, $00, $cf, $20
'-' xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
	byte	$00, $00, $c0, $f0
'-' xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
	byte	$00, $00, $c0, $b0
'-' xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
	byte	$02, $00, $c0, $70
'-' 
'-' xfreq1          long    $80000000
	byte	$00, $00, $00, $80
'-' xfreq2          long    $40000000
	byte	$00, $00, $00, $40
'-' delay           long    3
	byte	$03, $00, $00, $00
'-' 
'-' lutcodeaddr                 
'-' startupparams
'-' excludedcogs                                    'careful: shared register use!
'-' frequency       long    lut_code - driver_start 'determine offset of LUT code from base
	byte	$cc, $07, $00, $00
'-' flags           long    0
	byte	$00, $00, $00, $00
'-' mask                                            'careful: shared register use!
'-' resetmaskA      long    0
	byte	$00, $00, $00, $00
'-' limit                                           'careful: shared register use!
'-' resetmaskB      long    0
	byte	$00, $00, $00, $00
'-' datapins        long    0
	byte	$00, $00, $00, $00
'-' const512                                        'careful: shared register use!
'-' devicelist      long    0
	byte	$00, $00, $00, $00
'-' coglist         long    0
	byte	$00, $00, $00, $00
'-' mbox            long    0 
	byte	$00, $00, $00, $00
'-' 
'-' clkpin                                          'shared with code patched during init
'-' clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
	byte	$a8, $03, $18, $fc
'-' cspin                                           'shared with code patched during init
'-' speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
	byte	$1d, $3a, $63, $fd
'-' registered      long    %100_000_000_00_00000_0 'config pin for clocked input
	byte	$00, $00, $01, $00
'-' clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
	byte	$4a, $00, $00, $00
'-' clkdelay        long    1
	byte	$01, $00, $00, $00
'-' regdatabus      long    0
	byte	$00, $00, $00, $00
'-' 
'-' deviceaddr      long    $10
	byte	$10, $00, $00, $00
'-' rrcounter
'-' pinmask         long    $ff3f7f7f
	byte	$7f, $7f, $3f, $ff
'-' 
'-' ' jump addresses for the per COG handlers
'-' cog0_handler    long    cog0
	byte	$20, $00, $00, $00
'-' cog1_handler    long    cog1
	byte	$2c, $00, $00, $00
'-' cog2_handler    long    cog2
	byte	$38, $00, $00, $00
'-' cog3_handler    long    cog3
	byte	$44, $00, $00, $00
'-' cog4_handler    long    cog4
	byte	$50, $00, $00, $00
'-' cog5_handler    long    cog5
	byte	$5c, $00, $00, $00
'-' cog6_handler    long    cog6
	byte	$68, $00, $00, $00
'-' cog7_handler    long    cog7
	byte	$74, $00, $00, $00
'-' expansion       long    gfxexpansion - driver_start
	byte	$0c, $0f, $00, $00
'-' 
'-' ' EXECF sequences
'-' newburstr       long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-' lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
	byte	$48, $9b, $ef, $00
'-' restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
	byte	$41, $f3, $05, $74
'-' lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
	byte	$80, $22, $3f, $00
'-' lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
	byte	$4b, $f3, $e0, $0f
'-' resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
	byte	$4b, $03, $e0, $0f
'-' resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
	byte	$76, $02, $8a, $84
'-' 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
'-' 
'-' 
'-' ' SKIPF sequences
'-' skiptable
'-'                 long    %11000011000001111110  ' read modify write byte
	byte	$7e, $30, $0c, $00
'-'                 long    %110011011100001110    ' read modify write word
	byte	$0e, $37, $03, $00
'-'                 long    0                      ' read modify write long
	byte	$00, $00, $00, $00
'-'                 long    %1111110               ' single byte read
	byte	$7e, $00, $00, $00
'-'                 long    %11110001110           ' single word read
	byte	$8e, $07, $00, $00
'-' pattern2        long    0
	byte	$00, $00, $00, $00
'-' pattern3        long    0
	byte	$00, $00, $00, $00
'-' singlelong      long    %1001110111  
	byte	$77, $02, $00, $00
'-' skipcase_a      long    %01101111100000000001000011111101
	byte	$fd, $10, $80, $6f
'-' skipcase_b      long    %00000000010100000001100000010000
	byte	$10, $18, $50, $00
'-' skipcase_c      long    %00000000011000000011111000010001
	byte	$11, $3e, $60, $00
'-' skipseq_write   long    %00000000000000000000111100000010
	byte	$02, $0f, $00, $00
'-' 
'-' ' LUT RAM address values
'-' complete_rw     long    complete_rw_lut
	byte	$ff, $02, $00, $00
'-' continue_read   long    continue_read_lut
	byte	$dd, $02, $00, $00
'-' continue_write  long    continue_write_lut
	byte	$db, $02, $00, $00
'-' noread          long    noread_lut
	byte	$f6, $02, $00, $00
'-' 
'-' id0             long    0
	byte	$00, $00, $00, $00
'-' id1             long    1
	byte	$01, $00, $00, $00
'-' id2             long    2
	byte	$02, $00, $00, $00
'-' id3             long    3
	byte	$03, $00, $00, $00
'-' id4             long    4
	byte	$04, $00, $00, $00
'-' id5             long    5
	byte	$05, $00, $00, $00
'-' id6             long    6
	byte	$06, $00, $00, $00
'-' id7             long    7
	byte	$07, $00, $00, $00
'-' 
'-' 'These next 10 request registers below are also temporarily reused during init 
'-' 'and COG updates and need to follow immediately after id0-id7
'-' addr1           long    0
	byte	$00, $00, $00, $00
'-' hubdata         long    0
	byte	$00, $00, $00, $00
'-' count           long    0
	byte	$00, $00, $00, $00
'-' addr2           long    0
	byte	$00, $00, $00, $00
'-' total           long    0
	byte	$00, $00, $00, $00
'-' offset1         long    0
	byte	$00, $00, $00, $00
'-' offset2         long    0
	byte	$00, $00, $00, $00
'-' link            long    0
	byte	$00, $00, $00, $00
'-' 
'-' burstwrite                                      'note shared register use during init
'-' initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
	byte	$00, $10, $f0, $fe
'-' id              long    0
	byte	$00, $00, $00, $00
'-' 
'-' header          long    0
	byte	$00, $00, $00, $00
'-' trailer         long    0
	byte	$00, $00, $00, $00
'-' cmdaddr         long    0
	byte	$00, $00, $00, $00
'-' request         long    0
	byte	$00, $00, $00, $00
'-' rrlimit         long    0
	byte	$00, $00, $00, $00
'-' pinconfig       long    0
	byte	$00, $00, $00, $00
'-' clks            long    0
	byte	$00, $00, $00, $00
'-' resume          long    0
	byte	$00, $00, $00, $00
'-' orighubsize     long    0
	byte	$00, $00, $00, $00
'-' wrclks          long    0
	byte	$00, $00, $00, $00
'-' 
'-' pattern         long    0
	byte	$00, $00, $00, $00
'-' hubscratch      long    0
	byte	$00, $00, $00, $00
'-' val4k           long    4096
	byte	$00, $10, $00, $00
'-' 
'-' ' temporary general purpose regs
'-' a               long    0
	byte	$00, $00, $00, $00
'-' b               long    0
	byte	$00, $00, $00, $00
'-' c               long    0
	byte	$00, $00, $00, $00
'-' d               long    0
	byte	$00, $00, $00, $00
'-'                 fit     502
'-' 
'-'                 fit     502
'-' 
'-' '..................................................................................................
'-' 
'-'             orgh
'-' 
'-' lut_code
'-' 'HW init code up to 80 longs
'-' 
'-' '..................................................................................................
'-' ' Memory layout for LUT RAM once operational:
'-' '
'-' '  LUT RAM address      Usage
'-' '  ---------------      ----
'-' '    $200-$20F          Bank parameters: burst + type + size per bank (16)
'-' '    $210-$21F          Pin parameters : latency + control pins per bank (16)
'-' '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
'-' '    $270-$3FF          Main PSRAM access code in LUTRAM 
'-' '
'-' ' Also during driver COG startup:
'-' ' $230-$24F is used for HW init setup
'-' ' $250-$26F is used as temporary vector storage 
'-' '..................................................................................................
'-' 
'-'                 org $230    
'-' 
'-' ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
'-' hwinit                      setxfrq xfreq2
	byte	$1d, $3c, $63, $fd
'-'                             pollxfi
	byte	$24, $16, $60, $fd
'-'                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
	byte	$ff, $aa, $2a, $ff, $ff, $ed, $07, $f6
'-'                             call    #sendqspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$0FF00FF0         '$66 - reset enable
	byte	$07, $f8, $07, $ff, $f0, $ed, $07, $f6
'-'                             call    #sendspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$F00FF00F         '$99 - reset
	byte	$f8, $07, $78, $ff, $0f, $ec, $07, $f6
'-'                             call    #sendspi
	byte	$1c, $00, $b0, $fd
'-'                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
	byte	$7f, $78, $78, $ff, $00, $ed, $07, $f6
'-'                             call    #sendspi 
	byte	$10, $00, $b0, $fd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-' 
'-' sendqspi                    mov     clks,#4
	byte	$04, $d0, $07, $f6
'-'                             skipf   #%110
	byte	$32, $0c, $64, $fd
'-'                             mov     pb, xsendimm
	byte	$9c, $ef, $03, $f6
'-' 
'-' sendspi                     mov     clks, #16
	byte	$10, $d0, $07, $f6
'-'                             mov     pb, ximm8lut
	byte	$97, $ef, $03, $f6
'-'                             drvl    cspin                   'active low chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   pb, pa                  'send 32 bit immediate data
	byte	$f6, $ef, $a3, $fc
'-'                             wypin   clks, clkpin            'start memory clock output 
	byte	$a8, $d1, $23, $fc
'-'                             waitxfi                         'wait for the completion
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                'float data bus
	byte	$50, $48, $63, $fd
'-'                             drvh    cspin                   'raise chip select
	byte	$59, $52, $63, $fd
'-'             _ret_           waitx   #200                    'delay before return to ensure CS delay
	byte	$1f, $90, $65, $0d
'-' 
'-'                 long    0[$270-32-$]
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-'     
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-' ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
'-' rw_vect ' PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    (%0111010000000000111000 << 10) + w_single
	byte	$41, $e3, $00, $74
'-'                 long    (%0111010000000000100100 << 10) + w_single
	byte	$41, $93, $00, $74
'-'                 long    (%0111010000000000011100 << 10) + w_single
	byte	$41, $73, $00, $74
'-'                 long    (%1111111000000000000110 << 10) + w_burst
	byte	$47, $1b, $00, $fe
'-' ro_vect ' R/O PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-' ctrl_vect ' Control jump vectors
'-'                 long    (%0000000000111001111110 << 10) + get_latency
	byte	$84, $f9, $39, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000001111011111110 << 10) + get_burst
	byte	$84, $f9, $7b, $00
'-'                 long    (%0000000001111111000000 << 10) + dump_state
	byte	$85, $01, $7f, $00
'-'                 long    (%0000000011010001111110 << 10) + set_latency
	byte	$84, $f9, $d1, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000011001011111110 << 10) + set_burst
	byte	$84, $f9, $cb, $00
'-'                 long    reconfig 
	byte	$3e, $01, $00, $00
'-' no_vect ' Invalid bank jump vectors
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 fit     $270
'-' 
'-'                 fit     $270
'-' '..................................................................................................
'-' ' PSRAM READS
'-'                                                             ' a b c d e f
'-'                                                             ' B W L B R L  (a) byte read
'-'                                                             ' Y O O U E O  (b) word read
'-'                                                             ' T R N R S C  (c) long read
'-'                                                             ' E D G S U K  (d) new burst read
'-'                                                             '       T M E  (e) resumed sub-burst
'-'                                                             '         E D  (f) locked sub-burst
'-' 
'-' 
'-' r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
	byte	$da, $d5, $03, $f6
'-' r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
	byte	$da, $b5, $cb, $f7
'-'                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
	byte	$36, $d9, $07, $f6
'-'             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
	byte	$20, $d9, $27, $a5
'-'                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
	byte	$02, $34, $27, $f9
'-'                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
	byte	$80, $b4, $97, $fb
'-' r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    ' a b c d e    get bank limit/mask
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 ' | | | d e    build mask for addr
	byte	$f0, $45, $cb, $f9
'-'                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
	byte	$f0, $3f, $eb, $f8
'-' p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
	byte	$11, $e0, $47, $f0
'-'                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
	byte	$f0, $47, $23, $f3
'-'                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
	byte	$05, $3e, $57, $f0
'-'             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
	byte	$10, $5a, $67, $04
'-'                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
	byte	$10, $5a, $67, $f4
'-'                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
	byte	$f9, $3b, $83, $fc
'-' r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
	byte	$d9, $3b, $83, $fc
'-'                             mov     c, count                ' | | | d e f  get count of bytes left to read
	byte	$da, $e3, $03, $f6
'-'                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
	byte	$20, $d0, $17, $f6
'-'             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
	byte	$cd, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
	byte	$cc, $d3, $03, $36
'-'                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
	byte	$32, $20, $64, $fd
'-'                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
	byte	$54, $00, $90, $fd
'-' 
'-'                             ' fall through to read bursts
'-'                         
'-' burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
	byte	$cd, $d3, $03, $c6
'-'                             mov     pattern, #0             'enable all by default
	byte	$00, $d8, $07, $f6
'-'                             testb   addr1, #1 wc            'test if start addr starts in second word
	byte	$01, $b0, $17, $f4
'-'                             bitnc   pattern, #1             'enable delay cycle if so
	byte	$01, $d8, $67, $f4
'-'                             wrc     clks                    'and account for its clock cycle
	byte	$6c, $d0, $63, $fd
'-'                             testb   addr1, #0 wc            'test if start addr starts on odd byte
	byte	$00, $b0, $17, $f4
'-'                             bitnc   pattern, #2             'add hi 8 transfer initially
	byte	$02, $d8, $67, $f4
'-'                             mov     d, c                    'get count of bytes to be read into HUB
	byte	$f1, $e5, $03, $f6
'-'             if_c            sub     d, #1                   'minus 1 if start addr was odd
	byte	$01, $e4, $87, $c1
'-'                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
	byte	$01, $e4, $4f, $f0
'-'                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
	byte	$f2, $d1, $23, $f1
'-'                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
	byte	$f2, $35, $23, $f9
'-'                             bitz    pattern, #3             'adjust the pattern to include this
	byte	$03, $d8, $87, $f4
'-'                             testb   c, #0 xorc              'test for end address
	byte	$00, $e2, $d7, $f4
'-'                             bitnc   pattern, #4             'include low 8 bit transfer if required
	byte	$04, $d8, $67, $f4
'-'                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
	byte	$0e, $d0, $27, $f1
'-'                             add     clks, clks
	byte	$e8, $d1, $03, $f1
'-' readcommon
'-'                             mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$EB, #3       'add quad read command
	byte	$eb, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-' 
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable data bus
	byte	$58, $48, $63, $fd
'-'             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
'-'                             xinit   ximm8lut, cmdaddr       'stream out command+address
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   clks, clkpin            'start clock output
	byte	$a8, $d1, $23, $fc
'-'                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
	byte	$00, $00, $cc, $fc
'-'                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
	byte	$00, $0c, $cc, $fc
'-'                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
'-'                             fltl    datapins                'safe to float the data bus, address has been sent by now
	byte	$50, $48, $63, $fd
'-'                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
	byte	$a4, $5b, $03, $fc
'-'                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
	byte	$28, $3a, $63, $fd
'-'                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
	byte	$00, $3e, $c7, $fc
'-'                             xcont   #6, #0                  'fixed delay offset to expand delay range
	byte	$00, $0c, $cc, $fc
'-'                             skipf   pattern                 'choose path below
	byte	$32, $d8, $63, $fd
'-'                                                             'Bursts Bytes Words Longs  RMW FromWrites
'-'                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
	byte	$28, $3c, $63, $fd
'-'                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
	byte	$00, $02, $cc, $fc
'-'                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
	byte	$00, $32, $c7, $fc
'-'                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
	byte	$00, $34, $c7, $fc
'-'                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
	byte	$00, $30, $c7, $fc
'-'                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
	byte	$24, $36, $60, $fd
'-'                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
	byte	$a4, $55, $03, $fc
'-'             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
	byte	$59, $52, $63, $0d
'-'                             drvh    cspin                   '         b     c           e       deassert chip select and continue
	byte	$59, $52, $63, $fd
'-'                             getnib  d, request, #1          'get request code value
	byte	$e5, $e5, $4b, $f8
'-'             if_nz           sub     d, #3                   'offset for table if RMW
	byte	$03, $e4, $87, $51
'-'                             altd    d, #skiptable-5         'patch next instruction
	byte	$bb, $e5, $8f, $f9
'-'                             skipf   0-0                     'generate skip sequence
	byte	$32, $00, $60, $fd
'-'                                                             ' B   W  RMWB RMWW RMLL 
'-'                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
	byte	$80, $df, $07, $fb
'-'                             setq    count                   ' |   |   |    |    e   setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
	byte	$d9, $df, $f3, $f9
'-'                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
	byte	$40, $00, $90, $fd
'-'                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
	byte	$01, $b0, $17, $f4
'-'             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
	byte	$ef, $ef, $3b, $c9
'-'             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
	byte	$ef, $ef, $33, $39
'-'                             mov     d, addr1                ' a   |   c    d
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3                   ' a   |   c    |        get LSBs of address
	byte	$03, $e4, $07, $f5
'-'                             altgb   d, #a                   ' a   |   c    |        index into long
	byte	$ef, $e5, $6f, $f9
'-'                             getbyte pb                      ' a   |   c    |        and extract the byte
	byte	$00, $ee, $e3, $f8
'-'                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
	byte	$80, $ef, $67, $fc
'-'                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
	byte	$c0, $00, $b0, $fd
'-'                             ret                             ' a   b   |    |        then return
	byte	$2d, $00, $64, $fd
'-'                             setq    count                   '         c    d        setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    pb, hubdata             '         c    d        apply bit mux
	byte	$d9, $ef, $f3, $f9
'-'                             altsb   d, #a                   '         c    |
	byte	$ef, $e5, $67, $f9
'-'                             setbyte 0-0, pb, #0             '         c    |
	byte	$f7, $01, $c0, $f8
'-'             if_c            setword a, pb, #1               '         |    d
	byte	$f7, $df, $2b, $c9
'-'             if_nc           setword a, pb, #0               '         |    d
	byte	$f7, $df, $23, $39
'-' writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
	byte	$37, $8a, $07, $f6
'-'                             mov     hubdata, a              'write a to PSRAM
	byte	$ef, $b3, $03, $f6
'-'                             mov     wrclks, #20             '20 clocks to write a long
	byte	$14, $d6, $07, $f6
'-'                             mov     resume, complete_rw     'we'll complete the operation after this
	byte	$cc, $d3, $03, $f6
'-'                             jmp     #writecommon
	byte	$10, $03, $90, $fd
'-' 
'-' '..................................................................................................
'-' ' Burst continuation testing
'-' 
'-' continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
	byte	$32, $96, $63, $fd
'-'                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
	byte	$be, $d3, $03, $f6
'-' continue_read_lut          
'-'                             mov     resume, resumereads     ' | setup resume address to execf
	byte	$bf, $d3, $03, $f6
'-'                             add     hubdata, c              ' a compute the next hub addr to use
	byte	$f1, $b3, $03, $f1
'-'                             sub     count, c                ' a account for the bytes already sent
	byte	$f1, $b5, $83, $f1
'-'                             add     c, addr1                ' a compute next external mem address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    ' a configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
	byte	$14, $00, $90, $5d
'-'                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
	byte	$e1, $47, $3b, $f9
'-'                             fle     limit, b                ' | also re-apply per bank limit
	byte	$f0, $47, $23, $f3
'-'             _ret_           push    #continue_read_exec     ' | 
	byte	$2a, $2a, $67, $0d
'-'             if_nz           jmp     #yield                  ' a
	byte	$04, $00, $90, $5d
'-'             _ret_           push    #continue_write_exec    ' a
	byte	$2a, $2c, $67, $0d
'-' 
'-' yield                       wrlut   total, ptra[4]          'save context for next time
	byte	$04, $b9, $37, $fc
'-'                             wrlut   offset1, ptra[5]        'save context for next time
	byte	$05, $bb, $37, $fc
'-'                             wrlut   offset2, ptra[6]        'save context for next time
	byte	$06, $bd, $37, $fc
'-'                             wrlut   link, ptra[7]           'save context for next time
	byte	$07, $bf, $37, $fc
'-' yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
	byte	$00, $b1, $37, $fc
'-'                             wrlut   hubdata, ptra[1]        'save context for next time
	byte	$01, $b3, $37, $fc
'-'                             wrlut   count, ptra[2]          'save context for next time
	byte	$02, $b5, $37, $fc
'-'                             wrlut   addr2, ptra[3]          'save context for next time
	byte	$03, $b7, $37, $fc
'-'                             wrlut   resume, ptra[8]         'save next resume address
	byte	$08, $d3, $37, $fc
'-'                             wrlut   orighubsize, ptra[9]    'save original hub size
	byte	$09, $d5, $37, $fc
'-'             _ret_           push    #poller
	byte	$2a, $1c, $66, $0d
'-' 
'-' 
'-' notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
	byte	$32, $be, $65, $fd
'-' nowrite_lut                                                 '  (a) new skip sequence 
'-' noread_lut                  skipf   #0                      ' | cancel skipping
	byte	$32, $00, $64, $fd
'-'                             wrlut   #0, ptra[8]             ' | clear resume
	byte	$08, $01, $3c, $fc
'-'                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_nz           jmp     #notify                 ' | if not a request list then we are done
	byte	$40, $f8, $9f, $5d
'-'                             testb   addr2, #31 wz           ' | check if extended list item
	byte	$1f, $b6, $0f, $f4
'-' donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
	byte	$df, $b7, $03, $a6
'-' checklist                   call    #checknext              ' | handle running from list
	byte	$1c, $00, $b0, $fd
'-'                             ret                             ' | continue processing
	byte	$2d, $00, $64, $fd
'-'             _ret_           push    noread                  'continue end of transfer
	byte	$2a, $9e, $63, $0d
'-' '..................................................................................................
'-' ' Completion of requests
'-' 
'-' complete_rw_lut             
'-'                             testb   id, #LIST_BIT wz        'test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_z            skipf   #%10                    'if a request list then skip notification
	byte	$32, $04, $64, $ad
'-'                             wrlut   #0, ptra[8]             ' a   default is not to resume
	byte	$08, $01, $3c, $fc
'-'             _ret_           push    #notify                 ' |   if not a request list then we are done
	byte	$2a, $14, $66, $0d
'-'                             tjs     addr2, #extendedreq     '     test for special extended request  
	byte	$0d, $b6, $b7, $fb
'-' checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
	byte	$07, $b6, $97, $fb
'-'                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
	byte	$bf, $ed, $07, $fb
'-'                             tjns    pa, #listcomplete       'exit if it has
	byte	$05, $ec, $bf, $fb
'-'                             testb   id, #LOCKED_BIT wz
	byte	$0a, $c2, $0f, $f4
'-'             if_z            mov     hubdata, addr2
	byte	$db, $b3, $03, $a6
'-'             if_z            skipf   #%110001
	byte	$32, $62, $64, $ad
'-'             if_nz           skipf   #%1000                  'do not notify if list is continuing
	byte	$32, $10, $64, $5d
'-'                             wrlong  addr2, ptrb             ' a  write back next list address
	byte	$80, $b7, $67, $fc
'-' listcomplete                altd    id, #id0                ' a  compute COG's state address
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
	byte	$09, $00, $04, $f4
'-'             _ret_           push    #notify                 ' |  we are done with the list
	byte	$2a, $14, $66, $0d
'-'             _ret_           push    #poller                 ' a  we are still continuing the list
	byte	$2a, $1c, $66, $0d
'-'             _ret_           push    #real_list              ' a  we are still continuing the list
	byte	$2a, $50, $66, $0d
'-' extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
	byte	$e3, $b5, $97, $fb
'-'                             getnib  a, addr2, #7            'check the request type
	byte	$db, $df, $7b, $f8
'-'                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
	byte	$0f, $de, $0f, $f2
'-'                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
	byte	$d8, $df, $73, $f8
'-'             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
	byte	$32, $90, $63, $5d
'-'                                                             ' skipcase (a) gfx copy to/from hub
'-'                                                             ' skipcase (b) gfx copy extmem bank to bank
'-'                                                             ' skipcase (c) linear copy extmem bank to bank
'-'                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
	byte	$db, $df, $73, $f8
'-'                             rdlut   d, a wz                 ' a      load bank information and check if valid
	byte	$ef, $e5, $ab, $fa
'-'             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
	byte	$31, $02, $64, $5d
'-'             _ret_           push    #invalidbank            ' |      otherwise bail out after this
	byte	$2a, $02, $66, $0d
'-'                             test    offset1 wz              ' |      check for first offset being zero
	byte	$dd, $bb, $cb, $f7
'-'             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
	byte	$de, $bd, $cb, $a7
'-'             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
	byte	$32, $94, $63, $ad
'-'                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
	byte	$32, $92, $63, $fd
'-'                             add     hubdata, c              ' a b c  add bytes just sent to hub address
	byte	$f1, $b3, $03, $f1
'-'                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
	byte	$ea, $b3, $83, $f1
'-'                             add     c, addr1                ' a b c  compute next address to use
	byte	$d8, $e3, $03, $f1
'-'                             test    total wz                ' a b |  check for zero tranfers
	byte	$dc, $b9, $cb, $f7
'-'                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
	byte	$dc, $d5, $2b, $f3
'-'             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
	byte	$44, $ff, $9f, $ad
'-'                             testb   addr1, #30 wz           ' a b c  check if reading/writing
	byte	$1e, $b0, $0f, $f4
'-'                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
	byte	$ea, $b5, $03, $f6
'-'                             sub     c, orighubsize          ' a b |  rewind to original position
	byte	$ea, $e3, $83, $f1
'-'             if_z            add     c, offset1              ' a b |  add any dst scanline offset
	byte	$dd, $e3, $03, $a1
'-'             if_nz           add     c, offset2              ' a b |  add any src scanline offset
	byte	$de, $e3, $03, $51
'-'             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
	byte	$de, $b3, $03, $a1
'-'             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
	byte	$dd, $b3, $03, $51
'-'                             setq    mask                    ' a b c  configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a b c  perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             mov     a, addr1                ' | b c  ]
	byte	$d8, $df, $03, $f6
'-'                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
	byte	$db, $b1, $03, $f6
'-'                             mov     addr2, a                ' | b c  ]
	byte	$ef, $b7, $03, $f6
'-'                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
	byte	$1e, $b0, $a7, $f4
'-'                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
	byte	$0f, $b6, $3f, $f8
'-'                             sub     total, #1 wz            ' a | |  decrement scanline count
	byte	$01, $b8, $8f, $f1
'-'             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
	byte	$01, $b8, $8f, $a1
'-'             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
	byte	$ea, $b9, $8b, $a1
'-'             if_z            mov     addr2, link
	byte	$df, $b7, $03, $a6
'-'             if_z            jmp     #checknext
	byte	$34, $ff, $9f, $ad
'-' moretransfers               getbyte request, addr1, #3      'prepare next request
	byte	$d8, $cb, $fb, $f8
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            skipf   #%1110                  '     skip some code if we are locked
	byte	$32, $1c, $64, $ad
'-'                             testb   addr1, #30 wz           ' a   test if will be reading or writing
	byte	$1e, $b0, $0f, $f4
'-'             if_z            mov     resume, resumewrites    ' |   resume burst writing
	byte	$be, $d3, $03, $a6
'-'             if_nz           mov     resume, newburstr       ' |   resume burst reading
	byte	$b9, $d3, $03, $56
'-'                             jmp     #yield                  ' |   yield to poller
	byte	$b0, $fe, $9f, $fd
'-'             if_z            skip    #%1                     '     skip next instruction for writing case
	byte	$31, $02, $64, $ad
'-'             _ret_           push    #start_read_exec        '(|)  do new read burst next 
	byte	$2a, $26, $67, $0d
'-'             _ret_           push    #start_write_exec       'do new write burst next
	byte	$2a, $28, $67, $0d
'-' 
'-' '..................................................................................................
'-' ' PSRAM WRITES
'-'                                                             '  a b c d e f g h
'-' 
'-'                                                             '  B W L F B R L L (a) byte write(s)
'-'                                                             '  Y O O I U E O O (b) word write(s)
'-'                                                             '  T R N L R S C C (c) long write(s)
'-'                                                             '  E D G L S U K K (d) resumed fill
'-'                                                             '          T M E E (e) new burst write
'-'                                                             '            E D D (f) resumed burst
'-'                                                             '              F B (g) locked fill
'-'                                                             '              I U (h) locked burst write
'-'                                                             '              L R 
'-'                                                             '              L S 
'-'                                                             '                T 
'-' 
'-' w_single                   
'-' w_fill_cont           
'-'                             getnib  a, addr1, #7            '  a b c d          obtain request
	byte	$d8, $df, $7b, $f8
'-'                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
	byte	$03, $de, $07, $f5
'-'                             movbyts hubdata, #0             '  a | | |          replicate byte across long
	byte	$00, $b2, $ff, $f9
'-'                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
	byte	$44, $b2, $ff, $f9
'-'                             andn    addr1, #1               '  | b | |          align word addresses
	byte	$01, $b0, $27, $f5
'-'                             andn    addr1, #3               '  | | c |          align long addresses
	byte	$03, $b0, $27, $f5
'-' w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
	byte	$da, $d5, $03, $f6
'-' w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
	byte	$01, $b4, $0f, $f2
'-'                             shl     count, a                '  a b c | |   |    scale into bytes
	byte	$ef, $b5, $63, $f0
'-'                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
	byte	$ab, $b5, $97, $fb
'-' w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
	byte	$da, $e3, $03, $f6
'-'                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
	byte	$76, $02, $a0, $fd
'-'                ' disable call to r_resume_burst for single longs when z=0
'-'                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
	byte	$3f, $8a, $0f, $f6
'-'                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
	byte	$ce, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
	byte	$cc, $d3, $03, $36
'-'                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
	byte	$d9, $df, $03, $f6
'-'                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
	byte	$14, $d6, $07, $f6
'-'                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
	byte	$01, $de, $17, $f4
'-'                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
	byte	$c7, $8b, $03, $f6
'-'             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
	byte	$14, $01, $90, $8d
'-'             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
	byte	$09, $8a, $67, $25
'-'             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
	byte	$5c, $00, $90, $2d
'-'                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
	byte	$0f, $8a, $07, $f6
'-'         
'-'             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
'-'             '
'-'             '  At least one of these 3 optional components will be sent
'-'             '     header - first partial long of data, gets aligned to PSRAM long boundary
'-'             '     body - N x full longs of data
'-'             '     trailer - last partial long of data
'-'             '
'-'             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
'-'             '
'-'             'Case    Type                           Sends
'-'             ' 1)     Single byte/word write         header only (takes its own optimized path)
'-'             ' 2)     Single long write              body only (takes its own optimized path)
'-'             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
'-'             ' 4)     Multiple long fill             body only
'-'             ' 5)     Burst write                    optional header, optional body, optional trailer
'-' 
'-'                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
	byte	$ce, $d3, $03, $c6
'-'                             mov     pattern3, #%10011
	byte	$13, $8c, $07, $f6
'-'                             mov     d, addr1                'get start address position 
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3 wz                'get alignment
	byte	$03, $e4, $0f, $f5
'-'                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
	byte	$04, $e2, $17, $f2
'-'                             mov     wrclks, #16             'clocks needed for address phase
	byte	$10, $d6, $07, $f6
'-'                             mov     pb, c                   'get number of bytes to send
	byte	$f1, $ef, $03, $f6
'-'                             add     pb, d                   'and increase total to send, including initial re-alignment
	byte	$f2, $ef, $03, $f1
'-'             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
	byte	$40, $00, $90, $2d
'-'                             
'-'                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'             if_c            skipf   #%11110                 'if fill skip burst write stuff
	byte	$32, $3c, $64, $cd
'-'                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
	byte	$04, $d6, $07, $f1
'-'                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
	byte	$f2, $df, $83, $f1
'-'                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
	byte	$ef, $e5, $03, $fb
'-'                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
	byte	$04, $de, $07, $f1
'-'                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
	byte	$32, $08, $64, $fd
'-'                             sub     pb, #4 wcz              ' subtract a long from the total
	byte	$04, $ee, $9f, $f1
'-'                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
	byte	$00, $8a, $07, $f4
'-' single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
	byte	$d9, $e5, $03, $f6
'-'                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
	byte	$88, $01, $b0, $fd
'-'                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
	byte	$5a, $b0, $47, $fb
'-'                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
	byte	$ed, $c5, $03, $fb
'-'                             setq    pa                      ' setup byte mux mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    header, d               ' copy bytes into long
	byte	$f2, $c5, $f3, $f9
'-'             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
	byte	$94, $00, $90, $ed
'-' 
'-' header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'                             mov     d, pb                   'preserve the count
	byte	$f7, $e5, $03, $f6
'-'                             andn    pb, #3 wz               'determine the number of full long bytes left to send
	byte	$03, $ee, $2f, $f5
'-'                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
	byte	$07, $ee, $97, $fb
'-'                  
'-'                             add     wrclks, pb              'include this number of bytes as more clock transitions
	byte	$f7, $d7, $03, $f1
'-'             if_c            skipf   #%1010                 'for fills we can skip burst stuff
	byte	$32, $14, $64, $cd
'-'             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
	byte	$0c, $8a, $27, $c5
'-'                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
	byte	$01, $8a, $07, $f4
'-'                             shr     pb, #1                  ' |  b  compute word count for bursts
	byte	$01, $ee, $47, $f0
'-'                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
	byte	$f7, $37, $23, $f9
'-'                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
	byte	$01, $ee, $47, $f0
'-' 
'-' body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
	byte	$03, $e4, $07, $f5
'-'                             tjz     d, #trailer_done        'no trailer to send, we exit now
	byte	$17, $e4, $97, $fb
'-'             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
	byte	$da, $e3, $0b, $c2
'-'             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
	byte	$cc, $d3, $0b, $32
'-'             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
	byte	$f2, $e3, $83, $51
'-'             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
	byte	$4c, $00, $90, $5d
'-' 
'-'                             'we have 1-3 more aligned residual bytes left to send as the trailer
'-'                             or      d, #$1f0                'setup mux mask address
	byte	$f0, $e5, $47, $f5
'-'                             rdlut   pa, d                   'read mux mask for this length at offset 0
	byte	$f2, $ed, $a3, $fa
'-'                             push    addr1                   'save address
	byte	$2a, $b0, $63, $fd
'-' 
'-' ' use this code (note: foldover can occur here in PSRAM bank)
'-'                             add     addr1, c                'find last long address in PSRAM
	byte	$f1, $b1, $03, $f1
'-'                             sub     addr1, #1               '..to be rewritten
	byte	$01, $b0, $87, $f1
'-'                             call    #readlong               'read data from this external address
	byte	$18, $01, $b0, $fd
'-'             
'-'             if_c            mov     d, hubdata              'get data to be sent for fills
	byte	$d9, $e5, $03, $c6
'-'             if_c            skipf   #%11110                 'skip burst code for fills
	byte	$32, $3c, $64, $cd
'-'                             pop     addr1                   'restore address
	byte	$2b, $b0, $63, $fd
'-'                             mov     d, pb                   ' | get number of full longs that were sent
	byte	$f7, $e5, $03, $f6
'-'                             shl     d, #2                   ' | convert to bytes
	byte	$02, $e4, $67, $f0
'-'                             add     d, a                    ' | add to start adress of longs to stream
	byte	$ef, $e5, $03, $f1
'-'                             rdlong  d, d                    ' | read this last long from HUB RAM
	byte	$f2, $e5, $03, $fb
'-' 
'-'                             rdlong  trailer, hubscratch     'read external RAM data value
	byte	$ed, $c7, $03, $fb
'-'                             setq    pa                      'setup byte mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    trailer, d              'apply byte mask to data via muxq
	byte	$f2, $c7, $f3, $f9
'-'                             add     wrclks, #4              'increase by 4 more clocks
	byte	$04, $d6, $07, $f1
'-'                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
	byte	$05, $8a, $07, $f4
'-'                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
	byte	$00, $8c, $07, $f4
'-' 
'-'                             'trailer is done
'-' trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
	byte	$ef, $3b, $73, $fc
'-' 
'-' writecommon                 mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$02, #3       'add quad write command
	byte	$02, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr                 
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-'                             
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   wrclks, clkpin          'start memory clock output 
	byte	$a8, $d7, $23, $fc
'-'                                                          
'-'                             skipf   pattern2                '   B W L Burst FB FW FL RMW
	byte	$32, $8a, $63, $fd
'-'                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
	byte	$e2, $39, $c3, $fc
'-'                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
	byte	$00, $36, $c7, $fc
'-'                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
	byte	$f7, $03, $d8, $fc
'-'                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
	byte	$d9, $39, $c3, $fc
'-'                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
	byte	$32, $8c, $63, $fd
'-'                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
	byte	$e3, $39, $c3, $fc
'-'                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
	byte	$50, $48, $63, $fd
'-'             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
	byte	$59, $52, $63, $0d
'-'  
'-'                             drvh    cspin
	byte	$59, $52, $63, $fd
'-' check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
	byte	$09, $c2, $17, $f4
'-'                             sub     count, c wz             'account for bytes written
	byte	$f1, $b5, $8b, $f1
'-'             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
	byte	$34, $00, $90, $5d
'-'                             wrlut   #0, ptra[8]             'default is not to resume
	byte	$08, $01, $3c, $fc
'-'             if_nc           jmp     #notify                 'if not a request list then we are done
	byte	$3c, $f5, $9f, $3d
'-'                             tjns    addr2, #checklist       'if not extended, check next list entry
	byte	$40, $b7, $bf, $fb
'-'                             djz     total, #donerepeats     'check for repeats remaining
	byte	$3e, $b9, $67, $fb
'-'                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
	byte	$b8, $b9, $b3, $fb
'-'                             mov     d, orighubsize
	byte	$ea, $e5, $03, $f6
'-'                             shl     d, a
	byte	$ef, $e5, $63, $f0
'-'                             sub     c, d
	byte	$f2, $e3, $83, $f1
'-'                             add     c, offset1
	byte	$dd, $e3, $03, $f1
'-'                             mov     count, d                'restore original count
	byte	$f2, $b5, $03, $f6
'-' readmask                    getnib  b, request, #0          'get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 'build mask for addr (in case count=1)
	byte	$f0, $45, $cb, $f9
'-' continue_fill               add     c, addr1                'add bytes to destination address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    'setup bit mask
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                'setup new external memory address
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            execf   lockedfill              'continue next fill operation
	byte	$33, $74, $63, $ad
'-'                             mov     resume, restorefill
	byte	$bb, $d3, $03, $f6
'-'             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
	byte	$00, $b6, $07, $36
'-'             if_nc           call    #yieldfill              'we have to yield now to other COGs
	byte	$80, $fc, $bf, $3d
'-'             if_c            call    #yield
	byte	$6c, $fc, $bf, $cd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-'                            
'-' getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
'-'                       '     rczl    pa                      'rotate left into address offset
'-'                       '     rczl    c wcz                   'restore count and flags
'-'                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
	byte	$03, $e2, $ef, $f7
'-'                             shl     pa, #2
	byte	$02, $ec, $67, $f0
'-'             if_z            setq    #3
	byte	$28, $06, $64, $ad
'-'             if_z            muxq    pa, c
	byte	$f1, $ed, $f3, $a9
'-'                             or      pa, #$1f0               'setup LUT address offset
	byte	$f0, $ed, $47, $f5
'-'            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
	byte	$f6, $ed, $a3, $fa
'-'                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
	byte	$2d, $00, $7c, $fd
'-' 
'-' readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
	byte	$ed, $3b, $83, $fc
'-'                             setword xrecvdata, #2, #0       'read 2x16 words
	byte	$02, $34, $27, $f9
'-'                             mov     clks, #32               '32 read clock transitions
	byte	$20, $d0, $07, $f6
'-'                             mov     pattern, #%110110       'setup read skip pattern
	byte	$36, $d8, $07, $f6
'-'                             jmp     #readcommon             'read then return directly to caller
	byte	$14, $fb, $9f, $fd
'-'                 fit 1024-32
'-'         
'-' 
'-' '..................................................................................................
'-' 
'-'                 fit 1024-32
'-'                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'                 org 1024-32
'-' 
'-' ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
'-'                 long $0000
	byte	$00, $00, $00, $00
'-'                 long $1111
	byte	$11, $11, $00, $00
'-'                 long $2222
	byte	$22, $22, $00, $00
'-'                 long $3333
	byte	$33, $33, $00, $00
'-'                 long $4444
	byte	$44, $44, $00, $00
'-'                 long $5555
	byte	$55, $55, $00, $00
'-'                 long $6666
	byte	$66, $66, $00, $00
'-'                 long $7777
	byte	$77, $77, $00, $00
'-'                 long $8888
	byte	$88, $88, $00, $00
'-'                 long $9999
	byte	$99, $99, $00, $00
'-'                 long $aaaa
	byte	$aa, $aa, $00, $00
'-'                 long $bbbb
	byte	$bb, $bb, $00, $00
'-'                 long $cccc
	byte	$cc, $cc, $00, $00
'-'                 long $dddd
	byte	$dd, $dd, $00, $00
'-'                 long $eeee
	byte	$ee, $ee, $00, $00
'-'                 long $ffff
	byte	$ff, $ff, $00, $00
'-' 
'-' 'masks
'-'                 long $ffffffff ' 00 aligned 0/4 length
	byte	$ff, $ff, $ff, $ff
'-'                 long $000000ff ' 00 aligned 1 length
	byte	$ff, $00, $00, $00
'-'                 long $0000ffff ' 00 aligned 2 length
	byte	$ff, $ff, $00, $00
'-'                 long $00ffffff ' 00 aligned 3 length
	byte	$ff, $ff, $ff, $00
'-' 
'-'                 long $ffffff00 ' 01 aligned 0/4 length
	byte	$00, $ff, $ff, $ff
'-'                 long $0000ff00 ' 01 aligned 1 length
	byte	$00, $ff, $00, $00
'-'                 long $00ffff00 ' 01 aligned 2 length
	byte	$00, $ff, $ff, $00
'-'                 long $ffffff00 ' 01 aligned 3 length
	byte	$00, $ff, $ff, $ff
'-' 
'-'                 long $ffff0000 ' 10 aligned 0/4 length
	byte	$00, $00, $ff, $ff
'-'                 long $00ff0000 ' 10 aligned 1 length
	byte	$00, $00, $ff, $00
'-'                 long $ffff0000 ' 10 aligned 2 length
	byte	$00, $00, $ff, $ff
'-'                 long $ffff0000 ' 10 aligned 3 length
	byte	$00, $00, $ff, $ff
'-' 
'-'                 long $ff000000 ' 11 aligned 0/4 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 1 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 2 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 3 length
	byte	$00, $00, $00, $ff
'-'         fit 1024
'-' 
'-'         fit 1024
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-'         orgh
'-' 
'-' gfxexpansion
'-'                             'simple line drawing graphics expansion of memory driver
'-'                             'jmp     #donerepeats                'just return for now
'-' 
'-'                             cmp     addr1, addr2 wz         'see if we've reached the end
	byte	$db, $b1, $0b, $f2
'-'             if_z            jmp     #donerepeats            'nothing more to draw
	byte	$fb, $02, $80, $ad
'-'                             add     total, #1               'restore total after decrement
	byte	$01, $b8, $07, $f1
'-'                             mov     b, offset1              'get error term
	byte	$dd, $e1, $03, $f6
'-'                             shl     b, #1                   'compute e2 = 2 x error
	byte	$01, $e0, $67, $f0
'-'                             getword d, offset2, #0          'get dx = abs(x0-x1)
	byte	$de, $e5, $33, $f9
'-'                             sar     offset2, #16            'get dy = -abs(y0-y1)
	byte	$10, $bc, $c7, $f0
'-'                             cmps    b, offset2 wc           'compare if e2 >= dy
	byte	$de, $e1, $53, $f2
'-'                             mov     c, #0                   'clear accumulator reg
	byte	$00, $e2, $07, $f6
'-'             if_c            skip    #%1110                  'if not, skip
	byte	$31, $1c, $64, $cd
'-'                             decod   a                       'decode as 1,2,or 4 byte size
	byte	$ef, $df, $c3, $f9
'-'                             add     offset1, offset2        'err+=dy 
	byte	$de, $bb, $03, $f1
'-'                             testb   total, #16 wz           'check sign sx   
	byte	$10, $b8, $0f, $f4
'-'                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
	byte	$ef, $e3, $c3, $f3
'-'                             cmps    d, b wc                 'compare if e2 <= dx
	byte	$f0, $e5, $53, $f2
'-'             if_c            skip    #%11110                 'if not, skip
	byte	$31, $3c, $64, $cd
'-'                             rolword offset2, d, #0          'restore offset
	byte	$f2, $bd, $43, $f9
'-'                             add     offset1, d              'err+=dx
	byte	$f2, $bb, $03, $f1
'-'                             testb   total, #17 wz           'check sign sy
	byte	$11, $b8, $0f, $f4
'-'                             getword d, total, #0            'get line width
	byte	$dc, $e5, $33, $f9
'-'                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
	byte	$f2, $e3, $c3, $f3
'-'                             encod   a wc                    'restore size and set carry
	byte	$ef, $df, $93, $f7
'-'                             mov     count, orighubsize      'reset the fill width
	byte	$ea, $b5, $03, $f6
'-'                             shl     count, a                '..for the type of transfer
	byte	$ef, $b5, $63, $f0
'-'                             jmp     #readmask               'continue filling
	byte	$c3, $03, $80, $fd
	alignl
_usbnew_spin2_dat_
'-'                 org     $000
'-' 
'-' usb_host_start
'-'                 mov     hcog_base_addr, ptrb
	byte	$f9, $8f, $02, $f6
'-' 
'-'                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
	byte	$03, $00, $00, $ff, $d0, $70, $07, $f6
'-'                 shr     htmp, #2                        ' so byte->long for the lut cell count
	byte	$02, $70, $47, $f0
'-'                 loc     pb, #@hlut_start - @usb_host_start
	byte	$b4, $04, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq2   htmp
	byte	$29, $70, $63, $fd
'-'                 rdlong  0, pb                           ' Do the hub->lut copy
	byte	$f7, $01, $00, $fb
'-' 
'-'                 loc     pb, #@usb_host_init - @usb_host_start
	byte	$88, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 jmp     pb                              ' Initialize host and enter main processing loop
	byte	$2c, $ee, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
'-' ' special because the receiving function must not respond with either STALL or
'-' ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
'-' ' non-control endpoint receives a SETUP token, or the function receives a
'-' ' corrupt packet, it must ignore the transaction
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data struct.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error code.
'-' '------------------------------------------------------------------------------
'-' txn_setup
'-'                 setbyte ep_addr_pid, #PID_SETUP, #0
	byte	$2d, $bc, $c6, $f8
'-'                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
	byte	$08, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
	byte	$03, $96, $06, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
	byte	$0c, $a2, $06, $f6
'-'                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
	byte	$f8, $ed, $03, $f6
'-' .setup
'-'                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
	byte	$24, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait
	byte	$7c, $0b, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
	byte	$f6, $f1, $03, $f6
'-'                 jmp     #.setup
	byte	$e0, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' IN/INTERRUPT transaction.
'-' ' Possible function response: STALL or NAK handshake, or DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_in
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$90, $03, $b0, $fd
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #utx_token                      ' Put IN request on the bus
	byte	$bc, $00, $b0, $fd
'-' 
'-'                 ' Fall through to urx_packet
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a packet from a device/function. As host, the only two packet types
'-' ' received are handshakes and IN DATAx.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'-' '     returned.
'-' '------------------------------------------------------------------------------
'-' urx_packet
'-'                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #urx_packet
	byte	$f4, $ff, $9f, $cd
'-'                 getct   hct2
	byte	$1a, $92, $63, $fd
'-'                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
	byte	$4e, $93, $6b, $fa
'-'                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
	byte	$05, $96, $06, $f4
'-'                 mov     newb_flg, #0                    ' Initialize for multi-byte read
	byte	$00, $a8, $06, $f6
'-' .wait_sop
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #.get_pid
	byte	$08, $00, $90, $cd
'-'                 jnct2   #.wait_sop
	byte	$fc, $25, $cc, $fb
'-'         _ret_   mov     retval, #ERR_TAT
	byte	$05, $be, $06, $06
'-' .get_pid
'-'                 call    #urx_next
	byte	$28, $02, $b0, $fd
'-'                 testb   urx, #BUS_ERRB          wc
	byte	$06, $a6, $16, $f4
'-'         if_nc   jmp     #.chk_pid
	byte	$04, $00, $90, $3d
'-'         _ret_   mov     retval, #ERR_URX
	byte	$02, $be, $06, $06
'-' .chk_pid
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $52
'-'         if_nz   cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
	byte	$38, $00, $90, $ad
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
	byte	$03, $96, $16, $f4
'-'                 cmp     retval, #PID_DATA0      wz
	byte	$c3, $be, $0e, $f2
'-'    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
	byte	$28, $01, $90, $2d
'-'    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
	byte	$10, $00, $90, $8d
'-'                 cmp     retval, #PID_DATA1      wz
	byte	$4b, $be, $0e, $f2
'-'    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
	byte	$1c, $01, $90, $8d
'-'    if_z_and_nc  jmp     #.ack_resend
	byte	$04, $00, $90, $2d
'-'         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
	byte	$04, $be, $06, $06
'-' .ack_resend
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.ack_resend
	byte	$f4, $ff, $9f, $3d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 call    #utx_handshake                  ' Send handshake PID and return to caller
	byte	$98, $01, $b0, $fd
'-'         _ret_   mov     retval, #ERR_DATAX_SYNC
	byte	$09, $be, $06, $06
'-' .chk_eop
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
	byte	$1c, $00, $90, $3d
'-'                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
	byte	$c8, $01, $b0, $fd
'-'                 testb   hstatus, #EOPB          wc
	byte	$05, $96, $16, $f4
'-'         if_c    jmp     #.idle                          ' Low-speed EOP seen
	byte	$10, $00, $90, $cd
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
	byte	$04, $be, $06, $36
'-'         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
	byte	$02, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
	byte	$f4, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send a token packet with CRC5 checksum of address and endpoint. It is the
'-' ' responsibility of the caller to append the appropriate inter-packet delay,
'-' ' if one is required.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - packed with the PID, address and endpoint.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_token
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #utx_token
	byte	$f4, $ff, $9f, $3d
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$34, $0d, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync byte
	byte	$70, $01, $b0, $fd
'-'                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
	byte	$5e, $71, $03, $f6
'-'                 mov     pkt_cnt, #3
	byte	$03, $b8, $06, $f6
'-' .next_byte
'-'                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
	byte	$b8, $a5, $e2, $f8
'-'                 shr     htmp, #8                        ' Shift to next byte to send
	byte	$08, $70, $47, $f0
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   utx, dm
	byte	$22, $a5, $22, $fc
'-'         _ret_   djnz    pkt_cnt, #.next_byte
	byte	$f9, $b9, $6e, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP/OUT/INTERRUPT transaction.
'-' ' Possible function response in order of precedence: STALL, ACK, NAK.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' '   PTRA - start address of the data buff/struct that has the bytes to send.
'-' '   pkt_data - count of DATAx payload bytes to send.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_out
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$88, $02, $b0, $fd
'-'                 call    #utx_token                      ' Put SETUP/OUT token on the bus
	byte	$b8, $ff, $bf, $fd
'-'                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
	byte	$00, $00, $c0, $ff, $f8, $01, $78, $fc
'-'                 mov     pkt_cnt, pkt_data
	byte	$58, $b9, $02, $f6
'-' 
'-'                 ' Fall through to utx_data
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
'-' ' calculated while the data byte is being shifted out. Since data stage
'-' ' success/fail is not determined until the status stage of the transaction,
'-' ' this routine is only concerned about the current DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - hub start address of the data to read.
'-' '   pkt_cnt - data payload size.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_data
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #utx_data
	byte	$f4, $ff, $9f, $cd
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
	byte	$2c, $0a, $b0, $fd
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$d8, $0c, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$14, $01, $b0, $fd
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
	byte	$03, $96, $16, $f4
'-'         if_nc   mov     utx, #PID_DATA0
	byte	$c3, $a4, $06, $36
'-'         if_c    mov     utx, #PID_DATA1
	byte	$4b, $a4, $06, $c6
'-'                 call    #utx_byte                       ' No CRC calc done on PID
	byte	$00, $01, $b0, $fd
'-'                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
	byte	$1c, $00, $90, $ad
'-' .read_byte
'-'                 rfbyte  utx                             ' Fetch data byte
	byte	$10, $a4, $62, $fd
'-'                 call    #utx_byte
	byte	$f0, $00, $b0, $fd
'-'                 rev     utx                             ' Calculate CRC while the data is shifting out
	byte	$69, $a4, $62, $fd
'-'                 setq    utx                             ' SETQ left-justifies the reflected data byte
	byte	$28, $a4, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-'                 djnz    pkt_cnt, #.read_byte
	byte	$f9, $b9, $6e, $fb
'-' .send_crc
'-'                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
	byte	$e0, $bb, $e6, $f4
'-'                 getbyte utx, crc, #0
	byte	$5d, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$d0, $00, $b0, $fd
'-'                 getbyte utx, crc, #1
	byte	$5d, $a5, $ea, $f8
'-'                 call    #utx_byte                       ' Last CRC byte out
	byte	$c8, $00, $b0, $fd
'-'                 jmp     #urx_packet                     ' Handle function response/error and back to caller
	byte	$7c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
'-' ' payload bytes are received. The routine reads bytes until EOP is detected and
'-' ' expects that the packet includes at least the CRC word.
'-' '
'-' ' In control transfers, it's possible to recieve fewer data bytes than what
'-' ' was requested, which makes it difficult to determine where the data stops
'-' ' and the CRC word begins. So the CRC calculation is done on every byte of the
'-' ' packet, including the CRC word. The CRC value should then be equal to the
'-' ' USB-16 expected residual value of 0xB001.
'-' '
'-' ' The routine writes the IN packet data to a static max_packet_size buffer
'-' ' so the caller can verify IN success before writing the data to its final
'-' ' destination.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   pkt_data - max byte count expected to be in the packet.
'-' '   newb_flg - signals new byte ready when toggled.
'-' ' On exit:
'-' '   pkt_cnt - actual number of bytes read.
'-' '------------------------------------------------------------------------------
'-' urx_data
'-'                 mov     htmp2, pb
	byte	$f7, $75, $03, $f6
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
	byte	$00, $00, $c0, $ff, $f7, $01, $88, $fc
'-'                 mov     pb, htmp2
	byte	$ba, $ef, $03, $f6
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
	byte	$00, $b8, $06, $f6
'-'                 mov     pkt_tmp, pkt_data
	byte	$58, $83, $03, $f6
'-'                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
	byte	$02, $82, $07, $f1
'-' .wait_byte
'-' ' In-line rx for max speed
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   jmp     #.get_byte                      ' New byte!
	byte	$0c, $00, $90, $5d
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_c    jmp     #.chk_crc                       ' At end-of-packet
	byte	$38, $00, $90, $cd
'-'                 jmp     #.wait_byte
	byte	$dc, $ff, $9f, $fd
'-' .get_byte
'-'                 getbyte retval, urx, #1                 ' New byte from smart pins
	byte	$53, $bf, $ea, $f8
'-'                 wfbyte  retval                          ' Add it to the data buffer
	byte	$15, $be, $62, $fd
'-'                 rev     retval                          ' Calculate CRC while next byte is shifting in
	byte	$69, $be, $62, $fd
'-'                 setq    retval                          ' SETQ left-justifies the reflected data byte
	byte	$28, $be, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-' .end_crc
'-'                 add     pkt_cnt, #1
	byte	$01, $b8, $06, $f1
'-'                 cmp     pkt_cnt, pkt_tmp        wcz
	byte	$c1, $b9, $1a, $f2
'-'         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
	byte	$04, $be, $06, $16
'-'         if_a    ret
	byte	$2d, $00, $64, $1d
'-' ' For full-speed at 80MHz, the time it takes to do the final byte write and
'-' ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
'-' ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
'-' ' to miss it, so cheat a bit and look for SOP clear here.
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
	byte	$a8, $ff, $9f, $3d
'-' ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
'-' .chk_crc
'-'                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
	byte	$02, $b8, $86, $f1
'-'                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
	byte	$58, $00, $00, $ff, $01, $ba, $6e, $f5
'-'         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
	byte	$f0, $fd, $9f, $5d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$34, $09, $b0, $fd
'-' 
'-'                 ' Fall through to utx_handshake
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
'-' ' the appropriate IP delay has been inserted.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - handshake PID to send.
'-' ' On exit:
'-' '   retval unchanged.
'-' '------------------------------------------------------------------------------
'-' utx_handshake
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$e0, $0b, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$1c, $00, $b0, $fd
'-'                 mov     utx, retval
	byte	$5f, $a5, $02, $f6
'-'                 call    #utx_byte                       ' Send handshake PID
	byte	$14, $00, $b0, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
	byte	$f4, $ff, $9f, $3d
'-'                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
	byte	$4e, $99, $02, $f6
'-'                 jmp     #poll_waitx
	byte	$08, $09, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for the USB tx buffer to empty and feed it a new byte.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   utx - byte to transmit.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_byte
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #utx_byte
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
	byte	$1f, $94, $62, $fd
'-'         _ret_   wypin   utx, dm
	byte	$22, $a5, $22, $0c
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Fetch the next data byte of a packet. Always check receiver status for EOP.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the byte read.
'-' '   urx - the receiver status. The caller must check the hstatus reg EOP flag
'-' '     on return. If EOP is set, the byte in reg retval remains as the last byte
'-' '     received.
'-' '------------------------------------------------------------------------------
'-' urx_next
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
	byte	$53, $bf, $ea, $58
'-'         if_nz   ret                                     ' New byte is priority, so return now
	byte	$2d, $00, $64, $5d
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
	byte	$d8, $ff, $9f, $4d
'-'         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
	byte	$05, $96, $26, $34
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
'-' ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
'-' ' length, and the PID is not included in the CRC calculation:
'-' '  CRC5  FRAME_NUMBER SOF (full-speed)
'-' '  CRC5  ENDP ADDRESS PID
'-' ' %00000_1111_1111111_xxxxxxxx
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - stuffed with the function endpoint, address and
'-' '     SETUP/IN/OUT/SOF PID according to the USB standard.
'-' ' On exit:
'-' '   ep_addr_pid - CRC value appended to the packet.
'-' '------------------------------------------------------------------------------
'-' calc_crc5
'-'                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
	byte	$ff, $03, $00, $ff, $ff, $bd, $06, $f5
'-'                 mov     htmp, ep_addr_pid
	byte	$5e, $71, $03, $f6
'-'                 shr     htmp, #8                        ' PID not included in CRC calc
	byte	$08, $70, $47, $f0
'-'                 mov     crc, #$1f                       ' Initial CRC5 value
	byte	$1f, $ba, $06, $f6
'-'                 rev     htmp                            ' Input data reflected
	byte	$69, $70, $63, $fd
'-'                 setq    htmp                            ' CRCNIB setup for data bits 0..7
	byte	$28, $70, $63, $fd
'-'                 crcnib  crc, #USB5_POLY
	byte	$14, $ba, $de, $f9
'-'                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
	byte	$14, $ba, $de, $f9
'-'                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
	byte	$09, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $70, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 xor     crc, #$1f                       ' Final XOR value
	byte	$1f, $ba, $66, $f5
'-'                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
	byte	$13, $ba, $66, $f0
'-'         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
	byte	$5d, $bd, $42, $05
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed/low-speed frame timing interrupt service routine.
'-' '------------------------------------------------------------------------------
'-' isr1_fsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6d, $13, $fc
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 mov     utx, #PID_SOF
	byte	$a5, $a4, $06, $f6
'-'                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
	byte	$22, $01, $29, $fc
'-'                 call    #utx_byte                       ' Send token PID byte
	byte	$4c, $ff, $bf, $fd
'-'                 mov     icrc, #$1f                      ' Prime the CRC5 pump
	byte	$1f, $b6, $06, $f6
'-'                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
	byte	$59, $b5, $02, $f6
'-'                 rev     sof_pkt                         ' Input data reflected
	byte	$69, $b4, $62, $fd
'-'                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
	byte	$28, $b4, $62, $fd
'-'                 crcnib  icrc, #USB5_POLY
	byte	$14, $b6, $de, $f9
'-'                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
	byte	$14, $b6, $de, $f9
'-'                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
	byte	$59, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$2c, $ff, $bf, $fd
'-'                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
	byte	$08, $b4, $66, $f0
'-'                 rep     #2, #3                          ' Three data bits left to process
	byte	$03, $04, $dc, $fc
'-'                 shl     sof_pkt, #1             wc
	byte	$01, $b4, $76, $f0
'-'                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
	byte	$14, $b6, $d6, $f9
'-'                 xor     icrc, #$1f                      ' Final XOR value
	byte	$1f, $b6, $66, $f5
'-'                 getbyte utx, frame, #1                  ' Send remaining frame number bits
	byte	$59, $a5, $ea, $f8
'-'                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
	byte	$03, $b6, $66, $f0
'-'                 or      utx, icrc
	byte	$5b, $a5, $42, $f5
'-'                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
	byte	$08, $ff, $bf, $fd
'-'                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
	byte	$a3, $81, $03, $f6
'-'                 jmp     #isr1_wait
	byte	$20, $00, $90, $fd
'-' isr1_lsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
	byte	$22, $09, $28, $fc
'-'                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
	byte	$a2, $81, $03, $f6
'-' isr1_wait
'-'                 rqpin   utx, dm
	byte	$22, $a5, $82, $fa
'-'                 testb   utx, #SOPB                 wc
	byte	$04, $a4, $16, $f4
'-'         if_c    jmp     #isr1_wait
	byte	$f4, $ff, $9f, $cd
'-'                 add     frame, #1                       ' Next frame# and check for wrap around
	byte	$01, $b2, $06, $f1
'-'                 and     frame, ##$7ff
	byte	$03, $00, $00, $ff, $ff, $b3, $06, $f5
'-'                 waitx   isrtmp1                         ' Make sure bus is idle
	byte	$1f, $80, $63, $fd
'-'                 reti1
	byte	$f5, $ff, $3b, $fb
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a window within the 1ms frame boundary that will ensure that a
'-' ' transaction will complete before the next frame is triggered.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' wait_txn_ok
'-'                 getct   htmp2
	byte	$1a, $74, $63, $fd
'-'                 sub     htmp2, iframe_ct_base
	byte	$49, $75, $83, $f1
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    cmp     htmp2, _txn_ok_ls_      wcz
	byte	$a0, $75, $1b, $c2
'-'         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
	byte	$a1, $75, $1b, $32
'-'         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
	byte	$e8, $ff, $9f, $1d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A device connection was detected, or a bus reset was requested by the USB
'-' ' client. Set the appropriate smart pin FS/LS speed mode to match the device
'-' ' and perform a reset sequence prior to device enumeration.
'-' '------------------------------------------------------------------------------
'-' dev_reset
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
	byte	$01, $a6, $16, $f4
'-'         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
	byte	$f4, $03, $b0, $cd
'-'         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
	byte	$e0, $03, $b0, $3d
'-' reset
'-'                 setint1 #0                              ' Don't want frame interrupt while in reset
	byte	$25, $00, $64, $fd
'-'                 wypin   #OUT_SE0, dm                    ' Assert bus reset
	byte	$22, $03, $28, $fc
'-'                 waitx   _reset_hold_                    ' Spec is >= 10ms
	byte	$1f, $5a, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 mov     frame, #0                       ' Reset the frame timespan count
	byte	$00, $b2, $06, $f6
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
	byte	$59, $71, $03, $f6
'-'                 add     htmp, #36
	byte	$24, $70, $07, $f1
'-'                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
	byte	$25, $02, $64, $fd
'-' .framewait
'-'                 cmp     frame, htmp             wcz
	byte	$b8, $b3, $1a, $f2
'-'         if_b    jmp     #.framewait
	byte	$f8, $ff, $9f, $cd
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - source address.
'-' '   PB - destination address.
'-' '   hr0 - length of copy, in bytes.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hmemcpy
'-'                 rdbyte  htmp, ptra++
	byte	$61, $71, $c7, $fa
'-'                 wrbyte  htmp, pb
	byte	$f7, $71, $43, $fc
'-'                 add     pb, #1
	byte	$01, $ee, $07, $f1
'-'         _ret_   djnz    hr0, #hmemcpy
	byte	$fc, $85, $6f, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
'-' ' loop until the errant device is disconnected.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' host_error
'-'           if ERROR_LED >= 0
'-'           end
'-'                 jmp     #host_reset                     ' See if it works...
	byte	$a0, $07, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get HID descriptor buffer for current port
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   PB - HID descriptor buffer pointer
'-' '------------------------------------------------------------------------------
'-' get_hid_descr_buffer
'-'                 mov     pb, hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb, #1
	byte	$01, $ee, $e7, $f2
'-'                 mul     pb, #HID_DESCR_LEN
	byte	$00, $ef, $07, $fa
'-'         _ret_   add     pb, hid_descr_p
	byte	$25, $ef, $03, $01
'-' 
'-' 
'-' usb16_poly_r    long    USB16_POLY
	byte	$01, $a0, $00, $00
'-' 
'-' ' USB commands and error codes
'-' cmd_data        long    0
	byte	$00, $00, $00, $00
'-' usb_err_code    long    ERR_NONE
	byte	$00, $00, $00, $00
'-' 
'-' ' Parameters block assigned at cog startup
'-' dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
	byte	$12, $00, $00, $00
'-' dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
	byte	$13, $00, $00, $00
'-' usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
	byte	$11, $00, $00, $00
'-' if ACTIVITY_LED >= 0
'-' host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
'-' end
'-' if ERROR_LED >= 0
'-' host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
'-' end
'-' hid_descr_p     long    0
	byte	$00, $00, $00, $00
'-' 'hid_report_p    long    0, 0[MAX_DEVICES]
'-' 'hkbd_report_p   long    0
'-' hub_descr_p     long    0
	byte	$00, $00, $00, $00
'-' urx_buff_p      long    0
	byte	$00, $00, $00, $00
'-' dev_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' con_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' cache_start_p   long    0
	byte	$00, $00, $00, $00
'-' cache_end_p     long    0
	byte	$00, $00, $00, $00
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_out_ptr  long    0
'-' end
'-' save_sysclk     long    0         ' Save the current sysclock as the client may change it
	byte	$00, $00, $00, $00
'-' 
'-' hdev_init_start
'-' hdev_port       res     1
'-' hdev_port       res     1
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' kbm_next_datax  res     1
'-' kbm_next_datax  res     1
'-' hub_intf_num    res     1
'-' hub_intf_num    res     1
'-' hub_next_datax  res     1
'-' hub_next_datax  res     1
'-' hub_status_chg  res     1
'-' hub_status_chg  res     1
'-' hub_port_status res     1
'-' hub_port_status res     1
'-' if HAVE_MOUSE
'-' ms_intf_num     res     1
'-' ms_intf_num     res     1
'-' ms_in_max_pkt   res     1
'-' ms_in_max_pkt   res     1
'-' end
'-' kb_intf_num     res     1
'-' kb_intf_num     res     1
'-' kb_interval     res     1
'-' kb_interval     res     1
'-' kb_in_max_pkt   res     1
'-' kb_in_max_pkt   res     1
'-' kb_max_index    res     1
'-' kb_max_index    res     1
'-' kb_led_states   res     1
'-' kb_led_states   res     1
'-' gp_intf_num     res     1
'-' gp_intf_num     res     1
'-' gp_interval     res     1
'-' gp_interval     res     1
'-' gp_max_index    res     1
'-' gp_max_index    res     1
'-' gp_descr_len    res     1+MAX_DEVICES
'-' gp_descr_len    res     1+MAX_DEVICES
'-' hdev_init_end
'-' 
'-' ' Initialized at cog startup:
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' iframe_ct_new   res     1
'-' iframe_ct_new   res     1
'-' iframe_ct_base  res     1
'-' iframe_ct_base  res     1
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' 
'-' ' This register block is reset to zero when a USB device connects
'-' hreg_init_start
'-' hstatus         res     1         ' Host status flags
'-' hstatus         res     1         ' Host status flags
'-' hctwait         res     1         ' Poll-based wait clocks
'-' hctwait         res     1         ' Poll-based wait clocks
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' xfer_retry      res     1         ' Control transfer retry count
'-' xfer_retry      res     1         ' Control transfer retry count
'-' retry           res     1         ' Transaction retry count
'-' retry           res     1         ' Transaction retry count
'-' utx             res     1         ' Byte to transmit on USB
'-' utx             res     1         ' Byte to transmit on USB
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' frame           res     1         ' USB 1ms frame counter value
'-' frame           res     1         ' USB 1ms frame counter value
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' crc             res     1         ' Used for CRC16 calculation
'-' crc             res     1         ' Used for CRC16 calculation
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' retval          res     1         ' Global success/fail return parameter
'-' retval          res     1         ' Global success/fail return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' ' Device stuff
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_bcd        res     1
'-' hdev_bcd        res     1
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' ' Keyboard/mouse stuff
'-' hctrl_ep_addr   res     1
'-' hctrl_ep_addr   res     1
'-' hctrl_max_pkt   res     1
'-' hctrl_max_pkt   res     1
'-' hconfig_base    res     1
'-' hconfig_base    res     1
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_class      res     1
'-' hdev_class      res     1
'-' hdev_subclass   res     1
'-' hdev_subclass   res     1
'-' hdev_protocol   res     1
'-' hdev_protocol   res     1
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' if HAVE_MOUSE
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' end
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_out_addr   res     1
'-' hdev_out_addr   res     1
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
'-' end
'-' 
'-' hreg_init_end
'-' 
'-' hidr_start
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_flags      res     1
'-' hidr_flags      res     1
'-' hidr_axis       res     3
'-' hidr_axis       res     3
'-' hidr_buttons    res     1
'-' hidr_buttons    res     1
'-' hidr_hats       res     1
'-' hidr_hats       res     1
'-' '' Above are actually useful values, 6 longs
'-' hidr_id         res     1
'-' hidr_id         res     1
'-' hidr_state      res     1
'-' hidr_state      res     1
'-' hidr_size       res     1
'-' hidr_size       res     1
'-' hidr_count      res     1
'-' hidr_count      res     1
'-' hidr_offset     res     1
'-' hidr_offset     res     1
'-' hidr_usage_idx  res     1
'-' hidr_usage_idx  res     1
'-' hidr_lminmax    res     1
'-' hidr_lminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_type       res     1
'-' hidr_type       res     1
'-' hidr_end
'-' 
'-' ' Variables dependent on the system freqency
'-' _var_64_lower_  res     1
'-' _var_64_lower_  res     1
'-' _var_64_upper_  res     1
'-' _var_64_upper_  res     1
'-' _12Mbps_        res     1
'-' _12Mbps_        res     1
'-' _1_5Mbps_       res     1
'-' _1_5Mbps_       res     1
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1us_           res     1         ' 1us
'-' _1us_           res     1         ' 1us
'-' _10us_          res     1         ' 10us
'-' _10us_          res     1         ' 10us
'-' _33us_          res     1         ' 33us
'-' _33us_          res     1         ' 33us
'-' _txn_err_       res     1         ' 250us
'-' _txn_err_       res     1         ' 250us
'-' _500us_         res     1         ' 500us
'-' _500us_         res     1         ' 500us
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _preamble_wait_ res     1
'-' _preamble_wait_ res     1
'-' _1ms_           res     1         ' 1ms
'-' _1ms_           res     1         ' 1ms
'-' _2ms_           res     1         ' 2ms
'-' _2ms_           res     1         ' 2ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _4ms_           res     1         ' 4ms
'-' _4ms_           res     1         ' 4ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _reset_hold_    res     1         ' 15ms
'-' _reset_hold_    res     1         ' 15ms
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _21ms_          res     1         ' 21ms
'-' _21ms_          res     1         ' 21ms
'-' _100ms_         res     1         ' 100ms
'-' _100ms_         res     1         ' 100ms
'-' _500ms_         res     1         ' 500ms
'-' _500ms_         res     1         ' 500ms
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' '------------------------------------------------------------------------------
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_d_ls_nco_  res     1
'-' _usb_d_ls_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' '------------------------------------------------------------------------------
'-' ' Scratch registers
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp1           res     1
'-' htmp1           res     1
'-' htmp2           res     1
'-' htmp2           res     1
'-' htmp3           res     1
'-' htmp3           res     1
'-' hrep            res     1         ' Repeat count
'-' hrep            res     1         ' Repeat count
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave1          res     1
'-' hsave1          res     1
'-' hsave2          res     1
'-' hsave2          res     1
'-' isrtmp1         res     1
'-' isrtmp1         res     1
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' hr0             res     1         ' Multi-purpose registers
'-' hr0             res     1         ' Multi-purpose registers
'-' hr1             res     1
'-' hr1             res     1
'-' hr2             res     1
'-' hr2             res     1
'-' hr3             res     1
'-' hr3             res     1
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar2           res     1
'-' hpar2           res     1
'-' hpar3           res     1
'-' hpar3           res     1
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' mod_cnt         res     1         ' Used in idle loops
'-' mod_cnt         res     1         ' Used in idle loops
'-'                 fit     $1F0
'-'                 org     $200
'-' hlut_start
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed is the host's native speed, so all that is needed is to set the FS
'-' ' settings to startup defaults.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: Save/restore caller C flag state if C is changed in this routine!
'-' '------------------------------------------------------------------------------
'-' set_speed_full
'-'                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$d0, $e8, $07, $f6
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
	byte	$a3, $9b, $02, $06
'-' '                ret                             wcz     ' Restore caller flags on exit
'-' 
'-' '------------------------------------------------------------------------------
'-' ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
'-' ' is a downstream hub connected (not yet implemented), the baud generator
'-' ' remains set at the full-speed rate, but signaling is switched to low-speed,
'-' ' which reverses the D-/D+ polarity. The polarity can be changed without
'-' ' putting the smart pins into reset.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: CZ flags restored to caller states
'-' '------------------------------------------------------------------------------
'-' set_speed_low
'-'                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
	byte	$80, $96, $ce, $f7
'-'         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$ed, $e8, $07, $a6
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
	byte	$22, $69, $13, $fc
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a4, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a2, $9b, $02, $f6
'-'                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
	byte	$02, $96, $26, $f4
'-'                 ret                             wcz     ' Restore caller flags on exit
	byte	$2d, $00, $7c, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform configuration stuff required when a device intitially connects.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' on_connect
'-'                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$02, $84, $07, $f6
'-'                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
	byte	$d8, $fb, $bf, $fd
'-' .retry
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
	byte	$01, $8c, $07, $c6
'-'         if_nc   mov     hpar1, #USB_SPEED_FULL
	byte	$02, $8c, $07, $36
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$1c, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$f4, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.get_dev_desc
	byte	$18, $00, $90, $ad
'-'                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$4c, $03, $b0, $fd
'-'                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$01, $84, $8f, $f1
'-'         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
	byte	$f0, $fb, $9f, $ad
'-'                 call    #reset                          ' Try another reset to see if the device responds
	byte	$a4, $fb, $bf, $fd
'-'                 jmp     #.retry
	byte	$b8, $ff, $9f, $fd
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
	byte	$28, $03, $b0, $fd
'-'                 call    #reset
	byte	$88, $fb, $bf, $fd
'-'                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
	byte	$34, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
	byte	$01, $11, $5c, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$d8, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$04, $03, $b0, $fd
'-'                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
	byte	$04, $00, $00, $ff, $00, $bc, $06, $f6
'-'                 call    #calc_crc5
	byte	$34, $fa, $bf, $fd
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
	byte	$1c, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$78, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
	byte	$07, $db, $c6, $fa
'-'                 mov     hctwait, _500us_
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $02, $b0, $fd
'-'                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$24, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$48, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $85, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $87, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $71, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $84, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $86, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $71, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #host_error
	byte	$2c, $fb, $9f, $cd
'-'                 loc     pa, #@init_kbdm_data - @usb_host_start
	byte	$14, $13, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-'                 loc     pa, #@hparse_con_desc - @usb_host_start
	byte	$b8, $0d, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 jmp     pa
	byte	$2c, $ec, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
'-' ' Status reporting is always in the function-to-host direction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data in hub.
'-' '   PB - start address of the buffer/struct to be written to during the IN data
'-' '     stage.
'-' '   ep_addr_pid - device address, endpoint and CRC5.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'-' '     contains the count of data stage bytes actually received, which must
'-' '     always be <= the count requested.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_read
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8d, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $8f, $03, $f6
'-'                 mov     hpar3, pb                       ' Save dest buffer pointer
	byte	$f7, $91, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$c0, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to caller to handle error
	byte	$2d, $00, $64, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$90, $01, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 mov     nak_retry, ##IN_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
	byte	$55, $b1, $02, $16
'-' .nak_retry
'-'                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
	byte	$0c, $a2, $06, $f6
'-' .in_retry
'-'                 call    #txn_in
	byte	$bc, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$28, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$a8, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$14, $02, $b0, $fd
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak_retry                     ' Function not ready to send data
	byte	$dc, $ff, $9f, $ad
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$94, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.in_retry                      ' Bus error retry
	byte	$d0, $ff, $9f, $5d
'-'                 ret                                     ' The transfer has failed
	byte	$2d, $00, $64, $fd
'-' .commit
'-'                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.pre_status                    ' and also end-of-data
	byte	$38, $00, $90, $ad
'-'                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
	byte	$27, $f1, $03, $f6
'-'                 mov     hr0, pkt_cnt
	byte	$5c, $85, $03, $f6
'-'                 cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $f2
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$6c, $fa, $bf, $5d
'-'                 add     stage_data, pkt_cnt             ' Update bytes received on commit
	byte	$5c, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
	byte	$56, $af, $0a, $f2
'-'         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
	byte	$1c, $00, $90, $ad
'-'                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
	byte	$58, $b9, $1a, $f2
'-'         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
	byte	$14, $00, $90, $cd
'-'         if_a    mov     retval, #ERR_PACKET
	byte	$04, $be, $06, $16
'-'         if_a    mov     context_retval, retval          ' In this case overall and context are the same
	byte	$5f, $c1, $02, $16
'-'         if_a    ret                                     ' Caller must handle ERR_PACKET
	byte	$2d, $00, $64, $1d
'-'                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $f4
'-'                 jmp     #.data                          ' Start next IN transaction
	byte	$78, $ff, $9f, $fd
'-' .pre_status
'-'                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
	byte	$57, $ad, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $f8
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-'                 mov     nak_retry, ##OUT_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-' .out_retry
'-'                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
	byte	$34, $f7, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret                                     ' All is good when ACK
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$18, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$84, $01, $b0, $fd
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
	byte	$d8, $ff, $9f, $5d
'-'                 ret                                     ' Caller must handle transfer retirement
	byte	$2d, $00, $64, $fd
'-' ' I've encountered transfer STALL, even though the data looks correct, and
'-' ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
'-' ' ControlRead() transfer gets things unstuck most of the time...
'-' .xfer_retry
'-'                 mov     hctwait, _xfer_wait_
	byte	$ab, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$58, $01, $b0, $fd
'-'                 call    #wait_txn_ok
	byte	$8c, $f9, $bf, $fd
'-'                 mov     ep_addr_pid, hpar1
	byte	$c6, $bd, $02, $f6
'-'                 mov     ptra, hpar2
	byte	$c7, $f1, $03, $f6
'-'                 mov     pb, hpar3
	byte	$c8, $ef, $03, $f6
'-'                 djnz    xfer_retry, #.xfer_start
	byte	$bb, $a1, $6e, $fb
'-'                 mov     context_retval, retval          ' Preserve the USB error code
	byte	$5f, $c1, $02, $f6
'-'         _ret_   mov     retval, #ERR_XFER_RETRY
	byte	$07, $be, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
'-' ' reporting is always in the function-to-host direction. It is assumed that
'-' ' the SETUP data struct is filled with the required values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - points to the start of the struct for the SETUP data.
'-' '   PB - the start address of the struct/buffer to be read for the OUT data
'-' '     stage.
'-' '   ep_addr_pid - the proper CRC'd address and endpoint to use.
'-' ' On exit:
'-' '   retval - used to convey the success/failure of each stage.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_write
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8d, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $8f, $03, $f6
'-'                 mov     hpar3, pb
	byte	$f7, $91, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
	byte	$00, $9e, $06, $f6
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$84, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
	byte	$ec, $00, $90, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$54, $00, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
	byte	$e1, $bc, $c6, $f8
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
	byte	$55, $b1, $02, $16
'-' .out_retry
'-'                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
	byte	$f7, $f1, $03, $f6
'-'                 call    #txn_out
	byte	$88, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit                        ' Function got the data
	byte	$10, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$e0, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry
	byte	$e4, $ff, $9f, $5d
'-'                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
	byte	$a4, $00, $90, $fd
'-' .commit
'-'                 mov     pb, ptra                        ' Save the current buffer/struct location
	byte	$f8, $ef, $03, $f6
'-'                 add     stage_data, pkt_data
	byte	$58, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz
	byte	$56, $af, $0a, $f2
'-'         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $54
'-'         if_nz   jmp     #.data                          ' More data to send
	byte	$bc, $ff, $9f, $5d
'-' pre_status_in
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .status_retry
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 call    #txn_in
	byte	$44, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
	byte	$d2, $be, $0e, $f2
'-'         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
	byte	$00, $b0, $0e, $a2
'-'         if_z    jmp     #dwnstream_reset                ' Control Write finished
	byte	$74, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait                     ' NAK or bus error, so delay a bit
	byte	$98, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.status_retry
	byte	$d8, $ff, $9f, $5d
'-' '               ret                                     ' Caller must handle transfer retirement
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - The function address and endpoint for the IN request.
'-' '   hpar2 - Address of the IN data buffer
'-' '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
'-' ' On exit:
'-' '   retval - the result of the operation.
'-' '   hpar3 - the count of IN data bytes actually received.
'-' '------------------------------------------------------------------------------
'-' do_int_in
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 getword htmp, hpar3, #0
	byte	$c8, $71, $33, $f9
'-'                 cmp     htmp, #PID_DATA0        wz
	byte	$c3, $70, $0f, $f2
'-'                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
	byte	$03, $96, $a6, $f4
'-'                 mov     retry, #TXN_RETRIES
	byte	$0c, $a2, $06, $f6
'-' .retry
'-'                 getword pkt_data, hpar3, #1             ' IN max packet length
	byte	$c8, $b1, $3a, $f9
'-'                 call    #txn_in
	byte	$00, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK if data received
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$1c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
	byte	$5a, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.post_ret                      ' The caller must handle either
	byte	$24, $00, $90, $ad
'-'                 call    #retry_wait
	byte	$54, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    jmp     #.post_ret
	byte	$18, $00, $90, $ad
'-'                 jmp     #.retry
	byte	$d4, $ff, $9f, $fd
'-' .commit
'-'                 mov     ptra, urx_buff_p                ' Copy the rx buffer
	byte	$27, $f1, $03, $f6
'-'                 mov     pb, hpar2                       ' to the destination buffer
	byte	$c7, $ef, $03, $f6
'-'                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
	byte	$5c, $85, $0b, $f6
'-'         if_nz   cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $52
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$c0, $f8, $bf, $5d
'-' .post_ret
'-'                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
	byte	$5c, $91, $03, $f6
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Resets the downstream hub port to FS
'-' '------------------------------------------------------------------------------
'-' dwnstream_reset
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_nc   ret                                     ' No LS device, reset not needed
	byte	$2d, $00, $64, $3d
'-' 
'-'                 bitl    _usb_h_ls_nco_, #14
	byte	$0e, $68, $07, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6d, $13, $fc
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The one millisecond frame timer is implemented as an interrupt service
'-' ' routine. Since this timing is critical, care must be taken to avoid any
'-' ' instructions that can delay the interrupt branch, which will likely upset
'-' ' the timer. WAITX is among those instructions, so any time you're inside
'-' ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hctwait - wait interval in sysclocks.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' poll_waitx
'-'                 getct   hct2
	byte	$1a, $92, $63, $fd
'-'                 addct2  hct2, hctwait
	byte	$4c, $93, $6b, $fa
'-' .wait
'-'                 jnct2   #.wait
	byte	$ff, $25, $cc, $fb
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transaction retry handling for NAK/STALL or bus error.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - transaction response PID or error code.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' retry_wait
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret                                     ' STALL is special case
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak
	byte	$14, $00, $90, $ad
'-'                 mov     hctwait, _txn_err_              ' Transaction error wait...
	byte	$9e, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$d8, $ff, $bf, $fd
'-' .dec
'-'                 sub     retry, #1               wz
	byte	$01, $a2, $8e, $f1
'-'         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
	byte	$06, $be, $06, $a6
'-'                 ret                                     ' Retry result to caller
	byte	$2d, $00, $64, $fd
'-' .nak
'-'                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
	byte	$9d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $ff, $bf, $fd
'-'                 cmp     nak_retry, #NAK_NOLIMIT wz
	byte	$00, $9e, $0e, $f2
'-'         if_z    ret                                     ' Indefinite NAK retries
	byte	$2d, $00, $64, $ad
'-'                 sub     nak_retry, #1           wz
	byte	$01, $9e, $8e, $f1
'-'         if_z    mov     retval, #ERR_NAK
	byte	$08, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' host_reset
'-'                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
	byte	$25, $00, $64, $fd
'-'                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
	byte	$14, $70, $07, $fb
'-' ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
'-'                 cmp     htmp, ##168_000_000     wcz
	byte	$bd, $01, $05, $ff, $00, $70, $1f, $f2
'-'         if_be   mov     utx_tweak, #0
	byte	$00, $94, $06, $e6
'-'         if_a    mov     utx_tweak, #3   '#20
	byte	$03, $94, $06, $16
'-' ' Check to see if the system clock has been changed.
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $71, $0b, $f2
'-'         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $5e
'-'         if_nz   add     pb, hcog_base_addr
	byte	$47, $ef, $03, $51
'-'         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $5d
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-' 
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
	byte	$22, $6d, $13, $fc
'-' .enable
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 waitx   _1us_
	byte	$1f, $36, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 ' Handle Port protection enable and startup delay
'-'                 cmp     usb_enable_pin, #0      wc
	byte	$00, $48, $16, $f2
'-'         if_ae   drvl    usb_enable_pin                 ' disable port
	byte	$58, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Wait a while for everything to turn off
	byte	$1f, $5e, $63, $fd
'-'         if_ae   drvh    usb_enable_pin                  ' Enable the port
	byte	$59, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Hold to let the idle state get settled
	byte	$1f, $5e, $63, $fd
'-' 
'-'                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
	byte	$4b, $ed, $b7, $f9
'-'                 rep     @.regloop,#hreg_init_end - hreg_init_start
	byte	$3b, $04, $dc, $fc
'-'                 alti    pa, #%000_111_000
	byte	$38, $ec, $a7, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' .regloop
'-' 
'-'                 'call #dev_reset ' TODO THINK ABOUT THIS
'-' 
'-' discon_entry
'-'                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
	byte	$03, $96, $07, $f6
'-' 
'-'               
'-'         if HAVE_HIDPAD
'-'                 loc     pb, #@hidpad_report - @usb_host_start
	byte	$d8, $27, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
	byte	$28, $60, $64, $fd
'-'                 wrlong  #0,pb
	byte	$f7, $01, $68, $fc
'-'         end
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-'                 ' Fall through to disconnected loop
'-' 
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' Device connect handling (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
'-' ' device to connect (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' disconnected
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
	byte	$14, $86, $07, $fb
'-'                 cmp     hr1, save_sysclk        wz
	byte	$2c, $87, $0b, $f2
'-'         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
	byte	$6c, $ff, $9f, $5d
'-'                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
	byte	$03, $86, $47, $f0
'-'                 waitx   hr1                             ' it down to smaller wait chunks
	byte	$1f, $86, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
	byte	$e0, $ff, $9f, $ad
'-'         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
	byte	$28, $00, $90, $5d
'-' .se1_test
'-'                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$fc, $fe, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
	byte	$00, $be, $06, $56
'-'         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
	byte	$b0, $ff, $9f, $5d
'-' .se1            'SE1 is a fatal error condition
'-'                 mov     hctwait, _100ms_
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$e4, $fe, $bf, $fd
'-'                 mov     retval, #ERR_SE1
	byte	$03, $be, $06, $f6
'-'                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
	byte	$88, $f7, $bf, $fd
'-' .connect_test                                           ' Test lines until stable J/K state seen
'-'                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
	byte	$1f, $60, $63, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #discon_entry                   ' D+ and D- low
	byte	$90, $ff, $9f, $ad
'-'         if_e    jmp     #.se1_test                      ' D+ and D- high
	byte	$c4, $ff, $9f, $ad
'-' connected
'-'                 bith    hstatus, #CONNECTEDB            ' Device plugged in
	byte	$01, $96, $26, $f4
'-'                 call    #on_connect                     ' Initial device configuration
	byte	$34, $fb, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #discon_entry
	byte	$7c, $ff, $9f, $5d
'-' .set_pulse
'-'                 getct   _pulse_time_
	byte	$1a, $64, $63, $fd
'-'                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
	byte	$b1, $65, $03, $f1
'-' ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
'-' ' of 1ms and make a correction, if necessary.
'-' '                mov     htmp, _1ms_
'-' '                subs    htmp, iframe_delta
'-' '                adds    _frame1ms_clks_, htmp
'-' '                debug(udec(_frame1ms_clks_))
'-' 
'-'                 ' Fall through to idle/processing loop
'-'                 cmp     hdev_port, #MAX_DEVICES wcz
	byte	$07, $5a, $1e, $f2
'-'         if_a    mov     hdev_port, #0 
	byte	$00, $5a, $06, $16
'-' 
'-' hidle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_c    jmp     #.se0_test
	byte	$98, $00, $90, $cd
'-'                 pollct3                         wc
	byte	$24, $06, $70, $fd
'-'         if_nc   jmp     #.nopoll
	byte	$68, $00, $90, $3d
'-'                 getct   hct3
	byte	$1a, $94, $63, $fd
'-'                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
	byte	$a7, $95, $73, $fa
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $70, $e3, $f8
'-' 
'-'                 cmp     htmp, #HUB_READY        wz
	byte	$09, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_hub_status - @usb_host_start
	byte	$88, $1b, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$40, $00, $90, $ad
'-' 
'-'         if _HAVE_GAMEPAD
'-'                 cmp     htmp, #HID_READY        wz
	byte	$06, $70, $0f, $f2
'-'         if_nz   cmp     htmp, #PS3_READY        wz
	byte	$08, $70, $0f, $52
'-'         if_nz   cmp     htmp, #XINPUT_READY     wz
	byte	$07, $70, $0f, $52
'-'         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
	byte	$10, $16, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$2c, $00, $90, $ad
'-'         end
'-' 
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$34, $15, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$20, $00, $90, $ad
'-'         end
'-' 
'-'                 cmp     htmp, #KB_READY         wz
	byte	$03, $70, $0f, $f2
'-'         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$9c, $13, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$14, $00, $90, $ad
'-' 
'-'                 cmp     htmp, #KBM_READY        wz
	byte	$05, $70, $0f, $f2
'-'         if_nz   jmp     #.skip_poll
	byte	$14, $00, $90, $5d
'-'                 bitnot  hstatus, #KBM_TOGGLEB   wcz
	byte	$09, $96, $fe, $f4
'-'         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$9c, $13, $80, $3e
'-'         if HAVE_MOUSE
'-'         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$34, $15, $80, $ce
'-'         else
'-'         end
'-' 
'-' .poll
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-' .skip_poll
'-' 
'-'                 incmod  hdev_port, #MAX_DEVICES
	byte	$07, $5a, $06, $f7
'-' 
'-' .nopoll
'-'                 cmp     cmd_data, #CMD_SUSPEND  wz
	byte	$0e, $40, $0e, $f2
'-'         if_z    jmp     #hsuspend
	byte	$44, $00, $90, $ad
'-'                 cmp     cmd_data, #CMD_RESET    wz
	byte	$10, $40, $0e, $f2
'-'         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
	byte	$00, $40, $06, $a6
'-'         if_z    jmp     #host_reset                     ' See if it works...
	byte	$68, $fe, $9f, $ad
'-'                 getct   hr0
	byte	$1a, $84, $63, $fd
'-'                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
	byte	$b2, $85, $1b, $f2
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'         if_ae   getct   _pulse_time_
	byte	$1a, $64, $63, $3d
'-'         if_ae   add     _pulse_time_, _500ms_
	byte	$b1, $65, $03, $31
'-'                 jmp     #hidle
	byte	$5c, $ff, $9f, $fd
'-' ' Check for extended SE0 state on the bus
'-' .se0_test
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
	byte	$fc, $fd, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_nc   jmp     #hidle                          ' Bus still IDLE
	byte	$48, $ff, $9f, $3d
'-'                 call    #wait_txn_ok
	byte	$24, $f6, $bf, $fd
'-'                 wypin   ##OUT_IDLE, dm                  ' Float USB
	byte	$00, $00, $80, $ff, $22, $01, $28, $fc
'-'                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
'-'                 jmp     #host_reset                     ' Device disconnected
	byte	$30, $fe, $9f, $fd
'-' 
'-' hsuspend
'-'                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
	byte	$14, $f6, $bf, $fd
'-'                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
	byte	$25, $00, $64, $fd
'-'                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
	byte	$1f, $52, $63, $fd
'-'                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
	byte	$22, $01, $28, $fc
'-'                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
	byte	$00, $40, $06, $f6
'-'                 mov     mod_cnt, #0
	byte	$00, $96, $07, $f6
'-' 
'-'                 ' Fall through to resume wait loop
'-' 
'-' hwait_resume
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
	byte	$14, $86, $07, $fb
'-'                 shr     hr1, #2
	byte	$02, $86, $47, $f0
'-'                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
	byte	$1f, $86, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 cmp     cmd_data, #CMD_RESUME   wz
	byte	$0f, $40, $0e, $f2
'-'         if_nz   jmp     #hwait_resume
	byte	$ec, $ff, $9f, $5d
'-'                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
	byte	$14, $70, $07, $fb
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $71, $0b, $f2
'-'         if_z    jmp     #.resume
	byte	$18, $00, $90, $ad
'-'                 loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $fd
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
	byte	$22, $6d, $13, $3c
'-'         if_c    wxpin   _usb_h_ls_nco_, dm
	byte	$22, $69, $13, $cc
'-' .resume
'-'                 wypin   #OUT_K, dm
	byte	$22, $05, $28, $fc
'-'                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
	byte	$1f, $5c, $63, $fd
'-'                 wypin   #OUT_SE0, dm
	byte	$22, $03, $28, $fc
'-'                 mov     htmp, _ip_delay_ls_
	byte	$a2, $71, $03, $f6
'-'                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
	byte	$01, $70, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $70, $63, $fd
'-'                 wypin   #OUT_J, dm
	byte	$22, $07, $28, $fc
'-'                 shr     htmp, #1
	byte	$01, $70, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $70, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b3, $91, $62, $fa
'-'                 setint1 #1                              ' Enable the 1ms frame ISR
	byte	$25, $02, $64, $fd
'-'                 mov     hctwait, _4ms_
	byte	$aa, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
	byte	$50, $fd, $bf, $fd
'-'         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
	byte	$00, $40, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send preamble to enable low-speed HUB ports
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   USB baud rate set to low-speed
'-' '------------------------------------------------------------------------------
'-' utx_pre
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   #0, dm                          ' Disable smartpin mode
	byte	$22, $01, $08, $fc
'-'                 drvl    dm
	byte	$58, $44, $62, $fd
'-'                 drvh    dp
	byte	$59, $46, $62, $fd
'-' 
'-'                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
	byte	$1e, $00, $00, $ff, $80, $70, $07, $f6
'-' 
'-'                 rep     @.l1, #16 + 1
	byte	$11, $08, $dc, $fc
'-'                 shr     htmp, #1        wc
	byte	$01, $70, $57, $f0
'-'         if_nc   setq    #1
	byte	$28, $02, $64, $3d
'-'         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
	byte	$4f, $44, $62, $3d
'-'                 waitx   _preamble_wait_
	byte	$1f, $4c, $63, $fd
'-' .l1
'-' 
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
	byte	$22, $69, $13, $fc
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a4, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a2, $9b, $02, $06
'-' 
'-' hlut_end
'-'                 fit     $400
'-'                 orgh
'-' if OVERLAP_MEMORY
'-'                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
'-' end
'-' '------------------------------------------------------------------------------
'-' ' Routines called from cog space.
'-' '------------------------------------------------------------------------------
'-' ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'-' '------------------------------------------------------------------------------
'-' 
'-' '------------------------------------------------------------------------------
'-' ' USB host cog initialization.
'-' '------------------------------------------------------------------------------
'-' usb_host_init
'-'                 ' Initialize buffer pointers
'-'         if OVERLAP_MEMORY
'-'         else
'-'                 loc     pb, #hid_descr
	byte	$40, $15, $b0, $fe
'-'         end
'-'                 mov     hid_descr_p, pb
	byte	$f7, $4b, $02, $f6
'-'                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
'-'                 {
'-'                 }
'-'         
'-'                 {
'-'                 }
'-'                 'loc     pb,#hkbd_report
'-'                 'mov     hkbd_report_p,pb
'-' 
'-'                 loc     pb, #hub_descr
	byte	$08, $1d, $b0, $fe
'-'                 mov     hub_descr_p, pb
	byte	$f7, $4d, $02, $f6
'-'                 loc     pb, #urx_buff
	byte	$1d, $1d, $b0, $fe
'-'                 mov     urx_buff_p, pb
	byte	$f7, $4f, $02, $f6
'-'                 loc     pb, #dev_desc_buff
	byte	$95, $1d, $b0, $fe
'-'                 mov     dev_desc_buff_p, pb
	byte	$f7, $51, $02, $f6
'-'                 loc     pb, #con_desc_buff
	byte	$9f, $1d, $b0, $fe
'-'                 mov     con_desc_buff_p, pb
	byte	$f7, $53, $02, $f6
'-'                 loc     pb, #usb_cache_start
	byte	$18, $15, $b0, $fe
'-'                 mov     cache_start_p, pb
	byte	$f7, $55, $02, $f6
'-'                 loc     pb, #usb_cache_end
	byte	$e9, $1c, $b0, $fe
'-'                 mov     cache_end_p, pb
	byte	$f7, $57, $02, $f6
'-' 
'-'         if ERROR_LED >= 0
'-'         end
'-' 
'-'                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
'-'                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
'-'                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
'-' ' Configure and enable the Serial Host USB port.
'-'                 jmp     #host_reset                     ' Initialize host and enter main processing loop
	byte	$03, $03, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Timing calculations happen before any interrupt(s) are enabled.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   htmp - current CLKFREQ value.
'-' '------------------------------------------------------------------------------
'-' hinit_usb_timings
'-' '                getct   htmp2
'-'                 mov     save_sysclk, htmp
	byte	$b8, $59, $02, $f6
'-'                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
	byte	$8d, $5b, $80, $ff, $2c, $01, $2a, $fd
'-'                 getqx   _12Mbps_
	byte	$18, $30, $63, $fd
'-'                 shr     _12Mbps_, #16           wc
	byte	$10, $30, $57, $f0
'-'                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
	byte	$00, $30, $27, $f1
'-'                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
	byte	$03, $6c, $07, $f6
'-'                 shl     _usb_h_fs_nco_, #14
	byte	$0e, $6c, $67, $f0
'-'                 add     _usb_h_fs_nco_, _12Mbps_
	byte	$98, $6d, $03, $f1
'-'                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
	byte	$01, $6e, $07, $f6
'-'                 shl     _usb_d_fs_nco_, #14
	byte	$0e, $6e, $67, $f0
'-'                 add     _usb_d_fs_nco_, _12Mbps_
	byte	$98, $6f, $03, $f1
'-'                 mov     _1_5Mbps_, _12Mbps_
	byte	$98, $33, $03, $f6
'-'                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
	byte	$03, $32, $47, $f0
'-'                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
	byte	$02, $68, $07, $f6
'-'                 shl     _usb_h_ls_nco_, #14
	byte	$0e, $68, $67, $f0
'-'                 add     _usb_h_ls_nco_, _1_5Mbps_
	byte	$99, $69, $03, $f1
'-'                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
	byte	$99, $6b, $03, $f6
'-'                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
	byte	$80, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1b
	byte	$65, $cd, $1d, $ff, $00, $2e, $27, $fd
'-'                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
	byte	$18, $34, $63, $fd
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1m
	byte	$a1, $07, $00, $ff, $40, $2e, $27, $fd
'-'                 getqx   _1us_                           ' 1us as 32,9 fixed point
	byte	$18, $36, $63, $fd
'-'                 mov     hsave0, _1us_                   ' Save it to compute other us values
	byte	$9b, $7b, $03, $f6
'-'                 shr     _1us_, #9               wc
	byte	$09, $36, $57, $f0
'-'                 addx    _1us_, #0                       ' Round to final value
	byte	$00, $36, $27, $f1
'-'                 qmul    hsave0, #10                     ' Calc 10us
	byte	$0a, $7a, $07, $fd
'-'                 getqx   _10us_
	byte	$18, $38, $63, $fd
'-'                 shr     _10us_, #9              wc
	byte	$09, $38, $57, $f0
'-'                 addx    _10us_, #0                      ' 10us
	byte	$00, $38, $27, $f1
'-'                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
	byte	$21, $7a, $07, $fd
'-'                 getqx   _33us_
	byte	$18, $3a, $63, $fd
'-'                 shr     _33us_, #9              wc
	byte	$09, $3a, $57, $f0
'-'                 addx    _33us_, #0                      ' 33us
	byte	$00, $3a, $27, $f1
'-'                 qmul    hsave0, #250                    ' Calc 250us
	byte	$fa, $7a, $07, $fd
'-'                 getqx   _txn_err_
	byte	$18, $3c, $63, $fd
'-'                 shr     _txn_err_, #9           wc
	byte	$09, $3c, $57, $f0
'-'                 addx    _txn_err_, #0                   ' 250us
	byte	$00, $3c, $27, $f1
'-'                 qmul    hsave0, #500                    ' Calc 500us
	byte	$f4, $7b, $07, $fd
'-'                 getqx   _500us_
	byte	$18, $3e, $63, $fd
'-'                 shr     _500us_, #9             wc
	byte	$09, $3e, $57, $f0
'-'                 addx    _500us_, #0                     ' 500us
	byte	$00, $3e, $27, $f1
'-'                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
	byte	$01, $00, $00, $ff, $9a, $7a, $07, $fd
'-'                 getqx   _txn_ok_ls_
	byte	$18, $40, $63, $fd
'-'                 shr     _txn_ok_ls_, #9         wc
	byte	$09, $40, $57, $f0
'-'                 addx    _txn_ok_ls_, #0                 ' 666us
	byte	$00, $40, $27, $f1
'-'                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
	byte	$01, $00, $00, $ff, $52, $7b, $07, $fd
'-'                 getqx   _txn_ok_fs_
	byte	$18, $42, $63, $fd
'-'                 shr     _txn_ok_fs_, #9         wc
	byte	$09, $42, $57, $f0
'-'                 addx    _txn_ok_fs_, #0                 ' 850us
	byte	$00, $42, $27, $f1
'-'                 mov     _ip_delay_ls_, _1ns16fp_
	byte	$9a, $45, $03, $f6
'-'                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
	byte	$05, $00, $00, $ff, $80, $44, $07, $fa
'-'                 shr     _ip_delay_ls_, #16      wc
	byte	$10, $44, $57, $f0
'-'                 addx    _ip_delay_ls_, #0
	byte	$00, $44, $27, $f1
'-'                 mov     _tat_wait_ls_, _1ns16fp_
	byte	$9a, $49, $03, $f6
'-'                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
	byte	$1c, $00, $00, $ff, $c0, $49, $07, $fa
'-'                 shr     _tat_wait_ls_, #16      wc
	byte	$10, $48, $57, $f0
'-'                 addx    _tat_wait_ls_, #0
	byte	$00, $48, $27, $f1
'-'                 mov     _ip_delay_fs_, _1ns16fp_
	byte	$9a, $47, $03, $f6
'-'                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
	byte	$00, $00, $00, $ff, $4e, $47, $07, $fa
'-'                 shr     _ip_delay_fs_, #16      wc
	byte	$10, $46, $57, $f0
'-'                 addx    _ip_delay_fs_, #0
	byte	$00, $46, $27, $f1
'-'                 mov     _tat_wait_fs_, _1ns16fp_
	byte	$9a, $4b, $03, $f6
'-'                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
	byte	$04, $00, $00, $ff, $23, $4b, $07, $fa
'-'                 shr     _tat_wait_fs_, #16      wc
	byte	$10, $4a, $57, $f0
'-'                 addx    _tat_wait_fs_, #0
	byte	$00, $4a, $27, $f1
'-'                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
	byte	$8d, $5b, $00, $ff, $00, $59, $16, $fd
'-'                 getqx   _preamble_wait_
	byte	$18, $4c, $63, $fd
'-'                 sub     _preamble_wait_,# 9 - 1
	byte	$08, $4c, $87, $f1
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2c, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $2e, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2c, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1thou
	byte	$01, $00, $00, $ff, $e8, $2f, $27, $fd
'-'                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
	byte	$18, $4e, $63, $fd
'-'                 shr     _1ms_, #9               wc
	byte	$09, $4e, $57, $f0
'-'                 addx    _1ms_, #0                       ' 1ms
	byte	$00, $4e, $27, $f1
'-'                 mov     _frame1ms_clks_, ##-14
	byte	$ff, $ff, $7f, $ff, $f2, $67, $07, $f6
'-'                 adds    _frame1ms_clks_, _1ms_
	byte	$a7, $67, $43, $f1
'-'                 mov     _2ms_, _1ms_
	byte	$a7, $51, $03, $f6
'-'                 shl     _2ms_, #1                       ' 2ms
	byte	$01, $50, $67, $f0
'-'                 mov     _suspend_wait_, _1ms_
	byte	$a7, $53, $03, $f6
'-'                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
	byte	$a7, $53, $03, $f1
'-'                 mov     _4ms_, _1ms_
	byte	$a7, $55, $03, $f6
'-'                 shl     _4ms_, #2                       ' 4ms
	byte	$02, $54, $67, $f0
'-'                 mov     _xfer_wait_, _4ms_
	byte	$aa, $57, $03, $f6
'-'                 add     _xfer_wait_, _1ms_              ' 5ms
	byte	$a7, $57, $03, $f1
'-'                 mov     _reset_hold_, _xfer_wait_       ' 5ms
	byte	$ab, $5b, $03, $f6
'-'                 mov     _resume_hold_, _reset_hold_
	byte	$ad, $5d, $03, $f6
'-'                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
	byte	$02, $5c, $67, $f0
'-'                 mov     _100ms_, _resume_hold_          ' 20ms
	byte	$ae, $61, $03, $f6
'-'                 shl     _100ms_, #1                     ' 40ms
	byte	$01, $60, $67, $f0
'-'                 mov     _8ms_, _1ms_
	byte	$a7, $59, $03, $f6
'-'                 shl     _8ms_, #3                       ' 8ms
	byte	$03, $58, $67, $f0
'-'                 shl     _reset_hold_, #1                ' 10ms
	byte	$01, $5a, $67, $f0
'-'                 add     _100ms_, _reset_hold_           ' 50ms
	byte	$ad, $61, $03, $f1
'-'                 add     _reset_hold_, _xfer_wait_       ' 15ms
	byte	$ab, $5b, $03, $f1
'-'                 mov     _21ms_, _xfer_wait_             ' 5ms
	byte	$ab, $5f, $03, $f6
'-'                 shl     _21ms_, #2                      ' 20ms
	byte	$02, $5e, $67, $f0
'-'                 add     _21ms_, _1ms_                   ' 21ms
	byte	$a7, $5f, $03, $f1
'-'                 mov     _500ms_, _100ms_                ' 50ms
	byte	$b0, $63, $03, $f6
'-'                 shl     _100ms_, #1                     ' 100ms
	byte	$01, $60, $67, $f0
'-'                 shl     _500ms_, #3                     ' 400ms
	byte	$03, $62, $67, $f0
'-'         _ret_   add     _500ms_, _100ms_                ' 500ms
	byte	$b0, $63, $03, $01
'-' '        _ret_   mov     _1sec_, save_sysclk
'-' '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'-' '                ret
'-' {
'-' }
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Parse a configuration descriptor chain to see if the device is a recognized
'-' ' one. If it is, start the task progression that will configure the device for
'-' ' use.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hconfig_base - start address of the cached config descriptor chain.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hparse_con_desc
'-'                 mov     ptrb, dev_desc_buff_p
	byte	$28, $f3, $03, $f6
'-'                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
	byte	$82, $71, $07, $fb
'-'                 altr    hdev_port,#hdev_id
	byte	$61, $5b, $86, $f9
'-'                 movbyts htmp,#%%1032
	byte	$4e, $70, $ff, $f9
'-'                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
	byte	$86, $d3, $e6, $fa
'-'                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
'-' 
'-'                 mov     pa, #CON_wTotalLen
	byte	$02, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
	byte	$f6, $df, $e2, $fa
'-'                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
'-' ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
'-' ' that defines a keyboard and/or mouse.
'-'                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
	byte	$6e, $eb, $c2, $fa
'-' .next_intf
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #hset_config
	byte	$bc, $01, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $70, $0f, $f2
'-'         if_z    jmp     #.intf
	byte	$0c, $00, $90, $ad
'-'                 rdbyte  htmp, ptrb
	byte	$80, $71, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b8, $eb, $02, $f1
'-'                 jmp     #.next_intf
	byte	$d8, $ff, $9f, $fd
'-' .intf
'-'                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
	byte	$00, $8e, $07, $f6
'-'                 mov     hpar3, #0
	byte	$00, $90, $07, $f6
'-'                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
	byte	$82, $e1, $c6, $fa
'-'                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
	byte	$85, $e3, $c6, $fa
'-'                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
	byte	$86, $e5, $c6, $fa
'-'                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
	byte	$87, $e7, $c6, $fa
'-'                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
'-' 
'-' .endp
'-'                 rdbyte  htmp, ptrb
	byte	$80, $71, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b8, $eb, $02, $f1
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #.get_device
	byte	$78, $00, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $70, $0f, $f2
'-'         if_z    jmp     #.get_device
	byte	$64, $00, $90, $ad
'-'                 cmp     htmp, #TYPE_ENDPOINT    wz
	byte	$05, $70, $0f, $f2
'-'         if_z    jmp     #.get_ep
	byte	$04, $00, $90, $ad
'-'                 jmp     #.endp
	byte	$d0, $ff, $9f, $fd
'-' .get_ep
'-'                 rdbyte  hr1, ptrb[ENDP_bAddress]
	byte	$82, $87, $c7, $fa
'-'                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
	byte	$07, $86, $17, $f4
'-'                 shl     hr1, #8 + 7
	byte	$0f, $86, $67, $f0
'-'                 mov     htmp, hctrl_ep_addr
	byte	$6c, $71, $03, $f6
'-'                 and     htmp, ##ADDR_MASK
	byte	$3f, $00, $00, $ff, $00, $71, $07, $f5
'-'                 or      htmp, hr1                       ' endpoint address
	byte	$c3, $71, $43, $f5
'-'                 cmp     hpar2, #0               wz
	byte	$00, $8e, $0f, $f2
'-'  if_z_and_c     jmp     #.in_ep
	byte	$0c, $00, $90, $8d
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'  if_z_and_nc    jmp     #.out_ep
	byte	$18, $00, $90, $2d
'-'                 jmp     #.endp
	byte	$a0, $ff, $9f, $fd
'-' .in_ep
'-'                 mov     hpar2, htmp                     ' IN endpoint
	byte	$b8, $8f, $03, $f6
'-'                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
	byte	$84, $89, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $85, $c7, $fa
'-'                 setbyte hr2, hr0, #3
	byte	$c2, $89, $db, $f8
'-'                 jmp     #.endp
	byte	$8c, $ff, $9f, $fd
'-' .out_ep
'-'                 mov     hpar3, htmp                     ' OUT endpoint
	byte	$b8, $91, $03, $f6
'-'                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8b, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $85, $c7, $fa
'-'                 setbyte hr3, hr0, #3
	byte	$c2, $8b, $db, $f8
'-'                 jmp     #.endp
	byte	$78, $ff, $9f, $fd
'-' 
'-' .get_device
'-'                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
	byte	$ff, $e2, $0e, $f2
'-'         if_z    cmp     hdev_subclass, #$5D     wz
	byte	$5d, $e4, $0e, $a2
'-'         if_z    cmp     hdev_protocol, #$01     wz
	byte	$01, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$68, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HUB  wz
	byte	$09, $e2, $0e, $f2
'-'         if_z    jmp     #.hub
	byte	$ac, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HID              wz
	byte	$03, $e2, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No HID class, ignore
	byte	$18, $ff, $9f, $5d
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_z    cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$4c, $00, $90, $ad
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
	byte	$01, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
	byte	$04, $ff, $9f, $5d
'-' .keyboard
'-'                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
	byte	$01, $e6, $0e, $f2
'-'         if HAVE_MOUSE
'-'         if_nz  jmp      #.mouse                         ' No Keyboard
	byte	$1c, $00, $90, $5d
'-'         else
'-'         end
'-'                 cmp     hkbd_ep_addr, #0    wz
	byte	$00, $f2, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$f4, $fe, $9f, $5d
'-'                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6f, $e2, $f8
'-'                 getbyte kb_interval, hr2, #3
	byte	$c4, $71, $fa, $f8
'-'                 getbyte kb_in_max_pkt, hr2, #0
	byte	$c4, $73, $e2, $f8
'-'                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
	byte	$c7, $f3, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$e0, $fe, $9f, $fd
'-' if HAVE_MOUSE
'-' .mouse
'-'                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
	byte	$02, $e6, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No Mouse
	byte	$d8, $fe, $9f, $5d
'-'                 cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$d0, $fe, $9f, $5d
'-'                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6b, $e2, $f8
'-'                 'getbyte ms_interval, hr2, #3
'-'                 getbyte ms_in_max_pkt, hr2, #0
	byte	$c4, $6d, $e2, $f8
'-'                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
	byte	$c7, $f5, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$c0, $fe, $9f, $fd
'-' end
'-' .gamepad
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $71, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c7, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$ac, $fe, $9f, $ad
'-'         if HAVE_MOUSE
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $71, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c7, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$98, $fe, $9f, $ad
'-'         end
'-'                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz      ' |
	byte	$00, $00, $0c, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$8c, $fe, $9f, $5d
'-' 
'-'                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $79, $e2, $f8
'-'                 getbyte gp_interval, hr2, #3
	byte	$c4, $7b, $fa, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, hpar2                      ' IN endpoint address
	byte	$c7, $01, $00, $f6
'-'                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
	byte	$c8, $0b, $03, $f6
'-'                 'debug(udec(gp_intf_num))
'-'                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
'-'                 jmp     #.next_intf
	byte	$74, $fe, $9f, $fd
'-' .hub
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$6c, $fe, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_nz   cmp     hdev_protocol, #2                   wz
	byte	$02, $e6, $0e, $52
'-'         if_nz   jmp     #.next_intf
	byte	$60, $fe, $9f, $5d
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$58, $fe, $9f, $5d
'-'                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
	byte	$70, $63, $e2, $f8
'-'                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $ed, $02, $f6
'-'                 mov     ep_addr_pid, hpar2              ' IN endpoint address
	byte	$c7, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 mov     hhub_ep_addr, ep_addr_pid
	byte	$5e, $ef, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
	byte	$6c, $bd, $02, $f6
'-'                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
'-'                 jmp     #.next_intf
	byte	$3c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' If a newly-connected device is recognized, do whatever is needed to configure
'-' ' it according to its function, or functions. In the case of this boot protocol
'-' ' keyboard/mouse class driver:
'-' ' - SetConfiguration(config_num)
'-' ' - SetProtocol(boot)
'-' ' - SetIdle(indefinite)
'-' ' - Enter the device interrupt IN polling task stage.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_config
'-' '                mov     hkbd_ep_addr, #0                ' DEBUG
'-' '                mov     hmouse_ep_addr, #0              ' DEBUG
'-'                 mov     htmp2, #DEV_UNKNOWN
	byte	$02, $74, $07, $f6
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $a2
'-'         if HAVE_MOUSE
'-'         if_z    cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $a2
'-'         end
'-'         if_z    cmp     hhub_ep_addr, #0        wz
	byte	$00, $ee, $0e, $a2
'-'         if_z    jmp     #.notify_client                 ' No known device
	byte	$4c, $03, $90, $ad
'-' .set_config
'-'                 loc     ptra, #set_config
	byte	$6c, $0e, $d0, $fe
'-'                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
	byte	$05, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdbyte  hpar1, pa
	byte	$f6, $8d, $c3, $fa
'-'                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
	byte	$01, $8d, $57, $fc
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
	byte	$6c, $bd, $02, $f6
'-'                 mov     pb, #0                          ' SetConfiguration() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-' .kbd_config
'-'                 cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $f2
'-'         if_z    jmp     #.mouse_config                  ' No keyboard
	byte	$98, $00, $90, $ad
'-' 
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.mouse_config                  ' No keyboard
	byte	$84, $00, $90, $5d
'-' 
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $71, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$34, $0e, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$e4, $02, $90, $5d
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8c, $07, $f6
'-'                 getbyte hpar2, kb_intf_num, #0
	byte	$37, $8f, $e3, $f8
'-'                 call    #hset_idle
	byte	$30, $03, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hkbd_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 mov     hctwait, _2ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
	byte	$00, $76, $06, $f6
'-'                 mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $f6
'-'                 loc     pa, #hkbd_led_rep
	byte	$90, $17, $90, $fe
'-'                 wrbyte  hkbd_ledstates,pa
	byte	$f6, $f9, $42, $fc
'-'                 call    #hset_kbdled_report
	byte	$2c, $03, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$b0, $02, $90, $5d
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hkbd_ep_addr, ep_addr_pid
	byte	$5e, $f3, $02, $f6
'-'                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $f1, $02, $f6
'-'                 bitc    hkbd_ctrl_ep, #31
	byte	$1f, $f0, $46, $f4
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
	byte	$00, $f6, $06, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $c6, $f8
'-'                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
	byte	$03, $74, $07, $f6
'-'         if !!HAVE_MOUSE
'-'         end
'-' 
'-' .mouse_config
'-' if HAVE_MOUSE
'-'                 cmp     hmouse_ep_addr, #0        wz
	byte	$00, $f4, $0e, $f2
'-'         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$ac, $00, $90, $ad
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$98, $00, $90, $5d
'-' 
'-'                 debug("mouse passed addr check")
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$b0, $0d, $d0, $fe
'-'                 wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $ff, $03, $01, $5e, $fc
'-'                 wrword  ms_intf_num,ptra[wIndex]
	byte	$02, $6b, $56, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$44, $02, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),uhex_byte_array(pb,total_data))
'-' 
'-'                 getbyte htmp, ms_intf_num, #0
	byte	$35, $71, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$64, $0d, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$14, $02, $90, $5d
'-'                 debug("mouse passed SetProtocol")
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8c, $07, $f6
'-'                 getbyte hpar2, ms_intf_num, #0
	byte	$35, $8f, $e3, $f8
'-'                 call    #hset_idle
	byte	$60, $02, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hmouse_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 debug("mouse passed SetIdle")
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hmouse_ep_addr, ep_addr_pid
	byte	$5e, $f5, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $ce, $f8
'-'                 mov     htmp2, hkbd_ep_addr
	byte	$79, $75, $03, $f6
'-'                 xor     htmp2, hmouse_ep_addr
	byte	$7a, $75, $63, $f5
'-'                 and     htmp2, ##ADDR_MASK              wz
	byte	$3f, $00, $00, $ff, $00, $75, $0f, $f5
'-'         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
	byte	$05, $74, $07, $a6
'-'         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
	byte	$04, $74, $07, $56
'-'                 jmp     #.notify_client
	byte	$d0, $01, $90, $fd
'-' end
'-' .gamepad_config
'-' if _HAVE_GAMEPAD
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    jmp     #.hub_config                    ' No gamepad
	byte	$58, $01, $90, $ad
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     htmp, 0-0
	byte	$00, $70, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.hub_config                    ' No gamepad
	byte	$40, $01, $90, $5d
'-' 
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, ep_addr_pid
	byte	$5e, $01, $00, $f6
'-'                 mov     ep_addr_pid, hdev_out_addr  wz
	byte	$85, $bd, $0a, $f6
'-'         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $58
'-'         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $5d
'-'         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $54
'-'         if_nz   bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $54
'-'         if_nz   mov     hdev_out_addr, ep_addr_pid
	byte	$5e, $0b, $03, $56
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 if EMUPAD_MAX_PLAYER > 0
'-'                 
'-' .rule_loop           
'-'                 end
'-' 
'-'                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
	byte	$ff, $e2, $0e, $f2
'-'         if_e    jmp     #.xinput
	byte	$5c, $00, $90, $ad
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     htmp,0-0
	byte	$00, $70, $03, $f6
'-'                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
	byte	$01, $a6, $02, $ff, $68, $70, $0f, $f2
'-'         if_e    jmp     #.ps3
	byte	$7c, $00, $90, $ad
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$a0, $0c, $d0, $fe
'-'                 cmp     hdev_port,#0            wz
	byte	$00, $5a, $0e, $f2
'-'         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $5f, $03, $01, $5e, $5c
'-'         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
	byte	$03, $00, $80, $af, $03, $01, $5e, $ac
'-'                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
	byte	$02, $01, $5c, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$24, $01, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),uhex_byte_array(pb,total_data))
'-' 
'-'                 mov     htmp2, #HID_READY               ' Standard gamepad
	byte	$06, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$10, $01, $90, $fd
'-' .xinput
'-'                 loc     ptra, #xinp_led_cmd             ' Turn on LED
	byte	$b4, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb,#1 ' root device is also player 1
	byte	$01, $ee, $e7, $f2
'-'                 fle     pb,#3
	byte	$03, $ee, $27, $f3
'-'                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
	byte	$06, $ee, $07, $f1
'-'                 wrbyte  pb, ptra[2]
	byte	$02, $ef, $47, $fc
'-' 
'-'                 mov     pkt_data, #3
	byte	$03, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB
	byte	$03, $96, $06, $f4
'-'                 mov     ep_addr_pid, hdev_out_addr
	byte	$85, $bd, $02, $f6
'-'                 call    #txn_out
	byte	$5a, $00, $a0, $fd
'-'                 mov     ep_addr_pid, hctrl_ep_addr
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 mov     htmp2, #XINPUT_READY
	byte	$07, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$dc, $00, $90, $fd
'-' .ps3
'-'                 loc     ptra, #ps3_command_buff         ' Turn on LED
	byte	$50, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 fge     pb,#1 ' root device is also player 1
	byte	$01, $ee, $07, $f3
'-'                 fle     pb,#4
	byte	$04, $ee, $27, $f3
'-'                 decod   pb
	byte	$f7, $ef, $c3, $f9
'-'                 wrbyte  pb, ptra[9]
	byte	$09, $ef, $47, $fc
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$00, $0c, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $03, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #48, ptra[wLength]
	byte	$03, $61, $5c, $fc
'-'                 loc     pb, #ps3_command_buff
	byte	$20, $0c, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$e0, $0b, $d0, $fe
'-'                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $e9, $5f, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #4, ptra[wLength]
	byte	$03, $09, $5c, $fc
'-'                 loc     pb, #ps3_enable_cmd             ' Enable PS3
	byte	$fc, $0b, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK    wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$74, $00, $90, $5d
'-' 
'-'                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
	byte	$08, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$6c, $00, $90, $fd
'-' end
'-' 
'-' .hub_config
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_z    jmp     #.notify_client                 ' No HUB
	byte	$64, $00, $90, $ad
'-'                 mov     htmp, hhub_ep_addr
	byte	$77, $71, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $71, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $71, $0f, $f5
'-'         if_nz   jmp     #.notify_client                 ' No HUB
	byte	$50, $00, $90, $5d
'-' 
'-'                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
	byte	$a0, $0b, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, hub_descr_p
	byte	$26, $ef, $03, $f6
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hhub_ep_addr, #0
	byte	$00, $ee, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $00, $90, $5d
'-'                 debug(uhex_byte_array(hub_descr_p,total_data))
'-' 
'-'                 mov     ptra, hub_descr_p
	byte	$26, $f1, $03, $f6
'-'                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
	byte	$02, $77, $c7, $fa
'-'                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
	byte	$07, $76, $27, $f3
'-'                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
'-' .pwr_loop
'-'                 loc     ptra, #set_port_feat            ' Power on ports
	byte	$80, $0b, $d0, $fe
'-'                 wrword  #HUB_PORT_POWER, ptra[wValue]
	byte	$01, $11, $5c, $fc
'-'                 wrword  htmp3, ptra[wIndex]
	byte	$02, $77, $57, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 djnz    htmp3, #.pwr_loop
	byte	$fb, $77, $6f, $fb
'-' 
'-'                 mov     hctwait, _500ms_
	byte	$b1, $99, $02, $f6
'-'                 add     hctwait, _100ms_
	byte	$b0, $99, $02, $f1
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 mov     htmp2, #HUB_READY               ' Hub ready
	byte	$09, $74, $07, $f6
'-'                 jmp     #.notify_client
	byte	$00, $00, $90, $fd
'-' 
'-' .notify_client
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte htmp2                           ' Save device ready
	byte	$ba, $01, $c0, $f8
'-'                 debug(uhex_long(hdev_type,hdev_type+1))
'-'         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Initialize the keyboard/mouse data area to start-up values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' init_kbdm_data
'-'                 mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $f6
'-'                 mov     hdev_ep_addr, #0
	byte	$00, $fa, $06, $f6
'-' 
'-'                 mov     ptra, cache_start_p         ' Clear cached data buffers
	byte	$2a, $f1, $03, $f6
'-'                 mov     pa, cache_end_p
	byte	$2b, $ed, $03, $f6
'-' .loop
'-'                 wrbyte  #0, ptra++
	byte	$61, $01, $4c, $fc
'-'                 cmp     ptra, pa                wcz
	byte	$f6, $f1, $1b, $f2
'-'         if_b    jmp     #.loop
	byte	$f4, $ff, $9f, $cd
'-'         
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' 
'-'                 mov     pa, #hdev_init_start        ' Clear device data registers
	byte	$2d, $ed, $07, $f6
'-' .regloop
'-'                 altd    pa
	byte	$00, $ec, $8f, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-'                 add     pa, #1
	byte	$01, $ec, $07, $f1
'-'                 cmp     pa, #hdev_init_end      wz
	byte	$47, $ed, $0f, $f2
'-'         if_nz   jmp     #.regloop
	byte	$ec, $ff, $9f, $5d
'-' 
'-'                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
	byte	$e1, $e1, $61, $ff, $c3, $5d, $06, $f6
'-'                 mov     hdev_next_datax + 1,hdev_next_datax
	byte	$2e, $5f, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0
	byte	$c3, $60, $c6, $f8
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1
	byte	$c3, $60, $ce, $f8
'-' 
'-'         _ret_   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
'-' ' function.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'-' '   hpar2 - index number of the target interface.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_idle
'-'                 mov     hctwait, _2ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #set_idle
	byte	$d8, $0a, $d0, $fe
'-'                 wrword  hpar1, ptra[wValue]
	byte	$01, $8d, $57, $fc
'-'                 wrword  hpar2, ptra[wIndex]
	byte	$02, $8f, $57, $fc
'-'                 jmp     #control_write
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
'-' ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - device address and enpoint for the request.
'-' ' On exit:
'-' '   retval - transaction result.
'-' '------------------------------------------------------------------------------
'-' hset_kbdled_report
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $71, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$cc, $0a, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
	byte	$01, $00, $80, $ff, $01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $71, $57, $fc
'-'                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
	byte	$03, $03, $5c, $fc
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrbyte  kb_led_states, pb
	byte	$f7, $77, $42, $fc
'-'                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for keyboard activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_kbd_in_report
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #0
	byte	$30, $91, $e3, $f8
'-'                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
	byte	$39, $91, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
	byte	$30, $71, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
	byte	$4b, $60, $c6, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
	byte	$c3, $60, $c6, $58
'-' 
'-'                 mov     kb_max_index, hpar3             ' Save actual bytes read
	byte	$c8, $75, $02, $f6
'-'                 call    #hkbd_compare
	byte	$18, $00, $b0, $fd
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' .led_check
'-'                 mov     htmp, kb_led_states
	byte	$3b, $71, $03, $f6
'-'                 cmp     hkbd_ledstates, htmp    wz
	byte	$b8, $f9, $0a, $f2
'-'         if_z    ret                                     ' No toggle key indicator changes, so we're done
	byte	$2d, $00, $64, $ad
'-'                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
	byte	$7c, $77, $02, $f6
'-'                 mov     ep_addr_pid, hkbd_ctrl_ep
	byte	$78, $bd, $02, $f6
'-'                 jmp     #hset_kbdled_report             ' Set report and ignore errors
	byte	$88, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Compare current and previous keyboard data buffers for keypress changes.
'-' '------------------------------------------------------------------------------
'-' hkbd_compare
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$d4, $13, $f0, $fe
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $75, $07, $fb
'-'                 cmp     htmp1, htmp2    wz
	byte	$ba, $73, $0b, $f2
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $75, $07, $fb
'-'         if_z    cmp     htmp1, htmp2    wz
	byte	$ba, $73, $0b, $a2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-' 
'-'                 loc     ptra, #hkbd_report
	byte	$b4, $13, $d0, $fe
'-' 
'-'                 ' Handle modifiers
'-'                 rdbyte  hpar2, urx_buff_p
	byte	$27, $8f, $c3, $fa
'-'                 rdbyte  hr1, ptra
	byte	$00, $87, $c7, $fa
'-'                 rolword hr1,hpar2,#0
	byte	$c7, $87, $43, $f9
'-'                 mergew  hr1
	byte	$63, $86, $63, $fd
'-'                 mov     pa,#8
	byte	$08, $ec, $07, $f6
'-' .modloop
'-'                 rczr    hr1     wcz ' New value in C, old value in Z
	byte	$6a, $86, $7b, $fd
'-'                 mov     hpar1,#$E8
	byte	$e8, $8c, $07, $f6
'-'                 sub     hpar1,pa
	byte	$f6, $8d, $83, $f1
'-'       if_c_ne_z call    #hkbd_translate
	byte	$a0, $00, $b0, $6d
'-'                 djnz    pa,#.modloop
	byte	$fb, $ed, $6f, $fb
'-' 
'-' .release        modc    _set    wc
	byte	$6f, $e0, $75, $fd
'-'                 'alts    hdev_port, #hid_report_p
'-'                 'mov     ptra, hid_report_p
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .rl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8d, $cf, $fa
'-'         if_z    jmp     #.rl3
	byte	$20, $00, $90, $ad
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .rl2            rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b8, $8d, $0b, $f2
'-'         if_z    jmp     #.rl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.rl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$68, $00, $b0, $fd
'-' .rl3            djnz    pa, #.rl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-'                 mov     hpar3, #0
	byte	$00, $90, $07, $f6
'-'                 bith    hpar3, #31
	byte	$1f, $90, $27, $f4
'-' 
'-' .press          modc    _clr    wc
	byte	$6f, $00, $74, $fd
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .pl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8d, $cf, $fa
'-'         if_z    jmp     #.pl3
	byte	$20, $00, $90, $ad
'-'                 loc     ptrb, #hkbd_report
	byte	$30, $13, $f0, $fe
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .pl2            rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b8, $8d, $0b, $f2
'-'         if_z    jmp     #.pl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.pl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$24, $00, $b0, $fd
'-' .pl3            djnz    pa, #.pl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-' .copy           mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$08, $13, $f0, $fe
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 rdlong  htmp1, ptra++
	byte	$61, $73, $07, $fb
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 wrlong  htmp1, ptrb++
	byte	$e1, $73, $67, $fc
'-'                 wrbyte  hkbd_ledstates,ptrb++
	byte	$e1, $f9, $46, $fc
'-' 
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Translate keyboard scancode to ASCII
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - scancode
'-' '   hpar2 - key modifiers state
'-' '       c - pressed (0) or released (1) flag
'-' ' On exit:
'-' '   hpar1 - bit     31 = 0 pressed, 1 released
'-' '               30..17 = unused
'-' '                   18 = scroll-lock state 
'-' '                   17 = caps-lock state
'-' '                   16 = num-lock state 
'-' '                15..8 = key modifiers state
'-' '                 7..0 = scancode
'-' '------------------------------------------------------------------------------
'-' hkbd_translate
'-'                 cmp     hpar1, #KEY_CAPSLOCK    wz
	byte	$39, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
	byte	$01, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_NUMLOCK     wz
	byte	$53, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
	byte	$00, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_SCROLLLOCK  wz
	byte	$47, $8c, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
	byte	$02, $f8, $e6, $24
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' 
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' 
'-'         end
'-'                 setbyte hpar1, hpar2, #1
	byte	$c7, $8d, $cb, $f8
'-'                 setbyte hpar1, hkbd_ledstates,#2
	byte	$7c, $8d, $d3, $f8
'-'                 bitc    hpar1, #31
	byte	$1f, $8c, $47, $f4
'-'         if KEYQUEUE_SIZE > 0
'-'                 loc pb,#keyq_head
	byte	$c4, $09, $b0, $fe
'-'                 rdword htmp,pb
	byte	$f7, $71, $e3, $fa
'-'                 getbyte htmp1,htmp,#1 ' tail
	byte	$b8, $73, $eb, $f8
'-'                 getbyte htmp,htmp,#0 ' head
	byte	$b8, $71, $e3, $f8
'-'                 mov htmp2,htmp
	byte	$b8, $75, $03, $f6
'-'                 mul htmp2,#4
	byte	$04, $74, $07, $fa
'-'                 add htmp2,pb
	byte	$f7, $75, $03, $f1
'-'                 add htmp2,#2
	byte	$02, $74, $07, $f1
'-'                 incmod htmp,#KEYQUEUE_SIZE - 1
	byte	$7f, $70, $07, $f7
'-'                 cmp htmp1,htmp wz ' check buffer overflow
	byte	$b8, $73, $0b, $f2
'-'         if_nz   wrlong hpar1,htmp2
	byte	$ba, $8d, $63, $5c
'-'         if_nz   wrbyte htmp,pb
	byte	$f7, $71, $43, $5c
'-'         end
'-'                 ret wcz
	byte	$2d, $00, $7c, $fd
'-' 
'-' if HAVE_MOUSE
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for mouse activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_mouse_in_report
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #1
	byte	$30, $91, $eb, $f8
'-'                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
	byte	$36, $91, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
	byte	$30, $71, $eb, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
	byte	$4b, $60, $ce, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
	byte	$c3, $60, $ce, $58
'-' 
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 cmp     hpar3, #5               wcz     ' Hack: Combo PS/2-USB adapters adds report-id
	byte	$05, $90, $1f, $f2
'-'         if_ae   add     ptra, #1                        ' | skip
	byte	$01, $f0, $07, $31
'-'         if_ae   sub     hpar3, #1
	byte	$01, $90, $87, $31
'-' 
'-'                 loc     pa, #mouse_limits
	byte	$40, $09, $90, $fe
'-'                 loc     ptrb, #mouse_xacc
	byte	$25, $13, $f0, $fe
'-' 
'-'                 ' load xacc,yacc,zacc
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  hr1,ptrb
	byte	$80, $87, $07, $fb
'-'                 ' load limits and outptr
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  htmp1,pa
	byte	$f6, $73, $03, $fb
'-' 
'-'                 rdbyte  htmp, ptra++                     ' Button flags
	byte	$61, $71, $c7, $fa
'-'                 wrbyte  htmp, ptrb[12]                    ' write verbatim into extra byte
	byte	$8c, $71, $47, $fc
'-'                 testb   htmp,#0                 wc       ' left button flag
	byte	$00, $70, $17, $f4
'-'         if_c    wrbyte  #1,ptrb[13]
	byte	$8d, $03, $4c, $cc
'-'                 testb   htmp,#1                 wc       ' left button flag
	byte	$01, $70, $17, $f4
'-'         if_c    wrbyte  #1,ptrb[14]
	byte	$8e, $03, $4c, $cc
'-'                 testb   htmp,#2                 wc       ' left button flag
	byte	$02, $70, $17, $f4
'-'         if_c    wrbyte  #1,ptrb[15]
	byte	$8f, $03, $4c, $cc
'-'               
'-' 
'-'                 rdbyte  htmp, ptra++                     ' X direction and velocity is 8-bit signed
	byte	$61, $71, $c7, $fa
'-'                 signx   htmp, #7
	byte	$07, $70, $67, $f7
'-'                 add     hr1,htmp
	byte	$b8, $87, $03, $f1
'-'                 cmp     htmp1,#0 wz
	byte	$00, $72, $0f, $f2
'-'         if_ne   fles    hr1,htmp1
	byte	$b9, $87, $63, $53
'-'         if_ne   fges    hr1,#0
	byte	$00, $86, $47, $53
'-' 
'-'                 rdbyte  htmp, ptra++                     ' Y direction and velocity is 8-bit signed
	byte	$61, $71, $c7, $fa
'-'                 signx   htmp, #7
	byte	$07, $70, $67, $f7
'-'                 add     hr2,htmp
	byte	$b8, $89, $03, $f1
'-'                 cmp     htmp2,#0 wz
	byte	$00, $74, $0f, $f2
'-'         if_ne   fles    hr2,htmp2
	byte	$ba, $89, $63, $53
'-'         if_ne   fges    hr2,#0
	byte	$00, $88, $47, $53
'-'                 
'-' 
'-'                 cmp     hpar3, #4               wz      ' Very few mice send +/- scroll wheel data in boot protocol
	byte	$04, $90, $0f, $f2
'-'         if_z    rdbyte  htmp, ptra
	byte	$00, $71, $c7, $aa
'-'         if_z    signx   htmp, #7                        ' If it's there, use it
	byte	$07, $70, $67, $a7
'-'         if_z    add     hr3,htmp
	byte	$b8, $8b, $03, $a1
'-' 
'-'                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
	byte	$90, $71, $cf, $fa
'-'         if_nz   ret                                     ' If so, don't write results
	byte	$2d, $00, $64, $5d
'-' 
'-'                 ' write back accumulators
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 wrlong  hr1,ptrb
	byte	$80, $87, $67, $fc
'-'                 ' if outptr set, write X/Y words
'-'                 cmp htmp3,#0                    wz
	byte	$00, $76, $0f, $f2
'-'         if_nz   setword hr1,hr2,#1
	byte	$c4, $87, $2b, $59
'-'         if_nz   wrlong hr1,htmp3
	byte	$bb, $87, $63, $5c
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' hget_gp_in_report
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-' 
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 altgb   hdev_port, #hdev_next_datax
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte hpar3
	byte	$00, $90, $e3, $f8
'-'                 setword hpar3, #255, #1                 ' Always ask for max report size
	byte	$ff, $90, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-'                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte htmp                            ' |
	byte	$00, $70, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $70, $0f, $f2
'-'         if_z    mov     htmp, #PID_DATA1                ' |
	byte	$4b, $70, $07, $a6
'-'         if_nz   mov     htmp, #PID_DATA0                ' |
	byte	$c3, $70, $07, $56
'-'                 altsb   hdev_port, #hdev_next_datax     ' |
	byte	$2e, $5b, $66, $f9
'-'                 setbyte htmp                            ' |
	byte	$b8, $01, $c0, $f8
'-' 
'-' ' Note: the following code compares the current and previous reports
'-' ' and process the data if there are changes to ease the debug output.
'-' ' Actual implementations should remove this block, along with hid_pre_rpt_p and
'-' ' gpPreReport buffer.
'-' 
'-'                 ' ----- start of block to remove
'-'                 {
'-'                 }
'-'                 ' ----- end of block to remove
'-'                 loc pa,#hpad_translate
	byte	$f4, $04, $90, $fe
'-'                 push pa
	byte	$2a, $ec, $63, $fd
'-' 
'-'                 ' FALL THROUGH !!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Decode controller report
'-' '------------------------------------------------------------------------------
'-' hid_decode
'-'                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
'-'                 setq #(hidr_end-hidr_start)-1
	byte	$28, $1e, $64, $fd
'-'                 rdlong  hidr_start,##$8_0000
	byte	$00, $04, $00, $ff, $00, $0c, $07, $fb
'-' 
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte hidr_type
	byte	$00, $2a, $e3, $f8
'-'                 cmp     hidr_type, #XINPUT_READY        wz
	byte	$07, $2a, $0f, $f2
'-'         if_z    jmp     #hpad_xinput
	byte	$34, $02, $90, $ad
'-'                 cmp     hidr_type, #PS3_READY           wz
	byte	$08, $2a, $0f, $f2
'-'         if_z    jmp     #hpad_ps3
	byte	$1c, $03, $90, $ad
'-'                 cmp     hidr_type, #KBM_READY           wz
	byte	$05, $2a, $0f, $f2
'-'         if_z    mov     hidr_type,#M_READY
	byte	$04, $2a, $07, $a6
'-'                 cmp     hidr_type, #M_READY             wz
	byte	$04, $2a, $0f, $f2
'-'                 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle HID controller (or mouse now
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' hpad_hid
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 mov     ptra, pb
	byte	$f7, $f1, $03, $f6
'-'                 alts    hdev_port, #gp_descr_len
	byte	$3f, $5b, $96, $f9
'-'                 mov     pa, 0-0
	byte	$00, $ec, $03, $f6
'-'                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
'-'                 mov     hidr_usage, ##$76543210
	byte	$19, $2a, $3b, $ff, $10, $0c, $07, $f6
'-' 
'-' .next
'-'                 cmps    pa, #0      wcz
	byte	$00, $ec, $5f, $f2
'-'         if_be   ret     wcz
	byte	$2d, $00, $7c, $ed
'-' 
'-'                 rdbyte  hpar1, ptra++
	byte	$61, $8d, $c7, $fa
'-'                 sub     pa, #1
	byte	$01, $ec, $87, $f1
'-'                 mov     hpar2, #0
	byte	$00, $8e, $07, $f6
'-' 
'-'                 mov     htmp, hpar1
	byte	$c6, $71, $03, $f6
'-'                 and     htmp, #$03
	byte	$03, $70, $07, $f5
'-'                 cmp     htmp, #1    wz
	byte	$01, $70, $0f, $f2
'-'         if_z    rdbyte  hpar2, ptra++
	byte	$61, $8f, $c7, $aa
'-'         if_z    signx   hpar2,#7
	byte	$07, $8e, $67, $a7
'-'         if_z    sub     pa, #1
	byte	$01, $ec, $87, $a1
'-'                 cmp     htmp, #2    wz
	byte	$02, $70, $0f, $f2
'-'         if_z    rdword  hpar2, ptra++
	byte	$61, $8f, $e7, $aa
'-'         if_z    signx   hpar2,#15
	byte	$0f, $8e, $67, $a7
'-'         if_z    sub     pa, #2
	byte	$02, $ec, $87, $a1
'-'                 cmp     htmp, #3    wz
	byte	$03, $70, $0f, $f2
'-'         if_z    rdlong  hpar2, ptra++
	byte	$61, $8f, $07, $ab
'-'         if_z    sub     pa, #4
	byte	$04, $ec, $87, $a1
'-' 
'-'                 and     hpar1, #$FC
	byte	$fc, $8c, $07, $f5
'-'                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
'-' 
'-'                 cmp     hpar1, #HID_REPORT_ID   wz
	byte	$84, $8c, $0f, $f2
'-'         if_z    jmp     #.report_id
	byte	$0c, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE_PAGE  wz
	byte	$04, $8c, $0f, $f2
'-'         if_z    jmp     #.usage_page
	byte	$24, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE       wz
	byte	$08, $8c, $0f, $f2
'-'         if_z    jmp     #.usage
	byte	$2c, $01, $90, $ad
'-'                 cmp     hpar1, #HID_LOGICAL_MIN wz
	byte	$14, $8c, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #1
	byte	$c7, $27, $2b, $a9
'-'                 cmp     hpar1, #HID_LOGICAL_MAX wz
	byte	$24, $8c, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #0
	byte	$c7, $27, $23, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MIN wz
	byte	$34, $8c, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #1
	byte	$c7, $29, $2b, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MAX wz
	byte	$44, $8c, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #0
	byte	$c7, $29, $23, $a9
'-'                 cmp     hpar1, #HID_REPORT_SIZE wz
	byte	$74, $8c, $0f, $f2
'-'         if_z    mov     hidr_size, hpar2
	byte	$c7, $1f, $03, $a6
'-'                 cmp     hpar1, #HID_REPORT_COUNT wz
	byte	$94, $8c, $0f, $f2
'-'         if_z    mov     hidr_count, hpar2
	byte	$c7, $21, $03, $a6
'-'                 cmp     hpar1, #HID_INPUT       wz
	byte	$80, $8c, $0f, $f2
'-'         if_nz   jmp     #.next
	byte	$64, $ff, $9f, $5d
'-' 
'-'                 tjf     hidr_state,#.next
	byte	$d8, $1d, $a7, $fb
'-' 
'-'                 and     hpar2, #$03
	byte	$03, $8e, $07, $f5
'-'                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
	byte	$02, $8e, $0f, $f2
'-'         if_nz   jmp     #.skip
	byte	$18, $00, $90, $5d
'-' 
'-'                 cmp     hidr_state, #2  wz
	byte	$02, $1c, $0f, $f2
'-'         if_z    jmp     #.axes
	byte	$20, $00, $90, $ad
'-'                 cmp     hidr_state, #3  wz
	byte	$03, $1c, $0f, $f2
'-'         if_z    jmp     #.hats
	byte	$5c, $00, $90, $ad
'-'                 cmp     hidr_state, #4  wz
	byte	$04, $1c, $0f, $f2
'-'         if_z    jmp     #.buttons
	byte	$70, $00, $90, $ad
'-' .skip
'-'                 mov     htmp, hidr_size
	byte	$8f, $71, $03, $f6
'-'                 mul     htmp, hidr_count
	byte	$90, $71, $03, $fa
'-'                 add     hidr_offset, htmp
	byte	$b8, $23, $03, $f1
'-'                 jmp     #.next
	byte	$2c, $ff, $9f, $fd
'-' .axes
'-'                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 getnib  hr0, hidr_flags, #2
	byte	$87, $85, $53, $f8
'-'                 mov     hr1, hidr_count
	byte	$90, $87, $03, $f6
'-' .l1
'-'                 mov     hpar1, hidr_offset
	byte	$91, $8d, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$8f, $8f, $03, $f6
'-'                 call    #hpad_getbits
	byte	$04, $03, $b0, $fd
'-'                 call    #hpad_normalize
	byte	$64, $03, $b0, $fd
'-'                 cmp     hr0, #6         wcz
	byte	$06, $84, $1f, $f2
'-'         if_b    altgn   hr0, #hidr_usage
	byte	$86, $85, $5f, $c9
'-'         if_b    getnib  hr2
	byte	$00, $88, $43, $c8
'-'         if_b    altsw   hr2, #hidr_axis
	byte	$88, $89, $77, $c9
'-'         if_b    setword retval
	byte	$5f, $01, $20, $c9
'-'         if_b    add     hr0, #1
	byte	$01, $84, $07, $c1
'-'                 add     hidr_offset, hidr_size
	byte	$8f, $23, $03, $f1
'-'                 djnz    hr1, #.l1
	byte	$f4, $87, $6f, $fb
'-' 
'-'                 setnib  hidr_flags, hr0, #2
	byte	$c2, $0f, $13, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $1c, $07, $f6
'-'                 jmp     #.next
	byte	$e8, $fe, $9f, $fd
'-' .hats
'-'                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$91, $8d, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$8f, $8f, $03, $f6
'-'                 call    #hpad_getbits
	byte	$c8, $02, $b0, $fd
'-'                 setbyte hidr_hats, retval, #0
	byte	$5f, $19, $c3, $f8
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $1c, $07, $f6
'-'                 jmp     #.skip
	byte	$90, $ff, $9f, $fd
'-' .buttons
'-'                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$91, $8d, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$8f, $8f, $03, $f6
'-'                 mul     hpar2, hidr_count
	byte	$90, $8f, $03, $fa
'-'                 call    #hpad_getbits
	byte	$a8, $02, $b0, $fd
'-'                 getbyte htmp, hidr_flags, #0
	byte	$87, $71, $e3, $f8
'-'                 shl     retval, htmp
	byte	$b8, $bf, $62, $f0
'-'                 or      hidr_buttons, retval
	byte	$5f, $17, $43, $f5
'-'                 add     htmp, hidr_count
	byte	$90, $71, $03, $f1
'-'                 setbyte hidr_flags, htmp, #0
	byte	$b8, $0f, $c3, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $1c, $07, $f6
'-'                 jmp     #.skip
	byte	$64, $ff, $9f, $fd
'-' .report_id
'-'                 cmp     hidr_id, #0     wz
	byte	$00, $1a, $0f, $f2
'-'         if_nz   ret     wcz
	byte	$2d, $00, $7c, $5d
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     htmp, hpar2     wz
	byte	$c7, $71, $0b, $f2
'-'         if_z    mov     hidr_id, htmp
	byte	$b8, $1b, $03, $a6
'-'         if_nz   neg     hidr_state,#1
	byte	$01, $1c, $67, $56
'-'         if_nz   sub     ptrb,#1
	byte	$01, $f2, $87, $51
'-'                 jmp     #.next
	byte	$80, $fe, $9f, $fd
'-' .usage_page
'-'                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
	byte	$09, $8e, $0f, $f2
'-'         if_z    cmp     hidr_state, #1  wz
	byte	$01, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #4
	byte	$04, $1c, $07, $a6
'-'                 jmp     #.next
	byte	$70, $fe, $9f, $fd
'-' .usage
'-'                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
	byte	$04, $8e, $0f, $f2
'-'         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
	byte	$05, $8e, $0f, $52
'-'         if_z    cmp     hidr_type,#HID_READY        wz
	byte	$06, $2a, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $1c, $07, $a6
'-'         if_z    jmp     #.next
	byte	$5c, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_MOUSE     wz
	byte	$02, $8e, $0f, $f2
'-'         if_z    cmp     hidr_type,#M_READY          wz
	byte	$04, $2a, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $1c, $07, $a6
'-'         if_z    jmp     #.next
	byte	$4c, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_X     wz
	byte	$30, $8e, $0f, $f2
'-'         if_nz   cmp     hpar2, #HID_USAGE_Y     wz
	byte	$31, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_Z     wz
	byte	$32, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_RX    wz
	byte	$33, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_RY    wz
	byte	$34, $8e, $0f, $52
'-'         if_nz   cmp     hpar2, #HID_USAGE_RZ    wz
	byte	$35, $8e, $0f, $52
'-'         if_z    jmp     #.usage_axis
	byte	$10, $00, $90, $ad
'-'                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
	byte	$39, $8e, $0f, $f2
'-'         if_z    cmp     hidr_state, #1      wz
	byte	$01, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #3
	byte	$03, $1c, $07, $a6
'-'                 jmp     #.next
	byte	$20, $fe, $9f, $fd
'-' .usage_axis
'-'                 cmps    hidr_state, #1          wc
	byte	$01, $1c, $57, $f2
'-'         if_b    jmp     #.next
	byte	$18, $fe, $9f, $cd
'-'                 altsn   hidr_usage_idx, #hidr_usage
	byte	$86, $25, $57, $f9
'-'                 setnib  hpar2
	byte	$c7, $01, $00, $f8
'-' 
'-'                 sub     hpar2, #HID_USAGE_X - 16
	byte	$20, $8e, $87, $f1
'-'                 decod   hpar2
	byte	$c7, $8f, $c3, $f9
'-'                 or      hidr_flags, hpar2
	byte	$c7, $0f, $43, $f5
'-' 
'-'                 add     hidr_usage_idx, #1
	byte	$01, $24, $07, $f1
'-'                 mov     hidr_state, #2
	byte	$02, $1c, $07, $f6
'-'                 jmp     #.next
	byte	$f8, $fd, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle XInput controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_xinput
'-'                 rdbyte  htmp, ptrb      wz
	byte	$80, $71, $cf, $fa
'-'         if_nz   ret                         ' Ignore message type <> $00
	byte	$2d, $00, $64, $5d
'-'                 rdbyte  htmp, ptrb[1]
	byte	$81, $71, $c7, $fa
'-'                 cmp     htmp, #$14      wz
	byte	$14, $70, $0f, $f2
'-'         if_nz   ret                         ' Ignore report length <> $14 (20)
	byte	$2d, $00, $64, $5d
'-' 
'-'                 debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
	byte	$b0, $0e, $27, $f4
'-'                 setnib  hidr_flags, #6, #2
	byte	$06, $0e, $17, $f8
'-' 
'-'                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
	byte	$83, $11, $e7, $fa
'-'                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
	byte	$84, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
	byte	$85, $13, $e7, $fa
'-'                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
	byte	$86, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $26, $07, $f6
'-'                 rdbyte  retval, ptrb[4]     ' left analog trigger
	byte	$84, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
	byte	$06, $16, $27, $34
'-'                 call    #hpad_normalize
	byte	$f8, $01, $b0, $fd
'-'                 setword hidr_axis+1, retval, #1
	byte	$5f, $13, $2b, $f9
'-'                 rdbyte  retval, ptrb[5]     ' right analog trigger
	byte	$85, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
	byte	$07, $16, $27, $34
'-'                 call    #hpad_normalize
	byte	$e4, $01, $b0, $fd
'-'                 setword hidr_axis+2, retval, #0
	byte	$5f, $15, $23, $f9
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 rdword  retval, ptrb[1]
	byte	$81, $bf, $e6, $fa
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $16, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $16, $47, $f4
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $16, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $16, $47, $f4
'-'                 testb   retval, #8      wc  ' LB
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $16, $47, $f4
'-'                 testb   retval, #9      wc  ' RB
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $16, $47, $f4
'-'                 testb   retval, #5      wc  ' SELECT
	byte	$05, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $16, $47, $f4
'-'                 testb   retval, #4      wc  ' START
	byte	$04, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $16, $47, $f4
'-'                 testb   retval, #6      wc  ' L3
	byte	$06, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $16, $47, $f4
'-'                 testb   retval, #7      wc  ' R3
	byte	$07, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $16, $47, $f4
'-'                 testb   retval, #10     wc  ' XBOX
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $16, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
	byte	$5f, $71, $43, $f8
'-'                 mov     htmp1, ##$F576_F40F
	byte	$7a, $bb, $7a, $ff, $0f, $72, $07, $f6
'-'                 mov     htmp2, ##$FFFF_F312
	byte	$f9, $ff, $7f, $ff, $12, $75, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$b9, $71, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $70, $43, $f8
'-'                 setbyte hidr_hats, htmp, #0
	byte	$b8, $19, $c3, $f8
'-' 
'-'                 jmp     #hpad_translate
	byte	$ac, $01, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle PS3 controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_ps3
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $71, $c7, $fa
'-'                 cmp     htmp, #$01      wz
	byte	$01, $70, $0f, $f2
'-'         if_nz   ret                         ' Ignore report ID <> $01
	byte	$2d, $00, $64, $5d
'-' 
'-'                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $26, $07, $f6
'-'                 rdbyte  retval, ptrb[5]         ' X = left stick X
	byte	$85, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$40, $01, $b0, $fd
'-'                 setword hidr_axis, retval, #0
	byte	$5f, $11, $23, $f9
'-'                 bith    hidr_flags, #HID_AXIS_X
	byte	$10, $0e, $27, $f4
'-'                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
	byte	$86, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$30, $01, $b0, $fd
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 bith    hidr_flags, #HID_AXIS_Y
	byte	$11, $0e, $27, $f4
'-'                 rdbyte  retval, ptrb[7]         ' Z = right stick X
	byte	$87, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$20, $01, $b0, $fd
'-'                 setword hidr_axis+1, retval, #0
	byte	$5f, $13, $23, $f9
'-'                 bith    hidr_flags, #HID_AXIS_Z
	byte	$12, $0e, $27, $f4
'-'                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
	byte	$88, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$10, $01, $b0, $fd
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-'                 bith    hidr_flags, #HID_AXIS_RZ
	byte	$15, $0e, $27, $f4
'-'                 setnib  hidr_flags, #4, #2
	byte	$04, $0e, $17, $f8
'-' 
'-'                 mov     hpar1, #8
	byte	$08, $8c, $07, $f6
'-'                 mov     hpar2, #19
	byte	$13, $8e, $07, $f6
'-'                 call    #hpad_getbits
	byte	$94, $00, $b0, $fd
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $16, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $16, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $16, $47, $f4
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $16, $47, $f4
'-'                 testb   retval, #10     wc  ' L1
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $16, $47, $f4
'-'                 testb   retval, #11     wc  ' R1
	byte	$0b, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $16, $47, $f4
'-'                 testb   retval, #8      wc  ' L2
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #6
	byte	$06, $16, $47, $f4
'-'                 testb   retval, #9      wc  ' R2
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #7
	byte	$07, $16, $47, $f4
'-'                 testb   retval, #0      wc  ' SELECT
	byte	$00, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $16, $47, $f4
'-'                 testb   retval, #3      wc  ' START
	byte	$03, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $16, $47, $f4
'-'                 testb   retval, #1      wc  ' LEFT STICK
	byte	$01, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $16, $47, $f4
'-'                 testb   retval, #2      wc  ' RIGHT STICK
	byte	$02, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $16, $47, $f4
'-'                 testb   retval, #16     wc  ' HOME
	byte	$10, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $16, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
	byte	$5f, $71, $4b, $f8
'-'                 mov     htmp1, ##$F3F4_120F
	byte	$09, $fa, $79, $ff, $0f, $72, $07, $f6
'-'                 mov     htmp2, ##$FFF5_FF76
	byte	$ff, $fa, $7f, $ff, $76, $75, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$b9, $71, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $70, $43, $f8
'-'                 setbyte hidr_hats, htmp, #0
	byte	$b8, $19, $c3, $f8
'-' 
'-'                 jmp     #hpad_translate
	byte	$b8, $00, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Read bits from report data buffer
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRB - report buffer
'-' '   hpar1 - start bit
'-' '   hpar2 - number of bits
'-' ' On exit:
'-' '   retval - bits
'-' '------------------------------------------------------------------------------
'-' hpad_getbits
'-'                 mov     htmp, hpar1
	byte	$c6, $71, $03, $f6
'-'                 shr     htmp, #3        ' byte offset
	byte	$03, $70, $47, $f0
'-'                 add     htmp, ptrb
	byte	$f9, $71, $03, $f1
'-'                 rdlong  retval, htmp
	byte	$b8, $bf, $02, $fb
'-' 
'-'                 mov     htmp1, hpar1
	byte	$c6, $73, $03, $f6
'-'                 and     htmp1, #$07     ' shift
	byte	$07, $72, $07, $f5
'-'                 shr     retval, htmp1
	byte	$b9, $bf, $42, $f0
'-' 
'-'                 cmp     hpar2, #24      wcz
	byte	$18, $8e, $1f, $f2
'-'         if_a    jmp     #.l1
	byte	$10, $00, $90, $1d
'-' 
'-'                 decod   hpar2
	byte	$c7, $8f, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $8e, $87, $f1
'-'                 and     retval, hpar2
	byte	$c7, $bf, $02, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .l1
'-'                 and     retval, ##$00_FFFFFF
	byte	$ff, $7f, $00, $ff, $ff, $bf, $06, $f5
'-'                 add     htmp, #3
	byte	$03, $70, $07, $f1
'-'                 rdlong  htmp2, htmp
	byte	$b8, $75, $03, $fb
'-'                 sub     hpar2, #24
	byte	$18, $8e, $87, $f1
'-'                 decod   hpar2
	byte	$c7, $8f, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $8e, $87, $f1
'-'                 shr     htmp2, htmp1
	byte	$b9, $75, $43, $f0
'-'                 and     htmp2, hpar2
	byte	$c7, $75, $03, $f5
'-'                 shl     htmp2, #24
	byte	$18, $74, $67, $f0
'-'                 or      retval, htmp2
	byte	$ba, $bf, $42, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Normalize value to signed word (-32768 / 32767)
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - value to normalize
'-' '   hidr_lminmax - min (word 1) max (word 0) value range
'-' '   - or -
'-' '   hidr_pminmax - min (word 1) max (word 0) value range
'-' '   hidr_size - value bits length
'-' ' On exit:
'-' '   retval - normalized value
'-' '------------------------------------------------------------------------------
'-' hpad_normalize
'-'                 mov     htmp, hidr_lminmax  wz
	byte	$93, $71, $0b, $f6
'-'         if_z    mov     htmp, hidr_pminmax  wz
	byte	$94, $71, $0b, $a6
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 getword htmp1, htmp, #1     ' htmp1 = min
	byte	$b8, $73, $3b, $f9
'-'                 getword htmp, htmp, #0      ' htmp = max
	byte	$b8, $71, $33, $f9
'-'                 signx   htmp1, #15      wc
	byte	$0f, $72, $77, $f7
'-'         if_c    alts    hidr_size, #511
	byte	$ff, $1f, $97, $c9
'-'         if_c    signx   retval, #0-0
	byte	$00, $be, $66, $c7
'-'                 subs    htmp, htmp1         ' htmp = (max - min)
	byte	$b9, $71, $c3, $f1
'-'                 subs    retval, htmp1       ' retval = (retval - min)
	byte	$b9, $bf, $c2, $f1
'-'                 shl     retval, #16         ' retval = (retval - min) << 16
	byte	$10, $be, $66, $f0
'-'                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
	byte	$01, $be, $c6, $f1
'-'                 abs     htmp            wc
	byte	$b8, $71, $53, $f6
'-'                 testb   retval, #31     wz
	byte	$1f, $be, $0e, $f4
'-'                 abs     retval
	byte	$5f, $bf, $42, $f6
'-'                 qdiv    retval, htmp
	byte	$b8, $bf, $12, $fd
'-'                 getqx   retval
	byte	$18, $be, $62, $fd
'-'     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
	byte	$5f, $bf, $62, $66
'-'                 adds    retval, ##$8000 signx 15
	byte	$c0, $ff, $7f, $ff, $00, $be, $46, $f1
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform controller actions
'-' ' On entry:
'-' '    hidr_id        report id
'-' '    hidr_axis      axis value (signed word, 2 axes per long)
'-' '                      X = hidr_axis+0, #0
'-' '                      Y = hidr_axis+0, #1
'-' '                      Z = hidr_axis+1, #0
'-' '                     RX = hidr_axis+1, #1
'-' '                     RY = hidr_axis+2, #0
'-' '                     RZ = hidr_axis+2, #1
'-' '    hidr_buttons   buttons state (bits 0 to 31)
'-' '    hidr_hats      hats state (byte 0, 1, 2, 3)
'-' '
'-' '                     -------3 -------2 -------1 -------0 byte
'-' '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
'-' '    hidr_flags       xxxxxxxx_xxrrrzyx_hhhhaaaa_bbbbbbbb
'-' '                                zyx||| |||||||| ++++++++ n. buttons
'-' '                                |||||| ||||++++--------- n. axes
'-' '                                |||||| ++++------------- n. hats
'-' '                                ++++++------------------ valid axes
'-' '------------------------------------------------------------------------------
'-' hpad_translate
'-' 
'-' 
'-'         if HAVE_HIDPAD
'-'                 loc     ptrb,#hidpad_report
	byte	$84, $0c, $f0, $fe
'-'                 mov     htmp,hdev_port          wz
	byte	$2d, $71, $0b, $f6
'-'         if_z    mov     htmp,hidr_id
	byte	$8d, $71, $03, $a6
'-'                 cmpsub  htmp,#1
	byte	$01, $70, $e7, $f2
'-'         if_z    cmp     hidr_id, #MAX_DEVICES   wc
	byte	$07, $1a, $17, $a2
'-'         if_nz   cmp     hidr_id, #2             wc
	byte	$02, $1a, $17, $52
'-'         if_ae   ret     wcz
	byte	$2d, $00, $7c, $3d
'-'                 mul     htmp, #HIDPAD_REPORT_SIZE
	byte	$1c, $70, $07, $fa
'-'                 add     ptrb,htmp
	byte	$b8, $f3, $03, $f1
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
	byte	$00, $0c, $03, $f6
'-'                 setq    #7-1
	byte	$28, $0c, $64, $fd
'-'                 wrlong  hidr_usage,ptrb
	byte	$80, $0d, $67, $fc
'-'         end
'-' 
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' .emupad_no_hat
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' .emupad_slot_over
'-'         end
'-' 
'-'         if 0
'-'                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
'-' 
'-'                 debug("    btn: ", ubin_long_(hidr_buttons))
'-' 
'-'         end
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' '------------------------------------------------------------------------------
'-' ' Clear EmuPad state
'-' '------------------------------------------------------------------------------
'-' emupad_reset
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get EmuPad Player number for current device (into retval)
'-' ' Z flag is also set if current device is valid
'-' ' (Value may be larger than EMUPAD_MAX_PLAYER !)
'-' '------------------------------------------------------------------------------
'-' emupad_getnum
'-' .loop
'-' '------------------------------------------------------------------------------
'-' ' Handle disconnect of device (call after emupad_getnum returns with Z set)
'-' '------------------------------------------------------------------------------
'-' emupad_discon
'-' .loop         
'-'         
'-'         ' FALL THROUGH!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Update EmuPad reports (all of them...)
'-' '------------------------------------------------------------------------------
'-' emupad_write_reports
'-' .devloop
'-' 
'-' end
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_hub_status
'-'                 mov     ep_addr_pid, hhub_ep_addr
	byte	$77, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $8f, $03, $f6
'-'                 setword hpar3, hub_next_datax, #0
	byte	$32, $91, $23, $f9
'-'                 setword hpar3, #1, #1
	byte	$01, $90, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.data
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
	byte	$1a, $01, $80, $5d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .data
'-'                 cmp     hpar3, #0               wz
	byte	$00, $90, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 cmp     hub_next_datax, #PID_DATA0  wz
	byte	$c3, $64, $0e, $f2
'-'         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
	byte	$4b, $64, $06, $a6
'-'         if_nz   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $56
'-'                 rdlong  hub_status_chg, urx_buff_p
	byte	$27, $67, $02, $fb
'-'                 debug(ubin_long(hub_status_chg))
'-' 
'-'                 mov     hdev_port, #1
	byte	$01, $5a, $06, $f6
'-' .loop
'-'                 testb   hub_status_chg, hdev_port wz
	byte	$2d, $67, $0a, $f4
'-'         if_x1   call    #hub_port_handler
	byte	$0c, $00, $b0, $ad
'-'                 incmod  hdev_port, #7           wcz
	byte	$07, $5a, $1e, $f7
'-'         if_nc   jmp     #.loop
	byte	$f0, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' hub_port_handler
'-'                 mov     ep_addr_pid, hhub_ctrl_ep
	byte	$76, $bd, $02, $f6
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$8c, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-' 
'-'                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
	byte	$10, $68, $0e, $f4
'-'         if_x0   jmp     #.other
	byte	$50, $01, $90, $5d
'-'                 loc     ptra, #clr_port_feat
	byte	$68, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
	byte	$01, $21, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
	byte	$00, $68, $0e, $f4
'-'         if_x0   jmp     #.disconnect
	byte	$7c, $01, $90, $5d
'-'                 mov     hctwait, _100ms_
	byte	$b0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 loc     ptra, #set_port_feat            ' reset port
	byte	$40, $02, $d0, $fe
'-'                 wrword  #HUB_PORT_RESET, ptra[wValue]
	byte	$01, $09, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp3, #2
	byte	$02, $76, $07, $f6
'-' .wait_reset
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$34, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
	byte	$14, $68, $0e, $f4
'-'         if_x0   djnz    htmp3, #.wait_reset
	byte	$f7, $77, $6f, $5b
'-' 
'-'                 loc     ptra, #clr_port_feat
	byte	$10, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
	byte	$24, $70, $07, $f6
'-' .wait_recover
'-'                 mov     hctwait, _1ms_
	byte	$a7, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 djnz    htmp,#.wait_recover
	byte	$fd, $71, $6f, $fb
'-' 
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $68, $27, $c4
'-' 
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$8c, $01, $d0, $fe
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$48, $01, $90, $5d
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
	byte	$80, $01, $d0, $fe
'-'                 mov     htmp, hdev_port             ' Address is hub port number
	byte	$2d, $71, $03, $f6
'-'                 wrword  htmp, ptra[wValue]
	byte	$01, $71, $57, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$24, $01, $90, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$ef, $02, $a0, $fd
'-'                 mov     ep_addr_pid, hdev_port
	byte	$2d, $bd, $02, $f6
'-'                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
	byte	$08, $bc, $66, $f0
'-'                 call    #calc_crc5
	byte	$be, $00, $a0, $fd
'-'                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
	byte	$3c, $01, $d0, $fe
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$f4, $00, $90, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
'-'                 mov     hctwait, _500us_
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$18, $01, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$cc, $00, $90, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $85, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $87, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $71, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $84, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $86, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $71, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #.done
	byte	$a4, $00, $90, $cd
'-'                 call    #hparse_con_desc
	byte	$6c, $f0, $bf, $fd
'-'                 jmp     #.done
	byte	$9c, $00, $90, $fd
'-' 
'-' .other
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz
	byte	$14, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$28, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
	byte	$11, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
	byte	$01, $23, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$1c, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
	byte	$12, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
	byte	$01, $25, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$10, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
	byte	$13, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
	byte	$01, $27, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$04, $00, $90, $ad
'-'                 jmp     #.done
	byte	$68, $00, $90, $fd
'-' .reset_feature
'-'                 loc     ptra, #clr_port_feat
	byte	$e4, $00, $d0, $fe
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 jmp     #.done
	byte	$58, $00, $90, $fd
'-' .disconnect
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $70, $e3, $f8
'-'                 cmp     htmp,#KB_READY wz
	byte	$03, $70, $0f, $f2
'-'         if_nz   cmp     htmp,#KBM_READY wz
	byte	$05, $70, $0f, $52
'-'         if_z    mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $a6
'-'         if_z    mov     hkbd_ctrl_ep, #0
	byte	$00, $f0, $06, $a6
'-'         if_z    mov     kb_led_states, #0
	byte	$00, $76, $06, $a6
'-'         if_z    mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $a6
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $70, $0f, $f2
'-'         if_nz   cmp     htmp, #KBM_READY        wz
	byte	$05, $70, $0f, $52
'-'         if_z    mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $a6
'-'         end
'-'         if HAVE_HIDPAD
'-'                 loc ptrb,#hidpad_report
	byte	$14, $0a, $f0, $fe
'-'                 mov htmp,hdev_port
	byte	$2d, $71, $03, $f6
'-'                 cmpsub htmp,#1
	byte	$01, $70, $e7, $f2
'-'                 mul htmp,#HIDPAD_REPORT_SIZE
	byte	$1c, $70, $07, $fa
'-'                 add ptrb,htmp
	byte	$b8, $f3, $03, $f1
'-'                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
	byte	$28, $0c, $64, $fd
'-'                 wrlong #0,ptrb
	byte	$80, $01, $6c, $fc
'-'         end
'-' 
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte #0
	byte	$00, $00, $c4, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' 
'-' .done
'-'                 bitl    _usb_h_ls_nco_, #14     wcz
	byte	$0e, $68, $1f, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6d, $13, $cc
'-'                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $f6
'-' 
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$6c, $00, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, ptra
	byte	$00, $69, $06, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Partially populated SETUP packets
'-' '------------------------------------------------------------------------------
'-' get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_DEVICE << 8
	byte	$00, $01
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_CONFIG << 8
	byte	$00, $02
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_CONFIG
	byte	$09
'-'                 word    0       ' Configuration value
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
	byte	$00, $00
'-' set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_ADDR
	byte	$05
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
'-' ' wValue field dictates which protocol should be used.
'-' '
'-' ' When initialized, all devices default to report protocol. However the host
'-' ' should not make any assumptions about the device state and should set the
'-' ' desired protocol whenever initializing a device.
'-' '------------------------------------------------------------------------------
'-' set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_PROTO
	byte	$0b
'-'                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
	byte	$00, $00
'-'                                                 ' (HID 1.11 Section 7.2.6).
'-'                 word    0               ' Interface index number.
	byte	$00, $00
'-'                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_IDLE
	byte	$0a
'-'                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
	byte	$00, $00
'-'                                         ' reporting until a change is detected in the report data
'-' 
'-'                                         ' (HID 1.11 Section 7.2.4).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
	byte	$00, $00
'-' set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_REPORT
	byte	$09
'-'                 word    0       ' Byte1 = report type, byte0 = ReportID.
	byte	$00, $00
'-'                                         ' (HID 1.11 Section 7.2.2).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Size of the report, in bytes.
	byte	$00, $00
'-' get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
	byte	$81
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_REPORT << 8
	byte	$00, $22
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
	byte	$a0
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_HUB << 8
	byte	$00, $29
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_SET_FEATURE
	byte	$03
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_CLEAR_FEATURE
	byte	$01
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
	byte	$a3
'-'                 byte    REQ_GET_STATUS
	byte	$00
'-'                 word    0
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    4       ' Number of bytes to transfer if there is a data stage
	byte	$04, $00
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' ps3_enable_cmd  byte    $42, $0C, $00, $00
	byte	$42, $0c, $00, $00
'-' ps3_command_buff
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
	byte	$00, $00, $00, $00, $02
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' '------------------------------------------------------------------------------
'-' xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
	byte	$01, $03, $06
'-'                                         ' 0x01 All blinking
'-'                                         ' 0x02 1 flashes, then on
'-'                                         ' 0x03 2 flashes, then on
'-'                                         ' 0x04 3 flashes, then on
'-'                                         ' 0x05 4 flashes, then on
'-'                                         ' 0x06 1 on
'-'                                         ' 0x07 2 on
'-'                                         ' 0x08 3 on
'-'                                         ' 0x09 4 on
'-'                                         ' 0x0A Rotating (e.g. 1-2-4-3)
'-'                                         ' 0x0B Blinking*
'-'                                         ' 0x0C Slow blinking*
'-'                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
'-' xinp_rumble_cmd byte    $00, $08, $00
	byte	$00, $08, $00
'-'                 byte    $00             ' Left rumble
	byte	$00
'-'                 byte    $00             ' Right rumble
	byte	$00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' end
	byte	$00
'-' alignl
'-' 
'-' if HAVE_MOUSE
'-' mouse_limits long 0[2]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' mouse_outptr long 0
	byte	$00, $00, $00, $00
'-' end
'-' 
'-' if KEYQUEUE_SIZE > 0
'-' keyq_head byte 0
	byte	$00
'-' keyq_tail byte 0
	byte	$00
'-' keyq_data long 0[KEYQUEUE_SIZE]
	byte	$00[514]
'-' alignl
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_rule_buffer
'-' if EMUPAD_BUILTIN_RULES
'-' file "padmap_builtin.dat"
'-' end
'-' byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
'-' '' Default rule directly follows!
'-' byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The USB data cache area gets zero-filled at every device disconnect
'-' '------------------------------------------------------------------------------
'-' usb_cache_start
'-' 
'-' ' HID descriptor and report buffers
'-' if !!OVERLAP_MEMORY
'-' hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
	byte	$00[1792]
'-' end
'-' hkbd_report     byte    0[8]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' hkbd_led_rep    byte    0
	byte	$00, $00, $00, $00
'-' alignl
'-' 
'-' if HAVE_HIDPAD
'-' hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
	byte	$00[196]
'-' end
'-' 
'-' ' HUB descriptor
'-' hub_descr       byte    0   ' bDescLength
	byte	$00
'-'                 byte    0   ' bDescriptorType
	byte	$00
'-'                 byte    0   ' bNbrPorts
	byte	$00
'-'                 word    0   ' wHubCharacteristics
	byte	$00, $00
'-'                 byte    0   ' bPwrOn2PwrGood
	byte	$00
'-'                 byte    0   ' bHubContrCurrent
	byte	$00
'-'                 byte    0   ' DeviceRemoveable
	byte	$00
'-'                 byte    0   ' PortPwrCtrlMask
	byte	$00
'-' 
'-' usb_cache_end
'-' 
'-' if HAVE_MOUSE
'-' mouse_xacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_yacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_zacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_bstate    byte 0
	byte	$00
'-' mouse_lpending  byte 0
	byte	$00
'-' mouse_rpending  byte 0
	byte	$00
'-' mouse_mpending  byte 0
	byte	$00
'-' mouse_lock      byte 0
	byte	$00
'-'                 byte 0[3] ' padding
	byte	$00, $00, $00
'-' end
'-' 
'-' urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
	byte	$00[128]
'-' dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
	byte	$00[18]
'-' con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
	byte	$00[256]
'-' 
'-' driver_cog      byte    0                       ' Current driver cog + 1
	byte	$00
	alignl
_audio096_spin2_dat_
'-' 
'-' audio       org     0
'-' 
'-'             rdlong  mailbox2, ptra++     ' get start address of all mailboxes
	byte	$61, $cd, $05, $fb
'-'             rdlong  scbase, ptra++       ' get start address of scope buffer
	byte	$61, $1b, $06, $fb
'-'             rdlong  hubptr, ptra++       ' get start address of PSRAM cache
	byte	$61, $27, $06, $fb
'-'  
'-'             cogid   pa                   ' compute cogid
	byte	$01, $ec, $63, $fd
'-'             mul     pa, #12              ' and mailbox spacing
	byte	$0c, $ec, $07, $fa
'-'             add     mailbox2, pa         ' add offset to find this COG's mailbox
	byte	$f6, $cd, $01, $f1
'-'             mov     mailbox,mailbox2     ' we need 2 copies of this to ensble switching between hub and psram
	byte	$e6, $ca, $01, $f6
'-' 
'-'             mov     ptrb,#0              ' A tail pointer for the buffer
	byte	$00, $f2, $07, $f6
'-'             wrpin   dac2,#left            ' Noise dither DACs at clk/95
	byte	$0e, $24, $06, $fc
'-'             wxpin   #256,#left       	 ' Set initial DACs sample rate. It is now controlled via a register by the main program
	byte	$0e, $00, $1e, $fc
'-'             wrpin   dac2,#right
	byte	$0f, $24, $06, $fc
'-'             wxpin   #256,#right    
	byte	$0f, $00, $1e, $fc
'-'             dirh    #left addpins 1
	byte	$41, $9c, $64, $fd
'-'             setse1  #%001<<6 + left      ' Set the event - DAC empty
	byte	$20, $9c, $64, $fd
'-'             mov     ijmp1,#isr1          ' Init the interrupt
	byte	$cd, $e8, $07, $f6
'-'             setint1 #4                   ' Interrupt from DAC empty event
	byte	$25, $08, $64, $fd
'-'             
'-' '---------------------------------------------------------------------------------        
'-' '----------------- The main loop -------------------------------------------------
'-' '---------------------------------------------------------------------------------
'-' 
'-' loop        cmp     time0,a41000000 wc  ' time counter overflow protection
	byte	$d6, $ae, $11, $f2
'-'       if_c  jmp     #loop1
	byte	$10, $00, $90, $cd
'-'   
'-'             mov     cn,#9               ' Substract $40000000 from all the channel times and the main timer
	byte	$09, $00, $06, $f6
'-' p402        altd    cn,#a41000000       ' this has to be done at once for all channels
	byte	$d6, $00, $8e, $f9
'-'             sub     0-0,a40000000
	byte	$d5, $00, $80, $f1
'-'             djnz    cn,#p402
	byte	$fd, $01, $6e, $fb
'-'     
'-' loop1       mov     cn,#0               ' Find the channel to compute
	byte	$00, $00, $06, $f6
'-'             mov     ct,time1            ' with the lowest next sample time
	byte	$d8, $02, $02, $f6
'-'             fle     ct,time2 wcz        ' How to size-optimize this???
	byte	$d9, $02, $3a, $f3
'-'     if_c    mov     cn,#1
	byte	$01, $00, $06, $c6
'-'             fle     ct,time3 wcz
	byte	$da, $02, $3a, $f3
'-'     if_c    mov     cn,#2     
	byte	$02, $00, $06, $c6
'-'             fle     ct,time4 wcz
	byte	$db, $02, $3a, $f3
'-'     if_c    mov     cn,#3
	byte	$03, $00, $06, $c6
'-'             fle     ct,time5 wcz
	byte	$dc, $02, $3a, $f3
'-'     if_c    mov     cn,#4
	byte	$04, $00, $06, $c6
'-'             fle     ct,time6 wcz
	byte	$dd, $02, $3a, $f3
'-'     if_c    mov     cn,#5
	byte	$05, $00, $06, $c6
'-'             fle     ct,time7 wcz
	byte	$de, $02, $3a, $f3
'-'     if_c    mov     cn,#6
	byte	$06, $00, $06, $c6
'-'             fle     ct,time8 wcz
	byte	$df, $02, $3a, $f3
'-'     if_c    mov     cn,#7
	byte	$07, $00, $06, $c6
'-' 
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- Compute channel samples --------------------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' 
'-' p401        mov     channeladd,cn             	' compute the pointer to channel parameters block
	byte	$00, $c1, $01, $f6
'-'             shl     channeladd,#6
	byte	$06, $c0, $65, $f0
'-'             add     ptra,channeladd
	byte	$e0, $f0, $03, $f1
'-' 
'-'             setq    #11                        	' read parameters
	byte	$28, $16, $64, $fd
'-'             rdlong  pointer0,ptra
	byte	$00, $d7, $05, $fb
'-'     	    
'-' p408        testb   command0,#31 wz	      	' bit #31 command - set the DAC sample rate
	byte	$1f, $e4, $0d, $f4
'-'     if_nz   jmp     #p404                     	' if not set, proceed
	byte	$18, $00, $90, $5d
'-'             getword qq,command0,#0            	' get the new rate
	byte	$f2, $c4, $31, $f9
'-'             wxpin   qq,#left addpins 1        	' and program the pins
	byte	$4e, $c4, $15, $fc
'-'             getbyte qq,qq,#0 		      	' check if the rate is n*256
	byte	$e2, $c4, $e1, $f8
'-'             cmp     qq,#0 wz                         
	byte	$00, $c4, $0d, $f2
'-'     if_z    wrpin   dac2,#left addpins 1      	' if yes, set PWM DAC mode
	byte	$4e, $24, $06, $ac
'-'     if_nz   wrpin   dac,#left addpins 1       	' else set noise DAC mode
	byte	$4e, $22, $06, $5c
'-'             
'-' p404        bitl    command0,#30 wcz          	' bit #30: select PSRAM/HUB
	byte	$1e, $e4, $1d, $f4
'-'     if_nz   mov     mailbox,mailbox2            ' if not set, use PSRAM
	byte	$e6, $ca, $01, $56
'-'     if_z    mov     mailbox,#0                  ' if set, use HUB 
	byte	$00, $ca, $05, $a6
'-' 
'-' p405        getword oldls,sample0,#0          ' extract old sample value
	byte	$ec, $06, $32, $f9
'-'             getword oldrs,sample0,#1
	byte	$ec, $08, $3a, $f9
'-'      	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
	byte	$f0, $fc, $39, $f9
'-'     	    getword avol0,volpan0,#0
	byte	$f0, $fa, $31, $f9
'-'             getword askip0,freqskip0,#1    	    
	byte	$f1, $f8, $39, $f9
'-'             getword afreq0,freqskip0,#0
	byte	$f1, $f6, $31, $f9
'-' 
'-'             alts    cn, #time1                ' compute the time difference between this and previous sample
	byte	$d8, $00, $96, $f9
'-'             mov     dt0,0-0    
	byte	$00, $04, $02, $f6
'-'             sub     dt0,time0
	byte	$d7, $04, $82, $f1
'-'             
'-'             altd    cn, #time1                ' add channel period to channel time
	byte	$d8, $00, $8e, $f9
'-'             add     0-0,afreq0  	
	byte	$fb, $00, $00, $f1
'-'             
'-' '---- envelopes
'-'             
'-'             cmp     envptr0,#0 wcz    		' read the pointer
	byte	$00, $e8, $1d, $f2
'-'     if_z    mov     envs1,##$4000		' if 0, no envelope, load $4000=1 for scas
	byte	$20, $00, $00, $af, $00, $48, $06, $a6
'-'     if_z    jmp     #p410			' and run away	
	byte	$5c, $00, $90, $ad
'-' 
'-'             mov     envs1,afreq0
	byte	$fb, $48, $02, $f6
'-'             mul     envs1,envspd0
	byte	$f5, $48, $02, $fa
'-'             add     envph0,envs1 
	byte	$24, $e7, $01, $f1
'-' 
'-'       	    mov     envhi, envph0		' move phase acc to high part of env pointer
	byte	$f3, $44, $02, $f6
'-' 	    shr     envhi,#6			' leave 10 bits in hi
	byte	$06, $44, $46, $f0
'-' 	    getword envlo,envhi,#0              ' and 16 bit in lo
	byte	$22, $47, $32, $f9
'-' 	    shr     envhi,#16			' move 10 bits of hi to the lower word
	byte	$10, $44, $46, $f0
'-' 	    cmp     envhi,envlen0 wcz		' compare this to envelope length
	byte	$f6, $44, $1a, $f2
'-'     if_ge   mov     envhi,envlen0		' if greater than, set it at envlen
	byte	$f6, $44, $02, $36
'-'     if_ge   mov     envlo,#0
	byte	$00, $46, $06, $36
'-'     if_ge   mov     envph0,envlen0
	byte	$f6, $e6, $01, $36
'-'     if_ge   shl     envph0,#22
	byte	$16, $e6, $65, $30
'-' 
'-'             mov     envs1,envhi			' get the phase acc
	byte	$22, $49, $02, $f6
'-'             shl     envs1,#1			' env defs are words, so phase acc*=2
	byte	$01, $48, $66, $f0
'-'             add     envs1,envptr0		' and add the pointer
	byte	$f4, $48, $02, $f1
'-'             rdlong  envs1,envs1			' then read 2 entries
	byte	$24, $49, $02, $fb
'-'             getword envs2,envs1,#1		' next value
	byte	$24, $4b, $3a, $f9
'-'             getword envs1,envs1,#0		' current value
	byte	$24, $49, $32, $f9
'-'             mul     envs2,envlo			' linear interpolate : new val x envlo
	byte	$23, $4b, $02, $fa
'-'             not     envlo			' sum of envlo and not envlo is always $FFFF
	byte	$23, $47, $22, $f6
'-'             mul     envs1,envlo
	byte	$23, $49, $02, $fa
'-'             add     envs1,envs2
	byte	$25, $49, $02, $f1
'-'             shr     envs1,#18			' normalize it to $4000
	byte	$12, $48, $46, $f0
'-'             
'-' p410        testb   sstart0, #27 wz
	byte	$1b, $da, $0d, $f4
'-'     if_z    getrnd  spl
	byte	$1b, $c6, $61, $ad
'-'     if_z    jmp     #p406
	byte	$58, $00, $90, $ad
'-'  
'-'             add     pointer0,askip0           	' compute the pointer to the next sample       
	byte	$fc, $d6, $01, $f1
'-'             setbyte pointer00,pointer0,#0
	byte	$eb, $42, $c2, $f8
'-'             shr     pointer0,#8
	byte	$08, $d6, $45, $f0
'-'          
'-'             testb   sstart0,#31 wz            
	byte	$1f, $da, $0d, $f4
'-'     if_z    shl     pointer0,#1        
	byte	$01, $d6, $65, $a0
'-'             testb   sstart0,#28 wz            
	byte	$1c, $da, $0d, $f4
'-'     if_z    shl     pointer0,#1        
	byte	$01, $d6, $65, $a0
'-'         
'-'             cmp     pointer0,lend0 wcz
	byte	$ef, $d6, $19, $f2
'-'     if_ge   sub     pointer0,lend0	      	' and loop if needed     
	byte	$ef, $d6, $81, $31
'-'     if_ge   add     pointer0,lstart0       
	byte	$ee, $d6, $01, $31
'-'             
'-'             mov     qq,pointer0               	' compute place in the memory from where the sample will be loaded
	byte	$eb, $c4, $01, $f6
'-'             add     qq,sstart0            
	byte	$ed, $c4, $01, $f1
'-' 
'-'             cmps    mailbox,#$1FF wcz          	' the mailbox has to point somewhere not at the start of HUB RAM
	byte	$ff, $cb, $5d, $f2
'-'     if_le   rdword  spl,qq                     	' if not, use HUB RAM for samples
	byte	$e2, $c6, $e1, $ea
'-'     if_gt   call    #cache_read
	byte	$1c, $01, $b0, $1d
'-'          
'-'             testb   sstart0,#31 wz 
	byte	$1f, $da, $0d, $f4
'-'     if_nz   shl     spl,#8
	byte	$08, $c6, $65, $50
'-'     if_nz   shl     pointer0,#8
	byte	$08, $d6, $65, $50
'-'     if_z    shl     pointer0,#7
	byte	$07, $d6, $65, $a0
'-'             testb   sstart0,#28 wz            
	byte	$1c, $da, $0d, $f4
'-'     if_z    shr     pointer0,#1    
	byte	$01, $d6, $45, $a0
'-' 	    setbyte pointer0,pointer00,#0       
	byte	$21, $d7, $c1, $f8
'-' 
'-' 
'-' p406        scas    spl,envs1			' apply envelope
	byte	$24, $c7, $31, $fa
'-'             mov     spl,0-0
	byte	$00, $c6, $01, $f6
'-'             scas    spl,avol0                 	' apply volume
	byte	$fd, $c6, $31, $fa
'-'             mov     spl,0-0
	byte	$00, $c6, $01, $f6
'-' 
'-'             scas    spl,apan0                 	' apply pan
	byte	$fe, $c6, $31, $fa
'-'             mov     ls0,0-0
	byte	$00, $0a, $02, $f6
'-'             mov     qq,##16384
	byte	$20, $00, $00, $ff, $00, $c4, $05, $f6
'-'             sub     qq,apan0
	byte	$fe, $c4, $81, $f1
'-'             scas    spl,qq
	byte	$e2, $c6, $31, $fa
'-'             mov     rs0, 0-0
	byte	$00, $0c, $02, $f6
'-' 
'-'             sub     rs,oldrs 		      	' replace the old sample with the new one in the mix
	byte	$04, $11, $82, $f1
'-'             add     rs,rs0
	byte	$06, $11, $02, $f1
'-'             sub     ls,oldls
	byte	$03, $0f, $82, $f1
'-'             add     ls,ls0
	byte	$05, $0f, $02, $f1
'-'    
'-'             setword sample0,rs0,#1           	' pack samples into long
	byte	$06, $d9, $29, $f9
'-'             setword sample0,ls0,#0
	byte	$05, $d9, $21, $f9
'-'             
'-'             bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
	byte	$1e, $da, $1d, $f4
'-'     if_z    mov     pointer0, #0  		
	byte	$00, $d6, $05, $a6
'-'     if_z    mov     envph0, #0  		' reset also envelope pha and sample value
	byte	$00, $e6, $05, $a6
'-'   '  if_z    mov     sample0,#0
'-'     if_z    wrlong  sstart0, ptra[2]          	' reset bit #30 in hub
	byte	$02, $db, $65, $ac
'-'             bitl    sstart0, #29 wcz	      	' if bit #29 is set, synchronize stereo at channels 1 and 2
	byte	$1d, $da, $1d, $f4
'-'     if_z    add     time1,##2048
	byte	$04, $00, $00, $af, $00, $b0, $05, $a1
'-'     if_z    mov     time2,time1
	byte	$d8, $b2, $01, $a6
'-'     if_z    wrlong  sstart0,ptra[2]
	byte	$02, $db, $65, $ac
'-' 
'-' p403        setq    #1                         	' write new pointer and sample value to the hub
	byte	$28, $02, $64, $fd
'-'             wrlong  pointer0,ptra
	byte	$00, $d7, $65, $fc
'-'             wrlong  envph0,ptra[8]
	byte	$08, $e7, $65, $fc
'-'             sub     ptra, channeladd         	' reset the pointer to channel parameters
	byte	$e0, $f0, $83, $f1
'-'                       
'-'             cmp     oldt0,time0 wz           ' If more than 1 sample is computed at the same time, write only the last result
	byte	$d7, $fe, $09, $f2
'-'     if_z    decmod  front, #511          
	byte	$ff, $c3, $25, $a7
'-'          
'-'             getword oldls,ls,#0              ' reuse oldls variable to convert the sample to unsigned
	byte	$07, $07, $32, $f9
'-'  	    getword oldrs,rs,#0              ' getword instead of mov makes the upper bits=0
	byte	$08, $09, $32, $f9
'-'             bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
	byte	$0f, $06, $e6, $f4
'-'             bitnot  oldrs,#15		     ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
	byte	$0f, $08, $e6, $f4
'-' 	    
'-' 		    
'-'             setword oldrs,oldls,#1           ' Pack L and R to one long    		
	byte	$03, $09, $2a, $f9
'-'             mov     oldsample, newsample     ' The new computed sample will be outputted in the next loop, now we have to fill the buffer with the old one
	byte	$0a, $13, $02, $f6
'-'             mov     newsample, oldrs       
	byte	$04, $15, $02, $f6
'-' 
'-'             mov     oldt0,time0              ' update global time
	byte	$d7, $fe, $01, $f6
'-'             add     time0,dt0    
	byte	$02, $af, $01, $f1
'-'                                      
'-'             cmp     dt0,#0 wz                ' now push dt0 samples to the buffer
	byte	$00, $04, $0e, $f2
'-'     if_z    jmp     #loop1
	byte	$d8, $fd, $9f, $ad
'-'             mov     qq,dt0
	byte	$02, $c5, $01, $f6
'-' 
'-'     
'-'             
'-' p301        rol     dropper,#1 wc
	byte	$01, $4e, $36, $f0
'-'     if_nc   jmp     #p399
	byte	$40, $00, $90, $3d
'-' p398        alts    ptrb,#511                ' checking if the buffer is full - Wuerfel_21's magic stuff
	byte	$ff, $f3, $97, $f9
'-'             cmpr    front, #0-0 wcz
	byte	$00, $c2, $9d, $f2
'-'     if_e    jmp     #p398   
	byte	$f4, $ff, $9f, $ad
'-' 		
'-' 	    cmp     scbase,#0 wz
	byte	$00, $1a, $0e, $f2
'-'     if_z    jmp     #p302	   
	byte	$20, $00, $90, $ad
'-'   
'-'             incmod  scope,#63 wc            ' save every 127th sample to the scope buffer
	byte	$3f, $20, $16, $f7
'-'     if_c    mov     scptr2,scptr
	byte	$0e, $1f, $02, $c6
'-'     if_c    shl     scptr2,#2
	byte	$02, $1e, $66, $c0
'-'     if_c    add     scptr2,scbase     
	byte	$0d, $1f, $02, $c1
'-'             wrlong  scptr2,#$60
	byte	$60, $1e, $66, $fc
'-'     if_c    wrlong  oldsample,scptr2
	byte	$0f, $13, $62, $cc
'-'     if_c    incmod  scptr,##639
	byte	$01, $00, $00, $cf, $7f, $1c, $06, $c7
'-' 			    
'-' p302        wrlut   oldsample, front        ' if there is a free slot, put the sample into the buffer
	byte	$e1, $12, $32, $fc
'-'             incmod  front, ##511
	byte	$00, $00, $00, $ff, $ff, $c3, $05, $f7
'-' p399        djnz    qq,#p301
	byte	$ed, $c5, $6d, $fb
'-'             
'-'             jmp     #loop            'loop
	byte	$6c, $fd, $9f, $fd
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- This is the end of the main loop -----------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- PSRAM cache ----------- --------------------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' ' There are 8 cache pointers for 8 channels
'-' ' if 24 higher bits of address=cache, then get a word from the cache
'-' ' else load the cache from PSRAM, update the pointer, then read a sample
'-' 
'-' 
'-' cache_read  getbyte addrlo,qq,#0 		' when this is called, qq is the addres of the sample			
	byte	$e2, $3e, $e2, $f8
'-'             
'-' 	    mov     addrhi,qq		
	byte	$e2, $40, $02, $f6
'-' 	    shr     addrhi,#8		        ' get 24 upper bits
	byte	$08, $40, $46, $f0
'-' 	    alts    cn,#cache1            
	byte	$14, $01, $96, $f9
'-' 	    cmp	    addrhi,0-0 wz               ' and compare with the cache pointer for the channel
	byte	$00, $40, $0a, $f2
'-'     if_z    jmp     #p701	    		' if equal, cache hit, read the sample from it
	byte	$34, $00, $90, $ad
'-' 	
'-' p702	    altd    cn,#cache1			' cache miss. 
	byte	$14, $01, $8e, $f9
'-' 	    mov     0-0,addrhi                  ' update the pointer
	byte	$20, $01, $00, $f6
'-' 	    mov     cmd,addrhi			' prepare the mailbox
	byte	$20, $39, $02, $f6
'-' 	    shl     cmd,#8
	byte	$08, $38, $66, $f0
'-'             setnib  cmd, #%1011, #7             ' read burst from the external memory
	byte	$0b, $38, $3e, $f8
'-'             mov     hubaddr,cn                  ' to the channel cache
	byte	$00, $3b, $02, $f6
'-'             shl     hubaddr,#8                  '
	byte	$08, $3a, $66, $f0
'-'             add     hubaddr,hubptr 
	byte	$13, $3b, $02, $f1
'-'             mov     count,#256                  ' 256 bytes
	byte	$00, $3d, $06, $f6
'-'             setq    #2                          ' write 3 longs
	byte	$28, $04, $64, $fd
'-'             wrlong  cmd, mailbox                ' run it
	byte	$e5, $38, $62, $fc
'-' poll1       rdlong  cmd, mailbox                ' poll mailbox for result
	byte	$e5, $38, $02, $fb
'-'             tjs     cmd, #poll1                 ' retry until valid 
	byte	$fe, $39, $b6, $fb
'-'             
'-' 	
'-' p701	    mov     qq,cn			' cache hit
	byte	$00, $c5, $01, $f6
'-' 	    shl     qq,#8			' compute the cache start
	byte	$08, $c4, $65, $f0
'-' 	    add     qq,hubptr
	byte	$13, $c5, $01, $f1
'-' 	    add	    qq,addrlo			' add 8 lower bits to the cache addredd
	byte	$1f, $c5, $01, $f1
'-'     _ret_   rdword  spl,qq                      ' read a word
	byte	$e2, $c6, $e1, $0a
'-'           
'-' 
'-' '--------------------------------------------------------------------------
'-' '------ Interrupt service -------------------------------------------------
'-' '------ Output the sample, get the next one if exists ---------------------
'-' '--------------------------------------------------------------------------
'-' 
'-' isr1        wypin   lsample,#left        '2     The sample has to be outputted every 95 cycles     
	byte	$0e, $ce, $25, $fc
'-'             wypin   rsample,#right       '4
	byte	$0f, $d0, $25, $fc
'-'             cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
	byte	$e1, $f2, $1b, $f2
'-'     if_ne   rdlut   lsnext,ptrb          '11    else read the sample and its time from LUT
	byte	$80, $d3, $a5, $5a
'-'     if_ne   incmod  ptrb,#511
	byte	$ff, $f3, $07, $57
'-'     if_ne   getword rsample,lsnext,#1    '13
	byte	$e9, $d0, $39, $59
'-'     if_ne   getword lsample,lsnext,#0    '15
	byte	$e9, $ce, $31, $59
'-'     
'-'             reti1                        '17/19 
	byte	$f5, $ff, $3b, $fb
'-'           
'-' '---------------------------------------------------------------------------
'-' '-------- End of interrupt -------------------------------------------------
'-' '---------------------------------------------------------------------------    
'-' 
'-' 
'-' '---------------------------------------------------------------------------
'-' '------- Variables ---------------------------------------------------------
'-' '---------------------------------------------------------------------------
'-' 
'-' ' constants
'-' 
'-' a40000000   long $40000000
	byte	$00, $00, $00, $40
'-' a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before
	byte	$00, $00, $00, $41
'-' 
'-' ' Time variables
'-' 
'-' time0       long 0    ' Global sample computing time
	byte	$00, $00, $00, $00
'-' time1       long 1    ' Local channels time
	byte	$01, $00, $00, $00
'-' time2       long 2
	byte	$02, $00, $00, $00
'-' time3       long 3
	byte	$03, $00, $00, $00
'-' time4       long 4
	byte	$04, $00, $00, $00
'-' time5       long 5
	byte	$05, $00, $00, $00
'-' time6       long 6
	byte	$06, $00, $00, $00
'-' time7       long 7
	byte	$07, $00, $00, $00
'-' time8       long 8
	byte	$08, $00, $00, $00
'-' 
'-' channeladd long 0
	byte	$00, $00, $00, $00
'-' 
'-' front       long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' temporary variables 
'-' qq          long 0
	byte	$00, $00, $00, $00
'-' spl         long 0
	byte	$00, $00, $00, $00
'-' zero        long 0
	byte	$00, $00, $00, $00
'-' mailbox     long 0
	byte	$00, $00, $00, $00
'-' mailbox2 long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' Interrupt ISR variables
'-' 
'-' lsample     long 0
	byte	$00, $00, $00, $00
'-' rsample     long 0
	byte	$00, $00, $00, $00
'-' lsnext      long 0
	byte	$00, $00, $00, $00
'-' rsnext      long 0 
	byte	$00, $00, $00, $00
'-' 
'-' ' channel parameter block
'-' 
'-' pointer0    long 0     
	byte	$00, $00, $00, $00
'-' sample0     long 0
	byte	$00, $00, $00, $00
'-' sstart0     long 0     ' start pointer and type at bit 31
	byte	$00, $00, $00, $00
'-' lstart0     long 0
	byte	$00, $00, $00, $00
'-' lend0       long 0
	byte	$00, $00, $00, $00
'-' volpan0     long 0
	byte	$00, $00, $00, $00
'-' freqskip0   long 0
	byte	$00, $00, $00, $00
'-' command0    long 0
	byte	$00, $00, $00, $00
'-' envph0	    long 0
	byte	$00, $00, $00, $00
'-' envptr0	    long 0
	byte	$00, $00, $00, $00
'-' envspd0	    long 0
	byte	$00, $00, $00, $00
'-' envlen0	    long 0
	byte	$00, $00, $00, $00
'-' res5	    long 0
	byte	$00, $00, $00, $00
'-' res6	    long 0
	byte	$00, $00, $00, $00
'-' res7	    long 0
	byte	$00, $00, $00, $00
'-' res8	    long 0
	byte	$00, $00, $00, $00
'-' 
'-' afreq0      long 0
	byte	$00, $00, $00, $00
'-' askip0      long 0
	byte	$00, $00, $00, $00
'-' avol0       long 0
	byte	$00, $00, $00, $00
'-' apan0       long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldt0       long $FFFFFFFF    'Temporary time variables
	byte	$ff, $ff, $ff, $ff
'-' cn          long 0
	byte	$00, $00, $00, $00
'-' ct          long 0
	byte	$00, $00, $00, $00
'-' dt0         long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' Samples
'-' oldls       long 0
	byte	$00, $00, $00, $00
'-' oldrs       long 0
	byte	$00, $00, $00, $00
'-' 
'-' ls0         long 0
	byte	$00, $00, $00, $00
'-' rs0         long 0
	byte	$00, $00, $00, $00
'-' 
'-' ls          long 0    
	byte	$00, $00, $00, $00
'-' rs          long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldsample   long 0
	byte	$00, $00, $00, $00
'-' newsample   long 0
	byte	$00, $00, $00, $00
'-' 
'-' nrsample    long 0
	byte	$00, $00, $00, $00
'-' nlsample    long 0
	byte	$00, $00, $00, $00
'-' 
'-' scbase long 0
	byte	$00, $00, $00, $00
'-' scptr long 0
	byte	$00, $00, $00, $00
'-' scptr2 long 0
	byte	$00, $00, $00, $00
'-' scope long 0
	byte	$00, $00, $00, $00
'-' 
'-' dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
	byte	$44, $00, $17, $00
'-' dac2        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   
	byte	$46, $00, $17, $00
'-' 
'-' hubptr      long $71800
	byte	$00, $18, $07, $00
'-' cache1      long 0
	byte	$00, $00, $00, $00
'-' cache2      long 0
	byte	$00, $00, $00, $00
'-' cache3      long 0
	byte	$00, $00, $00, $00
'-' cache4      long 0
	byte	$00, $00, $00, $00
'-' cache5      long 0
	byte	$00, $00, $00, $00
'-' cache6      long 0
	byte	$00, $00, $00, $00
'-' cache7      long 0
	byte	$00, $00, $00, $00
'-' cache8      long 0
	byte	$00, $00, $00, $00
'-' 
'-' 
'-' cmd         long 0
	byte	$00, $00, $00, $00
'-' hubaddr     long 0
	byte	$00, $00, $00, $00
'-' count       long 256
	byte	$00, $01, $00, $00
'-' addrlo long 0
	byte	$00, $00, $00, $00
'-' addrhi long 0
	byte	$00, $00, $00, $00
'-' pointer00 long 0
	byte	$00, $00, $00, $00
'-' envhi long 0
	byte	$00, $00, $00, $00
'-' envlo long 0
	byte	$00, $00, $00, $00
'-' envs1 long 0
	byte	$00, $00, $00, $00
'-' envs2 long 0
	byte	$00, $00, $00, $00
'-' noise0 long 0
	byte	$00, $00, $00, $00
'-' dropper long %10010010_10010010_10010010_10010010
	byte	$92, $92, $92, $92
'-' null  			long 	0,0           ' for channel reset
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	alignl
__system__dat_
	byte	$00[8]
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[660]
	long	(157 {__system____root_opendir})<<20
	long	(158 {__system____root_closedir})<<20
	long	(159 {__system____root_readdir})<<20
	long	(160 {__system____root_stat})<<20
	byte	$00[28]
	long	@@@__system__dat_ + 832
	long	@@@__system__dat_ + 835
	long	@@@__system__dat_ + 868
	long	@@@__system__dat_ + 893
	long	@@@__system__dat_ + 920
	long	@@@__system__dat_ + 946
	long	@@@__system__dat_ + 962
	long	@@@__system__dat_ + 980
	long	@@@__system__dat_ + 998
	long	@@@__system__dat_ + 1016
	long	@@@__system__dat_ + 1028
	long	@@@__system__dat_ + 1045
	long	@@@__system__dat_ + 1065
	long	@@@__system__dat_ + 1075
	long	@@@__system__dat_ + 1091
	long	@@@__system__dat_ + 1106
	long	@@@__system__dat_ + 1128
	long	@@@__system__dat_ + 1153
	long	@@@__system__dat_ + 1173
	long	@@@__system__dat_ + 1187
	long	@@@__system__dat_ + 1207
	long	@@@__system__dat_ + 1219
	long	@@@__system__dat_ + 1237
	long	@@@__system__dat_ + 1261
	long	@@@__system__dat_ + 1279
	long	@@@__system__dat_ + 1298
	byte	$4f, $4b, $00, $4e, $75, $6d, $65, $72, $69, $63, $61, $6c, $20, $61, $72, $67
	byte	$75, $6d, $65, $6e, $74, $20, $6f, $75, $74, $20, $6f, $66, $20, $64, $6f, $6d
	byte	$61, $69, $6e, $00, $52, $65, $73, $75, $6c, $74, $20, $6e, $6f, $74, $20, $72
	byte	$65, $70, $72, $65, $73, $65, $6e, $74, $61, $62, $6c, $65, $00, $49, $6c, $6c
	byte	$65, $67, $61, $6c, $20, $6d, $75, $6c, $74, $69, $62, $79, $74, $65, $20, $73
	byte	$65, $71, $75, $65, $6e, $63, $65, $00, $4e, $6f, $20, $73, $75, $63, $68, $20
	byte	$66, $69, $6c, $65, $20, $6f, $72, $20, $64, $69, $72, $65, $63, $74, $6f, $72
	byte	$79, $00, $42, $61, $64, $20, $66, $69, $6c, $65, $20, $6e, $75, $6d, $62, $65
	byte	$72, $00, $50, $65, $72, $6d, $69, $73, $73, $69, $6f, $6e, $20, $64, $65, $6e
	byte	$69, $65, $64, $00, $4e, $6f, $74, $20, $65, $6e, $6f, $75, $67, $68, $20, $6d
	byte	$65, $6d, $6f, $72, $79, $00, $54, $65, $6d, $70, $6f, $72, $61, $72, $79, $20
	byte	$66, $61, $69, $6c, $75, $72, $65, $00, $46, $69, $6c, $65, $20, $65, $78, $69
	byte	$73, $74, $73, $00, $49, $6e, $76, $61, $6c, $69, $64, $20, $61, $72, $67, $75
	byte	$6d, $65, $6e, $74, $00, $54, $6f, $6f, $20, $6d, $61, $6e, $79, $20, $6f, $70
	byte	$65, $6e, $20, $66, $69, $6c, $65, $73, $00, $49, $2f, $4f, $20, $65, $72, $72
	byte	$6f, $72, $00, $4e, $6f, $74, $20, $61, $20, $64, $69, $72, $65, $63, $74, $6f
	byte	$72, $79, $00, $49, $73, $20, $61, $20, $64, $69, $72, $65, $63, $74, $6f, $72
	byte	$79, $00, $52, $65, $61, $64, $20, $6f, $6e, $6c, $79, $20, $66, $69, $6c, $65
	byte	$20, $73, $79, $73, $74, $65, $6d, $00, $46, $75, $6e, $63, $74, $69, $6f, $6e
	byte	$20, $6e, $6f, $74, $20, $69, $6d, $70, $6c, $65, $6d, $65, $6e, $74, $65, $64
	byte	$00, $44, $69, $72, $65, $63, $74, $6f, $72, $79, $20, $6e, $6f, $74, $20, $65
	byte	$6d, $70, $74, $79, $00, $4e, $61, $6d, $65, $20, $74, $6f, $6f, $20, $6c, $6f
	byte	$6e, $67, $00, $44, $65, $76, $69, $63, $65, $20, $6e, $6f, $74, $20, $73, $65
	byte	$65, $6b, $61, $62, $6c, $65, $00, $42, $61, $64, $20, $61, $64, $64, $72, $65
	byte	$73, $73, $00, $42, $72, $6f, $6b, $65, $6e, $20, $63, $6f, $6e, $6e, $65, $63
	byte	$74, $69, $6f, $6e, $00, $44, $65, $76, $69, $63, $65, $20, $6f, $72, $20, $72
	byte	$65, $73, $6f, $75, $72, $63, $65, $20, $62, $75, $73, $79, $00, $43, $72, $6f
	byte	$73, $73, $20, $64, $65, $76, $69, $63, $65, $20, $6c, $69, $6e, $6b, $00, $4e
	byte	$6f, $20, $73, $70, $61, $63, $65, $20, $6f, $6e, $20, $64, $65, $76, $69, $63
	byte	$65, $00, $55, $6e, $6b, $6e, $6f, $77, $6e, $20, $65, $72, $72, $6f, $72, $00
	byte	$00[12]
	byte	$05, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
	long	(181 {__system___tx})<<20
	long	(182 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(183 {__system___rxtxioctl_0720})<<20
	long	(184 {__system____dummy_flush_0721})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(181 {__system___tx})<<20
	long	(182 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(183 {__system___rxtxioctl_0720})<<20
	long	(184 {__system____dummy_flush_0721})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(181 {__system___tx})<<20
	long	(182 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(183 {__system___rxtxioctl_0720})<<20
	long	(184 {__system____dummy_flush_0721})<<20
	byte	$00[376]
	long	@@@__system__dat_ + 1848
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	alignl
_fatfs_cc_dat_
	byte	$c7, $00, $fc, $00, $e9, $00, $e2, $00, $e4, $00, $e0, $00, $e5, $00, $e7, $00
	byte	$ea, $00, $eb, $00, $e8, $00, $ef, $00, $ee, $00, $ec, $00, $c4, $00, $c5, $00
	byte	$c9, $00, $e6, $00, $c6, $00, $f4, $00, $f6, $00, $f2, $00, $fb, $00, $f9, $00
	byte	$ff, $00, $d6, $00, $dc, $00, $f8, $00, $a3, $00, $d8, $00, $d7, $00, $92, $01
	byte	$e1, $00, $ed, $00, $f3, $00, $fa, $00, $f1, $00, $d1, $00, $aa, $00, $ba, $00
	byte	$bf, $00, $ae, $00, $ac, $00, $bd, $00, $bc, $00, $a1, $00, $ab, $00, $bb, $00
	byte	$91, $25, $92, $25, $93, $25, $02, $25, $24, $25, $c1, $00, $c2, $00, $c0, $00
	byte	$a9, $00, $63, $25, $51, $25, $57, $25, $5d, $25, $a2, $00, $a5, $00, $10, $25
	byte	$14, $25, $34, $25, $2c, $25, $1c, $25, $00, $25, $3c, $25, $e3, $00, $c3, $00
	byte	$5a, $25, $54, $25, $69, $25, $66, $25, $60, $25, $50, $25, $6c, $25, $a4, $00
	byte	$f0, $00, $d0, $00, $ca, $00, $cb, $00, $c8, $00, $31, $01, $cd, $00, $ce, $00
	byte	$cf, $00, $18, $25, $0c, $25, $88, $25, $84, $25, $a6, $00, $cc, $00, $80, $25
	byte	$d3, $00, $df, $00, $d4, $00, $d2, $00, $f5, $00, $d5, $00, $b5, $00, $fe, $00
	byte	$de, $00, $da, $00, $db, $00, $d9, $00, $fd, $00, $dd, $00, $af, $00, $b4, $00
	byte	$ad, $00, $b1, $00, $17, $20, $be, $00, $b6, $00, $a7, $00, $f7, $00, $b8, $00
	byte	$b0, $00, $a8, $00, $b7, $00, $b9, $00, $b3, $00, $b2, $00, $a0, $25, $a0, $00
	byte	$61, $00, $1a, $03, $e0, $00, $17, $03, $f8, $00, $07, $03, $ff, $00, $01, $00
	byte	$78, $01, $00, $01, $30, $01, $32, $01, $06, $01, $39, $01, $10, $01, $4a, $01
	byte	$2e, $01, $79, $01, $06, $01, $80, $01, $4d, $00, $43, $02, $81, $01, $82, $01
	byte	$82, $01, $84, $01, $84, $01, $86, $01, $87, $01, $87, $01, $89, $01, $8a, $01
	byte	$8b, $01, $8b, $01, $8d, $01, $8e, $01, $8f, $01, $90, $01, $91, $01, $91, $01
	byte	$93, $01, $94, $01, $f6, $01, $96, $01, $97, $01, $98, $01, $98, $01, $3d, $02
	byte	$9b, $01, $9c, $01, $9d, $01, $20, $02, $9f, $01, $a0, $01, $a0, $01, $a2, $01
	byte	$a2, $01, $a4, $01, $a4, $01, $a6, $01, $a7, $01, $a7, $01, $a9, $01, $aa, $01
	byte	$ab, $01, $ac, $01, $ac, $01, $ae, $01, $af, $01, $af, $01, $b1, $01, $b2, $01
	byte	$b3, $01, $b3, $01, $b5, $01, $b5, $01, $b7, $01, $b8, $01, $b8, $01, $ba, $01
	byte	$bb, $01, $bc, $01, $bc, $01, $be, $01, $f7, $01, $c0, $01, $c1, $01, $c2, $01
	byte	$c3, $01, $c4, $01, $c5, $01, $c4, $01, $c7, $01, $c8, $01, $c7, $01, $ca, $01
	byte	$cb, $01, $ca, $01, $cd, $01, $10, $01, $dd, $01, $01, $00, $8e, $01, $de, $01
	byte	$12, $01, $f3, $01, $03, $00, $f1, $01, $f4, $01, $f4, $01, $f8, $01, $28, $01
	byte	$22, $02, $12, $01, $3a, $02, $09, $00, $65, $2c, $3b, $02, $3b, $02, $3d, $02
	byte	$66, $2c, $3f, $02, $40, $02, $41, $02, $41, $02, $46, $02, $0a, $01, $53, $02
	byte	$40, $00, $81, $01, $86, $01, $55, $02, $89, $01, $8a, $01, $58, $02, $8f, $01
	byte	$5a, $02, $90, $01, $5c, $02, $5d, $02, $5e, $02, $5f, $02, $93, $01, $61, $02
	byte	$62, $02, $94, $01, $64, $02, $65, $02, $66, $02, $67, $02, $97, $01, $96, $01
	byte	$6a, $02, $62, $2c, $6c, $02, $6d, $02, $6e, $02, $9c, $01, $70, $02, $71, $02
	byte	$9d, $01, $73, $02, $74, $02, $9f, $01, $76, $02, $77, $02, $78, $02, $79, $02
	byte	$7a, $02, $7b, $02, $7c, $02, $64, $2c, $7e, $02, $7f, $02, $a6, $01, $81, $02
	byte	$82, $02, $a9, $01, $84, $02, $85, $02, $86, $02, $87, $02, $ae, $01, $44, $02
	byte	$b1, $01, $b2, $01, $45, $02, $8d, $02, $8e, $02, $8f, $02, $90, $02, $91, $02
	byte	$b7, $01, $7b, $03, $03, $00, $fd, $03, $fe, $03, $ff, $03, $ac, $03, $04, $00
	byte	$86, $03, $88, $03, $89, $03, $8a, $03, $b1, $03, $11, $03, $c2, $03, $02, $00
	byte	$a3, $03, $a3, $03, $c4, $03, $08, $03, $cc, $03, $03, $00, $8c, $03, $8e, $03
	byte	$8f, $03, $d8, $03, $18, $01, $f2, $03, $0a, $00, $f9, $03, $f3, $03, $f4, $03
	byte	$f5, $03, $f6, $03, $f7, $03, $f7, $03, $f9, $03, $fa, $03, $fa, $03, $30, $04
	byte	$20, $03, $50, $04, $10, $07, $60, $04, $22, $01, $8a, $04, $36, $01, $c1, $04
	byte	$0e, $01, $cf, $04, $01, $00, $c0, $04, $d0, $04, $44, $01, $61, $05, $26, $04
	byte	$00, $00, $7d, $1d, $01, $00, $63, $2c, $00, $1e, $96, $01, $a0, $1e, $5a, $01
	byte	$00, $1f, $08, $06, $10, $1f, $06, $06, $20, $1f, $08, $06, $30, $1f, $08, $06
	byte	$40, $1f, $06, $06, $51, $1f, $07, $00, $59, $1f, $52, $1f, $5b, $1f, $54, $1f
	byte	$5d, $1f, $56, $1f, $5f, $1f, $60, $1f, $08, $06, $70, $1f, $0e, $00, $ba, $1f
	byte	$bb, $1f, $c8, $1f, $c9, $1f, $ca, $1f, $cb, $1f, $da, $1f, $db, $1f, $f8, $1f
	byte	$f9, $1f, $ea, $1f, $eb, $1f, $fa, $1f, $fb, $1f, $80, $1f, $08, $06, $90, $1f
	byte	$08, $06, $a0, $1f, $08, $06, $b0, $1f, $04, $00, $b8, $1f, $b9, $1f, $b2, $1f
	byte	$bc, $1f, $cc, $1f, $01, $00, $c3, $1f, $d0, $1f, $02, $06, $e0, $1f, $02, $06
	byte	$e5, $1f, $01, $00, $ec, $1f, $f3, $1f, $01, $00, $fc, $1f, $4e, $21, $01, $00
	byte	$32, $21, $70, $21, $10, $02, $84, $21, $01, $00, $83, $21, $d0, $24, $1a, $05
	byte	$30, $2c, $2f, $04, $60, $2c, $02, $01, $67, $2c, $06, $01, $75, $2c, $02, $01
	byte	$80, $2c, $64, $01, $00, $2d, $26, $08, $41, $ff, $1a, $03, $00, $00, $01, $03
	byte	$05, $07, $09, $0e, $10, $12, $14, $16, $18, $1c, $1e, $43, $55, $45, $41, $41
	byte	$41, $41, $43, $45, $45, $45, $49, $49, $49, $41, $41, $45, $92, $92, $4f, $4f
	byte	$4f, $55, $55, $59, $4f, $55, $4f, $9c, $4f, $9e, $9f, $41, $49, $4f, $55, $a5
	byte	$a5, $a6, $a7, $a8, $a9, $aa, $ab, $ac, $ad, $ae, $af, $b0, $b1, $b2, $b3, $b4
	byte	$41, $41, $41, $b8, $b9, $ba, $bb, $bc, $bd, $be, $bf, $c0, $c1, $c2, $c3, $c4
	byte	$c5, $41, $41, $c8, $c9, $ca, $cb, $cc, $cd, $ce, $cf, $d1, $d1, $45, $45, $45
	byte	$49, $49, $49, $49, $d9, $da, $db, $dc, $dd, $49, $df, $4f, $e1, $4f, $4f, $4f
	byte	$4f, $e6, $e8, $e8, $55, $55, $55, $59, $59, $ee, $ef, $f0, $f1, $f2, $f3, $f4
	byte	$f5, $f6, $f7, $f8, $f9, $fa, $fb, $fc, $fd, $fe, $ff, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
	long	(164 {_fatfs_cc_v_close})<<20
	long	(165 {_fatfs_cc_v_read})<<20
	long	(166 {_fatfs_cc_v_write})<<20
	long	(167 {_fatfs_cc_v_lseek})<<20
	long	(168 {_fatfs_cc_v_ioctl})<<20
	long	(185 {_fatfs_cc_v_flush})<<20
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(169 {_fatfs_cc_v_open})<<20
	long	(170 {_fatfs_cc_v_creat})<<20
	long	(171 {_fatfs_cc_v_opendir})<<20
	long	(172 {_fatfs_cc_v_closedir})<<20
	long	(173 {_fatfs_cc_v_readdir})<<20
	long	(174 {_fatfs_cc_v_stat})<<20
	long	(175 {_fatfs_cc_v_mkdir})<<20
	long	(176 {_fatfs_cc_v_rmdir})<<20
	long	(177 {_fatfs_cc_v_remove})<<20
	long	(178 {_fatfs_cc_v_rename})<<20
	long	(179 {_fatfs_cc_v_init})<<20
	long	(180 {_fatfs_cc_v_deinit})<<20
	byte	$ff, $ff, $ff, $ff, $1f, $00, $00, $00, $1c, $00, $00, $00, $1f, $00, $00, $00
	byte	$1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00
	byte	$1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00
	byte	$1f, $00, $00, $00, $00, $00, $00, $00, $1f, $00, $00, $00, $3b, $00, $00, $00
	byte	$5a, $00, $00, $00, $78, $00, $00, $00, $97, $00, $00, $00, $b5, $00, $00, $00
	byte	$d4, $00, $00, $00, $f3, $00, $00, $00, $11, $01, $00, $00, $30, $01, $00, $00
	byte	$4e, $01, $00, $00, $6d, $01, $00, $00, $ff, $ff, $ff, $ff, $00, $00, $00, $00
	byte	$00[32]
	long	@@@_fatfs_cc_dat_ + 1346
	long	@@@_fatfs_cc_dat_ + 1350
	byte	$00[18]
	byte	$3f, $3f, $3f, $00, $55, $43, $54, $00, $55, $43, $54, $00, $00, $00, $00, $00
	byte	$00[7]
	byte	$ca, $9a, $3b, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$91, $11, $11, $11, $11, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01
	byte	$01[7]
	byte	$90, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
	byte	$42[10]
	byte	$20[7]
	byte	$44[6]
	byte	$04[20]
	byte	$20[6]
	byte	$48[6]
	byte	$08[20]
	byte	$20, $20, $20, $20, $01, $00, $00, $00, $00
__methodtable__
	long	@_do_no_command
	long	@_do_plus
	long	@_do_minus
	long	@_do_or
	long	@_do_mul
	long	@_do_fdiv
	long	@_do_and
	long	@_do_div
	long	@_do_mod
	long	@_do_shl
	long	@_do_shr
	long	@_do_power
	long	@_do_getvar
	long	@_do_push
	long	@_do_assign
	long	@_do_cls
	long	@_do_new
	long	@_do_plot
	long	@_do_draw
	long	@_do_print
	long	@_do_circle
	long	@_do_fcircle
	long	@_do_box
	long	@_do_frame
	long	@_do_color
	long	@_do_for
	long	@_do_next
	long	@_do_list
	long	@_do_run
	long	@_do_error
	long	@_do_fast_goto
	long	@_do_find_goto
	long	@_do_slow_goto
	long	@_do_nothing
	long	@_test_csave
	long	@_do_save
	long	@_do_load
	long	@_do_pinwrite
	long	@_do_waitms
	long	@_do_waitvbl
	long	@_do_if
	long	@_do_else
	long	@_do_eq
	long	@_do_ge
	long	@_do_le
	long	@_do_gt
	long	@_do_lt
	long	@_do_ne
	long	@_do_rnd
	long	@_do_brun
	long	@_do_beep
	long	@_do_dir
	long	@_do_paper
	long	@_do_ink
	long	@_do_font
	long	@_do_mode
	long	@_do_mouse
	long	@_do_gettime
	long	@_do_cursor
	long	@_do_click
	long	@_do_mousex
	long	@_do_mousey
	long	@_do_mousek
	long	@_do_mousew
	long	@_do_sin
	long	@_do_stick
	long	@_do_strig
	long	@_do_sprite
	long	@_do_defsprite
	long	@_do_getpixel
	long	@_do_waitclock
	long	@_do_negative
	long	@_do_rdpin
	long	@_do_rqpin
	long	@_do_pinread
	long	@_do_wrpin
	long	@_do_wxpin
	long	@_do_wypin
	long	@_do_pinfloat
	long	@_do_pinlo
	long	@_do_pinhi
	long	@_do_pinstart
	long	@_do_pintoggle
	long	@_do_position
	long	@_do_cos
	long	@_do_tan
	long	@_do_atn
	long	@_do_asin
	long	@_do_acos
	long	@_do_sqr
	long	@_do_fill
	long	@_do_defsnd
	long	@_do_defenv
	long	@_do_rad
	long	@_do_deg
	long	@_do_int
	long	@_do_play
	long	@_do_setdelay
	long	@_do_setenv
	long	@_do_setlen
	long	@_do_setpan
	long	@_do_setvol
	long	@_do_setwave
	long	@_do_setsustain
	long	@_do_release
	long	@_do_getenvsustain
	long	@_do_poke
	long	@_do_dpoke
	long	@_do_lpoke
	long	@_do_peek
	long	@_do_dpeek
	long	@_do_lpeek
	long	@_do_fre
	long	@_do_getnotevalue
	long	@_do_getaddr
	long	@_do_inkey
	long	@_do_abs
	long	@_do_hex
	long	@_do_bin
	long	@_do_val
	long	@_do_chr
	long	@_do_asc
	long	@_do_left
	long	@_do_right
	long	@_do_mid
	long	@_do_len
	long	@_do_gosub
	long	@_do_return
	long	@_do_end
	long	@_do_pop
	long	@_do_log
	long	@_do_changevol
	long	@_do_changewav
	long	@_do_changepan
	long	@_do_changefreq
	long	@_do_shutup
	long	@_do_round
	long	@_do_enter
	long	@_do_open
	long	@_do_close
	long	@_do_get
	long	@_do_put
	long	@_do_cd
	long	@_do_delete
	long	@_do_mkdir
	long	@_do_blit
	long	@_do_framebuf
	long	@_do_on
	long	@_do_skip
	long	@_do_input
	long	@_hg010b_spin2_putchar
	long	@__struct___bas_wrap_sender_tx
	long	@__struct___bas_wrap_sender_rx
	long	@__struct___bas_wrap_sender_close
	long	@__struct__s_vfs_file_t_putchar
	long	@__struct__s_vfs_file_t_getchar
	long	@___strs_cl_pfunc
	long	@__system____root_opendir
	long	@__system____root_closedir
	long	@__system____root_readdir
	long	@__system____root_stat
	long	@__system____default_putc
	long	@__system____default_getc
	long	@__system____default_flush
	long	@_fatfs_cc_v_close
	long	@_fatfs_cc_v_read
	long	@_fatfs_cc_v_write
	long	@_fatfs_cc_v_lseek
	long	@_fatfs_cc_v_ioctl
	long	@_fatfs_cc_v_open
	long	@_fatfs_cc_v_creat
	long	@_fatfs_cc_v_opendir
	long	@_fatfs_cc_v_closedir
	long	@_fatfs_cc_v_readdir
	long	@_fatfs_cc_v_stat
	long	@_fatfs_cc_v_mkdir
	long	@_fatfs_cc_v_rmdir
	long	@_fatfs_cc_v_remove
	long	@_fatfs_cc_v_rename
	long	@_fatfs_cc_v_init
	long	@_fatfs_cc_v_deinit
	long	@__system___tx
	long	@__system___rx
	long	@__system___rxtxioctl_0720
	long	@__system____dummy_flush_0721
	long	@_fatfs_cc_v_flush
__heap_base
	long	0[24002]
objmem
	long	0[10508]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
_var03
	res	1
_var04
	res	1
_var05
	res	1
_var06
	res	1
_var07
	res	1
_var08
	res	1
_var09
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
arg05
	res	1
arg06
	res	1
arg07
	res	1
arg08
	res	1
arg09
	res	1
arg10
	res	1
local01
	res	1
local02
	res	1
local03
	res	1
local04
	res	1
local05
	res	1
local06
	res	1
local07
	res	1
local08
	res	1
local09
	res	1
local10
	res	1
local11
	res	1
local12
	res	1
local13
	res	1
local14
	res	1
local15
	res	1
local16
	res	1
local17
	res	1
local18
	res	1
local19
	res	1
local20
	res	1
local21
	res	1
local22
	res	1
local23
	res	1
local24
	res	1
local25
	res	1
local26
	res	1
local27
	res	1
local28
	res	1
local29
	res	1
local30
	res	1
local31
	res	1
local32
	res	1
local33
	res	1
local34
	res	1
local35
	res	1
local36
	res	1
local37
	res	1
local38
	res	1
local39
	res	1
local40
	res	1
local41
	res	1
local42
	res	1
local43
	res	1
local44
	res	1
local45
	res	1
local46
	res	1
local47
	res	1
local48
	res	1
local49
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	480
