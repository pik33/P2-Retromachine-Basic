00000                 | 
00000                 | #line 1 "D:/Programowanie/P2-Retromachine-Basic/pt-test.p2asm"
00000                 | con
00000                 | 	_clkfreq = 338695652
00000                 | 	_clkmode = 28773115
00000                 | ' _clkfreq=338688000
00000                 | ' c4=262
00000                 | 	c4 = 262
00000                 | ' d4=294
00000                 | 	d4 = 294
00000                 | ' e4=330
00000                 | 	e4 = 330
00000                 | ' f4=349
00000                 | 	f4 = 349
00000                 | ' g4=392
00000                 | 	g4 = 392
00000                 | ' a4=440
00000                 | 	a4 = 440
00000                 | ' h4=494
00000                 | 	h4 = 494
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 338695652
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $1b70afb
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 00 06 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 03 90 5D |  if_ne	jmp	#spininit
0040c 002 FF F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 02 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 85 DB 80 FF 
00420 007 00 F0 65 FD | 	hubset	##28773112
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 85 DB 00 FF 
00430 00b FB EC 07 F6 | 	mov	pa, ##28773115
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 0A 18 8A FF 
00440 00f 14 C8 6F FC | 	wrlong	##338695652, #20
00444 010 BC 02 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
006fc 0be 00 00 00 00 
00700 0bf 00 00 00 00 | 	orgf	192
00704 0c0             | skip_clock_set_
00704 0c0 14 08 A0 FD | 	call	#_drivertest
00708 0c1             | cogexit
00708 0c1 38 01 80 FF 
0070c 0c2 1F 00 66 FD | 	waitx	##160000
00710 0c3 01 0E 62 FD | 	cogid	arg01
00714 0c4 03 0E 62 FD | 	cogstop	arg01
00718 0c5             | spininit
00718 0c5 61 F5 05 FB | 	rdlong	objptr, ptra++
0071c 0c6 61 01 06 FB | 	rdlong	result1, ptra++
00720 0c7 28 06 64 FD | 	setq	#3
00724 0c8 00 0F 06 FB | 	rdlong	arg01, ptra
00728 0c9 04 F0 87 F1 | 	sub	ptra, #4
0072c 0ca 2D 00 62 FD | 	call	result1
00730 0cb D4 FF 9F FD | 	jmp	#cogexit
00734 0cc             | FCACHE_LOAD_
00734 0cc F9 AD 01 F6 |     mov	fcache_tmpb_,ptrb
00738 0cd 2B F2 63 FD |     pop	ptrb
0073c 0ce D5 EC 8B F9 |     altd	pa,ret_instr_
00740 0cf D5 00 00 F6 |     mov	 0-0, ret_instr_
00744 0d0 28 EC 63 FD |     setq	pa
00748 0d1 E1 01 04 FB |     rdlong	$0, ptrb++
0074c 0d2 2A F2 63 FD |     push	ptrb
00750 0d3 D6 F2 03 F6 |     mov ptrb,fcache_tmpb_
00754 0d4 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00758 0d5             | ret_instr_
00758 0d5 00 FE 07 02 |     _ret_ cmp inb,#0
0075c 0d6             | fcache_tmpb_
0075c 0d6 00 00 00 00 |     long 0
00760 0d7             | fcache_load_ptr_
00760 0d7 CC 00 00 00 |     long FCACHE_LOAD_
00764 0d8             | builtin_bytefill_
00764 0d8 01 12 56 F0 |         shr	arg03, #1 wc
00768 0d9 07 11 42 CC |  if_c   wrbyte	arg02, arg01
0076c 0da 01 0E 06 C1 |  if_c   add	arg01, #1
00770 0db 00 10 FE F9 |         movbyts	arg02, #0
00774 0dc             | builtin_wordfill_
00774 0dc 01 12 56 F0 |         shr	arg03, #1 wc
00778 0dd 07 11 52 CC |  if_c   wrword	arg02, arg01
0077c 0de 02 0E 06 C1 |  if_c   add	arg01, #2
00780 0df 08 11 2A F9 |         setword	arg02, arg02, #1
00784 0e0             | builtin_longfill_
00784 0e0 07 01 88 FC |         wrfast	#0,arg01
00788 0e1 00 12 0E F2 |         cmp	arg03, #0 wz
0078c 0e2 09 03 D8 5C |  if_nz  rep	#1, arg03
00790 0e3 17 10 62 5D |  if_nz  wflong	arg02
00794 0e4 2D 00 64 FD |         ret
00798 0e5             | COUNT_
00798 0e5 00 00 00 00 |     long 0
0079c 0e6             | RETADDR_
0079c 0e6 00 00 00 00 |     long 0
007a0 0e7             | fp
007a0 0e7 00 00 00 00 |     long 0
007a4 0e8             | pushregs_
007a4 0e8 2B EC 63 FD |     pop  pa
007a8 0e9 2B CC 61 FD |     pop  RETADDR_
007ac 0ea 03 CA 95 FB |     tjz  COUNT_, #pushregs_done_
007b0 0eb FF CB 8D F9 |     altd  COUNT_, #511
007b4 0ec 28 00 64 FD |     setq #0-0
007b8 0ed 61 21 66 FC |     wrlong local01, ptra++
007bc 0ee             | pushregs_done_
007bc 0ee 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
007c0 0ef 61 CB 65 FC |     wrlong COUNT_, ptra++
007c4 0f0 F8 CF 01 F6 |     mov    fp, ptra
007c8 0f1 2C EC 63 FD |     jmp  pa
007cc 0f2             |  popregs_
007cc 0f2 2B EC 63 FD |     pop    pa
007d0 0f3 28 04 64 FD |     setq   #2
007d4 0f4 5F CB 05 FB |     rdlong COUNT_, --ptra
007d8 0f5 02 CA 75 FB |     djf    COUNT_, #popregs__ret
007dc 0f6 28 CA 61 FD |     setq   COUNT_
007e0 0f7 5F 21 06 FB |     rdlong local01, --ptra
007e4 0f8             | popregs__ret
007e4 0f8 2A CC 61 FD |     push   RETADDR_
007e8 0f9 2C EC 63 FD |     jmp    pa
007ec 0fa             | 
007ec 0fa             | objptr
007ec 0fa FC 34 00 00 | 	long	@objmem
007f0 0fb             | ptr__Audio2_004_dat__
007f0 0fb 28 1F 00 00 | 	long	@_Audio2_004_dat_
007f4 0fc             | ptr__dat__
007f4 0fc 08 16 00 00 | 	long	@_dat_
007f8 0fd             | ptr__psram16drv_dat__
007f8 0fd 6C 25 00 00 | 	long	@_psram16drv_dat_
007fc 0fe             | ptr__psram_dat__
007fc 0fe 24 23 00 00 | 	long	@_psram_dat_
00800 0ff             | ptr_stackspace_
00800 0ff 74 3A 00 00 | 	long	@stackspace
00804 100             | result1
00804 100 00 00 00 00 | 	long	0
00808 101             | result2
00808 101 01 00 00 00 | 	long	1
0080c 102             | result3
0080c 102 02 00 00 00 | 	long	2
00810 103             | result4
00810 103 03 00 00 00 | 	long	3
00814 104             | COG_BSS_START
00814 104             | 	fit	480
00814                 | 	orgh
00814                 | hubentry
00814                 | 
00814                 | ' 
00814                 | ' pub drivertest()   : cog,base,i,j
00814                 | _drivertest
00814     02 CA 05 F6 | 	mov	COUNT_, #2
00818     E8 00 A0 FD | 	call	#pushregs_
0081c                 | ' ' prepare 8-bit saw wave
0081c                 | ' repeat i from $40000 to $407FF step 2
0081c     12 20 C6 F9 | 	decod	local01, #18
00820     D7 14 48 FB | 	callpa	#(@LR__0002-@LR__0001)>>2,fcache_load_ptr_
00824                 | LR__0001
00824                 | '   j:=@waveform+i-$40000+16
00824     FC 22 02 F6 | 	mov	local02, ptr__dat__
00828     10 23 02 F1 | 	add	local02, local01
0082c     FF 01 00 FF 
00830     F0 23 86 F1 | 	sub	local02, ##262128
00834                 | '   word[i]:=word[j]
00834     11 23 E2 FA | 	rdword	local02, local02
00838     10 23 52 FC | 	wrword	local02, local01
0083c     02 20 06 F1 | 	add	local01, #2
00840     04 02 00 FF 
00844     00 20 56 F2 | 	cmps	local01, ##264192 wc
00848     D8 FF 9F CD |  if_b	jmp	#LR__0001
0084c                 | LR__0002
0084c                 | '  ' debug(sdec(word[i]))
0084c                 | ' ' start the driver. It will generate scope data at $60000. It will not use any PSRAM
0084c                 | ' repeat i from $41000 to $411FF step 2
0084c     08 02 00 FF 
00850     00 20 06 F6 | 	mov	local01, ##266240
00854     04 00 00 FF 
00858     10 F8 05 F1 | 	add	ptr__dat__, ##2064
0085c     D7 1C 48 FB | 	callpa	#(@LR__0004-@LR__0003)>>2,fcache_load_ptr_
00860                 | LR__0003
00860                 | '   j:=@envelope+((i-$41000)>>1)+16
00860     FC 22 02 F6 | 	mov	local02, ptr__dat__
00864     10 1F 02 F6 | 	mov	arg09, local01
00868     08 02 00 FF 
0086c     00 1E 86 F1 | 	sub	arg09, ##266240
00870     01 1E 46 F0 | 	shr	arg09, #1
00874     0F 23 02 F1 | 	add	local02, arg09
00878     10 22 06 F1 | 	add	local02, #16
0087c                 | '   word[i]:=byte[j]<<8
0087c     11 23 C2 FA | 	rdbyte	local02, local02
00880     08 22 66 F0 | 	shl	local02, #8
00884     10 23 52 FC | 	wrword	local02, local01
00888     02 20 06 F1 | 	add	local01, #2
0088c     09 02 00 FF 
00890     00 20 56 F2 | 	cmps	local01, ##266752 wc
00894     C8 FF 9F CD |  if_b	jmp	#LR__0003
00898                 | LR__0004
00898     04 00 00 FF 
0089c     10 F8 85 F1 | 	sub	ptr__dat__, ##2064
008a0                 | '   
008a0                 | ' pscog,mail:=psram.startx(0, 1024, 11, 7) 
008a0     00 0E 06 F6 | 	mov	arg01, #0
008a4     0A 10 C6 F9 | 	decod	arg02, #10
008a8     0B 12 06 F6 | 	mov	arg03, #11
008ac     07 14 06 F6 | 	mov	arg04, #7
008b0     02 00 00 FF 
008b4     78 F5 05 F1 | 	add	objptr, ##1400
008b8     AC 09 B0 FD | 	call	#_psram_startx
008bc     02 00 00 FF 
008c0     78 F5 85 F1 | 	sub	objptr, ##1400
008c4     FA 00 62 FC | 	wrlong	result1, objptr
008c8     04 F4 05 F1 | 	add	objptr, #4
008cc     FA 02 62 FC | 	wrlong	result2, objptr
008d0                 | ' debug(uhex(mail)) 
008d0                 | ' psram.write($40000,$100000,2048)  
008d0     12 0E C6 F9 | 	decod	arg01, #18
008d4     14 10 C6 F9 | 	decod	arg02, #20
008d8     0B 12 C6 F9 | 	decod	arg03, #11
008dc     02 00 00 FF 
008e0     74 F5 05 F1 | 	add	objptr, ##1396
008e4     CC 0B B0 FD | 	call	#_psram_write
008e8                 | ' cog, base:=audio.start(mail,$60000,$68000)
008e8     02 00 00 FF 
008ec     74 F5 85 F1 | 	sub	objptr, ##1396
008f0     FA 0E 02 FB | 	rdlong	arg01, objptr
008f4     00 03 00 FF 
008f8     00 10 06 F6 | 	mov	arg02, ##393216
008fc     40 03 00 FF 
00900     00 12 06 F6 | 	mov	arg03, ##425984
00904     08 F4 05 F1 | 	add	objptr, #8
00908     80 03 B0 FD | 	call	#_Audio2_004_start
0090c     0C F4 85 F1 | 	sub	objptr, #12
00910                 | ' waitms(100)
00910     64 0E 06 F6 | 	mov	arg01, #100
00914     84 0C B0 FD | 	call	#__system___waitms
00918                 | ' 'debug(udec(cog,base))
00918                 | ' 
00918                 | ' {{Channel registers:
00918                 | ' }}
00918                 | ' 
00918                 | ' ' tell it to play
00918                 | ' 
00918                 | ' 
00918                 | ' 
00918                 | ' 'repeat i from 1 to 10000
00918                 | ' '  audio.play(0,i,10,4096,$08000000,0,0)
00918                 | ' 
00918                 | ' 'audio.play(0,c4*1000,200,4096,$100000,$41000,600) ' (channel, frequency, delay, volume, waveform, envelope, length, pan, sustain) 
00918                 | ' 'audio.play(0,c4*1000,200,4096,$40000,$41000,600) ' (channel, frequency, delay, volume, waveform, envelope, length, pan, sustain) 
00918                 | ' 'repeat
00918                 | ' 
00918                 | ' repeat
00918     0C F4 05 F1 | 	add	objptr, #12
0091c                 | LR__0005
0091c                 | '    audio.play(0,c4*1000,2000,4096,$100000,$41000,2000) ' (channel, frequency, delay, volume, waveform, envelope, length, pan, sustain) 
0091c     00 0E 06 F6 | 	mov	arg01, #0
00920     FF 01 00 FF 
00924     70 11 06 F6 | 	mov	arg02, ##262000
00928     03 00 00 FF 
0092c     D0 13 06 F6 | 	mov	arg03, ##2000
00930     0C 14 C6 F9 | 	decod	arg04, #12
00934     14 16 C6 F9 | 	decod	arg05, #20
00938     08 02 00 FF 
0093c     00 18 06 F6 | 	mov	arg06, ##266240
00940     03 00 00 FF 
00944     D0 1B 06 F6 | 	mov	arg07, ##2000
00948     01 1C 66 F6 | 	neg	arg08, #1
0094c     01 1E 66 F6 | 	neg	arg09, #1
00950     D4 05 B0 FD | 	call	#_Audio2_004_play
00954                 | '    audio.play(1,d4*1000,2000,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00954     01 0E 06 F6 | 	mov	arg01, #1
00958     3E 02 00 FF 
0095c     70 10 06 F6 | 	mov	arg02, ##294000
00960     03 00 00 FF 
00964     D0 13 06 F6 | 	mov	arg03, ##2000
00968     0C 14 C6 F9 | 	decod	arg04, #12
0096c     14 16 C6 F9 | 	decod	arg05, #20
00970     08 02 00 FF 
00974     00 18 06 F6 | 	mov	arg06, ##266240
00978     03 00 00 FF 
0097c     D0 1B 06 F6 | 	mov	arg07, ##2000
00980     01 1C 66 F6 | 	neg	arg08, #1
00984     01 1E 66 F6 | 	neg	arg09, #1
00988     9C 05 B0 FD | 	call	#_Audio2_004_play
0098c                 | '    audio.play(2,e4*1000,2000,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
0098c     02 0E 06 F6 | 	mov	arg01, #2
00990     84 02 00 FF 
00994     10 11 06 F6 | 	mov	arg02, ##330000
00998     03 00 00 FF 
0099c     D0 13 06 F6 | 	mov	arg03, ##2000
009a0     0C 14 C6 F9 | 	decod	arg04, #12
009a4     14 16 C6 F9 | 	decod	arg05, #20
009a8     08 02 00 FF 
009ac     00 18 06 F6 | 	mov	arg06, ##266240
009b0     03 00 00 FF 
009b4     D0 1B 06 F6 | 	mov	arg07, ##2000
009b8     01 1C 66 F6 | 	neg	arg08, #1
009bc     01 1E 66 F6 | 	neg	arg09, #1
009c0     64 05 B0 FD | 	call	#_Audio2_004_play
009c4                 | '    audio.play(3,f4*1000,2000,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
009c4     03 0E 06 F6 | 	mov	arg01, #3
009c8     A9 02 00 FF 
009cc     48 11 06 F6 | 	mov	arg02, ##349000
009d0     03 00 00 FF 
009d4     D0 13 06 F6 | 	mov	arg03, ##2000
009d8     0C 14 C6 F9 | 	decod	arg04, #12
009dc     14 16 C6 F9 | 	decod	arg05, #20
009e0     08 02 00 FF 
009e4     00 18 06 F6 | 	mov	arg06, ##266240
009e8     03 00 00 FF 
009ec     D0 1B 06 F6 | 	mov	arg07, ##2000
009f0     01 1C 66 F6 | 	neg	arg08, #1
009f4     01 1E 66 F6 | 	neg	arg09, #1
009f8     2C 05 B0 FD | 	call	#_Audio2_004_play
009fc                 | '    audio.play(4,g4*1000,2000,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
009fc     04 0E 06 F6 | 	mov	arg01, #4
00a00     FD 02 00 FF 
00a04     40 11 06 F6 | 	mov	arg02, ##392000
00a08     03 00 00 FF 
00a0c     D0 13 06 F6 | 	mov	arg03, ##2000
00a10     0C 14 C6 F9 | 	decod	arg04, #12
00a14     14 16 C6 F9 | 	decod	arg05, #20
00a18     08 02 00 FF 
00a1c     00 18 06 F6 | 	mov	arg06, ##266240
00a20     03 00 00 FF 
00a24     D0 1B 06 F6 | 	mov	arg07, ##2000
00a28     01 1C 66 F6 | 	neg	arg08, #1
00a2c     01 1E 66 F6 | 	neg	arg09, #1
00a30     F4 04 B0 FD | 	call	#_Audio2_004_play
00a34                 | '    audio.play(5,a4*1000,2000,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00a34     05 0E 06 F6 | 	mov	arg01, #5
00a38     5B 03 00 FF 
00a3c     C0 10 06 F6 | 	mov	arg02, ##440000
00a40     03 00 00 FF 
00a44     D0 13 06 F6 | 	mov	arg03, ##2000
00a48     0C 14 C6 F9 | 	decod	arg04, #12
00a4c     14 16 C6 F9 | 	decod	arg05, #20
00a50     08 02 00 FF 
00a54     00 18 06 F6 | 	mov	arg06, ##266240
00a58     03 00 00 FF 
00a5c     D0 1B 06 F6 | 	mov	arg07, ##2000
00a60     01 1C 66 F6 | 	neg	arg08, #1
00a64     01 1E 66 F6 | 	neg	arg09, #1
00a68     BC 04 B0 FD | 	call	#_Audio2_004_play
00a6c                 | '    audio.play(6,h4*1000,2000,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00a6c     06 0E 06 F6 | 	mov	arg01, #6
00a70     C4 03 00 FF 
00a74     B0 11 06 F6 | 	mov	arg02, ##494000
00a78     03 00 00 FF 
00a7c     D0 13 06 F6 | 	mov	arg03, ##2000
00a80     0C 14 C6 F9 | 	decod	arg04, #12
00a84     14 16 C6 F9 | 	decod	arg05, #20
00a88     08 02 00 FF 
00a8c     00 18 06 F6 | 	mov	arg06, ##266240
00a90     03 00 00 FF 
00a94     D0 1B 06 F6 | 	mov	arg07, ##2000
00a98     01 1C 66 F6 | 	neg	arg08, #1
00a9c     01 1E 66 F6 | 	neg	arg09, #1
00aa0     84 04 B0 FD | 	call	#_Audio2_004_play
00aa4                 | '    audio.play(7,c4*2000,2000,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00aa4     07 0E 06 F6 | 	mov	arg01, #7
00aa8     FF 03 00 FF 
00aac     E0 10 06 F6 | 	mov	arg02, ##524000
00ab0     03 00 00 FF 
00ab4     D0 13 06 F6 | 	mov	arg03, ##2000
00ab8     0C 14 C6 F9 | 	decod	arg04, #12
00abc     14 16 C6 F9 | 	decod	arg05, #20
00ac0     08 02 00 FF 
00ac4     00 18 06 F6 | 	mov	arg06, ##266240
00ac8     03 00 00 FF 
00acc     D0 1B 06 F6 | 	mov	arg07, ##2000
00ad0     01 1C 66 F6 | 	neg	arg08, #1
00ad4     01 1E 66 F6 | 	neg	arg09, #1
00ad8     4C 04 B0 FD | 	call	#_Audio2_004_play
00adc                 | '    audio.play(8,c4*2000,200,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00adc     08 0E 06 F6 | 	mov	arg01, #8
00ae0     FF 03 00 FF 
00ae4     E0 10 06 F6 | 	mov	arg02, ##524000
00ae8     C8 12 06 F6 | 	mov	arg03, #200
00aec     0C 14 C6 F9 | 	decod	arg04, #12
00af0     14 16 C6 F9 | 	decod	arg05, #20
00af4     08 02 00 FF 
00af8     00 18 06 F6 | 	mov	arg06, ##266240
00afc     03 00 00 FF 
00b00     D0 1B 06 F6 | 	mov	arg07, ##2000
00b04     01 1C 66 F6 | 	neg	arg08, #1
00b08     01 1E 66 F6 | 	neg	arg09, #1
00b0c     18 04 B0 FD | 	call	#_Audio2_004_play
00b10                 | '    audio.play(9,h4*1000,200,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00b10     09 0E 06 F6 | 	mov	arg01, #9
00b14     C4 03 00 FF 
00b18     B0 11 06 F6 | 	mov	arg02, ##494000
00b1c     C8 12 06 F6 | 	mov	arg03, #200
00b20     0C 14 C6 F9 | 	decod	arg04, #12
00b24     14 16 C6 F9 | 	decod	arg05, #20
00b28     08 02 00 FF 
00b2c     00 18 06 F6 | 	mov	arg06, ##266240
00b30     03 00 00 FF 
00b34     D0 1B 06 F6 | 	mov	arg07, ##2000
00b38     01 1C 66 F6 | 	neg	arg08, #1
00b3c     01 1E 66 F6 | 	neg	arg09, #1
00b40     E4 03 B0 FD | 	call	#_Audio2_004_play
00b44                 | '    audio.play(10,a4*1000,200,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00b44     0A 0E 06 F6 | 	mov	arg01, #10
00b48     5B 03 00 FF 
00b4c     C0 10 06 F6 | 	mov	arg02, ##440000
00b50     C8 12 06 F6 | 	mov	arg03, #200
00b54     0C 14 C6 F9 | 	decod	arg04, #12
00b58     14 16 C6 F9 | 	decod	arg05, #20
00b5c     08 02 00 FF 
00b60     00 18 06 F6 | 	mov	arg06, ##266240
00b64     03 00 00 FF 
00b68     D0 1B 06 F6 | 	mov	arg07, ##2000
00b6c     01 1C 66 F6 | 	neg	arg08, #1
00b70     01 1E 66 F6 | 	neg	arg09, #1
00b74     B0 03 B0 FD | 	call	#_Audio2_004_play
00b78                 | '    audio.play(11,g4*1000,200,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00b78     0B 0E 06 F6 | 	mov	arg01, #11
00b7c     FD 02 00 FF 
00b80     40 11 06 F6 | 	mov	arg02, ##392000
00b84     C8 12 06 F6 | 	mov	arg03, #200
00b88     0C 14 C6 F9 | 	decod	arg04, #12
00b8c     14 16 C6 F9 | 	decod	arg05, #20
00b90     08 02 00 FF 
00b94     00 18 06 F6 | 	mov	arg06, ##266240
00b98     03 00 00 FF 
00b9c     D0 1B 06 F6 | 	mov	arg07, ##2000
00ba0     01 1C 66 F6 | 	neg	arg08, #1
00ba4     01 1E 66 F6 | 	neg	arg09, #1
00ba8     7C 03 B0 FD | 	call	#_Audio2_004_play
00bac                 | '    audio.play(12,f4*1000,200,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00bac     0C 0E 06 F6 | 	mov	arg01, #12
00bb0     A9 02 00 FF 
00bb4     48 11 06 F6 | 	mov	arg02, ##349000
00bb8     C8 12 06 F6 | 	mov	arg03, #200
00bbc     0C 14 C6 F9 | 	decod	arg04, #12
00bc0     14 16 C6 F9 | 	decod	arg05, #20
00bc4     08 02 00 FF 
00bc8     00 18 06 F6 | 	mov	arg06, ##266240
00bcc     03 00 00 FF 
00bd0     D0 1B 06 F6 | 	mov	arg07, ##2000
00bd4     01 1C 66 F6 | 	neg	arg08, #1
00bd8     01 1E 66 F6 | 	neg	arg09, #1
00bdc     48 03 B0 FD | 	call	#_Audio2_004_play
00be0                 | '    audio.play(13,e4*1000,200,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00be0     0D 0E 06 F6 | 	mov	arg01, #13
00be4     84 02 00 FF 
00be8     10 11 06 F6 | 	mov	arg02, ##330000
00bec     C8 12 06 F6 | 	mov	arg03, #200
00bf0     0C 14 C6 F9 | 	decod	arg04, #12
00bf4     14 16 C6 F9 | 	decod	arg05, #20
00bf8     08 02 00 FF 
00bfc     00 18 06 F6 | 	mov	arg06, ##266240
00c00     03 00 00 FF 
00c04     D0 1B 06 F6 | 	mov	arg07, ##2000
00c08     01 1C 66 F6 | 	neg	arg08, #1
00c0c     01 1E 66 F6 | 	neg	arg09, #1
00c10     14 03 B0 FD | 	call	#_Audio2_004_play
00c14                 | '    audio.play(14,d4*1000,200,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00c14     0E 0E 06 F6 | 	mov	arg01, #14
00c18     3E 02 00 FF 
00c1c     70 10 06 F6 | 	mov	arg02, ##294000
00c20     C8 12 06 F6 | 	mov	arg03, #200
00c24     0C 14 C6 F9 | 	decod	arg04, #12
00c28     14 16 C6 F9 | 	decod	arg05, #20
00c2c     08 02 00 FF 
00c30     00 18 06 F6 | 	mov	arg06, ##266240
00c34     03 00 00 FF 
00c38     D0 1B 06 F6 | 	mov	arg07, ##2000
00c3c     01 1C 66 F6 | 	neg	arg08, #1
00c40     01 1E 66 F6 | 	neg	arg09, #1
00c44     E0 02 B0 FD | 	call	#_Audio2_004_play
00c48                 | '    audio.play(15,c4*1000,200,4096,$100000,$41000,2000) '16(channel,sample,splfreq,vol,len,loop,delay) 
00c48     0F 0E 06 F6 | 	mov	arg01, #15
00c4c     FF 01 00 FF 
00c50     70 11 06 F6 | 	mov	arg02, ##262000
00c54     C8 12 06 F6 | 	mov	arg03, #200
00c58     0C 14 C6 F9 | 	decod	arg04, #12
00c5c     14 16 C6 F9 | 	decod	arg05, #20
00c60     08 02 00 FF 
00c64     00 18 06 F6 | 	mov	arg06, ##266240
00c68     03 00 00 FF 
00c6c     D0 1B 06 F6 | 	mov	arg07, ##2000
00c70     01 1C 66 F6 | 	neg	arg08, #1
00c74     01 1E 66 F6 | 	neg	arg09, #1
00c78     AC 02 B0 FD | 	call	#_Audio2_004_play
00c7c     9C FC 9F FD | 	jmp	#LR__0005
00c80     E7 F0 03 F6 | 	mov	ptra, fp
00c84     F2 00 A0 FD | 	call	#popregs_
00c88                 | _drivertest_ret
00c88     2D 00 64 FD | 	ret
00c8c                 | 
00c8c                 | ' 
00c8c                 | ' '--------------------------------------------------------------
00c8c                 | ' '---------- Init the variables, start the cog. ----------------
00c8c                 | ' '--------------------------------------------------------------
00c8c                 | ' 
00c8c                 | ' pub start(mbox,scope,cache) :cog,base | iii
00c8c                 | _Audio2_004_start
00c8c     04 CA 05 F6 | 	mov	COUNT_, #4
00c90     E8 00 A0 FD | 	call	#pushregs_
00c94     07 21 02 F6 | 	mov	local01, arg01
00c98                 | ' 
00c98                 | ' ' mbox: PSRAM mailbox or 0 if no PSRAM
00c98                 | ' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
00c98                 | ' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
00c98                 | ' 
00c98                 | ' mailboxaddr:=mbox 
00c98     FA 20 62 FC | 	wrlong	local01, objptr
00c9c                 | ' scope_ptr:=scope
00c9c     04 F4 05 F1 | 	add	objptr, #4
00ca0     FA 10 62 FC | 	wrlong	arg02, objptr
00ca4                 | ' cache_ptr:=cache
00ca4     04 F4 05 F1 | 	add	objptr, #4
00ca8     FA 12 62 FC | 	wrlong	arg03, objptr
00cac                 | ' base:=@channel0[0]
00cac     04 F4 05 F1 | 	add	objptr, #4
00cb0     FA 22 02 F6 | 	mov	local02, objptr
00cb4                 | ' 
00cb4                 | ' repeat iii from 0 to 15
00cb4     00 24 06 F6 | 	mov	local03, #0
00cb8     0C F4 85 F1 | 	sub	objptr, #12
00cbc     D7 1A 49 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
00cc0                 | LR__0010
00cc0                 | '   long[base+64*iii]:=0
00cc0     11 21 02 F6 | 	mov	local01, local02
00cc4     12 03 02 F6 | 	mov	result2, local03
00cc8     06 02 66 F0 | 	shl	result2, #6
00ccc     01 21 02 F1 | 	add	local01, result2
00cd0     10 01 68 FC | 	wrlong	#0, local01
00cd4                 | '   long[base+64*iii+4]:=0  		
00cd4     11 21 02 F6 | 	mov	local01, local02
00cd8     12 03 02 F6 | 	mov	result2, local03
00cdc     06 02 66 F0 | 	shl	result2, #6
00ce0     01 21 02 F1 | 	add	local01, result2
00ce4     04 20 06 F1 | 	add	local01, #4
00ce8     10 01 68 FC | 	wrlong	#0, local01
00cec                 | '   long[base+64*iii+8]:=0
00cec     11 27 02 F6 | 	mov	local04, local02
00cf0     12 21 02 F6 | 	mov	local01, local03
00cf4     06 20 66 F0 | 	shl	local01, #6
00cf8     10 27 02 F1 | 	add	local04, local01
00cfc     08 26 06 F1 | 	add	local04, #8
00d00     13 01 68 FC | 	wrlong	#0, local04
00d04                 | '   long[base+64*iii+12]:=0
00d04     11 27 02 F6 | 	mov	local04, local02
00d08     12 21 02 F6 | 	mov	local01, local03
00d0c     06 20 66 F0 | 	shl	local01, #6
00d10     10 27 02 F1 | 	add	local04, local01
00d14     0C 26 06 F1 | 	add	local04, #12
00d18     13 01 68 FC | 	wrlong	#0, local04
00d1c                 | '   long[base+64*iii+16]:=0
00d1c     11 27 02 F6 | 	mov	local04, local02
00d20     12 21 02 F6 | 	mov	local01, local03
00d24     06 20 66 F0 | 	shl	local01, #6
00d28     10 27 02 F1 | 	add	local04, local01
00d2c     10 26 06 F1 | 	add	local04, #16
00d30     13 01 68 FC | 	wrlong	#0, local04
00d34                 | '   long[base+64*iii+20]:=0
00d34     11 27 02 F6 | 	mov	local04, local02
00d38     12 21 02 F6 | 	mov	local01, local03
00d3c     06 20 66 F0 | 	shl	local01, #6
00d40     10 27 02 F1 | 	add	local04, local01
00d44     14 26 06 F1 | 	add	local04, #20
00d48     13 01 68 FC | 	wrlong	#0, local04
00d4c                 | '   long[base+64*iii+24]:=0
00d4c     11 27 02 F6 | 	mov	local04, local02
00d50     12 21 02 F6 | 	mov	local01, local03
00d54     06 20 66 F0 | 	shl	local01, #6
00d58     10 27 02 F1 | 	add	local04, local01
00d5c     18 26 06 F1 | 	add	local04, #24
00d60     13 01 68 FC | 	wrlong	#0, local04
00d64                 | '   long[base+64*iii+28]:=0
00d64     11 27 02 F6 | 	mov	local04, local02
00d68     12 21 02 F6 | 	mov	local01, local03
00d6c     06 20 66 F0 | 	shl	local01, #6
00d70     10 27 02 F1 | 	add	local04, local01
00d74     1C 26 06 F1 | 	add	local04, #28
00d78     13 01 68 FC | 	wrlong	#0, local04
00d7c                 | '   word[base+64*iii+32]:=8192
00d7c     11 27 02 F6 | 	mov	local04, local02
00d80     12 21 02 F6 | 	mov	local01, local03
00d84     06 20 66 F0 | 	shl	local01, #6
00d88     10 27 02 F1 | 	add	local04, local01
00d8c     20 26 06 F1 | 	add	local04, #32
00d90     10 00 80 FF 
00d94     13 01 58 FC | 	wrword	##8192, local04
00d98                 | '   word[base+64*iii+34]:=8192
00d98     11 27 02 F6 | 	mov	local04, local02
00d9c     12 21 02 F6 | 	mov	local01, local03
00da0     06 20 66 F0 | 	shl	local01, #6
00da4     10 27 02 F1 | 	add	local04, local01
00da8     22 26 06 F1 | 	add	local04, #34
00dac     10 00 80 FF 
00db0     13 01 58 FC | 	wrword	##8192, local04
00db4                 | '   long[base+64*iii+36]:=0
00db4     11 27 02 F6 | 	mov	local04, local02
00db8     12 21 02 F6 | 	mov	local01, local03
00dbc     06 20 66 F0 | 	shl	local01, #6
00dc0     10 27 02 F1 | 	add	local04, local01
00dc4     24 26 06 F1 | 	add	local04, #36
00dc8     13 01 68 FC | 	wrlong	#0, local04
00dcc                 | '   long[base+64*iii+40]:=0
00dcc     11 27 02 F6 | 	mov	local04, local02
00dd0     12 21 02 F6 | 	mov	local01, local03
00dd4     06 20 66 F0 | 	shl	local01, #6
00dd8     10 27 02 F1 | 	add	local04, local01
00ddc     28 26 06 F1 | 	add	local04, #40
00de0     13 01 68 FC | 	wrlong	#0, local04
00de4                 | '   long[base+64*iii+44]:=0
00de4     11 27 02 F6 | 	mov	local04, local02
00de8     12 21 02 F6 | 	mov	local01, local03
00dec     06 20 66 F0 | 	shl	local01, #6
00df0     10 27 02 F1 | 	add	local04, local01
00df4     2C 26 06 F1 | 	add	local04, #44
00df8     13 01 68 FC | 	wrlong	#0, local04
00dfc                 | '   long[base+64*iii+48]:=0
00dfc     11 27 02 F6 | 	mov	local04, local02
00e00     12 21 02 F6 | 	mov	local01, local03
00e04     06 20 66 F0 | 	shl	local01, #6
00e08     10 27 02 F1 | 	add	local04, local01
00e0c     30 26 06 F1 | 	add	local04, #48
00e10     13 01 68 FC | 	wrlong	#0, local04
00e14                 | '   long[base+64*iii+52]:=0
00e14     11 27 02 F6 | 	mov	local04, local02
00e18     12 21 02 F6 | 	mov	local01, local03
00e1c     06 20 66 F0 | 	shl	local01, #6
00e20     10 27 02 F1 | 	add	local04, local01
00e24     34 26 06 F1 | 	add	local04, #52
00e28     13 01 68 FC | 	wrlong	#0, local04
00e2c                 | '   freqs[iii]:=440000
00e2c     12 27 02 F6 | 	mov	local04, local03
00e30     02 26 66 F0 | 	shl	local04, #2
00e34     02 00 00 FF 
00e38     0C F4 05 F1 | 	add	objptr, ##1036
00e3c     FA 26 02 F1 | 	add	local04, objptr
00e40     5B 03 80 FF 
00e44     13 81 69 FC | 	wrlong	##440000, local04
00e48                 | '   delays[iii]:=0
00e48     12 27 02 F6 | 	mov	local04, local03
00e4c     01 26 66 F0 | 	shl	local04, #1
00e50     40 F4 05 F1 | 	add	objptr, #64
00e54     FA 26 02 F1 | 	add	local04, objptr
00e58     13 01 58 FC | 	wrword	#0, local04
00e5c                 | '   volumes[iii]:=4096
00e5c     12 27 02 F6 | 	mov	local04, local03
00e60     01 26 66 F0 | 	shl	local04, #1
00e64     20 F4 05 F1 | 	add	objptr, #32
00e68     FA 26 02 F1 | 	add	local04, objptr
00e6c     08 00 80 FF 
00e70     13 01 58 FC | 	wrword	##4096, local04
00e74                 | '   waveforms[iii]:=0
00e74     12 27 02 F6 | 	mov	local04, local03
00e78     02 26 66 F0 | 	shl	local04, #2
00e7c     20 F4 05 F1 | 	add	objptr, #32
00e80     FA 26 02 F1 | 	add	local04, objptr
00e84     13 01 68 FC | 	wrlong	#0, local04
00e88                 | '   envelopes[iii]:=0
00e88     12 27 02 F6 | 	mov	local04, local03
00e8c     02 26 66 F0 | 	shl	local04, #2
00e90     40 F4 05 F1 | 	add	objptr, #64
00e94     FA 26 02 F1 | 	add	local04, objptr
00e98     13 01 68 FC | 	wrlong	#0, local04
00e9c                 | '   lengths[iii]:=1000
00e9c     12 27 02 F6 | 	mov	local04, local03
00ea0     01 26 66 F0 | 	shl	local04, #1
00ea4     40 F4 05 F1 | 	add	objptr, #64
00ea8     FA 26 02 F1 | 	add	local04, objptr
00eac     01 00 80 FF 
00eb0     13 D1 5B FC | 	wrword	##1000, local04
00eb4                 | '   pans[iii]:=8192
00eb4     12 27 02 F6 | 	mov	local04, local03
00eb8     01 26 66 F0 | 	shl	local04, #1
00ebc     20 F4 05 F1 | 	add	objptr, #32
00ec0     FA 26 02 F1 | 	add	local04, objptr
00ec4     10 00 80 FF 
00ec8     13 01 58 FC | 	wrword	##8192, local04
00ecc                 | '   sustains[iii]:=255
00ecc     12 27 02 F6 | 	mov	local04, local03
00ed0     01 26 66 F0 | 	shl	local04, #1
00ed4     20 F4 05 F1 | 	add	objptr, #32
00ed8     FA 26 02 F1 | 	add	local04, objptr
00edc     13 FF 59 FC | 	wrword	#255, local04
00ee0     01 24 06 F1 | 	add	local03, #1
00ee4     10 24 56 F2 | 	cmps	local03, #16 wc
00ee8     02 00 00 FF 
00eec     4C F5 85 F1 | 	sub	objptr, ##1356
00ef0     CC FD 9F CD |  if_b	jmp	#LR__0010
00ef4                 | LR__0011
00ef4                 | '   
00ef4                 | ' cog:=coginit(16,@audio,@mailboxaddr)
00ef4     FB 10 02 F6 | 	mov	arg02, ptr__Audio2_004_dat__
00ef8     FA 12 02 F6 | 	mov	arg03, objptr
00efc     10 26 06 F6 | 	mov	local04, #16
00f00     28 12 62 FD | 	setq	arg03
00f04     08 27 F2 FC | 	coginit	local04, arg02 wc
00f08     01 26 66 C6 |  if_b	neg	local04, #1
00f0c                 | ' waitms(10)
00f0c     0A 0E 06 F6 | 	mov	arg01, #10
00f10     88 06 B0 FD | 	call	#__system___waitms
00f14                 | ' return cog,base
00f14     11 03 02 F6 | 	mov	result2, local02
00f18     13 01 02 F6 | 	mov	result1, local04
00f1c     E7 F0 03 F6 | 	mov	ptra, fp
00f20     F2 00 A0 FD | 	call	#popregs_
00f24                 | _Audio2_004_start_ret
00f24     2D 00 64 FD | 	ret
00f28                 | 
00f28                 | ' 
00f28                 | ' pub play (channel, frequency=-1, delay=-1, volume=-1, waveform=-1, envelope=-1, length=-1, pan=-1, sustain=-1) | base2
00f28                 | _Audio2_004_play
00f28     0B CA 05 F6 | 	mov	COUNT_, #11
00f2c     E8 00 A0 FD | 	call	#pushregs_
00f30     07 21 02 F6 | 	mov	local01, arg01
00f34     08 23 02 F6 | 	mov	local02, arg02
00f38     09 25 02 F6 | 	mov	local03, arg03
00f3c     0A 27 02 F6 | 	mov	local04, arg04
00f40     0B 29 02 F6 | 	mov	local05, arg05
00f44     0C 2B 02 F6 | 	mov	local06, arg06
00f48     0D 2D 02 F6 | 	mov	local07, arg07
00f4c     0E 2F 02 F6 | 	mov	local08, arg08
00f50     0F 31 02 F6 | 	mov	local09, arg09
00f54                 | ' 
00f54                 | ' if frequency==(-1)
00f54     FF FF 7F FF 
00f58     FF 23 0E F2 | 	cmp	local02, ##-1 wz
00f5c     20 00 90 5D |  if_ne	jmp	#LR__0020
00f60                 | '   frequency:=freqs[channel]
00f60     10 23 02 F6 | 	mov	local02, local01
00f64     02 22 66 F0 | 	shl	local02, #2
00f68     FA 32 02 F6 | 	mov	local10, objptr
00f6c     02 00 00 FF 
00f70     0C 32 06 F1 | 	add	local10, ##1036
00f74     19 23 02 F1 | 	add	local02, local10
00f78     11 23 02 FB | 	rdlong	local02, local02
00f7c     1C 00 90 FD | 	jmp	#LR__0021
00f80                 | LR__0020
00f80                 | ' else
00f80                 | '   freqs[channel]:=frequency
00f80     10 35 02 F6 | 	mov	local11, local01
00f84     02 34 66 F0 | 	shl	local11, #2
00f88     FA 32 02 F6 | 	mov	local10, objptr
00f8c     02 00 00 FF 
00f90     0C 32 06 F1 | 	add	local10, ##1036
00f94     19 35 02 F1 | 	add	local11, local10
00f98     1A 23 62 FC | 	wrlong	local02, local11
00f9c                 | LR__0021
00f9c                 | '   
00f9c                 | ' if delay==(-1)
00f9c     FF FF 7F FF 
00fa0     FF 25 0E F2 | 	cmp	local03, ##-1 wz
00fa4     20 00 90 5D |  if_ne	jmp	#LR__0022
00fa8                 | '   delay:=delays[channel]
00fa8     10 33 02 F6 | 	mov	local10, local01
00fac     01 32 66 F0 | 	shl	local10, #1
00fb0     FA 34 02 F6 | 	mov	local11, objptr
00fb4     02 00 00 FF 
00fb8     4C 34 06 F1 | 	add	local11, ##1100
00fbc     1A 33 02 F1 | 	add	local10, local11
00fc0     19 25 E2 FA | 	rdword	local03, local10
00fc4     1C 00 90 FD | 	jmp	#LR__0023
00fc8                 | LR__0022
00fc8                 | ' else
00fc8                 | '   delays[channel]:=delay
00fc8     10 33 02 F6 | 	mov	local10, local01
00fcc     01 32 66 F0 | 	shl	local10, #1
00fd0     FA 34 02 F6 | 	mov	local11, objptr
00fd4     02 00 00 FF 
00fd8     4C 34 06 F1 | 	add	local11, ##1100
00fdc     1A 33 02 F1 | 	add	local10, local11
00fe0     19 25 52 FC | 	wrword	local03, local10
00fe4                 | LR__0023
00fe4                 | '   
00fe4                 | ' if volume==(-1)      
00fe4     FF FF 7F FF 
00fe8     FF 27 0E F2 | 	cmp	local04, ##-1 wz
00fec     20 00 90 5D |  if_ne	jmp	#LR__0024
00ff0                 | '   volume:=volumes[channel]
00ff0     10 33 02 F6 | 	mov	local10, local01
00ff4     01 32 66 F0 | 	shl	local10, #1
00ff8     FA 34 02 F6 | 	mov	local11, objptr
00ffc     02 00 00 FF 
01000     6C 34 06 F1 | 	add	local11, ##1132
01004     1A 33 02 F1 | 	add	local10, local11
01008     19 27 E2 FA | 	rdword	local04, local10
0100c     1C 00 90 FD | 	jmp	#LR__0025
01010                 | LR__0024
01010                 | ' else
01010                 | '   volumes[channel]:=volume
01010     10 33 02 F6 | 	mov	local10, local01
01014     01 32 66 F0 | 	shl	local10, #1
01018     FA 34 02 F6 | 	mov	local11, objptr
0101c     02 00 00 FF 
01020     6C 34 06 F1 | 	add	local11, ##1132
01024     1A 33 02 F1 | 	add	local10, local11
01028     19 27 52 FC | 	wrword	local04, local10
0102c                 | LR__0025
0102c                 | '   
0102c                 | ' if waveform==(-1)
0102c     FF FF 7F FF 
01030     FF 29 0E F2 | 	cmp	local05, ##-1 wz
01034     20 00 90 5D |  if_ne	jmp	#LR__0026
01038                 | '   waveform:=waveforms[channel]
01038     10 35 02 F6 | 	mov	local11, local01
0103c     02 34 66 F0 | 	shl	local11, #2
01040     FA 32 02 F6 | 	mov	local10, objptr
01044     02 00 00 FF 
01048     8C 32 06 F1 | 	add	local10, ##1164
0104c     19 35 02 F1 | 	add	local11, local10
01050     1A 29 02 FB | 	rdlong	local05, local11
01054     1C 00 90 FD | 	jmp	#LR__0027
01058                 | LR__0026
01058                 | ' else
01058                 | '   waveforms[channel]:=waveform
01058     10 35 02 F6 | 	mov	local11, local01
0105c     02 34 66 F0 | 	shl	local11, #2
01060     FA 32 02 F6 | 	mov	local10, objptr
01064     02 00 00 FF 
01068     8C 32 06 F1 | 	add	local10, ##1164
0106c     19 35 02 F1 | 	add	local11, local10
01070     1A 29 62 FC | 	wrlong	local05, local11
01074                 | LR__0027
01074                 | '   
01074                 | ' if envelope==(-1)
01074     FF FF 7F FF 
01078     FF 2B 0E F2 | 	cmp	local06, ##-1 wz
0107c     20 00 90 5D |  if_ne	jmp	#LR__0028
01080                 | '   envelope:=envelopes[channel]
01080     10 35 02 F6 | 	mov	local11, local01
01084     02 34 66 F0 | 	shl	local11, #2
01088     FA 32 02 F6 | 	mov	local10, objptr
0108c     02 00 00 FF 
01090     CC 32 06 F1 | 	add	local10, ##1228
01094     19 35 02 F1 | 	add	local11, local10
01098     1A 2B 02 FB | 	rdlong	local06, local11
0109c     1C 00 90 FD | 	jmp	#LR__0029
010a0                 | LR__0028
010a0                 | ' else
010a0                 | '   envelopes[channel]:=envelope
010a0     10 35 02 F6 | 	mov	local11, local01
010a4     02 34 66 F0 | 	shl	local11, #2
010a8     FA 32 02 F6 | 	mov	local10, objptr
010ac     02 00 00 FF 
010b0     CC 32 06 F1 | 	add	local10, ##1228
010b4     19 35 02 F1 | 	add	local11, local10
010b8     1A 2B 62 FC | 	wrlong	local06, local11
010bc                 | LR__0029
010bc                 | '   
010bc                 | ' if length==(-1)
010bc     FF FF 7F FF 
010c0     FF 2D 0E F2 | 	cmp	local07, ##-1 wz
010c4     20 00 90 5D |  if_ne	jmp	#LR__0030
010c8                 | '   length:=lengths[channel]
010c8     10 33 02 F6 | 	mov	local10, local01
010cc     01 32 66 F0 | 	shl	local10, #1
010d0     FA 34 02 F6 | 	mov	local11, objptr
010d4     02 00 00 FF 
010d8     0C 35 06 F1 | 	add	local11, ##1292
010dc     1A 33 02 F1 | 	add	local10, local11
010e0     19 2D E2 FA | 	rdword	local07, local10
010e4     1C 00 90 FD | 	jmp	#LR__0031
010e8                 | LR__0030
010e8                 | ' else
010e8                 | '   lengths[channel]:=length
010e8     10 33 02 F6 | 	mov	local10, local01
010ec     01 32 66 F0 | 	shl	local10, #1
010f0     FA 34 02 F6 | 	mov	local11, objptr
010f4     02 00 00 FF 
010f8     0C 35 06 F1 | 	add	local11, ##1292
010fc     1A 33 02 F1 | 	add	local10, local11
01100     19 2D 52 FC | 	wrword	local07, local10
01104                 | LR__0031
01104                 | '   
01104                 | ' if pan==(-1)
01104     FF FF 7F FF 
01108     FF 2F 0E F2 | 	cmp	local08, ##-1 wz
0110c     20 00 90 5D |  if_ne	jmp	#LR__0032
01110                 | '   pan:=pans[channel]
01110     10 33 02 F6 | 	mov	local10, local01
01114     01 32 66 F0 | 	shl	local10, #1
01118     FA 34 02 F6 | 	mov	local11, objptr
0111c     02 00 00 FF 
01120     2C 35 06 F1 | 	add	local11, ##1324
01124     1A 33 02 F1 | 	add	local10, local11
01128     19 2F E2 FA | 	rdword	local08, local10
0112c     1C 00 90 FD | 	jmp	#LR__0033
01130                 | LR__0032
01130                 | ' else
01130                 | '   pans[channel]:=pan
01130     10 33 02 F6 | 	mov	local10, local01
01134     01 32 66 F0 | 	shl	local10, #1
01138     FA 34 02 F6 | 	mov	local11, objptr
0113c     02 00 00 FF 
01140     2C 35 06 F1 | 	add	local11, ##1324
01144     1A 33 02 F1 | 	add	local10, local11
01148     19 2F 52 FC | 	wrword	local08, local10
0114c                 | LR__0033
0114c                 | '  
0114c                 | ' if sustain==(-1)
0114c     FF FF 7F FF 
01150     FF 31 0E F2 | 	cmp	local09, ##-1 wz
01154     20 00 90 5D |  if_ne	jmp	#LR__0034
01158                 | '   sustain:=sustains[channel]
01158     10 33 02 F6 | 	mov	local10, local01
0115c     01 32 66 F0 | 	shl	local10, #1
01160     FA 34 02 F6 | 	mov	local11, objptr
01164     02 00 00 FF 
01168     4C 35 06 F1 | 	add	local11, ##1356
0116c     1A 33 02 F1 | 	add	local10, local11
01170     19 31 E2 FA | 	rdword	local09, local10
01174     1C 00 90 FD | 	jmp	#LR__0035
01178                 | LR__0034
01178                 | ' else
01178                 | '   sustains[channel]:=sustain
01178     10 33 02 F6 | 	mov	local10, local01
0117c     01 32 66 F0 | 	shl	local10, #1
01180     FA 34 02 F6 | 	mov	local11, objptr
01184     02 00 00 FF 
01188     4C 35 06 F1 | 	add	local11, ##1356
0118c     1A 33 02 F1 | 	add	local10, local11
01190     19 31 52 FC | 	wrword	local09, local10
01194                 | LR__0035
01194     16 35 52 F6 | 	abs	local11, local07 wc
01198     C2 B9 80 FF 
0119c     1A DF 19 FD | 	qdiv	##24347887, local11
011a0                 | '                 
011a0                 | ' length:=24347887/length  
011a0     18 34 62 FD | 	getqx	local11
011a4     6D 22 06 FD | 	qmul	local02, #109
011a8     1A 2D 82 F6 | 	negc	local07, local11
011ac                 | ' 'debug(udec(sustain))
011ac                 | ' base2:=@channel0[0]+64*channel
011ac     FA 22 02 F6 | 	mov	local02, objptr
011b0     0C 22 06 F1 | 	add	local02, #12
011b4     06 20 66 F0 | 	shl	local01, #6
011b8     10 23 02 F1 | 	add	local02, local01
011bc                 | ' long[base2+20]:=waveform+$C0000000 
011bc     00 00 60 FF 
011c0     00 28 06 F1 | 	add	local05, ##-1073741824
011c4     11 33 02 F6 | 	mov	local10, local02
011c8     14 32 06 F1 | 	add	local10, #20
011cc     19 29 62 FC | 	wrlong	local05, local10
011d0                 | ' long[base2+28]:= 2048
011d0     11 35 02 F6 | 	mov	local11, local02
011d4     1C 34 06 F1 | 	add	local11, #28
011d8     04 00 80 FF 
011dc     1A 01 68 FC | 	wrlong	##2048, local11
011e0                 | ' long[base2+24]:= 0
011e0     11 35 02 F6 | 	mov	local11, local02
011e4     18 34 06 F1 | 	add	local11, #24
011e8     1A 01 68 FC | 	wrlong	#0, local11
011ec                 | ' word[base2+32]:=volume
011ec     11 35 02 F6 | 	mov	local11, local02
011f0     20 34 06 F1 | 	add	local11, #32
011f4     1A 27 52 FC | 	wrword	local04, local11
011f8                 | ' word[base2+32]:=pan
011f8     11 35 02 F6 | 	mov	local11, local02
011fc     20 34 06 F1 | 	add	local11, #32
01200     1A 2F 52 FC | 	wrword	local08, local11
01204                 | ' long[base2+36]:=((frequency*109)/1000)*3574 ' (frequency*389566)/1000  freq*3574*109/1000
01204     18 34 62 FD | 	getqx	local11
01208     1A 33 52 F6 | 	abs	local10, local11 wc
0120c     01 00 00 FF 
01210     E8 33 16 FD | 	qdiv	local10, ##1000
01214     18 32 62 FD | 	getqx	local10
01218     19 33 82 F6 | 	negc	local10, local10
0121c     06 00 00 FF 
01220     F6 33 06 FD | 	qmul	local10, ##3574
01224     11 33 02 F6 | 	mov	local10, local02
01228     24 32 06 F1 | 	add	local10, #36
0122c                 | ' long[base2+44]:=envelope
0122c     11 35 02 F6 | 	mov	local11, local02
01230     2C 34 06 F1 | 	add	local11, #44
01234                 | ' long[base2+48]:=length
01234                 | ' long[base2+52]:=sustain
01234                 | ' waitms(delay)
01234     12 0F 02 F6 | 	mov	arg01, local03
01238     18 2E 62 FD | 	getqx	local08
0123c     19 2F 62 FC | 	wrlong	local08, local10
01240     1A 2B 62 FC | 	wrlong	local06, local11
01244     11 35 02 F6 | 	mov	local11, local02
01248     30 34 06 F1 | 	add	local11, #48
0124c     1A 2D 62 FC | 	wrlong	local07, local11
01250     34 22 06 F1 | 	add	local02, #52
01254     11 31 62 FC | 	wrlong	local09, local02
01258     40 03 B0 FD | 	call	#__system___waitms
0125c     E7 F0 03 F6 | 	mov	ptra, fp
01260     F2 00 A0 FD | 	call	#popregs_
01264                 | _Audio2_004_play_ret
01264     2D 00 64 FD | 	ret
01268                 | 
01268                 | ' 
01268                 | ' '..............................................................................
01268                 | ' 
01268                 | ' {{
01268                 | ' }}
01268                 | ' PUB startx(freq, burst, delay, desiredcog) : cog,mail | driverAddr
01268                 | _psram_startx
01268     04 CA 05 F6 | 	mov	COUNT_, #4
0126c     E8 00 A0 FD | 	call	#pushregs_
01270     07 21 02 F6 | 	mov	local01, arg01
01274     09 23 02 F6 | 	mov	local02, arg03
01278     0A 25 02 F6 | 	mov	local03, arg04
0127c                 | '     stop() ' restart driver if required
0127c     74 01 B0 FD | 	call	#_psram_stop
01280     00 20 0E F2 | 	cmp	local01, #0 wz
01284     14 20 06 AB |  if_e	rdlong	local01, #20
01288     10 11 52 F6 | 	abs	arg02, local01 wc
0128c     A1 07 00 FF 
01290     40 10 16 FD | 	qdiv	arg02, ##1000000
01294                 | ' 
01294                 | '     ' use current frequency if none specified
01294                 | ' 
01294                 | '     if freq == 0 
01294                 | '         freq := clkfreq 
01294                 | ' 
01294                 | '     ' compute the device burst size including overheads to keep CS low time below 8us
01294                 | ' 
01294                 | '     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
01294                 | '     if burst < 0
01294                 | '         return ERR_TOO_SLOW,0 ' P2 frequency is too low for any 8us transfers
01294     18 10 62 FD | 	getqx	arg02
01298     08 15 82 F6 | 	negc	arg04, arg02
0129c     03 14 66 F0 | 	shl	arg04, #3
012a0     84 14 86 F1 | 	sub	arg04, #132
012a4     04 14 46 F0 | 	shr	arg04, #4
012a8     04 14 66 F0 | 	shl	arg04, #4
012ac     00 14 56 F2 | 	cmps	arg04, #0 wc
012b0     00 02 06 C6 |  if_b	mov	result2, #0
012b4     0E 00 66 C6 |  if_b	neg	result1, #14
012b8     2C 01 90 CD |  if_b	jmp	#LR__0044
012bc                 | ' 
012bc                 | '     ' compute the input delay
012bc                 | ' 
012bc                 | '     if delay <= 0
012bc     01 22 56 F2 | 	cmps	local02, #1 wc
012c0     10 00 90 3D |  if_ae	jmp	#LR__0040
012c4                 | '         delay := lookupDelay(freq)
012c4     10 0F 02 F6 | 	mov	arg01, local01
012c8     88 02 B0 FD | 	call	#_psram_lookupDelay
012cc     00 23 02 F6 | 	mov	local02, result1
012d0     04 00 90 FD | 	jmp	#LR__0041
012d4                 | LR__0040
012d4                 | '     else
012d4                 | '         delay <#= $f ' limit to 15
012d4     0F 22 66 F3 | 	fles	local02, #15
012d8                 | LR__0041
012d8                 | ' 
012d8                 | '     ' create our lock
012d8                 | ' 
012d8                 | '     driverlock := LOCKNEW()  
012d8     00 00 06 F6 | 	mov	result1, #0
012dc     04 00 62 FD | 	locknew	result1
012e0     04 FD 05 F1 | 	add	ptr__psram_dat__, #260
012e4     FE 00 62 FC | 	wrlong	result1, ptr__psram_dat__
012e8                 | '     if driverlock == -1
012e8     04 FD 85 F1 | 	sub	ptr__psram_dat__, #260
012ec     FF FF 7F FF 
012f0     FF 01 0E F2 | 	cmp	result1, ##-1 wz
012f4                 | '         return ERR_NO_LOCK,0
012f4     00 02 06 A6 |  if_e	mov	result2, #0
012f8     1A 00 66 A6 |  if_e	neg	result1, #26
012fc     E8 00 90 AD |  if_e	jmp	#LR__0044
01300                 | ' 
01300                 | '     ' patch in the proper data and HUB addresses to the startup structure
01300                 | ' 
01300                 | '     long[@startupData][0]:=clkfreq
01300     14 20 06 FB | 	rdlong	local01, #20
01304     28 FD 05 F1 | 	add	ptr__psram_dat__, #296
01308     FE 20 62 FC | 	wrlong	local01, ptr__psram_dat__
0130c                 | ' '    long[@startupData][1]:=$1000_0000
0130c                 | '     long[@startupData][5]:=@deviceData
0130c     FE 20 02 F6 | 	mov	local01, ptr__psram_dat__
01310     20 20 06 F1 | 	add	local01, #32
01314     FE 10 02 F6 | 	mov	arg02, ptr__psram_dat__
01318     14 10 06 F1 | 	add	arg02, #20
0131c     08 21 62 FC | 	wrlong	local01, arg02
01320                 | '     long[@startupData][6]:=@qosData
01320     FE 20 02 F6 | 	mov	local01, ptr__psram_dat__
01324     A0 20 06 F1 | 	add	local01, #160
01328     FE 10 02 F6 | 	mov	arg02, ptr__psram_dat__
0132c     18 10 06 F1 | 	add	arg02, #24
01330     08 21 62 FC | 	wrlong	local01, arg02
01334                 | ' 
01334                 | ' 
01334                 | '     long[@startupData][7]:=mailbox
01334     FE 20 02 F6 | 	mov	local01, ptr__psram_dat__
01338     1C 20 06 F1 | 	add	local01, #28
0133c     DF 03 80 FF 
01340     10 01 6A FC | 	wrlong	##507648, local01
01344                 | '   
01344                 | '     ' setup some default bank and QoS parameter values
01344                 | ' 
01344                 | '     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
01344     20 FC 05 F1 | 	add	ptr__psram_dat__, #32
01348     FE 0E 02 F6 | 	mov	arg01, ptr__psram_dat__
0134c     48 FD 85 F1 | 	sub	ptr__psram_dat__, #328
01350     10 14 66 F0 | 	shl	arg04, #16
01354     0C 22 66 F0 | 	shl	local02, #12
01358     11 15 42 F5 | 	or	arg04, local02
0135c     18 14 46 F5 | 	or	arg04, #24
01360     0A 11 02 F6 | 	mov	arg02, arg04
01364     02 12 06 F6 | 	mov	arg03, #2
01368     E0 00 A0 FD | 	call	#\builtin_longfill_
0136c                 | '     longfill(@qosData, $FFFF0000, 8)
0136c     FE 0E 02 F6 | 	mov	arg01, ptr__psram_dat__
01370     C8 0F 06 F1 | 	add	arg01, #456
01374     07 12 06 F6 | 	mov	arg03, #7
01378     28 12 62 FD | 	setq	arg03
0137c     80 FF FF FF 
01380     07 01 68 FC | 	wrlong	##-65536, arg01
01384                 | ' 
01384                 | '     ' get the address of the PSRAM memory driver so we can start it
01384                 | ' 
01384                 | '     driverAddr:= driver.getDriverAddr()
01384                 | '     return @driver_start
01384     FD 10 02 F6 | 	mov	arg02, ptr__psram16drv_dat__
01388     20 10 06 F1 | 	add	arg02, #32
0138c                 | ' 
0138c                 | '     ' start the PSRAM memory driver and wait for it to complete initialization
0138c                 | ' 
0138c                 | '     if desiredcog < 0
0138c     00 24 56 F2 | 	cmps	local03, #0 wc
01390                 | '         desiredcog := NEWCOG
01390     10 24 06 C6 |  if_b	mov	local03, #16
01394                 | '     drivercog := coginit(desiredcog, driverAddr, @startupData)
01394     FE 12 02 F6 | 	mov	arg03, ptr__psram_dat__
01398     28 13 06 F1 | 	add	arg03, #296
0139c     12 27 02 F6 | 	mov	local04, local03
013a0     28 12 62 FD | 	setq	arg03
013a4     08 27 F2 FC | 	coginit	local04, arg02 wc
013a8     01 26 66 C6 |  if_b	neg	local04, #1
013ac     00 FD 05 F1 | 	add	ptr__psram_dat__, #256
013b0     FE 26 62 FC | 	wrlong	local04, ptr__psram_dat__
013b4     00 FD 85 F1 | 	sub	ptr__psram_dat__, #256
013b8     D7 08 48 FB | 	callpa	#(@LR__0043-@LR__0042)>>2,fcache_load_ptr_
013bc                 | '     repeat until long[@startupData] == 0 
013bc                 | LR__0042
013bc     FE 26 02 F6 | 	mov	local04, ptr__psram_dat__
013c0     28 27 06 F1 | 	add	local04, #296
013c4     13 27 0A FB | 	rdlong	local04, local04 wz
013c8     F0 FF 9F 5D |  if_ne	jmp	#LR__0042
013cc                 | LR__0043
013cc                 | ' 
013cc                 | '     return drivercog,long[@startupData][7]
013cc     00 FD 05 F1 | 	add	ptr__psram_dat__, #256
013d0     FE 00 02 FB | 	rdlong	result1, ptr__psram_dat__
013d4     28 FC 05 F1 | 	add	ptr__psram_dat__, #40
013d8     FE 26 02 F6 | 	mov	local04, ptr__psram_dat__
013dc     1C 26 06 F1 | 	add	local04, #28
013e0     13 03 02 FB | 	rdlong	result2, local04
013e4     28 FD 85 F1 | 	sub	ptr__psram_dat__, #296
013e8                 | LR__0044
013e8     E7 F0 03 F6 | 	mov	ptra, fp
013ec     F2 00 A0 FD | 	call	#popregs_
013f0                 | _psram_startx_ret
013f0     2D 00 64 FD | 	ret
013f4                 | 
013f4                 | ' 
013f4                 | ' '..............................................................................
013f4                 | ' 
013f4                 | ' {{
013f4                 | ' }}
013f4                 | ' PUB stop() : i
013f4                 | _psram_stop
013f4     00 08 06 F6 | 	mov	_var01, #0
013f8                 | '     if drivercog <> -1
013f8     00 FD 05 F1 | 	add	ptr__psram_dat__, #256
013fc     FE 0E 02 FB | 	rdlong	arg01, ptr__psram_dat__
01400     00 FD 85 F1 | 	sub	ptr__psram_dat__, #256
01404     FF FF 7F FF 
01408     FF 0F 0E F2 | 	cmp	arg01, ##-1 wz
0140c     70 00 90 AD |  if_e	jmp	#LR__0053
01410                 | '         cogstop(drivercog) ' a rather brutal stop
01410     00 FD 05 F1 | 	add	ptr__psram_dat__, #256
01414     FE 0E 02 FB | 	rdlong	arg01, ptr__psram_dat__
01418     00 FD 85 F1 | 	sub	ptr__psram_dat__, #256
0141c     03 0E 62 FD | 	cogstop	arg01
01420     D7 26 48 FB | 	callpa	#(@LR__0052-@LR__0050)>>2,fcache_load_ptr_
01424                 | '         repeat i from 0 to 7
01424                 | LR__0050
01424                 | '             if long[mailbox][i*3] < 0
01424     04 01 02 F6 | 	mov	result1, _var01
01428     01 00 66 F0 | 	shl	result1, #1
0142c     04 01 02 F1 | 	add	result1, _var01
01430     02 00 66 F0 | 	shl	result1, #2
01434     DF 03 00 FF 
01438     00 01 06 F1 | 	add	result1, ##507648
0143c     00 01 02 FB | 	rdlong	result1, result1
01440     00 00 56 F2 | 	cmps	result1, #0 wc
01444     1C 00 90 3D |  if_ae	jmp	#LR__0051
01448                 | '                 long[mailbox][i*3] := -ERR_ABORTED ' abort request
01448     04 01 02 F6 | 	mov	result1, _var01
0144c     01 00 66 F0 | 	shl	result1, #1
01450     04 01 02 F1 | 	add	result1, _var01
01454     02 00 66 F0 | 	shl	result1, #2
01458     DF 03 00 FF 
0145c     00 01 06 F1 | 	add	result1, ##507648
01460     00 21 68 FC | 	wrlong	#16, result1
01464                 | LR__0051
01464     01 08 06 F1 | 	add	_var01, #1
01468     08 08 56 F2 | 	cmps	_var01, #8 wc
0146c     B4 FF 9F CD |  if_b	jmp	#LR__0050
01470                 | LR__0052
01470                 | '         drivercog := -1
01470     00 FD 05 F1 | 	add	ptr__psram_dat__, #256
01474     FF FF FF FF 
01478     FE FE 6B FC | 	wrlong	##-1, ptr__psram_dat__
0147c     00 FD 85 F1 | 	sub	ptr__psram_dat__, #256
01480                 | LR__0053
01480                 | '     if driverlock <> -1
01480     04 FD 05 F1 | 	add	ptr__psram_dat__, #260
01484     FE 0A 02 FB | 	rdlong	_var02, ptr__psram_dat__
01488     04 FD 85 F1 | 	sub	ptr__psram_dat__, #260
0148c     FF FF 7F FF 
01490     FF 0B 0E F2 | 	cmp	_var02, ##-1 wz
01494                 | '         LOCKRET(driverlock)
01494     04 FD 05 51 |  if_ne	add	ptr__psram_dat__, #260
01498     FE 0E 02 5B |  if_ne	rdlong	arg01, ptr__psram_dat__
0149c     05 0E 62 5D |  if_ne	lockret	arg01
014a0                 | '         driverlock := -1
014a0     FF FF FF 5F 
014a4     FE FE 6B 5C |  if_ne	wrlong	##-1, ptr__psram_dat__
014a8     04 FD 85 51 |  if_ne	sub	ptr__psram_dat__, #260
014ac     04 01 02 F6 | 	mov	result1, _var01
014b0                 | _psram_stop_ret
014b0     2D 00 64 FD | 	ret
014b4                 | 
014b4                 | ' 
014b4                 | ' '..............................................................................
014b4                 | ' 
014b4                 | ' {{
014b4                 | ' }}
014b4                 | ' PUB write(srcHubAddr, dstAddr, count) : result | mailbox1
014b4                 | _psram_write
014b4                 | ' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
014b4                 | '     if drivercog == -1 ' driver must be running
014b4     00 FD 05 F1 | 	add	ptr__psram_dat__, #256
014b8     FE 08 02 FB | 	rdlong	_var01, ptr__psram_dat__
014bc     00 FD 85 F1 | 	sub	ptr__psram_dat__, #256
014c0     FF FF 7F FF 
014c4     FF 09 0E F2 | 	cmp	_var01, ##-1 wz
014c8                 | '         return ERR_INACTIVE
014c8     0F 00 66 A6 |  if_e	neg	result1, #15
014cc     80 00 90 AD |  if_e	jmp	#LR__0061
014d0                 | '     if count == 0 ' don't even bother writing
014d0     00 12 0E F2 | 	cmp	arg03, #0 wz
014d4                 | '         return 0
014d4     00 00 06 A6 |  if_e	mov	result1, #0
014d8     74 00 90 AD |  if_e	jmp	#LR__0061
014dc                 | '     mailbox1 := mailbox + cogid()*12     ' compute COG's mailbox address
014dc     DF 03 00 FF 
014e0     00 0B 06 F6 | 	mov	_var02, ##507648
014e4     00 00 06 F6 | 	mov	result1, #0
014e8     01 00 62 FD | 	cogid	result1
014ec     00 09 02 F6 | 	mov	_var01, result1
014f0     01 08 66 F0 | 	shl	_var01, #1
014f4     00 09 02 F1 | 	add	_var01, result1
014f8     02 08 66 F0 | 	shl	_var01, #2
014fc     04 0B 02 F1 | 	add	_var02, _var01
01500                 | '     if long[mailbox] < 0
01500     DF 03 00 FF 
01504     00 09 06 FB | 	rdlong	_var01, ##507648
01508     00 08 56 F2 | 	cmps	_var01, #0 wc
0150c                 | '         return ERR_MAILBOX_BUSY
0150c     1C 00 66 C6 |  if_b	neg	result1, #28
01510     3C 00 90 CD |  if_b	jmp	#LR__0061
01514                 | '     long[mailbox1][2] := count
01514     08 0A 06 F1 | 	add	_var02, #8
01518     05 13 62 FC | 	wrlong	arg03, _var02
0151c                 | '     long[mailbox1][1] := srcHubAddr
0151c     04 0A 86 F1 | 	sub	_var02, #4
01520     05 0F 62 FC | 	wrlong	arg01, _var02
01524     04 0A 86 F1 | 	sub	_var02, #4
01528                 | '     long[mailbox1] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
01528     08 0D 02 F6 | 	mov	_var03, arg02
0152c     D9 0C 06 F4 | 	bitl	_var03, #217
01530     00 00 78 FF 
01534     00 08 06 F6 | 	mov	_var01, ##-268435456
01538     06 09 02 F1 | 	add	_var01, _var03
0153c     05 09 62 FC | 	wrlong	_var01, _var02
01540                 | '     repeat
01540                 | LR__0060
01540                 | '         result := long[mailbox1]    
01540     05 0D 02 FB | 	rdlong	_var03, _var02
01544     00 0C 56 F2 | 	cmps	_var03, #0 wc
01548     F4 FF 9F CD |  if_b	jmp	#LR__0060
0154c                 | '     while result < 0   
0154c                 | '     return -result                       'return success or error
0154c     06 01 62 F6 | 	neg	result1, _var03
01550                 | LR__0061
01550                 | _psram_write_ret
01550     2D 00 64 FD | 	ret
01554                 | 
01554                 | ' 
01554                 | ' '..............................................................................
01554                 | ' 
01554                 | ' {{
01554                 | ' }}
01554                 | ' PRI lookupDelay(freq) : delay | profile
01554                 | _psram_lookupDelay
01554                 | '     profile := @delayTable
01554     FE 08 02 F6 | 	mov	_var01, ptr__psram_dat__
01558     08 09 06 F1 | 	add	_var01, #264
0155c                 | '     delay := long[profile][0]
0155c     04 0B 02 FB | 	rdlong	_var02, _var01
01560     D7 16 48 FB | 	callpa	#(@LR__0071-@LR__0070)>>2,fcache_load_ptr_
01564                 | '     repeat while long[profile][1] 
01564                 | LR__0070
01564     04 08 06 F1 | 	add	_var01, #4
01568     04 01 0A FB | 	rdlong	result1, _var01 wz
0156c     04 08 86 F1 | 	sub	_var01, #4
01570     1C 00 90 AD |  if_e	jmp	#LR__0072
01574                 | '         if freq +< long[profile][1] 
01574     04 08 06 F1 | 	add	_var01, #4
01578     04 01 02 FB | 	rdlong	result1, _var01
0157c     04 08 86 F1 | 	sub	_var01, #4
01580     00 0F 12 F2 | 	cmp	arg01, result1 wc
01584                 | '             quit
01584                 | '         profile += 4
01584     04 08 06 31 |  if_ae	add	_var01, #4
01588                 | '         delay++
01588     01 0A 06 31 |  if_ae	add	_var02, #1
0158c     D4 FF 9F 3D |  if_ae	jmp	#LR__0070
01590                 | LR__0071
01590                 | LR__0072
01590     05 01 02 F6 | 	mov	result1, _var02
01594                 | _psram_lookupDelay_ret
01594     2D 00 64 FD | 	ret
01598                 | hubexit
01598     C1 00 80 FD | 	jmp	#cogexit
0159c                 | 
0159c                 | __system___waitms
0159c     07 09 02 F6 | 	mov	_var01, arg01
015a0     1A 0A 62 FD | 	getct	_var02
015a4     14 0C 06 FB | 	rdlong	_var03, #20
015a8     D7 14 48 FB | 	callpa	#(@LR__0081-@LR__0080)>>2,fcache_load_ptr_
015ac                 | LR__0080
015ac     01 00 00 FF 
015b0     E8 09 56 F2 | 	cmps	_var01, ##1000 wc
015b4     1C 00 90 CD |  if_b	jmp	#LR__0082
015b8     06 0B 02 F1 | 	add	_var02, _var03
015bc     05 0F 02 F6 | 	mov	arg01, _var02
015c0     00 0E 66 FA | 	addct1	arg01, #0
015c4     24 22 60 FD | 	waitct1
015c8     01 00 00 FF 
015cc     E8 09 86 F1 | 	sub	_var01, ##1000
015d0     D8 FF 9F FD | 	jmp	#LR__0080
015d4                 | LR__0081
015d4                 | LR__0082
015d4     01 08 56 F2 | 	cmps	_var01, #1 wc
015d8     28 00 90 CD |  if_b	jmp	#LR__0083
015dc     06 09 02 FD | 	qmul	_var01, _var03
015e0     01 00 00 FF 
015e4     E8 13 06 F6 | 	mov	arg03, ##1000
015e8     19 00 62 FD | 	getqy	result1
015ec     18 0E 62 FD | 	getqx	arg01
015f0     28 00 62 FD | 	setq	result1
015f4     09 0F 12 FD | 	qdiv	arg01, arg03
015f8     18 0E 62 FD | 	getqx	arg01
015fc     05 0F 62 FA | 	addct1	arg01, _var02
01600     24 22 60 FD | 	waitct1
01604                 | LR__0083
01604                 | __system___waitms_ret
01604     2D 00 64 FD | 	ret
01608                 | 	alignl
01608                 | _dat_
01608     73 32 00 04 
0160c     00 00 10 00 
01610     00 00 00 00 
01614     00 00 00 00 | waveform file "glocke.s2"
01618     00 00 AB 04 
0161c     52 09 F4 0D 
01620     8C 12 19 17 
01624     97 1B 03 20 | 	byte	$00, $00, $ab, $04, $52, $09, $f4, $0d, $8c, $12, $19, $17, $97, $1b, $03, $20
01628     5B 24 9C 28 
0162c     C3 2C CE 30 
01630     BA 34 86 38 
01634     2F 3C B3 3F | 	byte	$5b, $24, $9c, $28, $c3, $2c, $ce, $30, $ba, $34, $86, $38, $2f, $3c, $b3, $3f
01638     10 43 45 46 
0163c     51 49 31 4C 
01640     E5 4E 6B 51 
01644     C3 53 ED 55 | 	byte	$10, $43, $45, $46, $51, $49, $31, $4c, $e5, $4e, $6b, $51, $c3, $53, $ed, $55
01648     E7 57 B2 59 
0164c     4D 5B B8 5C 
01650     F4 5D 00 5F 
01654     DF 5F 8F 60 | 	byte	$e7, $57, $b2, $59, $4d, $5b, $b8, $5c, $f4, $5d, $00, $5f, $df, $5f, $8f, $60
01658     13 61 6A 61 
0165c     97 61 9A 61 
01660     76 61 2B 61 
01664     BB 60 28 60 | 	byte	$13, $61, $6a, $61, $97, $61, $9a, $61, $76, $61, $2b, $61, $bb, $60, $28, $60
01668     74 5F A1 5E 
0166c     B0 5D A4 5C 
01670     7F 5B 43 5A 
01674     F3 58 90 57 | 	byte	$74, $5f, $a1, $5e, $b0, $5d, $a4, $5c, $7f, $5b, $43, $5a, $f3, $58, $90, $57
01678     1C 56 9B 54 
0167c     0E 53 77 51 
01680     D8 4F 34 4E 
01684     8D 4C E5 4A | 	byte	$1c, $56, $9b, $54, $0e, $53, $77, $51, $d8, $4f, $34, $4e, $8d, $4c, $e5, $4a
01688     3D 49 97 47 
0168c     F6 45 5A 44 
01690     C7 42 3C 41 
01694     BC 3F 47 3E | 	byte	$3d, $49, $97, $47, $f6, $45, $5a, $44, $c7, $42, $3c, $41, $bc, $3f, $47, $3e
01698     E0 3C 86 3B 
0169c     3C 3A 01 39 
016a0     D6 37 BD 36 
016a4     B5 35 BF 34 | 	byte	$e0, $3c, $86, $3b, $3c, $3a, $01, $39, $d6, $37, $bd, $36, $b5, $35, $bf, $34
016a8     DB 33 09 33 
016ac     49 32 9A 31 
016b0     FE 30 73 30 
016b4     F8 2F 8E 2F | 	byte	$db, $33, $09, $33, $49, $32, $9a, $31, $fe, $30, $73, $30, $f8, $2f, $8e, $2f
016b8     34 2F E8 2E 
016bc     AA 2E 79 2E 
016c0     55 2E 3B 2E 
016c4     2C 2E 25 2E | 	byte	$34, $2f, $e8, $2e, $aa, $2e, $79, $2e, $55, $2e, $3b, $2e, $2c, $2e, $25, $2e
016c8     26 2E 2D 2E 
016cc     39 2E 49 2E 
016d0     5C 2E 70 2E 
016d4     84 2E 96 2E | 	byte	$26, $2e, $2d, $2e, $39, $2e, $49, $2e, $5c, $2e, $70, $2e, $84, $2e, $96, $2e
016d8     A6 2E B2 2E 
016dc     B8 2E B9 2E 
016e0     B2 2E A2 2E 
016e4     88 2E 64 2E | 	byte	$a6, $2e, $b2, $2e, $b8, $2e, $b9, $2e, $b2, $2e, $a2, $2e, $88, $2e, $64, $2e
016e8     34 2E F7 2D 
016ec     AE 2D 55 2D 
016f0     EF 2C 78 2C 
016f4     F2 2B 5C 2B | 	byte	$34, $2e, $f7, $2d, $ae, $2d, $55, $2d, $ef, $2c, $78, $2c, $f2, $2b, $5c, $2b
016f8     B5 2A FD 29 
016fc     34 29 5A 28 
01700     6E 27 72 26 
01704     65 25 47 24 | 	byte	$b5, $2a, $fd, $29, $34, $29, $5a, $28, $6e, $27, $72, $26, $65, $25, $47, $24
01708     19 23 DC 21 
0170c     8F 20 34 1F 
01710     CB 1D 54 1C 
01714     D2 1A 44 19 | 	byte	$19, $23, $dc, $21, $8f, $20, $34, $1f, $cb, $1d, $54, $1c, $d2, $1a, $44, $19
01718     AC 17 0B 16 
0171c     61 14 B0 12 
01720     FA 10 3F 0F 
01724     80 0D C0 0B | 	byte	$ac, $17, $0b, $16, $61, $14, $b0, $12, $fa, $10, $3f, $0f, $80, $0d, $c0, $0b
01728     FF 09 3E 08 
0172c     80 06 C5 04 
01730     0F 03 5F 01 
01734     B6 FF 16 FE | 	byte	$ff, $09, $3e, $08, $80, $06, $c5, $04, $0f, $03, $5f, $01, $b6, $ff, $16, $fe
01738     81 FC F7 FA 
0173c     7A F9 0B F8 
01740     AB F6 5C F5 
01744     1E F4 F2 F2 | 	byte	$81, $fc, $f7, $fa, $7a, $f9, $0b, $f8, $ab, $f6, $5c, $f5, $1e, $f4, $f2, $f2
01748     DB F1 D7 F0 
0174c     E9 EF 11 EF 
01750     4F EE A5 ED 
01754     13 ED 98 EC | 	byte	$db, $f1, $d7, $f0, $e9, $ef, $11, $ef, $4f, $ee, $a5, $ed, $13, $ed, $98, $ec
01758     36 EC ED EB 
0175c     BD EB A5 EB 
01760     A7 EB C1 EB 
01764     F3 EB 3D EC | 	byte	$36, $ec, $ed, $eb, $bd, $eb, $a5, $eb, $a7, $eb, $c1, $eb, $f3, $eb, $3d, $ec
01768     9F EC 17 ED 
0176c     A6 ED 4A EE 
01770     03 EF D0 EF 
01774     AE F0 9F F1 | 	byte	$9f, $ec, $17, $ed, $a6, $ed, $4a, $ee, $03, $ef, $d0, $ef, $ae, $f0, $9f, $f1
01778     A0 F2 AF F3 
0177c     CD F4 F6 F5 
01780     2A F7 68 F8 
01784     AD F9 F8 FA | 	byte	$a0, $f2, $af, $f3, $cd, $f4, $f6, $f5, $2a, $f7, $68, $f8, $ad, $f9, $f8, $fa
01788     47 FC 99 FD 
0178c     EC FE 3F 00 
01790     8F 01 DA 02 
01794     21 04 5F 05 | 	byte	$47, $fc, $99, $fd, $ec, $fe, $3f, $00, $8f, $01, $da, $02, $21, $04, $5f, $05
01798     95 06 C0 07 
0179c     DE 08 EF 09 
017a0     F1 0A E2 0B 
017a4     C1 0C 8D 0D | 	byte	$95, $06, $c0, $07, $de, $08, $ef, $09, $f1, $0a, $e2, $0b, $c1, $0c, $8d, $0d
017a8     45 0E E8 0E 
017ac     75 0F EA 0F 
017b0     48 10 8E 10 
017b4     BB 10 CF 10 | 	byte	$45, $0e, $e8, $0e, $75, $0f, $ea, $0f, $48, $10, $8e, $10, $bb, $10, $cf, $10
017b8     CA 10 AB 10 
017bc     73 10 22 10 
017c0     B9 0F 36 0F 
017c4     9D 0E EC 0D | 	byte	$ca, $10, $ab, $10, $73, $10, $22, $10, $b9, $0f, $36, $0f, $9d, $0e, $ec, $0d
017c8     25 0D 49 0C 
017cc     59 0B 56 0A 
017d0     42 09 1D 08 
017d4     EB 06 AB 05 | 	byte	$25, $0d, $49, $0c, $59, $0b, $56, $0a, $42, $09, $1d, $08, $eb, $06, $ab, $05
017d8     61 04 0E 03 
017dc     B4 01 54 00 
017e0     F2 FE 8F FD 
017e4     2D FC CE FA | 	byte	$61, $04, $0e, $03, $b4, $01, $54, $00, $f2, $fe, $8f, $fd, $2d, $fc, $ce, $fa
017e8     75 F9 24 F8 
017ec     DE F6 A3 F5 
017f0     78 F4 5D F3 
017f4     55 F2 63 F1 | 	byte	$75, $f9, $24, $f8, $de, $f6, $a3, $f5, $78, $f4, $5d, $f3, $55, $f2, $63, $f1
017f8     87 F0 C5 EF 
017fc     1E EF 93 EE 
01800     27 EE DB ED 
01804     B1 ED AA ED | 	byte	$87, $f0, $c5, $ef, $1e, $ef, $93, $ee, $27, $ee, $db, $ed, $b1, $ed, $aa, $ed
01808     C7 ED 09 EE 
0180c     71 EE 01 EF 
01810     B8 EF 98 F0 
01814     A0 F1 D1 F2 | 	byte	$c7, $ed, $09, $ee, $71, $ee, $01, $ef, $b8, $ef, $98, $f0, $a0, $f1, $d1, $f2
01818     2B F4 AD F5 
0181c     58 F7 2B F9 
01820     25 FB 45 FD 
01824     8B FF F5 01 | 	byte	$2b, $f4, $ad, $f5, $58, $f7, $2b, $f9, $25, $fb, $45, $fd, $8b, $ff, $f5, $01
01828     82 04 31 07 
0182c     01 0A EE 0C 
01830     F9 0F 1E 13 
01834     5C 16 B1 19 | 	byte	$82, $04, $31, $07, $01, $0a, $ee, $0c, $f9, $0f, $1e, $13, $5c, $16, $b1, $19
01838     1A 1D 95 20 
0183c     20 24 B8 27 
01840     5A 2B 05 2F 
01844     B6 32 6A 36 | 	byte	$1a, $1d, $95, $20, $20, $24, $b8, $27, $5a, $2b, $05, $2f, $b6, $32, $6a, $36
01848     1E 3A D0 3D 
0184c     7D 41 22 45 
01850     BE 48 4D 4C 
01854     CD 4F 3C 53 | 	byte	$1e, $3a, $d0, $3d, $7d, $41, $22, $45, $be, $48, $4d, $4c, $cd, $4f, $3c, $53
01858     98 56 DD 59 
0185c     0B 5D 1E 60 
01860     15 63 EE 65 
01864     A8 68 40 6B | 	byte	$98, $56, $dd, $59, $0b, $5d, $1e, $60, $15, $63, $ee, $65, $a8, $68, $40, $6b
01868     B5 6D 07 70 
0186c     32 72 38 74 
01870     16 76 CC 77 
01874     59 79 BD 7A | 	byte	$b5, $6d, $07, $70, $32, $72, $38, $74, $16, $76, $cc, $77, $59, $79, $bd, $7a
01878     F7 7B 07 7D 
0187c     EE 7D AA 7E 
01880     3D 7F A6 7F 
01884     E7 7F FF 7F | 	byte	$f7, $7b, $07, $7d, $ee, $7d, $aa, $7e, $3d, $7f, $a6, $7f, $e7, $7f, $ff, $7f
01888     F0 7F BA 7F 
0188c     5F 7F DF 7E 
01890     3B 7E 75 7D 
01894     8F 7C 89 7B | 	byte	$f0, $7f, $ba, $7f, $5f, $7f, $df, $7e, $3b, $7e, $75, $7d, $8f, $7c, $89, $7b
01898     65 7A 25 79 
0189c     CA 77 57 76 
018a0     CB 74 2B 73 
018a4     76 71 B0 6F | 	byte	$65, $7a, $25, $79, $ca, $77, $57, $76, $cb, $74, $2b, $73, $76, $71, $b0, $6f
018a8     D9 6D F3 6B 
018ac     01 6A 04 68 
018b0     FD 65 EF 63 
018b4     DC 61 C4 5F | 	byte	$d9, $6d, $f3, $6b, $01, $6a, $04, $68, $fd, $65, $ef, $63, $dc, $61, $c4, $5f
018b8     A9 5D 8D 5B 
018bc     71 59 57 57 
018c0     40 55 2D 53 
018c4     20 51 19 4F | 	byte	$a9, $5d, $8d, $5b, $71, $59, $57, $57, $40, $55, $2d, $53, $20, $51, $19, $4f
018c8     19 4D 22 4B 
018cc     34 49 50 47 
018d0     76 45 A8 43 
018d4     E5 41 2E 40 | 	byte	$19, $4d, $22, $4b, $34, $49, $50, $47, $76, $45, $a8, $43, $e5, $41, $2e, $40
018d8     83 3E E4 3C 
018dc     51 3B CB 39 
018e0     51 38 E3 36 
018e4     81 35 2A 34 | 	byte	$83, $3e, $e4, $3c, $51, $3b, $cb, $39, $51, $38, $e3, $36, $81, $35, $2a, $34
018e8     DE 32 9D 31 
018ec     65 30 37 2F 
018f0     11 2E F4 2C 
018f4     DD 2B CC 2A | 	byte	$de, $32, $9d, $31, $65, $30, $37, $2f, $11, $2e, $f4, $2c, $dd, $2b, $cc, $2a
018f8     C1 29 BB 28 
018fc     B7 27 B7 26 
01900     B7 25 B9 24 
01904     BA 23 BA 22 | 	byte	$c1, $29, $bb, $28, $b7, $27, $b7, $26, $b7, $25, $b9, $24, $ba, $23, $ba, $22
01908     B7 21 B1 20 
0190c     A6 1F 97 1E 
01910     81 1D 64 1C 
01914     3F 1B 12 1A | 	byte	$b7, $21, $b1, $20, $a6, $1f, $97, $1e, $81, $1d, $64, $1c, $3f, $1b, $12, $1a
01918     DB 18 9A 17 
0191c     4F 16 F8 14 
01920     95 13 27 12 
01924     AB 10 23 0F | 	byte	$db, $18, $9a, $17, $4f, $16, $f8, $14, $95, $13, $27, $12, $ab, $10, $23, $0f
01928     8E 0D EC 0B 
0192c     3C 0A 7F 08 
01930     B6 06 DF 04 
01934     FC 02 0D 01 | 	byte	$8e, $0d, $ec, $0b, $3c, $0a, $7f, $08, $b6, $06, $df, $04, $fc, $02, $0d, $01
01938     12 FF 0C FD 
0193c     FB FA E1 F8 
01940     BE F6 94 F4 
01944     62 F2 2A F0 | 	byte	$12, $ff, $0c, $fd, $fb, $fa, $e1, $f8, $be, $f6, $94, $f4, $62, $f2, $2a, $f0
01948     ED ED AD EB 
0194c     6B E9 27 E7 
01950     E4 E4 A3 E2 
01954     65 E0 2C DE | 	byte	$ed, $ed, $ad, $eb, $6b, $e9, $27, $e7, $e4, $e4, $a3, $e2, $65, $e0, $2c, $de
01958     FA DB CF D9 
0195c     AE D7 98 D5 
01960     8F D3 95 D1 
01964     AA CF D1 CD | 	byte	$fa, $db, $cf, $d9, $ae, $d7, $98, $d5, $8f, $d3, $95, $d1, $aa, $cf, $d1, $cd
01968     0C CC 5B CA 
0196c     C1 C8 3E C7 
01970     D5 C5 86 C4 
01974     53 C3 3E C2 | 	byte	$0c, $cc, $5b, $ca, $c1, $c8, $3e, $c7, $d5, $c5, $86, $c4, $53, $c3, $3e, $c2
01978     46 C1 6E C0 
0197c     B7 BF 20 BF 
01980     AC BE 5A BE 
01984     2C BE 21 BE | 	byte	$46, $c1, $6e, $c0, $b7, $bf, $20, $bf, $ac, $be, $5a, $be, $2c, $be, $21, $be
01988     3A BE 77 BE 
0198c     D8 BE 5D BF 
01990     07 C0 D4 C0 
01994     C4 C1 D6 C2 | 	byte	$3a, $be, $77, $be, $d8, $be, $5d, $bf, $07, $c0, $d4, $c0, $c4, $c1, $d6, $c2
01998     0A C4 5F C5 
0199c     D4 C6 67 C8 
019a0     18 CA E5 CB 
019a4     CD CD CD CF | 	byte	$0a, $c4, $5f, $c5, $d4, $c6, $67, $c8, $18, $ca, $e5, $cb, $cd, $cd, $cd, $cf
019a8     E5 D1 12 D4 
019ac     53 D6 A5 D8 
019b0     06 DB 75 DD 
019b4     EF DF 71 E2 | 	byte	$e5, $d1, $12, $d4, $53, $d6, $a5, $d8, $06, $db, $75, $dd, $ef, $df, $71, $e2
019b8     FA E4 88 E7 
019bc     16 EA A5 EC 
019c0     30 EF B6 F1 
019c4     34 F4 A8 F6 | 	byte	$fa, $e4, $88, $e7, $16, $ea, $a5, $ec, $30, $ef, $b6, $f1, $34, $f4, $a8, $f6
019c8     10 F9 69 FB 
019cc     B2 FD E7 FF 
019d0     08 02 12 04 
019d4     03 06 DA 07 | 	byte	$10, $f9, $69, $fb, $b2, $fd, $e7, $ff, $08, $02, $12, $04, $03, $06, $da, $07
019d8     95 09 32 0B 
019dc     B1 0C 0F 0E 
019e0     4C 0F 68 10 
019e4     60 11 35 12 | 	byte	$95, $09, $32, $0b, $b1, $0c, $0f, $0e, $4c, $0f, $68, $10, $60, $11, $35, $12
019e8     E6 12 73 13 
019ec     DC 13 21 14 
019f0     41 14 3E 14 
019f4     18 14 D0 13 | 	byte	$e6, $12, $73, $13, $dc, $13, $21, $14, $41, $14, $3e, $14, $18, $14, $d0, $13
019f8     66 13 DC 12 
019fc     33 12 6C 11 
01a00     89 10 8B 0F 
01a04     75 0E 47 0D | 	byte	$66, $13, $dc, $12, $33, $12, $6c, $11, $89, $10, $8b, $0f, $75, $0e, $47, $0d
01a08     04 0C AE 0A 
01a0c     47 09 D2 07 
01a10     50 06 C5 04 
01a14     32 03 9A 01 | 	byte	$04, $0c, $ae, $0a, $47, $09, $d2, $07, $50, $06, $c5, $04, $32, $03, $9a, $01
01a18     00 00 66 FE 
01a1c     CE FC 3B FB 
01a20     B0 F9 2E F8 
01a24     B9 F6 52 F5 | 	byte	$00, $00, $66, $fe, $ce, $fc, $3b, $fb, $b0, $f9, $2e, $f8, $b9, $f6, $52, $f5
01a28     FC F3 B9 F2 
01a2c     8B F1 75 F0 
01a30     77 EF 94 EE 
01a34     CD ED 24 ED | 	byte	$fc, $f3, $b9, $f2, $8b, $f1, $75, $f0, $77, $ef, $94, $ee, $cd, $ed, $24, $ed
01a38     9A EC 30 EC 
01a3c     E8 EB C2 EB 
01a40     BF EB DF EB 
01a44     24 EC 8D EC | 	byte	$9a, $ec, $30, $ec, $e8, $eb, $c2, $eb, $bf, $eb, $df, $eb, $24, $ec, $8d, $ec
01a48     1A ED CB ED 
01a4c     A0 EE 98 EF 
01a50     B4 F0 F1 F1 
01a54     4F F3 CE F4 | 	byte	$1a, $ed, $cb, $ed, $a0, $ee, $98, $ef, $b4, $f0, $f1, $f1, $4f, $f3, $ce, $f4
01a58     6B F6 26 F8 
01a5c     FD F9 EE FB 
01a60     F8 FD 19 00 
01a64     4E 02 97 04 | 	byte	$6b, $f6, $26, $f8, $fd, $f9, $ee, $fb, $f8, $fd, $19, $00, $4e, $02, $97, $04
01a68     F0 06 58 09 
01a6c     CC 0B 4A 0E 
01a70     D0 10 5B 13 
01a74     EA 15 78 18 | 	byte	$f0, $06, $58, $09, $cc, $0b, $4a, $0e, $d0, $10, $5b, $13, $ea, $15, $78, $18
01a78     06 1B 8F 1D 
01a7c     11 20 8B 22 
01a80     FA 24 5B 27 
01a84     AD 29 EE 2B | 	byte	$06, $1b, $8f, $1d, $11, $20, $8b, $22, $fa, $24, $5b, $27, $ad, $29, $ee, $2b
01a88     1B 2E 33 30 
01a8c     33 32 1B 34 
01a90     E8 35 99 37 
01a94     2C 39 A1 3A | 	byte	$1b, $2e, $33, $30, $33, $32, $1b, $34, $e8, $35, $99, $37, $2c, $39, $a1, $3a
01a98     F6 3B 2A 3D 
01a9c     3C 3E 2C 3F 
01aa0     F9 3F A3 40 
01aa4     28 41 89 41 | 	byte	$f6, $3b, $2a, $3d, $3c, $3e, $2c, $3f, $f9, $3f, $a3, $40, $28, $41, $89, $41
01aa8     C6 41 DF 41 
01aac     D4 41 A6 41 
01ab0     54 41 E0 40 
01ab4     49 40 92 3F | 	byte	$c6, $41, $df, $41, $d4, $41, $a6, $41, $54, $41, $e0, $40, $49, $40, $92, $3f
01ab8     BA 3E C2 3D 
01abc     AD 3C 7A 3B 
01ac0     2B 3A C2 38 
01ac4     3F 37 A5 35 | 	byte	$ba, $3e, $c2, $3d, $ad, $3c, $7a, $3b, $2b, $3a, $c2, $38, $3f, $37, $a5, $35
01ac8     F4 33 2F 32 
01acc     56 30 6B 2E 
01ad0     71 2C 68 2A 
01ad4     52 28 31 26 | 	byte	$f4, $33, $2f, $32, $56, $30, $6b, $2e, $71, $2c, $68, $2a, $52, $28, $31, $26
01ad8     06 24 D4 21 
01adc     9B 1F 5D 1D 
01ae0     1C 1B D9 18 
01ae4     95 16 53 14 | 	byte	$06, $24, $d4, $21, $9b, $1f, $5d, $1d, $1c, $1b, $d9, $18, $95, $16, $53, $14
01ae8     13 12 D6 0F 
01aec     9E 0D 6C 0B 
01af0     42 09 1F 07 
01af4     05 05 F4 02 | 	byte	$13, $12, $d6, $0f, $9e, $0d, $6c, $0b, $42, $09, $1f, $07, $05, $05, $f4, $02
01af8     EE 00 F3 FE 
01afc     04 FD 21 FB 
01b00     4A F9 81 F7 
01b04     C4 F5 14 F4 | 	byte	$ee, $00, $f3, $fe, $04, $fd, $21, $fb, $4a, $f9, $81, $f7, $c4, $f5, $14, $f4
01b08     72 F2 DD F0 
01b0c     55 EF D9 ED 
01b10     6B EC 08 EB 
01b14     B1 E9 66 E8 | 	byte	$72, $f2, $dd, $f0, $55, $ef, $d9, $ed, $6b, $ec, $08, $eb, $b1, $e9, $66, $e8
01b18     25 E7 EE E5 
01b1c     C1 E4 9C E3 
01b20     7F E2 69 E1 
01b24     5A E0 4F DF | 	byte	$25, $e7, $ee, $e5, $c1, $e4, $9c, $e3, $7f, $e2, $69, $e1, $5a, $e0, $4f, $df
01b28     49 DE 46 DD 
01b2c     46 DC 47 DB 
01b30     49 DA 49 D9 
01b34     49 D8 45 D7 | 	byte	$49, $de, $46, $dd, $46, $dc, $47, $db, $49, $da, $49, $d9, $49, $d8, $45, $d7
01b38     3F D6 34 D5 
01b3c     23 D4 0C D3 
01b40     EF D1 C9 D0 
01b44     9B CF 63 CE | 	byte	$3f, $d6, $34, $d5, $23, $d4, $0c, $d3, $ef, $d1, $c9, $d0, $9b, $cf, $63, $ce
01b48     22 CD D6 CB 
01b4c     7F CA 1D C9 
01b50     AF C7 35 C6 
01b54     AF C4 1C C3 | 	byte	$22, $cd, $d6, $cb, $7f, $ca, $1d, $c9, $af, $c7, $35, $c6, $af, $c4, $1c, $c3
01b58     7D C1 D2 BF 
01b5c     1B BE 58 BC 
01b60     8A BA B0 B8 
01b64     CC B6 DE B4 | 	byte	$7d, $c1, $d2, $bf, $1b, $be, $58, $bc, $8a, $ba, $b0, $b8, $cc, $b6, $de, $b4
01b68     E7 B2 E7 B0 
01b6c     E0 AE D3 AC 
01b70     C0 AA A9 A8 
01b74     8F A6 73 A4 | 	byte	$e7, $b2, $e7, $b0, $e0, $ae, $d3, $ac, $c0, $aa, $a9, $a8, $8f, $a6, $73, $a4
01b78     57 A2 3C A0 
01b7c     24 9E 11 9C 
01b80     03 9A FC 97 
01b84     FF 95 0D 94 | 	byte	$57, $a2, $3c, $a0, $24, $9e, $11, $9c, $03, $9a, $fc, $97, $ff, $95, $0d, $94
01b88     27 92 50 90 
01b8c     8A 8E D5 8C 
01b90     35 8B A9 89 
01b94     36 88 DB 86 | 	byte	$27, $92, $50, $90, $8a, $8e, $d5, $8c, $35, $8b, $a9, $89, $36, $88, $db, $86
01b98     9B 85 77 84 
01b9c     71 83 8B 82 
01ba0     C5 81 21 81 
01ba4     A1 80 46 80 | 	byte	$9b, $85, $77, $84, $71, $83, $8b, $82, $c5, $81, $21, $81, $a1, $80, $46, $80
01ba8     10 80 01 80 
01bac     19 80 5A 80 
01bb0     C3 80 56 81 
01bb4     12 82 F9 82 | 	byte	$10, $80, $01, $80, $19, $80, $5a, $80, $c3, $80, $56, $81, $12, $82, $f9, $82
01bb8     09 84 43 85 
01bbc     A7 86 34 88 
01bc0     EA 89 C8 8B 
01bc4     CE 8D F9 8F | 	byte	$09, $84, $43, $85, $a7, $86, $34, $88, $ea, $89, $c8, $8b, $ce, $8d, $f9, $8f
01bc8     4B 92 C0 94 
01bcc     58 97 12 9A 
01bd0     EB 9C E2 9F 
01bd4     F5 A2 23 A6 | 	byte	$4b, $92, $c0, $94, $58, $97, $12, $9a, $eb, $9c, $e2, $9f, $f5, $a2, $23, $a6
01bd8     68 A9 C4 AC 
01bdc     33 B0 B3 B3 
01be0     42 B7 DE BA 
01be4     83 BE 30 C2 | 	byte	$68, $a9, $c4, $ac, $33, $b0, $b3, $b3, $42, $b7, $de, $ba, $83, $be, $30, $c2
01be8     E2 C5 96 C9 
01bec     4A CD FB D0 
01bf0     A6 D4 48 D8 
01bf4     E0 DB 6B DF | 	byte	$e2, $c5, $96, $c9, $4a, $cd, $fb, $d0, $a6, $d4, $48, $d8, $e0, $db, $6b, $df
01bf8     E6 E2 4F E6 
01bfc     A4 E9 E2 EC 
01c00     07 F0 12 F3 
01c04     FF F5 CF F8 | 	byte	$e6, $e2, $4f, $e6, $a4, $e9, $e2, $ec, $07, $f0, $12, $f3, $ff, $f5, $cf, $f8
01c08     7E FB 0B FE 
01c0c     75 00 BB 02 
01c10     DB 04 D5 06 
01c14     A8 08 53 0A | 	byte	$7e, $fb, $0b, $fe, $75, $00, $bb, $02, $db, $04, $d5, $06, $a8, $08, $53, $0a
01c18     D5 0B 2F 0D 
01c1c     60 0E 68 0F 
01c20     48 10 FF 10 
01c24     8F 11 F7 11 | 	byte	$d5, $0b, $2f, $0d, $60, $0e, $68, $0f, $48, $10, $ff, $10, $8f, $11, $f7, $11
01c28     39 12 56 12 
01c2c     4F 12 25 12 
01c30     D9 11 6D 11 
01c34     E2 10 3B 10 | 	byte	$39, $12, $56, $12, $4f, $12, $25, $12, $d9, $11, $6d, $11, $e2, $10, $3b, $10
01c38     79 0F 9D 0E 
01c3c     AB 0D A3 0C 
01c40     88 0B 5D 0A 
01c44     22 09 DC 07 | 	byte	$79, $0f, $9d, $0e, $ab, $0d, $a3, $0c, $88, $0b, $5d, $0a, $22, $09, $dc, $07
01c48     8B 06 32 05 
01c4c     D3 03 71 02 
01c50     0E 01 AC FF 
01c54     4C FE F2 FC | 	byte	$8b, $06, $32, $05, $d3, $03, $71, $02, $0e, $01, $ac, $ff, $4c, $fe, $f2, $fc
01c58     9F FB 55 FA 
01c5c     15 F9 E3 F7 
01c60     BE F6 AA F5 
01c64     A7 F4 B7 F3 | 	byte	$9f, $fb, $55, $fa, $15, $f9, $e3, $f7, $be, $f6, $aa, $f5, $a7, $f4, $b7, $f3
01c68     DB F2 14 F2 
01c6c     63 F1 CA F0 
01c70     47 F0 DE EF 
01c74     8D EF 55 EF | 	byte	$db, $f2, $14, $f2, $63, $f1, $ca, $f0, $47, $f0, $de, $ef, $8d, $ef, $55, $ef
01c78     36 EF 31 EF 
01c7c     45 EF 72 EF 
01c80     B8 EF 16 F0 
01c84     8B F0 18 F1 | 	byte	$36, $ef, $31, $ef, $45, $ef, $72, $ef, $b8, $ef, $16, $f0, $8b, $f0, $18, $f1
01c88     BB F1 73 F2 
01c8c     3F F3 1E F4 
01c90     0F F5 11 F6 
01c94     22 F7 40 F8 | 	byte	$bb, $f1, $73, $f2, $3f, $f3, $1e, $f4, $0f, $f5, $11, $f6, $22, $f7, $40, $f8
01c98     6B F9 A1 FA 
01c9c     DF FB 26 FD 
01ca0     71 FE C1 FF 
01ca4     14 01 67 02 | 	byte	$6b, $f9, $a1, $fa, $df, $fb, $26, $fd, $71, $fe, $c1, $ff, $14, $01, $67, $02
01ca8     B9 03 08 05 
01cac     53 06 98 07 
01cb0     D6 08 0A 0A 
01cb4     33 0B 51 0C | 	byte	$b9, $03, $08, $05, $53, $06, $98, $07, $d6, $08, $0a, $0a, $33, $0b, $51, $0c
01cb8     60 0D 61 0E 
01cbc     52 0F 30 10 
01cc0     FD 10 B6 11 
01cc4     5A 12 E9 12 | 	byte	$60, $0d, $61, $0e, $52, $0f, $30, $10, $fd, $10, $b6, $11, $5a, $12, $e9, $12
01cc8     61 13 C3 13 
01ccc     0D 14 3F 14 
01cd0     59 14 5B 14 
01cd4     43 14 13 14 | 	byte	$61, $13, $c3, $13, $0d, $14, $3f, $14, $59, $14, $5b, $14, $43, $14, $13, $14
01cd8     CA 13 68 13 
01cdc     ED 12 5B 12 
01ce0     B1 11 EF 10 
01ce4     17 10 29 0F | 	byte	$ca, $13, $68, $13, $ed, $12, $5b, $12, $b1, $11, $ef, $10, $17, $10, $29, $0f
01ce8     25 0E 0E 0D 
01cec     E2 0B A4 0A 
01cf0     55 09 F5 07 
01cf4     86 06 09 05 | 	byte	$25, $0e, $0e, $0d, $e2, $0b, $a4, $0a, $55, $09, $f5, $07, $86, $06, $09, $05
01cf8     7F 03 EA 01 
01cfc     4A 00 A1 FE 
01d00     F1 FC 3B FB 
01d04     80 F9 C2 F7 | 	byte	$7f, $03, $ea, $01, $4a, $00, $a1, $fe, $f1, $fc, $3b, $fb, $80, $f9, $c2, $f7
01d08     01 F6 40 F4 
01d0c     80 F2 C1 F0 
01d10     06 EF 50 ED 
01d14     9F EB F5 E9 | 	byte	$01, $f6, $40, $f4, $80, $f2, $c1, $f0, $06, $ef, $50, $ed, $9f, $eb, $f5, $e9
01d18     54 E8 BC E6 
01d1c     2E E5 AC E3 
01d20     35 E2 CC E0 
01d24     71 DF 24 DE | 	byte	$54, $e8, $bc, $e6, $2e, $e5, $ac, $e3, $35, $e2, $cc, $e0, $71, $df, $24, $de
01d28     E7 DC B9 DB 
01d2c     9B DA 8E D9 
01d30     92 D8 A6 D7 
01d34     CC D6 03 D6 | 	byte	$e7, $dc, $b9, $db, $9b, $da, $8e, $d9, $92, $d8, $a6, $d7, $cc, $d6, $03, $d6
01d38     4B D5 A4 D4 
01d3c     0E D4 88 D3 
01d40     11 D3 AB D2 
01d44     52 D2 09 D2 | 	byte	$4b, $d5, $a4, $d4, $0e, $d4, $88, $d3, $11, $d3, $ab, $d2, $52, $d2, $09, $d2
01d48     CC D1 9C D1 
01d4c     78 D1 5E D1 
01d50     4E D1 47 D1 
01d54     48 D1 4E D1 | 	byte	$cc, $d1, $9c, $d1, $78, $d1, $5e, $d1, $4e, $d1, $47, $d1, $48, $d1, $4e, $d1
01d58     5A D1 6A D1 
01d5c     7C D1 90 D1 
01d60     A4 D1 B7 D1 
01d64     C7 D1 D3 D1 | 	byte	$5a, $d1, $6a, $d1, $7c, $d1, $90, $d1, $a4, $d1, $b7, $d1, $c7, $d1, $d3, $d1
01d68     DA D1 DB D1 
01d6c     D4 D1 C5 D1 
01d70     AB D1 87 D1 
01d74     56 D1 18 D1 | 	byte	$da, $d1, $db, $d1, $d4, $d1, $c5, $d1, $ab, $d1, $87, $d1, $56, $d1, $18, $d1
01d78     CC D0 72 D0 
01d7c     08 D0 8D CF 
01d80     02 CF 66 CE 
01d84     B7 CD F7 CC | 	byte	$cc, $d0, $72, $d0, $08, $d0, $8d, $cf, $02, $cf, $66, $ce, $b7, $cd, $f7, $cc
01d88     25 CC 41 CB 
01d8c     4B CA 43 C9 
01d90     2A C8 FF C6 
01d94     C4 C5 7A C4 | 	byte	$25, $cc, $41, $cb, $4b, $ca, $43, $c9, $2a, $c8, $ff, $c6, $c4, $c5, $7a, $c4
01d98     20 C3 B9 C1 
01d9c     44 C0 C4 BE 
01da0     39 BD A6 BB 
01da4     0A BA 69 B8 | 	byte	$20, $c3, $b9, $c1, $44, $c0, $c4, $be, $39, $bd, $a6, $bb, $0a, $ba, $69, $b8
01da8     C3 B6 1B B5 
01dac     73 B3 CC B1 
01db0     28 B0 89 AE 
01db4     F2 AC 65 AB | 	byte	$c3, $b6, $1b, $b5, $73, $b3, $cc, $b1, $28, $b0, $89, $ae, $f2, $ac, $65, $ab
01db8     E4 A9 70 A8 
01dbc     0D A7 BD A5 
01dc0     81 A4 5C A3 
01dc4     50 A2 5F A1 | 	byte	$e4, $a9, $70, $a8, $0d, $a7, $bd, $a5, $81, $a4, $5c, $a3, $50, $a2, $5f, $a1
01dc8     8C A0 D8 9F 
01dcc     45 9F D5 9E 
01dd0     8A 9E 66 9E 
01dd4     69 9E 96 9E | 	byte	$8c, $a0, $d8, $9f, $45, $9f, $d5, $9e, $8a, $9e, $66, $9e, $69, $9e, $96, $9e
01dd8     ED 9E 71 9F 
01ddc     21 A0 00 A1 
01de0     0C A2 48 A3 
01de4     B3 A4 4E A6 | 	byte	$ed, $9e, $71, $9f, $21, $a0, $00, $a1, $0c, $a2, $48, $a3, $b3, $a4, $4e, $a6
01de8     19 A8 13 AA 
01dec     3D AC 95 AE 
01df0     1B B1 CF B3 
01df4     AF B6 BB B9 | 	byte	$19, $a8, $13, $aa, $3d, $ac, $95, $ae, $1b, $b1, $cf, $b3, $af, $b6, $bb, $b9
01df8     F0 BC 4D C0 
01dfc     D1 C3 7A C7 
01e00     46 CB 32 CF 
01e04     3D D3 64 D7 | 	byte	$f0, $bc, $4d, $c0, $d1, $c3, $7a, $c7, $46, $cb, $32, $cf, $3d, $d3, $64, $d7
01e08     A5 DB FD DF 
01e0c     69 E4 E7 E8 
01e10     74 ED 0C F2 
01e14     AE F6 55 FB | 	byte	$a5, $db, $fd, $df, $69, $e4, $e7, $e8, $74, $ed, $0c, $f2, $ae, $f6, $55, $fb
01e18     68 32 00 01 
01e1c     00 00 08 00 
01e20     00 00 00 00 
01e24     00 00 00 00 | envelope file "percus.h2"
01e28     FF FD FC FA 
01e2c     F8 F6 F4 F2 
01e30     F0 EE EC EA 
01e34     E8 E6 E4 E1 | 	byte	$ff, $fd, $fc, $fa, $f8, $f6, $f4, $f2, $f0, $ee, $ec, $ea, $e8, $e6, $e4, $e1
01e38     DF DD DB D8 
01e3c     D6 D4 D1 CF 
01e40     CC CA C7 C5 
01e44     C2 BF BD BA | 	byte	$df, $dd, $db, $d8, $d6, $d4, $d1, $cf, $cc, $ca, $c7, $c5, $c2, $bf, $bd, $ba
01e48     B7 B5 B2 B0 
01e4c     AD AA A7 A5 
01e50     A2 A0 9D 9B 
01e54     99 97 95 93 | 	byte	$b7, $b5, $b2, $b0, $ad, $aa, $a7, $a5, $a2, $a0, $9d, $9b, $99, $97, $95, $93
01e58     91 8F 8D 8C 
01e5c     8A 88 86 84 
01e60     82 80 7E 7D 
01e64     7B 79 78 76 | 	byte	$91, $8f, $8d, $8c, $8a, $88, $86, $84, $82, $80, $7e, $7d, $7b, $79, $78, $76
01e68     75 73 72 70 
01e6c     6F 6E 6D 6B 
01e70     6A 68 67 66 
01e74     64 63 62 60 | 	byte	$75, $73, $72, $70, $6f, $6e, $6d, $6b, $6a, $68, $67, $66, $64, $63, $62, $60
01e78     5F 5E 5C 5B 
01e7c     5A 59 58 57 
01e80     56 55 54 53 
01e84     52 51 50 4F | 	byte	$5f, $5e, $5c, $5b, $5a, $59, $58, $57, $56, $55, $54, $53, $52, $51, $50, $4f
01e88     4E 4D 4C 4C 
01e8c     4B 4A 49 48 
01e90     47 46 45 44 
01e94     43 42 41 40 | 	byte	$4e, $4d, $4c, $4c, $4b, $4a, $49, $48, $47, $46, $45, $44, $43, $42, $41, $40
01e98     3F 3E 3D 3D 
01e9c     3C 3C 3B 3A 
01ea0     3A 39 38 38 
01ea4     37 36 36 35 | 	byte	$3f, $3e, $3d, $3d, $3c, $3c, $3b, $3a, $3a, $39, $38, $38, $37, $36, $36, $35
01ea8     34 34 33 32 
01eac     31 31 30 2F 
01eb0     2F 2E 2D 2D 
01eb4     2C 2B 2B 2A | 	byte	$34, $34, $33, $32, $31, $31, $30, $2f, $2f, $2e, $2d, $2d, $2c, $2b, $2b, $2a
01eb8     29 29 28 27 
01ebc     27 26 25 25 
01ec0     24 24 23 22 
01ec4     22 21 20 20 | 	byte	$29, $29, $28, $27, $27, $26, $25, $25, $24, $24, $23, $22, $22, $21, $20, $20
01ec8     1F 1E 1E 1E 
01ecc     1D 1D 1D 1C 
01ed0     1C 1B 1B 1A 
01ed4     19 19 18 17 | 	byte	$1f, $1e, $1e, $1e, $1d, $1d, $1d, $1c, $1c, $1b, $1b, $1a, $19, $19, $18, $17
01ed8     17 16 15 15 
01edc     14 13 13 12 
01ee0     11 11 10 0F 
01ee4     0F 0E 0D 0D | 	byte	$17, $16, $15, $15, $14, $13, $13, $12, $11, $11, $10, $0f, $0f, $0e, $0d, $0d
01ee8     0C 0C 0B 0B 
01eec     0B 0A 0A 0A 
01ef0     09 09 09 08 
01ef4     08 08 07 07 | 	byte	$0c, $0c, $0b, $0b, $0b, $0a, $0a, $0a, $09, $09, $09, $08, $08, $08, $07, $07
01ef8     07 06 06 06 
01efc     05 05 05 04 
01f00     04 04 03 03 
01f04     03 02 02 02 | 	byte	$07, $06, $06, $06, $05, $05, $05, $04, $04, $04, $03, $03, $03, $02, $02, $02
01f08     01 01 01 00 
01f0c     00 00 00 00 
01f10     00 00 00 00 
01f14     00 00 00 00 | 	byte	$01, $01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
01f18     00 00 00 00 
01f1c     00 00 00 00 
01f20     00 00 00 00 
01f24     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
01f28                 | 	alignl
01f28                 | _Audio2_004_dat_
01f28                 | 
01f28                 | audio       	org     0
01f28                 | 
01f28     61 79 05 FB |             	rdlong  mailbox2, ptra++     	' get start address of all mailboxes
01f2c     61 B1 05 FB |             	rdlong  scbase, ptra++       	' get start address of scope buffer
01f30     61 BD 05 FB |             	rdlong  hubptr, ptra++       	' get start address of PSRAM cache
01f34                 | 
01f34     01 EC 63 FD |             	cogid   pa                   	' compute cogid
01f38     0C EC 07 FA |             	mul     pa, #12              	' and mailbox spacing
01f3c     F6 79 01 F1 |             	add     mailbox2, pa         	' add offset to find this COG's mailbox
01f40     BC 76 01 F6 |             	mov     mailbox, mailbox2     	' we need 2 copies of this to enable switching between hub and psram
01f44                 | 
01f44     0E BA 05 FC |             	wrpin   dac2,#left           	' PWM DACs at 44100@339 MHz
01f48     0E BE 15 FC |             	wxpin   sr44100,#left      	' 30*256
01f4c     0F BA 05 FC |             	wrpin   dac2,#right
01f50     0F BE 15 FC |             	wxpin   sr44100,#right    
01f54     41 9C 64 FD |             	dirh    #left addpins 1
01f58     20 9C 64 FD |             	setse1  #%001<<6 + left      	' Set the event - DAC empty
01f5c                 |   'debug(uhex(mailbox))
01f5c                 |             
01f5c                 | '---------------------------------------------------------------------------------        
01f5c                 | '----------------- The main loop -------------------------------------------------
01f5c                 | '---------------------------------------------------------------------------------
01f5c                 | 
01f5c     0F A8 05 F6 | loop       	mov 	    cn,#15 '7
01f60                 |               					'   waitx ##3300000  		'for debug
01f60                 |             
01f60                 | '----------------------------------------------------------------------------------
01f60                 | '------------- Get parameters and execute commands if any -------------------------
01f60                 | '----------------------------------------------------------------------------------
01f60                 | 
01f60                 | 
01f60     1A F6 61 FD | p401        	getct ct1
01f64     D4 70 01 F6 |                 mov     channeladd,cn             	' compute the pointer to channel parameters block
01f68     06 70 65 F0 |             	shl     channeladd,#6
01f6c     B8 F0 03 F1 |             	add     ptra,channeladd
01f70                 | 
01f70     28 1A 64 FD |             	setq    #13                       	' read parameters
01f74     00 7F 05 FB |             	rdlong  pointer0,ptra
01f78     1F 92 1D F4 | p408        	bitl    command0,#31 wcz	      	' bit #31 command - set the DAC sample rate
01f7c     2C 00 90 3D |     	if_nc   jmp     #p404                     	' if not set, proceed
01f80     C9 72 01 F6 |             	mov     qq,command0             	' get the new rate
01f84     4E 72 15 FC |             	wxpin   qq,#left addpins 1        	' and program the pins
01f88     B9 72 E1 F8 |             	getbyte qq,qq,#0 		      	' check if the rate is n*256
01f8c     00 72 0D F2 |             	cmp     qq,#0 wz                         
01f90     4E BA 05 AC |     	if_z    wrpin   dac2,#left addpins 1      	' if yes, set PWM DAC mode
01f94     4E B8 05 5C |     	if_nz   wrpin   dac,#left addpins 1       	' else set noise DAC mode
01f98                 |                 
01f98     1E 88 1D F4 |                	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
01f9c     00 7E 05 A6 |     	if_z    mov     pointer0, #0  
01fa0     00 80 05 A6 |     	if_z    mov     pointer0h, #0  
01fa4     00 86 05 A6 |     	if_z    mov     envph0, #0  
01fa8     05 89 65 AC |     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
01fac                 |     	
01fac     C4 72 01 F6 | p404        	mov     qq,sstart0		     	' check if start>$80000
01fb0     FF FF 03 FF 
01fb4     FF 73 05 F5 | 		and 	qq,##$7FFFFFF 
01fb8     00 04 00 FF 
01fbc     00 72 1D F2 |                 cmp 	qq,##$80000 wcz
01fc0     BC 76 01 36 |     	if_ge   mov     mailbox,mailbox2          	' if yes, use PSRAM
01fc4     00 76 05 C6 |     	if_lt   mov     mailbox,#0                	' if not, use HUB 
01fc8                 |  ''debug(uhex(sstart0,mailbox))
01fc8     C7 A4 39 F9 | p405           	getword apan0,volpan0,#1          	' extract vol,pan from longs 
01fcc     C7 A2 31 F9 |     	    	getword avol0,volpan0,#0
01fd0                 |     	'   debug(uhex(pointer0,pointer0h,sstart0)) 	
01fd0                 | '----------------------------------------------------------------------------------
01fd0                 | '------------- Compute the envelope, if exists ------------------------------------
01fd0                 | '----------------------------------------------------------------------------------
01fd0                 |             
01fd0     00 94 1D F2 |             	cmp     envptr0,#0 wcz     		' read the pointer
01fd4     20 00 00 AF 
01fd8     00 F0 05 A6 |     	if_z    mov     envs1,##$4000			' if 0, no envelope, load $4000=1 for scas
01fdc     54 00 90 AD |     	if_z    jmp     #p410				' and run away	
01fe0                 | 
01fe0     CB 86 01 F1 |            	add     envph0,envspd0			' envelope PA update
01fe4                 |            	           
01fe4     C3 EC 01 F6 |       	    	mov     envhi, envph0			' move phase acc to high part of env pointer
01fe8     06 EC 45 F0 | 		shr     envhi,#6			' leave 10 bits in hi
01fec     F6 EE 31 F9 | 	   	getword envlo,envhi,#0              	' and 16 bit in lo
01ff0     10 EC 45 F0 | 	    	shr     envhi,#16			' move 10 bits of hi to the lower word
01ff4     CC EC 19 F2 | 	    	cmp     envhi,envlen0 wcz		' compare this to envelope length
01ff8                 | 	    											'debug(udec(envhi,envlen0))
01ff8     CC EC 01 36 |     	if_ge  	mov     envhi,envlen0			' if greater than, set it at envlen
01ffc     00 EE 05 36 |     	if_ge   mov     envlo,#0
02000     CC 86 01 36 |     	if_ge   mov     envph0,envlen0             	' and set envph0 at the end of the envelope
02004     16 86 65 30 |     	if_ge   shl     envph0,#22
02008                 | 
02008     F6 F0 01 F6 |             	mov 	envs1,envhi			' 10 high bits of PA is the offset to the envelope entry
0200c     01 F0 65 F0 |             	shl 	envs1,#1                        ' these entries are 16 bit so multiply the offset by 2
02010     CA F0 01 F1 |             	add 	envs1,envptr0                   ' and add it to the pointer
02014     F8 F0 01 FB |             	rdlong 	envs1,envs1			' and then read 2 entries in one rdlong
02018     F8 F2 39 F9 |             	getword envs2,envs1,#1			' then separate them		
0201c     F8 F0 31 F9 |            	getword envs1,envs1,#0
02020     F7 F2 01 FA |             	mul     envs2,envlo                     ' and do linear interpolation based on lower bits of the offset
02024     F7 EE 21 F6 |             	not     envlo
02028     F7 F0 01 FA |             	mul     envs1,envlo
0202c     F9 F0 01 F1 |             	add     envs1,envs2
02030     12 F0 45 F0 |             	shr     envs1,#18			' we need only 14 bits for scas
02034                 |               
02034                 | '----------------------------------------------------------------------------------
02034                 | '------------- Generate the noise if bit 27 of the pointer is set -----------------
02034                 | '----------------------------------------------------------------------------------
02034                 | 
02034                 | 
02034                 |     	
02034                 | '----------------------------------------------------------------------------------
02034                 | '------------- Get the sample -----------------------------------------------------
02034                 | '----------------------------------------------------------------------------------    	
02034                 |  
02034     C0 A6 01 F6 | p410  		mov	oldptrh,pointer0h
02038     C8 A0 F9 F8 |            	getbyte	afreq0,freqskip0,#3         	' the frequency is in 8:24 format, so get integer in afreq0
0203c     08 90 65 F0 |            	shl	freqskip0,#8                	' and keep the fractional in freqskip0
02040     C8 7E 19 F1 |            	add     pointer0,freqskip0 wcz      	' compute the pointer to the next sample   
02044     D0 80 21 F1 |            	addx	pointer0h,afreq0  
02048                 |           	
02048     1B 88 0D F4 |    	   	testb   sstart0, #27 wz
0204c     10 00 90 5D |     	if_nz	jmp #p412   	
02050     1B 74 61 CD |    	if_c  	getrnd  spl
02054     BA 84 41 C9 |    	if_c	rolword rawspl0,spl,#0	
02058     C2 74 31 F9 |    		getword spl,rawspl0,#0
0205c     90 00 90 FD |       	        jmp     #p406          	
02060                 |            	
02060                 |            	
02060     D3 80 19 F2 | p412 		cmp	pointer0h,oldptrh wcz
02064     58 00 90 AD |  	if_e 	jmp 	#p411				' if the pointer didn't change, no sample has to be read
02068                 |      	
02068     1F 88 0D F4 |             	testb   sstart0,#31 wz       	   	' bit 31 : 16 bit sample  
0206c     01 80 65 A0 |      	if_z    shl     pointer0h,#1        
02070     1C 88 0D F4 |             	testb   sstart0,#28 wz  		' bit 28 : interleaved sample         
02074     01 80 65 A0 |      	if_z    shl     pointer0h,#1        
02078                 | 												
02078     C6 80 19 F2 |             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
0207c     C6 80 81 31 |    	if_ge   sub     pointer0h,lend0       
02080     C5 80 01 31 |         if_ge   add     pointer0h,lstart0
02084     C6 80 19 F2 |             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
02088     C6 80 01 36 |         if_ge   mov	pointer0h,lend0	
0208c                 |  
0208c     C0 72 01 F6 |              	mov     qq,pointer0h              	' compute place in the memory from where the sample will be loaded
02090     C4 72 01 F1 |            	add     qq,sstart0            
02094     FF FF 03 FF 
02098     FF 73 05 F5 |            	and  	qq,##$7FF_FFFF
0209c     FF 77 5D F2 |            	cmps    mailbox,#$1FF wcz          	' the mailbox has to point somewhere not at the start of HUB RAM
020a0     B9 74 E1 EA |     	if_le   rdword  spl,qq                      	' if not, use HUB RAM for samples
020a4     00 01 B0 1D |     	if_gt   call    #cache_read
020a8     1F 88 0D F4 |                 testb   sstart0,#31 wz 
020ac     08 74 65 50 |     	if_nz   shl     spl,#8				' convert 8 to 16 bit if needed
020b0     01 80 45 A0 |         if_z    shr     pointer0h,#1
020b4     1C 88 0D F4 |                 testb   sstart0,#28 wz            
020b8     01 80 45 A0 |     	if_z    shr     pointer0h,#1    
020bc     BA 84 41 F9 |                 rolword rawspl0,spl,#0			' now rawspl0 has oldsample:newsample in it
020c0                 |               
020c0     C2 74 31 F9 | p411	      	getword spl,rawspl0,#0
020c4     C2 9E 39 F9 | 		getword oldspl,rawspl0,#1		' then separate them		
020c8                 | 
020c8                 |           '  debug(uhex(pointer0h,pointer0,spl,oldspl))
020c8                 | 
020c8                 | 
020c8     BF EE 01 F6 | 		mov	envlo,pointer0
020cc     12 EE 45 F0 | 		shr 	envlo,#18
020d0                 | 	
020d0     F7 74 31 FA |             	scas    spl,envlo                   	' and do linear interpolation
020d4     00 74 01 F6 |             	mov 	spl,0-0
020d8     F7 EE 21 F6 |             	not     envlo
020dc     1F 00 00 FF 
020e0     FF EF 05 F5 |           	and     envlo,##$3FFF
020e4     F7 9E 31 FA |            	scas    oldspl,envlo
020e8     00 9E 01 F6 |             	mov     oldspl,0-0
020ec     CF 74 01 F1 |                 add     spl, oldspl
020f0                 | 	 
020f0     F8 74 31 FA | p406        	scas    spl, envs1
020f4     00 74 01 F6 |             	mov     spl,0-0
020f8     D1 74 31 FA |             	scas    spl,avol0                 	' apply volume
020fc     00 74 01 F6 |             	mov     spl,0-0
02100                 |  
02100     D2 74 31 FA |             	scas    spl,apan0                 	' apply pan
02104     00 AA 01 F6 |             	mov     ls0,0-0
02108     20 00 00 FF 
0210c     00 72 05 F6 |             	mov     qq,##16384
02110     D2 72 81 F1 |             	sub     qq,apan0
02114     B9 74 31 FA |             	scas    spl,qq
02118     00 AC 01 F6 |             	mov     rs0, 0-0
0211c                 |       
0211c     D6 82 29 F9 |                 setword sample0,rs0,#1           	' pack samples into long
02120     D5 82 21 F9 |                 setword sample0,ls0,#0
02124                 |                 
02124     D5 7A 01 F1 |                 add  lsample,ls0
02128     D6 7C 01 F1 |                 add  rsample,rs0
0212c                 |              
0212c     1E 88 1D F4 |             	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
02130     00 7E 05 A6 |     	if_z    mov     pointer0, #0  
02134     00 80 05 A6 |     	if_z    mov     pointer0h, #0  
02138     00 86 05 A6 |     	if_z    mov     envph0, #0  
0213c     05 89 65 AC |     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
02140                 |             
02140     28 08 64 FD | p403        	setq #4                          	' write new pointer, sample values and env pointer to the hub
02144     00 7F 65 FC | 	       	wrlong  pointer0,ptra
02148     B8 F0 83 F1 |             	sub     ptra, channeladd         	' reset the pointer to channel parameters
0214c                 | 
0214c     84 A9 7D FB |             	djnf    cn, #p401
02150                 | 
02150     0F 7C E5 F4 |             	bitnot rsample, #15
02154     0F 7A E5 F4 |             	bitnot lsample, #15
02158     1A F8 61 FD |   							           	getct ct2  	'debug
0215c     FB F8 81 F1 |   							          	sub ct2,ct1
02160                 |   							          	debug(udec(ct2))
02160     24 28 60 FD |             	waitse1
02164                 |           
02164     0E 7A 25 FC |            	wypin   lsample, #left              
02168     0F 7C 25 FC |                 wypin   rsample, #right        
0216c                 | 
0216c     BD AE 21 F9 | 		setword oldsample, lsample,#0		' for oscilloscope
02170     BE AE 29 F9 | 		setword oldsample, rsample,#1
02174                 | 		
02174     00 7C 05 F6 |             	mov rsample, #0
02178     00 7A 05 F6 |             	mov lsample, #0
0217c                 | 
0217c                 | '----------------------------------------------------------------------------------
0217c                 | '------------- Oscilloscope  -----------------------------------------------------
0217c                 | '----------------------------------------------------------------------------------   
0217c                 | 		
0217c     00 B0 0D F2 | 	    	cmp     scbase,#0 wz
02180     20 00 90 AD |     	if_z    jmp #p302	   
02184                 |  
02184     01 B6 15 F7 |             	incmod  scope,#1 wc            		'  todo: scope speed instead of const  
02188     D9 B4 01 C6 |     	if_c    mov scptr2,scptr
0218c     02 B4 65 C0 |     	if_c    shl scptr2,#2
02190     D8 B4 01 C1 |     	if_c    add scptr2,scbase     
02194     60 B4 65 FC |             	wrlong scptr2,#$60
02198     DA AE 61 CC |     	if_c    wrlong oldsample,scptr2
0219c     01 00 00 CF 
021a0     7F B2 05 C7 |     	if_c    incmod scptr,##639
021a4                 |             
021a4     B4 FD 9F FD |  p302           jmp     #loop            'loop
021a8                 | 
021a8                 | '----------------------------------------------------------------------------------
021a8                 | '------------- This is the end of the main loop -----------------------------------
021a8                 | '----------------------------------------------------------------------------------
021a8                 | 
021a8                 | '----------------------------------------------------------------------------------
021a8                 | '------------- PSRAM cache ----------- --------------------------------------------
021a8                 | '----------------------------------------------------------------------------------
021a8                 | 
021a8                 | ' There are 16 cache pointers for 16 channels
021a8                 | ' if 24 higher bits of address=cache, then get a word from the cache
021a8                 | ' else load the cache from PSRAM, update the pointer, then read a sample
021a8                 | 
021a8                 | 
021a8     B9 E6 E1 F8 | cache_read  	getbyte addrlo,qq,#0 			' when this is called, qq is the addres of the sample			
021ac                 |          '   debug ("cache")
021ac     B9 E8 01 F6 | 	   	mov     addrhi,qq		
021b0     08 E8 45 F0 | 	    	shr     addrhi,#8		        ' get 24 upper bits
021b4     E0 A8 95 F9 | 	    	alts    cn,#cache1            
021b8     00 E8 09 F2 | 	    	cmp	addrhi,0-0 wz               	' and compare with the cache pointer for the channel
021bc     34 00 90 AD |    	if_z    jmp     #p701	    			' if equal, cache hit, read the sample from it
021c0                 | 
021c0     E0 A8 8D F9 | p702	    	altd    cn,#cache1			' cache miss. 
021c4     F4 00 00 F6 | 	    	mov     0-0,addrhi                  	' update the pointer
021c8                 | 	    ''	 debug(uhex(addrhi))
021c8     F4 E0 01 F6 | 	    	mov     cmd,addrhi			' prepare the mailbox
021cc     08 E0 65 F0 | 	    	shl     cmd,#8
021d0     0B E0 3D F8 |             	setnib  cmd, #%1011, #7             	' read burst from the external memory
021d4     D4 E2 01 F6 |             	mov     hubaddr,cn                  	' to the channel cache
021d8     08 E2 65 F0 |             	shl     hubaddr,#8                  	'
021dc     DE E2 01 F1 |             	add     hubaddr,hubptr 
021e0     00 E5 05 F6 |             	mov     count,#256                  	' 256 bytes
021e4     28 04 64 FD |             	setq    #2                          	' write 3 longs
021e8     BB E0 61 FC |             	wrlong  cmd, mailbox                	' run it
021ec     BB E0 01 FB | poll1       	rdlong  cmd, mailbox                	' poll mailbox for result
021f0     FE E1 B5 FB |             	tjs     cmd, #poll1                 	' retry until valid 
021f4                 |             
021f4                 | 	
021f4     D4 72 01 F6 | p701	    	mov     qq,cn				' cache hit
021f8     08 72 65 F0 | 	    	shl     qq,#8				' compute the cache start
021fc     DE 72 01 F1 | 	    	add     qq,hubptr
02200     F3 72 01 F1 | 	    	add	qq,addrlo			' add 8 lower bits to the cache addredd
02204     B9 74 E1 0A |     	_ret_   rdword  spl,qq                      	' read a long from the cache
02208                 |           
02208                 |   
02208                 | 
02208                 | 
02208                 | '---------------------------------------------------------------------------
02208                 | '------- Variables ---------------------------------------------------------
02208                 | '---------------------------------------------------------------------------
02208                 | 
02208                 | ' constants
02208                 | 
02208     00 00 00 00 | channeladd 	long 0
0220c                 | 
0220c                 | ' temporary variables 
0220c                 | 
0220c     00 00 00 00 | qq          	long 0
02210     00 00 00 00 | spl         	long 0
02214     00 00 00 00 | mailbox     	long 0
02218     00 00 00 00 | mailbox2    	long 0
0221c     00 00 00 00 | lsample     	long 0
02220     00 00 00 00 | rsample     	long 0
02224                 | 
02224                 | ' channel parameter block
02224                 | 
02224     00 00 00 00 | pointer0    	long 0   
02228     00 00 00 00 | pointer0h   	long 0  
0222c     00 00 00 00 | sample0     	long 0
02230     00 00 00 00 | rawspl0	    	long 0
02234     00 00 00 00 | envph0	    	long 0
02238     00 00 00 00 | sstart0     	long 0     ' start pointer and type at bit 31
0223c     00 00 00 00 | lstart0     	long 0
02240     00 00 00 00 | lend0       	long 0
02244     00 00 00 00 | volpan0     	long 0
02248     00 00 00 00 | freqskip0   	long 0
0224c     00 00 00 00 | command0    	long 0
02250     00 00 00 00 | envptr0	    	long 0
02254     00 00 00 00 | envspd0	    	long 0
02258     00 00 00 00 | envlen0	    	long 0
0225c     00 00 00 00 | res5	    	long 0
02260     00 00 00 00 | res6	    	long 0
02264                 | 
02264     00 00 00 00 | oldspl		long 0
02268     00 00 00 00 | afreq0      	long 0
0226c                 | 
0226c     00 00 00 00 | avol0       	long 0
02270     00 00 00 00 | apan0       	long 0
02274     00 00 00 00 | oldptrh	    	long 0
02278     00 00 00 00 | cn          	long 0
0227c                 | 
0227c                 | ' Samples
0227c                 | 
0227c     00 00 00 00 | ls0         	long 0
02280     00 00 00 00 | rs0         	long 0
02284                 | 
02284     00 00 00 00 | oldsample   	long 0
02288                 | 
02288     00 00 00 00 | scbase 		long 0
0228c     00 00 00 00 | scptr 		long 0
02290     00 00 00 00 | scptr2		long 0
02294     00 00 00 00 | scope 		long 0
02298                 | 
02298     44 00 17 00 | dac         	long %10111_00000000_01_00010_0     	'random dither
0229c     46 00 17 00 | dac2        	long %10111_00000000_01_00011_0     	'pwm
022a0                 | 
022a0     00 18 07 00 | hubptr      	long $71800
022a4     00 1E 00 00 | sr44100     	long 30*256
022a8                 | 
022a8     00 00 00 00 | cache1      	long 0
022ac     00 00 00 00 | cache2      	long 0
022b0     00 00 00 00 | cache3      	long 0
022b4     00 00 00 00 | cache4      	long 0
022b8     00 00 00 00 | cache5      	long 0
022bc     00 00 00 00 | cache6      	long 0
022c0     00 00 00 00 | cache7      	long 0
022c4     00 00 00 00 | cache8      	long 0
022c8     00 00 00 00 | cache9      	long 0
022cc     00 00 00 00 | cachea      	long 0
022d0     00 00 00 00 | cacheb      	long 0
022d4     00 00 00 00 | cachec      	long 0
022d8     00 00 00 00 | cached      	long 0
022dc     00 00 00 00 | cachee      	long 0
022e0     00 00 00 00 | cachef      	long 0
022e4     00 00 00 00 | cache0      	long 0
022e8                 | 
022e8     00 00 00 00 | cmd         	long 0
022ec     00 00 00 00 | hubaddr    	long 0
022f0     00 01 00 00 | count       	long 256
022f4                 | 
022f4     00 00 00 00 | addrlo 		long 0
022f8     00 00 00 00 | addrhi 		long 0
022fc     00 00 00 00 | pointer00 	long 0
02300     00 00 00 00 | envhi 		long 0
02304     00 00 00 00 | envlo 		long 0
02308     00 00 00 00 | envs1 		long 0
0230c     00 00 00 00 | envs2 		long 0
02310     00 00 00 00 | noise0 		long 0
02314                 | 
02314     00 00 00 00 |  ct1 		long 0
02318     00 00 00 00 |  ct2 		long 0
0231c                 | 
0231c                 | 		fit 256		'todo: maybe the better interpolation. Or all params in cog
0231c                 | 		fit 256		'todo: maybe the better interpolation. Or all params in cog
0231c     00 00 00 00 
02320     00 00 00 00 | null  			long 	0,0           ' for channel reset
02324                 | 	alignl
02324                 | _psram_dat_
02324     00 00 00 00 
      ...             
0241c     00 00 00 00 
02420     00 00 00 00 |     listdata long 0[8*8]
02424                 |             orgh
02424                 | 
02424                 | ' driver state
02424     FF FF FF FF | drivercog   long    -1  ' COG id of driver
02428     FF FF FF FF | driverlock  long    -1  ' LOCK id of driver
0242c                 | 
0242c                 | ' delay profile
0242c     07 00 00 00 
02430     00 CF 7B 05 
02434     80 D1 F0 08 
02438     80 4F 47 0C | delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
0243c     80 C4 60 0F 
02440     80 39 7A 12 
02444     40 2D D9 13 
02448     00 00 00 00 | 	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
0244c                 | 
0244c                 | ' data to be passed to driver when starting it
0244c                 | startupData
0244c     00 00 00 00 |     long    0           ' current frequency
02450     00 00 00 00 |     long    FLAGS       ' optional flags for driver
02454     00 00 00 00 |     long    0           ' reset pin mask on port A for PSRAM (none)
02458     00 00 00 00 |     long    0           ' reset pin mask on port B for PSRAM (none)
0245c     28 00 00 00 |     long    DATABUS     ' PSRAM data bus start pin
02460     6C 24 00 00 |     long    deviceData  ' address of devices data structure in HUBRAM
02464     EC 24 00 00 |     long    qosData     ' address of QoS data structure in HUBRAM
02468     0C 25 00 00 |     long    mailboxes   ' address of mailbox structure in HUBRAM
0246c                 | 
0246c                 | ' data for memory
0246c                 | deviceData
0246c                 |     ' 16 bank parameters follow (16MB per bank)
0246c     00 00 00 00 
      ...             
024a4     00 00 00 00 
024a8     00 00 00 00 |     long    0[16]                               ' banks 0-15
024ac                 |     ' 16 banks of pin parameters follow
024ac     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
024b0     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
024b4     FF FF FF FF 
      ...             
024e4     FF FF FF FF 
024e8     FF FF FF FF |     long    -1[14]                              ' banks 2-15
024ec                 | 
024ec                 | ' data for COG polling
024ec                 | qosData 
024ec     00 00 FF FF 
024f0     00 00 FF FF 
024f4     00 00 FF FF 
024f8     00 00 FF FF |     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
024fc     00 00 FF FF 
02500     00 00 FF FF 
02504     00 00 FF FF 
02508     00 00 FF FF | 	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
0250c                 |     
0250c                 | ' mailbox storage
0250c                 | 
0250c                 | mailboxes
0250c     00 00 00 00 
      ...             
02564     00 00 00 00 
02568     00 00 00 00 |     long    0[8*3]          ' 3 longs per mailbox per COG
0256c                 | 	alignl
0256c                 | _psram16drv_dat_
0256c                 |                             orgh
0256c     00 00 00 00 
      ...             
02584     00 00 00 00 
02588     00 00 00 00 | scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
0258c                 | 
0258c                 | driver_start
0258c                 |                             org
0258c 000             | '..................................................................................................
0258c 000             | ' Memory layout for COG RAM once operational:
0258c 000             | '
0258c 000             | '  COG RAM address      Usage
0258c 000             | '  ---------------      ----
0258c 000             | '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
0258c 000             | '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
0258c 000             | '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
0258c 000             | '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
0258c 000             | '   $100-$197           Mailbox poller, error handlers, and all driver management code
0258c 000             | '  ~$198-$1F3           State and register variables
0258c 000             | '
0258c 000             | ' Also during driver COG startup:
0258c 000             | '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
0258c 000             | ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
0258c 000             | '..................................................................................................
0258c 000             |                             
0258c 000             | ' Mailbox storage after vector initialization
0258c 000             | 
0258c 000 FC 01 B0 FD | req0                        call    #init                   'do HW setup/initialization
02590 001 F0 E3 AB FA | data0                       rdlut   c, b wz                 'read bank info          
02594 002 F0 DF 03 F6 | count0                      mov     a, b                    'set COGRAM address low nibble
02598 003 68 F0 07 A6 | req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
0259c 004 0A E2 17 F4 | data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
025a0 005 50 F0 07 16 | count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
025a4 006 58 F0 07 46 | req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
025a8 007 08 E2 07 F6 | data2                       mov     c, #$8                  'setup vector base to $80
025ac 008 F1 DF 0B F8 | count2                      setnib  a, c, #1                'prepare vector base address for bank
025b0 009 00 DE 8F F9 | req3                        altd    a, #0                   'prepare COG destination read address
025b4 00a 61 01 A4 FA | data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
025b8 00b 0F E2 0F F7 | count3                      incmod  c, #15 wz               'next vector
025bc 00c EC FF 9F 5D | req4        if_nz           jmp     #count2                 'repeat
025c0 00d 0F E0 0F F7 | data4                       incmod  b, #15 wz               'next bank
025c4 00e C8 FF 9F 5D | count4      if_nz           jmp     #data0                  'repeat
025c8 00f 20 F0 07 F6 | req5                        mov     ptra, #$20              'setup base LUT address to clear
025cc 010 50 0A DC FC | data5                       rep     #5, #80                 'update next 80 longs      
025d0 011 E2 F1 13 F2 | count5                      cmp     ptra, header wc         'check if LUT address range 
025d4 012 E3 F1 93 32 | req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
025d8 013 61 01 3C CC | data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
025dc 014 61 B1 37 3C | count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
025e0 015 A5 29 00 31 | req7        if_nc           add     $-1, const512           'increment source of LUT write data
025e4 016 FF C0 03 F6 | data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
025e8 017 26 FF 05 06 | count7      _ret_           mov     255, #dolist            'setup list address, return to notify
025ec 018             | 
025ec 018             | ' Mailbox parameter addresses per COG once patched
025ec 018             |                             
025ec 018 04 00 00 00 | cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
025f0 019 10 00 00 00 | cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
025f4 01a 1C 00 00 00 | cog2mboxdata                long    2*12+4                  '...
025f8 01b 28 00 00 00 | cog3mboxdata                long    3*12+4
025fc 01c 34 00 00 00 | cog4mboxdata                long    4*12+4
02600 01d 40 00 00 00 | cog5mboxdata                long    5*12+4
02604 01e 4C 00 00 00 | cog6mboxdata                long    6*12+4
02608 01f 58 00 00 00 | cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
0260c 020             | 
0260c 020             | '..................................................................................................
0260c 020             | ' Per COG request and state setup and service branching
0260c 020             |         
0260c 020             | cog0                 
0260c 020 20 F0 07 F6 |                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
02610 021 18 F2 03 F6 |                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
02614 022 D0 C3 03 F6 |                             mov     id, id0                 'get COG0 state
02618 023 E1 47 3B F9 |                             getword limit, id, #1           'get COG0 burst limit
0261c 024 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
02620 025 30 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
02624 026 00 B0 03 F6 |                             mov     addr1, req0             'get mailbox request parameter for COG0
02628 027 01 B2 03 F6 |                             mov     hubdata, data0          'get COG0 mailbox data parameter
0262c 028 02 B4 03 F6 |                             mov     count, count0           'get COG0 mailbox count parameter
02630 029 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
02634 02a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
02638 02b 33 CA 63 FD |                             execf   request-0               'jump to service
0263c 02c             | cog1                        
0263c 02c 2A F0 07 F6 |                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
02640 02d 19 F2 03 F6 |                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
02644 02e D1 C3 03 F6 |                             mov     id, id1                 'get COG1 state
02648 02f E1 47 3B F9 |                             getword limit, id, #1           'get COG1 burst limit
0264c 030 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
02650 031 00 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
02654 032 03 B0 03 F6 |                             mov     addr1, req1             'get mailbox request parameter for COG1
02658 033 04 B2 03 F6 |                             mov     hubdata, data1          'get COG1 mailbox data parameter
0265c 034 05 B4 03 F6 |                             mov     count, count1           'get COG1 mailbox count parameter
02660 035 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
02664 036 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
02668 037 33 CA 63 FD |                             execf   request-0               'jump to service
0266c 038             | cog2                         
0266c 038 34 F0 07 F6 |                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
02670 039 1A F2 03 F6 |                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
02674 03a D2 C3 03 F6 |                             mov     id, id2                 'get COG2 state
02678 03b E1 47 3B F9 |                             getword limit, id, #1           'get COG2 burst limit
0267c 03c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
02680 03d D0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
02684 03e 06 B0 03 F6 |                             mov     addr1, req2             'get mailbox request parameter for COG2
02688 03f 07 B2 03 F6 |                             mov     hubdata, data2          'get COG2 mailbox data parameter
0268c 040 08 B4 03 F6 |                             mov     count, count2           'get COG2 mailbox count parameter
02690 041 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
02694 042 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
02698 043 33 CA 63 FD |                             execf   request-0               'jump to service
0269c 044             | cog3                        
0269c 044 3E F0 07 F6 |                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
026a0 045 1B F2 03 F6 |                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
026a4 046 D3 C3 03 F6 |                             mov     id, id3                 'get COG3 state
026a8 047 E1 47 3B F9 |                             getword limit, id, #1           'get COG3 burst limit
026ac 048 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
026b0 049 A0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
026b4 04a 09 B0 03 F6 |                             mov     addr1, req3             'get mailbox request parameter for COG3
026b8 04b 0A B2 03 F6 |                             mov     hubdata, data3          'get COG3 mailbox data parameter
026bc 04c 0B B4 03 F6 |                             mov     count, count3           'get COG3 mailbox count parameter
026c0 04d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
026c4 04e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
026c8 04f 33 CA 63 FD |                             execf   request-0               'jump to service
026cc 050             | cog4                        
026cc 050 48 F0 07 F6 |                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
026d0 051 1C F2 03 F6 |                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
026d4 052 D4 C3 03 F6 |                             mov     id, id4                 'get COG4 state
026d8 053 E1 47 3B F9 |                             getword limit, id, #1           'get COG4 burst limit
026dc 054 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
026e0 055 70 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
026e4 056 0C B0 03 F6 |                             mov     addr1, req4             'get mailbox request parameter for COG4
026e8 057 0D B2 03 F6 |                             mov     hubdata, data4          'get COG4 mailbox data parameter
026ec 058 0E B4 03 F6 |                             mov     count, count4           'get COG4 mailbox count parameter
026f0 059 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
026f4 05a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
026f8 05b 33 CA 63 FD |                             execf   request-0               'jump to service
026fc 05c             | cog5                        
026fc 05c 52 F0 07 F6 |                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
02700 05d 1D F2 03 F6 |                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
02704 05e D5 C3 03 F6 |                             mov     id, id5                 'get COG5 state
02708 05f E1 47 3B F9 |                             getword limit, id, #1           'get COG5 burst limit
0270c 060 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
02710 061 40 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
02714 062 0F B0 03 F6 |                             mov     addr1, req5             'get mailbox request parameter for COG5
02718 063 10 B2 03 F6 |                             mov     hubdata, data5          'get COG5 mailbox data parameter
0271c 064 11 B4 03 F6 |                             mov     count, count5           'get COG5 mailbox count parameter
02720 065 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
02724 066 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
02728 067 33 CA 63 FD |                             execf   request-0               'jump to service
0272c 068             | cog6                        
0272c 068 5C F0 07 F6 |                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
02730 069 1E F2 03 F6 |                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
02734 06a D6 C3 03 F6 |                             mov     id, id6                 'get COG6 state
02738 06b E1 47 3B F9 |                             getword limit, id, #1           'get COG6 burst limit
0273c 06c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
02740 06d 10 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
02744 06e 12 B0 03 F6 |                             mov     addr1, req6             'get mailbox request parameter for COG6
02748 06f 13 B2 03 F6 |                             mov     hubdata, data6          'get COG6 mailbox data parameter
0274c 070 14 B4 03 F6 |                             mov     count, count6           'get COG6 mailbox count parameter
02750 071 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
02754 072 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
02758 073 33 CA 63 FD |                             execf   request-0               'jump to service
0275c 074             | cog7                        
0275c 074 66 F0 07 F6 |                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
02760 075 1F F2 03 F6 |                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
02764 076 D7 C3 03 F6 |                             mov     id, id7                 'get COG7 state
02768 077 E1 47 3B F9 |                             getword limit, id, #1           'get COG7 burst limit
0276c 078 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
02770 079 E0 02 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
02774 07a 15 B0 03 F6 |                             mov     addr1, req7             'get mailbox request parameter for COG7
02778 07b 16 B2 03 F6 |                             mov     hubdata, data7          'get COG7 mailbox data parameter
0277c 07c 17 B4 03 F6 |                             mov     count, count7           'get COG7 mailbox count parameter
02780 07d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
02784 07e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
02788 07f 33 CA 63 FD |                             execf   request-0               'jump to service
0278c 080             | 
0278c 080             |                             fit     128
0278c 080             |                             fit     128
0278c 080             | pad                         long    0[128-$]                'align init code to $80
0278c 080             | 
0278c 080             | '..................................................................................................
0278c 080             | 
0278c 080             | ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
0278c 080             | 
0278c 080             | init                        
0278c 080             |                             ' get driver scratch long address in hub
0278c 080 01 DA 63 FD |                             cogid   hubscratch              'get cogid
02790 081 01 DA 07 F1 |                             add     hubscratch, #1          'increase by 1 from 1-8
02794 082 04 DA 07 FA |                             mul     hubscratch, #4          'multiply by 4 to get 4-32
02798 083 F9 DB C3 F2 |                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
0279c 084             |                     
0279c 084             |                             ' read in the additional LUT RAM code
0279c 084 F9 41 03 F1 |                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
027a0 085 29 9E 67 FD |                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
027a4 086 A0 61 00 FB |                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
027a8 087             | 
027a8 087             |                             ' read the startup parameters
027a8 087 28 0E 64 FD |                             setq    #8-1                    'read 8 longs from hub
027ac 088 00 41 07 FB |                             rdlong  startupparams, ptra     '.. as the startup parameters 
027b0 089             | 
027b0 089             |                             ' setup some of the config flag dependent state and patch LUTRAM
027b0 089 1C 42 0F F4 |                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
027b4 08a             | 
027b4 08a F9 71 03 A1 |             if_z            add     expansion, ptrb         'compensate for HUB address
027b8 08b 01 00 00 5F 
027bc 08c FB 70 07 56 |             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
027c0 08d 1D 42 17 F4 |                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
027c4 08e AA 57 43 35 |             if_nc           or      clkconfig, registered   'enable this if so
027c8 08f 00 58 07 36 |             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
027cc 090             | 
027cc 090             |                             ' setup data pin modes and data bus pin group in streamer commands
027cc 090 38 48 07 F5 |                             and     datapins, #%111000      'compute base pin
027d0 091 01 00 00 FF 
027d4 092 C0 49 47 F5 |                             or      datapins, ##(15<<6)     'configure 16 pins total
027d8 093 A4 DF 03 F6 |                             mov     a, datapins             'get data pin base
027dc 094 A4 55 03 FC |                             wrpin   registered, datapins    'prepare data pins for address phase transfer
027e0 095 03 DE 47 F0 |                             shr     a, #3                   'determine data pin group
027e4 096 07 DE 07 F5 |                             and     a, #7                   'ignore the unwanted bits
027e8 097 08 DE 47 F5 |                             or      a, #8
027ec 098 EF 2F 2B F8 |                             setnib  ximm8lut, a, #5         'setup bus group in streamer
027f0 099 EF 31 2B F8 |                             setnib  xrecvlo8, a, #5
027f4 09a EF 35 2B F8 |                             setnib  xrecvdata, a, #5
027f8 09b EF 37 2B F8 |                             setnib  xsenddata, a, #5
027fc 09c EF 39 2B F8 |                             setnib  xsendimm, a, #5
02800 09d 01 DE 07 F1 |                             add     a, #1
02804 09e EF 33 2B F8 |                             setnib  xrecvhi8, a, #5         ' increase port by one
02808 09f             |  
02808 09f             |                             ' setup device control pin states
02808 09f 29 3E 64 FD |                             setq2   #32-1                   'read 32 longs to LUTRAM
0280c 0a0 A5 01 00 FB |                             rdlong  $000, devicelist        'read bank/pin data for all banks    
02810 0a1 01 00 00 FF 
02814 0a2 00 4A 07 F6 |                             mov     const512, ##512         'prepare constant
02818 0a3             | 
02818 0a3 10 F2 07 F6 |                             mov     ptrb, #16               'point to bank pin config data
0281c 0a4 10 14 DC FC |                             rep     @pinloop, #16           'iterate through 16 banks
02820 0a5 E1 CF B7 FA |                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
02824 0a6 AF CF 03 F5 |                             and     pinconfig, pinmask      'save us from invalid bits in args
02828 0a7 E7 53 E3 38 |             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
0282c 0a8 A9 01 08 3C |             if_nc           wrpin   #0, cspin               'clear smart pin mode
02830 0a9 59 52 63 3D |             if_nc           drvh    cspin                   'setup pins for all banks
02834 0aa E7 51 EB 38 |             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
02838 0ab 50 50 63 3D |             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
0283c 0ac A8 57 03 3C |             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
02840 0ad A8 03 18 3C |             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
02844 0ae 58 50 63 3D |             if_nc           drvl    clkpin                  'set clk state low
02848 0af             | pinloop
02848 0af             |                             ' generate minimum CE high time before access
02848 0af A1 07 00 FF 
0284c 0b0 40 40 17 FD |                             qdiv    frequency, ##1000000    'convert from Hz to MHz
02850 0b1 18 E2 63 FD |                             getqx   c                       'get P2 clocks per microsecond
02854 0b2 96 DE 07 F6 |                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
02858 0b3 F1 DF 03 FA |                             mul     a, c                    'convert microseconds to clocks
0285c 0b4 1F DE 63 FD |                             waitx   a                       'delay
02860 0b5 E8 05 B0 FD |                             call    #hwinit                 'setup HW into QSPI mode
02864 0b6             | 
02864 0b6             |                             ' setup the COG mailboxes and addresses 
02864 0b6 08 04 DC FC |                             rep     #2, #8                  'setup loop to patch mailbox addresses
02868 0b7 38 70 A5 F9 |                             alti    $+1, #%111_000          'increase D field
0286c 0b8 A7 31 00 F1 |                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
02870 0b9             | 
02870 0b9 28 2E 64 FD |                             setq    #24-1
02874 0ba A7 01 68 FC |                             wrlong  #0, mbox                'clear out mailboxes ????
02878 0bb             | 
02878 0bb             |                             ' setup the polling loop for active COGs 
02878 0bb 01 C2 63 FD |                             cogid   id
0287c 0bc D0 C3 97 F9 |                             alts    id, #id0                'determine id register of control COG
02880 0bd 00 90 B6 F9 |                             setd    patchid, #0             'patch into destination address
02884 0be 2A F0 63 FD |                             push    ptra                    'save ptra before we lose it
02888 0bf 0A F0 07 F6 |                             mov     ptra, #10
0288c 0c0 E1 F1 03 FA |                             mul     ptra, id
02890 0c1 20 F0 07 F1 |                             add     ptra, #$20              'prep ptra for reloadcogs
02894 0c2 B0 C3 97 F9 |                             alts    id, #cog0_handler       'add to handler base
02898 0c3 00 48 BE F9 |                             sets    ctrlpollinst, #0-0      'patch into jump instruction
0289c 0c4 03 C2 07 FA |                             mul     id, #3
028a0 0c5 E1 49 B2 F9 |                             setd    ctrlpollinst, id
028a4 0c6 09 C3 A7 FA |                             rdlut   id, ptra[9]             'save original value
028a8 0c7 09 C1 37 FC |                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
028ac 0c8 D8 01 B0 FD |                             call    #reloadcogs
028b0 0c9 09 C3 37 FC |                             wrlut   id, ptra[9]             'restore original value
028b4 0ca 2B F0 63 FD |                             pop     ptra                    'restore original ptra
028b8 0cb             |                             ' move LUT control vectors into temporary location to avoid clobbering them later
028b8 0cb D8 E5 B7 F9 |                             setd    d, #addr1
028bc 0cc 60 E4 BF F9 |                             sets    d, #(ctrl_vect & $1ff)
028c0 0cd 08 04 DC FC |                             rep     #2, #8
028c4 0ce 3F E4 A7 F9 |                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
028c8 0cf 60 B0 A7 FA |                             rdlut   addr1-0, #$60-0
028cc 0d0             | 
028cc 0d0             |                             'setup control COG service handling, we need to patch 5 instructions
028cc 0d0             |                             'one existing instruction is moved earlier and four instructions get replaced
028cc 0d0 01 C2 63 FD |                             cogid   id
028d0 0d1 0C DE 07 F6 |                             mov     a, #(cog1-cog0)         'get code separation of handlers
028d4 0d2 E1 DF 03 FA |                             mul     a, id                   'scale ID by separation
028d8 0d3 24 DE 07 F1 |                             add     a, #cog0+4              'add to base for COG0 and offset
028dc 0d4 EF E5 B3 F9 |                             setd    d, a                    'set this as the destination
028e0 0d5 02 DE 07 F1 |                             add     a, #2                   'increment COG address
028e4 0d6 EF E5 BB F9 |                             sets    d, a                    'set this as the source
028e8 0d7 3C E4 A7 F9 |                             alti    d, #%111_100             
028ec 0d8 00 00 00 F6 |                             mov     0-0, 0-0                'move instruction
028f0 0d9 EE E4 BF F9 |                             sets    d, #controlpatch        'set source of patched instructions
028f4 0da 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
028f8 0db 3F E4 A7 F9 |                             alti    d, #%111_111
028fc 0dc 00 00 00 F6 |                             mov     0-0, 0-0
02900 0dd A5 E5 03 F1 |                             add     d, const512             'skip two instructions
02904 0de A5 E5 03 F1 |                             add     d, const512
02908 0df 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
0290c 0e0 3F E4 A7 F9 |                             alti    d, #%111_111
02910 0e1 00 00 00 F6 |                             mov     0-0, 0-0
02914 0e2             |                             
02914 0e2             |                             ' setup register values for control vector loop setup after we return
02914 0e2 E1 C5 03 F6 |                             mov     header, id              'get cog ID
02918 0e3 0A C4 07 FA |                             mul     header, #10             'multiply by size of state memory per COG
0291c 0e4 20 C4 07 F1 |                             add     header, #$20            'add to COG state base address in LUT
02920 0e5 E2 C7 03 F6 |                             mov     trailer, header         'determine start/end LUT address
02924 0e6 09 C6 07 F1 |                             add     trailer, #9             '...for control region
02928 0e7 E0 C3 43 F5 |                             or      id, initctrl            'set id field for control COG
0292c 0e8 D0 C3 8F F9 |                             altd    id, #id0
02930 0e9 E1 01 00 F6 |                             mov     0-0, id                 'setup id field for notification
02934 0ea F8 F3 03 F6 |                             mov     ptrb, ptra              'get startup parameter address
02938 0eb 04 F2 07 F1 |                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
0293c 0ec 00 E0 07 F6 |                             mov     b, #0                   'prepare b for upcoming loop
02940 0ed 2A 14 66 0D |                 _ret_       push    #notify                 'continue init in mailbox area
02944 0ee             |  
02944 0ee D8 CB 7B F8 | controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
02948 0ef 07 CA 07 F5 |                             and     request, #7
0294c 0f0 F8 CB 03 F1 |                             add     request, ptra           'add request vector offset
02950 0f1 E5 CB A3 FA |                             rdlut   request, request        'lookup jump vector service table 
02954 0f2             | 
02954 0f2             |                             fit     $100                    'ensure all init code fits this space
02954 0f2             |                             fit     $100                    'ensure all init code fits this space
02954 0f2             | 
02954 0f2 00 00 00 00 
      ...             
02984 0fe 00 00 00 00 
02988 0ff 00 00 00 00 |                             long    0[$100-$]               'pad more if required until table ends
0298c 100             | 
0298c 100             | '..................................................................................................
0298c 100             | ' Error result handling and COG notification of request completion
0298c 100             | 
0298c 100 04 04 4C FB | unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
02990 101 03 02 4C FB | invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
02994 102 02 06 4C FB | invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
02998 103 01 08 4C FB | alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
0299c 104 05 EC 07 F6 | busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
029a0 105 D0 C3 8F F9 | err                         altd    id, #id0                'adjust for the running COG
029a4 106 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
029a8 107 08 01 3C FC |                             wrlut   #0, ptra[8]             'cancel any resume state
029ac 108 32 04 64 FD |                             skipf   #%10                    'dont notify with success code 0 below
029b0 109 BF ED 67 FC |                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
029b4 10a BF 01 6C FC | notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
029b8 10b 0B C2 0F F4 |                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
029bc 10c E1 DF C3 F9 |                             decod   a, id                   'convert COG ID to bitmask
029c0 10d 3F DE 63 AD |             if_z            cogatn  a                       'notify COG via ATN
029c4 10e             | ' Poller re-starts here after a COG is serviced
029c4 10e 0F C2 0F F4 | poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
029c8 10f E6 5F 03 57 |             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
029cc 110 AF 45 CB F9 |                             bmask   mask, rrcounter         'generate a RR skip mask from the count
029d0 111             | ' Main dynamic polling loop repeats until a request arrives
029d0 111 00 00 DC FC | polling_loop                rep     #0-0, #0                'repeat until we get a request for something
029d4 112 28 2E 64 FD |                             setq    #24-1                   'read 24 longs
029d8 113 A7 01 00 FB |                             rdlong  req0, mbox              'get all mailbox requests and data longs
029dc 114             | 
029dc 114 B0 01 B0 FB | polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
029e0 115 32 44 63 FD |                             skipf   mask                    ']after all priority COG handlers if present
029e4 116 B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
029e8 117 B2 0D B0 FB |                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
029ec 118 B3 13 B0 FB |                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
029f0 119 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
029f4 11a B5 1F B0 FB |                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
029f8 11b B6 25 B0 FB |                             tjs     req6, cog6_handler      ']based on the active COGs being polled
029fc 11c B7 2B B0 FB |                             tjs     req7, cog7_handler      ']and whether priority or round robin.
02a00 11d B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
02a04 11e B2 0D B0 FB |                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
02a08 11f B3 13 B0 FB |                             tjs     req3, cog3_handler      ']have changed.
02a0c 120 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
02a10 121 B5 1F B0 FB |                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
02a14 122 B6 25 B0 FB |                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
02a18 123 B7 2B B0 FB | pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
02a1c 124             | 
02a1c 124 B0 01 B0 FB | ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
02a20 125 32 44 63 FD | skipfinst                   skipf   mask                    'instruction template for skipf
02a24 126             |  
02a24 126             | '..................................................................................................
02a24 126             | ' List handler                               
02a24 126             | 
02a24 126 01 B0 A7 FB | dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
02a28 127 33 C0 63 FD |                             execf   burstwrite              'otherwise do a burst write to this bank
02a2c 128 28 0E 64 FD | real_list                   setq    #8-1                    'read 8 longs (largest request size)
02a30 129 D9 B1 03 FB |                             rdlong  addr1, hubdata          '..to update the request state
02a34 12a D7 B1 BF FB |                             tjns    addr1, #invalidlist     'error if request list item not valid
02a38 12b D0 C3 8F F9 |                             altd    id, #id0                'get COG state
02a3c 12c 09 00 3C F4 |                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
02a40 12d 09 C2 27 F4 |                             bith    id, #LIST_BIT           'retain fact that we are in a list
02a44 12e 44 FF 9F AD |             if_z            jmp     #unsupported            'no list recursion is allowed!
02a48 12f D8 CB FB F8 |                             getbyte request, addr1, #3      'get upper byte of this request
02a4c 130 00 CA 8F F9 | service_request             altd    request, #0             'get request address in COG RAM
02a50 131 33 00 60 FD |                             execf   0-0                     'process the request 
02a54 132             | 
02a54 132             | '..................................................................................................
02a54 132             | ' Restoring per COG state and resuming where we left off
02a54 132             | 
02a54 132 00 B1 A7 FA | restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
02a58 133 01 B3 A7 FA |                             rdlut   hubdata, ptra[1]
02a5c 134 02 B5 A7 FA |                             rdlut   count, ptra[2]
02a60 135 03 B7 B7 FA |                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
02a64 136 D8 CB FB F8 |                             getbyte request, addr1, #3
02a68 137 33 D2 63 3D |             if_nc           execf   resume                  'if not extended then resume immediately
02a6c 138 04 B9 A7 FA |                             rdlut   total, ptra[4]          'we need to read the extended parameters
02a70 139 05 BB A7 FA |                             rdlut   offset1, ptra[5]
02a74 13a 06 BD A7 FA |                             rdlut   offset2, ptra[6]
02a78 13b 07 BF A7 FA |                             rdlut   link, ptra[7]
02a7c 13c 09 D5 A7 FA |                             rdlut   orighubsize, ptra[9]
02a80 13d 33 D2 63 FD |                             execf   resume                  'then resume what we were doing last time
02a84 13e             |                    
02a84 13e             | '..................................................................................................
02a84 13e             | ' Re-configuration of QoS settings and custom polling loop sequence generator
02a84 13e             | 
02a84 13e 2A 14 66 FD | reconfig                    push    #notify                 'setup return addr, then reload 
02a88 13f 28 0E 64 FD | reloadcogs                  setq    #8-1                    'reload all per COG QoS params
02a8c 140 A6 B1 03 FB |                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
02a90 141 D0 DF B7 F9 |                             setd    a, #id0
02a94 142 D8 DF BF F9 |                             sets    a, #addr1
02a98 143 FE FF FF FF 
02a9c 144 28 00 66 FD |                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
02aa0 145 08 04 DC FC |                             rep     #2, #8                  'repeat for 8 COGs
02aa4 146 3F DE A7 F9 |                             alti    a, #%111_111 
02aa8 147 00 00 F0 F9 |                             muxq    0-0, 0-0
02aac 148 09 01 A4 FA | patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
02ab0 149 01 E2 63 FD |                             cogid   c
02ab4 14a F1 41 C3 F9 |                             decod   excludedcogs, c         'exclude driver cog initially
02ab8 14b 08 DE 07 F6 |                             mov     a, #$8                  'a iterates through prio levels 8=lowest
02abc 14c 01 EC 67 F6 |                             neg     pa, #1                  'start with all ones
02ac0 14d 07 E2 07 F6 | fillprio                    mov     c, #7                   'c iterates through cogs
02ac4 14e D0 E3 97 F9 | prioloop                    alts    c, #id0
02ac8 14f 00 E0 03 F6 |                             mov     b, 0-0
02acc 150 F0 E5 3B F9 |                             getword d, b, #1                'get burst field
02ad0 151 F2 E5 CB F7 |                             test    d wz                    'if burst=0 
02ad4 152 F1 41 23 A4 |             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
02ad8 153 0C 00 90 AD |             if_z            jmp     #excluded               
02adc 154 F0 E5 5B F8 |                             getnib  d, b, #3                'get RR/PRI flag & priority
02ae0 155 EF E5 0B F2 |                             cmp     d, a wz                 'compare against current priority level
02ae4 156 F1 ED 83 A8 |             if_z            rolnib  pa, c, #0               'if matches include COG at this level
02ae8 157 F6 E3 7F FB | excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
02aec 158 0F DE 0F F7 |                             incmod  a, #15 wz               'next level
02af0 159 CC FF 9F 5D |             if_nz           jmp     #fillprio 
02af4 15a             | 
02af4 15a             | 'determine priority cogs and build instructions for the polling sequence
02af4 15a 00 EE 07 F6 |                             mov     pb, #0                  'clear out set of priority COGs
02af8 15b 03 DE 07 F6 |                             mov     a, #3                   'start with no COGs being polled + 3 instructions
02afc 15c 14 E5 B7 F9 |                             setd    d, #polling_code        'initialize COGRAM write position
02b00 15d             | 
02b00 15d 08 18 DC FC |                             rep     @endprioloop, #8        'test all 8 priority slots
02b04 15e 03 EC 17 F4 |                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
02b08 15f F6 E3 43 F8 |                             getnib  c, pa, #0               'get cogid ID at this priority level
02b0c 160 F1 EF 0B 34 |             if_nc           testb   pb, c wz                'check if already exists as priority COG
02b10 161 F1 EF 23 14 |             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
02b14 162 01 DE 07 11 |             if_nc_and_nz    add     a, #1                   'add another COG to poll 
02b18 163 B0 E3 97 19 |             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
02b1c 164 00 46 BE 19 |             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
02b20 165 03 E2 07 1A |             if_nc_and_nz    mul     c, #3
02b24 166 F1 47 B2 19 |             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
02b28 167 38 E4 A7 19 |             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
02b2c 168 23 01 00 16 |             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
02b30 169 04 EC 07 F0 |                             ror     pa, #4                  'advance to next priority
02b34 16a             | endprioloop
02b34 16a FF EE 67 F5 |                             xor     pb, #$ff                'invert to find all the non-priority COGs
02b38 16b A0 EF 23 F5 |                             andn    pb, excludedcogs        'and remove any other excluded COGs
02b3c 16c F7 CD AB F7 |                             ones    rrlimit, pb wz          'count the number of RR COGs
02b40 16d E6 DF 03 F1 |                             add     a, rrlimit              'account for this number of RR COGs to poll
02b44 16e 01 CC 87 F1 |                             sub     rrlimit, #1             'setup last RR count value for incmod
02b48 16f 38 E4 A7 F9 |                             alti    d, #%111_000            'generate the control polling instruction
02b4c 170 24 01 00 F6 |                             mov     0-0, ctrlpollinst       'write the instruction
02b50 171 38 E4 A7 59 |             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
02b54 172 25 01 00 56 |             if_nz           mov     0-0, skipfinst          'add the skipf instruction
02b58 173 02 DE 07 51 |             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
02b5c 174 EF 23 B2 F9 |                             setd    polling_loop, a         'save it as the repeat count
02b60 175 2D 00 64 AD |             if_z            ret                             'we are done now, if no round robin COGs
02b64 176             | 
02b64 176             | ' populate the round robin COG polling instructions
02b64 176 02 5E 07 F6 |                             mov     rrcounter, #2           'fill the RR poll instruction list twice
02b68 177 F7 E1 03 F6 | rrloop                      mov     b, pb                   'get the set of RR COGs
02b6c 178 00 E2 07 F6 |                             mov     c, #0                   'start at COG ID = 0
02b70 179 00 DE 07 F6 |                             mov     a, #0                   'req mailbox COGRAM address for COG 0
02b74 17a 01 E0 5F F0 | nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
02b78 17b EF 47 B2 C9 |             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
02b7c 17c B0 E3 97 C9 |             if_c            alts    c, #cog0_handler        'determine jump address
02b80 17d 00 46 BE C9 |             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
02b84 17e 38 E4 A7 C9 |             if_c            alti    d, #%111_000            'generate new COG RAM write address
02b88 17f 23 01 00 C6 |             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
02b8c 180 01 E2 07 F1 |                             add     c, #1                   'increment the COG ID
02b90 181 03 DE 07 F1 |                             add     a, #3                   'increase the request address
02b94 182 DC FF 9F 5D |             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
02b98 183 F3 5F 6F 0B |             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
02b9c 184             | '..................................................................................................
02b9c 184             | ' Code to get/set driver settings per bank or to dump COG/LUT state
02b9c 184             | 
02b9c 184             | set_latency                                                 '            (a) set latency
02b9c 184             | get_latency                                                 '            (b) get latency
02b9c 184             | set_burst                                                   '            (c) set burst size of bank
02b9c 184             | get_burst                                                   '            (d) get burst size of bank
02b9c 184             |                                                             '            (e) dump state
02b9c 184 D8 E1 73 F8 |                             getnib  b, addr1, #6            ' a b c d    get bank address
02ba0 185 28 FE 67 FD | dump_state                  setq    #511                    ' | | | | e  prepare burst write
02ba4 186 D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
02ba8 187             |                                                             ' | | | | e  account for following AUGS
02ba8 187 04 00 00 FF 
02bac 188 00 B2 07 F1 |                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
02bb0 189 29 FE 67 FD |                             setq2   #511                    ' | | | | e  prepare burst write
02bb4 18a D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
02bb8 18b 10 E0 07 F1 |                             add     b, #16                  ' a b | | |  point to latency params
02bbc 18c F0 DF A3 FA |                             rdlut   a, b                    ' a b c d |  read data for bank
02bc0 18d D9 DF DB F8 |                             setbyte a, hubdata, #3          ' a | | | |  patch latency
02bc4 18e D9 DF 03 F6 |                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
02bc8 18f F0 DF 33 FC |                             wrlut   a, b                    ' a | c | |  if setting, save bank data
02bcc 190 EF DF FB F8 |                             getbyte a, a, #3                ' | b | | |  extract latency field only
02bd0 191 80 DF 67 FC |                             wrlong  a, ptrb                 ' | b | d |  write result          
02bd4 192 DC FD 9F FD |                             jmp     #notify                 ' a b c d e  return success
02bd8 193             | 
02bd8 193             | '..................................................................................................
02bd8 193             | ' Misc EXECF code
02bd8 193             | 
02bd8 193 33 72 63 FD | start_read_exec             execf   newburstr
02bdc 194 33 7C 63 FD | start_write_exec            execf   resumewrites
02be0 195 33 78 63 FD | continue_read_exec          execf   lockedreads
02be4 196 33 7A 63 FD | continue_write_exec         execf   lockedwrites
02be8 197             | 
02be8 197             | '..................................................................................................
02be8 197             | ' Variables
02be8 197             | 
02be8 197 08 00 CF 20 | ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
02bec 198 01 00 C6 E0 | xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
02bf0 199 01 00 C6 E0 | xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
02bf4 19a 00 00 C0 F0 | xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
02bf8 19b 00 00 C0 B0 | xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
02bfc 19c 02 00 C0 70 | xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
02c00 19d             | 
02c00 19d 00 00 00 80 | xfreq1          long    $80000000
02c04 19e 00 00 00 40 | xfreq2          long    $40000000
02c08 19f 03 00 00 00 | delay           long    3
02c0c 1a0             | 
02c0c 1a0             | lutcodeaddr                 
02c0c 1a0             | startupparams
02c0c 1a0             | excludedcogs                                    'careful: shared register use!
02c0c 1a0 CC 07 00 00 | frequency       long    lut_code - driver_start 'determine offset of LUT code from base
02c10 1a1 00 00 00 00 | flags           long    0
02c14 1a2             | mask                                            'careful: shared register use!
02c14 1a2 00 00 00 00 | resetmaskA      long    0
02c18 1a3             | limit                                           'careful: shared register use!
02c18 1a3 00 00 00 00 | resetmaskB      long    0
02c1c 1a4 00 00 00 00 | datapins        long    0
02c20 1a5             | const512                                        'careful: shared register use!
02c20 1a5 00 00 00 00 | devicelist      long    0
02c24 1a6 00 00 00 00 | coglist         long    0
02c28 1a7 00 00 00 00 | mbox            long    0 
02c2c 1a8             | 
02c2c 1a8             | clkpin                                          'shared with code patched during init
02c2c 1a8 A8 03 18 FC | clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
02c30 1a9             | cspin                                           'shared with code patched during init
02c30 1a9 1D 3A 63 FD | speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
02c34 1aa 00 00 01 00 | registered      long    %100_000_000_00_00000_0 'config pin for clocked input
02c38 1ab 4A 00 00 00 | clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
02c3c 1ac 01 00 00 00 | clkdelay        long    1
02c40 1ad 00 00 00 00 | regdatabus      long    0
02c44 1ae             | 
02c44 1ae 10 00 00 00 | deviceaddr      long    $10
02c48 1af             | rrcounter
02c48 1af 7F 7F 3F FF | pinmask         long    $ff3f7f7f
02c4c 1b0             | 
02c4c 1b0             | ' jump addresses for the per COG handlers
02c4c 1b0 20 00 00 00 | cog0_handler    long    cog0
02c50 1b1 2C 00 00 00 | cog1_handler    long    cog1
02c54 1b2 38 00 00 00 | cog2_handler    long    cog2
02c58 1b3 44 00 00 00 | cog3_handler    long    cog3
02c5c 1b4 50 00 00 00 | cog4_handler    long    cog4
02c60 1b5 5C 00 00 00 | cog5_handler    long    cog5
02c64 1b6 68 00 00 00 | cog6_handler    long    cog6
02c68 1b7 74 00 00 00 | cog7_handler    long    cog7
02c6c 1b8 0C 0F 00 00 | expansion       long    gfxexpansion - driver_start
02c70 1b9             | 
02c70 1b9             | ' EXECF sequences
02c70 1b9 70 7A 80 22 | newburstr       long    (%0010001010000000011110 << 10) + r_burst
02c74 1ba 48 9B EF 00 | lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
02c78 1bb 41 F3 05 74 | restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
02c7c 1bc 80 22 3F 00 | lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
02c80 1bd 4B F3 E0 0F | lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
02c84 1be 4B 03 E0 0F | resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
02c88 1bf 76 02 8A 84 | resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
02c8c 1c0             | 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
02c8c 1c0             | 
02c8c 1c0             | 
02c8c 1c0             | ' SKIPF sequences
02c8c 1c0             | skiptable
02c8c 1c0 7E 30 0C 00 |                 long    %11000011000001111110  ' read modify write byte
02c90 1c1 0E 37 03 00 |                 long    %110011011100001110    ' read modify write word
02c94 1c2 00 00 00 00 |                 long    0                      ' read modify write long
02c98 1c3 7E 00 00 00 |                 long    %1111110               ' single byte read
02c9c 1c4 8E 07 00 00 |                 long    %11110001110           ' single word read
02ca0 1c5 00 00 00 00 | pattern2        long    0
02ca4 1c6 00 00 00 00 | pattern3        long    0
02ca8 1c7 77 02 00 00 | singlelong      long    %1001110111  
02cac 1c8 FD 10 80 6F | skipcase_a      long    %01101111100000000001000011111101
02cb0 1c9 10 18 50 00 | skipcase_b      long    %00000000010100000001100000010000
02cb4 1ca 11 3E 60 00 | skipcase_c      long    %00000000011000000011111000010001
02cb8 1cb 02 0F 00 00 | skipseq_write   long    %00000000000000000000111100000010
02cbc 1cc             | 
02cbc 1cc             | ' LUT RAM address values
02cbc 1cc FF 02 00 00 | complete_rw     long    complete_rw_lut
02cc0 1cd DD 02 00 00 | continue_read   long    continue_read_lut
02cc4 1ce DB 02 00 00 | continue_write  long    continue_write_lut
02cc8 1cf F6 02 00 00 | noread          long    noread_lut
02ccc 1d0             | 
02ccc 1d0 00 00 00 00 | id0             long    0
02cd0 1d1 01 00 00 00 | id1             long    1
02cd4 1d2 02 00 00 00 | id2             long    2
02cd8 1d3 03 00 00 00 | id3             long    3
02cdc 1d4 04 00 00 00 | id4             long    4
02ce0 1d5 05 00 00 00 | id5             long    5
02ce4 1d6 06 00 00 00 | id6             long    6
02ce8 1d7 07 00 00 00 | id7             long    7
02cec 1d8             | 
02cec 1d8             | 'These next 10 request registers below are also temporarily reused during init 
02cec 1d8             | 'and COG updates and need to follow immediately after id0-id7
02cec 1d8 00 00 00 00 | addr1           long    0
02cf0 1d9 00 00 00 00 | hubdata         long    0
02cf4 1da 00 00 00 00 | count           long    0
02cf8 1db 00 00 00 00 | addr2           long    0
02cfc 1dc 00 00 00 00 | total           long    0
02d00 1dd 00 00 00 00 | offset1         long    0
02d04 1de 00 00 00 00 | offset2         long    0
02d08 1df 00 00 00 00 | link            long    0
02d0c 1e0             | 
02d0c 1e0             | burstwrite                                      'note shared register use during init
02d0c 1e0 00 10 F0 FE | initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
02d10 1e1 00 00 00 00 | id              long    0
02d14 1e2             | 
02d14 1e2 00 00 00 00 | header          long    0
02d18 1e3 00 00 00 00 | trailer         long    0
02d1c 1e4 00 00 00 00 | cmdaddr         long    0
02d20 1e5 00 00 00 00 | request         long    0
02d24 1e6 00 00 00 00 | rrlimit         long    0
02d28 1e7 00 00 00 00 | pinconfig       long    0
02d2c 1e8 00 00 00 00 | clks            long    0
02d30 1e9 00 00 00 00 | resume          long    0
02d34 1ea 00 00 00 00 | orighubsize     long    0
02d38 1eb 00 00 00 00 | wrclks          long    0
02d3c 1ec             | 
02d3c 1ec 00 00 00 00 | pattern         long    0
02d40 1ed 00 00 00 00 | hubscratch      long    0
02d44 1ee 00 10 00 00 | val4k           long    4096
02d48 1ef             | 
02d48 1ef             | ' temporary general purpose regs
02d48 1ef 00 00 00 00 | a               long    0
02d4c 1f0 00 00 00 00 | b               long    0
02d50 1f1 00 00 00 00 | c               long    0
02d54 1f2 00 00 00 00 | d               long    0
02d58 1f3             | 
02d58 1f3             |                 fit     502
02d58 1f3             |                 fit     502
02d58 1f3             | 
02d58 1f3             | '..................................................................................................
02d58 1f3             | 
02d58 1f3             |             orgh
02d58                 | 
02d58                 | lut_code
02d58                 | 'HW init code up to 80 longs
02d58                 | 
02d58                 | '..................................................................................................
02d58                 | ' Memory layout for LUT RAM once operational:
02d58                 | '
02d58                 | '  LUT RAM address      Usage
02d58                 | '  ---------------      ----
02d58                 | '    $200-$20F          Bank parameters: burst + type + size per bank (16)
02d58                 | '    $210-$21F          Pin parameters : latency + control pins per bank (16)
02d58                 | '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
02d58                 | '    $270-$3FF          Main PSRAM access code in LUTRAM 
02d58                 | '
02d58                 | ' Also during driver COG startup:
02d58                 | ' $230-$24F is used for HW init setup
02d58                 | ' $250-$26F is used as temporary vector storage 
02d58                 | '..................................................................................................
02d58                 | 
02d58                 |                 org $230    
02d58 230             | 
02d58 230             | ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
02d58 230 1D 3C 63 FD | hwinit                      setxfrq xfreq2
02d5c 231 24 16 60 FD |                             pollxfi
02d60 232 FF AA 2A FF 
02d64 233 FF ED 07 F6 |                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
02d68 234 28 00 B0 FD |                             call    #sendqspi
02d6c 235 07 F8 07 FF 
02d70 236 F0 ED 07 F6 |                             mov     pa, ##$0FF00FF0         '$66 - reset enable
02d74 237 28 00 B0 FD |                             call    #sendspi
02d78 238 F8 07 78 FF 
02d7c 239 0F EC 07 F6 |                             mov     pa, ##$F00FF00F         '$99 - reset
02d80 23a 1C 00 B0 FD |                             call    #sendspi
02d84 23b 7F 78 78 FF 
02d88 23c 00 ED 07 F6 |                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
02d8c 23d 10 00 B0 FD |                             call    #sendspi 
02d90 23e 2D 00 64 FD |                             ret
02d94 23f             | 
02d94 23f 04 D0 07 F6 | sendqspi                    mov     clks,#4
02d98 240 32 0C 64 FD |                             skipf   #%110
02d9c 241 9C EF 03 F6 |                             mov     pb, xsendimm
02da0 242             | 
02da0 242 10 D0 07 F6 | sendspi                     mov     clks, #16
02da4 243 97 EF 03 F6 |                             mov     pb, ximm8lut
02da8 244 58 52 63 FD |                             drvl    cspin                   'active low chip select
02dac 245 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
02db0 246 F6 EF A3 FC |                             xinit   pb, pa                  'send 32 bit immediate data
02db4 247 A8 D1 23 FC |                             wypin   clks, clkpin            'start memory clock output 
02db8 248 24 36 60 FD |                             waitxfi                         'wait for the completion
02dbc 249 50 48 63 FD |                             fltl    datapins                'float data bus
02dc0 24a 59 52 63 FD |                             drvh    cspin                   'raise chip select
02dc4 24b 1F 90 65 0D |             _ret_           waitx   #200                    'delay before return to ensure CS delay
02dc8 24c             | 
02dc8 24c 00 00 00 00 
02dcc 24d 00 00 00 00 
02dd0 24e 00 00 00 00 
02dd4 24f 00 00 00 00 |                 long    0[$270-32-$]
02dd8 250             |     
02dd8 250             |                 fit     $270-32  ' keep room for 32 vector longs
02dd8 250             |                 fit     $270-32  ' keep room for 32 vector longs
02dd8 250             | ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
02dd8 250             | rw_vect ' PSRAM jump vectors
02dd8 250 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
02ddc 251 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
02de0 252 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
02de4 253 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
02de8 254 41 E3 00 74 |                 long    (%0111010000000000111000 << 10) + w_single
02dec 255 41 93 00 74 |                 long    (%0111010000000000100100 << 10) + w_single
02df0 256 41 73 00 74 |                 long    (%0111010000000000011100 << 10) + w_single
02df4 257 47 1B 00 FE |                 long    (%1111111000000000000110 << 10) + w_burst
02df8 258             | ro_vect ' R/O PSRAM jump vectors
02df8 258 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
02dfc 259 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
02e00 25a 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
02e04 25b 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
02e08 25c 00 01 00 00 |                 long    unsupported
02e0c 25d 00 01 00 00 |                 long    unsupported
02e10 25e 00 01 00 00 |                 long    unsupported
02e14 25f 00 01 00 00 |                 long    unsupported
02e18 260             | ctrl_vect ' Control jump vectors
02e18 260 84 F9 39 00 |                 long    (%0000000000111001111110 << 10) + get_latency
02e1c 261 00 01 00 00 |                 long    unsupported
02e20 262 84 F9 7B 00 |                 long    (%0000000001111011111110 << 10) + get_burst
02e24 263 85 01 7F 00 |                 long    (%0000000001111111000000 << 10) + dump_state
02e28 264 84 F9 D1 00 |                 long    (%0000000011010001111110 << 10) + set_latency
02e2c 265 00 01 00 00 |                 long    unsupported
02e30 266 84 F9 CB 00 |                 long    (%0000000011001011111110 << 10) + set_burst
02e34 267 3E 01 00 00 |                 long    reconfig 
02e38 268             | no_vect ' Invalid bank jump vectors
02e38 268 01 01 00 00 |                 long    invalidbank
02e3c 269 01 01 00 00 |                 long    invalidbank
02e40 26a 01 01 00 00 |                 long    invalidbank
02e44 26b 01 01 00 00 |                 long    invalidbank
02e48 26c 01 01 00 00 |                 long    invalidbank
02e4c 26d 01 01 00 00 |                 long    invalidbank
02e50 26e 01 01 00 00 |                 long    invalidbank
02e54 26f 01 01 00 00 |                 long    invalidbank
02e58 270             | 
02e58 270             |                 fit     $270
02e58 270             |                 fit     $270
02e58 270             | '..................................................................................................
02e58 270             | ' PSRAM READS
02e58 270             |                                                             ' a b c d e f
02e58 270             |                                                             ' B W L B R L  (a) byte read
02e58 270             |                                                             ' Y O O U E O  (b) word read
02e58 270             |                                                             ' T R N R S C  (c) long read
02e58 270             |                                                             ' E D G S U K  (d) new burst read
02e58 270             |                                                             '       T M E  (e) resumed sub-burst
02e58 270             |                                                             '         E D  (f) locked sub-burst
02e58 270             | 
02e58 270             | 
02e58 270 DA D5 03 F6 | r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
02e5c 271 DA B5 CB F7 | r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
02e60 272 36 D9 07 F6 |                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
02e64 273 20 D9 27 A5 |             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
02e68 274 02 34 27 F9 |                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
02e6c 275 80 B4 97 FB |                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
02e70 276 E5 E1 43 F8 | r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
02e74 277 F0 E1 A3 FA |                             rdlut   b, b                    ' a b c d e    get bank limit/mask
02e78 278 F0 45 CB F9 |                             bmask   mask, b                 ' | | | d e    build mask for addr
02e7c 279 F0 3F EB F8 |                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
02e80 27a 11 E0 47 F0 | p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
02e84 27b F0 47 23 F3 |                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
02e88 27c 05 3E 57 F0 |                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
02e8c 27d 10 5A 67 04 |             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
02e90 27e 10 5A 67 F4 |                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
02e94 27f F9 3B 83 FC |                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
02e98 280 D9 3B 83 FC | r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
02e9c 281 DA E3 03 F6 |                             mov     c, count                ' | | | d e f  get count of bytes left to read
02ea0 282 A3 E3 33 F3 |                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
02ea4 283 20 D0 17 F6 |                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
02ea8 284 CD D3 03 C6 |             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
02eac 285 CC D3 03 36 |             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
02eb0 286 32 20 64 FD |                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
02eb4 287 E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
02eb8 288 AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
02ebc 289 E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
02ec0 28a E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
02ec4 28b 54 00 90 FD |                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
02ec8 28c             | 
02ec8 28c             |                             ' fall through to read bursts
02ec8 28c             |                         
02ec8 28c             | burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
02ec8 28c D8 E5 03 F6 |                             mov     d, addr1                'get start address
02ecc 28d 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
02ed0 28e EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
02ed4 28f F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
02ed8 290 CD D3 03 C6 |             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
02edc 291 00 D8 07 F6 |                             mov     pattern, #0             'enable all by default
02ee0 292 01 B0 17 F4 |                             testb   addr1, #1 wc            'test if start addr starts in second word
02ee4 293 01 D8 67 F4 |                             bitnc   pattern, #1             'enable delay cycle if so
02ee8 294 6C D0 63 FD |                             wrc     clks                    'and account for its clock cycle
02eec 295 00 B0 17 F4 |                             testb   addr1, #0 wc            'test if start addr starts on odd byte
02ef0 296 02 D8 67 F4 |                             bitnc   pattern, #2             'add hi 8 transfer initially
02ef4 297 F1 E5 03 F6 |                             mov     d, c                    'get count of bytes to be read into HUB
02ef8 298 01 E4 87 C1 |             if_c            sub     d, #1                   'minus 1 if start addr was odd
02efc 299 01 E4 4F F0 |                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
02f00 29a F2 D1 23 F1 |                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
02f04 29b F2 35 23 F9 |                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
02f08 29c 03 D8 87 F4 |                             bitz    pattern, #3             'adjust the pattern to include this
02f0c 29d 00 E2 D7 F4 |                             testb   c, #0 xorc              'test for end address
02f10 29e 04 D8 67 F4 |                             bitnc   pattern, #4             'include low 8 bit transfer if required
02f14 29f 0E D0 27 F1 |                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
02f18 2a0 E8 D1 03 F1 |                             add     clks, clks
02f1c 2a1             | readcommon
02f1c 2a1 D8 C9 03 F6 |                             mov     cmdaddr, addr1          'get start address of transfer
02f20 2a2 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
02f24 2a3 EB C8 DF F8 |                             setbyte cmdaddr, #$EB, #3       'add quad read command
02f28 2a4             | 
02f28 2a4 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
02f2c 2a5 69 C8 63 FD |                             rev     cmdaddr
02f30 2a6 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
02f34 2a7 61 C8 63 FD |                             mergeb  cmdaddr
02f38 2a8             | 
02f38 2a8 58 52 63 FD |                             drvl    cspin                   'activate chip select
02f3c 2a9 58 48 63 FD |                             drvl    datapins                'enable data bus
02f40 2aa             |             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
02f40 2aa E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'stream out command+address
02f44 2ab A8 D1 23 FC |                             wypin   clks, clkpin            'start clock output
02f48 2ac 00 00 CC FC |                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
02f4c 2ad 00 0C CC FC |                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
02f50 2ae             |                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
02f50 2ae 50 48 63 FD |                             fltl    datapins                'safe to float the data bus, address has been sent by now
02f54 2af A4 5B 03 FC |                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
02f58 2b0 28 3A 63 FD |                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
02f5c 2b1 00 3E C7 FC |                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
02f60 2b2 00 0C CC FC |                             xcont   #6, #0                  'fixed delay offset to expand delay range
02f64 2b3 32 D8 63 FD |                             skipf   pattern                 'choose path below
02f68 2b4             |                                                             'Bursts Bytes Words Longs  RMW FromWrites
02f68 2b4 28 3C 63 FD |                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
02f6c 2b5 00 02 CC FC |                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
02f70 2b6 00 32 C7 FC |                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
02f74 2b7 00 34 C7 FC |                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
02f78 2b8 00 30 C7 FC |                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
02f7c 2b9 2D D2 63 FD |                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
02f80 2ba 24 36 60 FD |                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
02f84 2bb A4 55 03 FC |                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
02f88 2bc 59 52 63 0D |             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
02f8c 2bd 59 52 63 FD |                             drvh    cspin                   '         b     c           e       deassert chip select and continue
02f90 2be E5 E5 4B F8 |                             getnib  d, request, #1          'get request code value
02f94 2bf 03 E4 87 51 |             if_nz           sub     d, #3                   'offset for table if RMW
02f98 2c0 BB E5 8F F9 |                             altd    d, #skiptable-5         'patch next instruction
02f9c 2c1 32 00 60 FD |                             skipf   0-0                     'generate skip sequence
02fa0 2c2             |                                                             ' B   W  RMWB RMWW RMLL 
02fa0 2c2 80 DF 07 FB |                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
02fa4 2c3 28 B4 63 FD |                             setq    count                   ' |   |   |    |    e   setup bit mux mask
02fa8 2c4 D9 DF F3 F9 |                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
02fac 2c5 40 00 90 FD |                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
02fb0 2c6 01 B0 17 F4 |                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
02fb4 2c7 EF EF 3B C9 |             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
02fb8 2c8 EF EF 33 39 |             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
02fbc 2c9 D8 E5 03 F6 |                             mov     d, addr1                ' a   |   c    d
02fc0 2ca 03 E4 07 F5 |                             and     d, #3                   ' a   |   c    |        get LSBs of address
02fc4 2cb EF E5 6F F9 |                             altgb   d, #a                   ' a   |   c    |        index into long
02fc8 2cc 00 EE E3 F8 |                             getbyte pb                      ' a   |   c    |        and extract the byte
02fcc 2cd 80 EF 67 FC |                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
02fd0 2ce C0 00 B0 FD |                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
02fd4 2cf 2D 00 64 FD |                             ret                             ' a   b   |    |        then return
02fd8 2d0 28 B4 63 FD |                             setq    count                   '         c    d        setup bit mux mask
02fdc 2d1 D9 EF F3 F9 |                             muxq    pb, hubdata             '         c    d        apply bit mux
02fe0 2d2 EF E5 67 F9 |                             altsb   d, #a                   '         c    |
02fe4 2d3 F7 01 C0 F8 |                             setbyte 0-0, pb, #0             '         c    |
02fe8 2d4 F7 DF 2B C9 |             if_c            setword a, pb, #1               '         |    d
02fec 2d5 F7 DF 23 39 |             if_nc           setword a, pb, #0               '         |    d
02ff0 2d6 37 8A 07 F6 | writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
02ff4 2d7 EF B3 03 F6 |                             mov     hubdata, a              'write a to PSRAM
02ff8 2d8 14 D6 07 F6 |                             mov     wrclks, #20             '20 clocks to write a long
02ffc 2d9 CC D3 03 F6 |                             mov     resume, complete_rw     'we'll complete the operation after this
03000 2da 10 03 90 FD |                             jmp     #writecommon
03004 2db             | 
03004 2db             | '..................................................................................................
03004 2db             | ' Burst continuation testing
03004 2db             | 
03004 2db 32 96 63 FD | continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
03008 2dc BE D3 03 F6 |                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
0300c 2dd             | continue_read_lut          
0300c 2dd BF D3 03 F6 |                             mov     resume, resumereads     ' | setup resume address to execf
03010 2de F1 B3 03 F1 |                             add     hubdata, c              ' a compute the next hub addr to use
03014 2df F1 B5 83 F1 |                             sub     count, c                ' a account for the bytes already sent
03018 2e0 D8 E3 03 F1 |                             add     c, addr1                ' a compute next external mem address
0301c 2e1 28 44 63 FD |                             setq    mask                    ' a configure mask for bit muxing
03020 2e2 F1 B1 F3 F9 |                             muxq    addr1, c                ' a perform address bit muxing
03024 2e3 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
03028 2e4 14 00 90 5D |             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
0302c 2e5 E1 47 3B F9 |                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
03030 2e6 F0 47 23 F3 |                             fle     limit, b                ' | also re-apply per bank limit
03034 2e7 2A 2A 67 0D |             _ret_           push    #continue_read_exec     ' | 
03038 2e8 04 00 90 5D |             if_nz           jmp     #yield                  ' a
0303c 2e9 2A 2C 67 0D |             _ret_           push    #continue_write_exec    ' a
03040 2ea             | 
03040 2ea 04 B9 37 FC | yield                       wrlut   total, ptra[4]          'save context for next time
03044 2eb 05 BB 37 FC |                             wrlut   offset1, ptra[5]        'save context for next time
03048 2ec 06 BD 37 FC |                             wrlut   offset2, ptra[6]        'save context for next time
0304c 2ed 07 BF 37 FC |                             wrlut   link, ptra[7]           'save context for next time
03050 2ee 00 B1 37 FC | yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
03054 2ef 01 B3 37 FC |                             wrlut   hubdata, ptra[1]        'save context for next time
03058 2f0 02 B5 37 FC |                             wrlut   count, ptra[2]          'save context for next time
0305c 2f1 03 B7 37 FC |                             wrlut   addr2, ptra[3]          'save context for next time
03060 2f2 08 D3 37 FC |                             wrlut   resume, ptra[8]         'save next resume address
03064 2f3 09 D5 37 FC |                             wrlut   orighubsize, ptra[9]    'save original hub size
03068 2f4 2A 1C 66 0D |             _ret_           push    #poller
0306c 2f5             | 
0306c 2f5             | 
0306c 2f5 32 BE 65 FD | notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
03070 2f6             | nowrite_lut                                                 '  (a) new skip sequence 
03070 2f6 32 00 64 FD | noread_lut                  skipf   #0                      ' | cancel skipping
03074 2f7 08 01 3C FC |                             wrlut   #0, ptra[8]             ' | clear resume
03078 2f8 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
0307c 2f9 40 F8 9F 5D |             if_nz           jmp     #notify                 ' | if not a request list then we are done
03080 2fa 1F B6 0F F4 |                             testb   addr2, #31 wz           ' | check if extended list item
03084 2fb DF B7 03 A6 | donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
03088 2fc 1C 00 B0 FD | checklist                   call    #checknext              ' | handle running from list
0308c 2fd 2D 00 64 FD |                             ret                             ' | continue processing
03090 2fe 2A 9E 63 0D |             _ret_           push    noread                  'continue end of transfer
03094 2ff             | '..................................................................................................
03094 2ff             | ' Completion of requests
03094 2ff             | 
03094 2ff             | complete_rw_lut             
03094 2ff 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        'test for running from a request list   
03098 300 32 04 64 AD |             if_z            skipf   #%10                    'if a request list then skip notification
0309c 301 08 01 3C FC |                             wrlut   #0, ptra[8]             ' a   default is not to resume
030a0 302 2A 14 66 0D |             _ret_           push    #notify                 ' |   if not a request list then we are done
030a4 303 0D B6 B7 FB |                             tjs     addr2, #extendedreq     '     test for special extended request  
030a8 304 07 B6 97 FB | checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
030ac 305 BF ED 07 FB |                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
030b0 306 05 EC BF FB |                             tjns    pa, #listcomplete       'exit if it has
030b4 307 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz
030b8 308 DB B3 03 A6 |             if_z            mov     hubdata, addr2
030bc 309 32 62 64 AD |             if_z            skipf   #%110001
030c0 30a 32 10 64 5D |             if_nz           skipf   #%1000                  'do not notify if list is continuing
030c4 30b 80 B7 67 FC |                             wrlong  addr2, ptrb             ' a  write back next list address
030c8 30c D0 C3 8F F9 | listcomplete                altd    id, #id0                ' a  compute COG's state address
030cc 30d 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
030d0 30e 2A 14 66 0D |             _ret_           push    #notify                 ' |  we are done with the list
030d4 30f 2A 1C 66 0D |             _ret_           push    #poller                 ' a  we are still continuing the list
030d8 310 2A 50 66 0D |             _ret_           push    #real_list              ' a  we are still continuing the list
030dc 311 E3 B5 97 FB | extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
030e0 312 DB DF 7B F8 |                             getnib  a, addr2, #7            'check the request type
030e4 313 0F DE 0F F2 |                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
030e8 314 D8 DF 73 F8 |                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
030ec 315 32 90 63 5D |             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
030f0 316             |                                                             ' skipcase (a) gfx copy to/from hub
030f0 316             |                                                             ' skipcase (b) gfx copy extmem bank to bank
030f0 316             |                                                             ' skipcase (c) linear copy extmem bank to bank
030f0 316 DB DF 73 F8 |                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
030f4 317 EF E5 AB FA |                             rdlut   d, a wz                 ' a      load bank information and check if valid
030f8 318 31 02 64 5D |             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
030fc 319 2A 02 66 0D |             _ret_           push    #invalidbank            ' |      otherwise bail out after this
03100 31a DD BB CB F7 |                             test    offset1 wz              ' |      check for first offset being zero
03104 31b DE BD CB A7 |             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
03108 31c 32 94 63 AD |             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
0310c 31d 32 92 63 FD |                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
03110 31e F1 B3 03 F1 |                             add     hubdata, c              ' a b c  add bytes just sent to hub address
03114 31f EA B3 83 F1 |                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
03118 320 D8 E3 03 F1 |                             add     c, addr1                ' a b c  compute next address to use
0311c 321 DC B9 CB F7 |                             test    total wz                ' a b |  check for zero tranfers
03120 322 DC D5 2B F3 |                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
03124 323 44 FF 9F AD |             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
03128 324 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a b c  check if reading/writing
0312c 325 EA B5 03 F6 |                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
03130 326 EA E3 83 F1 |                             sub     c, orighubsize          ' a b |  rewind to original position
03134 327 DD E3 03 A1 |             if_z            add     c, offset1              ' a b |  add any dst scanline offset
03138 328 DE E3 03 51 |             if_nz           add     c, offset2              ' a b |  add any src scanline offset
0313c 329 DE B3 03 A1 |             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
03140 32a DD B3 03 51 |             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
03144 32b 28 44 63 FD |                             setq    mask                    ' a b c  configure mask for bit muxing
03148 32c F1 B1 F3 F9 |                             muxq    addr1, c                ' a b c  perform address bit muxing
0314c 32d D8 DF 03 F6 |                             mov     a, addr1                ' | b c  ]
03150 32e DB B1 03 F6 |                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
03154 32f EF B7 03 F6 |                             mov     addr2, a                ' | b c  ]
03158 330 1E B0 A7 F4 |                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
0315c 331 0F B6 3F F8 |                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
03160 332 01 B8 8F F1 |                             sub     total, #1 wz            ' a | |  decrement scanline count
03164 333 01 B8 8F A1 |             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
03168 334 EA B9 8B A1 |             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
0316c 335 DF B7 03 A6 |             if_z            mov     addr2, link
03170 336 34 FF 9F AD |             if_z            jmp     #checknext
03174 337 D8 CB FB F8 | moretransfers               getbyte request, addr1, #3      'prepare next request
03178 338 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
0317c 339 32 1C 64 AD |             if_z            skipf   #%1110                  '     skip some code if we are locked
03180 33a 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a   test if will be reading or writing
03184 33b BE D3 03 A6 |             if_z            mov     resume, resumewrites    ' |   resume burst writing
03188 33c B9 D3 03 56 |             if_nz           mov     resume, newburstr       ' |   resume burst reading
0318c 33d B0 FE 9F FD |                             jmp     #yield                  ' |   yield to poller
03190 33e 31 02 64 AD |             if_z            skip    #%1                     '     skip next instruction for writing case
03194 33f 2A 26 67 0D |             _ret_           push    #start_read_exec        '(|)  do new read burst next 
03198 340 2A 28 67 0D |             _ret_           push    #start_write_exec       'do new write burst next
0319c 341             | 
0319c 341             | '..................................................................................................
0319c 341             | ' PSRAM WRITES
0319c 341             |                                                             '  a b c d e f g h
0319c 341             | 
0319c 341             |                                                             '  B W L F B R L L (a) byte write(s)
0319c 341             |                                                             '  Y O O I U E O O (b) word write(s)
0319c 341             |                                                             '  T R N L R S C C (c) long write(s)
0319c 341             |                                                             '  E D G L S U K K (d) resumed fill
0319c 341             |                                                             '          T M E E (e) new burst write
0319c 341             |                                                             '            E D D (f) resumed burst
0319c 341             |                                                             '              F B (g) locked fill
0319c 341             |                                                             '              I U (h) locked burst write
0319c 341             |                                                             '              L R 
0319c 341             |                                                             '              L S 
0319c 341             |                                                             '                T 
0319c 341             | 
0319c 341             | w_single                   
0319c 341             | w_fill_cont           
0319c 341 D8 DF 7B F8 |                             getnib  a, addr1, #7            '  a b c d          obtain request
031a0 342 03 DE 07 F5 |                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
031a4 343 00 B2 FF F9 |                             movbyts hubdata, #0             '  a | | |          replicate byte across long
031a8 344 44 B2 FF F9 |                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
031ac 345 01 B0 27 F5 |                             andn    addr1, #1               '  | b | |          align word addresses
031b0 346 03 B0 27 F5 |                             andn    addr1, #3               '  | | c |          align long addresses
031b4 347 DA D5 03 F6 | w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
031b8 348 01 B4 0F F2 | w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
031bc 349 EF B5 63 F0 |                             shl     count, a                '  a b c | |   |    scale into bytes
031c0 34a AB B5 97 FB |                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
031c4 34b DA E3 03 F6 | w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
031c8 34c 76 02 A0 FD |                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
031cc 34d             |                ' disable call to r_resume_burst for single longs when z=0
031cc 34d E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
031d0 34e AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
031d4 34f E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
031d8 350 E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
031dc 351 3F 8A 0F F6 |                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
031e0 352 A3 E3 33 F3 |                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
031e4 353 CE D3 03 C6 |             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
031e8 354 CC D3 03 36 |             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
031ec 355 D9 DF 03 F6 |                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
031f0 356 14 D6 07 F6 |                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
031f4 357 01 DE 17 F4 |                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
031f8 358 C7 8B 03 F6 |                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
031fc 359 14 01 90 8D |             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
03200 35a 09 8A 67 25 |             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
03204 35b 5C 00 90 2D |             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
03208 35c 0F 8A 07 F6 |                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
0320c 35d             |         
0320c 35d             |             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
0320c 35d             |             '
0320c 35d             |             '  At least one of these 3 optional components will be sent
0320c 35d             |             '     header - first partial long of data, gets aligned to PSRAM long boundary
0320c 35d             |             '     body - N x full longs of data
0320c 35d             |             '     trailer - last partial long of data
0320c 35d             |             '
0320c 35d             |             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
0320c 35d             |             '
0320c 35d             |             'Case    Type                           Sends
0320c 35d             |             ' 1)     Single byte/word write         header only (takes its own optimized path)
0320c 35d             |             ' 2)     Single long write              body only (takes its own optimized path)
0320c 35d             |             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
0320c 35d             |             ' 4)     Multiple long fill             body only
0320c 35d             |             ' 5)     Burst write                    optional header, optional body, optional trailer
0320c 35d             | 
0320c 35d             |                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
0320c 35d D8 E5 03 F6 |                             mov     d, addr1                'get start address
03210 35e 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
03214 35f EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
03218 360 F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
0321c 361 CE D3 03 C6 |             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
03220 362 13 8C 07 F6 |                             mov     pattern3, #%10011
03224 363 D8 E5 03 F6 |                             mov     d, addr1                'get start address position 
03228 364 03 E4 0F F5 |                             and     d, #3 wz                'get alignment
0322c 365 04 E2 17 F2 |                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
03230 366 10 D6 07 F6 |                             mov     wrclks, #16             'clocks needed for address phase
03234 367 F1 EF 03 F6 |                             mov     pb, c                   'get number of bytes to send
03238 368 F2 EF 03 F1 |                             add     pb, d                   'and increase total to send, including initial re-alignment
0323c 369 40 00 90 2D |             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
03240 36a             |                             
03240 36a F0 CA 17 F2 |                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
03244 36b 32 3C 64 CD |             if_c            skipf   #%11110                 'if fill skip burst write stuff
03248 36c 04 D6 07 F1 |                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
0324c 36d F2 DF 83 F1 |                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
03250 36e EF E5 03 FB |                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
03254 36f 04 DE 07 F1 |                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
03258 370 32 08 64 FD |                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
0325c 371 04 EE 9F F1 |                             sub     pb, #4 wcz              ' subtract a long from the total
03260 372 00 8A 07 F4 |                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
03264 373 D9 E5 03 F6 | single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
03268 374 88 01 B0 FD |                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
0326c 375 5A B0 47 FB |                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
03270 376 ED C5 03 FB |                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
03274 377 28 EC 63 FD |                             setq    pa                      ' setup byte mux mask
03278 378 F2 C5 F3 F9 |                             muxq    header, d               ' copy bytes into long
0327c 379 94 00 90 ED |             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
03280 37a             | 
03280 37a F0 CA 17 F2 | header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
03284 37b F7 E5 03 F6 |                             mov     d, pb                   'preserve the count
03288 37c 03 EE 2F F5 |                             andn    pb, #3 wz               'determine the number of full long bytes left to send
0328c 37d 07 EE 97 FB |                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
03290 37e             |                  
03290 37e F7 D7 03 F1 |                             add     wrclks, pb              'include this number of bytes as more clock transitions
03294 37f 32 14 64 CD |             if_c            skipf   #%1010                 'for fills we can skip burst stuff
03298 380 0C 8A 27 C5 |             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
0329c 381 01 8A 07 F4 |                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
032a0 382 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute word count for bursts
032a4 383 F7 37 23 F9 |                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
032a8 384 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
032ac 385             | 
032ac 385 03 E4 07 F5 | body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
032b0 386 17 E4 97 FB |                             tjz     d, #trailer_done        'no trailer to send, we exit now
032b4 387 DA E3 0B C2 |             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
032b8 388 CC D3 0B 32 |             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
032bc 389 F2 E3 83 51 |             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
032c0 38a 4C 00 90 5D |             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
032c4 38b             | 
032c4 38b             |                             'we have 1-3 more aligned residual bytes left to send as the trailer
032c4 38b F0 E5 47 F5 |                             or      d, #$1f0                'setup mux mask address
032c8 38c F2 ED A3 FA |                             rdlut   pa, d                   'read mux mask for this length at offset 0
032cc 38d 2A B0 63 FD |                             push    addr1                   'save address
032d0 38e             | 
032d0 38e             | ' use this code (note: foldover can occur here in PSRAM bank)
032d0 38e F1 B1 03 F1 |                             add     addr1, c                'find last long address in PSRAM
032d4 38f 01 B0 87 F1 |                             sub     addr1, #1               '..to be rewritten
032d8 390 18 01 B0 FD |                             call    #readlong               'read data from this external address
032dc 391             |             
032dc 391 D9 E5 03 C6 |             if_c            mov     d, hubdata              'get data to be sent for fills
032e0 392 32 3C 64 CD |             if_c            skipf   #%11110                 'skip burst code for fills
032e4 393 2B B0 63 FD |                             pop     addr1                   'restore address
032e8 394 F7 E5 03 F6 |                             mov     d, pb                   ' | get number of full longs that were sent
032ec 395 02 E4 67 F0 |                             shl     d, #2                   ' | convert to bytes
032f0 396 EF E5 03 F1 |                             add     d, a                    ' | add to start adress of longs to stream
032f4 397 F2 E5 03 FB |                             rdlong  d, d                    ' | read this last long from HUB RAM
032f8 398             | 
032f8 398 ED C7 03 FB |                             rdlong  trailer, hubscratch     'read external RAM data value
032fc 399 28 EC 63 FD |                             setq    pa                      'setup byte mask
03300 39a F2 C7 F3 F9 |                             muxq    trailer, d              'apply byte mask to data via muxq
03304 39b 04 D6 07 F1 |                             add     wrclks, #4              'increase by 4 more clocks
03308 39c 05 8A 07 F4 |                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
0330c 39d 00 8C 07 F4 |                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
03310 39e             | 
03310 39e             |                             'trailer is done
03310 39e EF 3B 73 FC | trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
03314 39f             | 
03314 39f D8 C9 03 F6 | writecommon                 mov     cmdaddr, addr1          'get start address of transfer
03318 3a0 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
0331c 3a1 02 C8 DF F8 |                             setbyte cmdaddr, #$02, #3       'add quad write command
03320 3a2             | 
03320 3a2 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
03324 3a3 69 C8 63 FD |                             rev     cmdaddr                 
03328 3a4 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
0332c 3a5 61 C8 63 FD |                             mergeb  cmdaddr
03330 3a6             |                             
03330 3a6 58 52 63 FD |                             drvl    cspin                   'activate chip select
03334 3a7 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
03338 3a8 E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
0333c 3a9 A8 D7 23 FC |                             wypin   wrclks, clkpin          'start memory clock output 
03340 3aa             |                                                          
03340 3aa 32 8A 63 FD |                             skipf   pattern2                '   B W L Burst FB FW FL RMW
03344 3ab E2 39 C3 FC |                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
03348 3ac 00 36 C7 FC |                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
0334c 3ad F7 03 D8 FC |                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
03350 3ae D9 39 C3 FC |                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
03354 3af 32 8C 63 FD |                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
03358 3b0 E3 39 C3 FC |                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
0335c 3b1 2D D2 63 FD |                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
03360 3b2 24 36 60 FD |                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
03364 3b3 50 48 63 FD |                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
03368 3b4 59 52 63 0D |             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
0336c 3b5             |  
0336c 3b5 59 52 63 FD |                             drvh    cspin
03370 3b6 09 C2 17 F4 | check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
03374 3b7 F1 B5 8B F1 |                             sub     count, c wz             'account for bytes written
03378 3b8 34 00 90 5D |             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
0337c 3b9 08 01 3C FC |                             wrlut   #0, ptra[8]             'default is not to resume
03380 3ba 3C F5 9F 3D |             if_nc           jmp     #notify                 'if not a request list then we are done
03384 3bb 40 B7 BF FB |                             tjns    addr2, #checklist       'if not extended, check next list entry
03388 3bc 3E B9 67 FB |                             djz     total, #donerepeats     'check for repeats remaining
0338c 3bd B8 B9 B3 FB |                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
03390 3be EA E5 03 F6 |                             mov     d, orighubsize
03394 3bf EF E5 63 F0 |                             shl     d, a
03398 3c0 F2 E3 83 F1 |                             sub     c, d
0339c 3c1 DD E3 03 F1 |                             add     c, offset1
033a0 3c2 F2 B5 03 F6 |                             mov     count, d                'restore original count
033a4 3c3 E5 E1 43 F8 | readmask                    getnib  b, request, #0          'get bank parameter LUT address
033a8 3c4 F0 E1 A3 FA |                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
033ac 3c5 F0 45 CB F9 |                             bmask   mask, b                 'build mask for addr (in case count=1)
033b0 3c6 D8 E3 03 F1 | continue_fill               add     c, addr1                'add bytes to destination address
033b4 3c7 28 44 63 FD |                             setq    mask                    'setup bit mask
033b8 3c8 F1 B1 F3 F9 |                             muxq    addr1, c                'setup new external memory address
033bc 3c9 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
033c0 3ca 33 74 63 AD |             if_z            execf   lockedfill              'continue next fill operation
033c4 3cb BB D3 03 F6 |                             mov     resume, restorefill
033c8 3cc 00 B6 07 36 |             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
033cc 3cd 80 FC BF 3D |             if_nc           call    #yieldfill              'we have to yield now to other COGs
033d0 3ce 6C FC BF CD |             if_c            call    #yield
033d4 3cf 2D 00 64 FD |                             ret
033d8 3d0             |                            
033d8 3d0             | getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
033d8 3d0             |                       '     rczl    pa                      'rotate left into address offset
033d8 3d0             |                       '     rczl    c wcz                   'restore count and flags
033d8 3d0 03 E2 EF F7 |                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
033dc 3d1 02 EC 67 F0 |                             shl     pa, #2
033e0 3d2 28 06 64 AD |             if_z            setq    #3
033e4 3d3 F1 ED F3 A9 |             if_z            muxq    pa, c
033e8 3d4 F0 ED 47 F5 |                             or      pa, #$1f0               'setup LUT address offset
033ec 3d5 F6 ED A3 FA |            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
033f0 3d6 2D 00 7C FD |                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
033f4 3d7             | 
033f4 3d7 ED 3B 83 FC | readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
033f8 3d8 02 34 27 F9 |                             setword xrecvdata, #2, #0       'read 2x16 words
033fc 3d9 20 D0 07 F6 |                             mov     clks, #32               '32 read clock transitions
03400 3da 36 D8 07 F6 |                             mov     pattern, #%110110       'setup read skip pattern
03404 3db 14 FB 9F FD |                             jmp     #readcommon             'read then return directly to caller
03408 3dc             |         
03408 3dc             | 
03408 3dc             | '..................................................................................................
03408 3dc             | 
03408 3dc             |                 fit 1024-32
03408 3dc             |                 fit 1024-32
03408 3dc 00 00 00 00 
0340c 3dd 00 00 00 00 
03410 3de 00 00 00 00 
03414 3df 00 00 00 00 |                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
03418 3e0             |                 org 1024-32
03418 000             | 
03418 000             | ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
03418 000 00 00 00 00 |                 long $0000
0341c 001 11 11 00 00 |                 long $1111
03420 002 22 22 00 00 |                 long $2222
03424 003 33 33 00 00 |                 long $3333
03428 004 44 44 00 00 |                 long $4444
0342c 005 55 55 00 00 |                 long $5555
03430 006 66 66 00 00 |                 long $6666
03434 007 77 77 00 00 |                 long $7777
03438 008 88 88 00 00 |                 long $8888
0343c 009 99 99 00 00 |                 long $9999
03440 00a AA AA 00 00 |                 long $aaaa
03444 00b BB BB 00 00 |                 long $bbbb
03448 00c CC CC 00 00 |                 long $cccc
0344c 00d DD DD 00 00 |                 long $dddd
03450 00e EE EE 00 00 |                 long $eeee
03454 00f FF FF 00 00 |                 long $ffff
03458 010             | 
03458 010             | 'masks
03458 010 FF FF FF FF |                 long $ffffffff ' 00 aligned 0/4 length
0345c 011 FF 00 00 00 |                 long $000000ff ' 00 aligned 1 length
03460 012 FF FF 00 00 |                 long $0000ffff ' 00 aligned 2 length
03464 013 FF FF FF 00 |                 long $00ffffff ' 00 aligned 3 length
03468 014             | 
03468 014 00 FF FF FF |                 long $ffffff00 ' 01 aligned 0/4 length
0346c 015 00 FF 00 00 |                 long $0000ff00 ' 01 aligned 1 length
03470 016 00 FF FF 00 |                 long $00ffff00 ' 01 aligned 2 length
03474 017 00 FF FF FF |                 long $ffffff00 ' 01 aligned 3 length
03478 018             | 
03478 018 00 00 FF FF |                 long $ffff0000 ' 10 aligned 0/4 length
0347c 019 00 00 FF 00 |                 long $00ff0000 ' 10 aligned 1 length
03480 01a 00 00 FF FF |                 long $ffff0000 ' 10 aligned 2 length
03484 01b 00 00 FF FF |                 long $ffff0000 ' 10 aligned 3 length
03488 01c             | 
03488 01c 00 00 00 FF |                 long $ff000000 ' 11 aligned 0/4 length
0348c 01d 00 00 00 FF |                 long $ff000000 ' 11 aligned 1 length
03490 01e 00 00 00 FF |                 long $ff000000 ' 11 aligned 2 length
03494 01f 00 00 00 FF |                 long $ff000000 ' 11 aligned 3 length
03498 020             | 
03498 020             |         fit 1024
03498 020             |         fit 1024
03498 020             | 
03498 020             | '--------------------------------------------------------------------------------------------------
03498 020             |         orgh
03498                 | 
03498                 | gfxexpansion
03498                 |                             'simple line drawing graphics expansion of memory driver
03498                 |                             'jmp     #donerepeats                'just return for now
03498                 | 
03498     DB B1 0B F2 |                             cmp     addr1, addr2 wz         'see if we've reached the end
0349c     FB 02 80 AD |             if_z            jmp     #donerepeats            'nothing more to draw
034a0     01 B8 07 F1 |                             add     total, #1               'restore total after decrement
034a4     DD E1 03 F6 |                             mov     b, offset1              'get error term
034a8     01 E0 67 F0 |                             shl     b, #1                   'compute e2 = 2 x error
034ac     DE E5 33 F9 |                             getword d, offset2, #0          'get dx = abs(x0-x1)
034b0     10 BC C7 F0 |                             sar     offset2, #16            'get dy = -abs(y0-y1)
034b4     DE E1 53 F2 |                             cmps    b, offset2 wc           'compare if e2 >= dy
034b8     00 E2 07 F6 |                             mov     c, #0                   'clear accumulator reg
034bc     31 1C 64 CD |             if_c            skip    #%1110                  'if not, skip
034c0     EF DF C3 F9 |                             decod   a                       'decode as 1,2,or 4 byte size
034c4     DE BB 03 F1 |                             add     offset1, offset2        'err+=dy 
034c8     10 B8 0F F4 |                             testb   total, #16 wz           'check sign sx   
034cc     EF E3 C3 F3 |                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
034d0     F0 E5 53 F2 |                             cmps    d, b wc                 'compare if e2 <= dx
034d4     31 3C 64 CD |             if_c            skip    #%11110                 'if not, skip
034d8     F2 BD 43 F9 |                             rolword offset2, d, #0          'restore offset
034dc     F2 BB 03 F1 |                             add     offset1, d              'err+=dx
034e0     11 B8 0F F4 |                             testb   total, #17 wz           'check sign sy
034e4     DC E5 33 F9 |                             getword d, total, #0            'get line width
034e8     F2 E3 C3 F3 |                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
034ec     EF DF 93 F7 |                             encod   a wc                    'restore size and set carry
034f0     EA B5 03 F6 |                             mov     count, orighubsize      'reset the fill width
034f4     EF B5 63 F0 |                             shl     count, a                '..for the type of transfer
034f8     C3 03 80 FD |                             jmp     #readmask               'continue filling
034fc                 | objmem
034fc     00 00 00 00 
      ...             
03a6c     00 00 00 00 
03a70     00 00 00 00 | 	long	0[350]
03a74                 | stackspace
03a74     00 00 00 00 | 	long	0[1]
03a78 104             | 	org	COG_BSS_START
03a78 104             | _var01
03a78 104             | 	res	1
03a78 105             | _var02
03a78 105             | 	res	1
03a78 106             | _var03
03a78 106             | 	res	1
03a78 107             | arg01
03a78 107             | 	res	1
03a78 108             | arg02
03a78 108             | 	res	1
03a78 109             | arg03
03a78 109             | 	res	1
03a78 10a             | arg04
03a78 10a             | 	res	1
03a78 10b             | arg05
03a78 10b             | 	res	1
03a78 10c             | arg06
03a78 10c             | 	res	1
03a78 10d             | arg07
03a78 10d             | 	res	1
03a78 10e             | arg08
03a78 10e             | 	res	1
03a78 10f             | arg09
03a78 10f             | 	res	1
03a78 110             | local01
03a78 110             | 	res	1
03a78 111             | local02
03a78 111             | 	res	1
03a78 112             | local03
03a78 112             | 	res	1
03a78 113             | local04
03a78 113             | 	res	1
03a78 114             | local05
03a78 114             | 	res	1
03a78 115             | local06
03a78 115             | 	res	1
03a78 116             | local07
03a78 116             | 	res	1
03a78 117             | local08
03a78 117             | 	res	1
03a78 118             | local09
03a78 118             | 	res	1
03a78 119             | local10
03a78 119             | 	res	1
03a78 11a             | local11
03a78 11a             | 	res	1
03a78 11b             | 	fit	480
03a78 11b             | 
