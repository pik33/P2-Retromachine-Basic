con
	_clkfreq = 160000000
	_clkmode = 16779259
	clkfreq = 340000000
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 160000000
	long	0 ' clock mode: will default to $10007fb
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##16779256
	waitx	##200000
	mov	pa, ##16779259
	hubset	pa
	wrlong	pa, #24
	wrlong	##160000000, #20
	jmp	#skip_clock_set_
	orgf	128
skip_clock_set_
	call	#_program
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    mov	fcache_tmpb_,ptrb
    pop	ptrb
    altd	pa,ret_instr_
    mov	 0-0, ret_instr_
    setq	pa
    rdlong	$0, ptrb++
    push	ptrb
    mov ptrb,fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    _ret_ cmp inb,#0
fcache_tmpb_
    long 0
fcache_load_ptr_
    long FCACHE_LOAD_
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret
COUNT_
    long 0
RETADDR_
    long 0
fp
    long 0
pushregs_
    pop  pa
    pop  RETADDR_
    tjz  COUNT_, #pushregs_done_
    altd  COUNT_, #511
    setq #0-0
    wrlong local01, ptra++
pushregs_done_
    setq #2 ' push 3 registers starting at COUNT_
    wrlong COUNT_, ptra++
    mov    fp, ptra
    jmp  pa
 popregs_
    pop    pa
    setq   #2
    rdlong COUNT_, --ptra
    djf    COUNT_, #popregs__ret
    setq   COUNT_
    rdlong local01, --ptra
popregs__ret
    push   RETADDR_
    jmp    pa

divide_
       abs     muldivb_,muldivb_     wcz      'abs(y)
       wrc     itmp2_                         'store sign of y
       abs     muldiva_,muldiva_     wc       'abs(x)
       qdiv    muldiva_, muldivb_             'queue divide
 if_c  xor     itmp2_,#1                      'store sign of x
       getqx   muldivb_                       'get quotient
       getqy   muldiva_                       'get remainder
       negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
       testb   itmp2_,#0             wc       'restore sign, division result
 _ret_ negc    muldivb_,muldivb_     

__methods__
	long	@__methodtable__
itmp1_
	long	0
itmp2_
	long	0
objptr
	long	@objmem
ptr___system__dat__
	long	@__system__dat_
ptr__dat__
	long	@_dat_
ptr__psram16drv_spin2_dat__
	long	@_psram16drv_spin2_dat_
ptr__psram_spin2_dat__
	long	@_psram_spin2_dat_
ptr__sa001_spin2_dat__
	long	@_sa001_spin2_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
result2
	long	1
COG_BSS_START
	fit	480
	orgh
hubentry

_program
	add	objptr, ##524
'     return startx(0, 0, 0, -1)
	mov	arg01, #0
	mov	arg02, #0
	mov	arg03, #0
	neg	arg04, #1
	call	#_psram_spin2_startx
	mov	arg01, ptr__dat__
	add	arg01, #16
	mov	arg02, #0
	decod	arg03, #11
	call	#_psram_spin2_write
	sub	objptr, ##524
	mov	arg01, ##524032
	mov	arg02, #0
	mov	arg03, ##458752
	call	#_sa001_spin2_start
	call	#_sa001_spin2_test
' 
' psram.start()
' psram.write(varptr(sinewave)+16,0,2048)
' audio.start($7FF00,0,$70000)
' audio.test()
' do: 
LR__0001
'   if lpeek($30)<>0 then print lpeek($30): lpoke $30,0
	rdlong	result1, #48 wz
 if_e	jmp	#LR__0001
	mov	arg01, #0
	call	#__system___getiolock_0095
	mov	arg01, result1
	call	#__system___lockmem
	rdlong	arg02, #48
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #16
	call	#__system___basic_print_unsigned
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0095
	wrlong	#0, result1
	wrlong	#0, #48
	jmp	#LR__0001
_program_ret
	ret

' 
' 
' pub test()
_sa001_spin2_test
' 
' 
' play(2,0,$1000,16384,1024,0)  
	mov	arg01, #2
	mov	arg02, #0
	decod	arg03, #12
	decod	arg04, #14
	decod	arg05, #10
	mov	arg06, #0
	call	#_sa001_spin2_play
_sa001_spin2_test_ret
	ret

' 
' '--------------------------------------------------------------
' '---------- Init the variables, start the cog. ----------------
' '--------------------------------------------------------------
' 
' pub start(mbox,scope,cache) :cog,base | iii
_sa001_spin2_start
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
' 
' ' mbox: PSRAM mailbox or 0 if no PSRAM
' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
' 
' mailboxaddr:=mbox 
	wrlong	local01, objptr
' scope_ptr:=scope
	add	objptr, #4
	wrlong	arg02, objptr
' cache_ptr:=cache
	add	objptr, #4
	wrlong	arg03, objptr
' base:=@channel1[0]
	add	objptr, #4
	mov	local02, objptr
' long[$40]:=mbox
	wrlong	local01, #64
' repeat iii from 0 to 7
	mov	local03, #0
	add	ptr__sa001_spin2_dat__, ##892
	sub	objptr, #12
	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
LR__0010
'   long[base+64*iii]:=0
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	wrlong	#0, local01
'   long[base+64*iii+4]:=0
	mov	local01, local02
	mov	result2, local03
	shl	result2, #6
	add	local01, result2
	add	local01, #4
	wrlong	#0, local01
'   long[base+64*iii+12]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #12
	wrlong	#0, local04
'   long[base+64*iii+16]:=2 
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #16
	wrlong	#2, local04
'   word[base+64*iii+20]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #20
	wrword	#0, local04
'   word[base+64*iii+22]:=8192
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #22
	wrword	##8192, local04
'   word[base+64*iii+24]:=4000+2*iii
	mov	local04, local03
	shl	local04, #1
	mov	local01, ##4000
	add	local01, local04
	mov	local04, local02
	mov	result2, local03
	shl	result2, #6
	add	local04, result2
	add	local04, #24
	wrword	local01, local04
'   word[base+64*iii+26]:=2
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #26
	wrword	#2, local04
'   long [base+64*iii+8]:=@null | $C0000000
	mov	local01, ptr__sa001_spin2_dat__
	bith	local01, #62
	mov	local04, local02
	mov	arg03, local03
	shl	arg03, #6
	add	local04, arg03
	add	local04, #8
	wrlong	local01, local04
'   long[base+64*iii+32]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #32
	wrlong	#0, local04
'   long[base+64*iii+36]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #36
	wrlong	#0, local04
'   long[base+64*iii+40]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #40
	wrlong	#0, local04
'   long[base+64*iii+44]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #44
	wrlong	#0, local04
'   long[base+64*iii+28]:=0
	mov	local04, local02
	mov	local01, local03
	shl	local01, #6
	add	local04, local01
	add	local04, #28
	wrlong	#0, local04
	add	local03, #1
	cmps	local03, #8 wc
 if_b	jmp	#LR__0010
LR__0011
	sub	ptr__sa001_spin2_dat__, ##892
'   
' cog:=coginit(16,@audio,@mailboxaddr)
	mov	arg02, ptr__sa001_spin2_dat__
	mov	arg03, objptr
	mov	local04, #16
	setq	arg03
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
' waitms(100)
	mov	arg01, #100
	call	#__system___waitms
' return cog,base
	mov	result2, local02
	mov	result1, local04
	mov	ptra, fp
	call	#popregs_
_sa001_spin2_start_ret
	ret

' 
' ' a simple play procedure to not poke everything. 
' 
' pub play(channel,sample,splfreq,vol,len,loop=-1) |base2
_sa001_spin2_play
' 
' base2:=@channel1[0]+64*channel
	add	objptr, #12
	mov	_var01, objptr
	shl	arg01, #6
	add	_var01, arg01
' 
' 
' long[base2+12]:= len
	mov	arg01, _var01
	add	arg01, #12
	wrlong	arg05, arg01
' if loop >=0 
	cmps	arg06, #0 wc
'   long[base2+16]:= loop
	sub	objptr, #12
 if_ae	mov	arg01, _var01
 if_ae	add	arg01, #16
 if_ae	wrlong	arg06, arg01
' else
'   long[base2+16]:= len+2
 if_b	add	arg05, #2
 if_b	mov	arg06, _var01
 if_b	add	arg06, #16
 if_b	wrlong	arg05, arg06
' word[base2+20]:=vol
	mov	arg01, _var01
	add	arg01, #20
	wrword	arg04, arg01
' long[base2+24]:= splfreq
	mov	arg01, _var01
	add	arg01, #24
	wrlong	arg03, arg01
' 
' long[base2+28]:=$40000000    
	mov	arg01, _var01
	add	arg01, #28
	wrlong	##1073741824, arg01
' long[base2+32]:=0    
	mov	arg01, _var01
	add	arg01, #32
	wrlong	#0, arg01
' long[base2+36]:=0    
	mov	arg01, _var01
	add	arg01, #36
	wrlong	#0, arg01
' long[base2+40]:=0    
	mov	arg01, _var01
	add	arg01, #40
	wrlong	#0, arg01
' long[base2+44]:=0    
	mov	arg01, _var01
	add	arg01, #44
	wrlong	#0, arg01
' long[base2+8]:=sample+$C0000000     
	add	arg02, ##-1073741824
	add	_var01, #8
	wrlong	arg02, _var01
_sa001_spin2_play_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB startx(freq, burst, delay, desiredcog) : result | driverAddr
_psram_spin2_startx
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	mov	local03, arg04
'     stop() ' restart driver if required
	call	#_psram_spin2_stop
	cmp	local01, #0 wz
 if_e	rdlong	local01, #20
	abs	arg02, local01 wc
	qdiv	arg02, ##1000000
' 
'     ' use current frequency if none specified
' 
'     if freq == 0 
'         freq := clkfreq 
' 
'     ' compute the device burst size including overheads to keep CS low time below 8us
' 
'     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
'     if burst < 0
'         return ERR_TOO_SLOW ' P2 frequency is too low for any 8us transfers
	getqx	arg02
	negc	arg04, arg02
	shl	arg04, #3
	sub	arg04, #132
	shr	arg04, #4
	shl	arg04, #4
	cmps	arg04, #0 wc
 if_b	neg	result1, #14
 if_b	jmp	#LR__0023
' 
'     ' compute the input delay
' 
'     if delay <= 0
	cmps	local02, #1 wc
 if_ae	jmp	#LR__0020
'         delay := lookupDelay(freq)
	mov	arg01, local01
	call	#_psram_spin2_lookupDelay
	mov	local02, result1
	jmp	#LR__0021
LR__0020
'     else
'         delay <#= $f ' limit to 15
	fles	local02, #15
LR__0021
' 
'     ' create our lock
' 
'     driverlock := LOCKNEW()  
	mov	result1, #0
	locknew	result1
	add	ptr__psram_spin2_dat__, #260
	wrlong	result1, ptr__psram_spin2_dat__
'     if driverlock == -1
	sub	ptr__psram_spin2_dat__, #260
	cmp	result1, ##-1 wz
'         return ERR_NO_LOCK
 if_e	neg	result1, #26
 if_e	jmp	#LR__0023
' 
'     ' patch in the proper data and HUB addresses to the startup structure
' 
'     long[@startupData][0]:=clkfreq
	rdlong	local01, #20
	add	ptr__psram_spin2_dat__, #296
	wrlong	local01, ptr__psram_spin2_dat__
' '    long[@startupData][1]:=$1000_0000
'     long[@startupData][5]:=@deviceData
	add	ptr__psram_spin2_dat__, #32
	mov	local01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #32
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #20
	wrlong	local01, arg02
'     long[@startupData][6]:=@qosData
	add	ptr__psram_spin2_dat__, #160
	mov	local01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #160
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #24
	wrlong	local01, arg02
'     long[@startupData][7]:=$7FF00
	mov	local01, ptr__psram_spin2_dat__
	add	local01, #28
	wrlong	##524032, local01
' 
'     ' setup some default bank and QoS parameter values
' 
'     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
	add	ptr__psram_spin2_dat__, #32
	mov	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #328
	shl	arg04, #16
	shl	local02, #12
	or	arg04, local02
	or	arg04, #24
	mov	arg02, arg04
	mov	arg03, #2
	call	#\builtin_longfill_
'     longfill(@qosData, $FFFF0000, 8)
	add	ptr__psram_spin2_dat__, #456
	mov	arg03, #7
	setq	arg03
	wrlong	##-65536, ptr__psram_spin2_dat__
' 
'     ' get the address of the PSRAM memory driver so we can start it
' 
'     driverAddr:= driver.getDriverAddr()
'     return @driver_start
	add	ptr__psram16drv_spin2_dat__, #32
	mov	arg02, ptr__psram16drv_spin2_dat__
	sub	ptr__psram16drv_spin2_dat__, #32
' 
'     ' start the PSRAM memory driver and wait for it to complete initialization
' 
'     if desiredcog < 0
	cmps	local03, #0 wc
'         desiredcog := NEWCOG
 if_b	mov	local03, #16
'     drivercog := coginit(desiredcog, driverAddr, @startupData)
	sub	ptr__psram_spin2_dat__, #160
	mov	local04, local03
	setq	ptr__psram_spin2_dat__
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
	sub	ptr__psram_spin2_dat__, #40
	wrlong	local04, ptr__psram_spin2_dat__
'     repeat until long[@startupData] == 0 
	add	ptr__psram_spin2_dat__, #40
LR__0022
	rdlong	local04, ptr__psram_spin2_dat__ wz
 if_ne	jmp	#LR__0022
' 
'     return drivercog
	sub	ptr__psram_spin2_dat__, #40
	rdlong	result1, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
LR__0023
	mov	ptra, fp
	call	#popregs_
_psram_spin2_startx_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB stop() : i
_psram_spin2_stop
	mov	_var01, #0
'     if drivercog <> -1
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	arg01, ##-1 wz
 if_e	jmp	#LR__0033
'         cogstop(drivercog) ' a rather brutal stop
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cogstop	arg01
	callpa	#(@LR__0032-@LR__0030)>>2,fcache_load_ptr_
'         repeat i from 0 to 7
LR__0030
'             if long[$7FF00][i*3] < 0
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##524032
	rdlong	result1, result1
	cmps	result1, #0 wc
 if_ae	jmp	#LR__0031
'                 long[$7FF00][i*3] := -ERR_ABORTED ' abort request
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##524032
	wrlong	#16, result1
LR__0031
	add	_var01, #1
	cmps	_var01, #8 wc
 if_b	jmp	#LR__0030
LR__0032
'         drivercog := -1
	add	ptr__psram_spin2_dat__, #256
	wrlong	##-1, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
LR__0033
'     if driverlock <> -1
	add	ptr__psram_spin2_dat__, #260
	rdlong	_var02, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #260
	cmp	_var02, ##-1 wz
'         LOCKRET(driverlock)
 if_ne	add	ptr__psram_spin2_dat__, #260
 if_ne	rdlong	arg01, ptr__psram_spin2_dat__
 if_ne	lockret	arg01
'         driverlock := -1
 if_ne	wrlong	##-1, ptr__psram_spin2_dat__
 if_ne	sub	ptr__psram_spin2_dat__, #260
	mov	result1, _var01
_psram_spin2_stop_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB write(srcHubAddr, dstAddr, count) : result | mailbox
_psram_spin2_write
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__0041
'     if count == 0 ' don't even bother writing
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__0041
'     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	mov	_var02, ##524032
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__0041
'     long[mailbox][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox][1] := srcHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
	mov	_var03, arg02
	bitl	_var03, #217
	mov	_var01, ##-268435456
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__0040
'         result := long[mailbox]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__0040
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__0041
_psram_spin2_write_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PRI lookupDelay(freq) : delay | profile
_psram_spin2_lookupDelay
'     profile := @delayTable
	add	ptr__psram_spin2_dat__, #264
	mov	_var01, ptr__psram_spin2_dat__
'     delay := long[profile][0]
	rdlong	_var02, _var01
'     repeat while long[profile][1] 
	sub	ptr__psram_spin2_dat__, #264
	callpa	#(@LR__0051-@LR__0050)>>2,fcache_load_ptr_
LR__0050
	add	_var01, #4
	rdlong	result1, _var01 wz
	sub	_var01, #4
 if_e	jmp	#LR__0052
'         if freq +< long[profile][1] 
	add	_var01, #4
	rdlong	result1, _var01
	sub	_var01, #4
	cmp	arg01, result1 wc
'             quit
'         profile += 4
 if_ae	add	_var01, #4
'         delay++
 if_ae	add	_var02, #1
 if_ae	jmp	#LR__0050
LR__0051
LR__0052
	mov	result1, _var02
_psram_spin2_lookupDelay_ret
	ret
hubexit
	jmp	#cogexit

__system___setbaud
	rdlong	muldiva_, #20
	mov	muldivb_, arg01
	call	#divide_
	callpa	#(@LR__0061-@LR__0060)>>2,fcache_load_ptr_
LR__0060
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__0060
LR__0061
	dirl	#62
	dirl	#63
	wrlong	muldivb_, ptr___system__dat__
	shl	muldivb_, #16
	mov	arg02, #7
	add	arg02, muldivb_
	wrpin	#124, #62
	wxpin	arg02, #62
	wrpin	#62, #63
	add	arg02, #20
	wxpin	arg02, #63
	dirh	#62
	dirh	#63
__system___setbaud_ret
	ret

__system___txraw
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	callpa	#(@LR__0071-@LR__0070)>>2,fcache_load_ptr_
LR__0070
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__0070
LR__0071
	rdlong	result1, ptr___system__dat__ wz
 if_e	mov	arg01, ##230400
 if_e	call	#__system___setbaud
	drvl	#62
	wypin	local01, #62
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___txraw_ret
	ret

__system___rxraw
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, ptr___system__dat__ wz
 if_e	mov	arg01, ##230400
 if_e	call	#__system___setbaud
	cmp	local01, #0 wz
 if_e	jmp	#LR__0080
	rdlong	local03, #20
	shr	local03, #10
	qmul	local01, local03
	getct	result1
	getqx	local04
	add	result1, local04
	mov	local05, result1
	jmp	#LR__0081
LR__0080
	mov	local05, #0
LR__0081
	neg	local06, #1
	mov	local07, #63
	mov	local08, #0
	add	ptr___system__dat__, #4
	rdlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
LR__0082
	testb	local09, #8 wc
	testbn	local09, #9 andc
	shr	local09, #10
 if_b	mov	local08, #1
 if_ae	testp	#63 wz
 if_nc_and_z	mov	local08, #1
 if_nc_and_z	rdpin	local09, #63
 if_nc_and_z	shr	local09, #4
LR__0083
	mov	local02, #0
	cmp	local08, #0 wz
 if_ne	neg	local02, #1
	mov	local10, #0
	mov	local03, #0
	cmp	local01, #0 wz
 if_ne	neg	local03, #1
	mov	local04, #0
	mov	local11, #0
	mov	local12, local05
	getct	result1
	mov	local13, result1
	sub	local12, local13
	cmps	local12, #0 wc
 if_b	not	local11, #0
	cmp	local11, #0 wz
 if_ne	not	local04, #0
	test	local03, local04 wz
 if_ne	not	local10, #0
	or	local02, local10 wz
 if_e	jmp	#LR__0082
	cmp	local08, #0 wz
 if_ne	mov	local06, local09
 if_ne	getbyte	local06, local06, #0
	add	ptr___system__dat__, #4
	wrlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___rxraw_ret
	ret

__system___lockmem
	mov	result1, #0
	cogid	result1
	add	result1, #256
LR__0090
	rdlong	_var01, arg01 wz
 if_e	wrlong	result1, arg01
 if_e	rdlong	_var01, arg01
 if_e	rdlong	_var01, arg01
	cmp	_var01, result1 wz
 if_ne	jmp	#LR__0090
__system___lockmem_ret
	ret

__system___tx
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	cmp	local01, #10 wz
 if_ne	jmp	#LR__0100
	add	ptr___system__dat__, #8
	rdlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	local02, #2 wz
 if_ne	mov	arg01, #13
 if_ne	call	#__system___txraw
LR__0100
	mov	arg01, local01
	call	#__system___txraw
	mov	ptra, fp
	call	#popregs_
__system___tx_ret
	ret

__system___rx
	mov	COUNT_, #1
	call	#pushregs_
LR__0110
	mov	arg01, #0
	call	#__system___rxraw
	mov	local01, result1
	cmp	local01, ##-1 wz
 if_e	jmp	#LR__0110
	cmp	local01, #13 wz
 if_ne	jmp	#LR__0111
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	result1, #2 wz
 if_ne	mov	local01, #10
LR__0111
	add	ptr___system__dat__, #8
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	arg01, #1 wz
 if_e	jmp	#LR__0114
	cmp	local01, #127 wz
 if_ne	jmp	#LR__0112
	mov	arg01, #8
	call	#__system___tx
	jmp	#LR__0113
LR__0112
	mov	arg01, local01
	call	#__system___tx
LR__0113
LR__0114
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system___rx_ret
	ret

__system___waitms
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__0121-@LR__0120)>>2,fcache_load_ptr_
LR__0120
	cmps	_var01, ##1000 wc
 if_b	jmp	#LR__0122
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000
	jmp	#LR__0120
LR__0121
LR__0122
	cmps	_var01, #1 wc
 if_b	jmp	#LR__0123
	qmul	_var01, _var03
	mov	arg03, ##1000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	arg01
	addct1	arg01, _var02
	waitct1
LR__0123
__system___waitms_ret
	ret

__system___basic_print_char
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	call	#__system___gettxfunc
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0130
	mov	local03, local02
	zerox	local02, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local02
	call	local03
	mov	objptr, local01
	mov	result1, #1
LR__0130
	mov	ptra, fp
	call	#popregs_
__system___basic_print_char_ret
	ret

__system___basic_print_unsigned
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	call	#__system___gettxfunc
	mov	arg01, result1 wz
 if_e	mov	result1, #0
 if_ne	bith	local02, #58
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	mov	arg04, local03
 if_ne	call	#__system___fmtnum
	mov	ptra, fp
	call	#popregs_
__system___basic_print_unsigned_ret
	ret

__system___fmtchar
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #4
	wrlong	arg01, fp
	add	fp, #4
	wrlong	arg02, fp
	add	fp, #4
	wrlong	arg03, fp
	getbyte	arg03, arg03, #0
	wrlong	arg03, fp
	sub	fp, #8
	rdlong	arg01, fp
	add	fp, #4
	rdlong	arg02, fp
	add	fp, #4
	mov	arg03, fp
	sub	fp, #12
	call	#__system___fmtstr
	mov	ptra, fp
	call	#popregs_
__system___fmtchar_ret
	ret

__system___fmtstr
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg04, local02, #0
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__0141-@LR__0140)>>2,fcache_load_ptr_
LR__0140
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0140
LR__0141
	sub	local04, arg01
	cmp	arg04, #0 wz
 if_ne	fles	local04, arg04 wcz
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #2
	call	#__system___fmtpad
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	mov	result1, local05
 if_b	jmp	#LR__0144
	cmps	local04, #1 wc
 if_b	jmp	#LR__0143
	mov	local06, local04
LR__0142
	mov	local07, local01
	mov	local08, local01
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	rdbyte	arg01, local03
	mov	local09, objptr
	mov	objptr, local07
	add	local03, #1
	call	local08
	mov	objptr, local09
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_b	jmp	#LR__0144
	add	local05, local09
	djnz	local06, #LR__0142
LR__0143
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #1
	call	#__system___fmtpad
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_ae	add	local05, local09
 if_ae	mov	result1, local05
LR__0144
	mov	ptra, fp
	call	#popregs_
__system___fmtstr_ret
	ret

__system___fmtnum
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, ptra
	mov	local06, local05
	mov	local07, #0
	mov	local08, local02
	shr	local08, #16
	and	local08, #63
	getbyte	local09, local02, #0
	mov	local10, local02
	shr	local10, #26
	and	local10, #3
	mov	local11, local10
	cmps	local08, #1 wc
	add	ptra, #68
 if_ae	sub	local08, #1
	cmps	local09, #65 wc
 if_b	cmp	local09, #0 wz
 if_nc_or_z	mov	local09, #64
	cmp	local11, #3 wz
 if_e	mov	local11, #0
 if_ne	cmps	local03, #0 wc
 if_c_and_nz	mov	local11, #4
 if_c_and_nz	neg	local03, local03
	cmp	local11, #0 wz
 if_e	jmp	#LR__0153
	mov	local07, #1
	cmp	local08, local09 wz
 if_ne	jmp	#LR__0151
	djnz	local08, #LR__0150
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #35
	call	#__system___fmtchar
	jmp	#LR__0157
LR__0150
LR__0151
	cmp	local11, #2 wz
 if_e	mov	local10, local06
 if_e	add	local06, #1
 if_e	wrbyte	#32, local10
 if_e	jmp	#LR__0152
	cmp	local11, #4 wz
 if_e	wrbyte	#45, local06
 if_e	add	local06, #1
 if_ne	wrbyte	#43, local06
 if_ne	add	local06, #1
LR__0152
LR__0153
	mov	arg01, local06
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local08
	mov	arg05, #0
	testbn	local02, #29 wz
 if_ne	mov	arg05, #1
	call	#__system___uitoa
	add	local07, result1
	cmps	local07, local09 wcz
 if_be	jmp	#LR__0156
	callpa	#(@LR__0155-@LR__0154)>>2,fcache_load_ptr_
LR__0154
	mov	local10, local09
	cmps	local10, #1 wc
	sub	local09, #1
 if_ae	mov	local10, local06
 if_ae	add	local06, #1
 if_ae	wrbyte	#35, local10
 if_ae	jmp	#LR__0154
LR__0155
	wrbyte	#0, local06
LR__0156
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local05
	call	#__system___fmtstr
LR__0157
	mov	ptra, fp
	call	#popregs_
__system___fmtnum_ret
	ret

__system____default_getc
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #8
	rdlong	local03, local02
	test	local03, #2 wz
 if_ne	mov	arg01, local01
 if_ne	call	#__system____default_flush
	rdlong	local03, local02
	or	local03, #1
	wrlong	local03, local02
	sub	local02, #8
	rdlong	local03, local02 wz
 if_ne	jmp	#LR__0160
	mov	arg01, local01
	call	#__system____default_filbuf
	mov	local03, result1
LR__0160
	cmps	local03, #1 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__0161
	sub	local03, #1
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	rdbyte	result1, local03
	add	local03, #1
	wrlong	local03, local02
LR__0161
	mov	ptra, fp
	call	#popregs_
__system____default_getc_ret
	ret

__system____default_putc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local02
	add	local03, #8
	rdlong	result1, local03
	test	result1, #1 wz
 if_ne	mov	arg01, local02
 if_ne	call	#__system____default_flush
	rdlong	local04, local03
	or	local04, #2
	wrlong	local04, local03
	sub	local03, #8
	rdlong	local05, local03
	add	local03, #16
	rdlong	arg02, local03
	sub	local03, #16
	mov	result1, local05
	add	result1, arg02
	wrbyte	local01, result1
	getbyte	local01, local01, #0
	add	local05, #1
	wrlong	local05, local03
	add	local02, #6
	rdword	local06, local02 wz
	sub	local02, #6
 if_ne	add	local03, #12
 if_ne	rdlong	local04, local03
 if_ne	cmp	local05, local04 wz
 if_e	jmp	#LR__0170
	cmp	local01, #10 wz
 if_e	cmp	local06, #1 wz
 if_ne	jmp	#LR__0171
LR__0170
	mov	arg01, local02
	call	#__system____default_flush
	cmp	result1, #0 wz
 if_ne	neg	local01, #1
LR__0171
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system____default_putc_ret
	ret

__system____default_flush
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	rdlong	local03, local02
	add	local02, #8
	rdlong	result1, local02
	sub	local02, #8
	test	result1, #2 wz
 if_e	jmp	#LR__0182
	cmps	local03, #1 wc
 if_b	jmp	#LR__0184
	add	local01, #8
	rdlong	result1, local01
	sub	local01, #8
	test	result1, #64 wz
 if_e	jmp	#LR__0181
	add	local01, #8
	rdlong	arg03, local01
	sub	local01, #8
	test	arg03, #128 wz
 if_e	jmp	#LR__0180
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #2
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	add	local01, #8
	rdlong	local06, local01
	andn	local06, #128
	wrlong	local06, local01
	sub	local01, #8
LR__0180
LR__0181
	add	local01, #24
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #24
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	add	local02, #16
	rdlong	arg02, local02
	sub	local02, #16
	mov	arg01, local01
	mov	arg03, local03
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	jmp	#LR__0184
LR__0182
	add	local02, #8
	rdlong	local06, local02
	sub	local02, #8
	test	local06, #1 wz
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__0183
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	neg	arg02, local03
	mov	arg03, #1
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
LR__0183
LR__0184
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system____default_flush_ret
	ret

__system____getftab
	cmp	arg01, #10 wc
 if_b	qmul	arg01, #52
 if_ae	mov	result1, #0
 if_b	add	ptr___system__dat__, #40
 if_b	getqx	result1
 if_b	add	result1, ptr___system__dat__
 if_b	sub	ptr___system__dat__, #40
__system____getftab_ret
	ret

__system___strrev
	rdbyte	_var01, arg01 wz
 if_e	jmp	#__system___strrev_ret
	mov	_var02, arg01
	callpa	#(@LR__0192-@LR__0190)>>2,fcache_load_ptr_
LR__0190
	rdbyte	_var01, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__0190
	sub	_var02, #1
LR__0191
	cmps	_var02, arg01 wcz
 if_be	jmp	#LR__0193
	rdbyte	_var01, arg01
	rdbyte	_var03, _var02
	wrbyte	_var03, arg01
	wrbyte	_var01, _var02
	add	arg01, #1
	sub	_var02, #1
	jmp	#LR__0191
LR__0192
LR__0193
__system___strrev_ret
	ret

__system___fmtpad
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg01, local02, #1
	shr	local02, #22
	and	local02, #3 wz
	mov	local04, #0
 if_e	mov	local02, #1
	test	local02, arg04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0203
	subr	local03, arg01
	cmps	local03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__0203
	cmp	local02, #3 wz
 if_ne	jmp	#LR__0200
	cmp	arg04, #1 wz
	wrz	local02
	add	local03, local02
	abs	local03, local03 wc
	shr	local03, #1
	negc	local03, local03
LR__0200
	cmps	local03, #1 wc
 if_b	jmp	#LR__0202
	mov	local05, local03
LR__0201
	mov	local02, local01
	mov	local06, local01
	zerox	local02, #19
	shr	local06, #20
	shl	local06, #2
	add	local06, __methods__
	rdlong	local06, local06
	mov	arg01, #32
	mov	local03, objptr
	mov	objptr, local02
	call	local06
	mov	objptr, local03
	mov	local06, result1
	cmps	local06, #0 wc
 if_b	mov	result1, local06
 if_b	jmp	#LR__0203
	add	local04, local06
	djnz	local05, #LR__0201
LR__0202
	mov	result1, local04
LR__0203
	mov	ptra, fp
	call	#popregs_
__system___fmtpad_ret
	ret

__system___uitoa
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	cmps	arg05, #0 wz
	mov	arg05, local01
	mov	local02, #0
 if_ne	mov	local03, #55
 if_e	mov	local03, #87
LR__0210
	qdiv	arg02, arg03
	getqy	local04
	qdiv	arg02, arg03
	cmp	local04, #10 wc
 if_b	add	local04, #48
 if_ae	add	local04, local03
	wrbyte	local04, arg05
	add	arg05, #1
	add	local02, #1
	getqx	arg02
	cmp	arg02, #0 wz
 if_ne	jmp	#LR__0210
	cmp	local02, arg04 wc
 if_b	jmp	#LR__0210
	wrbyte	#0, arg05
	mov	arg01, local01
	call	#__system___strrev
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
__system___uitoa_ret
	ret

__system___gettxfunc
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__0220
	add	local01, #8
	rdlong	arg02, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__0221
LR__0220
	mov	result1, #0
	jmp	#LR__0222
LR__0221
	bith	local01, #52
	mov	result1, local01
LR__0222
	mov	ptra, fp
	call	#popregs_
__system___gettxfunc_ret
	ret

__system___getiolock_0095
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__0230
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__0231
LR__0230
	add	ptr___system__dat__, #36
	mov	result1, ptr___system__dat__
	sub	ptr___system__dat__, #36
	jmp	#LR__0232
LR__0231
	add	local01, #12
	mov	result1, local01
LR__0232
	mov	ptra, fp
	call	#popregs_
__system___getiolock_0095_ret
	ret

__system___rxtxioctl_0142
	cmp	arg02, #256 wz
 if_e	jmp	#LR__0240
	cmp	arg02, #257 wz
 if_e	jmp	#LR__0241
	jmp	#LR__0242
LR__0240
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	wrlong	result1, arg03
	mov	result1, #0
	jmp	#LR__0243
LR__0241
	rdlong	arg01, arg03
	add	ptr___system__dat__, #8
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	mov	result1, #0
	jmp	#LR__0243
LR__0242
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
LR__0243
__system___rxtxioctl_0142_ret
	ret

__system____dummy_flush_0143
	mov	result1, #0
__system____dummy_flush_0143_ret
	ret

__system____default_filbuf
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #12
	rdlong	result1, local02 wz
	sub	local02, #12
 if_ne	jmp	#LR__0250
	add	local02, #20
	mov	result1, local02
	sub	local02, #4
	wrlong	result1, local02
	sub	local02, #4
	wrlong	##1024, local02
	sub	local02, #12
LR__0250
	add	local01, #20
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #20
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	add	local02, #16
	rdlong	arg02, local02
	sub	local02, #4
	rdlong	arg03, local02
	sub	local02, #12
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local01
	mov	local04, result1
	cmps	local04, #0 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__0251
	wrlong	local04, local02
	add	local02, #16
	rdlong	local03, local02
	sub	local02, #12
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	or	local03, #1
	wrlong	local03, local02
	mov	result1, local04
LR__0251
	mov	ptra, fp
	call	#popregs_
__system____default_filbuf_ret
	ret

__struct__s_vfs_file_t_putchar
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, #28
	rdlong	local01, objptr wz
	sub	objptr, #28
 if_e	mov	result1, #0
 if_e	jmp	#LR__0260
	add	objptr, #28
	rdlong	local02, objptr
	mov	local03, local02
	sub	objptr, #28
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg02, objptr
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
'     return (i < 0) ? 0 : 1;
	cmps	result1, #0 wc
 if_b	mov	local01, #0
 if_ae	mov	local01, #1
	mov	result1, local01
LR__0260
	mov	ptra, fp
	call	#popregs_
__struct__s_vfs_file_t_putchar_ret
	ret

__struct__s_vfs_file_t_getchar
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #32
	rdlong	arg01, objptr wz
	sub	objptr, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0270
'     return getcf(__this);
	add	objptr, #32
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #32
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	arg01, objptr
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
LR__0270
	mov	ptra, fp
	call	#popregs_
__struct__s_vfs_file_t_getchar_ret
	ret

__struct___bas_wrap_sender_tx
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, objptr
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__struct___bas_wrap_sender_tx_ret
	ret

__struct___bas_wrap_sender_rx
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #4
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #4
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__struct___bas_wrap_sender_rx_ret
	ret

__struct___bas_wrap_sender_close
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #8
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #8
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__struct___bas_wrap_sender_close_ret
	ret
	alignl
_dat_
'-' sinewave file "sinus.s2"
	byte	$73, $32, $00, $04, $00, $00, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $c9, $00, $92, $01, $5b, $02, $24, $03, $ed, $03, $b6, $04, $7f, $05
	byte	$48, $06, $11, $07, $d9, $07, $a2, $08, $6a, $09, $33, $0a, $fb, $0a, $c4, $0b
	byte	$8c, $0c, $54, $0d, $1c, $0e, $e3, $0e, $ab, $0f, $72, $10, $3a, $11, $01, $12
	byte	$c8, $12, $8f, $13, $55, $14, $1c, $15, $e2, $15, $a8, $16, $6e, $17, $33, $18
	byte	$f9, $18, $be, $19, $82, $1a, $47, $1b, $0b, $1c, $cf, $1c, $93, $1d, $57, $1e
	byte	$1a, $1f, $dd, $1f, $9f, $20, $61, $21, $23, $22, $e5, $22, $a6, $23, $67, $24
	byte	$28, $25, $e8, $25, $a8, $26, $67, $27, $26, $28, $e5, $28, $a3, $29, $61, $2a
	byte	$1f, $2b, $dc, $2b, $99, $2c, $55, $2d, $11, $2e, $cc, $2e, $87, $2f, $41, $30
	byte	$fb, $30, $b5, $31, $6e, $32, $26, $33, $df, $33, $96, $34, $4d, $35, $04, $36
	byte	$ba, $36, $6f, $37, $24, $38, $d9, $38, $8c, $39, $40, $3a, $f2, $3a, $a5, $3b
	byte	$56, $3c, $07, $3d, $b8, $3d, $68, $3e, $17, $3f, $c5, $3f, $73, $40, $21, $41
	byte	$ce, $41, $7a, $42, $25, $43, $d0, $43, $7a, $44, $24, $45, $cd, $45, $75, $46
	byte	$1c, $47, $c3, $47, $69, $48, $0f, $49, $b4, $49, $58, $4a, $fb, $4a, $9d, $4b
	byte	$3f, $4c, $e0, $4c, $81, $4d, $20, $4e, $bf, $4e, $5d, $4f, $fb, $4f, $97, $50
	byte	$33, $51, $ce, $51, $68, $52, $02, $53, $9b, $53, $32, $54, $c9, $54, $60, $55
	byte	$f5, $55, $8a, $56, $1d, $57, $b0, $57, $42, $58, $d3, $58, $64, $59, $f3, $59
	byte	$82, $5a, $0f, $5b, $9c, $5b, $28, $5c, $b3, $5c, $3e, $5d, $c7, $5d, $4f, $5e
	byte	$d7, $5e, $5d, $5f, $e3, $5f, $68, $60, $eb, $60, $6e, $61, $f0, $61, $71, $62
	byte	$f1, $62, $70, $63, $ee, $63, $6c, $64, $e8, $64, $63, $65, $dd, $65, $56, $66
	byte	$cf, $66, $46, $67, $bc, $67, $32, $68, $a6, $68, $19, $69, $8b, $69, $fd, $69
	byte	$6d, $6a, $dc, $6a, $4a, $6b, $b7, $6b, $23, $6c, $8e, $6c, $f8, $6c, $61, $6d
	byte	$c9, $6d, $30, $6e, $96, $6e, $fb, $6e, $5e, $6f, $c1, $6f, $22, $70, $83, $70
	byte	$e2, $70, $40, $71, $9d, $71, $f9, $71, $54, $72, $ae, $72, $07, $73, $5e, $73
	byte	$b5, $73, $0a, $74, $5f, $74, $b2, $74, $04, $75, $55, $75, $a5, $75, $f3, $75
	byte	$41, $76, $8d, $76, $d8, $76, $22, $77, $6b, $77, $b3, $77, $fa, $77, $3f, $78
	byte	$84, $78, $c7, $78, $09, $79, $4a, $79, $89, $79, $c8, $79, $05, $7a, $41, $7a
	byte	$7c, $7a, $b6, $7a, $ee, $7a, $26, $7b, $5c, $7b, $91, $7b, $c5, $7b, $f8, $7b
	byte	$29, $7c, $59, $7c, $88, $7c, $b6, $7c, $e3, $7c, $0e, $7d, $39, $7d, $62, $7d
	byte	$89, $7d, $b0, $7d, $d5, $7d, $fa, $7d, $1d, $7e, $3e, $7e, $5f, $7e, $7e, $7e
	byte	$9c, $7e, $b9, $7e, $d5, $7e, $ef, $7e, $09, $7f, $21, $7f, $37, $7f, $4d, $7f
	byte	$61, $7f, $74, $7f, $86, $7f, $97, $7f, $a6, $7f, $b4, $7f, $c1, $7f, $cd, $7f
	byte	$d8, $7f, $e1, $7f, $e9, $7f, $f0, $7f, $f5, $7f, $f9, $7f, $fd, $7f, $fe, $7f
	byte	$ff, $7f, $fe, $7f, $fd, $7f, $f9, $7f, $f5, $7f, $f0, $7f, $e9, $7f, $e1, $7f
	byte	$d8, $7f, $cd, $7f, $c1, $7f, $b4, $7f, $a6, $7f, $97, $7f, $86, $7f, $74, $7f
	byte	$61, $7f, $4d, $7f, $37, $7f, $21, $7f, $09, $7f, $ef, $7e, $d5, $7e, $b9, $7e
	byte	$9c, $7e, $7e, $7e, $5f, $7e, $3e, $7e, $1d, $7e, $fa, $7d, $d5, $7d, $b0, $7d
	byte	$89, $7d, $62, $7d, $39, $7d, $0e, $7d, $e3, $7c, $b6, $7c, $88, $7c, $59, $7c
	byte	$29, $7c, $f8, $7b, $c5, $7b, $91, $7b, $5c, $7b, $26, $7b, $ee, $7a, $b6, $7a
	byte	$7c, $7a, $41, $7a, $05, $7a, $c8, $79, $89, $79, $4a, $79, $09, $79, $c7, $78
	byte	$84, $78, $3f, $78, $fa, $77, $b3, $77, $6b, $77, $22, $77, $d8, $76, $8d, $76
	byte	$41, $76, $f3, $75, $a5, $75, $55, $75, $04, $75, $b2, $74, $5f, $74, $0a, $74
	byte	$b5, $73, $5e, $73, $07, $73, $ae, $72, $54, $72, $f9, $71, $9d, $71, $40, $71
	byte	$e2, $70, $83, $70, $22, $70, $c1, $6f, $5e, $6f, $fb, $6e, $96, $6e, $30, $6e
	byte	$c9, $6d, $61, $6d, $f8, $6c, $8e, $6c, $23, $6c, $b7, $6b, $4a, $6b, $dc, $6a
	byte	$6d, $6a, $fd, $69, $8b, $69, $19, $69, $a6, $68, $32, $68, $bc, $67, $46, $67
	byte	$cf, $66, $56, $66, $dd, $65, $63, $65, $e8, $64, $6c, $64, $ee, $63, $70, $63
	byte	$f1, $62, $71, $62, $f0, $61, $6e, $61, $eb, $60, $68, $60, $e3, $5f, $5d, $5f
	byte	$d7, $5e, $4f, $5e, $c7, $5d, $3e, $5d, $b3, $5c, $28, $5c, $9c, $5b, $0f, $5b
	byte	$82, $5a, $f3, $59, $64, $59, $d3, $58, $42, $58, $b0, $57, $1d, $57, $8a, $56
	byte	$f5, $55, $60, $55, $c9, $54, $32, $54, $9b, $53, $02, $53, $68, $52, $ce, $51
	byte	$33, $51, $97, $50, $fb, $4f, $5d, $4f, $bf, $4e, $20, $4e, $81, $4d, $e0, $4c
	byte	$3f, $4c, $9d, $4b, $fb, $4a, $58, $4a, $b4, $49, $0f, $49, $69, $48, $c3, $47
	byte	$1c, $47, $75, $46, $cd, $45, $24, $45, $7a, $44, $d0, $43, $25, $43, $7a, $42
	byte	$ce, $41, $21, $41, $73, $40, $c5, $3f, $17, $3f, $68, $3e, $b8, $3d, $07, $3d
	byte	$56, $3c, $a5, $3b, $f2, $3a, $40, $3a, $8c, $39, $d9, $38, $24, $38, $6f, $37
	byte	$ba, $36, $04, $36, $4d, $35, $96, $34, $df, $33, $26, $33, $6e, $32, $b5, $31
	byte	$fb, $30, $41, $30, $87, $2f, $cc, $2e, $11, $2e, $55, $2d, $99, $2c, $dc, $2b
	byte	$1f, $2b, $61, $2a, $a3, $29, $e5, $28, $26, $28, $67, $27, $a8, $26, $e8, $25
	byte	$28, $25, $67, $24, $a6, $23, $e5, $22, $23, $22, $61, $21, $9f, $20, $dd, $1f
	byte	$1a, $1f, $57, $1e, $93, $1d, $cf, $1c, $0b, $1c, $47, $1b, $82, $1a, $be, $19
	byte	$f9, $18, $33, $18, $6e, $17, $a8, $16, $e2, $15, $1c, $15, $55, $14, $8f, $13
	byte	$c8, $12, $01, $12, $3a, $11, $72, $10, $ab, $0f, $e3, $0e, $1c, $0e, $54, $0d
	byte	$8c, $0c, $c4, $0b, $fb, $0a, $33, $0a, $6a, $09, $a2, $08, $d9, $07, $11, $07
	byte	$48, $06, $7f, $05, $b6, $04, $ed, $03, $24, $03, $5b, $02, $92, $01, $c9, $00
	byte	$00, $00, $37, $ff, $6e, $fe, $a5, $fd, $dc, $fc, $13, $fc, $4a, $fb, $81, $fa
	byte	$b8, $f9, $ef, $f8, $27, $f8, $5e, $f7, $96, $f6, $cd, $f5, $05, $f5, $3c, $f4
	byte	$74, $f3, $ac, $f2, $e4, $f1, $1d, $f1, $55, $f0, $8e, $ef, $c6, $ee, $ff, $ed
	byte	$38, $ed, $71, $ec, $ab, $eb, $e4, $ea, $1e, $ea, $58, $e9, $92, $e8, $cd, $e7
	byte	$07, $e7, $42, $e6, $7e, $e5, $b9, $e4, $f5, $e3, $31, $e3, $6d, $e2, $a9, $e1
	byte	$e6, $e0, $23, $e0, $61, $df, $9f, $de, $dd, $dd, $1b, $dd, $5a, $dc, $99, $db
	byte	$d8, $da, $18, $da, $58, $d9, $99, $d8, $da, $d7, $1b, $d7, $5d, $d6, $9f, $d5
	byte	$e1, $d4, $24, $d4, $67, $d3, $ab, $d2, $ef, $d1, $34, $d1, $79, $d0, $bf, $cf
	byte	$05, $cf, $4b, $ce, $92, $cd, $da, $cc, $21, $cc, $6a, $cb, $b3, $ca, $fc, $c9
	byte	$46, $c9, $91, $c8, $dc, $c7, $27, $c7, $74, $c6, $c0, $c5, $0e, $c5, $5b, $c4
	byte	$aa, $c3, $f9, $c2, $48, $c2, $98, $c1, $e9, $c0, $3b, $c0, $8d, $bf, $df, $be
	byte	$32, $be, $86, $bd, $db, $bc, $30, $bc, $86, $bb, $dc, $ba, $33, $ba, $8b, $b9
	byte	$e4, $b8, $3d, $b8, $97, $b7, $f1, $b6, $4c, $b6, $a8, $b5, $05, $b5, $63, $b4
	byte	$c1, $b3, $20, $b3, $7f, $b2, $e0, $b1, $41, $b1, $a3, $b0, $05, $b0, $69, $af
	byte	$cd, $ae, $32, $ae, $98, $ad, $fe, $ac, $65, $ac, $ce, $ab, $37, $ab, $a0, $aa
	byte	$0b, $aa, $76, $a9, $e3, $a8, $50, $a8, $be, $a7, $2d, $a7, $9c, $a6, $0d, $a6
	byte	$7e, $a5, $f1, $a4, $64, $a4, $d8, $a3, $4d, $a3, $c2, $a2, $39, $a2, $b1, $a1
	byte	$29, $a1, $a3, $a0, $1d, $a0, $98, $9f, $15, $9f, $92, $9e, $10, $9e, $8f, $9d
	byte	$0f, $9d, $90, $9c, $12, $9c, $94, $9b, $18, $9b, $9d, $9a, $23, $9a, $aa, $99
	byte	$31, $99, $ba, $98, $44, $98, $ce, $97, $5a, $97, $e7, $96, $75, $96, $03, $96
	byte	$93, $95, $24, $95, $b6, $94, $49, $94, $dd, $93, $72, $93, $08, $93, $9f, $92
	byte	$37, $92, $d0, $91, $6a, $91, $05, $91, $a2, $90, $3f, $90, $de, $8f, $7d, $8f
	byte	$1e, $8f, $c0, $8e, $63, $8e, $07, $8e, $ac, $8d, $52, $8d, $f9, $8c, $a2, $8c
	byte	$4b, $8c, $f6, $8b, $a1, $8b, $4e, $8b, $fc, $8a, $ab, $8a, $5b, $8a, $0d, $8a
	byte	$bf, $89, $73, $89, $28, $89, $de, $88, $95, $88, $4d, $88, $06, $88, $c1, $87
	byte	$7c, $87, $39, $87, $f7, $86, $b6, $86, $77, $86, $38, $86, $fb, $85, $bf, $85
	byte	$84, $85, $4a, $85, $12, $85, $da, $84, $a4, $84, $6f, $84, $3b, $84, $08, $84
	byte	$d7, $83, $a7, $83, $78, $83, $4a, $83, $1d, $83, $f2, $82, $c7, $82, $9e, $82
	byte	$77, $82, $50, $82, $2b, $82, $06, $82, $e3, $81, $c2, $81, $a1, $81, $82, $81
	byte	$64, $81, $47, $81, $2b, $81, $11, $81, $f7, $80, $df, $80, $c9, $80, $b3, $80
	byte	$9f, $80, $8c, $80, $7a, $80, $69, $80, $5a, $80, $4c, $80, $3f, $80, $33, $80
	byte	$28, $80, $1f, $80, $17, $80, $10, $80, $0b, $80, $07, $80, $03, $80, $02, $80
	byte	$01, $80, $02, $80, $03, $80, $07, $80, $0b, $80, $10, $80, $17, $80, $1f, $80
	byte	$28, $80, $33, $80, $3f, $80, $4c, $80, $5a, $80, $69, $80, $7a, $80, $8c, $80
	byte	$9f, $80, $b3, $80, $c9, $80, $df, $80, $f7, $80, $11, $81, $2b, $81, $47, $81
	byte	$64, $81, $82, $81, $a1, $81, $c2, $81, $e3, $81, $06, $82, $2b, $82, $50, $82
	byte	$77, $82, $9e, $82, $c7, $82, $f2, $82, $1d, $83, $4a, $83, $78, $83, $a7, $83
	byte	$d7, $83, $08, $84, $3b, $84, $6f, $84, $a4, $84, $da, $84, $12, $85, $4a, $85
	byte	$84, $85, $bf, $85, $fb, $85, $38, $86, $77, $86, $b6, $86, $f7, $86, $39, $87
	byte	$7c, $87, $c1, $87, $06, $88, $4d, $88, $95, $88, $de, $88, $28, $89, $73, $89
	byte	$bf, $89, $0d, $8a, $5b, $8a, $ab, $8a, $fc, $8a, $4e, $8b, $a1, $8b, $f6, $8b
	byte	$4b, $8c, $a2, $8c, $f9, $8c, $52, $8d, $ac, $8d, $07, $8e, $63, $8e, $c0, $8e
	byte	$1e, $8f, $7d, $8f, $de, $8f, $3f, $90, $a2, $90, $05, $91, $6a, $91, $d0, $91
	byte	$37, $92, $9f, $92, $08, $93, $72, $93, $dd, $93, $49, $94, $b6, $94, $24, $95
	byte	$93, $95, $03, $96, $75, $96, $e7, $96, $5a, $97, $ce, $97, $44, $98, $ba, $98
	byte	$31, $99, $aa, $99, $23, $9a, $9d, $9a, $18, $9b, $94, $9b, $12, $9c, $90, $9c
	byte	$0f, $9d, $8f, $9d, $10, $9e, $92, $9e, $15, $9f, $98, $9f, $1d, $a0, $a3, $a0
	byte	$29, $a1, $b1, $a1, $39, $a2, $c2, $a2, $4d, $a3, $d8, $a3, $64, $a4, $f1, $a4
	byte	$7e, $a5, $0d, $a6, $9c, $a6, $2d, $a7, $be, $a7, $50, $a8, $e3, $a8, $76, $a9
	byte	$0b, $aa, $a0, $aa, $37, $ab, $ce, $ab, $65, $ac, $fe, $ac, $98, $ad, $32, $ae
	byte	$cd, $ae, $69, $af, $05, $b0, $a3, $b0, $41, $b1, $e0, $b1, $7f, $b2, $20, $b3
	byte	$c1, $b3, $63, $b4, $05, $b5, $a8, $b5, $4c, $b6, $f1, $b6, $97, $b7, $3d, $b8
	byte	$e4, $b8, $8b, $b9, $33, $ba, $dc, $ba, $86, $bb, $30, $bc, $db, $bc, $86, $bd
	byte	$32, $be, $df, $be, $8d, $bf, $3b, $c0, $e9, $c0, $98, $c1, $48, $c2, $f9, $c2
	byte	$aa, $c3, $5b, $c4, $0e, $c5, $c0, $c5, $74, $c6, $27, $c7, $dc, $c7, $91, $c8
	byte	$46, $c9, $fc, $c9, $b3, $ca, $6a, $cb, $21, $cc, $da, $cc, $92, $cd, $4b, $ce
	byte	$05, $cf, $bf, $cf, $79, $d0, $34, $d1, $ef, $d1, $ab, $d2, $67, $d3, $24, $d4
	byte	$e1, $d4, $9f, $d5, $5d, $d6, $1b, $d7, $da, $d7, $99, $d8, $58, $d9, $18, $da
	byte	$d8, $da, $99, $db, $5a, $dc, $1b, $dd, $dd, $dd, $9f, $de, $61, $df, $23, $e0
	byte	$e6, $e0, $a9, $e1, $6d, $e2, $31, $e3, $f5, $e3, $b9, $e4, $7e, $e5, $42, $e6
	byte	$07, $e7, $cd, $e7, $92, $e8, $58, $e9, $1e, $ea, $e4, $ea, $ab, $eb, $71, $ec
	byte	$38, $ed, $ff, $ed, $c6, $ee, $8e, $ef, $55, $f0, $1d, $f1, $e4, $f1, $ac, $f2
	byte	$74, $f3, $3c, $f4, $05, $f5, $cd, $f5, $96, $f6, $5e, $f7, $27, $f8, $ef, $f8
	byte	$b8, $f9, $81, $fa, $4a, $fb, $13, $fc, $dc, $fc, $a5, $fd, $6e, $fe, $37, $ff
	alignl
_sa001_spin2_dat_
'-' 
'-' audio       org     0
'-' 
'-'             rdlong  mailbox2, ptra++     ' get start address of all mailboxes
	byte	$61, $3b, $05, $fb
'-'             rdlong  scbase, ptra++       ' get start address of scope buffer
	byte	$61, $89, $05, $fb
'-'             rdlong  hubptr, ptra++       ' get start address of PSRAM cache
	byte	$61, $95, $05, $fb
'-'  
'-'             cogid   pa                   ' compute cogid
	byte	$01, $ec, $63, $fd
'-'             mul     pa, #12              ' and mailbox spacing
	byte	$0c, $ec, $07, $fa
'-'             add     mailbox2, pa         ' add offset to find this COG's mailbox
	byte	$f6, $3b, $01, $f1
'-'             mov     mailbox,mailbox2     ' we need 2 copies of this to ensble switching between hub and psram
	byte	$9d, $38, $01, $f6
'-' 
'-'             mov     ptrb,#0              ' A tail pointer for the buffer
	byte	$00, $f2, $07, $f6
'-'             wrpin   dac2,#left           ' PWM DAC at 264600=6*44100
	byte	$0e, $92, $05, $fc
'-'             wxpin   ##5000000*256,#left        ' Set initial DACs sample rate. It is now controlled via a register by the main program
	byte	$a0, $25, $a6, $ff, $0e, $00, $1c, $fc
'-'             wrpin   dac2,#right
	byte	$0f, $92, $05, $fc
'-'             wxpin   ##5000000*256,#right    
	byte	$a0, $25, $a6, $ff, $0f, $00, $1c, $fc
'-'             dirh    #left addpins 1
	byte	$41, $9c, $64, $fd
'-'             setse1  #%001<<6 + left      ' Set the event - DAC empty
	byte	$20, $9c, $64, $fd
'-'             mov     cn,#0
	byte	$00, $6e, $05, $f6
'-'             
'-' '---------------------------------------------------------------------------------        
'-' '----------------- The main loop -------------------------------------------------
'-' '---------------------------------------------------------------------------------
'-' 
'-' loop       incmod cn,#7 wcz
	byte	$07, $6e, $1d, $f7
'-' 
'-' 
'-' 	   if_z   waitx ##34000000 ' waitse1
	byte	$66, $03, $81, $af, $1f, $00, $65, $ad
'-' 	   if_z wypin oldls,#left
	byte	$0e, $74, $25, $ac
'-'            if_z wypin oldrs,#right
	byte	$0f, $76, $25, $ac
'-'            
'-' '----------------------------------------------------------------------------------
'-' '------------- Compute channel samples --------------------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' 
'-' p401        mov     channeladd,cn             	' compute the pointer to channel parameters block
	byte	$b7, $2e, $01, $f6
'-'             shl     channeladd,#6
	byte	$06, $2e, $65, $f0
'-'             add     ptra,channeladd
	byte	$97, $f0, $03, $f1
'-' 
'-'             setq    #11                        	' read parameters
	byte	$28, $16, $64, $fd
'-'             rdlong  pointer0,ptra
	byte	$00, $45, $05, $fb
'-'     	    
'-' p408        
'-'             
'-' p404        bitl    command0,#30 wcz          	' bit #30: select PSRAM/HUB
	byte	$1e, $52, $1d, $f4
'-'     if_nz   mov     mailbox,mailbox2            ' if not set, use PSRAM
	byte	$9d, $38, $01, $56
'-'     if_z    mov     mailbox,#0                  ' if set, use HUB 
	byte	$00, $38, $05, $a6
'-' 
'-' p405        getword oldls,sample0,#0          ' extract old sample value
	byte	$a3, $74, $31, $f9
'-'             getword oldrs,sample0,#1
	byte	$a3, $76, $39, $f9
'-'      	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
	byte	$a7, $6a, $39, $f9
'-'     	    getword avol0,volpan0,#0
	byte	$a7, $68, $31, $f9
'-' 
'-'             
'-' '---- envelopes
'-'             
'-'             cmp     envptr0,#0 wcz    		' read the pointer
	byte	$00, $56, $1d, $f2
'-'     if_z    mov     envs1,##$4000		' if 0, no envelope, load $4000=1 for scas
	byte	$20, $00, $00, $af, $00, $b6, $05, $a6
'-'     if_z    jmp     #p410			' and run away	
	byte	$54, $00, $90, $ad
'-' 
'-'             add     envph0,envspd0 
	byte	$ac, $54, $01, $f1
'-'       	    mov     envhi, envph0		' move phase acc to high part of env pointer
	byte	$aa, $b2, $01, $f6
'-' 	    shr     envhi,#6			' leave 10 bits in hi
	byte	$06, $b2, $45, $f0
'-' 	    getword envlo,envhi,#0              ' and 16 bit in lo
	byte	$d9, $b4, $31, $f9
'-' 	    shr     envhi,#16			' move 10 bits of hi to the lower word
	byte	$10, $b2, $45, $f0
'-' 	    cmp     envhi,envlen0 wcz		' compare this to envelope length
	byte	$ad, $b2, $19, $f2
'-'     if_ge   mov     envhi,envlen0		' if greater than, set it at envlen
	byte	$ad, $b2, $01, $36
'-'     if_ge   mov     envlo,#0
	byte	$00, $b4, $05, $36
'-'     if_ge   mov     envph0,envlen0
	byte	$ad, $54, $01, $36
'-'     if_ge   shl     envph0,#22
	byte	$16, $54, $65, $30
'-' 
'-'             mov     envs1,envhi			' get the phase acc
	byte	$d9, $b6, $01, $f6
'-'             shl     envs1,#1			' env defs are words, so phase acc*=2
	byte	$01, $b6, $65, $f0
'-'             add     envs1,envptr0		' and add the pointer
	byte	$ab, $b6, $01, $f1
'-'             rdlong  envs1,envs1			' then read 2 entries
	byte	$db, $b6, $01, $fb
'-'             getword envs2,envs1,#1		' next value
	byte	$db, $b8, $39, $f9
'-'             getword envs1,envs1,#0		' current value
	byte	$db, $b6, $31, $f9
'-'             mul     envs2,envlo			' linear interpolate : new val x envlo
	byte	$da, $b8, $01, $fa
'-'             not     envlo			' sum of envlo and not envlo is always $FFFF
	byte	$da, $b4, $21, $f6
'-'             mul     envs1,envlo
	byte	$da, $b6, $01, $fa
'-'             add     envs1,envs2
	byte	$dc, $b6, $01, $f1
'-'             shr     envs1,#18			' normalize it to $4000
	byte	$12, $b6, $45, $f0
'-'             
'-' p410        testb   sstart0, #27 wz
	byte	$1b, $48, $0d, $f4
'-'     if_z    getrnd  spl
	byte	$1b, $34, $61, $ad
'-'     if_z    jmp     #p406
	byte	$ac, $00, $90, $ad
'-'  
'-'  
'-'  
'-'             add     pointer0,freq0          	' compute the pointer to the next sample       
	byte	$a8, $44, $01, $f1
'-'          	   cmp cn,#2 wz
	byte	$02, $6e, $0d, $f2
'-'          if_z	   wrlong pointer0, #$30
	byte	$30, $44, $65, $ac
'-'          	   
'-'             testb   sstart0,#31 wz            
	byte	$1f, $48, $0d, $f4
'-'     if_z    shl     pointer0,#1        
	byte	$01, $44, $65, $a0
'-'             testb   sstart0,#28 wz            
	byte	$1c, $48, $0d, $f4
'-'     if_z    shl     pointer0,#1        
	byte	$01, $44, $65, $a0
'-'         
'-'             cmp     pointer0,lend0 wcz
	byte	$a6, $44, $19, $f2
'-'     if_ge   sub     pointer0,lend0	      	' and loop if needed     
	byte	$a6, $44, $81, $31
'-'     if_ge   add     pointer0,lstart0       
	byte	$a5, $44, $01, $31
'-'             
'-'             mov     qq,pointer0               	' compute place in the memory from where the sample will be loaded
	byte	$a2, $32, $01, $f6
'-'             shr     qq,#12  			' 20:12 pointer
	byte	$0c, $32, $45, $f0
'-'             add     qq,sstart0            
	byte	$a4, $32, $01, $f1
'-' 
'-'   jmp #p701
	byte	$4c, $00, $90, $fd
'-' 
'-' 
'-' cache_read  getbyte addrlo,qq,#0 		' when this is called, qq is the addres of the sample			
	byte	$99, $ac, $e1, $f8
'-'             
'-' 	    mov     addrhi,qq		
	byte	$99, $ae, $01, $f6
'-' 	    shr     addrhi,#8		        ' get 24 upper bits
	byte	$08, $ae, $45, $f0
'-' 	    alts    cn,#cache1            
	byte	$cb, $6e, $95, $f9
'-' 	    cmp	    addrhi,0-0 wz               ' and compare with the cache pointer for the channel
	byte	$00, $ae, $09, $f2
'-'     if_z    jmp     #p701	    		' if equal, cache hit, read the sample from it
	byte	$34, $00, $90, $ad
'-' 	
'-' p702	    altd    cn,#cache1			' cache miss. 
	byte	$cb, $6e, $8d, $f9
'-' 	    mov     0-0,addrhi                  ' update the pointer
	byte	$d7, $00, $00, $f6
'-' 	    mov     cmd,addrhi			' prepare the mailbox
	byte	$d7, $a6, $01, $f6
'-' 	    shl     cmd,#8
	byte	$08, $a6, $65, $f0
'-'             setnib  cmd, #%1011, #7             ' read burst from the external memory
	byte	$0b, $a6, $3d, $f8
'-'             mov     hubaddr,cn                  ' to the channel cache
	byte	$b7, $a8, $01, $f6
'-'             shl     hubaddr,#8                  '
	byte	$08, $a8, $65, $f0
'-'             add     hubaddr,hubptr 
	byte	$ca, $a8, $01, $f1
'-'             mov     count,#256                  ' 256 bytes
	byte	$00, $ab, $05, $f6
'-'             setq    #2                          ' write 3 longs
	byte	$28, $04, $64, $fd
'-'             wrlong  cmd, mailbox                ' run it
	byte	$9c, $a6, $61, $fc
'-' poll1       rdlong  cmd, mailbox                ' poll mailbox for result
	byte	$9c, $a6, $01, $fb
'-'             tjs     cmd, #poll1                 ' retry until valid 
	byte	$fe, $a7, $b5, $fb
'-'             
'-' 	
'-' p701	    mov     qq,cn			' cache hit
	byte	$b7, $32, $01, $f6
'-' 	    shl     qq,#8			' compute the cache start
	byte	$08, $32, $65, $f0
'-' 	    add     qq,hubptr
	byte	$ca, $32, $01, $f1
'-' 	    add	    qq,addrlo			' add 8 lower bits to the cache addredd
	byte	$d6, $32, $01, $f1
'-'             rdword  spl,qq                      ' read a word
	byte	$99, $34, $e1, $fa
'-'          
'-'             testb   sstart0,#31 wz 
	byte	$1f, $48, $0d, $f4
'-'     if_nz   shl     spl,#8
	byte	$08, $34, $65, $50
'-' 
'-'     if_z    shr     pointer0,#1
	byte	$01, $44, $45, $a0
'-'             testb   sstart0,#28 wz            
	byte	$1c, $48, $0d, $f4
'-'     if_z    shr     pointer0,#1    
	byte	$01, $44, $45, $a0
'-' 	   
'-' 
'-' 
'-' p406        scas    spl,envs1			' apply envelope
	byte	$db, $34, $31, $fa
'-'             mov     spl,0-0
	byte	$00, $34, $01, $f6
'-'             scas    spl,avol0                 	' apply volume
	byte	$b4, $34, $31, $fa
'-'             mov     spl,0-0
	byte	$00, $34, $01, $f6
'-' 
'-'             scas    spl,apan0                 	' apply pan
	byte	$b5, $34, $31, $fa
'-'             mov     ls0,0-0
	byte	$00, $78, $01, $f6
'-'             mov     qq,##16384
	byte	$20, $00, $00, $ff, $00, $32, $05, $f6
'-'             sub     qq,apan0
	byte	$b5, $32, $81, $f1
'-'             scas    spl,qq
	byte	$99, $34, $31, $fa
'-'             mov     rs0, 0-0
	byte	$00, $7a, $01, $f6
'-' 
'-'             sub     rs,oldrs 		      	' replace the old sample with the new one in the mix
	byte	$bb, $7e, $81, $f1
'-'             add     rs,rs0
	byte	$bd, $7e, $01, $f1
'-'             sub     ls,oldls
	byte	$ba, $7c, $81, $f1
'-'             add     ls,ls0
	byte	$bc, $7c, $01, $f1
'-'    
'-'             setword sample0,rs0,#1           	' pack samples into long
	byte	$bd, $46, $29, $f9
'-'             setword sample0,ls0,#0
	byte	$bc, $46, $21, $f9
'-'             
'-'             bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
	byte	$1e, $48, $1d, $f4
'-'     if_z    mov     pointer0, #0  		
	byte	$00, $44, $05, $a6
'-'     if_z    mov     envph0, #0  		' reset also envelope pha and sample value
	byte	$00, $54, $05, $a6
'-'   '  if_z    mov     sample0,#0
'-'     if_z    wrlong  sstart0, ptra[2]          	' reset bit #30 in hub
	byte	$02, $49, $65, $ac
'-'             bitl    sstart0, #29 wcz	      	' if bit #29 is set, synchronize stereo at channels 1 and 2
	byte	$1d, $48, $1d, $f4
'-'     if_z    add     time1,##2048
	byte	$04, $00, $00, $af, $00, $1e, $05, $a1
'-'     if_z    mov     time2,time1
	byte	$8f, $20, $01, $a6
'-'     if_z    wrlong  sstart0,ptra[2]
	byte	$02, $49, $65, $ac
'-' 
'-' p403        setq    #1                         	' write new pointer and sample value to the hub
	byte	$28, $02, $64, $fd
'-'             wrlong  pointer0,ptra
	byte	$00, $45, $65, $fc
'-'             wrlong  envph0,ptra[8]
	byte	$08, $55, $65, $fc
'-'             sub     ptra, channeladd         	' reset the pointer to channel parameters
	byte	$97, $f0, $83, $f1
'-'                       
'-'             getword oldls,ls,#0              ' reuse oldls variable to convert the sample to unsigned
	byte	$be, $74, $31, $f9
'-'  	    getword oldrs,rs,#0              ' getword instead of mov makes the upper bits=0
	byte	$bf, $76, $31, $f9
'-'             bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
	byte	$0f, $74, $e5, $f4
'-'             bitnot  oldrs,#15		     ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
	byte	$0f, $76, $e5, $f4
'-' 		
'-' '	    cmp     scbase,#0 wz
'-' '    if_z    jmp     #p302	   
'-' '  
'-' '            incmod  scope,#63 wc            ' save every 127th sample to the scope buffer
'-' '    if_c    mov     scptr2,scptr
'-' '    if_c    shl     scptr2,#2
'-' '    if_c    add     scptr2,scbase     
'-' '            wrlong  scptr2,#$60
'-' '    if_c    wrlong  oldsample,scptr2
'-' '    if_c    incmod  scptr,##639
'-' 
'-' p302        jmp     #loop            'loop
	byte	$14, $fe, $9f, $fd
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- This is the end of the main loop -----------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' '----------------------------------------------------------------------------------
'-' '------------- PSRAM cache ----------- --------------------------------------------
'-' '----------------------------------------------------------------------------------
'-' 
'-' ' There are 8 cache pointers for 8 channels
'-' ' if 24 higher bits of address=cache, then get a word from the cache
'-' ' else load the cache from PSRAM, update the pointer, then read a sample
'-' 
'-' 
'-' 
'-'           
'-' 
'-' 
'-' 
'-' '---------------------------------------------------------------------------
'-' '------- Variables ---------------------------------------------------------
'-' '---------------------------------------------------------------------------
'-' 
'-' ' constants
'-' 
'-' a40000000   long $40000000
	byte	$00, $00, $00, $40
'-' a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before
	byte	$00, $00, $00, $41
'-' 
'-' ' Time variables
'-' 
'-' time0       long 0    ' Global sample computing time
	byte	$00, $00, $00, $00
'-' time1       long 1    ' Local channels time
	byte	$01, $00, $00, $00
'-' time2       long 2
	byte	$02, $00, $00, $00
'-' time3       long 3
	byte	$03, $00, $00, $00
'-' time4       long 4
	byte	$04, $00, $00, $00
'-' time5       long 5
	byte	$05, $00, $00, $00
'-' time6       long 6
	byte	$06, $00, $00, $00
'-' time7       long 7
	byte	$07, $00, $00, $00
'-' time8       long 8
	byte	$08, $00, $00, $00
'-' 
'-' channeladd long 0
	byte	$00, $00, $00, $00
'-' 
'-' front       long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' temporary variables 
'-' qq          long 0
	byte	$00, $00, $00, $00
'-' spl         long 0
	byte	$00, $00, $00, $00
'-' zero        long 0
	byte	$00, $00, $00, $00
'-' mailbox     long 0
	byte	$00, $00, $00, $00
'-' mailbox2 long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' Interrupt ISR variables
'-' 
'-' lsample     long 0
	byte	$00, $00, $00, $00
'-' rsample     long 0
	byte	$00, $00, $00, $00
'-' lsnext      long 0
	byte	$00, $00, $00, $00
'-' rsnext      long 0 
	byte	$00, $00, $00, $00
'-' 
'-' ' channel parameter block
'-' 
'-' pointer0    long 0     
	byte	$00, $00, $00, $00
'-' sample0     long 0
	byte	$00, $00, $00, $00
'-' sstart0     long 0     ' start pointer and type at bit 31
	byte	$00, $00, $00, $00
'-' lstart0     long 0
	byte	$00, $00, $00, $00
'-' lend0       long 0
	byte	$00, $00, $00, $00
'-' volpan0     long 0
	byte	$00, $00, $00, $00
'-' freq0       long 0
	byte	$00, $00, $00, $00
'-' command0    long 0
	byte	$00, $00, $00, $00
'-' envph0	    long 0
	byte	$00, $00, $00, $00
'-' envptr0	    long 0
	byte	$00, $00, $00, $00
'-' envspd0	    long 0
	byte	$00, $00, $00, $00
'-' envlen0	    long 0
	byte	$00, $00, $00, $00
'-' res5	    long 0
	byte	$00, $00, $00, $00
'-' res6	    long 0
	byte	$00, $00, $00, $00
'-' res7	    long 0
	byte	$00, $00, $00, $00
'-' res8	    long 0
	byte	$00, $00, $00, $00
'-' 
'-' afreq0      long 0
	byte	$00, $00, $00, $00
'-' askip0      long 0
	byte	$00, $00, $00, $00
'-' avol0       long 0
	byte	$00, $00, $00, $00
'-' apan0       long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldt0       long $FFFFFFFF    'Temporary time variables
	byte	$ff, $ff, $ff, $ff
'-' cn          long 0
	byte	$00, $00, $00, $00
'-' ct          long 0
	byte	$00, $00, $00, $00
'-' dt0         long 0
	byte	$00, $00, $00, $00
'-' 
'-' ' Samples
'-' oldls       long 0
	byte	$00, $00, $00, $00
'-' oldrs       long 0
	byte	$00, $00, $00, $00
'-' 
'-' ls0         long 0
	byte	$00, $00, $00, $00
'-' rs0         long 0
	byte	$00, $00, $00, $00
'-' 
'-' ls          long 0    
	byte	$00, $00, $00, $00
'-' rs          long 0
	byte	$00, $00, $00, $00
'-' 
'-' oldsample   long 0
	byte	$00, $00, $00, $00
'-' newsample   long 0
	byte	$00, $00, $00, $00
'-' 
'-' nrsample    long 0
	byte	$00, $00, $00, $00
'-' nlsample    long 0
	byte	$00, $00, $00, $00
'-' 
'-' scbase long 0
	byte	$00, $00, $00, $00
'-' scptr long 0
	byte	$00, $00, $00, $00
'-' scptr2 long 0
	byte	$00, $00, $00, $00
'-' scope long 0
	byte	$00, $00, $00, $00
'-' 
'-' dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
	byte	$44, $00, $17, $00
'-' dac2        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   
	byte	$46, $00, $17, $00
'-' 
'-' hubptr      long $71800
	byte	$00, $18, $07, $00
'-' cache1      long 0
	byte	$00, $00, $00, $00
'-' cache2      long 0
	byte	$00, $00, $00, $00
'-' cache3      long 0
	byte	$00, $00, $00, $00
'-' cache4      long 0
	byte	$00, $00, $00, $00
'-' cache5      long 0
	byte	$00, $00, $00, $00
'-' cache6      long 0
	byte	$00, $00, $00, $00
'-' cache7      long 0
	byte	$00, $00, $00, $00
'-' cache8      long 0
	byte	$00, $00, $00, $00
'-' 
'-' 
'-' cmd         long 0
	byte	$00, $00, $00, $00
'-' hubaddr     long 0
	byte	$00, $00, $00, $00
'-' count       long 256
	byte	$00, $01, $00, $00
'-' addrlo long 0
	byte	$00, $00, $00, $00
'-' addrhi long 0
	byte	$00, $00, $00, $00
'-' pointer00 long 0
	byte	$00, $00, $00, $00
'-' envhi long 0
	byte	$00, $00, $00, $00
'-' envlo long 0
	byte	$00, $00, $00, $00
'-' envs1 long 0
	byte	$00, $00, $00, $00
'-' envs2 long 0
	byte	$00, $00, $00, $00
'-' noise0 long 0
	byte	$00, $00, $00, $00
'-' dropper long %10010010_10010010_10010010_10010010
	byte	$92, $92, $92, $92
'-' null  			long 	0,0           ' for channel reset
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' sinewave 		file 	"sinus.s2"    ' for testing
	byte	$73, $32, $00, $04, $00, $00, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $c9, $00, $92, $01, $5b, $02, $24, $03, $ed, $03, $b6, $04, $7f, $05
	byte	$48, $06, $11, $07, $d9, $07, $a2, $08, $6a, $09, $33, $0a, $fb, $0a, $c4, $0b
	byte	$8c, $0c, $54, $0d, $1c, $0e, $e3, $0e, $ab, $0f, $72, $10, $3a, $11, $01, $12
	byte	$c8, $12, $8f, $13, $55, $14, $1c, $15, $e2, $15, $a8, $16, $6e, $17, $33, $18
	byte	$f9, $18, $be, $19, $82, $1a, $47, $1b, $0b, $1c, $cf, $1c, $93, $1d, $57, $1e
	byte	$1a, $1f, $dd, $1f, $9f, $20, $61, $21, $23, $22, $e5, $22, $a6, $23, $67, $24
	byte	$28, $25, $e8, $25, $a8, $26, $67, $27, $26, $28, $e5, $28, $a3, $29, $61, $2a
	byte	$1f, $2b, $dc, $2b, $99, $2c, $55, $2d, $11, $2e, $cc, $2e, $87, $2f, $41, $30
	byte	$fb, $30, $b5, $31, $6e, $32, $26, $33, $df, $33, $96, $34, $4d, $35, $04, $36
	byte	$ba, $36, $6f, $37, $24, $38, $d9, $38, $8c, $39, $40, $3a, $f2, $3a, $a5, $3b
	byte	$56, $3c, $07, $3d, $b8, $3d, $68, $3e, $17, $3f, $c5, $3f, $73, $40, $21, $41
	byte	$ce, $41, $7a, $42, $25, $43, $d0, $43, $7a, $44, $24, $45, $cd, $45, $75, $46
	byte	$1c, $47, $c3, $47, $69, $48, $0f, $49, $b4, $49, $58, $4a, $fb, $4a, $9d, $4b
	byte	$3f, $4c, $e0, $4c, $81, $4d, $20, $4e, $bf, $4e, $5d, $4f, $fb, $4f, $97, $50
	byte	$33, $51, $ce, $51, $68, $52, $02, $53, $9b, $53, $32, $54, $c9, $54, $60, $55
	byte	$f5, $55, $8a, $56, $1d, $57, $b0, $57, $42, $58, $d3, $58, $64, $59, $f3, $59
	byte	$82, $5a, $0f, $5b, $9c, $5b, $28, $5c, $b3, $5c, $3e, $5d, $c7, $5d, $4f, $5e
	byte	$d7, $5e, $5d, $5f, $e3, $5f, $68, $60, $eb, $60, $6e, $61, $f0, $61, $71, $62
	byte	$f1, $62, $70, $63, $ee, $63, $6c, $64, $e8, $64, $63, $65, $dd, $65, $56, $66
	byte	$cf, $66, $46, $67, $bc, $67, $32, $68, $a6, $68, $19, $69, $8b, $69, $fd, $69
	byte	$6d, $6a, $dc, $6a, $4a, $6b, $b7, $6b, $23, $6c, $8e, $6c, $f8, $6c, $61, $6d
	byte	$c9, $6d, $30, $6e, $96, $6e, $fb, $6e, $5e, $6f, $c1, $6f, $22, $70, $83, $70
	byte	$e2, $70, $40, $71, $9d, $71, $f9, $71, $54, $72, $ae, $72, $07, $73, $5e, $73
	byte	$b5, $73, $0a, $74, $5f, $74, $b2, $74, $04, $75, $55, $75, $a5, $75, $f3, $75
	byte	$41, $76, $8d, $76, $d8, $76, $22, $77, $6b, $77, $b3, $77, $fa, $77, $3f, $78
	byte	$84, $78, $c7, $78, $09, $79, $4a, $79, $89, $79, $c8, $79, $05, $7a, $41, $7a
	byte	$7c, $7a, $b6, $7a, $ee, $7a, $26, $7b, $5c, $7b, $91, $7b, $c5, $7b, $f8, $7b
	byte	$29, $7c, $59, $7c, $88, $7c, $b6, $7c, $e3, $7c, $0e, $7d, $39, $7d, $62, $7d
	byte	$89, $7d, $b0, $7d, $d5, $7d, $fa, $7d, $1d, $7e, $3e, $7e, $5f, $7e, $7e, $7e
	byte	$9c, $7e, $b9, $7e, $d5, $7e, $ef, $7e, $09, $7f, $21, $7f, $37, $7f, $4d, $7f
	byte	$61, $7f, $74, $7f, $86, $7f, $97, $7f, $a6, $7f, $b4, $7f, $c1, $7f, $cd, $7f
	byte	$d8, $7f, $e1, $7f, $e9, $7f, $f0, $7f, $f5, $7f, $f9, $7f, $fd, $7f, $fe, $7f
	byte	$ff, $7f, $fe, $7f, $fd, $7f, $f9, $7f, $f5, $7f, $f0, $7f, $e9, $7f, $e1, $7f
	byte	$d8, $7f, $cd, $7f, $c1, $7f, $b4, $7f, $a6, $7f, $97, $7f, $86, $7f, $74, $7f
	byte	$61, $7f, $4d, $7f, $37, $7f, $21, $7f, $09, $7f, $ef, $7e, $d5, $7e, $b9, $7e
	byte	$9c, $7e, $7e, $7e, $5f, $7e, $3e, $7e, $1d, $7e, $fa, $7d, $d5, $7d, $b0, $7d
	byte	$89, $7d, $62, $7d, $39, $7d, $0e, $7d, $e3, $7c, $b6, $7c, $88, $7c, $59, $7c
	byte	$29, $7c, $f8, $7b, $c5, $7b, $91, $7b, $5c, $7b, $26, $7b, $ee, $7a, $b6, $7a
	byte	$7c, $7a, $41, $7a, $05, $7a, $c8, $79, $89, $79, $4a, $79, $09, $79, $c7, $78
	byte	$84, $78, $3f, $78, $fa, $77, $b3, $77, $6b, $77, $22, $77, $d8, $76, $8d, $76
	byte	$41, $76, $f3, $75, $a5, $75, $55, $75, $04, $75, $b2, $74, $5f, $74, $0a, $74
	byte	$b5, $73, $5e, $73, $07, $73, $ae, $72, $54, $72, $f9, $71, $9d, $71, $40, $71
	byte	$e2, $70, $83, $70, $22, $70, $c1, $6f, $5e, $6f, $fb, $6e, $96, $6e, $30, $6e
	byte	$c9, $6d, $61, $6d, $f8, $6c, $8e, $6c, $23, $6c, $b7, $6b, $4a, $6b, $dc, $6a
	byte	$6d, $6a, $fd, $69, $8b, $69, $19, $69, $a6, $68, $32, $68, $bc, $67, $46, $67
	byte	$cf, $66, $56, $66, $dd, $65, $63, $65, $e8, $64, $6c, $64, $ee, $63, $70, $63
	byte	$f1, $62, $71, $62, $f0, $61, $6e, $61, $eb, $60, $68, $60, $e3, $5f, $5d, $5f
	byte	$d7, $5e, $4f, $5e, $c7, $5d, $3e, $5d, $b3, $5c, $28, $5c, $9c, $5b, $0f, $5b
	byte	$82, $5a, $f3, $59, $64, $59, $d3, $58, $42, $58, $b0, $57, $1d, $57, $8a, $56
	byte	$f5, $55, $60, $55, $c9, $54, $32, $54, $9b, $53, $02, $53, $68, $52, $ce, $51
	byte	$33, $51, $97, $50, $fb, $4f, $5d, $4f, $bf, $4e, $20, $4e, $81, $4d, $e0, $4c
	byte	$3f, $4c, $9d, $4b, $fb, $4a, $58, $4a, $b4, $49, $0f, $49, $69, $48, $c3, $47
	byte	$1c, $47, $75, $46, $cd, $45, $24, $45, $7a, $44, $d0, $43, $25, $43, $7a, $42
	byte	$ce, $41, $21, $41, $73, $40, $c5, $3f, $17, $3f, $68, $3e, $b8, $3d, $07, $3d
	byte	$56, $3c, $a5, $3b, $f2, $3a, $40, $3a, $8c, $39, $d9, $38, $24, $38, $6f, $37
	byte	$ba, $36, $04, $36, $4d, $35, $96, $34, $df, $33, $26, $33, $6e, $32, $b5, $31
	byte	$fb, $30, $41, $30, $87, $2f, $cc, $2e, $11, $2e, $55, $2d, $99, $2c, $dc, $2b
	byte	$1f, $2b, $61, $2a, $a3, $29, $e5, $28, $26, $28, $67, $27, $a8, $26, $e8, $25
	byte	$28, $25, $67, $24, $a6, $23, $e5, $22, $23, $22, $61, $21, $9f, $20, $dd, $1f
	byte	$1a, $1f, $57, $1e, $93, $1d, $cf, $1c, $0b, $1c, $47, $1b, $82, $1a, $be, $19
	byte	$f9, $18, $33, $18, $6e, $17, $a8, $16, $e2, $15, $1c, $15, $55, $14, $8f, $13
	byte	$c8, $12, $01, $12, $3a, $11, $72, $10, $ab, $0f, $e3, $0e, $1c, $0e, $54, $0d
	byte	$8c, $0c, $c4, $0b, $fb, $0a, $33, $0a, $6a, $09, $a2, $08, $d9, $07, $11, $07
	byte	$48, $06, $7f, $05, $b6, $04, $ed, $03, $24, $03, $5b, $02, $92, $01, $c9, $00
	byte	$00, $00, $37, $ff, $6e, $fe, $a5, $fd, $dc, $fc, $13, $fc, $4a, $fb, $81, $fa
	byte	$b8, $f9, $ef, $f8, $27, $f8, $5e, $f7, $96, $f6, $cd, $f5, $05, $f5, $3c, $f4
	byte	$74, $f3, $ac, $f2, $e4, $f1, $1d, $f1, $55, $f0, $8e, $ef, $c6, $ee, $ff, $ed
	byte	$38, $ed, $71, $ec, $ab, $eb, $e4, $ea, $1e, $ea, $58, $e9, $92, $e8, $cd, $e7
	byte	$07, $e7, $42, $e6, $7e, $e5, $b9, $e4, $f5, $e3, $31, $e3, $6d, $e2, $a9, $e1
	byte	$e6, $e0, $23, $e0, $61, $df, $9f, $de, $dd, $dd, $1b, $dd, $5a, $dc, $99, $db
	byte	$d8, $da, $18, $da, $58, $d9, $99, $d8, $da, $d7, $1b, $d7, $5d, $d6, $9f, $d5
	byte	$e1, $d4, $24, $d4, $67, $d3, $ab, $d2, $ef, $d1, $34, $d1, $79, $d0, $bf, $cf
	byte	$05, $cf, $4b, $ce, $92, $cd, $da, $cc, $21, $cc, $6a, $cb, $b3, $ca, $fc, $c9
	byte	$46, $c9, $91, $c8, $dc, $c7, $27, $c7, $74, $c6, $c0, $c5, $0e, $c5, $5b, $c4
	byte	$aa, $c3, $f9, $c2, $48, $c2, $98, $c1, $e9, $c0, $3b, $c0, $8d, $bf, $df, $be
	byte	$32, $be, $86, $bd, $db, $bc, $30, $bc, $86, $bb, $dc, $ba, $33, $ba, $8b, $b9
	byte	$e4, $b8, $3d, $b8, $97, $b7, $f1, $b6, $4c, $b6, $a8, $b5, $05, $b5, $63, $b4
	byte	$c1, $b3, $20, $b3, $7f, $b2, $e0, $b1, $41, $b1, $a3, $b0, $05, $b0, $69, $af
	byte	$cd, $ae, $32, $ae, $98, $ad, $fe, $ac, $65, $ac, $ce, $ab, $37, $ab, $a0, $aa
	byte	$0b, $aa, $76, $a9, $e3, $a8, $50, $a8, $be, $a7, $2d, $a7, $9c, $a6, $0d, $a6
	byte	$7e, $a5, $f1, $a4, $64, $a4, $d8, $a3, $4d, $a3, $c2, $a2, $39, $a2, $b1, $a1
	byte	$29, $a1, $a3, $a0, $1d, $a0, $98, $9f, $15, $9f, $92, $9e, $10, $9e, $8f, $9d
	byte	$0f, $9d, $90, $9c, $12, $9c, $94, $9b, $18, $9b, $9d, $9a, $23, $9a, $aa, $99
	byte	$31, $99, $ba, $98, $44, $98, $ce, $97, $5a, $97, $e7, $96, $75, $96, $03, $96
	byte	$93, $95, $24, $95, $b6, $94, $49, $94, $dd, $93, $72, $93, $08, $93, $9f, $92
	byte	$37, $92, $d0, $91, $6a, $91, $05, $91, $a2, $90, $3f, $90, $de, $8f, $7d, $8f
	byte	$1e, $8f, $c0, $8e, $63, $8e, $07, $8e, $ac, $8d, $52, $8d, $f9, $8c, $a2, $8c
	byte	$4b, $8c, $f6, $8b, $a1, $8b, $4e, $8b, $fc, $8a, $ab, $8a, $5b, $8a, $0d, $8a
	byte	$bf, $89, $73, $89, $28, $89, $de, $88, $95, $88, $4d, $88, $06, $88, $c1, $87
	byte	$7c, $87, $39, $87, $f7, $86, $b6, $86, $77, $86, $38, $86, $fb, $85, $bf, $85
	byte	$84, $85, $4a, $85, $12, $85, $da, $84, $a4, $84, $6f, $84, $3b, $84, $08, $84
	byte	$d7, $83, $a7, $83, $78, $83, $4a, $83, $1d, $83, $f2, $82, $c7, $82, $9e, $82
	byte	$77, $82, $50, $82, $2b, $82, $06, $82, $e3, $81, $c2, $81, $a1, $81, $82, $81
	byte	$64, $81, $47, $81, $2b, $81, $11, $81, $f7, $80, $df, $80, $c9, $80, $b3, $80
	byte	$9f, $80, $8c, $80, $7a, $80, $69, $80, $5a, $80, $4c, $80, $3f, $80, $33, $80
	byte	$28, $80, $1f, $80, $17, $80, $10, $80, $0b, $80, $07, $80, $03, $80, $02, $80
	byte	$01, $80, $02, $80, $03, $80, $07, $80, $0b, $80, $10, $80, $17, $80, $1f, $80
	byte	$28, $80, $33, $80, $3f, $80, $4c, $80, $5a, $80, $69, $80, $7a, $80, $8c, $80
	byte	$9f, $80, $b3, $80, $c9, $80, $df, $80, $f7, $80, $11, $81, $2b, $81, $47, $81
	byte	$64, $81, $82, $81, $a1, $81, $c2, $81, $e3, $81, $06, $82, $2b, $82, $50, $82
	byte	$77, $82, $9e, $82, $c7, $82, $f2, $82, $1d, $83, $4a, $83, $78, $83, $a7, $83
	byte	$d7, $83, $08, $84, $3b, $84, $6f, $84, $a4, $84, $da, $84, $12, $85, $4a, $85
	byte	$84, $85, $bf, $85, $fb, $85, $38, $86, $77, $86, $b6, $86, $f7, $86, $39, $87
	byte	$7c, $87, $c1, $87, $06, $88, $4d, $88, $95, $88, $de, $88, $28, $89, $73, $89
	byte	$bf, $89, $0d, $8a, $5b, $8a, $ab, $8a, $fc, $8a, $4e, $8b, $a1, $8b, $f6, $8b
	byte	$4b, $8c, $a2, $8c, $f9, $8c, $52, $8d, $ac, $8d, $07, $8e, $63, $8e, $c0, $8e
	byte	$1e, $8f, $7d, $8f, $de, $8f, $3f, $90, $a2, $90, $05, $91, $6a, $91, $d0, $91
	byte	$37, $92, $9f, $92, $08, $93, $72, $93, $dd, $93, $49, $94, $b6, $94, $24, $95
	byte	$93, $95, $03, $96, $75, $96, $e7, $96, $5a, $97, $ce, $97, $44, $98, $ba, $98
	byte	$31, $99, $aa, $99, $23, $9a, $9d, $9a, $18, $9b, $94, $9b, $12, $9c, $90, $9c
	byte	$0f, $9d, $8f, $9d, $10, $9e, $92, $9e, $15, $9f, $98, $9f, $1d, $a0, $a3, $a0
	byte	$29, $a1, $b1, $a1, $39, $a2, $c2, $a2, $4d, $a3, $d8, $a3, $64, $a4, $f1, $a4
	byte	$7e, $a5, $0d, $a6, $9c, $a6, $2d, $a7, $be, $a7, $50, $a8, $e3, $a8, $76, $a9
	byte	$0b, $aa, $a0, $aa, $37, $ab, $ce, $ab, $65, $ac, $fe, $ac, $98, $ad, $32, $ae
	byte	$cd, $ae, $69, $af, $05, $b0, $a3, $b0, $41, $b1, $e0, $b1, $7f, $b2, $20, $b3
	byte	$c1, $b3, $63, $b4, $05, $b5, $a8, $b5, $4c, $b6, $f1, $b6, $97, $b7, $3d, $b8
	byte	$e4, $b8, $8b, $b9, $33, $ba, $dc, $ba, $86, $bb, $30, $bc, $db, $bc, $86, $bd
	byte	$32, $be, $df, $be, $8d, $bf, $3b, $c0, $e9, $c0, $98, $c1, $48, $c2, $f9, $c2
	byte	$aa, $c3, $5b, $c4, $0e, $c5, $c0, $c5, $74, $c6, $27, $c7, $dc, $c7, $91, $c8
	byte	$46, $c9, $fc, $c9, $b3, $ca, $6a, $cb, $21, $cc, $da, $cc, $92, $cd, $4b, $ce
	byte	$05, $cf, $bf, $cf, $79, $d0, $34, $d1, $ef, $d1, $ab, $d2, $67, $d3, $24, $d4
	byte	$e1, $d4, $9f, $d5, $5d, $d6, $1b, $d7, $da, $d7, $99, $d8, $58, $d9, $18, $da
	byte	$d8, $da, $99, $db, $5a, $dc, $1b, $dd, $dd, $dd, $9f, $de, $61, $df, $23, $e0
	byte	$e6, $e0, $a9, $e1, $6d, $e2, $31, $e3, $f5, $e3, $b9, $e4, $7e, $e5, $42, $e6
	byte	$07, $e7, $cd, $e7, $92, $e8, $58, $e9, $1e, $ea, $e4, $ea, $ab, $eb, $71, $ec
	byte	$38, $ed, $ff, $ed, $c6, $ee, $8e, $ef, $55, $f0, $1d, $f1, $e4, $f1, $ac, $f2
	byte	$74, $f3, $3c, $f4, $05, $f5, $cd, $f5, $96, $f6, $5e, $f7, $27, $f8, $ef, $f8
	byte	$b8, $f9, $81, $fa, $4a, $fb, $13, $fc, $dc, $fc, $a5, $fd, $6e, $fe, $37, $ff
	alignl
_psram_spin2_dat_
'-'     listdata long 0[8*8]
	byte	$00[256]
'-'             orgh
'-' 
'-' ' driver state
'-' drivercog   long    -1  ' COG id of driver
	byte	$ff, $ff, $ff, $ff
'-' driverlock  long    -1  ' LOCK id of driver
	byte	$ff, $ff, $ff, $ff
'-' 
'-' ' delay profile
'-' delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
	byte	$07, $00, $00, $00, $00, $cf, $7b, $05, $80, $d1, $f0, $08, $80, $4f, $47, $0c
	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
'-' 
'-' ' data to be passed to driver when starting it
'-' startupData
'-'     long    0           ' current frequency
	byte	$00, $00, $00, $00
'-'     long    FLAGS       ' optional flags for driver
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port A for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port B for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    DATABUS     ' PSRAM data bus start pin
	byte	$28, $00, $00, $00
'-'     long    deviceData  ' address of devices data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 328
'-'     long    qosData     ' address of QoS data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 456
'-'     long    mailboxes   ' address of mailbox structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 488
'-' 
'-' ' data for memory
'-' deviceData
'-'     ' 16 bank parameters follow (16MB per bank)
'-'     long    0[16]                               ' banks 0-15
	byte	$00[64]
'-'     ' 16 banks of pin parameters follow
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
	byte	$39, $38, $00, $00
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
	byte	$39, $38, $00, $00
'-'     long    -1[14]                              ' banks 2-15
	byte	$ff[56]
'-' 
'-' ' data for COG polling
'-' qosData 
'-'     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
'-'     
'-' ' mailbox storage
'-' 
'-' mailboxes
'-'     long    0[8*3]          ' 3 longs per mailbox per COG
	byte	$00[96]
	alignl
_psram16drv_spin2_dat_
'-'                             orgh
'-' scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
	byte	$00[32]
'-' 
'-' driver_start
'-'                             org
'-' '..................................................................................................
'-' ' Memory layout for COG RAM once operational:
'-' '
'-' '  COG RAM address      Usage
'-' '  ---------------      ----
'-' '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
'-' '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
'-' '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
'-' '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
'-' '   $100-$197           Mailbox poller, error handlers, and all driver management code
'-' '  ~$198-$1F3           State and register variables
'-' '
'-' ' Also during driver COG startup:
'-' '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
'-' ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
'-' '..................................................................................................
'-'                             
'-' ' Mailbox storage after vector initialization
'-' 
'-' req0                        call    #init                   'do HW setup/initialization
	byte	$fc, $01, $b0, $fd
'-' data0                       rdlut   c, b wz                 'read bank info          
	byte	$f0, $e3, $ab, $fa
'-' count0                      mov     a, b                    'set COGRAM address low nibble
	byte	$f0, $df, $03, $f6
'-' req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
	byte	$68, $f0, $07, $a6
'-' data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
	byte	$0a, $e2, $17, $f4
'-' count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
	byte	$50, $f0, $07, $16
'-' req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
	byte	$58, $f0, $07, $46
'-' data2                       mov     c, #$8                  'setup vector base to $80
	byte	$08, $e2, $07, $f6
'-' count2                      setnib  a, c, #1                'prepare vector base address for bank
	byte	$f1, $df, $0b, $f8
'-' req3                        altd    a, #0                   'prepare COG destination read address
	byte	$00, $de, $8f, $f9
'-' data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
	byte	$61, $01, $a4, $fa
'-' count3                      incmod  c, #15 wz               'next vector
	byte	$0f, $e2, $0f, $f7
'-' req4        if_nz           jmp     #count2                 'repeat
	byte	$ec, $ff, $9f, $5d
'-' data4                       incmod  b, #15 wz               'next bank
	byte	$0f, $e0, $0f, $f7
'-' count4      if_nz           jmp     #data0                  'repeat
	byte	$c8, $ff, $9f, $5d
'-' req5                        mov     ptra, #$20              'setup base LUT address to clear
	byte	$20, $f0, $07, $f6
'-' data5                       rep     #5, #80                 'update next 80 longs      
	byte	$50, $0a, $dc, $fc
'-' count5                      cmp     ptra, header wc         'check if LUT address range 
	byte	$e2, $f1, $13, $f2
'-' req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
	byte	$e3, $f1, $93, $32
'-' data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
	byte	$61, $01, $3c, $cc
'-' count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
	byte	$61, $b1, $37, $3c
'-' req7        if_nc           add     $-1, const512           'increment source of LUT write data
	byte	$a5, $29, $00, $31
'-' data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
	byte	$ff, $c0, $03, $f6
'-' count7      _ret_           mov     255, #dolist            'setup list address, return to notify
	byte	$26, $ff, $05, $06
'-' 
'-' ' Mailbox parameter addresses per COG once patched
'-'                             
'-' cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
	byte	$04, $00, $00, $00
'-' cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
	byte	$10, $00, $00, $00
'-' cog2mboxdata                long    2*12+4                  '...
	byte	$1c, $00, $00, $00
'-' cog3mboxdata                long    3*12+4
	byte	$28, $00, $00, $00
'-' cog4mboxdata                long    4*12+4
	byte	$34, $00, $00, $00
'-' cog5mboxdata                long    5*12+4
	byte	$40, $00, $00, $00
'-' cog6mboxdata                long    6*12+4
	byte	$4c, $00, $00, $00
'-' cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
	byte	$58, $00, $00, $00
'-' 
'-' '..................................................................................................
'-' ' Per COG request and state setup and service branching
'-'         
'-' cog0                 
'-'                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
	byte	$20, $f0, $07, $f6
'-'                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
	byte	$18, $f2, $03, $f6
'-'                             mov     id, id0                 'get COG0 state
	byte	$d0, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG0 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$30, $04, $90, $5d
'-'                             mov     addr1, req0             'get mailbox request parameter for COG0
	byte	$00, $b0, $03, $f6
'-'                             mov     hubdata, data0          'get COG0 mailbox data parameter
	byte	$01, $b2, $03, $f6
'-'                             mov     count, count0           'get COG0 mailbox count parameter
	byte	$02, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog1                        
'-'                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
	byte	$2a, $f0, $07, $f6
'-'                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
	byte	$19, $f2, $03, $f6
'-'                             mov     id, id1                 'get COG1 state
	byte	$d1, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG1 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$00, $04, $90, $5d
'-'                             mov     addr1, req1             'get mailbox request parameter for COG1
	byte	$03, $b0, $03, $f6
'-'                             mov     hubdata, data1          'get COG1 mailbox data parameter
	byte	$04, $b2, $03, $f6
'-'                             mov     count, count1           'get COG1 mailbox count parameter
	byte	$05, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog2                         
'-'                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
	byte	$34, $f0, $07, $f6
'-'                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
	byte	$1a, $f2, $03, $f6
'-'                             mov     id, id2                 'get COG2 state
	byte	$d2, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG2 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$d0, $03, $90, $5d
'-'                             mov     addr1, req2             'get mailbox request parameter for COG2
	byte	$06, $b0, $03, $f6
'-'                             mov     hubdata, data2          'get COG2 mailbox data parameter
	byte	$07, $b2, $03, $f6
'-'                             mov     count, count2           'get COG2 mailbox count parameter
	byte	$08, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog3                        
'-'                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
	byte	$3e, $f0, $07, $f6
'-'                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
	byte	$1b, $f2, $03, $f6
'-'                             mov     id, id3                 'get COG3 state
	byte	$d3, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG3 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$a0, $03, $90, $5d
'-'                             mov     addr1, req3             'get mailbox request parameter for COG3
	byte	$09, $b0, $03, $f6
'-'                             mov     hubdata, data3          'get COG3 mailbox data parameter
	byte	$0a, $b2, $03, $f6
'-'                             mov     count, count3           'get COG3 mailbox count parameter
	byte	$0b, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog4                        
'-'                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
	byte	$48, $f0, $07, $f6
'-'                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
	byte	$1c, $f2, $03, $f6
'-'                             mov     id, id4                 'get COG4 state
	byte	$d4, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG4 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$70, $03, $90, $5d
'-'                             mov     addr1, req4             'get mailbox request parameter for COG4
	byte	$0c, $b0, $03, $f6
'-'                             mov     hubdata, data4          'get COG4 mailbox data parameter
	byte	$0d, $b2, $03, $f6
'-'                             mov     count, count4           'get COG4 mailbox count parameter
	byte	$0e, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog5                        
'-'                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
	byte	$52, $f0, $07, $f6
'-'                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
	byte	$1d, $f2, $03, $f6
'-'                             mov     id, id5                 'get COG5 state
	byte	$d5, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG5 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$40, $03, $90, $5d
'-'                             mov     addr1, req5             'get mailbox request parameter for COG5
	byte	$0f, $b0, $03, $f6
'-'                             mov     hubdata, data5          'get COG5 mailbox data parameter
	byte	$10, $b2, $03, $f6
'-'                             mov     count, count5           'get COG5 mailbox count parameter
	byte	$11, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog6                        
'-'                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
	byte	$5c, $f0, $07, $f6
'-'                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
	byte	$1e, $f2, $03, $f6
'-'                             mov     id, id6                 'get COG6 state
	byte	$d6, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG6 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$10, $03, $90, $5d
'-'                             mov     addr1, req6             'get mailbox request parameter for COG6
	byte	$12, $b0, $03, $f6
'-'                             mov     hubdata, data6          'get COG6 mailbox data parameter
	byte	$13, $b2, $03, $f6
'-'                             mov     count, count6           'get COG6 mailbox count parameter
	byte	$14, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog7                        
'-'                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
	byte	$66, $f0, $07, $f6
'-'                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
	byte	$1f, $f2, $03, $f6
'-'                             mov     id, id7                 'get COG7 state
	byte	$d7, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG7 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$e0, $02, $90, $5d
'-'                             mov     addr1, req7             'get mailbox request parameter for COG7
	byte	$15, $b0, $03, $f6
'-'                             mov     hubdata, data7          'get COG7 mailbox data parameter
	byte	$16, $b2, $03, $f6
'-'                             mov     count, count7           'get COG7 mailbox count parameter
	byte	$17, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-'                             fit     128
'-' 
'-'                             fit     128
'-' pad                         long    0[128-$]                'align init code to $80
'-' 
'-' '..................................................................................................
'-' 
'-' ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
'-' 
'-' init                        
'-'                             ' get driver scratch long address in hub
'-'                             cogid   hubscratch              'get cogid
	byte	$01, $da, $63, $fd
'-'                             add     hubscratch, #1          'increase by 1 from 1-8
	byte	$01, $da, $07, $f1
'-'                             mul     hubscratch, #4          'multiply by 4 to get 4-32
	byte	$04, $da, $07, $fa
'-'                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
	byte	$f9, $db, $c3, $f2
'-'                     
'-'                             ' read in the additional LUT RAM code
'-'                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
	byte	$f9, $41, $03, $f1
'-'                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
	byte	$29, $9e, $67, $fd
'-'                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
	byte	$a0, $61, $00, $fb
'-' 
'-'                             ' read the startup parameters
'-'                             setq    #8-1                    'read 8 longs from hub
	byte	$28, $0e, $64, $fd
'-'                             rdlong  startupparams, ptra     '.. as the startup parameters 
	byte	$00, $41, $07, $fb
'-' 
'-'                             ' setup some of the config flag dependent state and patch LUTRAM
'-'                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
	byte	$1c, $42, $0f, $f4
'-' 
'-'             if_z            add     expansion, ptrb         'compensate for HUB address
	byte	$f9, $71, $03, $a1
'-'             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
	byte	$01, $00, $00, $5f, $fb, $70, $07, $56
'-'                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
	byte	$1d, $42, $17, $f4
'-'             if_nc           or      clkconfig, registered   'enable this if so
	byte	$aa, $57, $43, $35
'-'             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
	byte	$00, $58, $07, $36
'-' 
'-'                             ' setup data pin modes and data bus pin group in streamer commands
'-'                             and     datapins, #%111000      'compute base pin
	byte	$38, $48, $07, $f5
'-'                             or      datapins, ##(15<<6)     'configure 16 pins total
	byte	$01, $00, $00, $ff, $c0, $49, $47, $f5
'-'                             mov     a, datapins             'get data pin base
	byte	$a4, $df, $03, $f6
'-'                             wrpin   registered, datapins    'prepare data pins for address phase transfer
	byte	$a4, $55, $03, $fc
'-'                             shr     a, #3                   'determine data pin group
	byte	$03, $de, $47, $f0
'-'                             and     a, #7                   'ignore the unwanted bits
	byte	$07, $de, $07, $f5
'-'                             or      a, #8
	byte	$08, $de, $47, $f5
'-'                             setnib  ximm8lut, a, #5         'setup bus group in streamer
	byte	$ef, $2f, $2b, $f8
'-'                             setnib  xrecvlo8, a, #5
	byte	$ef, $31, $2b, $f8
'-'                             setnib  xrecvdata, a, #5
	byte	$ef, $35, $2b, $f8
'-'                             setnib  xsenddata, a, #5
	byte	$ef, $37, $2b, $f8
'-'                             setnib  xsendimm, a, #5
	byte	$ef, $39, $2b, $f8
'-'                             add     a, #1
	byte	$01, $de, $07, $f1
'-'                             setnib  xrecvhi8, a, #5         ' increase port by one
	byte	$ef, $33, $2b, $f8
'-'  
'-'                             ' setup device control pin states
'-'                             setq2   #32-1                   'read 32 longs to LUTRAM
	byte	$29, $3e, $64, $fd
'-'                             rdlong  $000, devicelist        'read bank/pin data for all banks    
	byte	$a5, $01, $00, $fb
'-'                             mov     const512, ##512         'prepare constant
	byte	$01, $00, $00, $ff, $00, $4a, $07, $f6
'-' 
'-'                             mov     ptrb, #16               'point to bank pin config data
	byte	$10, $f2, $07, $f6
'-'                             rep     @pinloop, #16           'iterate through 16 banks
	byte	$10, $14, $dc, $fc
'-'                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
	byte	$e1, $cf, $b7, $fa
'-'                             and     pinconfig, pinmask      'save us from invalid bits in args
	byte	$af, $cf, $03, $f5
'-'             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
	byte	$e7, $53, $e3, $38
'-'             if_nc           wrpin   #0, cspin               'clear smart pin mode
	byte	$a9, $01, $08, $3c
'-'             if_nc           drvh    cspin                   'setup pins for all banks
	byte	$59, $52, $63, $3d
'-'             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
	byte	$e7, $51, $eb, $38
'-'             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
	byte	$50, $50, $63, $3d
'-'             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
	byte	$a8, $57, $03, $3c
'-'             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
	byte	$a8, $03, $18, $3c
'-'             if_nc           drvl    clkpin                  'set clk state low
	byte	$58, $50, $63, $3d
'-' pinloop
'-'                             ' generate minimum CE high time before access
'-'                             qdiv    frequency, ##1000000    'convert from Hz to MHz
	byte	$a1, $07, $00, $ff, $40, $40, $17, $fd
'-'                             getqx   c                       'get P2 clocks per microsecond
	byte	$18, $e2, $63, $fd
'-'                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
	byte	$96, $de, $07, $f6
'-'                             mul     a, c                    'convert microseconds to clocks
	byte	$f1, $df, $03, $fa
'-'                             waitx   a                       'delay
	byte	$1f, $de, $63, $fd
'-'                             call    #hwinit                 'setup HW into QSPI mode
	byte	$e8, $05, $b0, $fd
'-' 
'-'                             ' setup the COG mailboxes and addresses 
'-'                             rep     #2, #8                  'setup loop to patch mailbox addresses
	byte	$08, $04, $dc, $fc
'-'                             alti    $+1, #%111_000          'increase D field
	byte	$38, $70, $a5, $f9
'-'                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
	byte	$a7, $31, $00, $f1
'-' 
'-'                             setq    #24-1
	byte	$28, $2e, $64, $fd
'-'                             wrlong  #0, mbox                'clear out mailboxes ????
	byte	$a7, $01, $68, $fc
'-' 
'-'                             ' setup the polling loop for active COGs 
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             alts    id, #id0                'determine id register of control COG
	byte	$d0, $c3, $97, $f9
'-'                             setd    patchid, #0             'patch into destination address
	byte	$00, $90, $b6, $f9
'-'                             push    ptra                    'save ptra before we lose it
	byte	$2a, $f0, $63, $fd
'-'                             mov     ptra, #10
	byte	$0a, $f0, $07, $f6
'-'                             mul     ptra, id
	byte	$e1, $f1, $03, $fa
'-'                             add     ptra, #$20              'prep ptra for reloadcogs
	byte	$20, $f0, $07, $f1
'-'                             alts    id, #cog0_handler       'add to handler base
	byte	$b0, $c3, $97, $f9
'-'                             sets    ctrlpollinst, #0-0      'patch into jump instruction
	byte	$00, $48, $be, $f9
'-'                             mul     id, #3
	byte	$03, $c2, $07, $fa
'-'                             setd    ctrlpollinst, id
	byte	$e1, $49, $b2, $f9
'-'                             rdlut   id, ptra[9]             'save original value
	byte	$09, $c3, $a7, $fa
'-'                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
	byte	$09, $c1, $37, $fc
'-'                             call    #reloadcogs
	byte	$d8, $01, $b0, $fd
'-'                             wrlut   id, ptra[9]             'restore original value
	byte	$09, $c3, $37, $fc
'-'                             pop     ptra                    'restore original ptra
	byte	$2b, $f0, $63, $fd
'-'                             ' move LUT control vectors into temporary location to avoid clobbering them later
'-'                             setd    d, #addr1
	byte	$d8, $e5, $b7, $f9
'-'                             sets    d, #(ctrl_vect & $1ff)
	byte	$60, $e4, $bf, $f9
'-'                             rep     #2, #8
	byte	$08, $04, $dc, $fc
'-'                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
	byte	$3f, $e4, $a7, $f9
'-'                             rdlut   addr1-0, #$60-0
	byte	$60, $b0, $a7, $fa
'-' 
'-'                             'setup control COG service handling, we need to patch 5 instructions
'-'                             'one existing instruction is moved earlier and four instructions get replaced
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             mov     a, #(cog1-cog0)         'get code separation of handlers
	byte	$0c, $de, $07, $f6
'-'                             mul     a, id                   'scale ID by separation
	byte	$e1, $df, $03, $fa
'-'                             add     a, #cog0+4              'add to base for COG0 and offset
	byte	$24, $de, $07, $f1
'-'                             setd    d, a                    'set this as the destination
	byte	$ef, $e5, $b3, $f9
'-'                             add     a, #2                   'increment COG address
	byte	$02, $de, $07, $f1
'-'                             sets    d, a                    'set this as the source
	byte	$ef, $e5, $bb, $f9
'-'                             alti    d, #%111_100             
	byte	$3c, $e4, $a7, $f9
'-'                             mov     0-0, 0-0                'move instruction
	byte	$00, $00, $00, $f6
'-'                             sets    d, #controlpatch        'set source of patched instructions
	byte	$ee, $e4, $bf, $f9
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             add     d, const512             'skip two instructions
	byte	$a5, $e5, $03, $f1
'-'                             add     d, const512
	byte	$a5, $e5, $03, $f1
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             
'-'                             ' setup register values for control vector loop setup after we return
'-'                             mov     header, id              'get cog ID
	byte	$e1, $c5, $03, $f6
'-'                             mul     header, #10             'multiply by size of state memory per COG
	byte	$0a, $c4, $07, $fa
'-'                             add     header, #$20            'add to COG state base address in LUT
	byte	$20, $c4, $07, $f1
'-'                             mov     trailer, header         'determine start/end LUT address
	byte	$e2, $c7, $03, $f6
'-'                             add     trailer, #9             '...for control region
	byte	$09, $c6, $07, $f1
'-'                             or      id, initctrl            'set id field for control COG
	byte	$e0, $c3, $43, $f5
'-'                             altd    id, #id0
	byte	$d0, $c3, $8f, $f9
'-'                             mov     0-0, id                 'setup id field for notification
	byte	$e1, $01, $00, $f6
'-'                             mov     ptrb, ptra              'get startup parameter address
	byte	$f8, $f3, $03, $f6
'-'                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
	byte	$04, $f2, $07, $f1
'-'                             mov     b, #0                   'prepare b for upcoming loop
	byte	$00, $e0, $07, $f6
'-'                 _ret_       push    #notify                 'continue init in mailbox area
	byte	$2a, $14, $66, $0d
'-'  
'-' controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
	byte	$d8, $cb, $7b, $f8
'-'                             and     request, #7
	byte	$07, $ca, $07, $f5
'-'                             add     request, ptra           'add request vector offset
	byte	$f8, $cb, $03, $f1
'-'                             rdlut   request, request        'lookup jump vector service table 
	byte	$e5, $cb, $a3, $fa
'-'                             fit     $100                    'ensure all init code fits this space
'-' 
'-'                             fit     $100                    'ensure all init code fits this space
'-' 
'-'                             long    0[$100-$]               'pad more if required until table ends
	byte	$00[56]
'-' 
'-' '..................................................................................................
'-' ' Error result handling and COG notification of request completion
'-' 
'-' unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
	byte	$04, $04, $4c, $fb
'-' invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
	byte	$03, $02, $4c, $fb
'-' invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
	byte	$02, $06, $4c, $fb
'-' alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
	byte	$01, $08, $4c, $fb
'-' busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
	byte	$05, $ec, $07, $f6
'-' err                         altd    id, #id0                'adjust for the running COG
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
	byte	$09, $00, $04, $f4
'-'                             wrlut   #0, ptra[8]             'cancel any resume state
	byte	$08, $01, $3c, $fc
'-'                             skipf   #%10                    'dont notify with success code 0 below
	byte	$32, $04, $64, $fd
'-'                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
	byte	$bf, $ed, $67, $fc
'-' notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
	byte	$bf, $01, $6c, $fc
'-'                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
	byte	$0b, $c2, $0f, $f4
'-'                             decod   a, id                   'convert COG ID to bitmask
	byte	$e1, $df, $c3, $f9
'-'             if_z            cogatn  a                       'notify COG via ATN
	byte	$3f, $de, $63, $ad
'-' ' Poller re-starts here after a COG is serviced
'-' poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
	byte	$0f, $c2, $0f, $f4
'-'             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
	byte	$e6, $5f, $03, $57
'-'                             bmask   mask, rrcounter         'generate a RR skip mask from the count
	byte	$af, $45, $cb, $f9
'-' ' Main dynamic polling loop repeats until a request arrives
'-' polling_loop                rep     #0-0, #0                'repeat until we get a request for something
	byte	$00, $00, $dc, $fc
'-'                             setq    #24-1                   'read 24 longs
	byte	$28, $2e, $64, $fd
'-'                             rdlong  req0, mbox              'get all mailbox requests and data longs
	byte	$a7, $01, $00, $fb
'-' 
'-' polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
	byte	$b0, $01, $b0, $fb
'-'                             skipf   mask                    ']after all priority COG handlers if present
	byte	$32, $44, $63, $fd
'-'                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']based on the active COGs being polled
	byte	$b6, $25, $b0, $fb
'-'                             tjs     req7, cog7_handler      ']and whether priority or round robin.
	byte	$b7, $2b, $b0, $fb
'-'                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']have changed.
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
	byte	$b6, $25, $b0, $fb
'-' pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
	byte	$b7, $2b, $b0, $fb
'-' 
'-' ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
	byte	$b0, $01, $b0, $fb
'-' skipfinst                   skipf   mask                    'instruction template for skipf
	byte	$32, $44, $63, $fd
'-'  
'-' '..................................................................................................
'-' ' List handler                               
'-' 
'-' dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
	byte	$01, $b0, $a7, $fb
'-'                             execf   burstwrite              'otherwise do a burst write to this bank
	byte	$33, $c0, $63, $fd
'-' real_list                   setq    #8-1                    'read 8 longs (largest request size)
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, hubdata          '..to update the request state
	byte	$d9, $b1, $03, $fb
'-'                             tjns    addr1, #invalidlist     'error if request list item not valid
	byte	$d7, $b1, $bf, $fb
'-'                             altd    id, #id0                'get COG state
	byte	$d0, $c3, $8f, $f9
'-'                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
	byte	$09, $00, $3c, $f4
'-'                             bith    id, #LIST_BIT           'retain fact that we are in a list
	byte	$09, $c2, $27, $f4
'-'             if_z            jmp     #unsupported            'no list recursion is allowed!
	byte	$44, $ff, $9f, $ad
'-'                             getbyte request, addr1, #3      'get upper byte of this request
	byte	$d8, $cb, $fb, $f8
'-' service_request             altd    request, #0             'get request address in COG RAM
	byte	$00, $ca, $8f, $f9
'-'                             execf   0-0                     'process the request 
	byte	$33, $00, $60, $fd
'-' 
'-' '..................................................................................................
'-' ' Restoring per COG state and resuming where we left off
'-' 
'-' restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
	byte	$00, $b1, $a7, $fa
'-'                             rdlut   hubdata, ptra[1]
	byte	$01, $b3, $a7, $fa
'-'                             rdlut   count, ptra[2]
	byte	$02, $b5, $a7, $fa
'-'                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
	byte	$03, $b7, $b7, $fa
'-'                             getbyte request, addr1, #3
	byte	$d8, $cb, $fb, $f8
'-'             if_nc           execf   resume                  'if not extended then resume immediately
	byte	$33, $d2, $63, $3d
'-'                             rdlut   total, ptra[4]          'we need to read the extended parameters
	byte	$04, $b9, $a7, $fa
'-'                             rdlut   offset1, ptra[5]
	byte	$05, $bb, $a7, $fa
'-'                             rdlut   offset2, ptra[6]
	byte	$06, $bd, $a7, $fa
'-'                             rdlut   link, ptra[7]
	byte	$07, $bf, $a7, $fa
'-'                             rdlut   orighubsize, ptra[9]
	byte	$09, $d5, $a7, $fa
'-'                             execf   resume                  'then resume what we were doing last time
	byte	$33, $d2, $63, $fd
'-'                    
'-' '..................................................................................................
'-' ' Re-configuration of QoS settings and custom polling loop sequence generator
'-' 
'-' reconfig                    push    #notify                 'setup return addr, then reload 
	byte	$2a, $14, $66, $fd
'-' reloadcogs                  setq    #8-1                    'reload all per COG QoS params
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
	byte	$a6, $b1, $03, $fb
'-'                             setd    a, #id0
	byte	$d0, $df, $b7, $f9
'-'                             sets    a, #addr1
	byte	$d8, $df, $bf, $f9
'-'                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
	byte	$fe, $ff, $ff, $ff, $28, $00, $66, $fd
'-'                             rep     #2, #8                  'repeat for 8 COGs
	byte	$08, $04, $dc, $fc
'-'                             alti    a, #%111_111 
	byte	$3f, $de, $a7, $f9
'-'                             muxq    0-0, 0-0
	byte	$00, $00, $f0, $f9
'-' patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
	byte	$09, $01, $a4, $fa
'-'                             cogid   c
	byte	$01, $e2, $63, $fd
'-'                             decod   excludedcogs, c         'exclude driver cog initially
	byte	$f1, $41, $c3, $f9
'-'                             mov     a, #$8                  'a iterates through prio levels 8=lowest
	byte	$08, $de, $07, $f6
'-'                             neg     pa, #1                  'start with all ones
	byte	$01, $ec, $67, $f6
'-' fillprio                    mov     c, #7                   'c iterates through cogs
	byte	$07, $e2, $07, $f6
'-' prioloop                    alts    c, #id0
	byte	$d0, $e3, $97, $f9
'-'                             mov     b, 0-0
	byte	$00, $e0, $03, $f6
'-'                             getword d, b, #1                'get burst field
	byte	$f0, $e5, $3b, $f9
'-'                             test    d wz                    'if burst=0 
	byte	$f2, $e5, $cb, $f7
'-'             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
	byte	$f1, $41, $23, $a4
'-'             if_z            jmp     #excluded               
	byte	$0c, $00, $90, $ad
'-'                             getnib  d, b, #3                'get RR/PRI flag & priority
	byte	$f0, $e5, $5b, $f8
'-'                             cmp     d, a wz                 'compare against current priority level
	byte	$ef, $e5, $0b, $f2
'-'             if_z            rolnib  pa, c, #0               'if matches include COG at this level
	byte	$f1, $ed, $83, $a8
'-' excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
	byte	$f6, $e3, $7f, $fb
'-'                             incmod  a, #15 wz               'next level
	byte	$0f, $de, $0f, $f7
'-'             if_nz           jmp     #fillprio 
	byte	$cc, $ff, $9f, $5d
'-' 
'-' 'determine priority cogs and build instructions for the polling sequence
'-'                             mov     pb, #0                  'clear out set of priority COGs
	byte	$00, $ee, $07, $f6
'-'                             mov     a, #3                   'start with no COGs being polled + 3 instructions
	byte	$03, $de, $07, $f6
'-'                             setd    d, #polling_code        'initialize COGRAM write position
	byte	$14, $e5, $b7, $f9
'-' 
'-'                             rep     @endprioloop, #8        'test all 8 priority slots
	byte	$08, $18, $dc, $fc
'-'                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
	byte	$03, $ec, $17, $f4
'-'                             getnib  c, pa, #0               'get cogid ID at this priority level
	byte	$f6, $e3, $43, $f8
'-'             if_nc           testb   pb, c wz                'check if already exists as priority COG
	byte	$f1, $ef, $0b, $34
'-'             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
	byte	$f1, $ef, $23, $14
'-'             if_nc_and_nz    add     a, #1                   'add another COG to poll 
	byte	$01, $de, $07, $11
'-'             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
	byte	$b0, $e3, $97, $19
'-'             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $19
'-'             if_nc_and_nz    mul     c, #3
	byte	$03, $e2, $07, $1a
'-'             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
	byte	$f1, $47, $b2, $19
'-'             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $19
'-'             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $16
'-'                             ror     pa, #4                  'advance to next priority
	byte	$04, $ec, $07, $f0
'-' endprioloop
'-'                             xor     pb, #$ff                'invert to find all the non-priority COGs
	byte	$ff, $ee, $67, $f5
'-'                             andn    pb, excludedcogs        'and remove any other excluded COGs
	byte	$a0, $ef, $23, $f5
'-'                             ones    rrlimit, pb wz          'count the number of RR COGs
	byte	$f7, $cd, $ab, $f7
'-'                             add     a, rrlimit              'account for this number of RR COGs to poll
	byte	$e6, $df, $03, $f1
'-'                             sub     rrlimit, #1             'setup last RR count value for incmod
	byte	$01, $cc, $87, $f1
'-'                             alti    d, #%111_000            'generate the control polling instruction
	byte	$38, $e4, $a7, $f9
'-'                             mov     0-0, ctrlpollinst       'write the instruction
	byte	$24, $01, $00, $f6
'-'             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
	byte	$38, $e4, $a7, $59
'-'             if_nz           mov     0-0, skipfinst          'add the skipf instruction
	byte	$25, $01, $00, $56
'-'             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
	byte	$02, $de, $07, $51
'-'                             setd    polling_loop, a         'save it as the repeat count
	byte	$ef, $23, $b2, $f9
'-'             if_z            ret                             'we are done now, if no round robin COGs
	byte	$2d, $00, $64, $ad
'-' 
'-' ' populate the round robin COG polling instructions
'-'                             mov     rrcounter, #2           'fill the RR poll instruction list twice
	byte	$02, $5e, $07, $f6
'-' rrloop                      mov     b, pb                   'get the set of RR COGs
	byte	$f7, $e1, $03, $f6
'-'                             mov     c, #0                   'start at COG ID = 0
	byte	$00, $e2, $07, $f6
'-'                             mov     a, #0                   'req mailbox COGRAM address for COG 0
	byte	$00, $de, $07, $f6
'-' nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
	byte	$01, $e0, $5f, $f0
'-'             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
	byte	$ef, $47, $b2, $c9
'-'             if_c            alts    c, #cog0_handler        'determine jump address
	byte	$b0, $e3, $97, $c9
'-'             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $c9
'-'             if_c            alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $c9
'-'             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $c6
'-'                             add     c, #1                   'increment the COG ID
	byte	$01, $e2, $07, $f1
'-'                             add     a, #3                   'increase the request address
	byte	$03, $de, $07, $f1
'-'             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
	byte	$dc, $ff, $9f, $5d
'-'             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
	byte	$f3, $5f, $6f, $0b
'-' '..................................................................................................
'-' ' Code to get/set driver settings per bank or to dump COG/LUT state
'-' 
'-' set_latency                                                 '            (a) set latency
'-' get_latency                                                 '            (b) get latency
'-' set_burst                                                   '            (c) set burst size of bank
'-' get_burst                                                   '            (d) get burst size of bank
'-'                                                             '            (e) dump state
'-'                             getnib  b, addr1, #6            ' a b c d    get bank address
	byte	$d8, $e1, $73, $f8
'-' dump_state                  setq    #511                    ' | | | | e  prepare burst write
	byte	$28, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                                                             ' | | | | e  account for following AUGS
'-'                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
	byte	$04, $00, $00, $ff, $00, $b2, $07, $f1
'-'                             setq2   #511                    ' | | | | e  prepare burst write
	byte	$29, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                             add     b, #16                  ' a b | | |  point to latency params
	byte	$10, $e0, $07, $f1
'-'                             rdlut   a, b                    ' a b c d |  read data for bank
	byte	$f0, $df, $a3, $fa
'-'                             setbyte a, hubdata, #3          ' a | | | |  patch latency
	byte	$d9, $df, $db, $f8
'-'                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
	byte	$d9, $df, $03, $f6
'-'                             wrlut   a, b                    ' a | c | |  if setting, save bank data
	byte	$f0, $df, $33, $fc
'-'                             getbyte a, a, #3                ' | b | | |  extract latency field only
	byte	$ef, $df, $fb, $f8
'-'                             wrlong  a, ptrb                 ' | b | d |  write result          
	byte	$80, $df, $67, $fc
'-'                             jmp     #notify                 ' a b c d e  return success
	byte	$dc, $fd, $9f, $fd
'-' 
'-' '..................................................................................................
'-' ' Misc EXECF code
'-' 
'-' start_read_exec             execf   newburstr
	byte	$33, $72, $63, $fd
'-' start_write_exec            execf   resumewrites
	byte	$33, $7c, $63, $fd
'-' continue_read_exec          execf   lockedreads
	byte	$33, $78, $63, $fd
'-' continue_write_exec         execf   lockedwrites
	byte	$33, $7a, $63, $fd
'-' 
'-' '..................................................................................................
'-' ' Variables
'-' 
'-' ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
	byte	$08, $00, $cf, $20
'-' xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
	byte	$00, $00, $c0, $f0
'-' xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
	byte	$00, $00, $c0, $b0
'-' xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
	byte	$02, $00, $c0, $70
'-' 
'-' xfreq1          long    $80000000
	byte	$00, $00, $00, $80
'-' xfreq2          long    $40000000
	byte	$00, $00, $00, $40
'-' delay           long    3
	byte	$03, $00, $00, $00
'-' 
'-' lutcodeaddr                 
'-' startupparams
'-' excludedcogs                                    'careful: shared register use!
'-' frequency       long    lut_code - driver_start 'determine offset of LUT code from base
	byte	$cc, $07, $00, $00
'-' flags           long    0
	byte	$00, $00, $00, $00
'-' mask                                            'careful: shared register use!
'-' resetmaskA      long    0
	byte	$00, $00, $00, $00
'-' limit                                           'careful: shared register use!
'-' resetmaskB      long    0
	byte	$00, $00, $00, $00
'-' datapins        long    0
	byte	$00, $00, $00, $00
'-' const512                                        'careful: shared register use!
'-' devicelist      long    0
	byte	$00, $00, $00, $00
'-' coglist         long    0
	byte	$00, $00, $00, $00
'-' mbox            long    0 
	byte	$00, $00, $00, $00
'-' 
'-' clkpin                                          'shared with code patched during init
'-' clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
	byte	$a8, $03, $18, $fc
'-' cspin                                           'shared with code patched during init
'-' speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
	byte	$1d, $3a, $63, $fd
'-' registered      long    %100_000_000_00_00000_0 'config pin for clocked input
	byte	$00, $00, $01, $00
'-' clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
	byte	$4a, $00, $00, $00
'-' clkdelay        long    1
	byte	$01, $00, $00, $00
'-' regdatabus      long    0
	byte	$00, $00, $00, $00
'-' 
'-' deviceaddr      long    $10
	byte	$10, $00, $00, $00
'-' rrcounter
'-' pinmask         long    $ff3f7f7f
	byte	$7f, $7f, $3f, $ff
'-' 
'-' ' jump addresses for the per COG handlers
'-' cog0_handler    long    cog0
	byte	$20, $00, $00, $00
'-' cog1_handler    long    cog1
	byte	$2c, $00, $00, $00
'-' cog2_handler    long    cog2
	byte	$38, $00, $00, $00
'-' cog3_handler    long    cog3
	byte	$44, $00, $00, $00
'-' cog4_handler    long    cog4
	byte	$50, $00, $00, $00
'-' cog5_handler    long    cog5
	byte	$5c, $00, $00, $00
'-' cog6_handler    long    cog6
	byte	$68, $00, $00, $00
'-' cog7_handler    long    cog7
	byte	$74, $00, $00, $00
'-' expansion       long    gfxexpansion - driver_start
	byte	$0c, $0f, $00, $00
'-' 
'-' ' EXECF sequences
'-' newburstr       long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-' lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
	byte	$48, $9b, $ef, $00
'-' restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
	byte	$41, $f3, $05, $74
'-' lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
	byte	$80, $22, $3f, $00
'-' lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
	byte	$4b, $f3, $e0, $0f
'-' resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
	byte	$4b, $03, $e0, $0f
'-' resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
	byte	$76, $02, $8a, $84
'-' 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
'-' 
'-' 
'-' ' SKIPF sequences
'-' skiptable
'-'                 long    %11000011000001111110  ' read modify write byte
	byte	$7e, $30, $0c, $00
'-'                 long    %110011011100001110    ' read modify write word
	byte	$0e, $37, $03, $00
'-'                 long    0                      ' read modify write long
	byte	$00, $00, $00, $00
'-'                 long    %1111110               ' single byte read
	byte	$7e, $00, $00, $00
'-'                 long    %11110001110           ' single word read
	byte	$8e, $07, $00, $00
'-' pattern2        long    0
	byte	$00, $00, $00, $00
'-' pattern3        long    0
	byte	$00, $00, $00, $00
'-' singlelong      long    %1001110111  
	byte	$77, $02, $00, $00
'-' skipcase_a      long    %01101111100000000001000011111101
	byte	$fd, $10, $80, $6f
'-' skipcase_b      long    %00000000010100000001100000010000
	byte	$10, $18, $50, $00
'-' skipcase_c      long    %00000000011000000011111000010001
	byte	$11, $3e, $60, $00
'-' skipseq_write   long    %00000000000000000000111100000010
	byte	$02, $0f, $00, $00
'-' 
'-' ' LUT RAM address values
'-' complete_rw     long    complete_rw_lut
	byte	$ff, $02, $00, $00
'-' continue_read   long    continue_read_lut
	byte	$dd, $02, $00, $00
'-' continue_write  long    continue_write_lut
	byte	$db, $02, $00, $00
'-' noread          long    noread_lut
	byte	$f6, $02, $00, $00
'-' 
'-' id0             long    0
	byte	$00, $00, $00, $00
'-' id1             long    1
	byte	$01, $00, $00, $00
'-' id2             long    2
	byte	$02, $00, $00, $00
'-' id3             long    3
	byte	$03, $00, $00, $00
'-' id4             long    4
	byte	$04, $00, $00, $00
'-' id5             long    5
	byte	$05, $00, $00, $00
'-' id6             long    6
	byte	$06, $00, $00, $00
'-' id7             long    7
	byte	$07, $00, $00, $00
'-' 
'-' 'These next 10 request registers below are also temporarily reused during init 
'-' 'and COG updates and need to follow immediately after id0-id7
'-' addr1           long    0
	byte	$00, $00, $00, $00
'-' hubdata         long    0
	byte	$00, $00, $00, $00
'-' count           long    0
	byte	$00, $00, $00, $00
'-' addr2           long    0
	byte	$00, $00, $00, $00
'-' total           long    0
	byte	$00, $00, $00, $00
'-' offset1         long    0
	byte	$00, $00, $00, $00
'-' offset2         long    0
	byte	$00, $00, $00, $00
'-' link            long    0
	byte	$00, $00, $00, $00
'-' 
'-' burstwrite                                      'note shared register use during init
'-' initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
	byte	$00, $10, $f0, $fe
'-' id              long    0
	byte	$00, $00, $00, $00
'-' 
'-' header          long    0
	byte	$00, $00, $00, $00
'-' trailer         long    0
	byte	$00, $00, $00, $00
'-' cmdaddr         long    0
	byte	$00, $00, $00, $00
'-' request         long    0
	byte	$00, $00, $00, $00
'-' rrlimit         long    0
	byte	$00, $00, $00, $00
'-' pinconfig       long    0
	byte	$00, $00, $00, $00
'-' clks            long    0
	byte	$00, $00, $00, $00
'-' resume          long    0
	byte	$00, $00, $00, $00
'-' orighubsize     long    0
	byte	$00, $00, $00, $00
'-' wrclks          long    0
	byte	$00, $00, $00, $00
'-' 
'-' pattern         long    0
	byte	$00, $00, $00, $00
'-' hubscratch      long    0
	byte	$00, $00, $00, $00
'-' val4k           long    4096
	byte	$00, $10, $00, $00
'-' 
'-' ' temporary general purpose regs
'-' a               long    0
	byte	$00, $00, $00, $00
'-' b               long    0
	byte	$00, $00, $00, $00
'-' c               long    0
	byte	$00, $00, $00, $00
'-' d               long    0
	byte	$00, $00, $00, $00
'-'                 fit     502
'-' 
'-'                 fit     502
'-' 
'-' '..................................................................................................
'-' 
'-'             orgh
'-' 
'-' lut_code
'-' 'HW init code up to 80 longs
'-' 
'-' '..................................................................................................
'-' ' Memory layout for LUT RAM once operational:
'-' '
'-' '  LUT RAM address      Usage
'-' '  ---------------      ----
'-' '    $200-$20F          Bank parameters: burst + type + size per bank (16)
'-' '    $210-$21F          Pin parameters : latency + control pins per bank (16)
'-' '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
'-' '    $270-$3FF          Main PSRAM access code in LUTRAM 
'-' '
'-' ' Also during driver COG startup:
'-' ' $230-$24F is used for HW init setup
'-' ' $250-$26F is used as temporary vector storage 
'-' '..................................................................................................
'-' 
'-'                 org $230    
'-' 
'-' ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
'-' hwinit                      setxfrq xfreq2
	byte	$1d, $3c, $63, $fd
'-'                             pollxfi
	byte	$24, $16, $60, $fd
'-'                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
	byte	$ff, $aa, $2a, $ff, $ff, $ed, $07, $f6
'-'                             call    #sendqspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$0FF00FF0         '$66 - reset enable
	byte	$07, $f8, $07, $ff, $f0, $ed, $07, $f6
'-'                             call    #sendspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$F00FF00F         '$99 - reset
	byte	$f8, $07, $78, $ff, $0f, $ec, $07, $f6
'-'                             call    #sendspi
	byte	$1c, $00, $b0, $fd
'-'                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
	byte	$7f, $78, $78, $ff, $00, $ed, $07, $f6
'-'                             call    #sendspi 
	byte	$10, $00, $b0, $fd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-' 
'-' sendqspi                    mov     clks,#4
	byte	$04, $d0, $07, $f6
'-'                             skipf   #%110
	byte	$32, $0c, $64, $fd
'-'                             mov     pb, xsendimm
	byte	$9c, $ef, $03, $f6
'-' 
'-' sendspi                     mov     clks, #16
	byte	$10, $d0, $07, $f6
'-'                             mov     pb, ximm8lut
	byte	$97, $ef, $03, $f6
'-'                             drvl    cspin                   'active low chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   pb, pa                  'send 32 bit immediate data
	byte	$f6, $ef, $a3, $fc
'-'                             wypin   clks, clkpin            'start memory clock output 
	byte	$a8, $d1, $23, $fc
'-'                             waitxfi                         'wait for the completion
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                'float data bus
	byte	$50, $48, $63, $fd
'-'                             drvh    cspin                   'raise chip select
	byte	$59, $52, $63, $fd
'-'             _ret_           waitx   #200                    'delay before return to ensure CS delay
	byte	$1f, $90, $65, $0d
'-' 
'-'                 long    0[$270-32-$]
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-'     
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-' ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
'-' rw_vect ' PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    (%0111010000000000111000 << 10) + w_single
	byte	$41, $e3, $00, $74
'-'                 long    (%0111010000000000100100 << 10) + w_single
	byte	$41, $93, $00, $74
'-'                 long    (%0111010000000000011100 << 10) + w_single
	byte	$41, $73, $00, $74
'-'                 long    (%1111111000000000000110 << 10) + w_burst
	byte	$47, $1b, $00, $fe
'-' ro_vect ' R/O PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-' ctrl_vect ' Control jump vectors
'-'                 long    (%0000000000111001111110 << 10) + get_latency
	byte	$84, $f9, $39, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000001111011111110 << 10) + get_burst
	byte	$84, $f9, $7b, $00
'-'                 long    (%0000000001111111000000 << 10) + dump_state
	byte	$85, $01, $7f, $00
'-'                 long    (%0000000011010001111110 << 10) + set_latency
	byte	$84, $f9, $d1, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000011001011111110 << 10) + set_burst
	byte	$84, $f9, $cb, $00
'-'                 long    reconfig 
	byte	$3e, $01, $00, $00
'-' no_vect ' Invalid bank jump vectors
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 fit     $270
'-' 
'-'                 fit     $270
'-' '..................................................................................................
'-' ' PSRAM READS
'-'                                                             ' a b c d e f
'-'                                                             ' B W L B R L  (a) byte read
'-'                                                             ' Y O O U E O  (b) word read
'-'                                                             ' T R N R S C  (c) long read
'-'                                                             ' E D G S U K  (d) new burst read
'-'                                                             '       T M E  (e) resumed sub-burst
'-'                                                             '         E D  (f) locked sub-burst
'-' 
'-' 
'-' r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
	byte	$da, $d5, $03, $f6
'-' r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
	byte	$da, $b5, $cb, $f7
'-'                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
	byte	$36, $d9, $07, $f6
'-'             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
	byte	$20, $d9, $27, $a5
'-'                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
	byte	$02, $34, $27, $f9
'-'                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
	byte	$80, $b4, $97, $fb
'-' r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    ' a b c d e    get bank limit/mask
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 ' | | | d e    build mask for addr
	byte	$f0, $45, $cb, $f9
'-'                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
	byte	$f0, $3f, $eb, $f8
'-' p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
	byte	$11, $e0, $47, $f0
'-'                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
	byte	$f0, $47, $23, $f3
'-'                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
	byte	$05, $3e, $57, $f0
'-'             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
	byte	$10, $5a, $67, $04
'-'                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
	byte	$10, $5a, $67, $f4
'-'                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
	byte	$f9, $3b, $83, $fc
'-' r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
	byte	$d9, $3b, $83, $fc
'-'                             mov     c, count                ' | | | d e f  get count of bytes left to read
	byte	$da, $e3, $03, $f6
'-'                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
	byte	$20, $d0, $17, $f6
'-'             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
	byte	$cd, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
	byte	$cc, $d3, $03, $36
'-'                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
	byte	$32, $20, $64, $fd
'-'                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
	byte	$54, $00, $90, $fd
'-' 
'-'                             ' fall through to read bursts
'-'                         
'-' burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
	byte	$cd, $d3, $03, $c6
'-'                             mov     pattern, #0             'enable all by default
	byte	$00, $d8, $07, $f6
'-'                             testb   addr1, #1 wc            'test if start addr starts in second word
	byte	$01, $b0, $17, $f4
'-'                             bitnc   pattern, #1             'enable delay cycle if so
	byte	$01, $d8, $67, $f4
'-'                             wrc     clks                    'and account for its clock cycle
	byte	$6c, $d0, $63, $fd
'-'                             testb   addr1, #0 wc            'test if start addr starts on odd byte
	byte	$00, $b0, $17, $f4
'-'                             bitnc   pattern, #2             'add hi 8 transfer initially
	byte	$02, $d8, $67, $f4
'-'                             mov     d, c                    'get count of bytes to be read into HUB
	byte	$f1, $e5, $03, $f6
'-'             if_c            sub     d, #1                   'minus 1 if start addr was odd
	byte	$01, $e4, $87, $c1
'-'                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
	byte	$01, $e4, $4f, $f0
'-'                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
	byte	$f2, $d1, $23, $f1
'-'                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
	byte	$f2, $35, $23, $f9
'-'                             bitz    pattern, #3             'adjust the pattern to include this
	byte	$03, $d8, $87, $f4
'-'                             testb   c, #0 xorc              'test for end address
	byte	$00, $e2, $d7, $f4
'-'                             bitnc   pattern, #4             'include low 8 bit transfer if required
	byte	$04, $d8, $67, $f4
'-'                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
	byte	$0e, $d0, $27, $f1
'-'                             add     clks, clks
	byte	$e8, $d1, $03, $f1
'-' readcommon
'-'                             mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$EB, #3       'add quad read command
	byte	$eb, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-' 
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable data bus
	byte	$58, $48, $63, $fd
'-'             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
'-'                             xinit   ximm8lut, cmdaddr       'stream out command+address
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   clks, clkpin            'start clock output
	byte	$a8, $d1, $23, $fc
'-'                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
	byte	$00, $00, $cc, $fc
'-'                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
	byte	$00, $0c, $cc, $fc
'-'                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
'-'                             fltl    datapins                'safe to float the data bus, address has been sent by now
	byte	$50, $48, $63, $fd
'-'                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
	byte	$a4, $5b, $03, $fc
'-'                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
	byte	$28, $3a, $63, $fd
'-'                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
	byte	$00, $3e, $c7, $fc
'-'                             xcont   #6, #0                  'fixed delay offset to expand delay range
	byte	$00, $0c, $cc, $fc
'-'                             skipf   pattern                 'choose path below
	byte	$32, $d8, $63, $fd
'-'                                                             'Bursts Bytes Words Longs  RMW FromWrites
'-'                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
	byte	$28, $3c, $63, $fd
'-'                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
	byte	$00, $02, $cc, $fc
'-'                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
	byte	$00, $32, $c7, $fc
'-'                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
	byte	$00, $34, $c7, $fc
'-'                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
	byte	$00, $30, $c7, $fc
'-'                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
	byte	$24, $36, $60, $fd
'-'                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
	byte	$a4, $55, $03, $fc
'-'             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
	byte	$59, $52, $63, $0d
'-'                             drvh    cspin                   '         b     c           e       deassert chip select and continue
	byte	$59, $52, $63, $fd
'-'                             getnib  d, request, #1          'get request code value
	byte	$e5, $e5, $4b, $f8
'-'             if_nz           sub     d, #3                   'offset for table if RMW
	byte	$03, $e4, $87, $51
'-'                             altd    d, #skiptable-5         'patch next instruction
	byte	$bb, $e5, $8f, $f9
'-'                             skipf   0-0                     'generate skip sequence
	byte	$32, $00, $60, $fd
'-'                                                             ' B   W  RMWB RMWW RMLL 
'-'                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
	byte	$80, $df, $07, $fb
'-'                             setq    count                   ' |   |   |    |    e   setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
	byte	$d9, $df, $f3, $f9
'-'                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
	byte	$40, $00, $90, $fd
'-'                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
	byte	$01, $b0, $17, $f4
'-'             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
	byte	$ef, $ef, $3b, $c9
'-'             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
	byte	$ef, $ef, $33, $39
'-'                             mov     d, addr1                ' a   |   c    d
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3                   ' a   |   c    |        get LSBs of address
	byte	$03, $e4, $07, $f5
'-'                             altgb   d, #a                   ' a   |   c    |        index into long
	byte	$ef, $e5, $6f, $f9
'-'                             getbyte pb                      ' a   |   c    |        and extract the byte
	byte	$00, $ee, $e3, $f8
'-'                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
	byte	$80, $ef, $67, $fc
'-'                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
	byte	$c0, $00, $b0, $fd
'-'                             ret                             ' a   b   |    |        then return
	byte	$2d, $00, $64, $fd
'-'                             setq    count                   '         c    d        setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    pb, hubdata             '         c    d        apply bit mux
	byte	$d9, $ef, $f3, $f9
'-'                             altsb   d, #a                   '         c    |
	byte	$ef, $e5, $67, $f9
'-'                             setbyte 0-0, pb, #0             '         c    |
	byte	$f7, $01, $c0, $f8
'-'             if_c            setword a, pb, #1               '         |    d
	byte	$f7, $df, $2b, $c9
'-'             if_nc           setword a, pb, #0               '         |    d
	byte	$f7, $df, $23, $39
'-' writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
	byte	$37, $8a, $07, $f6
'-'                             mov     hubdata, a              'write a to PSRAM
	byte	$ef, $b3, $03, $f6
'-'                             mov     wrclks, #20             '20 clocks to write a long
	byte	$14, $d6, $07, $f6
'-'                             mov     resume, complete_rw     'we'll complete the operation after this
	byte	$cc, $d3, $03, $f6
'-'                             jmp     #writecommon
	byte	$10, $03, $90, $fd
'-' 
'-' '..................................................................................................
'-' ' Burst continuation testing
'-' 
'-' continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
	byte	$32, $96, $63, $fd
'-'                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
	byte	$be, $d3, $03, $f6
'-' continue_read_lut          
'-'                             mov     resume, resumereads     ' | setup resume address to execf
	byte	$bf, $d3, $03, $f6
'-'                             add     hubdata, c              ' a compute the next hub addr to use
	byte	$f1, $b3, $03, $f1
'-'                             sub     count, c                ' a account for the bytes already sent
	byte	$f1, $b5, $83, $f1
'-'                             add     c, addr1                ' a compute next external mem address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    ' a configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
	byte	$14, $00, $90, $5d
'-'                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
	byte	$e1, $47, $3b, $f9
'-'                             fle     limit, b                ' | also re-apply per bank limit
	byte	$f0, $47, $23, $f3
'-'             _ret_           push    #continue_read_exec     ' | 
	byte	$2a, $2a, $67, $0d
'-'             if_nz           jmp     #yield                  ' a
	byte	$04, $00, $90, $5d
'-'             _ret_           push    #continue_write_exec    ' a
	byte	$2a, $2c, $67, $0d
'-' 
'-' yield                       wrlut   total, ptra[4]          'save context for next time
	byte	$04, $b9, $37, $fc
'-'                             wrlut   offset1, ptra[5]        'save context for next time
	byte	$05, $bb, $37, $fc
'-'                             wrlut   offset2, ptra[6]        'save context for next time
	byte	$06, $bd, $37, $fc
'-'                             wrlut   link, ptra[7]           'save context for next time
	byte	$07, $bf, $37, $fc
'-' yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
	byte	$00, $b1, $37, $fc
'-'                             wrlut   hubdata, ptra[1]        'save context for next time
	byte	$01, $b3, $37, $fc
'-'                             wrlut   count, ptra[2]          'save context for next time
	byte	$02, $b5, $37, $fc
'-'                             wrlut   addr2, ptra[3]          'save context for next time
	byte	$03, $b7, $37, $fc
'-'                             wrlut   resume, ptra[8]         'save next resume address
	byte	$08, $d3, $37, $fc
'-'                             wrlut   orighubsize, ptra[9]    'save original hub size
	byte	$09, $d5, $37, $fc
'-'             _ret_           push    #poller
	byte	$2a, $1c, $66, $0d
'-' 
'-' 
'-' notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
	byte	$32, $be, $65, $fd
'-' nowrite_lut                                                 '  (a) new skip sequence 
'-' noread_lut                  skipf   #0                      ' | cancel skipping
	byte	$32, $00, $64, $fd
'-'                             wrlut   #0, ptra[8]             ' | clear resume
	byte	$08, $01, $3c, $fc
'-'                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_nz           jmp     #notify                 ' | if not a request list then we are done
	byte	$40, $f8, $9f, $5d
'-'                             testb   addr2, #31 wz           ' | check if extended list item
	byte	$1f, $b6, $0f, $f4
'-' donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
	byte	$df, $b7, $03, $a6
'-' checklist                   call    #checknext              ' | handle running from list
	byte	$1c, $00, $b0, $fd
'-'                             ret                             ' | continue processing
	byte	$2d, $00, $64, $fd
'-'             _ret_           push    noread                  'continue end of transfer
	byte	$2a, $9e, $63, $0d
'-' '..................................................................................................
'-' ' Completion of requests
'-' 
'-' complete_rw_lut             
'-'                             testb   id, #LIST_BIT wz        'test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_z            skipf   #%10                    'if a request list then skip notification
	byte	$32, $04, $64, $ad
'-'                             wrlut   #0, ptra[8]             ' a   default is not to resume
	byte	$08, $01, $3c, $fc
'-'             _ret_           push    #notify                 ' |   if not a request list then we are done
	byte	$2a, $14, $66, $0d
'-'                             tjs     addr2, #extendedreq     '     test for special extended request  
	byte	$0d, $b6, $b7, $fb
'-' checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
	byte	$07, $b6, $97, $fb
'-'                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
	byte	$bf, $ed, $07, $fb
'-'                             tjns    pa, #listcomplete       'exit if it has
	byte	$05, $ec, $bf, $fb
'-'                             testb   id, #LOCKED_BIT wz
	byte	$0a, $c2, $0f, $f4
'-'             if_z            mov     hubdata, addr2
	byte	$db, $b3, $03, $a6
'-'             if_z            skipf   #%110001
	byte	$32, $62, $64, $ad
'-'             if_nz           skipf   #%1000                  'do not notify if list is continuing
	byte	$32, $10, $64, $5d
'-'                             wrlong  addr2, ptrb             ' a  write back next list address
	byte	$80, $b7, $67, $fc
'-' listcomplete                altd    id, #id0                ' a  compute COG's state address
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
	byte	$09, $00, $04, $f4
'-'             _ret_           push    #notify                 ' |  we are done with the list
	byte	$2a, $14, $66, $0d
'-'             _ret_           push    #poller                 ' a  we are still continuing the list
	byte	$2a, $1c, $66, $0d
'-'             _ret_           push    #real_list              ' a  we are still continuing the list
	byte	$2a, $50, $66, $0d
'-' extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
	byte	$e3, $b5, $97, $fb
'-'                             getnib  a, addr2, #7            'check the request type
	byte	$db, $df, $7b, $f8
'-'                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
	byte	$0f, $de, $0f, $f2
'-'                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
	byte	$d8, $df, $73, $f8
'-'             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
	byte	$32, $90, $63, $5d
'-'                                                             ' skipcase (a) gfx copy to/from hub
'-'                                                             ' skipcase (b) gfx copy extmem bank to bank
'-'                                                             ' skipcase (c) linear copy extmem bank to bank
'-'                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
	byte	$db, $df, $73, $f8
'-'                             rdlut   d, a wz                 ' a      load bank information and check if valid
	byte	$ef, $e5, $ab, $fa
'-'             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
	byte	$31, $02, $64, $5d
'-'             _ret_           push    #invalidbank            ' |      otherwise bail out after this
	byte	$2a, $02, $66, $0d
'-'                             test    offset1 wz              ' |      check for first offset being zero
	byte	$dd, $bb, $cb, $f7
'-'             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
	byte	$de, $bd, $cb, $a7
'-'             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
	byte	$32, $94, $63, $ad
'-'                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
	byte	$32, $92, $63, $fd
'-'                             add     hubdata, c              ' a b c  add bytes just sent to hub address
	byte	$f1, $b3, $03, $f1
'-'                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
	byte	$ea, $b3, $83, $f1
'-'                             add     c, addr1                ' a b c  compute next address to use
	byte	$d8, $e3, $03, $f1
'-'                             test    total wz                ' a b |  check for zero tranfers
	byte	$dc, $b9, $cb, $f7
'-'                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
	byte	$dc, $d5, $2b, $f3
'-'             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
	byte	$44, $ff, $9f, $ad
'-'                             testb   addr1, #30 wz           ' a b c  check if reading/writing
	byte	$1e, $b0, $0f, $f4
'-'                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
	byte	$ea, $b5, $03, $f6
'-'                             sub     c, orighubsize          ' a b |  rewind to original position
	byte	$ea, $e3, $83, $f1
'-'             if_z            add     c, offset1              ' a b |  add any dst scanline offset
	byte	$dd, $e3, $03, $a1
'-'             if_nz           add     c, offset2              ' a b |  add any src scanline offset
	byte	$de, $e3, $03, $51
'-'             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
	byte	$de, $b3, $03, $a1
'-'             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
	byte	$dd, $b3, $03, $51
'-'                             setq    mask                    ' a b c  configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a b c  perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             mov     a, addr1                ' | b c  ]
	byte	$d8, $df, $03, $f6
'-'                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
	byte	$db, $b1, $03, $f6
'-'                             mov     addr2, a                ' | b c  ]
	byte	$ef, $b7, $03, $f6
'-'                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
	byte	$1e, $b0, $a7, $f4
'-'                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
	byte	$0f, $b6, $3f, $f8
'-'                             sub     total, #1 wz            ' a | |  decrement scanline count
	byte	$01, $b8, $8f, $f1
'-'             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
	byte	$01, $b8, $8f, $a1
'-'             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
	byte	$ea, $b9, $8b, $a1
'-'             if_z            mov     addr2, link
	byte	$df, $b7, $03, $a6
'-'             if_z            jmp     #checknext
	byte	$34, $ff, $9f, $ad
'-' moretransfers               getbyte request, addr1, #3      'prepare next request
	byte	$d8, $cb, $fb, $f8
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            skipf   #%1110                  '     skip some code if we are locked
	byte	$32, $1c, $64, $ad
'-'                             testb   addr1, #30 wz           ' a   test if will be reading or writing
	byte	$1e, $b0, $0f, $f4
'-'             if_z            mov     resume, resumewrites    ' |   resume burst writing
	byte	$be, $d3, $03, $a6
'-'             if_nz           mov     resume, newburstr       ' |   resume burst reading
	byte	$b9, $d3, $03, $56
'-'                             jmp     #yield                  ' |   yield to poller
	byte	$b0, $fe, $9f, $fd
'-'             if_z            skip    #%1                     '     skip next instruction for writing case
	byte	$31, $02, $64, $ad
'-'             _ret_           push    #start_read_exec        '(|)  do new read burst next 
	byte	$2a, $26, $67, $0d
'-'             _ret_           push    #start_write_exec       'do new write burst next
	byte	$2a, $28, $67, $0d
'-' 
'-' '..................................................................................................
'-' ' PSRAM WRITES
'-'                                                             '  a b c d e f g h
'-' 
'-'                                                             '  B W L F B R L L (a) byte write(s)
'-'                                                             '  Y O O I U E O O (b) word write(s)
'-'                                                             '  T R N L R S C C (c) long write(s)
'-'                                                             '  E D G L S U K K (d) resumed fill
'-'                                                             '          T M E E (e) new burst write
'-'                                                             '            E D D (f) resumed burst
'-'                                                             '              F B (g) locked fill
'-'                                                             '              I U (h) locked burst write
'-'                                                             '              L R 
'-'                                                             '              L S 
'-'                                                             '                T 
'-' 
'-' w_single                   
'-' w_fill_cont           
'-'                             getnib  a, addr1, #7            '  a b c d          obtain request
	byte	$d8, $df, $7b, $f8
'-'                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
	byte	$03, $de, $07, $f5
'-'                             movbyts hubdata, #0             '  a | | |          replicate byte across long
	byte	$00, $b2, $ff, $f9
'-'                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
	byte	$44, $b2, $ff, $f9
'-'                             andn    addr1, #1               '  | b | |          align word addresses
	byte	$01, $b0, $27, $f5
'-'                             andn    addr1, #3               '  | | c |          align long addresses
	byte	$03, $b0, $27, $f5
'-' w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
	byte	$da, $d5, $03, $f6
'-' w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
	byte	$01, $b4, $0f, $f2
'-'                             shl     count, a                '  a b c | |   |    scale into bytes
	byte	$ef, $b5, $63, $f0
'-'                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
	byte	$ab, $b5, $97, $fb
'-' w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
	byte	$da, $e3, $03, $f6
'-'                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
	byte	$76, $02, $a0, $fd
'-'                ' disable call to r_resume_burst for single longs when z=0
'-'                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
	byte	$3f, $8a, $0f, $f6
'-'                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
	byte	$ce, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
	byte	$cc, $d3, $03, $36
'-'                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
	byte	$d9, $df, $03, $f6
'-'                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
	byte	$14, $d6, $07, $f6
'-'                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
	byte	$01, $de, $17, $f4
'-'                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
	byte	$c7, $8b, $03, $f6
'-'             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
	byte	$14, $01, $90, $8d
'-'             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
	byte	$09, $8a, $67, $25
'-'             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
	byte	$5c, $00, $90, $2d
'-'                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
	byte	$0f, $8a, $07, $f6
'-'         
'-'             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
'-'             '
'-'             '  At least one of these 3 optional components will be sent
'-'             '     header - first partial long of data, gets aligned to PSRAM long boundary
'-'             '     body - N x full longs of data
'-'             '     trailer - last partial long of data
'-'             '
'-'             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
'-'             '
'-'             'Case    Type                           Sends
'-'             ' 1)     Single byte/word write         header only (takes its own optimized path)
'-'             ' 2)     Single long write              body only (takes its own optimized path)
'-'             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
'-'             ' 4)     Multiple long fill             body only
'-'             ' 5)     Burst write                    optional header, optional body, optional trailer
'-' 
'-'                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
	byte	$ce, $d3, $03, $c6
'-'                             mov     pattern3, #%10011
	byte	$13, $8c, $07, $f6
'-'                             mov     d, addr1                'get start address position 
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3 wz                'get alignment
	byte	$03, $e4, $0f, $f5
'-'                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
	byte	$04, $e2, $17, $f2
'-'                             mov     wrclks, #16             'clocks needed for address phase
	byte	$10, $d6, $07, $f6
'-'                             mov     pb, c                   'get number of bytes to send
	byte	$f1, $ef, $03, $f6
'-'                             add     pb, d                   'and increase total to send, including initial re-alignment
	byte	$f2, $ef, $03, $f1
'-'             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
	byte	$40, $00, $90, $2d
'-'                             
'-'                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'             if_c            skipf   #%11110                 'if fill skip burst write stuff
	byte	$32, $3c, $64, $cd
'-'                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
	byte	$04, $d6, $07, $f1
'-'                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
	byte	$f2, $df, $83, $f1
'-'                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
	byte	$ef, $e5, $03, $fb
'-'                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
	byte	$04, $de, $07, $f1
'-'                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
	byte	$32, $08, $64, $fd
'-'                             sub     pb, #4 wcz              ' subtract a long from the total
	byte	$04, $ee, $9f, $f1
'-'                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
	byte	$00, $8a, $07, $f4
'-' single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
	byte	$d9, $e5, $03, $f6
'-'                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
	byte	$88, $01, $b0, $fd
'-'                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
	byte	$5a, $b0, $47, $fb
'-'                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
	byte	$ed, $c5, $03, $fb
'-'                             setq    pa                      ' setup byte mux mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    header, d               ' copy bytes into long
	byte	$f2, $c5, $f3, $f9
'-'             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
	byte	$94, $00, $90, $ed
'-' 
'-' header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'                             mov     d, pb                   'preserve the count
	byte	$f7, $e5, $03, $f6
'-'                             andn    pb, #3 wz               'determine the number of full long bytes left to send
	byte	$03, $ee, $2f, $f5
'-'                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
	byte	$07, $ee, $97, $fb
'-'                  
'-'                             add     wrclks, pb              'include this number of bytes as more clock transitions
	byte	$f7, $d7, $03, $f1
'-'             if_c            skipf   #%1010                 'for fills we can skip burst stuff
	byte	$32, $14, $64, $cd
'-'             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
	byte	$0c, $8a, $27, $c5
'-'                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
	byte	$01, $8a, $07, $f4
'-'                             shr     pb, #1                  ' |  b  compute word count for bursts
	byte	$01, $ee, $47, $f0
'-'                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
	byte	$f7, $37, $23, $f9
'-'                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
	byte	$01, $ee, $47, $f0
'-' 
'-' body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
	byte	$03, $e4, $07, $f5
'-'                             tjz     d, #trailer_done        'no trailer to send, we exit now
	byte	$17, $e4, $97, $fb
'-'             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
	byte	$da, $e3, $0b, $c2
'-'             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
	byte	$cc, $d3, $0b, $32
'-'             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
	byte	$f2, $e3, $83, $51
'-'             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
	byte	$4c, $00, $90, $5d
'-' 
'-'                             'we have 1-3 more aligned residual bytes left to send as the trailer
'-'                             or      d, #$1f0                'setup mux mask address
	byte	$f0, $e5, $47, $f5
'-'                             rdlut   pa, d                   'read mux mask for this length at offset 0
	byte	$f2, $ed, $a3, $fa
'-'                             push    addr1                   'save address
	byte	$2a, $b0, $63, $fd
'-' 
'-' ' use this code (note: foldover can occur here in PSRAM bank)
'-'                             add     addr1, c                'find last long address in PSRAM
	byte	$f1, $b1, $03, $f1
'-'                             sub     addr1, #1               '..to be rewritten
	byte	$01, $b0, $87, $f1
'-'                             call    #readlong               'read data from this external address
	byte	$18, $01, $b0, $fd
'-'             
'-'             if_c            mov     d, hubdata              'get data to be sent for fills
	byte	$d9, $e5, $03, $c6
'-'             if_c            skipf   #%11110                 'skip burst code for fills
	byte	$32, $3c, $64, $cd
'-'                             pop     addr1                   'restore address
	byte	$2b, $b0, $63, $fd
'-'                             mov     d, pb                   ' | get number of full longs that were sent
	byte	$f7, $e5, $03, $f6
'-'                             shl     d, #2                   ' | convert to bytes
	byte	$02, $e4, $67, $f0
'-'                             add     d, a                    ' | add to start adress of longs to stream
	byte	$ef, $e5, $03, $f1
'-'                             rdlong  d, d                    ' | read this last long from HUB RAM
	byte	$f2, $e5, $03, $fb
'-' 
'-'                             rdlong  trailer, hubscratch     'read external RAM data value
	byte	$ed, $c7, $03, $fb
'-'                             setq    pa                      'setup byte mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    trailer, d              'apply byte mask to data via muxq
	byte	$f2, $c7, $f3, $f9
'-'                             add     wrclks, #4              'increase by 4 more clocks
	byte	$04, $d6, $07, $f1
'-'                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
	byte	$05, $8a, $07, $f4
'-'                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
	byte	$00, $8c, $07, $f4
'-' 
'-'                             'trailer is done
'-' trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
	byte	$ef, $3b, $73, $fc
'-' 
'-' writecommon                 mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$02, #3       'add quad write command
	byte	$02, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr                 
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-'                             
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   wrclks, clkpin          'start memory clock output 
	byte	$a8, $d7, $23, $fc
'-'                                                          
'-'                             skipf   pattern2                '   B W L Burst FB FW FL RMW
	byte	$32, $8a, $63, $fd
'-'                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
	byte	$e2, $39, $c3, $fc
'-'                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
	byte	$00, $36, $c7, $fc
'-'                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
	byte	$f7, $03, $d8, $fc
'-'                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
	byte	$d9, $39, $c3, $fc
'-'                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
	byte	$32, $8c, $63, $fd
'-'                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
	byte	$e3, $39, $c3, $fc
'-'                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
	byte	$50, $48, $63, $fd
'-'             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
	byte	$59, $52, $63, $0d
'-'  
'-'                             drvh    cspin
	byte	$59, $52, $63, $fd
'-' check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
	byte	$09, $c2, $17, $f4
'-'                             sub     count, c wz             'account for bytes written
	byte	$f1, $b5, $8b, $f1
'-'             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
	byte	$34, $00, $90, $5d
'-'                             wrlut   #0, ptra[8]             'default is not to resume
	byte	$08, $01, $3c, $fc
'-'             if_nc           jmp     #notify                 'if not a request list then we are done
	byte	$3c, $f5, $9f, $3d
'-'                             tjns    addr2, #checklist       'if not extended, check next list entry
	byte	$40, $b7, $bf, $fb
'-'                             djz     total, #donerepeats     'check for repeats remaining
	byte	$3e, $b9, $67, $fb
'-'                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
	byte	$b8, $b9, $b3, $fb
'-'                             mov     d, orighubsize
	byte	$ea, $e5, $03, $f6
'-'                             shl     d, a
	byte	$ef, $e5, $63, $f0
'-'                             sub     c, d
	byte	$f2, $e3, $83, $f1
'-'                             add     c, offset1
	byte	$dd, $e3, $03, $f1
'-'                             mov     count, d                'restore original count
	byte	$f2, $b5, $03, $f6
'-' readmask                    getnib  b, request, #0          'get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 'build mask for addr (in case count=1)
	byte	$f0, $45, $cb, $f9
'-' continue_fill               add     c, addr1                'add bytes to destination address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    'setup bit mask
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                'setup new external memory address
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            execf   lockedfill              'continue next fill operation
	byte	$33, $74, $63, $ad
'-'                             mov     resume, restorefill
	byte	$bb, $d3, $03, $f6
'-'             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
	byte	$00, $b6, $07, $36
'-'             if_nc           call    #yieldfill              'we have to yield now to other COGs
	byte	$80, $fc, $bf, $3d
'-'             if_c            call    #yield
	byte	$6c, $fc, $bf, $cd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-'                            
'-' getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
'-'                       '     rczl    pa                      'rotate left into address offset
'-'                       '     rczl    c wcz                   'restore count and flags
'-'                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
	byte	$03, $e2, $ef, $f7
'-'                             shl     pa, #2
	byte	$02, $ec, $67, $f0
'-'             if_z            setq    #3
	byte	$28, $06, $64, $ad
'-'             if_z            muxq    pa, c
	byte	$f1, $ed, $f3, $a9
'-'                             or      pa, #$1f0               'setup LUT address offset
	byte	$f0, $ed, $47, $f5
'-'            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
	byte	$f6, $ed, $a3, $fa
'-'                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
	byte	$2d, $00, $7c, $fd
'-' 
'-' readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
	byte	$ed, $3b, $83, $fc
'-'                             setword xrecvdata, #2, #0       'read 2x16 words
	byte	$02, $34, $27, $f9
'-'                             mov     clks, #32               '32 read clock transitions
	byte	$20, $d0, $07, $f6
'-'                             mov     pattern, #%110110       'setup read skip pattern
	byte	$36, $d8, $07, $f6
'-'                             jmp     #readcommon             'read then return directly to caller
	byte	$14, $fb, $9f, $fd
'-'                 fit 1024-32
'-'         
'-' 
'-' '..................................................................................................
'-' 
'-'                 fit 1024-32
'-'                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'                 org 1024-32
'-' 
'-' ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
'-'                 long $0000
	byte	$00, $00, $00, $00
'-'                 long $1111
	byte	$11, $11, $00, $00
'-'                 long $2222
	byte	$22, $22, $00, $00
'-'                 long $3333
	byte	$33, $33, $00, $00
'-'                 long $4444
	byte	$44, $44, $00, $00
'-'                 long $5555
	byte	$55, $55, $00, $00
'-'                 long $6666
	byte	$66, $66, $00, $00
'-'                 long $7777
	byte	$77, $77, $00, $00
'-'                 long $8888
	byte	$88, $88, $00, $00
'-'                 long $9999
	byte	$99, $99, $00, $00
'-'                 long $aaaa
	byte	$aa, $aa, $00, $00
'-'                 long $bbbb
	byte	$bb, $bb, $00, $00
'-'                 long $cccc
	byte	$cc, $cc, $00, $00
'-'                 long $dddd
	byte	$dd, $dd, $00, $00
'-'                 long $eeee
	byte	$ee, $ee, $00, $00
'-'                 long $ffff
	byte	$ff, $ff, $00, $00
'-' 
'-' 'masks
'-'                 long $ffffffff ' 00 aligned 0/4 length
	byte	$ff, $ff, $ff, $ff
'-'                 long $000000ff ' 00 aligned 1 length
	byte	$ff, $00, $00, $00
'-'                 long $0000ffff ' 00 aligned 2 length
	byte	$ff, $ff, $00, $00
'-'                 long $00ffffff ' 00 aligned 3 length
	byte	$ff, $ff, $ff, $00
'-' 
'-'                 long $ffffff00 ' 01 aligned 0/4 length
	byte	$00, $ff, $ff, $ff
'-'                 long $0000ff00 ' 01 aligned 1 length
	byte	$00, $ff, $00, $00
'-'                 long $00ffff00 ' 01 aligned 2 length
	byte	$00, $ff, $ff, $00
'-'                 long $ffffff00 ' 01 aligned 3 length
	byte	$00, $ff, $ff, $ff
'-' 
'-'                 long $ffff0000 ' 10 aligned 0/4 length
	byte	$00, $00, $ff, $ff
'-'                 long $00ff0000 ' 10 aligned 1 length
	byte	$00, $00, $ff, $00
'-'                 long $ffff0000 ' 10 aligned 2 length
	byte	$00, $00, $ff, $ff
'-'                 long $ffff0000 ' 10 aligned 3 length
	byte	$00, $00, $ff, $ff
'-' 
'-'                 long $ff000000 ' 11 aligned 0/4 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 1 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 2 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 3 length
	byte	$00, $00, $00, $ff
'-'         fit 1024
'-' 
'-'         fit 1024
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-'         orgh
'-' 
'-' gfxexpansion
'-'                             'simple line drawing graphics expansion of memory driver
'-'                             'jmp     #donerepeats                'just return for now
'-' 
'-'                             cmp     addr1, addr2 wz         'see if we've reached the end
	byte	$db, $b1, $0b, $f2
'-'             if_z            jmp     #donerepeats            'nothing more to draw
	byte	$fb, $02, $80, $ad
'-'                             add     total, #1               'restore total after decrement
	byte	$01, $b8, $07, $f1
'-'                             mov     b, offset1              'get error term
	byte	$dd, $e1, $03, $f6
'-'                             shl     b, #1                   'compute e2 = 2 x error
	byte	$01, $e0, $67, $f0
'-'                             getword d, offset2, #0          'get dx = abs(x0-x1)
	byte	$de, $e5, $33, $f9
'-'                             sar     offset2, #16            'get dy = -abs(y0-y1)
	byte	$10, $bc, $c7, $f0
'-'                             cmps    b, offset2 wc           'compare if e2 >= dy
	byte	$de, $e1, $53, $f2
'-'                             mov     c, #0                   'clear accumulator reg
	byte	$00, $e2, $07, $f6
'-'             if_c            skip    #%1110                  'if not, skip
	byte	$31, $1c, $64, $cd
'-'                             decod   a                       'decode as 1,2,or 4 byte size
	byte	$ef, $df, $c3, $f9
'-'                             add     offset1, offset2        'err+=dy 
	byte	$de, $bb, $03, $f1
'-'                             testb   total, #16 wz           'check sign sx   
	byte	$10, $b8, $0f, $f4
'-'                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
	byte	$ef, $e3, $c3, $f3
'-'                             cmps    d, b wc                 'compare if e2 <= dx
	byte	$f0, $e5, $53, $f2
'-'             if_c            skip    #%11110                 'if not, skip
	byte	$31, $3c, $64, $cd
'-'                             rolword offset2, d, #0          'restore offset
	byte	$f2, $bd, $43, $f9
'-'                             add     offset1, d              'err+=dx
	byte	$f2, $bb, $03, $f1
'-'                             testb   total, #17 wz           'check sign sy
	byte	$11, $b8, $0f, $f4
'-'                             getword d, total, #0            'get line width
	byte	$dc, $e5, $33, $f9
'-'                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
	byte	$f2, $e3, $c3, $f3
'-'                             encod   a wc                    'restore size and set carry
	byte	$ef, $df, $93, $f7
'-'                             mov     count, orighubsize      'reset the fill width
	byte	$ea, $b5, $03, $f6
'-'                             shl     count, a                '..for the type of transfer
	byte	$ef, $b5, $63, $f0
'-'                             jmp     #readmask               'continue filling
	byte	$c3, $03, $80, $fd
	alignl
__system__dat_
	byte	$00[8]
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[24]
	byte	$05, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
	long	(8 {__system___tx})<<20
	long	(9 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(10 {__system___rxtxioctl_0142})<<20
	long	(11 {__system____dummy_flush_0143})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(8 {__system___tx})<<20
	long	(9 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(10 {__system___rxtxioctl_0142})<<20
	long	(11 {__system____dummy_flush_0143})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(8 {__system___tx})<<20
	long	(9 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(10 {__system___rxtxioctl_0142})<<20
	long	(11 {__system____dummy_flush_0143})<<20
	byte	$00[368]
__methodtable__
	long	@__struct___bas_wrap_sender_tx
	long	@__struct___bas_wrap_sender_rx
	long	@__struct___bas_wrap_sender_close
	long	@__struct__s_vfs_file_t_putchar
	long	@__struct__s_vfs_file_t_getchar
	long	@__system____default_putc
	long	@__system____default_getc
	long	@__system____default_flush
	long	@__system___tx
	long	@__system___rx
	long	@__system___rxtxioctl_0142
	long	@__system____dummy_flush_0143
objmem
	long	0[131]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
_var03
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
arg05
	res	1
arg06
	res	1
local01
	res	1
local02
	res	1
local03
	res	1
local04
	res	1
local05
	res	1
local06
	res	1
local07
	res	1
local08
	res	1
local09
	res	1
local10
	res	1
local11
	res	1
local12
	res	1
local13
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	480
