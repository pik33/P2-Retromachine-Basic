00000                 | 
00000                 | #line 1 "D:/Programowanie/P2-Retromachine-Basic/audio095-8-sc.p2asm"
00000                 | con
00000                 | 	_clkfreq = 20000000
00000                 | 	_clkmode = 16779595
00000                 | ' 
00000                 | ' 
00000                 | ' left= 14
00000                 | 	left = 14
00000                 | ' right=15
00000                 | 	right = 15
00000                 | ' 
00000                 | ' c4=262
00000                 | 	c4 = 262
00000                 | ' d4=294
00000                 | 	d4 = 294
00000                 | ' e4=330
00000                 | 	e4 = 330
00000                 | ' f4=349
00000                 | 	f4 = 349
00000                 | ' g4=392
00000                 | 	g4 = 392
00000                 | ' a4=440
00000                 | 	a4 = 440
00000                 | ' h4=494
00000                 | 	h4 = 494
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 20000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $100094b
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 7A 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 02 90 5D |  if_ne	jmp	#spininit
0040c 002 BC F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 01 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 04 80 80 FF 
00420 007 00 90 66 FD | 	hubset	##16779592
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 04 80 00 FF 
00430 00b 4B ED 07 F6 | 	mov	pa, ##16779595
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 96 98 80 FF 
00440 00f 14 00 6E FC | 	wrlong	##20000000, #20
00444 010 BC 01 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
005fc 07e 00 00 00 00 
00600 07f 00 00 00 00 | 	orgf	128
00604 080             | skip_clock_set_
00604 080 00 07 A0 FD | 	call	#_start
00608 081             | cogexit
00608 081 38 01 80 FF 
0060c 082 1F 00 66 FD | 	waitx	##160000
00610 083 01 84 61 FD | 	cogid	arg01
00614 084 03 84 61 FD | 	cogstop	arg01
00618 085             | spininit
00618 085 61 75 05 FB | 	rdlong	objptr, ptra++
0061c 086 61 7B 05 FB | 	rdlong	result1, ptra++
00620 087 28 06 64 FD | 	setq	#3
00624 088 00 85 05 FB | 	rdlong	arg01, ptra
00628 089 04 F0 87 F1 | 	sub	ptra, #4
0062c 08a 2D 7A 61 FD | 	call	result1
00630 08b D4 FF 9F FD | 	jmp	#cogexit
00634 08c             | FCACHE_LOAD_
00634 08c F9 2D 01 F6 |     mov	fcache_tmpb_,ptrb
00638 08d 2B F2 63 FD |     pop	ptrb
0063c 08e 95 EC 8B F9 |     altd	pa,ret_instr_
00640 08f 95 00 00 F6 |     mov	 0-0, ret_instr_
00644 090 28 EC 63 FD |     setq	pa
00648 091 E1 01 04 FB |     rdlong	$0, ptrb++
0064c 092 2A F2 63 FD |     push	ptrb
00650 093 96 F2 03 F6 |     mov ptrb,fcache_tmpb_
00654 094 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00658 095             | ret_instr_
00658 095 00 FE 07 02 |     _ret_ cmp inb,#0
0065c 096             | fcache_tmpb_
0065c 096 00 00 00 00 |     long 0
00660 097             | fcache_load_ptr_
00660 097 8C 00 00 00 |     long FCACHE_LOAD_
00664 098             | builtin_bytefill_
00664 098 01 88 55 F0 |         shr	arg03, #1 wc
00668 099 C2 86 41 CC |  if_c   wrbyte	arg02, arg01
0066c 09a 01 84 05 C1 |  if_c   add	arg01, #1
00670 09b 00 86 FD F9 |         movbyts	arg02, #0
00674 09c             | builtin_wordfill_
00674 09c 01 88 55 F0 |         shr	arg03, #1 wc
00678 09d C2 86 51 CC |  if_c   wrword	arg02, arg01
0067c 09e 02 84 05 C1 |  if_c   add	arg01, #2
00680 09f C3 86 29 F9 |         setword	arg02, arg02, #1
00684 0a0             | builtin_longfill_
00684 0a0 C2 00 88 FC |         wrfast	#0,arg01
00688 0a1 00 88 0D F2 |         cmp	arg03, #0 wz
0068c 0a2 C4 02 D8 5C |  if_nz  rep	#1, arg03
00690 0a3 17 86 61 5D |  if_nz  wflong	arg02
00694 0a4 2D 00 64 FD |         ret
00698 0a5             | COUNT_
00698 0a5 00 00 00 00 |     long 0
0069c 0a6             | RETADDR_
0069c 0a6 00 00 00 00 |     long 0
006a0 0a7             | fp
006a0 0a7 00 00 00 00 |     long 0
006a4 0a8             | pushregs_
006a4 0a8 2B EC 63 FD |     pop  pa
006a8 0a9 2B 4C 61 FD |     pop  RETADDR_
006ac 0aa 03 4A 95 FB |     tjz  COUNT_, #pushregs_done_
006b0 0ab FF 4B 8D F9 |     altd  COUNT_, #511
006b4 0ac 28 00 64 FD |     setq #0-0
006b8 0ad 61 8D 65 FC |     wrlong local01, ptra++
006bc 0ae             | pushregs_done_
006bc 0ae 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
006c0 0af 61 4B 65 FC |     wrlong COUNT_, ptra++
006c4 0b0 F8 4F 01 F6 |     mov    fp, ptra
006c8 0b1 2C EC 63 FD |     jmp  pa
006cc 0b2             |  popregs_
006cc 0b2 2B EC 63 FD |     pop    pa
006d0 0b3 28 04 64 FD |     setq   #2
006d4 0b4 5F 4B 05 FB |     rdlong COUNT_, --ptra
006d8 0b5 02 4A 75 FB |     djf    COUNT_, #popregs__ret
006dc 0b6 28 4A 61 FD |     setq   COUNT_
006e0 0b7 5F 8D 05 FB |     rdlong local01, --ptra
006e4 0b8             | popregs__ret
006e4 0b8 2A 4C 61 FD |     push   RETADDR_
006e8 0b9 2C EC 63 FD |     jmp    pa
006ec 0ba             | 
006ec 0ba             | objptr
006ec 0ba E0 0D 00 00 | 	long	@objmem
006f0 0bb             | ptr__dat__
006f0 0bb 48 09 00 00 | 	long	@_dat_
006f4 0bc             | ptr_stackspace_
006f4 0bc EC 0F 00 00 | 	long	@stackspace
006f8 0bd             | result1
006f8 0bd 00 00 00 00 | 	long	0
006fc 0be             | result2
006fc 0be 01 00 00 00 | 	long	1
00700 0bf             | COG_BSS_START
00700 0bf             | 	fit	480
00700                 | 	orgh
00700                 | hubentry
00700                 | 
00700                 | ' 
00700                 | ' 
00700                 | ' '--------------------------------------------------------------
00700                 | ' '---------- Init the variables, start the cog. ----------------
00700                 | ' '--------------------------------------------------------------
00700                 | ' 
00700                 | ' pub start(mbox,scope,cache) :cog,base | iii
00700                 | _start
00700     04 4A 05 F6 | 	mov	COUNT_, #4
00704     A8 00 A0 FD | 	call	#pushregs_
00708     C2 8C 01 F6 | 	mov	local01, arg01
0070c                 | ' 
0070c                 | ' ' mbox: PSRAM mailbox or 0 if no PSRAM
0070c                 | ' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
0070c                 | ' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
0070c                 | ' 
0070c                 | ' mailboxaddr:=mbox 
0070c     BA 8C 61 FC | 	wrlong	local01, objptr
00710                 | ' scope_ptr:=scope
00710     04 74 05 F1 | 	add	objptr, #4
00714     BA 86 61 FC | 	wrlong	arg02, objptr
00718                 | ' cache_ptr:=cache
00718     04 74 05 F1 | 	add	objptr, #4
0071c     BA 88 61 FC | 	wrlong	arg03, objptr
00720                 | ' base:=@channel1[0]
00720     04 74 05 F1 | 	add	objptr, #4
00724     BA 8E 01 F6 | 	mov	local02, objptr
00728                 | ' 
00728                 | ' repeat iii from 0 to 7
00728     00 90 05 F6 | 	mov	local03, #0
0072c     02 00 00 FF 
00730     90 76 05 F1 | 	add	ptr__dat__, ##1168
00734     0C 74 85 F1 | 	sub	objptr, #12
00738     97 B0 48 FB | 	callpa	#(@LR__0002-@LR__0001)>>2,fcache_load_ptr_
0073c                 | LR__0001
0073c                 | '   long[base+64*iii]:=0
0073c     C7 8C 01 F6 | 	mov	local01, local02
00740     C8 7C 01 F6 | 	mov	result2, local03
00744     06 7C 65 F0 | 	shl	result2, #6
00748     BE 8C 01 F1 | 	add	local01, result2
0074c     C6 00 68 FC | 	wrlong	#0, local01
00750                 | '   long[base+64*iii+4]:=0
00750     C7 8C 01 F6 | 	mov	local01, local02
00754     C8 7C 01 F6 | 	mov	result2, local03
00758     06 7C 65 F0 | 	shl	result2, #6
0075c     BE 8C 01 F1 | 	add	local01, result2
00760     04 8C 05 F1 | 	add	local01, #4
00764     C6 00 68 FC | 	wrlong	#0, local01
00768                 | '   long[base+64*iii+12]:=0
00768     C7 92 01 F6 | 	mov	local04, local02
0076c     C8 8C 01 F6 | 	mov	local01, local03
00770     06 8C 65 F0 | 	shl	local01, #6
00774     C6 92 01 F1 | 	add	local04, local01
00778     0C 92 05 F1 | 	add	local04, #12
0077c     C9 00 68 FC | 	wrlong	#0, local04
00780                 | '   long[base+64*iii+16]:=2 
00780     C7 92 01 F6 | 	mov	local04, local02
00784     C8 8C 01 F6 | 	mov	local01, local03
00788     06 8C 65 F0 | 	shl	local01, #6
0078c     C6 92 01 F1 | 	add	local04, local01
00790     10 92 05 F1 | 	add	local04, #16
00794     C9 04 68 FC | 	wrlong	#2, local04
00798                 | '   word[base+64*iii+20]:=0
00798     C7 92 01 F6 | 	mov	local04, local02
0079c     C8 8C 01 F6 | 	mov	local01, local03
007a0     06 8C 65 F0 | 	shl	local01, #6
007a4     C6 92 01 F1 | 	add	local04, local01
007a8     14 92 05 F1 | 	add	local04, #20
007ac     C9 00 58 FC | 	wrword	#0, local04
007b0                 | '   word[base+64*iii+22]:=8192
007b0     C7 92 01 F6 | 	mov	local04, local02
007b4     C8 8C 01 F6 | 	mov	local01, local03
007b8     06 8C 65 F0 | 	shl	local01, #6
007bc     C6 92 01 F1 | 	add	local04, local01
007c0     16 92 05 F1 | 	add	local04, #22
007c4     10 00 80 FF 
007c8     C9 00 58 FC | 	wrword	##8192, local04
007cc                 | '   word[base+64*iii+24]:=4000+2*iii
007cc     C8 92 01 F6 | 	mov	local04, local03
007d0     01 92 65 F0 | 	shl	local04, #1
007d4     07 00 00 FF 
007d8     A0 8D 05 F6 | 	mov	local01, ##4000
007dc     C9 8C 01 F1 | 	add	local01, local04
007e0     C7 92 01 F6 | 	mov	local04, local02
007e4     C8 7C 01 F6 | 	mov	result2, local03
007e8     06 7C 65 F0 | 	shl	result2, #6
007ec     BE 92 01 F1 | 	add	local04, result2
007f0     18 92 05 F1 | 	add	local04, #24
007f4     C9 8C 51 FC | 	wrword	local01, local04
007f8                 | '   word[base+64*iii+26]:=2
007f8     C7 92 01 F6 | 	mov	local04, local02
007fc     C8 8C 01 F6 | 	mov	local01, local03
00800     06 8C 65 F0 | 	shl	local01, #6
00804     C6 92 01 F1 | 	add	local04, local01
00808     1A 92 05 F1 | 	add	local04, #26
0080c     C9 04 58 FC | 	wrword	#2, local04
00810                 | '   long [base+64*iii+8]:=@null | $C0000000
00810     BB 8C 01 F6 | 	mov	local01, ptr__dat__
00814     3E 8C 25 F4 | 	bith	local01, #62
00818     C7 92 01 F6 | 	mov	local04, local02
0081c     C8 88 01 F6 | 	mov	arg03, local03
00820     06 88 65 F0 | 	shl	arg03, #6
00824     C4 92 01 F1 | 	add	local04, arg03
00828     08 92 05 F1 | 	add	local04, #8
0082c     C9 8C 61 FC | 	wrlong	local01, local04
00830                 | '   long[base+64*iii+32]:=0
00830     C7 92 01 F6 | 	mov	local04, local02
00834     C8 8C 01 F6 | 	mov	local01, local03
00838     06 8C 65 F0 | 	shl	local01, #6
0083c     C6 92 01 F1 | 	add	local04, local01
00840     20 92 05 F1 | 	add	local04, #32
00844     C9 00 68 FC | 	wrlong	#0, local04
00848                 | '   long[base+64*iii+36]:=0
00848     C7 92 01 F6 | 	mov	local04, local02
0084c     C8 8C 01 F6 | 	mov	local01, local03
00850     06 8C 65 F0 | 	shl	local01, #6
00854     C6 92 01 F1 | 	add	local04, local01
00858     24 92 05 F1 | 	add	local04, #36
0085c     C9 00 68 FC | 	wrlong	#0, local04
00860                 | '   long[base+64*iii+40]:=0
00860     C7 92 01 F6 | 	mov	local04, local02
00864     C8 8C 01 F6 | 	mov	local01, local03
00868     06 8C 65 F0 | 	shl	local01, #6
0086c     C6 92 01 F1 | 	add	local04, local01
00870     28 92 05 F1 | 	add	local04, #40
00874     C9 00 68 FC | 	wrlong	#0, local04
00878                 | '   long[base+64*iii+44]:=0
00878     C7 92 01 F6 | 	mov	local04, local02
0087c     C8 8C 01 F6 | 	mov	local01, local03
00880     06 8C 65 F0 | 	shl	local01, #6
00884     C6 92 01 F1 | 	add	local04, local01
00888     2C 92 05 F1 | 	add	local04, #44
0088c     C9 00 68 FC | 	wrlong	#0, local04
00890     01 90 05 F1 | 	add	local03, #1
00894     08 90 55 F2 | 	cmps	local03, #8 wc
00898     A0 FE 9F CD |  if_b	jmp	#LR__0001
0089c                 | LR__0002
0089c     02 00 00 FF 
008a0     90 76 85 F1 | 	sub	ptr__dat__, ##1168
008a4                 | '   
008a4                 | ' cog:=coginit(16,@audio,@mailboxaddr)
008a4     BB 86 01 F6 | 	mov	arg02, ptr__dat__
008a8     BA 88 01 F6 | 	mov	arg03, objptr
008ac     10 92 05 F6 | 	mov	local04, #16
008b0     28 88 61 FD | 	setq	arg03
008b4     C3 92 F1 FC | 	coginit	local04, arg02 wc
008b8     01 92 65 C6 |  if_b	neg	local04, #1
008bc                 | ' waitms(100)
008bc     64 84 05 F6 | 	mov	arg01, #100
008c0     18 00 B0 FD | 	call	#__system___waitms
008c4                 | ' return cog,base
008c4     C7 7C 01 F6 | 	mov	result2, local02
008c8     C9 7A 01 F6 | 	mov	result1, local04
008cc     A7 F0 03 F6 | 	mov	ptra, fp
008d0     B2 00 A0 FD | 	call	#popregs_
008d4                 | _start_ret
008d4     2D 00 64 FD | 	ret
008d8                 | hubexit
008d8     81 00 80 FD | 	jmp	#cogexit
008dc                 | 
008dc                 | __system___waitms
008dc     C2 7E 01 F6 | 	mov	_var01, arg01
008e0     1A 80 61 FD | 	getct	_var02
008e4     14 82 05 FB | 	rdlong	_var03, #20
008e8     97 14 48 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
008ec                 | LR__0010
008ec     01 00 00 FF 
008f0     E8 7F 55 F2 | 	cmps	_var01, ##1000 wc
008f4     1C 00 90 CD |  if_b	jmp	#LR__0012
008f8     C1 80 01 F1 | 	add	_var02, _var03
008fc     C0 84 01 F6 | 	mov	arg01, _var02
00900     00 84 65 FA | 	addct1	arg01, #0
00904     24 22 60 FD | 	waitct1
00908     01 00 00 FF 
0090c     E8 7F 85 F1 | 	sub	_var01, ##1000
00910     D8 FF 9F FD | 	jmp	#LR__0010
00914                 | LR__0011
00914                 | LR__0012
00914     01 7E 55 F2 | 	cmps	_var01, #1 wc
00918     28 00 90 CD |  if_b	jmp	#LR__0013
0091c     C1 7E 01 FD | 	qmul	_var01, _var03
00920     01 00 00 FF 
00924     E8 89 05 F6 | 	mov	arg03, ##1000
00928     19 7A 61 FD | 	getqy	result1
0092c     18 84 61 FD | 	getqx	arg01
00930     28 7A 61 FD | 	setq	result1
00934     C4 84 11 FD | 	qdiv	arg01, arg03
00938     18 84 61 FD | 	getqx	arg01
0093c     C0 84 61 FA | 	addct1	arg01, _var02
00940     24 22 60 FD | 	waitct1
00944                 | LR__0013
00944                 | __system___waitms_ret
00944     2D 00 64 FD | 	ret
00948                 | 	alignl
00948                 | _dat_
00948                 | 
00948                 | audio       org     0
00948                 | 
00948     61 C7 05 FB |             rdlong  mailbox2, ptra++     ' get start address of all mailboxes
0094c     61 15 06 FB |             rdlong  scbase, ptra++       ' get start address of scope buffer
00950     61 21 06 FB |             rdlong  hubptr, ptra++       ' get start address of PSRAM cache
00954                 | 
00954     01 EC 63 FD |             cogid   pa                   ' compute cogid
00958     0C EC 07 FA |             mul     pa, #12              ' and mailbox spacing
0095c     F6 C7 01 F1 |             add     mailbox2, pa         ' add offset to find this COG's mailbox
00960     E3 C4 01 F6 |             mov     mailbox,mailbox2     ' we need 2 copies of this to ensble switching between hub and psram
00964                 | 
00964     00 F2 07 F6 |             mov     ptrb,#0              ' A tail pointer for the buffer
00968     0E 1C 06 FC |             wrpin   dac,#left            ' Noise dither DACs at clk/95
0096c     0E BE 1C FC |             wxpin   #95,#left       	 ' Set initial DACs sample rate. It is now controlled via a register by the main program
00970     0F 1C 06 FC |             wrpin   dac,#right
00974     0F BE 1C FC |             wxpin   #95,#right    
00978     41 9C 64 FD |             dirh    #left addpins 1
0097c     20 9C 64 FD |             setse1  #%001<<6 + left      ' Set the event - DAC empty
00980     CA E8 07 F6 |             mov     ijmp1,#isr1          ' Init the interrupt
00984     25 08 64 FD |             setint1 #4                   ' Interrupt from DAC empty event
00988                 |             
00988                 | '---------------------------------------------------------------------------------        
00988                 | '----------------- The main loop -------------------------------------------------
00988                 | '---------------------------------------------------------------------------------
00988                 | 
00988     D3 A8 11 F2 | loop        cmp     time0,a41000000 wc  ' time counter overflow protection
0098c     10 00 90 CD |       if_c  jmp     #loop1
00990                 |   
00990     09 FA 05 F6 |             mov     cn,#9               ' Substract $40000000 from all the channel times and the main timer
00994     D3 FA 8D F9 | p402        altd    cn,#a41000000       ' this has to be done at once for all channels
00998     D2 00 80 F1 |             sub     0-0,a40000000
0099c     FD FB 6D FB |             djnz    cn,#p402
009a0                 |     
009a0     00 FA 05 F6 | loop1       mov     cn,#0               ' Find the channel to compute
009a4     D5 FC 01 F6 |             mov     ct,time1            ' with the lowest next sample time
009a8     D6 FC 39 F3 |             fle     ct,time2 wcz        ' How to size-optimize this???
009ac     01 FA 05 C6 |     if_c    mov     cn,#1
009b0     D7 FC 39 F3 |             fle     ct,time3 wcz
009b4     02 FA 05 C6 |     if_c    mov     cn,#2     
009b8     D8 FC 39 F3 |             fle     ct,time4 wcz
009bc     03 FA 05 C6 |     if_c    mov     cn,#3
009c0     D9 FC 39 F3 |             fle     ct,time5 wcz
009c4     04 FA 05 C6 |     if_c    mov     cn,#4
009c8     DA FC 39 F3 |             fle     ct,time6 wcz
009cc     05 FA 05 C6 |     if_c    mov     cn,#5
009d0     DB FC 39 F3 |             fle     ct,time7 wcz
009d4     06 FA 05 C6 |     if_c    mov     cn,#6
009d8     DC FC 39 F3 |             fle     ct,time8 wcz
009dc     07 FA 05 C6 |     if_c    mov     cn,#7
009e0                 | 
009e0                 | 
009e0                 | '----------------------------------------------------------------------------------
009e0                 | '------------- Compute channel samples --------------------------------------------
009e0                 | '----------------------------------------------------------------------------------
009e0                 | 
009e0                 | 
009e0     FD BA 01 F6 | p401        mov     channeladd,cn             ' compute the pointer to channel parameters block
009e4     06 BA 65 F0 |             shl     channeladd,#6
009e8     DD F0 03 F1 |             add     ptra,channeladd
009ec                 | 
009ec     28 16 64 FD |             setq    #11                        ' read parameters
009f0     00 D1 05 FB |             rdlong  pointer0,ptra
009f4                 |     	    
009f4     1F DE 0D F4 | p408        testb   command0,#31 wz	      ' bit #31 command - set the DAC sample rate
009f8     18 00 90 5D |     if_nz   jmp     #p404                     ' if not set, proceed
009fc     EF BE 31 F9 |             getword qq,command0,#0            ' get the new rate
00a00     4E BE 15 FC |             wxpin   qq,#left addpins 1        ' and program the pins
00a04     DF BE E1 F8 |             getbyte qq,qq,#0 		      ' check if the rate is n*256
00a08     00 BE 0D F2 |             cmp     qq,#0 wz                         
00a0c     4E 1E 06 AC |     if_z    wrpin   dac2,#left addpins 1      ' if yes, set PWM DAC mode
00a10     4E 1C 06 5C |     if_nz   wrpin   dac,#left addpins 1       ' else set noise DAC mode
00a14                 |             
00a14     1E DE 1D F4 | p404        bitl    command0,#30 wcz             ' bit #30: select PSRAM/HUB
00a18     E3 C4 01 56 |     if_nz   mov     mailbox,mailbox2             ' if not set, use PSRAM
00a1c     00 C4 05 A6 |     if_z    mov     mailbox,#0                   ' if set, use HUB : TODO: this can be done at a channel level!
00a20                 | 
00a20                 | 
00a20     E9 00 32 F9 | p405        getword oldls,sample0,#0          ' extract old sample value
00a24     E9 02 3A F9 |             getword oldrs,sample0,#1
00a28     ED F6 39 F9 |      	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
00a2c     ED F4 31 F9 |     	    getword avol0,volpan0,#0
00a30     EE F2 39 F9 |             getword askip0,freqskip0,#1    	    
00a34     EE F0 31 F9 |             getword afreq0,freqskip0,#0
00a38                 | 
00a38     D5 FA 95 F9 |             alts    cn, #time1                ' compute the time difference between this and previous sample
00a3c     00 FE 01 F6 |             mov     dt0,0-0    
00a40     D4 FE 81 F1 |             sub     dt0,time0
00a44                 |             
00a44     D5 FA 8D F9 |             altd    cn, #time1                ' add channel period to channel time
00a48     F8 00 00 F1 |             add     0-0,afreq0  	
00a4c                 |             
00a4c                 | '---- envelopes
00a4c                 |             
00a4c     00 E2 1D F2 |             cmp     envptr0,#0 wcz    		' read the pointer
00a50     20 00 00 AF 
00a54     00 42 06 A6 |     if_z    mov     envs1,##$4000		' if 0, no envelope, load $4000=1 for scas
00a58     5C 00 90 AD |     if_z    jmp     #p410			' and run away	
00a5c                 | 
00a5c     F8 42 02 F6 |             mov envs1,afreq0
00a60     F2 42 02 FA |             mul envs1,envspd0
00a64     21 E1 01 F1 |             add envph0,envs1 
00a68                 | 
00a68     F0 3E 02 F6 |       	    mov     envhi, envph0		' move phase acc to high part of env pointer
00a6c     06 3E 46 F0 | 	    shr     envhi,#6			' leave 10 bits in hi
00a70     1F 41 32 F9 | 	    getword envlo,envhi,#0              ' and 16 bit in lo
00a74     10 3E 46 F0 | 	    shr     envhi,#16			' move 10 bits of hi to the lower word
00a78     F3 3E 1A F2 | 	    cmp     envhi,envlen0 wcz		' compare this to envelope length
00a7c     F3 3E 02 36 |     if_ge   mov     envhi,envlen0		' if greater than, set it at envlen
00a80     00 40 06 36 |     if_ge   mov     envlo,#0
00a84     F3 E0 01 36 |     if_ge   mov     envph0,envlen0
00a88     16 E0 65 30 |     if_ge   shl     envph0,#22
00a8c                 | 
00a8c     1F 43 02 F6 |             mov envs1,envhi
00a90     01 42 66 F0 |             shl envs1,#1
00a94     F1 42 02 F1 |             add envs1,envptr0
00a98     21 43 02 FB |             rdlong envs1,envs1
00a9c     21 45 3A F9 |             getword envs2,envs1,#1
00aa0     21 43 32 F9 |             getword envs1,envs1,#0
00aa4     20 45 02 FA |             mul envs2,envlo
00aa8     20 41 22 F6 |             not envlo
00aac     20 43 02 FA |             mul envs1,envlo
00ab0     22 43 02 F1 |             add envs1,envs2
00ab4     12 42 46 F0 |             shr envs1,#18
00ab8                 |             
00ab8                 | 
00ab8                 | 
00ab8     1B D4 0D F4 | p410        testb   sstart0, #27 wz
00abc     1B C0 61 AD |     if_z    getrnd  spl
00ac0     58 00 90 AD |     if_z    jmp     #p406
00ac4                 |  
00ac4     F9 D0 01 F1 |             add     pointer0,askip0           ' compute the pointer to the next sample       
00ac8     E8 3C C2 F8 |             setbyte pointer00,pointer0,#0
00acc     08 D0 45 F0 |             shr     pointer0,#8
00ad0                 |          
00ad0     1F D4 0D F4 |             testb   sstart0,#31 wz            
00ad4     01 D0 65 A0 |     if_z    shl     pointer0,#1        
00ad8     1C D4 0D F4 |             testb   sstart0,#28 wz            
00adc     01 D0 65 A0 |     if_z    shl     pointer0,#1        
00ae0                 |         
00ae0     EC D0 19 F2 |             cmp     pointer0,lend0 wcz
00ae4     EC D0 81 31 |     if_ge   sub     pointer0,lend0	      ' and loop if needed     
00ae8     EB D0 01 31 |     if_ge   add     pointer0,lstart0       
00aec                 |             
00aec     E8 BE 01 F6 |             mov     qq,pointer0               ' compute place in the memory from where the sample will be loaded
00af0     EA BE 01 F1 |             add     qq,sstart0            
00af4                 | 
00af4                 | 
00af4                 | 
00af4     FF C5 5D F2 |             cmps    mailbox,#$1FF wcz            ' the mailbox has to point somewhere not at the start of HUB RAM
00af8     DF C0 E1 EA |     if_le   rdword  spl,qq                     ' if not, use HUB RAM for samples
00afc     10 01 B0 1D |     if_gt   call    #cache_read
00b00                 |          
00b00                 |          
00b00                 |  
00b00                 |          
00b00     1F D4 0D F4 |             testb   sstart0,#31 wz 
00b04     08 C0 65 50 |     if_nz   shl     spl,#8
00b08     08 D0 65 50 |     if_nz   shl     pointer0,#8
00b0c     07 D0 65 A0 |     if_z    shl     pointer0,#7
00b10     1C D4 0D F4 |             testb   sstart0,#28 wz            
00b14     01 D0 45 A0 |     if_z    shr     pointer0,#1    
00b18     1E D1 C1 F8 | 	    setbyte pointer0,pointer00,#0       
00b1c                 | 
00b1c                 | 
00b1c                 | p406      '  scas    spl,envs1
00b1c                 |           '  mov     spl,0-0
00b1c     FA C0 31 FA |             scas    spl,avol0                 ' apply volume
00b20     00 C0 01 F6 |             mov     spl,0-0
00b24                 | 
00b24     FB C0 31 FA |             scas    spl,apan0                 ' apply pan
00b28     00 04 02 F6 |             mov     ls0,0-0
00b2c     20 00 00 FF 
00b30     00 BE 05 F6 |             mov     qq,##16384
00b34     FB BE 81 F1 |             sub     qq,apan0
00b38     DF C0 31 FA |             scas    spl,qq
00b3c     00 06 02 F6 |             mov     rs0, 0-0
00b40                 | 
00b40     01 0B 82 F1 |             sub     rs,oldrs 		      ' replace the old sample with the new one in the mix
00b44     03 0B 02 F1 |             add     rs,rs0
00b48     00 09 82 F1 |             sub     ls,oldls
00b4c     02 09 02 F1 |             add     ls,ls0
00b50                 |    
00b50     03 D3 29 F9 |             setword sample0,rs0,#1           ' pack samples into long
00b54     02 D3 21 F9 |             setword sample0,ls0,#0
00b58                 |             
00b58     1E D4 1D F4 |             bitl    sstart0, #30 wcz          ' if bit #30 of start pointer is set, the current pointers needs resetting  
00b5c     00 D0 05 A6 |     if_z    mov     pointer0, #0  
00b60     00 E0 05 A6 |     if_z    mov     envph0, #0  
00b64     00 D2 05 A6 |     if_z    mov     sample0,#0
00b68     02 D5 65 AC |     if_z    wrlong  sstart0, ptra[2]          ' reset bit #30 in hub
00b6c     1D D4 1D F4 |             bitl    sstart0, #29 wcz	      ' if bit #29 is set, synchronize stereo at channels 1 and 2
00b70     04 00 00 AF 
00b74     00 AA 05 A1 |     if_z    add     time1,##2048
00b78     D5 AC 01 A6 |     if_z    mov     time2,time1
00b7c     02 D5 65 AC |     if_z    wrlong  sstart0,ptra[2]
00b80                 | 
00b80                 |             
00b80     28 02 64 FD | p403        setq #1                          ' write new pointer and sample value to the hub
00b84     00 D1 65 FC |             wrlong  pointer0,ptra
00b88     08 E1 65 FC |             wrlong  envph0,ptra[8]
00b8c     DD F0 83 F1 |             sub     ptra, channeladd         ' reset the pointer to channel parameters
00b90                 |                       
00b90     D4 F8 09 F2 |             cmp     oldt0,time0 wz           ' If more than 1 sample is computed at the same time, write only the last result
00b94     FF BD 25 A7 |     if_z    decmod  front, #511          
00b98                 |          
00b98     04 01 32 F9 |             getword oldls,ls,#0              ' reuse oldls variable to convert the sample to unsigned
00b9c     05 03 32 F9 |  	    getword oldrs,rs,#0              ' getword instead of mov makes the upper bits=0
00ba0     0F 00 E6 F4 |             bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
00ba4     0F 02 E6 F4 |             bitnot  oldrs,#15		     ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
00ba8                 | 	    
00ba8                 | 		    
00ba8     00 03 2A F9 |             setword oldrs,oldls,#1           ' Pack L and R to one long    		
00bac     07 0D 02 F6 |             mov     oldsample, newsample     ' The new computed sample will be outputted in the next loop, now we have to fill the buffer with the old one
00bb0     01 0F 02 F6 |             mov     newsample, oldrs       
00bb4                 | 
00bb4     D4 F8 01 F6 |             mov     oldt0,time0              ' update global time
00bb8     FF A8 01 F1 |             add     time0,dt0    
00bbc                 |                                      
00bbc     00 FE 0D F2 |             cmp     dt0,#0 wz                ' now push dt0 samples to the buffer
00bc0     DC FD 9F AD |     if_z    jmp     #loop1
00bc4     FF BE 01 F6 |             mov     qq,dt0
00bc8                 |   
00bc8     FF F3 97 F9 | p301        alts    ptrb,#511                ' checking if the buffer is full - Wuerfel_21's magic stuff
00bcc     00 BC 9D F2 |             cmpr    front, #0-0 wcz
00bd0     F4 FF 9F AD |     if_e    jmp     #p301    
00bd4                 | 		
00bd4     00 14 0E F2 | 	    cmp     scbase,#0 wz
00bd8     20 00 90 AD |     if_z    jmp #p302	   
00bdc                 |  
00bdc                 |  
00bdc     3F 1A 16 F7 |             incmod  scope,#63 wc            ' save every 127th sample to the scope buffer
00be0     0B 19 02 C6 |     if_c    mov scptr2,scptr
00be4     02 18 66 C0 |     if_c    shl scptr2,#2
00be8     0A 19 02 C1 |     if_c    add scptr2,scbase     
00bec     60 18 66 FC |             wrlong scptr2,#$60
00bf0     0C 0D 62 CC |     if_c    wrlong oldsample,scptr2
00bf4     01 00 00 CF 
00bf8     7F 16 06 C7 |     if_c    incmod scptr,##639
00bfc                 | 			    
00bfc     DE 0C 32 FC | p302        wrlut   oldsample, front        ' if there is a free slot, put the sample into the buffer
00c00     00 00 00 FF 
00c04     FF BD 05 F7 |             incmod  front, ##511
00c08     EF BF 6D FB |             djnz    qq,#p301
00c0c                 |             
00c0c     78 FD 9F FD |             jmp     #loop            'loop
00c10                 | 
00c10                 | '----------------------------------------------------------------------------------
00c10                 | '------------- This is the end of the main loop -----------------------------------
00c10                 | '----------------------------------------------------------------------------------
00c10                 | 
00c10                 | '----------------------------------------------------------------------------------
00c10                 | '------------- PSRAM cache ----------- --------------------------------------------
00c10                 | '----------------------------------------------------------------------------------
00c10                 | 
00c10                 | ' There are 8 cache pointers for 8 channels
00c10                 | ' if 24 higher bits of address=cache, then get a word from the cache
00c10                 | ' else load the cache from PSRAM, update the pointer, then read a sample
00c10                 | 
00c10                 | 
00c10     DF 38 E2 F8 | cache_read  getbyte addrlo,qq,#0 		' when this is called, qq is the addres of the sample			
00c14                 |             
00c14     DF 3A 02 F6 | 	    mov     addrhi,qq		
00c18     08 3A 46 F0 | 	    shr     addrhi,#8		        ' get 24 upper bits
00c1c     11 FB 95 F9 | 	    alts    cn,#cache1            
00c20     00 3A 0A F2 | 	    cmp	    addrhi,0-0 wz               ' and compare with the cache pointer for the channel
00c24     34 00 90 AD |     if_z    jmp     #p701	    		' if equal, cache hit, read the sample from it
00c28                 | 	
00c28     11 FB 8D F9 | p702	    altd    cn,#cache1			' cache miss. 
00c2c     1D 01 00 F6 | 	    mov     0-0,addrhi                  ' update the pointer
00c30     1D 33 02 F6 | 	    mov     cmd,addrhi			' prepare the mailbox
00c34     08 32 66 F0 | 	    shl     cmd,#8
00c38     0B 32 3E F8 |             setnib  cmd, #%1011, #7             ' read burst from the external memory
00c3c     FD 34 02 F6 |             mov     hubaddr,cn                  ' to the channel cache
00c40     08 34 66 F0 |             shl     hubaddr,#8                  '
00c44     10 35 02 F1 |             add     hubaddr,hubptr 
00c48     00 37 06 F6 |             mov     count,#256                  ' 256 bytes
00c4c     28 04 64 FD |             setq    #2                          ' write 3 longs
00c50     E2 32 62 FC |             wrlong  cmd, mailbox                ' run it
00c54     E2 32 02 FB | poll1       rdlong  cmd, mailbox                ' poll mailbox for result
00c58     FE 33 B6 FB |             tjs     cmd, #poll1                 ' retry until valid 
00c5c                 |             
00c5c                 | 	
00c5c     FD BE 01 F6 | p701	    mov     qq,cn			' cache hit
00c60     08 BE 65 F0 | 	    shl     qq,#8			' compute the cache start
00c64     10 BF 01 F1 | 	    add     qq,hubptr
00c68     1C BF 01 F1 | 	    add	    qq,addrlo			' add 8 lower bits to the cache addredd
00c6c     DF C0 E1 0A |     _ret_   rdword  spl,qq                      ' read a word
00c70                 |           
00c70                 | 
00c70                 | '--------------------------------------------------------------------------
00c70                 | '------ Interrupt service -------------------------------------------------
00c70                 | '------ Output the sample, get the next one if exists ---------------------
00c70                 | '--------------------------------------------------------------------------
00c70                 | 
00c70     0E C8 25 FC | isr1        wypin   lsample,#left        '2     The sample has to be outputted every 100 cycles     
00c74     0F CA 25 FC |             wypin   rsample,#right       '4
00c78     DE F2 1B F2 |             cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
00c7c     80 CD A5 5A |     if_ne   rdlut   lsnext,ptrb          '11    else read the sample and its time from LUT
00c80     FF F3 07 57 |     if_ne   incmod  ptrb,#511
00c84     E6 CA 39 59 |     if_ne   getword rsample,lsnext,#1    '13
00c88     E6 C8 31 59 |     if_ne   getword lsample,lsnext,#0    '15
00c8c                 |     
00c8c     F5 FF 3B FB |             reti1                        '17/19 
00c90                 |           
00c90                 | '---------------------------------------------------------------------------
00c90                 | '-------- End of interrupt -------------------------------------------------
00c90                 | '---------------------------------------------------------------------------    
00c90                 | 
00c90                 | 
00c90                 | '---------------------------------------------------------------------------
00c90                 | '------- Variables ---------------------------------------------------------
00c90                 | '---------------------------------------------------------------------------
00c90                 | 
00c90                 | ' constants
00c90                 | 
00c90     00 00 00 40 | a40000000   long $40000000
00c94     00 00 00 41 | a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before
00c98                 | 
00c98                 | ' Time variables
00c98                 | 
00c98     00 00 00 00 | time0       long 0    ' Global sample computing time
00c9c     01 00 00 00 | time1       long 1    ' Local channels time
00ca0     02 00 00 00 | time2       long 2
00ca4     03 00 00 00 | time3       long 3
00ca8     04 00 00 00 | time4       long 4
00cac     05 00 00 00 | time5       long 5
00cb0     06 00 00 00 | time6       long 6
00cb4     07 00 00 00 | time7       long 7
00cb8     08 00 00 00 | time8       long 8
00cbc                 | 
00cbc     00 00 00 00 | channeladd long 0
00cc0                 | 
00cc0     00 00 00 00 | front       long 0
00cc4                 | 
00cc4                 | ' temporary variables 
00cc4     00 00 00 00 | qq          long 0
00cc8     00 00 00 00 | spl         long 0
00ccc     00 00 00 00 | zero        long 0
00cd0     00 00 00 00 | mailbox     long 0
00cd4     00 00 00 00 | mailbox2 long 0
00cd8                 | 
00cd8                 | ' Interrupt ISR variables
00cd8                 | 
00cd8     00 00 00 00 | lsample     long 0
00cdc     00 00 00 00 | rsample     long 0
00ce0     00 00 00 00 | lsnext      long 0
00ce4     00 00 00 00 | rsnext      long 0 
00ce8                 | 
00ce8                 | ' channel parameter block
00ce8                 | 
00ce8     00 00 00 00 | pointer0    long 0     
00cec     00 00 00 00 | sample0     long 0
00cf0     00 00 00 00 | sstart0     long 0     ' start pointer and type at bit 31
00cf4     00 00 00 00 | lstart0     long 0
00cf8     00 00 00 00 | lend0       long 0
00cfc     00 00 00 00 | volpan0     long 0
00d00     00 00 00 00 | freqskip0   long 0
00d04     00 00 00 00 | command0    long 0
00d08     00 00 00 00 | envph0	    long 0
00d0c     00 00 00 00 | envptr0	    long 0
00d10     00 00 00 00 | envspd0	    long 0
00d14     00 00 00 00 | envlen0	    long 0
00d18     00 00 00 00 | res5	    long 0
00d1c     00 00 00 00 | res6	    long 0
00d20     00 00 00 00 | res7	    long 0
00d24     00 00 00 00 | res8	    long 0
00d28                 | 
00d28     00 00 00 00 | afreq0      long 0
00d2c     00 00 00 00 | askip0      long 0
00d30     00 00 00 00 | avol0       long 0
00d34     00 00 00 00 | apan0       long 0
00d38                 | 
00d38     FF FF FF FF | oldt0       long $FFFFFFFF    'Temporary time variables
00d3c     00 00 00 00 | cn          long 0
00d40     00 00 00 00 | ct          long 0
00d44     00 00 00 00 | dt0         long 0
00d48                 | 
00d48                 | ' Samples
00d48     00 00 00 00 | oldls       long 0
00d4c     00 00 00 00 | oldrs       long 0
00d50                 | 
00d50     00 00 00 00 | ls0         long 0
00d54     00 00 00 00 | rs0         long 0
00d58                 | 
00d58     00 00 00 00 | ls          long 0    
00d5c     00 00 00 00 | rs          long 0
00d60                 | 
00d60     00 00 00 00 | oldsample   long 0
00d64     00 00 00 00 | newsample   long 0
00d68                 | 
00d68     00 00 00 00 | nrsample    long 0
00d6c     00 00 00 00 | nlsample    long 0
00d70                 | 
00d70     00 00 00 00 | scbase long 0
00d74     00 00 00 00 | scptr long 0
00d78     00 00 00 00 | scptr2 long 0
00d7c     00 00 00 00 | scope long 0
00d80                 | 
00d80     44 00 17 00 | dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
00d84     46 00 17 00 | dac2        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   
00d88                 | 
00d88     00 18 07 00 | hubptr      long $71800
00d8c     00 00 00 00 | cache1      long 0
00d90     00 00 00 00 | cache2      long 0
00d94     00 00 00 00 | cache3      long 0
00d98     00 00 00 00 | cache4      long 0
00d9c     00 00 00 00 | cache5      long 0
00da0     00 00 00 00 | cache6      long 0
00da4     00 00 00 00 | cache7      long 0
00da8     00 00 00 00 | cache8      long 0
00dac                 | 
00dac                 | 
00dac     00 00 00 00 | cmd         long 0
00db0     00 00 00 00 | hubaddr     long 0
00db4     00 01 00 00 | count       long 256
00db8     00 00 00 00 | addrlo long 0
00dbc     00 00 00 00 | addrhi long 0
00dc0     00 00 00 00 | pointer00 long 0
00dc4     00 00 00 00 | envhi long 0
00dc8     00 00 00 00 | envlo long 0
00dcc     00 00 00 00 | envs1 long 0
00dd0     00 00 00 00 | envs2 long 0
00dd4     00 00 00 00 | noise0 long 0
00dd8     00 00 00 00 
00ddc     00 00 00 00 | null  			long 	0,0           ' for channel reset
00de0                 | objmem
00de0     00 00 00 00 
      ...             
00fe4     00 00 00 00 
00fe8     00 00 00 00 | 	long	0[131]
00fec                 | stackspace
00fec     00 00 00 00 | 	long	0[1]
00ff0 0bf             | 	org	COG_BSS_START
00ff0 0bf             | _var01
00ff0 0bf             | 	res	1
00ff0 0c0             | _var02
00ff0 0c0             | 	res	1
00ff0 0c1             | _var03
00ff0 0c1             | 	res	1
00ff0 0c2             | arg01
00ff0 0c2             | 	res	1
00ff0 0c3             | arg02
00ff0 0c3             | 	res	1
00ff0 0c4             | arg03
00ff0 0c4             | 	res	1
00ff0 0c5             | arg04
00ff0 0c5             | 	res	1
00ff0 0c6             | local01
00ff0 0c6             | 	res	1
00ff0 0c7             | local02
00ff0 0c7             | 	res	1
00ff0 0c8             | local03
00ff0 0c8             | 	res	1
00ff0 0c9             | local04
00ff0 0c9             | 	res	1
00ff0 0ca             | 	fit	480
00ff0 0ca             | 
