con
	_clkfreq = 338695652
	_clkmode = 28773115
	pin = 0
dat
	nop
	cogid	pa
	coginit	pa,##$404
	orgh	$10
	long	0	'reserved
	long	0 ' clock frequency: will default to 338695652
	long	0 ' clock mode: will default to $1b70afb
	orgh	$400
 _ret_	mov	result1, #0
	org	0
entry
	cmp	ptra, #0 wz
 if_ne	jmp	#spininit
	mov	ptra, ptr_stackspace_
	rdlong	pa, #20 wz
 if_ne	jmp	#skip_clock_set_
	hubset	#0
	hubset	##28773112
	waitx	##200000
	mov	pa, ##28773115
	hubset	pa
	wrlong	pa, #24
	wrlong	##338695652, #20
	jmp	#skip_clock_set_
	orgf	192
skip_clock_set_
	call	#_program
cogexit
	waitx	##160000
	cogid	arg01
	cogstop	arg01
spininit
	rdlong	objptr, ptra++
	rdlong	result1, ptra++
	setq	#3
	rdlong	arg01, ptra
	sub	ptra, #4
	call	result1
	jmp	#cogexit
FCACHE_LOAD_
    mov	fcache_tmpb_,ptrb
    pop	ptrb
    altd	pa,ret_instr_
    mov	 0-0, ret_instr_
    setq	pa
    rdlong	$0, ptrb++
    push	ptrb
    mov ptrb,fcache_tmpb_
    jmp	#\$0 ' jmp to cache
ret_instr_
    _ret_ cmp inb,#0
fcache_tmpb_
    long 0
fcache_load_ptr_
    long FCACHE_LOAD_
builtin_bytefill_
        shr	arg03, #1 wc
 if_c   wrbyte	arg02, arg01
 if_c   add	arg01, #1
        movbyts	arg02, #0
builtin_wordfill_
        shr	arg03, #1 wc
 if_c   wrword	arg02, arg01
 if_c   add	arg01, #2
        setword	arg02, arg02, #1
builtin_longfill_
        wrfast	#0,arg01
        cmp	arg03, #0 wz
 if_nz  rep	#1, arg03
 if_nz  wflong	arg02
        ret
COUNT_
    long 0
RETADDR_
    long 0
fp
    long 0
pushregs_
    pop  pa
    pop  RETADDR_
    tjz  COUNT_, #pushregs_done_
    altd  COUNT_, #511
    setq #0-0
    wrlong local01, ptra++
pushregs_done_
    setq #2 ' push 3 registers starting at COUNT_
    wrlong COUNT_, ptra++
    mov    fp, ptra
    jmp  pa
 popregs_
    pop    pa
    setq   #2
    rdlong COUNT_, --ptra
    djf    COUNT_, #popregs__ret
    setq   COUNT_
    rdlong local01, --ptra
popregs__ret
    push   RETADDR_
    jmp    pa

divide_
       abs     muldivb_,muldivb_     wcz      'abs(y)
       wrc     itmp2_                         'store sign of y
       abs     muldiva_,muldiva_     wc       'abs(x)
       qdiv    muldiva_, muldivb_             'queue divide
 if_c  xor     itmp2_,#1                      'store sign of x
       getqx   muldivb_                       'get quotient
       getqy   muldiva_                       'get remainder
       negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
       testb   itmp2_,#0             wc       'restore sign, division result
 _ret_ negc    muldivb_,muldivb_     
__pc long 0
__setjmp
    pop __pc
    mov result1, #0
    mov result2, #0
    mov abortchain, arg01
    wrlong fp, arg01
    add arg01, #4
    wrlong ptra, arg01
    add arg01, #4
    wrlong objptr, arg01
    add arg01, #4
    wrlong __pc, arg01
    jmp __pc
__unwind_pc long 0
__unwind_stack
   pop  __unwind_pc
__unwind_loop
   cmp  arg01, arg02 wz
  if_z jmp #__unwind_stack_ret
   mov   ptra, arg01
   call  #popregs_
   mov   arg01, fp
   jmp   #__unwind_loop
__unwind_stack_ret
   jmp  __unwind_pc
__longjmp
    pop __pc
    cmp    arg01, #0 wz
 if_z jmp #nocatch
    mov result1, arg02
    mov result2, #1
    rdlong arg02, arg01
    add arg01, #4
    rdlong ptra, arg01
    add arg01, #4
    rdlong objptr, arg01
    add arg01, #4
    rdlong __pc, arg01
    mov arg01, fp
    call #__unwind_stack
__longjmp_ret
    jmp  __pc
nocatch
    cmp arg03, #0 wz
 if_z jmp #cogexit
    jmp #__longjmp_ret

__heap_ptr
	long	@__heap_base
__methods__
	long	@__methodtable__
__recvreg
	long	0
__sendreg
	long	0
abortchain
	long	0
itmp1_
	long	0
itmp2_
	long	0
objptr
	long	@objmem
ptr___system__dat__
	long	@__system__dat_
ptr__dat__
	long	@_dat_
ptr__hg010b_spin2_dat__
	long	@_hg010b_spin2_dat_
ptr__psram16drv_spin2_dat__
	long	@_psram16drv_spin2_dat_
ptr__psram_spin2_dat__
	long	@_psram_spin2_dat_
ptr__usbnew_spin2_dat__
	long	@_usbnew_spin2_dat_
ptr_stackspace_
	long	@stackspace
result1
	long	0
result2
	long	1
result3
	long	2
COG_BSS_START
	fit	480
	orgh
hubentry

' 
' function getchar() as ubyte
_getchar
' 
' do
LR__0001
	call	#_usbnew_spin2_get_key
	mov	arg01, result1
	call	#_scantochar
	add	objptr, ##113752
	wrlong	result1, objptr
	sub	objptr, ##113752
	cmps	result1, #1 wc
 if_b	jmp	#LR__0001
' print q : return q
	mov	arg01, #0
	call	#__system___getiolock_0103
	mov	arg01, result1
	call	#__system___lockmem
	add	objptr, ##113752
	rdlong	arg02, objptr
	sub	objptr, ##113752
	mov	arg01, #0
	mov	arg03, #0
	mov	arg04, #10
	call	#__system___basic_print_integer
	mov	arg01, #0
	mov	arg02, #10
	mov	arg03, #0
	call	#__system___basic_print_char
	mov	arg01, #0
	call	#__system___getiolock_0103
	wrlong	#0, result1
	add	objptr, ##113752
	rdlong	result1, objptr
	sub	objptr, ##113752
_getchar_ret
	ret

' 
' function scantochar(key)
_scantochar
' 
' if (key and $8000_0000)=0 then
	testbn	arg01, #31 wz
 if_ne	jmp	#LR__0015
'   select case (key shr 8) and 255
	mov	_var01, arg01
	sar	_var01, #8
	and	_var01, #255 wz
 if_e	jmp	#LR__0010
	cmp	_var01, #2 wz
 if_ne	cmp	_var01, #32 wz
 if_e	jmp	#LR__0011
	cmp	_var01, #64 wz
 if_e	jmp	#LR__0012
	cmp	_var01, #66 wz
 if_ne	cmp	_var01, #96 wz
 if_ne	jmp	#LR__0014
	jmp	#LR__0013
LR__0010
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__0011
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #1
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__0012
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #2
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__0013
	mov	result1, arg01
	and	result1, #127
	shl	result1, #2
	add	result1, #3
	add	result1, ptr__dat__
	rdbyte	result1, result1
	jmp	#_scantochar_ret
LR__0014
	mov	result1, #0
	jmp	#_scantochar_ret
LR__0015
	mov	result1, #0
_scantochar_ret
	ret

_program
	mov	COUNT_, #1
	call	#pushregs_
	mov	arg01, #0
	decod	arg02, #10
	mov	arg03, #11
	mov	arg04, #7
	add	objptr, ##5836
	call	#_psram_spin2_startx
	add	objptr, ##98304
	wrbyte	result1, objptr
'     return $7FF00 + cog*12
	add	objptr, #4
	wrlong	##524032, objptr
	sub	objptr, ##104144
	call	#_usbnew_spin2_start
	add	objptr, ##104142
	wrbyte	result1, objptr
	add	objptr, #2
	rdlong	arg02, objptr
	sub	objptr, ##104144
	mov	arg01, #0
	call	#_hg010b_spin2_start
	add	objptr, ##104141
	wrbyte	result1, objptr
	sub	objptr, ##104141
	mov	arg01, #4
	call	#_hg010b_spin2_setfontfamily
' 
' pscog=psram.startx(0, 1024, 11, 7)
' mbox=psram.getMailbox(0)
' usbcog=kbm.start()
' videocog=v.start(pin,mbox)
' v.setfontfamily(4)
' for thecog=0 to 7:psram.setQos(thecog, 80 << 16) :next thecog
	mov	local01, #0
	add	objptr, ##5836
LR__0020
	mov	arg01, local01
	mov	arg02, ##5242880
	call	#_psram_spin2_setQos
	add	local01, #1
	cmps	local01, #8 wc
 if_b	jmp	#LR__0020
	add	objptr, ##98305
	rdbyte	arg01, objptr
	mov	arg02, ##67171328
	sub	objptr, ##98305
	call	#_psram_spin2_setQos
	sub	objptr, ##5836
' psram.setQoS(videocog, $0400f400) 
' open SendRecvDevice(@v.putchar, nil, nil) as #0
	mov	arg02, objptr
	bith	arg02, #21
	mov	arg03, #0
	mov	arg04, #0
	mov	arg01, #0
	call	#__system___basic_open
	mov	__sendreg, objptr
	bith	__sendreg, #21
	mov	__recvreg, objptr
	bith	__recvreg, #52
	mov	arg01, #100
	call	#__system___waitms
	mov	arg01, #154
	mov	arg02, #147
	call	#_hg010b_spin2_cls
	add	objptr, ##71372
	call	#_life_b_program
	sub	objptr, ##71372
	mov	ptra, fp
	call	#popregs_
_program_ret
	ret

' '' this is not a main program.
' 
' '****************************************************************************************************************
' '                                                                                                             	*
' 'Start the driver  at pins 'base'                            					rev 20230829 	*
' '                                                                                                            	*
' ' base - HDMI base pin												*
' ' mb - PSRAM mailbox pointer, 0 if no PSRAM									*
' '														*
' '														*
' '****************************************************************************************************************
' 
' pub start(base,mb):result |i
_hg010b_spin2_start
' 
' '--------------------------- initialize pointers and variables
' 
' border_ptr:=@bordercolor					' Initial border color pointer, can be changed via DL
	add	objptr, #52
	mov	result1, objptr
	sub	objptr, #40
	wrlong	result1, objptr
' 'font_ptr:=@amiga_font						' Initial 8x16 font definition
' hdmibase:=base							' HDMI base pin, 8*n
	add	objptr, #24
	wrlong	arg01, objptr
' mailbox_ptr:=mb		
	add	objptr, #4
	wrlong	arg02, objptr
' mailbox0:=mb				' PSRAM mailbox pointer
	add	objptr, #449
	wrlong	arg02, objptr
' sprite_ptr:=@spr1ptr
	sub	objptr, #216
	mov	result1, objptr
	sub	objptr, #229
	wrlong	result1, objptr
' 
' 		'
' word[spr1ptr+17*12+4]:=8				' spr18w
	add	objptr, #229
	rdlong	result1, objptr
	add	result1, #208
	wrword	#8, result1
' word[spr1ptr+17*12+6]:=16				' for a blinking cursor
	rdlong	arg03, objptr
	add	arg03, #210
	wrword	#16, arg03
' leading_spaces:=0				'
	add	objptr, #421
	wrlong	#0, objptr
' 
' emptydl[0]:=%0100_0000_0000_0000_0000_0000_0000_0111
	sub	objptr, #153
	wrlong	##1073741831, objptr
' emptydl[1]:=0
	add	objptr, #4
	wrlong	#0, objptr
' 
' '---------------------------- the mode has to be set here to enable computing the buffer length
' 
' s_debug:=debugger						' check if debug mode defined (eats 16 kB upper RAM so don't use it)					' 
	sub	objptr, #296
	wrlong	#1, objptr
' if s_debug<>0
'   s_debug:=16384						' the buffers adresses will be corrected to not interfere with the debugger
	wrlong	##16384, objptr
	sub	objptr, #249
' setmode()							' set the mode, see below
	call	#_hg010b_spin2_setmode
' vblank_ptr:=@vblank						' set pointers before starting the driver
	add	objptr, #73
	mov	result1, objptr
	sub	objptr, #53
	wrlong	result1, objptr
' cursor_ptr:=@cursor_x						
	add	objptr, #40
	mov	arg03, objptr
	sub	objptr, #44
	wrlong	arg03, objptr
' fontnum:=0  							' start with a PC type font 
	add	objptr, #85
	wrlong	#0, objptr
' bytemove(@colors,@vgacolors,16)					' prepare standard DOS VGA colors
	add	objptr, #28
	mov	arg01, objptr
	sub	objptr, #129
	mov	arg02, ptr__hg010b_spin2_dat__
	add	arg02, ##14464
	mov	arg03, #16
	call	#__system____builtin_memmove
' leading_spaces:=0
	add	objptr, ##694
	wrlong	#0, objptr
	sub	objptr, ##694
' '---------------------------- initialize a cursor (MSDOS type)
' 
' initcursor(154)
	mov	arg01, #154
	call	#_hg010b_spin2_initcursor
' 
' '---------------------------- start the cog
' 
' cog:=coginit(16,@hdmi, @vblank_ptr)				' start the driver cog			
	mov	arg02, ptr__hg010b_spin2_dat__
	add	arg02, ##14480
	mov	arg03, objptr
	add	arg03, #20
	mov	result1, #16
	setq	arg03
	coginit	result1, arg02 wc
 if_b	neg	result1, #1
	add	objptr, #48
	wrlong	result1, objptr
	sub	objptr, #48
' waitms(40)							' wait for stabilize
	mov	arg01, #40
	call	#__system___waitms
' return cog							' return the driver's cog #
	add	objptr, #48
	rdlong	result1, objptr
	sub	objptr, #48
_hg010b_spin2_start_ret
	ret

' 
' '---------------------------- initialize a cursor (MSDOS type)
' pub initcursor(color) |i
_hg010b_spin2_initcursor
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' cursor_x:=0							' place the cursor at 0:0
	add	objptr, #60
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' repeat i from 0 to 111
	mov	local02, #0
	add	objptr, #504
	callpa	#(@LR__0031-@LR__0030)>>2,fcache_load_ptr_
LR__0030
'   cursor[i]:=0
	mov	local03, local02
	add	local03, objptr
	wrbyte	#0, local03
	add	local02, #1
	cmps	local02, #112 wc
 if_b	jmp	#LR__0030
LR__0031
' repeat i from 112 to 127
	mov	local02, #112
	callpa	#(@LR__0033-@LR__0032)>>2,fcache_load_ptr_
LR__0032
'   cursor[i]:=color  
	mov	local03, local02
	add	local03, objptr
	wrbyte	local01, local03
	add	local02, #1
	cmp	local02, #128 wc
 if_b	jmp	#LR__0032
LR__0033
	sub	objptr, ##566
' 'repeat i from 0 to 127
' '  if ((i/8)//2)
' '    cursor[i]:=15
' '  else
' '    cursor[i]:=0
' '  if i>=120    
' '    cursor[i]:=40
' setspriteptr(17,@cursor)
	mov	arg02, objptr
	add	arg02, ##566
	mov	arg01, #17
	call	#_hg010b_spin2_setspriteptr
' setspritesize(17,8,16)
	mov	arg01, #17
	mov	arg02, #8
	mov	arg03, #16
	call	#_hg010b_spin2_setspritesize
' setspritepos(17,0,0)
	mov	arg01, #17
	mov	arg02, #0
	mov	arg03, #0
	call	#_hg010b_spin2_setspritepos
' cursorshape:=14
	add	objptr, ##5830
	wrlong	#14, objptr
' cursorcolor:=color
	sub	objptr, #4
	wrlong	local01, objptr
	sub	objptr, ##5826
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_initcursor_ret
	ret

' 
' pub setcursorcolor(color) | i
_hg010b_spin2_setcursorcolor
' 
' cursorcolor:=color
	add	objptr, ##5826
	wrlong	arg01, objptr
' repeat i from 0 to (8*cursorshape)-1
	mov	arg01, #0
	add	objptr, #4
	rdlong	_var01, objptr
	shl	_var01, #3
	sub	_var01, #1
	cmps	_var01, #0 wc
	negc	_var02, #1
	mov	_var03, _var02
	add	_var01, _var02
	sub	objptr, ##5264
	callpa	#(@LR__0041-@LR__0040)>>2,fcache_load_ptr_
LR__0040
'   cursor[i]:=0
	mov	_var02, arg01
	add	_var02, objptr
	wrbyte	#0, _var02
	add	arg01, _var03
	cmp	arg01, _var01 wz
 if_ne	jmp	#LR__0040
LR__0041
' repeat i from 8*cursorshape to 127
	add	objptr, ##5264
	rdlong	_var03, objptr
	mov	arg01, _var03
	shl	arg01, #3
	sub	objptr, ##5830
	shl	_var03, #3
	cmps	_var03, #128 wc
	negnc	_var02, #1
	mov	_var01, #127
	add	_var01, _var02
	callpa	#(@LR__0043-@LR__0042)>>2,fcache_load_ptr_
LR__0042
'   cursor[i]:=cursorcolor
	mov	_var03, arg01
	add	objptr, ##566
	add	_var03, objptr
	add	objptr, ##5260
	rdlong	_var04, objptr
	sub	objptr, ##5826
	wrbyte	_var04, _var03
	add	arg01, _var02
	cmp	arg01, _var01 wz
 if_ne	jmp	#LR__0042
LR__0043
_hg010b_spin2_setcursorcolor_ret
	ret

'   
'   
'   
' pub setmode() | i', 'xzoom, yzoom, azoom
_hg010b_spin2_setmode
	mov	COUNT_, #2
	call	#pushregs_
' 
' 
' dl_ptr:=@emptydl[0]
	add	objptr, ##541
	mov	arg05, objptr
	sub	objptr, #509
	wrlong	arg05, objptr
' 
' if cog>0 
	add	objptr, #16
	rdlong	arg05, objptr
	sub	objptr, #48
	cmps	arg05, #1 wc
'    waitvbl(1)						    	' if the driver is active, wait for vblank to set the new mode and DL	
 if_ae	mov	arg01, #1
 if_ae	call	#_hg010b_spin2_waitvbl
' xres:=1024
	add	objptr, ##550
	wrlong	##1024, objptr
' yres:=600
	add	objptr, #4
	wrlong	##600, objptr
' ppl:=(timings[3])
	add	ptr__hg010b_spin2_dat__, ##14412
	rdlong	arg05, ptr__hg010b_spin2_dat__
	sub	objptr, #337
	wrlong	arg05, objptr
' cpl:=timings[7]<<1                                      	' now cpl is longs per line
	add	ptr__hg010b_spin2_dat__, #16
	rdlong	local01, ptr__hg010b_spin2_dat__
	shl	local01, #1
	sub	objptr, #128
	wrlong	local01, objptr
' cpl1:=cpl '' todo remove
	add	objptr, #4
	wrlong	local01, objptr
' palette_ptr:=@ataripalette				    	' use 256-colors palettr
	sub	ptr__hg010b_spin2_dat__, ##2076
	sub	objptr, #65
	wrlong	ptr__hg010b_spin2_dat__, objptr
' repeat i from 0 to 3
	mov	local02, #0
	add	ptr__hg010b_spin2_dat__, ##2048
	add	objptr, #8
	callpa	#(@LR__0051-@LR__0050)>>2,fcache_load_ptr_
LR__0050
'   timings[i]:=timings[i]+hdmibase<<17+ timingsxxt          	' add a streamer config (imm->pins) to horizontal timings 
	mov	local01, local02
	shl	local01, #2
	add	local01, ptr__hg010b_spin2_dat__
	rdlong	arg05, objptr
	shl	arg05, #17
	rdlong	local01, local01
	add	local01, arg05
	add	local01, ##1887502336
	mov	arg05, local02
	shl	arg05, #2
	add	arg05, ptr__hg010b_spin2_dat__
	wrlong	local01, arg05
	add	local02, #1
	cmps	local02, #4 wc
 if_b	jmp	#LR__0050
LR__0051
	sub	objptr, #36
	sub	ptr__hg010b_spin2_dat__, ##14400
' 'clkfreq:=timings[9]					    	' set the clock frequency for the mode
' 'hubset(timings[10])
' waitms(1)                                                   	' wait for stabilization
	mov	arg01, #1
	call	#__system___waitms
	add	ptr__hg010b_spin2_dat__, ##14444
	rdlong	local02, ptr__hg010b_spin2_dat__
	add	objptr, #97
	wrlong	local02, objptr
	abs	local01, local02 wc
	shr	local01, #4
	negc	local01, local01
	add	objptr, #156
	wrlong	local01, objptr
	sub	objptr, #164
	rdlong	local02, objptr
	add	objptr, #8
	rdlong	local01, objptr
	qmul	local02, local01
' lines:=timings[11]
' t_lines:=lines/16
' buflen:=cpl*lines						' framebuffer length in longs
	sub	objptr, #41
	decod	local01, #25
	sub	ptr__hg010b_spin2_dat__, #16
	getqx	local02
	wrlong	local02, objptr
	sub	objptr, #56
	shl	local02, #2
	sub	local01, local02
	wrlong	local01, objptr
	add	objptr, #253
	rdlong	local02, objptr
	rdlong	arg05, ptr__hg010b_spin2_dat__
	qmul	local02, arg05
' buf_ptr:=$2000000-4*buflen                          	     	' todo: get a PSRAM real himem 
' textbuf_ptr:=buf_ptr-t_lines*timings[7]
	sub	objptr, #249
' mode_ptr:=@timings						' set pointers to timings
	sub	ptr__hg010b_spin2_dat__, #28
' graphmode:=1024+512+192+48							' det global variable
' makedl(graphmode)							' make a DL for the mode
	mov	arg01, ##1776
	getqx	local02
	sub	local01, local02
	wrlong	local01, objptr
	add	objptr, #20
	wrlong	ptr__hg010b_spin2_dat__, objptr
	add	objptr, #121
	wrlong	##1776, objptr
	sub	objptr, #145
	sub	ptr__hg010b_spin2_dat__, ##14400
	call	#_hg010b_spin2_makedl
' s_buf_ptr:=buf_ptr						' secondary copies of main framebuffer parameters 
	rdlong	local01, objptr
	add	objptr, #221
	wrlong	local01, objptr
' s_font_ptr:=font_ptr
	sub	objptr, #213
	rdlong	local01, objptr
	add	objptr, #217
	wrlong	local01, objptr
' s_lines:=lines
	sub	objptr, #128
	rdlong	local01, objptr
	add	objptr, #132
	wrlong	local01, objptr
' s_buflen:=buflen
	sub	objptr, #173
	rdlong	local01, objptr
	add	objptr, #181
	wrlong	local01, objptr
' s_cpl:=cpl
	sub	objptr, #148
	rdlong	local01, objptr
	add	objptr, #144
	wrlong	local01, objptr
' s_cpl1:=cpl
	sub	objptr, #144
	rdlong	local01, objptr
	add	objptr, #152
	wrlong	local01, objptr
' st_lines:=t_lines
	add	objptr, #12
	rdlong	local01, objptr
	add	objptr, #4
	wrlong	local01, objptr
' ppl:=ppl/xzoom  
	sub	objptr, #40
	rdlong	muldiva_, objptr
	add	objptr, #44
	rdlong	muldivb_, objptr
	sub	objptr, #261
	call	#divide_
	add	objptr, #217
	wrlong	muldivb_, objptr
' s_ppl:=ppl
	add	objptr, #28
	wrlong	muldivb_, objptr
	sub	objptr, #245
' waitms(20)							' wait 
	mov	arg01, #20
	call	#__system___waitms
' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
	add	objptr, #4
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	arg03, arg01
	mov	arg02, #32
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5836
	call	#_psram_spin2_fill
	sub	objptr, ##5836
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_setmode_ret
	ret

' 
' '****************************************************************************************************************
' '                                                                                                             	*
' '  Make a display list for simple standard modes                                             	rev.20220319    *
' '                                                                                                             	*
' '****************************************************************************************************************
' 
' pub makedl(mode) |i,vzoom,border,psbuf,lines2
_hg010b_spin2_makedl
' 
' psbuf:=$80000-s_debug-1024                                                     ' HUB line buffer on the top of HUB RAM (-16 kB if debug enabled)
' vzoom:=1<<((mode>>2) & 3)                                                      ' real vzoom from mode#
' repeat i from 0 to 11                                                           ' clear DL
	mov	_var01, #0
	add	objptr, #493
	callpa	#(@LR__0061-@LR__0060)>>2,fcache_load_ptr_
LR__0060
'   displaylist[i]:=0 
	mov	_var02, _var01
	shl	_var02, #2
	add	_var02, objptr
	wrlong	#0, _var02
	add	_var01, #1
	cmps	_var01, #12 wc
 if_b	jmp	#LR__0060
LR__0061
'                         ' 
' displaylist[0]:=lines<<20+(0)<<16+%0001+ (0+(cpl1<<2)) <<4             
	sub	objptr, #396
	rdlong	_var02, objptr
	shl	_var02, #20
	add	_var02, #1
	sub	objptr, #4
	rdlong	_var01, objptr
	shl	_var01, #6
	add	_var02, _var01
	add	objptr, #400
	wrlong	_var02, objptr
	sub	objptr, #493
' displaylist[1]:=buf_ptr<<4+%10  
	rdlong	_var02, objptr
	shl	_var02, #4
	add	_var02, #2
	add	objptr, #497
	wrlong	_var02, objptr
' dl_ptr:=@displaylist[0] 						      ' tell the driver where to find the DL
	sub	objptr, #4
	mov	_var02, objptr
	sub	objptr, #461
	wrlong	_var02, objptr
	sub	objptr, #32
_hg010b_spin2_makedl_ret
	ret

' 
' 
' '****************************************************************************************************************
' '                                                                        					*
' '  Graphic primitives                                                    					*
' '                                                                        					*
' '****************************************************************************************************************
' 
' pub setspriteptr(num,ptr)
_hg010b_spin2_setspriteptr
' long[@spr1ptr+12*num]:=ptr
	mov	_var01, objptr
	add	_var01, #273
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	wrlong	arg02, _var01
_hg010b_spin2_setspriteptr_ret
	ret

' 
' pub setspritepos(num,x,y)
_hg010b_spin2_setspritepos
' if y>601
	cmps	arg03, ##602 wc
'   y:=601
 if_ae	mov	arg03, ##601
' if x>1024
	cmps	arg02, ##1025 wc
'   x:=1024
 if_ae	decod	arg02, #10
' word[@spr1ptr+12*num+4]:=x
	add	objptr, #273
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #4
	wrword	arg02, _var01
' word[@spr1ptr+12*num+6]:=y
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #6
	wrword	arg03, _var01
	sub	objptr, #273
_hg010b_spin2_setspritepos_ret
	ret

' 
' pub setspritesize(num,w,h)
_hg010b_spin2_setspritesize
' word[@spr1ptr+12*num+8]:=w
	add	objptr, #273
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #8
	wrword	arg02, _var01
' word[@spr1ptr+12*num+10]:=h
	mov	_var01, objptr
	mov	_var02, arg01
	shl	_var02, #1
	add	_var02, arg01
	shl	_var02, #2
	add	_var01, _var02
	add	_var01, #10
	wrword	arg03, _var01
	sub	objptr, #273
_hg010b_spin2_setspritesize_ret
	ret

'   
' '----------- A line drawing family. BASIC doesn't like the name, so it is named "draw" and aliased  -----------------------------
' 
' pub fastline(x1,x2,y,c)									' a fast 8bpp horizontal line
_hg010b_spin2_fastline
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' if y<0 || y>=yres || (x1<0 && x2<0) || (x1>xres && x2>xres)
	cmps	arg03, #0 wc
 if_b	jmp	#LR__0070
	add	objptr, ##554
	rdlong	arg05, objptr
	sub	objptr, ##554
	cmps	arg03, arg05 wc
 if_ae	jmp	#LR__0070
	cmps	local01, #0 wc
 if_b	cmps	local02, #0 wc
 if_b	jmp	#LR__0070
	add	objptr, ##550
	rdlong	arg05, objptr
	sub	objptr, ##550
	cmps	local01, arg05 wcz
 if_a	add	objptr, ##550
 if_a	rdlong	arg01, objptr
 if_a	sub	objptr, ##550
 if_a	cmps	local02, arg01 wcz
'   return
 if_a	jmp	#LR__0070
	cmps	local01, local02 wcz
 if_a	mov	arg05, local01
 if_a	mov	local01, local02
 if_a	mov	local02, arg05
	cmps	local01, #0 wc
 if_b	mov	local01, #0
	add	objptr, ##550
	rdlong	arg05, objptr
	sub	objptr, ##550
	cmps	local02, arg05 wc
 if_ae	add	objptr, ##550
 if_ae	rdlong	local02, objptr
 if_ae	sub	objptr, ##550
	add	objptr, #221
	rdlong	arg01, objptr
	add	objptr, #20
	rdlong	arg05, objptr
	shl	arg05, #2
	qmul	arg05, arg03
' if x1>x2
'   x1,x2:=x2,x1
' if x1<0 
'   x1:=0
' if x2>=xres
'   x2:=xres-1  
 if_ae	sub	local02, #1
' ram.fill(s_buf_ptr+(4*s_cpl1*y+x1),c,1+x2-x1,0,1)
	mov	arg03, #1
	add	arg03, local02
	sub	arg03, local01
	mov	arg02, arg04
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5595
	getqx	local02
	add	local02, local01
	add	arg01, local02
	call	#_psram_spin2_fill
	sub	objptr, ##5836
LR__0070
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_fastline_ret
	ret

'       
' pub putcharxycgf(x,y,achar,f,b) |xx, yy,bb,c1,c2
_hg010b_spin2_putcharxycgf
' 
'  
' repeat yy from 0 to 15
	mov	_var01, #0
	callpa	#(@LR__0082-@LR__0080)>>2,fcache_load_ptr_
LR__0080
' 
'   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
	add	objptr, #149
	rdlong	_var02, objptr
	shl	_var02, #10
	mov	_var03, ptr__hg010b_spin2_dat__
	add	_var03, _var02
	mov	_var02, arg03
	shl	_var02, #4
	add	_var03, _var02
	add	_var03, _var01
	rdbyte	_var03, _var03
'   asm
	testb	_var03, #0 wz
 if_e	setbyte	_var04, arg04, #0
 if_ne	setbyte	_var04, arg05, #0
	testb	_var03, #1 wz
 if_e	setbyte	_var04, arg04, #1
 if_ne	setbyte	_var04, arg05, #1
	testb	_var03, #2 wz
 if_e	setbyte	_var04, arg04, #2
 if_ne	setbyte	_var04, arg05, #2
	testb	_var03, #3 wz
 if_e	setbyte	_var04, arg04, #3
 if_ne	setbyte	_var04, arg05, #3
	testb	_var03, #4 wz
 if_e	setbyte	_var05, arg04, #0
 if_ne	setbyte	_var05, arg05, #0
	testb	_var03, #5 wz
 if_e	setbyte	_var05, arg04, #1
 if_ne	setbyte	_var05, arg05, #1
	testb	_var03, #6 wz
 if_e	setbyte	_var05, arg04, #2
 if_ne	setbyte	_var05, arg05, #2
	testb	_var03, #7 wz
 if_e	setbyte	_var05, arg04, #3
 if_ne	setbyte	_var05, arg05, #3
'   
'   ccc[0]:=c1
	add	objptr, #409
	wrlong	_var04, objptr
'   ccc[1]:=c2 
	add	objptr, #4
	wrlong	_var05, objptr
'   long[mailbox0][2]:=8
	sub	objptr, #73
	rdlong	_var03, objptr
	add	_var03, #8
	wrlong	#8, _var03
'   long[mailbox0][1]:=@ccc
	mov	_var03, objptr
	add	_var03, #69
	rdlong	_var02, objptr
	add	_var02, #4
	wrlong	_var03, _var02
'   long[mailbox0]:= s_buf_ptr+((y+yy)<<10+x<<2)+$f0000000   
	sub	objptr, #268
	rdlong	_var03, objptr
	mov	_var02, arg02
	add	_var02, _var01
	shl	_var02, #10
	mov	_var06, arg01
	shl	_var06, #2
	add	_var02, _var06
	add	_var03, _var02
	add	_var03, ##-268435456
	add	objptr, #268
	rdlong	_var06, objptr
	wrlong	_var03, _var06
'   repeat
LR__0081
	rdlong	_var03, objptr
	rdlong	_var02, _var03
	cmps	_var02, #0 wc
 if_b	jmp	#LR__0081
	sub	objptr, #489
	add	_var01, #1
	cmps	_var01, #16 wc
 if_b	jmp	#LR__0080
LR__0082
_hg010b_spin2_putcharxycgf_ret
	ret

' 
' 
' '**********************************************************************r***
' '                                                                        *
' ' Font related functions                                                 *
' '                                                                        *
' '*************************************************************************
' 
' ''--------- Set a font offset. TODO: remove, use byte#1 instead
' 
' pub setfontfamily(afontnum)
_hg010b_spin2_setfontfamily
' 
' font_family:=afontnum
	add	objptr, #149
	wrlong	arg01, objptr
	sub	objptr, #149
' 'if afontnum==8
' '  font_ptr:=@amiga_font
' 
' if afontnum==4
	cmp	arg01, #4 wz
'   font_ptr:=@st_font
 if_e	mov	_var01, ptr__hg010b_spin2_dat__
 if_e	add	_var01, ##4096
 if_e	add	objptr, #8
 if_e	wrlong	_var01, objptr
 if_e	sub	objptr, #8
' if afontnum==0
	cmp	arg01, #0 wz
'   font_ptr:=@vga_font
 if_e	add	objptr, #8
 if_e	wrlong	ptr__hg010b_spin2_dat__, objptr
 if_e	sub	objptr, #8
_hg010b_spin2_setfontfamily_ret
	ret

' 
' '*************************************************************************
' '                                                                        *
' '  VBlank functions                                                      *
' '                                                                        *
' '*************************************************************************
' 
' pub waitvbl(amount) | i
_hg010b_spin2_waitvbl
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
' 
' ''---------- Wait for start of vblank. Amount=delay in frames
' 
' repeat i from 1 to amount
	mov	local02, #1
	cmps	local01, #1 wc
	negc	local03, #1
	add	local01, local03
LR__0090
'   repeat until vblank==0
LR__0091
	add	objptr, #73
	rdlong	arg01, objptr wz
	sub	objptr, #73
 if_e	jmp	#LR__0092
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__0091
LR__0092
'   repeat until vblank==1
LR__0093
	add	objptr, #73
	rdlong	arg01, objptr
	sub	objptr, #73
	cmp	arg01, #1 wz
 if_e	jmp	#LR__0094
'     waitus(100)
	mov	arg01, #100
	call	#__system___waitus
	jmp	#LR__0093
LR__0094
	add	local02, local03
	cmp	local02, local01 wz
 if_ne	jmp	#LR__0090
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_waitvbl_ret
	ret

' 
' 
' pub cls(fc,bc)   :c,i
_hg010b_spin2_cls
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
' 
' c:=bc
' ram.fill(s_buf_ptr,c,4*buflen,0,1)  
	add	objptr, #221
	rdlong	arg01, objptr
	sub	objptr, #165
	rdlong	arg03, objptr
	shl	arg03, #2
	mov	arg02, local02
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5780
	call	#_psram_spin2_fill
' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
	sub	objptr, ##5832
	rdlong	arg01, objptr
	sub	objptr, #4
	rdlong	arg03, objptr
	sub	arg03, arg01
	mov	arg02, #32
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5836
	call	#_psram_spin2_fill
' setwritecolors(fc,bc)
' 
' write_color:=ff
	sub	objptr, ##5771
	wrlong	local01, objptr
' write_background:=bb
	add	objptr, #4
	wrlong	local02, objptr
' cursor_x:=0
	sub	objptr, #9
	wrword	#0, objptr
' cursor_y:=0
	add	objptr, #2
	wrbyte	#0, objptr
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	sub	objptr, #2
	rdword	arg02, objptr
	shl	arg02, #2
	sub	objptr, #60
	mov	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
' setcursorcolor(fc)
	mov	arg01, local01
	call	#_hg010b_spin2_setcursorcolor
	mov	result1, local02
	mov	result2, #0
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_cls_ret
	ret

' 
' ''---------- Output a char at the cursor position, move the cursor 
' 
' pub putchar(achar) | c,x,y,l,newcpl
_hg010b_spin2_putchar
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
' 
' if achar==10
	cmp	local01, #10 wz
'   crlf()
 if_e	call	#_hg010b_spin2_crlf
' if achar==9
	cmp	local01, #9 wz
 if_ne	jmp	#LR__0100
'   cursor_x:=(cursor_x& %11110000)+16
	add	objptr, #60
	rdword	arg03, objptr
	and	arg03, #240
	add	arg03, #16
	wrword	arg03, objptr
	sub	objptr, #60
LR__0100
'   
' if (achar<>9) && (achar<>10) 
	cmp	local01, #9 wz
 if_ne	cmp	local01, #10 wz
 if_e	jmp	#LR__0101
'   putcharxycgf(cursor_x,16*cursor_y+4,achar,write_color,write_background)
	add	objptr, #60
	rdword	arg01, objptr
	add	objptr, #2
	rdbyte	arg02, objptr
	shl	arg02, #4
	add	arg02, #4
	add	objptr, #3
	rdlong	arg04, objptr
	add	objptr, #4
	rdlong	arg05, objptr
	sub	objptr, #69
	mov	arg03, local01
	call	#_hg010b_spin2_putcharxycgf
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	arg03, ptr__hg010b_spin2_dat__
	add	objptr, #58
	rdbyte	arg05, objptr
	qmul	arg03, arg05
'   ram.fill(textbuf_ptr+(timings[7]*cursor_y+(cursor_x>>1)),achar,1,0,1)
	sub	ptr__hg010b_spin2_dat__, ##14428
	sub	objptr, #2
	rdword	local02, objptr
	shr	local02, #1
	mov	arg02, local01
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5776
	getqx	local01
	add	local01, local02
	add	arg01, local01
	call	#_psram_spin2_fill
'   cursor_x+=2
	sub	objptr, ##5776
	rdword	local02, objptr
	add	local02, #2
	wrword	local02, objptr
	sub	objptr, #60
LR__0101
' 
' if cursor_x>=256
	add	objptr, #60
	rdword	local02, objptr
	sub	objptr, #60
	cmps	local02, #256 wc
 if_b	jmp	#LR__0103
'   cursor_x:=0
	add	objptr, #60
	wrword	#0, objptr
'   cursor_y+=1
	add	objptr, #2
	rdbyte	local02, objptr
	add	local02, #1
	wrbyte	local02, objptr
'   if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	rdbyte	arg03, objptr
	sub	objptr, #62
	cmps	arg03, local02 wcz
 if_be	jmp	#LR__0102
'     scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup2
'     cursor_y:=st_lines-1
	add	objptr, #257
	rdlong	local02, objptr
	sub	local02, #1
	sub	objptr, #195
	wrbyte	local02, objptr
	sub	objptr, #62
LR__0102
LR__0103
' setspritepos(17,4*cursor_x,16*cursor_y+4 )
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_putchar_ret
	ret

'    
' ' a version for text scrolling in Basic shifted 4 lines down
' 
' pub scrollup2(start=0, end=600 , amount=16) | i
_hg010b_spin2_scrollup2
	mov	COUNT_, #3
	call	#pushregs_
' 	
' repeat i from 4 to 579 
	mov	local01, #4
LR__0110
	add	objptr, #221
	rdlong	arg02, objptr
	mov	arg05, local01
	add	arg05, #16
	shl	arg05, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg05, arg03
'   ram.read1($7E800, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
	shl	arg03, #2
	mov	arg01, ##518144
	add	objptr, ##5595
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_read1
	sub	objptr, ##5615
	rdlong	arg02, objptr
	mov	arg05, local01
	shl	arg05, #2
	add	objptr, #20
	rdlong	arg03, objptr
	qmul	arg05, arg03
'   ram.write($7E800, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
	shl	arg03, #2
	mov	arg01, ##518144
	add	objptr, ##5595
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_write
	sub	objptr, ##5836
	add	local01, #1
	cmp	local01, ##580 wc
 if_b	jmp	#LR__0110
' 
' repeat i from 580 to 599
	mov	local01, ##580
LR__0111
'    fastline(0,1023,i,write_background)   
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local01
	call	#_hg010b_spin2_fastline
	add	local01, #1
	cmp	local01, ##600 wc
 if_b	jmp	#LR__0111
' repeat i from 0 to 3
	mov	local01, #0
LR__0112
'    fastline(0,1023,i,write_background)      
	add	objptr, #69
	rdlong	arg04, objptr
	sub	objptr, #69
	mov	arg01, #0
	bmask	arg02, #9
	mov	arg03, local01
	call	#_hg010b_spin2_fastline
	add	local01, #1
	cmps	local01, #4 wc
 if_b	jmp	#LR__0112
' 
' repeat i from 0 to 35
	mov	local01, #0
LR__0113
	mov	arg05, local01
	add	arg05, #1
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	arg03, ptr__hg010b_spin2_dat__
	qmul	arg05, arg03
'   ram.read1($7E800, textbuf_ptr+(i+1)*timings[7], timings[7])
	add	objptr, #4
	rdlong	arg02, objptr
	sub	ptr__hg010b_spin2_dat__, ##14428
	mov	arg01, ##518144
	add	objptr, ##5832
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_read1
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	arg03, ptr__hg010b_spin2_dat__
	qmul	local01, arg03
'   ram.write($7E800, textbuf_ptr+i*timings[7], timings[7])
	sub	objptr, ##5832
	rdlong	arg02, objptr
	sub	ptr__hg010b_spin2_dat__, ##14428
	mov	arg01, ##518144
	add	objptr, ##5832
	getqx	arg05
	add	arg02, arg05
	call	#_psram_spin2_write
	sub	objptr, ##5836
	add	local01, #1
	cmps	local01, #36 wc
 if_b	jmp	#LR__0113
' repeat i from 0 to timings[7]-1
	mov	local01, #0
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	local02, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##14428
	sub	local02, #1
	cmps	local02, #0 wc
	negc	local03, #1
	add	local02, local03
LR__0114
'   ram.fill(textbuf_ptr+(36*timings[7]+i),32,1,0,1) 
	add	objptr, #4
	rdlong	arg01, objptr
	add	ptr__hg010b_spin2_dat__, ##14428
	rdlong	arg05, ptr__hg010b_spin2_dat__
	sub	ptr__hg010b_spin2_dat__, ##14428
	mov	arg04, arg05
	shl	arg04, #3
	add	arg04, arg05
	shl	arg04, #2
	add	arg04, local01
	add	arg01, arg04
	mov	arg02, #32
	mov	arg03, #1
	mov	arg04, #0
	mov	arg05, #1
	add	objptr, ##5832
	call	#_psram_spin2_fill
	sub	objptr, ##5836
	add	local01, local03
	cmp	local01, local02 wz
 if_ne	jmp	#LR__0114
	mov	ptra, fp
	call	#popregs_
_hg010b_spin2_scrollup2_ret
	ret

' 
' ''----------- Set cursor at the first character in a new line, scroll if needed 
' 
' pub crlf()
_hg010b_spin2_crlf
' 
' cursor_x:=leading_spaces*2
	add	objptr, ##694
	rdlong	arg03, objptr
	shl	arg03, #1
	sub	objptr, ##634
	wrword	arg03, objptr
' cursor_y+=1
	add	objptr, #2
	rdbyte	arg03, objptr
	add	arg03, #1
	wrbyte	arg03, objptr
' if cursor_y>st_lines-1
	add	objptr, #195
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #195
	rdbyte	arg02, objptr
	sub	objptr, #62
	cmps	arg02, arg03 wcz
 if_be	jmp	#LR__0120
'   scrollup2()
	mov	arg01, #0
	mov	arg02, ##600
	mov	arg03, #16
	call	#_hg010b_spin2_scrollup2
'   cursor_y:=st_lines-1
	add	objptr, #257
	rdlong	arg03, objptr
	sub	arg03, #1
	sub	objptr, #195
	wrbyte	arg03, objptr
	sub	objptr, #62
LR__0120
' setspritepos(17,4*cursor_x,16*cursor_y+4 )  
	add	objptr, #60
	rdword	arg02, objptr
	shl	arg02, #2
	add	objptr, #2
	rdbyte	arg03, objptr
	sub	objptr, #62
	shl	arg03, #4
	add	arg03, #4
	mov	arg01, #17
	call	#_hg010b_spin2_setspritepos
_hg010b_spin2_crlf_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB startx(freq, burst, delay, desiredcog) : result | driverAddr
_psram_spin2_startx
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg03
	mov	local03, arg04
'     stop() ' restart driver if required
	call	#_psram_spin2_stop
	cmp	local01, #0 wz
 if_e	rdlong	local01, #20
	abs	arg02, local01 wc
	qdiv	arg02, ##1000000
' 
'     ' use current frequency if none specified
' 
'     if freq == 0 
'         freq := clkfreq 
' 
'     ' compute the device burst size including overheads to keep CS low time below 8us
' 
'     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
'     if burst < 0
'         return ERR_TOO_SLOW ' P2 frequency is too low for any 8us transfers
	getqx	arg02
	negc	arg04, arg02
	shl	arg04, #3
	sub	arg04, #132
	shr	arg04, #4
	shl	arg04, #4
	cmps	arg04, #0 wc
 if_b	neg	result1, #14
 if_b	jmp	#LR__0134
' 
'     ' compute the input delay
' 
'     if delay <= 0
	cmps	local02, #1 wc
 if_ae	jmp	#LR__0130
'         delay := lookupDelay(freq)
	mov	arg01, local01
	call	#_psram_spin2_lookupDelay
	mov	local02, result1
	jmp	#LR__0131
LR__0130
'     else
'         delay <#= $f ' limit to 15
	fles	local02, #15
LR__0131
' 
'     ' create our lock
' 
'     driverlock := LOCKNEW()  
	mov	result1, #0
	locknew	result1
	add	ptr__psram_spin2_dat__, #260
	wrlong	result1, ptr__psram_spin2_dat__
'     if driverlock == -1
	sub	ptr__psram_spin2_dat__, #260
	cmp	result1, ##-1 wz
'         return ERR_NO_LOCK
 if_e	neg	result1, #26
 if_e	jmp	#LR__0134
' 
'     ' patch in the proper data and HUB addresses to the startup structure
' 
'     long[@startupData][0]:=clkfreq
	rdlong	local01, #20
	add	ptr__psram_spin2_dat__, #296
	wrlong	local01, ptr__psram_spin2_dat__
' '    long[@startupData][1]:=$1000_0000
'     long[@startupData][5]:=@deviceData
	mov	local01, ptr__psram_spin2_dat__
	add	local01, #32
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #20
	wrlong	local01, arg02
'     long[@startupData][6]:=@qosData
	mov	local01, ptr__psram_spin2_dat__
	add	local01, #160
	mov	arg02, ptr__psram_spin2_dat__
	add	arg02, #24
	wrlong	local01, arg02
'     long[@startupData][7]:=$7FF00
	mov	local01, ptr__psram_spin2_dat__
	add	local01, #28
	wrlong	##524032, local01
' 
'     ' setup some default bank and QoS parameter values
' 
'     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
	add	ptr__psram_spin2_dat__, #32
	mov	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #328
	shl	arg04, #16
	shl	local02, #12
	or	arg04, local02
	or	arg04, #24
	mov	arg02, arg04
	mov	arg03, #2
	call	#\builtin_longfill_
'     longfill(@qosData, $FFFF0000, 8)
	mov	arg01, ptr__psram_spin2_dat__
	add	arg01, #456
	mov	arg03, #7
	setq	arg03
	wrlong	##-65536, arg01
' 
'     ' get the address of the PSRAM memory driver so we can start it
' 
'     driverAddr:= driver.getDriverAddr()
'     return @driver_start
	mov	arg02, ptr__psram16drv_spin2_dat__
	add	arg02, #32
' 
'     ' start the PSRAM memory driver and wait for it to complete initialization
' 
'     if desiredcog < 0
	cmps	local03, #0 wc
'         desiredcog := NEWCOG
 if_b	mov	local03, #16
'     drivercog := coginit(desiredcog, driverAddr, @startupData)
	mov	arg03, ptr__psram_spin2_dat__
	add	arg03, #296
	mov	local04, local03
	setq	arg03
	coginit	local04, arg02 wc
 if_b	neg	local04, #1
	add	ptr__psram_spin2_dat__, #256
	wrlong	local04, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	callpa	#(@LR__0133-@LR__0132)>>2,fcache_load_ptr_
'     repeat until long[@startupData] == 0 
LR__0132
	mov	local04, ptr__psram_spin2_dat__
	add	local04, #296
	rdlong	local04, local04 wz
 if_ne	jmp	#LR__0132
LR__0133
' 
'     return drivercog
	add	ptr__psram_spin2_dat__, #256
	rdlong	result1, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
LR__0134
	mov	ptra, fp
	call	#popregs_
_psram_spin2_startx_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB stop() : i
_psram_spin2_stop
	mov	_var01, #0
'     if drivercog <> -1
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	arg01, ##-1 wz
 if_e	jmp	#LR__0143
'         cogstop(drivercog) ' a rather brutal stop
	add	ptr__psram_spin2_dat__, #256
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cogstop	arg01
	callpa	#(@LR__0142-@LR__0140)>>2,fcache_load_ptr_
'         repeat i from 0 to 7
LR__0140
'             if long[$7FF00][i*3] < 0
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##524032
	rdlong	result1, result1
	cmps	result1, #0 wc
 if_ae	jmp	#LR__0141
'                 long[$7FF00][i*3] := -ERR_ABORTED ' abort request
	mov	result1, _var01
	shl	result1, #1
	add	result1, _var01
	shl	result1, #2
	add	result1, ##524032
	wrlong	#16, result1
LR__0141
	add	_var01, #1
	cmps	_var01, #8 wc
 if_b	jmp	#LR__0140
LR__0142
'         drivercog := -1
	add	ptr__psram_spin2_dat__, #256
	wrlong	##-1, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
LR__0143
'     if driverlock <> -1
	add	ptr__psram_spin2_dat__, #260
	rdlong	_var02, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #260
	cmp	_var02, ##-1 wz
'         LOCKRET(driverlock)
 if_ne	add	ptr__psram_spin2_dat__, #260
 if_ne	rdlong	arg01, ptr__psram_spin2_dat__
 if_ne	lockret	arg01
'         driverlock := -1
 if_ne	wrlong	##-1, ptr__psram_spin2_dat__
 if_ne	sub	ptr__psram_spin2_dat__, #260
	mov	result1, _var01
_psram_spin2_stop_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB read1(dstHubAddr, srcAddr, count) : result | mailbox
_psram_spin2_read1
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__0151
'     if count == 0 ' don't even bother reading
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__0151
'     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	mov	_var02, ##524032
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__0151
'     long[mailbox][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox][1] := dstHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox] := driver.R_READBURST + (srcAddr & $1ffffff) ' trigger burst read operation
	mov	_var03, arg02
	bitl	_var03, #217
	mov	_var01, ##-1342177280
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__0150
'         result := long[mailbox]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__0150
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__0151
_psram_spin2_read1_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB write(srcHubAddr, dstAddr, count) : result | mailbox
_psram_spin2_write
' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var01, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__0161
'     if count == 0 ' don't even bother writing
	cmp	arg03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__0161
'     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
	mov	result1, #0
	cogid	result1
	mov	_var01, result1
	shl	_var01, #1
	add	_var01, result1
	shl	_var01, #2
	mov	_var02, ##524032
	add	_var02, _var01
'     if long[mailbox] < 0
	rdlong	_var01, _var02
	cmps	_var01, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__0161
'     long[mailbox][2] := count
	add	_var02, #8
	wrlong	arg03, _var02
'     long[mailbox][1] := srcHubAddr
	sub	_var02, #4
	wrlong	arg01, _var02
	sub	_var02, #4
'     long[mailbox] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
	mov	_var03, arg02
	bitl	_var03, #217
	mov	_var01, ##-268435456
	add	_var01, _var03
	wrlong	_var01, _var02
'     repeat
LR__0160
'         result := long[mailbox]    
	rdlong	_var03, _var02
	cmps	_var03, #0 wc
 if_b	jmp	#LR__0160
'     while result < 0   
'     return -result                       'return success or error
	neg	result1, _var03
LR__0161
_psram_spin2_write_ret
	ret

' 
' ' generalized fill
' PUB fill(addr, pattern, count, listPtr, datasize) : r | mailbox, req
_psram_spin2_fill
	mov	_var01, arg01
	mov	_var02, arg02
	mov	_var03, arg03
	mov	_var04, arg05
'     case datasize 
	sub	_var04, #1
	fle	_var04, #4
	jmprel	_var04
LR__0170
	jmp	#LR__0171
	jmp	#LR__0172
	jmp	#LR__0174
	jmp	#LR__0173
	jmp	#LR__0174
LR__0171
'         1: req := driver.R_WRITEBYTE
	mov	_var05, ##-1073741824
	jmp	#LR__0175
LR__0172
'         2: req := driver.R_WRITEWORD
	mov	_var05, ##-805306368
	jmp	#LR__0175
LR__0173
'         4: req := driver.R_WRITELONG
	mov	_var05, ##-536870912
	jmp	#LR__0175
LR__0174
'         other : return ERR_INVALID
	neg	result1, #6
	jmp	#LR__0177
LR__0175
'     if count == 0   ' nothing to do
	cmp	_var03, #0 wz
'         return 0
 if_e	mov	result1, #0
 if_e	jmp	#LR__0177
'     if drivercog == -1
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var04, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var04, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__0177
'     mailbox := $7FF00 + 12*cogid() ' get mailbox base address for this COG
	mov	result1, #0
	cogid	result1
	mov	_var04, result1
	shl	_var04, #1
	add	_var04, result1
	shl	_var04, #2
	mov	_var06, ##524032
	add	_var06, _var04
'     if long[mailbox] < 0
	rdlong	_var04, _var06
	cmps	_var04, #0 wc
'         return ERR_MAILBOX_BUSY
 if_b	neg	result1, #28
 if_b	jmp	#LR__0177
'     long[mailbox][2] := count
	add	_var06, #8
	wrlong	_var03, _var06
'     long[mailbox][1] := pattern
	sub	_var06, #4
	wrlong	_var02, _var06
	sub	_var06, #4
'     long[mailbox] := req + (addr & $1ffffff)
	mov	_var07, _var05
	mov	_var08, _var01
	bitl	_var08, #217
	add	_var07, _var08
	wrlong	_var07, _var06
'     repeat
LR__0176
'         r := long[mailbox]
	rdlong	_var08, _var06
	cmps	_var08, #0 wc
 if_b	jmp	#LR__0176
'     while r < 0
'     return -r                  ' return 0 for success or negated error code
	neg	result1, _var08
LR__0177
_psram_spin2_fill_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PUB setQos(cog, qos) : result | mailbox
_psram_spin2_setQos
	mov	_var01, arg01
'     if drivercog == -1 ' driver must be running
	add	ptr__psram_spin2_dat__, #256
	rdlong	_var02, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #256
	cmp	_var02, ##-1 wz
'         return ERR_INACTIVE
 if_e	neg	result1, #15
 if_e	jmp	#LR__0184
'     if cog < 0 or cog > 7 ' enforce cog id range
	cmps	_var01, #0 wc
 if_b	jmp	#LR__0180
	cmps	_var01, #8 wc
 if_b	jmp	#LR__0181
LR__0180
'         return ERR_INVALID
	neg	result1, #6
	jmp	#LR__0184
LR__0181
'     long[@qosData][cog] := qos & !$1ff
	andn	arg02, #511
	add	ptr__psram_spin2_dat__, #456
	shl	_var01, #2
	add	_var01, ptr__psram_spin2_dat__
	wrlong	arg02, _var01
'     mailbox := $7FF00 + drivercog*12
	sub	ptr__psram_spin2_dat__, #200
	rdlong	_var03, ptr__psram_spin2_dat__
	mov	_var04, _var03
	shl	_var04, #1
	add	_var04, _var03
	shl	_var04, #2
	mov	_var05, ##524032
	add	_var05, _var04
'     repeat until LOCKTRY(driverlock)
	add	ptr__psram_spin2_dat__, #4
LR__0182
	rdlong	arg01, ptr__psram_spin2_dat__
	locktry	arg01 wc
 if_ae	jmp	#LR__0182
	sub	ptr__psram_spin2_dat__, #260
'     long[mailbox] := driver.R_CONFIG + cogid()
	mov	_var04, #0
	cogid	_var04
	mov	_var02, ##-268435456
	add	_var02, _var04
	wrlong	_var02, _var05
'     repeat while long[mailbox] < 0
LR__0183
	rdlong	_var02, _var05
	cmps	_var02, #0 wc
 if_b	jmp	#LR__0183
'     LOCKREL(driverlock)
	add	ptr__psram_spin2_dat__, #260
	rdlong	arg01, ptr__psram_spin2_dat__
	sub	ptr__psram_spin2_dat__, #260
	lockrel	arg01 wc
	mov	result1, #0
LR__0184
_psram_spin2_setQos_ret
	ret

' 
' '..............................................................................
' 
' {{
' }}
' PRI lookupDelay(freq) : delay | profile
_psram_spin2_lookupDelay
'     profile := @delayTable
	mov	_var01, ptr__psram_spin2_dat__
	add	_var01, #264
'     delay := long[profile][0]
	rdlong	_var02, _var01
	callpa	#(@LR__0191-@LR__0190)>>2,fcache_load_ptr_
'     repeat while long[profile][1] 
LR__0190
	add	_var01, #4
	rdlong	result1, _var01 wz
	sub	_var01, #4
 if_e	jmp	#LR__0192
'         if freq +< long[profile][1] 
	add	_var01, #4
	rdlong	result1, _var01
	sub	_var01, #4
	cmp	arg01, result1 wc
'             quit
'         profile += 4
 if_ae	add	_var01, #4
'         delay++
 if_ae	add	_var02, #1
 if_ae	jmp	#LR__0190
LR__0191
LR__0192
	mov	result1, _var02
_psram_spin2_lookupDelay_ret
	ret

' 
' PUB start() : r
_usbnew_spin2_start
	mov	_var01, #0
'   ifnot driver_cog
	add	ptr__usbnew_spin2_dat__, ##10887
	rdbyte	_var02, ptr__usbnew_spin2_dat__ wz
	sub	ptr__usbnew_spin2_dat__, ##10887
 if_ne	jmp	#LR__0200
'     r := coginit(COGEXEC_NEW,@usb_host_start,0)
	mov	arg02, ptr__usbnew_spin2_dat__
	mov	_var01, #16
	mov	arg03, #0
	setq	arg03
	coginit	_var01, arg02 wc
 if_b	neg	_var01, #1
'     if r >= 0
	cmps	_var01, #0 wc
'       driver_cog := r+1
 if_ae	mov	_var02, _var01
 if_ae	add	_var02, #1
 if_ae	add	ptr__usbnew_spin2_dat__, ##10887
 if_ae	wrbyte	_var02, ptr__usbnew_spin2_dat__
 if_ae	sub	ptr__usbnew_spin2_dat__, ##10887
LR__0200
	mov	result1, _var01
_usbnew_spin2_start_ret
	ret

'     '' Set KEYQUEUE_SIZE to enable (recommended value: 32)
' 
' '' Return key event from buffer if there is one
' PUB get_key() : r | tail
_usbnew_spin2_get_key
'   tail := keyq_tail
	add	ptr__usbnew_spin2_dat__, ##7893
	rdbyte	_var01, ptr__usbnew_spin2_dat__
'   if keyq_head == tail
	sub	ptr__usbnew_spin2_dat__, #1
	rdbyte	_var02, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7892
	cmp	_var02, _var01 wz
'     return 0 ' No event
 if_e	mov	result1, #0
 if_e	jmp	#_usbnew_spin2_get_key_ret
'   r := keyq_data[tail]
	mov	_var02, _var01
	shl	_var02, #2
	mov	result1, ptr__usbnew_spin2_dat__
	add	result1, ##7894
	add	_var02, result1
	rdlong	result1, _var02
'   if ++tail == KEYQUEUE_SIZE
	add	_var01, #1
	cmp	_var01, #128 wz
'     tail := 0
 if_e	mov	_var01, #0
'   keyq_tail := tail
	add	ptr__usbnew_spin2_dat__, ##7893
	wrbyte	_var01, ptr__usbnew_spin2_dat__
	sub	ptr__usbnew_spin2_dat__, ##7893
_usbnew_spin2_get_key_ret
	ret

_life_b_program
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, #0
	mov	arg01, __sendreg
	mov	arg02, #0
	call	#__system___funcptr_cmp
	cmp	result1, #0 wz
 if_e	mov	__sendreg, objptr
	mov	arg01, __recvreg
	mov	arg02, #0
	call	#__system___funcptr_cmp
	cmp	result1, #0 wz
 if_e	mov	__recvreg, objptr
 if_e	decod	arg02, #20
 if_e	bith	__recvreg, #20
	mov	result1, local01
	add	result1, objptr
	mov	arg01, local01
	add	arg01, objptr
	rdbyte	arg01, arg01
	add	arg01, #1
	wrbyte	arg01, result1
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #4
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0212
	callpa	#(@LR__0211-@LR__0210)>>2,fcache_load_ptr_
LR__0210
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #4
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0210
LR__0211
LR__0212
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0215
	callpa	#(@LR__0214-@LR__0213)>>2,fcache_load_ptr_
LR__0213
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #6
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0213
LR__0214
LR__0215
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0637
LR__0216
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0219
	callpa	#(@LR__0218-@LR__0217)>>2,fcache_load_ptr_
LR__0217
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0217
LR__0218
LR__0219
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0222
	callpa	#(@LR__0221-@LR__0220)>>2,fcache_load_ptr_
LR__0220
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #6
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0220
LR__0221
LR__0222
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #4
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0225
	callpa	#(@LR__0224-@LR__0223)>>2,fcache_load_ptr_
LR__0223
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #8
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0223
LR__0224
LR__0225
	add	local01, #1
	zerox	local01, #14
	mov	local02, __sendreg
	mov	local05, __sendreg
	zerox	local02, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	local06, local01
	add	local06, objptr
	rdbyte	arg01, local06
	mov	local06, objptr
	mov	objptr, local02
	call	local05
	mov	objptr, local06
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0228
	callpa	#(@LR__0227-@LR__0226)>>2,fcache_load_ptr_
LR__0226
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0226
LR__0227
LR__0228
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #3
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0231
	callpa	#(@LR__0230-@LR__0229)>>2,fcache_load_ptr_
LR__0229
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #3
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0229
LR__0230
LR__0231
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0233
LR__0232
	add	local01, #2
	zerox	local01, #14
	mov	local02, __sendreg
	mov	local05, __sendreg
	zerox	local02, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	local06, local01
	add	local06, objptr
	rdbyte	arg01, local06
	mov	local06, objptr
	mov	objptr, local02
	call	local05
	mov	objptr, local06
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0232
LR__0233
	add	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0236
	callpa	#(@LR__0235-@LR__0234)>>2,fcache_load_ptr_
LR__0234
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0234
LR__0235
LR__0236
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #2
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0239
	callpa	#(@LR__0238-@LR__0237)>>2,fcache_load_ptr_
LR__0237
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #5
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0237
LR__0238
LR__0239
	sub	local01, #1
	zerox	local01, #14
	mov	local02, __sendreg
	mov	local05, __sendreg
	zerox	local02, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	local06, local01
	add	local06, objptr
	rdbyte	arg01, local06
	mov	local06, objptr
	mov	objptr, local02
	call	local05
	mov	objptr, local06
	sub	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0242
	callpa	#(@LR__0241-@LR__0240)>>2,fcache_load_ptr_
LR__0240
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0240
LR__0241
LR__0242
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0245
	callpa	#(@LR__0244-@LR__0243)>>2,fcache_load_ptr_
LR__0243
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #6
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0243
LR__0244
LR__0245
	sub	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0299
LR__0246
	add	local01, #4
	zerox	local01, #14
	mov	local02, __sendreg
	mov	local05, __sendreg
	zerox	local02, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	local06, local01
	mov	local07, objptr
	add	local06, objptr
	rdbyte	arg01, local06
	mov	local06, objptr
	mov	objptr, local02
	call	local05
	mov	objptr, local06
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #10
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0295
LR__0247
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0250
	callpa	#(@LR__0249-@LR__0248)>>2,fcache_load_ptr_
LR__0248
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0248
LR__0249
LR__0250
	add	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0253
	callpa	#(@LR__0252-@LR__0251)>>2,fcache_load_ptr_
LR__0251
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #11
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0251
LR__0252
LR__0253
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0256
	callpa	#(@LR__0255-@LR__0254)>>2,fcache_load_ptr_
LR__0254
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0254
LR__0255
LR__0256
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0259
	callpa	#(@LR__0258-@LR__0257)>>2,fcache_load_ptr_
LR__0257
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0257
LR__0258
LR__0259
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0262
	callpa	#(@LR__0261-@LR__0260)>>2,fcache_load_ptr_
LR__0260
	add	local01, #12
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #13
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0260
LR__0261
LR__0262
	add	local01, #12
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0269
	callpa	#(@LR__0268-@LR__0263)>>2,fcache_load_ptr_
LR__0263
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0265
LR__0264
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0264
LR__0265
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0267
LR__0266
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0266
LR__0267
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0263
LR__0268
LR__0269
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0272
	callpa	#(@LR__0271-@LR__0270)>>2,fcache_load_ptr_
LR__0270
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0270
LR__0271
LR__0272
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0275
	callpa	#(@LR__0274-@LR__0273)>>2,fcache_load_ptr_
LR__0273
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0273
LR__0274
LR__0275
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0282
	callpa	#(@LR__0281-@LR__0276)>>2,fcache_load_ptr_
LR__0276
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0278
LR__0277
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0277
LR__0278
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0280
LR__0279
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0279
LR__0280
	sub	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0276
LR__0281
LR__0282
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #9
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0285
	callpa	#(@LR__0284-@LR__0283)>>2,fcache_load_ptr_
LR__0283
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #5
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0283
LR__0284
LR__0285
	add	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0288
	callpa	#(@LR__0287-@LR__0286)>>2,fcache_load_ptr_
LR__0286
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0286
LR__0287
LR__0288
	sub	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0291
	callpa	#(@LR__0290-@LR__0289)>>2,fcache_load_ptr_
LR__0289
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #3
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0289
LR__0290
LR__0291
	add	local01, #1
	zerox	local01, #14
	mov	local02, __sendreg
	mov	local05, __sendreg
	zerox	local02, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	local09, local01
	mov	local07, objptr
	add	local09, objptr
	rdbyte	arg01, local09
	mov	local08, objptr
	mov	objptr, local02
	call	local05
	mov	objptr, local08
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0294
	callpa	#(@LR__0293-@LR__0292)>>2,fcache_load_ptr_
LR__0292
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0292
LR__0293
LR__0294
	sub	local01, #17
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local02, local01
	mov	local05, local02
	mov	local04, objptr
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0247
LR__0295
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #10
	wrbyte	local04, local02
	mov	local02, __sendreg
	mov	local05, __sendreg
	zerox	local02, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	local09, local01
	add	local09, objptr
	rdbyte	arg01, local09
	mov	local08, objptr
	mov	objptr, local02
	call	local05
	mov	objptr, local08
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0298
	callpa	#(@LR__0297-@LR__0296)>>2,fcache_load_ptr_
LR__0296
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0296
LR__0297
LR__0298
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0246
LR__0299
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0302
	callpa	#(@LR__0301-@LR__0300)>>2,fcache_load_ptr_
LR__0300
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0300
LR__0301
LR__0302
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0305
	callpa	#(@LR__0304-@LR__0303)>>2,fcache_load_ptr_
LR__0303
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0303
LR__0304
LR__0305
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #8
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0308
	callpa	#(@LR__0307-@LR__0306)>>2,fcache_load_ptr_
LR__0306
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #8
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0306
LR__0307
LR__0308
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #2
	wrbyte	local04, local02
	mov	local02, __sendreg
	mov	local05, __sendreg
	zerox	local02, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	local09, local01
	mov	local07, objptr
	add	local09, objptr
	rdbyte	arg01, local09
	mov	local08, objptr
	mov	objptr, local02
	call	local05
	mov	objptr, local08
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0311
	callpa	#(@LR__0310-@LR__0309)>>2,fcache_load_ptr_
LR__0309
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0309
LR__0310
LR__0311
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, __recvreg
	mov	local03, __recvreg
	zerox	local08, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	local09, objptr
	mov	objptr, local08
	call	local03
	mov	objptr, local09
	wrbyte	result1, local02
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #10
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0314
	callpa	#(@LR__0313-@LR__0312)>>2,fcache_load_ptr_
LR__0312
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0312
LR__0313
LR__0314
	add	local01, #6
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0319
	callpa	#(@LR__0318-@LR__0315)>>2,fcache_load_ptr_
LR__0315
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0317
LR__0316
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0316
LR__0317
	sub	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0315
LR__0318
LR__0319
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #10
	wrbyte	local04, local02
	add	local01, #5
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0382
LR__0320
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0323
	callpa	#(@LR__0322-@LR__0321)>>2,fcache_load_ptr_
LR__0321
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0321
LR__0322
LR__0323
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, __recvreg
	mov	local03, __recvreg
	zerox	local08, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	local09, objptr
	mov	objptr, local08
	call	local03
	mov	objptr, local09
	wrbyte	result1, local02
	sub	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	add	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0326
	callpa	#(@LR__0325-@LR__0324)>>2,fcache_load_ptr_
LR__0324
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0324
LR__0325
LR__0326
	sub	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0329
	callpa	#(@LR__0328-@LR__0327)>>2,fcache_load_ptr_
LR__0327
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0327
LR__0328
LR__0329
	add	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #10
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0381
LR__0330
	sub	local01, #8
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0333
	callpa	#(@LR__0332-@LR__0331)>>2,fcache_load_ptr_
LR__0331
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0331
LR__0332
LR__0333
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0336
	callpa	#(@LR__0335-@LR__0334)>>2,fcache_load_ptr_
LR__0334
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #6
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0334
LR__0335
LR__0336
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0339
	callpa	#(@LR__0338-@LR__0337)>>2,fcache_load_ptr_
LR__0337
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0337
LR__0338
LR__0339
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #10
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0342
	callpa	#(@LR__0341-@LR__0340)>>2,fcache_load_ptr_
LR__0340
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #11
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0340
LR__0341
LR__0342
	sub	local01, #6
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0345
	callpa	#(@LR__0344-@LR__0343)>>2,fcache_load_ptr_
LR__0343
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0343
LR__0344
LR__0345
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0348
	callpa	#(@LR__0347-@LR__0346)>>2,fcache_load_ptr_
LR__0346
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #6
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0346
LR__0347
LR__0348
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0351
	callpa	#(@LR__0350-@LR__0349)>>2,fcache_load_ptr_
LR__0349
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0349
LR__0350
LR__0351
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #10
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0354
	callpa	#(@LR__0353-@LR__0352)>>2,fcache_load_ptr_
LR__0352
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0352
LR__0353
LR__0354
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0357
	callpa	#(@LR__0356-@LR__0355)>>2,fcache_load_ptr_
LR__0355
	add	local01, #12
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #13
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0355
LR__0356
LR__0357
	add	local01, #12
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0364
	callpa	#(@LR__0363-@LR__0358)>>2,fcache_load_ptr_
LR__0358
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0360
LR__0359
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0359
LR__0360
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0362
LR__0361
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0361
LR__0362
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0358
LR__0363
LR__0364
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0367
	callpa	#(@LR__0366-@LR__0365)>>2,fcache_load_ptr_
LR__0365
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0365
LR__0366
LR__0367
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0370
	callpa	#(@LR__0369-@LR__0368)>>2,fcache_load_ptr_
LR__0368
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0368
LR__0369
LR__0370
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0377
	callpa	#(@LR__0376-@LR__0371)>>2,fcache_load_ptr_
LR__0371
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0373
LR__0372
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0372
LR__0373
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0375
LR__0374
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0374
LR__0375
	sub	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0371
LR__0376
LR__0377
	sub	local01, #11
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, __recvreg
	mov	local03, __recvreg
	zerox	local08, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	local09, objptr
	mov	objptr, local08
	call	local03
	mov	objptr, local09
	wrbyte	result1, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0380
	callpa	#(@LR__0379-@LR__0378)>>2,fcache_load_ptr_
LR__0378
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0378
LR__0379
LR__0380
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0330
LR__0381
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0320
LR__0382
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0636
LR__0383
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #11
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0386
	callpa	#(@LR__0385-@LR__0384)>>2,fcache_load_ptr_
LR__0384
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #11
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #11
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0384
LR__0385
LR__0386
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0446
LR__0387
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0390
	callpa	#(@LR__0389-@LR__0388)>>2,fcache_load_ptr_
LR__0388
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0388
LR__0389
LR__0390
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0393
	callpa	#(@LR__0392-@LR__0391)>>2,fcache_load_ptr_
LR__0391
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0391
LR__0392
LR__0393
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0400
	callpa	#(@LR__0399-@LR__0394)>>2,fcache_load_ptr_
LR__0394
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0396
LR__0395
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0395
LR__0396
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0398
LR__0397
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0397
LR__0398
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0394
LR__0399
LR__0400
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0403
	callpa	#(@LR__0402-@LR__0401)>>2,fcache_load_ptr_
LR__0401
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0401
LR__0402
LR__0403
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0406
	callpa	#(@LR__0405-@LR__0404)>>2,fcache_load_ptr_
LR__0404
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0404
LR__0405
LR__0406
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0413
	callpa	#(@LR__0412-@LR__0407)>>2,fcache_load_ptr_
LR__0407
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0409
LR__0408
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0408
LR__0409
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0411
LR__0410
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0410
LR__0411
	sub	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0407
LR__0412
LR__0413
	sub	local01, #8
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0416
	callpa	#(@LR__0415-@LR__0414)>>2,fcache_load_ptr_
LR__0414
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0414
LR__0415
LR__0416
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0419
	callpa	#(@LR__0418-@LR__0417)>>2,fcache_load_ptr_
LR__0417
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0417
LR__0418
LR__0419
	sub	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0422
	callpa	#(@LR__0421-@LR__0420)>>2,fcache_load_ptr_
LR__0420
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0420
LR__0421
LR__0422
	add	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0425
	callpa	#(@LR__0424-@LR__0423)>>2,fcache_load_ptr_
LR__0423
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #6
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0423
LR__0424
LR__0425
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0434
	callpa	#(@LR__0433-@LR__0426)>>2,fcache_load_ptr_
LR__0426
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0428
LR__0427
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0427
LR__0428
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0430
LR__0429
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0429
LR__0430
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0432
LR__0431
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0431
LR__0432
	add	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0426
LR__0433
LR__0434
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0437
	callpa	#(@LR__0436-@LR__0435)>>2,fcache_load_ptr_
LR__0435
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0435
LR__0436
LR__0437
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0440
	callpa	#(@LR__0439-@LR__0438)>>2,fcache_load_ptr_
LR__0438
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0438
LR__0439
LR__0440
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0445
	callpa	#(@LR__0444-@LR__0441)>>2,fcache_load_ptr_
LR__0441
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0443
LR__0442
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0442
LR__0443
	sub	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0441
LR__0444
LR__0445
	sub	local01, #8
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0387
LR__0446
	sub	local01, #10
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #10
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0632
LR__0447
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #10
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0631
LR__0448
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0451
	callpa	#(@LR__0450-@LR__0449)>>2,fcache_load_ptr_
LR__0449
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0449
LR__0450
LR__0451
	add	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0454
	callpa	#(@LR__0453-@LR__0452)>>2,fcache_load_ptr_
LR__0452
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #11
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0452
LR__0453
LR__0454
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0457
	callpa	#(@LR__0456-@LR__0455)>>2,fcache_load_ptr_
LR__0455
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0455
LR__0456
LR__0457
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0460
	callpa	#(@LR__0459-@LR__0458)>>2,fcache_load_ptr_
LR__0458
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0458
LR__0459
LR__0460
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0463
	callpa	#(@LR__0462-@LR__0461)>>2,fcache_load_ptr_
LR__0461
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0461
LR__0462
LR__0463
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0466
	callpa	#(@LR__0465-@LR__0464)>>2,fcache_load_ptr_
LR__0464
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #8
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0464
LR__0465
LR__0466
	add	local01, #9
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0469
	callpa	#(@LR__0468-@LR__0467)>>2,fcache_load_ptr_
LR__0467
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0467
LR__0468
LR__0469
	add	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0472
	callpa	#(@LR__0471-@LR__0470)>>2,fcache_load_ptr_
LR__0470
	sub	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0470
LR__0471
LR__0472
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #12
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0475
	callpa	#(@LR__0474-@LR__0473)>>2,fcache_load_ptr_
LR__0473
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0473
LR__0474
LR__0475
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0478
	callpa	#(@LR__0477-@LR__0476)>>2,fcache_load_ptr_
LR__0476
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0476
LR__0477
LR__0478
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0485
	callpa	#(@LR__0484-@LR__0479)>>2,fcache_load_ptr_
LR__0479
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0481
LR__0480
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0480
LR__0481
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0483
LR__0482
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0482
LR__0483
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0479
LR__0484
LR__0485
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0488
	callpa	#(@LR__0487-@LR__0486)>>2,fcache_load_ptr_
LR__0486
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0486
LR__0487
LR__0488
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0491
	callpa	#(@LR__0490-@LR__0489)>>2,fcache_load_ptr_
LR__0489
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0489
LR__0490
LR__0491
	add	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0494
	callpa	#(@LR__0493-@LR__0492)>>2,fcache_load_ptr_
LR__0492
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0492
LR__0493
LR__0494
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0497
	callpa	#(@LR__0496-@LR__0495)>>2,fcache_load_ptr_
LR__0495
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0495
LR__0496
LR__0497
	add	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0500
	callpa	#(@LR__0499-@LR__0498)>>2,fcache_load_ptr_
LR__0498
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0498
LR__0499
LR__0500
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0503
	callpa	#(@LR__0502-@LR__0501)>>2,fcache_load_ptr_
LR__0501
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #9
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #6
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0501
LR__0502
LR__0503
	sub	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0510
	callpa	#(@LR__0509-@LR__0504)>>2,fcache_load_ptr_
LR__0504
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0506
LR__0505
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0505
LR__0506
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0508
LR__0507
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0507
LR__0508
	sub	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0504
LR__0509
LR__0510
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0513
	callpa	#(@LR__0512-@LR__0511)>>2,fcache_load_ptr_
LR__0511
	sub	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0511
LR__0512
LR__0513
	sub	local01, #9
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #11
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0516
	callpa	#(@LR__0515-@LR__0514)>>2,fcache_load_ptr_
LR__0514
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0514
LR__0515
LR__0516
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0519
	callpa	#(@LR__0518-@LR__0517)>>2,fcache_load_ptr_
LR__0517
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0517
LR__0518
LR__0519
	add	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0526
	callpa	#(@LR__0525-@LR__0520)>>2,fcache_load_ptr_
LR__0520
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0522
LR__0521
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0521
LR__0522
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0524
LR__0523
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0523
LR__0524
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0520
LR__0525
LR__0526
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0529
	callpa	#(@LR__0528-@LR__0527)>>2,fcache_load_ptr_
LR__0527
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0527
LR__0528
LR__0529
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0532
	callpa	#(@LR__0531-@LR__0530)>>2,fcache_load_ptr_
LR__0530
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0530
LR__0531
LR__0532
	add	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0535
	callpa	#(@LR__0534-@LR__0533)>>2,fcache_load_ptr_
LR__0533
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0533
LR__0534
LR__0535
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0538
	callpa	#(@LR__0537-@LR__0536)>>2,fcache_load_ptr_
LR__0536
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0536
LR__0537
LR__0538
	add	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0541
	callpa	#(@LR__0540-@LR__0539)>>2,fcache_load_ptr_
LR__0539
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0539
LR__0540
LR__0541
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0544
	callpa	#(@LR__0543-@LR__0542)>>2,fcache_load_ptr_
LR__0542
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #9
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #6
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0542
LR__0543
LR__0544
	sub	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0551
	callpa	#(@LR__0550-@LR__0545)>>2,fcache_load_ptr_
LR__0545
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0547
LR__0546
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0546
LR__0547
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0549
LR__0548
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0548
LR__0549
	sub	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0545
LR__0550
LR__0551
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0554
	callpa	#(@LR__0553-@LR__0552)>>2,fcache_load_ptr_
LR__0552
	sub	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0552
LR__0553
LR__0554
	sub	local01, #9
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #11
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0557
	callpa	#(@LR__0556-@LR__0555)>>2,fcache_load_ptr_
LR__0555
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #8
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0555
LR__0556
LR__0557
	add	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0564
	callpa	#(@LR__0563-@LR__0558)>>2,fcache_load_ptr_
LR__0558
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0560
LR__0559
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0559
LR__0560
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0562
LR__0561
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0561
LR__0562
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0558
LR__0563
LR__0564
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0567
	callpa	#(@LR__0566-@LR__0565)>>2,fcache_load_ptr_
LR__0565
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0565
LR__0566
LR__0567
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0570
	callpa	#(@LR__0569-@LR__0568)>>2,fcache_load_ptr_
LR__0568
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0568
LR__0569
LR__0570
	add	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0573
	callpa	#(@LR__0572-@LR__0571)>>2,fcache_load_ptr_
LR__0571
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0571
LR__0572
LR__0573
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0576
	callpa	#(@LR__0575-@LR__0574)>>2,fcache_load_ptr_
LR__0574
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #5
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #2
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0574
LR__0575
LR__0576
	add	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0579
	callpa	#(@LR__0578-@LR__0577)>>2,fcache_load_ptr_
LR__0577
	sub	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0577
LR__0578
LR__0579
	sub	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0582
	callpa	#(@LR__0581-@LR__0580)>>2,fcache_load_ptr_
LR__0580
	add	local01, #3
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #9
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #6
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0580
LR__0581
LR__0582
	sub	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0589
	callpa	#(@LR__0588-@LR__0583)>>2,fcache_load_ptr_
LR__0583
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0585
LR__0584
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0584
LR__0585
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0587
LR__0586
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0586
LR__0587
	sub	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0583
LR__0588
LR__0589
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0592
	callpa	#(@LR__0591-@LR__0590)>>2,fcache_load_ptr_
LR__0590
	sub	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0590
LR__0591
LR__0592
	sub	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #4
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0627
LR__0593
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0598
	callpa	#(@LR__0597-@LR__0594)>>2,fcache_load_ptr_
LR__0594
	add	local01, #7
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	sub	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0596
LR__0595
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0595
LR__0596
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0594
LR__0597
LR__0598
	sub	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0601
	callpa	#(@LR__0600-@LR__0599)>>2,fcache_load_ptr_
LR__0599
	add	local01, #12
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #13
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0599
LR__0600
LR__0601
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0603
LR__0602
	mov	local02, __sendreg
	mov	local05, __sendreg
	zerox	local02, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	local09, local01
	add	local09, objptr
	rdbyte	arg01, local09
	mov	local08, objptr
	mov	objptr, local02
	call	local05
	mov	objptr, __sendreg
	mov	local05, __sendreg
	zerox	objptr, #19
	shr	local05, #20
	shl	local05, #2
	add	local05, __methods__
	rdlong	local05, local05
	mov	local09, local01
	mov	local07, local08
	add	local09, local08
	rdbyte	arg01, local09
	call	local05
	mov	objptr, local08
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0602
LR__0603
	add	local01, #12
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0612
	callpa	#(@LR__0611-@LR__0604)>>2,fcache_load_ptr_
LR__0604
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0606
LR__0605
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0605
LR__0606
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0608
LR__0607
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0607
LR__0608
	add	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0610
LR__0609
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0609
LR__0610
	add	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0604
LR__0611
LR__0612
	add	local01, #3
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0615
	callpa	#(@LR__0614-@LR__0613)>>2,fcache_load_ptr_
LR__0613
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0613
LR__0614
LR__0615
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0618
	callpa	#(@LR__0617-@LR__0616)>>2,fcache_load_ptr_
LR__0616
	add	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0616
LR__0617
LR__0618
	sub	local01, #1
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0623
	callpa	#(@LR__0622-@LR__0619)>>2,fcache_load_ptr_
LR__0619
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0621
LR__0620
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	add	local04, #1
	wrbyte	local04, local02
	add	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0620
LR__0621
	sub	local01, #4
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0619
LR__0622
LR__0623
	sub	local01, #6
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0626
	callpa	#(@LR__0625-@LR__0624)>>2,fcache_load_ptr_
LR__0624
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0624
LR__0625
LR__0626
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0593
LR__0627
	sub	local01, #7
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0630
	callpa	#(@LR__0629-@LR__0628)>>2,fcache_load_ptr_
LR__0628
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0628
LR__0629
LR__0630
	sub	local01, #4
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local08, local01
	mov	local03, local08
	mov	local09, objptr
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local02, local01
	mov	local05, local02
	mov	local04, objptr
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0448
LR__0631
	sub	local01, #1
	zerox	local01, #14
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0447
LR__0632
	add	local01, #11
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_e	jmp	#LR__0635
	callpa	#(@LR__0634-@LR__0633)>>2,fcache_load_ptr_
LR__0633
	mov	local02, local01
	add	local02, objptr
	mov	local03, local01
	add	local03, objptr
	rdbyte	local04, local03
	sub	local04, #1
	wrbyte	local04, local02
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0633
LR__0634
LR__0635
	sub	local01, #2
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0383
LR__0636
	sub	local01, #10
	zerox	local01, #14
	mov	local05, local01
	add	local05, objptr
	rdbyte	local06, local05 wz
 if_ne	jmp	#LR__0216
LR__0637
	mov	ptra, fp
	call	#popregs_
_life_b_program_ret
	ret
hubexit
	jmp	#cogexit

__system___setbaud
	rdlong	muldiva_, #20
	mov	muldivb_, arg01
	call	#divide_
	callpa	#(@LR__0641-@LR__0640)>>2,fcache_load_ptr_
LR__0640
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__0640
LR__0641
	dirl	#62
	dirl	#63
	wrlong	muldivb_, ptr___system__dat__
	shl	muldivb_, #16
	mov	arg02, #7
	add	arg02, muldivb_
	wrpin	#124, #62
	wxpin	arg02, #62
	wrpin	#62, #63
	add	arg02, #20
	wxpin	arg02, #63
	dirh	#62
	dirh	#63
__system___setbaud_ret
	ret

__system___txraw
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	callpa	#(@LR__0651-@LR__0650)>>2,fcache_load_ptr_
LR__0650
	rdpin	result1, #62 wc
	subx	result2, result2
 if_b	jmp	#LR__0650
LR__0651
	rdlong	result1, ptr___system__dat__ wz
 if_e	mov	arg01, ##2000000
 if_e	call	#__system___setbaud
	drvl	#62
	wypin	local01, #62
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___txraw_ret
	ret

__system___rxraw
	mov	COUNT_, #13
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, ptr___system__dat__ wz
 if_e	mov	arg01, ##2000000
 if_e	call	#__system___setbaud
	cmp	local01, #0 wz
 if_e	jmp	#LR__0660
	rdlong	local03, #20
	shr	local03, #10
	qmul	local01, local03
	getct	result1
	getqx	local04
	add	result1, local04
	mov	local05, result1
	jmp	#LR__0661
LR__0660
	mov	local05, #0
LR__0661
	neg	local06, #1
	mov	local07, #63
	mov	local08, #0
	add	ptr___system__dat__, #4
	rdlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
LR__0662
	testb	local09, #8 wc
	testbn	local09, #9 andc
	shr	local09, #10
 if_b	mov	local08, #1
 if_ae	testp	#63 wz
 if_nc_and_z	mov	local08, #1
 if_nc_and_z	rdpin	local09, #63
 if_nc_and_z	shr	local09, #4
LR__0663
	mov	local02, #0
	cmp	local08, #0 wz
 if_ne	neg	local02, #1
	mov	local10, #0
	mov	local03, #0
	cmp	local01, #0 wz
 if_ne	neg	local03, #1
	mov	local04, #0
	mov	local11, #0
	mov	local12, local05
	getct	result1
	mov	local13, result1
	sub	local12, local13
	cmps	local12, #0 wc
 if_b	not	local11, #0
	cmp	local11, #0 wz
 if_ne	not	local04, #0
	test	local03, local04 wz
 if_ne	not	local10, #0
	or	local02, local10 wz
 if_e	jmp	#LR__0662
	cmp	local08, #0 wz
 if_ne	mov	local06, local09
 if_ne	getbyte	local06, local06, #0
	add	ptr___system__dat__, #4
	wrlong	local09, ptr___system__dat__
	sub	ptr___system__dat__, #4
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___rxraw_ret
	ret

__system____builtin_memmove
	mov	_var01, arg01
	cmps	arg01, arg02 wc
 if_b	jmp	#LR__0670
	mov	_var02, arg02
	add	_var02, arg03
	cmps	arg01, _var02 wc
 if_b	jmp	#LR__0676
LR__0670
	mov	_var03, arg03
	shr	_var03, #2 wz
 if_e	jmp	#LR__0675
	callpa	#(@LR__0673-@LR__0671)>>2,fcache_load_ptr_
LR__0671
	rep	@LR__0674, _var03
LR__0672
	rdlong	_var03, arg02
	wrlong	_var03, arg01
	add	arg01, #4
	add	arg02, #4
LR__0673
LR__0674
LR__0675
	test	arg03, #2 wz
 if_ne	rdword	_var02, arg02
 if_ne	wrword	_var02, arg01
 if_ne	add	arg01, #2
 if_ne	add	arg02, #2
	test	arg03, #1 wz
 if_ne	rdbyte	_var02, arg02
 if_ne	wrbyte	_var02, arg01
	jmp	#LR__0682
LR__0676
	add	arg01, arg03
	add	arg02, arg03
	mov	_var04, arg03 wz
 if_e	jmp	#LR__0681
	callpa	#(@LR__0679-@LR__0677)>>2,fcache_load_ptr_
LR__0677
	rep	@LR__0680, _var04
LR__0678
	sub	arg01, #1
	sub	arg02, #1
	rdbyte	_var02, arg02
	wrbyte	_var02, arg01
LR__0679
LR__0680
LR__0681
LR__0682
	mov	result1, _var01
__system____builtin_memmove_ret
	ret

__system____topofstack
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #8
	add	fp, #4
	wrlong	arg01, fp
	mov	result1, fp
	sub	fp, #4
	mov	ptra, fp
	call	#popregs_
__system____topofstack_ret
	ret

__system___lockmem
	mov	result1, #0
	cogid	result1
	add	result1, #256
LR__0690
	rdlong	_var01, arg01 wz
 if_e	wrlong	result1, arg01
 if_e	rdlong	_var01, arg01
 if_e	rdlong	_var01, arg01
	cmp	_var01, result1 wz
 if_ne	jmp	#LR__0690
__system___lockmem_ret
	ret

__system___funcptr_cmp
	rdlong	result1, arg01
	rdlong	_var01, arg02
	sub	result1, _var01 wz
 if_e	add	arg01, #4
 if_e	rdlong	result1, arg01
 if_e	add	arg02, #4
 if_e	rdlong	_var01, arg02
 if_e	sub	result1, _var01
__system___funcptr_cmp_ret
	ret

__system___tx
	mov	COUNT_, #2
	call	#pushregs_
	mov	local01, arg01
	cmp	local01, #10 wz
 if_ne	jmp	#LR__0700
	add	ptr___system__dat__, #8
	rdlong	local02, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	local02, #2 wz
 if_ne	mov	arg01, #13
 if_ne	call	#__system___txraw
LR__0700
	mov	arg01, local01
	call	#__system___txraw
	mov	ptra, fp
	call	#popregs_
__system___tx_ret
	ret

__system___rx
	mov	COUNT_, #1
	call	#pushregs_
LR__0710
	mov	arg01, #0
	call	#__system___rxraw
	mov	local01, result1
	cmp	local01, ##-1 wz
 if_e	jmp	#LR__0710
	cmp	local01, #13 wz
 if_ne	jmp	#LR__0711
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	result1, #2 wz
 if_ne	mov	local01, #10
LR__0711
	add	ptr___system__dat__, #8
	rdlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	test	arg01, #1 wz
 if_e	jmp	#LR__0714
	cmp	local01, #127 wz
 if_ne	jmp	#LR__0712
	mov	arg01, #8
	call	#__system___tx
	jmp	#LR__0713
LR__0712
	mov	arg01, local01
	call	#__system___tx
LR__0713
LR__0714
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system___rx_ret
	ret

__system___waitms
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__0721-@LR__0720)>>2,fcache_load_ptr_
LR__0720
	cmps	_var01, ##1000 wc
 if_b	jmp	#LR__0722
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000
	jmp	#LR__0720
LR__0721
LR__0722
	cmps	_var01, #1 wc
 if_b	jmp	#LR__0723
	qmul	_var01, _var03
	mov	arg03, ##1000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	arg01
	addct1	arg01, _var02
	waitct1
LR__0723
__system___waitms_ret
	ret

__system___waitus
	mov	_var01, arg01
	getct	_var02
	rdlong	_var03, #20
	callpa	#(@LR__0731-@LR__0730)>>2,fcache_load_ptr_
LR__0730
	cmps	_var01, ##1000000 wc
 if_b	jmp	#LR__0732
	add	_var02, _var03
	mov	arg01, _var02
	addct1	arg01, #0
	waitct1
	sub	_var01, ##1000000
	jmp	#LR__0730
LR__0731
LR__0732
	cmps	_var01, #1 wc
 if_b	jmp	#LR__0733
	qmul	_var01, _var03
	mov	arg03, ##1000000
	getqy	result1
	getqx	arg01
	setq	result1
	qdiv	arg01, arg03
	getqx	result1
	addct1	_var02, result1
	waitct1
LR__0733
__system___waitus_ret
	ret

__system___basic_open
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	mov	local04, #0
	call	#__system____getftab
	mov	local05, result1 wz
 if_ne	jmp	#LR__0740
	mov	arg01, abortchain
	mov	arg02, #12
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__0749
LR__0740
	add	local05, #8
	rdlong	result1, local05 wz
	sub	local05, #8
 if_ne	mov	arg01, local05
 if_ne	call	#__system___closeraw
	cmp	local01, #0 wz
 if_e	cmp	local02, #0 wz
 if_e	cmp	local03, #0 wz
 if_e	jmp	#LR__0742
	mov	arg01, #12
	call	#__system___gc_alloc_managed
	mov	local04, result1 wz
 if_ne	jmp	#LR__0741
	mov	arg01, abortchain
	mov	arg02, #7
	mov	arg03, #1
	call	#__longjmp
	neg	result1, #1
	jmp	#LR__0749
LR__0741
	wrlong	#0, local04
	add	local04, #4
	wrlong	#0, local04
	sub	local04, #4
	wrlong	local04, local05
LR__0742
	cmp	local01, #0 wz
 if_e	jmp	#LR__0743
	wrlong	local01, local04
	mov	result1, local04
	bith	result1, #22
	add	local05, #28
	wrlong	result1, local05
	sub	local05, #28
	jmp	#LR__0744
LR__0743
	add	local05, #28
	wrlong	#0, local05
	sub	local05, #28
LR__0744
	cmp	local02, #0 wz
 if_e	jmp	#LR__0745
	add	local04, #4
	wrlong	local02, local04
	sub	local04, #4
	mov	result1, local04
	or	result1, ##5242880
	add	local05, #32
	wrlong	result1, local05
	sub	local05, #32
	jmp	#LR__0746
LR__0745
	add	local05, #32
	wrlong	#0, local05
	sub	local05, #32
LR__0746
	cmp	local03, #0 wz
 if_e	jmp	#LR__0747
	add	local04, #8
	wrlong	local03, local04
	sub	local04, #8
	bith	local04, #53
	add	local05, #36
	wrlong	local04, local05
	sub	local05, #36
	jmp	#LR__0748
LR__0747
	add	local05, #36
	wrlong	#0, local05
	sub	local05, #36
LR__0748
	add	local05, #8
	wrlong	##32771, local05
	mov	result1, #0
LR__0749
	mov	ptra, fp
	call	#popregs_
__system___basic_open_ret
	ret

__system___basic_print_char
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg02
	call	#__system___gettxfunc
	mov	local02, result1 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0750
	mov	local03, local02
	zerox	local02, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local01, objptr
	mov	objptr, local02
	call	local03
	mov	objptr, local01
	mov	result1, #1
LR__0750
	mov	ptra, fp
	call	#popregs_
__system___basic_print_char_ret
	ret

__system___basic_print_integer
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg02
	mov	local02, arg03
	mov	local03, arg04
	call	#__system___gettxfunc
	mov	local04, result1 wz
 if_e	mov	result1, #0
 if_ne	mov	arg01, local04
 if_ne	mov	arg02, local02
 if_ne	mov	arg03, local01
 if_ne	mov	arg04, local03
 if_ne	call	#__system___fmtnum
	mov	ptra, fp
	call	#popregs_
__system___basic_print_integer_ret
	ret

__system___fmtchar
	mov	COUNT_, #0
	call	#pushregs_
	add	ptra, #16
	add	fp, #12
	wrlong	arg03, fp
	getbyte	arg03, arg03, #0
	wrlong	arg03, fp
	mov	arg03, fp
	sub	fp, #12
	call	#__system___fmtstr
	mov	ptra, fp
	call	#popregs_
__system___fmtchar_ret
	ret

__system___fmtstr
	mov	COUNT_, #9
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg04, local02, #0
	mov	arg01, local03
	mov	local04, arg01
	callpa	#(@LR__0761-@LR__0760)>>2,fcache_load_ptr_
LR__0760
	rdbyte	result1, local04 wz
 if_ne	add	local04, #1
 if_ne	jmp	#LR__0760
LR__0761
	sub	local04, arg01
	cmp	arg04, #0 wz
 if_ne	fles	local04, arg04 wcz
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #2
	call	#__system___fmtpad
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	mov	result1, local05
 if_b	jmp	#LR__0764
	cmps	local04, #1 wc
 if_b	jmp	#LR__0763
	mov	local06, local04
LR__0762
	mov	local07, local01
	mov	local08, local01
	zerox	local07, #19
	shr	local08, #20
	shl	local08, #2
	add	local08, __methods__
	rdlong	local08, local08
	rdbyte	arg01, local03
	mov	local09, objptr
	mov	objptr, local07
	add	local03, #1
	call	local08
	mov	objptr, local09
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_b	jmp	#LR__0764
	add	local05, local09
	djnz	local06, #LR__0762
LR__0763
	mov	arg02, local02
	mov	arg03, local04
	mov	arg01, local01
	mov	arg04, #1
	call	#__system___fmtpad
	mov	local09, result1
	cmps	local09, #0 wc
 if_b	mov	result1, local09
 if_ae	add	local05, local09
 if_ae	mov	result1, local05
LR__0764
	mov	ptra, fp
	call	#popregs_
__system___fmtstr_ret
	ret

__system___fmtnum
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	mov	local04, arg04
	mov	local05, ptra
	mov	local06, local05
	mov	local07, #0
	mov	local08, local02
	shr	local08, #16
	and	local08, #63
	getbyte	local09, local02, #0
	mov	local10, local02
	shr	local10, #26
	and	local10, #3
	mov	local11, local10
	cmps	local08, #1 wc
	add	ptra, #68
 if_ae	sub	local08, #1
	cmps	local09, #65 wc
 if_b	cmp	local09, #0 wz
 if_nc_or_z	mov	local09, #64
	cmp	local11, #3 wz
 if_e	mov	local11, #0
 if_ne	cmps	local03, #0 wc
 if_c_and_nz	mov	local11, #4
 if_c_and_nz	neg	local03, local03
	cmp	local11, #0 wz
 if_e	jmp	#LR__0773
	mov	local07, #1
	cmp	local08, local09 wz
 if_ne	jmp	#LR__0771
	djnz	local08, #LR__0770
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, #35
	call	#__system___fmtchar
	jmp	#LR__0777
LR__0770
LR__0771
	cmp	local11, #2 wz
 if_e	mov	local10, local06
 if_e	add	local06, #1
 if_e	wrbyte	#32, local10
 if_e	jmp	#LR__0772
	cmp	local11, #4 wz
 if_e	wrbyte	#45, local06
 if_e	add	local06, #1
 if_ne	wrbyte	#43, local06
 if_ne	add	local06, #1
LR__0772
LR__0773
	mov	local10, local07
	mov	arg01, local06
	mov	arg02, local03
	mov	arg03, local04
	mov	arg04, local08
	mov	arg05, #0
	testbn	local02, #29 wz
 if_ne	mov	arg05, #1
	call	#__system___uitoa
	add	local10, result1
	cmps	local10, local09 wcz
 if_be	jmp	#LR__0776
	callpa	#(@LR__0775-@LR__0774)>>2,fcache_load_ptr_
LR__0774
	mov	local10, local09
	cmps	local10, #1 wc
	sub	local09, #1
 if_ae	mov	local10, local06
 if_ae	add	local06, #1
 if_ae	wrbyte	#35, local10
 if_ae	jmp	#LR__0774
LR__0775
	wrbyte	#0, local06
LR__0776
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local05
	call	#__system___fmtstr
LR__0777
	mov	ptra, fp
	call	#popregs_
__system___fmtnum_ret
	ret

__system___gc_ptrs
	mov	_var01, __heap_ptr
	mov	_var02, _var01
	add	_var02, ##5992
	rdlong	result2, _var01 wz
 if_ne	jmp	#LR__0780
	mov	result2, _var02
	sub	result2, _var01
	wrword	#1, _var01
	mov	result1, _var01
	add	result1, #2
	wrword	##27792, result1
	mov	result1, _var01
	add	result1, #4
	wrword	#0, result1
	mov	result1, _var01
	add	result1, #6
	wrword	#1, result1
	add	_var01, #16
	abs	result2, result2 wc
	shr	result2, #4
	negc	result2, result2
	wrword	result2, _var01
	mov	result2, _var01
	add	result2, #2
	wrword	##27791, result2
	mov	result2, _var01
	add	result2, #4
	wrword	#0, result2
	mov	result2, _var01
	add	result2, #6
	wrword	#0, result2
	sub	_var01, #16
LR__0780
	mov	result1, _var01
	mov	result2, _var02
__system___gc_ptrs_ret
	ret

__system___gc_tryalloc
	mov	COUNT_, #11
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
	mov	local05, local03
	mov	local06, #0
	callpa	#(@LR__0791-@LR__0790)>>2,fcache_load_ptr_
LR__0790
	mov	local07, local05
	add	local05, #6
	rdword	arg02, local05 wz
	mov	arg01, local03
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local05, result1 wz
 if_ne	rdword	local06, local05
	cmp	local05, #0 wz
 if_ne	cmps	local05, local04 wc
 if_a	jmp	#LR__0792
 if_ne	cmps	local01, local06 wcz
 if_a	jmp	#LR__0790
LR__0791
LR__0792
	cmp	local05, #0 wz
 if_e	mov	result1, local05
 if_e	jmp	#LR__0795
	mov	result2, local05
	add	result2, #6
	rdword	local08, result2
	cmps	local01, local06 wc
 if_ae	jmp	#LR__0794
	wrword	local01, local05
	mov	arg01, local05
	mov	local08, local01
	shl	local08, #4
	add	arg01, local08
	sub	local06, local01
	wrword	local06, arg01
	mov	local08, arg01
	add	local08, #2
	wrword	##27791, local08
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, arg01
	add	local08, #4
	wrword	result1, local08
	mov	local08, local05
	add	local08, #6
	mov	arg02, arg01
	rdword	local08, local08
	add	arg02, #6
	wrword	local08, arg02
	mov	local09, arg01
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local08, result1
	rdword	local10, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local10, #4
 if_ne	add	arg01, local10
 if_ne	mov	result1, arg01
	mov	local11, result1 wz
 if_e	jmp	#LR__0793
	cmps	local11, local04 wc
 if_ae	jmp	#LR__0793
	mov	arg02, local09 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local11, #4
	wrword	result1, local11
LR__0793
LR__0794
	add	local07, #6
	wrword	local08, local07
	mov	local09, ##27776
	or	local09, local02
	mov	result1, #0
	cogid	result1
	or	local09, result1
	mov	local11, local05
	add	local11, #2
	wrword	local09, local11
	mov	local09, local03
	add	local09, #8
	mov	local11, local05
	rdword	local09, local09
	add	local11, #6
	wrword	local09, local11
	mov	arg02, local05 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local03
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	add	local03, #8
	wrword	result1, local03
	add	local05, #8
	mov	result1, local05
LR__0795
	mov	ptra, fp
	call	#popregs_
__system___gc_tryalloc_ret
	ret

__system___gc_alloc_managed
	mov	COUNT_, #1
	call	#pushregs_
	mov	local01, arg01
	mov	arg02, #0
	call	#__system___gc_doalloc
	mov	arg02, result1 wz
 if_e	cmps	local01, #1 wc
 if_nc_and_z	mov	result1, #0
 if_c_or_nz	mov	result1, arg02
	mov	ptra, fp
	call	#popregs_
__system___gc_alloc_managed_ret
	ret

__system___gc_doalloc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01 wz
	mov	local02, arg02
 if_e	mov	result1, #0
 if_e	jmp	#LR__0807
	add	local01, #23
	andn	local01, #15
	shr	local01, #4
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	call	#__system___lockmem
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1 wz
 if_ne	jmp	#LR__0800
	call	#__system___gc_docollect
	mov	arg01, local01
	mov	arg02, local02
	call	#__system___gc_tryalloc
	mov	local03, result1
LR__0800
	mov	arg01, ptr___system__dat__
	add	arg01, #28
	wrlong	#0, arg01
	cmp	local03, #0 wz
 if_e	jmp	#LR__0806
	shl	local01, #4
	sub	local01, #8
	abs	local04, local01 wc
	shr	local04, #2
	negc	local05, local04 wz
	mov	local06, local03
 if_e	jmp	#LR__0805
	callpa	#(@LR__0803-@LR__0801)>>2,fcache_load_ptr_
LR__0801
	rep	@LR__0804, local05
LR__0802
	wrlong	#0, local06
	add	local06, #4
LR__0803
LR__0804
LR__0805
LR__0806
	mov	result1, local03
LR__0807
	mov	ptra, fp
	call	#popregs_
__system___gc_doalloc_ret
	ret

__system___gc_isvalidptr
	bitl	arg03, #248
	sub	arg03, #8
	cmps	arg03, arg01 wc
 if_b	jmp	#LR__0810
	cmps	arg03, arg02 wc
 if_b	jmp	#LR__0811
LR__0810
	mov	result1, #0
	jmp	#__system___gc_isvalidptr_ret
LR__0811
	mov	_var01, arg03
	xor	_var01, arg01
	test	_var01, #15 wz
 if_ne	mov	result1, #0
 if_ne	jmp	#__system___gc_isvalidptr_ret
	mov	_var01, arg03
	add	_var01, #2
	rdword	_var01, _var01
	and	_var01, ##65472
	cmp	_var01, ##27776 wz
 if_ne	mov	result1, #0
 if_e	mov	result1, arg03
__system___gc_isvalidptr_ret
	ret

__system___gc_dofree
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	call	#__system___gc_ptrs
	mov	local02, result1
	mov	local03, result2
	mov	arg02, local01
	add	arg02, #2
	wrword	##27791, arg02
	mov	local04, local01
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	callpa	#(@LR__0821-@LR__0820)>>2,fcache_load_ptr_
LR__0820
	add	local04, #4
	rdword	arg02, local04 wz
	mov	arg01, local02
 if_e	mov	result1, #0
 if_ne	shl	arg02, #4
 if_ne	add	arg01, arg02
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_e	jmp	#LR__0822
	mov	arg01, local04
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__0820
LR__0821
LR__0822
	cmp	local04, #0 wz
 if_e	mov	local04, local02
	mov	arg02, local04
	add	arg02, #6
	mov	arg01, local01
	rdword	arg02, arg02
	add	arg01, #6
	wrword	arg02, arg01
	mov	arg02, local01 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local04
	add	arg02, #6
	wrword	result1, arg02
	cmp	local04, local02 wz
 if_e	jmp	#LR__0825
	mov	arg01, local04
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	cmp	result1, local01 wz
 if_ne	jmp	#LR__0824
	rdword	local06, local04
	rdword	arg02, local01
	add	local06, arg02
	wrword	local06, local04
	mov	local06, local01
	add	local06, #2
	wrword	#0, local06
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1
	cmps	local06, local03 wc
 if_ae	jmp	#LR__0823
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	arg02, local06
	add	arg02, #4
	wrword	result1, arg02
LR__0823
	mov	arg02, local01
	add	arg02, #6
	mov	result2, local04
	rdword	arg02, arg02
	add	result2, #6
	wrword	arg02, result2
	add	local01, #6
	wrword	#0, local01
	mov	local01, local04
LR__0824
LR__0825
	mov	arg01, local01
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	arg02, result1 wz
 if_e	jmp	#LR__0827
	cmps	arg02, local03 wc
 if_ae	jmp	#LR__0827
	mov	arg01, arg02
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_e	jmp	#LR__0827
	mov	local04, local01
	rdword	local06, local04
	mov	arg01, arg02
	rdword	local01, arg01
	add	local06, local01
	wrword	local06, local04
	mov	local06, arg01
	add	local06, #6
	mov	local01, local04
	rdword	local06, local06
	add	local01, #6
	wrword	local06, local01
	mov	local06, arg01
	add	local06, #2
	wrword	#170, local06
	mov	local06, arg01
	add	local06, #6
	wrword	#0, local06
	rdword	local05, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local05, #4
 if_ne	add	arg01, local05
 if_ne	mov	result1, arg01
	mov	local06, result1 wz
 if_e	jmp	#LR__0826
	cmps	local06, local03 wc
 if_ae	jmp	#LR__0826
	mov	arg02, local04 wz
 if_e	mov	result1, #0
 if_ne	sub	arg02, local02
 if_ne	shr	arg02, #4
 if_ne	mov	result1, arg02
	mov	local04, local06
	add	local04, #4
	wrword	result1, local04
LR__0826
LR__0827
	mov	result1, local06
	mov	ptra, fp
	call	#popregs_
__system___gc_dofree_ret
	ret

__system___gc_docollect
	mov	COUNT_, #5
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result2
	mov	local02, result1
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
	mov	result1, #0
	cogid	result1
	mov	local05, result1
 if_e	jmp	#LR__0832
	callpa	#(@LR__0831-@LR__0830)>>2,fcache_load_ptr_
LR__0830
	cmps	local04, local01 wc
 if_ae	jmp	#LR__0832
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	andn	arg02, #32
	mov	arg01, local04
	add	arg01, #2
	wrword	arg02, arg01
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local04, result1 wz
 if_ne	jmp	#LR__0830
LR__0831
LR__0832
	mov	local03, #0
	mov	arg01, #0
	call	#__system____topofstack
	mov	arg02, result1
	mov	arg01, local03
	call	#__system___gc_markhub
	call	#__system___gc_markcog
	mov	arg01, local02
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1 wz
 if_e	jmp	#LR__0836
LR__0833
	mov	local04, local02
	mov	arg01, local04
	rdword	local03, arg01 wz
 if_e	mov	result1, #0
 if_ne	shl	local03, #4
 if_ne	add	arg01, local03
 if_ne	mov	result1, arg01
	mov	local02, result1
	mov	arg02, local04
	add	arg02, #2
	rdword	arg02, arg02
	test	arg02, #32 wz
 if_e	test	arg02, #16 wz
 if_ne	jmp	#LR__0835
	getnib	arg02, arg02, #0
	cmp	arg02, local05 wz
 if_ne	cmp	arg02, #14 wz
 if_ne	jmp	#LR__0834
	mov	arg01, local04
	call	#__system___gc_dofree
	mov	local02, result1
LR__0834
LR__0835
	cmp	local02, #0 wz
 if_ne	cmps	local02, local01 wc
 if_c_and_nz	jmp	#LR__0833
LR__0836
	mov	ptra, fp
	call	#popregs_
__system___gc_docollect_ret
	ret

__system___gc_markhub
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	call	#__system___gc_ptrs
	mov	local03, result1
	mov	local04, result2
LR__0840
	cmps	local01, local02 wc
 if_ae	jmp	#LR__0841
	rdlong	arg03, local01
	add	local01, #4
	mov	arg02, local04
	mov	arg01, local03
	call	#__system___gc_isvalidptr
	mov	arg03, result1 wz
 if_e	jmp	#LR__0840
	mov	arg01, arg03
	mov	result1, #0
	add	arg01, #2
	rdword	arg01, arg01
	cmp	arg01, ##27791 wz
 if_e	neg	result1, #1
	cmp	result1, #0 wz
 if_ne	jmp	#LR__0840
	mov	result2, arg03
	add	result2, #2
	rdword	result2, result2
	andn	result2, #15
	or	result2, #46
	add	arg03, #2
	wrword	result2, arg03
	jmp	#LR__0840
LR__0841
	mov	ptra, fp
	call	#popregs_
__system___gc_markhub_ret
	ret

__system___gc_markcog
	mov	COUNT_, #4
	call	#pushregs_
	call	#__system___gc_ptrs
	mov	local01, result1
	mov	local02, result2
	mov	local03, #495
LR__0850
	'.live	local03
	alts	local03, #0
	mov	local04, local03
	mov	arg01, local01
	mov	arg02, local02
	mov	arg03, local04
	call	#__system___gc_isvalidptr
	cmp	result1, #0 wz
 if_e	jmp	#LR__0851
	mov	local04, result1
	add	local04, #2
	rdword	local04, local04
	or	local04, #32
	add	result1, #2
	wrword	local04, result1
LR__0851
	sub	local03, #1
	cmps	local03, #0 wc
 if_ae	jmp	#LR__0850
	mov	ptra, fp
	call	#popregs_
__system___gc_markcog_ret
	ret

__system___closeraw
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	mov	local02, #0
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_e	add	ptr___system__dat__, #32
 if_e	wrlong	#5, ptr___system__dat__
 if_e	sub	ptr___system__dat__, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0862
	add	local01, #44
	rdlong	result1, local01 wz
	sub	local01, #44
 if_e	jmp	#LR__0860
	add	local01, #44
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #44
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
LR__0860
	add	local01, #36
	rdlong	local05, local01 wz
	sub	local01, #36
 if_e	jmp	#LR__0861
	add	local01, #36
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #36
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local02, result1
LR__0861
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #52
	call	#\builtin_bytefill_
	mov	result1, local02
LR__0862
	mov	ptra, fp
	call	#popregs_
__system___closeraw_ret
	ret

__system____default_getc
	mov	COUNT_, #3
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local01, #8
	rdlong	local03, local01
	sub	local01, #8
	test	local03, #8 wz
 if_ne	mov	arg01, local01
 if_ne	call	#__system____default_flush
	add	local01, #8
	rdlong	local03, local01
	or	local03, #4
	wrlong	local03, local01
	sub	local01, #8
	rdlong	local03, local02 wz
 if_ne	jmp	#LR__0870
	mov	arg01, local01
	call	#__system____default_filbuf
	mov	local03, result1
LR__0870
	cmps	local03, #1 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__0871
	sub	local03, #1
	wrlong	local03, local02
	add	local02, #4
	rdlong	local03, local02
	rdbyte	result1, local03
	add	local03, #1
	wrlong	local03, local02
LR__0871
	mov	ptra, fp
	call	#popregs_
__system____default_getc_ret
	ret

__system____default_putc
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	rdlong	local03, local02
	add	local02, #8
	rdlong	arg02, local02
	sub	local02, #8
	test	arg02, #4 wz
 if_ne	mov	arg01, local02
 if_ne	call	#__system____default_flush
	add	local02, #8
	rdlong	local04, local02
	or	local04, #8
	wrlong	local04, local02
	rdlong	local05, local03
	add	local03, #12
	rdlong	arg02, local03
	sub	local03, #12
	mov	result1, local05
	add	result1, arg02
	wrbyte	local01, result1
	getbyte	local01, local01, #0
	add	local05, #1
	wrlong	local05, local03
	sub	local02, #2
	rdword	local06, local02 wz
	sub	local02, #6
 if_ne	add	local03, #8
 if_ne	rdlong	local04, local03
 if_ne	cmp	local05, local04 wz
 if_e	jmp	#LR__0880
	cmp	local01, #10 wz
 if_e	cmp	local06, #1 wz
 if_ne	jmp	#LR__0881
LR__0880
	mov	arg01, local02
	call	#__system____default_flush
	cmp	result1, #0 wz
 if_ne	neg	local01, #1
LR__0881
	mov	result1, local01
	mov	ptra, fp
	call	#popregs_
__system____default_putc_ret
	ret

__system____default_flush
	mov	COUNT_, #7
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	rdlong	local03, local02
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #8 wz
 if_e	jmp	#LR__0892
	cmps	local03, #1 wc
 if_b	jmp	#LR__0894
	add	local01, #8
	rdlong	result2, local01
	sub	local01, #8
	test	result2, #128 wz
 if_e	jmp	#LR__0891
	add	local01, #8
	rdlong	arg03, local01
	sub	local01, #8
	test	arg03, #256 wz
 if_e	jmp	#LR__0890
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg02, #0
	mov	arg03, #0
	mov	arg04, #2
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	add	local01, #8
	rdlong	local06, local01
	andn	local06, #256
	wrlong	local06, local01
	sub	local01, #8
LR__0890
LR__0891
	add	local01, #24
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #24
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	add	local02, #12
	rdlong	arg02, local02
	sub	local02, #12
	mov	arg01, local01
	mov	arg03, local03
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
	jmp	#LR__0894
LR__0892
	add	local01, #8
	rdlong	local06, local01
	sub	local01, #8
	test	local06, #4 wz
 if_ne	cmp	local03, #0 wz
 if_e	jmp	#LR__0893
	neg	arg02, local03
	mov	arg03, arg02
	sar	arg03, #31
	add	local01, #48
	rdlong	local04, local01
	mov	local05, local04
	sub	local01, #48
	zerox	local05, #19
	shr	local04, #20
	shl	local04, #2
	add	local04, __methods__
	rdlong	local04, local04
	mov	arg01, local01
	mov	arg04, #1
	mov	local06, objptr
	mov	objptr, local05
	call	local04
	mov	objptr, local06
LR__0893
LR__0894
	wrlong	#0, local02
	add	local02, #4
	wrlong	#0, local02
	add	local01, #8
	rdlong	local07, local01
	andn	local07, #12
	wrlong	local07, local01
	mov	result1, #0
	mov	ptra, fp
	call	#popregs_
__system____default_flush_ret
	ret

__system____getftab
	cmp	arg01, #10 wc
 if_b	qmul	arg01, #52
 if_ae	mov	result1, #0
 if_b	mov	arg01, ptr___system__dat__
 if_b	add	arg01, #40
 if_b	getqx	result1
 if_b	add	result1, arg01
__system____getftab_ret
	ret

__system___strrev
	rdbyte	_var01, arg01 wz
 if_e	jmp	#__system___strrev_ret
	mov	_var02, arg01
	callpa	#(@LR__0901-@LR__0900)>>2,fcache_load_ptr_
LR__0900
	rdbyte	_var01, _var02 wz
 if_ne	add	_var02, #1
 if_ne	jmp	#LR__0900
LR__0901
	sub	_var02, #1
	callpa	#(@LR__0903-@LR__0902)>>2,fcache_load_ptr_
LR__0902
	cmps	_var02, arg01 wcz
 if_be	jmp	#LR__0904
	rdbyte	_var01, arg01
	rdbyte	_var03, _var02
	wrbyte	_var03, arg01
	wrbyte	_var01, _var02
	add	arg01, #1
	sub	_var02, #1
	jmp	#LR__0902
LR__0903
LR__0904
__system___strrev_ret
	ret

__system___fmtpad
	mov	COUNT_, #6
	call	#pushregs_
	mov	local01, arg01
	mov	local02, arg02
	mov	local03, arg03
	getbyte	arg01, local02, #1
	shr	local02, #22
	and	local02, #3 wz
	mov	local04, #0
 if_e	mov	local02, #1
	test	local02, arg04 wz
 if_e	mov	result1, #0
 if_e	jmp	#LR__0913
	subr	local03, arg01
	cmps	local03, #1 wc
 if_b	mov	result1, #0
 if_b	jmp	#LR__0913
	cmp	local02, #3 wz
 if_ne	jmp	#LR__0910
	cmp	arg04, #1 wz
	wrz	local02
	add	local03, local02
	abs	local03, local03 wc
	shr	local03, #1
	negc	local03, local03
LR__0910
	cmps	local03, #1 wc
 if_b	jmp	#LR__0912
	mov	local05, local03
LR__0911
	mov	local02, local01
	mov	local06, local01
	zerox	local02, #19
	shr	local06, #20
	shl	local06, #2
	add	local06, __methods__
	rdlong	local06, local06
	mov	arg01, #32
	mov	local03, objptr
	mov	objptr, local02
	call	local06
	mov	objptr, local03
	mov	local06, result1
	cmps	local06, #0 wc
 if_b	mov	result1, local06
 if_b	jmp	#LR__0913
	add	local04, local06
	djnz	local05, #LR__0911
LR__0912
	mov	result1, local04
LR__0913
	mov	ptra, fp
	call	#popregs_
__system___fmtpad_ret
	ret

__system___uitoa
	mov	COUNT_, #4
	call	#pushregs_
	mov	local01, arg01
	cmps	arg05, #0 wz
	mov	arg05, local01
	mov	local02, #0
 if_ne	mov	local03, #55
 if_e	mov	local03, #87
LR__0920
	qdiv	arg02, arg03
	getqy	local04
	qdiv	arg02, arg03
	cmp	local04, #10 wc
 if_b	add	local04, #48
 if_ae	add	local04, local03
	wrbyte	local04, arg05
	add	arg05, #1
	add	local02, #1
	getqx	arg02
	cmp	arg02, #0 wz
 if_ne	jmp	#LR__0920
	cmp	local02, arg04 wc
 if_b	jmp	#LR__0920
	wrbyte	#0, arg05
	mov	arg01, local01
	call	#__system___strrev
	mov	result1, local02
	mov	ptra, fp
	call	#popregs_
__system___uitoa_ret
	ret

__system___getiolock_0103
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__0930
	add	local01, #8
	rdlong	result1, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__0931
LR__0930
	mov	result1, ptr___system__dat__
	add	result1, #36
	jmp	#LR__0932
LR__0931
	add	local01, #12
	mov	result1, local01
LR__0932
	mov	ptra, fp
	call	#popregs_
__system___getiolock_0103_ret
	ret

__system___gettxfunc
	mov	COUNT_, #1
	call	#pushregs_
	call	#__system____getftab
	mov	local01, result1 wz
 if_e	jmp	#LR__0940
	add	local01, #8
	rdlong	arg02, local01 wz
	sub	local01, #8
 if_ne	jmp	#LR__0941
LR__0940
	mov	result1, #0
	jmp	#LR__0942
LR__0941
	bith	local01, #84
	mov	result1, local01
LR__0942
	mov	ptra, fp
	call	#popregs_
__system___gettxfunc_ret
	ret

__system___rxtxioctl_0153
	cmp	arg02, #256 wz
 if_e	jmp	#LR__0950
	cmp	arg02, #257 wz
 if_e	jmp	#LR__0951
	jmp	#LR__0952
LR__0950
	add	ptr___system__dat__, #8
	rdlong	result1, ptr___system__dat__
	sub	ptr___system__dat__, #8
	wrlong	result1, arg03
	mov	result1, #0
	jmp	#LR__0953
LR__0951
	rdlong	arg01, arg03
	add	ptr___system__dat__, #8
	wrlong	arg01, ptr___system__dat__
	sub	ptr___system__dat__, #8
	mov	result1, #0
	jmp	#LR__0953
LR__0952
	add	ptr___system__dat__, #32
	wrlong	#10, ptr___system__dat__
	sub	ptr___system__dat__, #32
	neg	result1, #1
LR__0953
__system___rxtxioctl_0153_ret
	ret

__system____dummy_flush_0154
	mov	result1, #0
__system____dummy_flush_0154_ret
	ret

__system____default_filbuf
	mov	COUNT_, #5
	call	#pushregs_
	mov	local01, arg01
	rdlong	local02, local01
	add	local02, #8
	rdlong	result1, local02 wz
	sub	local02, #8
 if_ne	jmp	#LR__0960
	add	local02, #16
	mov	result1, local02
	sub	local02, #4
	wrlong	result1, local02
	sub	local02, #4
	wrlong	##1024, local02
	sub	local02, #8
LR__0960
	add	local01, #20
	rdlong	local03, local01
	mov	local04, local03
	sub	local01, #20
	zerox	local04, #19
	shr	local03, #20
	shl	local03, #2
	add	local03, __methods__
	rdlong	local03, local03
	mov	arg01, local01
	add	local02, #12
	rdlong	arg02, local02
	sub	local02, #4
	rdlong	arg03, local02
	sub	local02, #8
	mov	local05, objptr
	mov	objptr, local04
	call	local03
	mov	objptr, local05
	mov	local05, result1
	cmps	local05, #0 wc
 if_b	neg	result1, #1
 if_b	jmp	#LR__0961
	wrlong	local05, local02
	add	local02, #12
	rdlong	local03, local02
	sub	local02, #8
	wrlong	local03, local02
	add	local01, #8
	rdlong	local04, local01
	or	local04, #4
	wrlong	local04, local01
	mov	result1, local05
LR__0961
	mov	ptra, fp
	call	#popregs_
__system____default_filbuf_ret
	ret

__system___struct__s_vfs_file_t_putchar_
	mov	COUNT_, #4
	call	#pushregs_
	add	objptr, #28
	rdlong	local01, objptr wz
	sub	objptr, #28
 if_e	mov	result1, #0
 if_e	jmp	#LR__0970
	add	objptr, #28
	rdlong	local02, objptr
	mov	local03, local02
	sub	objptr, #28
	zerox	local03, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	arg02, objptr
	mov	local04, objptr
	mov	objptr, local03
	call	local02
	mov	objptr, local04
'     return (i < 0) ? 0 : 1;
	cmps	result1, #0 wc
 if_b	mov	local01, #0
 if_ae	mov	local01, #1
	mov	result1, local01
LR__0970
	mov	ptra, fp
	call	#popregs_
__system___struct__s_vfs_file_t_putchar__ret
	ret

__system___struct__s_vfs_file_t_getchar_
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #32
	rdlong	arg01, objptr wz
	sub	objptr, #32
 if_e	neg	result1, #1
 if_e	jmp	#LR__0980
'     return getcf(__this);
	add	objptr, #32
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #32
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	arg01, objptr
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
LR__0980
	mov	ptra, fp
	call	#popregs_
__system___struct__s_vfs_file_t_getchar__ret
	ret

__system___struct___bas_wrap_sender_tx_
	mov	COUNT_, #3
	call	#pushregs_
	rdlong	local01, objptr
	mov	local02, local01
	zerox	local01, #19
	shr	local02, #20
	shl	local02, #2
	add	local02, __methods__
	rdlong	local02, local02
	mov	local03, objptr
	mov	objptr, local01
	call	local02
	mov	objptr, local03
	mov	result1, #1
	mov	ptra, fp
	call	#popregs_
__system___struct___bas_wrap_sender_tx__ret
	ret

__system___struct___bas_wrap_sender_rx_
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #4
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #4
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__system___struct___bas_wrap_sender_rx__ret
	ret

__system___struct___bas_wrap_sender_close_
	mov	COUNT_, #3
	call	#pushregs_
	add	objptr, #8
	rdlong	local01, objptr
	mov	local02, local01
	sub	objptr, #8
	zerox	local02, #19
	shr	local01, #20
	shl	local01, #2
	add	local01, __methods__
	rdlong	local01, local01
	mov	local03, objptr
	mov	objptr, local02
	call	local01
	mov	objptr, local03
	mov	ptra, fp
	call	#popregs_
__system___struct___bas_wrap_sender_close__ret
	ret

LR__0990
	byte	" !!! corrupted heap??? !!! "
	byte	0
LR__0991
	byte	" !!! out of heap memory !!! "
	byte	0
LR__0992
	byte	" !!! corrupted heap !!! "
	byte	0
	alignl
_dat_
	byte	$00[16]
	byte	$61, $41, $17, $0e, $62, $42, $00, $00, $63, $43, $19, $10, $64, $44, $00, $00
	byte	$65, $45, $18, $0f, $66, $46, $00, $00, $67, $47, $00, $00, $68, $48, $00, $00
	byte	$69, $49, $00, $00, $6a, $4a, $00, $00, $6b, $4b, $00, $00, $6c, $4c, $1f, $16
	byte	$6d, $4d, $00, $00, $6e, $4e, $1a, $11, $6f, $4f, $1e, $15, $70, $50, $00, $00
	byte	$71, $51, $00, $00, $72, $52, $00, $00, $73, $53, $1b, $12, $74, $54, $00, $00
	byte	$75, $55, $00, $00, $76, $56, $00, $00, $77, $57, $00, $00, $78, $58, $1c, $13
	byte	$79, $59, $00, $00, $7a, $5a, $1d, $14, $31, $21, $04, $00, $32, $40, $05, $00
	byte	$33, $23, $06, $00, $34, $24, $07, $00, $35, $25, $08, $00, $36, $5e, $09, $00
	byte	$37, $26, $0a, $00, $38, $2a, $0b, $00, $39, $28, $0c, $00, $30, $29, $0d, $00
	byte	$0d, $0d, $0a, $00, $9b, $9b, $00, $00, $88, $88, $00, $00, $89, $89, $00, $00
	byte	$20, $20, $00, $00, $2d, $5f, $00, $00, $3d, $2b, $00, $00, $5b, $7b, $00, $00
	byte	$5d, $7d, $00, $00, $5c, $7c, $00, $00, $23, $7e, $00, $00, $3b, $3a, $00, $00
	byte	$27, $22, $00, $00, $60, $7e, $03, $00, $2c, $3c, $00, $00, $2e, $3e, $00, $00
	byte	$2f, $3f, $00, $00, $b9, $b9, $00, $00, $ba, $00, $00, $00, $bb, $00, $00, $00
	byte	$bc, $00, $00, $00, $bd, $00, $00, $00, $be, $00, $00, $00, $bf, $00, $00, $00
	byte	$c0, $00, $00, $00, $c1, $00, $00, $00, $c2, $00, $00, $00, $c3, $00, $00, $00
	byte	$c4, $00, $00, $00, $c5, $00, $00, $00, $c6, $00, $00, $00, $c7, $00, $00, $00
	byte	$c8, $00, $00, $00, $c9, $00, $00, $00, $ca, $00, $00, $00, $cb, $00, $00, $00
	byte	$7f, $7f, $00, $00, $cc, $00, $00, $00, $cd, $00, $00, $00, $ce, $00, $00, $00
	byte	$cf, $00, $00, $00, $d0, $00, $00, $00, $d1, $00, $00, $00, $d2, $00, $00, $00
	byte	$2f, $2f, $00, $00, $2a, $2a, $00, $00, $2d, $2d, $00, $00, $2b, $2b, $00, $00
	byte	$0d, $0d, $00, $00, $31, $31, $00, $00, $32, $32, $00, $00, $33, $33, $00, $00
	byte	$34, $34, $00, $00, $35, $35, $00, $00, $36, $36, $00, $00, $37, $37, $00, $00
	byte	$38, $38, $00, $00, $39, $39, $00, $00, $30, $30, $00, $00, $2e, $7f, $00, $00
	byte	$5c, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3d, $3d, $00, $00
	byte	$00[96]
	alignl
_hg010b_spin2_dat_
'-' 
'-' vga_font       file "vgafont.def"
	byte	$00[19]
	byte	$7e, $81, $a5, $81, $81, $bd, $99, $81, $81, $7e, $00, $00, $00, $00, $00, $00
	byte	$7e, $ff, $db, $ff, $ff, $c3, $e7, $ff, $ff, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $7f, $7f, $7f, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $3e, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $3c, $e7, $e7, $e7, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $ff, $ff, $7e, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $3c, $3c, $18, $00, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $ff, $e7, $c3, $c3, $e7, $ff, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$00, $00, $3c, $66, $42, $42, $66, $3c, $00, $00, $00, $00, $00, $ff, $ff, $ff
	byte	$ff, $ff, $c3, $99, $bd, $bd, $99, $c3, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
	byte	$78, $70, $58, $4c, $1e, $33, $33, $33, $33, $1e, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$fc, $cc, $fc, $0c, $0c, $0c, $0c, $0e, $0f, $07, $00, $00, $00, $00, $00, $00
	byte	$fe, $c6, $fe, $c6, $c6, $c6, $c6, $e6, $e7, $67, $03, $00, $00, $00, $00, $00
	byte	$18, $18, $db, $3c, $e7, $3c, $db, $18, $18, $00, $00, $00, $00, $00, $00, $01
	byte	$03, $07, $0f, $1f, $7f, $1f, $0f, $07, $03, $01, $00, $00, $00, $00, $00, $40
	byte	$60, $70, $78, $7c, $7f, $7c, $78, $70, $60, $40, $00, $00, $00, $00, $00, $00
	byte	$18, $3c, $7e, $18, $18, $18, $7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$00, $66, $66, $00, $00, $00, $00, $00, $00, $fe, $db, $db, $db, $de, $d8, $d8
	byte	$d8, $d8, $d8, $00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c
	byte	$30, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $7f, $7f, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $7e
	byte	$3c, $18, $7e, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $18
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $18, $30, $7f, $30, $18
	byte	$00[11]
	byte	$0c, $06, $7f, $06, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $03, $03, $03, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$14, $36, $7f, $36, $14, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $1c, $3e, $3e, $7f, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
	byte	$7f, $3e, $3e, $1c, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[14]
	byte	$18, $3c, $3c, $3c, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $66, $66
	byte	$66, $24, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $18, $18
	byte	$3e, $63, $43, $03, $3e, $60, $60, $61, $63, $3e, $18, $18, $00, $00, $00, $00
	byte	$00, $00, $43, $63, $30, $18, $0c, $06, $63, $61, $00, $00, $00, $00, $00, $00
	byte	$1c, $36, $36, $1c, $6e, $3b, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00
	byte	$0c, $0c, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $30, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f, $00, $00
	byte	$00[16]
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $40, $60, $30, $18, $0c, $06
	byte	$03, $01, $00, $00, $00, $00, $00, $00, $1c, $36, $63, $63, $6b, $6b, $63, $63
	byte	$36, $1c, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18, $18
	byte	$18, $7e, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $30, $18, $0c, $06, $03
	byte	$63, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $60, $3c, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30, $30
	byte	$30, $78, $00, $00, $00, $00, $00, $00, $7f, $03, $03, $03, $3f, $60, $60, $60
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $1c, $06, $03, $03, $3f, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $7f, $63, $60, $60, $30, $18, $0c, $0c
	byte	$0c, $0c, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $3e, $63, $63, $63
	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $7e, $60, $60, $60
	byte	$30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $60, $30, $18, $0c, $06, $0c, $18
	byte	$30, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00, $7e, $00
	byte	$00[9]
	byte	$06, $0c, $18, $30, $60, $30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $3e
	byte	$63, $63, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $63, $7b, $7b, $7b, $3b, $03, $3e, $00, $00, $00, $00, $00, $00, $08
	byte	$1c, $36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3f
	byte	$66, $66, $66, $3e, $66, $66, $66, $66, $3f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00, $00, $1f
	byte	$36, $66, $66, $66, $66, $66, $66, $36, $1f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $7f
	byte	$66, $46, $16, $1e, $16, $06, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $3c
	byte	$66, $43, $03, $03, $7b, $63, $63, $66, $5c, $00, $00, $00, $00, $00, $00, $63
	byte	$63, $63, $63, $7f, $63, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3c
	byte	$18[8]
	byte	$3c, $00, $00, $00, $00, $00, $00, $78, $30, $30, $30, $30, $30, $33, $33, $33
	byte	$1e, $00, $00, $00, $00, $00, $00, $67, $66, $66, $36, $1e, $1e, $36, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $7f, $6b, $63, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $06, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $6b, $7b
	byte	$3e, $30, $70, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66
	byte	$67, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $36, $1c
	byte	$08, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $6b, $6b, $6b, $7f, $77
	byte	$36, $00, $00, $00, $00, $00, $00, $63, $63, $36, $3e, $1c, $1c, $3e, $36, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $01, $03, $07, $0e, $1c, $38, $70, $60
	byte	$40, $00, $00, $00, $00, $00, $00, $3c, $30, $30, $30, $30, $30, $30, $30, $30
	byte	$3c, $00, $00, $00, $1c, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[17]
	byte	$ff, $00, $00, $0c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $07, $06, $06
	byte	$1e, $36, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $30, $30
	byte	$3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $63, $7f, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $6c, $4c
	byte	$0c, $1e, $0c, $0c, $0c, $0c, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$6e, $33, $33, $33, $33, $33, $3e, $30, $33, $1e, $00, $00, $00, $07, $06, $06
	byte	$36, $6e, $66, $66, $66, $66, $67, $00, $00, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $60, $60, $00
	byte	$70, $60, $60, $60, $60, $60, $60, $66, $66, $3c, $00, $00, $00, $07, $06, $06
	byte	$66, $36, $1e, $1e, $36, $66, $67, $00, $00, $00, $00, $00, $00, $1c, $18, $18
	byte	$18[6]
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $6b, $6b, $6b
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
	byte	$3e, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $6e, $33, $33, $33, $33, $33
	byte	$3e, $30, $30, $78, $00, $00, $00, $00, $00, $00, $3b, $6e, $66, $06, $06, $06
	byte	$0f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36
	byte	$1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $6b, $6b, $6b, $7f
	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $1c, $36
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63
	byte	$7e, $60, $30, $1f, $00, $00, $00, $00, $00, $00, $7f, $33, $18, $0c, $06, $63
	byte	$7f, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18, $18
	byte	$70, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18, $18
	byte	$0e, $00, $00, $00, $6e, $3b, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[10]
	byte	$08, $1c, $36, $63, $63, $63, $7f, $00, $00, $00, $00, $00, $00, $3c, $66, $43
	byte	$03, $03, $03, $03, $43, $66, $3c, $18, $30, $1e, $00, $00, $00, $00, $33, $00
	byte	$33[6]
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $33, $00, $1e, $30, $3e, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $1c, $36, $1c, $00, $33, $33, $33, $33, $33, $33
	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $03, $03, $03, $63
	byte	$3e, $18, $30, $1e, $00, $00, $00, $1c, $58, $78, $38, $18, $1c, $1e, $1a, $18
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $7f, $03, $03, $63
	byte	$3e, $00, $00, $00, $66, $33, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $cc, $66, $33, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $18, $3c, $66, $00, $1c, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
	byte	$7f, $00, $00, $00, $00, $63, $00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63
	byte	$63, $00, $00, $00, $30, $18, $00, $3c, $66, $43, $03, $03, $03, $03, $43, $66
	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66
	byte	$7f, $00, $00, $00, $0c, $06, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $6f, $46, $26, $06, $06, $06, $06, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $6e, $4c, $2c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$1e, $00, $00, $00, $30, $18, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $06, $1c, $30, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $63, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $6c, $38, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
	byte	$3c, $00, $00, $00, $00, $00, $60, $48, $2c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
	byte	$38, $00, $00, $00, $00, $00, $00, $0f, $26, $36, $1e, $0e, $07, $07, $46, $66
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36, $63, $00
	byte	$00[6]
	byte	$36, $1c, $08, $00, $3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00
	byte	$00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63, $63, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $1e, $30, $3e, $33, $33, $33, $6e, $18, $0c, $78, $36, $1c
	byte	$00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00
	byte	$00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66, $7f, $18, $0c, $78, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $7f, $03, $03, $63, $3e, $18, $0c, $78, $00, $00
	byte	$00, $3c, $66, $03, $1f, $03, $0f, $03, $03, $66, $3c, $00, $00, $00, $00, $00
	byte	$60, $30, $18, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $6c, $38
	byte	$00, $3c, $66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63, $3e, $18, $30, $1e, $00, $00
	byte	$00[6]
	byte	$6c, $36, $1b, $36, $6c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$1b, $36, $6c, $36, $1b, $00, $00, $00, $88, $22, $88, $22, $88, $22, $88, $22
	byte	$88, $22, $88, $22, $88, $22, $88, $22, $aa, $55, $aa, $55, $aa, $55, $aa, $55
	byte	$aa, $55, $aa, $55, $aa, $55, $aa, $55, $bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee
	byte	$bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18[15]
	byte	$1f, $18, $18, $18, $18, $18, $18, $18, $18, $30, $18, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $1c, $36, $00, $08, $1c, $36, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $36, $1c, $00, $7f, $66, $46, $16
	byte	$1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06
	byte	$1c, $30, $60, $63, $63, $3e, $18, $30, $1e, $6c, $6c, $6c, $6c, $6c, $6f, $60
	byte	$6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6c[9]
	byte	$00[5]
	byte	$7f, $60, $6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$6f, $60, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $7f, $63
	byte	$61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00, $00, $18, $18
	byte	$00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
	byte	$00, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
	byte	$18, $18, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $63, $3e, $00, $08, $1c
	byte	$36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $63, $3e
	byte	$00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $fc, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$fc, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
	byte	$ec, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
	byte	$ef, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
	byte	$63, $3e, $63, $63, $63, $63, $3e, $63, $00, $00, $00, $00, $00, $00, $30, $7e
	byte	$30, $3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $1f, $36
	byte	$66, $66, $6f, $66, $66, $66, $36, $1f, $00, $00, $00, $36, $1c, $00, $1f, $36
	byte	$66[6]
	byte	$36, $1f, $00, $00, $00, $00, $63, $00, $7f, $66, $46, $16, $1e, $16, $06, $46
	byte	$66, $7f, $00, $00, $00, $6c, $38, $00, $38, $30, $30, $3c, $36, $33, $33, $33
	byte	$33, $6e, $00, $00, $00, $36, $1c, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63
	byte	$63, $63, $00, $00, $00, $30, $18, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $3c, $66, $00, $3c, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $3c, $00, $00, $00, $00, $00, $36, $1c, $08, $00, $3e, $63, $7f, $03, $03
	byte	$63, $3e, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $1f, $00, $00, $00
	byte	$00[12]
	byte	$f8, $18, $18, $18, $18, $18, $18, $18, $18, $ff, $ff, $ff, $ff, $ff, $ff, $ff
	byte	$ff[9]
	byte	$00[7]
	byte	$ff[9]
	byte	$00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18, $3c, $18, $30, $1e
	byte	$1c, $36, $1c, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$ff[7]
	byte	$00[9]
	byte	$30, $18, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $00, $1e, $33, $33, $33, $1b, $33, $63, $63, $63, $33, $00, $00, $00
	byte	$1c, $36, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63, $63, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
	byte	$36, $1c, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $36, $1c, $08, $00, $3e, $63, $06, $1c, $30, $63, $3e, $00, $00, $00
	byte	$30, $18, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00
	byte	$30, $18, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00
	byte	$66, $33, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
	byte	$00, $00, $60, $30, $18, $00, $63, $63, $63, $63, $63, $63, $7e, $60, $30, $1f
	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18, $3c, $00, $00, $00
	byte	$00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c, $38, $18, $30, $1e
	byte	$30, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $66, $33, $00, $00, $00, $00, $00, $00
	byte	$00[21]
	byte	$0c, $06, $3c, $36, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c, $30, $63, $3e
	byte	$00[8]
	byte	$18, $00, $7e, $00, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$18, $30, $1e, $00, $00, $00, $1c, $36, $36, $1c, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[5]
	byte	$cc, $66, $33, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $36, $1c
	byte	$00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00, $00, $00
	byte	$36, $1c, $08, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $7e, $7e, $7e, $7e, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' st_font        file "st4font.def"
	byte	$00[55]
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$18[9]
	byte	$00[7]
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$1f, $1f, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$f8, $f8, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $00, $00, $18, $3c, $7e, $66, $66
	byte	$66, $7e, $7e, $66, $66, $66, $66, $30, $18, $00, $00, $7e, $7e, $06, $06, $3e
	byte	$3e, $06, $06, $06, $06, $7e, $7e, $18, $0c, $30, $18, $3c, $7e, $66, $66, $06
	byte	$06, $06, $06, $66, $66, $7e, $3c, $00, $00, $30, $18, $66, $66, $66, $6e, $6e
	byte	$7e, $7e, $76, $76, $66, $66, $66, $00, $00, $30, $18, $7c, $7e, $06, $06, $0e
	byte	$1c, $38, $70, $60, $60, $7e, $3e, $00, $00, $30, $18, $7e, $7e, $30, $30, $18
	byte	$18, $0c, $0c, $06, $06, $7e, $7e, $00, $00, $18, $18, $00, $7e, $7e, $30, $30
	byte	$18, $18, $0c, $0c, $06, $7e, $7e, $00, $00, $30, $18, $3c, $7e, $66, $66, $66
	byte	$66[5]
	byte	$7e, $3c, $00, $00, $00, $00, $06, $06, $06, $06, $16, $1e, $0e, $06, $06, $06
	byte	$7e, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $7c, $60, $7c, $7e, $66, $66
	byte	$7e, $7c, $30, $18, $00, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $06, $06
	byte	$7e, $7c, $18, $0c, $00, $00, $30, $18, $00, $3c, $3e, $06, $06, $06, $06, $06
	byte	$7e, $7c, $00, $00, $00, $00, $30, $18, $00, $3e, $7e, $66, $66, $66, $66, $66
	byte	$66, $66, $00, $00, $00, $00, $30, $18, $00, $7c, $7e, $06, $0e, $3c, $70, $60
	byte	$7e, $3e, $00, $00, $00, $00, $30, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $18, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $00, $3c, $7e, $66, $66, $66, $66, $66
	byte	$7e, $3c, $00, $00, $00, $00, $1c, $1c, $18, $18, $38, $3c, $1c, $18, $18, $18
	byte	$3c, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[8]
	byte	$00, $00, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $00, $00, $00, $00
	byte	$00[9]
	byte	$66, $66, $ff, $ff, $66, $66, $ff, $ff, $66, $66, $00, $00, $00, $00, $18, $18
	byte	$7c, $7e, $06, $06, $3e, $7c, $60, $60, $7e, $3e, $18, $18, $00, $00, $00, $66
	byte	$66, $30, $30, $18, $18, $0c, $0c, $66, $66, $00, $00, $00, $00, $00, $3c, $7e
	byte	$66, $66, $3c, $1c, $1c, $fc, $fe, $66, $66, $fe, $fc, $00, $00, $00, $00, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $30
	byte	$18, $1c, $0c, $0c, $0c, $0c, $0c, $0c, $1c, $18, $30, $00, $00, $00, $00, $0c
	byte	$18, $38, $30, $30, $30, $30, $30, $30, $38, $18, $0c, $00, $00, $00, $00, $00
	byte	$66, $66, $3c, $3c, $ff, $ff, $3c, $3c, $66, $66, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $18, $7e, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$00[6]
	byte	$18[5]
	byte	$0c, $04, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $00, $00, $00, $00
	byte	$00[13]
	byte	$18, $18, $18, $00, $00, $00, $00, $60, $60, $60, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $76, $6e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $18, $18, $1c, $1c, $18, $18, $18, $18, $18
	byte	$18, $7e, $7e, $00, $00, $00, $00, $3c, $7e, $66, $66, $30, $30, $18, $18, $0c
	byte	$0c, $7e, $7e, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $30, $30, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $30, $30, $38, $38, $3c, $3c, $36, $36, $7e
	byte	$7e, $30, $30, $00, $00, $00, $00, $7e, $7e, $06, $06, $3e, $7e, $60, $60, $60
	byte	$66, $7e, $3c, $00, $00, $00, $00, $38, $3c, $0e, $06, $06, $3e, $7e, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $7e, $7e, $60, $60, $30, $30, $18, $18, $0c
	byte	$0c, $0c, $0c, $00, $00, $00, $00, $3c, $7e, $66, $66, $3c, $3c, $66, $66, $66
	byte	$66, $7e, $3c, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $7c, $60, $60, $60
	byte	$70, $3c, $1c, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $18
	byte	$18, $18, $18, $0c, $04, $00, $00, $00, $70, $38, $1c, $0e, $07, $0e, $1c, $38
	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $7e, $7e
	byte	$00[8]
	byte	$0e, $1c, $38, $70, $e0, $70, $38, $1c, $0e, $00, $00, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $30, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $66, $66, $36, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $18
	byte	$3c, $7e, $66, $66, $66, $7e, $7e, $66, $66, $66, $66, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $7e, $3e, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $3c
	byte	$7e, $66, $66, $06, $06, $06, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $3e
	byte	$7e, $66, $66, $66, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $7e, $7e, $00, $00, $00, $00, $7e
	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $7c
	byte	$7e, $06, $06, $76, $76, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $66
	byte	$66, $66, $66, $7e, $7e, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $7e
	byte	$7e, $18, $18, $18, $18, $18, $18, $18, $18, $7e, $7e, $00, $00, $00, $00, $60
	byte	$60[7]
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $36, $36, $1e, $1e, $36, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $06, $06, $06, $06, $06, $06, $06, $06
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $c6, $c6, $ee, $ee, $fe, $d6, $d6, $c6
	byte	$c6, $c6, $c6, $c6, $00, $00, $00, $00, $66, $66, $66, $6e, $6e, $7e, $7e, $76
	byte	$76, $66, $66, $66, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $66, $7e, $3e
	byte	$06, $06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
	byte	$66, $56, $3e, $6c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $7e, $3e, $36
	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $7c, $7e, $06, $06, $0e, $1c, $38, $70
	byte	$60, $60, $7e, $3e, $00, $00, $00, $00, $7e, $7e, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
	byte	$3c, $3c, $18, $18, $00, $00, $00, $00, $c6, $c6, $c6, $c6, $c6, $d6, $d6, $fe
	byte	$fe, $ee, $c6, $82, $00, $00, $00, $00, $66, $66, $66, $3c, $3c, $18, $18, $3c
	byte	$3c, $66, $66, $66, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c, $18
	byte	$18, $18, $18, $18, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $0c, $0c
	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $3c, $3c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$0c, $0c, $3c, $3c, $00, $00, $00, $00, $06, $06, $0c, $0c, $18, $18, $30, $30
	byte	$60, $60, $c0, $c0, $00, $00, $00, $00, $3c, $3c, $30, $30, $30, $30, $30, $30
	byte	$30, $30, $3c, $3c, $00, $00, $00, $00, $18, $18, $3c, $3c, $66, $66, $00, $00
	byte	$00[18]
	byte	$fe, $fe, $00, $00, $00, $00, $0c, $0c, $18, $18, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$3c, $7c, $60, $7c, $7e, $66, $66, $7e, $7c, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $3e, $06, $06, $06, $06, $06, $7e, $7c, $00, $00, $00, $00, $60, $60, $60
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $7e, $06, $06, $7e, $7c, $00, $00, $00, $00, $70, $78, $18
	byte	$18, $7e, $7e, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $7e, $7c, $60, $7e, $3e, $00, $00, $06, $06, $06
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $18, $18, $00
	byte	$1c, $1c, $18, $18, $18, $18, $18, $3c, $3c, $00, $00, $00, $00, $30, $30, $00
	byte	$30[9]
	byte	$3e, $1e, $00, $00, $06, $06, $06, $36, $36, $1e, $1e, $1e, $36, $36, $66, $66
	byte	$00, $00, $00, $00, $1c, $1c, $18, $18, $18, $18, $18, $18, $18, $18, $3c, $3c
	byte	$00[7]
	byte	$6c, $fe, $fe, $d6, $d6, $c6, $c6, $c6, $c6, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $7e, $66, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $06, $06, $00, $00, $00, $00, $00
	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $60, $60, $00, $00, $00, $00, $00
	byte	$3e, $7e, $66, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $7e, $06, $0e, $3c, $70, $60, $7e, $3e, $00, $00, $00, $00, $00, $18, $18
	byte	$7e, $7e, $18, $18, $18, $18, $18, $78, $70, $00, $00, $00, $00, $00, $00, $00
	byte	$66[7]
	byte	$7e, $7c, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $c6, $c6, $d6, $d6, $fe, $fe, $ee
	byte	$c6, $82, $00, $00, $00, $00, $00, $00, $00, $66, $66, $3c, $3c, $18, $3c, $3c
	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $7e
	byte	$7c, $60, $7e, $3e, $00, $00, $00, $00, $00, $7e, $7e, $30, $18, $18, $0c, $0c
	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $18, $18, $18, $0c, $0c, $18, $18, $18
	byte	$18, $30, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $0c, $18, $18, $18, $18, $30, $30, $18, $18, $18
	byte	$18, $0c, $00, $00, $00, $00, $6c, $7e, $36, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
'-' a8_font        file "atari8.fnt"
	byte	$00, $6c, $fe, $fe, $7c, $38, $10, $00, $18, $18, $18, $f8, $f8, $18, $18, $18
	byte	$c0[8]
	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
	byte	$0f[8]
	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
	byte	$66[5]
	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
	byte	$08, $00
'-' a8_font2       file "atari8.fnt"
	byte	$00, $6c, $fe, $fe, $7c, $38, $10, $00, $18, $18, $18, $f8, $f8, $18, $18, $18
	byte	$c0[8]
	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
	byte	$0f[8]
	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
	byte	$00[9]
	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
	byte	$66[5]
	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
	byte	$08, $00
'-' amiga_font     file "amigafont.def"
	byte	$00[530]
	byte	$18[6]
	byte	$00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $00, $00, $00
	byte	$00[10]
	byte	$36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $7c, $06, $06, $3c, $60, $60, $3e, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $c6, $69, $36, $18, $6c, $96, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$1c, $36, $36, $1e, $6e, $3b, $33, $73, $de, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $66, $3c, $ff, $3c, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[7]
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00
	byte	$00[16]
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $c0, $60, $30, $18, $0c, $06
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $76, $7e, $6e, $66
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $30, $18, $0c
	byte	$06, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $38, $60, $60
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30
	byte	$30, $30, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06, $3e, $60, $60, $60
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $06, $06, $3e, $66, $66
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $7e, $60, $60, $60, $30, $18, $18
	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $3c, $66, $66
	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $7c, $60, $60
	byte	$30, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $60, $18, $06, $18, $60
	byte	$00[12]
	byte	$7e, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06
	byte	$18, $60, $18, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60
	byte	$60, $30, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
	byte	$7b, $6b, $7b, $03, $03, $1e, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66
	byte	$66, $3e, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $78, $0c, $06
	byte	$06, $06, $06, $06, $0c, $78, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $63
	byte	$63, $63, $63, $63, $33, $1f, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
	byte	$06, $1e, $06, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
	byte	$06, $1e, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06
	byte	$06, $76, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63
	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3c, $18, $18
	byte	$18[5]
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60, $60, $60, $60, $60, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $c3, $63, $33, $1b, $0f, $1b, $33, $63
	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $03, $03, $03, $03, $03, $03, $03, $03
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $6b, $63, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7b, $73, $63, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e, $06, $06, $06
	byte	$06, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $7b
	byte	$fe, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $33, $33, $1f, $1b, $33, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06, $0c, $18, $30, $60, $66
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $7e, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36, $36, $1c
	byte	$08, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $c3, $c3, $c3, $db, $ff, $e7
	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $3c, $66, $c3
	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $7f, $60, $60, $30, $18, $0c, $06, $03
	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $03, $06, $0c, $18, $30, $60, $c0
	byte	$00[8]
	byte	$3c, $30, $30, $30, $30, $30, $30, $30, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$08, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$7f, $00, $00, $00, $00, $00, $00, $18, $18, $30, $00, $00, $00, $00, $00, $00
	byte	$00[10]
	byte	$3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $06, $06, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60
	byte	$7c, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $0c
	byte	$3e, $0c, $0c, $0c, $0c, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7c, $66, $66, $66, $7c, $60, $60, $3c, $00, $00, $00, $00, $00, $06, $06, $06
	byte	$3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $18, $00
	byte	$18[5]
	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $30, $00, $30, $30, $30, $30, $30
	byte	$30, $30, $1e, $00, $00, $00, $00, $00, $03, $03, $03, $33, $1b, $0f, $1b, $33
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $63, $63
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $66
	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $66
	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e
	byte	$06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7c, $66, $66, $66, $7c
	byte	$60, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $06, $06, $06
	byte	$06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $06, $0c, $30, $60
	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $0c, $0c, $3e, $0c, $0c, $0c, $0c
	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66
	byte	$7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $6b, $3e
	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36
	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
	byte	$18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $30, $18, $0c, $06
	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18
	byte	$70, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
	byte	$18, $00, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18
	byte	$0e, $00, $00, $00, $00, $00, $00, $00, $46, $5d, $31, $00, $00, $00, $00, $00
	byte	$00[8]
	byte	$c0, $f0, $3c, $0f, $c3, $f0, $3c, $0f, $03, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $00, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $7e, $1b, $1b, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$78, $cc, $0c, $0c, $1e, $0c, $0c, $06, $7f, $00, $00, $00, $00, $00, $00, $00
	byte	$66, $3c, $66, $66, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$c3, $c3, $66, $3c, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $18, $18, $00, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $06, $06, $3c, $66, $66, $66, $3c, $60, $60, $3c, $00, $00, $00, $00, $00
	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $81, $b9, $85, $85, $b9, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $33, $33, $7e, $00, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $cc, $66, $33, $66, $cc, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $81, $9d, $a5, $9d, $a5, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $18, $7e, $18, $18, $18, $00, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$1e, $30, $30, $18, $0c, $06, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$1e, $30, $30, $1c, $30, $30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $66, $66, $66, $66, $66, $fe, $06, $06, $00, $00, $00, $00, $00
	byte	$7c, $5e, $5e, $5e, $5c, $50, $50, $50, $50, $50, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[9]
	byte	$30, $18, $00, $00, $00, $00, $00, $18, $1c, $18, $18, $18, $18, $18, $00, $00
	byte	$00[7]
	byte	$3c, $66, $66, $3c, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $33, $66, $cc, $66, $33, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$02, $63, $32, $1a, $4e, $66, $f3, $40, $40, $00, $00, $00, $00, $00, $00, $00
	byte	$04, $c6, $64, $34, $7c, $8c, $46, $23, $f0, $00, $00, $00, $00, $00, $00, $00
	byte	$03, $c4, $66, $34, $5b, $6c, $f6, $43, $40, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $18, $00, $18, $0c, $06, $06, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$06, $0c, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $33, $3e, $63, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$4e, $39, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$63, $00, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$1c, $22, $1c, $36, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$f8, $3c, $3c, $36, $f6, $3f, $33, $33, $f3, $00, $00, $00, $00, $00, $00, $00
	byte	$78, $0c, $06, $06, $06, $06, $06, $0c, $78, $30, $18, $00, $00, $00, $00, $00
	byte	$0c, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$66, $00, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$66, $00, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$1e, $36, $66, $66, $6f, $66, $66, $36, $1e, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $73, $67, $6f, $7b, $73, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
	byte	$06, $0c, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $33, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$63, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $63, $36, $1c, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$be, $63, $73, $7b, $6b, $6f, $67, $63, $3f, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $0c, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$08, $36, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$63, $00, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $c3, $66, $3c, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$03, $03, $3f, $63, $63, $3f, $03, $03, $03, $00, $00, $00, $00, $00, $00, $00
	byte	$3c, $66, $66, $66, $36, $66, $66, $66, $36, $06, $06, $00, $00, $00, $00, $00
	byte	$06, $0c, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$60, $30, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $24, $18, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $d8, $fe, $1b, $1b, $ee, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $3c, $06, $06, $06, $06, $3c, $18, $0c, $00, $00, $00, $00, $00
	byte	$06, $0c, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$60, $30, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $0c, $00, $0c, $0c, $0c, $0c, $0c, $18, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
	byte	$03, $06, $3f, $18, $3c, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $00, $3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
	byte	$06, $0c, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$60, $30, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$8e, $71, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $18, $18, $00, $7e, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $7e, $73, $7b, $6f, $67, $3f, $00, $00, $00, $00, $00, $00, $00
	byte	$0c, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$18, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
	byte	$06, $06, $06, $3e, $66, $66, $66, $3e, $06, $06, $06, $00, $00, $00, $00, $00
	byte	$00, $66, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
	byte	$00, $7e, $66, $66, $66, $66, $66, $66, $66, $7e, $00, $00, $00, $00, $00, $00
	byte	$00[526]
'-' vga16          long  $00000000,$00008000,$00800000,$00808000,$80000000,$80008000,$80400000,$AAAAAA00,$55555500,$0000FF00,$00FF0000,$00FFFF00,$FF000000,$FF00FF00,$FFFF0000,$FFFFFF00
	byte	$00[5]
	byte	$80, $00, $00, $00, $00, $80, $00, $00, $80, $80, $00, $00, $00, $00, $80, $00
	byte	$80, $00, $80, $00, $00, $40, $80, $00, $aa, $aa, $aa, $00, $55, $55, $55, $00
	byte	$ff, $00, $00, $00, $00, $ff, $00, $00, $ff, $ff, $00, $00, $00, $00, $ff, $00
	byte	$ff, $00, $ff, $00, $00, $ff, $ff, $00, $ff, $ff, $ff
'-' ataripalette   file "ataripalettep2.def"
	byte	$00[5]
	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
'-' ataripalette2  file "ataripalettep2.def"
	byte	$00[5]
	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
'-' 
'-' '**********************************************************************************
'-' '
'-' '        Timings and colors definitions
'-' '
'-' '**********************************************************************************
'-' 
'-' '                      bf.hs, hs,  bf.vis  visible, up p., vsync, down p.,  cpl, total lines, clock,       hubset                                scanlines  ud bord mode reserved
'-' timings         long   8,     60,  8,       1024,   7,     4,     1,        128, 600,         340500000,   %1_100111__10_1010_1000__1111_1011,   600,        0,     192, 0, 0
	byte	$08, $00, $00, $00, $3c, $00, $00, $00, $08, $00, $00, $00, $00, $04, $00, $00
	byte	$07, $00, $00, $00, $04, $00, $00, $00, $01, $00, $00, $00, $80, $00, $00, $00
	byte	$58, $02, $00, $00, $20, $9e, $4b, $14, $fb, $a8, $9e, $01, $58, $02, $00, $00
	byte	$00, $00, $00, $00, $c0, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-' 'timings        long   16,    80,  12,      1024,   8,     4,     8,        128, 576,         336956522,   %1_101101__11_0000_0110__1111_1011,   576,        0,     192, 0, 0
'-' vgacolors       byte   0, 117, 199, 151, 39, 71, 246, 10, 5, 121, 203, 155, 43, 75, 234, 15
	byte	$00, $75, $c7, $97, $27, $47, $f6, $0a, $05, $79, $cb, $9b, $2b, $4b, $ea, $0f
'-' 
'-' ''--------  Initialization  ----------------------------------------------------------------
'-' 
'-' hdmi            setq    #6
	byte	$28, $0c, $64, $fd
'-'                 rdlong  vblankptr,  ptra                   ' read pointers
	byte	$00, $a5, $05, $fb
'-'                 setq    #8
	byte	$28, $10, $64, $fd
'-'                 rdlong  m_bs,modeptr                       ' read timings
	byte	$d3, $8a, $01, $fb
'-' 
'-'                 bitl    hbase, #31 wcz                     ' if pin 31 is set, use full strength for Adafruit Pico HDMI board
	byte	$1f, $ac, $1d, $f4
'-'                 setcmod #$100                              ' enable HDMI mode
	byte	$3c, $00, $66, $fd
'-'                 mov     t1,#448                            ' 7 << 6          
	byte	$c0, $c7, $05, $f6
'-'                 add     t1,hbase
	byte	$d6, $c6, $01, $f1
'-'                 drvl    t1                                 ' #7<<6 + hdmi_base      ' enable HDMI pins
	byte	$58, $c6, $61, $fd
'-'         if_z    wrpin   #0, t1  '#7<<6 + hdmi_base         ' for Adafruit breakout board - full logic as in Pico, the board has 220 Ohm resistors on it
	byte	$e3, $00, $08, $ac
'-' 	if_nz   wrpin   ##%10110_1111_0111_10_00000_0, t1  ' #7<<6 + hdmi_base      ' a '123 ohm BITDAC for Parallax breakout board
	byte	$7b, $0b, $80, $5f, $e3, $00, $0b, $5c
'-'                 setxfrq ##$0CCCCCCC+1                      ' set streamer freq to 1/10th clk
	byte	$66, $66, $86, $ff, $1d, $9a, $65, $fd
'-' '
'-'                 mov 	t1,hbase			   '
	byte	$d6, $c6, $01, $f6
'-'                 shl 	t1,#17                             '
	byte	$11, $c6, $65, $f0
'-'                 add 	lutg8,t1                           ' add the pin base to he streamer constant
	byte	$e3, $a2, $01, $f1
'-'                 sub 	i_upporch,#2			   ' the driver will call 2 blank lines itself to preload the buffer, so sub #2 from up porch time
	byte	$02, $92, $85, $f1
'-' 
'-'                 cogid   t1              		   ' get a cogid
	byte	$01, $c6, $61, $fd
'-'                 mul     t1, #12                            ' compute the offset to PSRAM mailbox 
	byte	$0c, $c6, $05, $fa
'-'                 add     mailbox, t1                        ' add offset to find this COG's mailbox
	byte	$e3, $ae, $01, $f1
'-' 
'-' ''--------  frame rendering main loop  ---------------------------------------------------
'-' 
'-' p101            setq 	#3
	byte	$28, $06, $64, $fd
'-' 		rdlong  vblankptr,ptra
	byte	$00, $a5, $05, $fb
'-'                 setq    #47+6				   ' read sprite data
	byte	$28, $6a, $64, $fd
'-' 	 	rdlong  sprite1pointer,spriteptr
	byte	$d8, $dc, $01, $fb
'-' 		mov     spriteline,#0                      ' init the sprite line variable
	byte	$00, $4a, $06, $f6
'-'                 mov     dlinum, #0
	byte	$00, $a0, $05, $f6
'-'                 add     frames,#1			   ' increment the frame counter
	byte	$01, $9e, $05, $f1
'-'                 mov     dlptr2,dlptr			   ' init the temporary DL pointer
	byte	$d5, $b8, $01, $f6
'-' 
'-' 
'-'                 mov     linenum,#0			   ' init the current line #
	byte	$00, $9c, $05, $f6
'-'                 mov     rcnt,#0			   	   ' init the DL repeat counter
	byte	$00, $ce, $05, $f6
'-'                 mov     rcnt2a,affffffff 		   ' why?!                
	byte	$ed, $d2, $01, $f6
'-'                 
'-' 
'-' 
'-' '' ------- reload the palette. If bit31 set, don't reload, to prevent blinking while modifying the palette
'-'   
'-'                 testb   paletteptr,#31 wc
	byte	$1f, $a8, $15, $f4
'-'          if_nc  setq2   #255
	byte	$29, $fe, $65, $3d
'-'          if_nc  rdlong  $000, paletteptr                   'read palette
	byte	$d4, $00, $00, $3b
'-' 
'-' '' -----   up porch (before the picture)
'-' 
'-'                 mov     hsync0,sync_000      	           ' init constants for sync
	byte	$c0, $c2, $01, $f6
'-'                 mov     hsync1,sync_001	
	byte	$c1, $c4, $01, $f6
'-'                 callpa  i_upporch ,#blank                  ' call the porch line i_upporch (-2) times
	byte	$40, $92, $45, $fb
'-'                 wrlong  #0,vblankptr                       ' the vblank time ends here
	byte	$d2, $00, $68, $fc
'-'  
'-'    
'-'  
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'          	     call    #dli	                  ' call DL interpreter for line #0 at line #(-2) - 2 lines earlier, so it can start preloading data from PSRAM
	byte	$60, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                          rdfast  #64,buf1d                          ' prepare the HUB buffer for 4 scanlines
	byte	$df, $80, $78, $fc
'-' 
'-'                 xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-' 		call    #dli
	byte	$48, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'                  call    #sprite				   ' sprites for line #0
	byte	$20, $01, $b0, $fd
'-'                 	
'-'                 
'-' 
'-'  
'-' '' ------- the main screen drawing starts here
'-' 
'-' p301            xcont   m_bs,hsync0   			  ' make a right porch
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1                       ' make hsync
	byte	$e2, $8c, $b1, $fc
'-'                 call    #dli                              ' process the DL for line+2                
	byte	$30, $00, $b0, $fd
'-'                 xcont   m_bv,hsync0
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   lutg8,#0			  ' display the line 
	byte	$00, $a2, $c5, $fc
'-'                  add     linenum,#1                        ' increment the current line number 
	byte	$01, $9c, $05, $f1
'-'                  call    #sprite                           ' process sprites for line+1             
	byte	$04, $01, $b0, $fd
'-'               
'-' 
'-'                 cmp     linenum,i_totalvis  wz            ' check if all lines displayed
	byte	$cd, $9c, $09, $f2
'-'     if_nz       jmp     #p301                             ' if not, display the next line
	byte	$dc, $ff, $9f, $5d
'-' 
'-' ' ---------------- All visible lines displayed now, start vblank  
'-' 
'-' p112            wrlong  #1,vblankptr                       ' tell the system that the vblank started
	byte	$d2, $02, $68, $fc
'-'                 callpa  i_downporch ,#blank                ' bottom blanks
	byte	$28, $96, $45, $fb
'-'                 mov     hsync0,sync_222                    ' vsync on
	byte	$c2, $c2, $01, $f6
'-'                 mov     hsync1,sync_223
	byte	$c3, $c4, $01, $f6
'-'                 callpa  i_vsync,#blank                     ' vertical sync blanks
	byte	$25, $94, $45, $fb
'-'                 jmp     #p101                              ' return to the main loop
	byte	$4c, $ff, $9f, $fd
'-' 
'-' '' --------------- END of frame rendering loop ---------------------------------------------------------------------------
'-' 
'-' '' --------------- Display list interpreter ---------------------------------------------------------------------------
'-' 
'-' dli             cmp     rcnt,#0 wz			   ' check the DL repeat counter 
	byte	$00, $ce, $0d, $f2
'-' 
'-'     if_z        rdlong  dl,dlptr2				
	byte	$dc, $ba, $01, $ab
'-'     if_z        add     dlptr2,#4
	byte	$04, $b8, $05, $a1
'-'     if_z        jmp     #p307                              ' no repeat, goto read and interpret the next DL entry
	byte	$14, $00, $90, $ad
'-' 
'-'                 sub     rcnt,#1 wz                         ' decrement the repeat counter
	byte	$01, $ce, $8d, $f1
'-'     if_nz       mov     dl,rdl                             ' restore repeating DL entry from temporary buffer
	byte	$eb, $ba, $01, $56
'-'                 incmod  rcnt2a,rcnt2 wcz                   ' address update counter
	byte	$e8, $d2, $19, $f7
'-'     if_c        add     dl,roffset                         ' if it rollovers, add the offset to the data address
	byte	$ea, $ba, $01, $c1
'-'                 mov     rdl,dl                             ' save the result
	byte	$dd, $d6, $01, $f6
'-' 
'-' p307	        mov     framebuf2,dl wcz                   ' move this to framebuf2. If normal DL entry, the frame buffer start will be extracted from this
	byte	$dd, $c0, $19, $f6
'-'                 getnib  t1,dl,#0
	byte	$dd, $c6, $41, $f8
'-'                 cmp     t1,#%0010 wz			   ' 0010 - display a normal graphics line, preload it from the PSRAM
	byte	$02, $c6, $0d, $f2
'-'     if_z        jmp     #preload
	byte	$70, $00, $90, $ad
'-'     		cmp     t1,#%0000 wz			   ' 0000 - display a line from a PSRAM list
	byte	$00, $c6, $0d, $f2
'-'     if_z        jmp     #preload2
	byte	$94, $00, $90, $ad
'-'                 cmp     t1,#%0001 wz			   ' 0001 - repeat
	byte	$01, $c6, $0d, $f2
'-'     if_z        jmp     #p390
	byte	$0c, $00, $90, $ad
'-'                 cmp     t1,#%0011 wz			   ' 0011 - palette reload
	byte	$03, $c6, $0d, $f2
'-'     if_z        jmp     #p391  
	byte	$28, $00, $90, $ad
'-' 
'-' p308            ret
	byte	$2d, $00, $64, $fd
'-'    
'-' p390            rdlong  rdl,dlptr2                         ' read the next DL entry to repeat
	byte	$dc, $d6, $01, $fb
'-'                 getword rcnt,framebuf2,#1                  ' read the repeat count
	byte	$e0, $ce, $39, $f9
'-'                 shr     rcnt,#4                            ' from 12 upper bits
	byte	$04, $ce, $45, $f0
'-'                 mov     rcnt2a,affffffff                   ' I still don't know why?
	byte	$ed, $d2, $01, $f6
'-'                 getnib  rcnt2,framebuf2,#4                 ' read the pointer update counter
	byte	$e0, $d0, $61, $f8
'-'                 getword roffset,framebuf2,#0               ' read the offset to add
	byte	$e0, $d4, $31, $f9
'-'                 shr     roffset,#4                         ' clean the command field from offset
	byte	$04, $d4, $45, $f0
'-'                 shl     roffset,#4                         ' and make it ready to add to the DL entry (address=20 upper bits)
	byte	$04, $d4, $65, $f0
'-'                 jmp     #dli                               ' now start repeating 
	byte	$8c, $ff, $9f, $fd
'-'  
'-' '' --------  Reload palette. To do 
'-' 
'-' p391           	getnib  t1,framebuf2,#2			   ' get a bank (0..15) of 16 colors
	byte	$e0, $c6, $51, $f8
'-'          	shl     t1,#4				   ' compute the LUT address
	byte	$04, $c6, $65, $f0
'-'         	shr     framebuf2,#12			   ' compute the HUB address of 16 new colors
	byte	$0c, $c0, $45, $f0
'-'          	setq2   #15				   ' load 16 entries
	byte	$29, $1e, $64, $fd
'-'          	altd    t1                                 ' from t1 LUT address
	byte	$00, $c6, $8d, $f9
'-'         	rdlong  $000, framebuf2         	
	byte	$e0, $00, $00, $fb
'-'         	jmp     #dli                
	byte	$70, $ff, $9f, $fd
'-'       
'-' '' --------------- A display list interpreter end ------------------------------------------------------------------------    
'-' 
'-' 
'-' '' --------------- Blank and vsync procedures called via callpa have to be in the middle of the code ---------------------
'-' 
'-' blank           xcont   m_bs,hsync0                        ' horizontal sync
	byte	$e1, $8a, $c1, $fc
'-'                 xzero   m_sn,hsync1
	byte	$e2, $8c, $b1, $fc
'-'                 xcont   m_bv,hsync0     
	byte	$e1, $8e, $c1, $fc
'-'                 xcont   m_vi,hsync0
	byte	$e1, $90, $c1, $fc
'-'         _ret_   djnz    pa,#blank
	byte	$fb, $ed, $6f, $0b
'-'         
'-' '' -------------- Preload a line from PSRAM        
'-'         
'-' preload         mov     buf1c,dlinum			   ' preload a line buffer #dlinum (0..3)
	byte	$d0, $bc, $01, $f6
'-'                 shl     buf1c,#10		           ' 1024 bytes per line
	byte	$0a, $bc, $65, $f0
'-'                 add     buf1c,buf1d			   ' add the start address (himem-debug-4096) : Todo: debug variable!
	byte	$df, $bc, $01, $f1
'-'                 mov     buf1,buf1c
	byte	$de, $b4, $01, $f6
'-'                 incmod  dlinum,#3
	byte	$03, $a0, $05, $f7
'-' 
'-'                 shr     framebuf2,#4                      ' get the PSRAM start address from DL - Todo: use new DL format
	byte	$04, $c0, $45, $f0
'-'                 mov     buf2,a1024
	byte	$32, $b7, $01, $f6
'-'                 mov     cmd,framebuf2                      ' set the address
	byte	$e0, $b2, $01, $f6
'-'                 setnib  cmd, #%1011, #7                    ' attach the command - read burst from the external memory
	byte	$0b, $b2, $3d, $f8
'-'                 setq    #2				   ' write 3 longs to the mailbox
	byte	$28, $04, $64, $fd
'-'     _ret_       wrlong  cmd,mailbox			   ' read the PSRAM
	byte	$d7, $b2, $61, $0c
'-'  
'-'  
'-' preload2      '  incmod  dlinum,#3
'-'                 shr 	framebuf2,#4
	byte	$04, $c0, $45, $f0
'-'                 mov 	cmd,affffffff
	byte	$ed, $b2, $01, $f6
'-'                 mov 	buf1,framebuf2
	byte	$e0, $b4, $01, $f6
'-'                 setq	#1
	byte	$28, $02, $64, $fd
'-'     _ret_	wrlong  cmd,mailbox
	byte	$d7, $b2, $61, $0c
'-'                 
'-' 
'-' '' -------------- Draw sprites
'-' 
'-' sprite          mov t8,frames
	byte	$cf, $5c, $02, $f6
'-' 		and t8,#16 wz
	byte	$10, $5c, $0e, $f5
'-'                 mov spritenum, #17			' 16 +2 sprites. Todo: this should be a parameter
	byte	$11, $48, $06, $f6
'-' 	if_z    mov spritenum, #16	
	byte	$10, $48, $06, $a6
'-' 		
'-' 
'-' p802            mov     t5,spritenum		   	' prepare a pointer to load sprite data
	byte	$24, $57, $02, $f6
'-'                 mul     t5,#3          			' one sprite data set needs 3 longs
	byte	$03, $56, $06, $fa
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_y,0-0,#1		        ' get a sprite y
	byte	$00, $4e, $3a, $f9
'-'                 signx	sprite_y,#15			' they can be negative
	byte	$0f, $4e, $66, $f7
'-'                 alts    t5,#sprite1xy
	byte	$ef, $56, $96, $f9
'-'                 getword sprite_x,0-0,#0                 ' and x
	byte	$00, $4c, $32, $f9
'-'                 signx	sprite_x,#15
	byte	$0f, $4c, $66, $f7
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_h,0-0,#1		       	' get a sprite height
	byte	$00, $52, $3a, $f9
'-'                 sub     sprite_h,#1
	byte	$01, $52, $86, $f1
'-'                 alts    t5,#sprite1wh
	byte	$f0, $56, $96, $f9
'-'                 getword sprite_w,0-0,#0                 ' and width
	byte	$00, $50, $32, $f9
'-' 
'-' 
'-'                	cmps	sprite_x,a1024 wcz	         
	byte	$32, $4d, $5a, $f2
'-'      if_ge	jmp 	#p801                           ' go out if >1023
	byte	$bc, $00, $90, $3d
'-'               	cmps	sprite_w,#0 wcz	         
	byte	$00, $50, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if w=0
	byte	$b4, $00, $90, $ad
'-'               	cmps	sprite_h,#0 wcz	         
	byte	$00, $52, $5e, $f2
'-'      if_e	jmp 	#p801                           ' go out if h=0
	byte	$ac, $00, $90, $ad
'-'                 mov 	t9,#0
	byte	$00, $5e, $06, $f6
'-'                 sub 	t9,sprite_w                      	
	byte	$28, $5f, $82, $f1
'-'      		cmps  	sprite_x,t9 wcz   		'
	byte	$2f, $4d, $5a, $f2
'-'      if_le	jmp 	#p801	                        ' go out if sprite out of screen at right
	byte	$9c, $00, $90, $ed
'-'      
'-'   		mov     t2,linenum			' display line # to check if sprite has to be displayed
	byte	$ce, $c8, $01, $f6
'-'   		subs    t2,sprite_y wcz                 ' check if the sprite has to be displayed
	byte	$27, $c9, $d9, $f1
'-'      if_c       jmp     #p801				' if not, go out
	byte	$90, $00, $90, $cd
'-'                 cmp     t2,sprite_h wcz		    	' we have now the sprite line #, check, if it is not >= sprite height
	byte	$29, $c9, $19, $f2
'-'      if_gt      jmp     #p801				' if yes, go out
	byte	$88, $00, $90, $1d
'-'                 
'-'                 mov     t3,spriteline			' compute the line buffer addres where to put the sprite line
	byte	$25, $cb, $01, $f6
'-'                 shl     t3,#10			       	' =1024*spriteline where spriteline=0..3		' 
	byte	$0a, $ca, $65, $f0
'-'                 add     t3,buf1d			' line buffer addr
	byte	$df, $ca, $01, $f1
'-'   		
'-'   		testb	sprite_x,#31 wc 		' check if sprite pos <0
	byte	$1f, $4c, $16, $f4
'-'      if_nc      add     t3,sprite_x   			' if >=0 add xpos. If <0, the address is the start of the line  - now we have the address to where wmlong the sprite
	byte	$26, $cb, $01, $31
'-' 
'-'                 mul 	t2,sprite_w			' compute the offset to the sprite line data
	byte	$28, $c9, $01, $fa
'-'      if_c	add     sprite_w,sprite_x		' if sprite_x negative, shorten the width
	byte	$26, $51, $02, $c1
'-'      if_c	sub 	t2,sprite_x			' and add the offset (sub negative) to the sprite data offset
	byte	$26, $c9, $81, $c1
'-'  
'-'                 alts    t5,#sprite1pointer		' get the pointer to the sprite (3 longs per sprite data)
	byte	$ee, $56, $96, $f9
'-'                 add     t2,0-0				' then add the offset
	byte	$00, $c8, $01, $f1
'-'      if_c 	jmp     #p899		
	byte	$10, $00, $90, $cd
'-' 	
'-' 	
'-' 		mov 	t4,sprite_x	'
	byte	$26, $cd, $01, $f6
'-' 		add	t4,sprite_w
	byte	$28, $cd, $01, $f1
'-' 		sub     t4,a1024 wcz			' check if the sprite goes right off the screen
	byte	$32, $cd, $99, $f1
'-' 
'-' 	if_nc	sub	sprite_w,t4			' if yes, make it narrower
	byte	$e6, $50, $82, $31
'-' 
'-' p899		mov 	t6,sprite_w
	byte	$28, $59, $02, $f6
'-' 	 	sub     t6,#1
	byte	$01, $58, $86, $f1
'-' 	 	shr	t6,#2				' bytes to longs
	byte	$02, $58, $46, $f0
'-' 
'-'                 setq   	t6
	byte	$28, $58, $62, $fd
'-'                 rdlong 368,t2				' read sprite data to the cog
	byte	$e4, $e0, $02, $fb
'-'                 mov t8,sprite_w
	byte	$28, $5d, $02, $f6
'-'                 and t8,#3 wz				' if width mod 4=0 we have full longs, nothing to do
	byte	$03, $5c, $0e, $f5
'-'         if_z    jmp #p898
	byte	$24, $00, $90, $ad
'-'          
'-'         
'-'                 mov  t9,#368
	byte	$70, $5f, $06, $f6
'-'                 add t9,t6				' find the last long of the sprite
	byte	$2c, $5f, $02, $f1
'-' 
'-'                 subr t8,#4				' if modulo4=1, mask 3 bytes, if 2, mask 2, if 1, mask 3
	byte	$04, $5c, $c6, $f2
'-'                 mul t8,#8				' bits to shr
	byte	$08, $5c, $06, $fa
'-'                 mov t7,##-1				' full of 1s
	byte	$ff, $ff, $7f, $ff, $ff, $5b, $06, $f6
'-'                 shr t7,t8				' SHR to make 0s for masking
	byte	$2e, $5b, $42, $f0
'-'                 altd t9,#0				' and mask 
	byte	$00, $5e, $8e, $f9
'-'                 and 0-0, t7
	byte	$2d, $01, $00, $f5
'-'                
'-' 
'-' p898            setq   t6				' write the sprite data to the line buffer
	byte	$28, $58, $62, $fd
'-'                 wmlong 368,t3				
	byte	$e5, $e0, $7a, $fa
'-'                 
'-' p801            djnf spritenum,#p802			' get the next sprite
	byte	$c1, $49, $7e, $fb
'-'                 incmod spriteline,#3			' prepare to fill the next line
	byte	$03, $4a, $06, $f7
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 	
'-' 	
'-'                
'-'  
'-' '' -------------- Graphics line ------------------------------------------------------------
'-'  
'-' 
'-' '' consts and vars
'-' 
'-' sync_000        long    %1101010100_1101010100_1101010100_10    '
	byte	$52, $4d, $35, $d5
'-' sync_001        long    %1101010100_1101010100_0010101011_10    '        hsync
	byte	$ae, $42, $35, $d5
'-' sync_222        long    %0101010100_0101010100_0101010100_10    'vsync
	byte	$52, $45, $15, $55
'-' sync_223        long    %0101010100_0101010100_1010101011_10    'vsync + hsync
	byte	$ae, $4a, $15, $55
'-' 
'-' border          long    %00000000_00011010_00101100_00000000
	byte	$00, $2c, $1a, $00
'-' 
'-' '------ these longs will be set by setmode function
'-' 
'-' m_bs            long    0        'blanks before sync
	byte	$00, $00, $00, $00
'-' m_sn            long    0        'sync
	byte	$00, $00, $00, $00
'-' m_bv            long    0        'blanks before visible
	byte	$00, $00, $00, $00
'-' m_vi            long    0        'visible pixels #
	byte	$00, $00, $00, $00
'-' 'm_border        long    0        'left/right borders
'-' i_upporch       long    0        'up porch lines
	byte	$00, $00, $00, $00
'-' i_vsync         long    0        'vsync lines
	byte	$00, $00, $00, $00
'-' i_downporch     long    0        'down porch lines
	byte	$00, $00, $00, $00
'-' i_cpl           long    0        'chars/longs per line
	byte	$00, $00, $00, $00
'-' i_totalvis      long    0
	byte	$00, $00, $00, $00
'-' 
'-' '-------------------------------------
'-'  
'-' linenum         long    0
	byte	$00, $00, $00, $00
'-' frames          long    0
	byte	$00, $00, $00, $00
'-' dlinum long 0
	byte	$00, $00, $00, $00
'-' lutg8           long    $70880400 ' 0111_0000_1000_1000
	byte	$00, $04, $88, $70
'-' 
'-' vblankptr       long    0
	byte	$00, $00, $00, $00
'-' modeptr         long    0
	byte	$00, $00, $00, $00
'-' paletteptr      long    0
	byte	$00, $00, $00, $00
'-' dlptr           long    0
	byte	$00, $00, $00, $00
'-' hbase           long    1
	byte	$01, $00, $00, $00
'-' mailbox         long    0
	byte	$00, $00, $00, $00
'-' spriteptr          long 0
	byte	$00, $00, $00, $00
'-' 
'-' cmd             long    0
	byte	$00, $00, $00, $00
'-' buf1            long    $80000-1024-4096
	byte	$00, $ec, $07, $00
'-' buf2            long    1024
	byte	$00, $04, $00, $00
'-' dlptr2          long    1
	byte	$01, $00, $00, $00
'-' dl              long    1
	byte	$01, $00, $00, $00
'-' 
'-' buf1c long 0
	byte	$00, $00, $00, $00
'-' buf1d            long    $80000-1024-4096
	byte	$00, $ec, $07, $00
'-' framebuf2       long    1
	byte	$01, $00, $00, $00
'-' hsync0          long    1
	byte	$01, $00, $00, $00
'-' hsync1          long    1
	byte	$01, $00, $00, $00
'-' 
'-' t1              long    1
	byte	$01, $00, $00, $00
'-' t2 long 0
	byte	$00, $00, $00, $00
'-' t3 long 0
	byte	$00, $00, $00, $00
'-' t4 long 0
	byte	$00, $00, $00, $00
'-' 
'-' rcnt            long    0  'dl repeat count
	byte	$00, $00, $00, $00
'-' rcnt2           long    0
	byte	$00, $00, $00, $00
'-' rcnt2a          long    0
	byte	$00, $00, $00, $00
'-' roffset         long    0
	byte	$00, $00, $00, $00
'-' rdl             long    0  'dl repeat line
	byte	$00, $00, $00, $00
'-' dlc             long    0  'dl command
	byte	$00, $00, $00, $00
'-' 
'-' affffffff       long    $ffffffff
	byte	$ff, $ff, $ff, $ff
'-' sprite1pointer long 0
	byte	$00, $00, $00, $00
'-' sprite1xy      long 0
	byte	$00, $00, $00, $00
'-' sprite1wh      long 0
	byte	$00, $00, $00, $00
'-' sprite2pointer long 0
	byte	$00, $00, $00, $00
'-' sprite2xy      long 0
	byte	$00, $00, $00, $00
'-' sprite2wh      long 0
	byte	$00, $00, $00, $00
'-' sprite3pointer long 0
	byte	$00, $00, $00, $00
'-' sprite3xy      long 0
	byte	$00, $00, $00, $00
'-' sprite3wh      long 0
	byte	$00, $00, $00, $00
'-' sprite4pointer long 0
	byte	$00, $00, $00, $00
'-' sprite4xy      long 0
	byte	$00, $00, $00, $00
'-' sprite4wh      long 0
	byte	$00, $00, $00, $00
'-' sprite5pointer long 0
	byte	$00, $00, $00, $00
'-' sprite5xy      long 0
	byte	$00, $00, $00, $00
'-' sprite5wh      long 0
	byte	$00, $00, $00, $00
'-' sprite6pointer long 0
	byte	$00, $00, $00, $00
'-' sprite6xy      long 0
	byte	$00, $00, $00, $00
'-' sprite6wh      long 0
	byte	$00, $00, $00, $00
'-' sprite7pointer long 0
	byte	$00, $00, $00, $00
'-' sprite7xy      long 0
	byte	$00, $00, $00, $00
'-' sprite7wh      long 0
	byte	$00, $00, $00, $00
'-' sprite8pointer long 0
	byte	$00, $00, $00, $00
'-' sprite8xy      long 0
	byte	$00, $00, $00, $00
'-' sprite8wh      long 0
	byte	$00, $00, $00, $00
'-' sprite9pointer long 0
	byte	$00, $00, $00, $00
'-' sprite9xy      long 0
	byte	$00, $00, $00, $00
'-' sprite9wh      long 0
	byte	$00, $00, $00, $00
'-' sprite10pointer long 0
	byte	$00, $00, $00, $00
'-' sprite10xy      long 0
	byte	$00, $00, $00, $00
'-' sprite10wh      long 0
	byte	$00, $00, $00, $00
'-' sprite11pointer long 0
	byte	$00, $00, $00, $00
'-' sprite11xy      long 0
	byte	$00, $00, $00, $00
'-' sprite11wh      long 0
	byte	$00, $00, $00, $00
'-' sprite12pointer long 0
	byte	$00, $00, $00, $00
'-' sprite12xy      long 0
	byte	$00, $00, $00, $00
'-' sprite12wh      long 0
	byte	$00, $00, $00, $00
'-' sprite13pointer long 0
	byte	$00, $00, $00, $00
'-' sprite13xy      long 0
	byte	$00, $00, $00, $00
'-' sprite13wh      long 0
	byte	$00, $00, $00, $00
'-' sprite14pointer long 0
	byte	$00, $00, $00, $00
'-' sprite14xy      long 0
	byte	$00, $00, $00, $00
'-' sprite14wh      long 0
	byte	$00, $00, $00, $00
'-' sprite15pointer long 0
	byte	$00, $00, $00, $00
'-' sprite15xy      long 0
	byte	$00, $00, $00, $00
'-' sprite15wh      long 0
	byte	$00, $00, $00, $00
'-' sprite16pointer long 0
	byte	$00, $00, $00, $00
'-' sprite16xy      long 0
	byte	$00, $00, $00, $00
'-' sprite16wh      long 0
	byte	$00, $00, $00, $00
'-' sprite17pointer long 0
	byte	$00, $00, $00, $00
'-' sprite17xy      long 0
	byte	$00, $00, $00, $00
'-' sprite17wh      long 0
	byte	$00, $00, $00, $00
'-' sprite18pointer long 0
	byte	$00, $00, $00, $00
'-' sprite18xy      long 0
	byte	$00, $00, $00, $00
'-' sprite18wh      long 0
	byte	$00, $00, $00, $00
'-' spritenum long 0
	byte	$00, $00, $00, $00
'-' 
'-' spriteline long 0
	byte	$00, $00, $00, $00
'-' sprite_x long 900
	byte	$84, $03, $00, $00
'-' sprite_y long 0
	byte	$00, $00, $00, $00
'-' sprite_w long 16
	byte	$10, $00, $00, $00
'-' sprite_h long 64
	byte	$40, $00, $00, $00
'-' l2 long 0
	byte	$00, $00, $00, $00
'-' t5 long 0
	byte	$00, $00, $00, $00
'-' t6 long 0
	byte	$00, $00, $00, $00
'-' t7 long 0
	byte	$00, $00, $00, $00
'-' t8 long 0
	byte	$00, $00, $00, $00
'-' t9 long 0
	byte	$00, $00, $00, $00
'-' preloadaddr long 0
	byte	$00, $00, $00, $00
'-' preloadlineaddr long 0
	byte	$00, $00, $00, $00
'-' a1024 long 1024
	byte	$00, $04, $00, $00
'-' 
'-' aa long 992
	byte	$e0, $03, $00, $00
'-' a1023 long 1023
	byte	$ff, $03, $00, $00
'-' a4096 long 4096
	byte	$00, $10, $00, $00
'-'  fit 368
'-'  fit 368
	alignl
_psram_spin2_dat_
'-'     listdata long 0[8*8]
	byte	$00[256]
'-'             orgh
'-' 
'-' ' driver state
'-' drivercog   long    -1  ' COG id of driver
	byte	$ff, $ff, $ff, $ff
'-' driverlock  long    -1  ' LOCK id of driver
	byte	$ff, $ff, $ff, $ff
'-' 
'-' ' delay profile
'-' delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
	byte	$07, $00, $00, $00, $00, $cf, $7b, $05, $80, $d1, $f0, $08, $80, $4f, $47, $0c
	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
'-' 
'-' ' data to be passed to driver when starting it
'-' startupData
'-'     long    0           ' current frequency
	byte	$00, $00, $00, $00
'-'     long    FLAGS       ' optional flags for driver
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port A for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    0           ' reset pin mask on port B for PSRAM (none)
	byte	$00, $00, $00, $00
'-'     long    DATABUS     ' PSRAM data bus start pin
	byte	$28, $00, $00, $00
'-'     long    deviceData  ' address of devices data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 328
'-'     long    qosData     ' address of QoS data structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 456
'-'     long    mailboxes   ' address of mailbox structure in HUBRAM
	long	@@@_psram_spin2_dat_ + 488
'-' 
'-' ' data for memory
'-' deviceData
'-'     ' 16 bank parameters follow (16MB per bank)
'-'     long    0[16]                               ' banks 0-15
	byte	$00[64]
'-'     ' 16 banks of pin parameters follow
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
	byte	$39, $38, $00, $00
'-'     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
	byte	$39, $38, $00, $00
'-'     long    -1[14]                              ' banks 2-15
	byte	$ff[56]
'-' 
'-' ' data for COG polling
'-' qosData 
'-'     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
'-'     
'-' ' mailbox storage
'-' 
'-' mailboxes
'-'     long    0[8*3]          ' 3 longs per mailbox per COG
	byte	$00[96]
	alignl
_psram16drv_spin2_dat_
'-'                             orgh
'-' scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
	byte	$00[32]
'-' 
'-' driver_start
'-'                             org
'-' '..................................................................................................
'-' ' Memory layout for COG RAM once operational:
'-' '
'-' '  COG RAM address      Usage
'-' '  ---------------      ----
'-' '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
'-' '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
'-' '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
'-' '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
'-' '   $100-$197           Mailbox poller, error handlers, and all driver management code
'-' '  ~$198-$1F3           State and register variables
'-' '
'-' ' Also during driver COG startup:
'-' '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
'-' ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
'-' '..................................................................................................
'-'                             
'-' ' Mailbox storage after vector initialization
'-' 
'-' req0                        call    #init                   'do HW setup/initialization
	byte	$fc, $01, $b0, $fd
'-' data0                       rdlut   c, b wz                 'read bank info          
	byte	$f0, $e3, $ab, $fa
'-' count0                      mov     a, b                    'set COGRAM address low nibble
	byte	$f0, $df, $03, $f6
'-' req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
	byte	$68, $f0, $07, $a6
'-' data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
	byte	$0a, $e2, $17, $f4
'-' count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
	byte	$50, $f0, $07, $16
'-' req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
	byte	$58, $f0, $07, $46
'-' data2                       mov     c, #$8                  'setup vector base to $80
	byte	$08, $e2, $07, $f6
'-' count2                      setnib  a, c, #1                'prepare vector base address for bank
	byte	$f1, $df, $0b, $f8
'-' req3                        altd    a, #0                   'prepare COG destination read address
	byte	$00, $de, $8f, $f9
'-' data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
	byte	$61, $01, $a4, $fa
'-' count3                      incmod  c, #15 wz               'next vector
	byte	$0f, $e2, $0f, $f7
'-' req4        if_nz           jmp     #count2                 'repeat
	byte	$ec, $ff, $9f, $5d
'-' data4                       incmod  b, #15 wz               'next bank
	byte	$0f, $e0, $0f, $f7
'-' count4      if_nz           jmp     #data0                  'repeat
	byte	$c8, $ff, $9f, $5d
'-' req5                        mov     ptra, #$20              'setup base LUT address to clear
	byte	$20, $f0, $07, $f6
'-' data5                       rep     #5, #80                 'update next 80 longs      
	byte	$50, $0a, $dc, $fc
'-' count5                      cmp     ptra, header wc         'check if LUT address range 
	byte	$e2, $f1, $13, $f2
'-' req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
	byte	$e3, $f1, $93, $32
'-' data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
	byte	$61, $01, $3c, $cc
'-' count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
	byte	$61, $b1, $37, $3c
'-' req7        if_nc           add     $-1, const512           'increment source of LUT write data
	byte	$a5, $29, $00, $31
'-' data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
	byte	$ff, $c0, $03, $f6
'-' count7      _ret_           mov     255, #dolist            'setup list address, return to notify
	byte	$26, $ff, $05, $06
'-' 
'-' ' Mailbox parameter addresses per COG once patched
'-'                             
'-' cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
	byte	$04, $00, $00, $00
'-' cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
	byte	$10, $00, $00, $00
'-' cog2mboxdata                long    2*12+4                  '...
	byte	$1c, $00, $00, $00
'-' cog3mboxdata                long    3*12+4
	byte	$28, $00, $00, $00
'-' cog4mboxdata                long    4*12+4
	byte	$34, $00, $00, $00
'-' cog5mboxdata                long    5*12+4
	byte	$40, $00, $00, $00
'-' cog6mboxdata                long    6*12+4
	byte	$4c, $00, $00, $00
'-' cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
	byte	$58, $00, $00, $00
'-' 
'-' '..................................................................................................
'-' ' Per COG request and state setup and service branching
'-'         
'-' cog0                 
'-'                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
	byte	$20, $f0, $07, $f6
'-'                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
	byte	$18, $f2, $03, $f6
'-'                             mov     id, id0                 'get COG0 state
	byte	$d0, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG0 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$30, $04, $90, $5d
'-'                             mov     addr1, req0             'get mailbox request parameter for COG0
	byte	$00, $b0, $03, $f6
'-'                             mov     hubdata, data0          'get COG0 mailbox data parameter
	byte	$01, $b2, $03, $f6
'-'                             mov     count, count0           'get COG0 mailbox count parameter
	byte	$02, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog1                        
'-'                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
	byte	$2a, $f0, $07, $f6
'-'                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
	byte	$19, $f2, $03, $f6
'-'                             mov     id, id1                 'get COG1 state
	byte	$d1, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG1 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$00, $04, $90, $5d
'-'                             mov     addr1, req1             'get mailbox request parameter for COG1
	byte	$03, $b0, $03, $f6
'-'                             mov     hubdata, data1          'get COG1 mailbox data parameter
	byte	$04, $b2, $03, $f6
'-'                             mov     count, count1           'get COG1 mailbox count parameter
	byte	$05, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog2                         
'-'                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
	byte	$34, $f0, $07, $f6
'-'                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
	byte	$1a, $f2, $03, $f6
'-'                             mov     id, id2                 'get COG2 state
	byte	$d2, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG2 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$d0, $03, $90, $5d
'-'                             mov     addr1, req2             'get mailbox request parameter for COG2
	byte	$06, $b0, $03, $f6
'-'                             mov     hubdata, data2          'get COG2 mailbox data parameter
	byte	$07, $b2, $03, $f6
'-'                             mov     count, count2           'get COG2 mailbox count parameter
	byte	$08, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog3                        
'-'                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
	byte	$3e, $f0, $07, $f6
'-'                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
	byte	$1b, $f2, $03, $f6
'-'                             mov     id, id3                 'get COG3 state
	byte	$d3, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG3 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$a0, $03, $90, $5d
'-'                             mov     addr1, req3             'get mailbox request parameter for COG3
	byte	$09, $b0, $03, $f6
'-'                             mov     hubdata, data3          'get COG3 mailbox data parameter
	byte	$0a, $b2, $03, $f6
'-'                             mov     count, count3           'get COG3 mailbox count parameter
	byte	$0b, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog4                        
'-'                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
	byte	$48, $f0, $07, $f6
'-'                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
	byte	$1c, $f2, $03, $f6
'-'                             mov     id, id4                 'get COG4 state
	byte	$d4, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG4 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$70, $03, $90, $5d
'-'                             mov     addr1, req4             'get mailbox request parameter for COG4
	byte	$0c, $b0, $03, $f6
'-'                             mov     hubdata, data4          'get COG4 mailbox data parameter
	byte	$0d, $b2, $03, $f6
'-'                             mov     count, count4           'get COG4 mailbox count parameter
	byte	$0e, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog5                        
'-'                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
	byte	$52, $f0, $07, $f6
'-'                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
	byte	$1d, $f2, $03, $f6
'-'                             mov     id, id5                 'get COG5 state
	byte	$d5, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG5 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$40, $03, $90, $5d
'-'                             mov     addr1, req5             'get mailbox request parameter for COG5
	byte	$0f, $b0, $03, $f6
'-'                             mov     hubdata, data5          'get COG5 mailbox data parameter
	byte	$10, $b2, $03, $f6
'-'                             mov     count, count5           'get COG5 mailbox count parameter
	byte	$11, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog6                        
'-'                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
	byte	$5c, $f0, $07, $f6
'-'                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
	byte	$1e, $f2, $03, $f6
'-'                             mov     id, id6                 'get COG6 state
	byte	$d6, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG6 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$10, $03, $90, $5d
'-'                             mov     addr1, req6             'get mailbox request parameter for COG6
	byte	$12, $b0, $03, $f6
'-'                             mov     hubdata, data6          'get COG6 mailbox data parameter
	byte	$13, $b2, $03, $f6
'-'                             mov     count, count6           'get COG6 mailbox count parameter
	byte	$14, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' cog7                        
'-'                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
	byte	$66, $f0, $07, $f6
'-'                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
	byte	$1f, $f2, $03, $f6
'-'                             mov     id, id7                 'get COG7 state
	byte	$d7, $c3, $03, $f6
'-'                             getword limit, id, #1           'get COG7 burst limit
	byte	$e1, $47, $3b, $f9
'-'                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
	byte	$08, $d3, $af, $fa
'-'             if_nz           jmp     #restore                'if so restore state and resume
	byte	$e0, $02, $90, $5d
'-'                             mov     addr1, req7             'get mailbox request parameter for COG7
	byte	$15, $b0, $03, $f6
'-'                             mov     hubdata, data7          'get COG7 mailbox data parameter
	byte	$16, $b2, $03, $f6
'-'                             mov     count, count7           'get COG7 mailbox count parameter
	byte	$17, $b4, $03, $f6
'-'                             getbyte request, addr1, #3      'get request + bank info
	byte	$d8, $cb, $fb, $f8
'-'                             altd    request, #0             'lookup jump vector service table 
	byte	$00, $ca, $8f, $f9
'-'                             execf   request-0               'jump to service
	byte	$33, $ca, $63, $fd
'-' 
'-'                             fit     128
'-'                             fit     128
'-' pad                         long    0[128-$]                'align init code to $80
'-' 
'-' '..................................................................................................
'-' 
'-' ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
'-' 
'-' init                        
'-'                             ' get driver scratch long address in hub
'-'                             cogid   hubscratch              'get cogid
	byte	$01, $da, $63, $fd
'-'                             add     hubscratch, #1          'increase by 1 from 1-8
	byte	$01, $da, $07, $f1
'-'                             mul     hubscratch, #4          'multiply by 4 to get 4-32
	byte	$04, $da, $07, $fa
'-'                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
	byte	$f9, $db, $c3, $f2
'-'                     
'-'                             ' read in the additional LUT RAM code
'-'                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
	byte	$f9, $41, $03, $f1
'-'                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
	byte	$29, $9e, $67, $fd
'-'                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
	byte	$a0, $61, $00, $fb
'-' 
'-'                             ' read the startup parameters
'-'                             setq    #8-1                    'read 8 longs from hub
	byte	$28, $0e, $64, $fd
'-'                             rdlong  startupparams, ptra     '.. as the startup parameters 
	byte	$00, $41, $07, $fb
'-' 
'-'                             ' setup some of the config flag dependent state and patch LUTRAM
'-'                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
	byte	$1c, $42, $0f, $f4
'-' 
'-'             if_z            add     expansion, ptrb         'compensate for HUB address
	byte	$f9, $71, $03, $a1
'-'             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
	byte	$01, $00, $00, $5f, $fb, $70, $07, $56
'-'                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
	byte	$1d, $42, $17, $f4
'-'             if_nc           or      clkconfig, registered   'enable this if so
	byte	$aa, $57, $43, $35
'-'             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
	byte	$00, $58, $07, $36
'-' 
'-'                             ' setup data pin modes and data bus pin group in streamer commands
'-'                             and     datapins, #%111000      'compute base pin
	byte	$38, $48, $07, $f5
'-'                             or      datapins, ##(15<<6)     'configure 16 pins total
	byte	$01, $00, $00, $ff, $c0, $49, $47, $f5
'-'                             mov     a, datapins             'get data pin base
	byte	$a4, $df, $03, $f6
'-'                             wrpin   registered, datapins    'prepare data pins for address phase transfer
	byte	$a4, $55, $03, $fc
'-'                             shr     a, #3                   'determine data pin group
	byte	$03, $de, $47, $f0
'-'                             and     a, #7                   'ignore the unwanted bits
	byte	$07, $de, $07, $f5
'-'                             or      a, #8
	byte	$08, $de, $47, $f5
'-'                             setnib  ximm8lut, a, #5         'setup bus group in streamer
	byte	$ef, $2f, $2b, $f8
'-'                             setnib  xrecvlo8, a, #5
	byte	$ef, $31, $2b, $f8
'-'                             setnib  xrecvdata, a, #5
	byte	$ef, $35, $2b, $f8
'-'                             setnib  xsenddata, a, #5
	byte	$ef, $37, $2b, $f8
'-'                             setnib  xsendimm, a, #5
	byte	$ef, $39, $2b, $f8
'-'                             add     a, #1
	byte	$01, $de, $07, $f1
'-'                             setnib  xrecvhi8, a, #5         ' increase port by one
	byte	$ef, $33, $2b, $f8
'-'  
'-'                             ' setup device control pin states
'-'                             setq2   #32-1                   'read 32 longs to LUTRAM
	byte	$29, $3e, $64, $fd
'-'                             rdlong  $000, devicelist        'read bank/pin data for all banks    
	byte	$a5, $01, $00, $fb
'-'                             mov     const512, ##512         'prepare constant
	byte	$01, $00, $00, $ff, $00, $4a, $07, $f6
'-' 
'-'                             mov     ptrb, #16               'point to bank pin config data
	byte	$10, $f2, $07, $f6
'-'                             rep     @pinloop, #16           'iterate through 16 banks
	byte	$10, $14, $dc, $fc
'-'                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
	byte	$e1, $cf, $b7, $fa
'-'                             and     pinconfig, pinmask      'save us from invalid bits in args
	byte	$af, $cf, $03, $f5
'-'             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
	byte	$e7, $53, $e3, $38
'-'             if_nc           wrpin   #0, cspin               'clear smart pin mode
	byte	$a9, $01, $08, $3c
'-'             if_nc           drvh    cspin                   'setup pins for all banks
	byte	$59, $52, $63, $3d
'-'             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
	byte	$e7, $51, $eb, $38
'-'             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
	byte	$50, $50, $63, $3d
'-'             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
	byte	$a8, $57, $03, $3c
'-'             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
	byte	$a8, $03, $18, $3c
'-'             if_nc           drvl    clkpin                  'set clk state low
	byte	$58, $50, $63, $3d
'-' pinloop
'-'                             ' generate minimum CE high time before access
'-'                             qdiv    frequency, ##1000000    'convert from Hz to MHz
	byte	$a1, $07, $00, $ff, $40, $40, $17, $fd
'-'                             getqx   c                       'get P2 clocks per microsecond
	byte	$18, $e2, $63, $fd
'-'                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
	byte	$96, $de, $07, $f6
'-'                             mul     a, c                    'convert microseconds to clocks
	byte	$f1, $df, $03, $fa
'-'                             waitx   a                       'delay
	byte	$1f, $de, $63, $fd
'-'                             call    #hwinit                 'setup HW into QSPI mode
	byte	$e8, $05, $b0, $fd
'-' 
'-'                             ' setup the COG mailboxes and addresses 
'-'                             rep     #2, #8                  'setup loop to patch mailbox addresses
	byte	$08, $04, $dc, $fc
'-'                             alti    $+1, #%111_000          'increase D field
	byte	$38, $70, $a5, $f9
'-'                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
	byte	$a7, $31, $00, $f1
'-' 
'-'                             setq    #24-1
	byte	$28, $2e, $64, $fd
'-'                             wrlong  #0, mbox                'clear out mailboxes ????
	byte	$a7, $01, $68, $fc
'-' 
'-'                             ' setup the polling loop for active COGs 
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             alts    id, #id0                'determine id register of control COG
	byte	$d0, $c3, $97, $f9
'-'                             setd    patchid, #0             'patch into destination address
	byte	$00, $90, $b6, $f9
'-'                             push    ptra                    'save ptra before we lose it
	byte	$2a, $f0, $63, $fd
'-'                             mov     ptra, #10
	byte	$0a, $f0, $07, $f6
'-'                             mul     ptra, id
	byte	$e1, $f1, $03, $fa
'-'                             add     ptra, #$20              'prep ptra for reloadcogs
	byte	$20, $f0, $07, $f1
'-'                             alts    id, #cog0_handler       'add to handler base
	byte	$b0, $c3, $97, $f9
'-'                             sets    ctrlpollinst, #0-0      'patch into jump instruction
	byte	$00, $48, $be, $f9
'-'                             mul     id, #3
	byte	$03, $c2, $07, $fa
'-'                             setd    ctrlpollinst, id
	byte	$e1, $49, $b2, $f9
'-'                             rdlut   id, ptra[9]             'save original value
	byte	$09, $c3, $a7, $fa
'-'                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
	byte	$09, $c1, $37, $fc
'-'                             call    #reloadcogs
	byte	$d8, $01, $b0, $fd
'-'                             wrlut   id, ptra[9]             'restore original value
	byte	$09, $c3, $37, $fc
'-'                             pop     ptra                    'restore original ptra
	byte	$2b, $f0, $63, $fd
'-'                             ' move LUT control vectors into temporary location to avoid clobbering them later
'-'                             setd    d, #addr1
	byte	$d8, $e5, $b7, $f9
'-'                             sets    d, #(ctrl_vect & $1ff)
	byte	$60, $e4, $bf, $f9
'-'                             rep     #2, #8
	byte	$08, $04, $dc, $fc
'-'                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
	byte	$3f, $e4, $a7, $f9
'-'                             rdlut   addr1-0, #$60-0
	byte	$60, $b0, $a7, $fa
'-' 
'-'                             'setup control COG service handling, we need to patch 5 instructions
'-'                             'one existing instruction is moved earlier and four instructions get replaced
'-'                             cogid   id
	byte	$01, $c2, $63, $fd
'-'                             mov     a, #(cog1-cog0)         'get code separation of handlers
	byte	$0c, $de, $07, $f6
'-'                             mul     a, id                   'scale ID by separation
	byte	$e1, $df, $03, $fa
'-'                             add     a, #cog0+4              'add to base for COG0 and offset
	byte	$24, $de, $07, $f1
'-'                             setd    d, a                    'set this as the destination
	byte	$ef, $e5, $b3, $f9
'-'                             add     a, #2                   'increment COG address
	byte	$02, $de, $07, $f1
'-'                             sets    d, a                    'set this as the source
	byte	$ef, $e5, $bb, $f9
'-'                             alti    d, #%111_100             
	byte	$3c, $e4, $a7, $f9
'-'                             mov     0-0, 0-0                'move instruction
	byte	$00, $00, $00, $f6
'-'                             sets    d, #controlpatch        'set source of patched instructions
	byte	$ee, $e4, $bf, $f9
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             add     d, const512             'skip two instructions
	byte	$a5, $e5, $03, $f1
'-'                             add     d, const512
	byte	$a5, $e5, $03, $f1
'-'                             rep     #2, #2                  'patch two instructions
	byte	$02, $04, $dc, $fc
'-'                             alti    d, #%111_111
	byte	$3f, $e4, $a7, $f9
'-'                             mov     0-0, 0-0
	byte	$00, $00, $00, $f6
'-'                             
'-'                             ' setup register values for control vector loop setup after we return
'-'                             mov     header, id              'get cog ID
	byte	$e1, $c5, $03, $f6
'-'                             mul     header, #10             'multiply by size of state memory per COG
	byte	$0a, $c4, $07, $fa
'-'                             add     header, #$20            'add to COG state base address in LUT
	byte	$20, $c4, $07, $f1
'-'                             mov     trailer, header         'determine start/end LUT address
	byte	$e2, $c7, $03, $f6
'-'                             add     trailer, #9             '...for control region
	byte	$09, $c6, $07, $f1
'-'                             or      id, initctrl            'set id field for control COG
	byte	$e0, $c3, $43, $f5
'-'                             altd    id, #id0
	byte	$d0, $c3, $8f, $f9
'-'                             mov     0-0, id                 'setup id field for notification
	byte	$e1, $01, $00, $f6
'-'                             mov     ptrb, ptra              'get startup parameter address
	byte	$f8, $f3, $03, $f6
'-'                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
	byte	$04, $f2, $07, $f1
'-'                             mov     b, #0                   'prepare b for upcoming loop
	byte	$00, $e0, $07, $f6
'-'                 _ret_       push    #notify                 'continue init in mailbox area
	byte	$2a, $14, $66, $0d
'-'  
'-' controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
	byte	$d8, $cb, $7b, $f8
'-'                             and     request, #7
	byte	$07, $ca, $07, $f5
'-'                             add     request, ptra           'add request vector offset
	byte	$f8, $cb, $03, $f1
'-'                             rdlut   request, request        'lookup jump vector service table 
	byte	$e5, $cb, $a3, $fa
'-' 
'-'                             fit     $100                    'ensure all init code fits this space
'-'                             fit     $100                    'ensure all init code fits this space
'-' 
'-'                             long    0[$100-$]               'pad more if required until table ends
	byte	$00[56]
'-' 
'-' '..................................................................................................
'-' ' Error result handling and COG notification of request completion
'-' 
'-' unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
	byte	$04, $04, $4c, $fb
'-' invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
	byte	$03, $02, $4c, $fb
'-' invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
	byte	$02, $06, $4c, $fb
'-' alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
	byte	$01, $08, $4c, $fb
'-' busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
	byte	$05, $ec, $07, $f6
'-' err                         altd    id, #id0                'adjust for the running COG
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
	byte	$09, $00, $04, $f4
'-'                             wrlut   #0, ptra[8]             'cancel any resume state
	byte	$08, $01, $3c, $fc
'-'                             skipf   #%10                    'dont notify with success code 0 below
	byte	$32, $04, $64, $fd
'-'                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
	byte	$bf, $ed, $67, $fc
'-' notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
	byte	$bf, $01, $6c, $fc
'-'                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
	byte	$0b, $c2, $0f, $f4
'-'                             decod   a, id                   'convert COG ID to bitmask
	byte	$e1, $df, $c3, $f9
'-'             if_z            cogatn  a                       'notify COG via ATN
	byte	$3f, $de, $63, $ad
'-' ' Poller re-starts here after a COG is serviced
'-' poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
	byte	$0f, $c2, $0f, $f4
'-'             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
	byte	$e6, $5f, $03, $57
'-'                             bmask   mask, rrcounter         'generate a RR skip mask from the count
	byte	$af, $45, $cb, $f9
'-' ' Main dynamic polling loop repeats until a request arrives
'-' polling_loop                rep     #0-0, #0                'repeat until we get a request for something
	byte	$00, $00, $dc, $fc
'-'                             setq    #24-1                   'read 24 longs
	byte	$28, $2e, $64, $fd
'-'                             rdlong  req0, mbox              'get all mailbox requests and data longs
	byte	$a7, $01, $00, $fb
'-' 
'-' polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
	byte	$b0, $01, $b0, $fb
'-'                             skipf   mask                    ']after all priority COG handlers if present
	byte	$32, $44, $63, $fd
'-'                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']based on the active COGs being polled
	byte	$b6, $25, $b0, $fb
'-'                             tjs     req7, cog7_handler      ']and whether priority or round robin.
	byte	$b7, $2b, $b0, $fb
'-'                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
	byte	$b1, $07, $b0, $fb
'-'                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
	byte	$b2, $0d, $b0, $fb
'-'                             tjs     req3, cog3_handler      ']have changed.
	byte	$b3, $13, $b0, $fb
'-'                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
	byte	$b4, $19, $b0, $fb
'-'                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
	byte	$b5, $1f, $b0, $fb
'-'                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
	byte	$b6, $25, $b0, $fb
'-' pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
	byte	$b7, $2b, $b0, $fb
'-' 
'-' ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
	byte	$b0, $01, $b0, $fb
'-' skipfinst                   skipf   mask                    'instruction template for skipf
	byte	$32, $44, $63, $fd
'-'  
'-' '..................................................................................................
'-' ' List handler                               
'-' 
'-' dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
	byte	$01, $b0, $a7, $fb
'-'                             execf   burstwrite              'otherwise do a burst write to this bank
	byte	$33, $c0, $63, $fd
'-' real_list                   setq    #8-1                    'read 8 longs (largest request size)
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, hubdata          '..to update the request state
	byte	$d9, $b1, $03, $fb
'-'                             tjns    addr1, #invalidlist     'error if request list item not valid
	byte	$d7, $b1, $bf, $fb
'-'                             altd    id, #id0                'get COG state
	byte	$d0, $c3, $8f, $f9
'-'                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
	byte	$09, $00, $3c, $f4
'-'                             bith    id, #LIST_BIT           'retain fact that we are in a list
	byte	$09, $c2, $27, $f4
'-'             if_z            jmp     #unsupported            'no list recursion is allowed!
	byte	$44, $ff, $9f, $ad
'-'                             getbyte request, addr1, #3      'get upper byte of this request
	byte	$d8, $cb, $fb, $f8
'-' service_request             altd    request, #0             'get request address in COG RAM
	byte	$00, $ca, $8f, $f9
'-'                             execf   0-0                     'process the request 
	byte	$33, $00, $60, $fd
'-' 
'-' '..................................................................................................
'-' ' Restoring per COG state and resuming where we left off
'-' 
'-' restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
	byte	$00, $b1, $a7, $fa
'-'                             rdlut   hubdata, ptra[1]
	byte	$01, $b3, $a7, $fa
'-'                             rdlut   count, ptra[2]
	byte	$02, $b5, $a7, $fa
'-'                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
	byte	$03, $b7, $b7, $fa
'-'                             getbyte request, addr1, #3
	byte	$d8, $cb, $fb, $f8
'-'             if_nc           execf   resume                  'if not extended then resume immediately
	byte	$33, $d2, $63, $3d
'-'                             rdlut   total, ptra[4]          'we need to read the extended parameters
	byte	$04, $b9, $a7, $fa
'-'                             rdlut   offset1, ptra[5]
	byte	$05, $bb, $a7, $fa
'-'                             rdlut   offset2, ptra[6]
	byte	$06, $bd, $a7, $fa
'-'                             rdlut   link, ptra[7]
	byte	$07, $bf, $a7, $fa
'-'                             rdlut   orighubsize, ptra[9]
	byte	$09, $d5, $a7, $fa
'-'                             execf   resume                  'then resume what we were doing last time
	byte	$33, $d2, $63, $fd
'-'                    
'-' '..................................................................................................
'-' ' Re-configuration of QoS settings and custom polling loop sequence generator
'-' 
'-' reconfig                    push    #notify                 'setup return addr, then reload 
	byte	$2a, $14, $66, $fd
'-' reloadcogs                  setq    #8-1                    'reload all per COG QoS params
	byte	$28, $0e, $64, $fd
'-'                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
	byte	$a6, $b1, $03, $fb
'-'                             setd    a, #id0
	byte	$d0, $df, $b7, $f9
'-'                             sets    a, #addr1
	byte	$d8, $df, $bf, $f9
'-'                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
	byte	$fe, $ff, $ff, $ff, $28, $00, $66, $fd
'-'                             rep     #2, #8                  'repeat for 8 COGs
	byte	$08, $04, $dc, $fc
'-'                             alti    a, #%111_111 
	byte	$3f, $de, $a7, $f9
'-'                             muxq    0-0, 0-0
	byte	$00, $00, $f0, $f9
'-' patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
	byte	$09, $01, $a4, $fa
'-'                             cogid   c
	byte	$01, $e2, $63, $fd
'-'                             decod   excludedcogs, c         'exclude driver cog initially
	byte	$f1, $41, $c3, $f9
'-'                             mov     a, #$8                  'a iterates through prio levels 8=lowest
	byte	$08, $de, $07, $f6
'-'                             neg     pa, #1                  'start with all ones
	byte	$01, $ec, $67, $f6
'-' fillprio                    mov     c, #7                   'c iterates through cogs
	byte	$07, $e2, $07, $f6
'-' prioloop                    alts    c, #id0
	byte	$d0, $e3, $97, $f9
'-'                             mov     b, 0-0
	byte	$00, $e0, $03, $f6
'-'                             getword d, b, #1                'get burst field
	byte	$f0, $e5, $3b, $f9
'-'                             test    d wz                    'if burst=0 
	byte	$f2, $e5, $cb, $f7
'-'             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
	byte	$f1, $41, $23, $a4
'-'             if_z            jmp     #excluded               
	byte	$0c, $00, $90, $ad
'-'                             getnib  d, b, #3                'get RR/PRI flag & priority
	byte	$f0, $e5, $5b, $f8
'-'                             cmp     d, a wz                 'compare against current priority level
	byte	$ef, $e5, $0b, $f2
'-'             if_z            rolnib  pa, c, #0               'if matches include COG at this level
	byte	$f1, $ed, $83, $a8
'-' excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
	byte	$f6, $e3, $7f, $fb
'-'                             incmod  a, #15 wz               'next level
	byte	$0f, $de, $0f, $f7
'-'             if_nz           jmp     #fillprio 
	byte	$cc, $ff, $9f, $5d
'-' 
'-' 'determine priority cogs and build instructions for the polling sequence
'-'                             mov     pb, #0                  'clear out set of priority COGs
	byte	$00, $ee, $07, $f6
'-'                             mov     a, #3                   'start with no COGs being polled + 3 instructions
	byte	$03, $de, $07, $f6
'-'                             setd    d, #polling_code        'initialize COGRAM write position
	byte	$14, $e5, $b7, $f9
'-' 
'-'                             rep     @endprioloop, #8        'test all 8 priority slots
	byte	$08, $18, $dc, $fc
'-'                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
	byte	$03, $ec, $17, $f4
'-'                             getnib  c, pa, #0               'get cogid ID at this priority level
	byte	$f6, $e3, $43, $f8
'-'             if_nc           testb   pb, c wz                'check if already exists as priority COG
	byte	$f1, $ef, $0b, $34
'-'             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
	byte	$f1, $ef, $23, $14
'-'             if_nc_and_nz    add     a, #1                   'add another COG to poll 
	byte	$01, $de, $07, $11
'-'             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
	byte	$b0, $e3, $97, $19
'-'             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $19
'-'             if_nc_and_nz    mul     c, #3
	byte	$03, $e2, $07, $1a
'-'             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
	byte	$f1, $47, $b2, $19
'-'             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $19
'-'             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $16
'-'                             ror     pa, #4                  'advance to next priority
	byte	$04, $ec, $07, $f0
'-' endprioloop
'-'                             xor     pb, #$ff                'invert to find all the non-priority COGs
	byte	$ff, $ee, $67, $f5
'-'                             andn    pb, excludedcogs        'and remove any other excluded COGs
	byte	$a0, $ef, $23, $f5
'-'                             ones    rrlimit, pb wz          'count the number of RR COGs
	byte	$f7, $cd, $ab, $f7
'-'                             add     a, rrlimit              'account for this number of RR COGs to poll
	byte	$e6, $df, $03, $f1
'-'                             sub     rrlimit, #1             'setup last RR count value for incmod
	byte	$01, $cc, $87, $f1
'-'                             alti    d, #%111_000            'generate the control polling instruction
	byte	$38, $e4, $a7, $f9
'-'                             mov     0-0, ctrlpollinst       'write the instruction
	byte	$24, $01, $00, $f6
'-'             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
	byte	$38, $e4, $a7, $59
'-'             if_nz           mov     0-0, skipfinst          'add the skipf instruction
	byte	$25, $01, $00, $56
'-'             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
	byte	$02, $de, $07, $51
'-'                             setd    polling_loop, a         'save it as the repeat count
	byte	$ef, $23, $b2, $f9
'-'             if_z            ret                             'we are done now, if no round robin COGs
	byte	$2d, $00, $64, $ad
'-' 
'-' ' populate the round robin COG polling instructions
'-'                             mov     rrcounter, #2           'fill the RR poll instruction list twice
	byte	$02, $5e, $07, $f6
'-' rrloop                      mov     b, pb                   'get the set of RR COGs
	byte	$f7, $e1, $03, $f6
'-'                             mov     c, #0                   'start at COG ID = 0
	byte	$00, $e2, $07, $f6
'-'                             mov     a, #0                   'req mailbox COGRAM address for COG 0
	byte	$00, $de, $07, $f6
'-' nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
	byte	$01, $e0, $5f, $f0
'-'             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
	byte	$ef, $47, $b2, $c9
'-'             if_c            alts    c, #cog0_handler        'determine jump address
	byte	$b0, $e3, $97, $c9
'-'             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
	byte	$00, $46, $be, $c9
'-'             if_c            alti    d, #%111_000            'generate new COG RAM write address
	byte	$38, $e4, $a7, $c9
'-'             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
	byte	$23, $01, $00, $c6
'-'                             add     c, #1                   'increment the COG ID
	byte	$01, $e2, $07, $f1
'-'                             add     a, #3                   'increase the request address
	byte	$03, $de, $07, $f1
'-'             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
	byte	$dc, $ff, $9f, $5d
'-'             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
	byte	$f3, $5f, $6f, $0b
'-' '..................................................................................................
'-' ' Code to get/set driver settings per bank or to dump COG/LUT state
'-' 
'-' set_latency                                                 '            (a) set latency
'-' get_latency                                                 '            (b) get latency
'-' set_burst                                                   '            (c) set burst size of bank
'-' get_burst                                                   '            (d) get burst size of bank
'-'                                                             '            (e) dump state
'-'                             getnib  b, addr1, #6            ' a b c d    get bank address
	byte	$d8, $e1, $73, $f8
'-' dump_state                  setq    #511                    ' | | | | e  prepare burst write
	byte	$28, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                                                             ' | | | | e  account for following AUGS
'-'                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
	byte	$04, $00, $00, $ff, $00, $b2, $07, $f1
'-'                             setq2   #511                    ' | | | | e  prepare burst write
	byte	$29, $fe, $67, $fd
'-'                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
	byte	$d9, $01, $60, $fc
'-'                             add     b, #16                  ' a b | | |  point to latency params
	byte	$10, $e0, $07, $f1
'-'                             rdlut   a, b                    ' a b c d |  read data for bank
	byte	$f0, $df, $a3, $fa
'-'                             setbyte a, hubdata, #3          ' a | | | |  patch latency
	byte	$d9, $df, $db, $f8
'-'                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
	byte	$d9, $df, $03, $f6
'-'                             wrlut   a, b                    ' a | c | |  if setting, save bank data
	byte	$f0, $df, $33, $fc
'-'                             getbyte a, a, #3                ' | b | | |  extract latency field only
	byte	$ef, $df, $fb, $f8
'-'                             wrlong  a, ptrb                 ' | b | d |  write result          
	byte	$80, $df, $67, $fc
'-'                             jmp     #notify                 ' a b c d e  return success
	byte	$dc, $fd, $9f, $fd
'-' 
'-' '..................................................................................................
'-' ' Misc EXECF code
'-' 
'-' start_read_exec             execf   newburstr
	byte	$33, $72, $63, $fd
'-' start_write_exec            execf   resumewrites
	byte	$33, $7c, $63, $fd
'-' continue_read_exec          execf   lockedreads
	byte	$33, $78, $63, $fd
'-' continue_write_exec         execf   lockedwrites
	byte	$33, $7a, $63, $fd
'-' 
'-' '..................................................................................................
'-' ' Variables
'-' 
'-' ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
	byte	$08, $00, $cf, $20
'-' xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
	byte	$01, $00, $c6, $e0
'-' xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
	byte	$00, $00, $c0, $f0
'-' xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
	byte	$00, $00, $c0, $b0
'-' xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
	byte	$02, $00, $c0, $70
'-' 
'-' xfreq1          long    $80000000
	byte	$00, $00, $00, $80
'-' xfreq2          long    $40000000
	byte	$00, $00, $00, $40
'-' delay           long    3
	byte	$03, $00, $00, $00
'-' 
'-' lutcodeaddr                 
'-' startupparams
'-' excludedcogs                                    'careful: shared register use!
'-' frequency       long    lut_code - driver_start 'determine offset of LUT code from base
	byte	$cc, $07, $00, $00
'-' flags           long    0
	byte	$00, $00, $00, $00
'-' mask                                            'careful: shared register use!
'-' resetmaskA      long    0
	byte	$00, $00, $00, $00
'-' limit                                           'careful: shared register use!
'-' resetmaskB      long    0
	byte	$00, $00, $00, $00
'-' datapins        long    0
	byte	$00, $00, $00, $00
'-' const512                                        'careful: shared register use!
'-' devicelist      long    0
	byte	$00, $00, $00, $00
'-' coglist         long    0
	byte	$00, $00, $00, $00
'-' mbox            long    0 
	byte	$00, $00, $00, $00
'-' 
'-' clkpin                                          'shared with code patched during init
'-' clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
	byte	$a8, $03, $18, $fc
'-' cspin                                           'shared with code patched during init
'-' speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
	byte	$1d, $3a, $63, $fd
'-' registered      long    %100_000_000_00_00000_0 'config pin for clocked input
	byte	$00, $00, $01, $00
'-' clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
	byte	$4a, $00, $00, $00
'-' clkdelay        long    1
	byte	$01, $00, $00, $00
'-' regdatabus      long    0
	byte	$00, $00, $00, $00
'-' 
'-' deviceaddr      long    $10
	byte	$10, $00, $00, $00
'-' rrcounter
'-' pinmask         long    $ff3f7f7f
	byte	$7f, $7f, $3f, $ff
'-' 
'-' ' jump addresses for the per COG handlers
'-' cog0_handler    long    cog0
	byte	$20, $00, $00, $00
'-' cog1_handler    long    cog1
	byte	$2c, $00, $00, $00
'-' cog2_handler    long    cog2
	byte	$38, $00, $00, $00
'-' cog3_handler    long    cog3
	byte	$44, $00, $00, $00
'-' cog4_handler    long    cog4
	byte	$50, $00, $00, $00
'-' cog5_handler    long    cog5
	byte	$5c, $00, $00, $00
'-' cog6_handler    long    cog6
	byte	$68, $00, $00, $00
'-' cog7_handler    long    cog7
	byte	$74, $00, $00, $00
'-' expansion       long    gfxexpansion - driver_start
	byte	$0c, $0f, $00, $00
'-' 
'-' ' EXECF sequences
'-' newburstr       long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-' lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
	byte	$48, $9b, $ef, $00
'-' restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
	byte	$41, $f3, $05, $74
'-' lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
	byte	$80, $22, $3f, $00
'-' lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
	byte	$4b, $f3, $e0, $0f
'-' resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
	byte	$4b, $03, $e0, $0f
'-' resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
	byte	$76, $02, $8a, $84
'-' 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
'-' 
'-' 
'-' ' SKIPF sequences
'-' skiptable
'-'                 long    %11000011000001111110  ' read modify write byte
	byte	$7e, $30, $0c, $00
'-'                 long    %110011011100001110    ' read modify write word
	byte	$0e, $37, $03, $00
'-'                 long    0                      ' read modify write long
	byte	$00, $00, $00, $00
'-'                 long    %1111110               ' single byte read
	byte	$7e, $00, $00, $00
'-'                 long    %11110001110           ' single word read
	byte	$8e, $07, $00, $00
'-' pattern2        long    0
	byte	$00, $00, $00, $00
'-' pattern3        long    0
	byte	$00, $00, $00, $00
'-' singlelong      long    %1001110111  
	byte	$77, $02, $00, $00
'-' skipcase_a      long    %01101111100000000001000011111101
	byte	$fd, $10, $80, $6f
'-' skipcase_b      long    %00000000010100000001100000010000
	byte	$10, $18, $50, $00
'-' skipcase_c      long    %00000000011000000011111000010001
	byte	$11, $3e, $60, $00
'-' skipseq_write   long    %00000000000000000000111100000010
	byte	$02, $0f, $00, $00
'-' 
'-' ' LUT RAM address values
'-' complete_rw     long    complete_rw_lut
	byte	$ff, $02, $00, $00
'-' continue_read   long    continue_read_lut
	byte	$dd, $02, $00, $00
'-' continue_write  long    continue_write_lut
	byte	$db, $02, $00, $00
'-' noread          long    noread_lut
	byte	$f6, $02, $00, $00
'-' 
'-' id0             long    0
	byte	$00, $00, $00, $00
'-' id1             long    1
	byte	$01, $00, $00, $00
'-' id2             long    2
	byte	$02, $00, $00, $00
'-' id3             long    3
	byte	$03, $00, $00, $00
'-' id4             long    4
	byte	$04, $00, $00, $00
'-' id5             long    5
	byte	$05, $00, $00, $00
'-' id6             long    6
	byte	$06, $00, $00, $00
'-' id7             long    7
	byte	$07, $00, $00, $00
'-' 
'-' 'These next 10 request registers below are also temporarily reused during init 
'-' 'and COG updates and need to follow immediately after id0-id7
'-' addr1           long    0
	byte	$00, $00, $00, $00
'-' hubdata         long    0
	byte	$00, $00, $00, $00
'-' count           long    0
	byte	$00, $00, $00, $00
'-' addr2           long    0
	byte	$00, $00, $00, $00
'-' total           long    0
	byte	$00, $00, $00, $00
'-' offset1         long    0
	byte	$00, $00, $00, $00
'-' offset2         long    0
	byte	$00, $00, $00, $00
'-' link            long    0
	byte	$00, $00, $00, $00
'-' 
'-' burstwrite                                      'note shared register use during init
'-' initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
	byte	$00, $10, $f0, $fe
'-' id              long    0
	byte	$00, $00, $00, $00
'-' 
'-' header          long    0
	byte	$00, $00, $00, $00
'-' trailer         long    0
	byte	$00, $00, $00, $00
'-' cmdaddr         long    0
	byte	$00, $00, $00, $00
'-' request         long    0
	byte	$00, $00, $00, $00
'-' rrlimit         long    0
	byte	$00, $00, $00, $00
'-' pinconfig       long    0
	byte	$00, $00, $00, $00
'-' clks            long    0
	byte	$00, $00, $00, $00
'-' resume          long    0
	byte	$00, $00, $00, $00
'-' orighubsize     long    0
	byte	$00, $00, $00, $00
'-' wrclks          long    0
	byte	$00, $00, $00, $00
'-' 
'-' pattern         long    0
	byte	$00, $00, $00, $00
'-' hubscratch      long    0
	byte	$00, $00, $00, $00
'-' val4k           long    4096
	byte	$00, $10, $00, $00
'-' 
'-' ' temporary general purpose regs
'-' a               long    0
	byte	$00, $00, $00, $00
'-' b               long    0
	byte	$00, $00, $00, $00
'-' c               long    0
	byte	$00, $00, $00, $00
'-' d               long    0
	byte	$00, $00, $00, $00
'-' 
'-'                 fit     502
'-'                 fit     502
'-' 
'-' '..................................................................................................
'-' 
'-'             orgh
'-' 
'-' lut_code
'-' 'HW init code up to 80 longs
'-' 
'-' '..................................................................................................
'-' ' Memory layout for LUT RAM once operational:
'-' '
'-' '  LUT RAM address      Usage
'-' '  ---------------      ----
'-' '    $200-$20F          Bank parameters: burst + type + size per bank (16)
'-' '    $210-$21F          Pin parameters : latency + control pins per bank (16)
'-' '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
'-' '    $270-$3FF          Main PSRAM access code in LUTRAM 
'-' '
'-' ' Also during driver COG startup:
'-' ' $230-$24F is used for HW init setup
'-' ' $250-$26F is used as temporary vector storage 
'-' '..................................................................................................
'-' 
'-'                 org $230    
'-' 
'-' ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
'-' hwinit                      setxfrq xfreq2
	byte	$1d, $3c, $63, $fd
'-'                             pollxfi
	byte	$24, $16, $60, $fd
'-'                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
	byte	$ff, $aa, $2a, $ff, $ff, $ed, $07, $f6
'-'                             call    #sendqspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$0FF00FF0         '$66 - reset enable
	byte	$07, $f8, $07, $ff, $f0, $ed, $07, $f6
'-'                             call    #sendspi
	byte	$28, $00, $b0, $fd
'-'                             mov     pa, ##$F00FF00F         '$99 - reset
	byte	$f8, $07, $78, $ff, $0f, $ec, $07, $f6
'-'                             call    #sendspi
	byte	$1c, $00, $b0, $fd
'-'                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
	byte	$7f, $78, $78, $ff, $00, $ed, $07, $f6
'-'                             call    #sendspi 
	byte	$10, $00, $b0, $fd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-' 
'-' sendqspi                    mov     clks,#4
	byte	$04, $d0, $07, $f6
'-'                             skipf   #%110
	byte	$32, $0c, $64, $fd
'-'                             mov     pb, xsendimm
	byte	$9c, $ef, $03, $f6
'-' 
'-' sendspi                     mov     clks, #16
	byte	$10, $d0, $07, $f6
'-'                             mov     pb, ximm8lut
	byte	$97, $ef, $03, $f6
'-'                             drvl    cspin                   'active low chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   pb, pa                  'send 32 bit immediate data
	byte	$f6, $ef, $a3, $fc
'-'                             wypin   clks, clkpin            'start memory clock output 
	byte	$a8, $d1, $23, $fc
'-'                             waitxfi                         'wait for the completion
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                'float data bus
	byte	$50, $48, $63, $fd
'-'                             drvh    cspin                   'raise chip select
	byte	$59, $52, $63, $fd
'-'             _ret_           waitx   #200                    'delay before return to ensure CS delay
	byte	$1f, $90, $65, $0d
'-' 
'-'                 long    0[$270-32-$]
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'     
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-'                 fit     $270-32  ' keep room for 32 vector longs
'-' ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
'-' rw_vect ' PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    (%0111010000000000111000 << 10) + w_single
	byte	$41, $e3, $00, $74
'-'                 long    (%0111010000000000100100 << 10) + w_single
	byte	$41, $93, $00, $74
'-'                 long    (%0111010000000000011100 << 10) + w_single
	byte	$41, $73, $00, $74
'-'                 long    (%1111111000000000000110 << 10) + w_burst
	byte	$47, $1b, $00, $fe
'-' ro_vect ' R/O PSRAM jump vectors
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1110111001011010010100 << 10) + r_single
	byte	$71, $52, $5a, $ee
'-'                 long    (%1010111001011010010000 << 10) + r_single
	byte	$71, $42, $5a, $ae
'-'                 long    (%0010001010000000011110 << 10) + r_burst
	byte	$70, $7a, $80, $22
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-' ctrl_vect ' Control jump vectors
'-'                 long    (%0000000000111001111110 << 10) + get_latency
	byte	$84, $f9, $39, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000001111011111110 << 10) + get_burst
	byte	$84, $f9, $7b, $00
'-'                 long    (%0000000001111111000000 << 10) + dump_state
	byte	$85, $01, $7f, $00
'-'                 long    (%0000000011010001111110 << 10) + set_latency
	byte	$84, $f9, $d1, $00
'-'                 long    unsupported
	byte	$00, $01, $00, $00
'-'                 long    (%0000000011001011111110 << 10) + set_burst
	byte	$84, $f9, $cb, $00
'-'                 long    reconfig 
	byte	$3e, $01, $00, $00
'-' no_vect ' Invalid bank jump vectors
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-'                 long    invalidbank
	byte	$01, $01, $00, $00
'-' 
'-'                 fit     $270
'-'                 fit     $270
'-' '..................................................................................................
'-' ' PSRAM READS
'-'                                                             ' a b c d e f
'-'                                                             ' B W L B R L  (a) byte read
'-'                                                             ' Y O O U E O  (b) word read
'-'                                                             ' T R N R S C  (c) long read
'-'                                                             ' E D G S U K  (d) new burst read
'-'                                                             '       T M E  (e) resumed sub-burst
'-'                                                             '         E D  (f) locked sub-burst
'-' 
'-' 
'-' r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
	byte	$da, $d5, $03, $f6
'-' r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
	byte	$da, $b5, $cb, $f7
'-'                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
	byte	$36, $d9, $07, $f6
'-'             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
	byte	$20, $d9, $27, $a5
'-'                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
	byte	$02, $34, $27, $f9
'-'                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
	byte	$80, $b4, $97, $fb
'-' r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    ' a b c d e    get bank limit/mask
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 ' | | | d e    build mask for addr
	byte	$f0, $45, $cb, $f9
'-'                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
	byte	$f0, $3f, $eb, $f8
'-' p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
	byte	$11, $e0, $47, $f0
'-'                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
	byte	$f0, $47, $23, $f3
'-'                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
	byte	$05, $3e, $57, $f0
'-'             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
	byte	$10, $5a, $67, $04
'-'                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
	byte	$10, $5a, $67, $f4
'-'                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
	byte	$f9, $3b, $83, $fc
'-' r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
	byte	$d9, $3b, $83, $fc
'-'                             mov     c, count                ' | | | d e f  get count of bytes left to read
	byte	$da, $e3, $03, $f6
'-'                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
	byte	$20, $d0, $17, $f6
'-'             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
	byte	$cd, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
	byte	$cc, $d3, $03, $36
'-'                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
	byte	$32, $20, $64, $fd
'-'                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
	byte	$54, $00, $90, $fd
'-' 
'-'                             ' fall through to read bursts
'-'                         
'-' burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
	byte	$cd, $d3, $03, $c6
'-'                             mov     pattern, #0             'enable all by default
	byte	$00, $d8, $07, $f6
'-'                             testb   addr1, #1 wc            'test if start addr starts in second word
	byte	$01, $b0, $17, $f4
'-'                             bitnc   pattern, #1             'enable delay cycle if so
	byte	$01, $d8, $67, $f4
'-'                             wrc     clks                    'and account for its clock cycle
	byte	$6c, $d0, $63, $fd
'-'                             testb   addr1, #0 wc            'test if start addr starts on odd byte
	byte	$00, $b0, $17, $f4
'-'                             bitnc   pattern, #2             'add hi 8 transfer initially
	byte	$02, $d8, $67, $f4
'-'                             mov     d, c                    'get count of bytes to be read into HUB
	byte	$f1, $e5, $03, $f6
'-'             if_c            sub     d, #1                   'minus 1 if start addr was odd
	byte	$01, $e4, $87, $c1
'-'                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
	byte	$01, $e4, $4f, $f0
'-'                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
	byte	$f2, $d1, $23, $f1
'-'                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
	byte	$f2, $35, $23, $f9
'-'                             bitz    pattern, #3             'adjust the pattern to include this
	byte	$03, $d8, $87, $f4
'-'                             testb   c, #0 xorc              'test for end address
	byte	$00, $e2, $d7, $f4
'-'                             bitnc   pattern, #4             'include low 8 bit transfer if required
	byte	$04, $d8, $67, $f4
'-'                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
	byte	$0e, $d0, $27, $f1
'-'                             add     clks, clks
	byte	$e8, $d1, $03, $f1
'-' readcommon
'-'                             mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$EB, #3       'add quad read command
	byte	$eb, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-' 
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable data bus
	byte	$58, $48, $63, $fd
'-'             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
'-'                             xinit   ximm8lut, cmdaddr       'stream out command+address
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   clks, clkpin            'start clock output
	byte	$a8, $d1, $23, $fc
'-'                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
	byte	$00, $00, $cc, $fc
'-'                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
	byte	$00, $0c, $cc, $fc
'-'                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
'-'                             fltl    datapins                'safe to float the data bus, address has been sent by now
	byte	$50, $48, $63, $fd
'-'                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
	byte	$a4, $5b, $03, $fc
'-'                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
	byte	$28, $3a, $63, $fd
'-'                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
	byte	$00, $3e, $c7, $fc
'-'                             xcont   #6, #0                  'fixed delay offset to expand delay range
	byte	$00, $0c, $cc, $fc
'-'                             skipf   pattern                 'choose path below
	byte	$32, $d8, $63, $fd
'-'                                                             'Bursts Bytes Words Longs  RMW FromWrites
'-'                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
	byte	$28, $3c, $63, $fd
'-'                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
	byte	$00, $02, $cc, $fc
'-'                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
	byte	$00, $32, $c7, $fc
'-'                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
	byte	$00, $34, $c7, $fc
'-'                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
	byte	$00, $30, $c7, $fc
'-'                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
	byte	$24, $36, $60, $fd
'-'                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
	byte	$a4, $55, $03, $fc
'-'             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
	byte	$59, $52, $63, $0d
'-'                             drvh    cspin                   '         b     c           e       deassert chip select and continue
	byte	$59, $52, $63, $fd
'-'                             getnib  d, request, #1          'get request code value
	byte	$e5, $e5, $4b, $f8
'-'             if_nz           sub     d, #3                   'offset for table if RMW
	byte	$03, $e4, $87, $51
'-'                             altd    d, #skiptable-5         'patch next instruction
	byte	$bb, $e5, $8f, $f9
'-'                             skipf   0-0                     'generate skip sequence
	byte	$32, $00, $60, $fd
'-'                                                             ' B   W  RMWB RMWW RMLL 
'-'                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
	byte	$80, $df, $07, $fb
'-'                             setq    count                   ' |   |   |    |    e   setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
	byte	$d9, $df, $f3, $f9
'-'                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
	byte	$40, $00, $90, $fd
'-'                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
	byte	$01, $b0, $17, $f4
'-'             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
	byte	$ef, $ef, $3b, $c9
'-'             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
	byte	$ef, $ef, $33, $39
'-'                             mov     d, addr1                ' a   |   c    d
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3                   ' a   |   c    |        get LSBs of address
	byte	$03, $e4, $07, $f5
'-'                             altgb   d, #a                   ' a   |   c    |        index into long
	byte	$ef, $e5, $6f, $f9
'-'                             getbyte pb                      ' a   |   c    |        and extract the byte
	byte	$00, $ee, $e3, $f8
'-'                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
	byte	$80, $ef, $67, $fc
'-'                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
	byte	$c0, $00, $b0, $fd
'-'                             ret                             ' a   b   |    |        then return
	byte	$2d, $00, $64, $fd
'-'                             setq    count                   '         c    d        setup bit mux mask
	byte	$28, $b4, $63, $fd
'-'                             muxq    pb, hubdata             '         c    d        apply bit mux
	byte	$d9, $ef, $f3, $f9
'-'                             altsb   d, #a                   '         c    |
	byte	$ef, $e5, $67, $f9
'-'                             setbyte 0-0, pb, #0             '         c    |
	byte	$f7, $01, $c0, $f8
'-'             if_c            setword a, pb, #1               '         |    d
	byte	$f7, $df, $2b, $c9
'-'             if_nc           setword a, pb, #0               '         |    d
	byte	$f7, $df, $23, $39
'-' writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
	byte	$37, $8a, $07, $f6
'-'                             mov     hubdata, a              'write a to PSRAM
	byte	$ef, $b3, $03, $f6
'-'                             mov     wrclks, #20             '20 clocks to write a long
	byte	$14, $d6, $07, $f6
'-'                             mov     resume, complete_rw     'we'll complete the operation after this
	byte	$cc, $d3, $03, $f6
'-'                             jmp     #writecommon
	byte	$10, $03, $90, $fd
'-' 
'-' '..................................................................................................
'-' ' Burst continuation testing
'-' 
'-' continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
	byte	$32, $96, $63, $fd
'-'                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
	byte	$be, $d3, $03, $f6
'-' continue_read_lut          
'-'                             mov     resume, resumereads     ' | setup resume address to execf
	byte	$bf, $d3, $03, $f6
'-'                             add     hubdata, c              ' a compute the next hub addr to use
	byte	$f1, $b3, $03, $f1
'-'                             sub     count, c                ' a account for the bytes already sent
	byte	$f1, $b5, $83, $f1
'-'                             add     c, addr1                ' a compute next external mem address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    ' a configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
	byte	$14, $00, $90, $5d
'-'                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
	byte	$e1, $47, $3b, $f9
'-'                             fle     limit, b                ' | also re-apply per bank limit
	byte	$f0, $47, $23, $f3
'-'             _ret_           push    #continue_read_exec     ' | 
	byte	$2a, $2a, $67, $0d
'-'             if_nz           jmp     #yield                  ' a
	byte	$04, $00, $90, $5d
'-'             _ret_           push    #continue_write_exec    ' a
	byte	$2a, $2c, $67, $0d
'-' 
'-' yield                       wrlut   total, ptra[4]          'save context for next time
	byte	$04, $b9, $37, $fc
'-'                             wrlut   offset1, ptra[5]        'save context for next time
	byte	$05, $bb, $37, $fc
'-'                             wrlut   offset2, ptra[6]        'save context for next time
	byte	$06, $bd, $37, $fc
'-'                             wrlut   link, ptra[7]           'save context for next time
	byte	$07, $bf, $37, $fc
'-' yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
	byte	$00, $b1, $37, $fc
'-'                             wrlut   hubdata, ptra[1]        'save context for next time
	byte	$01, $b3, $37, $fc
'-'                             wrlut   count, ptra[2]          'save context for next time
	byte	$02, $b5, $37, $fc
'-'                             wrlut   addr2, ptra[3]          'save context for next time
	byte	$03, $b7, $37, $fc
'-'                             wrlut   resume, ptra[8]         'save next resume address
	byte	$08, $d3, $37, $fc
'-'                             wrlut   orighubsize, ptra[9]    'save original hub size
	byte	$09, $d5, $37, $fc
'-'             _ret_           push    #poller
	byte	$2a, $1c, $66, $0d
'-' 
'-' 
'-' notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
	byte	$32, $be, $65, $fd
'-' nowrite_lut                                                 '  (a) new skip sequence 
'-' noread_lut                  skipf   #0                      ' | cancel skipping
	byte	$32, $00, $64, $fd
'-'                             wrlut   #0, ptra[8]             ' | clear resume
	byte	$08, $01, $3c, $fc
'-'                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_nz           jmp     #notify                 ' | if not a request list then we are done
	byte	$40, $f8, $9f, $5d
'-'                             testb   addr2, #31 wz           ' | check if extended list item
	byte	$1f, $b6, $0f, $f4
'-' donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
	byte	$df, $b7, $03, $a6
'-' checklist                   call    #checknext              ' | handle running from list
	byte	$1c, $00, $b0, $fd
'-'                             ret                             ' | continue processing
	byte	$2d, $00, $64, $fd
'-'             _ret_           push    noread                  'continue end of transfer
	byte	$2a, $9e, $63, $0d
'-' '..................................................................................................
'-' ' Completion of requests
'-' 
'-' complete_rw_lut             
'-'                             testb   id, #LIST_BIT wz        'test for running from a request list   
	byte	$09, $c2, $0f, $f4
'-'             if_z            skipf   #%10                    'if a request list then skip notification
	byte	$32, $04, $64, $ad
'-'                             wrlut   #0, ptra[8]             ' a   default is not to resume
	byte	$08, $01, $3c, $fc
'-'             _ret_           push    #notify                 ' |   if not a request list then we are done
	byte	$2a, $14, $66, $0d
'-'                             tjs     addr2, #extendedreq     '     test for special extended request  
	byte	$0d, $b6, $b7, $fb
'-' checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
	byte	$07, $b6, $97, $fb
'-'                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
	byte	$bf, $ed, $07, $fb
'-'                             tjns    pa, #listcomplete       'exit if it has
	byte	$05, $ec, $bf, $fb
'-'                             testb   id, #LOCKED_BIT wz
	byte	$0a, $c2, $0f, $f4
'-'             if_z            mov     hubdata, addr2
	byte	$db, $b3, $03, $a6
'-'             if_z            skipf   #%110001
	byte	$32, $62, $64, $ad
'-'             if_nz           skipf   #%1000                  'do not notify if list is continuing
	byte	$32, $10, $64, $5d
'-'                             wrlong  addr2, ptrb             ' a  write back next list address
	byte	$80, $b7, $67, $fc
'-' listcomplete                altd    id, #id0                ' a  compute COG's state address
	byte	$d0, $c3, $8f, $f9
'-'                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
	byte	$09, $00, $04, $f4
'-'             _ret_           push    #notify                 ' |  we are done with the list
	byte	$2a, $14, $66, $0d
'-'             _ret_           push    #poller                 ' a  we are still continuing the list
	byte	$2a, $1c, $66, $0d
'-'             _ret_           push    #real_list              ' a  we are still continuing the list
	byte	$2a, $50, $66, $0d
'-' extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
	byte	$e3, $b5, $97, $fb
'-'                             getnib  a, addr2, #7            'check the request type
	byte	$db, $df, $7b, $f8
'-'                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
	byte	$0f, $de, $0f, $f2
'-'                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
	byte	$d8, $df, $73, $f8
'-'             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
	byte	$32, $90, $63, $5d
'-'                                                             ' skipcase (a) gfx copy to/from hub
'-'                                                             ' skipcase (b) gfx copy extmem bank to bank
'-'                                                             ' skipcase (c) linear copy extmem bank to bank
'-'                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
	byte	$db, $df, $73, $f8
'-'                             rdlut   d, a wz                 ' a      load bank information and check if valid
	byte	$ef, $e5, $ab, $fa
'-'             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
	byte	$31, $02, $64, $5d
'-'             _ret_           push    #invalidbank            ' |      otherwise bail out after this
	byte	$2a, $02, $66, $0d
'-'                             test    offset1 wz              ' |      check for first offset being zero
	byte	$dd, $bb, $cb, $f7
'-'             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
	byte	$de, $bd, $cb, $a7
'-'             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
	byte	$32, $94, $63, $ad
'-'                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
	byte	$32, $92, $63, $fd
'-'                             add     hubdata, c              ' a b c  add bytes just sent to hub address
	byte	$f1, $b3, $03, $f1
'-'                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
	byte	$ea, $b3, $83, $f1
'-'                             add     c, addr1                ' a b c  compute next address to use
	byte	$d8, $e3, $03, $f1
'-'                             test    total wz                ' a b |  check for zero tranfers
	byte	$dc, $b9, $cb, $f7
'-'                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
	byte	$dc, $d5, $2b, $f3
'-'             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
	byte	$44, $ff, $9f, $ad
'-'                             testb   addr1, #30 wz           ' a b c  check if reading/writing
	byte	$1e, $b0, $0f, $f4
'-'                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
	byte	$ea, $b5, $03, $f6
'-'                             sub     c, orighubsize          ' a b |  rewind to original position
	byte	$ea, $e3, $83, $f1
'-'             if_z            add     c, offset1              ' a b |  add any dst scanline offset
	byte	$dd, $e3, $03, $a1
'-'             if_nz           add     c, offset2              ' a b |  add any src scanline offset
	byte	$de, $e3, $03, $51
'-'             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
	byte	$de, $b3, $03, $a1
'-'             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
	byte	$dd, $b3, $03, $51
'-'                             setq    mask                    ' a b c  configure mask for bit muxing
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                ' a b c  perform address bit muxing
	byte	$f1, $b1, $f3, $f9
'-'                             mov     a, addr1                ' | b c  ]
	byte	$d8, $df, $03, $f6
'-'                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
	byte	$db, $b1, $03, $f6
'-'                             mov     addr2, a                ' | b c  ]
	byte	$ef, $b7, $03, $f6
'-'                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
	byte	$1e, $b0, $a7, $f4
'-'                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
	byte	$0f, $b6, $3f, $f8
'-'                             sub     total, #1 wz            ' a | |  decrement scanline count
	byte	$01, $b8, $8f, $f1
'-'             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
	byte	$01, $b8, $8f, $a1
'-'             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
	byte	$ea, $b9, $8b, $a1
'-'             if_z            mov     addr2, link
	byte	$df, $b7, $03, $a6
'-'             if_z            jmp     #checknext
	byte	$34, $ff, $9f, $ad
'-' moretransfers               getbyte request, addr1, #3      'prepare next request
	byte	$d8, $cb, $fb, $f8
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            skipf   #%1110                  '     skip some code if we are locked
	byte	$32, $1c, $64, $ad
'-'                             testb   addr1, #30 wz           ' a   test if will be reading or writing
	byte	$1e, $b0, $0f, $f4
'-'             if_z            mov     resume, resumewrites    ' |   resume burst writing
	byte	$be, $d3, $03, $a6
'-'             if_nz           mov     resume, newburstr       ' |   resume burst reading
	byte	$b9, $d3, $03, $56
'-'                             jmp     #yield                  ' |   yield to poller
	byte	$b0, $fe, $9f, $fd
'-'             if_z            skip    #%1                     '     skip next instruction for writing case
	byte	$31, $02, $64, $ad
'-'             _ret_           push    #start_read_exec        '(|)  do new read burst next 
	byte	$2a, $26, $67, $0d
'-'             _ret_           push    #start_write_exec       'do new write burst next
	byte	$2a, $28, $67, $0d
'-' 
'-' '..................................................................................................
'-' ' PSRAM WRITES
'-'                                                             '  a b c d e f g h
'-' 
'-'                                                             '  B W L F B R L L (a) byte write(s)
'-'                                                             '  Y O O I U E O O (b) word write(s)
'-'                                                             '  T R N L R S C C (c) long write(s)
'-'                                                             '  E D G L S U K K (d) resumed fill
'-'                                                             '          T M E E (e) new burst write
'-'                                                             '            E D D (f) resumed burst
'-'                                                             '              F B (g) locked fill
'-'                                                             '              I U (h) locked burst write
'-'                                                             '              L R 
'-'                                                             '              L S 
'-'                                                             '                T 
'-' 
'-' w_single                   
'-' w_fill_cont           
'-'                             getnib  a, addr1, #7            '  a b c d          obtain request
	byte	$d8, $df, $7b, $f8
'-'                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
	byte	$03, $de, $07, $f5
'-'                             movbyts hubdata, #0             '  a | | |          replicate byte across long
	byte	$00, $b2, $ff, $f9
'-'                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
	byte	$44, $b2, $ff, $f9
'-'                             andn    addr1, #1               '  | b | |          align word addresses
	byte	$01, $b0, $27, $f5
'-'                             andn    addr1, #3               '  | | c |          align long addresses
	byte	$03, $b0, $27, $f5
'-' w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
	byte	$da, $d5, $03, $f6
'-' w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
	byte	$01, $b4, $0f, $f2
'-'                             shl     count, a                '  a b c | |   |    scale into bytes
	byte	$ef, $b5, $63, $f0
'-'                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
	byte	$ab, $b5, $97, $fb
'-' w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
	byte	$da, $e3, $03, $f6
'-'                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
	byte	$76, $02, $a0, $fd
'-'                ' disable call to r_resume_burst for single longs when z=0
'-'                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
	byte	$e5, $5d, $03, $f8
'-'                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
	byte	$ae, $cf, $a3, $fa
'-'                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
	byte	$e7, $53, $e3, $f8
'-'                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
	byte	$e7, $51, $eb, $f8
'-'                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
	byte	$3f, $8a, $0f, $f6
'-'                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
	byte	$a3, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
	byte	$ce, $d3, $03, $c6
'-'             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
	byte	$cc, $d3, $03, $36
'-'                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
	byte	$d9, $df, $03, $f6
'-'                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
	byte	$14, $d6, $07, $f6
'-'                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
	byte	$01, $de, $17, $f4
'-'                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
	byte	$c7, $8b, $03, $f6
'-'             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
	byte	$14, $01, $90, $8d
'-'             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
	byte	$09, $8a, $67, $25
'-'             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
	byte	$5c, $00, $90, $2d
'-'                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
	byte	$0f, $8a, $07, $f6
'-'         
'-'             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
'-'             '
'-'             '  At least one of these 3 optional components will be sent
'-'             '     header - first partial long of data, gets aligned to PSRAM long boundary
'-'             '     body - N x full longs of data
'-'             '     trailer - last partial long of data
'-'             '
'-'             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
'-'             '
'-'             'Case    Type                           Sends
'-'             ' 1)     Single byte/word write         header only (takes its own optimized path)
'-'             ' 2)     Single long write              body only (takes its own optimized path)
'-'             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
'-'             ' 4)     Multiple long fill             body only
'-'             ' 5)     Burst write                    optional header, optional body, optional trailer
'-' 
'-'                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
'-'                             mov     d, addr1                'get start address
	byte	$d8, $e5, $03, $f6
'-'                             zerox   d, #11                  'only keep 12 LSBs
	byte	$0b, $e4, $47, $f7
'-'                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
	byte	$ee, $e5, $c3, $f2
'-'                             fle     c, d wc                 'compare this size to our transfer size and limit it
	byte	$f2, $e3, $33, $f3
'-'             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
	byte	$ce, $d3, $03, $c6
'-'                             mov     pattern3, #%10011
	byte	$13, $8c, $07, $f6
'-'                             mov     d, addr1                'get start address position 
	byte	$d8, $e5, $03, $f6
'-'                             and     d, #3 wz                'get alignment
	byte	$03, $e4, $0f, $f5
'-'                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
	byte	$04, $e2, $17, $f2
'-'                             mov     wrclks, #16             'clocks needed for address phase
	byte	$10, $d6, $07, $f6
'-'                             mov     pb, c                   'get number of bytes to send
	byte	$f1, $ef, $03, $f6
'-'                             add     pb, d                   'and increase total to send, including initial re-alignment
	byte	$f2, $ef, $03, $f1
'-'             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
	byte	$40, $00, $90, $2d
'-'                             
'-'                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'             if_c            skipf   #%11110                 'if fill skip burst write stuff
	byte	$32, $3c, $64, $cd
'-'                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
	byte	$04, $d6, $07, $f1
'-'                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
	byte	$f2, $df, $83, $f1
'-'                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
	byte	$ef, $e5, $03, $fb
'-'                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
	byte	$04, $de, $07, $f1
'-'                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
	byte	$32, $08, $64, $fd
'-'                             sub     pb, #4 wcz              ' subtract a long from the total
	byte	$04, $ee, $9f, $f1
'-'                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
	byte	$00, $8a, $07, $f4
'-' single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
	byte	$d9, $e5, $03, $f6
'-'                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
	byte	$88, $01, $b0, $fd
'-'                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
	byte	$5a, $b0, $47, $fb
'-'                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
	byte	$ed, $c5, $03, $fb
'-'                             setq    pa                      ' setup byte mux mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    header, d               ' copy bytes into long
	byte	$f2, $c5, $f3, $f9
'-'             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
	byte	$94, $00, $90, $ed
'-' 
'-' header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
	byte	$f0, $ca, $17, $f2
'-'                             mov     d, pb                   'preserve the count
	byte	$f7, $e5, $03, $f6
'-'                             andn    pb, #3 wz               'determine the number of full long bytes left to send
	byte	$03, $ee, $2f, $f5
'-'                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
	byte	$07, $ee, $97, $fb
'-'                  
'-'                             add     wrclks, pb              'include this number of bytes as more clock transitions
	byte	$f7, $d7, $03, $f1
'-'             if_c            skipf   #%1010                 'for fills we can skip burst stuff
	byte	$32, $14, $64, $cd
'-'             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
	byte	$0c, $8a, $27, $c5
'-'                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
	byte	$01, $8a, $07, $f4
'-'                             shr     pb, #1                  ' |  b  compute word count for bursts
	byte	$01, $ee, $47, $f0
'-'                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
	byte	$f7, $37, $23, $f9
'-'                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
	byte	$01, $ee, $47, $f0
'-' 
'-' body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
	byte	$03, $e4, $07, $f5
'-'                             tjz     d, #trailer_done        'no trailer to send, we exit now
	byte	$17, $e4, $97, $fb
'-'             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
	byte	$da, $e3, $0b, $c2
'-'             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
	byte	$cc, $d3, $0b, $32
'-'             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
	byte	$f2, $e3, $83, $51
'-'             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
	byte	$4c, $00, $90, $5d
'-' 
'-'                             'we have 1-3 more aligned residual bytes left to send as the trailer
'-'                             or      d, #$1f0                'setup mux mask address
	byte	$f0, $e5, $47, $f5
'-'                             rdlut   pa, d                   'read mux mask for this length at offset 0
	byte	$f2, $ed, $a3, $fa
'-'                             push    addr1                   'save address
	byte	$2a, $b0, $63, $fd
'-' 
'-' ' use this code (note: foldover can occur here in PSRAM bank)
'-'                             add     addr1, c                'find last long address in PSRAM
	byte	$f1, $b1, $03, $f1
'-'                             sub     addr1, #1               '..to be rewritten
	byte	$01, $b0, $87, $f1
'-'                             call    #readlong               'read data from this external address
	byte	$18, $01, $b0, $fd
'-'             
'-'             if_c            mov     d, hubdata              'get data to be sent for fills
	byte	$d9, $e5, $03, $c6
'-'             if_c            skipf   #%11110                 'skip burst code for fills
	byte	$32, $3c, $64, $cd
'-'                             pop     addr1                   'restore address
	byte	$2b, $b0, $63, $fd
'-'                             mov     d, pb                   ' | get number of full longs that were sent
	byte	$f7, $e5, $03, $f6
'-'                             shl     d, #2                   ' | convert to bytes
	byte	$02, $e4, $67, $f0
'-'                             add     d, a                    ' | add to start adress of longs to stream
	byte	$ef, $e5, $03, $f1
'-'                             rdlong  d, d                    ' | read this last long from HUB RAM
	byte	$f2, $e5, $03, $fb
'-' 
'-'                             rdlong  trailer, hubscratch     'read external RAM data value
	byte	$ed, $c7, $03, $fb
'-'                             setq    pa                      'setup byte mask
	byte	$28, $ec, $63, $fd
'-'                             muxq    trailer, d              'apply byte mask to data via muxq
	byte	$f2, $c7, $f3, $f9
'-'                             add     wrclks, #4              'increase by 4 more clocks
	byte	$04, $d6, $07, $f1
'-'                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
	byte	$05, $8a, $07, $f4
'-'                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
	byte	$00, $8c, $07, $f4
'-' 
'-'                             'trailer is done
'-' trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
	byte	$ef, $3b, $73, $fc
'-' 
'-' writecommon                 mov     cmdaddr, addr1          'get start address of transfer
	byte	$d8, $c9, $03, $f6
'-'                             shr     cmdaddr, #2             'align to 32 bit boundary
	byte	$02, $c8, $47, $f0
'-'                             setbyte cmdaddr, #$02, #3       'add quad write command
	byte	$02, $c8, $df, $f8
'-' 
'-'                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
	byte	$60, $c8, $63, $fd
'-'                             rev     cmdaddr                 
	byte	$69, $c8, $63, $fd
'-'                             movbyts cmdaddr, #%%0123
	byte	$1b, $c8, $ff, $f9
'-'                             mergeb  cmdaddr
	byte	$61, $c8, $63, $fd
'-'                             
'-'                             drvl    cspin                   'activate chip select
	byte	$58, $52, $63, $fd
'-'                             drvl    datapins                'enable the DATA bus
	byte	$58, $48, $63, $fd
'-'                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
	byte	$e4, $2f, $a3, $fc
'-'                             wypin   wrclks, clkpin          'start memory clock output 
	byte	$a8, $d7, $23, $fc
'-'                                                          
'-'                             skipf   pattern2                '   B W L Burst FB FW FL RMW
	byte	$32, $8a, $63, $fd
'-'                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
	byte	$e2, $39, $c3, $fc
'-'                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
	byte	$00, $36, $c7, $fc
'-'                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
	byte	$f7, $03, $d8, $fc
'-'                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
	byte	$d9, $39, $c3, $fc
'-'                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
	byte	$32, $8c, $63, $fd
'-'                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
	byte	$e3, $39, $c3, $fc
'-'                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
	byte	$2d, $d2, $63, $fd
'-'                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
	byte	$24, $36, $60, $fd
'-'                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
	byte	$50, $48, $63, $fd
'-'             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
	byte	$59, $52, $63, $0d
'-'  
'-'                             drvh    cspin
	byte	$59, $52, $63, $fd
'-' check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
	byte	$09, $c2, $17, $f4
'-'                             sub     count, c wz             'account for bytes written
	byte	$f1, $b5, $8b, $f1
'-'             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
	byte	$34, $00, $90, $5d
'-'                             wrlut   #0, ptra[8]             'default is not to resume
	byte	$08, $01, $3c, $fc
'-'             if_nc           jmp     #notify                 'if not a request list then we are done
	byte	$3c, $f5, $9f, $3d
'-'                             tjns    addr2, #checklist       'if not extended, check next list entry
	byte	$40, $b7, $bf, $fb
'-'                             djz     total, #donerepeats     'check for repeats remaining
	byte	$3e, $b9, $67, $fb
'-'                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
	byte	$b8, $b9, $b3, $fb
'-'                             mov     d, orighubsize
	byte	$ea, $e5, $03, $f6
'-'                             shl     d, a
	byte	$ef, $e5, $63, $f0
'-'                             sub     c, d
	byte	$f2, $e3, $83, $f1
'-'                             add     c, offset1
	byte	$dd, $e3, $03, $f1
'-'                             mov     count, d                'restore original count
	byte	$f2, $b5, $03, $f6
'-' readmask                    getnib  b, request, #0          'get bank parameter LUT address
	byte	$e5, $e1, $43, $f8
'-'                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
	byte	$f0, $e1, $a3, $fa
'-'                             bmask   mask, b                 'build mask for addr (in case count=1)
	byte	$f0, $45, $cb, $f9
'-' continue_fill               add     c, addr1                'add bytes to destination address
	byte	$d8, $e3, $03, $f1
'-'                             setq    mask                    'setup bit mask
	byte	$28, $44, $63, $fd
'-'                             muxq    addr1, c                'setup new external memory address
	byte	$f1, $b1, $f3, $f9
'-'                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
	byte	$0a, $c2, $0f, $f4
'-'             if_z            execf   lockedfill              'continue next fill operation
	byte	$33, $74, $63, $ad
'-'                             mov     resume, restorefill
	byte	$bb, $d3, $03, $f6
'-'             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
	byte	$00, $b6, $07, $36
'-'             if_nc           call    #yieldfill              'we have to yield now to other COGs
	byte	$80, $fc, $bf, $3d
'-'             if_c            call    #yield
	byte	$6c, $fc, $bf, $cd
'-'                             ret
	byte	$2d, $00, $64, $fd
'-'                            
'-' getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
'-'                       '     rczl    pa                      'rotate left into address offset
'-'                       '     rczl    c wcz                   'restore count and flags
'-'                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
	byte	$03, $e2, $ef, $f7
'-'                             shl     pa, #2
	byte	$02, $ec, $67, $f0
'-'             if_z            setq    #3
	byte	$28, $06, $64, $ad
'-'             if_z            muxq    pa, c
	byte	$f1, $ed, $f3, $a9
'-'                             or      pa, #$1f0               'setup LUT address offset
	byte	$f0, $ed, $47, $f5
'-'            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
	byte	$f6, $ed, $a3, $fa
'-'                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
	byte	$2d, $00, $7c, $fd
'-' 
'-' readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
	byte	$ed, $3b, $83, $fc
'-'                             setword xrecvdata, #2, #0       'read 2x16 words
	byte	$02, $34, $27, $f9
'-'                             mov     clks, #32               '32 read clock transitions
	byte	$20, $d0, $07, $f6
'-'                             mov     pattern, #%110110       'setup read skip pattern
	byte	$36, $d8, $07, $f6
'-'                             jmp     #readcommon             'read then return directly to caller
	byte	$14, $fb, $9f, $fd
'-'         
'-' 
'-' '..................................................................................................
'-' 
'-'                 fit 1024-32
'-'                 fit 1024-32
'-'                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
'-'                 org 1024-32
'-' 
'-' ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
'-'                 long $0000
	byte	$00, $00, $00, $00
'-'                 long $1111
	byte	$11, $11, $00, $00
'-'                 long $2222
	byte	$22, $22, $00, $00
'-'                 long $3333
	byte	$33, $33, $00, $00
'-'                 long $4444
	byte	$44, $44, $00, $00
'-'                 long $5555
	byte	$55, $55, $00, $00
'-'                 long $6666
	byte	$66, $66, $00, $00
'-'                 long $7777
	byte	$77, $77, $00, $00
'-'                 long $8888
	byte	$88, $88, $00, $00
'-'                 long $9999
	byte	$99, $99, $00, $00
'-'                 long $aaaa
	byte	$aa, $aa, $00, $00
'-'                 long $bbbb
	byte	$bb, $bb, $00, $00
'-'                 long $cccc
	byte	$cc, $cc, $00, $00
'-'                 long $dddd
	byte	$dd, $dd, $00, $00
'-'                 long $eeee
	byte	$ee, $ee, $00, $00
'-'                 long $ffff
	byte	$ff, $ff, $00, $00
'-' 
'-' 'masks
'-'                 long $ffffffff ' 00 aligned 0/4 length
	byte	$ff, $ff, $ff, $ff
'-'                 long $000000ff ' 00 aligned 1 length
	byte	$ff, $00, $00, $00
'-'                 long $0000ffff ' 00 aligned 2 length
	byte	$ff, $ff, $00, $00
'-'                 long $00ffffff ' 00 aligned 3 length
	byte	$ff, $ff, $ff, $00
'-' 
'-'                 long $ffffff00 ' 01 aligned 0/4 length
	byte	$00, $ff, $ff, $ff
'-'                 long $0000ff00 ' 01 aligned 1 length
	byte	$00, $ff, $00, $00
'-'                 long $00ffff00 ' 01 aligned 2 length
	byte	$00, $ff, $ff, $00
'-'                 long $ffffff00 ' 01 aligned 3 length
	byte	$00, $ff, $ff, $ff
'-' 
'-'                 long $ffff0000 ' 10 aligned 0/4 length
	byte	$00, $00, $ff, $ff
'-'                 long $00ff0000 ' 10 aligned 1 length
	byte	$00, $00, $ff, $00
'-'                 long $ffff0000 ' 10 aligned 2 length
	byte	$00, $00, $ff, $ff
'-'                 long $ffff0000 ' 10 aligned 3 length
	byte	$00, $00, $ff, $ff
'-' 
'-'                 long $ff000000 ' 11 aligned 0/4 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 1 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 2 length
	byte	$00, $00, $00, $ff
'-'                 long $ff000000 ' 11 aligned 3 length
	byte	$00, $00, $00, $ff
'-' 
'-'         fit 1024
'-'         fit 1024
'-' 
'-' '--------------------------------------------------------------------------------------------------
'-'         orgh
'-' 
'-' gfxexpansion
'-'                             'simple line drawing graphics expansion of memory driver
'-'                             'jmp     #donerepeats                'just return for now
'-' 
'-'                             cmp     addr1, addr2 wz         'see if we've reached the end
	byte	$db, $b1, $0b, $f2
'-'             if_z            jmp     #donerepeats            'nothing more to draw
	byte	$fb, $02, $80, $ad
'-'                             add     total, #1               'restore total after decrement
	byte	$01, $b8, $07, $f1
'-'                             mov     b, offset1              'get error term
	byte	$dd, $e1, $03, $f6
'-'                             shl     b, #1                   'compute e2 = 2 x error
	byte	$01, $e0, $67, $f0
'-'                             getword d, offset2, #0          'get dx = abs(x0-x1)
	byte	$de, $e5, $33, $f9
'-'                             sar     offset2, #16            'get dy = -abs(y0-y1)
	byte	$10, $bc, $c7, $f0
'-'                             cmps    b, offset2 wc           'compare if e2 >= dy
	byte	$de, $e1, $53, $f2
'-'                             mov     c, #0                   'clear accumulator reg
	byte	$00, $e2, $07, $f6
'-'             if_c            skip    #%1110                  'if not, skip
	byte	$31, $1c, $64, $cd
'-'                             decod   a                       'decode as 1,2,or 4 byte size
	byte	$ef, $df, $c3, $f9
'-'                             add     offset1, offset2        'err+=dy 
	byte	$de, $bb, $03, $f1
'-'                             testb   total, #16 wz           'check sign sx   
	byte	$10, $b8, $0f, $f4
'-'                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
	byte	$ef, $e3, $c3, $f3
'-'                             cmps    d, b wc                 'compare if e2 <= dx
	byte	$f0, $e5, $53, $f2
'-'             if_c            skip    #%11110                 'if not, skip
	byte	$31, $3c, $64, $cd
'-'                             rolword offset2, d, #0          'restore offset
	byte	$f2, $bd, $43, $f9
'-'                             add     offset1, d              'err+=dx
	byte	$f2, $bb, $03, $f1
'-'                             testb   total, #17 wz           'check sign sy
	byte	$11, $b8, $0f, $f4
'-'                             getword d, total, #0            'get line width
	byte	$dc, $e5, $33, $f9
'-'                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
	byte	$f2, $e3, $c3, $f3
'-'                             encod   a wc                    'restore size and set carry
	byte	$ef, $df, $93, $f7
'-'                             mov     count, orighubsize      'reset the fill width
	byte	$ea, $b5, $03, $f6
'-'                             shl     count, a                '..for the type of transfer
	byte	$ef, $b5, $63, $f0
'-'                             jmp     #readmask               'continue filling
	byte	$c3, $03, $80, $fd
	alignl
_usbnew_spin2_dat_
'-'                 org     $000
'-' 
'-' usb_host_start
'-'                 mov     hcog_base_addr, ptrb
	byte	$f9, $8f, $02, $f6
'-' 
'-'                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
	byte	$03, $00, $00, $ff, $d0, $72, $07, $f6
'-'                 shr     htmp, #2                        ' so byte->long for the lut cell count
	byte	$02, $72, $47, $f0
'-'                 loc     pb, #@hlut_start - @usb_host_start
	byte	$b4, $04, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq2   htmp
	byte	$29, $72, $63, $fd
'-'                 rdlong  0, pb                           ' Do the hub->lut copy
	byte	$f7, $01, $00, $fb
'-' 
'-'                 loc     pb, #@usb_host_init - @usb_host_start
	byte	$88, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 jmp     pb                              ' Initialize host and enter main processing loop
	byte	$2c, $ee, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
'-' ' special because the receiving function must not respond with either STALL or
'-' ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
'-' ' non-control endpoint receives a SETUP token, or the function receives a
'-' ' corrupt packet, it must ignore the transaction
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data struct.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error code.
'-' '------------------------------------------------------------------------------
'-' txn_setup
'-'                 setbyte ep_addr_pid, #PID_SETUP, #0
	byte	$2d, $bc, $c6, $f8
'-'                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
	byte	$08, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
	byte	$03, $96, $06, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
	byte	$0c, $a2, $06, $f6
'-'                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
	byte	$f8, $ed, $03, $f6
'-' .setup
'-'                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
	byte	$24, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait
	byte	$7c, $0b, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
	byte	$f6, $f1, $03, $f6
'-'                 jmp     #.setup
	byte	$e0, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' IN/INTERRUPT transaction.
'-' ' Possible function response: STALL or NAK handshake, or DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_in
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$90, $03, $b0, $fd
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #utx_token                      ' Put IN request on the bus
	byte	$bc, $00, $b0, $fd
'-' 
'-'                 ' Fall through to urx_packet
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a packet from a device/function. As host, the only two packet types
'-' ' received are handshakes and IN DATAx.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
'-' '     returned.
'-' '------------------------------------------------------------------------------
'-' urx_packet
'-'                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #urx_packet
	byte	$f4, $ff, $9f, $cd
'-'                 getct   hct2
	byte	$1a, $94, $63, $fd
'-'                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
	byte	$4e, $95, $6b, $fa
'-'                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
	byte	$05, $96, $06, $f4
'-'                 mov     newb_flg, #0                    ' Initialize for multi-byte read
	byte	$00, $a8, $06, $f6
'-' .wait_sop
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #.get_pid
	byte	$08, $00, $90, $cd
'-'                 jnct2   #.wait_sop
	byte	$fc, $25, $cc, $fb
'-'         _ret_   mov     retval, #ERR_TAT
	byte	$05, $be, $06, $06
'-' .get_pid
'-'                 call    #urx_next
	byte	$28, $02, $b0, $fd
'-'                 testb   urx, #BUS_ERRB          wc
	byte	$06, $a6, $16, $f4
'-'         if_nc   jmp     #.chk_pid
	byte	$04, $00, $90, $3d
'-'         _ret_   mov     retval, #ERR_URX
	byte	$02, $be, $06, $06
'-' .chk_pid
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $52
'-'         if_nz   cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
	byte	$38, $00, $90, $ad
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
	byte	$03, $96, $16, $f4
'-'                 cmp     retval, #PID_DATA0      wz
	byte	$c3, $be, $0e, $f2
'-'    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
	byte	$28, $01, $90, $2d
'-'    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
	byte	$10, $00, $90, $8d
'-'                 cmp     retval, #PID_DATA1      wz
	byte	$4b, $be, $0e, $f2
'-'    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
	byte	$1c, $01, $90, $8d
'-'    if_z_and_nc  jmp     #.ack_resend
	byte	$04, $00, $90, $2d
'-'         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
	byte	$04, $be, $06, $06
'-' .ack_resend
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.ack_resend
	byte	$f4, $ff, $9f, $3d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 call    #utx_handshake                  ' Send handshake PID and return to caller
	byte	$98, $01, $b0, $fd
'-'         _ret_   mov     retval, #ERR_DATAX_SYNC
	byte	$09, $be, $06, $06
'-' .chk_eop
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
	byte	$1c, $00, $90, $3d
'-'                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
	byte	$c8, $01, $b0, $fd
'-'                 testb   hstatus, #EOPB          wc
	byte	$05, $96, $16, $f4
'-'         if_c    jmp     #.idle                          ' Low-speed EOP seen
	byte	$10, $00, $90, $cd
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
	byte	$04, $be, $06, $36
'-'         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
	byte	$02, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
	byte	$f4, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send a token packet with CRC5 checksum of address and endpoint. It is the
'-' ' responsibility of the caller to append the appropriate inter-packet delay,
'-' ' if one is required.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - packed with the PID, address and endpoint.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_token
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #utx_token
	byte	$f4, $ff, $9f, $3d
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$34, $0d, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync byte
	byte	$70, $01, $b0, $fd
'-'                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
	byte	$5e, $73, $03, $f6
'-'                 mov     pkt_cnt, #3
	byte	$03, $b8, $06, $f6
'-' .next_byte
'-'                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
	byte	$b9, $a5, $e2, $f8
'-'                 shr     htmp, #8                        ' Shift to next byte to send
	byte	$08, $72, $47, $f0
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   utx, dm
	byte	$22, $a5, $22, $fc
'-'         _ret_   djnz    pkt_cnt, #.next_byte
	byte	$f9, $b9, $6e, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' SETUP/OUT/INTERRUPT transaction.
'-' ' Possible function response in order of precedence: STALL, ACK, NAK.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
'-' '     CRC(b19..23).
'-' '   PTRA - start address of the data buff/struct that has the bytes to send.
'-' '   pkt_data - count of DATAx payload bytes to send.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' txn_out
'-'                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
	byte	$88, $02, $b0, $fd
'-'                 call    #utx_token                      ' Put SETUP/OUT token on the bus
	byte	$b8, $ff, $bf, $fd
'-'                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
	byte	$00, $00, $c0, $ff, $f8, $01, $78, $fc
'-'                 mov     pkt_cnt, pkt_data
	byte	$58, $b9, $02, $f6
'-' 
'-'                 ' Fall through to utx_data
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
'-' ' calculated while the data byte is being shifted out. Since data stage
'-' ' success/fail is not determined until the status stage of the transaction,
'-' ' this routine is only concerned about the current DATAx packet.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - hub start address of the data to read.
'-' '   pkt_cnt - data payload size.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_data
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'         if_c    jmp     #utx_data
	byte	$f4, $ff, $9f, $cd
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
	byte	$2c, $0a, $b0, $fd
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$d8, $0c, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$14, $01, $b0, $fd
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
	byte	$03, $96, $16, $f4
'-'         if_nc   mov     utx, #PID_DATA0
	byte	$c3, $a4, $06, $36
'-'         if_c    mov     utx, #PID_DATA1
	byte	$4b, $a4, $06, $c6
'-'                 call    #utx_byte                       ' No CRC calc done on PID
	byte	$00, $01, $b0, $fd
'-'                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
	byte	$1c, $00, $90, $ad
'-' .read_byte
'-'                 rfbyte  utx                             ' Fetch data byte
	byte	$10, $a4, $62, $fd
'-'                 call    #utx_byte
	byte	$f0, $00, $b0, $fd
'-'                 rev     utx                             ' Calculate CRC while the data is shifting out
	byte	$69, $a4, $62, $fd
'-'                 setq    utx                             ' SETQ left-justifies the reflected data byte
	byte	$28, $a4, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-'                 djnz    pkt_cnt, #.read_byte
	byte	$f9, $b9, $6e, $fb
'-' .send_crc
'-'                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
	byte	$e0, $bb, $e6, $f4
'-'                 getbyte utx, crc, #0
	byte	$5d, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$d0, $00, $b0, $fd
'-'                 getbyte utx, crc, #1
	byte	$5d, $a5, $ea, $f8
'-'                 call    #utx_byte                       ' Last CRC byte out
	byte	$c8, $00, $b0, $fd
'-'                 jmp     #urx_packet                     ' Handle function response/error and back to caller
	byte	$7c, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
'-' ' payload bytes are received. The routine reads bytes until EOP is detected and
'-' ' expects that the packet includes at least the CRC word.
'-' '
'-' ' In control transfers, it's possible to recieve fewer data bytes than what
'-' ' was requested, which makes it difficult to determine where the data stops
'-' ' and the CRC word begins. So the CRC calculation is done on every byte of the
'-' ' packet, including the CRC word. The CRC value should then be equal to the
'-' ' USB-16 expected residual value of 0xB001.
'-' '
'-' ' The routine writes the IN packet data to a static max_packet_size buffer
'-' ' so the caller can verify IN success before writing the data to its final
'-' ' destination.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   pkt_data - max byte count expected to be in the packet.
'-' '   newb_flg - signals new byte ready when toggled.
'-' ' On exit:
'-' '   pkt_cnt - actual number of bytes read.
'-' '------------------------------------------------------------------------------
'-' urx_data
'-'                 mov     htmp2, pb
	byte	$f7, $77, $03, $f6
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
	byte	$00, $00, $c0, $ff, $f7, $01, $88, $fc
'-'                 mov     pb, htmp2
	byte	$bb, $ef, $03, $f6
'-'                 bmask   crc, #15                        ' Prime the CRC16 pump
	byte	$0f, $ba, $ce, $f9
'-'                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
	byte	$00, $b8, $06, $f6
'-'                 mov     pkt_tmp, pkt_data
	byte	$58, $85, $03, $f6
'-'                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
	byte	$02, $84, $07, $f1
'-' .wait_byte
'-' ' In-line rx for max speed
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   jmp     #.get_byte                      ' New byte!
	byte	$0c, $00, $90, $5d
'-'                 testb   urx, #EOPB              wc
	byte	$05, $a6, $16, $f4
'-'         if_c    jmp     #.chk_crc                       ' At end-of-packet
	byte	$38, $00, $90, $cd
'-'                 jmp     #.wait_byte
	byte	$dc, $ff, $9f, $fd
'-' .get_byte
'-'                 getbyte retval, urx, #1                 ' New byte from smart pins
	byte	$53, $bf, $ea, $f8
'-'                 wfbyte  retval                          ' Add it to the data buffer
	byte	$15, $be, $62, $fd
'-'                 rev     retval                          ' Calculate CRC while next byte is shifting in
	byte	$69, $be, $62, $fd
'-'                 setq    retval                          ' SETQ left-justifies the reflected data byte
	byte	$28, $be, $62, $fd
'-'                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
	byte	$1f, $bb, $da, $f9
'-'                 crcnib  crc, usb16_poly_r
	byte	$1f, $bb, $da, $f9
'-' .end_crc
'-'                 add     pkt_cnt, #1
	byte	$01, $b8, $06, $f1
'-'                 cmp     pkt_cnt, pkt_tmp        wcz
	byte	$c2, $b9, $1a, $f2
'-'         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
	byte	$04, $be, $06, $16
'-'         if_a    ret
	byte	$2d, $00, $64, $1d
'-' ' For full-speed at 80MHz, the time it takes to do the final byte write and
'-' ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
'-' ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
'-' ' to miss it, so cheat a bit and look for SOP clear here.
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
	byte	$05, $a6, $16, $f4
'-'         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
	byte	$a8, $ff, $9f, $3d
'-' ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
'-' .chk_crc
'-'                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
	byte	$02, $b8, $86, $f1
'-'                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
	byte	$58, $00, $00, $ff, $01, $ba, $6e, $f5
'-'         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
	byte	$f0, $fd, $9f, $5d
'-'                 mov     retval, #PID_ACK
	byte	$d2, $be, $06, $f6
'-'                 mov     hctwait, ip_delay
	byte	$4d, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$34, $09, $b0, $fd
'-' 
'-'                 ' Fall through to utx_handshake
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
'-' ' the appropriate IP delay has been inserted.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - handshake PID to send.
'-' ' On exit:
'-' '   retval unchanged.
'-' '------------------------------------------------------------------------------
'-' utx_handshake
'-'                 testb   hstatus, #DWNSTRM_HUBB  wc
	byte	$07, $96, $16, $f4
'-'         if_c    call    #utx_pre
	byte	$e0, $0b, $b0, $cd
'-'                 mov     utx, #OUT_SOP
	byte	$80, $a4, $06, $f6
'-'                 call    #utx_byte                       ' Send sync
	byte	$1c, $00, $b0, $fd
'-'                 mov     utx, retval
	byte	$5f, $a5, $02, $f6
'-'                 call    #utx_byte                       ' Send handshake PID
	byte	$14, $00, $b0, $fd
'-' .idle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #J_IDLEB           wc
	byte	$00, $a6, $16, $f4
'-'         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
	byte	$f4, $ff, $9f, $3d
'-'                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
	byte	$4e, $99, $02, $f6
'-'                 jmp     #poll_waitx
	byte	$08, $09, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for the USB tx buffer to empty and feed it a new byte.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   utx - byte to transmit.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' utx_byte
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #utx_byte
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
	byte	$1f, $94, $62, $fd
'-'         _ret_   wypin   utx, dm
	byte	$22, $a5, $22, $0c
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Fetch the next data byte of a packet. Always check receiver status for EOP.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   retval - the byte read.
'-' '   urx - the receiver status. The caller must check the hstatus reg EOP flag
'-' '     on return. If EOP is set, the byte in reg retval remains as the last byte
'-' '     received.
'-' '------------------------------------------------------------------------------
'-' urx_next
'-'                 rdpin   urx, dm
	byte	$22, $a7, $8a, $fa
'-'                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
	byte	$80, $a4, $06, $f6
'-'                 and     utx, urx
	byte	$53, $a5, $02, $f5
'-'                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
	byte	$52, $a9, $0a, $f2
'-'         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
	byte	$80, $a8, $66, $55
'-'         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
	byte	$53, $bf, $ea, $58
'-'         if_nz   ret                                     ' New byte is priority, so return now
	byte	$2d, $00, $64, $5d
'-'                 testb   urx, #SOPB              wc
	byte	$04, $a6, $16, $f4
'-'                 testb   urx, #BUS_ERRB          wz
	byte	$06, $a6, $0e, $f4
'-'    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
	byte	$d8, $ff, $9f, $4d
'-'         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
	byte	$05, $96, $26, $34
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
'-' ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
'-' ' length, and the PID is not included in the CRC calculation:
'-' '  CRC5  FRAME_NUMBER SOF (full-speed)
'-' '  CRC5  ENDP ADDRESS PID
'-' ' %00000_1111_1111111_xxxxxxxx
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - stuffed with the function endpoint, address and
'-' '     SETUP/IN/OUT/SOF PID according to the USB standard.
'-' ' On exit:
'-' '   ep_addr_pid - CRC value appended to the packet.
'-' '------------------------------------------------------------------------------
'-' calc_crc5
'-'                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
	byte	$ff, $03, $00, $ff, $ff, $bd, $06, $f5
'-'                 mov     htmp, ep_addr_pid
	byte	$5e, $73, $03, $f6
'-'                 shr     htmp, #8                        ' PID not included in CRC calc
	byte	$08, $72, $47, $f0
'-'                 mov     crc, #$1f                       ' Initial CRC5 value
	byte	$1f, $ba, $06, $f6
'-'                 rev     htmp                            ' Input data reflected
	byte	$69, $72, $63, $fd
'-'                 setq    htmp                            ' CRCNIB setup for data bits 0..7
	byte	$28, $72, $63, $fd
'-'                 crcnib  crc, #USB5_POLY
	byte	$14, $ba, $de, $f9
'-'                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
	byte	$14, $ba, $de, $f9
'-'                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
	byte	$09, $72, $77, $f0
'-'                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $72, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 shl     htmp, #1                wc
	byte	$01, $72, $77, $f0
'-'                 crcbit  crc, #USB5_POLY
	byte	$14, $ba, $d6, $f9
'-'                 xor     crc, #$1f                       ' Final XOR value
	byte	$1f, $ba, $66, $f5
'-'                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
	byte	$13, $ba, $66, $f0
'-'         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
	byte	$5d, $bd, $42, $05
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed/low-speed frame timing interrupt service routine.
'-' '------------------------------------------------------------------------------
'-' isr1_fsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6f, $13, $fc
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 mov     utx, #PID_SOF
	byte	$a5, $a4, $06, $f6
'-'                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
	byte	$22, $01, $29, $fc
'-'                 call    #utx_byte                       ' Send token PID byte
	byte	$4c, $ff, $bf, $fd
'-'                 mov     icrc, #$1f                      ' Prime the CRC5 pump
	byte	$1f, $b6, $06, $f6
'-'                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
	byte	$59, $b5, $02, $f6
'-'                 rev     sof_pkt                         ' Input data reflected
	byte	$69, $b4, $62, $fd
'-'                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
	byte	$28, $b4, $62, $fd
'-'                 crcnib  icrc, #USB5_POLY
	byte	$14, $b6, $de, $f9
'-'                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
	byte	$14, $b6, $de, $f9
'-'                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
	byte	$59, $a5, $e2, $f8
'-'                 call    #utx_byte
	byte	$2c, $ff, $bf, $fd
'-'                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
	byte	$08, $b4, $66, $f0
'-'                 rep     #2, #3                          ' Three data bits left to process
	byte	$03, $04, $dc, $fc
'-'                 shl     sof_pkt, #1             wc
	byte	$01, $b4, $76, $f0
'-'                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
	byte	$14, $b6, $d6, $f9
'-'                 xor     icrc, #$1f                      ' Final XOR value
	byte	$1f, $b6, $66, $f5
'-'                 getbyte utx, frame, #1                  ' Send remaining frame number bits
	byte	$59, $a5, $ea, $f8
'-'                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
	byte	$03, $b6, $66, $f0
'-'                 or      utx, icrc
	byte	$5b, $a5, $42, $f5
'-'                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
	byte	$08, $ff, $bf, $fd
'-'                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
	byte	$a4, $83, $03, $f6
'-'                 jmp     #isr1_wait
	byte	$20, $00, $90, $fd
'-' isr1_lsframe
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-' .wait
'-'                 testp   dp                      wc
	byte	$40, $46, $72, $fd
'-'         if_nc   jmp     #.wait
	byte	$f8, $ff, $9f, $3d
'-'                 akpin   dp
	byte	$23, $03, $08, $fc
'-'                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
	byte	$22, $09, $28, $fc
'-'                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
	byte	$a3, $83, $03, $f6
'-' isr1_wait
'-'                 rqpin   utx, dm
	byte	$22, $a5, $82, $fa
'-'                 testb   utx, #SOPB                 wc
	byte	$04, $a4, $16, $f4
'-'         if_c    jmp     #isr1_wait
	byte	$f4, $ff, $9f, $cd
'-'                 add     frame, #1                       ' Next frame# and check for wrap around
	byte	$01, $b2, $06, $f1
'-'                 and     frame, ##$7ff
	byte	$03, $00, $00, $ff, $ff, $b3, $06, $f5
'-'                 waitx   isrtmp1                         ' Make sure bus is idle
	byte	$1f, $82, $63, $fd
'-'                 reti1
	byte	$f5, $ff, $3b, $fb
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Wait for a window within the 1ms frame boundary that will ensure that a
'-' ' transaction will complete before the next frame is triggered.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' wait_txn_ok
'-'                 getct   htmp2
	byte	$1a, $76, $63, $fd
'-'                 sub     htmp2, iframe_ct_base
	byte	$49, $77, $83, $f1
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    cmp     htmp2, _txn_ok_ls_      wcz
	byte	$a1, $77, $1b, $c2
'-'         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
	byte	$a2, $77, $1b, $32
'-'         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
	byte	$e8, $ff, $9f, $1d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A device connection was detected, or a bus reset was requested by the USB
'-' ' client. Set the appropriate smart pin FS/LS speed mode to match the device
'-' ' and perform a reset sequence prior to device enumeration.
'-' '------------------------------------------------------------------------------
'-' dev_reset
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
	byte	$01, $a6, $16, $f4
'-'         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
	byte	$f4, $03, $b0, $cd
'-'         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
	byte	$e0, $03, $b0, $3d
'-' reset
'-'                 setint1 #0                              ' Don't want frame interrupt while in reset
	byte	$25, $00, $64, $fd
'-'                 wypin   #OUT_SE0, dm                    ' Assert bus reset
	byte	$22, $03, $28, $fc
'-'                 waitx   _reset_hold_                    ' Spec is >= 10ms
	byte	$1f, $5c, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 mov     frame, #0                       ' Reset the frame timespan count
	byte	$00, $b2, $06, $f6
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-'                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
	byte	$59, $73, $03, $f6
'-'                 add     htmp, #36
	byte	$24, $72, $07, $f1
'-'                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
	byte	$25, $02, $64, $fd
'-' .framewait
'-'                 cmp     frame, htmp             wcz
	byte	$b9, $b3, $1a, $f2
'-'         if_b    jmp     #.framewait
	byte	$f8, $ff, $9f, $cd
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - source address.
'-' '   PB - destination address.
'-' '   hr0 - length of copy, in bytes.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hmemcpy
'-'                 rdbyte  htmp, ptra++
	byte	$61, $73, $c7, $fa
'-'                 wrbyte  htmp, pb
	byte	$f7, $73, $43, $fc
'-'                 add     pb, #1
	byte	$01, $ee, $07, $f1
'-'         _ret_   djnz    hr0, #hmemcpy
	byte	$fc, $87, $6f, $0b
'-' 
'-' '------------------------------------------------------------------------------
'-' ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
'-' ' loop until the errant device is disconnected.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' host_error
'-'           if ERROR_LED >= 0
'-'           end
'-'                 jmp     #host_reset                     ' See if it works...
	byte	$a0, $07, $90, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get HID descriptor buffer for current port
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   PB - HID descriptor buffer pointer
'-' '------------------------------------------------------------------------------
'-' get_hid_descr_buffer
'-'                 mov     pb, hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb, #1
	byte	$01, $ee, $e7, $f2
'-'                 mul     pb, #HID_DESCR_LEN
	byte	$00, $ef, $07, $fa
'-'         _ret_   add     pb, hid_descr_p
	byte	$25, $ef, $03, $01
'-' 
'-' 
'-' usb16_poly_r    long    USB16_POLY
	byte	$01, $a0, $00, $00
'-' 
'-' ' USB commands and error codes
'-' cmd_data        long    0
	byte	$00, $00, $00, $00
'-' usb_err_code    long    ERR_NONE
	byte	$00, $00, $00, $00
'-' 
'-' ' Parameters block assigned at cog startup
'-' dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
	byte	$12, $00, $00, $00
'-' dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
	byte	$13, $00, $00, $00
'-' usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
	byte	$11, $00, $00, $00
'-' if ACTIVITY_LED >= 0
'-' host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
'-' end
'-' if ERROR_LED >= 0
'-' host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
'-' end
'-' hid_descr_p     long    0
	byte	$00, $00, $00, $00
'-' 'hid_report_p    long    0, 0[MAX_DEVICES]
'-' 'hkbd_report_p   long    0
'-' hub_descr_p     long    0
	byte	$00, $00, $00, $00
'-' urx_buff_p      long    0
	byte	$00, $00, $00, $00
'-' dev_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' con_desc_buff_p long    0
	byte	$00, $00, $00, $00
'-' cache_start_p   long    0
	byte	$00, $00, $00, $00
'-' cache_end_p     long    0
	byte	$00, $00, $00, $00
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_out_ptr  long    0
'-' end
'-' save_sysclk     long    0         ' Save the current sysclock as the client may change it
	byte	$00, $00, $00, $00
'-' 
'-' hdev_init_start
'-' hdev_port       res     1
'-' hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
'-' kbm_next_datax  res     1
'-' hub_intf_num    res     1
'-' hub_next_datax  res     1
'-' hub_status_chg  res     1
'-' hub_port_status res     1
'-' if HAVE_MOUSE
'-' ms_intf_num     res     1
'-' ms_in_max_pkt   res     1
'-' end
'-' kb_intf_num     res     1
'-' kb_interval     res     1
'-' kb_in_max_pkt   res     1
'-' kb_max_index    res     1
'-' kb_led_states   res     1
'-' gp_intf_num     res     1
'-' gp_interval     res     1
'-' gp_max_index    res     1
'-' gp_descr_len    res     1+MAX_DEVICES
'-' hdev_init_end
'-' 
'-' ' Initialized at cog startup:
'-' hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
'-' iframe_ct_new   res     1
'-' iframe_ct_base  res     1
'-' utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
'-' 
'-' ' This register block is reset to zero when a USB device connects
'-' hreg_init_start
'-' hstatus         res     1         ' Host status flags
'-' hctwait         res     1         ' Poll-based wait clocks
'-' ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
'-' tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
'-' nak_retry       res     1         ' NAK retry count, unlimited retries if zero
'-' xfer_retry      res     1         ' Control transfer retry count
'-' retry           res     1         ' Transaction retry count
'-' utx             res     1         ' Byte to transmit on USB
'-' urx             res     1         ' LSByte receiver status flags, MSByte received data
'-' newb_flg        res     1         ' Receive "new byte" bit toggle detector
'-' max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
'-' total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
'-' stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
'-' pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
'-' frame           res     1         ' USB 1ms frame counter value
'-' sof_pkt         res     1         ' ISR frame# packet and CRC5
'-' icrc            res     1         ' Only used by the 1ms frame output ISR routine
'-' pkt_cnt         res     1         ' Count of DATAx packet payload bytes
'-' crc             res     1         ' Used for CRC16 calculation
'-' ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
'-' retval          res     1         ' Global success/fail return parameter
'-' context_retval  res     1         ' Operation contextual return parameter
'-' ' Device stuff
'-' hdev_id         res     1+MAX_DEVICES
'-' hdev_bcd        res     1
'-' hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
'-' ' Keyboard/mouse stuff
'-' hctrl_ep_addr   res     1
'-' hctrl_max_pkt   res     1
'-' hconfig_base    res     1
'-' hcon_tot_len    res     1         ' Size of the complete config descriptor chain
'-' hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
'-' hdev_class      res     1
'-' hdev_subclass   res     1
'-' hdev_protocol   res     1
'-' hsearch_key     res     1         ' Descriptor type to search for in the config chain
'-' hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
'-' hhub_ctrl_ep    res     1         ' Hub control endpoint address
'-' hhub_ep_addr    res     1         ' Hub interface endpoint address
'-' hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
'-' hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
'-' if HAVE_MOUSE
'-' hmouse_ep_addr  res     1 ' Mouse interface endpoint address
'-' end
'-' hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
'-' hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
'-' hdev_ep_addr    res     1+MAX_DEVICES
'-' hdev_out_addr   res     1
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_buffer res EMUPAD_MAX_PLAYER
'-' hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
'-' end
'-' 
'-' hreg_init_end
'-' 
'-' hidr_start
'-' hidr_usage      res     1 ' <- can get trashed after parsing
'-' hidr_flags      res     1
'-' hidr_axis       res     4
'-' hidr_buttons    res     1
'-' hidr_hats       res     1
'-' '' Above are actually useful values, 6 longs
'-' hidr_type       res     1
'-' hidr_id         res     1
'-' hidr_offset     res     1
'-' hidr_usage_idx  res     1
'-' ' below need to be push/pop'd
'-' hidr_state      res     1
'-' hidr_size       res     1
'-' hidr_count      res     1
'-' hidr_lminmax    res     1
'-' hidr_pminmax    res     1
'-' hidr_end
'-' 
'-' ' Variables dependent on the system freqency
'-' _var_64_lower_  res     1
'-' _var_64_upper_  res     1
'-' _12Mbps_        res     1
'-' _1_5Mbps_       res     1
'-' _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
'-' _1us_           res     1         ' 1us
'-' _10us_          res     1         ' 10us
'-' _33us_          res     1         ' 33us
'-' _txn_err_       res     1         ' 250us
'-' _500us_         res     1         ' 500us
'-' _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
'-' _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
'-' _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
'-' _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
'-' _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
'-' _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
'-' _preamble_wait_ res     1
'-' _1ms_           res     1         ' 1ms
'-' _2ms_           res     1         ' 2ms
'-' _suspend_wait_  res     1         ' 3ms
'-' _4ms_           res     1         ' 4ms
'-' _xfer_wait_     res     1         ' 5ms
'-' _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
'-' _reset_hold_    res     1         ' 15ms
'-' _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
'-' _21ms_          res     1         ' 21ms
'-' _100ms_         res     1         ' 100ms
'-' _500ms_         res     1         ' 500ms
'-' _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
'-' _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
'-' '------------------------------------------------------------------------------
'-' _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
'-' _usb_d_ls_nco_  res     1
'-' _usb_h_fs_nco_  res     1
'-' _usb_d_fs_nco_  res     1
'-' '------------------------------------------------------------------------------
'-' ' Scratch registers
'-' htmp            res     1         ' Scratch registers whose context remains within the same code block
'-' htmp1           res     1
'-' htmp2           res     1
'-' htmp3           res     1
'-' hrep            res     1         ' Repeat count
'-' hsave0          res     1         ' Subroutine parameter saves
'-' hsave1          res     1
'-' hsave2          res     1
'-' isrtmp1         res     1
'-' pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
'-' hr0             res     1         ' Multi-purpose registers
'-' hr1             res     1
'-' hr2             res     1
'-' hr3             res     1
'-' hpar1           res     1         ' Routine entry/exit parameters
'-' hpar2           res     1
'-' hpar3           res     1
'-' hct2            res     1         ' Function response bus turn-around timer
'-' hct3            res     1         ' Keyboard/mouse poll timer
'-' mod_cnt         res     1         ' Used in idle loops
'-' 
'-'                 fit     $1F0
'-'                 fit     $1F0
'-'                 org     $200
'-' hlut_start
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Full-speed is the host's native speed, so all that is needed is to set the FS
'-' ' settings to startup defaults.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: Save/restore caller C flag state if C is changed in this routine!
'-' '------------------------------------------------------------------------------
'-' set_speed_full
'-'                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$d0, $e8, $07, $f6
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
	byte	$a6, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
	byte	$a4, $9b, $02, $06
'-' '                ret                             wcz     ' Restore caller flags on exit
'-' 
'-' '------------------------------------------------------------------------------
'-' ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
'-' ' is a downstream hub connected (not yet implemented), the baud generator
'-' ' remains set at the full-speed rate, but signaling is switched to low-speed,
'-' ' which reverses the D-/D+ polarity. The polarity can be changed without
'-' ' putting the smart pins into reset.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit: CZ flags restored to caller states
'-' '------------------------------------------------------------------------------
'-' set_speed_low
'-'                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
	byte	$80, $96, $ce, $f7
'-'         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
	byte	$ed, $e8, $07, $a6
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
	byte	$22, $6b, $13, $fc
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $f6
'-'                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
	byte	$02, $96, $26, $f4
'-'                 ret                             wcz     ' Restore caller flags on exit
	byte	$2d, $00, $7c, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform configuration stuff required when a device intitially connects.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' on_connect
'-'                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$02, $86, $07, $f6
'-'                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
	byte	$d8, $fb, $bf, $fd
'-' .retry
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
	byte	$01, $8e, $07, $c6
'-'         if_nc   mov     hpar1, #USB_SPEED_FULL
	byte	$02, $8e, $07, $36
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$20, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$f4, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.get_dev_desc
	byte	$18, $00, $90, $ad
'-'                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
	byte	$b2, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$4c, $03, $b0, $fd
'-'                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
	byte	$01, $86, $8f, $f1
'-'         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
	byte	$f0, $fb, $9f, $ad
'-'                 call    #reset                          ' Try another reset to see if the device responds
	byte	$a4, $fb, $bf, $fd
'-'                 jmp     #.retry
	byte	$b8, $ff, $9f, $fd
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 mov     hctwait, _1ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
	byte	$28, $03, $b0, $fd
'-'                 call    #reset
	byte	$88, $fb, $bf, $fd
'-'                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
	byte	$38, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
	byte	$01, $11, $5c, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$d8, $01, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ad, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$04, $03, $b0, $fd
'-'                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
	byte	$04, $00, $00, $ff, $00, $bc, $06, $f6
'-'                 call    #calc_crc5
	byte	$34, $fa, $bf, $fd
'-'                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
	byte	$20, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$78, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to idle if not ACK
	byte	$2d, $00, $64, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
	byte	$07, $db, $c6, $fa
'-'                 mov     hctwait, _500us_
	byte	$a0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $02, $b0, $fd
'-'                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$28, $1e, $c0, $fe
'-'                 add     ptra, hcog_base_addr
	byte	$47, $f1, $03, $f1
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$48, $00, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $87, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $89, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $73, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $86, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $88, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $73, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #host_error
	byte	$2c, $fb, $9f, $cd
'-'                 loc     pa, #@init_kbdm_data - @usb_host_start
	byte	$24, $13, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-'                 loc     pa, #@hparse_con_desc - @usb_host_start
	byte	$b8, $0d, $80, $fe
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 jmp     pa
	byte	$2c, $ec, $63, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
'-' ' Status reporting is always in the function-to-host direction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - start address of the SETUP data in hub.
'-' '   PB - start address of the buffer/struct to be written to during the IN data
'-' '     stage.
'-' '   ep_addr_pid - device address, endpoint and CRC5.
'-' ' On exit:
'-' '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
'-' '     contains the count of data stage bytes actually received, which must
'-' '     always be <= the count requested.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_read
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8f, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $91, $03, $f6
'-'                 mov     hpar3, pb                       ' Save dest buffer pointer
	byte	$f7, $93, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$c0, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' Back to caller to handle error
	byte	$2d, $00, $64, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$90, $01, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 mov     nak_retry, ##IN_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
	byte	$55, $b1, $02, $16
'-' .nak_retry
'-'                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
	byte	$0c, $a2, $06, $f6
'-' .in_retry
'-'                 call    #txn_in
	byte	$bc, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$28, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$a8, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$14, $02, $b0, $fd
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak_retry                     ' Function not ready to send data
	byte	$dc, $ff, $9f, $ad
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$94, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.in_retry                      ' Bus error retry
	byte	$d0, $ff, $9f, $5d
'-'                 ret                                     ' The transfer has failed
	byte	$2d, $00, $64, $fd
'-' .commit
'-'                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
	byte	$00, $b8, $0e, $f2
'-'         if_z    jmp     #.pre_status                    ' and also end-of-data
	byte	$38, $00, $90, $ad
'-'                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
	byte	$27, $f1, $03, $f6
'-'                 mov     hr0, pkt_cnt
	byte	$5c, $87, $03, $f6
'-'                 cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $f2
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$6c, $fa, $bf, $5d
'-'                 add     stage_data, pkt_cnt             ' Update bytes received on commit
	byte	$5c, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
	byte	$56, $af, $0a, $f2
'-'         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
	byte	$1c, $00, $90, $ad
'-'                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
	byte	$58, $b9, $1a, $f2
'-'         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
	byte	$14, $00, $90, $cd
'-'         if_a    mov     retval, #ERR_PACKET
	byte	$04, $be, $06, $16
'-'         if_a    mov     context_retval, retval          ' In this case overall and context are the same
	byte	$5f, $c1, $02, $16
'-'         if_a    ret                                     ' Caller must handle ERR_PACKET
	byte	$2d, $00, $64, $1d
'-'                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $f4
'-'                 jmp     #.data                          ' Start next IN transaction
	byte	$78, $ff, $9f, $fd
'-' .pre_status
'-'                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
	byte	$57, $ad, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $f8
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-'                 mov     nak_retry, ##OUT_NAK_RETRIES
	byte	$61, $00, $00, $ff, $50, $9f, $06, $f6
'-' .out_retry
'-'                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
	byte	$34, $f7, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    ret                                     ' All is good when ACK
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
	byte	$18, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$84, $01, $b0, $fd
'-'                 cmp     retval, #ERR_NAK        wz
	byte	$08, $be, $0e, $f2
'-'         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
	byte	$d8, $ff, $9f, $5d
'-'                 ret                                     ' Caller must handle transfer retirement
	byte	$2d, $00, $64, $fd
'-' ' I've encountered transfer STALL, even though the data looks correct, and
'-' ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
'-' ' ControlRead() transfer gets things unstuck most of the time...
'-' .xfer_retry
'-'                 mov     hctwait, _xfer_wait_
	byte	$ac, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$58, $01, $b0, $fd
'-'                 call    #wait_txn_ok
	byte	$8c, $f9, $bf, $fd
'-'                 mov     ep_addr_pid, hpar1
	byte	$c7, $bd, $02, $f6
'-'                 mov     ptra, hpar2
	byte	$c8, $f1, $03, $f6
'-'                 mov     pb, hpar3
	byte	$c9, $ef, $03, $f6
'-'                 djnz    xfer_retry, #.xfer_start
	byte	$bb, $a1, $6e, $fb
'-'                 mov     context_retval, retval          ' Preserve the USB error code
	byte	$5f, $c1, $02, $f6
'-'         _ret_   mov     retval, #ERR_XFER_RETRY
	byte	$07, $be, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
'-' ' reporting is always in the function-to-host direction. It is assumed that
'-' ' the SETUP data struct is filled with the required values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRA - points to the start of the struct for the SETUP data.
'-' '   PB - the start address of the struct/buffer to be read for the OUT data
'-' '     stage.
'-' '   ep_addr_pid - the proper CRC'd address and endpoint to use.
'-' ' On exit:
'-' '   retval - used to convey the success/failure of each stage.
'-' '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
'-' '     more specific USB operation error code.
'-' '------------------------------------------------------------------------------
'-' control_write
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $27, $c4
'-' 
'-'                 mov     hpar1, ep_addr_pid
	byte	$5e, $8f, $03, $f6
'-'                 mov     hpar2, ptra
	byte	$f8, $91, $03, $f6
'-'                 mov     hpar3, pb
	byte	$f7, $93, $03, $f6
'-'                 mov     xfer_retry, #XFER_RETRIES
	byte	$0c, $a0, $06, $f6
'-' .xfer_start
'-'                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
	byte	$00, $9e, $06, $f6
'-'                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
	byte	$03, $ad, $e6, $fa
'-'                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
	byte	$84, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
	byte	$ec, $00, $90, $5d
'-'                 cmp     total_data, #0          wz
	byte	$00, $ac, $0e, $f2
'-'         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
	byte	$54, $00, $90, $ad
'-'                 mov     stage_data, #0                  ' Prepare for data stage
	byte	$00, $ae, $06, $f6
'-'                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
	byte	$e1, $bc, $c6, $f8
'-'                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .data
'-'                 mov     pkt_data, total_data
	byte	$56, $b1, $02, $f6
'-'                 sub     pkt_data, stage_data
	byte	$57, $b1, $82, $f1
'-'                 cmp     pkt_data, max_pkt_size  wcz
	byte	$55, $b1, $1a, $f2
'-'         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
	byte	$55, $b1, $02, $16
'-' .out_retry
'-'                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
	byte	$f7, $f1, $03, $f6
'-'                 call    #txn_out
	byte	$88, $f6, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit                        ' Function got the data
	byte	$10, $00, $90, $ad
'-'                 call    #retry_wait                     ' Wait a bit before retry
	byte	$e0, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.out_retry
	byte	$e4, $ff, $9f, $5d
'-'                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
	byte	$a4, $00, $90, $fd
'-' .commit
'-'                 mov     pb, ptra                        ' Save the current buffer/struct location
	byte	$f8, $ef, $03, $f6
'-'                 add     stage_data, pkt_data
	byte	$58, $af, $02, $f1
'-'                 cmp     stage_data, total_data  wz
	byte	$56, $af, $0a, $f2
'-'         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
	byte	$03, $96, $e6, $54
'-'         if_nz   jmp     #.data                          ' More data to send
	byte	$bc, $ff, $9f, $5d
'-' pre_status_in
'-'                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
	byte	$03, $96, $26, $f4
'-'                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
	byte	$0c, $a2, $06, $f6
'-' .status_retry
'-'                 mov     pkt_data, #0
	byte	$00, $b0, $06, $f6
'-'                 call    #txn_in
	byte	$44, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
	byte	$d2, $be, $0e, $f2
'-'         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
	byte	$00, $b0, $0e, $a2
'-'         if_z    jmp     #dwnstream_reset                ' Control Write finished
	byte	$74, $00, $90, $ad
'-'                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 call    #retry_wait                     ' NAK or bus error, so delay a bit
	byte	$98, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_nz   jmp     #.status_retry
	byte	$d8, $ff, $9f, $5d
'-' '               ret                                     ' Caller must handle transfer retirement
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - The function address and endpoint for the IN request.
'-' '   hpar2 - Address of the IN data buffer
'-' '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
'-' ' On exit:
'-' '   retval - the result of the operation.
'-' '   hpar3 - the count of IN data bytes actually received.
'-' '------------------------------------------------------------------------------
'-' do_int_in
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $27, $c4
'-' 
'-'                 getword htmp, hpar3, #0
	byte	$c9, $73, $33, $f9
'-'                 cmp     htmp, #PID_DATA0        wz
	byte	$c3, $72, $0f, $f2
'-'                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
	byte	$03, $96, $a6, $f4
'-'                 mov     retry, #TXN_RETRIES
	byte	$0c, $a2, $06, $f6
'-' .retry
'-'                 getword pkt_data, hpar3, #1             ' IN max packet length
	byte	$c9, $b1, $3a, $f9
'-'                 call    #txn_in
	byte	$00, $f5, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' ACK if data received
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.commit
	byte	$1c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
	byte	$5a, $be, $0e, $f2
'-'         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
	byte	$1e, $be, $0e, $52
'-'         if_z    jmp     #.post_ret                      ' The caller must handle either
	byte	$24, $00, $90, $ad
'-'                 call    #retry_wait
	byte	$54, $00, $b0, $fd
'-'                 cmp     retval, #ERR_TXN_RETRY  wz
	byte	$06, $be, $0e, $f2
'-'         if_z    jmp     #.post_ret
	byte	$18, $00, $90, $ad
'-'                 jmp     #.retry
	byte	$d4, $ff, $9f, $fd
'-' .commit
'-'                 mov     ptra, urx_buff_p                ' Copy the rx buffer
	byte	$27, $f1, $03, $f6
'-'                 mov     pb, hpar2                       ' to the destination buffer
	byte	$c8, $ef, $03, $f6
'-'                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
	byte	$5c, $87, $0b, $f6
'-'         if_nz   cmp     ptra, pb                wz
	byte	$f7, $f1, $0b, $52
'-'         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
	byte	$c0, $f8, $bf, $5d
'-' .post_ret
'-'                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
	byte	$5c, $93, $03, $f6
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Resets the downstream hub port to FS
'-' '------------------------------------------------------------------------------
'-' dwnstream_reset
'-'                 testb   ep_addr_pid, #31        wc
	byte	$1f, $bc, $16, $f4
'-'         if_nc   ret                                     ' No LS device, reset not needed
	byte	$2d, $00, $64, $3d
'-' 
'-'                 bitl    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $07, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6f, $13, $fc
'-'                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a6, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a4, $9b, $02, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The one millisecond frame timer is implemented as an interrupt service
'-' ' routine. Since this timing is critical, care must be taken to avoid any
'-' ' instructions that can delay the interrupt branch, which will likely upset
'-' ' the timer. WAITX is among those instructions, so any time you're inside
'-' ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hctwait - wait interval in sysclocks.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' poll_waitx
'-'                 getct   hct2
	byte	$1a, $94, $63, $fd
'-'                 addct2  hct2, hctwait
	byte	$4c, $95, $6b, $fa
'-' .wait
'-'                 jnct2   #.wait
	byte	$ff, $25, $cc, $fb
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Transaction retry handling for NAK/STALL or bus error.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - transaction response PID or error code.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' retry_wait
'-'                 cmp     retval, #PID_STALL      wz
	byte	$1e, $be, $0e, $f2
'-'         if_z    ret                                     ' STALL is special case
	byte	$2d, $00, $64, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_z    jmp     #.nak
	byte	$14, $00, $90, $ad
'-'                 mov     hctwait, _txn_err_              ' Transaction error wait...
	byte	$9f, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$d8, $ff, $bf, $fd
'-' .dec
'-'                 sub     retry, #1               wz
	byte	$01, $a2, $8e, $f1
'-'         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
	byte	$06, $be, $06, $a6
'-'                 ret                                     ' Retry result to caller
	byte	$2d, $00, $64, $fd
'-' .nak
'-'                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
	byte	$9e, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$c4, $ff, $bf, $fd
'-'                 cmp     nak_retry, #NAK_NOLIMIT wz
	byte	$00, $9e, $0e, $f2
'-'         if_z    ret                                     ' Indefinite NAK retries
	byte	$2d, $00, $64, $ad
'-'                 sub     nak_retry, #1           wz
	byte	$01, $9e, $8e, $f1
'-'         if_z    mov     retval, #ERR_NAK
	byte	$08, $be, $06, $a6
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' host_reset
'-'                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
	byte	$25, $00, $64, $fd
'-'                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
	byte	$14, $72, $07, $fb
'-' ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
'-'                 cmp     htmp, ##168_000_000     wcz
	byte	$bd, $01, $05, $ff, $00, $72, $1f, $f2
'-'         if_be   mov     utx_tweak, #0
	byte	$00, $94, $06, $e6
'-'         if_a    mov     utx_tweak, #3   '#20
	byte	$03, $94, $06, $16
'-' ' Check to see if the system clock has been changed.
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $73, $0b, $f2
'-'         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $5e
'-'         if_nz   add     pb, hcog_base_addr
	byte	$47, $ef, $03, $51
'-'         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $5d
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-' 
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
	byte	$22, $6f, $13, $fc
'-' .enable
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 waitx   _1us_
	byte	$1f, $38, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 ' Handle Port protection enable and startup delay
'-'                 cmps    usb_enable_pin, #0      wc
	byte	$00, $48, $56, $f2
'-'         if_ae   drvl    usb_enable_pin                 ' disable port
	byte	$58, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Wait a while for everything to turn off
	byte	$1f, $60, $63, $fd
'-'         if_ae   drvh    usb_enable_pin                  ' Enable the port
	byte	$59, $48, $62, $3d
'-'                 waitx   _21ms_                          ' Hold to let the idle state get settled
	byte	$1f, $60, $63, $fd
'-' 
'-'                 'call #dev_reset ' TODO THINK ABOUT THIS
'-' 
'-' discon_entry
'-'                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
	byte	$03, $98, $07, $f6
'-' 
'-'                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
	byte	$4b, $ed, $b7, $f9
'-'                 rep     @.regloop,#hreg_init_end - hreg_init_start
	byte	$3b, $04, $dc, $fc
'-'                 alti    pa, #%000_111_000
	byte	$38, $ec, $a7, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' .regloop
'-'               
'-'         if HAVE_HIDPAD
'-'                 loc     pb, #@hidpad_report - @usb_host_start
	byte	$f8, $27, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
	byte	$28, $6e, $64, $fd
'-'                 wrlong  #0,pb
	byte	$f7, $01, $68, $fc
'-'         end
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-'                 ' Fall through to disconnected loop
'-' 
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' Device connect handling (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
'-' ' device to connect (Section 7.1.7.3).
'-' '-----------------------------------------------------------------------------------------------------------------
'-' disconnected
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
	byte	$14, $88, $07, $fb
'-'                 cmp     hr1, save_sysclk        wz
	byte	$2c, $89, $0b, $f2
'-'         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
	byte	$6c, $ff, $9f, $5d
'-'                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
	byte	$03, $88, $47, $f0
'-'                 waitx   hr1                             ' it down to smaller wait chunks
	byte	$1f, $88, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
	byte	$e0, $ff, $9f, $ad
'-'         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
	byte	$28, $00, $90, $5d
'-' .se1_test
'-'                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$fc, $fe, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
	byte	$00, $be, $06, $56
'-'         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
	byte	$a0, $ff, $9f, $5d
'-' .se1            'SE1 is a fatal error condition
'-'                 mov     hctwait, _100ms_
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$e4, $fe, $bf, $fd
'-'                 mov     retval, #ERR_SE1
	byte	$03, $be, $06, $f6
'-'                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
	byte	$88, $f7, $bf, $fd
'-' .connect_test                                           ' Test lines until stable J/K state seen
'-'                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
	byte	$1f, $62, $63, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 and     urx, #J_IDLEF | K_RESUMEF wcz
	byte	$03, $a6, $1e, $f5
'-'         if_z    jmp     #discon_entry                   ' D+ and D- low
	byte	$80, $ff, $9f, $ad
'-'         if_e    jmp     #.se1_test                      ' D+ and D- high
	byte	$c4, $ff, $9f, $ad
'-' connected
'-'                 bith    hstatus, #CONNECTEDB            ' Device plugged in
	byte	$01, $96, $26, $f4
'-'                 call    #on_connect                     ' Initial device configuration
	byte	$34, $fb, $bf, $fd
'-'                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #discon_entry
	byte	$6c, $ff, $9f, $5d
'-' .set_pulse
'-'                 getct   _pulse_time_
	byte	$1a, $66, $63, $fd
'-'                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
	byte	$b2, $67, $03, $f1
'-' ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
'-' ' of 1ms and make a correction, if necessary.
'-' '                mov     htmp, _1ms_
'-' '                subs    htmp, iframe_delta
'-' '                adds    _frame1ms_clks_, htmp
'-' '                debug(udec(_frame1ms_clks_))
'-' 
'-'                 ' Fall through to idle/processing loop
'-'                 cmp     hdev_port, #MAX_DEVICES wcz
	byte	$07, $5a, $1e, $f2
'-'         if_a    mov     hdev_port, #0 
	byte	$00, $5a, $06, $16
'-' 
'-' hidle
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_c    jmp     #.se0_test
	byte	$98, $00, $90, $cd
'-'                 pollct3                         wc
	byte	$24, $06, $70, $fd
'-'         if_nc   jmp     #.nopoll
	byte	$68, $00, $90, $3d
'-'                 getct   hct3
	byte	$1a, $96, $63, $fd
'-'                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
	byte	$a8, $97, $73, $fa
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $72, $e3, $f8
'-' 
'-'                 cmp     htmp, #HUB_READY        wz
	byte	$09, $72, $0f, $f2
'-'         if_z    loc     pa, #@hget_hub_status - @usb_host_start
	byte	$8c, $1b, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$40, $00, $90, $ad
'-' 
'-'         if _HAVE_GAMEPAD
'-'                 cmp     htmp, #HID_READY        wz
	byte	$06, $72, $0f, $f2
'-'         if_nz   cmp     htmp, #PS3_READY        wz
	byte	$08, $72, $0f, $52
'-'         if_nz   cmp     htmp, #XINPUT_READY     wz
	byte	$07, $72, $0f, $52
'-'         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
	byte	$f4, $15, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$2c, $00, $90, $ad
'-'         end
'-' 
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $72, $0f, $f2
'-'         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$44, $15, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$20, $00, $90, $ad
'-'         end
'-' 
'-'                 cmp     htmp, #KB_READY         wz
	byte	$03, $72, $0f, $f2
'-'         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$ac, $13, $80, $ae
'-'         if_z    jmp     #.poll
	byte	$14, $00, $90, $ad
'-' 
'-'                 cmp     htmp, #KBM_READY        wz
	byte	$05, $72, $0f, $f2
'-'         if_nz   jmp     #.skip_poll
	byte	$14, $00, $90, $5d
'-'                 bitnot  hstatus, #KBM_TOGGLEB   wcz
	byte	$09, $96, $fe, $f4
'-'         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
	byte	$ac, $13, $80, $3e
'-'         if HAVE_MOUSE
'-'         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
	byte	$44, $15, $80, $ce
'-'         else
'-'         end
'-' 
'-' .poll
'-'                 add     pa, hcog_base_addr
	byte	$47, $ed, $03, $f1
'-'                 call    pa
	byte	$2d, $ec, $63, $fd
'-' .skip_poll
'-' 
'-'                 incmod  hdev_port, #MAX_DEVICES
	byte	$07, $5a, $06, $f7
'-' 
'-' .nopoll
'-'                 cmp     cmd_data, #CMD_SUSPEND  wz
	byte	$0e, $40, $0e, $f2
'-'         if_z    jmp     #hsuspend
	byte	$44, $00, $90, $ad
'-'                 cmp     cmd_data, #CMD_RESET    wz
	byte	$10, $40, $0e, $f2
'-'         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
	byte	$00, $40, $06, $a6
'-'         if_z    jmp     #host_reset                     ' See if it works...
	byte	$68, $fe, $9f, $ad
'-'                 getct   hr0
	byte	$1a, $86, $63, $fd
'-'                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
	byte	$b3, $87, $1b, $f2
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'         if_ae   getct   _pulse_time_
	byte	$1a, $66, $63, $3d
'-'         if_ae   add     _pulse_time_, _500ms_
	byte	$b2, $67, $03, $31
'-'                 jmp     #hidle
	byte	$5c, $ff, $9f, $fd
'-' ' Check for extended SE0 state on the bus
'-' .se0_test
'-'                 mov     hctwait, _1ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
	byte	$fc, $fd, $bf, $fd
'-'                 rqpin   urx, dm
	byte	$22, $a7, $82, $fa
'-'                 testb   urx, #SE0_RESETB        wc
	byte	$02, $a6, $16, $f4
'-'         if_nc   jmp     #hidle                          ' Bus still IDLE
	byte	$48, $ff, $9f, $3d
'-'                 call    #wait_txn_ok
	byte	$24, $f6, $bf, $fd
'-'                 wypin   ##OUT_IDLE, dm                  ' Float USB
	byte	$00, $00, $80, $ff, $22, $01, $28, $fc
'-'                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
'-'                 jmp     #discon_entry                   ' Device disconnected
	byte	$94, $fe, $9f, $fd
'-' 
'-' hsuspend
'-'                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
	byte	$14, $f6, $bf, $fd
'-'                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
	byte	$25, $00, $64, $fd
'-'                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
	byte	$1f, $54, $63, $fd
'-'                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
	byte	$22, $01, $28, $fc
'-'                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
	byte	$00, $40, $06, $f6
'-'                 mov     mod_cnt, #0
	byte	$00, $98, $07, $f6
'-' 
'-'                 ' Fall through to resume wait loop
'-' 
'-' hwait_resume
'-'                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
	byte	$14, $88, $07, $fb
'-'                 shr     hr1, #2
	byte	$02, $88, $47, $f0
'-'                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
	byte	$1f, $88, $63, $fd
'-'         if ACTIVITY_LED >= 0
'-'         end
'-'                 cmp     cmd_data, #CMD_RESUME   wz
	byte	$0f, $40, $0e, $f2
'-'         if_nz   jmp     #hwait_resume
	byte	$ec, $ff, $9f, $5d
'-'                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
	byte	$14, $72, $07, $fb
'-'                 cmp     htmp, save_sysclk       wz
	byte	$2c, $73, $0b, $f2
'-'         if_z    jmp     #.resume
	byte	$18, $00, $90, $ad
'-'                 loc     pb, #@hinit_usb_timings - @usb_host_start
	byte	$c4, $0b, $a0, $fe
'-'                 add     pb, hcog_base_addr
	byte	$47, $ef, $03, $f1
'-'                 call    pb                              ' Recalculate sysclk dependent timing values
	byte	$2d, $ee, $63, $fd
'-'                 testb   hstatus, #LOW_SPEEDB    wc
	byte	$02, $96, $16, $f4
'-'         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
	byte	$22, $6f, $13, $3c
'-'         if_c    wxpin   _usb_h_ls_nco_, dm
	byte	$22, $6b, $13, $cc
'-' .resume
'-'                 wypin   #OUT_K, dm
	byte	$22, $05, $28, $fc
'-'                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
	byte	$1f, $5e, $63, $fd
'-'                 wypin   #OUT_SE0, dm
	byte	$22, $03, $28, $fc
'-'                 mov     htmp, _ip_delay_ls_
	byte	$a3, $73, $03, $f6
'-'                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
	byte	$01, $72, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $72, $63, $fd
'-'                 wypin   #OUT_J, dm
	byte	$22, $07, $28, $fc
'-'                 shr     htmp, #1
	byte	$01, $72, $47, $f0
'-'                 waitx   htmp
	byte	$1f, $72, $63, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-'                 getct   iframe_ct_base
	byte	$1a, $92, $62, $fd
'-'                 mov     iframe_ct_new, iframe_ct_base
	byte	$49, $91, $02, $f6
'-'                 addct1  iframe_ct_new, _frame1ms_clks_
	byte	$b4, $91, $62, $fa
'-'                 setint1 #1                              ' Enable the 1ms frame ISR
	byte	$25, $02, $64, $fd
'-'                 mov     hctwait, _4ms_
	byte	$ab, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
	byte	$50, $fd, $bf, $fd
'-'         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
	byte	$00, $40, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Send preamble to enable low-speed HUB ports
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '   USB baud rate set to low-speed
'-' '------------------------------------------------------------------------------
'-' utx_pre
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   #0, dm                          ' Disable smartpin mode
	byte	$22, $01, $08, $fc
'-'                 drvl    dm
	byte	$58, $44, $62, $fd
'-'                 drvh    dp
	byte	$59, $46, $62, $fd
'-' 
'-'                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
	byte	$1e, $00, $00, $ff, $80, $72, $07, $f6
'-' 
'-'                 rep     @.l1, #16 + 1
	byte	$11, $08, $dc, $fc
'-'                 shr     htmp, #1        wc
	byte	$01, $72, $57, $f0
'-'         if_nc   setq    #1
	byte	$28, $02, $64, $3d
'-'         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
	byte	$4f, $44, $62, $3d
'-'                 waitx   _preamble_wait_
	byte	$1f, $4e, $63, $fd
'-' .l1
'-' 
'-'                 dirl    dm                              ' Put smart pins into reset
	byte	$40, $44, $62, $fd
'-'                 dirl    dp
	byte	$40, $46, $62, $fd
'-'                 setq    #1
	byte	$28, $02, $64, $fd
'-'                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
	byte	$80, $00, $80, $ff, $22, $ed, $08, $fc
'-'                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
	byte	$22, $6b, $13, $fc
'-'                 dirh    dm                              ' Crank them smart pins up
	byte	$41, $44, $62, $fd
'-'                 dirh    dp
	byte	$41, $46, $62, $fd
'-'                 wypin   #OUT_IDLE, dm
	byte	$22, $01, $28, $fc
'-' 
'-'                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
	byte	$08, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
	byte	$a5, $9d, $02, $f6
'-'         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
	byte	$a3, $9b, $02, $06
'-' 
'-' hlut_end
'-'                 fit     $400
'-'                 fit     $400
'-'                 orgh
'-' if OVERLAP_MEMORY
'-'                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
'-' end
'-' '------------------------------------------------------------------------------
'-' ' Routines called from cog space.
'-' '------------------------------------------------------------------------------
'-' ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
'-' '------------------------------------------------------------------------------
'-' 
'-' '------------------------------------------------------------------------------
'-' ' USB host cog initialization.
'-' '------------------------------------------------------------------------------
'-' usb_host_init
'-'                 ' Initialize buffer pointers
'-'         if OVERLAP_MEMORY
'-'         else
'-'                 loc     pb, #hid_descr
	byte	$4c, $15, $b0, $fe
'-'         end
'-'                 mov     hid_descr_p, pb
	byte	$f7, $4b, $02, $f6
'-'                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
'-'                 {
'-'                 }
'-'         
'-'                 {
'-'                 }
'-'                 'loc     pb,#hkbd_report
'-'                 'mov     hkbd_report_p,pb
'-' 
'-'                 loc     pb, #hub_descr
	byte	$44, $1d, $b0, $fe
'-'                 mov     hub_descr_p, pb
	byte	$f7, $4d, $02, $f6
'-'                 loc     pb, #urx_buff
	byte	$59, $1d, $b0, $fe
'-'                 mov     urx_buff_p, pb
	byte	$f7, $4f, $02, $f6
'-'                 loc     pb, #dev_desc_buff
	byte	$d1, $1d, $b0, $fe
'-'                 mov     dev_desc_buff_p, pb
	byte	$f7, $51, $02, $f6
'-'                 loc     pb, #con_desc_buff
	byte	$db, $1d, $b0, $fe
'-'                 mov     con_desc_buff_p, pb
	byte	$f7, $53, $02, $f6
'-'                 loc     pb, #usb_cache_start
	byte	$24, $15, $b0, $fe
'-'                 mov     cache_start_p, pb
	byte	$f7, $55, $02, $f6
'-'                 loc     pb, #usb_cache_end
	byte	$25, $1d, $b0, $fe
'-'                 mov     cache_end_p, pb
	byte	$f7, $57, $02, $f6
'-' 
'-'         if ERROR_LED >= 0
'-'         end
'-' 
'-'                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
'-'                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
'-'                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
'-' ' Configure and enable the Serial Host USB port.
'-'                 jmp     #host_reset                     ' Initialize host and enter main processing loop
	byte	$03, $03, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Timing calculations happen before any interrupt(s) are enabled.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   htmp - current CLKFREQ value.
'-' '------------------------------------------------------------------------------
'-' hinit_usb_timings
'-' '                getct   htmp2
'-'                 mov     save_sysclk, htmp
	byte	$b9, $59, $02, $f6
'-'                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
	byte	$8d, $5b, $80, $ff, $2c, $01, $2a, $fd
'-'                 getqx   _12Mbps_
	byte	$18, $32, $63, $fd
'-'                 shr     _12Mbps_, #16           wc
	byte	$10, $32, $57, $f0
'-'                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
	byte	$00, $32, $27, $f1
'-'                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
	byte	$03, $6e, $07, $f6
'-'                 shl     _usb_h_fs_nco_, #14
	byte	$0e, $6e, $67, $f0
'-'                 add     _usb_h_fs_nco_, _12Mbps_
	byte	$99, $6f, $03, $f1
'-'                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
	byte	$01, $70, $07, $f6
'-'                 shl     _usb_d_fs_nco_, #14
	byte	$0e, $70, $67, $f0
'-'                 add     _usb_d_fs_nco_, _12Mbps_
	byte	$99, $71, $03, $f1
'-'                 mov     _1_5Mbps_, _12Mbps_
	byte	$99, $35, $03, $f6
'-'                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
	byte	$03, $34, $47, $f0
'-'                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
	byte	$02, $6a, $07, $f6
'-'                 shl     _usb_h_ls_nco_, #14
	byte	$0e, $6a, $67, $f0
'-'                 add     _usb_h_ls_nco_, _1_5Mbps_
	byte	$9a, $6b, $03, $f1
'-'                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
	byte	$9a, $6d, $03, $f6
'-'                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
	byte	$80, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2e, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $30, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2e, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1b
	byte	$65, $cd, $1d, $ff, $00, $30, $27, $fd
'-'                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
	byte	$18, $36, $63, $fd
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2e, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $30, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2e, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1m
	byte	$a1, $07, $00, $ff, $40, $30, $27, $fd
'-'                 getqx   _1us_                           ' 1us as 32,9 fixed point
	byte	$18, $38, $63, $fd
'-'                 mov     hsave0, _1us_                   ' Save it to compute other us values
	byte	$9c, $7d, $03, $f6
'-'                 shr     _1us_, #9               wc
	byte	$09, $38, $57, $f0
'-'                 addx    _1us_, #0                       ' Round to final value
	byte	$00, $38, $27, $f1
'-'                 qmul    hsave0, #10                     ' Calc 10us
	byte	$0a, $7c, $07, $fd
'-'                 getqx   _10us_
	byte	$18, $3a, $63, $fd
'-'                 shr     _10us_, #9              wc
	byte	$09, $3a, $57, $f0
'-'                 addx    _10us_, #0                      ' 10us
	byte	$00, $3a, $27, $f1
'-'                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
	byte	$21, $7c, $07, $fd
'-'                 getqx   _33us_
	byte	$18, $3c, $63, $fd
'-'                 shr     _33us_, #9              wc
	byte	$09, $3c, $57, $f0
'-'                 addx    _33us_, #0                      ' 33us
	byte	$00, $3c, $27, $f1
'-'                 qmul    hsave0, #250                    ' Calc 250us
	byte	$fa, $7c, $07, $fd
'-'                 getqx   _txn_err_
	byte	$18, $3e, $63, $fd
'-'                 shr     _txn_err_, #9           wc
	byte	$09, $3e, $57, $f0
'-'                 addx    _txn_err_, #0                   ' 250us
	byte	$00, $3e, $27, $f1
'-'                 qmul    hsave0, #500                    ' Calc 500us
	byte	$f4, $7d, $07, $fd
'-'                 getqx   _500us_
	byte	$18, $40, $63, $fd
'-'                 shr     _500us_, #9             wc
	byte	$09, $40, $57, $f0
'-'                 addx    _500us_, #0                     ' 500us
	byte	$00, $40, $27, $f1
'-'                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
	byte	$01, $00, $00, $ff, $9a, $7c, $07, $fd
'-'                 getqx   _txn_ok_ls_
	byte	$18, $42, $63, $fd
'-'                 shr     _txn_ok_ls_, #9         wc
	byte	$09, $42, $57, $f0
'-'                 addx    _txn_ok_ls_, #0                 ' 666us
	byte	$00, $42, $27, $f1
'-'                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
	byte	$01, $00, $00, $ff, $52, $7d, $07, $fd
'-'                 getqx   _txn_ok_fs_
	byte	$18, $44, $63, $fd
'-'                 shr     _txn_ok_fs_, #9         wc
	byte	$09, $44, $57, $f0
'-'                 addx    _txn_ok_fs_, #0                 ' 850us
	byte	$00, $44, $27, $f1
'-'                 mov     _ip_delay_ls_, _1ns16fp_
	byte	$9b, $47, $03, $f6
'-'                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
	byte	$05, $00, $00, $ff, $80, $46, $07, $fa
'-'                 shr     _ip_delay_ls_, #16      wc
	byte	$10, $46, $57, $f0
'-'                 addx    _ip_delay_ls_, #0
	byte	$00, $46, $27, $f1
'-'                 mov     _tat_wait_ls_, _1ns16fp_
	byte	$9b, $4b, $03, $f6
'-'                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
	byte	$1c, $00, $00, $ff, $c0, $4b, $07, $fa
'-'                 shr     _tat_wait_ls_, #16      wc
	byte	$10, $4a, $57, $f0
'-'                 addx    _tat_wait_ls_, #0
	byte	$00, $4a, $27, $f1
'-'                 mov     _ip_delay_fs_, _1ns16fp_
	byte	$9b, $49, $03, $f6
'-'                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
	byte	$00, $00, $00, $ff, $4e, $49, $07, $fa
'-'                 shr     _ip_delay_fs_, #16      wc
	byte	$10, $48, $57, $f0
'-'                 addx    _ip_delay_fs_, #0
	byte	$00, $48, $27, $f1
'-'                 mov     _tat_wait_fs_, _1ns16fp_
	byte	$9b, $4d, $03, $f6
'-'                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
	byte	$04, $00, $00, $ff, $23, $4d, $07, $fa
'-'                 shr     _tat_wait_fs_, #16      wc
	byte	$10, $4c, $57, $f0
'-'                 addx    _tat_wait_fs_, #0
	byte	$00, $4c, $27, $f1
'-'                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
	byte	$8d, $5b, $00, $ff, $00, $59, $16, $fd
'-'                 getqx   _preamble_wait_
	byte	$18, $4e, $63, $fd
'-'                 sub     _preamble_wait_,# 9 - 1
	byte	$08, $4e, $87, $f1
'-'                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
	byte	$01, $00, $00, $ff, $00, $58, $06, $fd
'-'                 getqx   _var_64_lower_
	byte	$18, $2e, $63, $fd
'-'                 getqy   _var_64_upper_
	byte	$19, $30, $63, $fd
'-'                 setq    _var_64_lower_
	byte	$28, $2e, $63, $fd
'-'                 qfrac   _var_64_upper_, ##_1thou
	byte	$01, $00, $00, $ff, $e8, $31, $27, $fd
'-'                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
	byte	$18, $50, $63, $fd
'-'                 shr     _1ms_, #9               wc
	byte	$09, $50, $57, $f0
'-'                 addx    _1ms_, #0                       ' 1ms
	byte	$00, $50, $27, $f1
'-'                 mov     _frame1ms_clks_, ##-14
	byte	$ff, $ff, $7f, $ff, $f2, $69, $07, $f6
'-'                 adds    _frame1ms_clks_, _1ms_
	byte	$a8, $69, $43, $f1
'-'                 mov     _2ms_, _1ms_
	byte	$a8, $53, $03, $f6
'-'                 shl     _2ms_, #1                       ' 2ms
	byte	$01, $52, $67, $f0
'-'                 mov     _suspend_wait_, _1ms_
	byte	$a8, $55, $03, $f6
'-'                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
	byte	$a8, $55, $03, $f1
'-'                 mov     _4ms_, _1ms_
	byte	$a8, $57, $03, $f6
'-'                 shl     _4ms_, #2                       ' 4ms
	byte	$02, $56, $67, $f0
'-'                 mov     _xfer_wait_, _4ms_
	byte	$ab, $59, $03, $f6
'-'                 add     _xfer_wait_, _1ms_              ' 5ms
	byte	$a8, $59, $03, $f1
'-'                 mov     _reset_hold_, _xfer_wait_       ' 5ms
	byte	$ac, $5d, $03, $f6
'-'                 mov     _resume_hold_, _reset_hold_
	byte	$ae, $5f, $03, $f6
'-'                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
	byte	$02, $5e, $67, $f0
'-'                 mov     _100ms_, _resume_hold_          ' 20ms
	byte	$af, $63, $03, $f6
'-'                 shl     _100ms_, #1                     ' 40ms
	byte	$01, $62, $67, $f0
'-'                 mov     _8ms_, _1ms_
	byte	$a8, $5b, $03, $f6
'-'                 shl     _8ms_, #3                       ' 8ms
	byte	$03, $5a, $67, $f0
'-'                 shl     _reset_hold_, #1                ' 10ms
	byte	$01, $5c, $67, $f0
'-'                 add     _100ms_, _reset_hold_           ' 50ms
	byte	$ae, $63, $03, $f1
'-'                 add     _reset_hold_, _xfer_wait_       ' 15ms
	byte	$ac, $5d, $03, $f1
'-'                 mov     _21ms_, _xfer_wait_             ' 5ms
	byte	$ac, $61, $03, $f6
'-'                 shl     _21ms_, #2                      ' 20ms
	byte	$02, $60, $67, $f0
'-'                 add     _21ms_, _1ms_                   ' 21ms
	byte	$a8, $61, $03, $f1
'-'                 mov     _500ms_, _100ms_                ' 50ms
	byte	$b1, $65, $03, $f6
'-'                 shl     _100ms_, #1                     ' 100ms
	byte	$01, $62, $67, $f0
'-'                 shl     _500ms_, #3                     ' 400ms
	byte	$03, $64, $67, $f0
'-'         _ret_   add     _500ms_, _100ms_                ' 500ms
	byte	$b1, $65, $03, $01
'-' '        _ret_   mov     _1sec_, save_sysclk
'-' '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
'-' '                ret
'-' {
'-' }
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Parse a configuration descriptor chain to see if the device is a recognized
'-' ' one. If it is, start the task progression that will configure the device for
'-' ' use.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hconfig_base - start address of the cached config descriptor chain.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hparse_con_desc
'-'                 mov     ptrb, dev_desc_buff_p
	byte	$28, $f3, $03, $f6
'-'                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
	byte	$82, $73, $07, $fb
'-'                 altr    hdev_port,#hdev_id
	byte	$61, $5b, $86, $f9
'-'                 movbyts htmp,#%%1032
	byte	$4e, $72, $ff, $f9
'-'                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
	byte	$86, $d3, $e6, $fa
'-'                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
'-' 
'-'                 mov     pa, #CON_wTotalLen
	byte	$02, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
	byte	$f6, $df, $e2, $fa
'-'                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
'-' ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
'-' ' that defines a keyboard and/or mouse.
'-'                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
	byte	$6e, $eb, $c2, $fa
'-' .next_intf
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #hset_config
	byte	$b8, $01, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $73, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $72, $0f, $f2
'-'         if_z    jmp     #.intf
	byte	$0c, $00, $90, $ad
'-'                 rdbyte  htmp, ptrb
	byte	$80, $73, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b9, $eb, $02, $f1
'-'                 jmp     #.next_intf
	byte	$d8, $ff, $9f, $fd
'-' .intf
'-'                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
	byte	$00, $90, $07, $f6
'-'                 mov     hpar3, #0
	byte	$00, $92, $07, $f6
'-'                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
	byte	$82, $e1, $c6, $fa
'-'                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
	byte	$85, $e3, $c6, $fa
'-'                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
	byte	$86, $e5, $c6, $fa
'-'                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
	byte	$87, $e7, $c6, $fa
'-'                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
'-' 
'-' .endp
'-'                 rdbyte  htmp, ptrb
	byte	$80, $73, $c7, $fa
'-'                 add     hnext_desc, htmp                ' Get offset of next desc to check
	byte	$b9, $eb, $02, $f1
'-'                 cmp     hnext_desc, hcon_tot_len wcz
	byte	$6f, $eb, $1a, $f2
'-'         if_ae   jmp     #.get_device
	byte	$78, $00, $90, $3d
'-'                 mov     ptrb, hconfig_base
	byte	$6e, $f3, $03, $f6
'-'                 add     ptrb, hnext_desc
	byte	$75, $f3, $03, $f1
'-'                 rdbyte  htmp, ptrb[DESC_bDescType]
	byte	$81, $73, $c7, $fa
'-'                 cmp     htmp, #TYPE_INTERFACE   wz
	byte	$04, $72, $0f, $f2
'-'         if_z    jmp     #.get_device
	byte	$64, $00, $90, $ad
'-'                 cmp     htmp, #TYPE_ENDPOINT    wz
	byte	$05, $72, $0f, $f2
'-'         if_z    jmp     #.get_ep
	byte	$04, $00, $90, $ad
'-'                 jmp     #.endp
	byte	$d0, $ff, $9f, $fd
'-' .get_ep
'-'                 rdbyte  hr1, ptrb[ENDP_bAddress]
	byte	$82, $89, $c7, $fa
'-'                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
	byte	$07, $88, $17, $f4
'-'                 shl     hr1, #8 + 7
	byte	$0f, $88, $67, $f0
'-'                 mov     htmp, hctrl_ep_addr
	byte	$6c, $73, $03, $f6
'-'                 and     htmp, ##ADDR_MASK
	byte	$3f, $00, $00, $ff, $00, $73, $07, $f5
'-'                 or      htmp, hr1                       ' endpoint address
	byte	$c4, $73, $43, $f5
'-'                 cmp     hpar2, #0               wz
	byte	$00, $90, $0f, $f2
'-'  if_z_and_c     jmp     #.in_ep
	byte	$0c, $00, $90, $8d
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'  if_z_and_nc    jmp     #.out_ep
	byte	$18, $00, $90, $2d
'-'                 jmp     #.endp
	byte	$a0, $ff, $9f, $fd
'-' .in_ep
'-'                 mov     hpar2, htmp                     ' IN endpoint
	byte	$b9, $91, $03, $f6
'-'                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8b, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $87, $c7, $fa
'-'                 setbyte hr2, hr0, #3
	byte	$c3, $8b, $db, $f8
'-'                 jmp     #.endp
	byte	$8c, $ff, $9f, $fd
'-' .out_ep
'-'                 mov     hpar3, htmp                     ' OUT endpoint
	byte	$b9, $93, $03, $f6
'-'                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
	byte	$84, $8d, $c7, $fa
'-'                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
'-'                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
	byte	$86, $87, $c7, $fa
'-'                 setbyte hr3, hr0, #3
	byte	$c3, $8d, $db, $f8
'-'                 jmp     #.endp
	byte	$78, $ff, $9f, $fd
'-' 
'-' .get_device
'-'                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
	byte	$ff, $e2, $0e, $f2
'-'         if_z    cmp     hdev_subclass, #$5D     wz
	byte	$5d, $e4, $0e, $a2
'-'         if_z    cmp     hdev_protocol, #$01     wz
	byte	$01, $e6, $0e, $a2
'-'         if_z    jmp     #.gamepad
	byte	$64, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HUB  wz
	byte	$09, $e2, $0e, $f2
'-'         if_z    jmp     #.hub
	byte	$a8, $00, $90, $ad
'-'                 cmp     hdev_class, #CLASS_HID              wz
	byte	$03, $e2, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No HID class, ignore
	byte	$18, $ff, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_z    jmp     #.gamepad
	byte	$4c, $00, $90, $ad
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
	byte	$01, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
	byte	$08, $ff, $9f, $5d
'-' .keyboard
'-'                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
	byte	$01, $e6, $0e, $f2
'-'         if HAVE_MOUSE
'-'         if_nz  jmp      #.mouse                         ' No Keyboard
	byte	$1c, $00, $90, $5d
'-'         else
'-'         end
'-'                 cmp     hkbd_ep_addr, #0    wz
	byte	$00, $f2, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$f8, $fe, $9f, $5d
'-'                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6f, $e2, $f8
'-'                 getbyte kb_interval, hr2, #3
	byte	$c5, $71, $fa, $f8
'-'                 getbyte kb_in_max_pkt, hr2, #0
	byte	$c5, $73, $e2, $f8
'-'                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
	byte	$c8, $f3, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$e4, $fe, $9f, $fd
'-' if HAVE_MOUSE
'-' .mouse
'-'                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
	byte	$02, $e6, $0e, $f2
'-'         if_nz   jmp     #.next_intf                     ' No Mouse
	byte	$dc, $fe, $9f, $5d
'-'                 cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$d4, $fe, $9f, $5d
'-'                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $6b, $e2, $f8
'-'                 'getbyte ms_interval, hr2, #3
'-'                 getbyte ms_in_max_pkt, hr2, #0
	byte	$c5, $6d, $e2, $f8
'-'                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
	byte	$c8, $f5, $02, $f6
'-'                 'debug(udec(kb_intf_num))
'-'                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
'-'                 jmp     #.next_intf
	byte	$c4, $fe, $9f, $fd
'-' end
'-' .gamepad
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $73, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c8, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$b0, $fe, $9f, $ad
'-'         if HAVE_MOUSE
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $73, $03, $f6
'-'                 xor     htmp, hpar2
	byte	$c8, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_z    jmp     #.next_intf
	byte	$9c, $fe, $9f, $ad
'-'         end
'-'                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz      ' |
	byte	$00, $00, $0c, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$90, $fe, $9f, $5d
'-' 
'-'                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
	byte	$70, $79, $e2, $f8
'-'                 getbyte gp_interval, hr2, #3
	byte	$c5, $7b, $fa, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, hpar2                      ' IN endpoint address
	byte	$c8, $01, $00, $f6
'-'                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
	byte	$c9, $0b, $03, $f6
'-'                 'debug(udec(gp_intf_num))
'-'                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
'-'                 jmp     #.next_intf
	byte	$78, $fe, $9f, $fd
'-' .hub
'-'                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
	byte	$00, $e4, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$70, $fe, $9f, $5d
'-'                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
	byte	$00, $e6, $0e, $f2
'-'         if_nz   cmp     hdev_protocol, #2                   wz
	byte	$02, $e6, $0e, $52
'-'         if_nz   jmp     #.next_intf
	byte	$64, $fe, $9f, $5d
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_nz   jmp     #.next_intf
	byte	$5c, $fe, $9f, $5d
'-'                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
	byte	$70, $63, $e2, $f8
'-'                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $ed, $02, $f6
'-'                 mov     ep_addr_pid, hpar2              ' IN endpoint address
	byte	$c8, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 mov     hhub_ep_addr, ep_addr_pid
	byte	$5e, $ef, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
	byte	$6c, $bd, $02, $f6
'-'                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
'-'                 jmp     #.next_intf
	byte	$40, $fe, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' If a newly-connected device is recognized, do whatever is needed to configure
'-' ' it according to its function, or functions. In the case of this boot protocol
'-' ' keyboard/mouse class driver:
'-' ' - SetConfiguration(config_num)
'-' ' - SetProtocol(boot)
'-' ' - SetIdle(indefinite)
'-' ' - Enter the device interrupt IN polling task stage.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_config
'-' '                mov     hkbd_ep_addr, #0                ' DEBUG
'-' '                mov     hmouse_ep_addr, #0              ' DEBUG
'-'                 mov     htmp2, #DEV_UNKNOWN
	byte	$02, $76, $07, $f6
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $a2
'-'         if HAVE_MOUSE
'-'         if_z    cmp     hmouse_ep_addr, #0      wz
	byte	$00, $f4, $0e, $a2
'-'         end
'-'         if_z    cmp     hhub_ep_addr, #0        wz
	byte	$00, $ee, $0e, $a2
'-'         if_z    jmp     #.notify_client                 ' No known device
	byte	$60, $03, $90, $ad
'-' .set_config
'-'                 loc     ptra, #set_config
	byte	$74, $0e, $d0, $fe
'-'                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
	byte	$05, $ec, $07, $f6
'-'                 add     pa, hconfig_base
	byte	$6e, $ed, $03, $f1
'-'                 rdbyte  hpar1, pa
	byte	$f6, $8f, $c3, $fa
'-'                 debug("SetConfiguration: ",udec_(hpar1))
'-'                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
	byte	$01, $8f, $57, $fc
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
	byte	$6c, $bd, $02, $f6
'-'                 mov     pb, #0                          ' SetConfiguration() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret
	byte	$2d, $00, $64, $5d
'-' .kbd_config
'-'                 cmp     hkbd_ep_addr, #0        wz
	byte	$00, $f2, $0e, $f2
'-'         if_z    jmp     #.mouse_config                  ' No keyboard
	byte	$98, $00, $90, $ad
'-' 
'-'                 mov     htmp, hkbd_ep_addr
	byte	$79, $73, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.mouse_config                  ' No keyboard
	byte	$84, $00, $90, $5d
'-' 
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $73, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$3c, $0e, $d0, $fe
'-'                 wrword  #BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$f8, $02, $90, $5d
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8e, $07, $f6
'-'                 getbyte hpar2, kb_intf_num, #0
	byte	$37, $91, $e3, $f8
'-'                 call    #hset_idle
	byte	$44, $03, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hkbd_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 mov     hctwait, _2ms_
	byte	$a9, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
	byte	$00, $76, $06, $f6
'-'         if NUMLOCK_DEFAULT_STATE && RPI_KEYBOARD_NUMLOCK_HACK
'-'         end
'-'                 mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $f6
'-'                 loc     pa, #hkbd_led_rep
	byte	$a0, $17, $90, $fe
'-'                 wrbyte  hkbd_ledstates,pa
	byte	$f6, $f9, $42, $fc
'-'                 call    #hset_kbdled_report
	byte	$40, $03, $b0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$c4, $02, $90, $5d
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hkbd_ep_addr, ep_addr_pid
	byte	$5e, $f3, $02, $f6
'-'                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
	byte	$6c, $f1, $02, $f6
'-'                 bitc    hkbd_ctrl_ep, #31
	byte	$1f, $f0, $46, $f4
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
	byte	$00, $f6, $06, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $c6, $f8
'-'                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
	byte	$03, $76, $07, $f6
'-'         if !!HAVE_MOUSE
'-'         end
'-' 
'-' .mouse_config
'-' if HAVE_MOUSE
'-'                 cmp     hmouse_ep_addr, #0        wz
	byte	$00, $f4, $0e, $f2
'-'         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$ac, $00, $90, $ad
'-'                 mov     htmp, hmouse_ep_addr
	byte	$7a, $73, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
	byte	$98, $00, $90, $5d
'-' 
'-'                 debug("mouse passed addr check")
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$b8, $0d, $d0, $fe
'-'                 wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $ff, $03, $01, $5e, $fc
'-'                 wrword  ms_intf_num,ptra[wIndex]
	byte	$02, $6b, $56, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$58, $02, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),uhex_byte_array(pb,total_data))
'-' 
'-'                 getbyte htmp, ms_intf_num, #0
	byte	$35, $73, $e3, $f8
'-'                 loc     ptra, #set_protocol
	byte	$6c, $0d, $d0, $fe
'-'                 wrword  #MOUSE_FULL_PROTOCOL ? REPORT_PROTOCOL : BOOT_PROTOCOL, ptra[wValue]
	byte	$01, $03, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 mov     pb, #0                          ' SetProtocol() has no data stage
	byte	$00, $ee, $07, $f6
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$28, $02, $90, $5d
'-'                 debug("mouse passed SetProtocol")
'-'                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
	byte	$00, $8e, $07, $f6
'-'                 getbyte hpar2, ms_intf_num, #0
	byte	$35, $91, $e3, $f8
'-'                 call    #hset_idle
	byte	$74, $02, $b0, $fd
'-'                 'cmp     retval, #PID_ACK        wz
'-'         'if_nz   mov     hmouse_ep_addr, #0
'-'         'if_nz   jmp     #.notify_client
'-'                 debug("mouse passed SetIdle")
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 mov     hmouse_ep_addr, ep_addr_pid
	byte	$5e, $f5, $02, $f6
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
	byte	$c3, $60, $ce, $f8
'-'                 mov     htmp2, hkbd_ep_addr
	byte	$79, $77, $03, $f6
'-'                 xor     htmp2, hmouse_ep_addr
	byte	$7a, $77, $63, $f5
'-'                 and     htmp2, ##ADDR_MASK              wz
	byte	$3f, $00, $00, $ff, $00, $77, $0f, $f5
'-'         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
	byte	$05, $76, $07, $a6
'-'         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
	byte	$04, $76, $07, $56
'-'                 jmp     #.notify_client
	byte	$e4, $01, $90, $fd
'-' end
'-' .gamepad_config
'-' if _HAVE_GAMEPAD
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 cmp     0-0, #0                 wz
	byte	$00, $00, $0c, $f2
'-'         if_z    jmp     #.hub_config                    ' No gamepad
	byte	$6c, $01, $90, $ad
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     htmp, 0-0
	byte	$00, $72, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.hub_config                    ' No gamepad
	byte	$54, $01, $90, $5d
'-' 
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-'                 setbyte ep_addr_pid, #PID_IN, #0
	byte	$69, $bc, $c6, $f8
'-'                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'                 bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $f4
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, ep_addr_pid
	byte	$5e, $01, $00, $f6
'-'                 mov     ep_addr_pid, hdev_out_addr  wz
	byte	$85, $bd, $0a, $f6
'-'         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
	byte	$e1, $bc, $c6, $58
'-'         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
	byte	$be, $00, $a0, $5d
'-'         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $54
'-'         if_nz   bitc    ep_addr_pid, #31
	byte	$1f, $bc, $46, $54
'-'         if_nz   mov     hdev_out_addr, ep_addr_pid
	byte	$5e, $0b, $03, $56
'-'                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 if EMUPAD_MAX_PLAYER > 0
'-'                 
'-' .rule_loop           
'-'                 end
'-' 
'-'                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
	byte	$ff, $e2, $0e, $f2
'-'         if_e    jmp     #.xinput
	byte	$5c, $00, $90, $ad
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     htmp,0-0
	byte	$00, $72, $03, $f6
'-'                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
	byte	$01, $a6, $02, $ff, $68, $72, $0f, $f2
'-'         if_e    jmp     #.ps3
	byte	$8c, $00, $90, $ad
'-' 
'-'                 loc     ptra, #get_desc                 ' Get HID descriptor
	byte	$a4, $0c, $d0, $fe
'-'                 cmp     hdev_port,#0            wz
	byte	$00, $5a, $0e, $f2
'-'         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
	byte	$00, $00, $80, $5f, $03, $01, $5e, $5c
'-'         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
	byte	$03, $00, $80, $af, $03, $01, $5e, $ac
'-'                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
	byte	$02, $01, $5c, $fc
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $01, $90, $5d
'-'                 altd    hdev_port, #gp_descr_len
	byte	$3f, $5b, $8e, $f9
'-'                 mov     0-0, total_data
	byte	$56, $01, $00, $f6
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 debug(uhex(pb),udec(total_data),uhex_byte_array(pb,total_data))
'-' 
'-'                 mov     htmp2, #HID_READY               ' Standard gamepad
	byte	$06, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$20, $01, $90, $fd
'-' .xinput
'-'                 loc     ptra, #xinp_led_cmd             ' Turn on LED
	byte	$b8, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 cmpsub  pb,#1 ' root device is also player 1
	byte	$01, $ee, $e7, $f2
'-'                 fle     pb,#3
	byte	$03, $ee, $27, $f3
'-'                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
	byte	$06, $ee, $07, $f1
'-'                 wrbyte  pb, ptra[2]
	byte	$02, $ef, $47, $fc
'-' 
'-'                 mov     pkt_data, #3
	byte	$03, $b0, $06, $f6
'-'                 bitl    hstatus, #DATAx_TGLB
	byte	$03, $96, $06, $f4
'-'                 mov     ep_addr_pid, hdev_out_addr
	byte	$85, $bd, $02, $f6
'-'                 debug("XInput LED set ",uhex_long(ep_addr_pid),uhex_byte(pb))
'-'                 call    #txn_out
	byte	$5a, $00, $a0, $fd
'-'                 mov     ep_addr_pid, hctrl_ep_addr
	byte	$6c, $bd, $02, $f6
'-' 
'-'                 loc     ptra, #xinp_fix_8bitdo
	byte	$97, $0c, $d0, $fe
'-'                 mov     pb, urx_buff_p          ' We don't actually care where it goes
	byte	$27, $ef, $03, $f6
'-'                 call    #control_read           ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 debug("8bitdo weird fix... ",uhex(retval))
'-'                 mov retval,#PID_ACK             ' If we don't do this something else becomes sad (TODO fix?)
	byte	$d2, $be, $06, $f6
'-' 
'-' 
'-'                 mov     htmp2, #XINPUT_READY
	byte	$07, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$dc, $00, $90, $fd
'-' .ps3
'-'                 loc     ptra, #ps3_command_buff         ' Turn on LED
	byte	$44, $0c, $d0, $fe
'-'                 mov     pb,hdev_port
	byte	$2d, $ef, $03, $f6
'-'                 fge     pb,#1 ' root device is also player 1
	byte	$01, $ee, $07, $f3
'-'                 fle     pb,#4
	byte	$04, $ee, $27, $f3
'-'                 decod   pb
	byte	$f7, $ef, $c3, $f9
'-'                 wrbyte  pb, ptra[9]
	byte	$09, $ef, $47, $fc
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $73, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$f4, $0b, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $03, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 wrword  #48, ptra[wLength]
	byte	$03, $61, $5c, $fc
'-'                 loc     pb, #ps3_command_buff
	byte	$14, $0c, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 getbyte htmp, gp_intf_num, #0
	byte	$3c, $73, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$d4, $0b, $d0, $fe
'-'                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
	byte	$01, $00, $80, $ff, $01, $e9, $5f, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 wrword  #4, ptra[wLength]
	byte	$03, $09, $5c, $fc
'-'                 loc     pb, #ps3_enable_cmd             ' Enable PS3
	byte	$f0, $0b, $b0, $fe
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK    wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $59
'-'         if_nz   mov     0-0, #0
	byte	$00, $00, $04, $56
'-'         if_nz   jmp     #.notify_client
	byte	$74, $00, $90, $5d
'-' 
'-'                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
	byte	$08, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$6c, $00, $90, $fd
'-' end
'-' 
'-' .hub_config
'-'                 cmp     hhub_ep_addr, #0    wz
	byte	$00, $ee, $0e, $f2
'-'         if_z    jmp     #.notify_client                 ' No HUB
	byte	$64, $00, $90, $ad
'-'                 mov     htmp, hhub_ep_addr
	byte	$77, $73, $03, $f6
'-'                 xor     htmp, ep_addr_pid
	byte	$5e, $73, $63, $f5
'-'                 and     htmp, ##ADDR_MASK       wz
	byte	$3f, $00, $00, $ff, $00, $73, $0f, $f5
'-'         if_nz   jmp     #.notify_client                 ' No HUB
	byte	$50, $00, $90, $5d
'-' 
'-'                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
	byte	$94, $0b, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, hub_descr_p
	byte	$26, $ef, $03, $f6
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   mov     hhub_ep_addr, #0
	byte	$00, $ee, $06, $56
'-'         if_nz   jmp     #.notify_client
	byte	$34, $00, $90, $5d
'-'                 debug(uhex_byte_array(hub_descr_p,total_data))
'-' 
'-'                 mov     ptra, hub_descr_p
	byte	$26, $f1, $03, $f6
'-'                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
	byte	$02, $79, $c7, $fa
'-'                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
	byte	$07, $78, $27, $f3
'-'                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
'-' .pwr_loop
'-'                 loc     ptra, #set_port_feat            ' Power on ports
	byte	$74, $0b, $d0, $fe
'-'                 wrword  #HUB_PORT_POWER, ptra[wValue]
	byte	$01, $11, $5c, $fc
'-'                 wrword  htmp3, ptra[wIndex]
	byte	$02, $79, $57, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 djnz    htmp3, #.pwr_loop
	byte	$fb, $79, $6f, $fb
'-' 
'-'                 mov     hctwait, _500ms_
	byte	$b2, $99, $02, $f6
'-'                 add     hctwait, _100ms_
	byte	$b1, $99, $02, $f1
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 mov     htmp2, #HUB_READY               ' Hub ready
	byte	$09, $76, $07, $f6
'-'                 jmp     #.notify_client
	byte	$00, $00, $90, $fd
'-' 
'-' .notify_client
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte htmp2                           ' Save device ready
	byte	$bb, $01, $c0, $f8
'-'                 debug(uhex_long(hdev_type,hdev_type+1))
'-'         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Initialize the keyboard/mouse data area to start-up values.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' init_kbdm_data
'-'                 mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $f6
'-'                 mov     hdev_ep_addr, #0
	byte	$00, $fa, $06, $f6
'-' 
'-'                 mov     ptra, cache_start_p         ' Clear cached data buffers
	byte	$2a, $f1, $03, $f6
'-'                 mov     pa, cache_end_p
	byte	$2b, $ed, $03, $f6
'-' .loop
'-'                 wrbyte  #0, ptra++
	byte	$61, $01, $4c, $fc
'-'                 cmp     ptra, pa                wcz
	byte	$f6, $f1, $1b, $f2
'-'         if_b    jmp     #.loop
	byte	$f4, $ff, $9f, $cd
'-'         
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' 
'-'                 mov     pa, #hdev_init_start        ' Clear device data registers
	byte	$2d, $ed, $07, $f6
'-' .regloop
'-'                 altd    pa
	byte	$00, $ec, $8f, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-'                 add     pa, #1
	byte	$01, $ec, $07, $f1
'-'                 cmp     pa, #hdev_init_end      wz
	byte	$47, $ed, $0f, $f2
'-'         if_nz   jmp     #.regloop
	byte	$ec, $ff, $9f, $5d
'-' 
'-'                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
	byte	$e1, $e1, $61, $ff, $c3, $5d, $06, $f6
'-'                 mov     hdev_next_datax + 1,hdev_next_datax
	byte	$2e, $5f, $02, $f6
'-'                 setbyte kbm_next_datax, #PID_DATA0, #0
	byte	$c3, $60, $c6, $f8
'-'                 setbyte kbm_next_datax, #PID_DATA0, #1
	byte	$c3, $60, $ce, $f8
'-' 
'-'         _ret_   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $06
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
'-' ' function.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
'-' '   hpar2 - index number of the target interface.
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hset_idle
'-'                 mov     hctwait, _2ms_
	byte	$a9, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #set_idle
	byte	$cc, $0a, $d0, $fe
'-'                 wrword  hpar1, ptra[wValue]
	byte	$01, $8f, $57, $fc
'-'                 wrword  hpar2, ptra[wIndex]
	byte	$02, $91, $57, $fc
'-'                 jmp     #control_write
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
'-' ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   ep_addr_pid - device address and enpoint for the request.
'-' ' On exit:
'-' '   retval - transaction result.
'-' '------------------------------------------------------------------------------
'-' hset_kbdled_report
'-'                 getbyte htmp, kb_intf_num, #0
	byte	$37, $73, $e3, $f8
'-'                 loc     ptra, #set_report
	byte	$c0, $0a, $d0, $fe
'-'                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
	byte	$01, $00, $80, $ff, $01, $01, $5c, $fc
'-'                 wrword  htmp, ptra[wIndex]
	byte	$02, $73, $57, $fc
'-'                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
	byte	$03, $03, $5c, $fc
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrbyte  kb_led_states, pb
	byte	$f7, $77, $42, $fc
'-'                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
	byte	$a0, $02, $80, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for keyboard activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_kbd_in_report
'-'                 mov     ep_addr_pid, hkbd_ep_addr
	byte	$79, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #0
	byte	$30, $93, $e3, $f8
'-'                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
	byte	$39, $93, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
	byte	$30, $73, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $72, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
	byte	$4b, $60, $c6, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
	byte	$c3, $60, $c6, $58
'-' 
'-'                 mov     kb_max_index, hpar3             ' Save actual bytes read
	byte	$c9, $75, $02, $f6
'-'                 call    #hkbd_compare
	byte	$18, $00, $b0, $fd
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-' 
'-' .led_check
'-'                 mov     htmp, kb_led_states
	byte	$3b, $73, $03, $f6
'-'                 cmp     hkbd_ledstates, htmp    wz
	byte	$b9, $f9, $0a, $f2
'-'         if_z    ret                                     ' No toggle key indicator changes, so we're done
	byte	$2d, $00, $64, $ad
'-'                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
	byte	$7c, $77, $02, $f6
'-'                 mov     ep_addr_pid, hkbd_ctrl_ep
	byte	$78, $bd, $02, $f6
'-'                 jmp     #hset_kbdled_report             ' Set report and ignore errors
	byte	$88, $ff, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Compare current and previous keyboard data buffers for keypress changes.
'-' '------------------------------------------------------------------------------
'-' hkbd_compare
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$d0, $13, $f0, $fe
'-'                 rdlong  htmp1, ptra++
	byte	$61, $75, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $77, $07, $fb
'-'                 cmp     htmp1, htmp2    wz
	byte	$bb, $75, $0b, $f2
'-'                 rdlong  htmp1, ptra++
	byte	$61, $75, $07, $fb
'-'                 rdlong  htmp2, ptrb++
	byte	$e1, $77, $07, $fb
'-'         if_z    cmp     htmp1, htmp2    wz
	byte	$bb, $75, $0b, $a2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-' 
'-'                 loc     ptra, #hkbd_report
	byte	$b0, $13, $d0, $fe
'-' 
'-'                 ' Handle modifiers
'-'                 rdbyte  hpar2, urx_buff_p
	byte	$27, $91, $c3, $fa
'-'                 rdbyte  hr1, ptra
	byte	$00, $89, $c7, $fa
'-'                 rolword hr1,hpar2,#0
	byte	$c8, $89, $43, $f9
'-'                 mergew  hr1
	byte	$63, $88, $63, $fd
'-'                 mov     pa,#8
	byte	$08, $ec, $07, $f6
'-' .modloop
'-'                 rczr    hr1     wcz ' New value in C, old value in Z
	byte	$6a, $88, $7b, $fd
'-'                 mov     hpar1,#$E8
	byte	$e8, $8e, $07, $f6
'-'                 sub     hpar1,pa
	byte	$f6, $8f, $83, $f1
'-'       if_c_ne_z call    #hkbd_translate
	byte	$a0, $00, $b0, $6d
'-'                 djnz    pa,#.modloop
	byte	$fb, $ed, $6f, $fb
'-' 
'-' .release        modc    _set    wc
	byte	$6f, $e0, $75, $fd
'-'                 'alts    hdev_port, #hid_report_p
'-'                 'mov     ptra, hid_report_p
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .rl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8f, $cf, $fa
'-'         if_z    jmp     #.rl3
	byte	$20, $00, $90, $ad
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .rl2            rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b9, $8f, $0b, $f2
'-'         if_z    jmp     #.rl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.rl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$68, $00, $b0, $fd
'-' .rl3            djnz    pa, #.rl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-'                 mov     hpar3, #0
	byte	$00, $92, $07, $f6
'-'                 bith    hpar3, #31
	byte	$1f, $92, $27, $f4
'-' 
'-' .press          modc    _clr    wc
	byte	$6f, $00, $74, $fd
'-'                 mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 add     ptra, #2
	byte	$02, $f0, $07, $f1
'-'                 mov     pa, #6
	byte	$06, $ec, $07, $f6
'-' .pl1            rdbyte  hpar1, ptra++   wz
	byte	$61, $8f, $cf, $fa
'-'         if_z    jmp     #.pl3
	byte	$20, $00, $90, $ad
'-'                 loc     ptrb, #hkbd_report
	byte	$2c, $13, $f0, $fe
'-'                 add     ptrb, #2
	byte	$02, $f2, $07, $f1
'-'                 mov     pb, #6
	byte	$06, $ee, $07, $f6
'-' .pl2            rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 cmp     hpar1, htmp     wz
	byte	$b9, $8f, $0b, $f2
'-'         if_z    jmp     #.pl3
	byte	$08, $00, $90, $ad
'-'                 djnz    pb, #.pl2
	byte	$fc, $ef, $6f, $fb
'-'                 call    #hkbd_translate
	byte	$24, $00, $b0, $fd
'-' .pl3            djnz    pa, #.pl1
	byte	$f5, $ed, $6f, $fb
'-' 
'-' .copy           mov     ptra, urx_buff_p
	byte	$27, $f1, $03, $f6
'-'                 loc     ptrb, #hkbd_report
	byte	$04, $13, $f0, $fe
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 rdlong  htmp1, ptra++
	byte	$61, $75, $07, $fb
'-'                 setq #1
	byte	$28, $02, $64, $fd
'-'                 wrlong  htmp1, ptrb++
	byte	$e1, $75, $67, $fc
'-'                 wrbyte  hkbd_ledstates,ptrb++
	byte	$e1, $f9, $46, $fc
'-' 
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Translate keyboard scancode to ASCII
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   hpar1 - scancode
'-' '   hpar2 - key modifiers state
'-' '       c - pressed (0) or released (1) flag
'-' ' On exit:
'-' '   hpar1 - bit     31 = 0 pressed, 1 released
'-' '               30..17 = unused
'-' '                   18 = scroll-lock state 
'-' '                   17 = caps-lock state
'-' '                   16 = num-lock state 
'-' '                15..8 = key modifiers state
'-' '                 7..0 = scancode
'-' '------------------------------------------------------------------------------
'-' hkbd_translate
'-'                 cmp     hpar1, #KEY_CAPSLOCK    wz
	byte	$39, $8e, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
	byte	$01, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_NUMLOCK     wz
	byte	$53, $8e, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
	byte	$00, $f8, $e6, $24
'-'                 cmp     hpar1, #KEY_SCROLLLOCK  wz
	byte	$47, $8e, $0f, $f2
'-'   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
	byte	$02, $f8, $e6, $24
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' 
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' 
'-'         end
'-'                 setbyte hpar1, hpar2, #1
	byte	$c8, $8f, $cb, $f8
'-'                 setbyte hpar1, hkbd_ledstates,#2
	byte	$7c, $8f, $d3, $f8
'-'                 bitc    hpar1, #31
	byte	$1f, $8e, $47, $f4
'-'         if KEYQUEUE_SIZE > 0
'-'                 loc pb,#keyq_head
	byte	$c0, $09, $b0, $fe
'-'                 rdword htmp,pb
	byte	$f7, $73, $e3, $fa
'-'                 getbyte htmp1,htmp,#1 ' tail
	byte	$b9, $75, $eb, $f8
'-'                 getbyte htmp,htmp,#0 ' head
	byte	$b9, $73, $e3, $f8
'-'                 mov htmp2,htmp
	byte	$b9, $77, $03, $f6
'-'                 mul htmp2,#4
	byte	$04, $76, $07, $fa
'-'                 add htmp2,pb
	byte	$f7, $77, $03, $f1
'-'                 add htmp2,#2
	byte	$02, $76, $07, $f1
'-'                 incmod htmp,#KEYQUEUE_SIZE - 1
	byte	$7f, $72, $07, $f7
'-'                 cmp htmp1,htmp wz ' check buffer overflow
	byte	$b9, $75, $0b, $f2
'-'         if_nz   wrlong hpar1,htmp2
	byte	$bb, $8f, $63, $5c
'-'         if_nz   wrbyte htmp,pb
	byte	$f7, $73, $43, $5c
'-'         end
'-'                 ret wcz
	byte	$2d, $00, $7c, $fd
'-' 
'-' if HAVE_MOUSE
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for mouse activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_mouse_in_report
'-'                 mov     ep_addr_pid, hmouse_ep_addr
	byte	$7a, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 getbyte hpar3, kbm_next_datax, #1
	byte	$30, $93, $eb, $f8
'-'                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
	byte	$36, $93, $2b, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
	byte	$30, $73, $eb, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $72, $0f, $f2
'-'         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
	byte	$4b, $60, $ce, $a8
'-'         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
	byte	$c3, $60, $ce, $58
'-' 
'-'         'debug(uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 call #hid_decode
	byte	$c8, $00, $b0, $fd
'-'         else
'-'         end
'-' 
'-'                 loc     pa, #mouse_limits
	byte	$48, $09, $90, $fe
'-'                 loc     ptrb, #mouse_xacc
	byte	$5d, $13, $f0, $fe
'-' 
'-'                 ' load xacc,yacc,zacc
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  hr1,ptrb
	byte	$80, $89, $07, $fb
'-'                 ' load limits and outptr
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 rdlong  htmp1,pa
	byte	$f6, $75, $03, $fb
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 wrbyte  hidr_buttons, ptrb[12]
	byte	$8c, $19, $47, $fc
'-'         else
'-'                 { ' Currently not used
'-'                 '}
'-'         end
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 getword htmp, hidr_axis+0, #0
	byte	$88, $73, $33, $f9
'-'                 signx   htmp, #15
	byte	$0f, $72, $67, $f7
'-'         else
'-'         end
'-'                 add     hr1,htmp
	byte	$b9, $89, $03, $f1
'-'                 cmp     htmp1,#0 wz
	byte	$00, $74, $0f, $f2
'-'         if_ne   fles    hr1,htmp1
	byte	$ba, $89, $63, $53
'-'         if_ne   fges    hr1,#0
	byte	$00, $88, $47, $53
'-' 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 getword htmp, hidr_axis+0, #1
	byte	$88, $73, $3b, $f9
'-'                 signx   htmp, #15
	byte	$0f, $72, $67, $f7
'-'         else
'-'         end
'-'                 add     hr2,htmp
	byte	$b9, $8b, $03, $f1
'-'                 cmp     htmp2,#0 wz
	byte	$00, $76, $0f, $f2
'-'         if_ne   fles    hr2,htmp2
	byte	$bb, $8b, $63, $53
'-'         if_ne   fges    hr2,#0
	byte	$00, $8a, $47, $53
'-'                 
'-'         if MOUSE_FULL_PROTOCOL
'-'                 getword htmp, hidr_axis+3, #1           ' Mouse wheel is actually on the "wheel axis"
	byte	$8b, $73, $3b, $f9
'-'                 signx   htmp, #15
	byte	$0f, $72, $67, $f7
'-'                 add     hr3, htmp
	byte	$b9, $8d, $03, $f1
'-'         else    
'-'         end
'-' 
'-'                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
	byte	$90, $73, $cf, $fa
'-'         if_nz   ret                                     ' If so, don't write results
	byte	$2d, $00, $64, $5d
'-' 
'-'                 ' write back accumulators
'-'                 setq    #3-1
	byte	$28, $04, $64, $fd
'-'                 wrlong  hr1,ptrb
	byte	$80, $89, $67, $fc
'-'                 ' if outptr set, write X/Y words
'-'                 cmp htmp3,#0                    wz
	byte	$00, $78, $0f, $f2
'-'         if_nz   setword hr1,hr2,#1
	byte	$c5, $89, $2b, $59
'-'         if_nz   wrlong hr1,htmp3
	byte	$bc, $89, $63, $5c
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' hget_gp_in_report
'-'                 alts    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $96, $f9
'-'                 mov     ep_addr_pid, 0-0
	byte	$00, $bc, $02, $f6
'-' 
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 altgb   hdev_port, #hdev_next_datax
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte hpar3
	byte	$00, $92, $e3, $f8
'-'                 setword hpar3, #255, #1                 ' Always ask for max report size
	byte	$ff, $92, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   ret                                     ' No ACK, ignore
	byte	$2d, $00, $64, $5d
'-' 
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-'                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
'-' 
'-'                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
	byte	$2e, $5b, $6e, $f9
'-'                 getbyte htmp                            ' |
	byte	$00, $72, $e3, $f8
'-'                 cmp     htmp, #PID_DATA0        wz      ' |
	byte	$c3, $72, $0f, $f2
'-'         if_z    mov     htmp, #PID_DATA1                ' |
	byte	$4b, $72, $07, $a6
'-'         if_nz   mov     htmp, #PID_DATA0                ' |
	byte	$c3, $72, $07, $56
'-'                 altsb   hdev_port, #hdev_next_datax     ' |
	byte	$2e, $5b, $66, $f9
'-'                 setbyte htmp                            ' |
	byte	$b9, $01, $c0, $f8
'-' 
'-' ' Note: the following code compares the current and previous reports
'-' ' and process the data if there are changes to ease the debug output.
'-' ' Actual implementations should remove this block, along with hid_pre_rpt_p and
'-' ' gpPreReport buffer.
'-' 
'-'                 ' ----- start of block to remove
'-'                 {
'-'                 }
'-'                 ' ----- end of block to remove
'-'                 loc pa,#hpad_translate
	byte	$14, $05, $90, $fe
'-'                 push pa
	byte	$2a, $ec, $63, $fd
'-' 
'-'                 ' FALL THROUGH !!!!
'-' end
'-' if _HAVE_GAMEPAD || MOUSE_FULL_PROTOCOL
'-' '------------------------------------------------------------------------------
'-' ' Decode controller report
'-' '------------------------------------------------------------------------------
'-' hid_decode
'-'                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
'-'                 setq #(hidr_end-hidr_start)-1
	byte	$28, $20, $64, $fd
'-'                 rdlong  hidr_start,##$8_0000
	byte	$00, $04, $00, $ff, $00, $0c, $07, $fb
'-' 
'-'                 mov     ptrb, urx_buff_p
	byte	$27, $f3, $03, $f6
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte hidr_type
	byte	$00, $1c, $e3, $f8
'-'         if _HAVE_GAMEPAD
'-'                 cmp     hidr_type, #XINPUT_READY        wz
	byte	$07, $1c, $0f, $f2
'-'         if_z    jmp     #hpad_xinput
	byte	$08, $03, $90, $ad
'-'                 cmp     hidr_type, #PS3_READY           wz
	byte	$08, $1c, $0f, $f2
'-'         if_z    jmp     #hpad_ps3
	byte	$ec, $03, $90, $ad
'-'         end
'-'                 cmp     hidr_type, #KBM_READY           wz
	byte	$05, $1c, $0f, $f2
'-'         if_z    mov     hidr_type,#M_READY
	byte	$04, $1c, $07, $a6
'-'                 cmp     hidr_type, #M_READY             wz
	byte	$04, $1c, $0f, $f2
'-'                 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle HID controller (or mouse now
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' hpad_hid
'-'                 call    #get_hid_descr_buffer
	byte	$1b, $01, $a0, $fd
'-'                 mov     ptra, pb
	byte	$f7, $f1, $03, $f6
'-'                 alts    hdev_port, #gp_descr_len
	byte	$3f, $5b, $96, $f9
'-'                 mov     pa, 0-0
	byte	$00, $ec, $03, $f6
'-'                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
'-'                 mov     hidr_usage, ##$76543210
	byte	$19, $2a, $3b, $ff, $10, $0c, $07, $f6
'-' 
'-' .next
'-'                 cmps    pa, #0      wcz
	byte	$00, $ec, $5f, $f2
'-'         if_be   ret     wcz
	byte	$2d, $00, $7c, $ed
'-' 
'-'                 rdbyte  hpar1, ptra++
	byte	$61, $8f, $c7, $fa
'-'                 sub     pa, #1
	byte	$01, $ec, $87, $f1
'-'                 mov     hpar2, #0
	byte	$00, $90, $07, $f6
'-' 
'-'                 mov     htmp, hpar1
	byte	$c7, $73, $03, $f6
'-'                 and     htmp, #$03
	byte	$03, $72, $07, $f5
'-'                 cmp     htmp, #1    wz
	byte	$01, $72, $0f, $f2
'-'         if_z    rdbyte  hpar2, ptra++
	byte	$61, $91, $c7, $aa
'-'         if_z    signx   hpar2,#7
	byte	$07, $90, $67, $a7
'-'         if_z    sub     pa, #1
	byte	$01, $ec, $87, $a1
'-'                 cmp     htmp, #2    wz
	byte	$02, $72, $0f, $f2
'-'         if_z    rdword  hpar2, ptra++
	byte	$61, $91, $e7, $aa
'-'         if_z    signx   hpar2,#15
	byte	$0f, $90, $67, $a7
'-'         if_z    sub     pa, #2
	byte	$02, $ec, $87, $a1
'-'                 cmp     htmp, #3    wz
	byte	$03, $72, $0f, $f2
'-'         if_z    rdlong  hpar2, ptra++
	byte	$61, $91, $07, $ab
'-'         if_z    sub     pa, #4
	byte	$04, $ec, $87, $a1
'-' 
'-'                 and     hpar1, #$FC
	byte	$fc, $8e, $07, $f5
'-'                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
'-' 
'-'                 cmp     hpar1, #HID_REPORT_ID   wz
	byte	$84, $8e, $0f, $f2
'-'         if_z    jmp     #.report_id
	byte	$18, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE_PAGE  wz
	byte	$04, $8e, $0f, $f2
'-'         if_z    jmp     #.usage_page
	byte	$30, $01, $90, $ad
'-'                 cmp     hpar1, #HID_USAGE       wz
	byte	$08, $8e, $0f, $f2
'-'         if_z    jmp     #.usage
	byte	$38, $01, $90, $ad
'-'                 cmp     hpar1, #HID_LOGICAL_MIN wz
	byte	$14, $8e, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #1
	byte	$c8, $2b, $2b, $a9
'-'                 cmp     hpar1, #HID_LOGICAL_MAX wz
	byte	$24, $8e, $0f, $f2
'-'         if_z    setword hidr_lminmax, hpar2, #0
	byte	$c8, $2b, $23, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MIN wz
	byte	$34, $8e, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #1
	byte	$c8, $2d, $2b, $a9
'-'                 cmp     hpar1, #HID_PHYSICAL_MAX wz
	byte	$44, $8e, $0f, $f2
'-'         if_z    setword hidr_pminmax, hpar2, #0
	byte	$c8, $2d, $23, $a9
'-'                 cmp     hpar1, #HID_REPORT_SIZE wz
	byte	$74, $8e, $0f, $f2
'-'         if_z    mov     hidr_size, hpar2
	byte	$c8, $27, $03, $a6
'-'                 cmp     hpar1, #HID_REPORT_COUNT wz
	byte	$94, $8e, $0f, $f2
'-'         if_z    mov     hidr_count, hpar2
	byte	$c8, $29, $03, $a6
'-'                 cmp     hpar1, #HID_POP wcz
	byte	$b4, $8e, $1f, $f2
'-'         if_nz   cmp     hpar1, #HID_PUSH wz
	byte	$a4, $8e, $0f, $52
'-'         if_z    jmp     #.pushpop ' Entering with C set if PUSH  
	byte	$64, $01, $90, $ad
'-'                 cmp     hpar1, #HID_INPUT       wz
	byte	$80, $8e, $0f, $f2
'-'         if_nz   jmp     #.next
	byte	$58, $ff, $9f, $5d
'-' 
'-'                 tjf     hidr_state,#.next
	byte	$d5, $25, $a7, $fb
'-' 
'-'                 and     hpar2, #$03
	byte	$03, $90, $07, $f5
'-'                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
	byte	$02, $90, $0f, $f2
'-'         if_nz   jmp     #.skip
	byte	$18, $00, $90, $5d
'-' 
'-'                 cmp     hidr_state, #2  wz
	byte	$02, $24, $0f, $f2
'-'         if_z    jmp     #.axes
	byte	$20, $00, $90, $ad
'-'                 cmp     hidr_state, #3  wz
	byte	$03, $24, $0f, $f2
'-'         if_z    jmp     #.hats
	byte	$5c, $00, $90, $ad
'-'                 cmp     hidr_state, #4  wz
	byte	$04, $24, $0f, $f2
'-'         if_z    jmp     #.buttons
	byte	$70, $00, $90, $ad
'-' .skip
'-'                 mov     htmp, hidr_size
	byte	$93, $73, $03, $f6
'-'                 mul     htmp, hidr_count
	byte	$94, $73, $03, $fa
'-'                 add     hidr_offset, htmp
	byte	$b9, $21, $03, $f1
'-'                 jmp     #.next
	byte	$20, $ff, $9f, $fd
'-' .axes
'-'                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count),uhex_long(hidr_flags))
'-'                 getnib  hr0, hidr_flags, #2
	byte	$87, $87, $53, $f8
'-'                 mov     hr1, hidr_count
	byte	$94, $89, $03, $f6
'-' .l1
'-'                 mov     hpar1, hidr_offset
	byte	$90, $8f, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$93, $91, $03, $f6
'-'                 call    #hpad_getbits
	byte	$28, $01, $b0, $fd
'-'                 call    #hpad_normalize
	byte	$88, $01, $b0, $fd
'-'                 cmp     hr0, #8         wcz
	byte	$08, $86, $1f, $f2
'-'         if_b    altgn   hr0, #hidr_usage
	byte	$86, $87, $5f, $c9
'-'         if_b    getnib  hr2
	byte	$00, $8a, $43, $c8
'-'         if_b    altsw   hr2, #hidr_axis
	byte	$88, $8b, $77, $c9
'-'         if_b    setword retval
	byte	$5f, $01, $20, $c9
'-'         if_b    add     hr0, #1
	byte	$01, $86, $07, $c1
'-'                 add     hidr_offset, hidr_size
	byte	$93, $21, $03, $f1
'-'                 djnz    hr1, #.l1
	byte	$f4, $89, $6f, $fb
'-' 
'-'                 setnib  hidr_flags, hr0, #2
	byte	$c3, $0f, $13, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $24, $07, $f6
'-'                 jmp     #.next
	byte	$dc, $fe, $9f, $fd
'-' .hats
'-'                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$90, $8f, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$93, $91, $03, $f6
'-'                 call    #hpad_getbits
	byte	$ec, $00, $b0, $fd
'-'                 setbyte hidr_hats, retval, #0
	byte	$5f, $1b, $c3, $f8
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $24, $07, $f6
'-'                 jmp     #.skip
	byte	$90, $ff, $9f, $fd
'-' .buttons
'-'                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
'-'                 mov     hpar1, hidr_offset
	byte	$90, $8f, $03, $f6
'-'                 mov     hpar2, hidr_size
	byte	$93, $91, $03, $f6
'-'                 mul     hpar2, hidr_count
	byte	$94, $91, $03, $fa
'-'                 call    #hpad_getbits
	byte	$cc, $00, $b0, $fd
'-'                 getbyte htmp, hidr_flags, #0
	byte	$87, $73, $e3, $f8
'-'                 shl     retval, htmp
	byte	$b9, $bf, $62, $f0
'-'                 or      hidr_buttons, retval
	byte	$5f, $19, $43, $f5
'-'                 add     htmp, hidr_count
	byte	$94, $73, $03, $f1
'-'                 setbyte hidr_flags, htmp, #0
	byte	$b9, $0f, $c3, $f8
'-'                 mov     hidr_state, #1
	byte	$01, $24, $07, $f6
'-'                 jmp     #.skip
	byte	$64, $ff, $9f, $fd
'-' .report_id
'-'                 cmp     hidr_id, #0     wz
	byte	$00, $1e, $0f, $f2
'-'         if_nz   ret     wcz
	byte	$2d, $00, $7c, $5d
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 'debug(".report_id",udec(htmp,hpar2))
'-'                 cmp     htmp, hpar2     wz
	byte	$c8, $73, $0b, $f2
'-'         if_z    mov     hidr_id, htmp
	byte	$b9, $1f, $03, $a6
'-'         if_nz   neg     hidr_state,#1
	byte	$01, $24, $67, $56
'-'         if_nz   sub     ptrb,#1
	byte	$01, $f2, $87, $51
'-'                 jmp     #.next
	byte	$74, $fe, $9f, $fd
'-' .usage_page
'-'                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
	byte	$09, $90, $0f, $f2
'-'         if_z    cmp     hidr_state, #1  wz
	byte	$01, $24, $0f, $a2
'-'         if_z    mov     hidr_state, #4
	byte	$04, $24, $07, $a6
'-'                 jmp     #.next
	byte	$64, $fe, $9f, $fd
'-' .usage
'-'                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
	byte	$04, $90, $0f, $f2
'-'         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
	byte	$05, $90, $0f, $52
'-'         if_z    cmp     hidr_type,#HID_READY        wz
	byte	$06, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $24, $07, $a6
'-'         if_z    jmp     #.next
	byte	$50, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_MOUSE     wz
	byte	$02, $90, $0f, $f2
'-'         if_z    cmp     hidr_type,#M_READY          wz
	byte	$04, $1c, $0f, $a2
'-'         if_z    mov     hidr_state, #1
	byte	$01, $24, $07, $a6
'-'         if_z    jmp     #.next
	byte	$40, $fe, $9f, $ad
'-'                 cmp     hpar2, #HID_USAGE_X     wc
	byte	$30, $90, $17, $f2
'-'         if_nc   cmpr    hpar2, #HID_USAGE_WHEEL wc   
	byte	$38, $90, $97, $32
'-'         if_nc   jmp     #.usage_axis
	byte	$10, $00, $90, $3d
'-'                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
	byte	$39, $90, $0f, $f2
'-'         if_z    cmp     hidr_state, #1      wz
	byte	$01, $24, $0f, $a2
'-'         if_z    mov     hidr_state, #3
	byte	$03, $24, $07, $a6
'-'                 jmp     #.next
	byte	$24, $fe, $9f, $fd
'-' .usage_axis
'-'                 cmps    hidr_state, #1          wc
	byte	$01, $24, $57, $f2
'-'         if_b    jmp     #.next
	byte	$1c, $fe, $9f, $cd
'-'                 fle     hpar2, #HID_USAGE_DIAL   ' Let's just say wheel and dial are the same to keep sane
	byte	$37, $90, $27, $f3
'-'                 altsn   hidr_usage_idx, #hidr_usage
	byte	$86, $23, $57, $f9
'-'                 setnib  hpar2
	byte	$c8, $01, $00, $f8
'-' 
'-'                 sub     hpar2, #HID_USAGE_X - 16
	byte	$20, $90, $87, $f1
'-'                 bith    hidr_flags, hpar2
	byte	$c8, $0f, $23, $f4
'-' 
'-'                 add     hidr_usage_idx, #1
	byte	$01, $22, $07, $f1
'-'                 mov     hidr_state, #2
	byte	$02, $24, $07, $f6
'-'                 jmp     #.next
	byte	$fc, $fd, $9f, $fd
'-' .pushpop
'-'                 ' Entering with C set if PUSH  
'-'                 loc     pb, #hid_stack
	byte	$4c, $0f, $b0, $fe
'-'         if_c    setq    #(hidr_end-hidr_state)-1
	byte	$28, $08, $64, $cd
'-'         if_c    wrlong  hidr_state, pb
	byte	$f7, $25, $63, $cc
'-'         if_nc   setq    #(hidr_end-hidr_state)-1
	byte	$28, $08, $64, $3d
'-'         if_nc   rdlong  hidr_state, pb
	byte	$f7, $25, $03, $3b
'-'                 jmp     #.next
	byte	$e4, $fd, $9f, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Read bits from report data buffer
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   PTRB - report buffer
'-' '   hpar1 - start bit
'-' '   hpar2 - number of bits
'-' ' On exit:
'-' '   retval - bits
'-' '------------------------------------------------------------------------------
'-' hpad_getbits
'-'                 mov     htmp, hpar1
	byte	$c7, $73, $03, $f6
'-'                 shr     htmp, #3        ' byte offset
	byte	$03, $72, $47, $f0
'-'                 add     htmp, ptrb
	byte	$f9, $73, $03, $f1
'-'                 rdlong  retval, htmp
	byte	$b9, $bf, $02, $fb
'-' 
'-'                 mov     htmp1, hpar1
	byte	$c7, $75, $03, $f6
'-'                 and     htmp1, #$07     ' shift
	byte	$07, $74, $07, $f5
'-'                 shr     retval, htmp1
	byte	$ba, $bf, $42, $f0
'-' 
'-'                 cmp     hpar2, #24      wcz
	byte	$18, $90, $1f, $f2
'-'         if_a    jmp     #.l1
	byte	$10, $00, $90, $1d
'-' 
'-'                 decod   hpar2
	byte	$c8, $91, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $90, $87, $f1
'-'                 and     retval, hpar2
	byte	$c8, $bf, $02, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .l1
'-'                 and     retval, ##$00_FFFFFF
	byte	$ff, $7f, $00, $ff, $ff, $bf, $06, $f5
'-'                 add     htmp, #3
	byte	$03, $72, $07, $f1
'-'                 rdlong  htmp2, htmp
	byte	$b9, $77, $03, $fb
'-'                 sub     hpar2, #24
	byte	$18, $90, $87, $f1
'-'                 decod   hpar2
	byte	$c8, $91, $c3, $f9
'-'                 sub     hpar2, #1
	byte	$01, $90, $87, $f1
'-'                 shr     htmp2, htmp1
	byte	$ba, $77, $43, $f0
'-'                 and     htmp2, hpar2
	byte	$c8, $77, $03, $f5
'-'                 shl     htmp2, #24
	byte	$18, $76, $67, $f0
'-'                 or      retval, htmp2
	byte	$bb, $bf, $42, $f5
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Normalize value to signed word (-32768 / 32767)
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' '   retval - value to normalize
'-' '   hidr_lminmax - min (word 1) max (word 0) value range
'-' '   - or -
'-' '   hidr_pminmax - min (word 1) max (word 0) value range
'-' '   hidr_size - value bits length
'-' ' On exit:
'-' '   retval - normalized value
'-' '------------------------------------------------------------------------------
'-' hpad_normalize
'-'                 mov     htmp, hidr_lminmax  wz
	byte	$95, $73, $0b, $f6
'-'         if_z    mov     htmp, hidr_pminmax  wz
	byte	$96, $73, $0b, $a6
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 getword htmp1, htmp, #1     ' htmp1 = min
	byte	$b9, $75, $3b, $f9
'-'                 getword htmp, htmp, #0      ' htmp = max
	byte	$b9, $73, $33, $f9
'-'                 signx   htmp1, #15      wc
	byte	$0f, $74, $77, $f7
'-'         if_c    alts    hidr_size, #511
	byte	$ff, $27, $97, $c9
'-'         if_c    signx   retval, #0-0
	byte	$00, $be, $66, $c7
'-'                 ' slightly crappy hack: if in mouse mode, don't normalize
'-'                 cmp     hidr_type, #M_READY wz
	byte	$04, $1c, $0f, $f2
'-'         if_z    ret
	byte	$2d, $00, $64, $ad
'-'                 subs    htmp, htmp1         ' htmp = (max - min)
	byte	$ba, $73, $c3, $f1
'-'                 subs    retval, htmp1       ' retval = (retval - min)
	byte	$ba, $bf, $c2, $f1
'-'                 shl     retval, #16         ' retval = (retval - min) << 16
	byte	$10, $be, $66, $f0
'-'                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
	byte	$01, $be, $c6, $f1
'-'                 abs     htmp            wc
	byte	$b9, $73, $53, $f6
'-'                 testb   retval, #31     wz
	byte	$1f, $be, $0e, $f4
'-'                 abs     retval
	byte	$5f, $bf, $42, $f6
'-'                 qdiv    retval, htmp
	byte	$b9, $bf, $12, $fd
'-'                 getqx   retval
	byte	$18, $be, $62, $fd
'-'     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
	byte	$5f, $bf, $62, $66
'-'                 adds    retval, ##$8000 signx 15
	byte	$c0, $ff, $7f, $ff, $00, $be, $46, $f1
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' if _HAVE_GAMEPAD
'-' '------------------------------------------------------------------------------
'-' ' Handle XInput controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_xinput
'-'                 rdbyte  htmp, ptrb      wz
	byte	$80, $73, $cf, $fa
'-'         if_nz   ret                         ' Ignore message type <> $00
	byte	$2d, $00, $64, $5d
'-'                 rdbyte  htmp, ptrb[1]
	byte	$81, $73, $c7, $fa
'-'                 cmp     htmp, #$14      wz
	byte	$14, $72, $0f, $f2
'-'         if_nz   ret                         ' Ignore report length <> $14 (20)
	byte	$2d, $00, $64, $5d
'-' 
'-'                 'debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
	byte	$b0, $0e, $27, $f4
'-'                 setnib  hidr_flags, #6, #2
	byte	$06, $0e, $17, $f8
'-' 
'-'                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
	byte	$83, $11, $e7, $fa
'-'                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
	byte	$84, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
	byte	$85, $13, $e7, $fa
'-'                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
	byte	$86, $bf, $e6, $fa
'-'                 not     retval
	byte	$5f, $bf, $22, $f6
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $2a, $07, $f6
'-'                 rdbyte  retval, ptrb[4]     ' left analog trigger
	byte	$84, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
	byte	$06, $18, $27, $34
'-'                 call    #hpad_normalize
	byte	$54, $ff, $bf, $fd
'-'                 setword hidr_axis+1, retval, #1
	byte	$5f, $13, $2b, $f9
'-'                 rdbyte  retval, ptrb[5]     ' right analog trigger
	byte	$85, $bf, $c6, $fa
'-'                 cmp     retval, #192    wcz
	byte	$c0, $be, $1e, $f2
'-'         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
	byte	$07, $18, $27, $34
'-'                 call    #hpad_normalize
	byte	$40, $ff, $bf, $fd
'-'                 setword hidr_axis+2, retval, #0
	byte	$5f, $15, $23, $f9
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 rdword  retval, ptrb[1]
	byte	$81, $bf, $e6, $fa
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $18, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $18, $47, $f4
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $18, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $18, $47, $f4
'-'                 testb   retval, #8      wc  ' LB
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $18, $47, $f4
'-'                 testb   retval, #9      wc  ' RB
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $18, $47, $f4
'-'                 testb   retval, #5      wc  ' SELECT
	byte	$05, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $18, $47, $f4
'-'                 testb   retval, #4      wc  ' START
	byte	$04, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $18, $47, $f4
'-'                 testb   retval, #6      wc  ' L3
	byte	$06, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $18, $47, $f4
'-'                 testb   retval, #7      wc  ' R3
	byte	$07, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $18, $47, $f4
'-'                 testb   retval, #10     wc  ' XBOX
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $18, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
	byte	$5f, $73, $43, $f8
'-'                 mov     htmp1, ##$F576_F40F
	byte	$7a, $bb, $7a, $ff, $0f, $74, $07, $f6
'-'                 mov     htmp2, ##$FFFF_F312
	byte	$f9, $ff, $7f, $ff, $12, $77, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$ba, $73, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $72, $43, $f8
'-'         _ret_   setbyte hidr_hats, htmp, #0
	byte	$b9, $1b, $c3, $08
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Handle PS3 controller
'-' ' On entry:
'-' '   ptrb - controller report
'-' '------------------------------------------------------------------------------
'-' '   Default implementation translates the report to a pseudo-defacto hid
'-' '   standard and jumps to hpad_translate for actions.
'-' '   Implementors may take specific actions for this kind of controller.
'-' '------------------------------------------------------------------------------
'-' hpad_ps3
'-'                 rdbyte  htmp, ptrb++
	byte	$e1, $73, $c7, $fa
'-'                 cmp     htmp, #$01      wz
	byte	$01, $72, $0f, $f2
'-'         if_nz   ret                         ' Ignore report ID <> $01
	byte	$2d, $00, $64, $5d
'-' 
'-'                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
'-' 
'-'                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
	byte	$b0, $0e, $27, $f4
'-'                 setnib  hidr_flags, #6, #2
	byte	$06, $0e, $17, $f8
'-' 
'-'                 mov     hidr_lminmax, #$0000_00FF
	byte	$ff, $2a, $07, $f6
'-'                 rdbyte  retval, ptrb[5]         ' X = left stick X
	byte	$85, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$98, $fe, $bf, $fd
'-'                 setword hidr_axis, retval, #0
	byte	$5f, $11, $23, $f9
'-'                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
	byte	$86, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$8c, $fe, $bf, $fd
'-'                 setword hidr_axis, retval, #1
	byte	$5f, $11, $2b, $f9
'-'                 rdbyte  retval, ptrb[7]         ' Z = right stick X
	byte	$87, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$80, $fe, $bf, $fd
'-'                 setword hidr_axis+1, retval, #0
	byte	$5f, $13, $23, $f9
'-'                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
	byte	$88, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$74, $fe, $bf, $fd
'-'                 setword hidr_axis+2, retval, #1
	byte	$5f, $15, $2b, $f9
'-'                 rdbyte  retval, ptrb[17]        ' RX = L2 analog
	byte	$91, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$68, $fe, $bf, $fd
'-'                 setword hidr_axis+1, retval, #1
	byte	$5f, $13, $2b, $f9
'-'                 rdbyte  retval, ptrb[18]        ' RY = R2 analog
	byte	$92, $bf, $c6, $fa
'-'                 call    #hpad_normalize
	byte	$5c, $fe, $bf, $fd
'-'                 setword hidr_axis+2, retval, #0
	byte	$5f, $15, $23, $f9
'-' 
'-'                 mov     hpar1, #8
	byte	$08, $8e, $07, $f6
'-'                 mov     hpar2, #19
	byte	$13, $90, $07, $f6
'-'                 call    #hpad_getbits
	byte	$e8, $fd, $bf, $fd
'-' 
'-'                 setbyte hidr_flags,#13,#0
	byte	$0d, $0e, $c7, $f8
'-'                 testb   retval, #12     wc  ' A
	byte	$0c, $be, $16, $f4
'-'                 bitc    hidr_buttons, #0
	byte	$00, $18, $47, $f4
'-'                 testb   retval, #13     wc  ' B
	byte	$0d, $be, $16, $f4
'-'                 bitc    hidr_buttons, #1
	byte	$01, $18, $47, $f4
'-'                 testb   retval, #14     wc  ' X
	byte	$0e, $be, $16, $f4
'-'                 bitc    hidr_buttons, #2
	byte	$02, $18, $47, $f4
'-'                 testb   retval, #15     wc  ' Y
	byte	$0f, $be, $16, $f4
'-'                 bitc    hidr_buttons, #3
	byte	$03, $18, $47, $f4
'-'                 testb   retval, #10     wc  ' L1
	byte	$0a, $be, $16, $f4
'-'                 bitc    hidr_buttons, #4
	byte	$04, $18, $47, $f4
'-'                 testb   retval, #11     wc  ' R1
	byte	$0b, $be, $16, $f4
'-'                 bitc    hidr_buttons, #5
	byte	$05, $18, $47, $f4
'-'                 testb   retval, #8      wc  ' L2
	byte	$08, $be, $16, $f4
'-'                 bitc    hidr_buttons, #6
	byte	$06, $18, $47, $f4
'-'                 testb   retval, #9      wc  ' R2
	byte	$09, $be, $16, $f4
'-'                 bitc    hidr_buttons, #7
	byte	$07, $18, $47, $f4
'-'                 testb   retval, #0      wc  ' SELECT
	byte	$00, $be, $16, $f4
'-'                 bitc    hidr_buttons, #8
	byte	$08, $18, $47, $f4
'-'                 testb   retval, #3      wc  ' START
	byte	$03, $be, $16, $f4
'-'                 bitc    hidr_buttons, #9
	byte	$09, $18, $47, $f4
'-'                 testb   retval, #1      wc  ' LEFT STICK
	byte	$01, $be, $16, $f4
'-'                 bitc    hidr_buttons, #10
	byte	$0a, $18, $47, $f4
'-'                 testb   retval, #2      wc  ' RIGHT STICK
	byte	$02, $be, $16, $f4
'-'                 bitc    hidr_buttons, #11
	byte	$0b, $18, $47, $f4
'-'                 testb   retval, #16     wc  ' HOME
	byte	$10, $be, $16, $f4
'-'                 bitc    hidr_buttons, #12
	byte	$0c, $18, $47, $f4
'-' 
'-'                 setnib  hidr_flags, #1, #3
	byte	$01, $0e, $1f, $f8
'-'                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
	byte	$5f, $73, $4b, $f8
'-'                 mov     htmp1, ##$F3F4_120F
	byte	$09, $fa, $79, $ff, $0f, $74, $07, $f6
'-'                 mov     htmp2, ##$FFF5_FF76
	byte	$ff, $fa, $7f, $ff, $76, $77, $07, $f6
'-'                 altgn   htmp, #htmp1
	byte	$ba, $73, $5f, $f9
'-'                 getnib  htmp
	byte	$00, $72, $43, $f8
'-'         _ret_   setbyte hidr_hats, htmp, #0
	byte	$b9, $1b, $c3, $08
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Perform controller actions
'-' ' On entry:
'-' '    hidr_id        report id
'-' '    hidr_axis      axis value (signed word, 2 axes per long)
'-' '                      X = hidr_axis+0, #0
'-' '                      Y = hidr_axis+0, #1
'-' '                      Z = hidr_axis+1, #0
'-' '                     RX = hidr_axis+1, #1
'-' '                     RY = hidr_axis+2, #0
'-' '                     RZ = hidr_axis+2, #1
'-' '                     Sl = hidr_axis+3, #0
'-' '                     Wh = hidr_axis+3, #1
'-' '    hidr_buttons   buttons state (bits 0 to 31)
'-' '    hidr_hats      hats state (byte 0, 1, 2, 3)
'-' '
'-' '                     -------3 -------2 -------1 -------0 byte
'-' '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
'-' '    hidr_flags       xxxxxxxx_wsrrrzyx_hhhhaaaa_bbbbbbbb
'-' '                              hlzyx||| |||||||| ++++++++ n. buttons
'-' '                              |||||||| ||||++++--------- n. axes
'-' '                              |||||||| ++++------------- n. hats
'-' '                              ++++++++------------------ valid axes
'-' '------------------------------------------------------------------------------
'-' hpad_translate
'-' 
'-' 
'-'         if HAVE_HIDPAD
'-'                 loc     ptrb,#hidpad_report
	byte	$a0, $0c, $f0, $fe
'-'                 mov     htmp,hdev_port          wz
	byte	$2d, $73, $0b, $f6
'-'         if_z    mov     htmp,hidr_id
	byte	$8f, $73, $03, $a6
'-'                 cmpsub  htmp,#1
	byte	$01, $72, $e7, $f2
'-'         if_z    cmp     hidr_id, #MAX_DEVICES   wc
	byte	$07, $1e, $17, $a2
'-'         if_nz   cmp     hidr_id, #2             wc
	byte	$02, $1e, $17, $52
'-'         if_ae   ret     wcz
	byte	$2d, $00, $7c, $3d
'-'                 mul     htmp, #HIDPAD_REPORT_SIZE
	byte	$20, $72, $07, $fa
'-'                 add     ptrb,htmp
	byte	$b9, $f3, $03, $f1
'-'                 alts    hdev_port,#hdev_id
	byte	$61, $5b, $96, $f9
'-'                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
	byte	$00, $0c, $03, $f6
'-'                 setq    #8-1
	byte	$28, $0e, $64, $fd
'-'                 wrlong  hidr_usage,ptrb
	byte	$80, $0d, $67, $fc
'-'         end
'-' 
'-' 
'-'         if EMUPAD_MAX_PLAYER > 0
'-' .emupad_no_hat
'-'         if EMUPAD_BT0_BIT >= 0
'-'         end
'-'         if EMUPAD_BT1_BIT >= 0
'-'         end
'-'         if EMUPAD_BT2_BIT >= 0
'-'         end
'-'         if EMUPAD_BT3_BIT >= 0
'-'         end
'-'         if EMUPAD_BT4_BIT >= 0
'-'         end
'-'         if EMUPAD_BT5_BIT >= 0
'-'         end
'-'         if EMUPAD_BT6_BIT >= 0
'-'         end
'-'         if EMUPAD_BT7_BIT >= 0
'-'         end
'-'         if EMUPAD_BT8_BIT >= 0
'-'         end
'-'         if EMUPAD_BT9_BIT >= 0
'-'         end
'-' .emupad_slot_over
'-'         end
'-' 
'-'         if 0
'-'                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
'-' 
'-'                 debug("    btn: ", ubin_long_(hidr_buttons))
'-' 
'-'         end
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' '------------------------------------------------------------------------------
'-' ' Clear EmuPad state
'-' '------------------------------------------------------------------------------
'-' emupad_reset
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Get EmuPad Player number for current device (into retval)
'-' ' Z flag is also set if current device is valid
'-' ' (Value may be larger than EMUPAD_MAX_PLAYER !)
'-' '------------------------------------------------------------------------------
'-' emupad_getnum
'-' .loop
'-' '------------------------------------------------------------------------------
'-' ' Handle disconnect of device (call after emupad_getnum returns with Z set)
'-' '------------------------------------------------------------------------------
'-' emupad_discon
'-' .loop         
'-'         
'-'         ' FALL THROUGH!!!
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Update EmuPad reports (all of them...)
'-' '------------------------------------------------------------------------------
'-' emupad_write_reports
'-' .devloop
'-' 
'-' end
'-' 
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Execute an IN interrupt transaction to poll for gamepad activity.
'-' '------------------------------------------------------------------------------
'-' ' On entry:
'-' ' On exit:
'-' '------------------------------------------------------------------------------
'-' hget_hub_status
'-'                 mov     ep_addr_pid, hhub_ep_addr
	byte	$77, $bd, $02, $f6
'-'                 mov     hpar2, urx_buff_p
	byte	$27, $91, $03, $f6
'-'                 setword hpar3, hub_next_datax, #0
	byte	$32, $93, $23, $f9
'-'                 setword hpar3, #1, #1
	byte	$01, $92, $2f, $f9
'-'                 call    #do_int_in
	byte	$cf, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_z    jmp     #.data
	byte	$0c, $00, $90, $ad
'-'                 cmp     retval, #PID_NAK        wz
	byte	$5a, $be, $0e, $f2
'-'         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
	byte	$1a, $01, $80, $5d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' .data
'-'                 cmp     hpar3, #0               wz
	byte	$00, $92, $0f, $f2
'-'         if_z    ret                                     ' Ignore an empty DATAx packet
	byte	$2d, $00, $64, $ad
'-' 
'-'                 cmp     hub_next_datax, #PID_DATA0  wz
	byte	$c3, $64, $0e, $f2
'-'         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
	byte	$4b, $64, $06, $a6
'-'         if_nz   mov     hub_next_datax, #PID_DATA0
	byte	$c3, $64, $06, $56
'-'                 rdlong  hub_status_chg, urx_buff_p
	byte	$27, $67, $02, $fb
'-'                 debug(ubin_long(hub_status_chg))
'-' 
'-'                 mov     hdev_port, #1
	byte	$01, $5a, $06, $f6
'-' .loop
'-'                 testb   hub_status_chg, hdev_port wz
	byte	$2d, $67, $0a, $f4
'-'         if_x1   call    #hub_port_handler
	byte	$0c, $00, $b0, $ad
'-'                 incmod  hdev_port, #7           wcz
	byte	$07, $5a, $1e, $f7
'-'         if_nc   jmp     #.loop
	byte	$f0, $ff, $9f, $3d
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' hub_port_handler
'-'                 mov     ep_addr_pid, hhub_ctrl_ep
	byte	$76, $bd, $02, $f6
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$8c, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-' 
'-'                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
	byte	$10, $68, $0e, $f4
'-'         if_x0   jmp     #.other
	byte	$50, $01, $90, $5d
'-'                 loc     ptra, #clr_port_feat
	byte	$68, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
	byte	$01, $21, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
	byte	$00, $68, $0e, $f4
'-'         if_x0   jmp     #.disconnect
	byte	$7c, $01, $90, $5d
'-'                 mov     hctwait, _100ms_
	byte	$b1, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-' 
'-'                 loc     ptra, #set_port_feat            ' reset port
	byte	$40, $02, $d0, $fe
'-'                 wrword  #HUB_PORT_RESET, ptra[wValue]
	byte	$01, $09, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp3, #2
	byte	$02, $78, $07, $f6
'-' .wait_reset
'-'                 mov     hctwait, _8ms_
	byte	$ad, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$34, $02, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, urx_buff_p
	byte	$27, $69, $02, $fb
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
	byte	$14, $68, $0e, $f4
'-'         if_x0   djnz    htmp3, #.wait_reset
	byte	$f7, $79, $6f, $5b
'-' 
'-'                 loc     ptra, #clr_port_feat
	byte	$10, $02, $d0, $fe
'-'                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $fc
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-' 
'-'                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
	byte	$24, $72, $07, $f6
'-' .wait_recover
'-'                 mov     hctwait, _1ms_
	byte	$a8, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 djnz    htmp,#.wait_recover
	byte	$fd, $73, $6f, $fb
'-' 
'-'                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
	byte	$09, $68, $16, $f4
'-'         if_c    bith    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $26, $c4
'-'         if_c    bith    _usb_h_ls_nco_, #14
	byte	$0e, $6a, $27, $c4
'-' 
'-'                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
	byte	$00, $08, $00, $ff, $00, $bc, $06, $f6
'-'                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
	byte	$8c, $01, $d0, $fe
'-'                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
	byte	$03, $11, $5c, $fc
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
	byte	$28, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$48, $01, $90, $5d
'-' .get_dev_desc
'-'                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
	byte	$28, $ed, $03, $f6
'-'                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
	byte	$07, $ec, $07, $f1
'-'                 rdbyte  max_pkt_size, pa
	byte	$f6, $ab, $c2, $fa
'-'                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
	byte	$80, $01, $d0, $fe
'-'                 mov     htmp, hdev_port             ' Address is hub port number
	byte	$2d, $73, $03, $f6
'-'                 wrword  htmp, ptra[wValue]
	byte	$01, $73, $57, $fc
'-'                 call    #control_write                  ' Execute SetAddress()
	byte	$a0, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$24, $01, $90, $5d
'-'                 mov     hctwait, _8ms_
	byte	$ad, $99, $02, $f6
'-'                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
	byte	$ef, $02, $a0, $fd
'-'                 mov     ep_addr_pid, hdev_port
	byte	$2d, $bd, $02, $f6
'-'                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
	byte	$08, $bc, $66, $f0
'-'                 call    #calc_crc5
	byte	$be, $00, $a0, $fd
'-'                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
	byte	$3c, $01, $d0, $fe
'-'                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
	byte	$28, $ef, $03, $f6
'-'                 rdbyte  total_data, pb
	byte	$f7, $ad, $c2, $fa
'-'                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
	byte	$03, $ad, $56, $fc
'-'                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done                          ' Back to idle if not ACK
	byte	$f4, $00, $90, $5d
'-'                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
	byte	$5e, $d9, $02, $f6
'-'                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
	byte	$28, $f1, $03, $f6
'-'                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
'-'                 mov     hctwait, _500us_
	byte	$a0, $99, $02, $f6
'-'                 call    #poll_waitx
	byte	$ef, $02, $a0, $fd
'-'                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
	byte	$18, $01, $d0, $fe
'-'                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
	byte	$03, $ff, $5d, $fc
'-'                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
	byte	$29, $ef, $03, $f6
'-'                 call    #control_read                   ' Execute GetConfigurationDescriptor()
	byte	$55, $02, $a0, $fd
'-'                 cmp     retval, #PID_ACK        wz
	byte	$d2, $be, $0e, $f2
'-'         if_nz   jmp     #.done
	byte	$cc, $00, $90, $5d
'-'                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
	byte	$29, $f1, $03, $f6
'-'                 mov     hconfig_base, ptra              ' Will need this for configuration
	byte	$f8, $dd, $02, $f6
'-'                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
	byte	$61, $87, $c7, $fa
'-'                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
	byte	$61, $89, $c7, $fa
'-'                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
	byte	$00, $73, $e7, $fa
'-'                 cmp     hr0, #CON_DESC_LEN      wcz
	byte	$09, $86, $1f, $f2
'-'         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
	byte	$02, $88, $1f, $32
'-'         if_z    cmp     htmp, total_data        wcz
	byte	$56, $73, $1b, $a2
'-'         if_b    mov     retval, #ERR_CONFIG_FAIL
	byte	$0a, $be, $06, $c6
'-'         if_b    jmp     #.done
	byte	$a4, $00, $90, $cd
'-'                 call    #hparse_con_desc
	byte	$68, $f0, $bf, $fd
'-'                 jmp     #.done
	byte	$9c, $00, $90, $fd
'-' 
'-' .other
'-'                 testb   hub_port_status, #HUB_C_PORT_RESET wz
	byte	$14, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
	byte	$01, $29, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$28, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
	byte	$11, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
	byte	$01, $23, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$1c, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
	byte	$12, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
	byte	$01, $25, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$10, $00, $90, $ad
'-'                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
	byte	$13, $68, $0e, $f4
'-'         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
	byte	$01, $27, $5c, $ac
'-'         if_x1   jmp     #.reset_feature
	byte	$04, $00, $90, $ad
'-'                 jmp     #.done
	byte	$68, $00, $90, $fd
'-' .reset_feature
'-'                 loc     ptra, #clr_port_feat
	byte	$e4, $00, $d0, $fe
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_write
	byte	$a0, $02, $a0, $fd
'-'                 jmp     #.done
	byte	$58, $00, $90, $fd
'-' .disconnect
'-' 
'-'                 altgb   hdev_port, #hdev_type
	byte	$6a, $5b, $6e, $f9
'-'                 getbyte htmp
	byte	$00, $72, $e3, $f8
'-'                 cmp     htmp,#KB_READY wz
	byte	$03, $72, $0f, $f2
'-'         if_nz   cmp     htmp,#KBM_READY wz
	byte	$05, $72, $0f, $52
'-'         if_z    mov     hkbd_ep_addr, #0
	byte	$00, $f2, $06, $a6
'-'         if_z    mov     hkbd_ctrl_ep, #0
	byte	$00, $f0, $06, $a6
'-'         if_z    mov     kb_led_states, #0
	byte	$00, $76, $06, $a6
'-'         if_z    mov     hkbd_ledstates, kb_led_states
	byte	$3b, $f9, $02, $a6
'-'         if EMUPAD_MAX_PLAYER > 0
'-'         end
'-'         if HAVE_MOUSE
'-'                 cmp     htmp, #M_READY          wz
	byte	$04, $72, $0f, $f2
'-'         if_nz   cmp     htmp, #KBM_READY        wz
	byte	$05, $72, $0f, $52
'-'         if_z    mov     hmouse_ep_addr, #0
	byte	$00, $f4, $06, $a6
'-'         end
'-'         if HAVE_HIDPAD
'-'                 loc ptrb,#hidpad_report
	byte	$30, $0a, $f0, $fe
'-'                 mov htmp,hdev_port
	byte	$2d, $73, $03, $f6
'-'                 cmpsub htmp,#1
	byte	$01, $72, $e7, $f2
'-'                 mul htmp,#HIDPAD_REPORT_SIZE
	byte	$20, $72, $07, $fa
'-'                 add ptrb,htmp
	byte	$b9, $f3, $03, $f1
'-'                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
	byte	$28, $0e, $64, $fd
'-'                 wrlong #0,ptrb
	byte	$80, $01, $6c, $fc
'-'         end
'-' 
'-'                 altsb   hdev_port, #hdev_type
	byte	$6a, $5b, $66, $f9
'-'                 setbyte #0
	byte	$00, $00, $c4, $f8
'-'                 altd    hdev_port, #hdev_ep_addr
	byte	$7d, $5b, $8e, $f9
'-'                 mov     0-0, #0
	byte	$00, $00, $04, $f6
'-' 
'-' .done
'-'                 bitl    _usb_h_ls_nco_, #14     wcz
	byte	$0e, $6a, $1f, $f4
'-'                 bitl    hstatus, #DWNSTRM_HUBB
	byte	$07, $96, $06, $f4
'-'         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
	byte	$22, $6f, $13, $cc
'-'                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
	byte	$40, $aa, $06, $f6
'-'                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
	byte	$a6, $9d, $02, $f6
'-'                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
	byte	$a4, $9b, $02, $f6
'-' 
'-'                 loc     ptra, #get_port_status          ' Get HUB port status
	byte	$6c, $00, $d0, $fe
'-'                 mov     pb, urx_buff_p
	byte	$27, $ef, $03, $f6
'-'                 wrword  hdev_port, ptra[wIndex]
	byte	$02, $5b, $56, $fc
'-'                 call    #control_read
	byte	$55, $02, $a0, $fd
'-'                 rdlong  hub_port_status, ptra
	byte	$00, $69, $06, $fb
'-'                 debug(udec(hdev_port), ubin_long(hub_port_status))
'-'                 ret
	byte	$2d, $00, $64, $fd
'-' 
'-' '------------------------------------------------------------------------------
'-' ' Partially populated SETUP packets
'-' '------------------------------------------------------------------------------
'-' get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_DEVICE << 8
	byte	$00, $01
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_CONFIG << 8
	byte	$00, $02
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_CONFIG
	byte	$09
'-'                 word    0       ' Configuration value
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
	byte	$00, $00
'-' set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
	byte	$00
'-'                 byte    REQ_SET_ADDR
	byte	$05
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero
	byte	$00, $00
'-'                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
'-' ' wValue field dictates which protocol should be used.
'-' '
'-' ' When initialized, all devices default to report protocol. However the host
'-' ' should not make any assumptions about the device state and should set the
'-' ' desired protocol whenever initializing a device.
'-' '------------------------------------------------------------------------------
'-' set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_PROTO
	byte	$0b
'-'                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
	byte	$00, $00
'-'                                                 ' (HID 1.11 Section 7.2.6).
'-'                 word    0               ' Interface index number.
	byte	$00, $00
'-'                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_IDLE
	byte	$0a
'-'                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
	byte	$00, $00
'-'                                         ' reporting until a change is detected in the report data
'-' 
'-'                                         ' (HID 1.11 Section 7.2.4).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
	byte	$00, $00
'-' set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
	byte	$21
'-'                 byte    HID_SET_REPORT
	byte	$09
'-'                 word    0       ' Byte1 = report type, byte0 = ReportID.
	byte	$00, $00
'-'                                         ' (HID 1.11 Section 7.2.2).
'-'                 word    0       ' Interface index number.
	byte	$00, $00
'-'                 word    0       ' Size of the report, in bytes.
	byte	$00, $00
'-' get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
	byte	$81
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_REPORT << 8
	byte	$00, $22
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' '------------------------------------------------------------------------------
'-' get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
	byte	$a0
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_HUB << 8
	byte	$00, $29
'-'                 word    0       ' Zero or Language ID (Section 9.6.7)
	byte	$00, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_SET_FEATURE
	byte	$03
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
	byte	$23
'-'                 byte    REQ_CLEAR_FEATURE
	byte	$01
'-'                 word    0       ' port power
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    0       ' Number of bytes to transfer if there is a data stage
	byte	$00, $00
'-' get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
	byte	$a3
'-'                 byte    REQ_GET_STATUS
	byte	$00
'-'                 word    0
	byte	$00, $00
'-'                 word    1       ' Port index number (1+)
	byte	$01, $00
'-'                 word    4       ' Number of bytes to transfer if there is a data stage
	byte	$04, $00
'-' '------------------------------------------------------------------------------
'-' if _HAVE_GAMEPAD
'-' ps3_enable_cmd  byte    $42, $0C, $00, $00
	byte	$42, $0c, $00, $00
'-' ps3_command_buff
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
	byte	$00, $00, $00, $00, $02
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $FF, $27, $10, $00, $32
	byte	$ff, $27, $10, $00, $32
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' '------------------------------------------------------------------------------
'-' xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
	byte	$01, $03, $06
'-'                                         ' 0x01 All blinking
'-'                                         ' 0x02 1 flashes, then on
'-'                                         ' 0x03 2 flashes, then on
'-'                                         ' 0x04 3 flashes, then on
'-'                                         ' 0x05 4 flashes, then on
'-'                                         ' 0x06 1 on
'-'                                         ' 0x07 2 on
'-'                                         ' 0x08 3 on
'-'                                         ' 0x09 4 on
'-'                                         ' 0x0A Rotating (e.g. 1-2-4-3)
'-'                                         ' 0x0B Blinking*
'-'                                         ' 0x0C Slow blinking*
'-'                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
'-' xinp_rumble_cmd byte    $00, $08, $00
	byte	$00, $08, $00
'-'                 byte    $00             ' Left rumble
	byte	$00
'-'                 byte    $00             ' Right rumble
	byte	$00
'-'                 byte    $00, $00, $00
	byte	$00, $00, $00
'-' 
'-' xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
'-'                 '' of certain wired 8bitdo gamepads.
'-'                 byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
	byte	$80
'-'                 byte    REQ_GET_DESC
	byte	$06
'-'                 word    TYPE_STRING << 8 + 4
	byte	$04, $03
'-'                 word    $0409   ' Zero or Language ID (Section 9.6.7)
	byte	$09, $04
'-'                 word    2       ' Number of bytes to transfer if there is a data stage
	byte	$02, $00
'-' end
	byte	$00
'-' alignl
'-' 
'-' if HAVE_MOUSE
'-' mouse_limits long 0[2]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' mouse_outptr long 0
	byte	$00, $00, $00, $00
'-' end
'-' 
'-' if KEYQUEUE_SIZE > 0
'-' keyq_head byte 0
	byte	$00
'-' keyq_tail byte 0
	byte	$00
'-' keyq_data long 0[KEYQUEUE_SIZE]
	byte	$00[514]
'-' alignl
'-' end
'-' 
'-' if EMUPAD_MAX_PLAYER > 0
'-' emupad_rule_buffer
'-' if EMUPAD_BUILTIN_RULES
'-' file "padmap_builtin.dat"
'-' end
'-' byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
'-' '' Default rule directly follows!
'-' byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
'-' end
'-' 
'-' '------------------------------------------------------------------------------
'-' ' The USB data cache area gets zero-filled at every device disconnect
'-' '------------------------------------------------------------------------------
'-' usb_cache_start
'-' 
'-' ' HID descriptor and report buffers
'-' if !!OVERLAP_MEMORY
'-' hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
	byte	$00[1792]
'-' end
'-' hkbd_report     byte    0[8]
	byte	$00, $00, $00, $00, $00, $00, $00, $00
'-' hkbd_led_rep    byte    0
	byte	$00, $00, $00, $00
'-' alignl
'-' 
'-' hid_stack       long 0[(hidr_end - hidr_state) * 1]
	byte	$00[20]
'-' 
'-' if HAVE_HIDPAD
'-' hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
	byte	$00[224]
'-' end
'-' 
'-' ' HUB descriptor
'-' hub_descr       byte    0   ' bDescLength
	byte	$00
'-'                 byte    0   ' bDescriptorType
	byte	$00
'-'                 byte    0   ' bNbrPorts
	byte	$00
'-'                 word    0   ' wHubCharacteristics
	byte	$00, $00
'-'                 byte    0   ' bPwrOn2PwrGood
	byte	$00
'-'                 byte    0   ' bHubContrCurrent
	byte	$00
'-'                 byte    0   ' DeviceRemoveable
	byte	$00
'-'                 byte    0   ' PortPwrCtrlMask
	byte	$00
'-' 
'-' usb_cache_end
'-' 
'-' if HAVE_MOUSE
'-' mouse_xacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_yacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_zacc      long 0
	byte	$00, $00, $00, $00
'-' mouse_bstate    byte 0
	byte	$00
'-' mouse_lpending  byte 0
	byte	$00
'-' mouse_rpending  byte 0
	byte	$00
'-' mouse_mpending  byte 0
	byte	$00
'-' mouse_lock      byte 0
	byte	$00
'-'                 byte 0[3] ' padding
	byte	$00, $00, $00
'-' end
'-' 
'-' urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
	byte	$00[128]
'-' dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
	byte	$00[18]
'-' con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
	byte	$00[256]
'-' 
'-' driver_cog      byte    0                       ' Current driver cog + 1
	byte	$00
	alignl
__system__dat_
	byte	$00[8]
	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00[24]
	byte	$01, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00
	long	(0 {__system___tx})<<20
	long	(1 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(12 {__system___rxtxioctl_0153})<<20
	long	(13 {__system____dummy_flush_0154})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(0 {__system___tx})<<20
	long	(1 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(12 {__system___rxtxioctl_0153})<<20
	long	(13 {__system____dummy_flush_0154})<<20
	byte	$00[8]
	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
	byte	$00, $00, $00, $00, $00, $00, $00, $00
	long	(0 {__system___tx})<<20
	long	(1 {__system___rx})<<20
	byte	$00, $00, $00, $00
	long	(12 {__system___rxtxioctl_0153})<<20
	long	(13 {__system____dummy_flush_0154})<<20
	byte	$00[368]
__methodtable__
	long	@__system___tx
	long	@__system___rx
	long	@_hg010b_spin2_putchar
	long	@_getchar
	long	@__system___struct___bas_wrap_sender_tx_
	long	@__system___struct___bas_wrap_sender_rx_
	long	@__system___struct___bas_wrap_sender_close_
	long	@__system___struct__s_vfs_file_t_putchar_
	long	@__system___struct__s_vfs_file_t_getchar_
	long	@__system____default_putc
	long	@__system____default_getc
	long	@__system____default_flush
	long	@__system___rxtxioctl_0153
	long	@__system____dummy_flush_0154
__heap_base
	long	0[1502]
objmem
	long	0[28439]
stackspace
	long	0[1]
	org	COG_BSS_START
_var01
	res	1
_var02
	res	1
_var03
	res	1
_var04
	res	1
_var05
	res	1
_var06
	res	1
_var07
	res	1
_var08
	res	1
arg01
	res	1
arg02
	res	1
arg03
	res	1
arg04
	res	1
arg05
	res	1
local01
	res	1
local02
	res	1
local03
	res	1
local04
	res	1
local05
	res	1
local06
	res	1
local07
	res	1
local08
	res	1
local09
	res	1
local10
	res	1
local11
	res	1
local12
	res	1
local13
	res	1
muldiva_
	res	1
muldivb_
	res	1
	fit	480
