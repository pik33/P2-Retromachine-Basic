00000                 | 
00000                 | #line 1 "D:/programowanie/p2-retromachine/Propeller/Basic/psram4.p2asm"
00000                 | con
00000                 | 	_clkfreq = 20000000
00000                 | 	_clkmode = 16779595
00000                 | '     
00000                 | '     ' P2 EDGE with PSRAM pin mappings (P2-EC32MB)
00000                 | '    DATABUS  = 48
00000                 | 	DATABUS = 48
00000                 | '     CLK_PIN  = 55
00000                 | 	CLK_PIN = 55
00000                 | '     CE_PIN   = 54
00000                 | 	CE_PIN = 54
00000                 | ' '    DATABUS  = 0
00000                 | '   '  CLK_PIN  = 7
00000                 | '  '   CE_PIN   = 6
00000                 | ' 
00000                 | '     ' number of address bits used in 8MB of PSRAM
00000                 | '     ADDRSIZE = 23   
00000                 | 	ADDRSIZE = 23
00000                 | ' 
00000                 | '     ' 8 microsecond CS low time
00000                 | '     MAX_CS_LOW_USEC = 8
00000                 | 	MAX_CS_LOW_USEC = 8
00000                 | ' 
00000                 | '     ' optional FLAGS for driver
00000                 | '     FLAGS = 1<<driver.EXPANSION_BIT
00000                 | 	FLAGS = 268435456
00000                 | '     
00000                 | '     ' These error codes are compatible with the larger, complete driver
00000                 | '     ERR_INVALID      =  -6 ' invalid arguments
00000                 | 	ERR_INVALID = -6
00000                 | '     ERR_TOO_SLOW     = -14 ' can't send sufficient data at this P2 clock speed
00000                 | 	ERR_TOO_SLOW = -14
00000                 | '     ERR_INACTIVE     = -15 ' driver is not running
00000                 | 	ERR_INACTIVE = -15
00000                 | '     ERR_ABORTED      = -16 ' driver was shutdown
00000                 | 	ERR_ABORTED = -16
00000                 | '     ERR_WOULD_BLOCK  = -24
00000                 | 	ERR_WOULD_BLOCK = -24
00000                 | '     ERR_NO_LOCK      = -26 ' no LOCK available for driver
00000                 | 	ERR_NO_LOCK = -26
00000                 | '     ERR_MAILBOX_BUSY = -28 ' mailbox still has operation pending
00000                 | 	ERR_MAILBOX_BUSY = -28
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 20000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $100094b
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 7C 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 02 90 5D |  if_ne	jmp	#spininit
0040c 002 BD F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 01 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 04 80 80 FF 
00420 007 00 90 66 FD | 	hubset	##16779592
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 04 80 00 FF 
00430 00b 4B ED 07 F6 | 	mov	pa, ##16779595
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 96 98 80 FF 
00440 00f 14 00 6E FC | 	wrlong	##20000000, #20
00444 010 BC 01 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
005fc 07e 00 00 00 00 
00600 07f 00 00 00 00 | 	orgf	128
00604 080             | skip_clock_set_
00604 080 00 07 A0 FD | 	call	#_start
00608 081             | cogexit
00608 081 38 01 80 FF 
0060c 082 1F 00 66 FD | 	waitx	##160000
00610 083 01 82 61 FD | 	cogid	arg01
00614 084 03 82 61 FD | 	cogstop	arg01
00618 085             | spininit
00618 085 61 75 05 FB | 	rdlong	objptr, ptra++
0061c 086 61 7D 05 FB | 	rdlong	result1, ptra++
00620 087 28 06 64 FD | 	setq	#3
00624 088 00 83 05 FB | 	rdlong	arg01, ptra
00628 089 04 F0 87 F1 | 	sub	ptra, #4
0062c 08a 2D 7C 61 FD | 	call	result1
00630 08b D4 FF 9F FD | 	jmp	#cogexit
00634 08c             | FCACHE_LOAD_
00634 08c F9 2D 01 F6 |     mov	fcache_tmpb_,ptrb
00638 08d 2B F2 63 FD |     pop	ptrb
0063c 08e 95 EC 8B F9 |     altd	pa,ret_instr_
00640 08f 95 00 00 F6 |     mov	 0-0, ret_instr_
00644 090 28 EC 63 FD |     setq	pa
00648 091 E1 01 04 FB |     rdlong	$0, ptrb++
0064c 092 2A F2 63 FD |     push	ptrb
00650 093 96 F2 03 F6 |     mov ptrb,fcache_tmpb_
00654 094 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00658 095             | ret_instr_
00658 095 00 FE 07 02 |     _ret_ cmp inb,#0
0065c 096             | fcache_tmpb_
0065c 096 00 00 00 00 |     long 0
00660 097             | fcache_load_ptr_
00660 097 8C 00 00 00 |     long FCACHE_LOAD_
00664 098             | builtin_bytefill_
00664 098 01 86 55 F0 |         shr	arg03, #1 wc
00668 099 C1 84 41 CC |  if_c   wrbyte	arg02, arg01
0066c 09a 01 82 05 C1 |  if_c   add	arg01, #1
00670 09b 00 84 FD F9 |         movbyts	arg02, #0
00674 09c             | builtin_wordfill_
00674 09c 01 86 55 F0 |         shr	arg03, #1 wc
00678 09d C1 84 51 CC |  if_c   wrword	arg02, arg01
0067c 09e 02 82 05 C1 |  if_c   add	arg01, #2
00680 09f C2 84 29 F9 |         setword	arg02, arg02, #1
00684 0a0             | builtin_longfill_
00684 0a0 C1 00 88 FC |         wrfast	#0,arg01
00688 0a1 00 86 0D F2 |         cmp	arg03, #0 wz
0068c 0a2 C3 02 D8 5C |  if_nz  rep	#1, arg03
00690 0a3 17 84 61 5D |  if_nz  wflong	arg02
00694 0a4 2D 00 64 FD |         ret
00698 0a5             | COUNT_
00698 0a5 00 00 00 00 |     long 0
0069c 0a6             | RETADDR_
0069c 0a6 00 00 00 00 |     long 0
006a0 0a7             | fp
006a0 0a7 00 00 00 00 |     long 0
006a4 0a8             | pushregs_
006a4 0a8 2B EC 63 FD |     pop  pa
006a8 0a9 2B 4C 61 FD |     pop  RETADDR_
006ac 0aa 03 4A 95 FB |     tjz  COUNT_, #pushregs_done_
006b0 0ab FF 4B 8D F9 |     altd  COUNT_, #511
006b4 0ac 28 00 64 FD |     setq #0-0
006b8 0ad 61 8B 65 FC |     wrlong local01, ptra++
006bc 0ae             | pushregs_done_
006bc 0ae 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
006c0 0af 61 4B 65 FC |     wrlong COUNT_, ptra++
006c4 0b0 F8 4F 01 F6 |     mov    fp, ptra
006c8 0b1 2C EC 63 FD |     jmp  pa
006cc 0b2             |  popregs_
006cc 0b2 2B EC 63 FD |     pop    pa
006d0 0b3 28 04 64 FD |     setq   #2
006d4 0b4 5F 4B 05 FB |     rdlong COUNT_, --ptra
006d8 0b5 02 4A 75 FB |     djf    COUNT_, #popregs__ret
006dc 0b6 28 4A 61 FD |     setq   COUNT_
006e0 0b7 5F 8B 05 FB |     rdlong local01, --ptra
006e4 0b8             | popregs__ret
006e4 0b8 2A 4C 61 FD |     push   RETADDR_
006e8 0b9 2C EC 63 FD |     jmp    pa
006ec 0ba             | 
006ec 0ba             | objptr
006ec 0ba 50 19 00 00 | 	long	@objmem
006f0 0bb             | ptr__dat__
006f0 0bb 98 09 00 00 | 	long	@_dat_
006f4 0bc             | ptr__psram4drv_dat__
006f4 0bc E0 0B 00 00 | 	long	@_psram4drv_dat_
006f8 0bd             | ptr_stackspace_
006f8 0bd 50 19 00 00 | 	long	@stackspace
006fc 0be             | result1
006fc 0be 00 00 00 00 | 	long	0
00700 0bf             | COG_BSS_START
00700 0bf             | 	fit	480
00700                 | 	orgh
00700                 | hubentry
00700                 | 
00700                 | ' 
00700                 | ' '..............................................................................
00700                 | ' 
00700                 | ' {{
00700                 | ' }}
00700                 | ' PUB start() : result
00700                 | _start
00700                 | '     return startx(0, 0, 0, -1)
00700     00 82 05 F6 | 	mov	arg01, #0
00704     00 84 05 F6 | 	mov	arg02, #0
00708     00 86 05 F6 | 	mov	arg03, #0
0070c     01 88 65 F6 | 	neg	arg04, #1
00710     04 00 B0 FD | 	call	#_startx
00714                 | _start_ret
00714     2D 00 64 FD | 	ret
00718                 | 
00718                 | ' 
00718                 | ' '..............................................................................
00718                 | ' 
00718                 | ' {{
00718                 | ' }}
00718                 | ' PUB startx(freq, burst, delay, desiredcog) : result | driverAddr
00718                 | _startx
00718     04 4A 05 F6 | 	mov	COUNT_, #4
0071c     A8 00 A0 FD | 	call	#pushregs_
00720     C1 8A 01 F6 | 	mov	local01, arg01
00724     C3 8C 01 F6 | 	mov	local02, arg03
00728     C4 8E 01 F6 | 	mov	local03, arg04
0072c                 | '     stop() ' restart driver if required
0072c     54 01 B0 FD | 	call	#_stop
00730     00 8A 0D F2 | 	cmp	local01, #0 wz
00734     14 8A 05 AB |  if_e	rdlong	local01, #20
00738     C5 84 51 F6 | 	abs	arg02, local01 wc
0073c     84 1E 00 FF 
00740     00 85 15 FD | 	qdiv	arg02, ##4000000
00744                 | ' 
00744                 | '     ' use current frequency if none specified
00744                 | ' 
00744                 | '     if freq == 0 
00744                 | '         freq := clkfreq 
00744                 | ' 
00744                 | '     ' compute the device burst size including overheads to keep CS low time below 8us
00744                 | ' 
00744                 | '     burst := (((MAX_CS_LOW_USEC*(freq/4000000)) - 132) >> 4) << 4  ' some sane rounded value
00744                 | '     if burst < 0
00744                 | '         return ERR_TOO_SLOW ' P2 frequency is too low for any 8us transfers
00744     18 84 61 FD | 	getqx	arg02
00748     C2 88 81 F6 | 	negc	arg04, arg02
0074c     03 88 65 F0 | 	shl	arg04, #3
00750     84 88 85 F1 | 	sub	arg04, #132
00754     04 88 45 F0 | 	shr	arg04, #4
00758     04 88 65 F0 | 	shl	arg04, #4
0075c     00 88 55 F2 | 	cmps	arg04, #0 wc
00760     0E 7C 65 C6 |  if_b	neg	result1, #14
00764     10 01 90 CD |  if_b	jmp	#LR__0004
00768                 | ' 
00768                 | '     ' compute the input delay
00768                 | ' 
00768                 | '     if delay <= 0
00768     01 8C 55 F2 | 	cmps	local02, #1 wc
0076c     10 00 90 3D |  if_ae	jmp	#LR__0001
00770                 | '         delay := lookupDelay(freq)
00770     C5 82 01 F6 | 	mov	arg01, local01
00774     D4 01 B0 FD | 	call	#_lookupDelay
00778     BE 8C 01 F6 | 	mov	local02, result1
0077c     04 00 90 FD | 	jmp	#LR__0002
00780                 | LR__0001
00780                 | '     else
00780                 | '         delay <#= $f ' limit to 15
00780     0F 8C 65 F3 | 	fles	local02, #15
00784                 | LR__0002
00784                 | ' 
00784                 | '     ' create our lock
00784                 | ' 
00784                 | '     driverlock := LOCKNEW()  
00784     00 7C 05 F6 | 	mov	result1, #0
00788     04 7C 61 FD | 	locknew	result1
0078c     04 77 05 F1 | 	add	ptr__dat__, #260
00790     BB 7C 61 FC | 	wrlong	result1, ptr__dat__
00794                 | '     if driverlock == -1
00794     04 77 85 F1 | 	sub	ptr__dat__, #260
00798     FF FF 7F FF 
0079c     FF 7D 0D F2 | 	cmp	result1, ##-1 wz
007a0                 | '         return ERR_NO_LOCK
007a0     1A 7C 65 A6 |  if_e	neg	result1, #26
007a4     D0 00 90 AD |  if_e	jmp	#LR__0004
007a8                 | ' 
007a8                 | '     ' patch in the proper data and HUB addresses to the startup structure
007a8                 | ' 
007a8                 | '     long[@startupData][0]:=clkfreq
007a8     14 8A 05 FB | 	rdlong	local01, #20
007ac     28 77 05 F1 | 	add	ptr__dat__, #296
007b0     BB 8A 61 FC | 	wrlong	local01, ptr__dat__
007b4                 | '     long[@startupData][5]:=@deviceData
007b4     20 76 05 F1 | 	add	ptr__dat__, #32
007b8     BB 8A 01 F6 | 	mov	local01, ptr__dat__
007bc     20 76 85 F1 | 	sub	ptr__dat__, #32
007c0     BB 84 01 F6 | 	mov	arg02, ptr__dat__
007c4     14 84 05 F1 | 	add	arg02, #20
007c8     C2 8A 61 FC | 	wrlong	local01, arg02
007cc                 | '     long[@startupData][6]:=@qosData
007cc     A0 76 05 F1 | 	add	ptr__dat__, #160
007d0     BB 8A 01 F6 | 	mov	local01, ptr__dat__
007d4     A0 76 85 F1 | 	sub	ptr__dat__, #160
007d8     BB 84 01 F6 | 	mov	arg02, ptr__dat__
007dc     18 84 05 F1 | 	add	arg02, #24
007e0     C2 8A 61 FC | 	wrlong	local01, arg02
007e4                 | '     long[@startupData][7]:=@mailboxes
007e4     C0 76 05 F1 | 	add	ptr__dat__, #192
007e8     BB 8A 01 F6 | 	mov	local01, ptr__dat__
007ec     C0 76 85 F1 | 	sub	ptr__dat__, #192
007f0     BB 84 01 F6 | 	mov	arg02, ptr__dat__
007f4     1C 84 05 F1 | 	add	arg02, #28
007f8     C2 8A 61 FC | 	wrlong	local01, arg02
007fc                 | ' 
007fc                 | '     ' setup some default bank and QoS parameter values
007fc                 | ' 
007fc                 | '     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
007fc     20 76 05 F1 | 	add	ptr__dat__, #32
00800     BB 82 01 F6 | 	mov	arg01, ptr__dat__
00804     48 77 85 F1 | 	sub	ptr__dat__, #328
00808     10 88 65 F0 | 	shl	arg04, #16
0080c     0C 8C 65 F0 | 	shl	local02, #12
00810     C6 88 41 F5 | 	or	arg04, local02
00814     16 88 45 F5 | 	or	arg04, #22
00818     C4 84 01 F6 | 	mov	arg02, arg04
0081c     02 86 05 F6 | 	mov	arg03, #2
00820     A0 00 A0 FD | 	call	#\builtin_longfill_
00824                 | '     longfill(@qosData, $7FFF0000, 8)
00824     C8 77 05 F1 | 	add	ptr__dat__, #456
00828     07 86 05 F6 | 	mov	arg03, #7
0082c     28 86 61 FD | 	setq	arg03
00830     80 FF BF FF 
00834     BB 00 68 FC | 	wrlong	##2147418112, ptr__dat__
00838                 | ' 
00838                 | '     ' get the address of the PSRAM memory driver so we can start it
00838                 | ' 
00838                 | '     driverAddr:= driver.getDriverAddr()
00838                 | '     return @driver_start
00838     BC 84 01 F6 | 	mov	arg02, ptr__psram4drv_dat__
0083c                 | ' 
0083c                 | '     ' start the PSRAM memory driver and wait for it to complete initialization
0083c                 | ' 
0083c                 | '     if desiredcog < 0
0083c     00 8E 55 F2 | 	cmps	local03, #0 wc
00840                 | '         desiredcog := NEWCOG
00840     10 8E 05 C6 |  if_b	mov	local03, #16
00844                 | '     drivercog := coginit(desiredcog, driverAddr, @startupData)
00844     A0 76 85 F1 | 	sub	ptr__dat__, #160
00848     C7 90 01 F6 | 	mov	local04, local03
0084c     28 76 61 FD | 	setq	ptr__dat__
00850     C2 90 F1 FC | 	coginit	local04, arg02 wc
00854     01 90 65 C6 |  if_b	neg	local04, #1
00858     28 76 85 F1 | 	sub	ptr__dat__, #40
0085c     BB 90 61 FC | 	wrlong	local04, ptr__dat__
00860                 | '     repeat until long[@startupData] == 0 
00860     28 76 05 F1 | 	add	ptr__dat__, #40
00864                 | LR__0003
00864     BB 90 09 FB | 	rdlong	local04, ptr__dat__ wz
00868     F8 FF 9F 5D |  if_ne	jmp	#LR__0003
0086c                 | ' 
0086c                 | '     return drivercog
0086c     28 76 85 F1 | 	sub	ptr__dat__, #40
00870     BB 7C 01 FB | 	rdlong	result1, ptr__dat__
00874     00 77 85 F1 | 	sub	ptr__dat__, #256
00878                 | LR__0004
00878     A7 F0 03 F6 | 	mov	ptra, fp
0087c     B2 00 A0 FD | 	call	#popregs_
00880                 | _startx_ret
00880     2D 00 64 FD | 	ret
00884                 | 
00884                 | ' 
00884                 | ' '..............................................................................
00884                 | ' 
00884                 | ' {{
00884                 | ' }}
00884                 | ' PUB stop() : i
00884                 | _stop
00884     00 7E 05 F6 | 	mov	_var01, #0
00888                 | '     if drivercog <> -1
00888     00 77 05 F1 | 	add	ptr__dat__, #256
0088c     BB 82 01 FB | 	rdlong	arg01, ptr__dat__
00890     00 77 85 F1 | 	sub	ptr__dat__, #256
00894     FF FF 7F FF 
00898     FF 83 0D F2 | 	cmp	arg01, ##-1 wz
0089c     78 00 90 AD |  if_e	jmp	#LR__0013
008a0                 | '         cogstop(drivercog) ' a rather brutal stop
008a0     00 77 05 F1 | 	add	ptr__dat__, #256
008a4     BB 82 01 FB | 	rdlong	arg01, ptr__dat__
008a8     00 77 85 F1 | 	sub	ptr__dat__, #256
008ac     03 82 61 FD | 	cogstop	arg01
008b0     97 2A 48 FB | 	callpa	#(@LR__0012-@LR__0010)>>2,fcache_load_ptr_
008b4                 | '         repeat i from 0 to 7
008b4                 | LR__0010
008b4                 | '             if long[@mailboxes][i*3] < 0
008b4     E8 77 05 F1 | 	add	ptr__dat__, #488
008b8     BF 7C 01 F6 | 	mov	result1, _var01
008bc     01 7C 65 F0 | 	shl	result1, #1
008c0     BF 7C 01 F1 | 	add	result1, _var01
008c4     02 7C 65 F0 | 	shl	result1, #2
008c8     BB 7C 01 F1 | 	add	result1, ptr__dat__
008cc     BE 7C 01 FB | 	rdlong	result1, result1
008d0     00 7C 55 F2 | 	cmps	result1, #0 wc
008d4     E8 77 85 F1 | 	sub	ptr__dat__, #488
008d8     20 00 90 3D |  if_ae	jmp	#LR__0011
008dc                 | '                 long[@mailboxes][i*3] := -ERR_ABORTED ' abort request
008dc     E8 77 05 F1 | 	add	ptr__dat__, #488
008e0     BF 7C 01 F6 | 	mov	result1, _var01
008e4     01 7C 65 F0 | 	shl	result1, #1
008e8     BF 7C 01 F1 | 	add	result1, _var01
008ec     02 7C 65 F0 | 	shl	result1, #2
008f0     BB 7C 01 F1 | 	add	result1, ptr__dat__
008f4     BE 20 68 FC | 	wrlong	#16, result1
008f8     E8 77 85 F1 | 	sub	ptr__dat__, #488
008fc                 | LR__0011
008fc     01 7E 05 F1 | 	add	_var01, #1
00900     08 7E 55 F2 | 	cmps	_var01, #8 wc
00904     AC FF 9F CD |  if_b	jmp	#LR__0010
00908                 | LR__0012
00908                 | '         drivercog := -1
00908     00 77 05 F1 | 	add	ptr__dat__, #256
0090c     FF FF FF FF 
00910     BB FE 6B FC | 	wrlong	##-1, ptr__dat__
00914     00 77 85 F1 | 	sub	ptr__dat__, #256
00918                 | LR__0013
00918                 | '     if driverlock <> -1
00918     04 77 05 F1 | 	add	ptr__dat__, #260
0091c     BB 82 01 FB | 	rdlong	arg01, ptr__dat__
00920     04 77 85 F1 | 	sub	ptr__dat__, #260
00924     FF FF 7F FF 
00928     FF 83 0D F2 | 	cmp	arg01, ##-1 wz
0092c                 | '         LOCKRET(driverlock)
0092c     04 77 05 51 |  if_ne	add	ptr__dat__, #260
00930     BB 82 01 5B |  if_ne	rdlong	arg01, ptr__dat__
00934     05 82 61 5D |  if_ne	lockret	arg01
00938                 | '         driverlock := -1
00938     FF FF FF 5F 
0093c     BB FE 6B 5C |  if_ne	wrlong	##-1, ptr__dat__
00940     04 77 85 51 |  if_ne	sub	ptr__dat__, #260
00944     BF 7C 01 F6 | 	mov	result1, _var01
00948                 | _stop_ret
00948     2D 00 64 FD | 	ret
0094c                 | 
0094c                 | ' 
0094c                 | ' '..............................................................................
0094c                 | ' 
0094c                 | ' {{
0094c                 | ' }}
0094c                 | ' PRI lookupDelay(freq) : delay | profile
0094c                 | _lookupDelay
0094c                 | '     profile := @delayTable
0094c     08 77 05 F1 | 	add	ptr__dat__, #264
00950     BB 7E 01 F6 | 	mov	_var01, ptr__dat__
00954                 | '     delay := long[profile][0]
00954     BF 80 01 FB | 	rdlong	_var02, _var01
00958                 | '     repeat while long[profile][1] 
00958     08 77 85 F1 | 	sub	ptr__dat__, #264
0095c     97 16 48 FB | 	callpa	#(@LR__0021-@LR__0020)>>2,fcache_load_ptr_
00960                 | LR__0020
00960     04 7E 05 F1 | 	add	_var01, #4
00964     BF 7C 09 FB | 	rdlong	result1, _var01 wz
00968     04 7E 85 F1 | 	sub	_var01, #4
0096c     1C 00 90 AD |  if_e	jmp	#LR__0022
00970                 | '         if freq +< long[profile][1] 
00970     04 7E 05 F1 | 	add	_var01, #4
00974     BF 7C 01 FB | 	rdlong	result1, _var01
00978     04 7E 85 F1 | 	sub	_var01, #4
0097c     BE 82 11 F2 | 	cmp	arg01, result1 wc
00980                 | '             quit
00980                 | '         profile += 4
00980     04 7E 05 31 |  if_ae	add	_var01, #4
00984                 | '         delay++
00984     01 80 05 31 |  if_ae	add	_var02, #1
00988     D4 FF 9F 3D |  if_ae	jmp	#LR__0020
0098c                 | LR__0021
0098c                 | LR__0022
0098c     C0 7C 01 F6 | 	mov	result1, _var02
00990                 | _lookupDelay_ret
00990     2D 00 64 FD | 	ret
00994                 | hubexit
00994     81 00 80 FD | 	jmp	#cogexit
00998                 | 	alignl
00998                 | _dat_
00998     00 00 00 00 
      ...             
00a90     00 00 00 00 
00a94     00 00 00 00 |     listdata long 0[8*8]
00a98                 |             orgh
00a98                 | 
00a98                 | ' driver state
00a98     FF FF FF FF | drivercog   long    -1  ' COG id of driver
00a9c     FF FF FF FF | driverlock  long    -1  ' LOCK id of driver
00aa0                 | 
00aa0                 | ' delay profile
00aa0     07 00 00 00 
00aa4     00 CF 7B 05 
00aa8     80 D1 F0 08 
00aac     80 4F 47 0C | delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
00ab0     80 C4 60 0F 
00ab4     80 39 7A 12 
00ab8     40 2D D9 13 
00abc     00 00 00 00 | 	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
00ac0                 | 
00ac0                 | ' data to be passed to driver when starting it
00ac0                 | startupData
00ac0     00 00 00 00 |     long    0           ' current frequency
00ac4     00 00 00 10 |     long    FLAGS       ' optional flags for driver
00ac8     00 00 00 00 |     long    0           ' reset pin mask on port A for PSRAM (none)
00acc     00 00 00 00 |     long    0           ' reset pin mask on port B for PSRAM (none)
00ad0     30 00 00 00 |     long    DATABUS     ' PSRAM data bus start pin
00ad4     E0 0A 00 00 |     long    deviceData  ' address of devices data structure in HUBRAM
00ad8     60 0B 00 00 |     long    qosData     ' address of QoS data structure in HUBRAM
00adc     80 0B 00 00 |     long    mailboxes   ' address of mailbox structure in HUBRAM
00ae0                 | 
00ae0                 | ' data for memory
00ae0                 | deviceData
00ae0                 |     ' 16 bank parameters follow (16MB per bank)
00ae0     00 00 00 00 
      ...             
00b18     00 00 00 00 
00b1c     00 00 00 00 |     long    0[16]                               ' banks 0-15
00b20                 |     ' 16 banks of pin parameters follow
00b20     36 37 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
00b24     FF FF FF FF 
      ...             
00b58     FF FF FF FF 
00b5c     FF FF FF FF |     long    -1[15]                              ' banks 1-15
00b60                 | 
00b60                 | ' data for COG polling
00b60                 | qosData 
00b60     00 00 FF 7F 
00b64     00 00 FF 7F 
00b68     00 00 FF 7F 
00b6c     00 00 FF 7F |     long    $7FFF0000[8]    ' cog 0-7 default QoS parameters
00b70     00 00 FF 7F 
00b74     00 00 FF 7F 
00b78     00 00 FF 7F 
00b7c     00 00 FF 7F | 	byte	$00, $00, $ff, $7f, $00, $00, $ff, $7f, $00, $00, $ff, $7f, $00, $00, $ff, $7f
00b80                 |     
00b80                 | ' mailbox storage
00b80                 | mailboxes
00b80     00 00 00 00 
      ...             
00bd8     00 00 00 00 
00bdc     00 00 00 00 |     long    0[8*3]          ' 3 longs per mailbox per COG
00be0                 | 	alignl
00be0                 | _psram4drv_dat_
00be0                 |                             orgh
00be0                 | 
00be0                 | driver_start
00be0                 |                             org
00be0 000             | '..................................................................................................
00be0 000             | ' Memory layout for COG RAM once operational:
00be0 000             | '
00be0 000             | '  COG RAM address      Usage
00be0 000             | '  ---------------      ----
00be0 000             | '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
00be0 000             | '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
00be0 000             | '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
00be0 000             | '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
00be0 000             | '   $100-$197           Mailbox poller, error handlers, and all driver management code
00be0 000             | '  ~$198-$1F3           State and register variables
00be0 000             | '
00be0 000             | ' Also during driver COG startup:
00be0 000             | '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
00be0 000             | ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
00be0 000             | '..................................................................................................
00be0 000             |                             
00be0 000             | ' Mailbox storage after vector initialization
00be0 000             | 
00be0 000 FC 01 B0 FD | req0                        call    #init                   'do HW setup/initialization
00be4 001 EC DB AB FA | data0                       rdlut   c, b wz                 'read bank info          
00be8 002 EC D7 03 F6 | count0                      mov     a, b                    'set COGRAM address low nibble
00bec 003 68 F0 07 A6 | req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
00bf0 004 0A DA 17 F4 | data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
00bf4 005 50 F0 07 16 | count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
00bf8 006 58 F0 07 46 | req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
00bfc 007 08 DA 07 F6 | data2                       mov     c, #$8                  'setup vector base to $80
00c00 008 ED D7 0B F8 | count2                      setnib  a, c, #1                'prepare vector base address for bank
00c04 009 00 D6 8F F9 | req3                        altd    a, #0                   'prepare COG destination read address
00c08 00a 61 01 A4 FA | data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
00c0c 00b 0F DA 0F F7 | count3                      incmod  c, #15 wz               'next vector
00c10 00c EC FF 9F 5D | req4        if_nz           jmp     #count2                 'repeat
00c14 00d 0F D8 0F F7 | data4                       incmod  b, #15 wz               'next bank
00c18 00e C8 FF 9F 5D | count4      if_nz           jmp     #data0                  'repeat
00c1c 00f 20 F0 07 F6 | req5                        mov     ptra, #$20              'setup base LUT address to clear
00c20 010 50 0A DC FC | data5                       rep     #5, #80                 'update next 80 longs      
00c24 011 DF F1 13 F2 | count5                      cmp     ptra, header wc         'check if LUT address range 
00c28 012 E0 F1 93 32 | req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
00c2c 013 61 01 3C CC | data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
00c30 014 61 AB 37 3C | count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
00c34 015 A3 29 00 31 | req7        if_nc           add     $-1, const512           'increment source of LUT write data
00c38 016 FF BA 03 F6 | data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
00c3c 017 26 FF 05 06 | count7      _ret_           mov     255, #dolist            'setup list address, return to notify
00c40 018             | 
00c40 018             | ' Mailbox parameter addresses per COG once patched
00c40 018             |                             
00c40 018 04 00 00 00 | cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
00c44 019 10 00 00 00 | cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
00c48 01a 1C 00 00 00 | cog2mboxdata                long    2*12+4                  '...
00c4c 01b 28 00 00 00 | cog3mboxdata                long    3*12+4
00c50 01c 34 00 00 00 | cog4mboxdata                long    4*12+4
00c54 01d 40 00 00 00 | cog5mboxdata                long    5*12+4
00c58 01e 4C 00 00 00 | cog6mboxdata                long    6*12+4
00c5c 01f 58 00 00 00 | cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
00c60 020             | 
00c60 020             | '..................................................................................................
00c60 020             | ' Per COG request and state setup and service branching
00c60 020             |         
00c60 020             | cog0                 
00c60 020 20 F0 07 F6 |                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
00c64 021 18 F2 03 F6 |                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
00c68 022 CD BD 03 F6 |                             mov     id, id0                 'get COG0 state
00c6c 023 DE 43 3B F9 |                             getword limit, id, #1           'get COG0 burst limit
00c70 024 08 CD AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
00c74 025 30 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
00c78 026 00 AA 03 F6 |                             mov     addr1, req0             'get mailbox request parameter for COG0
00c7c 027 01 AC 03 F6 |                             mov     hubdata, data0          'get COG0 mailbox data parameter
00c80 028 02 AE 03 F6 |                             mov     count, count0           'get COG0 mailbox count parameter
00c84 029 D5 C5 FB F8 |                             getbyte request, addr1, #3      'get request + bank info
00c88 02a 00 C4 8F F9 |                             altd    request, #0             'lookup jump vector service table 
00c8c 02b 33 C4 63 FD |                             execf   request-0               'jump to service
00c90 02c             | cog1                        
00c90 02c 2A F0 07 F6 |                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
00c94 02d 19 F2 03 F6 |                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
00c98 02e CE BD 03 F6 |                             mov     id, id1                 'get COG1 state
00c9c 02f DE 43 3B F9 |                             getword limit, id, #1           'get COG1 burst limit
00ca0 030 08 CD AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
00ca4 031 00 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
00ca8 032 03 AA 03 F6 |                             mov     addr1, req1             'get mailbox request parameter for COG1
00cac 033 04 AC 03 F6 |                             mov     hubdata, data1          'get COG1 mailbox data parameter
00cb0 034 05 AE 03 F6 |                             mov     count, count1           'get COG1 mailbox count parameter
00cb4 035 D5 C5 FB F8 |                             getbyte request, addr1, #3      'get request + bank info
00cb8 036 00 C4 8F F9 |                             altd    request, #0             'lookup jump vector service table 
00cbc 037 33 C4 63 FD |                             execf   request-0               'jump to service
00cc0 038             | cog2                         
00cc0 038 34 F0 07 F6 |                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
00cc4 039 1A F2 03 F6 |                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
00cc8 03a CF BD 03 F6 |                             mov     id, id2                 'get COG2 state
00ccc 03b DE 43 3B F9 |                             getword limit, id, #1           'get COG2 burst limit
00cd0 03c 08 CD AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
00cd4 03d D0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
00cd8 03e 06 AA 03 F6 |                             mov     addr1, req2             'get mailbox request parameter for COG2
00cdc 03f 07 AC 03 F6 |                             mov     hubdata, data2          'get COG2 mailbox data parameter
00ce0 040 08 AE 03 F6 |                             mov     count, count2           'get COG2 mailbox count parameter
00ce4 041 D5 C5 FB F8 |                             getbyte request, addr1, #3      'get request + bank info
00ce8 042 00 C4 8F F9 |                             altd    request, #0             'lookup jump vector service table 
00cec 043 33 C4 63 FD |                             execf   request-0               'jump to service
00cf0 044             | cog3                        
00cf0 044 3E F0 07 F6 |                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
00cf4 045 1B F2 03 F6 |                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
00cf8 046 D0 BD 03 F6 |                             mov     id, id3                 'get COG3 state
00cfc 047 DE 43 3B F9 |                             getword limit, id, #1           'get COG3 burst limit
00d00 048 08 CD AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
00d04 049 A0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
00d08 04a 09 AA 03 F6 |                             mov     addr1, req3             'get mailbox request parameter for COG3
00d0c 04b 0A AC 03 F6 |                             mov     hubdata, data3          'get COG3 mailbox data parameter
00d10 04c 0B AE 03 F6 |                             mov     count, count3           'get COG3 mailbox count parameter
00d14 04d D5 C5 FB F8 |                             getbyte request, addr1, #3      'get request + bank info
00d18 04e 00 C4 8F F9 |                             altd    request, #0             'lookup jump vector service table 
00d1c 04f 33 C4 63 FD |                             execf   request-0               'jump to service
00d20 050             | cog4                        
00d20 050 48 F0 07 F6 |                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
00d24 051 1C F2 03 F6 |                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
00d28 052 D1 BD 03 F6 |                             mov     id, id4                 'get COG4 state
00d2c 053 DE 43 3B F9 |                             getword limit, id, #1           'get COG4 burst limit
00d30 054 08 CD AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
00d34 055 70 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
00d38 056 0C AA 03 F6 |                             mov     addr1, req4             'get mailbox request parameter for COG4
00d3c 057 0D AC 03 F6 |                             mov     hubdata, data4          'get COG4 mailbox data parameter
00d40 058 0E AE 03 F6 |                             mov     count, count4           'get COG4 mailbox count parameter
00d44 059 D5 C5 FB F8 |                             getbyte request, addr1, #3      'get request + bank info
00d48 05a 00 C4 8F F9 |                             altd    request, #0             'lookup jump vector service table 
00d4c 05b 33 C4 63 FD |                             execf   request-0               'jump to service
00d50 05c             | cog5                        
00d50 05c 52 F0 07 F6 |                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
00d54 05d 1D F2 03 F6 |                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
00d58 05e D2 BD 03 F6 |                             mov     id, id5                 'get COG5 state
00d5c 05f DE 43 3B F9 |                             getword limit, id, #1           'get COG5 burst limit
00d60 060 08 CD AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
00d64 061 40 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
00d68 062 0F AA 03 F6 |                             mov     addr1, req5             'get mailbox request parameter for COG5
00d6c 063 10 AC 03 F6 |                             mov     hubdata, data5          'get COG5 mailbox data parameter
00d70 064 11 AE 03 F6 |                             mov     count, count5           'get COG5 mailbox count parameter
00d74 065 D5 C5 FB F8 |                             getbyte request, addr1, #3      'get request + bank info
00d78 066 00 C4 8F F9 |                             altd    request, #0             'lookup jump vector service table 
00d7c 067 33 C4 63 FD |                             execf   request-0               'jump to service
00d80 068             | cog6                        
00d80 068 5C F0 07 F6 |                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
00d84 069 1E F2 03 F6 |                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
00d88 06a D3 BD 03 F6 |                             mov     id, id6                 'get COG6 state
00d8c 06b DE 43 3B F9 |                             getword limit, id, #1           'get COG6 burst limit
00d90 06c 08 CD AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
00d94 06d 10 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
00d98 06e 12 AA 03 F6 |                             mov     addr1, req6             'get mailbox request parameter for COG6
00d9c 06f 13 AC 03 F6 |                             mov     hubdata, data6          'get COG6 mailbox data parameter
00da0 070 14 AE 03 F6 |                             mov     count, count6           'get COG6 mailbox count parameter
00da4 071 D5 C5 FB F8 |                             getbyte request, addr1, #3      'get request + bank info
00da8 072 00 C4 8F F9 |                             altd    request, #0             'lookup jump vector service table 
00dac 073 33 C4 63 FD |                             execf   request-0               'jump to service
00db0 074             | cog7                        
00db0 074 66 F0 07 F6 |                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
00db4 075 1F F2 03 F6 |                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
00db8 076 D4 BD 03 F6 |                             mov     id, id7                 'get COG7 state
00dbc 077 DE 43 3B F9 |                             getword limit, id, #1           'get COG7 burst limit
00dc0 078 08 CD AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
00dc4 079 E0 02 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
00dc8 07a 15 AA 03 F6 |                             mov     addr1, req7             'get mailbox request parameter for COG7
00dcc 07b 16 AC 03 F6 |                             mov     hubdata, data7          'get COG7 mailbox data parameter
00dd0 07c 17 AE 03 F6 |                             mov     count, count7           'get COG7 mailbox count parameter
00dd4 07d D5 C5 FB F8 |                             getbyte request, addr1, #3      'get request + bank info
00dd8 07e 00 C4 8F F9 |                             altd    request, #0             'lookup jump vector service table 
00ddc 07f 33 C4 63 FD |                             execf   request-0               'jump to service
00de0 080             |                             fit     128
00de0 080             | 
00de0 080             |                             fit     128
00de0 080             | pad                         long    0[128-$]                'align init code to $80
00de0 080             | 
00de0 080             | '..................................................................................................
00de0 080             | 
00de0 080             | ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
00de0 080             | 
00de0 080             | init                        
00de0 080             |                             ' read in the additional LUT RAM code
00de0 080 F9 3D 03 F1 |                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
00de4 081 29 9E 67 FD |                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
00de8 082 9E 61 00 FB |                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
00dec 083             | 
00dec 083             |                             ' read the startup parameters
00dec 083 28 0E 64 FD |                             setq    #8-1                    'read 8 longs from hub
00df0 084 00 3D 07 FB |                             rdlong  startupparams, ptra     '.. as the startup parameters 
00df4 085             | 
00df4 085             |                             ' setup some of the config flag dependent state and patch LUTRAM
00df4 085 1C 3E 0F F4 |                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
00df8 086             | 
00df8 086 F9 6D 03 A1 |             if_z            add     expansion, ptrb         'compensate for HUB address
00dfc 087 01 00 00 5F 
00e00 088 E1 6C 07 56 |             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
00e04 089 1D 3E 17 F4 |                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
00e08 08a A8 53 43 35 |             if_nc           or      clkconfig, registered   'enable this if so
00e0c 08b 00 54 07 36 |             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
00e10 08c             | 
00e10 08c             |                             ' setup data pin modes and data bus pin group in streamer commands
00e10 08c 38 44 07 F5 |                             and     datapins, #%111000      'compute base pin
00e14 08d 00 00 00 FF 
00e18 08e C0 44 47 F5 |                             or      datapins, ##(3<<6)      'configure 4 pins total
00e1c 08f A2 D7 03 F6 |                             mov     a, datapins             'get data pin base
00e20 090 A2 51 03 FC |                             wrpin   registered, datapins    'prepare data pins for address phase transfer
00e24 091 03 D6 57 F0 |                             shr     a, #3 wc                'determine data pin group
00e28 092 08 D6 47 F5 |                             or      a, #8
00e2c 093 EB 2F 2B F8 |                             setnib  ximm8, a, #5            'setup bus group in streamer
00e30 094 13 2E 47 F4 |                             bitc    ximm8, #19
00e34 095 EB 31 2B F8 |                             setnib  xrecvdata, a, #5
00e38 096 13 30 47 F4 |                             bitc    xrecvdata, #19
00e3c 097 EB 33 2B F8 |                             setnib  xsenddata, a, #5
00e40 098 13 32 47 F4 |                             bitc    xsenddata, #19
00e44 099 EB 35 2B F8 |                             setnib  xsendimm, a, #5
00e48 09a 13 34 47 F4 |                             bitc    xsendimm, #19
00e4c 09b             |  
00e4c 09b             |                             ' setup device control pin states
00e4c 09b 29 3E 64 FD |                             setq2   #32-1                   'read 32 longs to LUTRAM
00e50 09c A3 01 00 FB |                             rdlong  $000, devicelist        'read bank/pin data for all banks    
00e54 09d 01 00 00 FF 
00e58 09e 00 46 07 F6 |                             mov     const512, ##512         'prepare constant
00e5c 09f             | 
00e5c 09f 10 F2 07 F6 |                             mov     ptrb, #16               'point to bank pin config data
00e60 0a0 10 14 DC FC |                             rep     @pinloop, #16           'iterate through 16 banks
00e64 0a1 E1 C9 B7 FA |                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
00e68 0a2 AD C9 03 F5 |                             and     pinconfig, pinmask      'save us from invalid bits in args
00e6c 0a3 E4 4F E3 38 |             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
00e70 0a4 A7 01 08 3C |             if_nc           wrpin   #0, cspin               'clear smart pin mode
00e74 0a5 59 4E 63 3D |             if_nc           drvh    cspin                   'setup pins for all banks
00e78 0a6 E4 4D EB 38 |             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
00e7c 0a7 50 4C 63 3D |             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
00e80 0a8 A6 53 03 3C |             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
00e84 0a9 A6 03 18 3C |             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
00e88 0aa             | '            if_nc           wxpin   #2, clkpin              'configure for 1 clocks between transitions
00e88 0aa 58 4C 63 3D |             if_nc           drvl    clkpin                  'set clk state low
00e8c 0ab             | pinloop
00e8c 0ab             |                             ' generate minimum CE high time before access
00e8c 0ab A1 07 00 FF 
00e90 0ac 40 3C 17 FD |                             qdiv    frequency, ##1000000    'convert from Hz to MHz
00e94 0ad 18 DA 63 FD |                             getqx   c                       'get P2 clocks per microsecond
00e98 0ae 96 D6 07 F6 |                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
00e9c 0af ED D7 03 FA |                             mul     a, c                    'convert microseconds to clocks
00ea0 0b0 1F D6 63 FD |                             waitx   a                       'delay
00ea4 0b1 F8 05 B0 FD |                             call    #hwinit                 'setup HW into QSPI mode
00ea8 0b2             | 
00ea8 0b2             |                             ' setup the COG mailboxes and addresses 
00ea8 0b2 08 04 DC FC |                             rep     #2, #8                  'setup loop to patch mailbox addresses
00eac 0b3 38 68 A5 F9 |                             alti    $+1, #%111_000          'increase D field
00eb0 0b4 A5 31 00 F1 |                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
00eb4 0b5             | 
00eb4 0b5 28 2E 64 FD |                             setq    #24-1
00eb8 0b6 A5 01 68 FC |                             wrlong  #0, mbox                'clear out mailboxes ????
00ebc 0b7             | 
00ebc 0b7             |                             ' setup the polling loop for active COGs 
00ebc 0b7 01 BC 63 FD |                             cogid   id
00ec0 0b8 CD BD 97 F9 |                             alts    id, #id0                'determine id register of control COG
00ec4 0b9 00 90 B6 F9 |                             setd    patchid, #0             'patch into destination address
00ec8 0ba 2A F0 63 FD |                             push    ptra                    'save ptra before we lose it
00ecc 0bb 0A F0 07 F6 |                             mov     ptra, #10
00ed0 0bc DE F1 03 FA |                             mul     ptra, id
00ed4 0bd 20 F0 07 F1 |                             add     ptra, #$20              'prep ptra for reloadcogs
00ed8 0be AE BD 97 F9 |                             alts    id, #cog0_handler       'add to handler base
00edc 0bf 00 48 BE F9 |                             sets    ctrlpollinst, #0-0      'patch into jump instruction
00ee0 0c0 03 BC 07 FA |                             mul     id, #3
00ee4 0c1 DE 49 B2 F9 |                             setd    ctrlpollinst, id
00ee8 0c2 09 BD A7 FA |                             rdlut   id, ptra[9]             'save original value
00eec 0c3 09 BB 37 FC |                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
00ef0 0c4 E8 01 B0 FD |                             call    #reloadcogs
00ef4 0c5 09 BD 37 FC |                             wrlut   id, ptra[9]             'restore original value
00ef8 0c6 2B F0 63 FD |                             pop     ptra                    'restore original ptra
00efc 0c7             |                             ' move LUT control vectors into temporary location to avoid clobbering them later
00efc 0c7 D5 DD B7 F9 |                             setd    d, #addr1
00f00 0c8 60 DC BF F9 |                             sets    d, #(ctrl_vect & $1ff)
00f04 0c9 08 04 DC FC |                             rep     #2, #8
00f08 0ca 3F DC A7 F9 |                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
00f0c 0cb 60 AA A7 FA |                             rdlut   addr1-0, #$60-0
00f10 0cc             | 
00f10 0cc             |                             'setup control COG service handling, we need to patch 5 instructions
00f10 0cc             |                             'one existing instruction is moved earlier and four instructions get replaced
00f10 0cc 01 BC 63 FD |                             cogid   id
00f14 0cd 0C D6 07 F6 |                             mov     a, #(cog1-cog0)         'get code separation of handlers
00f18 0ce DE D7 03 FA |                             mul     a, id                   'scale ID by separation
00f1c 0cf 24 D6 07 F1 |                             add     a, #cog0+4              'add to base for COG0 and offset
00f20 0d0 EB DD B3 F9 |                             setd    d, a                    'set this as the destination
00f24 0d1 02 D6 07 F1 |                             add     a, #2                   'increment COG address
00f28 0d2 EB DD BB F9 |                             sets    d, a                    'set this as the source
00f2c 0d3 3C DC A7 F9 |                             alti    d, #%111_100             
00f30 0d4 00 00 00 F6 |                             mov     0-0, 0-0                'move instruction
00f34 0d5 EA DC BF F9 |                             sets    d, #controlpatch        'set source of patched instructions
00f38 0d6 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
00f3c 0d7 3F DC A7 F9 |                             alti    d, #%111_111
00f40 0d8 00 00 00 F6 |                             mov     0-0, 0-0
00f44 0d9 A3 DD 03 F1 |                             add     d, const512             'skip two instructions
00f48 0da A3 DD 03 F1 |                             add     d, const512
00f4c 0db 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
00f50 0dc 3F DC A7 F9 |                             alti    d, #%111_111
00f54 0dd 00 00 00 F6 |                             mov     0-0, 0-0
00f58 0de             |                             
00f58 0de             |                             ' setup register values for control vector loop setup after we return
00f58 0de DE BF 03 F6 |                             mov     header, id              'get cog ID
00f5c 0df 0A BE 07 FA |                             mul     header, #10             'multiply by size of state memory per COG
00f60 0e0 20 BE 07 F1 |                             add     header, #$20            'add to COG state base address in LUT
00f64 0e1 DF C1 03 F6 |                             mov     trailer, header         'determine start/end LUT address
00f68 0e2 09 C0 07 F1 |                             add     trailer, #9             '...for control region
00f6c 0e3 DD BD 43 F5 |                             or      id, initctrl            'set id field for control COG
00f70 0e4 CD BD 8F F9 |                             altd    id, #id0
00f74 0e5 DE 01 00 F6 |                             mov     0-0, id                 'setup id field for notification
00f78 0e6 F8 F3 03 F6 |                             mov     ptrb, ptra              'get startup parameter address
00f7c 0e7 04 F2 07 F1 |                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
00f80 0e8 00 D8 07 F6 |                             mov     b, #0                   'prepare b for upcoming loop
00f84 0e9 2A 14 66 0D |                 _ret_       push    #notify                 'continue init in mailbox area
00f88 0ea             |  
00f88 0ea D5 C5 7B F8 | controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
00f8c 0eb 07 C4 07 F5 |                             and     request, #7
00f90 0ec F8 C5 03 F1 |                             add     request, ptra           'add request vector offset
00f94 0ed E2 C5 A3 FA |                             rdlut   request, request        'lookup jump vector service table 
00f98 0ee             |                             fit     $100                    'ensure all init code fits this space
00f98 0ee             | 
00f98 0ee             |                             fit     $100                    'ensure all init code fits this space
00f98 0ee             | 
00f98 0ee 00 00 00 00 
      ...             
00fd8 0fe 00 00 00 00 
00fdc 0ff 00 00 00 00 |                             long    0[$100-$]               'pad more if required until table ends
00fe0 100             | 
00fe0 100             | '..................................................................................................
00fe0 100             | ' Error result handling and COG notification of request completion
00fe0 100             | 
00fe0 100 04 04 4C FB | unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
00fe4 101 03 02 4C FB | invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
00fe8 102 02 06 4C FB | invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
00fec 103 01 08 4C FB | alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
00ff0 104 05 EC 07 F6 | busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
00ff4 105 CD BD 8F F9 | err                         altd    id, #id0                'adjust for the running COG
00ff8 106 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
00ffc 107 08 01 3C FC |                             wrlut   #0, ptra[8]             'cancel any resume state
01000 108 32 04 64 FD |                             skipf   #%10                    'dont notify with success code 0 below
01004 109 BF ED 67 FC |                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
01008 10a BF 01 6C FC | notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
0100c 10b 0B BC 0F F4 |                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
01010 10c DE D7 C3 F9 |                             decod   a, id                   'convert COG ID to bitmask
01014 10d 3F D6 63 AD |             if_z            cogatn  a                       'notify COG via ATN
01018 10e             | ' Poller re-starts here after a COG is serviced
01018 10e 0F BC 0F F4 | poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
0101c 10f E3 5B 03 57 |             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
01020 110 AD 41 CB F9 |                             bmask   mask, rrcounter         'generate a RR skip mask from the count
01024 111             | ' Main dynamic polling loop repeats until a request arrives
01024 111 00 00 DC FC | polling_loop                rep     #0-0, #0                'repeat until we get a request for something
01028 112 28 2E 64 FD |                             setq    #24-1                   'read 24 longs
0102c 113 A5 01 00 FB |                             rdlong  req0, mbox              'get all mailbox requests and data longs
01030 114             | 
01030 114 AE 01 B0 FB | polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
01034 115 32 40 63 FD |                             skipf   mask                    ']after all priority COG handlers if present
01038 116 AF 07 B0 FB |                     	    tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
0103c 117 B0 0D B0 FB |                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
01040 118 B1 13 B0 FB |                      	    tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
01044 119 B2 19 B0 FB |                     	    tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
01048 11a B3 1F B0 FB |                     	    tjs     req5, cog5_handler      ']This loop is recreated at init time 
0104c 11b B4 25 B0 FB |                     	    tjs     req6, cog6_handler      ']based on the active COGs being polled
01050 11c B5 2B B0 FB |                    	    tjs     req7, cog7_handler      ']and whether priority or round robin.
01054 11d AF 07 B0 FB |                     	    tjs     req1, cog1_handler      ']Any update of COG parameters would also
01058 11e B0 0D B0 FB |                   	    tjs     req2, cog2_handler      ']regenerate this code, in case priorities
0105c 11f B1 13 B0 FB |                      	    tjs     req3, cog3_handler      ']have changed.
01060 120 B2 19 B0 FB |                     	    tjs     req4, cog4_handler      ']A skip pattern that is continually 
01064 121 B3 1F B0 FB |                   	    tjs     req5, cog5_handler      ']changed selects which RR COG is the
01068 122 B4 25 B0 FB |                     	    tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
0106c 123 B5 2B B0 FB | pollinst            	    tjs     req7, cog7_handler      'instruction template for RR COGs
01070 124             | 
01070 124 AE 01 B0 FB | ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
01074 125 32 40 63 FD | skipfinst                   skipf   mask                    'instruction template for skipf
01078 126             |  
01078 126             | '..................................................................................................
01078 126             | ' List handler                               
01078 126             | 
01078 126 01 AA A7 FB | dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
0107c 127 33 BA 63 FD |                             execf   burstwrite              'otherwise do a burst write to this bank
01080 128 28 0E 64 FD | real_list                   setq    #8-1                    'read 8 longs (largest request size)
01084 129 D6 AB 03 FB |                             rdlong  addr1, hubdata          '..to update the request state
01088 12a D7 AB BF FB |                             tjns    addr1, #invalidlist     'error if request list item not valid
0108c 12b CD BD 8F F9 |                             altd    id, #id0                'get COG state
01090 12c 09 00 3C F4 |                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
01094 12d 09 BC 27 F4 |                             bith    id, #LIST_BIT           'retain fact that we are in a list
01098 12e 44 FF 9F AD |             if_z            jmp     #unsupported            'no list recursion is allowed!
0109c 12f D5 C5 FB F8 | list_test                   getbyte request, addr1, #3      'get upper byte of this request
010a0 130 00 C4 8F F9 | service_request             altd    request, #0             'get request address in COG RAM
010a4 131 33 00 60 FD |                             execf   0-0                     'process the request 
010a8 132             | 
010a8 132             | '..................................................................................................
010a8 132             | ' Restoring per COG state and resuming where we left off
010a8 132             | 
010a8 132 00 AB A7 FA | restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
010ac 133 01 AD A7 FA |                             rdlut   hubdata, ptra[1]
010b0 134 02 AF A7 FA |                             rdlut   count, ptra[2]
010b4 135 03 B1 B7 FA |                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
010b8 136 D5 C5 FB F8 |                             getbyte request, addr1, #3
010bc 137 33 CC 63 3D |             if_nc           execf   resume                  'if not extended then resume immediately
010c0 138 04 B3 A7 FA |                             rdlut   total, ptra[4]          'we need to read the extended parameters
010c4 139 05 B5 A7 FA |                             rdlut   offset1, ptra[5]
010c8 13a 06 B7 A7 FA |                             rdlut   offset2, ptra[6]
010cc 13b 07 B9 A7 FA |                             rdlut   link, ptra[7]
010d0 13c 09 CF A7 FA |                             rdlut   orighubsize, ptra[9]
010d4 13d 33 CC 63 FD |                             execf   resume                  'then resume what we were doing last time
010d8 13e             |                    
010d8 13e             | '..................................................................................................
010d8 13e             | ' Re-configuration of QoS settings and custom polling loop sequence generator
010d8 13e             | 
010d8 13e 2A 14 66 FD | reconfig                    push    #notify                 'setup return addr, then reload 
010dc 13f 28 0E 64 FD | reloadcogs                  setq    #8-1                    'reload all per COG QoS params
010e0 140 A4 AB 03 FB |                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
010e4 141 CD D7 B7 F9 |                             setd    a, #id0
010e8 142 D5 D7 BF F9 |                             sets    a, #addr1
010ec 143 FE FF FF FF 
010f0 144 28 00 66 FD |                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
010f4 145 08 04 DC FC |                             rep     #2, #8                  'repeat for 8 COGs
010f8 146 3F D6 A7 F9 |                             alti    a, #%111_111 
010fc 147 00 00 F0 F9 |                             muxq    0-0, 0-0
01100 148 09 01 A4 FA | patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
01104 149 01 DA 63 FD |                             cogid   c
01108 14a ED 3D C3 F9 |                             decod   excludedcogs, c         'exclude driver cog initially
0110c 14b 08 D6 07 F6 |                             mov     a, #$8                  'a iterates through prio levels 8=lowest
01110 14c 01 EC 67 F6 |                             neg     pa, #1                  'start with all ones
01114 14d 07 DA 07 F6 | fillprio                    mov     c, #7                   'c iterates through cogs
01118 14e CD DB 97 F9 | prioloop                    alts    c, #id0
0111c 14f 00 D8 03 F6 |                             mov     b, 0-0
01120 150 EC DD 3B F9 |                             getword d, b, #1                'get burst field
01124 151 EE DD CB F7 |                             test    d wz                    'if burst=0 
01128 152 ED 3D 23 A4 |             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
0112c 153 0C 00 90 AD |             if_z            jmp     #excluded               
01130 154 EC DD 5B F8 |                             getnib  d, b, #3                'get RR/PRI flag & priority
01134 155 EB DD 0B F2 |                             cmp     d, a wz                 'compare against current priority level
01138 156 ED ED 83 A8 |             if_z            rolnib  pa, c, #0               'if matches include COG at this level
0113c 157 F6 DB 7F FB | excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
01140 158 0F D6 0F F7 |                             incmod  a, #15 wz               'next level
01144 159 CC FF 9F 5D |             if_nz           jmp     #fillprio 
01148 15a             | 
01148 15a             | 'determine priority cogs and build instructions for the polling sequence
01148 15a 00 EE 07 F6 |                             mov     pb, #0                  'clear out set of priority COGs
0114c 15b 03 D6 07 F6 |                             mov     a, #3                   'start with no COGs being polled + 3 instructions
01150 15c 14 DD B7 F9 |                             setd    d, #polling_code        'initialize COGRAM write position
01154 15d             | 
01154 15d 08 18 DC FC |                             rep     @endprioloop, #8        'test all 8 priority slots
01158 15e 03 EC 17 F4 |                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
0115c 15f F6 DB 43 F8 |                             getnib  c, pa, #0               'get cogid ID at this priority level
01160 160 ED EF 0B 34 |             if_nc           testb   pb, c wz                'check if already exists as priority COG
01164 161 ED EF 23 14 |             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
01168 162 01 D6 07 11 |             if_nc_and_nz    add     a, #1                   'add another COG to poll 
0116c 163 AE DB 97 19 |             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
01170 164 00 46 BE 19 |             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
01174 165 03 DA 07 1A |             if_nc_and_nz    mul     c, #3
01178 166 ED 47 B2 19 |             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
0117c 167 38 DC A7 19 |             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
01180 168 23 01 00 16 |             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
01184 169 04 EC 07 F0 |                             ror     pa, #4                  'advance to next priority
01188 16a             | endprioloop
01188 16a FF EE 67 F5 |                             xor     pb, #$ff                'invert to find all the non-priority COGs
0118c 16b 9E EF 23 F5 |                             andn    pb, excludedcogs        'and remove any other excluded COGs
01190 16c F7 C7 AB F7 |                             ones    rrlimit, pb wz          'count the number of RR COGs
01194 16d E3 D7 03 F1 |                             add     a, rrlimit              'account for this number of RR COGs to poll
01198 16e 01 C6 87 F1 |                             sub     rrlimit, #1             'setup last RR count value for incmod
0119c 16f 38 DC A7 F9 |                             alti    d, #%111_000            'generate the control polling instruction
011a0 170 24 01 00 F6 |                             mov     0-0, ctrlpollinst       'write the instruction
011a4 171 38 DC A7 59 |             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
011a8 172 25 01 00 56 |             if_nz           mov     0-0, skipfinst          'add the skipf instruction
011ac 173 02 D6 07 51 |             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
011b0 174 EB 23 B2 F9 |                             setd    polling_loop, a         'save it as the repeat count
011b4 175 2D 00 64 AD |             if_z            ret                             'we are done now, if no round robin COGs
011b8 176             | 
011b8 176             | ' populate the round robin COG polling instructions
011b8 176 02 5A 07 F6 |                             mov     rrcounter, #2           'fill the RR poll instruction list twice
011bc 177 F7 D9 03 F6 | rrloop                      mov     b, pb                   'get the set of RR COGs
011c0 178 00 DA 07 F6 |                             mov     c, #0                   'start at COG ID = 0
011c4 179 00 D6 07 F6 |                             mov     a, #0                   'req mailbox COGRAM address for COG 0
011c8 17a 01 D8 5F F0 | nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
011cc 17b EB 47 B2 C9 |             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
011d0 17c AE DB 97 C9 |             if_c            alts    c, #cog0_handler        'determine jump address
011d4 17d 00 46 BE C9 |             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
011d8 17e 38 DC A7 C9 |             if_c            alti    d, #%111_000            'generate new COG RAM write address
011dc 17f 23 01 00 C6 |             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
011e0 180 01 DA 07 F1 |                             add     c, #1                   'increment the COG ID
011e4 181 03 D6 07 F1 |                             add     a, #3                   'increase the request address
011e8 182 DC FF 9F 5D |             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
011ec 183 F3 5B 6F 0B |             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
011f0 184             | '..................................................................................................
011f0 184             | ' Code to get/set driver settings per bank or to dump COG/LUT state
011f0 184             | 
011f0 184             | set_latency                                                 '            (a) set latency
011f0 184             | get_latency                                                 '            (b) get latency
011f0 184             | set_burst                                                   '            (c) set burst size of bank
011f0 184             | get_burst                                                   '            (d) get burst size of bank
011f0 184             |                                                             '            (e) dump state
011f0 184 D5 D9 73 F8 |                             getnib  b, addr1, #6            ' a b c d    get bank address
011f4 185 28 FE 67 FD | dump_state                  setq    #511                    ' | | | | e  prepare burst write
011f8 186 D6 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
011fc 187             |                                                             ' | | | | e  account for following AUGS
011fc 187 04 00 00 FF 
01200 188 00 AC 07 F1 |                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
01204 189 29 FE 67 FD |                             setq2   #511                    ' | | | | e  prepare burst write
01208 18a D6 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
0120c 18b 10 D8 07 F1 |                             add     b, #16                  ' a b | | |  point to latency params
01210 18c EC D7 A3 FA |                             rdlut   a, b                    ' a b c d |  read data for bank
01214 18d D6 D7 DB F8 |                             setbyte a, hubdata, #3          ' a | | | |  patch latency
01218 18e D6 D7 03 F6 |                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
0121c 18f EC D7 33 FC |                             wrlut   a, b                    ' a | c | |  if setting, save bank data
01220 190 EB D7 FB F8 |                             getbyte a, a, #3                ' | b | | |  extract latency field only
01224 191 80 D7 67 FC |                             wrlong  a, ptrb                 ' | b | d |  write result          
01228 192 DC FD 9F FD |                             jmp     #notify                 ' a b c d e  return success
0122c 193             | 
0122c 193             | '..................................................................................................
0122c 193             | ' Misc EXECF code
0122c 193             | 
0122c 193 33 6E 63 FD | start_read_exec             execf   newburstr
01230 194 33 78 63 FD | start_write_exec            execf   resumewrites
01234 195 33 74 63 FD | continue_read_exec          execf   lockedreads
01238 196 33 76 63 FD | continue_write_exec         execf   lockedwrites
0123c 197             | 
0123c 197             | '..................................................................................................
0123c 197             | ' Variables
0123c 197             | 
0123c 197 08 00 00 60 | ximm8           long    $6000_0008              '8 nibble transfers to pins
01240 198 00 00 00 E0 | xrecvdata       long    $E000_0000              'arbitrary 4 bit reads from 4 bit bus pins
01244 199 00 00 00 A0 | xsenddata       long    $A000_0000              'arbitrary 4 bit writes from hub to pins
01248 19a 02 00 00 60 | xsendimm        long    $6000_0002              'arbitrary nx4 bit immediate writes from imm to pins
0124c 19b             | 
0124c 19b 00 00 00 80 | xfreq1          long    $80000000
01250 19c 00 00 00 40 | xfreq2          long    $40000000
01254 19d             | 'xfreq2          long    $20000000
01254 19d             | 
01254 19d 03 00 00 00 | delay           long    3
01258 19e             | 
01258 19e             | lutcodeaddr                 
01258 19e             | startupparams
01258 19e             | excludedcogs                                    'careful: shared register use!
01258 19e BC 07 00 00 | frequency       long    lut_code - driver_start 'determine offset of LUT code from base
0125c 19f 00 00 00 00 | flags           long    0
01260 1a0             | mask                                            'careful: shared register use!
01260 1a0 00 00 00 00 | resetmaskA      long    0
01264 1a1             | limit                                           'careful: shared register use!
01264 1a1 00 00 00 00 | resetmaskB      long    0
01268 1a2 00 00 00 00 | datapins        long    0
0126c 1a3             | const512                                        'careful: shared register use!
0126c 1a3 00 00 00 00 | devicelist      long    0
01270 1a4 00 00 00 00 | coglist         long    0
01274 1a5 00 00 00 00 | mbox            long    0 
01278 1a6             | 
01278 1a6             | clkpin                                          'shared with code patched during init
01278 1a6 A6 03 18 FC | clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
0127c 1a7             | cspin                                           'shared with code patched during init
0127c 1a7 1D 36 63 FD | speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
01280 1a8 00 00 01 00 | registered      long    %100_000_000_00_00000_0 'config pin for clocked input
01284 1a9 4A 00 00 00 | clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
01288 1aa 01 00 00 00 | clkdelay        long    1
0128c 1ab 00 00 00 00 | regdatabus      long    0
01290 1ac             | 
01290 1ac 10 00 00 00 | deviceaddr      long    $10
01294 1ad             | rrcounter
01294 1ad 7F 7F 3F FF | pinmask         long    $ff3f7f7f
01298 1ae             | 
01298 1ae             | ' jump addresses for the per COG handlers
01298 1ae 20 00 00 00 | cog0_handler    long    cog0
0129c 1af 2C 00 00 00 | cog1_handler    long    cog1
012a0 1b0 38 00 00 00 | cog2_handler    long    cog2
012a4 1b1 44 00 00 00 | cog3_handler    long    cog3
012a8 1b2 50 00 00 00 | cog4_handler    long    cog4
012ac 1b3 5C 00 00 00 | cog5_handler    long    cog5
012b0 1b4 68 00 00 00 | cog6_handler    long    cog6
012b4 1b5 74 00 00 00 | cog7_handler    long    cog7
012b8 1b6 0C 0D 00 00 | expansion       long    gfxexpansion - driver_start
012bc 1b7             | 
012bc 1b7             | ' EXECF sequences
012bc 1b7 70 F2 03 F0 | newburstr       long    (%1111000000000011111100 << 10) + r_burst
012c0 1b8 2C 9B EF 00 | lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
012c4 1b9 27 73 01 1D | restorefill     long    (%0001110100000001011100 << 10) + w_fill_cont
012c8 1ba 80 F2 78 00 | lockedreads     long    (%0000000001111000111100 << 10) + r_locked_burst
012cc 1bb 2F F3 E0 01 | lockedwrites    long    (%0000000111100000111100 << 10) + w_resume_burst
012d0 1bc 2F 03 E0 01 | resumewrites    long    (%0000000111100000000000 << 10) + w_resume_burst
012d4 1bd 78 02 F0 00 | resumereads     long    (%0000000011110000000000 << 10) + r_resume_burst
012d8 1be             | 
012d8 1be             | 
012d8 1be             | ' SKIPF sequences
012d8 1be B0 01 00 00 | skiptable       long    %110110000 ' read modify write byte
012dc 1bf 68 01 00 00 |                 long    %101101000 ' read modify write word
012e0 1c0 D8 00 00 00 |                 long    %011011000 ' read modify write long
012e4 1c1 86 3F 00 00 | read_skip       long    %11111110000110      ' extended single read skip sequence
012e8 1c2 FE 38 06 00 | write_skip      long    %1100011100011111110 ' extended single write skip sequence
012ec 1c3 02 82 01 00 | fill_skip       long    %11000001000000010   ' extended fill skip sequence
012f0 1c4 00 1F 00 00 | burst_skip      long    %001111100000000     ' extended burst skip sequence
012f4 1c5             | 
012f4 1c5 FD 10 80 6F | skipcase_a      long    %01101111100000000001000011111101
012f8 1c6 10 18 50 00 | skipcase_b      long    %00000000010100000001100000010000
012fc 1c7 11 3E 60 00 | skipcase_c      long    %00000000011000000011111000010001
01300 1c8 02 0F 00 00 | skipseq_write   long    %00000000000000000000111100000010
01304 1c9             | 
01304 1c9             | ' LUT RAM address values
01304 1c9 E5 02 00 00 | complete_rw     long    complete_rw_lut
01308 1ca C3 02 00 00 | continue_read   long    continue_read_lut
0130c 1cb C1 02 00 00 | continue_write  long    continue_write_lut
01310 1cc DC 02 00 00 | noread          long    noread_lut
01314 1cd             | 
01314 1cd 00 00 00 00 | id0             long    0
01318 1ce 01 00 00 00 | id1             long    1
0131c 1cf 02 00 00 00 | id2             long    2
01320 1d0 03 00 00 00 | id3             long    3
01324 1d1 04 00 00 00 | id4             long    4
01328 1d2 05 00 00 00 | id5             long    5
0132c 1d3 06 00 00 00 | id6             long    6
01330 1d4 07 00 00 00 | id7             long    7
01334 1d5             | 
01334 1d5             | 'These next 10 request registers below are also temporarily reused during init 
01334 1d5             | 'and COG updates and need to follow immediately after id0-id7
01334 1d5 00 00 00 00 | addr1           long    0
01338 1d6 00 00 00 00 | hubdata         long    0
0133c 1d7 00 00 00 00 | count           long    0
01340 1d8 00 00 00 00 | addr2           long    0
01344 1d9 00 00 00 00 | total           long    0
01348 1da 00 00 00 00 | offset1         long    0
0134c 1db 00 00 00 00 | offset2         long    0
01350 1dc 00 00 00 00 | link            long    0
01354 1dd             | 
01354 1dd             | burstwrite                                      'note shared register use during init
01354 1dd 00 10 F0 FE | initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
01358 1de 00 00 00 00 | id              long    0
0135c 1df             | 
0135c 1df 00 00 00 00 | header          long    0
01360 1e0 00 00 00 00 | trailer         long    0
01364 1e1 00 00 00 00 | cmdaddr         long    0
01368 1e2 00 00 00 00 | request         long    0
0136c 1e3 00 00 00 00 | rrlimit         long    0
01370 1e4 00 00 00 00 | pinconfig       long    0
01374 1e5 00 00 00 00 | clks            long    0
01378 1e6 00 00 00 00 | resume          long    0
0137c 1e7 00 00 00 00 | orighubsize     long    0
01380 1e8 00 00 00 00 | wrclks          long    0
01384 1e9             | 
01384 1e9 00 00 00 00 | pattern         long    0
01388 1ea 00 04 00 00 | pagesize        long    PAGE_SIZE
0138c 1eb             | 
0138c 1eb             | ' temporary general purpose regs
0138c 1eb 00 00 00 00 | a               long    0
01390 1ec 00 00 00 00 | b               long    0
01394 1ed 00 00 00 00 | c               long    0
01398 1ee 00 00 00 00 | d               long    0
0139c 1ef             |                 fit     502
0139c 1ef             | 
0139c 1ef             |                 fit     502
0139c 1ef             | 
0139c 1ef             | '..................................................................................................
0139c 1ef             | 
0139c 1ef             |             orgh
0139c                 | 
0139c                 | lut_code
0139c                 | 'HW init code up to 80 longs
0139c                 | 
0139c                 | '..................................................................................................
0139c                 | ' Memory layout for LUT RAM once operational:
0139c                 | '
0139c                 | '  LUT RAM address      Usage
0139c                 | '  ---------------      ----
0139c                 | '    $200-$20F          Bank parameters: burst + type + size per bank (16)
0139c                 | '    $210-$21F          Pin parameters : latency + control pins per bank (16)
0139c                 | '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
0139c                 | '    $270-$3FF          Main PSRAM access code in LUTRAM 
0139c                 | '
0139c                 | ' Also during driver COG startup:
0139c                 | ' $230-$24F is used for HW init setup
0139c                 | ' $250-$26F is used as temporary vector storage 
0139c                 | '..................................................................................................
0139c                 | 
0139c                 |                 org $230    
0139c 230             | 
0139c 230             | ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
0139c 230 1D 38 63 FD | hwinit                      setxfrq xfreq2
013a0 231 24 16 60 FD |                             pollxfi
013a4 232 5F EC 07 F6 |                             mov     pa, #$5F                '$F5 - exit QSPI mode if we were in this mode
013a8 233 28 00 B0 FD |                             call    #sendqspi
013ac 234 07 F8 07 FF 
013b0 235 F0 ED 07 F6 |                             mov     pa, ##$0FF00FF0         '$66 - reset enable
013b4 236 28 00 B0 FD |                             call    #sendspi
013b8 237 F8 07 78 FF 
013bc 238 0F EC 07 F6 |                             mov     pa, ##$F00FF00F         '$99 - reset
013c0 239 1C 00 B0 FD |                             call    #sendspi
013c4 23a 7F 78 78 FF 
013c8 23b 00 ED 07 F6 |                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
013cc 23c 10 00 B0 FD |                             call    #sendspi 
013d0 23d 2D 00 64 FD |                             ret
013d4 23e             | 
013d4 23e 04 CA 07 F6 | sendqspi                    mov     clks,#4
013d8 23f 32 0C 64 FD |                             skipf   #%110
013dc 240 9A EF 03 F6 |                             mov     pb, xsendimm
013e0 241             | 
013e0 241 10 CA 07 F6 | sendspi                     mov     clks, #16
013e4 242 97 EF 03 F6 |                             mov     pb, ximm8
013e8 243 58 4E 63 FD |                             drvl    cspin                   'active low chip select
013ec 244 58 44 63 FD |                             drvl    datapins                'enable the DATA bus
013f0 245 F6 EF A3 FC |                             xinit   pb, pa                  'send 32 bit immediate data
013f4 246 A6 CB 23 FC |                             wypin   clks, clkpin            'start memory clock output 
013f8 247 24 36 60 FD |                             waitxfi                         'wait for the completion
013fc 248 50 44 63 FD |                             fltl    datapins                'float data bus
01400 249 59 4E 63 FD |                             drvh    cspin                   'raise chip select
01404 24a 1F 90 65 0D |             _ret_           waitx   #200                    'delay before return to ensure CS delay
01408 24b             | 
01408 24b 00 00 00 00 
0140c 24c 00 00 00 00 
01410 24d 00 00 00 00 
01414 24e 00 00 00 00 
01418 24f 00 00 00 00 |                 long    0[$270-32-$]
0141c 250             |                 fit     $270-32  ' keep room for 32 vector longs
0141c 250             |     
0141c 250             |                 fit     $270-32  ' keep room for 32 vector longs
0141c 250             | ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
0141c 250             | rw_vect ' PSRAM jump vectors
0141c 250 72 32 34 1B |                 long    (%0001101100110100001100 << 10) + r_single
01420 251 72 22 34 17 |                 long    (%0001011100110100001000 << 10) + r_single
01424 252 72 52 34 0F |                 long    (%0000111100110100010100 << 10) + r_single
01428 253 70 F2 03 F0 |                 long    (%1111000000000011111100 << 10) + r_burst
0142c 254 27 33 00 1D |                 long    (%0001110100000000001100 << 10) + w_single
01430 255 27 23 00 1D |                 long    (%0001110100000000001000 << 10) + w_single
01434 256 27 13 00 1D |                 long    (%0001110100000000000100 << 10) + w_single
01438 257 2B 1B 00 1E |                 long    (%0001111000000000000110 << 10) + w_burst
0143c 258             | ro_vect ' R/O PSRAM jump vectors
0143c 258 72 32 34 1B |                 long    (%0001101100110100001100 << 10) + r_single
01440 259 72 22 34 17 |                 long    (%0001011100110100001000 << 10) + r_single
01444 25a 72 52 34 0F |                 long    (%0000111100110100010100 << 10) + r_single
01448 25b 70 F2 03 F0 |                 long    (%1111000000000011111100 << 10) + r_burst
0144c 25c 00 01 00 00 |                 long    unsupported
01450 25d 00 01 00 00 |                 long    unsupported
01454 25e 00 01 00 00 |                 long    unsupported
01458 25f 00 01 00 00 |                 long    unsupported
0145c 260             | ctrl_vect ' Control jump vectors
0145c 260 84 F9 39 00 |                 long    (%0000000000111001111110 << 10) + get_latency
01460 261 00 01 00 00 |                 long    unsupported
01464 262 84 F9 7B 00 |                 long    (%0000000001111011111110 << 10) + get_burst
01468 263 85 01 7F 00 |                 long    (%0000000001111111000000 << 10) + dump_state
0146c 264 84 F9 D1 00 |                 long    (%0000000011010001111110 << 10) + set_latency
01470 265 00 01 00 00 |                 long    unsupported
01474 266 84 F9 CB 00 |                 long    (%0000000011001011111110 << 10) + set_burst
01478 267 3E 01 00 00 |                 long    reconfig 
0147c 268             | no_vect ' Invalid bank jump vectors
0147c 268 01 01 00 00 |                 long    invalidbank
01480 269 01 01 00 00 |                 long    invalidbank
01484 26a 01 01 00 00 |                 long    invalidbank
01488 26b 01 01 00 00 |                 long    invalidbank
0148c 26c 01 01 00 00 |                 long    invalidbank
01490 26d 01 01 00 00 |                 long    invalidbank
01494 26e 01 01 00 00 |                 long    invalidbank
01498 26f 01 01 00 00 |                 long    invalidbank
0149c 270             |                 fit     $270
0149c 270             | 
0149c 270             |                 fit     $270
0149c 270             | '..................................................................................................
0149c 270             | ' PSRAM READS
0149c 270             |                                                             ' a b c d e f
0149c 270             |                                                             ' B W L B R L  (a) byte read
0149c 270             |                                                             ' Y O O U E O  (b) word read
0149c 270             |                                                             ' T R N R S C  (c) long read
0149c 270             |                                                             ' E D G S U K  (d) new burst read
0149c 270             |                                                             '       T M E  (e) resumed sub-burst
0149c 270             |                                                             '         E D  (f) locked sub-burst
0149c 270             | 
0149c 270             | 
0149c 270 D7 CF 03 F6 | r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
014a0 271 6A AE 97 FB |                             tjz     count, #noread_lut      '       d      check for any bytes to send
014a4 272 D7 AF CB F7 | r_single                    test    count wz                ' a b c |      test for RMW (z=0 if RMW)
014a8 273 6F 0A 6C FD |                             modz    5 wz                    ' a b c |      test for RMW (z=1 if RMW) 
014ac 274 01 AA 27 F5 |                             andn    addr1, #1               ' | b | |      align to word boundary to prevent page issues
014b0 275 03 AA 27 F5 |                             andn    addr1, #3               ' | | c |      align to long boundary to prevent page issues
014b4 276 80 01 6C FC |                             wrlong  #0, ptrb                ' a b | |      clear upper bits of byte/word mailbox result
014b8 277 F9 37 83 FC |                             wrfast  xfreq1, ptrb            ' a b c |      setup streamer hub address for singles
014bc 278 E2 D9 43 F8 | r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
014c0 279 EC D9 A3 FA |                             rdlut   b, b                    ' a b c d e    get bank limit/mask
014c4 27a EC 41 CB F9 |                             bmask   mask, b                 ' | | | d e    build mask for addr
014c8 27b EC 3B EB F8 |                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
014cc 27c 11 D8 47 F0 |                             shr     b, #17                  ' | | | d e    scale burst size based on bus rate
014d0 27d EC 43 23 F3 |                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
014d4 27e 05 3A 57 F0 |                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
014d8 27f 10 56 67 F4 |                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
014dc 280 D7 DB 0B F6 | r_locked_burst              mov     c, count wz             ' | | | d e f  get count of bytes left to read
014e0 281 A1 DB 33 F3 |                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
014e4 282 02 CA 17 F6 |                             mov     clks, #2 wc             ' a | | | | |  2 clock transitions per byte
014e8 283 04 CA 17 F6 |                             mov     clks, #4 wc             ' | b | | | |  4 clock transitions per word
014ec 284 08 CA 17 F6 |                             mov     clks, #8 wc             ' | | c | | |  8 clock transitions per long
014f0 285 32 82 63 FD |                             skipf   read_skip               ' a b c | | |  extend skipf sequence for single reads
014f4 286 C9 CD 03 36 |             if_nc           mov     resume, complete_rw     ' a b c d e f  burst/single read will complete
014f8 287 CA CD 03 C6 |             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
014fc 288 D6 37 83 FC |                             wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
01500 289 E2 59 03 F8 |                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
01504 28a AC C9 A3 FA |                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
01508 28b E4 4F E3 F8 |                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
0150c 28c E4 4D EB F8 |                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
01510 28d             |                             ' handle the page boundary by splitting any read bursts that cross it 
01510 28d D5 DD 03 F6 |                             mov     d, addr1                ' | | | d e f  get start address
01514 28e 09 DC 47 F7 |                             zerox   d, #(PAGE_BITS-1)       ' | | | d e f  only keep page LSBs
01518 28f EA DD C3 F2 |                             subr    d, pagesize             ' | | | d e f  figure out how many bytes remain before we hit the boundary
0151c 290 EE DB 33 F3 |                             fle     c, d wc                 ' | | | d e f  compare this size to our transfer size and limit it
01520 291 CA CD 03 C6 |             if_c            mov     resume, continue_read   ' | | | d e f  and we will continue with a sub-burst again
01524 292 ED CB 03 F6 |                             mov     clks, c                 ' | | | d e f  get count of bytes to be read into HUB
01528 293 01 CA 67 F0 |                             shl     clks, #1                ' | | | d e f  multiply by two to work out nibble count
0152c 294             | 
0152c 294 E5 31 23 F9 |                             setword xrecvdata, clks, #0     'set the nibble transfers needed in streamer
01530 295 0E CA 07 F1 |                             add     clks, #14               'include 14 address+delay clocks
01534 296 E5 CB 03 F1 |                             add     clks, clks              'compute clock transitions by doubling
01538 297 D5 C3 03 F6 |                             mov     cmdaddr, addr1          'get start address of transfer
0153c 298 EB C2 DF F8 |                             setbyte cmdaddr, #$EB, #3       'add quad read command
01540 299             | 
01540 299 60 C2 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
01544 29a 69 C2 63 FD |                             rev     cmdaddr
01548 29b 1B C2 FF F9 |                             movbyts cmdaddr, #%%0123
0154c 29c 61 C2 63 FD |                             mergeb  cmdaddr
01550 29d             | 
01550 29d 58 4E 63 FD |                             drvl    cspin                   'activate chip select
01554 29e 58 44 63 FD |                             drvl    datapins                'enable data bus
01558 29f             |             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
01558 29f E1 2F A3 FC |                             xinit   ximm8, cmdaddr          'stream out command+address
0155c 2a0 A6 CB 23 FC |                             wypin   clks, clkpin            'start clock output
01560 2a1 00 00 CC FC |                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
01564 2a2 00 0C CC FC |                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
01568 2a3 59 44 63 FD |                             drvh    datapins                'enable this only if validating actual tri-state time on a scope
0156c 2a4 50 44 63 FD |                             fltl    datapins                'safe to float the data bus, address has been sent by now
01570 2a5             |                       
01570 2a5 A2 57 03 FC |                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
01574 2a6 28 36 63 FD |                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
01578 2a7 00 3A C7 FC |                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
0157c 2a8 00 0C CC FC |                             xcont   #6, #0                  'fixed delay offset to expand delay range
01580 2a9 32 48 64 AD |             if_z            skipf   #%0100100               'special skip case for read-modify-write(RWM)
01584 2aa             |                                                             'Bursts Bytes Words Longs  RMW
01584 2aa 28 38 63 FD |                             setq    xfreq2                  '   a     b     c     d     e
01588 2ab 00 30 C7 FC |                             xcont   xrecvdata, #0           '   a     b     c     d     e     transfer data as nibbles
0158c 2ac 2D CC 63 FD |                             call    resume                  '   a     b     c     d     |    
01590 2ad 24 36 60 FD |                             waitxfi                         '   a     b     c     d     e     wait for streaming to finish
01594 2ae A2 51 03 FC |                             wrpin   registered, datapins    '   a     b     c     d     e     restore data pins for next transfer
01598 2af 59 4E 63 0D |             _ret_           drvh    cspin                   '   a     b     c     d     |     de-assert chip select and return
0159c 2b0 59 4E 63 FD |                             drvh    cspin                   '                           e     deassert chip select and continue
015a0 2b1             | 
015a0 2b1 E2 DD 4B F8 |                             getnib  d, request, #1          'get request code value
015a4 2b2 B6 DD 8F F9 |                             altd    d, #skiptable-8         'patch next instruction
015a8 2b3 32 00 60 FD |                             skipf   0-0                     'generate skip sequence for byte, word or long
015ac 2b4             |                                                             ' RMWB RMWW RMLL 
015ac 2b4 80 D7 07 FB |                             rdlong  a, ptrb                 '  c    d    e   read back data written to mailbox
015b0 2b5 28 AE 63 FD |                             setq    count                   '  c    d    e   setup bit mux mask
015b4 2b6 D6 D7 F3 F9 |                             muxq    a, hubdata              '  c    d    e   apply bit mux
015b8 2b7 14 D0 07 F6 |                             mov     wrclks, #20             '  c    |    |   setup clks for byte write
015bc 2b8 18 D0 07 F6 |                             mov     wrclks, #24             '  |    d    |   setup clks for word write
015c0 2b9 20 D0 07 F6 |                             mov     wrclks, #32             '  |    |    e   setup clks for long write
015c4 2ba 02 34 27 F9 |                             setword xsendimm, #2, #0        '  c    |    |
015c8 2bb 04 34 27 F9 |                             setword xsendimm, #4, #0        '  |    d    |
015cc 2bc 08 34 27 F9 |                             setword xsendimm, #8, #0        '  |    |    e
015d0 2bd EB AD 03 F6 |                             mov     hubdata, a              'write a to PSRAM
015d4 2be 0D D2 07 F6 |                             mov     pattern, #%001101       'setup next skip pattern to send a single item and resume
015d8 2bf C9 CD 03 F6 |                             mov     resume, complete_rw     'we'll complete the operation after this
015dc 2c0 34 02 90 FD |                             jmp     #writecommon
015e0 2c1             | 
015e0 2c1             | '..................................................................................................
015e0 2c1             | ' Burst continuation testing
015e0 2c1             | 
015e0 2c1 32 90 63 FD | continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
015e4 2c2 BC CD 03 F6 |                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
015e8 2c3             | continue_read_lut          
015e8 2c3 BD CD 03 F6 |                             mov     resume, resumereads     ' | setup resume address to execf
015ec 2c4 ED AD 03 F1 |                             add     hubdata, c              ' a compute the next hub addr to use
015f0 2c5 ED AF 83 F1 |                             sub     count, c                ' a account for the bytes already sent
015f4 2c6 D5 DB 03 F1 |                             add     c, addr1                ' a compute next external mem address
015f8 2c7 28 40 63 FD |                             setq    mask                    ' a configure mask for bit muxing
015fc 2c8 ED AB F3 F9 |                             muxq    addr1, c                ' a perform address bit muxing
01600 2c9 0A BC 0F F4 |                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
01604 2ca 14 00 90 5D |             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
01608 2cb DE 43 3B F9 |                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
0160c 2cc EC 43 23 F3 |                             fle     limit, b                ' | also re-apply per bank limit
01610 2cd 2A 2A 67 0D |             _ret_           push    #continue_read_exec     ' | 
01614 2ce 04 00 90 5D |             if_nz           jmp     #yield                  ' a
01618 2cf 2A 2C 67 0D |             _ret_           push    #continue_write_exec    ' a
0161c 2d0             | 
0161c 2d0 04 B3 37 FC | yield                       wrlut   total, ptra[4]          'save context for next time
01620 2d1 05 B5 37 FC |                             wrlut   offset1, ptra[5]        'save context for next time
01624 2d2 06 B7 37 FC |                             wrlut   offset2, ptra[6]        'save context for next time
01628 2d3 07 B9 37 FC |                             wrlut   link, ptra[7]           'save context for next time
0162c 2d4 00 AB 37 FC | yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
01630 2d5 01 AD 37 FC |                             wrlut   hubdata, ptra[1]        'save context for next time
01634 2d6 02 AF 37 FC |                             wrlut   count, ptra[2]          'save context for next time
01638 2d7 03 B1 37 FC |                             wrlut   addr2, ptra[3]          'save context for next time
0163c 2d8 08 CD 37 FC |                             wrlut   resume, ptra[8]         'save next resume address
01640 2d9 09 CF 37 FC |                             wrlut   orighubsize, ptra[9]    'save original hub size
01644 2da 2A 1C 66 0D |             _ret_           push    #poller
01648 2db             | 
01648 2db             | 
01648 2db 32 BE 65 FD | notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
0164c 2dc             | nowrite_lut                                                 '  (a) new skip sequence 
0164c 2dc 32 00 64 FD | noread_lut                  skipf   #0                      ' | cancel skipping
01650 2dd 08 01 3C FC |                             wrlut   #0, ptra[8]             ' | clear resume
01654 2de 09 BC 0F F4 |                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
01658 2df A8 F8 9F 5D |             if_nz           jmp     #notify                 ' | if not a request list then we are done
0165c 2e0 1F B0 0F F4 |                             testb   addr2, #31 wz           ' | check if extended list item
01660 2e1 DC B1 03 A6 | donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
01664 2e2 1C 00 B0 FD | checklist                   call    #checknext              ' | handle running from list
01668 2e3 2D 00 64 FD |                             ret                             ' | continue processing
0166c 2e4 2A 98 63 0D |             _ret_           push    noread                  'continue end of transfer
01670 2e5             | '..................................................................................................
01670 2e5             | ' Completion of requests
01670 2e5             | 
01670 2e5             | complete_rw_lut             
01670 2e5 09 BC 0F F4 |                             testb   id, #LIST_BIT wz        'test for running from a request list   
01674 2e6 32 04 64 AD |             if_z            skipf   #%10                    'if a request list then skip notification
01678 2e7 08 01 3C FC |                             wrlut   #0, ptra[8]             ' a   default is not to resume
0167c 2e8 2A 14 66 0D |             _ret_           push    #notify                 ' |   if not a request list then we are done
01680 2e9 0D B0 B7 FB |                             tjs     addr2, #extendedreq     '     test for special extended request  
01684 2ea             | 'checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
01684 2ea             | '                            rdlong  pa, ptrb[-1]            'check if list has been aborted by client
01684 2ea             | '                            tjns    pa, #listcomplete       'exit if it has
01684 2ea             | '                            skipf   #%1000                  'do not notify if list is continuing
01684 2ea             | '                            wrlong  addr2, ptrb             ' a  write back next list address
01684 2ea             | 'listcomplete                altd    id, #id0                ' a  compute COG's state address
01684 2ea             | '                            bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
01684 2ea             | '            _ret_           push    #notify                 ' |  we are done with the list
01684 2ea             | '            _ret_           push    #poller                 ' a  we are still continuing the list
01684 2ea             | 
01684 2ea             | 
01684 2ea 07 B0 97 FB | checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
01688 2eb BF ED 07 FB |                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
0168c 2ec 05 EC BF FB |                             tjns    pa, #listcomplete       'exit if it has
01690 2ed 0A BC 0F F4 |                             testb   id, #LOCKED_BIT wz
01694 2ee D8 AD 03 A6 |             if_z            mov     hubdata, addr2
01698 2ef 32 62 64 AD |             if_z            skipf   #%110001
0169c 2f0 32 10 64 5D |             if_nz           skipf   #%1000                  'do not notify if list is continuing
016a0 2f1 80 B1 67 FC |                             wrlong  addr2, ptrb             ' a  write back next list address
016a4 2f2 CD BD 8F F9 | listcomplete                altd    id, #id0                ' a  compute COG's state address
016a8 2f3 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
016ac 2f4 2A 14 66 0D |             _ret_           push    #notify                 ' |  we are done with the list
016b0 2f5 2A 1C 66 0D |             _ret_           push    #poller                 ' a  we are still continuing the list
016b4 2f6 2A 50 66 0D |             _ret_           push    #real_list
016b8 2f7             | 
016b8 2f7             | 
016b8 2f7             | 
016b8 2f7 E3 AF 97 FB | extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
016bc 2f8 D8 D7 7B F8 |                             getnib  a, addr2, #7            'check the request type
016c0 2f9 0F D6 0F F2 |                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
016c4 2fa D5 D7 73 F8 |                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
016c8 2fb 32 8A 63 5D |             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
016cc 2fc             |                                                             ' skipcase (a) gfx copy to/from hub
016cc 2fc             |                                                             ' skipcase (b) gfx copy extmem bank to bank
016cc 2fc             |                                                             ' skipcase (c) linear copy extmem bank to bank
016cc 2fc D8 D7 73 F8 |                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
016d0 2fd EB DD AB FA |                             rdlut   d, a wz                 ' a      load bank information and check if valid
016d4 2fe 31 02 64 5D |             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
016d8 2ff 2A 02 66 0D |             _ret_           push    #invalidbank            ' |      otherwise bail out after this
016dc 300 DA B5 CB F7 |                             test    offset1 wz              ' |      check for first offset being zero
016e0 301 DB B7 CB A7 |             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
016e4 302 32 8E 63 AD |             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
016e8 303 32 8C 63 FD |                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
016ec 304 ED AD 03 F1 |                             add     hubdata, c              ' a b c  add bytes just sent to hub address
016f0 305 E7 AD 83 F1 |                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
016f4 306 D5 DB 03 F1 |                             add     c, addr1                ' a b c  compute next address to use
016f8 307 D9 B3 CB F7 |                             test    total wz                ' a b |  check for zero tranfers
016fc 308 D9 CF 2B F3 |                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
01700 309 44 FF 9F AD |             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
01704 30a 1E AA 0F F4 |                             testb   addr1, #30 wz           ' a b c  check if reading/writing
01708 30b E7 AF 03 F6 |                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
0170c 30c E7 DB 83 F1 |                             sub     c, orighubsize          ' a b |  rewind to original position
01710 30d DA DB 03 A1 |             if_z            add     c, offset1              ' a b |  add any dst scanline offset
01714 30e DB DB 03 51 |             if_nz           add     c, offset2              ' a b |  add any src scanline offset
01718 30f DB AD 03 A1 |             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
0171c 310 DA AD 03 51 |             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
01720 311 28 40 63 FD |                             setq    mask                    ' a b c  configure mask for bit muxing
01724 312 ED AB F3 F9 |                             muxq    addr1, c                ' a b c  perform address bit muxing
01728 313 D5 D7 03 F6 |                             mov     a, addr1                ' | b c  ]
0172c 314 D8 AB 03 F6 |                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
01730 315 EB B1 03 F6 |                             mov     addr2, a                ' | b c  ]
01734 316 1E AA A7 F4 |                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
01738 317 0F B0 3F F8 |                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
0173c 318 01 B2 8F F1 |                             sub     total, #1 wz            ' a | |  decrement scanline count
01740 319 01 B2 8F A1 |             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
01744 31a E7 B3 8B A1 |             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
01748 31b             | '            if_nz           jmp     #moretransfers          ' a b c  more transfers still to go
01748 31b             | '                            tjz     link, #listcomplete     ' a b c  test link for next request
01748 31b             | '                            rdlong  pa, ptrb[-1]            'check if list has been aborted by client
01748 31b             | '                            tjns    pa, #listcomplete       'will exit if it has
01748 31b             | '                            wrlong  link, ptrb              'setup list next pointer
01748 31b             | '                            altd    id, #id0                'compute COG's state address
01748 31b             | '                            bitl    0-0, #LIST_BIT          'clear list flag for this COG
01748 31b             | '            _ret_           push    #poller                 'we will return to polling
01748 31b DC B1 03 A6 |             if_z            mov addr2,link
0174c 31c 34 FF 9F AD |             if_z            jmp #checknext
01750 31d D5 C5 FB F8 | moretransfers               getbyte request, addr1, #3      'prepare next request
01754 31e 0A BC 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
01758 31f 32 1C 64 AD |             if_z            skipf   #%1110                  '     skip some code if we are locked
0175c 320 1E AA 0F F4 |                             testb   addr1, #30 wz           ' a   test if will be reading or writing
01760 321 BC CD 03 A6 |             if_z            mov     resume, resumewrites    ' |   resume burst writing
01764 322 B7 CD 03 56 |             if_nz           mov     resume, newburstr       ' |   resume burst reading
01768 323 B0 FE 9F FD |                             jmp     #yield                  ' |   yield to poller
0176c 324 31 02 64 AD |             if_z            skip    #%1                     '     skip next instruction for writing case
01770 325 2A 26 67 0D |             _ret_           push    #start_read_exec        '(|)  do new read burst next 
01774 326 2A 28 67 0D |             _ret_           push    #start_write_exec       'do new write burst next
01778 327             | 
01778 327             | '..................................................................................................
01778 327             | ' PSRAM WRITES
01778 327             |                                                             '  a b c d e f g h
01778 327             | 
01778 327             |                                                             '  B W L F B R L L (a) byte write(s)
01778 327             |                                                             '  Y O O I U E O O (b) word write(s)
01778 327             |                                                             '  T R N L R S C C (c) long write(s)
01778 327             |                                                             '  E D G L S U K K (d) resumed fill
01778 327             |                                                             '          T M E E (e) new burst write
01778 327             |                                                             '            E D D (f) resumed burst
01778 327             |                                                             '              F B (g) locked fill
01778 327             |                                                             '              I U (h) locked burst write
01778 327             |                                                             '              L R 
01778 327             |                                                             '              L S 
01778 327             |                                                             '                T 
01778 327             | 
01778 327             |                 
01778 327             | w_single                   
01778 327             | w_fill_cont           
01778 327 D5 D7 7B F8 |                             getnib  a, addr1, #7            '  a b c d          obtain request
0177c 328 03 D6 07 F5 |                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
01780 329 01 AA 27 F5 |                             andn    addr1, #1               '  | b | |          align word addresses to stop page crossing issues
01784 32a 03 AA 27 F5 |                             andn    addr1, #3               '  | | c |          align long addresses to stop page crossing issues
01788 32b D7 CF 03 F6 | w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
0178c 32c 01 AE 0F F2 | w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
01790 32d EB AF 63 F0 |                             shl     count, a                '  a b c | |   |    scale into bytes
01794 32e AD AF 97 FB |                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
01798 32f D7 DB 03 F6 | w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
0179c 330 7C 03 A0 FD |                             call    #\w_get_bankdelay       '  a b c d e f g h  get per bank limit and read delay info
017a0 331 E2 59 03 F8 |                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
017a4 332 AC C9 A3 FA |                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
017a8 333 E4 4F E3 F8 |                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
017ac 334 E4 4D EB F8 |                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
017b0 335 07 D2 0F F6 |                             mov     pattern, #%111 wz       '  | | | | e f | h  setup base skip pattern for bursts
017b4 336 A1 DB 33 F3 |                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
017b8 337 CB CD 03 C6 |             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
017bc 338 C9 CD 03 36 |             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
017c0 339 D6 37 73 FC |                             rdfast  xfreq1, hubdata         '  | | | | e f | h  setup streamer hub addr
017c4 33a 32 84 63 AD |             if_z            skipf   write_skip              '  a b c d | | g |  extend single write skip pattern (optimization)
017c8 33b 9D D2 07 A6 |             if_z            mov     pattern, #%10011101     '  a b c d | | g |  setup pattern for single writes
017cc 33c 32 86 63 FD |                             skipf   fill_skip               '  ? ? ? d | | g |  extend fill skip pattern
017d0 33d 00 D2 07 F6 |                             mov     pattern, #0             '  ? ? ? d | | g |  setup pattern for fill writes
017d4 33e 32 88 63 FD |                             skipf   burst_skip              '  | | | | e f | h  extend burst writes skip pattern
017d8 33f             |                             'if not just a single transfer we need to work out how many bytes are left to the page boundary
017d8 33f D5 DD 03 F6 |                             mov     d, addr1                '  | | | d e f g h  get start address
017dc 340 09 DC 47 F7 |                             zerox   d, #(PAGE_BITS-1)       '  | | | d e f g h  only keep page LSBs
017e0 341 EA DD C3 F2 |                             subr    d, pagesize             '  | | | d e f g h  figure out how many bytes remain before we hit the boundary
017e4 342 EE DB 33 F3 |                             fle     c, d wc                 '  | | | d e f g h  compare this size to our transfer size and limit it
017e8 343 ED D1 03 F6 |                             mov     wrclks, c               '  a b c d e f g h  number of bytes to be sent
017ec 344 04 D0 07 FA |                             mul     wrclks, #4              '  a b c d e f g h  convert to clock transitions (2 transitions/nibble)
017f0 345 10 D0 07 F1 |                             add     wrclks, #16             '  a b c d e f g h  add header clock transitions
017f4 346 CB CD 03 C6 |             if_c            mov     resume, continue_write  '  | | | | e f | h  and we will continue with a sub-burst again
017f8 347 ED EF 03 F6 |                             mov     pb, c                   '  | | | d | | g |  get number of bytes to be filled
017fc 348 EB EF 43 F0 |                             shr     pb, a                   '  | | | d | | g |  scale into number of items to fill
01800 349 EB DD C3 F9 |                             decod   d, a                    '  a b c d | | g |  get write item size in bytes
01804 34a 01 DC 67 F0 |                             shl     d, #1                   '  a b c d | | g |  convert to nibbles
01808 34b EE 35 23 F9 |                             setword xsendimm, d, #0         '  a b c d | | g |  setup streamer count
0180c 34c ED 33 23 F9 |                             setword xsenddata, c, #0        '  | | | | e f | h  setup write burst bytes to be streamed
01810 34d ED 33 03 F1 |                             add     xsenddata, c            '  | | | | e f | h  convert to nibbles
01814 34e             | 
01814 34e D5 C3 03 F6 | writecommon                 mov     cmdaddr, addr1          'get start address of transfer
01818 34f 02 C2 DF F8 |                             setbyte cmdaddr, #$02, #3       'add quad write command
0181c 350             | 
0181c 350 60 C2 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
01820 351 69 C2 63 FD |                             rev     cmdaddr                 
01824 352 1B C2 FF F9 |                             movbyts cmdaddr, #%%0123
01828 353 61 C2 63 FD |                             mergeb  cmdaddr
0182c 354             |                             
0182c 354 58 4E 63 FD |                             drvl    cspin                   'activate chip select
01830 355 58 44 63 FD |                             drvl    datapins                'enable the DATA bus
01834 356 E1 2F A3 FC |                             xinit   ximm8, cmdaddr          'send 8 nibbles of address and command via LUT translation
01838 357 A6 D1 23 FC |                             wypin   wrclks, clkpin          'start memory clock output 
0183c 358             |                                                          
0183c 358 32 D2 63 FD |                             skipf   pattern                 '   B W L Burst FB FW FL RMW
01840 359 F7 03 D8 FC |                             rep     #1, pb                  '   | | |   |    e  f  g  | ' repeat for bursts
01844 35a D6 35 C3 FC |                             xcont   xsendimm, hubdata       '   a b c   |    e  f  g  h ' send immediate data as nibbles
01848 35b 32 26 64 FD |                             skipf   #%10011                 '   | | |   |    e  f  g  | '
0184c 35c 00 32 C7 FC |                             xcont   xsenddata, #0           '   | | |   d    |  |  |  | ' send data from hub for bursts as nibbles
01850 35d 2D CC 63 FD |                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
01854 35e 24 36 60 FD |                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
01858 35f 50 44 63 FD |                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
0185c 360 59 4E 63 0D |             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
01860 361             | 
01860 361 59 4E 63 FD |                             drvh    cspin
01864 362 09 BC 17 F4 | check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
01868 363 ED AF 8B F1 |                             sub     count, c wz             'account for bytes written
0186c 364 34 00 90 5D |             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
01870 365 08 01 3C FC |                             wrlut   #0, ptra[8]             'default is not to resume
01874 366 8C F6 9F 3D |             if_nc           jmp     #notify                 'if not a request list then we are done
01878 367 7A B1 BF FB |                             tjns    addr2, #checklist       'if not extended, check next list entry
0187c 368 78 B3 67 FB |                             djz     total, #donerepeats     'check for repeats remaining
01880 369 B6 B3 B3 FB |                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
01884 36a E7 DD 03 F6 |                             mov     d, orighubsize
01888 36b EB DD 63 F0 |                             shl     d, a
0188c 36c EE DB 83 F1 |                             sub     c, d
01890 36d DA DB 03 F1 |                             add     c, offset1
01894 36e EE AF 03 F6 |                             mov     count, d                'restore original count
01898 36f E2 D9 43 F8 | readmask                    getnib  b, request, #0          'get bank parameter LUT address
0189c 370 EC D9 A3 FA |                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
018a0 371 EC 41 CB F9 |                             bmask   mask, b                 'build mask for addr (in case count=1)
018a4 372 D5 DB 03 F1 | continue_fill               add     c, addr1                'add bytes to destination address
018a8 373 28 40 63 FD |                             setq    mask                    'setup bit mask
018ac 374 ED AB F3 F9 |                             muxq    addr1, c                'setup new external memory address
018b0 375 0A BC 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
018b4 376 33 70 63 AD |             if_z            execf   lockedfill              'continue next fill operation
018b8 377 B9 CD 03 F6 |                             mov     resume, restorefill
018bc 378 00 B0 07 36 |             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
018c0 379 68 FD BF 3D |             if_nc           call    #yieldfill              'we have to yield now to other COGs
018c4 37a 54 FD BF CD |             if_c            call    #yield
018c8 37b 2D 00 64 FD |                             ret
018cc 37c             |                            
018cc 37c E2 D9 43 F8 | w_get_bankdelay             getnib  b, request, #0          'get bank parameter LUT address
018d0 37d EC D9 A3 FA |                             rdlut   b, b                    'get bank limit/mask
018d4 37e EC 41 CB F9 |                             bmask   mask, b                 'build mask for addr
018d8 37f EC 3B EB F8 |                             getbyte delay, b, #1            'get input delay of bank + flags
018dc 380 11 D8 47 F0 |                             shr     b, #17                  'scale burst size based on bus rate
018e0 381 EC 43 23 F3 |                             fle     limit, b                'apply any per bank limit to cog limit
018e4 382 05 3A 57 F0 |                             shr     delay, #5 wc            'prep delay and test for registered inputs
018e8 383 10 56 67 04 |             _ret_           bitnc   regdatabus, #16         'setup if data bus is registered or not
018ec 384             |         fit 1024
018ec 384             | 
018ec 384             | '..................................................................................................
018ec 384             | 
018ec 384             |         fit 1024
018ec 384             | 
018ec 384             | '--------------------------------------------------------------------------------------------------
018ec 384             |         orgh
018ec                 | 
018ec                 | gfxexpansion
018ec                 |                             'simple line drawing graphics expansion of memory driver
018ec                 |                             'jmp     #donerepeats                'just return for now
018ec                 | 
018ec     D8 AB 0B F2 |                             cmp     addr1, addr2 wz         'see if we've reached the end
018f0     E1 02 80 AD |             if_z            jmp     #donerepeats            'nothing more to draw
018f4     01 B2 07 F1 |                             add     total, #1               'restore total after decrement
018f8     DA D9 03 F6 |                             mov     b, offset1              'get error term
018fc     01 D8 67 F0 |                             shl     b, #1                   'compute e2 = 2 x error
01900     DB DD 33 F9 |                             getword d, offset2, #0          'get dx = abs(x0-x1)
01904     10 B6 C7 F0 |                             sar     offset2, #16            'get dy = -abs(y0-y1)
01908     DB D9 53 F2 |                             cmps    b, offset2 wc           'compare if e2 >= dy
0190c     00 DA 07 F6 |                             mov     c, #0                   'clear accumulator reg
01910     31 1C 64 CD |             if_c            skip    #%1110                  'if not, skip
01914     EB D7 C3 F9 |                             decod   a                       'decode as 1,2,or 4 byte size
01918     DB B5 03 F1 |                             add     offset1, offset2        'err+=dy 
0191c     10 B2 0F F4 |                             testb   total, #16 wz           'check sign sx   
01920     EB DB C3 F3 |                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
01924     EC DD 53 F2 |                             cmps    d, b wc                 'compare if e2 <= dx
01928     31 3C 64 CD |             if_c            skip    #%11110                 'if not, skip
0192c     EE B7 43 F9 |                             rolword offset2, d, #0          'restore offset
01930     EE B5 03 F1 |                             add     offset1, d              'err+=dx
01934     11 B2 0F F4 |                             testb   total, #17 wz           'check sign sy
01938     D9 DD 33 F9 |                             getword d, total, #0            'get line width
0193c     EE DB C3 F3 |                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
01940     EB D7 93 F7 |                             encod   a wc                    'restore size and set carry
01944     E7 AF 03 F6 |                             mov     count, orighubsize      'reset the fill width
01948     EB AF 63 F0 |                             shl     count, a                '..for the type of transfer
0194c     6F 03 80 FD |                             jmp     #readmask               'continue filling
01950                 | objmem
01950                 | 	long	0[0]
01950                 | stackspace
01950     00 00 00 00 | 	long	0[1]
01954 0bf             | 	org	COG_BSS_START
01954 0bf             | _var01
01954 0bf             | 	res	1
01954 0c0             | _var02
01954 0c0             | 	res	1
01954 0c1             | arg01
01954 0c1             | 	res	1
01954 0c2             | arg02
01954 0c2             | 	res	1
01954 0c3             | arg03
01954 0c3             | 	res	1
01954 0c4             | arg04
01954 0c4             | 	res	1
01954 0c5             | local01
01954 0c5             | 	res	1
01954 0c6             | local02
01954 0c6             | 	res	1
01954 0c7             | local03
01954 0c7             | 	res	1
01954 0c8             | local04
01954 0c8             | 	res	1
01954 0c9             | 	fit	480
01954 0c9             | 
