00000                 | 
00000                 | #line 1 "D:/Programowanie/P2-Retromachine-Basic/triangle.p2asm"
00000                 | con
00000                 | 	_clkfreq = 338695652
00000                 | 	_clkmode = 28773115
00000                 | 	pin = 0
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 338695652
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $1b70afb
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 74 06 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 03 90 5D |  if_ne	jmp	#spininit
0040c 002 39 F1 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 02 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 85 DB 80 FF 
00420 007 00 F0 65 FD | 	hubset	##28773112
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 85 DB 00 FF 
00430 00b FB EC 07 F6 | 	mov	pa, ##28773115
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 0A 18 8A FF 
00440 00f 14 C8 6F FC | 	wrlong	##338695652, #20
00444 010 BC 02 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
006fc 0be 00 00 00 00 
00700 0bf 00 00 00 00 | 	orgf	192
00704 0c0             | skip_clock_set_
00704 0c0 F8 08 A0 FD | 	call	#_program
00708 0c1             | cogexit
00708 0c1 38 01 80 FF 
0070c 0c2 1F 00 66 FD | 	waitx	##160000
00710 0c3 01 8A 62 FD | 	cogid	arg01
00714 0c4 03 8A 62 FD | 	cogstop	arg01
00718 0c5             | spininit
00718 0c5 61 67 06 FB | 	rdlong	objptr, ptra++
0071c 0c6 61 75 06 FB | 	rdlong	result1, ptra++
00720 0c7 28 06 64 FD | 	setq	#3
00724 0c8 00 8B 06 FB | 	rdlong	arg01, ptra
00728 0c9 04 F0 87 F1 | 	sub	ptra, #4
0072c 0ca 2D 74 62 FD | 	call	result1
00730 0cb D4 FF 9F FD | 	jmp	#cogexit
00734 0cc             | FCACHE_LOAD_
00734 0cc F9 AD 01 F6 |     mov	fcache_tmpb_,ptrb
00738 0cd 2B F2 63 FD |     pop	ptrb
0073c 0ce D5 EC 8B F9 |     altd	pa,ret_instr_
00740 0cf D5 00 00 F6 |     mov	 0-0, ret_instr_
00744 0d0 28 EC 63 FD |     setq	pa
00748 0d1 E1 01 04 FB |     rdlong	$0, ptrb++
0074c 0d2 2A F2 63 FD |     push	ptrb
00750 0d3 D6 F2 03 F6 |     mov ptrb,fcache_tmpb_
00754 0d4 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00758 0d5             | ret_instr_
00758 0d5 00 FE 07 02 |     _ret_ cmp inb,#0
0075c 0d6             | fcache_tmpb_
0075c 0d6 00 00 00 00 |     long 0
00760 0d7             | fcache_load_ptr_
00760 0d7 CC 00 00 00 |     long FCACHE_LOAD_
00764 0d8             | builtin_bytefill_
00764 0d8 01 8E 56 F0 |         shr	arg03, #1 wc
00768 0d9 45 8D 42 CC |  if_c   wrbyte	arg02, arg01
0076c 0da 01 8A 06 C1 |  if_c   add	arg01, #1
00770 0db 00 8C FE F9 |         movbyts	arg02, #0
00774 0dc             | builtin_wordfill_
00774 0dc 01 8E 56 F0 |         shr	arg03, #1 wc
00778 0dd 45 8D 52 CC |  if_c   wrword	arg02, arg01
0077c 0de 02 8A 06 C1 |  if_c   add	arg01, #2
00780 0df 46 8D 2A F9 |         setword	arg02, arg02, #1
00784 0e0             | builtin_longfill_
00784 0e0 45 01 88 FC |         wrfast	#0,arg01
00788 0e1 00 8E 0E F2 |         cmp	arg03, #0 wz
0078c 0e2 47 03 D8 5C |  if_nz  rep	#1, arg03
00790 0e3 17 8C 62 5D |  if_nz  wflong	arg02
00794 0e4 2D 00 64 FD |         ret
00798 0e5             | COUNT_
00798 0e5 00 00 00 00 |     long 0
0079c 0e6             | RETADDR_
0079c 0e6 00 00 00 00 |     long 0
007a0 0e7             | fp
007a0 0e7 00 00 00 00 |     long 0
007a4 0e8             | pushregs_
007a4 0e8 2B EC 63 FD |     pop  pa
007a8 0e9 2B CC 61 FD |     pop  RETADDR_
007ac 0ea 03 CA 95 FB |     tjz  COUNT_, #pushregs_done_
007b0 0eb FF CB 8D F9 |     altd  COUNT_, #511
007b4 0ec 28 00 64 FD |     setq #0-0
007b8 0ed 61 95 66 FC |     wrlong local01, ptra++
007bc 0ee             | pushregs_done_
007bc 0ee 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
007c0 0ef 61 CB 65 FC |     wrlong COUNT_, ptra++
007c4 0f0 F8 CF 01 F6 |     mov    fp, ptra
007c8 0f1 2C EC 63 FD |     jmp  pa
007cc 0f2             |  popregs_
007cc 0f2 2B EC 63 FD |     pop    pa
007d0 0f3 28 04 64 FD |     setq   #2
007d4 0f4 5F CB 05 FB |     rdlong COUNT_, --ptra
007d8 0f5 02 CA 75 FB |     djf    COUNT_, #popregs__ret
007dc 0f6 28 CA 61 FD |     setq   COUNT_
007e0 0f7 5F 95 06 FB |     rdlong local01, --ptra
007e4 0f8             | popregs__ret
007e4 0f8 2A CC 61 FD |     push   RETADDR_
007e8 0f9 2C EC 63 FD |     jmp    pa
007ec 0fa             | 
007ec 0fa             | divide_
007ec 0fa 58 B1 5A F6 |        abs     muldivb_,muldivb_     wcz      'abs(y)
007f0 0fb 6C 64 62 FD |        wrc     itmp2_                         'store sign of y
007f4 0fc 57 AF 52 F6 |        abs     muldiva_,muldiva_     wc       'abs(x)
007f8 0fd 58 AF 12 FD |        qdiv    muldiva_, muldivb_             'queue divide
007fc 0fe 01 64 66 C5 |  if_c  xor     itmp2_,#1                      'store sign of x
00800 0ff 18 B0 62 FD |        getqx   muldivb_                       'get quotient
00804 100 19 AE 62 FD |        getqy   muldiva_                       'get remainder
00808 101 57 AF 82 F6 |        negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
0080c 102 00 64 16 F4 |        testb   itmp2_,#0             wc       'restore sign, division result
00810 103 58 B1 82 06 |  _ret_ negc    muldivb_,muldivb_     
00814 104             | __pc long 0
00814 104 00 00 00 00 
00818 105             | __setjmp
00818 105 2B 08 62 FD |     pop __pc
0081c 106 00 74 06 F6 |     mov result1, #0
00820 107 00 76 06 F6 |     mov result2, #0
00824 108 45 61 02 F6 |     mov abortchain, arg01
00828 109 45 CF 61 FC |     wrlong fp, arg01
0082c 10a 04 8A 06 F1 |     add arg01, #4
00830 10b 45 F1 63 FC |     wrlong ptra, arg01
00834 10c 04 8A 06 F1 |     add arg01, #4
00838 10d 45 67 62 FC |     wrlong objptr, arg01
0083c 10e 04 8A 06 F1 |     add arg01, #4
00840 10f 45 09 62 FC |     wrlong __pc, arg01
00844 110 2C 08 62 FD |     jmp __pc
00848 111             | __unwind_pc long 0
00848 111 00 00 00 00 
0084c 112             | __unwind_stack
0084c 112 2B 22 62 FD |    pop  __unwind_pc
00850 113             | __unwind_loop
00850 113 46 8B 0A F2 |    cmp  arg01, arg02 wz
00854 114 10 00 90 AD |   if_z jmp #__unwind_stack_ret
00858 115 45 F1 03 F6 |    mov   ptra, arg01
0085c 116 6C FF BF FD |    call  #popregs_
00860 117 E7 8A 02 F6 |    mov   arg01, fp
00864 118 E8 FF 9F FD |    jmp   #__unwind_loop
00868 119             | __unwind_stack_ret
00868 119 2C 22 62 FD |    jmp  __unwind_pc
0086c 11a             | __longjmp
0086c 11a 2B 08 62 FD |     pop __pc
00870 11b 00 8A 0E F2 |     cmp    arg01, #0 wz
00874 11c 30 00 90 AD |  if_z jmp #nocatch
00878 11d 46 75 02 F6 |     mov result1, arg02
0087c 11e 01 76 06 F6 |     mov result2, #1
00880 11f 45 8D 02 FB |     rdlong arg02, arg01
00884 120 04 8A 06 F1 |     add arg01, #4
00888 121 45 F1 03 FB |     rdlong ptra, arg01
0088c 122 04 8A 06 F1 |     add arg01, #4
00890 123 45 67 02 FB |     rdlong objptr, arg01
00894 124 04 8A 06 F1 |     add arg01, #4
00898 125 45 09 02 FB |     rdlong __pc, arg01
0089c 126 E7 8A 02 F6 |     mov arg01, fp
008a0 127 A8 FF BF FD |     call #__unwind_stack
008a4 128             | __longjmp_ret
008a4 128 2C 08 62 FD |     jmp  __pc
008a8 129             | nocatch
008a8 129 00 8E 0E F2 |     cmp arg03, #0 wz
008ac 12a 58 FE 9F AD |  if_z jmp #cogexit
008b0 12b F0 FF 9F FD |     jmp #__longjmp_ret
008b4 12c             | 
008b4 12c             | __heap_ptr
008b4 12c 6C B8 00 00 | 	long	@__heap_base
008b8 12d             | __methods__
008b8 12d 34 B8 00 00 | 	long	@__methodtable__
008bc 12e             | __recvreg
008bc 12e 00 00 00 00 | 	long	0
008c0 12f             | __sendreg
008c0 12f 00 00 00 00 | 	long	0
008c4 130             | abortchain
008c4 130 00 00 00 00 | 	long	0
008c8 131             | itmp1_
008c8 131 00 00 00 00 | 	long	0
008cc 132             | itmp2_
008cc 132 00 00 00 00 | 	long	0
008d0 133             | objptr
008d0 133 E4 CF 00 00 | 	long	@objmem
008d4 134             | ptr___system__dat__
008d4 134 04 B6 00 00 | 	long	@__system__dat_
008d8 135             | ptr__hg010b_spin2_dat__
008d8 135 3C 3C 00 00 | 	long	@_hg010b_spin2_dat_
008dc 136             | ptr__psram16drv_spin2_dat__
008dc 136 EC 7B 00 00 | 	long	@_psram16drv_spin2_dat_
008e0 137             | ptr__psram_spin2_dat__
008e0 137 A4 79 00 00 | 	long	@_psram_spin2_dat_
008e4 138             | ptr__usbnew_spin2_dat__
008e4 138 7C 8B 00 00 | 	long	@_usbnew_spin2_dat_
008e8 139             | ptr_stackspace_
008e8 139 3C 8C 01 00 | 	long	@stackspace
008ec 13a             | result1
008ec 13a 00 00 00 00 | 	long	0
008f0 13b             | result2
008f0 13b 01 00 00 00 | 	long	1
008f4 13c             | result3
008f4 13c 02 00 00 00 | 	long	2
008f8 13d             | COG_BSS_START
008f8 13d             | 	fit	480
008f8                 | 	orgh
008f8                 | hubentry
008f8                 | 
008f8                 | _program
008f8     01 CA 05 F6 | 	mov	COUNT_, #1
008fc     E8 00 A0 FD | 	call	#pushregs_
00900     00 8A 06 F6 | 	mov	arg01, #0
00904     0A 8C C6 F9 | 	decod	arg02, #10
00908     0B 8E 06 F6 | 	mov	arg03, #11
0090c     07 90 06 F6 | 	mov	arg04, #7
00910     0B 00 00 FF 
00914     CC 66 06 F1 | 	add	objptr, ##5836
00918     C0 0F B0 FD | 	call	#_psram_spin2_startx
0091c     40 00 00 FF 
00920     00 66 06 F1 | 	add	objptr, ##32768
00924     33 75 42 FC | 	wrbyte	result1, objptr
00928                 | '     return $7FF00 + cog*12
00928     04 66 06 F1 | 	add	objptr, #4
0092c     FF 03 80 FF 
00930     33 01 6A FC | 	wrlong	##524032, objptr
00934     4B 00 00 FF 
00938     D0 66 86 F1 | 	sub	objptr, ##38608
0093c     00 15 B0 FD | 	call	#_usbnew_spin2_start
00940     4B 00 00 FF 
00944     CE 66 06 F1 | 	add	objptr, ##38606
00948     33 75 42 FC | 	wrbyte	result1, objptr
0094c     02 66 06 F1 | 	add	objptr, #2
00950     33 8D 02 FB | 	rdlong	arg02, objptr
00954     4B 00 00 FF 
00958     D0 66 86 F1 | 	sub	objptr, ##38608
0095c     00 8A 06 F6 | 	mov	arg01, #0
00960     00 01 B0 FD | 	call	#_hg010b_spin2_start
00964     4B 00 00 FF 
00968     CD 66 06 F1 | 	add	objptr, ##38605
0096c     33 75 42 FC | 	wrbyte	result1, objptr
00970                 | ' 
00970                 | ' pscog=psram.startx(0, 1024, 11, 7)
00970                 | ' mbox=psram.getMailbox(0)
00970                 | ' usbcog=kbm.start()
00970                 | ' videocog=v.start(pin,mbox)
00970                 | ' for thecog=0 to 7:psram.setQos(thecog, 80 << 16) :next thecog
00970     00 94 06 F6 | 	mov	local01, #0
00974     40 00 00 FF 
00978     01 66 86 F1 | 	sub	objptr, ##32769
0097c                 | LR__0001
0097c     4A 8B 02 F6 | 	mov	arg01, local01
00980     00 28 00 FF 
00984     00 8C 06 F6 | 	mov	arg02, ##5242880
00988     B0 13 B0 FD | 	call	#_psram_spin2_setQos
0098c     01 94 06 F1 | 	add	local01, #1
00990     08 94 56 F2 | 	cmps	local01, #8 wc
00994     E4 FF 9F CD |  if_b	jmp	#LR__0001
00998     40 00 00 FF 
0099c     01 66 06 F1 | 	add	objptr, ##32769
009a0     33 8B C2 FA | 	rdbyte	arg01, objptr
009a4     7A 00 02 FF 
009a8     00 8C 06 F6 | 	mov	arg02, ##67171328
009ac     40 00 00 FF 
009b0     01 66 86 F1 | 	sub	objptr, ##32769
009b4     84 13 B0 FD | 	call	#_psram_spin2_setQos
009b8     0B 00 00 FF 
009bc     CC 66 86 F1 | 	sub	objptr, ##5836
009c0                 | ' psram.setQoS(videocog, $0400f400) 
009c0                 | ' open SendRecvDevice(@v.putchar, nil, nil) as #0
009c0     33 8D 02 F6 | 	mov	arg02, objptr
009c4     15 8C 26 F4 | 	bith	arg02, #21
009c8     00 8E 06 F6 | 	mov	arg03, #0
009cc     00 90 06 F6 | 	mov	arg04, #0
009d0     00 8A 06 F6 | 	mov	arg01, #0
009d4     34 1F B0 FD | 	call	#__system___basic_open
009d8     33 5F 02 F6 | 	mov	__sendreg, objptr
009dc     15 5E 26 F4 | 	bith	__sendreg, #21
009e0     33 5D 02 F6 | 	mov	__recvreg, objptr
009e4     0B 00 00 FF 
009e8     CC 5C 06 F1 | 	add	__recvreg, ##5836
009ec     34 5C 26 F4 | 	bith	__recvreg, #52
009f0     64 8A 06 F6 | 	mov	arg01, #100
009f4     3C 1E B0 FD | 	call	#__system___waitms
009f8     9A 8A 06 F6 | 	mov	arg01, #154
009fc     93 8C 06 F6 | 	mov	arg02, #147
00a00     A0 09 B0 FD | 	call	#_hg010b_spin2_cls
00a04                 | ' send=v.putchar
00a04                 | ' recv=kbm.get_key
00a04                 | ' waitms(100)
00a04                 | ' v.cls(154,147)
00a04                 | ' print "Test ready"
00a04     00 8A 06 F6 | 	mov	arg01, #0
00a08     78 2E B0 FD | 	call	#__system___getiolock_0095
00a0c     3A 8B 02 F6 | 	mov	arg01, result1
00a10     18 1D B0 FD | 	call	#__system___lockmem
00a14     1E 00 00 FF 
00a18     2E 8C 06 F6 | 	mov	arg02, ##@LR__0533
00a1c     00 8A 06 F6 | 	mov	arg01, #0
00a20     00 8E 06 F6 | 	mov	arg03, #0
00a24     94 20 B0 FD | 	call	#__system___basic_print_string
00a28     00 8A 06 F6 | 	mov	arg01, #0
00a2c     0A 8C 06 F6 | 	mov	arg02, #10
00a30     00 8E 06 F6 | 	mov	arg03, #0
00a34     2C 20 B0 FD | 	call	#__system___basic_print_char
00a38     00 8A 06 F6 | 	mov	arg01, #0
00a3c     44 2E B0 FD | 	call	#__system___getiolock_0095
00a40     3A 01 68 FC | 	wrlong	#0, result1
00a44     0B 00 00 FF 
00a48     CC 66 06 F1 | 	add	objptr, ##5836
00a4c     B4 14 B0 FD | 	call	#_hello_b_program
00a50     0B 00 00 FF 
00a54     CC 66 86 F1 | 	sub	objptr, ##5836
00a58     E7 F0 03 F6 | 	mov	ptra, fp
00a5c     F2 00 A0 FD | 	call	#popregs_
00a60                 | _program_ret
00a60     2D 00 64 FD | 	ret
00a64                 | 
00a64                 | ' '' this is not a main program.
00a64                 | ' 
00a64                 | ' '****************************************************************************************************************
00a64                 | ' '                                                                                                             	*
00a64                 | ' 'Start the driver  at pins 'base'                            					rev 20230829 	*
00a64                 | ' '                                                                                                            	*
00a64                 | ' ' base - HDMI base pin												*
00a64                 | ' ' mb - PSRAM mailbox pointer, 0 if no PSRAM									*
00a64                 | ' '														*
00a64                 | ' '														*
00a64                 | ' '****************************************************************************************************************
00a64                 | ' 
00a64                 | ' pub start(base,mb):result |i
00a64                 | _hg010b_spin2_start
00a64                 | ' 
00a64                 | ' '--------------------------- initialize pointers and variables
00a64                 | ' 
00a64                 | ' border_ptr:=@bordercolor					' Initial border color pointer, can be changed via DL
00a64     34 66 06 F1 | 	add	objptr, #52
00a68     33 75 02 F6 | 	mov	result1, objptr
00a6c     28 66 86 F1 | 	sub	objptr, #40
00a70     33 75 62 FC | 	wrlong	result1, objptr
00a74                 | ' 'font_ptr:=@amiga_font						' Initial 8x16 font definition
00a74                 | ' hdmibase:=base							' HDMI base pin, 8*n
00a74     18 66 06 F1 | 	add	objptr, #24
00a78     33 8B 62 FC | 	wrlong	arg01, objptr
00a7c                 | ' mailbox_ptr:=mb		
00a7c     04 66 06 F1 | 	add	objptr, #4
00a80     33 8D 62 FC | 	wrlong	arg02, objptr
00a84                 | ' mailbox0:=mb				' PSRAM mailbox pointer
00a84     C1 67 06 F1 | 	add	objptr, #449
00a88     33 8D 62 FC | 	wrlong	arg02, objptr
00a8c                 | ' sprite_ptr:=@spr1ptr
00a8c     D8 66 86 F1 | 	sub	objptr, #216
00a90     33 75 02 F6 | 	mov	result1, objptr
00a94     E5 66 86 F1 | 	sub	objptr, #229
00a98     33 75 62 FC | 	wrlong	result1, objptr
00a9c                 | ' 
00a9c                 | ' 		'
00a9c                 | ' word[spr1ptr+17*12+4]:=8				' spr18w
00a9c     E5 66 06 F1 | 	add	objptr, #229
00aa0     33 75 02 FB | 	rdlong	result1, objptr
00aa4     D0 74 06 F1 | 	add	result1, #208
00aa8     3A 11 58 FC | 	wrword	#8, result1
00aac                 | ' word[spr1ptr+17*12+6]:=16				' for a blinking cursor
00aac     33 8F 02 FB | 	rdlong	arg03, objptr
00ab0     D2 8E 06 F1 | 	add	arg03, #210
00ab4     47 21 58 FC | 	wrword	#16, arg03
00ab8                 | ' leading_spaces:=0				'
00ab8     A5 67 06 F1 | 	add	objptr, #421
00abc     33 01 68 FC | 	wrlong	#0, objptr
00ac0                 | ' 
00ac0                 | ' emptydl[0]:=%0100_0000_0000_0000_0000_0000_0000_0111
00ac0     99 66 86 F1 | 	sub	objptr, #153
00ac4     00 00 A0 FF 
00ac8     33 0F 68 FC | 	wrlong	##1073741831, objptr
00acc                 | ' emptydl[1]:=0
00acc     04 66 06 F1 | 	add	objptr, #4
00ad0     33 01 68 FC | 	wrlong	#0, objptr
00ad4                 | ' 
00ad4                 | ' '---------------------------- the mode has to be set here to enable computing the buffer length
00ad4                 | ' 
00ad4                 | ' s_debug:=debugger						' check if debug mode defined (eats 16 kB upper RAM so don't use it)					' 
00ad4     28 67 86 F1 | 	sub	objptr, #296
00ad8     33 03 68 FC | 	wrlong	#1, objptr
00adc                 | ' if s_debug<>0
00adc                 | '   s_debug:=16384						' the buffers adresses will be corrected to not interfere with the debugger
00adc     20 00 80 FF 
00ae0     33 01 68 FC | 	wrlong	##16384, objptr
00ae4     F9 66 86 F1 | 	sub	objptr, #249
00ae8                 | ' setmode()							' set the mode, see below
00ae8     30 02 B0 FD | 	call	#_hg010b_spin2_setmode
00aec                 | ' vblank_ptr:=@vblank						' set pointers before starting the driver
00aec     49 66 06 F1 | 	add	objptr, #73
00af0     33 75 02 F6 | 	mov	result1, objptr
00af4     35 66 86 F1 | 	sub	objptr, #53
00af8     33 75 62 FC | 	wrlong	result1, objptr
00afc                 | ' cursor_ptr:=@cursor_x						
00afc     28 66 06 F1 | 	add	objptr, #40
00b00     33 8F 02 F6 | 	mov	arg03, objptr
00b04     2C 66 86 F1 | 	sub	objptr, #44
00b08     33 8F 62 FC | 	wrlong	arg03, objptr
00b0c                 | ' fontnum:=0  							' start with a PC type font 
00b0c     55 66 06 F1 | 	add	objptr, #85
00b10     33 01 68 FC | 	wrlong	#0, objptr
00b14                 | ' bytemove(@colors,@vgacolors,16)					' prepare standard DOS VGA colors
00b14     1C 66 06 F1 | 	add	objptr, #28
00b18     33 8B 02 F6 | 	mov	arg01, objptr
00b1c     81 66 86 F1 | 	sub	objptr, #129
00b20     35 8D 02 F6 | 	mov	arg02, ptr__hg010b_spin2_dat__
00b24     1C 00 00 FF 
00b28     80 8C 06 F1 | 	add	arg02, ##14464
00b2c     10 8E 06 F6 | 	mov	arg03, #16
00b30     3C 1B B0 FD | 	call	#__system____builtin_memmove
00b34                 | ' leading_spaces:=0
00b34     01 00 00 FF 
00b38     B6 66 06 F1 | 	add	objptr, ##694
00b3c     33 01 68 FC | 	wrlong	#0, objptr
00b40     01 00 00 FF 
00b44     B6 66 86 F1 | 	sub	objptr, ##694
00b48                 | ' '---------------------------- initialize a cursor (MSDOS type)
00b48                 | ' 
00b48                 | ' initcursor(154)
00b48     9A 8A 06 F6 | 	mov	arg01, #154
00b4c     48 00 B0 FD | 	call	#_hg010b_spin2_initcursor
00b50                 | ' 
00b50                 | ' '---------------------------- start the cog
00b50                 | ' 
00b50                 | ' cog:=coginit(16,@hdmi, @vblank_ptr)				' start the driver cog			
00b50     35 8D 02 F6 | 	mov	arg02, ptr__hg010b_spin2_dat__
00b54     1C 00 00 FF 
00b58     90 8C 06 F1 | 	add	arg02, ##14480
00b5c     33 8F 02 F6 | 	mov	arg03, objptr
00b60     14 8E 06 F1 | 	add	arg03, #20
00b64     10 74 06 F6 | 	mov	result1, #16
00b68     28 8E 62 FD | 	setq	arg03
00b6c     46 75 F2 FC | 	coginit	result1, arg02 wc
00b70     01 74 66 C6 |  if_b	neg	result1, #1
00b74     30 66 06 F1 | 	add	objptr, #48
00b78     33 75 62 FC | 	wrlong	result1, objptr
00b7c     30 66 86 F1 | 	sub	objptr, #48
00b80                 | ' waitms(40)							' wait for stabilize
00b80     28 8A 06 F6 | 	mov	arg01, #40
00b84     AC 1C B0 FD | 	call	#__system___waitms
00b88                 | ' return cog							' return the driver's cog #
00b88     30 66 06 F1 | 	add	objptr, #48
00b8c     33 75 02 FB | 	rdlong	result1, objptr
00b90     30 66 86 F1 | 	sub	objptr, #48
00b94                 | _hg010b_spin2_start_ret
00b94     2D 00 64 FD | 	ret
00b98                 | 
00b98                 | ' 
00b98                 | ' '---------------------------- initialize a cursor (MSDOS type)
00b98                 | ' pub initcursor(color) |i
00b98                 | _hg010b_spin2_initcursor
00b98     03 CA 05 F6 | 	mov	COUNT_, #3
00b9c     E8 00 A0 FD | 	call	#pushregs_
00ba0     45 95 02 F6 | 	mov	local01, arg01
00ba4                 | ' 
00ba4                 | ' cursor_x:=0							' place the cursor at 0:0
00ba4     3C 66 06 F1 | 	add	objptr, #60
00ba8     33 01 58 FC | 	wrword	#0, objptr
00bac                 | ' cursor_y:=0
00bac     02 66 06 F1 | 	add	objptr, #2
00bb0     33 01 48 FC | 	wrbyte	#0, objptr
00bb4                 | ' repeat i from 0 to 111
00bb4     00 96 06 F6 | 	mov	local02, #0
00bb8     F8 67 06 F1 | 	add	objptr, #504
00bbc     D7 0C 48 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
00bc0                 | LR__0010
00bc0                 | '   cursor[i]:=0
00bc0     4B 99 02 F6 | 	mov	local03, local02
00bc4     33 99 02 F1 | 	add	local03, objptr
00bc8     4C 01 48 FC | 	wrbyte	#0, local03
00bcc     01 96 06 F1 | 	add	local02, #1
00bd0     70 96 56 F2 | 	cmps	local02, #112 wc
00bd4     E8 FF 9F CD |  if_b	jmp	#LR__0010
00bd8                 | LR__0011
00bd8                 | ' repeat i from 112 to 127
00bd8     70 96 06 F6 | 	mov	local02, #112
00bdc     D7 0C 48 FB | 	callpa	#(@LR__0013-@LR__0012)>>2,fcache_load_ptr_
00be0                 | LR__0012
00be0                 | '   cursor[i]:=color  
00be0     4B 99 02 F6 | 	mov	local03, local02
00be4     33 99 02 F1 | 	add	local03, objptr
00be8     4C 95 42 FC | 	wrbyte	local01, local03
00bec     01 96 06 F1 | 	add	local02, #1
00bf0     80 96 16 F2 | 	cmp	local02, #128 wc
00bf4     E8 FF 9F CD |  if_b	jmp	#LR__0012
00bf8                 | LR__0013
00bf8     01 00 00 FF 
00bfc     36 66 86 F1 | 	sub	objptr, ##566
00c00                 | ' 'repeat i from 0 to 127
00c00                 | ' '  if ((i/8)//2)
00c00                 | ' '    cursor[i]:=15
00c00                 | ' '  else
00c00                 | ' '    cursor[i]:=0
00c00                 | ' '  if i>=120    
00c00                 | ' '    cursor[i]:=40
00c00                 | ' setspriteptr(17,@cursor)
00c00     33 8D 02 F6 | 	mov	arg02, objptr
00c04     01 00 00 FF 
00c08     36 8C 06 F1 | 	add	arg02, ##566
00c0c     11 8A 06 F6 | 	mov	arg01, #17
00c10     10 04 B0 FD | 	call	#_hg010b_spin2_setspriteptr
00c14                 | ' setspritesize(17,8,16)
00c14     11 8A 06 F6 | 	mov	arg01, #17
00c18     08 8C 06 F6 | 	mov	arg02, #8
00c1c     10 8E 06 F6 | 	mov	arg03, #16
00c20     8C 04 B0 FD | 	call	#_hg010b_spin2_setspritesize
00c24                 | ' setspritepos(17,0,0)
00c24     11 8A 06 F6 | 	mov	arg01, #17
00c28     00 8C 06 F6 | 	mov	arg02, #0
00c2c     00 8E 06 F6 | 	mov	arg03, #0
00c30     14 04 B0 FD | 	call	#_hg010b_spin2_setspritepos
00c34                 | ' cursorshape:=14
00c34     0B 00 00 FF 
00c38     C6 66 06 F1 | 	add	objptr, ##5830
00c3c     33 1D 68 FC | 	wrlong	#14, objptr
00c40                 | ' cursorcolor:=color
00c40     04 66 86 F1 | 	sub	objptr, #4
00c44     33 95 62 FC | 	wrlong	local01, objptr
00c48     0B 00 00 FF 
00c4c     C2 66 86 F1 | 	sub	objptr, ##5826
00c50     E7 F0 03 F6 | 	mov	ptra, fp
00c54     F2 00 A0 FD | 	call	#popregs_
00c58                 | _hg010b_spin2_initcursor_ret
00c58     2D 00 64 FD | 	ret
00c5c                 | 
00c5c                 | ' 
00c5c                 | ' pub setcursorcolor(color) | i
00c5c                 | _hg010b_spin2_setcursorcolor
00c5c                 | ' 
00c5c                 | ' cursorcolor:=color
00c5c     0B 00 00 FF 
00c60     C2 66 06 F1 | 	add	objptr, ##5826
00c64     33 8B 62 FC | 	wrlong	arg01, objptr
00c68                 | ' repeat i from 0 to (8*cursorshape)-1
00c68     00 8A 06 F6 | 	mov	arg01, #0
00c6c     04 66 06 F1 | 	add	objptr, #4
00c70     33 7B 02 FB | 	rdlong	_var01, objptr
00c74     03 7A 66 F0 | 	shl	_var01, #3
00c78     01 7A 86 F1 | 	sub	_var01, #1
00c7c     00 7A 56 F2 | 	cmps	_var01, #0 wc
00c80     01 7C 86 F6 | 	negc	_var02, #1
00c84     3E 7F 02 F6 | 	mov	_var03, _var02
00c88     3E 7B 02 F1 | 	add	_var01, _var02
00c8c     0A 00 00 FF 
00c90     90 66 86 F1 | 	sub	objptr, ##5264
00c94     D7 0C 48 FB | 	callpa	#(@LR__0021-@LR__0020)>>2,fcache_load_ptr_
00c98                 | LR__0020
00c98                 | '   cursor[i]:=0
00c98     45 7D 02 F6 | 	mov	_var02, arg01
00c9c     33 7D 02 F1 | 	add	_var02, objptr
00ca0     3E 01 48 FC | 	wrbyte	#0, _var02
00ca4     3F 8B 02 F1 | 	add	arg01, _var03
00ca8     3D 8B 0A F2 | 	cmp	arg01, _var01 wz
00cac     E8 FF 9F 5D |  if_ne	jmp	#LR__0020
00cb0                 | LR__0021
00cb0                 | ' repeat i from 8*cursorshape to 127
00cb0     0A 00 00 FF 
00cb4     90 66 06 F1 | 	add	objptr, ##5264
00cb8     33 7F 02 FB | 	rdlong	_var03, objptr
00cbc     3F 8B 02 F6 | 	mov	arg01, _var03
00cc0     03 8A 66 F0 | 	shl	arg01, #3
00cc4     0B 00 00 FF 
00cc8     C6 66 86 F1 | 	sub	objptr, ##5830
00ccc     03 7E 66 F0 | 	shl	_var03, #3
00cd0     80 7E 56 F2 | 	cmps	_var03, #128 wc
00cd4     01 7C A6 F6 | 	negnc	_var02, #1
00cd8     7F 7A 06 F6 | 	mov	_var01, #127
00cdc     3E 7B 02 F1 | 	add	_var01, _var02
00ce0     D7 1A 48 FB | 	callpa	#(@LR__0023-@LR__0022)>>2,fcache_load_ptr_
00ce4                 | LR__0022
00ce4                 | '   cursor[i]:=cursorcolor
00ce4     45 7F 02 F6 | 	mov	_var03, arg01
00ce8     01 00 00 FF 
00cec     36 66 06 F1 | 	add	objptr, ##566
00cf0     33 7F 02 F1 | 	add	_var03, objptr
00cf4     0A 00 00 FF 
00cf8     8C 66 06 F1 | 	add	objptr, ##5260
00cfc     33 81 02 FB | 	rdlong	_var04, objptr
00d00     0B 00 00 FF 
00d04     C2 66 86 F1 | 	sub	objptr, ##5826
00d08     3F 81 42 FC | 	wrbyte	_var04, _var03
00d0c     3E 8B 02 F1 | 	add	arg01, _var02
00d10     3D 8B 0A F2 | 	cmp	arg01, _var01 wz
00d14     CC FF 9F 5D |  if_ne	jmp	#LR__0022
00d18                 | LR__0023
00d18                 | _hg010b_spin2_setcursorcolor_ret
00d18     2D 00 64 FD | 	ret
00d1c                 | 
00d1c                 | '   
00d1c                 | '   
00d1c                 | '   
00d1c                 | ' pub setmode() | i', 'xzoom, yzoom, azoom
00d1c                 | _hg010b_spin2_setmode
00d1c     02 CA 05 F6 | 	mov	COUNT_, #2
00d20     E8 00 A0 FD | 	call	#pushregs_
00d24                 | ' 
00d24                 | ' 
00d24                 | ' dl_ptr:=@emptydl[0]
00d24     01 00 00 FF 
00d28     1D 66 06 F1 | 	add	objptr, ##541
00d2c     33 93 02 F6 | 	mov	arg05, objptr
00d30     FD 67 86 F1 | 	sub	objptr, #509
00d34     33 93 62 FC | 	wrlong	arg05, objptr
00d38                 | ' 
00d38                 | ' if cog>0 
00d38     10 66 06 F1 | 	add	objptr, #16
00d3c     33 93 02 FB | 	rdlong	arg05, objptr
00d40     30 66 86 F1 | 	sub	objptr, #48
00d44     01 92 56 F2 | 	cmps	arg05, #1 wc
00d48                 | '    waitvbl(1)						    	' if the driver is active, wait for vblank to set the new mode and DL	
00d48     01 8A 06 36 |  if_ae	mov	arg01, #1
00d4c     E4 05 B0 3D |  if_ae	call	#_hg010b_spin2_waitvbl
00d50                 | ' xres:=1024
00d50     01 00 00 FF 
00d54     26 66 06 F1 | 	add	objptr, ##550
00d58     02 00 80 FF 
00d5c     33 01 68 FC | 	wrlong	##1024, objptr
00d60                 | ' yres:=600
00d60     04 66 06 F1 | 	add	objptr, #4
00d64     01 00 80 FF 
00d68     33 B1 68 FC | 	wrlong	##600, objptr
00d6c                 | ' ppl:=(timings[3])
00d6c     1C 00 00 FF 
00d70     4C 6A 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14412
00d74     35 93 02 FB | 	rdlong	arg05, ptr__hg010b_spin2_dat__
00d78     51 67 86 F1 | 	sub	objptr, #337
00d7c     33 93 62 FC | 	wrlong	arg05, objptr
00d80                 | ' cpl:=timings[7]<<1                                      	' now cpl is longs per line
00d80     10 6A 06 F1 | 	add	ptr__hg010b_spin2_dat__, #16
00d84     35 95 02 FB | 	rdlong	local01, ptr__hg010b_spin2_dat__
00d88     01 94 66 F0 | 	shl	local01, #1
00d8c     80 66 86 F1 | 	sub	objptr, #128
00d90     33 95 62 FC | 	wrlong	local01, objptr
00d94                 | ' cpl1:=cpl '' todo remove
00d94     04 66 06 F1 | 	add	objptr, #4
00d98     33 95 62 FC | 	wrlong	local01, objptr
00d9c                 | ' palette_ptr:=@ataripalette				    	' use 256-colors palettr
00d9c     04 00 00 FF 
00da0     1C 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##2076
00da4     41 66 86 F1 | 	sub	objptr, #65
00da8     33 6B 62 FC | 	wrlong	ptr__hg010b_spin2_dat__, objptr
00dac                 | ' repeat i from 0 to 3
00dac     00 96 06 F6 | 	mov	local02, #0
00db0     04 00 00 FF 
00db4     00 6A 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##2048
00db8     08 66 06 F1 | 	add	objptr, #8
00dbc     D7 20 48 FB | 	callpa	#(@LR__0031-@LR__0030)>>2,fcache_load_ptr_
00dc0                 | LR__0030
00dc0                 | '   timings[i]:=timings[i]+hdmibase<<17+ timingsxxt          	' add a streamer config (imm->pins) to horizontal timings 
00dc0     4B 95 02 F6 | 	mov	local01, local02
00dc4     02 94 66 F0 | 	shl	local01, #2
00dc8     35 95 02 F1 | 	add	local01, ptr__hg010b_spin2_dat__
00dcc     33 93 02 FB | 	rdlong	arg05, objptr
00dd0     11 92 66 F0 | 	shl	arg05, #17
00dd4     4A 95 02 FB | 	rdlong	local01, local01
00dd8     49 95 02 F1 | 	add	local01, arg05
00ddc     80 40 38 FF 
00de0     00 94 06 F1 | 	add	local01, ##1887502336
00de4     4B 93 02 F6 | 	mov	arg05, local02
00de8     02 92 66 F0 | 	shl	arg05, #2
00dec     35 93 02 F1 | 	add	arg05, ptr__hg010b_spin2_dat__
00df0     49 95 62 FC | 	wrlong	local01, arg05
00df4     01 96 06 F1 | 	add	local02, #1
00df8     04 96 56 F2 | 	cmps	local02, #4 wc
00dfc     C0 FF 9F CD |  if_b	jmp	#LR__0030
00e00                 | LR__0031
00e00     24 66 86 F1 | 	sub	objptr, #36
00e04     1C 00 00 FF 
00e08     40 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14400
00e0c                 | ' 'clkfreq:=timings[9]					    	' set the clock frequency for the mode
00e0c                 | ' 'hubset(timings[10])
00e0c                 | ' waitms(1)                                                   	' wait for stabilization
00e0c     01 8A 06 F6 | 	mov	arg01, #1
00e10     20 1A B0 FD | 	call	#__system___waitms
00e14     1C 00 00 FF 
00e18     6C 6A 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14444
00e1c     35 97 02 FB | 	rdlong	local02, ptr__hg010b_spin2_dat__
00e20     61 66 06 F1 | 	add	objptr, #97
00e24     33 97 62 FC | 	wrlong	local02, objptr
00e28     4B 95 52 F6 | 	abs	local01, local02 wc
00e2c     04 94 46 F0 | 	shr	local01, #4
00e30     4A 95 82 F6 | 	negc	local01, local01
00e34     9C 66 06 F1 | 	add	objptr, #156
00e38     33 95 62 FC | 	wrlong	local01, objptr
00e3c     A4 66 86 F1 | 	sub	objptr, #164
00e40     33 97 02 FB | 	rdlong	local02, objptr
00e44     08 66 06 F1 | 	add	objptr, #8
00e48     33 95 02 FB | 	rdlong	local01, objptr
00e4c     4A 97 02 FD | 	qmul	local02, local01
00e50                 | ' lines:=timings[11]
00e50                 | ' t_lines:=lines/16
00e50                 | ' buflen:=cpl*lines						' framebuffer length in longs
00e50     29 66 86 F1 | 	sub	objptr, #41
00e54     19 94 C6 F9 | 	decod	local01, #25
00e58     10 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, #16
00e5c     18 96 62 FD | 	getqx	local02
00e60     33 97 62 FC | 	wrlong	local02, objptr
00e64     38 66 86 F1 | 	sub	objptr, #56
00e68     02 96 66 F0 | 	shl	local02, #2
00e6c     4B 95 82 F1 | 	sub	local01, local02
00e70     33 95 62 FC | 	wrlong	local01, objptr
00e74     FD 66 06 F1 | 	add	objptr, #253
00e78     33 97 02 FB | 	rdlong	local02, objptr
00e7c     35 93 02 FB | 	rdlong	arg05, ptr__hg010b_spin2_dat__
00e80     49 97 02 FD | 	qmul	local02, arg05
00e84                 | ' buf_ptr:=$2000000-4*buflen                          	     	' todo: get a PSRAM real himem 
00e84                 | ' textbuf_ptr:=buf_ptr-t_lines*timings[7]
00e84     F9 66 86 F1 | 	sub	objptr, #249
00e88                 | ' mode_ptr:=@timings						' set pointers to timings
00e88     1C 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, #28
00e8c                 | ' graphmode:=1024+512+192+48							' det global variable
00e8c                 | ' makedl(graphmode)							' make a DL for the mode
00e8c     03 00 00 FF 
00e90     F0 8A 06 F6 | 	mov	arg01, ##1776
00e94     18 96 62 FD | 	getqx	local02
00e98     4B 95 82 F1 | 	sub	local01, local02
00e9c     33 95 62 FC | 	wrlong	local01, objptr
00ea0     14 66 06 F1 | 	add	objptr, #20
00ea4     33 6B 62 FC | 	wrlong	ptr__hg010b_spin2_dat__, objptr
00ea8     79 66 06 F1 | 	add	objptr, #121
00eac     03 00 80 FF 
00eb0     33 E1 69 FC | 	wrlong	##1776, objptr
00eb4     91 66 86 F1 | 	sub	objptr, #145
00eb8     1C 00 00 FF 
00ebc     40 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14400
00ec0     E0 00 B0 FD | 	call	#_hg010b_spin2_makedl
00ec4                 | ' s_buf_ptr:=buf_ptr						' secondary copies of main framebuffer parameters 
00ec4     33 95 02 FB | 	rdlong	local01, objptr
00ec8     DD 66 06 F1 | 	add	objptr, #221
00ecc     33 95 62 FC | 	wrlong	local01, objptr
00ed0                 | ' s_font_ptr:=font_ptr
00ed0     D5 66 86 F1 | 	sub	objptr, #213
00ed4     33 95 02 FB | 	rdlong	local01, objptr
00ed8     D9 66 06 F1 | 	add	objptr, #217
00edc     33 95 62 FC | 	wrlong	local01, objptr
00ee0                 | ' s_lines:=lines
00ee0     80 66 86 F1 | 	sub	objptr, #128
00ee4     33 95 02 FB | 	rdlong	local01, objptr
00ee8     84 66 06 F1 | 	add	objptr, #132
00eec     33 95 62 FC | 	wrlong	local01, objptr
00ef0                 | ' s_buflen:=buflen
00ef0     AD 66 86 F1 | 	sub	objptr, #173
00ef4     33 95 02 FB | 	rdlong	local01, objptr
00ef8     B5 66 06 F1 | 	add	objptr, #181
00efc     33 95 62 FC | 	wrlong	local01, objptr
00f00                 | ' s_cpl:=cpl
00f00     94 66 86 F1 | 	sub	objptr, #148
00f04     33 95 02 FB | 	rdlong	local01, objptr
00f08     90 66 06 F1 | 	add	objptr, #144
00f0c     33 95 62 FC | 	wrlong	local01, objptr
00f10                 | ' s_cpl1:=cpl
00f10     90 66 86 F1 | 	sub	objptr, #144
00f14     33 95 02 FB | 	rdlong	local01, objptr
00f18     98 66 06 F1 | 	add	objptr, #152
00f1c     33 95 62 FC | 	wrlong	local01, objptr
00f20                 | ' st_lines:=t_lines
00f20     0C 66 06 F1 | 	add	objptr, #12
00f24     33 95 02 FB | 	rdlong	local01, objptr
00f28     04 66 06 F1 | 	add	objptr, #4
00f2c     33 95 62 FC | 	wrlong	local01, objptr
00f30                 | ' ppl:=ppl/xzoom  
00f30     28 66 86 F1 | 	sub	objptr, #40
00f34     33 AF 02 FB | 	rdlong	muldiva_, objptr
00f38     2C 66 06 F1 | 	add	objptr, #44
00f3c     33 B1 02 FB | 	rdlong	muldivb_, objptr
00f40     05 67 86 F1 | 	sub	objptr, #261
00f44     FA 00 A0 FD | 	call	#divide_
00f48     D9 66 06 F1 | 	add	objptr, #217
00f4c     33 B1 62 FC | 	wrlong	muldivb_, objptr
00f50                 | ' s_ppl:=ppl
00f50     1C 66 06 F1 | 	add	objptr, #28
00f54     33 B1 62 FC | 	wrlong	muldivb_, objptr
00f58     F5 66 86 F1 | 	sub	objptr, #245
00f5c                 | ' waitms(20)							' wait 
00f5c     14 8A 06 F6 | 	mov	arg01, #20
00f60     D0 18 B0 FD | 	call	#__system___waitms
00f64                 | ' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
00f64     04 66 06 F1 | 	add	objptr, #4
00f68     33 8B 02 FB | 	rdlong	arg01, objptr
00f6c     04 66 86 F1 | 	sub	objptr, #4
00f70     33 8F 02 FB | 	rdlong	arg03, objptr
00f74     45 8F 82 F1 | 	sub	arg03, arg01
00f78     20 8C 06 F6 | 	mov	arg02, #32
00f7c     00 90 06 F6 | 	mov	arg04, #0
00f80     01 92 06 F6 | 	mov	arg05, #1
00f84     0B 00 00 FF 
00f88     CC 66 06 F1 | 	add	objptr, ##5836
00f8c     B8 0C B0 FD | 	call	#_psram_spin2_fill
00f90     0B 00 00 FF 
00f94     CC 66 86 F1 | 	sub	objptr, ##5836
00f98     E7 F0 03 F6 | 	mov	ptra, fp
00f9c     F2 00 A0 FD | 	call	#popregs_
00fa0                 | _hg010b_spin2_setmode_ret
00fa0     2D 00 64 FD | 	ret
00fa4                 | 
00fa4                 | ' 
00fa4                 | ' '****************************************************************************************************************
00fa4                 | ' '                                                                                                             	*
00fa4                 | ' '  Make a display list for simple standard modes                                             	rev.20220319    *
00fa4                 | ' '                                                                                                             	*
00fa4                 | ' '****************************************************************************************************************
00fa4                 | ' 
00fa4                 | ' pub makedl(mode) |i,vzoom,border,psbuf,lines2
00fa4                 | _hg010b_spin2_makedl
00fa4                 | ' 
00fa4                 | ' psbuf:=$80000-s_debug-1024                                                     ' HUB line buffer on the top of HUB RAM (-16 kB if debug enabled)
00fa4                 | ' vzoom:=1<<((mode>>2) & 3)                                                      ' real vzoom from mode#
00fa4                 | ' repeat i from 0 to 11                                                           ' clear DL
00fa4     00 7A 06 F6 | 	mov	_var01, #0
00fa8     ED 67 06 F1 | 	add	objptr, #493
00fac     D7 0E 48 FB | 	callpa	#(@LR__0041-@LR__0040)>>2,fcache_load_ptr_
00fb0                 | LR__0040
00fb0                 | '   displaylist[i]:=0 
00fb0     3D 7D 02 F6 | 	mov	_var02, _var01
00fb4     02 7C 66 F0 | 	shl	_var02, #2
00fb8     33 7D 02 F1 | 	add	_var02, objptr
00fbc     3E 01 68 FC | 	wrlong	#0, _var02
00fc0     01 7A 06 F1 | 	add	_var01, #1
00fc4     0C 7A 56 F2 | 	cmps	_var01, #12 wc
00fc8     E4 FF 9F CD |  if_b	jmp	#LR__0040
00fcc                 | LR__0041
00fcc                 | '                         ' 
00fcc                 | ' displaylist[0]:=lines<<20+(0)<<16+%0001+ (0+(cpl1<<2)) <<4             
00fcc     8C 67 86 F1 | 	sub	objptr, #396
00fd0     33 7D 02 FB | 	rdlong	_var02, objptr
00fd4     14 7C 66 F0 | 	shl	_var02, #20
00fd8     01 7C 06 F1 | 	add	_var02, #1
00fdc     04 66 86 F1 | 	sub	objptr, #4
00fe0     33 7B 02 FB | 	rdlong	_var01, objptr
00fe4     06 7A 66 F0 | 	shl	_var01, #6
00fe8     3D 7D 02 F1 | 	add	_var02, _var01
00fec     90 67 06 F1 | 	add	objptr, #400
00ff0     33 7D 62 FC | 	wrlong	_var02, objptr
00ff4     ED 67 86 F1 | 	sub	objptr, #493
00ff8                 | ' displaylist[1]:=buf_ptr<<4+%10  
00ff8     33 7D 02 FB | 	rdlong	_var02, objptr
00ffc     04 7C 66 F0 | 	shl	_var02, #4
01000     02 7C 06 F1 | 	add	_var02, #2
01004     F1 67 06 F1 | 	add	objptr, #497
01008     33 7D 62 FC | 	wrlong	_var02, objptr
0100c                 | ' dl_ptr:=@displaylist[0] 						      ' tell the driver where to find the DL
0100c     04 66 86 F1 | 	sub	objptr, #4
01010     33 7D 02 F6 | 	mov	_var02, objptr
01014     CD 67 86 F1 | 	sub	objptr, #461
01018     33 7D 62 FC | 	wrlong	_var02, objptr
0101c     20 66 86 F1 | 	sub	objptr, #32
01020                 | _hg010b_spin2_makedl_ret
01020     2D 00 64 FD | 	ret
01024                 | 
01024                 | ' 
01024                 | ' 
01024                 | ' '****************************************************************************************************************
01024                 | ' '                                                                        					*
01024                 | ' '  Graphic primitives                                                    					*
01024                 | ' '                                                                        					*
01024                 | ' '****************************************************************************************************************
01024                 | ' 
01024                 | ' pub setspriteptr(num,ptr)
01024                 | _hg010b_spin2_setspriteptr
01024                 | ' long[@spr1ptr+12*num]:=ptr
01024     33 7B 02 F6 | 	mov	_var01, objptr
01028     11 7B 06 F1 | 	add	_var01, #273
0102c     45 7D 02 F6 | 	mov	_var02, arg01
01030     01 7C 66 F0 | 	shl	_var02, #1
01034     45 7D 02 F1 | 	add	_var02, arg01
01038     02 7C 66 F0 | 	shl	_var02, #2
0103c     3E 7B 02 F1 | 	add	_var01, _var02
01040     3D 8D 62 FC | 	wrlong	arg02, _var01
01044                 | _hg010b_spin2_setspriteptr_ret
01044     2D 00 64 FD | 	ret
01048                 | 
01048                 | ' 
01048                 | ' pub setspritepos(num,x,y)
01048                 | _hg010b_spin2_setspritepos
01048                 | ' if y>601
01048     01 00 00 FF 
0104c     5A 8E 56 F2 | 	cmps	arg03, ##602 wc
01050                 | '   y:=601
01050     01 00 00 3F 
01054     59 8E 06 36 |  if_ae	mov	arg03, ##601
01058                 | ' if x>1024
01058     02 00 00 FF 
0105c     01 8C 56 F2 | 	cmps	arg02, ##1025 wc
01060                 | '   x:=1024
01060     0A 8C C6 39 |  if_ae	decod	arg02, #10
01064                 | ' word[@spr1ptr+12*num+4]:=x
01064     11 67 06 F1 | 	add	objptr, #273
01068     33 7B 02 F6 | 	mov	_var01, objptr
0106c     45 7D 02 F6 | 	mov	_var02, arg01
01070     01 7C 66 F0 | 	shl	_var02, #1
01074     45 7D 02 F1 | 	add	_var02, arg01
01078     02 7C 66 F0 | 	shl	_var02, #2
0107c     3E 7B 02 F1 | 	add	_var01, _var02
01080     04 7A 06 F1 | 	add	_var01, #4
01084     3D 8D 52 FC | 	wrword	arg02, _var01
01088                 | ' word[@spr1ptr+12*num+6]:=y
01088     33 7B 02 F6 | 	mov	_var01, objptr
0108c     45 7D 02 F6 | 	mov	_var02, arg01
01090     01 7C 66 F0 | 	shl	_var02, #1
01094     45 7D 02 F1 | 	add	_var02, arg01
01098     02 7C 66 F0 | 	shl	_var02, #2
0109c     3E 7B 02 F1 | 	add	_var01, _var02
010a0     06 7A 06 F1 | 	add	_var01, #6
010a4     3D 8F 52 FC | 	wrword	arg03, _var01
010a8     11 67 86 F1 | 	sub	objptr, #273
010ac                 | _hg010b_spin2_setspritepos_ret
010ac     2D 00 64 FD | 	ret
010b0                 | 
010b0                 | ' 
010b0                 | ' pub setspritesize(num,w,h)
010b0                 | _hg010b_spin2_setspritesize
010b0                 | ' word[@spr1ptr+12*num+8]:=w
010b0     11 67 06 F1 | 	add	objptr, #273
010b4     33 7B 02 F6 | 	mov	_var01, objptr
010b8     45 7D 02 F6 | 	mov	_var02, arg01
010bc     01 7C 66 F0 | 	shl	_var02, #1
010c0     45 7D 02 F1 | 	add	_var02, arg01
010c4     02 7C 66 F0 | 	shl	_var02, #2
010c8     3E 7B 02 F1 | 	add	_var01, _var02
010cc     08 7A 06 F1 | 	add	_var01, #8
010d0     3D 8D 52 FC | 	wrword	arg02, _var01
010d4                 | ' word[@spr1ptr+12*num+10]:=h
010d4     33 7B 02 F6 | 	mov	_var01, objptr
010d8     45 7D 02 F6 | 	mov	_var02, arg01
010dc     01 7C 66 F0 | 	shl	_var02, #1
010e0     45 7D 02 F1 | 	add	_var02, arg01
010e4     02 7C 66 F0 | 	shl	_var02, #2
010e8     3E 7B 02 F1 | 	add	_var01, _var02
010ec     0A 7A 06 F1 | 	add	_var01, #10
010f0     3D 8F 52 FC | 	wrword	arg03, _var01
010f4     11 67 86 F1 | 	sub	objptr, #273
010f8                 | _hg010b_spin2_setspritesize_ret
010f8     2D 00 64 FD | 	ret
010fc                 | 
010fc                 | '   
010fc                 | ' '----------- A line drawing family. BASIC doesn't like the name, so it is named "draw" and aliased  -----------------------------
010fc                 | ' 
010fc                 | ' pub fastline(x1,x2,y,c)									' a fast 8bpp horizontal line
010fc                 | _hg010b_spin2_fastline
010fc     02 CA 05 F6 | 	mov	COUNT_, #2
01100     E8 00 A0 FD | 	call	#pushregs_
01104     45 95 02 F6 | 	mov	local01, arg01
01108     46 97 02 F6 | 	mov	local02, arg02
0110c                 | ' 
0110c                 | ' if y<0 || y>=yres || (x1<0 && x2<0) || (x1>xres && x2>xres)
0110c     00 8E 56 F2 | 	cmps	arg03, #0 wc
01110     F4 00 90 CD |  if_b	jmp	#LR__0050
01114     01 00 00 FF 
01118     2A 66 06 F1 | 	add	objptr, ##554
0111c     33 93 02 FB | 	rdlong	arg05, objptr
01120     01 00 00 FF 
01124     2A 66 86 F1 | 	sub	objptr, ##554
01128     49 8F 52 F2 | 	cmps	arg03, arg05 wc
0112c     D8 00 90 3D |  if_ae	jmp	#LR__0050
01130     00 94 56 F2 | 	cmps	local01, #0 wc
01134     00 96 56 C2 |  if_b	cmps	local02, #0 wc
01138     CC 00 90 CD |  if_b	jmp	#LR__0050
0113c     01 00 00 FF 
01140     26 66 06 F1 | 	add	objptr, ##550
01144     33 93 02 FB | 	rdlong	arg05, objptr
01148     01 00 00 FF 
0114c     26 66 86 F1 | 	sub	objptr, ##550
01150     49 95 5A F2 | 	cmps	local01, arg05 wcz
01154     01 00 00 1F 
01158     26 66 06 11 |  if_a	add	objptr, ##550
0115c     33 8B 02 1B |  if_a	rdlong	arg01, objptr
01160     01 00 00 1F 
01164     26 66 86 11 |  if_a	sub	objptr, ##550
01168     45 97 5A 12 |  if_a	cmps	local02, arg01 wcz
0116c                 | '   return
0116c     98 00 90 1D |  if_a	jmp	#LR__0050
01170     4B 95 5A F2 | 	cmps	local01, local02 wcz
01174     4A 93 02 16 |  if_a	mov	arg05, local01
01178     4B 95 02 16 |  if_a	mov	local01, local02
0117c     49 97 02 16 |  if_a	mov	local02, arg05
01180     00 94 56 F2 | 	cmps	local01, #0 wc
01184     00 94 06 C6 |  if_b	mov	local01, #0
01188     01 00 00 FF 
0118c     26 66 06 F1 | 	add	objptr, ##550
01190     33 93 02 FB | 	rdlong	arg05, objptr
01194     01 00 00 FF 
01198     26 66 86 F1 | 	sub	objptr, ##550
0119c     49 97 52 F2 | 	cmps	local02, arg05 wc
011a0     01 00 00 3F 
011a4     26 66 06 31 |  if_ae	add	objptr, ##550
011a8     33 97 02 3B |  if_ae	rdlong	local02, objptr
011ac     01 00 00 3F 
011b0     26 66 86 31 |  if_ae	sub	objptr, ##550
011b4     DD 66 06 F1 | 	add	objptr, #221
011b8     33 8B 02 FB | 	rdlong	arg01, objptr
011bc     14 66 06 F1 | 	add	objptr, #20
011c0     33 93 02 FB | 	rdlong	arg05, objptr
011c4     02 92 66 F0 | 	shl	arg05, #2
011c8     47 93 02 FD | 	qmul	arg05, arg03
011cc                 | ' if x1>x2
011cc                 | '   x1,x2:=x2,x1
011cc                 | ' if x1<0 
011cc                 | '   x1:=0
011cc                 | ' if x2>=xres
011cc                 | '   x2:=xres-1  
011cc     01 96 86 31 |  if_ae	sub	local02, #1
011d0                 | ' ram.fill(s_buf_ptr+(4*s_cpl1*y+x1),c,1+x2-x1,0,1)
011d0     01 8E 06 F6 | 	mov	arg03, #1
011d4     4B 8F 02 F1 | 	add	arg03, local02
011d8     4A 8F 82 F1 | 	sub	arg03, local01
011dc     48 8D 02 F6 | 	mov	arg02, arg04
011e0     00 90 06 F6 | 	mov	arg04, #0
011e4     01 92 06 F6 | 	mov	arg05, #1
011e8     0A 00 00 FF 
011ec     DB 67 06 F1 | 	add	objptr, ##5595
011f0     18 96 62 FD | 	getqx	local02
011f4     4A 97 02 F1 | 	add	local02, local01
011f8     4B 8B 02 F1 | 	add	arg01, local02
011fc     48 0A B0 FD | 	call	#_psram_spin2_fill
01200     0B 00 00 FF 
01204     CC 66 86 F1 | 	sub	objptr, ##5836
01208                 | LR__0050
01208     E7 F0 03 F6 | 	mov	ptra, fp
0120c     F2 00 A0 FD | 	call	#popregs_
01210                 | _hg010b_spin2_fastline_ret
01210     2D 00 64 FD | 	ret
01214                 | 
01214                 | '       
01214                 | ' pub putcharxycgf(x,y,achar,f,b) |xx, yy,bb,c1,c2
01214                 | _hg010b_spin2_putcharxycgf
01214                 | ' 
01214                 | '  
01214                 | ' repeat yy from 0 to 15
01214     00 7A 06 F6 | 	mov	_var01, #0
01218     D7 8A 48 FB | 	callpa	#(@LR__0062-@LR__0060)>>2,fcache_load_ptr_
0121c                 | LR__0060
0121c                 | ' 
0121c                 | '   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
0121c     95 66 06 F1 | 	add	objptr, #149
01220     33 7D 02 FB | 	rdlong	_var02, objptr
01224     0A 7C 66 F0 | 	shl	_var02, #10
01228     35 7F 02 F6 | 	mov	_var03, ptr__hg010b_spin2_dat__
0122c     3E 7F 02 F1 | 	add	_var03, _var02
01230     47 7D 02 F6 | 	mov	_var02, arg03
01234     04 7C 66 F0 | 	shl	_var02, #4
01238     3E 7F 02 F1 | 	add	_var03, _var02
0123c     3D 7F 02 F1 | 	add	_var03, _var01
01240     3F 7F C2 FA | 	rdbyte	_var03, _var03
01244                 | '   asm
01244     00 7E 0E F4 | 	testb	_var03, #0 wz
01248     48 81 C2 A8 |  if_e	setbyte	_var04, arg04, #0
0124c     49 81 C2 58 |  if_ne	setbyte	_var04, arg05, #0
01250     01 7E 0E F4 | 	testb	_var03, #1 wz
01254     48 81 CA A8 |  if_e	setbyte	_var04, arg04, #1
01258     49 81 CA 58 |  if_ne	setbyte	_var04, arg05, #1
0125c     02 7E 0E F4 | 	testb	_var03, #2 wz
01260     48 81 D2 A8 |  if_e	setbyte	_var04, arg04, #2
01264     49 81 D2 58 |  if_ne	setbyte	_var04, arg05, #2
01268     03 7E 0E F4 | 	testb	_var03, #3 wz
0126c     48 81 DA A8 |  if_e	setbyte	_var04, arg04, #3
01270     49 81 DA 58 |  if_ne	setbyte	_var04, arg05, #3
01274     04 7E 0E F4 | 	testb	_var03, #4 wz
01278     48 83 C2 A8 |  if_e	setbyte	_var05, arg04, #0
0127c     49 83 C2 58 |  if_ne	setbyte	_var05, arg05, #0
01280     05 7E 0E F4 | 	testb	_var03, #5 wz
01284     48 83 CA A8 |  if_e	setbyte	_var05, arg04, #1
01288     49 83 CA 58 |  if_ne	setbyte	_var05, arg05, #1
0128c     06 7E 0E F4 | 	testb	_var03, #6 wz
01290     48 83 D2 A8 |  if_e	setbyte	_var05, arg04, #2
01294     49 83 D2 58 |  if_ne	setbyte	_var05, arg05, #2
01298     07 7E 0E F4 | 	testb	_var03, #7 wz
0129c     48 83 DA A8 |  if_e	setbyte	_var05, arg04, #3
012a0     49 83 DA 58 |  if_ne	setbyte	_var05, arg05, #3
012a4                 | '   
012a4                 | '   ccc[0]:=c1
012a4     99 67 06 F1 | 	add	objptr, #409
012a8     33 81 62 FC | 	wrlong	_var04, objptr
012ac                 | '   ccc[1]:=c2 
012ac     04 66 06 F1 | 	add	objptr, #4
012b0     33 83 62 FC | 	wrlong	_var05, objptr
012b4                 | '   long[mailbox0][2]:=8
012b4     49 66 86 F1 | 	sub	objptr, #73
012b8     33 7F 02 FB | 	rdlong	_var03, objptr
012bc     08 7E 06 F1 | 	add	_var03, #8
012c0     3F 11 68 FC | 	wrlong	#8, _var03
012c4                 | '   long[mailbox0][1]:=@ccc
012c4     33 7F 02 F6 | 	mov	_var03, objptr
012c8     45 7E 06 F1 | 	add	_var03, #69
012cc     33 7D 02 FB | 	rdlong	_var02, objptr
012d0     04 7C 06 F1 | 	add	_var02, #4
012d4     3E 7F 62 FC | 	wrlong	_var03, _var02
012d8                 | '   long[mailbox0]:= s_buf_ptr+((y+yy)<<10+x<<2)+$f0000000   
012d8     0C 67 86 F1 | 	sub	objptr, #268
012dc     33 7F 02 FB | 	rdlong	_var03, objptr
012e0     46 7D 02 F6 | 	mov	_var02, arg02
012e4     3D 7D 02 F1 | 	add	_var02, _var01
012e8     0A 7C 66 F0 | 	shl	_var02, #10
012ec     45 85 02 F6 | 	mov	_var06, arg01
012f0     02 84 66 F0 | 	shl	_var06, #2
012f4     42 7D 02 F1 | 	add	_var02, _var06
012f8     3E 7F 02 F1 | 	add	_var03, _var02
012fc     00 00 78 FF 
01300     00 7E 06 F1 | 	add	_var03, ##-268435456
01304     0C 67 06 F1 | 	add	objptr, #268
01308     33 85 02 FB | 	rdlong	_var06, objptr
0130c     42 7F 62 FC | 	wrlong	_var03, _var06
01310                 | '   repeat
01310                 | LR__0061
01310     33 7F 02 FB | 	rdlong	_var03, objptr
01314     3F 7D 02 FB | 	rdlong	_var02, _var03
01318     00 7C 56 F2 | 	cmps	_var02, #0 wc
0131c     F0 FF 9F CD |  if_b	jmp	#LR__0061
01320     E9 67 86 F1 | 	sub	objptr, #489
01324     01 7A 06 F1 | 	add	_var01, #1
01328     10 7A 56 F2 | 	cmps	_var01, #16 wc
0132c     EC FE 9F CD |  if_b	jmp	#LR__0060
01330                 | LR__0062
01330                 | _hg010b_spin2_putcharxycgf_ret
01330     2D 00 64 FD | 	ret
01334                 | 
01334                 | ' 
01334                 | ' '*************************************************************************
01334                 | ' '                                                                        *
01334                 | ' '  VBlank functions                                                      *
01334                 | ' '                                                                        *
01334                 | ' '*************************************************************************
01334                 | ' 
01334                 | ' pub waitvbl(amount) | i
01334                 | _hg010b_spin2_waitvbl
01334     03 CA 05 F6 | 	mov	COUNT_, #3
01338     E8 00 A0 FD | 	call	#pushregs_
0133c     45 95 02 F6 | 	mov	local01, arg01
01340                 | ' 
01340                 | ' ''---------- Wait for start of vblank. Amount=delay in frames
01340                 | ' 
01340                 | ' repeat i from 1 to amount
01340     01 96 06 F6 | 	mov	local02, #1
01344     01 94 56 F2 | 	cmps	local01, #1 wc
01348     01 98 86 F6 | 	negc	local03, #1
0134c     4C 95 02 F1 | 	add	local01, local03
01350                 | LR__0070
01350                 | '   repeat until vblank==0
01350                 | LR__0071
01350     49 66 06 F1 | 	add	objptr, #73
01354     33 8B 0A FB | 	rdlong	arg01, objptr wz
01358     49 66 86 F1 | 	sub	objptr, #73
0135c     0C 00 90 AD |  if_e	jmp	#LR__0072
01360                 | '     waitus(100)
01360     64 8A 06 F6 | 	mov	arg01, #100
01364     38 15 B0 FD | 	call	#__system___waitus
01368     E4 FF 9F FD | 	jmp	#LR__0071
0136c                 | LR__0072
0136c                 | '   repeat until vblank==1
0136c                 | LR__0073
0136c     49 66 06 F1 | 	add	objptr, #73
01370     33 8B 02 FB | 	rdlong	arg01, objptr
01374     49 66 86 F1 | 	sub	objptr, #73
01378     01 8A 0E F2 | 	cmp	arg01, #1 wz
0137c     0C 00 90 AD |  if_e	jmp	#LR__0074
01380                 | '     waitus(100)
01380     64 8A 06 F6 | 	mov	arg01, #100
01384     18 15 B0 FD | 	call	#__system___waitus
01388     E0 FF 9F FD | 	jmp	#LR__0073
0138c                 | LR__0074
0138c     4C 97 02 F1 | 	add	local02, local03
01390     4A 97 0A F2 | 	cmp	local02, local01 wz
01394     B8 FF 9F 5D |  if_ne	jmp	#LR__0070
01398     E7 F0 03 F6 | 	mov	ptra, fp
0139c     F2 00 A0 FD | 	call	#popregs_
013a0                 | _hg010b_spin2_waitvbl_ret
013a0     2D 00 64 FD | 	ret
013a4                 | 
013a4                 | ' 
013a4                 | ' 
013a4                 | ' pub cls(fc,bc)   :c,i
013a4                 | _hg010b_spin2_cls
013a4     02 CA 05 F6 | 	mov	COUNT_, #2
013a8     E8 00 A0 FD | 	call	#pushregs_
013ac     45 95 02 F6 | 	mov	local01, arg01
013b0     46 97 02 F6 | 	mov	local02, arg02
013b4                 | ' 
013b4                 | ' c:=bc
013b4                 | ' ram.fill(s_buf_ptr,c,4*buflen,0,1)  
013b4     DD 66 06 F1 | 	add	objptr, #221
013b8     33 8B 02 FB | 	rdlong	arg01, objptr
013bc     A5 66 86 F1 | 	sub	objptr, #165
013c0     33 8F 02 FB | 	rdlong	arg03, objptr
013c4     02 8E 66 F0 | 	shl	arg03, #2
013c8     4B 8D 02 F6 | 	mov	arg02, local02
013cc     00 90 06 F6 | 	mov	arg04, #0
013d0     01 92 06 F6 | 	mov	arg05, #1
013d4     0B 00 00 FF 
013d8     94 66 06 F1 | 	add	objptr, ##5780
013dc     68 08 B0 FD | 	call	#_psram_spin2_fill
013e0                 | ' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
013e0     0B 00 00 FF 
013e4     C8 66 86 F1 | 	sub	objptr, ##5832
013e8     33 8B 02 FB | 	rdlong	arg01, objptr
013ec     04 66 86 F1 | 	sub	objptr, #4
013f0     33 8F 02 FB | 	rdlong	arg03, objptr
013f4     45 8F 82 F1 | 	sub	arg03, arg01
013f8     20 8C 06 F6 | 	mov	arg02, #32
013fc     00 90 06 F6 | 	mov	arg04, #0
01400     01 92 06 F6 | 	mov	arg05, #1
01404     0B 00 00 FF 
01408     CC 66 06 F1 | 	add	objptr, ##5836
0140c     38 08 B0 FD | 	call	#_psram_spin2_fill
01410                 | ' setwritecolors(fc,bc)
01410                 | ' 
01410                 | ' write_color:=ff
01410     0B 00 00 FF 
01414     8B 66 86 F1 | 	sub	objptr, ##5771
01418     33 95 62 FC | 	wrlong	local01, objptr
0141c                 | ' write_background:=bb
0141c     04 66 06 F1 | 	add	objptr, #4
01420     33 97 62 FC | 	wrlong	local02, objptr
01424                 | ' cursor_x:=0
01424     09 66 86 F1 | 	sub	objptr, #9
01428     33 01 58 FC | 	wrword	#0, objptr
0142c                 | ' cursor_y:=0
0142c     02 66 06 F1 | 	add	objptr, #2
01430     33 01 48 FC | 	wrbyte	#0, objptr
01434                 | ' setspritepos(17,4*cursor_x,16*cursor_y+4 )
01434     02 66 86 F1 | 	sub	objptr, #2
01438     33 8D E2 FA | 	rdword	arg02, objptr
0143c     02 8C 66 F0 | 	shl	arg02, #2
01440     3C 66 86 F1 | 	sub	objptr, #60
01444     04 8E 06 F6 | 	mov	arg03, #4
01448     11 8A 06 F6 | 	mov	arg01, #17
0144c     F8 FB BF FD | 	call	#_hg010b_spin2_setspritepos
01450                 | ' setcursorcolor(fc)
01450     4A 8B 02 F6 | 	mov	arg01, local01
01454     04 F8 BF FD | 	call	#_hg010b_spin2_setcursorcolor
01458     4B 75 02 F6 | 	mov	result1, local02
0145c     00 76 06 F6 | 	mov	result2, #0
01460     E7 F0 03 F6 | 	mov	ptra, fp
01464     F2 00 A0 FD | 	call	#popregs_
01468                 | _hg010b_spin2_cls_ret
01468     2D 00 64 FD | 	ret
0146c                 | 
0146c                 | ' 
0146c                 | ' ''---------- Output a char at the cursor position, move the cursor 
0146c                 | ' 
0146c                 | ' pub putchar(achar) | c,x,y,l,newcpl
0146c                 | _hg010b_spin2_putchar
0146c     02 CA 05 F6 | 	mov	COUNT_, #2
01470     E8 00 A0 FD | 	call	#pushregs_
01474     45 95 02 F6 | 	mov	local01, arg01
01478                 | ' 
01478                 | ' if achar==10
01478     0A 94 0E F2 | 	cmp	local01, #10 wz
0147c                 | '   crlf()
0147c     B8 03 B0 AD |  if_e	call	#_hg010b_spin2_crlf
01480                 | ' if achar==9
01480     09 94 0E F2 | 	cmp	local01, #9 wz
01484     18 00 90 5D |  if_ne	jmp	#LR__0080
01488                 | '   cursor_x:=(cursor_x& %11110000)+16
01488     3C 66 06 F1 | 	add	objptr, #60
0148c     33 8F E2 FA | 	rdword	arg03, objptr
01490     F0 8E 06 F5 | 	and	arg03, #240
01494     10 8E 06 F1 | 	add	arg03, #16
01498     33 8F 52 FC | 	wrword	arg03, objptr
0149c     3C 66 86 F1 | 	sub	objptr, #60
014a0                 | LR__0080
014a0                 | '   
014a0                 | ' if (achar<>9) && (achar<>10) 
014a0     09 94 0E F2 | 	cmp	local01, #9 wz
014a4     0A 94 0E 52 |  if_ne	cmp	local01, #10 wz
014a8     A8 00 90 AD |  if_e	jmp	#LR__0081
014ac                 | '   putcharxycgf(cursor_x,16*cursor_y+4,achar,write_color,write_background)
014ac     3C 66 06 F1 | 	add	objptr, #60
014b0     33 8B E2 FA | 	rdword	arg01, objptr
014b4     02 66 06 F1 | 	add	objptr, #2
014b8     33 8D C2 FA | 	rdbyte	arg02, objptr
014bc     04 8C 66 F0 | 	shl	arg02, #4
014c0     04 8C 06 F1 | 	add	arg02, #4
014c4     03 66 06 F1 | 	add	objptr, #3
014c8     33 91 02 FB | 	rdlong	arg04, objptr
014cc     04 66 06 F1 | 	add	objptr, #4
014d0     33 93 02 FB | 	rdlong	arg05, objptr
014d4     45 66 86 F1 | 	sub	objptr, #69
014d8     4A 8F 02 F6 | 	mov	arg03, local01
014dc     34 FD BF FD | 	call	#_hg010b_spin2_putcharxycgf
014e0     04 66 06 F1 | 	add	objptr, #4
014e4     33 8B 02 FB | 	rdlong	arg01, objptr
014e8     1C 00 00 FF 
014ec     5C 6A 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
014f0     35 8F 02 FB | 	rdlong	arg03, ptr__hg010b_spin2_dat__
014f4     3A 66 06 F1 | 	add	objptr, #58
014f8     33 93 C2 FA | 	rdbyte	arg05, objptr
014fc     49 8F 02 FD | 	qmul	arg03, arg05
01500                 | '   ram.fill(textbuf_ptr+(timings[7]*cursor_y+(cursor_x>>1)),achar,1,0,1)
01500     1C 00 00 FF 
01504     5C 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01508     02 66 86 F1 | 	sub	objptr, #2
0150c     33 97 E2 FA | 	rdword	local02, objptr
01510     01 96 46 F0 | 	shr	local02, #1
01514     4A 8D 02 F6 | 	mov	arg02, local01
01518     01 8E 06 F6 | 	mov	arg03, #1
0151c     00 90 06 F6 | 	mov	arg04, #0
01520     01 92 06 F6 | 	mov	arg05, #1
01524     0B 00 00 FF 
01528     90 66 06 F1 | 	add	objptr, ##5776
0152c     18 94 62 FD | 	getqx	local01
01530     4B 95 02 F1 | 	add	local01, local02
01534     4A 8B 02 F1 | 	add	arg01, local01
01538     0C 07 B0 FD | 	call	#_psram_spin2_fill
0153c                 | '   cursor_x+=2
0153c     0B 00 00 FF 
01540     90 66 86 F1 | 	sub	objptr, ##5776
01544     33 97 E2 FA | 	rdword	local02, objptr
01548     02 96 06 F1 | 	add	local02, #2
0154c     33 97 52 FC | 	wrword	local02, objptr
01550     3C 66 86 F1 | 	sub	objptr, #60
01554                 | LR__0081
01554                 | ' 
01554                 | ' if cursor_x>=256
01554     3C 66 06 F1 | 	add	objptr, #60
01558     33 97 E2 FA | 	rdword	local02, objptr
0155c     3C 66 86 F1 | 	sub	objptr, #60
01560     00 97 56 F2 | 	cmps	local02, #256 wc
01564     64 00 90 CD |  if_b	jmp	#LR__0083
01568                 | '   cursor_x:=0
01568     3C 66 06 F1 | 	add	objptr, #60
0156c     33 01 58 FC | 	wrword	#0, objptr
01570                 | '   cursor_y+=1
01570     02 66 06 F1 | 	add	objptr, #2
01574     33 97 C2 FA | 	rdbyte	local02, objptr
01578     01 96 06 F1 | 	add	local02, #1
0157c     33 97 42 FC | 	wrbyte	local02, objptr
01580                 | '   if cursor_y>st_lines-1
01580     C3 66 06 F1 | 	add	objptr, #195
01584     33 97 02 FB | 	rdlong	local02, objptr
01588     01 96 86 F1 | 	sub	local02, #1
0158c     C3 66 86 F1 | 	sub	objptr, #195
01590     33 8F C2 FA | 	rdbyte	arg03, objptr
01594     3E 66 86 F1 | 	sub	objptr, #62
01598     4B 8F 5A F2 | 	cmps	arg03, local02 wcz
0159c     2C 00 90 ED |  if_be	jmp	#LR__0082
015a0                 | '     scrollup2()
015a0     00 8A 06 F6 | 	mov	arg01, #0
015a4     01 00 00 FF 
015a8     58 8C 06 F6 | 	mov	arg02, ##600
015ac     10 8E 06 F6 | 	mov	arg03, #16
015b0     4C 00 B0 FD | 	call	#_hg010b_spin2_scrollup2
015b4                 | '     cursor_y:=st_lines-1
015b4     01 67 06 F1 | 	add	objptr, #257
015b8     33 97 02 FB | 	rdlong	local02, objptr
015bc     01 96 86 F1 | 	sub	local02, #1
015c0     C3 66 86 F1 | 	sub	objptr, #195
015c4     33 97 42 FC | 	wrbyte	local02, objptr
015c8     3E 66 86 F1 | 	sub	objptr, #62
015cc                 | LR__0082
015cc                 | LR__0083
015cc                 | ' setspritepos(17,4*cursor_x,16*cursor_y+4 )
015cc     3C 66 06 F1 | 	add	objptr, #60
015d0     33 8D E2 FA | 	rdword	arg02, objptr
015d4     02 8C 66 F0 | 	shl	arg02, #2
015d8     02 66 06 F1 | 	add	objptr, #2
015dc     33 8F C2 FA | 	rdbyte	arg03, objptr
015e0     3E 66 86 F1 | 	sub	objptr, #62
015e4     04 8E 66 F0 | 	shl	arg03, #4
015e8     04 8E 06 F1 | 	add	arg03, #4
015ec     11 8A 06 F6 | 	mov	arg01, #17
015f0     54 FA BF FD | 	call	#_hg010b_spin2_setspritepos
015f4     E7 F0 03 F6 | 	mov	ptra, fp
015f8     F2 00 A0 FD | 	call	#popregs_
015fc                 | _hg010b_spin2_putchar_ret
015fc     2D 00 64 FD | 	ret
01600                 | 
01600                 | '    
01600                 | ' ' a version for text scrolling in Basic shifted 4 lines down
01600                 | ' 
01600                 | ' pub scrollup2(start=0, end=600 , amount=16) | i
01600                 | _hg010b_spin2_scrollup2
01600     03 CA 05 F6 | 	mov	COUNT_, #3
01604     E8 00 A0 FD | 	call	#pushregs_
01608                 | ' 	
01608                 | ' repeat i from 4 to 579 
01608     04 94 06 F6 | 	mov	local01, #4
0160c                 | LR__0090
0160c     DD 66 06 F1 | 	add	objptr, #221
01610     33 8D 02 FB | 	rdlong	arg02, objptr
01614     4A 93 02 F6 | 	mov	arg05, local01
01618     10 92 06 F1 | 	add	arg05, #16
0161c     02 92 66 F0 | 	shl	arg05, #2
01620     14 66 06 F1 | 	add	objptr, #20
01624     33 8F 02 FB | 	rdlong	arg03, objptr
01628     47 93 02 FD | 	qmul	arg05, arg03
0162c                 | '   ram.read1($7E800, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
0162c     02 8E 66 F0 | 	shl	arg03, #2
01630     F4 03 00 FF 
01634     00 8A 06 F6 | 	mov	arg01, ##518144
01638     0A 00 00 FF 
0163c     DB 67 06 F1 | 	add	objptr, ##5595
01640     18 92 62 FD | 	getqx	arg05
01644     49 8D 02 F1 | 	add	arg02, arg05
01648     C4 04 B0 FD | 	call	#_psram_spin2_read1
0164c     0A 00 00 FF 
01650     EF 67 86 F1 | 	sub	objptr, ##5615
01654     33 8D 02 FB | 	rdlong	arg02, objptr
01658     4A 93 02 F6 | 	mov	arg05, local01
0165c     02 92 66 F0 | 	shl	arg05, #2
01660     14 66 06 F1 | 	add	objptr, #20
01664     33 8F 02 FB | 	rdlong	arg03, objptr
01668     47 93 02 FD | 	qmul	arg05, arg03
0166c                 | '   ram.write($7E800, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
0166c     02 8E 66 F0 | 	shl	arg03, #2
01670     F4 03 00 FF 
01674     00 8A 06 F6 | 	mov	arg01, ##518144
01678     0A 00 00 FF 
0167c     DB 67 06 F1 | 	add	objptr, ##5595
01680     18 92 62 FD | 	getqx	arg05
01684     49 8D 02 F1 | 	add	arg02, arg05
01688     20 05 B0 FD | 	call	#_psram_spin2_write
0168c     0B 00 00 FF 
01690     CC 66 86 F1 | 	sub	objptr, ##5836
01694     01 94 06 F1 | 	add	local01, #1
01698     01 00 00 FF 
0169c     44 94 16 F2 | 	cmp	local01, ##580 wc
016a0     68 FF 9F CD |  if_b	jmp	#LR__0090
016a4                 | ' 
016a4                 | ' repeat i from 580 to 599
016a4     01 00 00 FF 
016a8     44 94 06 F6 | 	mov	local01, ##580
016ac                 | LR__0091
016ac                 | '    fastline(0,1023,i,write_background)   
016ac     45 66 06 F1 | 	add	objptr, #69
016b0     33 91 02 FB | 	rdlong	arg04, objptr
016b4     45 66 86 F1 | 	sub	objptr, #69
016b8     00 8A 06 F6 | 	mov	arg01, #0
016bc     09 8C CE F9 | 	bmask	arg02, #9
016c0     4A 8F 02 F6 | 	mov	arg03, local01
016c4     34 FA BF FD | 	call	#_hg010b_spin2_fastline
016c8     01 94 06 F1 | 	add	local01, #1
016cc     01 00 00 FF 
016d0     58 94 16 F2 | 	cmp	local01, ##600 wc
016d4     D4 FF 9F CD |  if_b	jmp	#LR__0091
016d8                 | ' repeat i from 0 to 3
016d8     00 94 06 F6 | 	mov	local01, #0
016dc                 | LR__0092
016dc                 | '    fastline(0,1023,i,write_background)      
016dc     45 66 06 F1 | 	add	objptr, #69
016e0     33 91 02 FB | 	rdlong	arg04, objptr
016e4     45 66 86 F1 | 	sub	objptr, #69
016e8     00 8A 06 F6 | 	mov	arg01, #0
016ec     09 8C CE F9 | 	bmask	arg02, #9
016f0     4A 8F 02 F6 | 	mov	arg03, local01
016f4     04 FA BF FD | 	call	#_hg010b_spin2_fastline
016f8     01 94 06 F1 | 	add	local01, #1
016fc     04 94 56 F2 | 	cmps	local01, #4 wc
01700     D8 FF 9F CD |  if_b	jmp	#LR__0092
01704                 | ' 
01704                 | ' repeat i from 0 to 35
01704     00 94 06 F6 | 	mov	local01, #0
01708                 | LR__0093
01708     4A 93 02 F6 | 	mov	arg05, local01
0170c     01 92 06 F1 | 	add	arg05, #1
01710     1C 00 00 FF 
01714     5C 6A 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01718     35 8F 02 FB | 	rdlong	arg03, ptr__hg010b_spin2_dat__
0171c     47 93 02 FD | 	qmul	arg05, arg03
01720                 | '   ram.read1($7E800, textbuf_ptr+(i+1)*timings[7], timings[7])
01720     04 66 06 F1 | 	add	objptr, #4
01724     33 8D 02 FB | 	rdlong	arg02, objptr
01728     1C 00 00 FF 
0172c     5C 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01730     F4 03 00 FF 
01734     00 8A 06 F6 | 	mov	arg01, ##518144
01738     0B 00 00 FF 
0173c     C8 66 06 F1 | 	add	objptr, ##5832
01740     18 92 62 FD | 	getqx	arg05
01744     49 8D 02 F1 | 	add	arg02, arg05
01748     C4 03 B0 FD | 	call	#_psram_spin2_read1
0174c     1C 00 00 FF 
01750     5C 6A 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01754     35 8F 02 FB | 	rdlong	arg03, ptr__hg010b_spin2_dat__
01758     47 95 02 FD | 	qmul	local01, arg03
0175c                 | '   ram.write($7E800, textbuf_ptr+i*timings[7], timings[7])
0175c     0B 00 00 FF 
01760     C8 66 86 F1 | 	sub	objptr, ##5832
01764     33 8D 02 FB | 	rdlong	arg02, objptr
01768     1C 00 00 FF 
0176c     5C 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01770     F4 03 00 FF 
01774     00 8A 06 F6 | 	mov	arg01, ##518144
01778     0B 00 00 FF 
0177c     C8 66 06 F1 | 	add	objptr, ##5832
01780     18 92 62 FD | 	getqx	arg05
01784     49 8D 02 F1 | 	add	arg02, arg05
01788     20 04 B0 FD | 	call	#_psram_spin2_write
0178c     0B 00 00 FF 
01790     CC 66 86 F1 | 	sub	objptr, ##5836
01794     01 94 06 F1 | 	add	local01, #1
01798     24 94 56 F2 | 	cmps	local01, #36 wc
0179c     68 FF 9F CD |  if_b	jmp	#LR__0093
017a0                 | ' repeat i from 0 to timings[7]-1
017a0     00 94 06 F6 | 	mov	local01, #0
017a4     1C 00 00 FF 
017a8     5C 6A 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
017ac     35 97 02 FB | 	rdlong	local02, ptr__hg010b_spin2_dat__
017b0     1C 00 00 FF 
017b4     5C 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
017b8     01 96 86 F1 | 	sub	local02, #1
017bc     00 96 56 F2 | 	cmps	local02, #0 wc
017c0     01 98 86 F6 | 	negc	local03, #1
017c4     4C 97 02 F1 | 	add	local02, local03
017c8                 | LR__0094
017c8                 | '   ram.fill(textbuf_ptr+(36*timings[7]+i),32,1,0,1) 
017c8     04 66 06 F1 | 	add	objptr, #4
017cc     33 8B 02 FB | 	rdlong	arg01, objptr
017d0     1C 00 00 FF 
017d4     5C 6A 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
017d8     35 93 02 FB | 	rdlong	arg05, ptr__hg010b_spin2_dat__
017dc     1C 00 00 FF 
017e0     5C 6A 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
017e4     49 91 02 F6 | 	mov	arg04, arg05
017e8     03 90 66 F0 | 	shl	arg04, #3
017ec     49 91 02 F1 | 	add	arg04, arg05
017f0     02 90 66 F0 | 	shl	arg04, #2
017f4     4A 91 02 F1 | 	add	arg04, local01
017f8     48 8B 02 F1 | 	add	arg01, arg04
017fc     20 8C 06 F6 | 	mov	arg02, #32
01800     01 8E 06 F6 | 	mov	arg03, #1
01804     00 90 06 F6 | 	mov	arg04, #0
01808     01 92 06 F6 | 	mov	arg05, #1
0180c     0B 00 00 FF 
01810     C8 66 06 F1 | 	add	objptr, ##5832
01814     30 04 B0 FD | 	call	#_psram_spin2_fill
01818     0B 00 00 FF 
0181c     CC 66 86 F1 | 	sub	objptr, ##5836
01820     4C 95 02 F1 | 	add	local01, local03
01824     4B 95 0A F2 | 	cmp	local01, local02 wz
01828     9C FF 9F 5D |  if_ne	jmp	#LR__0094
0182c     E7 F0 03 F6 | 	mov	ptra, fp
01830     F2 00 A0 FD | 	call	#popregs_
01834                 | _hg010b_spin2_scrollup2_ret
01834     2D 00 64 FD | 	ret
01838                 | 
01838                 | ' 
01838                 | ' ''----------- Set cursor at the first character in a new line, scroll if needed 
01838                 | ' 
01838                 | ' pub crlf()
01838                 | _hg010b_spin2_crlf
01838                 | ' 
01838                 | ' cursor_x:=leading_spaces*2
01838     01 00 00 FF 
0183c     B6 66 06 F1 | 	add	objptr, ##694
01840     33 8F 02 FB | 	rdlong	arg03, objptr
01844     01 8E 66 F0 | 	shl	arg03, #1
01848     01 00 00 FF 
0184c     7A 66 86 F1 | 	sub	objptr, ##634
01850     33 8F 52 FC | 	wrword	arg03, objptr
01854                 | ' cursor_y+=1
01854     02 66 06 F1 | 	add	objptr, #2
01858     33 8F C2 FA | 	rdbyte	arg03, objptr
0185c     01 8E 06 F1 | 	add	arg03, #1
01860     33 8F 42 FC | 	wrbyte	arg03, objptr
01864                 | ' if cursor_y>st_lines-1
01864     C3 66 06 F1 | 	add	objptr, #195
01868     33 8F 02 FB | 	rdlong	arg03, objptr
0186c     01 8E 86 F1 | 	sub	arg03, #1
01870     C3 66 86 F1 | 	sub	objptr, #195
01874     33 8D C2 FA | 	rdbyte	arg02, objptr
01878     3E 66 86 F1 | 	sub	objptr, #62
0187c     47 8D 5A F2 | 	cmps	arg02, arg03 wcz
01880     2C 00 90 ED |  if_be	jmp	#LR__0100
01884                 | '   scrollup2()
01884     00 8A 06 F6 | 	mov	arg01, #0
01888     01 00 00 FF 
0188c     58 8C 06 F6 | 	mov	arg02, ##600
01890     10 8E 06 F6 | 	mov	arg03, #16
01894     68 FD BF FD | 	call	#_hg010b_spin2_scrollup2
01898                 | '   cursor_y:=st_lines-1
01898     01 67 06 F1 | 	add	objptr, #257
0189c     33 8F 02 FB | 	rdlong	arg03, objptr
018a0     01 8E 86 F1 | 	sub	arg03, #1
018a4     C3 66 86 F1 | 	sub	objptr, #195
018a8     33 8F 42 FC | 	wrbyte	arg03, objptr
018ac     3E 66 86 F1 | 	sub	objptr, #62
018b0                 | LR__0100
018b0                 | ' setspritepos(17,4*cursor_x,16*cursor_y+4 )  
018b0     3C 66 06 F1 | 	add	objptr, #60
018b4     33 8D E2 FA | 	rdword	arg02, objptr
018b8     02 8C 66 F0 | 	shl	arg02, #2
018bc     02 66 06 F1 | 	add	objptr, #2
018c0     33 8F C2 FA | 	rdbyte	arg03, objptr
018c4     3E 66 86 F1 | 	sub	objptr, #62
018c8     04 8E 66 F0 | 	shl	arg03, #4
018cc     04 8E 06 F1 | 	add	arg03, #4
018d0     11 8A 06 F6 | 	mov	arg01, #17
018d4     70 F7 BF FD | 	call	#_hg010b_spin2_setspritepos
018d8                 | _hg010b_spin2_crlf_ret
018d8     2D 00 64 FD | 	ret
018dc                 | 
018dc                 | ' 
018dc                 | ' '..............................................................................
018dc                 | ' 
018dc                 | ' {{
018dc                 | ' }}
018dc                 | ' PUB startx(freq, burst, delay, desiredcog) : result | driverAddr
018dc                 | _psram_spin2_startx
018dc     04 CA 05 F6 | 	mov	COUNT_, #4
018e0     E8 00 A0 FD | 	call	#pushregs_
018e4     45 95 02 F6 | 	mov	local01, arg01
018e8     47 97 02 F6 | 	mov	local02, arg03
018ec     48 99 02 F6 | 	mov	local03, arg04
018f0                 | '     stop() ' restart driver if required
018f0     5C 01 B0 FD | 	call	#_psram_spin2_stop
018f4     00 94 0E F2 | 	cmp	local01, #0 wz
018f8     14 94 06 AB |  if_e	rdlong	local01, #20
018fc     4A 8D 52 F6 | 	abs	arg02, local01 wc
01900     A1 07 00 FF 
01904     40 8C 16 FD | 	qdiv	arg02, ##1000000
01908                 | ' 
01908                 | '     ' use current frequency if none specified
01908                 | ' 
01908                 | '     if freq == 0 
01908                 | '         freq := clkfreq 
01908                 | ' 
01908                 | '     ' compute the device burst size including overheads to keep CS low time below 8us
01908                 | ' 
01908                 | '     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
01908                 | '     if burst < 0
01908                 | '         return ERR_TOO_SLOW ' P2 frequency is too low for any 8us transfers
01908     18 8C 62 FD | 	getqx	arg02
0190c     46 91 82 F6 | 	negc	arg04, arg02
01910     03 90 66 F0 | 	shl	arg04, #3
01914     84 90 86 F1 | 	sub	arg04, #132
01918     04 90 46 F0 | 	shr	arg04, #4
0191c     04 90 66 F0 | 	shl	arg04, #4
01920     00 90 56 F2 | 	cmps	arg04, #0 wc
01924     0E 74 66 C6 |  if_b	neg	result1, #14
01928     18 01 90 CD |  if_b	jmp	#LR__0114
0192c                 | ' 
0192c                 | '     ' compute the input delay
0192c                 | ' 
0192c                 | '     if delay <= 0
0192c     01 96 56 F2 | 	cmps	local02, #1 wc
01930     10 00 90 3D |  if_ae	jmp	#LR__0110
01934                 | '         delay := lookupDelay(freq)
01934     4A 8B 02 F6 | 	mov	arg01, local01
01938     C0 04 B0 FD | 	call	#_psram_spin2_lookupDelay
0193c     3A 97 02 F6 | 	mov	local02, result1
01940     04 00 90 FD | 	jmp	#LR__0111
01944                 | LR__0110
01944                 | '     else
01944                 | '         delay <#= $f ' limit to 15
01944     0F 96 66 F3 | 	fles	local02, #15
01948                 | LR__0111
01948                 | ' 
01948                 | '     ' create our lock
01948                 | ' 
01948                 | '     driverlock := LOCKNEW()  
01948     00 74 06 F6 | 	mov	result1, #0
0194c     04 74 62 FD | 	locknew	result1
01950     04 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #260
01954     37 75 62 FC | 	wrlong	result1, ptr__psram_spin2_dat__
01958                 | '     if driverlock == -1
01958     04 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
0195c     FF FF 7F FF 
01960     FF 75 0E F2 | 	cmp	result1, ##-1 wz
01964                 | '         return ERR_NO_LOCK
01964     1A 74 66 A6 |  if_e	neg	result1, #26
01968     D8 00 90 AD |  if_e	jmp	#LR__0114
0196c                 | ' 
0196c                 | '     ' patch in the proper data and HUB addresses to the startup structure
0196c                 | ' 
0196c                 | '     long[@startupData][0]:=clkfreq
0196c     14 94 06 FB | 	rdlong	local01, #20
01970     28 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #296
01974     37 95 62 FC | 	wrlong	local01, ptr__psram_spin2_dat__
01978                 | ' '    long[@startupData][1]:=$1000_0000
01978                 | '     long[@startupData][5]:=@deviceData
01978     37 95 02 F6 | 	mov	local01, ptr__psram_spin2_dat__
0197c     20 94 06 F1 | 	add	local01, #32
01980     37 8D 02 F6 | 	mov	arg02, ptr__psram_spin2_dat__
01984     14 8C 06 F1 | 	add	arg02, #20
01988     46 95 62 FC | 	wrlong	local01, arg02
0198c                 | '     long[@startupData][6]:=@qosData
0198c     37 95 02 F6 | 	mov	local01, ptr__psram_spin2_dat__
01990     A0 94 06 F1 | 	add	local01, #160
01994     37 8D 02 F6 | 	mov	arg02, ptr__psram_spin2_dat__
01998     18 8C 06 F1 | 	add	arg02, #24
0199c     46 95 62 FC | 	wrlong	local01, arg02
019a0                 | '     long[@startupData][7]:=$7FF00
019a0     37 95 02 F6 | 	mov	local01, ptr__psram_spin2_dat__
019a4     1C 94 06 F1 | 	add	local01, #28
019a8     FF 03 80 FF 
019ac     4A 01 6A FC | 	wrlong	##524032, local01
019b0                 | ' 
019b0                 | '     ' setup some default bank and QoS parameter values
019b0                 | ' 
019b0                 | '     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
019b0     20 6E 06 F1 | 	add	ptr__psram_spin2_dat__, #32
019b4     37 8B 02 F6 | 	mov	arg01, ptr__psram_spin2_dat__
019b8     48 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #328
019bc     10 90 66 F0 | 	shl	arg04, #16
019c0     0C 96 66 F0 | 	shl	local02, #12
019c4     4B 91 42 F5 | 	or	arg04, local02
019c8     18 90 46 F5 | 	or	arg04, #24
019cc     48 8D 02 F6 | 	mov	arg02, arg04
019d0     02 8E 06 F6 | 	mov	arg03, #2
019d4     E0 00 A0 FD | 	call	#\builtin_longfill_
019d8                 | '     longfill(@qosData, $FFFF0000, 8)
019d8     37 8B 02 F6 | 	mov	arg01, ptr__psram_spin2_dat__
019dc     C8 8B 06 F1 | 	add	arg01, #456
019e0     07 8E 06 F6 | 	mov	arg03, #7
019e4     28 8E 62 FD | 	setq	arg03
019e8     80 FF FF FF 
019ec     45 01 68 FC | 	wrlong	##-65536, arg01
019f0                 | ' 
019f0                 | '     ' get the address of the PSRAM memory driver so we can start it
019f0                 | ' 
019f0                 | '     driverAddr:= driver.getDriverAddr()
019f0                 | '     return @driver_start
019f0     36 8D 02 F6 | 	mov	arg02, ptr__psram16drv_spin2_dat__
019f4     20 8C 06 F1 | 	add	arg02, #32
019f8                 | ' 
019f8                 | '     ' start the PSRAM memory driver and wait for it to complete initialization
019f8                 | ' 
019f8                 | '     if desiredcog < 0
019f8     00 98 56 F2 | 	cmps	local03, #0 wc
019fc                 | '         desiredcog := NEWCOG
019fc     10 98 06 C6 |  if_b	mov	local03, #16
01a00                 | '     drivercog := coginit(desiredcog, driverAddr, @startupData)
01a00     37 8F 02 F6 | 	mov	arg03, ptr__psram_spin2_dat__
01a04     28 8F 06 F1 | 	add	arg03, #296
01a08     4C 9B 02 F6 | 	mov	local04, local03
01a0c     28 8E 62 FD | 	setq	arg03
01a10     46 9B F2 FC | 	coginit	local04, arg02 wc
01a14     01 9A 66 C6 |  if_b	neg	local04, #1
01a18     00 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01a1c     37 9B 62 FC | 	wrlong	local04, ptr__psram_spin2_dat__
01a20     00 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01a24     D7 08 48 FB | 	callpa	#(@LR__0113-@LR__0112)>>2,fcache_load_ptr_
01a28                 | '     repeat until long[@startupData] == 0 
01a28                 | LR__0112
01a28     37 9B 02 F6 | 	mov	local04, ptr__psram_spin2_dat__
01a2c     28 9B 06 F1 | 	add	local04, #296
01a30     4D 9B 0A FB | 	rdlong	local04, local04 wz
01a34     F0 FF 9F 5D |  if_ne	jmp	#LR__0112
01a38                 | LR__0113
01a38                 | ' 
01a38                 | '     return drivercog
01a38     00 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01a3c     37 75 02 FB | 	rdlong	result1, ptr__psram_spin2_dat__
01a40     00 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01a44                 | LR__0114
01a44     E7 F0 03 F6 | 	mov	ptra, fp
01a48     F2 00 A0 FD | 	call	#popregs_
01a4c                 | _psram_spin2_startx_ret
01a4c     2D 00 64 FD | 	ret
01a50                 | 
01a50                 | ' 
01a50                 | ' '..............................................................................
01a50                 | ' 
01a50                 | ' {{
01a50                 | ' }}
01a50                 | ' PUB stop() : i
01a50                 | _psram_spin2_stop
01a50     00 7A 06 F6 | 	mov	_var01, #0
01a54                 | '     if drivercog <> -1
01a54     00 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01a58     37 8B 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
01a5c     00 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01a60     FF FF 7F FF 
01a64     FF 8B 0E F2 | 	cmp	arg01, ##-1 wz
01a68     70 00 90 AD |  if_e	jmp	#LR__0123
01a6c                 | '         cogstop(drivercog) ' a rather brutal stop
01a6c     00 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01a70     37 8B 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
01a74     00 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01a78     03 8A 62 FD | 	cogstop	arg01
01a7c     D7 26 48 FB | 	callpa	#(@LR__0122-@LR__0120)>>2,fcache_load_ptr_
01a80                 | '         repeat i from 0 to 7
01a80                 | LR__0120
01a80                 | '             if long[$7FF00][i*3] < 0
01a80     3D 75 02 F6 | 	mov	result1, _var01
01a84     01 74 66 F0 | 	shl	result1, #1
01a88     3D 75 02 F1 | 	add	result1, _var01
01a8c     02 74 66 F0 | 	shl	result1, #2
01a90     FF 03 00 FF 
01a94     00 75 06 F1 | 	add	result1, ##524032
01a98     3A 75 02 FB | 	rdlong	result1, result1
01a9c     00 74 56 F2 | 	cmps	result1, #0 wc
01aa0     1C 00 90 3D |  if_ae	jmp	#LR__0121
01aa4                 | '                 long[$7FF00][i*3] := -ERR_ABORTED ' abort request
01aa4     3D 75 02 F6 | 	mov	result1, _var01
01aa8     01 74 66 F0 | 	shl	result1, #1
01aac     3D 75 02 F1 | 	add	result1, _var01
01ab0     02 74 66 F0 | 	shl	result1, #2
01ab4     FF 03 00 FF 
01ab8     00 75 06 F1 | 	add	result1, ##524032
01abc     3A 21 68 FC | 	wrlong	#16, result1
01ac0                 | LR__0121
01ac0     01 7A 06 F1 | 	add	_var01, #1
01ac4     08 7A 56 F2 | 	cmps	_var01, #8 wc
01ac8     B4 FF 9F CD |  if_b	jmp	#LR__0120
01acc                 | LR__0122
01acc                 | '         drivercog := -1
01acc     00 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01ad0     FF FF FF FF 
01ad4     37 FF 6B FC | 	wrlong	##-1, ptr__psram_spin2_dat__
01ad8     00 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01adc                 | LR__0123
01adc                 | '     if driverlock <> -1
01adc     04 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #260
01ae0     37 7D 02 FB | 	rdlong	_var02, ptr__psram_spin2_dat__
01ae4     04 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
01ae8     FF FF 7F FF 
01aec     FF 7D 0E F2 | 	cmp	_var02, ##-1 wz
01af0                 | '         LOCKRET(driverlock)
01af0     04 6F 06 51 |  if_ne	add	ptr__psram_spin2_dat__, #260
01af4     37 8B 02 5B |  if_ne	rdlong	arg01, ptr__psram_spin2_dat__
01af8     05 8A 62 5D |  if_ne	lockret	arg01
01afc                 | '         driverlock := -1
01afc     FF FF FF 5F 
01b00     37 FF 6B 5C |  if_ne	wrlong	##-1, ptr__psram_spin2_dat__
01b04     04 6F 86 51 |  if_ne	sub	ptr__psram_spin2_dat__, #260
01b08     3D 75 02 F6 | 	mov	result1, _var01
01b0c                 | _psram_spin2_stop_ret
01b0c     2D 00 64 FD | 	ret
01b10                 | 
01b10                 | ' 
01b10                 | ' '..............................................................................
01b10                 | ' 
01b10                 | ' {{
01b10                 | ' }}
01b10                 | ' PUB read1(dstHubAddr, srcAddr, count) : result | mailbox
01b10                 | _psram_spin2_read1
01b10                 | ' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
01b10                 | '     if drivercog == -1 ' driver must be running
01b10     00 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01b14     37 7B 02 FB | 	rdlong	_var01, ptr__psram_spin2_dat__
01b18     00 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01b1c     FF FF 7F FF 
01b20     FF 7B 0E F2 | 	cmp	_var01, ##-1 wz
01b24                 | '         return ERR_INACTIVE
01b24     0F 74 66 A6 |  if_e	neg	result1, #15
01b28     7C 00 90 AD |  if_e	jmp	#LR__0131
01b2c                 | '     if count == 0 ' don't even bother reading
01b2c     00 8E 0E F2 | 	cmp	arg03, #0 wz
01b30                 | '         return 0
01b30     00 74 06 A6 |  if_e	mov	result1, #0
01b34     70 00 90 AD |  if_e	jmp	#LR__0131
01b38                 | '     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
01b38     00 74 06 F6 | 	mov	result1, #0
01b3c     01 74 62 FD | 	cogid	result1
01b40     3A 7B 02 F6 | 	mov	_var01, result1
01b44     01 7A 66 F0 | 	shl	_var01, #1
01b48     3A 7B 02 F1 | 	add	_var01, result1
01b4c     02 7A 66 F0 | 	shl	_var01, #2
01b50     FF 03 00 FF 
01b54     00 7D 06 F6 | 	mov	_var02, ##524032
01b58     3D 7D 02 F1 | 	add	_var02, _var01
01b5c                 | '     if long[mailbox] < 0
01b5c     3E 7B 02 FB | 	rdlong	_var01, _var02
01b60     00 7A 56 F2 | 	cmps	_var01, #0 wc
01b64                 | '         return ERR_MAILBOX_BUSY
01b64     1C 74 66 C6 |  if_b	neg	result1, #28
01b68     3C 00 90 CD |  if_b	jmp	#LR__0131
01b6c                 | '     long[mailbox][2] := count
01b6c     08 7C 06 F1 | 	add	_var02, #8
01b70     3E 8F 62 FC | 	wrlong	arg03, _var02
01b74                 | '     long[mailbox][1] := dstHubAddr
01b74     04 7C 86 F1 | 	sub	_var02, #4
01b78     3E 8B 62 FC | 	wrlong	arg01, _var02
01b7c     04 7C 86 F1 | 	sub	_var02, #4
01b80                 | '     long[mailbox] := driver.R_READBURST + (srcAddr & $1ffffff) ' trigger burst read operation
01b80     46 7F 02 F6 | 	mov	_var03, arg02
01b84     D9 7E 06 F4 | 	bitl	_var03, #217
01b88     00 00 58 FF 
01b8c     00 7A 06 F6 | 	mov	_var01, ##-1342177280
01b90     3F 7B 02 F1 | 	add	_var01, _var03
01b94     3E 7B 62 FC | 	wrlong	_var01, _var02
01b98                 | '     repeat
01b98                 | LR__0130
01b98                 | '         result := long[mailbox]    
01b98     3E 7F 02 FB | 	rdlong	_var03, _var02
01b9c     00 7E 56 F2 | 	cmps	_var03, #0 wc
01ba0     F4 FF 9F CD |  if_b	jmp	#LR__0130
01ba4                 | '     while result < 0   
01ba4                 | '     return -result                       'return success or error
01ba4     3F 75 62 F6 | 	neg	result1, _var03
01ba8                 | LR__0131
01ba8                 | _psram_spin2_read1_ret
01ba8     2D 00 64 FD | 	ret
01bac                 | 
01bac                 | ' 
01bac                 | ' '..............................................................................
01bac                 | ' 
01bac                 | ' {{
01bac                 | ' }}
01bac                 | ' PUB write(srcHubAddr, dstAddr, count) : result | mailbox
01bac                 | _psram_spin2_write
01bac                 | ' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
01bac                 | '     if drivercog == -1 ' driver must be running
01bac     00 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01bb0     37 7B 02 FB | 	rdlong	_var01, ptr__psram_spin2_dat__
01bb4     00 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01bb8     FF FF 7F FF 
01bbc     FF 7B 0E F2 | 	cmp	_var01, ##-1 wz
01bc0                 | '         return ERR_INACTIVE
01bc0     0F 74 66 A6 |  if_e	neg	result1, #15
01bc4     7C 00 90 AD |  if_e	jmp	#LR__0141
01bc8                 | '     if count == 0 ' don't even bother writing
01bc8     00 8E 0E F2 | 	cmp	arg03, #0 wz
01bcc                 | '         return 0
01bcc     00 74 06 A6 |  if_e	mov	result1, #0
01bd0     70 00 90 AD |  if_e	jmp	#LR__0141
01bd4                 | '     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
01bd4     00 74 06 F6 | 	mov	result1, #0
01bd8     01 74 62 FD | 	cogid	result1
01bdc     3A 7B 02 F6 | 	mov	_var01, result1
01be0     01 7A 66 F0 | 	shl	_var01, #1
01be4     3A 7B 02 F1 | 	add	_var01, result1
01be8     02 7A 66 F0 | 	shl	_var01, #2
01bec     FF 03 00 FF 
01bf0     00 7D 06 F6 | 	mov	_var02, ##524032
01bf4     3D 7D 02 F1 | 	add	_var02, _var01
01bf8                 | '     if long[mailbox] < 0
01bf8     3E 7B 02 FB | 	rdlong	_var01, _var02
01bfc     00 7A 56 F2 | 	cmps	_var01, #0 wc
01c00                 | '         return ERR_MAILBOX_BUSY
01c00     1C 74 66 C6 |  if_b	neg	result1, #28
01c04     3C 00 90 CD |  if_b	jmp	#LR__0141
01c08                 | '     long[mailbox][2] := count
01c08     08 7C 06 F1 | 	add	_var02, #8
01c0c     3E 8F 62 FC | 	wrlong	arg03, _var02
01c10                 | '     long[mailbox][1] := srcHubAddr
01c10     04 7C 86 F1 | 	sub	_var02, #4
01c14     3E 8B 62 FC | 	wrlong	arg01, _var02
01c18     04 7C 86 F1 | 	sub	_var02, #4
01c1c                 | '     long[mailbox] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
01c1c     46 7F 02 F6 | 	mov	_var03, arg02
01c20     D9 7E 06 F4 | 	bitl	_var03, #217
01c24     00 00 78 FF 
01c28     00 7A 06 F6 | 	mov	_var01, ##-268435456
01c2c     3F 7B 02 F1 | 	add	_var01, _var03
01c30     3E 7B 62 FC | 	wrlong	_var01, _var02
01c34                 | '     repeat
01c34                 | LR__0140
01c34                 | '         result := long[mailbox]    
01c34     3E 7F 02 FB | 	rdlong	_var03, _var02
01c38     00 7E 56 F2 | 	cmps	_var03, #0 wc
01c3c     F4 FF 9F CD |  if_b	jmp	#LR__0140
01c40                 | '     while result < 0   
01c40                 | '     return -result                       'return success or error
01c40     3F 75 62 F6 | 	neg	result1, _var03
01c44                 | LR__0141
01c44                 | _psram_spin2_write_ret
01c44     2D 00 64 FD | 	ret
01c48                 | 
01c48                 | ' 
01c48                 | ' ' generalized fill
01c48                 | ' PUB fill(addr, pattern, count, listPtr, datasize) : r | mailbox, req
01c48                 | _psram_spin2_fill
01c48     45 7B 02 F6 | 	mov	_var01, arg01
01c4c     46 7D 02 F6 | 	mov	_var02, arg02
01c50     47 7F 02 F6 | 	mov	_var03, arg03
01c54     49 81 02 F6 | 	mov	_var04, arg05
01c58                 | '     case datasize 
01c58     01 80 86 F1 | 	sub	_var04, #1
01c5c     04 80 26 F3 | 	fle	_var04, #4
01c60     30 80 62 FD | 	jmprel	_var04
01c64                 | LR__0150
01c64     10 00 90 FD | 	jmp	#LR__0151
01c68     18 00 90 FD | 	jmp	#LR__0152
01c6c     2C 00 90 FD | 	jmp	#LR__0154
01c70     1C 00 90 FD | 	jmp	#LR__0153
01c74     24 00 90 FD | 	jmp	#LR__0154
01c78                 | LR__0151
01c78                 | '         1: req := driver.R_WRITEBYTE
01c78     00 00 60 FF 
01c7c     00 82 06 F6 | 	mov	_var05, ##-1073741824
01c80     20 00 90 FD | 	jmp	#LR__0155
01c84                 | LR__0152
01c84                 | '         2: req := driver.R_WRITEWORD
01c84     00 00 68 FF 
01c88     00 82 06 F6 | 	mov	_var05, ##-805306368
01c8c     14 00 90 FD | 	jmp	#LR__0155
01c90                 | LR__0153
01c90                 | '         4: req := driver.R_WRITELONG
01c90     00 00 70 FF 
01c94     00 82 06 F6 | 	mov	_var05, ##-536870912
01c98     08 00 90 FD | 	jmp	#LR__0155
01c9c                 | LR__0154
01c9c                 | '         other : return ERR_INVALID
01c9c     06 74 66 F6 | 	neg	result1, #6
01ca0     94 00 90 FD | 	jmp	#LR__0157
01ca4                 | LR__0155
01ca4                 | '     if count == 0   ' nothing to do
01ca4     00 7E 0E F2 | 	cmp	_var03, #0 wz
01ca8                 | '         return 0
01ca8     00 74 06 A6 |  if_e	mov	result1, #0
01cac     88 00 90 AD |  if_e	jmp	#LR__0157
01cb0                 | '     if drivercog == -1
01cb0     00 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01cb4     37 81 02 FB | 	rdlong	_var04, ptr__psram_spin2_dat__
01cb8     00 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01cbc     FF FF 7F FF 
01cc0     FF 81 0E F2 | 	cmp	_var04, ##-1 wz
01cc4                 | '         return ERR_INACTIVE
01cc4     0F 74 66 A6 |  if_e	neg	result1, #15
01cc8     6C 00 90 AD |  if_e	jmp	#LR__0157
01ccc                 | '     mailbox := $7FF00 + 12*cogid() ' get mailbox base address for this COG
01ccc     00 74 06 F6 | 	mov	result1, #0
01cd0     01 74 62 FD | 	cogid	result1
01cd4     3A 81 02 F6 | 	mov	_var04, result1
01cd8     01 80 66 F0 | 	shl	_var04, #1
01cdc     3A 81 02 F1 | 	add	_var04, result1
01ce0     02 80 66 F0 | 	shl	_var04, #2
01ce4     FF 03 00 FF 
01ce8     00 85 06 F6 | 	mov	_var06, ##524032
01cec     40 85 02 F1 | 	add	_var06, _var04
01cf0                 | '     if long[mailbox] < 0
01cf0     42 81 02 FB | 	rdlong	_var04, _var06
01cf4     00 80 56 F2 | 	cmps	_var04, #0 wc
01cf8                 | '         return ERR_MAILBOX_BUSY
01cf8     1C 74 66 C6 |  if_b	neg	result1, #28
01cfc     38 00 90 CD |  if_b	jmp	#LR__0157
01d00                 | '     long[mailbox][2] := count
01d00     08 84 06 F1 | 	add	_var06, #8
01d04     42 7F 62 FC | 	wrlong	_var03, _var06
01d08                 | '     long[mailbox][1] := pattern
01d08     04 84 86 F1 | 	sub	_var06, #4
01d0c     42 7D 62 FC | 	wrlong	_var02, _var06
01d10     04 84 86 F1 | 	sub	_var06, #4
01d14                 | '     long[mailbox] := req + (addr & $1ffffff)
01d14     41 87 02 F6 | 	mov	_var07, _var05
01d18     3D 89 02 F6 | 	mov	_var08, _var01
01d1c     D9 88 06 F4 | 	bitl	_var08, #217
01d20     44 87 02 F1 | 	add	_var07, _var08
01d24     42 87 62 FC | 	wrlong	_var07, _var06
01d28                 | '     repeat
01d28                 | LR__0156
01d28                 | '         r := long[mailbox]
01d28     42 89 02 FB | 	rdlong	_var08, _var06
01d2c     00 88 56 F2 | 	cmps	_var08, #0 wc
01d30     F4 FF 9F CD |  if_b	jmp	#LR__0156
01d34                 | '     while r < 0
01d34                 | '     return -r                  ' return 0 for success or negated error code
01d34     44 75 62 F6 | 	neg	result1, _var08
01d38                 | LR__0157
01d38                 | _psram_spin2_fill_ret
01d38     2D 00 64 FD | 	ret
01d3c                 | 
01d3c                 | ' 
01d3c                 | ' '..............................................................................
01d3c                 | ' 
01d3c                 | ' {{
01d3c                 | ' }}
01d3c                 | ' PUB setQos(cog, qos) : result | mailbox
01d3c                 | _psram_spin2_setQos
01d3c     45 7B 02 F6 | 	mov	_var01, arg01
01d40                 | '     if drivercog == -1 ' driver must be running
01d40     00 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #256
01d44     37 7D 02 FB | 	rdlong	_var02, ptr__psram_spin2_dat__
01d48     00 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
01d4c     FF FF 7F FF 
01d50     FF 7D 0E F2 | 	cmp	_var02, ##-1 wz
01d54                 | '         return ERR_INACTIVE
01d54     0F 74 66 A6 |  if_e	neg	result1, #15
01d58     9C 00 90 AD |  if_e	jmp	#LR__0164
01d5c                 | '     if cog < 0 or cog > 7 ' enforce cog id range
01d5c     00 7A 56 F2 | 	cmps	_var01, #0 wc
01d60     08 00 90 CD |  if_b	jmp	#LR__0160
01d64     08 7A 56 F2 | 	cmps	_var01, #8 wc
01d68     08 00 90 CD |  if_b	jmp	#LR__0161
01d6c                 | LR__0160
01d6c                 | '         return ERR_INVALID
01d6c     06 74 66 F6 | 	neg	result1, #6
01d70     84 00 90 FD | 	jmp	#LR__0164
01d74                 | LR__0161
01d74                 | '     long[@qosData][cog] := qos & !$1ff
01d74     FF 8D 26 F5 | 	andn	arg02, #511
01d78     C8 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #456
01d7c     02 7A 66 F0 | 	shl	_var01, #2
01d80     37 7B 02 F1 | 	add	_var01, ptr__psram_spin2_dat__
01d84     3D 8D 62 FC | 	wrlong	arg02, _var01
01d88                 | '     mailbox := $7FF00 + drivercog*12
01d88     C8 6E 86 F1 | 	sub	ptr__psram_spin2_dat__, #200
01d8c     37 7F 02 FB | 	rdlong	_var03, ptr__psram_spin2_dat__
01d90     3F 81 02 F6 | 	mov	_var04, _var03
01d94     01 80 66 F0 | 	shl	_var04, #1
01d98     3F 81 02 F1 | 	add	_var04, _var03
01d9c     02 80 66 F0 | 	shl	_var04, #2
01da0     FF 03 00 FF 
01da4     00 83 06 F6 | 	mov	_var05, ##524032
01da8     40 83 02 F1 | 	add	_var05, _var04
01dac                 | '     repeat until LOCKTRY(driverlock)
01dac     04 6E 06 F1 | 	add	ptr__psram_spin2_dat__, #4
01db0                 | LR__0162
01db0     37 8B 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
01db4     06 8A 72 FD | 	locktry	arg01 wc
01db8     F4 FF 9F 3D |  if_ae	jmp	#LR__0162
01dbc     04 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
01dc0                 | '     long[mailbox] := driver.R_CONFIG + cogid()
01dc0     00 80 06 F6 | 	mov	_var04, #0
01dc4     01 80 62 FD | 	cogid	_var04
01dc8     00 00 78 FF 
01dcc     00 7C 06 F6 | 	mov	_var02, ##-268435456
01dd0     40 7D 02 F1 | 	add	_var02, _var04
01dd4     41 7D 62 FC | 	wrlong	_var02, _var05
01dd8                 | '     repeat while long[mailbox] < 0
01dd8                 | LR__0163
01dd8     41 7D 02 FB | 	rdlong	_var02, _var05
01ddc     00 7C 56 F2 | 	cmps	_var02, #0 wc
01de0     F4 FF 9F CD |  if_b	jmp	#LR__0163
01de4                 | '     LOCKREL(driverlock)
01de4     04 6F 06 F1 | 	add	ptr__psram_spin2_dat__, #260
01de8     37 8B 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
01dec     04 6F 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
01df0     07 8A 72 FD | 	lockrel	arg01 wc
01df4     00 74 06 F6 | 	mov	result1, #0
01df8                 | LR__0164
01df8                 | _psram_spin2_setQos_ret
01df8     2D 00 64 FD | 	ret
01dfc                 | 
01dfc                 | ' 
01dfc                 | ' '..............................................................................
01dfc                 | ' 
01dfc                 | ' {{
01dfc                 | ' }}
01dfc                 | ' PRI lookupDelay(freq) : delay | profile
01dfc                 | _psram_spin2_lookupDelay
01dfc                 | '     profile := @delayTable
01dfc     37 7B 02 F6 | 	mov	_var01, ptr__psram_spin2_dat__
01e00     08 7B 06 F1 | 	add	_var01, #264
01e04                 | '     delay := long[profile][0]
01e04     3D 7D 02 FB | 	rdlong	_var02, _var01
01e08     D7 16 48 FB | 	callpa	#(@LR__0171-@LR__0170)>>2,fcache_load_ptr_
01e0c                 | '     repeat while long[profile][1] 
01e0c                 | LR__0170
01e0c     04 7A 06 F1 | 	add	_var01, #4
01e10     3D 75 0A FB | 	rdlong	result1, _var01 wz
01e14     04 7A 86 F1 | 	sub	_var01, #4
01e18     1C 00 90 AD |  if_e	jmp	#LR__0172
01e1c                 | '         if freq +< long[profile][1] 
01e1c     04 7A 06 F1 | 	add	_var01, #4
01e20     3D 75 02 FB | 	rdlong	result1, _var01
01e24     04 7A 86 F1 | 	sub	_var01, #4
01e28     3A 8B 12 F2 | 	cmp	arg01, result1 wc
01e2c                 | '             quit
01e2c                 | '         profile += 4
01e2c     04 7A 06 31 |  if_ae	add	_var01, #4
01e30                 | '         delay++
01e30     01 7C 06 31 |  if_ae	add	_var02, #1
01e34     D4 FF 9F 3D |  if_ae	jmp	#LR__0170
01e38                 | LR__0171
01e38                 | LR__0172
01e38     3E 75 02 F6 | 	mov	result1, _var02
01e3c                 | _psram_spin2_lookupDelay_ret
01e3c     2D 00 64 FD | 	ret
01e40                 | 
01e40                 | ' 
01e40                 | ' PUB start() : r
01e40                 | _usbnew_spin2_start
01e40     00 7A 06 F6 | 	mov	_var01, #0
01e44                 | '   ifnot driver_cog
01e44     15 00 00 FF 
01e48     87 70 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##10887
01e4c     38 7D CA FA | 	rdbyte	_var02, ptr__usbnew_spin2_dat__ wz
01e50     15 00 00 FF 
01e54     87 70 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##10887
01e58     38 00 90 5D |  if_ne	jmp	#LR__0180
01e5c                 | '     r := coginit(COGEXEC_NEW,@usb_host_start,0)
01e5c     38 8D 02 F6 | 	mov	arg02, ptr__usbnew_spin2_dat__
01e60     10 7A 06 F6 | 	mov	_var01, #16
01e64     00 8E 06 F6 | 	mov	arg03, #0
01e68     28 8E 62 FD | 	setq	arg03
01e6c     46 7B F2 FC | 	coginit	_var01, arg02 wc
01e70     01 7A 66 C6 |  if_b	neg	_var01, #1
01e74                 | '     if r >= 0
01e74     00 7A 56 F2 | 	cmps	_var01, #0 wc
01e78                 | '       driver_cog := r+1
01e78     3D 7D 02 36 |  if_ae	mov	_var02, _var01
01e7c     01 7C 06 31 |  if_ae	add	_var02, #1
01e80     15 00 00 3F 
01e84     87 70 06 31 |  if_ae	add	ptr__usbnew_spin2_dat__, ##10887
01e88     38 7D 42 3C |  if_ae	wrbyte	_var02, ptr__usbnew_spin2_dat__
01e8c     15 00 00 3F 
01e90     87 70 86 31 |  if_ae	sub	ptr__usbnew_spin2_dat__, ##10887
01e94                 | LR__0180
01e94     3D 75 02 F6 | 	mov	result1, _var01
01e98                 | _usbnew_spin2_start_ret
01e98     2D 00 64 FD | 	ret
01e9c                 | 
01e9c                 | '     '' Set KEYQUEUE_SIZE to enable (recommended value: 32)
01e9c                 | ' 
01e9c                 | ' '' Return key event from buffer if there is one
01e9c                 | ' PUB get_key() : r | tail
01e9c                 | _usbnew_spin2_get_key
01e9c                 | '   tail := keyq_tail
01e9c     0F 00 00 FF 
01ea0     D5 70 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##7893
01ea4     38 7B C2 FA | 	rdbyte	_var01, ptr__usbnew_spin2_dat__
01ea8                 | '   if keyq_head == tail
01ea8     01 70 86 F1 | 	sub	ptr__usbnew_spin2_dat__, #1
01eac     38 7D C2 FA | 	rdbyte	_var02, ptr__usbnew_spin2_dat__
01eb0     0F 00 00 FF 
01eb4     D4 70 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##7892
01eb8     3D 7D 0A F2 | 	cmp	_var02, _var01 wz
01ebc                 | '     return 0 ' No event
01ebc     00 74 06 A6 |  if_e	mov	result1, #0
01ec0     3C 00 90 AD |  if_e	jmp	#_usbnew_spin2_get_key_ret
01ec4                 | '   r := keyq_data[tail]
01ec4     3D 7D 02 F6 | 	mov	_var02, _var01
01ec8     02 7C 66 F0 | 	shl	_var02, #2
01ecc     38 75 02 F6 | 	mov	result1, ptr__usbnew_spin2_dat__
01ed0     0F 00 00 FF 
01ed4     D6 74 06 F1 | 	add	result1, ##7894
01ed8     3A 7D 02 F1 | 	add	_var02, result1
01edc     3E 75 02 FB | 	rdlong	result1, _var02
01ee0                 | '   if ++tail == KEYQUEUE_SIZE
01ee0     01 7A 06 F1 | 	add	_var01, #1
01ee4     80 7A 0E F2 | 	cmp	_var01, #128 wz
01ee8                 | '     tail := 0
01ee8     00 7A 06 A6 |  if_e	mov	_var01, #0
01eec                 | '   keyq_tail := tail
01eec     0F 00 00 FF 
01ef0     D5 70 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##7893
01ef4     38 7B 42 FC | 	wrbyte	_var01, ptr__usbnew_spin2_dat__
01ef8     0F 00 00 FF 
01efc     D5 70 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##7893
01f00                 | _usbnew_spin2_get_key_ret
01f00     2D 00 64 FD | 	ret
01f04                 | 
01f04                 | _hello_b_program
01f04     06 CA 05 F6 | 	mov	COUNT_, #6
01f08     E8 00 A0 FD | 	call	#pushregs_
01f0c     00 94 06 F6 | 	mov	local01, #0
01f10     2F 8B 02 F6 | 	mov	arg01, __sendreg
01f14     00 8C 06 F6 | 	mov	arg02, #0
01f18     38 08 B0 FD | 	call	#__system___funcptr_cmp
01f1c     00 74 0E F2 | 	cmp	result1, #0 wz
01f20     33 5F 02 A6 |  if_e	mov	__sendreg, objptr
01f24     2E 8B 02 F6 | 	mov	arg01, __recvreg
01f28     00 8C 06 F6 | 	mov	arg02, #0
01f2c     24 08 B0 FD | 	call	#__system___funcptr_cmp
01f30     00 74 0E F2 | 	cmp	result1, #0 wz
01f34     33 5D 02 A6 |  if_e	mov	__recvreg, objptr
01f38     14 8C C6 A9 |  if_e	decod	arg02, #20
01f3c     14 5C 26 A4 |  if_e	bith	__recvreg, #20
01f40     4A 97 02 F6 | 	mov	local02, local01
01f44     33 97 02 F1 | 	add	local02, objptr
01f48     4A 99 02 F6 | 	mov	local03, local01
01f4c     33 99 02 F1 | 	add	local03, objptr
01f50     4C 9B C2 FA | 	rdbyte	local04, local03
01f54     08 9A 06 F1 | 	add	local04, #8
01f58     4B 9B 42 FC | 	wrbyte	local04, local02
01f5c     4A 9D 02 F6 | 	mov	local05, local01
01f60     33 9D 02 F1 | 	add	local05, objptr
01f64     4E 9F CA FA | 	rdbyte	local06, local05 wz
01f68     E8 01 90 AD |  if_e	jmp	#LR__0196
01f6c     D7 F2 48 FB | 	callpa	#(@LR__0195-@LR__0190)>>2,fcache_load_ptr_
01f70                 | LR__0190
01f70     01 94 06 F1 | 	add	local01, #1
01f74     0E 94 46 F7 | 	zerox	local01, #14
01f78     4A 97 02 F6 | 	mov	local02, local01
01f7c     33 97 02 F1 | 	add	local02, objptr
01f80     4A 99 02 F6 | 	mov	local03, local01
01f84     33 99 02 F1 | 	add	local03, objptr
01f88     4C 9B C2 FA | 	rdbyte	local04, local03
01f8c     04 9A 06 F1 | 	add	local04, #4
01f90     4B 9B 42 FC | 	wrbyte	local04, local02
01f94     4A 9D 02 F6 | 	mov	local05, local01
01f98     33 9D 02 F1 | 	add	local05, objptr
01f9c     4E 9F CA FA | 	rdbyte	local06, local05 wz
01fa0     C4 00 90 AD |  if_e	jmp	#LR__0192
01fa4                 | LR__0191
01fa4     01 94 06 F1 | 	add	local01, #1
01fa8     0E 94 46 F7 | 	zerox	local01, #14
01fac     4A 97 02 F6 | 	mov	local02, local01
01fb0     33 97 02 F1 | 	add	local02, objptr
01fb4     4A 99 02 F6 | 	mov	local03, local01
01fb8     33 99 02 F1 | 	add	local03, objptr
01fbc     4C 9B C2 FA | 	rdbyte	local04, local03
01fc0     02 9A 06 F1 | 	add	local04, #2
01fc4     4B 9B 42 FC | 	wrbyte	local04, local02
01fc8     01 94 06 F1 | 	add	local01, #1
01fcc     0E 94 46 F7 | 	zerox	local01, #14
01fd0     4A 97 02 F6 | 	mov	local02, local01
01fd4     33 97 02 F1 | 	add	local02, objptr
01fd8     4A 99 02 F6 | 	mov	local03, local01
01fdc     33 99 02 F1 | 	add	local03, objptr
01fe0     4C 9B C2 FA | 	rdbyte	local04, local03
01fe4     03 9A 06 F1 | 	add	local04, #3
01fe8     4B 9B 42 FC | 	wrbyte	local04, local02
01fec     01 94 06 F1 | 	add	local01, #1
01ff0     0E 94 46 F7 | 	zerox	local01, #14
01ff4     4A 97 02 F6 | 	mov	local02, local01
01ff8     33 97 02 F1 | 	add	local02, objptr
01ffc     4A 99 02 F6 | 	mov	local03, local01
02000     33 99 02 F1 | 	add	local03, objptr
02004     4C 9B C2 FA | 	rdbyte	local04, local03
02008     03 9A 06 F1 | 	add	local04, #3
0200c     4B 9B 42 FC | 	wrbyte	local04, local02
02010     01 94 06 F1 | 	add	local01, #1
02014     0E 94 46 F7 | 	zerox	local01, #14
02018     4A 97 02 F6 | 	mov	local02, local01
0201c     33 97 02 F1 | 	add	local02, objptr
02020     4A 99 02 F6 | 	mov	local03, local01
02024     33 99 02 F1 | 	add	local03, objptr
02028     4C 9B C2 FA | 	rdbyte	local04, local03
0202c     01 9A 06 F1 | 	add	local04, #1
02030     4B 9B 42 FC | 	wrbyte	local04, local02
02034     04 94 86 F1 | 	sub	local01, #4
02038     0E 94 46 F7 | 	zerox	local01, #14
0203c     4A 97 02 F6 | 	mov	local02, local01
02040     33 97 02 F1 | 	add	local02, objptr
02044     4A 99 02 F6 | 	mov	local03, local01
02048     33 99 02 F1 | 	add	local03, objptr
0204c     4C 9B C2 FA | 	rdbyte	local04, local03
02050     01 9A 86 F1 | 	sub	local04, #1
02054     4B 9B 42 FC | 	wrbyte	local04, local02
02058     4A 9D 02 F6 | 	mov	local05, local01
0205c     33 9D 02 F1 | 	add	local05, objptr
02060     4E 9F CA FA | 	rdbyte	local06, local05 wz
02064     3C FF 9F 5D |  if_ne	jmp	#LR__0191
02068                 | LR__0192
02068     01 94 06 F1 | 	add	local01, #1
0206c     0E 94 46 F7 | 	zerox	local01, #14
02070     4A 97 02 F6 | 	mov	local02, local01
02074     33 97 02 F1 | 	add	local02, objptr
02078     4A 99 02 F6 | 	mov	local03, local01
0207c     33 99 02 F1 | 	add	local03, objptr
02080     4C 9B C2 FA | 	rdbyte	local04, local03
02084     01 9A 06 F1 | 	add	local04, #1
02088     4B 9B 42 FC | 	wrbyte	local04, local02
0208c     01 94 06 F1 | 	add	local01, #1
02090     0E 94 46 F7 | 	zerox	local01, #14
02094     4A 97 02 F6 | 	mov	local02, local01
02098     33 97 02 F1 | 	add	local02, objptr
0209c     4A 99 02 F6 | 	mov	local03, local01
020a0     33 99 02 F1 | 	add	local03, objptr
020a4     4C 9B C2 FA | 	rdbyte	local04, local03
020a8     01 9A 06 F1 | 	add	local04, #1
020ac     4B 9B 42 FC | 	wrbyte	local04, local02
020b0     01 94 06 F1 | 	add	local01, #1
020b4     0E 94 46 F7 | 	zerox	local01, #14
020b8     4A 97 02 F6 | 	mov	local02, local01
020bc     33 97 02 F1 | 	add	local02, objptr
020c0     4A 99 02 F6 | 	mov	local03, local01
020c4     33 99 02 F1 | 	add	local03, objptr
020c8     4C 9B C2 FA | 	rdbyte	local04, local03
020cc     01 9A 86 F1 | 	sub	local04, #1
020d0     4B 9B 42 FC | 	wrbyte	local04, local02
020d4     02 94 06 F1 | 	add	local01, #2
020d8     0E 94 46 F7 | 	zerox	local01, #14
020dc     4A 97 02 F6 | 	mov	local02, local01
020e0     33 97 02 F1 | 	add	local02, objptr
020e4     4A 99 02 F6 | 	mov	local03, local01
020e8     33 99 02 F1 | 	add	local03, objptr
020ec     4C 9B C2 FA | 	rdbyte	local04, local03
020f0     01 9A 06 F1 | 	add	local04, #1
020f4     4B 9B 42 FC | 	wrbyte	local04, local02
020f8     4A 9D 02 F6 | 	mov	local05, local01
020fc     33 9D 02 F1 | 	add	local05, objptr
02100     4E 9F CA FA | 	rdbyte	local06, local05 wz
02104     18 00 90 AD |  if_e	jmp	#LR__0194
02108                 | LR__0193
02108     01 94 86 F1 | 	sub	local01, #1
0210c     0E 94 46 F7 | 	zerox	local01, #14
02110     4A 9D 02 F6 | 	mov	local05, local01
02114     33 9D 02 F1 | 	add	local05, objptr
02118     4E 9F CA FA | 	rdbyte	local06, local05 wz
0211c     E8 FF 9F 5D |  if_ne	jmp	#LR__0193
02120                 | LR__0194
02120     01 94 86 F1 | 	sub	local01, #1
02124     0E 94 46 F7 | 	zerox	local01, #14
02128     4A 97 02 F6 | 	mov	local02, local01
0212c     33 97 02 F1 | 	add	local02, objptr
02130     4A 99 02 F6 | 	mov	local03, local01
02134     33 99 02 F1 | 	add	local03, objptr
02138     4C 9B C2 FA | 	rdbyte	local04, local03
0213c     01 9A 86 F1 | 	sub	local04, #1
02140     4B 9B 42 FC | 	wrbyte	local04, local02
02144     4A 9D 02 F6 | 	mov	local05, local01
02148     33 9D 02 F1 | 	add	local05, objptr
0214c     4E 9F CA FA | 	rdbyte	local06, local05 wz
02150     1C FE 9F 5D |  if_ne	jmp	#LR__0190
02154                 | LR__0195
02154                 | LR__0196
02154     02 94 06 F1 | 	add	local01, #2
02158     0E 94 46 F7 | 	zerox	local01, #14
0215c     2F 97 02 F6 | 	mov	local02, __sendreg
02160     2F 9D 02 F6 | 	mov	local05, __sendreg
02164     13 96 46 F7 | 	zerox	local02, #19
02168     14 9C 46 F0 | 	shr	local05, #20
0216c     02 9C 66 F0 | 	shl	local05, #2
02170     2D 9D 02 F1 | 	add	local05, __methods__
02174     4E 9D 02 FB | 	rdlong	local05, local05
02178     4A 9F 02 F6 | 	mov	local06, local01
0217c     33 9F 02 F1 | 	add	local06, objptr
02180     4F 8B C2 FA | 	rdbyte	arg01, local06
02184     33 9F 02 F6 | 	mov	local06, objptr
02188     4B 67 02 F6 | 	mov	objptr, local02
0218c     2D 9C 62 FD | 	call	local05
02190     01 94 06 F1 | 	add	local01, #1
02194     0E 94 46 F7 | 	zerox	local01, #14
02198     4A 97 02 F6 | 	mov	local02, local01
0219c     4F 97 02 F1 | 	add	local02, local06
021a0     4A 99 02 F6 | 	mov	local03, local01
021a4     4F 99 02 F1 | 	add	local03, local06
021a8     4C 9B C2 FA | 	rdbyte	local04, local03
021ac     03 9A 86 F1 | 	sub	local04, #3
021b0     4B 9B 42 FC | 	wrbyte	local04, local02
021b4     2F 67 02 F6 | 	mov	objptr, __sendreg
021b8     2F 9D 02 F6 | 	mov	local05, __sendreg
021bc     13 66 46 F7 | 	zerox	objptr, #19
021c0     14 9C 46 F0 | 	shr	local05, #20
021c4     02 9C 66 F0 | 	shl	local05, #2
021c8     2D 9D 02 F1 | 	add	local05, __methods__
021cc     4E 9D 02 FB | 	rdlong	local05, local05
021d0     4A 9B 02 F6 | 	mov	local04, local01
021d4     4F 9B 02 F1 | 	add	local04, local06
021d8     4D 8B C2 FA | 	rdbyte	arg01, local04
021dc     2D 9C 62 FD | 	call	local05
021e0     4A 97 02 F6 | 	mov	local02, local01
021e4     4F 97 02 F1 | 	add	local02, local06
021e8     4A 99 02 F6 | 	mov	local03, local01
021ec     4F 99 02 F1 | 	add	local03, local06
021f0     4C 9B C2 FA | 	rdbyte	local04, local03
021f4     07 9A 06 F1 | 	add	local04, #7
021f8     4B 9B 42 FC | 	wrbyte	local04, local02
021fc     2F 67 02 F6 | 	mov	objptr, __sendreg
02200     2F 9D 02 F6 | 	mov	local05, __sendreg
02204     13 66 46 F7 | 	zerox	objptr, #19
02208     14 9C 46 F0 | 	shr	local05, #20
0220c     02 9C 66 F0 | 	shl	local05, #2
02210     2D 9D 02 F1 | 	add	local05, __methods__
02214     4E 9D 02 FB | 	rdlong	local05, local05
02218     4A 9B 02 F6 | 	mov	local04, local01
0221c     4F 9B 02 F1 | 	add	local04, local06
02220     4D 8B C2 FA | 	rdbyte	arg01, local04
02224     2D 9C 62 FD | 	call	local05
02228     2F 67 02 F6 | 	mov	objptr, __sendreg
0222c     2F 9D 02 F6 | 	mov	local05, __sendreg
02230     13 66 46 F7 | 	zerox	objptr, #19
02234     14 9C 46 F0 | 	shr	local05, #20
02238     02 9C 66 F0 | 	shl	local05, #2
0223c     2D 9D 02 F1 | 	add	local05, __methods__
02240     4E 9D 02 FB | 	rdlong	local05, local05
02244     4A 9B 02 F6 | 	mov	local04, local01
02248     4F 9B 02 F1 | 	add	local04, local06
0224c     4D 8B C2 FA | 	rdbyte	arg01, local04
02250     2D 9C 62 FD | 	call	local05
02254     4A 97 02 F6 | 	mov	local02, local01
02258     4F 97 02 F1 | 	add	local02, local06
0225c     4A 99 02 F6 | 	mov	local03, local01
02260     4F 99 02 F1 | 	add	local03, local06
02264     4C 9B C2 FA | 	rdbyte	local04, local03
02268     03 9A 06 F1 | 	add	local04, #3
0226c     4B 9B 42 FC | 	wrbyte	local04, local02
02270     2F 67 02 F6 | 	mov	objptr, __sendreg
02274     2F 9D 02 F6 | 	mov	local05, __sendreg
02278     13 66 46 F7 | 	zerox	objptr, #19
0227c     14 9C 46 F0 | 	shr	local05, #20
02280     02 9C 66 F0 | 	shl	local05, #2
02284     2D 9D 02 F1 | 	add	local05, __methods__
02288     4E 9D 02 FB | 	rdlong	local05, local05
0228c     4A 9B 02 F6 | 	mov	local04, local01
02290     4F 9B 02 F1 | 	add	local04, local06
02294     4D 8B C2 FA | 	rdbyte	arg01, local04
02298     2D 9C 62 FD | 	call	local05
0229c     02 94 06 F1 | 	add	local01, #2
022a0     0E 94 46 F7 | 	zerox	local01, #14
022a4     2F 67 02 F6 | 	mov	objptr, __sendreg
022a8     2F 9D 02 F6 | 	mov	local05, __sendreg
022ac     13 66 46 F7 | 	zerox	objptr, #19
022b0     14 9C 46 F0 | 	shr	local05, #20
022b4     02 9C 66 F0 | 	shl	local05, #2
022b8     2D 9D 02 F1 | 	add	local05, __methods__
022bc     4E 9D 02 FB | 	rdlong	local05, local05
022c0     4A 9B 02 F6 | 	mov	local04, local01
022c4     4F 9B 02 F1 | 	add	local04, local06
022c8     4D 8B C2 FA | 	rdbyte	arg01, local04
022cc     2D 9C 62 FD | 	call	local05
022d0     01 94 86 F1 | 	sub	local01, #1
022d4     0E 94 46 F7 | 	zerox	local01, #14
022d8     4A 97 02 F6 | 	mov	local02, local01
022dc     4F 97 02 F1 | 	add	local02, local06
022e0     4A 99 02 F6 | 	mov	local03, local01
022e4     4F 99 02 F1 | 	add	local03, local06
022e8     4C 9B C2 FA | 	rdbyte	local04, local03
022ec     01 9A 86 F1 | 	sub	local04, #1
022f0     4B 9B 42 FC | 	wrbyte	local04, local02
022f4     2F 67 02 F6 | 	mov	objptr, __sendreg
022f8     2F 9D 02 F6 | 	mov	local05, __sendreg
022fc     13 66 46 F7 | 	zerox	objptr, #19
02300     14 9C 46 F0 | 	shr	local05, #20
02304     02 9C 66 F0 | 	shl	local05, #2
02308     2D 9D 02 F1 | 	add	local05, __methods__
0230c     4E 9D 02 FB | 	rdlong	local05, local05
02310     4A 9B 02 F6 | 	mov	local04, local01
02314     4F 9B 02 F1 | 	add	local04, local06
02318     4D 8B C2 FA | 	rdbyte	arg01, local04
0231c     2D 9C 62 FD | 	call	local05
02320     01 94 86 F1 | 	sub	local01, #1
02324     0E 94 46 F7 | 	zerox	local01, #14
02328     2F 67 02 F6 | 	mov	objptr, __sendreg
0232c     2F 9D 02 F6 | 	mov	local05, __sendreg
02330     13 66 46 F7 | 	zerox	objptr, #19
02334     14 9C 46 F0 | 	shr	local05, #20
02338     02 9C 66 F0 | 	shl	local05, #2
0233c     2D 9D 02 F1 | 	add	local05, __methods__
02340     4E 9D 02 FB | 	rdlong	local05, local05
02344     4A 9B 02 F6 | 	mov	local04, local01
02348     4F 9B 02 F1 | 	add	local04, local06
0234c     4D 8B C2 FA | 	rdbyte	arg01, local04
02350     2D 9C 62 FD | 	call	local05
02354     4A 97 02 F6 | 	mov	local02, local01
02358     4F 97 02 F1 | 	add	local02, local06
0235c     4A 99 02 F6 | 	mov	local03, local01
02360     4F 99 02 F1 | 	add	local03, local06
02364     4C 9B C2 FA | 	rdbyte	local04, local03
02368     03 9A 06 F1 | 	add	local04, #3
0236c     4B 9B 42 FC | 	wrbyte	local04, local02
02370     2F 67 02 F6 | 	mov	objptr, __sendreg
02374     2F 9D 02 F6 | 	mov	local05, __sendreg
02378     13 66 46 F7 | 	zerox	objptr, #19
0237c     14 9C 46 F0 | 	shr	local05, #20
02380     02 9C 66 F0 | 	shl	local05, #2
02384     2D 9D 02 F1 | 	add	local05, __methods__
02388     4E 9D 02 FB | 	rdlong	local05, local05
0238c     4A 9B 02 F6 | 	mov	local04, local01
02390     4F 9B 02 F1 | 	add	local04, local06
02394     4D 8B C2 FA | 	rdbyte	arg01, local04
02398     2D 9C 62 FD | 	call	local05
0239c     4A 97 02 F6 | 	mov	local02, local01
023a0     4F 97 02 F1 | 	add	local02, local06
023a4     4A 99 02 F6 | 	mov	local03, local01
023a8     4F 99 02 F1 | 	add	local03, local06
023ac     4C 9B C2 FA | 	rdbyte	local04, local03
023b0     06 9A 86 F1 | 	sub	local04, #6
023b4     4B 9B 42 FC | 	wrbyte	local04, local02
023b8     2F 67 02 F6 | 	mov	objptr, __sendreg
023bc     2F 9D 02 F6 | 	mov	local05, __sendreg
023c0     13 66 46 F7 | 	zerox	objptr, #19
023c4     14 9C 46 F0 | 	shr	local05, #20
023c8     02 9C 66 F0 | 	shl	local05, #2
023cc     2D 9D 02 F1 | 	add	local05, __methods__
023d0     4E 9D 02 FB | 	rdlong	local05, local05
023d4     4A 9B 02 F6 | 	mov	local04, local01
023d8     4F 9B 02 F1 | 	add	local04, local06
023dc     4D 8B C2 FA | 	rdbyte	arg01, local04
023e0     2D 9C 62 FD | 	call	local05
023e4     4A 97 02 F6 | 	mov	local02, local01
023e8     4F 97 02 F1 | 	add	local02, local06
023ec     4A 99 02 F6 | 	mov	local03, local01
023f0     4F 99 02 F1 | 	add	local03, local06
023f4     4C 9B C2 FA | 	rdbyte	local04, local03
023f8     08 9A 86 F1 | 	sub	local04, #8
023fc     4B 9B 42 FC | 	wrbyte	local04, local02
02400     2F 67 02 F6 | 	mov	objptr, __sendreg
02404     2F 9D 02 F6 | 	mov	local05, __sendreg
02408     13 66 46 F7 | 	zerox	objptr, #19
0240c     14 9C 46 F0 | 	shr	local05, #20
02410     02 9C 66 F0 | 	shl	local05, #2
02414     2D 9D 02 F1 | 	add	local05, __methods__
02418     4E 9D 02 FB | 	rdlong	local05, local05
0241c     4A 9B 02 F6 | 	mov	local04, local01
02420     4F 9B 02 F1 | 	add	local04, local06
02424     4D 8B C2 FA | 	rdbyte	arg01, local04
02428     2D 9C 62 FD | 	call	local05
0242c     02 94 06 F1 | 	add	local01, #2
02430     0E 94 46 F7 | 	zerox	local01, #14
02434     4A 97 02 F6 | 	mov	local02, local01
02438     4F 97 02 F1 | 	add	local02, local06
0243c     4A 99 02 F6 | 	mov	local03, local01
02440     4F 99 02 F1 | 	add	local03, local06
02444     4C 9B C2 FA | 	rdbyte	local04, local03
02448     01 9A 06 F1 | 	add	local04, #1
0244c     4B 9B 42 FC | 	wrbyte	local04, local02
02450     2F 67 02 F6 | 	mov	objptr, __sendreg
02454     2F 9D 02 F6 | 	mov	local05, __sendreg
02458     13 66 46 F7 | 	zerox	objptr, #19
0245c     14 9C 46 F0 | 	shr	local05, #20
02460     02 9C 66 F0 | 	shl	local05, #2
02464     2D 9D 02 F1 | 	add	local05, __methods__
02468     4E 9D 02 FB | 	rdlong	local05, local05
0246c     4A 9B 02 F6 | 	mov	local04, local01
02470     4F 9B 02 F1 | 	add	local04, local06
02474     4D 8B C2 FA | 	rdbyte	arg01, local04
02478     2D 9C 62 FD | 	call	local05
0247c     01 94 06 F1 | 	add	local01, #1
02480     0E 94 46 F7 | 	zerox	local01, #14
02484     4A 97 02 F6 | 	mov	local02, local01
02488     4F 97 02 F1 | 	add	local02, local06
0248c     4A 99 02 F6 | 	mov	local03, local01
02490     4F 99 02 F1 | 	add	local03, local06
02494     4C 9B C2 FA | 	rdbyte	local04, local03
02498     02 9A 06 F1 | 	add	local04, #2
0249c     4B 9B 42 FC | 	wrbyte	local04, local02
024a0     2F 67 02 F6 | 	mov	objptr, __sendreg
024a4     2F 9D 02 F6 | 	mov	local05, __sendreg
024a8     13 66 46 F7 | 	zerox	objptr, #19
024ac     14 9C 46 F0 | 	shr	local05, #20
024b0     02 9C 66 F0 | 	shl	local05, #2
024b4     2D 9D 02 F1 | 	add	local05, __methods__
024b8     4E 9D 02 FB | 	rdlong	local05, local05
024bc     4F 95 02 F1 | 	add	local01, local06
024c0     4A 8B C2 FA | 	rdbyte	arg01, local01
024c4     2D 9C 62 FD | 	call	local05
024c8     4F 67 02 F6 | 	mov	objptr, local06
024cc     E7 F0 03 F6 | 	mov	ptra, fp
024d0     F2 00 A0 FD | 	call	#popregs_
024d4                 | _hello_b_program_ret
024d4     2D 00 64 FD | 	ret
024d8                 | hubexit
024d8     C1 00 80 FD | 	jmp	#cogexit
024dc                 | 
024dc                 | __system___setbaud
024dc     14 AE 06 FB | 	rdlong	muldiva_, #20
024e0     45 B1 02 F6 | 	mov	muldivb_, arg01
024e4     FA 00 A0 FD | 	call	#divide_
024e8     D7 06 48 FB | 	callpa	#(@LR__0201-@LR__0200)>>2,fcache_load_ptr_
024ec                 | LR__0200
024ec     3E 74 9E FA | 	rdpin	result1, #62 wc
024f0     3B 77 A2 F1 | 	subx	result2, result2
024f4     F4 FF 9F CD |  if_b	jmp	#LR__0200
024f8                 | LR__0201
024f8     40 7C 64 FD | 	dirl	#62
024fc     40 7E 64 FD | 	dirl	#63
02500     34 B1 62 FC | 	wrlong	muldivb_, ptr___system__dat__
02504     10 B0 66 F0 | 	shl	muldivb_, #16
02508     07 8C 06 F6 | 	mov	arg02, #7
0250c     58 8D 02 F1 | 	add	arg02, muldivb_
02510     3E F8 0C FC | 	wrpin	#124, #62
02514     3E 8C 16 FC | 	wxpin	arg02, #62
02518     3F 7C 0C FC | 	wrpin	#62, #63
0251c     14 8C 06 F1 | 	add	arg02, #20
02520     3F 8C 16 FC | 	wxpin	arg02, #63
02524     41 7C 64 FD | 	dirh	#62
02528     41 7E 64 FD | 	dirh	#63
0252c                 | __system___setbaud_ret
0252c     2D 00 64 FD | 	ret
02530                 | 
02530                 | __system___txraw
02530     01 CA 05 F6 | 	mov	COUNT_, #1
02534     E8 00 A0 FD | 	call	#pushregs_
02538     45 95 02 F6 | 	mov	local01, arg01
0253c     D7 06 48 FB | 	callpa	#(@LR__0211-@LR__0210)>>2,fcache_load_ptr_
02540                 | LR__0210
02540     3E 74 9E FA | 	rdpin	result1, #62 wc
02544     3B 77 A2 F1 | 	subx	result2, result2
02548     F4 FF 9F CD |  if_b	jmp	#LR__0210
0254c                 | LR__0211
0254c     34 75 0A FB | 	rdlong	result1, ptr___system__dat__ wz
02550     42 0F 00 AF 
02554     80 8A 06 A6 |  if_e	mov	arg01, ##2000000
02558     80 FF BF AD |  if_e	call	#__system___setbaud
0255c     58 7C 64 FD | 	drvl	#62
02560     3E 94 26 FC | 	wypin	local01, #62
02564     01 74 06 F6 | 	mov	result1, #1
02568     E7 F0 03 F6 | 	mov	ptra, fp
0256c     F2 00 A0 FD | 	call	#popregs_
02570                 | __system___txraw_ret
02570     2D 00 64 FD | 	ret
02574                 | 
02574                 | __system___rxraw
02574     0D CA 05 F6 | 	mov	COUNT_, #13
02578     E8 00 A0 FD | 	call	#pushregs_
0257c     45 95 02 F6 | 	mov	local01, arg01
02580     34 97 0A FB | 	rdlong	local02, ptr___system__dat__ wz
02584     42 0F 00 AF 
02588     80 8A 06 A6 |  if_e	mov	arg01, ##2000000
0258c     4C FF BF AD |  if_e	call	#__system___setbaud
02590     00 94 0E F2 | 	cmp	local01, #0 wz
02594     20 00 90 AD |  if_e	jmp	#LR__0220
02598     14 98 06 FB | 	rdlong	local03, #20
0259c     0A 98 46 F0 | 	shr	local03, #10
025a0     4C 95 02 FD | 	qmul	local01, local03
025a4     1A 74 62 FD | 	getct	result1
025a8     18 9A 62 FD | 	getqx	local04
025ac     4D 75 02 F1 | 	add	result1, local04
025b0     3A 9D 02 F6 | 	mov	local05, result1
025b4     04 00 90 FD | 	jmp	#LR__0221
025b8                 | LR__0220
025b8     00 9C 06 F6 | 	mov	local05, #0
025bc                 | LR__0221
025bc     01 9E 66 F6 | 	neg	local06, #1
025c0     3F A0 06 F6 | 	mov	local07, #63
025c4     00 A2 06 F6 | 	mov	local08, #0
025c8     04 68 06 F1 | 	add	ptr___system__dat__, #4
025cc     34 A5 02 FB | 	rdlong	local09, ptr___system__dat__
025d0     04 68 86 F1 | 	sub	ptr___system__dat__, #4
025d4                 | LR__0222
025d4     08 A4 16 F4 | 	testb	local09, #8 wc
025d8     09 A4 76 F4 | 	testbn	local09, #9 andc
025dc     0A A4 46 F0 | 	shr	local09, #10
025e0     01 A2 06 C6 |  if_b	mov	local08, #1
025e4     40 7E 6C 3D |  if_ae	testp	#63 wz
025e8     01 A2 06 26 |  if_nc_and_z	mov	local08, #1
025ec     3F A4 8E 2A |  if_nc_and_z	rdpin	local09, #63
025f0     04 A4 46 20 |  if_nc_and_z	shr	local09, #4
025f4                 | LR__0223
025f4     00 96 06 F6 | 	mov	local02, #0
025f8     00 A2 0E F2 | 	cmp	local08, #0 wz
025fc     01 96 66 56 |  if_ne	neg	local02, #1
02600     00 A6 06 F6 | 	mov	local10, #0
02604     00 98 06 F6 | 	mov	local03, #0
02608     00 94 0E F2 | 	cmp	local01, #0 wz
0260c     01 98 66 56 |  if_ne	neg	local03, #1
02610     00 9A 06 F6 | 	mov	local04, #0
02614     00 A8 06 F6 | 	mov	local11, #0
02618     4E AB 02 F6 | 	mov	local12, local05
0261c     1A 74 62 FD | 	getct	result1
02620     3A AD 02 F6 | 	mov	local13, result1
02624     56 AB 82 F1 | 	sub	local12, local13
02628     00 AA 56 F2 | 	cmps	local12, #0 wc
0262c     00 A8 26 C6 |  if_b	not	local11, #0
02630     00 A8 0E F2 | 	cmp	local11, #0 wz
02634     00 9A 26 56 |  if_ne	not	local04, #0
02638     4D 99 CA F7 | 	test	local03, local04 wz
0263c     00 A6 26 56 |  if_ne	not	local10, #0
02640     53 97 4A F5 | 	or	local02, local10 wz
02644     8C FF 9F AD |  if_e	jmp	#LR__0222
02648     00 A2 0E F2 | 	cmp	local08, #0 wz
0264c     52 9F 02 56 |  if_ne	mov	local06, local09
02650     4F 9F E2 58 |  if_ne	getbyte	local06, local06, #0
02654     04 68 06 F1 | 	add	ptr___system__dat__, #4
02658     34 A5 62 FC | 	wrlong	local09, ptr___system__dat__
0265c     04 68 86 F1 | 	sub	ptr___system__dat__, #4
02660     4F 75 02 F6 | 	mov	result1, local06
02664     E7 F0 03 F6 | 	mov	ptra, fp
02668     F2 00 A0 FD | 	call	#popregs_
0266c                 | __system___rxraw_ret
0266c     2D 00 64 FD | 	ret
02670                 | 
02670                 | __system____builtin_memmove
02670     45 7B 02 F6 | 	mov	_var01, arg01
02674     46 8B 52 F2 | 	cmps	arg01, arg02 wc
02678     10 00 90 CD |  if_b	jmp	#LR__0230
0267c     46 7D 02 F6 | 	mov	_var02, arg02
02680     47 7D 02 F1 | 	add	_var02, arg03
02684     3E 8B 52 F2 | 	cmps	arg01, _var02 wc
02688     48 00 90 CD |  if_b	jmp	#LR__0236
0268c                 | LR__0230
0268c     47 7F 02 F6 | 	mov	_var03, arg03
02690     02 7E 4E F0 | 	shr	_var03, #2 wz
02694     18 00 90 AD |  if_e	jmp	#LR__0235
02698     D7 0A 48 FB | 	callpa	#(@LR__0233-@LR__0231)>>2,fcache_load_ptr_
0269c                 | LR__0231
0269c     3F 09 D8 FC | 	rep	@LR__0234, _var03
026a0                 | LR__0232
026a0     46 7F 02 FB | 	rdlong	_var03, arg02
026a4     45 7F 62 FC | 	wrlong	_var03, arg01
026a8     04 8A 06 F1 | 	add	arg01, #4
026ac     04 8C 06 F1 | 	add	arg02, #4
026b0                 | LR__0233
026b0                 | LR__0234
026b0                 | LR__0235
026b0     02 8E CE F7 | 	test	arg03, #2 wz
026b4     46 7D E2 5A |  if_ne	rdword	_var02, arg02
026b8     45 7D 52 5C |  if_ne	wrword	_var02, arg01
026bc     02 8A 06 51 |  if_ne	add	arg01, #2
026c0     02 8C 06 51 |  if_ne	add	arg02, #2
026c4     01 8E CE F7 | 	test	arg03, #1 wz
026c8     46 7D C2 5A |  if_ne	rdbyte	_var02, arg02
026cc     45 7D 42 5C |  if_ne	wrbyte	_var02, arg01
026d0     28 00 90 FD | 	jmp	#LR__0242
026d4                 | LR__0236
026d4     47 8B 02 F1 | 	add	arg01, arg03
026d8     47 8D 02 F1 | 	add	arg02, arg03
026dc     47 81 0A F6 | 	mov	_var04, arg03 wz
026e0     18 00 90 AD |  if_e	jmp	#LR__0241
026e4     D7 0A 48 FB | 	callpa	#(@LR__0239-@LR__0237)>>2,fcache_load_ptr_
026e8                 | LR__0237
026e8     40 09 D8 FC | 	rep	@LR__0240, _var04
026ec                 | LR__0238
026ec     01 8A 86 F1 | 	sub	arg01, #1
026f0     01 8C 86 F1 | 	sub	arg02, #1
026f4     46 7D C2 FA | 	rdbyte	_var02, arg02
026f8     45 7D 42 FC | 	wrbyte	_var02, arg01
026fc                 | LR__0239
026fc                 | LR__0240
026fc                 | LR__0241
026fc                 | LR__0242
026fc     3D 75 02 F6 | 	mov	result1, _var01
02700                 | __system____builtin_memmove_ret
02700     2D 00 64 FD | 	ret
02704                 | 
02704                 | __system____topofstack
02704     00 CA 05 F6 | 	mov	COUNT_, #0
02708     E8 00 A0 FD | 	call	#pushregs_
0270c     08 F0 07 F1 | 	add	ptra, #8
02710     04 CE 05 F1 | 	add	fp, #4
02714     E7 8A 62 FC | 	wrlong	arg01, fp
02718     E7 74 02 F6 | 	mov	result1, fp
0271c     04 CE 85 F1 | 	sub	fp, #4
02720     E7 F0 03 F6 | 	mov	ptra, fp
02724     F2 00 A0 FD | 	call	#popregs_
02728                 | __system____topofstack_ret
02728     2D 00 64 FD | 	ret
0272c                 | 
0272c                 | __system___lockmem
0272c     00 74 06 F6 | 	mov	result1, #0
02730     01 74 62 FD | 	cogid	result1
02734     00 75 06 F1 | 	add	result1, #256
02738                 | LR__0250
02738     45 7B 0A FB | 	rdlong	_var01, arg01 wz
0273c     45 75 62 AC |  if_e	wrlong	result1, arg01
02740     45 7B 02 AB |  if_e	rdlong	_var01, arg01
02744     45 7B 02 AB |  if_e	rdlong	_var01, arg01
02748     3A 7B 0A F2 | 	cmp	_var01, result1 wz
0274c     E8 FF 9F 5D |  if_ne	jmp	#LR__0250
02750                 | __system___lockmem_ret
02750     2D 00 64 FD | 	ret
02754                 | 
02754                 | __system___funcptr_cmp
02754     45 75 02 FB | 	rdlong	result1, arg01
02758     46 7B 02 FB | 	rdlong	_var01, arg02
0275c     3D 75 8A F1 | 	sub	result1, _var01 wz
02760     04 8A 06 A1 |  if_e	add	arg01, #4
02764     45 75 02 AB |  if_e	rdlong	result1, arg01
02768     04 8C 06 A1 |  if_e	add	arg02, #4
0276c     46 7B 02 AB |  if_e	rdlong	_var01, arg02
02770     3D 75 82 A1 |  if_e	sub	result1, _var01
02774                 | __system___funcptr_cmp_ret
02774     2D 00 64 FD | 	ret
02778                 | 
02778                 | __system___tx
02778     02 CA 05 F6 | 	mov	COUNT_, #2
0277c     E8 00 A0 FD | 	call	#pushregs_
02780     45 95 02 F6 | 	mov	local01, arg01
02784     0A 94 0E F2 | 	cmp	local01, #10 wz
02788     18 00 90 5D |  if_ne	jmp	#LR__0260
0278c     08 68 06 F1 | 	add	ptr___system__dat__, #8
02790     34 97 02 FB | 	rdlong	local02, ptr___system__dat__
02794     08 68 86 F1 | 	sub	ptr___system__dat__, #8
02798     02 96 CE F7 | 	test	local02, #2 wz
0279c     0D 8A 06 56 |  if_ne	mov	arg01, #13
027a0     8C FD BF 5D |  if_ne	call	#__system___txraw
027a4                 | LR__0260
027a4     4A 8B 02 F6 | 	mov	arg01, local01
027a8     84 FD BF FD | 	call	#__system___txraw
027ac     E7 F0 03 F6 | 	mov	ptra, fp
027b0     F2 00 A0 FD | 	call	#popregs_
027b4                 | __system___tx_ret
027b4     2D 00 64 FD | 	ret
027b8                 | 
027b8                 | __system___rx
027b8     01 CA 05 F6 | 	mov	COUNT_, #1
027bc     E8 00 A0 FD | 	call	#pushregs_
027c0                 | LR__0270
027c0     00 8A 06 F6 | 	mov	arg01, #0
027c4     AC FD BF FD | 	call	#__system___rxraw
027c8     3A 95 02 F6 | 	mov	local01, result1
027cc     FF FF 7F FF 
027d0     FF 95 0E F2 | 	cmp	local01, ##-1 wz
027d4     E8 FF 9F AD |  if_e	jmp	#LR__0270
027d8     0D 94 0E F2 | 	cmp	local01, #13 wz
027dc     14 00 90 5D |  if_ne	jmp	#LR__0271
027e0     08 68 06 F1 | 	add	ptr___system__dat__, #8
027e4     34 75 02 FB | 	rdlong	result1, ptr___system__dat__
027e8     08 68 86 F1 | 	sub	ptr___system__dat__, #8
027ec     02 74 CE F7 | 	test	result1, #2 wz
027f0     0A 94 06 56 |  if_ne	mov	local01, #10
027f4                 | LR__0271
027f4     08 68 06 F1 | 	add	ptr___system__dat__, #8
027f8     34 8B 02 FB | 	rdlong	arg01, ptr___system__dat__
027fc     08 68 86 F1 | 	sub	ptr___system__dat__, #8
02800     01 8A CE F7 | 	test	arg01, #1 wz
02804     1C 00 90 AD |  if_e	jmp	#LR__0274
02808     7F 94 0E F2 | 	cmp	local01, #127 wz
0280c     0C 00 90 5D |  if_ne	jmp	#LR__0272
02810     08 8A 06 F6 | 	mov	arg01, #8
02814     60 FF BF FD | 	call	#__system___tx
02818     08 00 90 FD | 	jmp	#LR__0273
0281c                 | LR__0272
0281c     4A 8B 02 F6 | 	mov	arg01, local01
02820     54 FF BF FD | 	call	#__system___tx
02824                 | LR__0273
02824                 | LR__0274
02824     4A 75 02 F6 | 	mov	result1, local01
02828     E7 F0 03 F6 | 	mov	ptra, fp
0282c     F2 00 A0 FD | 	call	#popregs_
02830                 | __system___rx_ret
02830     2D 00 64 FD | 	ret
02834                 | 
02834                 | __system___waitms
02834     45 7B 02 F6 | 	mov	_var01, arg01
02838     1A 7C 62 FD | 	getct	_var02
0283c     14 7E 06 FB | 	rdlong	_var03, #20
02840     D7 14 48 FB | 	callpa	#(@LR__0281-@LR__0280)>>2,fcache_load_ptr_
02844                 | LR__0280
02844     01 00 00 FF 
02848     E8 7B 56 F2 | 	cmps	_var01, ##1000 wc
0284c     1C 00 90 CD |  if_b	jmp	#LR__0282
02850     3F 7D 02 F1 | 	add	_var02, _var03
02854     3E 8B 02 F6 | 	mov	arg01, _var02
02858     00 8A 66 FA | 	addct1	arg01, #0
0285c     24 22 60 FD | 	waitct1
02860     01 00 00 FF 
02864     E8 7B 86 F1 | 	sub	_var01, ##1000
02868     D8 FF 9F FD | 	jmp	#LR__0280
0286c                 | LR__0281
0286c                 | LR__0282
0286c     01 7A 56 F2 | 	cmps	_var01, #1 wc
02870     28 00 90 CD |  if_b	jmp	#LR__0283
02874     3F 7B 02 FD | 	qmul	_var01, _var03
02878     01 00 00 FF 
0287c     E8 8F 06 F6 | 	mov	arg03, ##1000
02880     19 74 62 FD | 	getqy	result1
02884     18 8A 62 FD | 	getqx	arg01
02888     28 74 62 FD | 	setq	result1
0288c     47 8B 12 FD | 	qdiv	arg01, arg03
02890     18 8A 62 FD | 	getqx	arg01
02894     3E 8B 62 FA | 	addct1	arg01, _var02
02898     24 22 60 FD | 	waitct1
0289c                 | LR__0283
0289c                 | __system___waitms_ret
0289c     2D 00 64 FD | 	ret
028a0                 | 
028a0                 | __system___waitus
028a0     45 7B 02 F6 | 	mov	_var01, arg01
028a4     1A 7C 62 FD | 	getct	_var02
028a8     14 7E 06 FB | 	rdlong	_var03, #20
028ac     D7 14 48 FB | 	callpa	#(@LR__0291-@LR__0290)>>2,fcache_load_ptr_
028b0                 | LR__0290
028b0     A1 07 00 FF 
028b4     40 7A 56 F2 | 	cmps	_var01, ##1000000 wc
028b8     1C 00 90 CD |  if_b	jmp	#LR__0292
028bc     3F 7D 02 F1 | 	add	_var02, _var03
028c0     3E 8B 02 F6 | 	mov	arg01, _var02
028c4     00 8A 66 FA | 	addct1	arg01, #0
028c8     24 22 60 FD | 	waitct1
028cc     A1 07 00 FF 
028d0     40 7A 86 F1 | 	sub	_var01, ##1000000
028d4     D8 FF 9F FD | 	jmp	#LR__0290
028d8                 | LR__0291
028d8                 | LR__0292
028d8     01 7A 56 F2 | 	cmps	_var01, #1 wc
028dc     28 00 90 CD |  if_b	jmp	#LR__0293
028e0     3F 7B 02 FD | 	qmul	_var01, _var03
028e4     A1 07 00 FF 
028e8     40 8E 06 F6 | 	mov	arg03, ##1000000
028ec     19 74 62 FD | 	getqy	result1
028f0     18 8A 62 FD | 	getqx	arg01
028f4     28 74 62 FD | 	setq	result1
028f8     47 8B 12 FD | 	qdiv	arg01, arg03
028fc     18 74 62 FD | 	getqx	result1
02900     3A 7D 62 FA | 	addct1	_var02, result1
02904     24 22 60 FD | 	waitct1
02908                 | LR__0293
02908                 | __system___waitus_ret
02908     2D 00 64 FD | 	ret
0290c                 | 
0290c                 | __system___basic_open
0290c     05 CA 05 F6 | 	mov	COUNT_, #5
02910     E8 00 A0 FD | 	call	#pushregs_
02914     46 95 02 F6 | 	mov	local01, arg02
02918     47 97 02 F6 | 	mov	local02, arg03
0291c     48 99 02 F6 | 	mov	local03, arg04
02920     00 9A 06 F6 | 	mov	local04, #0
02924     74 0E B0 FD | 	call	#__system____getftab
02928     3A 9D 0A F6 | 	mov	local05, result1 wz
0292c     18 00 90 5D |  if_ne	jmp	#LR__0300
02930     30 8B 02 F6 | 	mov	arg01, abortchain
02934     0C 8C 06 F6 | 	mov	arg02, #12
02938     01 8E 06 F6 | 	mov	arg03, #1
0293c     1A 01 A0 FD | 	call	#__longjmp
02940     01 74 66 F6 | 	neg	result1, #1
02944     10 01 90 FD | 	jmp	#LR__0309
02948                 | LR__0300
02948     08 9C 06 F1 | 	add	local05, #8
0294c     4E 75 0A FB | 	rdlong	result1, local05 wz
02950     08 9C 86 F1 | 	sub	local05, #8
02954     4E 8B 02 56 |  if_ne	mov	arg01, local05
02958     A4 0A B0 5D |  if_ne	call	#__system___closeraw
0295c     00 94 0E F2 | 	cmp	local01, #0 wz
02960     00 96 0E A2 |  if_e	cmp	local02, #0 wz
02964     00 98 0E A2 |  if_e	cmp	local03, #0 wz
02968     3C 00 90 AD |  if_e	jmp	#LR__0302
0296c     0C 8A 06 F6 | 	mov	arg01, #12
02970     C8 04 B0 FD | 	call	#__system___gc_alloc_managed
02974     3A 9B 0A F6 | 	mov	local04, result1 wz
02978     18 00 90 5D |  if_ne	jmp	#LR__0301
0297c     30 8B 02 F6 | 	mov	arg01, abortchain
02980     07 8C 06 F6 | 	mov	arg02, #7
02984     01 8E 06 F6 | 	mov	arg03, #1
02988     1A 01 A0 FD | 	call	#__longjmp
0298c     01 74 66 F6 | 	neg	result1, #1
02990     C4 00 90 FD | 	jmp	#LR__0309
02994                 | LR__0301
02994     4D 01 68 FC | 	wrlong	#0, local04
02998     04 9A 06 F1 | 	add	local04, #4
0299c     4D 01 68 FC | 	wrlong	#0, local04
029a0     04 9A 86 F1 | 	sub	local04, #4
029a4     4E 9B 62 FC | 	wrlong	local04, local05
029a8                 | LR__0302
029a8     00 94 0E F2 | 	cmp	local01, #0 wz
029ac     1C 00 90 AD |  if_e	jmp	#LR__0303
029b0     4D 95 62 FC | 	wrlong	local01, local04
029b4     4D 75 02 F6 | 	mov	result1, local04
029b8     16 74 26 F4 | 	bith	result1, #22
029bc     1C 9C 06 F1 | 	add	local05, #28
029c0     4E 75 62 FC | 	wrlong	result1, local05
029c4     1C 9C 86 F1 | 	sub	local05, #28
029c8     0C 00 90 FD | 	jmp	#LR__0304
029cc                 | LR__0303
029cc     1C 9C 06 F1 | 	add	local05, #28
029d0     4E 01 68 FC | 	wrlong	#0, local05
029d4     1C 9C 86 F1 | 	sub	local05, #28
029d8                 | LR__0304
029d8     00 96 0E F2 | 	cmp	local02, #0 wz
029dc     28 00 90 AD |  if_e	jmp	#LR__0305
029e0     04 9A 06 F1 | 	add	local04, #4
029e4     4D 97 62 FC | 	wrlong	local02, local04
029e8     04 9A 86 F1 | 	sub	local04, #4
029ec     4D 75 02 F6 | 	mov	result1, local04
029f0     00 28 00 FF 
029f4     00 74 46 F5 | 	or	result1, ##5242880
029f8     20 9C 06 F1 | 	add	local05, #32
029fc     4E 75 62 FC | 	wrlong	result1, local05
02a00     20 9C 86 F1 | 	sub	local05, #32
02a04     0C 00 90 FD | 	jmp	#LR__0306
02a08                 | LR__0305
02a08     20 9C 06 F1 | 	add	local05, #32
02a0c     4E 01 68 FC | 	wrlong	#0, local05
02a10     20 9C 86 F1 | 	sub	local05, #32
02a14                 | LR__0306
02a14     00 98 0E F2 | 	cmp	local03, #0 wz
02a18     20 00 90 AD |  if_e	jmp	#LR__0307
02a1c     08 9A 06 F1 | 	add	local04, #8
02a20     4D 99 62 FC | 	wrlong	local03, local04
02a24     08 9A 86 F1 | 	sub	local04, #8
02a28     35 9A 26 F4 | 	bith	local04, #53
02a2c     24 9C 06 F1 | 	add	local05, #36
02a30     4E 9B 62 FC | 	wrlong	local04, local05
02a34     24 9C 86 F1 | 	sub	local05, #36
02a38     0C 00 90 FD | 	jmp	#LR__0308
02a3c                 | LR__0307
02a3c     24 9C 06 F1 | 	add	local05, #36
02a40     4E 01 68 FC | 	wrlong	#0, local05
02a44     24 9C 86 F1 | 	sub	local05, #36
02a48                 | LR__0308
02a48     08 9C 06 F1 | 	add	local05, #8
02a4c     40 00 80 FF 
02a50     4E 07 68 FC | 	wrlong	##32771, local05
02a54     00 74 06 F6 | 	mov	result1, #0
02a58                 | LR__0309
02a58     E7 F0 03 F6 | 	mov	ptra, fp
02a5c     F2 00 A0 FD | 	call	#popregs_
02a60                 | __system___basic_open_ret
02a60     2D 00 64 FD | 	ret
02a64                 | 
02a64                 | __system___basic_print_char
02a64     03 CA 05 F6 | 	mov	COUNT_, #3
02a68     E8 00 A0 FD | 	call	#pushregs_
02a6c     46 95 02 F6 | 	mov	local01, arg02
02a70     54 0E B0 FD | 	call	#__system___gettxfunc
02a74     3A 97 0A F6 | 	mov	local02, result1 wz
02a78     00 74 06 A6 |  if_e	mov	result1, #0
02a7c     30 00 90 AD |  if_e	jmp	#LR__0310
02a80     4B 99 02 F6 | 	mov	local03, local02
02a84     13 96 46 F7 | 	zerox	local02, #19
02a88     14 98 46 F0 | 	shr	local03, #20
02a8c     02 98 66 F0 | 	shl	local03, #2
02a90     2D 99 02 F1 | 	add	local03, __methods__
02a94     4C 99 02 FB | 	rdlong	local03, local03
02a98     4A 8B 02 F6 | 	mov	arg01, local01
02a9c     33 95 02 F6 | 	mov	local01, objptr
02aa0     4B 67 02 F6 | 	mov	objptr, local02
02aa4     2D 98 62 FD | 	call	local03
02aa8     4A 67 02 F6 | 	mov	objptr, local01
02aac     01 74 06 F6 | 	mov	result1, #1
02ab0                 | LR__0310
02ab0     E7 F0 03 F6 | 	mov	ptra, fp
02ab4     F2 00 A0 FD | 	call	#popregs_
02ab8                 | __system___basic_print_char_ret
02ab8     2D 00 64 FD | 	ret
02abc                 | 
02abc                 | __system___basic_print_string
02abc     03 CA 05 F6 | 	mov	COUNT_, #3
02ac0     E8 00 A0 FD | 	call	#pushregs_
02ac4     46 95 02 F6 | 	mov	local01, arg02
02ac8     47 97 02 F6 | 	mov	local02, arg03
02acc     F8 0D B0 FD | 	call	#__system___gettxfunc
02ad0     3A 99 0A F6 | 	mov	local03, result1 wz
02ad4     00 74 06 A6 |  if_e	mov	result1, #0
02ad8     18 00 90 AD |  if_e	jmp	#LR__0320
02adc     00 94 0E F2 | 	cmp	local01, #0 wz
02ae0     00 74 06 A6 |  if_e	mov	result1, #0
02ae4     4C 8B 02 56 |  if_ne	mov	arg01, local03
02ae8     4B 8D 02 56 |  if_ne	mov	arg02, local02
02aec     4A 8F 02 56 |  if_ne	mov	arg03, local01
02af0     0C 00 B0 5D |  if_ne	call	#__system___fmtstr
02af4                 | LR__0320
02af4     E7 F0 03 F6 | 	mov	ptra, fp
02af8     F2 00 A0 FD | 	call	#popregs_
02afc                 | __system___basic_print_string_ret
02afc     2D 00 64 FD | 	ret
02b00                 | 
02b00                 | __system___fmtstr
02b00     09 CA 05 F6 | 	mov	COUNT_, #9
02b04     E8 00 A0 FD | 	call	#pushregs_
02b08     45 95 02 F6 | 	mov	local01, arg01
02b0c     46 97 02 F6 | 	mov	local02, arg02
02b10     47 99 02 F6 | 	mov	local03, arg03
02b14     4B 91 E2 F8 | 	getbyte	arg04, local02, #0
02b18     4C 8B 02 F6 | 	mov	arg01, local03
02b1c     45 9B 02 F6 | 	mov	local04, arg01
02b20     D7 06 48 FB | 	callpa	#(@LR__0331-@LR__0330)>>2,fcache_load_ptr_
02b24                 | LR__0330
02b24     4D 75 CA FA | 	rdbyte	result1, local04 wz
02b28     01 9A 06 51 |  if_ne	add	local04, #1
02b2c     F4 FF 9F 5D |  if_ne	jmp	#LR__0330
02b30                 | LR__0331
02b30     45 9B 82 F1 | 	sub	local04, arg01
02b34     00 90 0E F2 | 	cmp	arg04, #0 wz
02b38     48 9B 7A 53 |  if_ne	fles	local04, arg04 wcz
02b3c     4B 8D 02 F6 | 	mov	arg02, local02
02b40     4D 8F 02 F6 | 	mov	arg03, local04
02b44     4A 8B 02 F6 | 	mov	arg01, local01
02b48     02 90 06 F6 | 	mov	arg04, #2
02b4c     6C 0C B0 FD | 	call	#__system___fmtpad
02b50     3A 9D 02 F6 | 	mov	local05, result1
02b54     00 9C 56 F2 | 	cmps	local05, #0 wc
02b58     4E 75 02 C6 |  if_b	mov	result1, local05
02b5c     80 00 90 CD |  if_b	jmp	#LR__0334
02b60     01 9A 56 F2 | 	cmps	local04, #1 wc
02b64     50 00 90 CD |  if_b	jmp	#LR__0333
02b68     4D 9F 02 F6 | 	mov	local06, local04
02b6c                 | LR__0332
02b6c     4A A1 02 F6 | 	mov	local07, local01
02b70     4A A3 02 F6 | 	mov	local08, local01
02b74     13 A0 46 F7 | 	zerox	local07, #19
02b78     14 A2 46 F0 | 	shr	local08, #20
02b7c     02 A2 66 F0 | 	shl	local08, #2
02b80     2D A3 02 F1 | 	add	local08, __methods__
02b84     51 A3 02 FB | 	rdlong	local08, local08
02b88     4C 8B C2 FA | 	rdbyte	arg01, local03
02b8c     33 A5 02 F6 | 	mov	local09, objptr
02b90     50 67 02 F6 | 	mov	objptr, local07
02b94     01 98 06 F1 | 	add	local03, #1
02b98     2D A2 62 FD | 	call	local08
02b9c     52 67 02 F6 | 	mov	objptr, local09
02ba0     3A A5 02 F6 | 	mov	local09, result1
02ba4     00 A4 56 F2 | 	cmps	local09, #0 wc
02ba8     52 75 02 C6 |  if_b	mov	result1, local09
02bac     30 00 90 CD |  if_b	jmp	#LR__0334
02bb0     52 9D 02 F1 | 	add	local05, local09
02bb4     ED 9F 6E FB | 	djnz	local06, #LR__0332
02bb8                 | LR__0333
02bb8     4B 8D 02 F6 | 	mov	arg02, local02
02bbc     4D 8F 02 F6 | 	mov	arg03, local04
02bc0     4A 8B 02 F6 | 	mov	arg01, local01
02bc4     01 90 06 F6 | 	mov	arg04, #1
02bc8     F0 0B B0 FD | 	call	#__system___fmtpad
02bcc     3A A5 02 F6 | 	mov	local09, result1
02bd0     00 A4 56 F2 | 	cmps	local09, #0 wc
02bd4     52 75 02 C6 |  if_b	mov	result1, local09
02bd8     52 9D 02 31 |  if_ae	add	local05, local09
02bdc     4E 75 02 36 |  if_ae	mov	result1, local05
02be0                 | LR__0334
02be0     E7 F0 03 F6 | 	mov	ptra, fp
02be4     F2 00 A0 FD | 	call	#popregs_
02be8                 | __system___fmtstr_ret
02be8     2D 00 64 FD | 	ret
02bec                 | 
02bec                 | __system___gc_ptrs
02bec     2C 7B 02 F6 | 	mov	_var01, __heap_ptr
02bf0     3D 7D 02 F6 | 	mov	_var02, _var01
02bf4     0B 00 00 FF 
02bf8     68 7D 06 F1 | 	add	_var02, ##5992
02bfc     3D 77 0A FB | 	rdlong	result2, _var01 wz
02c00     74 00 90 5D |  if_ne	jmp	#LR__0340
02c04     3E 77 02 F6 | 	mov	result2, _var02
02c08     3D 77 82 F1 | 	sub	result2, _var01
02c0c     3D 03 58 FC | 	wrword	#1, _var01
02c10     3D 75 02 F6 | 	mov	result1, _var01
02c14     02 74 06 F1 | 	add	result1, #2
02c18     36 00 80 FF 
02c1c     3A 21 59 FC | 	wrword	##27792, result1
02c20     3D 75 02 F6 | 	mov	result1, _var01
02c24     04 74 06 F1 | 	add	result1, #4
02c28     3A 01 58 FC | 	wrword	#0, result1
02c2c     3D 75 02 F6 | 	mov	result1, _var01
02c30     06 74 06 F1 | 	add	result1, #6
02c34     3A 03 58 FC | 	wrword	#1, result1
02c38     10 7A 06 F1 | 	add	_var01, #16
02c3c     3B 77 52 F6 | 	abs	result2, result2 wc
02c40     04 76 46 F0 | 	shr	result2, #4
02c44     3B 77 82 F6 | 	negc	result2, result2
02c48     3D 77 52 FC | 	wrword	result2, _var01
02c4c     3D 77 02 F6 | 	mov	result2, _var01
02c50     02 76 06 F1 | 	add	result2, #2
02c54     36 00 80 FF 
02c58     3B 1F 59 FC | 	wrword	##27791, result2
02c5c     3D 77 02 F6 | 	mov	result2, _var01
02c60     04 76 06 F1 | 	add	result2, #4
02c64     3B 01 58 FC | 	wrword	#0, result2
02c68     3D 77 02 F6 | 	mov	result2, _var01
02c6c     06 76 06 F1 | 	add	result2, #6
02c70     3B 01 58 FC | 	wrword	#0, result2
02c74     10 7A 86 F1 | 	sub	_var01, #16
02c78                 | LR__0340
02c78     3D 75 02 F6 | 	mov	result1, _var01
02c7c     3E 77 02 F6 | 	mov	result2, _var02
02c80                 | __system___gc_ptrs_ret
02c80     2D 00 64 FD | 	ret
02c84                 | 
02c84                 | __system___gc_tryalloc
02c84     0B CA 05 F6 | 	mov	COUNT_, #11
02c88     E8 00 A0 FD | 	call	#pushregs_
02c8c     45 95 02 F6 | 	mov	local01, arg01
02c90     46 97 02 F6 | 	mov	local02, arg02
02c94     54 FF BF FD | 	call	#__system___gc_ptrs
02c98     3A 99 02 F6 | 	mov	local03, result1
02c9c     3B 9B 02 F6 | 	mov	local04, result2
02ca0     4C 9D 02 F6 | 	mov	local05, local03
02ca4     00 9E 06 F6 | 	mov	local06, #0
02ca8     D7 1E 48 FB | 	callpa	#(@LR__0351-@LR__0350)>>2,fcache_load_ptr_
02cac                 | LR__0350
02cac     4E A1 02 F6 | 	mov	local07, local05
02cb0     06 9C 06 F1 | 	add	local05, #6
02cb4     4E 8D EA FA | 	rdword	arg02, local05 wz
02cb8     4C 8B 02 F6 | 	mov	arg01, local03
02cbc     00 74 06 A6 |  if_e	mov	result1, #0
02cc0     04 8C 66 50 |  if_ne	shl	arg02, #4
02cc4     46 8B 02 51 |  if_ne	add	arg01, arg02
02cc8     45 75 02 56 |  if_ne	mov	result1, arg01
02ccc     3A 9D 0A F6 | 	mov	local05, result1 wz
02cd0     4E 9F E2 5A |  if_ne	rdword	local06, local05
02cd4     00 9C 0E F2 | 	cmp	local05, #0 wz
02cd8     4D 9D 52 52 |  if_ne	cmps	local05, local04 wc
02cdc     08 00 90 1D |  if_a	jmp	#LR__0352
02ce0     4F 95 5A 52 |  if_ne	cmps	local01, local06 wcz
02ce4     C4 FF 9F 1D |  if_a	jmp	#LR__0350
02ce8                 | LR__0351
02ce8                 | LR__0352
02ce8     00 9C 0E F2 | 	cmp	local05, #0 wz
02cec     4E 75 02 A6 |  if_e	mov	result1, local05
02cf0     3C 01 90 AD |  if_e	jmp	#LR__0355
02cf4     4E 77 02 F6 | 	mov	result2, local05
02cf8     06 76 06 F1 | 	add	result2, #6
02cfc     3B A3 E2 FA | 	rdword	local08, result2
02d00     4F 95 52 F2 | 	cmps	local01, local06 wc
02d04     C0 00 90 3D |  if_ae	jmp	#LR__0354
02d08     4E 95 52 FC | 	wrword	local01, local05
02d0c     4E 8B 02 F6 | 	mov	arg01, local05
02d10     4A A3 02 F6 | 	mov	local08, local01
02d14     04 A2 66 F0 | 	shl	local08, #4
02d18     51 8B 02 F1 | 	add	arg01, local08
02d1c     4A 9F 82 F1 | 	sub	local06, local01
02d20     45 9F 52 FC | 	wrword	local06, arg01
02d24     45 A3 02 F6 | 	mov	local08, arg01
02d28     02 A2 06 F1 | 	add	local08, #2
02d2c     36 00 80 FF 
02d30     51 1F 59 FC | 	wrword	##27791, local08
02d34     4E 8D 0A F6 | 	mov	arg02, local05 wz
02d38     00 74 06 A6 |  if_e	mov	result1, #0
02d3c     4C 8D 82 51 |  if_ne	sub	arg02, local03
02d40     04 8C 46 50 |  if_ne	shr	arg02, #4
02d44     46 75 02 56 |  if_ne	mov	result1, arg02
02d48     45 A3 02 F6 | 	mov	local08, arg01
02d4c     04 A2 06 F1 | 	add	local08, #4
02d50     51 75 52 FC | 	wrword	result1, local08
02d54     4E A3 02 F6 | 	mov	local08, local05
02d58     06 A2 06 F1 | 	add	local08, #6
02d5c     45 8D 02 F6 | 	mov	arg02, arg01
02d60     51 A3 E2 FA | 	rdword	local08, local08
02d64     06 8C 06 F1 | 	add	arg02, #6
02d68     46 A3 52 FC | 	wrword	local08, arg02
02d6c     45 A5 02 F6 | 	mov	local09, arg01
02d70     52 8D 0A F6 | 	mov	arg02, local09 wz
02d74     00 74 06 A6 |  if_e	mov	result1, #0
02d78     4C 8D 82 51 |  if_ne	sub	arg02, local03
02d7c     04 8C 46 50 |  if_ne	shr	arg02, #4
02d80     46 75 02 56 |  if_ne	mov	result1, arg02
02d84     3A A3 02 F6 | 	mov	local08, result1
02d88     45 A7 EA FA | 	rdword	local10, arg01 wz
02d8c     00 74 06 A6 |  if_e	mov	result1, #0
02d90     04 A6 66 50 |  if_ne	shl	local10, #4
02d94     53 8B 02 51 |  if_ne	add	arg01, local10
02d98     45 75 02 56 |  if_ne	mov	result1, arg01
02d9c     3A A9 0A F6 | 	mov	local11, result1 wz
02da0     24 00 90 AD |  if_e	jmp	#LR__0353
02da4     4D A9 52 F2 | 	cmps	local11, local04 wc
02da8     1C 00 90 3D |  if_ae	jmp	#LR__0353
02dac     52 8D 0A F6 | 	mov	arg02, local09 wz
02db0     00 74 06 A6 |  if_e	mov	result1, #0
02db4     4C 8D 82 51 |  if_ne	sub	arg02, local03
02db8     04 8C 46 50 |  if_ne	shr	arg02, #4
02dbc     46 75 02 56 |  if_ne	mov	result1, arg02
02dc0     04 A8 06 F1 | 	add	local11, #4
02dc4     54 75 52 FC | 	wrword	result1, local11
02dc8                 | LR__0353
02dc8                 | LR__0354
02dc8     06 A0 06 F1 | 	add	local07, #6
02dcc     50 A3 52 FC | 	wrword	local08, local07
02dd0     36 00 00 FF 
02dd4     80 A4 06 F6 | 	mov	local09, ##27776
02dd8     4B A5 42 F5 | 	or	local09, local02
02ddc     00 74 06 F6 | 	mov	result1, #0
02de0     01 74 62 FD | 	cogid	result1
02de4     3A A5 42 F5 | 	or	local09, result1
02de8     4E A9 02 F6 | 	mov	local11, local05
02dec     02 A8 06 F1 | 	add	local11, #2
02df0     54 A5 52 FC | 	wrword	local09, local11
02df4     4C A5 02 F6 | 	mov	local09, local03
02df8     08 A4 06 F1 | 	add	local09, #8
02dfc     4E A9 02 F6 | 	mov	local11, local05
02e00     52 A5 E2 FA | 	rdword	local09, local09
02e04     06 A8 06 F1 | 	add	local11, #6
02e08     54 A5 52 FC | 	wrword	local09, local11
02e0c     4E 8D 0A F6 | 	mov	arg02, local05 wz
02e10     00 74 06 A6 |  if_e	mov	result1, #0
02e14     4C 8D 82 51 |  if_ne	sub	arg02, local03
02e18     04 8C 46 50 |  if_ne	shr	arg02, #4
02e1c     46 75 02 56 |  if_ne	mov	result1, arg02
02e20     08 98 06 F1 | 	add	local03, #8
02e24     4C 75 52 FC | 	wrword	result1, local03
02e28     08 9C 06 F1 | 	add	local05, #8
02e2c     4E 75 02 F6 | 	mov	result1, local05
02e30                 | LR__0355
02e30     E7 F0 03 F6 | 	mov	ptra, fp
02e34     F2 00 A0 FD | 	call	#popregs_
02e38                 | __system___gc_tryalloc_ret
02e38     2D 00 64 FD | 	ret
02e3c                 | 
02e3c                 | __system___gc_alloc_managed
02e3c     01 CA 05 F6 | 	mov	COUNT_, #1
02e40     E8 00 A0 FD | 	call	#pushregs_
02e44     45 95 02 F6 | 	mov	local01, arg01
02e48     00 8C 06 F6 | 	mov	arg02, #0
02e4c     1C 00 B0 FD | 	call	#__system___gc_doalloc
02e50     3A 8D 0A F6 | 	mov	arg02, result1 wz
02e54     01 94 56 A2 |  if_e	cmps	local01, #1 wc
02e58     00 74 06 26 |  if_nc_and_z	mov	result1, #0
02e5c     46 75 02 D6 |  if_c_or_nz	mov	result1, arg02
02e60     E7 F0 03 F6 | 	mov	ptra, fp
02e64     F2 00 A0 FD | 	call	#popregs_
02e68                 | __system___gc_alloc_managed_ret
02e68     2D 00 64 FD | 	ret
02e6c                 | 
02e6c                 | __system___gc_doalloc
02e6c     06 CA 05 F6 | 	mov	COUNT_, #6
02e70     E8 00 A0 FD | 	call	#pushregs_
02e74     45 95 0A F6 | 	mov	local01, arg01 wz
02e78     46 97 02 F6 | 	mov	local02, arg02
02e7c     00 74 06 A6 |  if_e	mov	result1, #0
02e80     84 00 90 AD |  if_e	jmp	#LR__0367
02e84     17 94 06 F1 | 	add	local01, #23
02e88     0F 94 26 F5 | 	andn	local01, #15
02e8c     04 94 46 F0 | 	shr	local01, #4
02e90     34 8B 02 F6 | 	mov	arg01, ptr___system__dat__
02e94     1C 8A 06 F1 | 	add	arg01, #28
02e98     90 F8 BF FD | 	call	#__system___lockmem
02e9c     4A 8B 02 F6 | 	mov	arg01, local01
02ea0     4B 8D 02 F6 | 	mov	arg02, local02
02ea4     DC FD BF FD | 	call	#__system___gc_tryalloc
02ea8     3A 99 0A F6 | 	mov	local03, result1 wz
02eac     14 00 90 5D |  if_ne	jmp	#LR__0360
02eb0     24 03 B0 FD | 	call	#__system___gc_docollect
02eb4     4A 8B 02 F6 | 	mov	arg01, local01
02eb8     4B 8D 02 F6 | 	mov	arg02, local02
02ebc     C4 FD BF FD | 	call	#__system___gc_tryalloc
02ec0     3A 99 02 F6 | 	mov	local03, result1
02ec4                 | LR__0360
02ec4     34 8B 02 F6 | 	mov	arg01, ptr___system__dat__
02ec8     1C 8A 06 F1 | 	add	arg01, #28
02ecc     45 01 68 FC | 	wrlong	#0, arg01
02ed0     00 98 0E F2 | 	cmp	local03, #0 wz
02ed4     2C 00 90 AD |  if_e	jmp	#LR__0366
02ed8     04 94 66 F0 | 	shl	local01, #4
02edc     08 94 86 F1 | 	sub	local01, #8
02ee0     4A 9B 52 F6 | 	abs	local04, local01 wc
02ee4     02 9A 46 F0 | 	shr	local04, #2
02ee8     4D 9D 8A F6 | 	negc	local05, local04 wz
02eec     4C 9F 02 F6 | 	mov	local06, local03
02ef0     10 00 90 AD |  if_e	jmp	#LR__0365
02ef4     D7 06 48 FB | 	callpa	#(@LR__0363-@LR__0361)>>2,fcache_load_ptr_
02ef8                 | LR__0361
02ef8     4E 05 D8 FC | 	rep	@LR__0364, local05
02efc                 | LR__0362
02efc     4F 01 68 FC | 	wrlong	#0, local06
02f00     04 9E 06 F1 | 	add	local06, #4
02f04                 | LR__0363
02f04                 | LR__0364
02f04                 | LR__0365
02f04                 | LR__0366
02f04     4C 75 02 F6 | 	mov	result1, local03
02f08                 | LR__0367
02f08     E7 F0 03 F6 | 	mov	ptra, fp
02f0c     F2 00 A0 FD | 	call	#popregs_
02f10                 | __system___gc_doalloc_ret
02f10     2D 00 64 FD | 	ret
02f14                 | 
02f14                 | __system___gc_isvalidptr
02f14     F8 8E 06 F4 | 	bitl	arg03, #248
02f18     08 8E 86 F1 | 	sub	arg03, #8
02f1c     45 8F 52 F2 | 	cmps	arg03, arg01 wc
02f20     08 00 90 CD |  if_b	jmp	#LR__0370
02f24     46 8F 52 F2 | 	cmps	arg03, arg02 wc
02f28     08 00 90 CD |  if_b	jmp	#LR__0371
02f2c                 | LR__0370
02f2c     00 74 06 F6 | 	mov	result1, #0
02f30     38 00 90 FD | 	jmp	#__system___gc_isvalidptr_ret
02f34                 | LR__0371
02f34     47 7B 02 F6 | 	mov	_var01, arg03
02f38     45 7B 62 F5 | 	xor	_var01, arg01
02f3c     0F 7A CE F7 | 	test	_var01, #15 wz
02f40     00 74 06 56 |  if_ne	mov	result1, #0
02f44     24 00 90 5D |  if_ne	jmp	#__system___gc_isvalidptr_ret
02f48     47 7B 02 F6 | 	mov	_var01, arg03
02f4c     02 7A 06 F1 | 	add	_var01, #2
02f50     3D 7B E2 FA | 	rdword	_var01, _var01
02f54     7F 00 00 FF 
02f58     C0 7B 06 F5 | 	and	_var01, ##65472
02f5c     36 00 00 FF 
02f60     80 7A 0E F2 | 	cmp	_var01, ##27776 wz
02f64     00 74 06 56 |  if_ne	mov	result1, #0
02f68     47 75 02 A6 |  if_e	mov	result1, arg03
02f6c                 | __system___gc_isvalidptr_ret
02f6c     2D 00 64 FD | 	ret
02f70                 | 
02f70                 | __system___gc_dofree
02f70     06 CA 05 F6 | 	mov	COUNT_, #6
02f74     E8 00 A0 FD | 	call	#pushregs_
02f78     45 95 02 F6 | 	mov	local01, arg01
02f7c     6C FC BF FD | 	call	#__system___gc_ptrs
02f80     3A 97 02 F6 | 	mov	local02, result1
02f84     3B 99 02 F6 | 	mov	local03, result2
02f88     4A 8D 02 F6 | 	mov	arg02, local01
02f8c     02 8C 06 F1 | 	add	arg02, #2
02f90     36 00 80 FF 
02f94     46 1F 59 FC | 	wrword	##27791, arg02
02f98     4A 9B 02 F6 | 	mov	local04, local01
02f9c     4A 8B 02 F6 | 	mov	arg01, local01
02fa0     45 9D EA FA | 	rdword	local05, arg01 wz
02fa4     00 74 06 A6 |  if_e	mov	result1, #0
02fa8     04 9C 66 50 |  if_ne	shl	local05, #4
02fac     4E 8B 02 51 |  if_ne	add	arg01, local05
02fb0     45 75 02 56 |  if_ne	mov	result1, arg01
02fb4     3A 9F 02 F6 | 	mov	local06, result1
02fb8     D7 24 48 FB | 	callpa	#(@LR__0381-@LR__0380)>>2,fcache_load_ptr_
02fbc                 | LR__0380
02fbc     04 9A 06 F1 | 	add	local04, #4
02fc0     4D 8D EA FA | 	rdword	arg02, local04 wz
02fc4     4B 8B 02 F6 | 	mov	arg01, local02
02fc8     00 74 06 A6 |  if_e	mov	result1, #0
02fcc     04 8C 66 50 |  if_ne	shl	arg02, #4
02fd0     46 8B 02 51 |  if_ne	add	arg01, arg02
02fd4     45 75 02 56 |  if_ne	mov	result1, arg01
02fd8     3A 9B 0A F6 | 	mov	local04, result1 wz
02fdc     24 00 90 AD |  if_e	jmp	#LR__0382
02fe0     4D 8B 02 F6 | 	mov	arg01, local04
02fe4     00 74 06 F6 | 	mov	result1, #0
02fe8     02 8A 06 F1 | 	add	arg01, #2
02fec     45 8B E2 FA | 	rdword	arg01, arg01
02ff0     36 00 00 FF 
02ff4     8F 8A 0E F2 | 	cmp	arg01, ##27791 wz
02ff8     01 74 66 A6 |  if_e	neg	result1, #1
02ffc     00 74 0E F2 | 	cmp	result1, #0 wz
03000     B8 FF 9F AD |  if_e	jmp	#LR__0380
03004                 | LR__0381
03004                 | LR__0382
03004     00 9A 0E F2 | 	cmp	local04, #0 wz
03008     4B 9B 02 A6 |  if_e	mov	local04, local02
0300c     4D 8D 02 F6 | 	mov	arg02, local04
03010     06 8C 06 F1 | 	add	arg02, #6
03014     4A 8B 02 F6 | 	mov	arg01, local01
03018     46 8D E2 FA | 	rdword	arg02, arg02
0301c     06 8A 06 F1 | 	add	arg01, #6
03020     45 8D 52 FC | 	wrword	arg02, arg01
03024     4A 8D 0A F6 | 	mov	arg02, local01 wz
03028     00 74 06 A6 |  if_e	mov	result1, #0
0302c     4B 8D 82 51 |  if_ne	sub	arg02, local02
03030     04 8C 46 50 |  if_ne	shr	arg02, #4
03034     46 75 02 56 |  if_ne	mov	result1, arg02
03038     4D 8D 02 F6 | 	mov	arg02, local04
0303c     06 8C 06 F1 | 	add	arg02, #6
03040     46 75 52 FC | 	wrword	result1, arg02
03044     4B 9B 0A F2 | 	cmp	local04, local02 wz
03048     A4 00 90 AD |  if_e	jmp	#LR__0385
0304c     4D 8B 02 F6 | 	mov	arg01, local04
03050     45 9D EA FA | 	rdword	local05, arg01 wz
03054     00 74 06 A6 |  if_e	mov	result1, #0
03058     04 9C 66 50 |  if_ne	shl	local05, #4
0305c     4E 8B 02 51 |  if_ne	add	arg01, local05
03060     45 75 02 56 |  if_ne	mov	result1, arg01
03064     4A 75 0A F2 | 	cmp	result1, local01 wz
03068     84 00 90 5D |  if_ne	jmp	#LR__0384
0306c     4D 9F E2 FA | 	rdword	local06, local04
03070     4A 8D E2 FA | 	rdword	arg02, local01
03074     46 9F 02 F1 | 	add	local06, arg02
03078     4D 9F 52 FC | 	wrword	local06, local04
0307c     4A 9F 02 F6 | 	mov	local06, local01
03080     02 9E 06 F1 | 	add	local06, #2
03084     4F 01 58 FC | 	wrword	#0, local06
03088     4A 8B 02 F6 | 	mov	arg01, local01
0308c     45 9D EA FA | 	rdword	local05, arg01 wz
03090     00 74 06 A6 |  if_e	mov	result1, #0
03094     04 9C 66 50 |  if_ne	shl	local05, #4
03098     4E 8B 02 51 |  if_ne	add	arg01, local05
0309c     45 75 02 56 |  if_ne	mov	result1, arg01
030a0     3A 9F 02 F6 | 	mov	local06, result1
030a4     4C 9F 52 F2 | 	cmps	local06, local03 wc
030a8     20 00 90 3D |  if_ae	jmp	#LR__0383
030ac     4D 8D 0A F6 | 	mov	arg02, local04 wz
030b0     00 74 06 A6 |  if_e	mov	result1, #0
030b4     4B 8D 82 51 |  if_ne	sub	arg02, local02
030b8     04 8C 46 50 |  if_ne	shr	arg02, #4
030bc     46 75 02 56 |  if_ne	mov	result1, arg02
030c0     4F 8D 02 F6 | 	mov	arg02, local06
030c4     04 8C 06 F1 | 	add	arg02, #4
030c8     46 75 52 FC | 	wrword	result1, arg02
030cc                 | LR__0383
030cc     4A 8D 02 F6 | 	mov	arg02, local01
030d0     06 8C 06 F1 | 	add	arg02, #6
030d4     4D 77 02 F6 | 	mov	result2, local04
030d8     46 8D E2 FA | 	rdword	arg02, arg02
030dc     06 76 06 F1 | 	add	result2, #6
030e0     3B 8D 52 FC | 	wrword	arg02, result2
030e4     06 94 06 F1 | 	add	local01, #6
030e8     4A 01 58 FC | 	wrword	#0, local01
030ec     4D 95 02 F6 | 	mov	local01, local04
030f0                 | LR__0384
030f0                 | LR__0385
030f0     4A 8B 02 F6 | 	mov	arg01, local01
030f4     45 9D EA FA | 	rdword	local05, arg01 wz
030f8     00 74 06 A6 |  if_e	mov	result1, #0
030fc     04 9C 66 50 |  if_ne	shl	local05, #4
03100     4E 8B 02 51 |  if_ne	add	arg01, local05
03104     45 75 02 56 |  if_ne	mov	result1, arg01
03108     3A 8D 0A F6 | 	mov	arg02, result1 wz
0310c     B8 00 90 AD |  if_e	jmp	#LR__0387
03110     4C 8D 52 F2 | 	cmps	arg02, local03 wc
03114     B0 00 90 3D |  if_ae	jmp	#LR__0387
03118     46 8B 02 F6 | 	mov	arg01, arg02
0311c     00 74 06 F6 | 	mov	result1, #0
03120     02 8A 06 F1 | 	add	arg01, #2
03124     45 8B E2 FA | 	rdword	arg01, arg01
03128     36 00 00 FF 
0312c     8F 8A 0E F2 | 	cmp	arg01, ##27791 wz
03130     01 74 66 A6 |  if_e	neg	result1, #1
03134     00 74 0E F2 | 	cmp	result1, #0 wz
03138     8C 00 90 AD |  if_e	jmp	#LR__0387
0313c     4A 9B 02 F6 | 	mov	local04, local01
03140     4D 9F E2 FA | 	rdword	local06, local04
03144     46 8B 02 F6 | 	mov	arg01, arg02
03148     45 95 E2 FA | 	rdword	local01, arg01
0314c     4A 9F 02 F1 | 	add	local06, local01
03150     4D 9F 52 FC | 	wrword	local06, local04
03154     45 9F 02 F6 | 	mov	local06, arg01
03158     06 9E 06 F1 | 	add	local06, #6
0315c     4D 95 02 F6 | 	mov	local01, local04
03160     4F 9F E2 FA | 	rdword	local06, local06
03164     06 94 06 F1 | 	add	local01, #6
03168     4A 9F 52 FC | 	wrword	local06, local01
0316c     45 9F 02 F6 | 	mov	local06, arg01
03170     02 9E 06 F1 | 	add	local06, #2
03174     4F 55 59 FC | 	wrword	#170, local06
03178     45 9F 02 F6 | 	mov	local06, arg01
0317c     06 9E 06 F1 | 	add	local06, #6
03180     4F 01 58 FC | 	wrword	#0, local06
03184     45 9D EA FA | 	rdword	local05, arg01 wz
03188     00 74 06 A6 |  if_e	mov	result1, #0
0318c     04 9C 66 50 |  if_ne	shl	local05, #4
03190     4E 8B 02 51 |  if_ne	add	arg01, local05
03194     45 75 02 56 |  if_ne	mov	result1, arg01
03198     3A 9F 0A F6 | 	mov	local06, result1 wz
0319c     28 00 90 AD |  if_e	jmp	#LR__0386
031a0     4C 9F 52 F2 | 	cmps	local06, local03 wc
031a4     20 00 90 3D |  if_ae	jmp	#LR__0386
031a8     4D 8D 0A F6 | 	mov	arg02, local04 wz
031ac     00 74 06 A6 |  if_e	mov	result1, #0
031b0     4B 8D 82 51 |  if_ne	sub	arg02, local02
031b4     04 8C 46 50 |  if_ne	shr	arg02, #4
031b8     46 75 02 56 |  if_ne	mov	result1, arg02
031bc     4F 9B 02 F6 | 	mov	local04, local06
031c0     04 9A 06 F1 | 	add	local04, #4
031c4     4D 75 52 FC | 	wrword	result1, local04
031c8                 | LR__0386
031c8                 | LR__0387
031c8     4F 75 02 F6 | 	mov	result1, local06
031cc     E7 F0 03 F6 | 	mov	ptra, fp
031d0     F2 00 A0 FD | 	call	#popregs_
031d4                 | __system___gc_dofree_ret
031d4     2D 00 64 FD | 	ret
031d8                 | 
031d8                 | __system___gc_docollect
031d8     05 CA 05 F6 | 	mov	COUNT_, #5
031dc     E8 00 A0 FD | 	call	#pushregs_
031e0     08 FA BF FD | 	call	#__system___gc_ptrs
031e4     3B 95 02 F6 | 	mov	local01, result2
031e8     3A 97 02 F6 | 	mov	local02, result1
031ec     4B 8B 02 F6 | 	mov	arg01, local02
031f0     45 99 EA FA | 	rdword	local03, arg01 wz
031f4     00 74 06 A6 |  if_e	mov	result1, #0
031f8     04 98 66 50 |  if_ne	shl	local03, #4
031fc     4C 8B 02 51 |  if_ne	add	arg01, local03
03200     45 75 02 56 |  if_ne	mov	result1, arg01
03204     3A 9B 0A F6 | 	mov	local04, result1 wz
03208     00 74 06 F6 | 	mov	result1, #0
0320c     01 74 62 FD | 	cogid	result1
03210     3A 9D 02 F6 | 	mov	local05, result1
03214     48 00 90 AD |  if_e	jmp	#LR__0392
03218     D7 22 48 FB | 	callpa	#(@LR__0391-@LR__0390)>>2,fcache_load_ptr_
0321c                 | LR__0390
0321c     4A 9B 52 F2 | 	cmps	local04, local01 wc
03220     3C 00 90 3D |  if_ae	jmp	#LR__0392
03224     4D 8D 02 F6 | 	mov	arg02, local04
03228     02 8C 06 F1 | 	add	arg02, #2
0322c     46 8D E2 FA | 	rdword	arg02, arg02
03230     20 8C 26 F5 | 	andn	arg02, #32
03234     4D 8B 02 F6 | 	mov	arg01, local04
03238     02 8A 06 F1 | 	add	arg01, #2
0323c     45 8D 52 FC | 	wrword	arg02, arg01
03240     4D 8B 02 F6 | 	mov	arg01, local04
03244     45 99 EA FA | 	rdword	local03, arg01 wz
03248     00 74 06 A6 |  if_e	mov	result1, #0
0324c     04 98 66 50 |  if_ne	shl	local03, #4
03250     4C 8B 02 51 |  if_ne	add	arg01, local03
03254     45 75 02 56 |  if_ne	mov	result1, arg01
03258     3A 9B 0A F6 | 	mov	local04, result1 wz
0325c     BC FF 9F 5D |  if_ne	jmp	#LR__0390
03260                 | LR__0391
03260                 | LR__0392
03260     00 98 06 F6 | 	mov	local03, #0
03264     00 8A 06 F6 | 	mov	arg01, #0
03268     98 F4 BF FD | 	call	#__system____topofstack
0326c     3A 8D 02 F6 | 	mov	arg02, result1
03270     4C 8B 02 F6 | 	mov	arg01, local03
03274     90 00 B0 FD | 	call	#__system___gc_markhub
03278     1C 01 B0 FD | 	call	#__system___gc_markcog
0327c     4B 8B 02 F6 | 	mov	arg01, local02
03280     45 99 EA FA | 	rdword	local03, arg01 wz
03284     00 74 06 A6 |  if_e	mov	result1, #0
03288     04 98 66 50 |  if_ne	shl	local03, #4
0328c     4C 8B 02 51 |  if_ne	add	arg01, local03
03290     45 75 02 56 |  if_ne	mov	result1, arg01
03294     3A 97 0A F6 | 	mov	local02, result1 wz
03298     60 00 90 AD |  if_e	jmp	#LR__0396
0329c                 | LR__0393
0329c     4B 9B 02 F6 | 	mov	local04, local02
032a0     4D 8B 02 F6 | 	mov	arg01, local04
032a4     45 99 EA FA | 	rdword	local03, arg01 wz
032a8     00 74 06 A6 |  if_e	mov	result1, #0
032ac     04 98 66 50 |  if_ne	shl	local03, #4
032b0     4C 8B 02 51 |  if_ne	add	arg01, local03
032b4     45 75 02 56 |  if_ne	mov	result1, arg01
032b8     3A 97 02 F6 | 	mov	local02, result1
032bc     4D 8D 02 F6 | 	mov	arg02, local04
032c0     02 8C 06 F1 | 	add	arg02, #2
032c4     46 8D E2 FA | 	rdword	arg02, arg02
032c8     20 8C CE F7 | 	test	arg02, #32 wz
032cc     10 8C CE A7 |  if_e	test	arg02, #16 wz
032d0     1C 00 90 5D |  if_ne	jmp	#LR__0395
032d4     46 8D 42 F8 | 	getnib	arg02, arg02, #0
032d8     4E 8D 0A F2 | 	cmp	arg02, local05 wz
032dc     0E 8C 0E 52 |  if_ne	cmp	arg02, #14 wz
032e0     0C 00 90 5D |  if_ne	jmp	#LR__0394
032e4     4D 8B 02 F6 | 	mov	arg01, local04
032e8     84 FC BF FD | 	call	#__system___gc_dofree
032ec     3A 97 02 F6 | 	mov	local02, result1
032f0                 | LR__0394
032f0                 | LR__0395
032f0     00 96 0E F2 | 	cmp	local02, #0 wz
032f4     4A 97 52 52 |  if_ne	cmps	local02, local01 wc
032f8     A0 FF 9F 4D |  if_c_and_nz	jmp	#LR__0393
032fc                 | LR__0396
032fc     E7 F0 03 F6 | 	mov	ptra, fp
03300     F2 00 A0 FD | 	call	#popregs_
03304                 | __system___gc_docollect_ret
03304     2D 00 64 FD | 	ret
03308                 | 
03308                 | __system___gc_markhub
03308     04 CA 05 F6 | 	mov	COUNT_, #4
0330c     E8 00 A0 FD | 	call	#pushregs_
03310     45 95 02 F6 | 	mov	local01, arg01
03314     46 97 02 F6 | 	mov	local02, arg02
03318     D0 F8 BF FD | 	call	#__system___gc_ptrs
0331c     3A 99 02 F6 | 	mov	local03, result1
03320     3B 9B 02 F6 | 	mov	local04, result2
03324                 | LR__0400
03324     4B 95 52 F2 | 	cmps	local01, local02 wc
03328     60 00 90 3D |  if_ae	jmp	#LR__0401
0332c     4A 8F 02 FB | 	rdlong	arg03, local01
03330     04 94 06 F1 | 	add	local01, #4
03334     4D 8D 02 F6 | 	mov	arg02, local04
03338     4C 8B 02 F6 | 	mov	arg01, local03
0333c     D4 FB BF FD | 	call	#__system___gc_isvalidptr
03340     3A 8F 0A F6 | 	mov	arg03, result1 wz
03344     DC FF 9F AD |  if_e	jmp	#LR__0400
03348     47 8B 02 F6 | 	mov	arg01, arg03
0334c     00 74 06 F6 | 	mov	result1, #0
03350     02 8A 06 F1 | 	add	arg01, #2
03354     45 8B E2 FA | 	rdword	arg01, arg01
03358     36 00 00 FF 
0335c     8F 8A 0E F2 | 	cmp	arg01, ##27791 wz
03360     01 74 66 A6 |  if_e	neg	result1, #1
03364     00 74 0E F2 | 	cmp	result1, #0 wz
03368     B8 FF 9F 5D |  if_ne	jmp	#LR__0400
0336c     47 77 02 F6 | 	mov	result2, arg03
03370     02 76 06 F1 | 	add	result2, #2
03374     3B 77 E2 FA | 	rdword	result2, result2
03378     0F 76 26 F5 | 	andn	result2, #15
0337c     2E 76 46 F5 | 	or	result2, #46
03380     02 8E 06 F1 | 	add	arg03, #2
03384     47 77 52 FC | 	wrword	result2, arg03
03388     98 FF 9F FD | 	jmp	#LR__0400
0338c                 | LR__0401
0338c     E7 F0 03 F6 | 	mov	ptra, fp
03390     F2 00 A0 FD | 	call	#popregs_
03394                 | __system___gc_markhub_ret
03394     2D 00 64 FD | 	ret
03398                 | 
03398                 | __system___gc_markcog
03398     04 CA 05 F6 | 	mov	COUNT_, #4
0339c     E8 00 A0 FD | 	call	#pushregs_
033a0     48 F8 BF FD | 	call	#__system___gc_ptrs
033a4     3A 95 02 F6 | 	mov	local01, result1
033a8     3B 97 02 F6 | 	mov	local02, result2
033ac     EF 99 06 F6 | 	mov	local03, #495
033b0                 | LR__0410
033b0                 | 	'.live	local03
033b0     00 98 96 F9 | 	alts	local03, #0
033b4     4C 9B 02 F6 | 	mov	local04, local03
033b8     4A 8B 02 F6 | 	mov	arg01, local01
033bc     4B 8D 02 F6 | 	mov	arg02, local02
033c0     4D 8F 02 F6 | 	mov	arg03, local04
033c4     4C FB BF FD | 	call	#__system___gc_isvalidptr
033c8     00 74 0E F2 | 	cmp	result1, #0 wz
033cc     18 00 90 AD |  if_e	jmp	#LR__0411
033d0     3A 9B 02 F6 | 	mov	local04, result1
033d4     02 9A 06 F1 | 	add	local04, #2
033d8     4D 9B E2 FA | 	rdword	local04, local04
033dc     20 9A 46 F5 | 	or	local04, #32
033e0     02 74 06 F1 | 	add	result1, #2
033e4     3A 9B 52 FC | 	wrword	local04, result1
033e8                 | LR__0411
033e8     01 98 86 F1 | 	sub	local03, #1
033ec     00 98 56 F2 | 	cmps	local03, #0 wc
033f0     BC FF 9F 3D |  if_ae	jmp	#LR__0410
033f4     E7 F0 03 F6 | 	mov	ptra, fp
033f8     F2 00 A0 FD | 	call	#popregs_
033fc                 | __system___gc_markcog_ret
033fc     2D 00 64 FD | 	ret
03400                 | 
03400                 | __system___closeraw
03400     05 CA 05 F6 | 	mov	COUNT_, #5
03404     E8 00 A0 FD | 	call	#pushregs_
03408     45 95 02 F6 | 	mov	local01, arg01
0340c     00 96 06 F6 | 	mov	local02, #0
03410     08 94 06 F1 | 	add	local01, #8
03414     4A 75 0A FB | 	rdlong	result1, local01 wz
03418     08 94 86 F1 | 	sub	local01, #8
0341c     20 68 06 A1 |  if_e	add	ptr___system__dat__, #32
03420     34 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
03424     20 68 86 A1 |  if_e	sub	ptr___system__dat__, #32
03428     01 74 66 A6 |  if_e	neg	result1, #1
0342c     A8 00 90 AD |  if_e	jmp	#LR__0422
03430     2C 94 06 F1 | 	add	local01, #44
03434     4A 75 0A FB | 	rdlong	result1, local01 wz
03438     2C 94 86 F1 | 	sub	local01, #44
0343c     38 00 90 AD |  if_e	jmp	#LR__0420
03440     2C 94 06 F1 | 	add	local01, #44
03444     4A 99 02 FB | 	rdlong	local03, local01
03448     4C 9B 02 F6 | 	mov	local04, local03
0344c     2C 94 86 F1 | 	sub	local01, #44
03450     13 9A 46 F7 | 	zerox	local04, #19
03454     14 98 46 F0 | 	shr	local03, #20
03458     02 98 66 F0 | 	shl	local03, #2
0345c     2D 99 02 F1 | 	add	local03, __methods__
03460     4C 99 02 FB | 	rdlong	local03, local03
03464     4A 8B 02 F6 | 	mov	arg01, local01
03468     33 9D 02 F6 | 	mov	local05, objptr
0346c     4D 67 02 F6 | 	mov	objptr, local04
03470     2D 98 62 FD | 	call	local03
03474     4E 67 02 F6 | 	mov	objptr, local05
03478                 | LR__0420
03478     24 94 06 F1 | 	add	local01, #36
0347c     4A 9D 0A FB | 	rdlong	local05, local01 wz
03480     24 94 86 F1 | 	sub	local01, #36
03484     3C 00 90 AD |  if_e	jmp	#LR__0421
03488     24 94 06 F1 | 	add	local01, #36
0348c     4A 99 02 FB | 	rdlong	local03, local01
03490     4C 9B 02 F6 | 	mov	local04, local03
03494     24 94 86 F1 | 	sub	local01, #36
03498     13 9A 46 F7 | 	zerox	local04, #19
0349c     14 98 46 F0 | 	shr	local03, #20
034a0     02 98 66 F0 | 	shl	local03, #2
034a4     2D 99 02 F1 | 	add	local03, __methods__
034a8     4C 99 02 FB | 	rdlong	local03, local03
034ac     4A 8B 02 F6 | 	mov	arg01, local01
034b0     33 9D 02 F6 | 	mov	local05, objptr
034b4     4D 67 02 F6 | 	mov	objptr, local04
034b8     2D 98 62 FD | 	call	local03
034bc     4E 67 02 F6 | 	mov	objptr, local05
034c0     3A 97 02 F6 | 	mov	local02, result1
034c4                 | LR__0421
034c4     4A 8B 02 F6 | 	mov	arg01, local01
034c8     00 8C 06 F6 | 	mov	arg02, #0
034cc     34 8E 06 F6 | 	mov	arg03, #52
034d0     D8 00 A0 FD | 	call	#\builtin_bytefill_
034d4     4B 75 02 F6 | 	mov	result1, local02
034d8                 | LR__0422
034d8     E7 F0 03 F6 | 	mov	ptra, fp
034dc     F2 00 A0 FD | 	call	#popregs_
034e0                 | __system___closeraw_ret
034e0     2D 00 64 FD | 	ret
034e4                 | 
034e4                 | __system____default_getc
034e4     03 CA 05 F6 | 	mov	COUNT_, #3
034e8     E8 00 A0 FD | 	call	#pushregs_
034ec     45 95 02 F6 | 	mov	local01, arg01
034f0     4A 97 02 FB | 	rdlong	local02, local01
034f4     08 94 06 F1 | 	add	local01, #8
034f8     4A 99 02 FB | 	rdlong	local03, local01
034fc     08 94 86 F1 | 	sub	local01, #8
03500     08 98 CE F7 | 	test	local03, #8 wz
03504     4A 8B 02 56 |  if_ne	mov	arg01, local01
03508     08 01 B0 5D |  if_ne	call	#__system____default_flush
0350c     08 94 06 F1 | 	add	local01, #8
03510     4A 99 02 FB | 	rdlong	local03, local01
03514     04 98 46 F5 | 	or	local03, #4
03518     4A 99 62 FC | 	wrlong	local03, local01
0351c     08 94 86 F1 | 	sub	local01, #8
03520     4B 99 0A FB | 	rdlong	local03, local02 wz
03524     0C 00 90 5D |  if_ne	jmp	#LR__0430
03528     4A 8B 02 F6 | 	mov	arg01, local01
0352c     38 04 B0 FD | 	call	#__system____default_filbuf
03530     3A 99 02 F6 | 	mov	local03, result1
03534                 | LR__0430
03534     01 98 56 F2 | 	cmps	local03, #1 wc
03538     01 74 66 C6 |  if_b	neg	result1, #1
0353c     1C 00 90 CD |  if_b	jmp	#LR__0431
03540     01 98 86 F1 | 	sub	local03, #1
03544     4B 99 62 FC | 	wrlong	local03, local02
03548     04 96 06 F1 | 	add	local02, #4
0354c     4B 99 02 FB | 	rdlong	local03, local02
03550     4C 75 C2 FA | 	rdbyte	result1, local03
03554     01 98 06 F1 | 	add	local03, #1
03558     4B 99 62 FC | 	wrlong	local03, local02
0355c                 | LR__0431
0355c     E7 F0 03 F6 | 	mov	ptra, fp
03560     F2 00 A0 FD | 	call	#popregs_
03564                 | __system____default_getc_ret
03564     2D 00 64 FD | 	ret
03568                 | 
03568                 | __system____default_putc
03568     06 CA 05 F6 | 	mov	COUNT_, #6
0356c     E8 00 A0 FD | 	call	#pushregs_
03570     45 95 02 F6 | 	mov	local01, arg01
03574     46 97 02 F6 | 	mov	local02, arg02
03578     4B 99 02 FB | 	rdlong	local03, local02
0357c     08 96 06 F1 | 	add	local02, #8
03580     4B 8D 02 FB | 	rdlong	arg02, local02
03584     08 96 86 F1 | 	sub	local02, #8
03588     04 8C CE F7 | 	test	arg02, #4 wz
0358c     4B 8B 02 56 |  if_ne	mov	arg01, local02
03590     80 00 B0 5D |  if_ne	call	#__system____default_flush
03594     08 96 06 F1 | 	add	local02, #8
03598     4B 9B 02 FB | 	rdlong	local04, local02
0359c     08 9A 46 F5 | 	or	local04, #8
035a0     4B 9B 62 FC | 	wrlong	local04, local02
035a4     4C 9D 02 FB | 	rdlong	local05, local03
035a8     0C 98 06 F1 | 	add	local03, #12
035ac     4C 8D 02 FB | 	rdlong	arg02, local03
035b0     0C 98 86 F1 | 	sub	local03, #12
035b4     4E 75 02 F6 | 	mov	result1, local05
035b8     46 75 02 F1 | 	add	result1, arg02
035bc     3A 95 42 FC | 	wrbyte	local01, result1
035c0     4A 95 E2 F8 | 	getbyte	local01, local01, #0
035c4     01 9C 06 F1 | 	add	local05, #1
035c8     4C 9D 62 FC | 	wrlong	local05, local03
035cc     02 96 86 F1 | 	sub	local02, #2
035d0     4B 9F EA FA | 	rdword	local06, local02 wz
035d4     06 96 86 F1 | 	sub	local02, #6
035d8     08 98 06 51 |  if_ne	add	local03, #8
035dc     4C 9B 02 5B |  if_ne	rdlong	local04, local03
035e0     4D 9D 0A 52 |  if_ne	cmp	local05, local04 wz
035e4     0C 00 90 AD |  if_e	jmp	#LR__0440
035e8     0A 94 0E F2 | 	cmp	local01, #10 wz
035ec     01 9E 0E A2 |  if_e	cmp	local06, #1 wz
035f0     10 00 90 5D |  if_ne	jmp	#LR__0441
035f4                 | LR__0440
035f4     4B 8B 02 F6 | 	mov	arg01, local02
035f8     18 00 B0 FD | 	call	#__system____default_flush
035fc     00 74 0E F2 | 	cmp	result1, #0 wz
03600     01 94 66 56 |  if_ne	neg	local01, #1
03604                 | LR__0441
03604     4A 75 02 F6 | 	mov	result1, local01
03608     E7 F0 03 F6 | 	mov	ptra, fp
0360c     F2 00 A0 FD | 	call	#popregs_
03610                 | __system____default_putc_ret
03610     2D 00 64 FD | 	ret
03614                 | 
03614                 | __system____default_flush
03614     07 CA 05 F6 | 	mov	COUNT_, #7
03618     E8 00 A0 FD | 	call	#pushregs_
0361c     45 95 02 F6 | 	mov	local01, arg01
03620     4A 97 02 FB | 	rdlong	local02, local01
03624     4B 99 02 FB | 	rdlong	local03, local02
03628     08 94 06 F1 | 	add	local01, #8
0362c     4A 77 02 FB | 	rdlong	result2, local01
03630     08 94 86 F1 | 	sub	local01, #8
03634     08 76 CE F7 | 	test	result2, #8 wz
03638     D4 00 90 AD |  if_e	jmp	#LR__0452
0363c     01 98 56 F2 | 	cmps	local03, #1 wc
03640     2C 01 90 CD |  if_b	jmp	#LR__0454
03644     08 94 06 F1 | 	add	local01, #8
03648     4A 77 02 FB | 	rdlong	result2, local01
0364c     08 94 86 F1 | 	sub	local01, #8
03650     80 76 CE F7 | 	test	result2, #128 wz
03654     6C 00 90 AD |  if_e	jmp	#LR__0451
03658     08 94 06 F1 | 	add	local01, #8
0365c     4A 8F 02 FB | 	rdlong	arg03, local01
03660     08 94 86 F1 | 	sub	local01, #8
03664     00 8F CE F7 | 	test	arg03, #256 wz
03668     58 00 90 AD |  if_e	jmp	#LR__0450
0366c     30 94 06 F1 | 	add	local01, #48
03670     4A 9B 02 FB | 	rdlong	local04, local01
03674     4D 9D 02 F6 | 	mov	local05, local04
03678     30 94 86 F1 | 	sub	local01, #48
0367c     13 9C 46 F7 | 	zerox	local05, #19
03680     14 9A 46 F0 | 	shr	local04, #20
03684     02 9A 66 F0 | 	shl	local04, #2
03688     2D 9B 02 F1 | 	add	local04, __methods__
0368c     4D 9B 02 FB | 	rdlong	local04, local04
03690     4A 8B 02 F6 | 	mov	arg01, local01
03694     00 8C 06 F6 | 	mov	arg02, #0
03698     00 8E 06 F6 | 	mov	arg03, #0
0369c     02 90 06 F6 | 	mov	arg04, #2
036a0     33 9F 02 F6 | 	mov	local06, objptr
036a4     4E 67 02 F6 | 	mov	objptr, local05
036a8     2D 9A 62 FD | 	call	local04
036ac     4F 67 02 F6 | 	mov	objptr, local06
036b0     08 94 06 F1 | 	add	local01, #8
036b4     4A 9F 02 FB | 	rdlong	local06, local01
036b8     00 9F 26 F5 | 	andn	local06, #256
036bc     4A 9F 62 FC | 	wrlong	local06, local01
036c0     08 94 86 F1 | 	sub	local01, #8
036c4                 | LR__0450
036c4                 | LR__0451
036c4     18 94 06 F1 | 	add	local01, #24
036c8     4A 9B 02 FB | 	rdlong	local04, local01
036cc     4D 9D 02 F6 | 	mov	local05, local04
036d0     18 94 86 F1 | 	sub	local01, #24
036d4     13 9C 46 F7 | 	zerox	local05, #19
036d8     14 9A 46 F0 | 	shr	local04, #20
036dc     02 9A 66 F0 | 	shl	local04, #2
036e0     2D 9B 02 F1 | 	add	local04, __methods__
036e4     4D 9B 02 FB | 	rdlong	local04, local04
036e8     0C 96 06 F1 | 	add	local02, #12
036ec     4B 8D 02 FB | 	rdlong	arg02, local02
036f0     0C 96 86 F1 | 	sub	local02, #12
036f4     4A 8B 02 F6 | 	mov	arg01, local01
036f8     4C 8F 02 F6 | 	mov	arg03, local03
036fc     33 9F 02 F6 | 	mov	local06, objptr
03700     4E 67 02 F6 | 	mov	objptr, local05
03704     2D 9A 62 FD | 	call	local04
03708     4F 67 02 F6 | 	mov	objptr, local06
0370c     60 00 90 FD | 	jmp	#LR__0454
03710                 | LR__0452
03710     08 94 06 F1 | 	add	local01, #8
03714     4A 9F 02 FB | 	rdlong	local06, local01
03718     08 94 86 F1 | 	sub	local01, #8
0371c     04 9E CE F7 | 	test	local06, #4 wz
03720     00 98 0E 52 |  if_ne	cmp	local03, #0 wz
03724     48 00 90 AD |  if_e	jmp	#LR__0453
03728     4C 8D 62 F6 | 	neg	arg02, local03
0372c     46 8F 02 F6 | 	mov	arg03, arg02
03730     1F 8E C6 F0 | 	sar	arg03, #31
03734     30 94 06 F1 | 	add	local01, #48
03738     4A 9B 02 FB | 	rdlong	local04, local01
0373c     4D 9D 02 F6 | 	mov	local05, local04
03740     30 94 86 F1 | 	sub	local01, #48
03744     13 9C 46 F7 | 	zerox	local05, #19
03748     14 9A 46 F0 | 	shr	local04, #20
0374c     02 9A 66 F0 | 	shl	local04, #2
03750     2D 9B 02 F1 | 	add	local04, __methods__
03754     4D 9B 02 FB | 	rdlong	local04, local04
03758     4A 8B 02 F6 | 	mov	arg01, local01
0375c     01 90 06 F6 | 	mov	arg04, #1
03760     33 9F 02 F6 | 	mov	local06, objptr
03764     4E 67 02 F6 | 	mov	objptr, local05
03768     2D 9A 62 FD | 	call	local04
0376c     4F 67 02 F6 | 	mov	objptr, local06
03770                 | LR__0453
03770                 | LR__0454
03770     4B 01 68 FC | 	wrlong	#0, local02
03774     04 96 06 F1 | 	add	local02, #4
03778     4B 01 68 FC | 	wrlong	#0, local02
0377c     08 94 06 F1 | 	add	local01, #8
03780     4A A1 02 FB | 	rdlong	local07, local01
03784     0C A0 26 F5 | 	andn	local07, #12
03788     4A A1 62 FC | 	wrlong	local07, local01
0378c     00 74 06 F6 | 	mov	result1, #0
03790     E7 F0 03 F6 | 	mov	ptra, fp
03794     F2 00 A0 FD | 	call	#popregs_
03798                 | __system____default_flush_ret
03798     2D 00 64 FD | 	ret
0379c                 | 
0379c                 | __system____getftab
0379c     0A 8A 16 F2 | 	cmp	arg01, #10 wc
037a0     34 8A 06 CD |  if_b	qmul	arg01, #52
037a4     00 74 06 36 |  if_ae	mov	result1, #0
037a8     34 8B 02 C6 |  if_b	mov	arg01, ptr___system__dat__
037ac     28 8A 06 C1 |  if_b	add	arg01, #40
037b0     18 74 62 CD |  if_b	getqx	result1
037b4     45 75 02 C1 |  if_b	add	result1, arg01
037b8                 | __system____getftab_ret
037b8     2D 00 64 FD | 	ret
037bc                 | 
037bc                 | __system___fmtpad
037bc     06 CA 05 F6 | 	mov	COUNT_, #6
037c0     E8 00 A0 FD | 	call	#pushregs_
037c4     45 95 02 F6 | 	mov	local01, arg01
037c8     46 97 02 F6 | 	mov	local02, arg02
037cc     47 99 02 F6 | 	mov	local03, arg03
037d0     4B 8B EA F8 | 	getbyte	arg01, local02, #1
037d4     16 96 46 F0 | 	shr	local02, #22
037d8     03 96 0E F5 | 	and	local02, #3 wz
037dc     00 9A 06 F6 | 	mov	local04, #0
037e0     01 96 06 A6 |  if_e	mov	local02, #1
037e4     48 97 CA F7 | 	test	local02, arg04 wz
037e8     00 74 06 A6 |  if_e	mov	result1, #0
037ec     88 00 90 AD |  if_e	jmp	#LR__0463
037f0     45 99 C2 F2 | 	subr	local03, arg01
037f4     01 98 56 F2 | 	cmps	local03, #1 wc
037f8     00 74 06 C6 |  if_b	mov	result1, #0
037fc     78 00 90 CD |  if_b	jmp	#LR__0463
03800     03 96 0E F2 | 	cmp	local02, #3 wz
03804     18 00 90 5D |  if_ne	jmp	#LR__0460
03808     01 90 0E F2 | 	cmp	arg04, #1 wz
0380c     6E 96 62 FD | 	wrz	local02
03810     4B 99 02 F1 | 	add	local03, local02
03814     4C 99 52 F6 | 	abs	local03, local03 wc
03818     01 98 46 F0 | 	shr	local03, #1
0381c     4C 99 82 F6 | 	negc	local03, local03
03820                 | LR__0460
03820     01 98 56 F2 | 	cmps	local03, #1 wc
03824     4C 00 90 CD |  if_b	jmp	#LR__0462
03828     4C 9D 02 F6 | 	mov	local05, local03
0382c                 | LR__0461
0382c     4A 97 02 F6 | 	mov	local02, local01
03830     4A 9F 02 F6 | 	mov	local06, local01
03834     13 96 46 F7 | 	zerox	local02, #19
03838     14 9E 46 F0 | 	shr	local06, #20
0383c     02 9E 66 F0 | 	shl	local06, #2
03840     2D 9F 02 F1 | 	add	local06, __methods__
03844     4F 9F 02 FB | 	rdlong	local06, local06
03848     20 8A 06 F6 | 	mov	arg01, #32
0384c     33 99 02 F6 | 	mov	local03, objptr
03850     4B 67 02 F6 | 	mov	objptr, local02
03854     2D 9E 62 FD | 	call	local06
03858     4C 67 02 F6 | 	mov	objptr, local03
0385c     3A 9F 02 F6 | 	mov	local06, result1
03860     00 9E 56 F2 | 	cmps	local06, #0 wc
03864     4F 75 02 C6 |  if_b	mov	result1, local06
03868     0C 00 90 CD |  if_b	jmp	#LR__0463
0386c     4F 9B 02 F1 | 	add	local04, local06
03870     EE 9D 6E FB | 	djnz	local05, #LR__0461
03874                 | LR__0462
03874     4D 75 02 F6 | 	mov	result1, local04
03878                 | LR__0463
03878     E7 F0 03 F6 | 	mov	ptra, fp
0387c     F2 00 A0 FD | 	call	#popregs_
03880                 | __system___fmtpad_ret
03880     2D 00 64 FD | 	ret
03884                 | 
03884                 | __system___getiolock_0095
03884     01 CA 05 F6 | 	mov	COUNT_, #1
03888     E8 00 A0 FD | 	call	#pushregs_
0388c     0C FF BF FD | 	call	#__system____getftab
03890     3A 95 0A F6 | 	mov	local01, result1 wz
03894     10 00 90 AD |  if_e	jmp	#LR__0470
03898     08 94 06 F1 | 	add	local01, #8
0389c     4A 75 0A FB | 	rdlong	result1, local01 wz
038a0     08 94 86 F1 | 	sub	local01, #8
038a4     0C 00 90 5D |  if_ne	jmp	#LR__0471
038a8                 | LR__0470
038a8     34 75 02 F6 | 	mov	result1, ptr___system__dat__
038ac     24 74 06 F1 | 	add	result1, #36
038b0     08 00 90 FD | 	jmp	#LR__0472
038b4                 | LR__0471
038b4     0C 94 06 F1 | 	add	local01, #12
038b8     4A 75 02 F6 | 	mov	result1, local01
038bc                 | LR__0472
038bc     E7 F0 03 F6 | 	mov	ptra, fp
038c0     F2 00 A0 FD | 	call	#popregs_
038c4                 | __system___getiolock_0095_ret
038c4     2D 00 64 FD | 	ret
038c8                 | 
038c8                 | __system___gettxfunc
038c8     01 CA 05 F6 | 	mov	COUNT_, #1
038cc     E8 00 A0 FD | 	call	#pushregs_
038d0     C8 FE BF FD | 	call	#__system____getftab
038d4     3A 95 0A F6 | 	mov	local01, result1 wz
038d8     10 00 90 AD |  if_e	jmp	#LR__0480
038dc     08 94 06 F1 | 	add	local01, #8
038e0     4A 8D 0A FB | 	rdlong	arg02, local01 wz
038e4     08 94 86 F1 | 	sub	local01, #8
038e8     08 00 90 5D |  if_ne	jmp	#LR__0481
038ec                 | LR__0480
038ec     00 74 06 F6 | 	mov	result1, #0
038f0     08 00 90 FD | 	jmp	#LR__0482
038f4                 | LR__0481
038f4     54 94 26 F4 | 	bith	local01, #84
038f8     4A 75 02 F6 | 	mov	result1, local01
038fc                 | LR__0482
038fc     E7 F0 03 F6 | 	mov	ptra, fp
03900     F2 00 A0 FD | 	call	#popregs_
03904                 | __system___gettxfunc_ret
03904     2D 00 64 FD | 	ret
03908                 | 
03908                 | __system___rxtxioctl_0145
03908     00 8D 0E F2 | 	cmp	arg02, #256 wz
0390c     0C 00 90 AD |  if_e	jmp	#LR__0490
03910     01 8D 0E F2 | 	cmp	arg02, #257 wz
03914     1C 00 90 AD |  if_e	jmp	#LR__0491
03918     30 00 90 FD | 	jmp	#LR__0492
0391c                 | LR__0490
0391c     08 68 06 F1 | 	add	ptr___system__dat__, #8
03920     34 75 02 FB | 	rdlong	result1, ptr___system__dat__
03924     08 68 86 F1 | 	sub	ptr___system__dat__, #8
03928     47 75 62 FC | 	wrlong	result1, arg03
0392c     00 74 06 F6 | 	mov	result1, #0
03930     28 00 90 FD | 	jmp	#LR__0493
03934                 | LR__0491
03934     47 8B 02 FB | 	rdlong	arg01, arg03
03938     08 68 06 F1 | 	add	ptr___system__dat__, #8
0393c     34 8B 62 FC | 	wrlong	arg01, ptr___system__dat__
03940     08 68 86 F1 | 	sub	ptr___system__dat__, #8
03944     00 74 06 F6 | 	mov	result1, #0
03948     10 00 90 FD | 	jmp	#LR__0493
0394c                 | LR__0492
0394c     20 68 06 F1 | 	add	ptr___system__dat__, #32
03950     34 15 68 FC | 	wrlong	#10, ptr___system__dat__
03954     20 68 86 F1 | 	sub	ptr___system__dat__, #32
03958     01 74 66 F6 | 	neg	result1, #1
0395c                 | LR__0493
0395c                 | __system___rxtxioctl_0145_ret
0395c     2D 00 64 FD | 	ret
03960                 | 
03960                 | __system____dummy_flush_0146
03960     00 74 06 F6 | 	mov	result1, #0
03964                 | __system____dummy_flush_0146_ret
03964     2D 00 64 FD | 	ret
03968                 | 
03968                 | __system____default_filbuf
03968     05 CA 05 F6 | 	mov	COUNT_, #5
0396c     E8 00 A0 FD | 	call	#pushregs_
03970     45 95 02 F6 | 	mov	local01, arg01
03974     4A 97 02 FB | 	rdlong	local02, local01
03978     08 96 06 F1 | 	add	local02, #8
0397c     4B 75 0A FB | 	rdlong	result1, local02 wz
03980     08 96 86 F1 | 	sub	local02, #8
03984     20 00 90 5D |  if_ne	jmp	#LR__0500
03988     10 96 06 F1 | 	add	local02, #16
0398c     4B 75 02 F6 | 	mov	result1, local02
03990     04 96 86 F1 | 	sub	local02, #4
03994     4B 75 62 FC | 	wrlong	result1, local02
03998     04 96 86 F1 | 	sub	local02, #4
0399c     02 00 80 FF 
039a0     4B 01 68 FC | 	wrlong	##1024, local02
039a4     08 96 86 F1 | 	sub	local02, #8
039a8                 | LR__0500
039a8     14 94 06 F1 | 	add	local01, #20
039ac     4A 99 02 FB | 	rdlong	local03, local01
039b0     4C 9B 02 F6 | 	mov	local04, local03
039b4     14 94 86 F1 | 	sub	local01, #20
039b8     13 9A 46 F7 | 	zerox	local04, #19
039bc     14 98 46 F0 | 	shr	local03, #20
039c0     02 98 66 F0 | 	shl	local03, #2
039c4     2D 99 02 F1 | 	add	local03, __methods__
039c8     4C 99 02 FB | 	rdlong	local03, local03
039cc     4A 8B 02 F6 | 	mov	arg01, local01
039d0     0C 96 06 F1 | 	add	local02, #12
039d4     4B 8D 02 FB | 	rdlong	arg02, local02
039d8     04 96 86 F1 | 	sub	local02, #4
039dc     4B 8F 02 FB | 	rdlong	arg03, local02
039e0     08 96 86 F1 | 	sub	local02, #8
039e4     33 9D 02 F6 | 	mov	local05, objptr
039e8     4D 67 02 F6 | 	mov	objptr, local04
039ec     2D 98 62 FD | 	call	local03
039f0     4E 67 02 F6 | 	mov	objptr, local05
039f4     3A 9D 02 F6 | 	mov	local05, result1
039f8     00 9C 56 F2 | 	cmps	local05, #0 wc
039fc     01 74 66 C6 |  if_b	neg	result1, #1
03a00     28 00 90 CD |  if_b	jmp	#LR__0501
03a04     4B 9D 62 FC | 	wrlong	local05, local02
03a08     0C 96 06 F1 | 	add	local02, #12
03a0c     4B 99 02 FB | 	rdlong	local03, local02
03a10     08 96 86 F1 | 	sub	local02, #8
03a14     4B 99 62 FC | 	wrlong	local03, local02
03a18     08 94 06 F1 | 	add	local01, #8
03a1c     4A 9B 02 FB | 	rdlong	local04, local01
03a20     04 9A 46 F5 | 	or	local04, #4
03a24     4A 9B 62 FC | 	wrlong	local04, local01
03a28     4E 75 02 F6 | 	mov	result1, local05
03a2c                 | LR__0501
03a2c     E7 F0 03 F6 | 	mov	ptra, fp
03a30     F2 00 A0 FD | 	call	#popregs_
03a34                 | __system____default_filbuf_ret
03a34     2D 00 64 FD | 	ret
03a38                 | 
03a38                 | __system___struct__s_vfs_file_t_putchar_
03a38     04 CA 05 F6 | 	mov	COUNT_, #4
03a3c     E8 00 A0 FD | 	call	#pushregs_
03a40     1C 66 06 F1 | 	add	objptr, #28
03a44     33 95 0A FB | 	rdlong	local01, objptr wz
03a48     1C 66 86 F1 | 	sub	objptr, #28
03a4c     00 74 06 A6 |  if_e	mov	result1, #0
03a50     48 00 90 AD |  if_e	jmp	#LR__0510
03a54     1C 66 06 F1 | 	add	objptr, #28
03a58     33 97 02 FB | 	rdlong	local02, objptr
03a5c     4B 99 02 F6 | 	mov	local03, local02
03a60     1C 66 86 F1 | 	sub	objptr, #28
03a64     13 98 46 F7 | 	zerox	local03, #19
03a68     14 96 46 F0 | 	shr	local02, #20
03a6c     02 96 66 F0 | 	shl	local02, #2
03a70     2D 97 02 F1 | 	add	local02, __methods__
03a74     4B 97 02 FB | 	rdlong	local02, local02
03a78     33 8D 02 F6 | 	mov	arg02, objptr
03a7c     33 9B 02 F6 | 	mov	local04, objptr
03a80     4C 67 02 F6 | 	mov	objptr, local03
03a84     2D 96 62 FD | 	call	local02
03a88     4D 67 02 F6 | 	mov	objptr, local04
03a8c                 | '     return (i < 0) ? 0 : 1;
03a8c     00 74 56 F2 | 	cmps	result1, #0 wc
03a90     00 94 06 C6 |  if_b	mov	local01, #0
03a94     01 94 06 36 |  if_ae	mov	local01, #1
03a98     4A 75 02 F6 | 	mov	result1, local01
03a9c                 | LR__0510
03a9c     E7 F0 03 F6 | 	mov	ptra, fp
03aa0     F2 00 A0 FD | 	call	#popregs_
03aa4                 | __system___struct__s_vfs_file_t_putchar__ret
03aa4     2D 00 64 FD | 	ret
03aa8                 | 
03aa8                 | __system___struct__s_vfs_file_t_getchar_
03aa8     03 CA 05 F6 | 	mov	COUNT_, #3
03aac     E8 00 A0 FD | 	call	#pushregs_
03ab0     20 66 06 F1 | 	add	objptr, #32
03ab4     33 8B 0A FB | 	rdlong	arg01, objptr wz
03ab8     20 66 86 F1 | 	sub	objptr, #32
03abc     01 74 66 A6 |  if_e	neg	result1, #1
03ac0     38 00 90 AD |  if_e	jmp	#LR__0520
03ac4                 | '     return getcf(__this);
03ac4     20 66 06 F1 | 	add	objptr, #32
03ac8     33 95 02 FB | 	rdlong	local01, objptr
03acc     4A 97 02 F6 | 	mov	local02, local01
03ad0     20 66 86 F1 | 	sub	objptr, #32
03ad4     13 96 46 F7 | 	zerox	local02, #19
03ad8     14 94 46 F0 | 	shr	local01, #20
03adc     02 94 66 F0 | 	shl	local01, #2
03ae0     2D 95 02 F1 | 	add	local01, __methods__
03ae4     4A 95 02 FB | 	rdlong	local01, local01
03ae8     33 8B 02 F6 | 	mov	arg01, objptr
03aec     33 99 02 F6 | 	mov	local03, objptr
03af0     4B 67 02 F6 | 	mov	objptr, local02
03af4     2D 94 62 FD | 	call	local01
03af8     4C 67 02 F6 | 	mov	objptr, local03
03afc                 | LR__0520
03afc     E7 F0 03 F6 | 	mov	ptra, fp
03b00     F2 00 A0 FD | 	call	#popregs_
03b04                 | __system___struct__s_vfs_file_t_getchar__ret
03b04     2D 00 64 FD | 	ret
03b08                 | 
03b08                 | __system___struct___bas_wrap_sender_tx_
03b08     03 CA 05 F6 | 	mov	COUNT_, #3
03b0c     E8 00 A0 FD | 	call	#pushregs_
03b10     33 95 02 FB | 	rdlong	local01, objptr
03b14     4A 97 02 F6 | 	mov	local02, local01
03b18     13 94 46 F7 | 	zerox	local01, #19
03b1c     14 96 46 F0 | 	shr	local02, #20
03b20     02 96 66 F0 | 	shl	local02, #2
03b24     2D 97 02 F1 | 	add	local02, __methods__
03b28     4B 97 02 FB | 	rdlong	local02, local02
03b2c     33 99 02 F6 | 	mov	local03, objptr
03b30     4A 67 02 F6 | 	mov	objptr, local01
03b34     2D 96 62 FD | 	call	local02
03b38     4C 67 02 F6 | 	mov	objptr, local03
03b3c     01 74 06 F6 | 	mov	result1, #1
03b40     E7 F0 03 F6 | 	mov	ptra, fp
03b44     F2 00 A0 FD | 	call	#popregs_
03b48                 | __system___struct___bas_wrap_sender_tx__ret
03b48     2D 00 64 FD | 	ret
03b4c                 | 
03b4c                 | __system___struct___bas_wrap_sender_rx_
03b4c     03 CA 05 F6 | 	mov	COUNT_, #3
03b50     E8 00 A0 FD | 	call	#pushregs_
03b54     04 66 06 F1 | 	add	objptr, #4
03b58     33 95 02 FB | 	rdlong	local01, objptr
03b5c     4A 97 02 F6 | 	mov	local02, local01
03b60     04 66 86 F1 | 	sub	objptr, #4
03b64     13 96 46 F7 | 	zerox	local02, #19
03b68     14 94 46 F0 | 	shr	local01, #20
03b6c     02 94 66 F0 | 	shl	local01, #2
03b70     2D 95 02 F1 | 	add	local01, __methods__
03b74     4A 95 02 FB | 	rdlong	local01, local01
03b78     33 99 02 F6 | 	mov	local03, objptr
03b7c     4B 67 02 F6 | 	mov	objptr, local02
03b80     2D 94 62 FD | 	call	local01
03b84     4C 67 02 F6 | 	mov	objptr, local03
03b88     E7 F0 03 F6 | 	mov	ptra, fp
03b8c     F2 00 A0 FD | 	call	#popregs_
03b90                 | __system___struct___bas_wrap_sender_rx__ret
03b90     2D 00 64 FD | 	ret
03b94                 | 
03b94                 | __system___struct___bas_wrap_sender_close_
03b94     03 CA 05 F6 | 	mov	COUNT_, #3
03b98     E8 00 A0 FD | 	call	#pushregs_
03b9c     08 66 06 F1 | 	add	objptr, #8
03ba0     33 95 02 FB | 	rdlong	local01, objptr
03ba4     4A 97 02 F6 | 	mov	local02, local01
03ba8     08 66 86 F1 | 	sub	objptr, #8
03bac     13 96 46 F7 | 	zerox	local02, #19
03bb0     14 94 46 F0 | 	shr	local01, #20
03bb4     02 94 66 F0 | 	shl	local01, #2
03bb8     2D 95 02 F1 | 	add	local01, __methods__
03bbc     4A 95 02 FB | 	rdlong	local01, local01
03bc0     33 99 02 F6 | 	mov	local03, objptr
03bc4     4B 67 02 F6 | 	mov	objptr, local02
03bc8     2D 94 62 FD | 	call	local01
03bcc     4C 67 02 F6 | 	mov	objptr, local03
03bd0     E7 F0 03 F6 | 	mov	ptra, fp
03bd4     F2 00 A0 FD | 	call	#popregs_
03bd8                 | __system___struct___bas_wrap_sender_close__ret
03bd8     2D 00 64 FD | 	ret
03bdc                 | 
03bdc                 | LR__0530
03bdc     20 21 21 21 
03be0     20 63 6F 72 
03be4     72 75 70 74 
03be8     65 64 20 68 
03bec     65 61 70 3F 
03bf0     3F 3F 20 21 
03bf4     21 21 20    | 	byte	" !!! corrupted heap??? !!! "
03bf7     00          | 	byte	0
03bf8                 | LR__0531
03bf8     20 21 21 21 
03bfc     20 6F 75 74 
03c00     20 6F 66 20 
03c04     68 65 61 70 
03c08     20 6D 65 6D 
03c0c     6F 72 79 20 
03c10     21 21 21 20 | 	byte	" !!! out of heap memory !!! "
03c14     00          | 	byte	0
03c15                 | LR__0532
03c15     20 21 21 21 
03c19     20 63 6F 72 
03c1d     72 75 70 74 
03c21     65 64 20 68 
03c25     65 61 70 20 
03c29     21 21 21 20 | 	byte	" !!! corrupted heap !!! "
03c2d     00          | 	byte	0
03c2e                 | LR__0533
03c2e     54 65 73 74 
03c32     20 72 65 61 
03c36     64 79       | 	byte	"Test ready"
03c38     00          | 	byte	0
03c39     00 00 00    | 	alignl
03c3c                 | _hg010b_spin2_dat_
03c3c                 | 
03c3c     00 00 00 00 
03c40     00 00 00 00 
03c44     00 00 00 00 
03c48     00 00 00 00 
03c4c     00 00 00    | vga_font       file "vgafont.def"
03c4f     7E 81 A5 81 
03c53     81 BD 99 81 
03c57     81 7E 00 00 
03c5b     00 00 00 00 | 	byte	$7e, $81, $a5, $81, $81, $bd, $99, $81, $81, $7e, $00, $00, $00, $00, $00, $00
03c5f     7E FF DB FF 
03c63     FF C3 E7 FF 
03c67     FF 7E 00 00 
03c6b     00 00 00 00 | 	byte	$7e, $ff, $db, $ff, $ff, $c3, $e7, $ff, $ff, $7e, $00, $00, $00, $00, $00, $00
03c6f     00 36 7F 7F 
03c73     7F 7F 3E 1C 
03c77     08 00 00 00 
03c7b     00 00 00 00 | 	byte	$00, $36, $7f, $7f, $7f, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00
03c7f     00 08 1C 3E 
03c83     7F 3E 1C 08 
03c87     00 00 00 00 
03c8b     00 00 00 00 | 	byte	$00, $08, $1c, $3e, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00
03c8f     18 3C 3C E7 
03c93     E7 E7 18 18 
03c97     3C 00 00 00 
03c9b     00 00 00 00 | 	byte	$18, $3c, $3c, $e7, $e7, $e7, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
03c9f     18 3C 7E FF 
03ca3     FF 7E 18 18 
03ca7     3C 00 00 00 
03cab     00 00 00 00 | 	byte	$18, $3c, $7e, $ff, $ff, $7e, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
03caf     00 00 00 18 
03cb3     3C 3C 18 00 
03cb7     00 00 00 00 
03cbb     00 FF FF FF | 	byte	$00, $00, $00, $18, $3c, $3c, $18, $00, $00, $00, $00, $00, $00, $ff, $ff, $ff
03cbf     FF FF FF E7 
03cc3     C3 C3 E7 FF 
03cc7     FF FF FF FF 
03ccb     FF 00 00 00 | 	byte	$ff, $ff, $ff, $e7, $c3, $c3, $e7, $ff, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
03ccf     00 00 3C 66 
03cd3     42 42 66 3C 
03cd7     00 00 00 00 
03cdb     00 FF FF FF | 	byte	$00, $00, $3c, $66, $42, $42, $66, $3c, $00, $00, $00, $00, $00, $ff, $ff, $ff
03cdf     FF FF C3 99 
03ce3     BD BD 99 C3 
03ce7     FF FF FF FF 
03ceb     FF 00 00 00 | 	byte	$ff, $ff, $c3, $99, $bd, $bd, $99, $c3, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
03cef     78 70 58 4C 
03cf3     1E 33 33 33 
03cf7     33 1E 00 00 
03cfb     00 00 00 00 | 	byte	$78, $70, $58, $4c, $1e, $33, $33, $33, $33, $1e, $00, $00, $00, $00, $00, $00
03cff     3C 66 66 66 
03d03     66 3C 18 7E 
03d07     18 18 00 00 
03d0b     00 00 00 00 | 	byte	$3c, $66, $66, $66, $66, $3c, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00
03d0f     FC CC FC 0C 
03d13     0C 0C 0C 0E 
03d17     0F 07 00 00 
03d1b     00 00 00 00 | 	byte	$fc, $cc, $fc, $0c, $0c, $0c, $0c, $0e, $0f, $07, $00, $00, $00, $00, $00, $00
03d1f     FE C6 FE C6 
03d23     C6 C6 C6 E6 
03d27     E7 67 03 00 
03d2b     00 00 00 00 | 	byte	$fe, $c6, $fe, $c6, $c6, $c6, $c6, $e6, $e7, $67, $03, $00, $00, $00, $00, $00
03d2f     18 18 DB 3C 
03d33     E7 3C DB 18 
03d37     18 00 00 00 
03d3b     00 00 00 01 | 	byte	$18, $18, $db, $3c, $e7, $3c, $db, $18, $18, $00, $00, $00, $00, $00, $00, $01
03d3f     03 07 0F 1F 
03d43     7F 1F 0F 07 
03d47     03 01 00 00 
03d4b     00 00 00 40 | 	byte	$03, $07, $0f, $1f, $7f, $1f, $0f, $07, $03, $01, $00, $00, $00, $00, $00, $40
03d4f     60 70 78 7C 
03d53     7F 7C 78 70 
03d57     60 40 00 00 
03d5b     00 00 00 00 | 	byte	$60, $70, $78, $7c, $7f, $7c, $78, $70, $60, $40, $00, $00, $00, $00, $00, $00
03d5f     18 3C 7E 18 
03d63     18 18 7E 3C 
03d67     18 00 00 00 
03d6b     00 00 00 00 | 	byte	$18, $3c, $7e, $18, $18, $18, $7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00
03d6f     66 66 66 66 
03d73     66 66 66    | 	byte	$66[7]
03d76     00 66 66 00 
03d7a     00 00 00 00 
03d7e     00 FE DB DB 
03d82     DB DE D8 D8 | 	byte	$00, $66, $66, $00, $00, $00, $00, $00, $00, $fe, $db, $db, $db, $de, $d8, $d8
03d86     D8 D8 D8 00 
03d8a     00 00 00 3E 
03d8e     63 06 1C 36 
03d92     63 63 36 1C | 	byte	$d8, $d8, $d8, $00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c
03d96     30 63 3E 00 
03d9a     00 00 00 00 
03d9e     00 00 00 00 
03da2     00 00 00 7F | 	byte	$30, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
03da6     7F 7F 7F 00 
03daa     00 00 00 00 
03dae     00 18 3C 7E 
03db2     18 18 18 7E | 	byte	$7f, $7f, $7f, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $7e
03db6     3C 18 7E 00 
03dba     00 00 00 00 
03dbe     00 18 3C 7E 
03dc2     18 18 18 18 | 	byte	$3c, $18, $7e, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $18
03dc6     18 18 18 00 
03dca     00 00 00 00 
03dce     00 18 18 18 
03dd2     18 18 18 18 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
03dd6     7E 3C 18 00 
03dda     00 00 00 00 
03dde     00 00 00 18 
03de2     30 7F 30 18 | 	byte	$7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $18, $30, $7f, $30, $18
03de6     00 00 00 00 
03dea     00 00 00 00 
03dee     00 00 00    | 	byte	$00[11]
03df1     0C 06 7F 06 
03df5     0C 00 00 00 
03df9     00 00 00 00 
03dfd     00 00 00 00 | 	byte	$0c, $06, $7f, $06, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
03e01     00 03 03 03 
03e05     7F 00 00 00 
03e09     00 00 00 00 
03e0d     00 00 00 00 | 	byte	$00, $03, $03, $03, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
03e11     14 36 7F 36 
03e15     14 00 00 00 
03e19     00 00 00 00 
03e1d     00 00 00 08 | 	byte	$14, $36, $7f, $36, $14, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08
03e21     1C 1C 3E 3E 
03e25     7F 7F 00 00 
03e29     00 00 00 00 
03e2d     00 00 00 7F | 	byte	$1c, $1c, $3e, $3e, $7f, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
03e31     7F 3E 3E 1C 
03e35     1C 08 00 00 
03e39     00 00 00 00 
03e3d     00 00 00 00 | 	byte	$7f, $3e, $3e, $1c, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
03e41     00 00 00 00 
03e45     00 00 00 00 
03e49     00 00 00 00 
03e4d     00 00       | 	byte	$00[14]
03e4f     18 3C 3C 3C 
03e53     18 18 18 00 
03e57     18 18 00 00 
03e5b     00 00 66 66 | 	byte	$18, $3c, $3c, $3c, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $66, $66
03e5f     66 24 00 00 
03e63     00 00 00 00 
03e67     00 00 00 00 
03e6b     00 00 00 00 | 	byte	$66, $24, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
03e6f     00 36 36 7F 
03e73     36 36 36 7F 
03e77     36 36 00 00 
03e7b     00 00 18 18 | 	byte	$00, $36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $18, $18
03e7f     3E 63 43 03 
03e83     3E 60 60 61 
03e87     63 3E 18 18 
03e8b     00 00 00 00 | 	byte	$3e, $63, $43, $03, $3e, $60, $60, $61, $63, $3e, $18, $18, $00, $00, $00, $00
03e8f     00 00 43 63 
03e93     30 18 0C 06 
03e97     63 61 00 00 
03e9b     00 00 00 00 | 	byte	$00, $00, $43, $63, $30, $18, $0c, $06, $63, $61, $00, $00, $00, $00, $00, $00
03e9f     1C 36 36 1C 
03ea3     6E 3B 33 33 
03ea7     33 6E 00 00 
03eab     00 00 00 00 | 	byte	$1c, $36, $36, $1c, $6e, $3b, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00
03eaf     0C 0C 0C 06 
03eb3     00 00 00 00 
03eb7     00 00 00 00 
03ebb     00 00 00 00 | 	byte	$0c, $0c, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
03ebf     30 18 0C 0C 
03ec3     0C 0C 0C 0C 
03ec7     18 30 00 00 
03ecb     00 00 00 00 | 	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00
03ecf     0C 18 30 30 
03ed3     30 30 30 30 
03ed7     18 0C 00 00 
03edb     00 00 00 00 | 	byte	$0c, $18, $30, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00
03edf     00 00 00 66 
03ee3     3C FF 3C 66 
03ee7     00 00 00 00 
03eeb     00 00 00 00 | 	byte	$00, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00
03eef     00 00 00 18 
03ef3     18 7E 18 18 
03ef7     00 00 00 00 
03efb     00 00 00 00 | 	byte	$00, $00, $00, $18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
03eff     00 00 00 00 
03f03     00 00 00 00 | 	byte	$00[8]
03f07     18 18 18 0C 
03f0b     00 00 00 00 
03f0f     00 00 00 00 
03f13     00 7F 00 00 | 	byte	$18, $18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f, $00, $00
03f17     00 00 00 00 
03f1b     00 00 00 00 
03f1f     00 00 00 00 
03f23     00 00 00 00 | 	byte	$00[16]
03f27     18 18 00 00 
03f2b     00 00 00 00 
03f2f     00 00 40 60 
03f33     30 18 0C 06 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $40, $60, $30, $18, $0c, $06
03f37     03 01 00 00 
03f3b     00 00 00 00 
03f3f     1C 36 63 63 
03f43     6B 6B 63 63 | 	byte	$03, $01, $00, $00, $00, $00, $00, $00, $1c, $36, $63, $63, $6b, $6b, $63, $63
03f47     36 1C 00 00 
03f4b     00 00 00 00 
03f4f     18 1C 1E 18 
03f53     18 18 18 18 | 	byte	$36, $1c, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18, $18
03f57     18 7E 00 00 
03f5b     00 00 00 00 
03f5f     3E 63 60 30 
03f63     18 0C 06 03 | 	byte	$18, $7e, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $30, $18, $0c, $06, $03
03f67     63 7F 00 00 
03f6b     00 00 00 00 
03f6f     3E 63 60 60 
03f73     3C 60 60 60 | 	byte	$63, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $60, $3c, $60, $60, $60
03f77     63 3E 00 00 
03f7b     00 00 00 00 
03f7f     30 38 3C 36 
03f83     33 7F 30 30 | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30, $30
03f87     30 78 00 00 
03f8b     00 00 00 00 
03f8f     7F 03 03 03 
03f93     3F 60 60 60 | 	byte	$30, $78, $00, $00, $00, $00, $00, $00, $7f, $03, $03, $03, $3f, $60, $60, $60
03f97     63 3E 00 00 
03f9b     00 00 00 00 
03f9f     1C 06 03 03 
03fa3     3F 63 63 63 | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $1c, $06, $03, $03, $3f, $63, $63, $63
03fa7     63 3E 00 00 
03fab     00 00 00 00 
03faf     7F 63 60 60 
03fb3     30 18 0C 0C | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $7f, $63, $60, $60, $30, $18, $0c, $0c
03fb7     0C 0C 00 00 
03fbb     00 00 00 00 
03fbf     3E 63 63 63 
03fc3     3E 63 63 63 | 	byte	$0c, $0c, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $3e, $63, $63, $63
03fc7     63 3E 00 00 
03fcb     00 00 00 00 
03fcf     3E 63 63 63 
03fd3     7E 60 60 60 | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $7e, $60, $60, $60
03fd7     30 1E 00 00 
03fdb     00 00 00 00 
03fdf     00 00 00 18 
03fe3     18 00 00 00 | 	byte	$30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
03fe7     18 18 00 00 
03feb     00 00 00 00 
03fef     00 00 00 18 
03ff3     18 00 00 00 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
03ff7     18 18 0C 00 
03ffb     00 00 00 00 
03fff     00 60 30 18 
04003     0C 06 0C 18 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $60, $30, $18, $0c, $06, $0c, $18
04007     30 60 00 00 
0400b     00 00 00 00 
0400f     00 00 00 7E 
04013     00 00 7E 00 | 	byte	$30, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00, $7e, $00
04017     00 00 00 00 
0401b     00 00 00 00 
0401f     00          | 	byte	$00[9]
04020     06 0C 18 30 
04024     60 30 18 0C 
04028     06 00 00 00 
0402c     00 00 00 3E | 	byte	$06, $0c, $18, $30, $60, $30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $3e
04030     63 63 30 18 
04034     18 18 00 18 
04038     18 00 00 00 
0403c     00 00 00 00 | 	byte	$63, $63, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00
04040     3E 63 63 7B 
04044     7B 7B 3B 03 
04048     3E 00 00 00 
0404c     00 00 00 08 | 	byte	$3e, $63, $63, $7b, $7b, $7b, $3b, $03, $3e, $00, $00, $00, $00, $00, $00, $08
04050     1C 36 63 63 
04054     7F 63 63 63 
04058     63 00 00 00 
0405c     00 00 00 3F | 	byte	$1c, $36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3f
04060     66 66 66 3E 
04064     66 66 66 66 
04068     3F 00 00 00 
0406c     00 00 00 3C | 	byte	$66, $66, $66, $3e, $66, $66, $66, $66, $3f, $00, $00, $00, $00, $00, $00, $3c
04070     66 43 03 03 
04074     03 03 43 66 
04078     3C 00 00 00 
0407c     00 00 00 1F | 	byte	$66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00, $00, $1f
04080     36 66 66 66 
04084     66 66 66 36 
04088     1F 00 00 00 
0408c     00 00 00 7F | 	byte	$36, $66, $66, $66, $66, $66, $66, $36, $1f, $00, $00, $00, $00, $00, $00, $7f
04090     66 46 16 1E 
04094     16 06 46 66 
04098     7F 00 00 00 
0409c     00 00 00 7F | 	byte	$66, $46, $16, $1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $7f
040a0     66 46 16 1E 
040a4     16 06 06 06 
040a8     0F 00 00 00 
040ac     00 00 00 3C | 	byte	$66, $46, $16, $1e, $16, $06, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $3c
040b0     66 43 03 03 
040b4     7B 63 63 66 
040b8     5C 00 00 00 
040bc     00 00 00 63 | 	byte	$66, $43, $03, $03, $7b, $63, $63, $66, $5c, $00, $00, $00, $00, $00, $00, $63
040c0     63 63 63 7F 
040c4     63 63 63 63 
040c8     63 00 00 00 
040cc     00 00 00 3C | 	byte	$63, $63, $63, $7f, $63, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3c
040d0     18 18 18 18 
040d4     18 18 18 18 | 	byte	$18[8]
040d8     3C 00 00 00 
040dc     00 00 00 78 
040e0     30 30 30 30 
040e4     30 33 33 33 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $78, $30, $30, $30, $30, $30, $33, $33, $33
040e8     1E 00 00 00 
040ec     00 00 00 67 
040f0     66 66 36 1E 
040f4     1E 36 66 66 | 	byte	$1e, $00, $00, $00, $00, $00, $00, $67, $66, $66, $36, $1e, $1e, $36, $66, $66
040f8     67 00 00 00 
040fc     00 00 00 0F 
04100     06 06 06 06 
04104     06 06 46 66 | 	byte	$67, $00, $00, $00, $00, $00, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
04108     7F 00 00 00 
0410c     00 00 00 63 
04110     77 7F 7F 6B 
04114     63 63 63 63 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $7f, $6b, $63, $63, $63, $63
04118     63 00 00 00 
0411c     00 00 00 63 
04120     67 6F 7F 7B 
04124     73 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63
04128     63 00 00 00 
0412c     00 00 00 3E 
04130     63 63 63 63 
04134     63 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
04138     3E 00 00 00 
0413c     00 00 00 3F 
04140     66 66 66 3E 
04144     06 06 06 06 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $06, $06, $06, $06
04148     0F 00 00 00 
0414c     00 00 00 3E 
04150     63 63 63 63 
04154     63 63 6B 7B | 	byte	$0f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $6b, $7b
04158     3E 30 70 00 
0415c     00 00 00 3F 
04160     66 66 66 3E 
04164     36 66 66 66 | 	byte	$3e, $30, $70, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66
04168     67 00 00 00 
0416c     00 00 00 3E 
04170     63 63 06 1C 
04174     30 60 63 63 | 	byte	$67, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
04178     3E 00 00 00 
0417c     00 00 00 7E 
04180     7E 5A 18 18 
04184     18 18 18 18 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
04188     3C 00 00 00 
0418c     00 00 00 63 
04190     63 63 63 63 
04194     63 63 63 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
04198     3E 00 00 00 
0419c     00 00 00 63 
041a0     63 63 63 63 
041a4     63 63 36 1C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $36, $1c
041a8     08 00 00 00 
041ac     00 00 00 63 
041b0     63 63 63 6B 
041b4     6B 6B 7F 77 | 	byte	$08, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $6b, $6b, $6b, $7f, $77
041b8     36 00 00 00 
041bc     00 00 00 63 
041c0     63 36 3E 1C 
041c4     1C 3E 36 63 | 	byte	$36, $00, $00, $00, $00, $00, $00, $63, $63, $36, $3e, $1c, $1c, $3e, $36, $63
041c8     63 00 00 00 
041cc     00 00 00 66 
041d0     66 66 66 3C 
041d4     18 18 18 18 | 	byte	$63, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18
041d8     3C 00 00 00 
041dc     00 00 00 7F 
041e0     63 61 30 18 
041e4     0C 06 43 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
041e8     7F 00 00 00 
041ec     00 00 00 3C 
041f0     0C 0C 0C 0C 
041f4     0C 0C 0C 0C | 	byte	$7f, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
041f8     3C 00 00 00 
041fc     00 00 00 00 
04200     01 03 07 0E 
04204     1C 38 70 60 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $01, $03, $07, $0e, $1c, $38, $70, $60
04208     40 00 00 00 
0420c     00 00 00 3C 
04210     30 30 30 30 
04214     30 30 30 30 | 	byte	$40, $00, $00, $00, $00, $00, $00, $3c, $30, $30, $30, $30, $30, $30, $30, $30
04218     3C 00 00 00 
0421c     1C 36 00 00 
04220     00 00 00 00 
04224     00 00 00 00 | 	byte	$3c, $00, $00, $00, $1c, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04228     00 00 00 00 
0422c     00 00 00 00 
04230     00 00 00 00 
04234     00 00 00 00 
04238     00          | 	byte	$00[17]
04239     FF 00 00 0C 
0423d     18 00 00 00 
04241     00 00 00 00 
04245     00 00 00 00 | 	byte	$ff, $00, $00, $0c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04249     00 00 00 00 
0424d     00 00 00 00 
04251     00          | 	byte	$00[9]
04252     1E 30 3E 33 
04256     33 33 6E 00 
0425a     00 00 00 00 
0425e     00 07 06 06 | 	byte	$1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $07, $06, $06
04262     1E 36 66 66 
04266     66 66 3E 00 
0426a     00 00 00 00 
0426e     00 00 00 00 | 	byte	$1e, $36, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
04272     3E 63 03 03 
04276     03 63 3E 00 
0427a     00 00 00 00 
0427e     00 38 30 30 | 	byte	$3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $30, $30
04282     3C 36 33 33 
04286     33 33 6E 00 
0428a     00 00 00 00 
0428e     00 00 00 00 | 	byte	$3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $00, $00, $00
04292     3E 63 7F 03 
04296     03 63 3E 00 
0429a     00 00 00 00 
0429e     00 38 6C 4C | 	byte	$3e, $63, $7f, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $6c, $4c
042a2     0C 1E 0C 0C 
042a6     0C 0C 1E 00 
042aa     00 00 00 00 
042ae     00 00 00 00 | 	byte	$0c, $1e, $0c, $0c, $0c, $0c, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
042b2     6E 33 33 33 
042b6     33 33 3E 30 
042ba     33 1E 00 00 
042be     00 07 06 06 | 	byte	$6e, $33, $33, $33, $33, $33, $3e, $30, $33, $1e, $00, $00, $00, $07, $06, $06
042c2     36 6E 66 66 
042c6     66 66 67 00 
042ca     00 00 00 00 
042ce     00 18 18 00 | 	byte	$36, $6e, $66, $66, $66, $66, $67, $00, $00, $00, $00, $00, $00, $18, $18, $00
042d2     1C 18 18 18 
042d6     18 18 3C 00 
042da     00 00 00 00 
042de     00 60 60 00 | 	byte	$1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $60, $60, $00
042e2     70 60 60 60 
042e6     60 60 60 66 
042ea     66 3C 00 00 
042ee     00 07 06 06 | 	byte	$70, $60, $60, $60, $60, $60, $60, $66, $66, $3c, $00, $00, $00, $07, $06, $06
042f2     66 36 1E 1E 
042f6     36 66 67 00 
042fa     00 00 00 00 
042fe     00 1C 18 18 | 	byte	$66, $36, $1e, $1e, $36, $66, $67, $00, $00, $00, $00, $00, $00, $1c, $18, $18
04302     18 18 18 18 
04306     18 18       | 	byte	$18[6]
04308     3C 00 00 00 
0430c     00 00 00 00 
04310     00 00 37 7F 
04314     6B 6B 6B 6B | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $6b, $6b, $6b
04318     63 00 00 00 
0431c     00 00 00 00 
04320     00 00 3B 66 
04324     66 66 66 66 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
04328     66 00 00 00 
0432c     00 00 00 00 
04330     00 00 3E 63 
04334     63 63 63 63 | 	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63
04338     3E 00 00 00 
0433c     00 00 00 00 
04340     00 00 3B 66 
04344     66 66 66 66 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
04348     3E 06 06 0F 
0434c     00 00 00 00 
04350     00 00 6E 33 
04354     33 33 33 33 | 	byte	$3e, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $6e, $33, $33, $33, $33, $33
04358     3E 30 30 78 
0435c     00 00 00 00 
04360     00 00 3B 6E 
04364     66 06 06 06 | 	byte	$3e, $30, $30, $78, $00, $00, $00, $00, $00, $00, $3b, $6e, $66, $06, $06, $06
04368     0F 00 00 00 
0436c     00 00 00 00 
04370     00 00 3E 63 
04374     06 1C 30 63 | 	byte	$0f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63
04378     3E 00 00 00 
0437c     00 00 00 08 
04380     0C 0C 3F 0C 
04384     0C 0C 0C 6C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
04388     38 00 00 00 
0438c     00 00 00 00 
04390     00 00 33 33 
04394     33 33 33 33 | 	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $33, $33, $33, $33, $33, $33
04398     6E 00 00 00 
0439c     00 00 00 00 
043a0     00 00 63 63 
043a4     63 63 63 36 | 	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36
043a8     1C 00 00 00 
043ac     00 00 00 00 
043b0     00 00 63 63 
043b4     6B 6B 6B 7F | 	byte	$1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $6b, $6b, $6b, $7f
043b8     36 00 00 00 
043bc     00 00 00 00 
043c0     00 00 63 36 
043c4     1C 1C 1C 36 | 	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $1c, $36
043c8     63 00 00 00 
043cc     00 00 00 00 
043d0     00 00 63 63 
043d4     63 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63
043d8     7E 60 30 1F 
043dc     00 00 00 00 
043e0     00 00 7F 33 
043e4     18 0C 06 63 | 	byte	$7e, $60, $30, $1f, $00, $00, $00, $00, $00, $00, $7f, $33, $18, $0c, $06, $63
043e8     7F 00 00 00 
043ec     00 00 00 70 
043f0     18 18 18 0E 
043f4     18 18 18 18 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18, $18
043f8     70 00 00 00 
043fc     00 00 00 18 
04400     18 18 18 18 
04404     18 18 18 18 | 	byte	$70, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18
04408     18 00 00 00 
0440c     00 00 00 0E 
04410     18 18 18 70 
04414     18 18 18 18 | 	byte	$18, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18, $18
04418     0E 00 00 00 
0441c     6E 3B 00 00 
04420     00 00 00 00 
04424     00 00 00 00 | 	byte	$0e, $00, $00, $00, $6e, $3b, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04428     00 00 00 00 
0442c     00 00 00 00 
04430     00 00       | 	byte	$00[10]
04432     08 1C 36 63 
04436     63 63 7F 00 
0443a     00 00 00 00 
0443e     00 3C 66 43 | 	byte	$08, $1c, $36, $63, $63, $63, $7f, $00, $00, $00, $00, $00, $00, $3c, $66, $43
04442     03 03 03 03 
04446     43 66 3C 18 
0444a     30 1E 00 00 
0444e     00 00 33 00 | 	byte	$03, $03, $03, $03, $43, $66, $3c, $18, $30, $1e, $00, $00, $00, $00, $33, $00
04452     33 33 33 33 
04456     33 33       | 	byte	$33[6]
04458     6E 00 00 00 
0445c     00 00 60 30 
04460     18 00 3E 63 
04464     7F 03 03 63 | 	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $7f, $03, $03, $63
04468     3E 00 00 00 
0446c     00 00 08 1C 
04470     36 00 1E 30 
04474     3E 33 33 33 | 	byte	$3e, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $1e, $30, $3e, $33, $33, $33
04478     6E 00 00 00 
0447c     00 00 00 00 
04480     33 00 1E 30 
04484     3E 33 33 33 | 	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $33, $00, $1e, $30, $3e, $33, $33, $33
04488     6E 00 00 00 
0448c     00 00 1C 36 
04490     1C 00 33 33 
04494     33 33 33 33 | 	byte	$6e, $00, $00, $00, $00, $00, $1c, $36, $1c, $00, $33, $33, $33, $33, $33, $33
04498     6E 00 00 00 
0449c     00 00 60 30 
044a0     18 00 3E 63 
044a4     03 03 03 63 | 	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $03, $03, $03, $63
044a8     3E 00 00 00 
044ac     00 00 00 00 
044b0     00 00 3E 63 
044b4     03 03 03 63 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $03, $03, $03, $63
044b8     3E 18 30 1E 
044bc     00 00 00 1C 
044c0     58 78 38 18 
044c4     1C 1E 1A 18 | 	byte	$3e, $18, $30, $1e, $00, $00, $00, $1c, $58, $78, $38, $18, $1c, $1e, $1a, $18
044c8     3C 00 00 00 
044cc     00 00 00 00 
044d0     63 00 3E 63 
044d4     7F 03 03 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $7f, $03, $03, $63
044d8     3E 00 00 00 
044dc     66 33 00 3E 
044e0     63 63 63 63 
044e4     63 63 63 63 | 	byte	$3e, $00, $00, $00, $66, $33, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
044e8     3E 00 00 00 
044ec     00 00 CC 66 
044f0     33 00 3E 63 
044f4     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $00, $cc, $66, $33, $00, $3e, $63, $63, $63, $63, $63
044f8     3E 00 00 00 
044fc     00 00 18 3C 
04500     66 00 1C 18 
04504     18 18 18 18 | 	byte	$3e, $00, $00, $00, $00, $00, $18, $3c, $66, $00, $1c, $18, $18, $18, $18, $18
04508     3C 00 00 00 
0450c     30 18 00 7F 
04510     63 61 30 18 
04514     0C 06 43 63 | 	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
04518     7F 00 00 00 
0451c     00 63 00 08 
04520     1C 36 63 63 
04524     7F 63 63 63 | 	byte	$7f, $00, $00, $00, $00, $63, $00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63
04528     63 00 00 00 
0452c     30 18 00 3C 
04530     66 43 03 03 
04534     03 03 43 66 | 	byte	$63, $00, $00, $00, $30, $18, $00, $3c, $66, $43, $03, $03, $03, $03, $43, $66
04538     3C 00 00 00 
0453c     30 18 00 7F 
04540     66 46 16 1E 
04544     16 06 46 66 | 	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66
04548     7F 00 00 00 
0454c     0C 06 00 0F 
04550     06 06 06 06 
04554     06 06 46 66 | 	byte	$7f, $00, $00, $00, $0c, $06, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
04558     7F 00 00 00 
0455c     30 18 00 1C 
04560     18 18 18 18 
04564     18 18 18 18 | 	byte	$7f, $00, $00, $00, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $18, $18, $18
04568     3C 00 00 00 
0456c     00 00 08 1C 
04570     36 00 3E 63 
04574     63 63 63 63 | 	byte	$3c, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $3e, $63, $63, $63, $63, $63
04578     3E 00 00 00 
0457c     00 00 00 00 
04580     63 00 3E 63 
04584     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63
04588     3E 00 00 00 
0458c     00 00 00 6F 
04590     46 26 06 06 
04594     06 06 46 66 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $6f, $46, $26, $06, $06, $06, $06, $46, $66
04598     7F 00 00 00 
0459c     00 00 00 6E 
045a0     4C 2C 0C 0C 
045a4     0C 0C 0C 0C | 	byte	$7f, $00, $00, $00, $00, $00, $00, $6e, $4c, $2c, $0c, $0c, $0c, $0c, $0c, $0c
045a8     1E 00 00 00 
045ac     30 18 00 3E 
045b0     63 63 06 1C 
045b4     30 60 63 63 | 	byte	$1e, $00, $00, $00, $30, $18, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
045b8     3E 00 00 00 
045bc     00 00 60 30 
045c0     18 00 3E 63 
045c4     06 1C 30 63 | 	byte	$3e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $06, $1c, $30, $63
045c8     3E 00 00 00 
045cc     00 63 00 3E 
045d0     63 63 63 63 
045d4     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
045d8     3E 00 00 00 
045dc     00 63 00 63 
045e0     63 63 63 63 
045e4     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $63, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
045e8     3E 00 00 00 
045ec     6C 38 00 7E 
045f0     7E 5A 18 18 
045f4     18 18 18 18 | 	byte	$3e, $00, $00, $00, $6c, $38, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
045f8     3C 00 00 00 
045fc     00 00 60 48 
04600     2C 0C 3F 0C 
04604     0C 0C 0C 6C | 	byte	$3c, $00, $00, $00, $00, $00, $60, $48, $2c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
04608     38 00 00 00 
0460c     00 00 00 0F 
04610     26 36 1E 0E 
04614     07 07 46 66 | 	byte	$38, $00, $00, $00, $00, $00, $00, $0f, $26, $36, $1e, $0e, $07, $07, $46, $66
04618     7F 00 00 00 
0461c     00 00 00 00 
04620     00 63 36 1C 
04624     1C 36 63 00 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36, $63, $00
04628     00 00 00 00 
0462c     00 00       | 	byte	$00[6]
0462e     36 1C 08 00 
04632     3E 63 03 03 
04636     03 63 3E 00 
0463a     00 00 00 00 | 	byte	$36, $1c, $08, $00, $3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00
0463e     30 18 0C 00 
04642     1E 30 3E 33 
04646     33 33 6E 00 
0464a     00 00 00 00 | 	byte	$30, $18, $0c, $00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00
0464e     60 30 18 00 
04652     1C 18 18 18 
04656     18 18 3C 00 
0465a     00 00 00 00 | 	byte	$60, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00
0465e     60 30 18 00 
04662     3E 63 63 63 
04666     63 63 3E 00 
0466a     00 00 00 00 | 	byte	$60, $30, $18, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00
0466e     30 18 0C 00 
04672     33 33 33 33 
04676     33 33 6E 00 
0467a     00 00 00 00 | 	byte	$30, $18, $0c, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00
0467e     00 08 1C 36 
04682     63 63 7F 63 
04686     63 63 63 18 
0468a     0C 78 00 00 | 	byte	$00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63, $63, $18, $0c, $78, $00, $00
0468e     00 00 00 00 
04692     1E 30 3E 33 
04696     33 33 6E 18 
0469a     0C 78 36 1C | 	byte	$00, $00, $00, $00, $1e, $30, $3e, $33, $33, $33, $6e, $18, $0c, $78, $36, $1c
0469e     00 7F 63 61 
046a2     30 18 0C 06 
046a6     43 63 7F 00 
046aa     00 00 00 00 | 	byte	$00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00
046ae     36 1C 08 00 
046b2     7F 33 18 0C 
046b6     06 63 7F 00 
046ba     00 00 00 00 | 	byte	$36, $1c, $08, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00
046be     00 7F 66 46 
046c2     16 1E 16 06 
046c6     46 66 7F 18 
046ca     0C 78 00 00 | 	byte	$00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66, $7f, $18, $0c, $78, $00, $00
046ce     00 00 00 00 
046d2     3E 63 7F 03 
046d6     03 63 3E 18 
046da     0C 78 00 00 | 	byte	$00, $00, $00, $00, $3e, $63, $7f, $03, $03, $63, $3e, $18, $0c, $78, $00, $00
046de     00 3C 66 03 
046e2     1F 03 0F 03 
046e6     03 66 3C 00 
046ea     00 00 00 00 | 	byte	$00, $3c, $66, $03, $1f, $03, $0f, $03, $03, $66, $3c, $00, $00, $00, $00, $00
046ee     60 30 18 00 
046f2     7F 33 18 0C 
046f6     06 63 7F 00 
046fa     00 00 6C 38 | 	byte	$60, $30, $18, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $6c, $38
046fe     00 3C 66 43 
04702     03 03 03 03 
04706     43 66 3C 00 
0470a     00 00 00 00 | 	byte	$00, $3c, $66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00
0470e     00 00 00 00 
04712     3E 63 06 1C 
04716     30 63 3E 18 
0471a     30 1E 00 00 | 	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63, $3e, $18, $30, $1e, $00, $00
0471e     00 00 00 00 
04722     00 00       | 	byte	$00[6]
04724     6C 36 1B 36 
04728     6C 00 00 00 
0472c     00 00 00 00 
04730     00 00 00 00 | 	byte	$6c, $36, $1b, $36, $6c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04734     1B 36 6C 36 
04738     1B 00 00 00 
0473c     88 22 88 22 
04740     88 22 88 22 | 	byte	$1b, $36, $6c, $36, $1b, $00, $00, $00, $88, $22, $88, $22, $88, $22, $88, $22
04744     88 22 88 22 
04748     88 22 88 22 
0474c     AA 55 AA 55 
04750     AA 55 AA 55 | 	byte	$88, $22, $88, $22, $88, $22, $88, $22, $aa, $55, $aa, $55, $aa, $55, $aa, $55
04754     AA 55 AA 55 
04758     AA 55 AA 55 
0475c     BB EE BB EE 
04760     BB EE BB EE | 	byte	$aa, $55, $aa, $55, $aa, $55, $aa, $55, $bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee
04764     BB EE BB EE 
04768     BB EE BB EE 
0476c     18 18 18 18 
04770     18 18 18 18 | 	byte	$bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee, $18, $18, $18, $18, $18, $18, $18, $18
04774     18 18 18 18 
04778     18 18 18 18 
0477c     18 18 18 18 
04780     18 18 18    | 	byte	$18[15]
04783     1F 18 18 18 
04787     18 18 18 18 
0478b     18 30 18 00 
0478f     08 1C 36 63 | 	byte	$1f, $18, $18, $18, $18, $18, $18, $18, $18, $30, $18, $00, $08, $1c, $36, $63
04793     63 7F 63 63 
04797     63 63 00 00 
0479b     00 1C 36 00 
0479f     08 1C 36 63 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $1c, $36, $00, $08, $1c, $36, $63
047a3     63 7F 63 63 
047a7     63 63 00 00 
047ab     00 36 1C 00 
047af     7F 66 46 16 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $36, $1c, $00, $7f, $66, $46, $16
047b3     1E 16 06 46 
047b7     66 7F 00 00 
047bb     00 00 00 00 
047bf     3E 63 63 06 | 	byte	$1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06
047c3     1C 30 60 63 
047c7     63 3E 18 30 
047cb     1E 6C 6C 6C 
047cf     6C 6C 6F 60 | 	byte	$1c, $30, $60, $63, $63, $3e, $18, $30, $1e, $6c, $6c, $6c, $6c, $6c, $6f, $60
047d3     6F 6C 6C 6C 
047d7     6C 6C 6C 6C 
047db     6C 6C 6C 6C 
047df     6C 6C 6C 6C | 	byte	$6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
047e3     6C 6C 6C 6C 
047e7     6C 6C 6C 6C 
047eb     6C          | 	byte	$6c[9]
047ec     00 00 00 00 
047f0     00          | 	byte	$00[5]
047f1     7F 60 6F 6C 
047f5     6C 6C 6C 6C 
047f9     6C 6C 6C 6C 
047fd     6C 6C 6C 6C | 	byte	$7f, $60, $6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
04801     6F 60 7F 00 
04805     00 00 00 00 
04809     00 00 00 18 
0480d     18 00 7F 63 | 	byte	$6f, $60, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $7f, $63
04811     61 30 18 0C 
04815     06 43 63 7F 
04819     00 00 00 00 
0481d     00 00 18 18 | 	byte	$61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00, $00, $18, $18
04821     00 7F 33 18 
04825     0C 06 63 7F 
04829     00 00 00 00 
0482d     00 00 00 00 | 	byte	$00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00, $00, $00, $00
04831     00 00 1F 18 
04835     18 18 18 18 
04839     18 18 18 18 
0483d     18 18 18 18 | 	byte	$00, $00, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
04841     18 18 F8 00 
04845     00 00 00 00 
04849     00 00 00 18 
0484d     18 18 18 18 | 	byte	$18, $18, $f8, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
04851     18 18 FF 00 
04855     00 00 00 00 
04859     00 00 00 00 
0485d     00 00 00 00 | 	byte	$18, $18, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04861     00 00 FF 18 
04865     18 18 18 18 
04869     18 18 18 18 
0486d     18 18 18 18 | 	byte	$00, $00, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
04871     18 18 F8 18 
04875     18 18 18 18 
04879     18 18 18 00 
0487d     00 00 00 00 | 	byte	$18, $18, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
04881     00 00 FF 00 
04885     00 00 00 00 
04889     00 00 00 18 
0488d     18 18 18 18 | 	byte	$00, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
04891     18 18 FF 18 
04895     18 18 18 18 
04899     18 18 18 63 
0489d     3E 00 08 1C | 	byte	$18, $18, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $63, $3e, $00, $08, $1c
048a1     36 63 63 7F 
048a5     63 63 63 63 
048a9     00 00 00 00 
048ad     00 00 63 3E | 	byte	$36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $63, $3e
048b1     00 1E 30 3E 
048b5     33 33 33 6E 
048b9     00 00 00 6C 
048bd     6C 6C 6C 6C | 	byte	$00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
048c1     EC 0C FC 00 
048c5     00 00 00 00 
048c9     00 00 00 00 
048cd     00 00 00 00 | 	byte	$ec, $0c, $fc, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
048d1     FC 0C EC 6C 
048d5     6C 6C 6C 6C 
048d9     6C 6C 6C 6C 
048dd     6C 6C 6C 6C | 	byte	$fc, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
048e1     EF 00 FF 00 
048e5     00 00 00 00 
048e9     00 00 00 00 
048ed     00 00 00 00 | 	byte	$ef, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
048f1     FF 00 EF 6C 
048f5     6C 6C 6C 6C 
048f9     6C 6C 6C 6C 
048fd     6C 6C 6C 6C | 	byte	$ff, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
04901     EC 0C EC 6C 
04905     6C 6C 6C 6C 
04909     6C 6C 6C 00 
0490d     00 00 00 00 | 	byte	$ec, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
04911     FF 00 FF 00 
04915     00 00 00 00 
04919     00 00 00 6C 
0491d     6C 6C 6C 6C | 	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
04921     EF 00 EF 6C 
04925     6C 6C 6C 6C 
04929     6C 6C 6C 00 
0492d     00 00 00 00 | 	byte	$ef, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
04931     63 3E 63 63 
04935     63 63 3E 63 
04939     00 00 00 00 
0493d     00 00 30 7E | 	byte	$63, $3e, $63, $63, $63, $63, $3e, $63, $00, $00, $00, $00, $00, $00, $30, $7e
04941     30 3C 36 33 
04945     33 33 33 6E 
04949     00 00 00 00 
0494d     00 00 1F 36 | 	byte	$30, $3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $1f, $36
04951     66 66 6F 66 
04955     66 66 36 1F 
04959     00 00 00 36 
0495d     1C 00 1F 36 | 	byte	$66, $66, $6f, $66, $66, $66, $36, $1f, $00, $00, $00, $36, $1c, $00, $1f, $36
04961     66 66 66 66 
04965     66 66       | 	byte	$66[6]
04967     36 1F 00 00 
0496b     00 00 63 00 
0496f     7F 66 46 16 
04973     1E 16 06 46 | 	byte	$36, $1f, $00, $00, $00, $00, $63, $00, $7f, $66, $46, $16, $1e, $16, $06, $46
04977     66 7F 00 00 
0497b     00 6C 38 00 
0497f     38 30 30 3C 
04983     36 33 33 33 | 	byte	$66, $7f, $00, $00, $00, $6c, $38, $00, $38, $30, $30, $3c, $36, $33, $33, $33
04987     33 6E 00 00 
0498b     00 36 1C 00 
0498f     63 67 6F 7F 
04993     7B 73 63 63 | 	byte	$33, $6e, $00, $00, $00, $36, $1c, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63
04997     63 63 00 00 
0499b     00 30 18 00 
0499f     3C 18 18 18 
049a3     18 18 18 18 | 	byte	$63, $63, $00, $00, $00, $30, $18, $00, $3c, $18, $18, $18, $18, $18, $18, $18
049a7     18 3C 00 00 
049ab     00 3C 66 00 
049af     3C 18 18 18 
049b3     18 18 18 18 | 	byte	$18, $3c, $00, $00, $00, $3c, $66, $00, $3c, $18, $18, $18, $18, $18, $18, $18
049b7     18 3C 00 00 
049bb     00 00 00 36 
049bf     1C 08 00 3E 
049c3     63 7F 03 03 | 	byte	$18, $3c, $00, $00, $00, $00, $00, $36, $1c, $08, $00, $3e, $63, $7f, $03, $03
049c7     63 3E 00 00 
049cb     00 18 18 18 
049cf     18 18 18 18 
049d3     1F 00 00 00 | 	byte	$63, $3e, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $1f, $00, $00, $00
049d7     00 00 00 00 
049db     00 00 00 00 
049df     00 00 00 00 | 	byte	$00[12]
049e3     F8 18 18 18 
049e7     18 18 18 18 
049eb     18 FF FF FF 
049ef     FF FF FF FF | 	byte	$f8, $18, $18, $18, $18, $18, $18, $18, $18, $ff, $ff, $ff, $ff, $ff, $ff, $ff
049f3     FF FF FF FF 
049f7     FF FF FF FF 
049fb     FF          | 	byte	$ff[9]
049fc     00 00 00 00 
04a00     00 00 00    | 	byte	$00[7]
04a03     FF FF FF FF 
04a07     FF FF FF FF 
04a0b     FF          | 	byte	$ff[9]
04a0c     00 00 00 7E 
04a10     7E 5A 18 18 
04a14     18 18 18 18 
04a18     3C 18 30 1E | 	byte	$00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18, $3c, $18, $30, $1e
04a1c     1C 36 1C 63 
04a20     63 63 63 63 
04a24     63 63 63 63 
04a28     3E 00 00 00 | 	byte	$1c, $36, $1c, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
04a2c     FF FF FF FF 
04a30     FF FF FF    | 	byte	$ff[7]
04a33     00 00 00 00 
04a37     00 00 00 00 
04a3b     00          | 	byte	$00[9]
04a3c     30 18 00 3E 
04a40     63 63 63 63 
04a44     63 63 63 63 
04a48     3E 00 00 00 | 	byte	$30, $18, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
04a4c     00 00 00 1E 
04a50     33 33 33 1B 
04a54     33 63 63 63 
04a58     33 00 00 00 | 	byte	$00, $00, $00, $1e, $33, $33, $33, $1b, $33, $63, $63, $63, $33, $00, $00, $00
04a5c     1C 36 00 3E 
04a60     63 63 63 63 
04a64     63 63 63 63 
04a68     3E 00 00 00 | 	byte	$1c, $36, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
04a6c     30 18 00 63 
04a70     67 6F 7F 7B 
04a74     73 63 63 63 
04a78     63 00 00 00 | 	byte	$30, $18, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63, $63, $00, $00, $00
04a7c     00 00 60 30 
04a80     18 00 3B 66 
04a84     66 66 66 66 
04a88     66 00 00 00 | 	byte	$00, $00, $60, $30, $18, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
04a8c     00 00 36 1C 
04a90     08 00 3B 66 
04a94     66 66 66 66 
04a98     66 00 00 00 | 	byte	$00, $00, $36, $1c, $08, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
04a9c     36 1C 00 3E 
04aa0     63 63 06 1C 
04aa4     30 60 63 63 
04aa8     3E 00 00 00 | 	byte	$36, $1c, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63, $3e, $00, $00, $00
04aac     00 00 36 1C 
04ab0     08 00 3E 63 
04ab4     06 1C 30 63 
04ab8     3E 00 00 00 | 	byte	$00, $00, $36, $1c, $08, $00, $3e, $63, $06, $1c, $30, $63, $3e, $00, $00, $00
04abc     30 18 00 3F 
04ac0     66 66 66 3E 
04ac4     36 66 66 66 
04ac8     6F 00 00 00 | 	byte	$30, $18, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00
04acc     30 18 00 63 
04ad0     63 63 63 63 
04ad4     63 63 63 63 
04ad8     3E 00 00 00 | 	byte	$30, $18, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
04adc     00 00 60 30 
04ae0     18 00 3B 6E 
04ae4     66 06 06 06 
04ae8     0F 00 00 00 | 	byte	$00, $00, $60, $30, $18, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00
04aec     66 33 00 63 
04af0     63 63 63 63 
04af4     63 63 63 63 
04af8     3E 00 00 00 | 	byte	$66, $33, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
04afc     00 00 60 30 
04b00     18 00 63 63 
04b04     63 63 63 63 
04b08     7E 60 30 1F | 	byte	$00, $00, $60, $30, $18, $00, $63, $63, $63, $63, $63, $63, $7e, $60, $30, $1f
04b0c     30 18 00 66 
04b10     66 66 66 3C 
04b14     18 18 18 18 
04b18     3C 00 00 00 | 	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18, $3c, $00, $00, $00
04b1c     00 00 00 08 
04b20     0C 0C 3F 0C 
04b24     0C 0C 0C 6C 
04b28     38 18 30 1E | 	byte	$00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c, $38, $18, $30, $1e
04b2c     30 18 00 00 
04b30     00 00 00 00 
04b34     00 00 00 00 
04b38     00 00 00 00 | 	byte	$30, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04b3c     00 00 00 00 
04b40     00 00 00 00 | 	byte	$00[8]
04b44     7F 00 00 00 
04b48     00 00 00 00 
04b4c     66 33 00 00 
04b50     00 00 00 00 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $66, $33, $00, $00, $00, $00, $00, $00
04b54     00 00 00 00 
04b58     00 00 00 00 
04b5c     00 00 00 00 
04b60     00 00 00 00 
04b64     00 00 00 00 
04b68     00          | 	byte	$00[21]
04b69     0C 06 3C 36 
04b6d     1C 00 00 00 
04b71     00 00 00 00 
04b75     00 00 00 00 | 	byte	$0c, $06, $3c, $36, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04b79     00 00 00 63 
04b7d     3E 00 00 00 
04b81     00 00 00 00 
04b85     00 00 00 00 | 	byte	$00, $00, $00, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04b89     00 00 00 00 
04b8d     3E 63 06 1C 
04b91     36 63 63 36 
04b95     1C 30 63 3E | 	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c, $30, $63, $3e
04b99     00 00 00 00 
04b9d     00 00 00 00 | 	byte	$00[8]
04ba1     18 00 7E 00 
04ba5     18 00 00 00 
04ba9     00 00 00 00 
04bad     00 00 00 00 | 	byte	$18, $00, $7e, $00, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04bb1     00 00 00 00 
04bb5     00 00 00 00 | 	byte	$00[8]
04bb9     18 30 1E 00 
04bbd     00 00 1C 36 
04bc1     36 1C 00 00 
04bc5     00 00 00 00 | 	byte	$18, $30, $1e, $00, $00, $00, $1c, $36, $36, $1c, $00, $00, $00, $00, $00, $00
04bc9     00 00 00 00 
04bcd     63 00 00 00 
04bd1     00 00 00 00 
04bd5     00 00 00 00 | 	byte	$00, $00, $00, $00, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04bd9     00 00 00 18 
04bdd     18 00 00 00 
04be1     00 00 00 00 
04be5     00 00 00 00 | 	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04be9     00 00 00 00 
04bed     00          | 	byte	$00[5]
04bee     CC 66 33 00 
04bf2     33 33 33 33 
04bf6     33 33 6E 00 
04bfa     00 00 36 1C | 	byte	$cc, $66, $33, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $36, $1c
04bfe     00 3F 66 66 
04c02     66 3E 36 66 
04c06     66 66 6F 00 
04c0a     00 00 00 00 | 	byte	$00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00, $00, $00
04c0e     36 1C 08 00 
04c12     3B 6E 66 06 
04c16     06 06 0F 00 
04c1a     00 00 00 00 | 	byte	$36, $1c, $08, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00, $00, $00
04c1e     00 00 00 7E 
04c22     7E 7E 7E 7E 
04c26     7E 7E 00 00 
04c2a     00 00 00 00 | 	byte	$00, $00, $00, $7e, $7e, $7e, $7e, $7e, $7e, $7e, $00, $00, $00, $00, $00, $00
04c2e     00 00 00 00 
04c32     00 00 00 00 
04c36     00 00 00 00 
04c3a     00 00       | 	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04c3c     00 00 00 00 
      ...             
04c6c     00 00 00 00 
04c70     00 00 00    | st_font        file "st4font.def"
04c73     FF FF 00 00 
04c77     00 00 00 00 
04c7b     00 18 18 18 
04c7f     18 18 18 18 | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
04c83     18 18 18 18 
04c87     18 18 18 18 
04c8b     18          | 	byte	$18[9]
04c8c     00 00 00 00 
04c90     00 00 00    | 	byte	$00[7]
04c93     FF FF 18 18 
04c97     18 18 18 18 
04c9b     18 18 18 18 
04c9f     18 18 18 18 | 	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
04ca3     FF FF 00 00 
04ca7     00 00 00 00 
04cab     00 18 18 18 
04caf     18 18 18 18 | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
04cb3     1F 1F 18 18 
04cb7     18 18 18 18 
04cbb     18 18 18 18 
04cbf     18 18 18 18 | 	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
04cc3     F8 F8 18 18 
04cc7     18 18 18 18 
04ccb     18 00 00 00 
04ccf     00 00 00 00 | 	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
04cd3     1F 1F 18 18 
04cd7     18 18 18 18 
04cdb     18 00 00 00 
04cdf     00 00 00 00 | 	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
04ce3     F8 F8 18 18 
04ce7     18 18 18 18 
04ceb     18 18 18 18 
04cef     18 18 18 18 | 	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
04cf3     1F 1F 00 00 
04cf7     00 00 00 00 
04cfb     00 18 18 18 
04cff     18 18 18 18 | 	byte	$1f, $1f, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
04d03     F8 F8 00 00 
04d07     00 00 00 00 
04d0b     00 18 18 18 
04d0f     18 18 18 18 | 	byte	$f8, $f8, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
04d13     FF FF 18 18 
04d17     18 18 18 18 
04d1b     18 00 00 18 
04d1f     3C 7E 66 66 | 	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $00, $00, $18, $3c, $7e, $66, $66
04d23     66 7E 7E 66 
04d27     66 66 66 30 
04d2b     18 00 00 7E 
04d2f     7E 06 06 3E | 	byte	$66, $7e, $7e, $66, $66, $66, $66, $30, $18, $00, $00, $7e, $7e, $06, $06, $3e
04d33     3E 06 06 06 
04d37     06 7E 7E 18 
04d3b     0C 30 18 3C 
04d3f     7E 66 66 06 | 	byte	$3e, $06, $06, $06, $06, $7e, $7e, $18, $0c, $30, $18, $3c, $7e, $66, $66, $06
04d43     06 06 06 66 
04d47     66 7E 3C 00 
04d4b     00 30 18 66 
04d4f     66 66 6E 6E | 	byte	$06, $06, $06, $66, $66, $7e, $3c, $00, $00, $30, $18, $66, $66, $66, $6e, $6e
04d53     7E 7E 76 76 
04d57     66 66 66 00 
04d5b     00 30 18 7C 
04d5f     7E 06 06 0E | 	byte	$7e, $7e, $76, $76, $66, $66, $66, $00, $00, $30, $18, $7c, $7e, $06, $06, $0e
04d63     1C 38 70 60 
04d67     60 7E 3E 00 
04d6b     00 30 18 7E 
04d6f     7E 30 30 18 | 	byte	$1c, $38, $70, $60, $60, $7e, $3e, $00, $00, $30, $18, $7e, $7e, $30, $30, $18
04d73     18 0C 0C 06 
04d77     06 7E 7E 00 
04d7b     00 18 18 00 
04d7f     7E 7E 30 30 | 	byte	$18, $0c, $0c, $06, $06, $7e, $7e, $00, $00, $18, $18, $00, $7e, $7e, $30, $30
04d83     18 18 0C 0C 
04d87     06 7E 7E 00 
04d8b     00 30 18 3C 
04d8f     7E 66 66 66 | 	byte	$18, $18, $0c, $0c, $06, $7e, $7e, $00, $00, $30, $18, $3c, $7e, $66, $66, $66
04d93     66 66 66 66 
04d97     66          | 	byte	$66[5]
04d98     7E 3C 00 00 
04d9c     00 00 06 06 
04da0     06 06 16 1E 
04da4     0E 06 06 06 | 	byte	$7e, $3c, $00, $00, $00, $00, $06, $06, $06, $06, $16, $1e, $0e, $06, $06, $06
04da8     7E 7E 00 00 
04dac     00 00 00 00 
04db0     00 3C 7C 60 
04db4     7C 7E 66 66 | 	byte	$7e, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $7c, $60, $7c, $7e, $66, $66
04db8     7E 7C 30 18 
04dbc     00 00 00 00 
04dc0     00 3C 7E 66 
04dc4     66 7E 06 06 | 	byte	$7e, $7c, $30, $18, $00, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $06, $06
04dc8     7E 7C 18 0C 
04dcc     00 00 30 18 
04dd0     00 3C 3E 06 
04dd4     06 06 06 06 | 	byte	$7e, $7c, $18, $0c, $00, $00, $30, $18, $00, $3c, $3e, $06, $06, $06, $06, $06
04dd8     7E 7C 00 00 
04ddc     00 00 30 18 
04de0     00 3E 7E 66 
04de4     66 66 66 66 | 	byte	$7e, $7c, $00, $00, $00, $00, $30, $18, $00, $3e, $7e, $66, $66, $66, $66, $66
04de8     66 66 00 00 
04dec     00 00 30 18 
04df0     00 7C 7E 06 
04df4     0E 3C 70 60 | 	byte	$66, $66, $00, $00, $00, $00, $30, $18, $00, $7c, $7e, $06, $0e, $3c, $70, $60
04df8     7E 3E 00 00 
04dfc     00 00 30 18 
04e00     00 7E 7E 30 
04e04     18 18 0C 0C | 	byte	$7e, $3e, $00, $00, $00, $00, $30, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
04e08     7E 7E 00 00 
04e0c     00 00 18 18 
04e10     00 7E 7E 30 
04e14     18 18 0C 0C | 	byte	$7e, $7e, $00, $00, $00, $00, $18, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
04e18     7E 7E 00 00 
04e1c     00 00 30 18 
04e20     00 3C 7E 66 
04e24     66 66 66 66 | 	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $00, $3c, $7e, $66, $66, $66, $66, $66
04e28     7E 3C 00 00 
04e2c     00 00 1C 1C 
04e30     18 18 38 3C 
04e34     1C 18 18 18 | 	byte	$7e, $3c, $00, $00, $00, $00, $1c, $1c, $18, $18, $38, $3c, $1c, $18, $18, $18
04e38     3C 3C 00 00 
04e3c     00 00 00 00 
04e40     00 00 00 00 
04e44     00 00 00 00 | 	byte	$3c, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04e48     00 00 00 00 
04e4c     00 00       | 	byte	$00[6]
04e4e     18 18 18 18 
04e52     18 18 18 18 | 	byte	$18[8]
04e56     00 00 18 18 
04e5a     00 00 00 00 
04e5e     66 66 66 66 
04e62     00 00 00 00 | 	byte	$00, $00, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $00, $00, $00, $00
04e66     00 00 00 00 
04e6a     00 00 00 00 
04e6e     00          | 	byte	$00[9]
04e6f     66 66 FF FF 
04e73     66 66 FF FF 
04e77     66 66 00 00 
04e7b     00 00 18 18 | 	byte	$66, $66, $ff, $ff, $66, $66, $ff, $ff, $66, $66, $00, $00, $00, $00, $18, $18
04e7f     7C 7E 06 06 
04e83     3E 7C 60 60 
04e87     7E 3E 18 18 
04e8b     00 00 00 66 | 	byte	$7c, $7e, $06, $06, $3e, $7c, $60, $60, $7e, $3e, $18, $18, $00, $00, $00, $66
04e8f     66 30 30 18 
04e93     18 0C 0C 66 
04e97     66 00 00 00 
04e9b     00 00 3C 7E | 	byte	$66, $30, $30, $18, $18, $0c, $0c, $66, $66, $00, $00, $00, $00, $00, $3c, $7e
04e9f     66 66 3C 1C 
04ea3     1C FC FE 66 
04ea7     66 FE FC 00 
04eab     00 00 00 18 | 	byte	$66, $66, $3c, $1c, $1c, $fc, $fe, $66, $66, $fe, $fc, $00, $00, $00, $00, $18
04eaf     18 18 18 18 
04eb3     00 00 00 00 
04eb7     00 00 00 00 
04ebb     00 00 00 30 | 	byte	$18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $30
04ebf     18 1C 0C 0C 
04ec3     0C 0C 0C 0C 
04ec7     1C 18 30 00 
04ecb     00 00 00 0C | 	byte	$18, $1c, $0c, $0c, $0c, $0c, $0c, $0c, $1c, $18, $30, $00, $00, $00, $00, $0c
04ecf     18 38 30 30 
04ed3     30 30 30 30 
04ed7     38 18 0C 00 
04edb     00 00 00 00 | 	byte	$18, $38, $30, $30, $30, $30, $30, $30, $38, $18, $0c, $00, $00, $00, $00, $00
04edf     66 66 3C 3C 
04ee3     FF FF 3C 3C 
04ee7     66 66 00 00 
04eeb     00 00 00 00 | 	byte	$66, $66, $3c, $3c, $ff, $ff, $3c, $3c, $66, $66, $00, $00, $00, $00, $00, $00
04eef     00 18 18 18 
04ef3     7E 7E 18 18 
04ef7     18 00 00 00 
04efb     00 00 00 00 | 	byte	$00, $18, $18, $18, $7e, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
04eff     00 00 00 00 
04f03     00 00       | 	byte	$00[6]
04f05     18 18 18 18 
04f09     18          | 	byte	$18[5]
04f0a     0C 04 00 00 
04f0e     00 00 00 00 
04f12     7E 7E 00 00 
04f16     00 00 00 00 | 	byte	$0c, $04, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $00, $00, $00, $00
04f1a     00 00 00 00 
04f1e     00 00 00 00 
04f22     00 00 00 00 
04f26     00          | 	byte	$00[13]
04f27     18 18 18 00 
04f2b     00 00 00 60 
04f2f     60 60 30 30 
04f33     18 18 0C 0C | 	byte	$18, $18, $18, $00, $00, $00, $00, $60, $60, $60, $30, $30, $18, $18, $0c, $0c
04f37     06 06 06 00 
04f3b     00 00 00 3C 
04f3f     7E 66 66 66 
04f43     76 6E 66 66 | 	byte	$06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $76, $6e, $66, $66
04f47     66 7E 3C 00 
04f4b     00 00 00 18 
04f4f     18 1C 1C 18 
04f53     18 18 18 18 | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $18, $18, $1c, $1c, $18, $18, $18, $18, $18
04f57     18 7E 7E 00 
04f5b     00 00 00 3C 
04f5f     7E 66 66 30 
04f63     30 18 18 0C | 	byte	$18, $7e, $7e, $00, $00, $00, $00, $3c, $7e, $66, $66, $30, $30, $18, $18, $0c
04f67     0C 7E 7E 00 
04f6b     00 00 00 7E 
04f6f     7E 30 30 18 
04f73     18 30 30 66 | 	byte	$0c, $7e, $7e, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $30, $30, $66
04f77     66 7E 3C 00 
04f7b     00 00 00 30 
04f7f     30 38 38 3C 
04f83     3C 36 36 7E | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $30, $30, $38, $38, $3c, $3c, $36, $36, $7e
04f87     7E 30 30 00 
04f8b     00 00 00 7E 
04f8f     7E 06 06 3E 
04f93     7E 60 60 60 | 	byte	$7e, $30, $30, $00, $00, $00, $00, $7e, $7e, $06, $06, $3e, $7e, $60, $60, $60
04f97     66 7E 3C 00 
04f9b     00 00 00 38 
04f9f     3C 0E 06 06 
04fa3     3E 7E 66 66 | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $38, $3c, $0e, $06, $06, $3e, $7e, $66, $66
04fa7     66 7E 3C 00 
04fab     00 00 00 7E 
04faf     7E 60 60 30 
04fb3     30 18 18 0C | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $7e, $7e, $60, $60, $30, $30, $18, $18, $0c
04fb7     0C 0C 0C 00 
04fbb     00 00 00 3C 
04fbf     7E 66 66 3C 
04fc3     3C 66 66 66 | 	byte	$0c, $0c, $0c, $00, $00, $00, $00, $3c, $7e, $66, $66, $3c, $3c, $66, $66, $66
04fc7     66 7E 3C 00 
04fcb     00 00 00 3C 
04fcf     7E 66 66 7E 
04fd3     7C 60 60 60 | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $7c, $60, $60, $60
04fd7     70 3C 1C 00 
04fdb     00 00 00 00 
04fdf     00 00 18 18 
04fe3     18 00 00 00 | 	byte	$70, $3c, $1c, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $00
04fe7     18 18 18 00 
04feb     00 00 00 00 
04fef     00 00 18 18 
04ff3     18 00 00 18 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $18
04ff7     18 18 18 0C 
04ffb     04 00 00 00 
04fff     70 38 1C 0E 
05003     07 0E 1C 38 | 	byte	$18, $18, $18, $0c, $04, $00, $00, $00, $70, $38, $1c, $0e, $07, $0e, $1c, $38
05007     70 00 00 00 
0500b     00 00 00 00 
0500f     00 00 7E 7E 
05013     00 00 7E 7E | 	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $7e, $7e
05017     00 00 00 00 
0501b     00 00 00 00 | 	byte	$00[8]
0501f     0E 1C 38 70 
05023     E0 70 38 1C 
05027     0E 00 00 00 
0502b     00 00 00 3C | 	byte	$0e, $1c, $38, $70, $e0, $70, $38, $1c, $0e, $00, $00, $00, $00, $00, $00, $3c
0502f     7E 66 66 30 
05033     30 18 18 18 
05037     00 18 18 00 
0503b     00 00 00 3C | 	byte	$7e, $66, $66, $30, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $3c
0503f     7E 66 66 66 
05043     66 36 06 66 
05047     66 7E 3C 00 
0504b     00 00 00 18 | 	byte	$7e, $66, $66, $66, $66, $36, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $18
0504f     3C 7E 66 66 
05053     66 7E 7E 66 
05057     66 66 66 00 
0505b     00 00 00 3E | 	byte	$3c, $7e, $66, $66, $66, $7e, $7e, $66, $66, $66, $66, $00, $00, $00, $00, $3e
0505f     7E 66 66 7E 
05063     3E 66 66 66 
05067     66 7E 3E 00 
0506b     00 00 00 3C | 	byte	$7e, $66, $66, $7e, $3e, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $3c
0506f     7E 66 66 06 
05073     06 06 06 66 
05077     66 7E 3C 00 
0507b     00 00 00 3E | 	byte	$7e, $66, $66, $06, $06, $06, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $3e
0507f     7E 66 66 66 
05083     66 66 66 66 
05087     66 7E 3E 00 
0508b     00 00 00 7E | 	byte	$7e, $66, $66, $66, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $7e
0508f     7E 06 06 3E 
05093     3E 06 06 06 
05097     06 7E 7E 00 
0509b     00 00 00 7E | 	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $7e, $7e, $00, $00, $00, $00, $7e
0509f     7E 06 06 3E 
050a3     3E 06 06 06 
050a7     06 06 06 00 
050ab     00 00 00 7C | 	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $7c
050af     7E 06 06 76 
050b3     76 66 66 66 
050b7     66 7E 3C 00 
050bb     00 00 00 66 | 	byte	$7e, $06, $06, $76, $76, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $66
050bf     66 66 66 7E 
050c3     7E 66 66 66 
050c7     66 66 66 00 
050cb     00 00 00 7E | 	byte	$66, $66, $66, $7e, $7e, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $7e
050cf     7E 18 18 18 
050d3     18 18 18 18 
050d7     18 7E 7E 00 
050db     00 00 00 60 | 	byte	$7e, $18, $18, $18, $18, $18, $18, $18, $18, $7e, $7e, $00, $00, $00, $00, $60
050df     60 60 60 60 
050e3     60 60 60    | 	byte	$60[7]
050e6     66 66 7E 3C 
050ea     00 00 00 00 
050ee     66 66 36 36 
050f2     1E 1E 36 36 | 	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $36, $36, $1e, $1e, $36, $36
050f6     66 66 C6 C6 
050fa     00 00 00 00 
050fe     06 06 06 06 
05102     06 06 06 06 | 	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $06, $06, $06, $06, $06, $06, $06, $06
05106     06 06 7E 7E 
0510a     00 00 00 00 
0510e     C6 C6 EE EE 
05112     FE D6 D6 C6 | 	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $c6, $c6, $ee, $ee, $fe, $d6, $d6, $c6
05116     C6 C6 C6 C6 
0511a     00 00 00 00 
0511e     66 66 66 6E 
05122     6E 7E 7E 76 | 	byte	$c6, $c6, $c6, $c6, $00, $00, $00, $00, $66, $66, $66, $6e, $6e, $7e, $7e, $76
05126     76 66 66 66 
0512a     00 00 00 00 
0512e     3C 7E 66 66 
05132     66 66 66 66 | 	byte	$76, $66, $66, $66, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
05136     66 66 7E 3C 
0513a     00 00 00 00 
0513e     3E 7E 66 66 
05142     66 66 7E 3E | 	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $66, $7e, $3e
05146     06 06 06 06 
0514a     00 00 00 00 
0514e     3C 7E 66 66 
05152     66 66 66 66 | 	byte	$06, $06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
05156     66 56 3E 6C 
0515a     00 00 00 00 
0515e     3E 7E 66 66 
05162     66 7E 3E 36 | 	byte	$66, $56, $3e, $6c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $7e, $3e, $36
05166     66 66 C6 C6 
0516a     00 00 00 00 
0516e     7C 7E 06 06 
05172     0E 1C 38 70 | 	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $7c, $7e, $06, $06, $0e, $1c, $38, $70
05176     60 60 7E 3E 
0517a     00 00 00 00 
0517e     7E 7E 18 18 
05182     18 18 18 18 | 	byte	$60, $60, $7e, $3e, $00, $00, $00, $00, $7e, $7e, $18, $18, $18, $18, $18, $18
05186     18 18 18 18 
0518a     00 00 00 00 
0518e     66 66 66 66 
05192     66 66 66 66 | 	byte	$18, $18, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
05196     66 66 7E 3C 
0519a     00 00 00 00 
0519e     66 66 66 66 
051a2     66 66 66 66 | 	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
051a6     3C 3C 18 18 
051aa     00 00 00 00 
051ae     C6 C6 C6 C6 
051b2     C6 D6 D6 FE | 	byte	$3c, $3c, $18, $18, $00, $00, $00, $00, $c6, $c6, $c6, $c6, $c6, $d6, $d6, $fe
051b6     FE EE C6 82 
051ba     00 00 00 00 
051be     66 66 66 3C 
051c2     3C 18 18 3C | 	byte	$fe, $ee, $c6, $82, $00, $00, $00, $00, $66, $66, $66, $3c, $3c, $18, $18, $3c
051c6     3C 66 66 66 
051ca     00 00 00 00 
051ce     66 66 66 66 
051d2     66 3C 3C 18 | 	byte	$3c, $66, $66, $66, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c, $18
051d6     18 18 18 18 
051da     00 00 00 00 
051de     7E 7E 30 30 
051e2     18 18 0C 0C | 	byte	$18, $18, $18, $18, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $0c, $0c
051e6     06 06 7E 7E 
051ea     00 00 00 00 
051ee     3C 3C 0C 0C 
051f2     0C 0C 0C 0C | 	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $3c, $3c, $0c, $0c, $0c, $0c, $0c, $0c
051f6     0C 0C 3C 3C 
051fa     00 00 00 00 
051fe     06 06 0C 0C 
05202     18 18 30 30 | 	byte	$0c, $0c, $3c, $3c, $00, $00, $00, $00, $06, $06, $0c, $0c, $18, $18, $30, $30
05206     60 60 C0 C0 
0520a     00 00 00 00 
0520e     3C 3C 30 30 
05212     30 30 30 30 | 	byte	$60, $60, $c0, $c0, $00, $00, $00, $00, $3c, $3c, $30, $30, $30, $30, $30, $30
05216     30 30 3C 3C 
0521a     00 00 00 00 
0521e     18 18 3C 3C 
05222     66 66 00 00 | 	byte	$30, $30, $3c, $3c, $00, $00, $00, $00, $18, $18, $3c, $3c, $66, $66, $00, $00
05226     00 00 00 00 
0522a     00 00 00 00 
0522e     00 00 00 00 
05232     00 00 00 00 
05236     00 00       | 	byte	$00[18]
05238     FE FE 00 00 
0523c     00 00 0C 0C 
05240     18 18 00 00 
05244     00 00 00 00 | 	byte	$fe, $fe, $00, $00, $00, $00, $0c, $0c, $18, $18, $00, $00, $00, $00, $00, $00
05248     00 00 00 00 
0524c     00 00 00 00 
05250     00          | 	byte	$00[9]
05251     3C 7C 60 7C 
05255     7E 66 66 7E 
05259     7C 00 00 00 
0525d     00 06 06 06 | 	byte	$3c, $7c, $60, $7c, $7e, $66, $66, $7e, $7c, $00, $00, $00, $00, $06, $06, $06
05261     3E 7E 66 66 
05265     66 66 66 7E 
05269     3E 00 00 00 
0526d     00 00 00 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $00, $00, $00
05271     3C 3E 06 06 
05275     06 06 06 7E 
05279     7C 00 00 00 
0527d     00 60 60 60 | 	byte	$3c, $3e, $06, $06, $06, $06, $06, $7e, $7c, $00, $00, $00, $00, $60, $60, $60
05281     7C 7E 66 66 
05285     66 66 66 7E 
05289     7C 00 00 00 
0528d     00 00 00 00 | 	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $00, $00, $00, $00, $00, $00, $00
05291     3C 7E 66 66 
05295     7E 06 06 7E 
05299     7C 00 00 00 
0529d     00 70 78 18 | 	byte	$3c, $7e, $66, $66, $7e, $06, $06, $7e, $7c, $00, $00, $00, $00, $70, $78, $18
052a1     18 7E 7E 18 
052a5     18 18 18 18 
052a9     18 00 00 00 
052ad     00 00 00 00 | 	byte	$18, $7e, $7e, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
052b1     7C 7E 66 66 
052b5     66 66 7E 7C 
052b9     60 7E 3E 00 
052bd     00 06 06 06 | 	byte	$7c, $7e, $66, $66, $66, $66, $7e, $7c, $60, $7e, $3e, $00, $00, $06, $06, $06
052c1     3E 7E 66 66 
052c5     66 66 66 66 
052c9     66 00 00 00 
052cd     00 18 18 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $18, $18, $00
052d1     1C 1C 18 18 
052d5     18 18 18 3C 
052d9     3C 00 00 00 
052dd     00 30 30 00 | 	byte	$1c, $1c, $18, $18, $18, $18, $18, $3c, $3c, $00, $00, $00, $00, $30, $30, $00
052e1     30 30 30 30 
052e5     30 30 30 30 
052e9     30          | 	byte	$30[9]
052ea     3E 1E 00 00 
052ee     06 06 06 36 
052f2     36 1E 1E 1E 
052f6     36 36 66 66 | 	byte	$3e, $1e, $00, $00, $06, $06, $06, $36, $36, $1e, $1e, $1e, $36, $36, $66, $66
052fa     00 00 00 00 
052fe     1C 1C 18 18 
05302     18 18 18 18 
05306     18 18 3C 3C | 	byte	$00, $00, $00, $00, $1c, $1c, $18, $18, $18, $18, $18, $18, $18, $18, $3c, $3c
0530a     00 00 00 00 
0530e     00 00 00    | 	byte	$00[7]
05311     6C FE FE D6 
05315     D6 C6 C6 C6 
05319     C6 00 00 00 
0531d     00 00 00 00 | 	byte	$6c, $fe, $fe, $d6, $d6, $c6, $c6, $c6, $c6, $00, $00, $00, $00, $00, $00, $00
05321     3E 7E 66 66 
05325     66 66 66 66 
05329     66 00 00 00 
0532d     00 00 00 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
05331     3C 7E 66 66 
05335     66 66 66 7E 
05339     3C 00 00 00 
0533d     00 00 00 00 | 	byte	$3c, $7e, $66, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $00, $00, $00
05341     3E 7E 66 66 
05345     66 66 66 7E 
05349     3E 06 06 00 
0534d     00 00 00 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $06, $06, $00, $00, $00, $00, $00
05351     7C 7E 66 66 
05355     66 66 66 7E 
05359     7C 60 60 00 
0535d     00 00 00 00 | 	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $60, $60, $00, $00, $00, $00, $00
05361     3E 7E 66 06 
05365     06 06 06 06 
05369     06 00 00 00 
0536d     00 00 00 00 | 	byte	$3e, $7e, $66, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00
05371     7C 7E 06 0E 
05375     3C 70 60 7E 
05379     3E 00 00 00 
0537d     00 00 18 18 | 	byte	$7c, $7e, $06, $0e, $3c, $70, $60, $7e, $3e, $00, $00, $00, $00, $00, $18, $18
05381     7E 7E 18 18 
05385     18 18 18 78 
05389     70 00 00 00 
0538d     00 00 00 00 | 	byte	$7e, $7e, $18, $18, $18, $18, $18, $78, $70, $00, $00, $00, $00, $00, $00, $00
05391     66 66 66 66 
05395     66 66 66    | 	byte	$66[7]
05398     7E 7C 00 00 
0539c     00 00 00 00 
053a0     00 66 66 66 
053a4     66 66 3C 3C | 	byte	$7e, $7c, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c
053a8     18 18 00 00 
053ac     00 00 00 00 
053b0     00 C6 C6 D6 
053b4     D6 FE FE EE | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $c6, $c6, $d6, $d6, $fe, $fe, $ee
053b8     C6 82 00 00 
053bc     00 00 00 00 
053c0     00 66 66 3C 
053c4     3C 18 3C 3C | 	byte	$c6, $82, $00, $00, $00, $00, $00, $00, $00, $66, $66, $3c, $3c, $18, $3c, $3c
053c8     66 66 00 00 
053cc     00 00 00 00 
053d0     00 66 66 66 
053d4     66 66 66 7E | 	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $7e
053d8     7C 60 7E 3E 
053dc     00 00 00 00 
053e0     00 7E 7E 30 
053e4     18 18 0C 0C | 	byte	$7c, $60, $7e, $3e, $00, $00, $00, $00, $00, $7e, $7e, $30, $18, $18, $0c, $0c
053e8     7E 7E 00 00 
053ec     00 00 30 18 
053f0     18 18 18 0C 
053f4     0C 18 18 18 | 	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $18, $18, $18, $0c, $0c, $18, $18, $18
053f8     18 30 00 00 
053fc     00 00 18 18 
05400     18 18 18 18 
05404     18 18 18 18 | 	byte	$18, $30, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
05408     18 18 00 00 
0540c     00 00 0C 18 
05410     18 18 18 30 
05414     30 18 18 18 | 	byte	$18, $18, $00, $00, $00, $00, $0c, $18, $18, $18, $18, $30, $30, $18, $18, $18
05418     18 0C 00 00 
0541c     00 00 6C 7E 
05420     36 00 00 00 
05424     00 00 00 00 | 	byte	$18, $0c, $00, $00, $00, $00, $6c, $7e, $36, $00, $00, $00, $00, $00, $00, $00
05428     00 00 00 00 
0542c     00 00 00 00 
05430     00          | 	byte	$00[9]
05431     18 18 18 18 
05435     18 18 00 00 
05439     00 00 00    | 	byte	$18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
0543c     00 6C FE FE 
05440     7C 38 10 00 
05444     18 18 18 F8 
05448     F8 18 18 18 | a8_font        file "atari8.fnt"
0544c     C0 C0 C0 C0 
05450     C0 C0 C0 C0 | 	byte	$c0[8]
05454     18 18 18 1F 
05458     1F 00 00 00 
0545c     18 18 18 1F 
05460     1F 18 18 18 | 	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
05464     00 00 00 1F 
05468     1F 18 18 18 
0546c     C0 E0 70 38 
05470     1C 0E 07 03 | 	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
05474     03 07 0E 1C 
05478     38 70 E0 C0 
0547c     80 C0 E0 F0 
05480     F8 FC FE FF | 	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
05484     00 00 00 00 
05488     F0 F0 F0 F0 
0548c     01 03 07 0F 
05490     1F 3F 7F FF | 	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
05494     F0 F0 F0 F0 
05498     00 00 00 00 
0549c     0F 0F 0F 0F 
054a0     00 00 00 00 | 	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
054a4     FF FF 00 00 
054a8     00 00 00 00 
054ac     00 00 00 00 
054b0     00 00 FF FF | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
054b4     00 00 00 00 
054b8     0F 0F 0F 0F 
054bc     00 38 38 EE 
054c0     EE 10 38 00 | 	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
054c4     00 00 00 F8 
054c8     F8 18 18 18 
054cc     00 00 00 FF 
054d0     FF 00 00 00 | 	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
054d4     18 18 18 FF 
054d8     FF 18 18 18 
054dc     00 00 3C 7E 
054e0     7E 7E 3C 00 | 	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
054e4     00 00 00 00 
054e8     FF FF FF FF 
054ec     03 03 03 03 
054f0     03 03 03 03 | 	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
054f4     00 00 00 FF 
054f8     FF 18 18 18 
054fc     18 18 18 FF 
05500     FF 00 00 00 | 	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
05504     0F 0F 0F 0F 
05508     0F 0F 0F 0F | 	byte	$0f[8]
0550c     18 18 18 F8 
05510     F8 00 00 00 
05514     1E 06 1E 06 
05518     7E 18 78 00 | 	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
0551c     00 18 3C 7E 
05520     18 18 18 00 
05524     00 18 18 18 
05528     7E 3C 18 00 | 	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
0552c     00 18 0C 7E 
05530     0C 18 00 00 
05534     00 18 30 7E 
05538     30 18 00 00 | 	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
0553c     00 00 00 00 
05540     00 00 00 00 
05544     00          | 	byte	$00[9]
05545     18 18 18 18 
05549     00 18 00 00 
0554d     66 66 66 00 
05551     00 00 00 00 | 	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
05555     66 FF 66 66 
05559     FF 66 00 18 
0555d     7C 06 3C 60 
05561     3E 18 00 00 | 	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
05565     66 36 18 0C 
05569     66 62 00 38 
0556d     6C 38 1C F6 
05571     66 DC 00 00 | 	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
05575     18 18 18 00 
05579     00 00 00 00 
0557d     70 38 18 18 
05581     38 70 00 00 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
05585     0E 1C 18 18 
05589     1C 0E 00 00 
0558d     66 3C FF 3C 
05591     66 00 00 00 | 	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
05595     18 18 7E 18 
05599     18 00 00 00 
0559d     00 00 00 00 
055a1     18 18 0C 00 | 	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
055a5     00 00 7E 00 
055a9     00 00 00 00 
055ad     00 00 00 00 
055b1     18 18 00 00 | 	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
055b5     60 30 18 0C 
055b9     06 02 00 00 
055bd     3C 66 76 6E 
055c1     66 3C 00 00 | 	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
055c5     18 1C 18 18 
055c9     18 7E 00 00 
055cd     3C 66 30 18 
055d1     0C 7E 00 00 | 	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
055d5     7E 30 18 30 
055d9     66 3C 00 00 
055dd     30 38 3C 36 
055e1     7E 30 00 00 | 	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
055e5     7E 06 3E 60 
055e9     66 3C 00 00 
055ed     3C 06 3E 66 
055f1     66 3C 00 00 | 	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
055f5     7E 60 30 18 
055f9     0C 0C 00 00 
055fd     3C 66 3C 66 
05601     66 3C 00 00 | 	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
05605     3C 66 7C 60 
05609     30 1C 00 00 
0560d     00 18 18 00 
05611     18 18 00 00 | 	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
05615     00 18 18 00 
05619     18 18 0C 60 
0561d     30 18 0C 18 
05621     30 60 00 00 | 	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
05625     00 7E 00 00 
05629     7E 00 00 06 
0562d     0C 18 30 18 
05631     0C 06 00 00 | 	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
05635     3C 66 30 18 
05639     00 18 00 00 
0563d     3C 66 76 76 
05641     06 7C 00 00 | 	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
05645     18 3C 66 66 
05649     7E 66 00 00 
0564d     3E 66 3E 66 
05651     66 3E 00 00 | 	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
05655     3C 66 06 06 
05659     66 3C 00 00 
0565d     1E 36 66 66 
05661     36 1E 00 00 | 	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
05665     7E 06 3E 06 
05669     06 7E 00 00 
0566d     7E 06 3E 06 
05671     06 06 00 00 | 	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
05675     7C 06 06 76 
05679     66 7C 00 00 
0567d     66 66 7E 66 
05681     66 66 00 00 | 	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
05685     7E 18 18 18 
05689     18 7E 00 00 
0568d     60 60 60 60 
05691     66 3C 00 00 | 	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
05695     66 36 1E 1E 
05699     36 66 00 00 
0569d     06 06 06 06 
056a1     06 7E 00 00 | 	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
056a5     C6 EE FE D6 
056a9     C6 C6 00 00 
056ad     66 6E 7E 7E 
056b1     76 66 00 00 | 	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
056b5     3C 66 66 66 
056b9     66 3C 00 00 
056bd     3E 66 66 3E 
056c1     06 06 00 00 | 	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
056c5     3C 66 66 66 
056c9     36 6C 00 00 
056cd     3E 66 66 3E 
056d1     36 66 00 00 | 	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
056d5     3C 06 3C 60 
056d9     60 3C 00 00 
056dd     7E 18 18 18 
056e1     18 18 00 00 | 	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
056e5     66 66 66 66 
056e9     66          | 	byte	$66[5]
056ea     7E 00 00 66 
056ee     66 66 66 3C 
056f2     18 00 00 C6 
056f6     C6 D6 FE EE | 	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
056fa     C6 00 00 66 
056fe     66 3C 3C 66 
05702     66 00 00 66 
05706     66 3C 18 18 | 	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
0570a     18 00 00 7E 
0570e     30 18 0C 06 
05712     7E 00 00 78 
05716     18 18 18 18 | 	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
0571a     78 00 00 02 
0571e     06 0C 18 30 
05722     60 00 00 1E 
05726     18 18 18 18 | 	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
0572a     1E 00 00 10 
0572e     38 6C C6 00 
05732     00 00 00 00 
05736     00 00 00 00 | 	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
0573a     FF 00 00 18 
0573e     3C 7E 7E 3C 
05742     18 00 00 00 
05746     3C 60 7C 66 | 	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
0574a     7C 00 00 06 
0574e     06 3E 66 66 
05752     3E 00 00 00 
05756     3C 06 06 06 | 	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
0575a     3C 00 00 60 
0575e     60 7C 66 66 
05762     7C 00 00 00 
05766     3C 66 7E 06 | 	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
0576a     3C 00 00 70 
0576e     18 7C 18 18 
05772     18 00 00 00 
05776     7C 66 66 7C | 	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
0577a     60 3E 00 06 
0577e     06 3E 66 66 
05782     66 00 00 18 
05786     00 1C 18 18 | 	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
0578a     3C 00 00 60 
0578e     00 60 60 60 
05792     60 3C 00 06 
05796     06 36 1E 36 | 	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
0579a     66 00 00 1C 
0579e     18 18 18 18 
057a2     3C 00 00 00 
057a6     66 FE FE D6 | 	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
057aa     C6 00 00 00 
057ae     3E 66 66 66 
057b2     66 00 00 00 
057b6     3C 66 66 66 | 	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
057ba     3C 00 00 00 
057be     3E 66 66 3E 
057c2     06 06 00 00 
057c6     7C 66 66 7C | 	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
057ca     60 60 00 00 
057ce     3E 66 06 06 
057d2     06 00 00 00 
057d6     7C 06 3C 60 | 	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
057da     3E 00 00 18 
057de     7E 18 18 18 
057e2     70 00 00 00 
057e6     66 66 66 66 | 	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
057ea     7C 00 00 00 
057ee     66 66 66 3C 
057f2     18 00 00 00 
057f6     C6 D6 FE 7C | 	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
057fa     6C 00 00 00 
057fe     66 3C 18 3C 
05802     66 00 00 00 
05806     66 66 66 7C | 	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
0580a     30 1E 00 00 
0580e     7E 30 18 0C 
05812     7E 00 00 18 
05816     3C 7E 7E 18 | 	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
0581a     3C 00 18 18 
0581e     18 18 18 18 
05822     18 18 00 7E 
05826     1E 3E 76 66 | 	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
0582a     60 00 10 18 
0582e     1C 1E 1C 18 
05832     10 00 08 18 
05836     38 78 38 18 | 	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
0583a     08 00       | 	byte	$08, $00
0583c     00 6C FE FE 
05840     7C 38 10 00 
05844     18 18 18 F8 
05848     F8 18 18 18 | a8_font2       file "atari8.fnt"
0584c     C0 C0 C0 C0 
05850     C0 C0 C0 C0 | 	byte	$c0[8]
05854     18 18 18 1F 
05858     1F 00 00 00 
0585c     18 18 18 1F 
05860     1F 18 18 18 | 	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
05864     00 00 00 1F 
05868     1F 18 18 18 
0586c     C0 E0 70 38 
05870     1C 0E 07 03 | 	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
05874     03 07 0E 1C 
05878     38 70 E0 C0 
0587c     80 C0 E0 F0 
05880     F8 FC FE FF | 	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
05884     00 00 00 00 
05888     F0 F0 F0 F0 
0588c     01 03 07 0F 
05890     1F 3F 7F FF | 	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
05894     F0 F0 F0 F0 
05898     00 00 00 00 
0589c     0F 0F 0F 0F 
058a0     00 00 00 00 | 	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
058a4     FF FF 00 00 
058a8     00 00 00 00 
058ac     00 00 00 00 
058b0     00 00 FF FF | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
058b4     00 00 00 00 
058b8     0F 0F 0F 0F 
058bc     00 38 38 EE 
058c0     EE 10 38 00 | 	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
058c4     00 00 00 F8 
058c8     F8 18 18 18 
058cc     00 00 00 FF 
058d0     FF 00 00 00 | 	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
058d4     18 18 18 FF 
058d8     FF 18 18 18 
058dc     00 00 3C 7E 
058e0     7E 7E 3C 00 | 	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
058e4     00 00 00 00 
058e8     FF FF FF FF 
058ec     03 03 03 03 
058f0     03 03 03 03 | 	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
058f4     00 00 00 FF 
058f8     FF 18 18 18 
058fc     18 18 18 FF 
05900     FF 00 00 00 | 	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
05904     0F 0F 0F 0F 
05908     0F 0F 0F 0F | 	byte	$0f[8]
0590c     18 18 18 F8 
05910     F8 00 00 00 
05914     1E 06 1E 06 
05918     7E 18 78 00 | 	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
0591c     00 18 3C 7E 
05920     18 18 18 00 
05924     00 18 18 18 
05928     7E 3C 18 00 | 	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
0592c     00 18 0C 7E 
05930     0C 18 00 00 
05934     00 18 30 7E 
05938     30 18 00 00 | 	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
0593c     00 00 00 00 
05940     00 00 00 00 
05944     00          | 	byte	$00[9]
05945     18 18 18 18 
05949     00 18 00 00 
0594d     66 66 66 00 
05951     00 00 00 00 | 	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
05955     66 FF 66 66 
05959     FF 66 00 18 
0595d     7C 06 3C 60 
05961     3E 18 00 00 | 	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
05965     66 36 18 0C 
05969     66 62 00 38 
0596d     6C 38 1C F6 
05971     66 DC 00 00 | 	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
05975     18 18 18 00 
05979     00 00 00 00 
0597d     70 38 18 18 
05981     38 70 00 00 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
05985     0E 1C 18 18 
05989     1C 0E 00 00 
0598d     66 3C FF 3C 
05991     66 00 00 00 | 	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
05995     18 18 7E 18 
05999     18 00 00 00 
0599d     00 00 00 00 
059a1     18 18 0C 00 | 	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
059a5     00 00 7E 00 
059a9     00 00 00 00 
059ad     00 00 00 00 
059b1     18 18 00 00 | 	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
059b5     60 30 18 0C 
059b9     06 02 00 00 
059bd     3C 66 76 6E 
059c1     66 3C 00 00 | 	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
059c5     18 1C 18 18 
059c9     18 7E 00 00 
059cd     3C 66 30 18 
059d1     0C 7E 00 00 | 	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
059d5     7E 30 18 30 
059d9     66 3C 00 00 
059dd     30 38 3C 36 
059e1     7E 30 00 00 | 	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
059e5     7E 06 3E 60 
059e9     66 3C 00 00 
059ed     3C 06 3E 66 
059f1     66 3C 00 00 | 	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
059f5     7E 60 30 18 
059f9     0C 0C 00 00 
059fd     3C 66 3C 66 
05a01     66 3C 00 00 | 	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
05a05     3C 66 7C 60 
05a09     30 1C 00 00 
05a0d     00 18 18 00 
05a11     18 18 00 00 | 	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
05a15     00 18 18 00 
05a19     18 18 0C 60 
05a1d     30 18 0C 18 
05a21     30 60 00 00 | 	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
05a25     00 7E 00 00 
05a29     7E 00 00 06 
05a2d     0C 18 30 18 
05a31     0C 06 00 00 | 	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
05a35     3C 66 30 18 
05a39     00 18 00 00 
05a3d     3C 66 76 76 
05a41     06 7C 00 00 | 	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
05a45     18 3C 66 66 
05a49     7E 66 00 00 
05a4d     3E 66 3E 66 
05a51     66 3E 00 00 | 	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
05a55     3C 66 06 06 
05a59     66 3C 00 00 
05a5d     1E 36 66 66 
05a61     36 1E 00 00 | 	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
05a65     7E 06 3E 06 
05a69     06 7E 00 00 
05a6d     7E 06 3E 06 
05a71     06 06 00 00 | 	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
05a75     7C 06 06 76 
05a79     66 7C 00 00 
05a7d     66 66 7E 66 
05a81     66 66 00 00 | 	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
05a85     7E 18 18 18 
05a89     18 7E 00 00 
05a8d     60 60 60 60 
05a91     66 3C 00 00 | 	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
05a95     66 36 1E 1E 
05a99     36 66 00 00 
05a9d     06 06 06 06 
05aa1     06 7E 00 00 | 	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
05aa5     C6 EE FE D6 
05aa9     C6 C6 00 00 
05aad     66 6E 7E 7E 
05ab1     76 66 00 00 | 	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
05ab5     3C 66 66 66 
05ab9     66 3C 00 00 
05abd     3E 66 66 3E 
05ac1     06 06 00 00 | 	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
05ac5     3C 66 66 66 
05ac9     36 6C 00 00 
05acd     3E 66 66 3E 
05ad1     36 66 00 00 | 	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
05ad5     3C 06 3C 60 
05ad9     60 3C 00 00 
05add     7E 18 18 18 
05ae1     18 18 00 00 | 	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
05ae5     66 66 66 66 
05ae9     66          | 	byte	$66[5]
05aea     7E 00 00 66 
05aee     66 66 66 3C 
05af2     18 00 00 C6 
05af6     C6 D6 FE EE | 	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
05afa     C6 00 00 66 
05afe     66 3C 3C 66 
05b02     66 00 00 66 
05b06     66 3C 18 18 | 	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
05b0a     18 00 00 7E 
05b0e     30 18 0C 06 
05b12     7E 00 00 78 
05b16     18 18 18 18 | 	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
05b1a     78 00 00 02 
05b1e     06 0C 18 30 
05b22     60 00 00 1E 
05b26     18 18 18 18 | 	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
05b2a     1E 00 00 10 
05b2e     38 6C C6 00 
05b32     00 00 00 00 
05b36     00 00 00 00 | 	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
05b3a     FF 00 00 18 
05b3e     3C 7E 7E 3C 
05b42     18 00 00 00 
05b46     3C 60 7C 66 | 	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
05b4a     7C 00 00 06 
05b4e     06 3E 66 66 
05b52     3E 00 00 00 
05b56     3C 06 06 06 | 	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
05b5a     3C 00 00 60 
05b5e     60 7C 66 66 
05b62     7C 00 00 00 
05b66     3C 66 7E 06 | 	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
05b6a     3C 00 00 70 
05b6e     18 7C 18 18 
05b72     18 00 00 00 
05b76     7C 66 66 7C | 	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
05b7a     60 3E 00 06 
05b7e     06 3E 66 66 
05b82     66 00 00 18 
05b86     00 1C 18 18 | 	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
05b8a     3C 00 00 60 
05b8e     00 60 60 60 
05b92     60 3C 00 06 
05b96     06 36 1E 36 | 	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
05b9a     66 00 00 1C 
05b9e     18 18 18 18 
05ba2     3C 00 00 00 
05ba6     66 FE FE D6 | 	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
05baa     C6 00 00 00 
05bae     3E 66 66 66 
05bb2     66 00 00 00 
05bb6     3C 66 66 66 | 	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
05bba     3C 00 00 00 
05bbe     3E 66 66 3E 
05bc2     06 06 00 00 
05bc6     7C 66 66 7C | 	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
05bca     60 60 00 00 
05bce     3E 66 06 06 
05bd2     06 00 00 00 
05bd6     7C 06 3C 60 | 	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
05bda     3E 00 00 18 
05bde     7E 18 18 18 
05be2     70 00 00 00 
05be6     66 66 66 66 | 	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
05bea     7C 00 00 00 
05bee     66 66 66 3C 
05bf2     18 00 00 00 
05bf6     C6 D6 FE 7C | 	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
05bfa     6C 00 00 00 
05bfe     66 3C 18 3C 
05c02     66 00 00 00 
05c06     66 66 66 7C | 	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
05c0a     30 1E 00 00 
05c0e     7E 30 18 0C 
05c12     7E 00 00 18 
05c16     3C 7E 7E 18 | 	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
05c1a     3C 00 18 18 
05c1e     18 18 18 18 
05c22     18 18 00 7E 
05c26     1E 3E 76 66 | 	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
05c2a     60 00 10 18 
05c2e     1C 1E 1C 18 
05c32     10 00 08 18 
05c36     38 78 38 18 | 	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
05c3a     08 00       | 	byte	$08, $00
05c3c     00 00 00 00 
      ...             
05e48     00 00 00 00 
05e4c     00 00       | amiga_font     file "amigafont.def"
05e4e     18 18 18 18 
05e52     18 18       | 	byte	$18[6]
05e54     00 18 18 00 
05e58     00 00 00 00 
05e5c     00 00 66 66 
05e60     66 00 00 00 | 	byte	$00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $00, $00, $00
05e64     00 00 00 00 
05e68     00 00 00 00 
05e6c     00 00       | 	byte	$00[10]
05e6e     36 36 7F 36 
05e72     36 36 7F 36 
05e76     36 00 00 00 
05e7a     00 00 00 00 | 	byte	$36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $00, $00, $00
05e7e     18 7C 06 06 
05e82     3C 60 60 3E 
05e86     18 00 00 00 
05e8a     00 00 00 00 | 	byte	$18, $7c, $06, $06, $3c, $60, $60, $3e, $18, $00, $00, $00, $00, $00, $00, $00
05e8e     00 00 C6 69 
05e92     36 18 6C 96 
05e96     63 00 00 00 
05e9a     00 00 00 00 | 	byte	$00, $00, $c6, $69, $36, $18, $6c, $96, $63, $00, $00, $00, $00, $00, $00, $00
05e9e     1C 36 36 1E 
05ea2     6E 3B 33 73 
05ea6     DE 00 00 00 
05eaa     00 00 00 00 | 	byte	$1c, $36, $36, $1e, $6e, $3b, $33, $73, $de, $00, $00, $00, $00, $00, $00, $00
05eae     18 18 0C 00 
05eb2     00 00 00 00 
05eb6     00 00 00 00 
05eba     00 00 00 00 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
05ebe     30 18 0C 0C 
05ec2     0C 0C 0C 18 
05ec6     30 00 00 00 
05eca     00 00 00 00 | 	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00, $00
05ece     0C 18 30 30 
05ed2     30 30 30 18 
05ed6     0C 00 00 00 
05eda     00 00 00 00 | 	byte	$0c, $18, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00, $00
05ede     00 66 66 3C 
05ee2     FF 3C 66 66 
05ee6     00 00 00 00 
05eea     00 00 00 00 | 	byte	$00, $66, $66, $3c, $ff, $3c, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00
05eee     00 18 18 18 
05ef2     7E 18 18 18 
05ef6     00 00 00 00 
05efa     00 00 00 00 | 	byte	$00, $18, $18, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
05efe     00 00 00 00 
05f02     00 00 00    | 	byte	$00[7]
05f05     18 18 0C 00 
05f09     00 00 00 00 
05f0d     00 00 00 00 
05f11     00 7E 00 00 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00
05f15     00 00 00 00 
05f19     00 00 00 00 
05f1d     00 00 00 00 
05f21     00 00 00 00 | 	byte	$00[16]
05f25     18 18 00 00 
05f29     00 00 00 00 
05f2d     00 00 C0 60 
05f31     30 18 0C 06 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $c0, $60, $30, $18, $0c, $06
05f35     03 00 00 00 
05f39     00 00 00 00 
05f3d     00 3C 66 66 
05f41     76 7E 6E 66 | 	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $76, $7e, $6e, $66
05f45     66 3C 00 00 
05f49     00 00 00 00 
05f4d     00 18 1C 1E 
05f51     18 18 18 18 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18
05f55     18 18 00 00 
05f59     00 00 00 00 
05f5d     00 3C 66 60 
05f61     60 30 18 0C | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $30, $18, $0c
05f65     06 7E 00 00 
05f69     00 00 00 00 
05f6d     00 3C 66 60 
05f71     60 38 60 60 | 	byte	$06, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $38, $60, $60
05f75     66 3C 00 00 
05f79     00 00 00 00 
05f7d     00 30 38 3C 
05f81     36 33 7F 30 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30
05f85     30 30 00 00 
05f89     00 00 00 00 
05f8d     00 7E 06 06 
05f91     3E 60 60 60 | 	byte	$30, $30, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06, $3e, $60, $60, $60
05f95     66 3C 00 00 
05f99     00 00 00 00 
05f9d     00 38 0C 06 
05fa1     06 3E 66 66 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $06, $06, $3e, $66, $66
05fa5     66 3C 00 00 
05fa9     00 00 00 00 
05fad     00 7E 60 60 
05fb1     60 30 18 18 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $7e, $60, $60, $60, $30, $18, $18
05fb5     18 18 00 00 
05fb9     00 00 00 00 
05fbd     00 3C 66 66 
05fc1     66 3C 66 66 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $3c, $66, $66
05fc5     66 3C 00 00 
05fc9     00 00 00 00 
05fcd     00 3C 66 66 
05fd1     66 7C 60 60 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $7c, $60, $60
05fd5     30 1C 00 00 
05fd9     00 00 00 00 
05fdd     00 00 00 18 
05fe1     18 00 00 18 | 	byte	$30, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $18
05fe5     18 00 00 00 
05fe9     00 00 00 00 
05fed     00 00 00 18 
05ff1     18 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
05ff5     18 18 0C 00 
05ff9     00 00 00 00 
05ffd     00 00 00 60 
06001     18 06 18 60 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $60, $18, $06, $18, $60
06005     00 00 00 00 
06009     00 00 00 00 
0600d     00 00 00 00 | 	byte	$00[12]
06011     7E 00 7E 00 
06015     00 00 00 00 
06019     00 00 00 00 
0601d     00 00 00 06 | 	byte	$7e, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06
06021     18 60 18 06 
06025     00 00 00 00 
06029     00 00 00 00 
0602d     00 3C 66 60 | 	byte	$18, $60, $18, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60
06031     60 30 18 00 
06035     18 18 00 00 
06039     00 00 00 00 
0603d     00 3E 63 63 | 	byte	$60, $30, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
06041     7B 6B 7B 03 
06045     03 1E 00 00 
06049     00 00 00 00 
0604d     00 3E 63 63 | 	byte	$7b, $6b, $7b, $03, $03, $1e, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
06051     63 7F 63 63 
06055     63 63 00 00 
06059     00 00 00 00 
0605d     00 3E 66 66 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66
06061     66 3E 66 66 
06065     66 3E 00 00 
06069     00 00 00 00 
0606d     00 78 0C 06 | 	byte	$66, $3e, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $78, $0c, $06
06071     06 06 06 06 
06075     0C 78 00 00 
06079     00 00 00 00 
0607d     00 1F 33 63 | 	byte	$06, $06, $06, $06, $0c, $78, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $63
06081     63 63 63 63 
06085     33 1F 00 00 
06089     00 00 00 00 
0608d     00 7E 06 06 | 	byte	$63, $63, $63, $63, $33, $1f, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
06091     06 1E 06 06 
06095     06 7E 00 00 
06099     00 00 00 00 
0609d     00 7E 06 06 | 	byte	$06, $1e, $06, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
060a1     06 1E 06 06 
060a5     06 06 00 00 
060a9     00 00 00 00 
060ad     00 3C 66 06 | 	byte	$06, $1e, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06
060b1     06 76 66 66 
060b5     66 7C 00 00 
060b9     00 00 00 00 
060bd     00 63 63 63 | 	byte	$06, $76, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63
060c1     63 7F 63 63 
060c5     63 63 00 00 
060c9     00 00 00 00 
060cd     00 3C 18 18 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3c, $18, $18
060d1     18 18 18 18 
060d5     18          | 	byte	$18[5]
060d6     3C 00 00 00 
060da     00 00 00 00 
060de     60 60 60 60 
060e2     60 60 60 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60, $60, $60, $60, $60, $63
060e6     3E 00 00 00 
060ea     00 00 00 00 
060ee     C3 63 33 1B 
060f2     0F 1B 33 63 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $c3, $63, $33, $1b, $0f, $1b, $33, $63
060f6     C3 00 00 00 
060fa     00 00 00 00 
060fe     03 03 03 03 
06102     03 03 03 03 | 	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $03, $03, $03, $03, $03, $03, $03, $03
06106     7F 00 00 00 
0610a     00 00 00 00 
0610e     63 77 7F 6B 
06112     63 63 63 63 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $6b, $63, $63, $63, $63
06116     63 00 00 00 
0611a     00 00 00 00 
0611e     63 67 6F 7B 
06122     73 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7b, $73, $63, $63, $63
06126     63 00 00 00 
0612a     00 00 00 00 
0612e     3E 63 63 63 
06132     63 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63
06136     3E 00 00 00 
0613a     00 00 00 00 
0613e     3E 66 66 66 
06142     3E 06 06 06 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e, $06, $06, $06
06146     06 00 00 00 
0614a     00 00 00 00 
0614e     3E 63 63 63 
06152     63 63 63 7B | 	byte	$06, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $7b
06156     FE 00 00 00 
0615a     00 00 00 00 
0615e     1F 33 33 33 
06162     1F 1B 33 63 | 	byte	$fe, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $33, $33, $1f, $1b, $33, $63
06166     63 00 00 00 
0616a     00 00 00 00 
0616e     3C 66 06 0C 
06172     18 30 60 66 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06, $0c, $18, $30, $60, $66
06176     3C 00 00 00 
0617a     00 00 00 00 
0617e     7E 18 18 18 
06182     18 18 18 18 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $7e, $18, $18, $18, $18, $18, $18, $18
06186     18 00 00 00 
0618a     00 00 00 00 
0618e     63 63 63 63 
06192     63 63 63 63 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63
06196     3E 00 00 00 
0619a     00 00 00 00 
0619e     63 63 63 63 
061a2     63 36 36 1C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36, $36, $1c
061a6     08 00 00 00 
061aa     00 00 00 00 
061ae     C3 C3 C3 C3 
061b2     C3 DB FF E7 | 	byte	$08, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $c3, $c3, $c3, $db, $ff, $e7
061b6     C3 00 00 00 
061ba     00 00 00 00 
061be     C3 C3 66 3C 
061c2     18 3C 66 C3 | 	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $3c, $66, $c3
061c6     C3 00 00 00 
061ca     00 00 00 00 
061ce     C3 C3 66 3C 
061d2     18 18 18 18 | 	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $18, $18, $18
061d6     18 00 00 00 
061da     00 00 00 00 
061de     7F 60 60 30 
061e2     18 0C 06 03 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $7f, $60, $60, $30, $18, $0c, $06, $03
061e6     7F 00 00 00 
061ea     00 00 00 00 
061ee     3C 0C 0C 0C 
061f2     0C 0C 0C 0C | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
061f6     3C 00 00 00 
061fa     00 00 00 00 
061fe     00 03 06 0C 
06202     18 30 60 C0 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $03, $06, $0c, $18, $30, $60, $c0
06206     00 00 00 00 
0620a     00 00 00 00 | 	byte	$00[8]
0620e     3C 30 30 30 
06212     30 30 30 30 
06216     3C 00 00 00 
0621a     00 00 00 00 | 	byte	$3c, $30, $30, $30, $30, $30, $30, $30, $3c, $00, $00, $00, $00, $00, $00, $00
0621e     08 1C 36 63 
06222     00 00 00 00 
06226     00 00 00 00 
0622a     00 00 00 00 | 	byte	$08, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0622e     00 00 00 00 
06232     00 00 00 00 
06236     00          | 	byte	$00[9]
06237     7F 00 00 00 
0623b     00 00 00 18 
0623f     18 30 00 00 
06243     00 00 00 00 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $18, $18, $30, $00, $00, $00, $00, $00, $00
06247     00 00 00 00 
0624b     00 00 00 00 
0624f     00 00       | 	byte	$00[10]
06251     3C 60 7C 66 
06255     66 7C 00 00 
06259     00 00 00 00 
0625d     00 06 06 06 | 	byte	$3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $06, $06, $06
06261     3E 66 66 66 
06265     66 3E 00 00 
06269     00 00 00 00 
0626d     00 00 00 00 | 	byte	$3e, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
06271     3C 06 06 06 
06275     06 3C 00 00 
06279     00 00 00 00 
0627d     00 60 60 60 | 	byte	$3c, $06, $06, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60
06281     7C 66 66 66 
06285     66 7C 00 00 
06289     00 00 00 00 
0628d     00 00 00 00 | 	byte	$7c, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
06291     3C 66 7E 06 
06295     06 3C 00 00 
06299     00 00 00 00 
0629d     00 38 0C 0C | 	byte	$3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $0c
062a1     3E 0C 0C 0C 
062a5     0C 0C 00 00 
062a9     00 00 00 00 
062ad     00 00 00 00 | 	byte	$3e, $0c, $0c, $0c, $0c, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
062b1     7C 66 66 66 
062b5     7C 60 60 3C 
062b9     00 00 00 00 
062bd     00 06 06 06 | 	byte	$7c, $66, $66, $66, $7c, $60, $60, $3c, $00, $00, $00, $00, $00, $06, $06, $06
062c1     3E 66 66 66 
062c5     66 66 00 00 
062c9     00 00 00 00 
062cd     00 00 18 00 | 	byte	$3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $18, $00
062d1     18 18 18 18 
062d5     18          | 	byte	$18[5]
062d6     30 00 00 00 
062da     00 00 00 00 
062de     00 30 00 30 
062e2     30 30 30 30 | 	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $30, $00, $30, $30, $30, $30, $30
062e6     30 30 1E 00 
062ea     00 00 00 00 
062ee     03 03 03 33 
062f2     1B 0F 1B 33 | 	byte	$30, $30, $1e, $00, $00, $00, $00, $00, $03, $03, $03, $33, $1b, $0f, $1b, $33
062f6     63 00 00 00 
062fa     00 00 00 00 
062fe     18 18 18 18 
06302     18 18 18 18 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
06306     30 00 00 00 
0630a     00 00 00 00 
0630e     00 00 00 37 
06312     7F 6B 63 63 | 	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $63, $63
06316     63 00 00 00 
0631a     00 00 00 00 
0631e     00 00 00 3E 
06322     66 66 66 66 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $66
06326     66 00 00 00 
0632a     00 00 00 00 
0632e     00 00 00 3C 
06332     66 66 66 66 | 	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $66
06336     3C 00 00 00 
0633a     00 00 00 00 
0633e     00 00 00 3E 
06342     66 66 66 3E | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e
06346     06 06 06 00 
0634a     00 00 00 00 
0634e     00 00 00 7C 
06352     66 66 66 7C | 	byte	$06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7c, $66, $66, $66, $7c
06356     60 60 60 00 
0635a     00 00 00 00 
0635e     00 00 00 3E 
06362     66 06 06 06 | 	byte	$60, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $06, $06, $06
06366     06 00 00 00 
0636a     00 00 00 00 
0636e     00 00 00 3C 
06372     06 0C 30 60 | 	byte	$06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $06, $0c, $30, $60
06376     3E 00 00 00 
0637a     00 00 00 00 
0637e     00 0C 0C 3E 
06382     0C 0C 0C 0C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $0c, $0c, $3e, $0c, $0c, $0c, $0c
06386     38 00 00 00 
0638a     00 00 00 00 
0638e     00 00 00 66 
06392     66 66 66 66 | 	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66
06396     7C 00 00 00 
0639a     00 00 00 00 
0639e     00 00 00 66 
063a2     66 66 66 3C | 	byte	$7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
063a6     18 00 00 00 
063aa     00 00 00 00 
063ae     00 00 00 63 
063b2     63 63 6B 3E | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $6b, $3e
063b6     36 00 00 00 
063ba     00 00 00 00 
063be     00 00 00 63 
063c2     36 1C 1C 36 | 	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36
063c6     63 00 00 00 
063ca     00 00 00 00 
063ce     00 00 00 66 
063d2     66 66 66 3C | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
063d6     18 0C 06 00 
063da     00 00 00 00 
063de     00 00 00 7E 
063e2     30 18 0C 06 | 	byte	$18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $30, $18, $0c, $06
063e6     7E 00 00 00 
063ea     00 00 00 00 
063ee     70 18 18 18 
063f2     0E 18 18 18 | 	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18
063f6     70 00 00 00 
063fa     00 00 00 00 
063fe     18 18 18 18 
06402     18 18 18 18 | 	byte	$70, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
06406     18 00 00 00 
0640a     00 00 00 00 
0640e     0E 18 18 18 
06412     70 18 18 18 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18
06416     0E 00 00 00 
0641a     00 00 00 00 
0641e     46 5D 31 00 
06422     00 00 00 00 | 	byte	$0e, $00, $00, $00, $00, $00, $00, $00, $46, $5d, $31, $00, $00, $00, $00, $00
06426     00 00 00 00 
0642a     00 00 00 00 | 	byte	$00[8]
0642e     C0 F0 3C 0F 
06432     C3 F0 3C 0F 
06436     03 00 00 00 
0643a     00 00 00 00 | 	byte	$c0, $f0, $3c, $0f, $c3, $f0, $3c, $0f, $03, $00, $00, $00, $00, $00, $00, $00
0643e     18 18 00 18 
06442     18 18 18 18 
06446     18 00 00 00 
0644a     00 00 00 00 | 	byte	$18, $18, $00, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0644e     18 18 7E 1B 
06452     1B 7E 18 18 
06456     00 00 00 00 
0645a     00 00 00 00 | 	byte	$18, $18, $7e, $1b, $1b, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
0645e     78 CC 0C 0C 
06462     1E 0C 0C 06 
06466     7F 00 00 00 
0646a     00 00 00 00 | 	byte	$78, $cc, $0c, $0c, $1e, $0c, $0c, $06, $7f, $00, $00, $00, $00, $00, $00, $00
0646e     66 3C 66 66 
06472     3C 66 00 00 
06476     00 00 00 00 
0647a     00 00 00 00 | 	byte	$66, $3c, $66, $66, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0647e     C3 C3 66 3C 
06482     18 7E 18 18 
06486     18 00 00 00 
0648a     00 00 00 00 | 	byte	$c3, $c3, $66, $3c, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0648e     18 18 18 18 
06492     00 18 18 18 
06496     18 00 00 00 
0649a     00 00 00 00 | 	byte	$18, $18, $18, $18, $00, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0649e     3C 06 06 3C 
064a2     66 66 66 3C 
064a6     60 60 3C 00 
064aa     00 00 00 00 | 	byte	$3c, $06, $06, $3c, $66, $66, $66, $3c, $60, $60, $3c, $00, $00, $00, $00, $00
064ae     66 66 00 00 
064b2     00 00 00 00 
064b6     00 00 00 00 
064ba     00 00 00 00 | 	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
064be     7E 81 B9 85 
064c2     85 B9 81 7E 
064c6     00 00 00 00 
064ca     00 00 00 00 | 	byte	$7e, $81, $b9, $85, $85, $b9, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
064ce     3C 33 33 7E 
064d2     00 7F 00 00 
064d6     00 00 00 00 
064da     00 00 00 00 | 	byte	$3c, $33, $33, $7e, $00, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
064de     00 00 CC 66 
064e2     33 66 CC 00 
064e6     00 00 00 00 
064ea     00 00 00 00 | 	byte	$00, $00, $cc, $66, $33, $66, $cc, $00, $00, $00, $00, $00, $00, $00, $00, $00
064ee     7E 60 60 00 
064f2     00 00 00 00 
064f6     00 00 00 00 
064fa     00 00 00 00 | 	byte	$7e, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
064fe     7E 81 9D A5 
06502     9D A5 81 7E 
06506     00 00 00 00 
0650a     00 00 00 00 | 	byte	$7e, $81, $9d, $a5, $9d, $a5, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
0650e     7E 00 00 00 
06512     00 00 00 00 
06516     00 00 00 00 
0651a     00 00 00 00 | 	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0651e     3C 66 66 3C 
06522     00 00 00 00 
06526     00 00 00 00 
0652a     00 00 00 00 | 	byte	$3c, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0652e     18 18 18 7E 
06532     18 18 18 00 
06536     7E 00 00 00 
0653a     00 00 00 00 | 	byte	$18, $18, $18, $7e, $18, $18, $18, $00, $7e, $00, $00, $00, $00, $00, $00, $00
0653e     1E 30 30 18 
06542     0C 06 3E 00 
06546     00 00 00 00 
0654a     00 00 00 00 | 	byte	$1e, $30, $30, $18, $0c, $06, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
0654e     1E 30 30 1C 
06552     30 30 1E 00 
06556     00 00 00 00 
0655a     00 00 00 00 | 	byte	$1e, $30, $30, $1c, $30, $30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
0655e     30 18 0C 06 
06562     00 00 00 00 
06566     00 00 00 00 
0656a     00 00 00 00 | 	byte	$30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0656e     00 00 00 66 
06572     66 66 66 66 
06576     FE 06 06 00 
0657a     00 00 00 00 | 	byte	$00, $00, $00, $66, $66, $66, $66, $66, $fe, $06, $06, $00, $00, $00, $00, $00
0657e     7C 5E 5E 5E 
06582     5C 50 50 50 
06586     50 50 00 00 
0658a     00 00 00 00 | 	byte	$7c, $5e, $5e, $5e, $5c, $50, $50, $50, $50, $50, $00, $00, $00, $00, $00, $00
0658e     00 00 00 18 
06592     18 00 00 00 
06596     00 00 00 00 
0659a     00 00 00 00 | 	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0659e     00 00 00 00 
065a2     00 00 00 00 
065a6     00          | 	byte	$00[9]
065a7     30 18 00 00 
065ab     00 00 00 18 
065af     1C 18 18 18 
065b3     18 18 00 00 | 	byte	$30, $18, $00, $00, $00, $00, $00, $18, $1c, $18, $18, $18, $18, $18, $00, $00
065b7     00 00 00 00 
065bb     00 00 00    | 	byte	$00[7]
065be     3C 66 66 3C 
065c2     00 7E 00 00 
065c6     00 00 00 00 
065ca     00 00 00 00 | 	byte	$3c, $66, $66, $3c, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
065ce     00 00 33 66 
065d2     CC 66 33 00 
065d6     00 00 00 00 
065da     00 00 00 00 | 	byte	$00, $00, $33, $66, $cc, $66, $33, $00, $00, $00, $00, $00, $00, $00, $00, $00
065de     02 63 32 1A 
065e2     4E 66 F3 40 
065e6     40 00 00 00 
065ea     00 00 00 00 | 	byte	$02, $63, $32, $1a, $4e, $66, $f3, $40, $40, $00, $00, $00, $00, $00, $00, $00
065ee     04 C6 64 34 
065f2     7C 8C 46 23 
065f6     F0 00 00 00 
065fa     00 00 00 00 | 	byte	$04, $c6, $64, $34, $7c, $8c, $46, $23, $f0, $00, $00, $00, $00, $00, $00, $00
065fe     03 C4 66 34 
06602     5B 6C F6 43 
06606     40 00 00 00 
0660a     00 00 00 00 | 	byte	$03, $c4, $66, $34, $5b, $6c, $f6, $43, $40, $00, $00, $00, $00, $00, $00, $00
0660e     18 18 00 18 
06612     0C 06 06 66 
06616     3C 00 00 00 
0661a     00 00 00 00 | 	byte	$18, $18, $00, $18, $0c, $06, $06, $66, $3c, $00, $00, $00, $00, $00, $00, $00
0661e     06 0C 3E 63 
06622     63 7F 63 63 
06626     63 00 00 00 
0662a     00 00 00 00 | 	byte	$06, $0c, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
0662e     30 18 3E 63 
06632     63 7F 63 63 
06636     63 00 00 00 
0663a     00 00 00 00 | 	byte	$30, $18, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
0663e     0C 33 3E 63 
06642     63 63 7F 63 
06646     63 00 00 00 
0664a     00 00 00 00 | 	byte	$0c, $33, $3e, $63, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
0664e     4E 39 3E 63 
06652     63 7F 63 63 
06656     63 00 00 00 
0665a     00 00 00 00 | 	byte	$4e, $39, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
0665e     63 00 3E 63 
06662     63 7F 63 63 
06666     63 00 00 00 
0666a     00 00 00 00 | 	byte	$63, $00, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
0666e     1C 22 1C 36 
06672     63 63 7F 63 
06676     63 00 00 00 
0667a     00 00 00 00 | 	byte	$1c, $22, $1c, $36, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
0667e     F8 3C 3C 36 
06682     F6 3F 33 33 
06686     F3 00 00 00 
0668a     00 00 00 00 | 	byte	$f8, $3c, $3c, $36, $f6, $3f, $33, $33, $f3, $00, $00, $00, $00, $00, $00, $00
0668e     78 0C 06 06 
06692     06 06 06 0C 
06696     78 30 18 00 
0669a     00 00 00 00 | 	byte	$78, $0c, $06, $06, $06, $06, $06, $0c, $78, $30, $18, $00, $00, $00, $00, $00
0669e     0C 18 7E 06 
066a2     06 3E 06 06 
066a6     7E 00 00 00 
066aa     00 00 00 00 | 	byte	$0c, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
066ae     30 18 7E 06 
066b2     06 3E 06 06 
066b6     7E 00 00 00 
066ba     00 00 00 00 | 	byte	$30, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
066be     18 66 7E 06 
066c2     06 3E 06 06 
066c6     7E 00 00 00 
066ca     00 00 00 00 | 	byte	$18, $66, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
066ce     66 00 7E 06 
066d2     06 3E 06 06 
066d6     7E 00 00 00 
066da     00 00 00 00 | 	byte	$66, $00, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
066de     0C 18 3C 18 
066e2     18 18 18 18 
066e6     3C 00 00 00 
066ea     00 00 00 00 | 	byte	$0c, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
066ee     30 18 3C 18 
066f2     18 18 18 18 
066f6     3C 00 00 00 
066fa     00 00 00 00 | 	byte	$30, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
066fe     18 66 3C 18 
06702     18 18 18 18 
06706     3C 00 00 00 
0670a     00 00 00 00 | 	byte	$18, $66, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
0670e     66 00 3C 18 
06712     18 18 18 18 
06716     3C 00 00 00 
0671a     00 00 00 00 | 	byte	$66, $00, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
0671e     1E 36 66 66 
06722     6F 66 66 36 
06726     1E 00 00 00 
0672a     00 00 00 00 | 	byte	$1e, $36, $66, $66, $6f, $66, $66, $36, $1e, $00, $00, $00, $00, $00, $00, $00
0672e     8E 73 67 6F 
06732     7B 73 63 63 
06736     63 00 00 00 
0673a     00 00 00 00 | 	byte	$8e, $73, $67, $6f, $7b, $73, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
0673e     06 0C 3E 63 
06742     63 63 63 63 
06746     3E 00 00 00 
0674a     00 00 00 00 | 	byte	$06, $0c, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
0674e     30 18 3E 63 
06752     63 63 63 63 
06756     3E 00 00 00 
0675a     00 00 00 00 | 	byte	$30, $18, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
0675e     0C 33 3E 63 
06762     63 63 63 63 
06766     3E 00 00 00 
0676a     00 00 00 00 | 	byte	$0c, $33, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
0676e     8E 71 3E 63 
06772     63 63 63 63 
06776     3E 00 00 00 
0677a     00 00 00 00 | 	byte	$8e, $71, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
0677e     63 00 3E 63 
06782     63 63 63 63 
06786     3E 00 00 00 
0678a     00 00 00 00 | 	byte	$63, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
0678e     00 00 63 36 
06792     1C 1C 36 63 
06796     00 00 00 00 
0679a     00 00 00 00 | 	byte	$00, $00, $63, $36, $1c, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00
0679e     BE 63 73 7B 
067a2     6B 6F 67 63 
067a6     3F 00 00 00 
067aa     00 00 00 00 | 	byte	$be, $63, $73, $7b, $6b, $6f, $67, $63, $3f, $00, $00, $00, $00, $00, $00, $00
067ae     0C 18 63 63 
067b2     63 63 63 63 
067b6     3E 00 00 00 
067ba     00 00 00 00 | 	byte	$0c, $18, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
067be     18 0C 63 63 
067c2     63 63 63 63 
067c6     3E 00 00 00 
067ca     00 00 00 00 | 	byte	$18, $0c, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
067ce     08 36 63 63 
067d2     63 63 63 63 
067d6     3E 00 00 00 
067da     00 00 00 00 | 	byte	$08, $36, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
067de     63 00 63 63 
067e2     63 63 63 63 
067e6     3E 00 00 00 
067ea     00 00 00 00 | 	byte	$63, $00, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
067ee     30 18 C3 66 
067f2     3C 18 18 18 
067f6     18 00 00 00 
067fa     00 00 00 00 | 	byte	$30, $18, $c3, $66, $3c, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
067fe     03 03 3F 63 
06802     63 3F 03 03 
06806     03 00 00 00 
0680a     00 00 00 00 | 	byte	$03, $03, $3f, $63, $63, $3f, $03, $03, $03, $00, $00, $00, $00, $00, $00, $00
0680e     3C 66 66 66 
06812     36 66 66 66 
06816     36 06 06 00 
0681a     00 00 00 00 | 	byte	$3c, $66, $66, $66, $36, $66, $66, $66, $36, $06, $06, $00, $00, $00, $00, $00
0681e     06 0C 00 3C 
06822     60 7C 66 66 
06826     7C 00 00 00 
0682a     00 00 00 00 | 	byte	$06, $0c, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
0682e     60 30 00 3C 
06832     60 7C 66 66 
06836     7C 00 00 00 
0683a     00 00 00 00 | 	byte	$60, $30, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
0683e     18 66 00 3C 
06842     60 7C 66 66 
06846     7C 00 00 00 
0684a     00 00 00 00 | 	byte	$18, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
0684e     8E 71 00 3C 
06852     60 7C 66 66 
06856     7C 00 00 00 
0685a     00 00 00 00 | 	byte	$8e, $71, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
0685e     00 66 00 3C 
06862     60 7C 66 66 
06866     7C 00 00 00 
0686a     00 00 00 00 | 	byte	$00, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
0686e     18 24 18 3C 
06872     60 7C 66 66 
06876     7C 00 00 00 
0687a     00 00 00 00 | 	byte	$18, $24, $18, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
0687e     00 00 00 7E 
06882     D8 FE 1B 1B 
06886     EE 00 00 00 
0688a     00 00 00 00 | 	byte	$00, $00, $00, $7e, $d8, $fe, $1b, $1b, $ee, $00, $00, $00, $00, $00, $00, $00
0688e     00 00 00 3C 
06892     06 06 06 06 
06896     3C 18 0C 00 
0689a     00 00 00 00 | 	byte	$00, $00, $00, $3c, $06, $06, $06, $06, $3c, $18, $0c, $00, $00, $00, $00, $00
0689e     06 0C 00 3C 
068a2     66 7E 06 06 
068a6     3C 00 00 00 
068aa     00 00 00 00 | 	byte	$06, $0c, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
068ae     60 30 00 3C 
068b2     66 7E 06 06 
068b6     3C 00 00 00 
068ba     00 00 00 00 | 	byte	$60, $30, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
068be     18 66 00 3C 
068c2     66 7E 06 06 
068c6     3C 00 00 00 
068ca     00 00 00 00 | 	byte	$18, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
068ce     00 66 00 3C 
068d2     66 7E 06 06 
068d6     3C 00 00 00 
068da     00 00 00 00 | 	byte	$00, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
068de     0C 18 00 18 
068e2     18 18 18 18 
068e6     30 00 00 00 
068ea     00 00 00 00 | 	byte	$0c, $18, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
068ee     18 0C 00 0C 
068f2     0C 0C 0C 0C 
068f6     18 00 00 00 
068fa     00 00 00 00 | 	byte	$18, $0c, $00, $0c, $0c, $0c, $0c, $0c, $18, $00, $00, $00, $00, $00, $00, $00
068fe     18 66 00 18 
06902     18 18 18 18 
06906     30 00 00 00 
0690a     00 00 00 00 | 	byte	$18, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
0690e     00 66 00 18 
06912     18 18 18 18 
06916     30 00 00 00 
0691a     00 00 00 00 | 	byte	$00, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
0691e     03 06 3F 18 
06922     3C 66 66 66 
06926     3C 00 00 00 
0692a     00 00 00 00 | 	byte	$03, $06, $3f, $18, $3c, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
0692e     8E 71 00 3E 
06932     66 66 66 66 
06936     66 00 00 00 
0693a     00 00 00 00 | 	byte	$8e, $71, $00, $3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
0693e     06 0C 00 3C 
06942     66 66 66 66 
06946     3C 00 00 00 
0694a     00 00 00 00 | 	byte	$06, $0c, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
0694e     60 30 00 3C 
06952     66 66 66 66 
06956     3C 00 00 00 
0695a     00 00 00 00 | 	byte	$60, $30, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
0695e     18 66 00 3C 
06962     66 66 66 66 
06966     3C 00 00 00 
0696a     00 00 00 00 | 	byte	$18, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
0696e     8E 71 00 3C 
06972     66 66 66 66 
06976     3C 00 00 00 
0697a     00 00 00 00 | 	byte	$8e, $71, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
0697e     00 66 00 3C 
06982     66 66 66 66 
06986     3C 00 00 00 
0698a     00 00 00 00 | 	byte	$00, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
0698e     00 18 18 00 
06992     7E 00 18 18 
06996     00 00 00 00 
0699a     00 00 00 00 | 	byte	$00, $18, $18, $00, $7e, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
0699e     00 00 00 7E 
069a2     73 7B 6F 67 
069a6     3F 00 00 00 
069aa     00 00 00 00 | 	byte	$00, $00, $00, $7e, $73, $7b, $6f, $67, $3f, $00, $00, $00, $00, $00, $00, $00
069ae     0C 18 00 66 
069b2     66 66 66 66 
069b6     7C 00 00 00 
069ba     00 00 00 00 | 	byte	$0c, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
069be     30 18 00 66 
069c2     66 66 66 66 
069c6     7C 00 00 00 
069ca     00 00 00 00 | 	byte	$30, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
069ce     18 66 00 66 
069d2     66 66 66 66 
069d6     7C 00 00 00 
069da     00 00 00 00 | 	byte	$18, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
069de     00 66 00 66 
069e2     66 66 66 66 
069e6     7C 00 00 00 
069ea     00 00 00 00 | 	byte	$00, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
069ee     30 18 00 66 
069f2     66 66 66 3C 
069f6     18 0C 06 00 
069fa     00 00 00 00 | 	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
069fe     06 06 06 3E 
06a02     66 66 66 3E 
06a06     06 06 06 00 
06a0a     00 00 00 00 | 	byte	$06, $06, $06, $3e, $66, $66, $66, $3e, $06, $06, $06, $00, $00, $00, $00, $00
06a0e     00 66 00 66 
06a12     66 66 66 3C 
06a16     18 0C 06 00 
06a1a     00 00 00 00 | 	byte	$00, $66, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
06a1e     00 7E 66 66 
06a22     66 66 66 66 
06a26     66 7E 00 00 
06a2a     00 00 00 00 | 	byte	$00, $7e, $66, $66, $66, $66, $66, $66, $66, $7e, $00, $00, $00, $00, $00, $00
06a2e     00 00 00 00 
      ...             
06c36     00 00 00 00 
06c3a     00 00       | 	byte	$00[526]
06c3c     00 00 00 00 
06c40     00          | vga16          long  $00000000,$00008000,$00800000,$00808000,$80000000,$80008000,$80400000,$AAAAAA00,$55555500,$0000FF00,$00FF0000,$00FFFF00,$FF000000,$FF00FF00,$FFFF0000,$FFFFFF00
06c41     80 00 00 00 
06c45     00 80 00 00 
06c49     80 80 00 00 
06c4d     00 00 80 00 | 	byte	$80, $00, $00, $00, $00, $80, $00, $00, $80, $80, $00, $00, $00, $00, $80, $00
06c51     80 00 80 00 
06c55     00 40 80 00 
06c59     AA AA AA 00 
06c5d     55 55 55 00 | 	byte	$80, $00, $80, $00, $00, $40, $80, $00, $aa, $aa, $aa, $00, $55, $55, $55, $00
06c61     FF 00 00 00 
06c65     00 FF 00 00 
06c69     FF FF 00 00 
06c6d     00 00 FF 00 | 	byte	$ff, $00, $00, $00, $00, $ff, $00, $00, $ff, $ff, $00, $00, $00, $00, $ff, $00
06c71     FF 00 FF 00 
06c75     00 FF FF 00 
06c79     FF FF FF    | 	byte	$ff, $00, $ff, $00, $00, $ff, $ff, $00, $ff, $ff, $ff
06c7c     00 00 00 00 
06c80     00          | ataripalette   file "ataripalettep2.def"
06c81     11 11 11 00 
06c85     22 22 22 00 
06c89     33 33 33 00 
06c8d     44 44 44 00 | 	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
06c91     55 55 55 00 
06c95     66 66 66 00 
06c99     77 77 77 00 
06c9d     88 88 88 00 | 	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
06ca1     99 99 99 00 
06ca5     AA AA AA 00 
06ca9     BB BB BB 00 
06cad     CC CC CC 00 | 	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
06cb1     DD DD DD 00 
06cb5     EE EE EE 00 
06cb9     FF FF FF 00 
06cbd     00 0A 20 00 | 	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
06cc1     00 14 40 00 
06cc5     00 1E 60 00 
06cc9     00 28 80 00 
06ccd     00 32 9F 00 | 	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
06cd1     00 3C BF 00 
06cd5     00 46 DF 00 
06cd9     00 50 FF 00 
06cdd     1C 63 FF 00 | 	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
06ce1     39 77 FF 00 
06ce5     55 8A FF 00 
06ce9     71 9E FF 00 
06ced     8E B1 FF 00 | 	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
06cf1     AA C5 FF 00 
06cf5     C6 D8 FF 00 
06cf9     E3 EC FF 00 
06cfd     00 00 20 00 | 	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
06d01     00 00 40 00 
06d05     00 00 60 00 
06d09     00 00 80 00 
06d0d     00 00 9F 00 | 	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
06d11     00 00 BF 00 
06d15     00 00 DF 00 
06d19     00 00 FF 00 
06d1d     1C 1C FF 00 | 	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
06d21     39 39 FF 00 
06d25     55 55 FF 00 
06d29     71 71 FF 00 
06d2d     8E 8E FF 00 | 	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
06d31     AA AA FF 00 
06d35     C6 C6 FF 00 
06d39     E3 E3 FF 00 
06d3d     10 00 20 00 | 	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
06d41     20 00 40 00 
06d45     30 00 60 00 
06d49     40 00 80 00 
06d4d     50 00 9F 00 | 	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
06d51     60 00 BF 00 
06d55     70 00 DF 00 
06d59     80 00 FF 00 
06d5d     8E 1C FF 00 | 	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
06d61     9C 39 FF 00 
06d65     AA 55 FF 00 
06d69     B8 71 FF 00 
06d6d     C7 8E FF 00 | 	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
06d71     D5 AA FF 00 
06d75     E3 C6 FF 00 
06d79     F1 E3 FF 00 
06d7d     20 00 20 00 | 	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
06d81     40 00 40 00 
06d85     60 00 60 00 
06d89     80 00 80 00 
06d8d     9F 00 9F 00 | 	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
06d91     BF 00 BF 00 
06d95     DF 00 DF 00 
06d99     FF 00 FF 00 
06d9d     FF 1C FF 00 | 	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
06da1     FF 39 FF 00 
06da5     FF 55 FF 00 
06da9     FF 71 FF 00 
06dad     FF 8E FF 00 | 	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
06db1     FF AA FF 00 
06db5     FF C6 FF 00 
06db9     FF E3 FF 00 
06dbd     20 00 10 00 | 	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
06dc1     40 00 20 00 
06dc5     60 00 30 00 
06dc9     80 00 40 00 
06dcd     9F 00 50 00 | 	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
06dd1     BF 00 60 00 
06dd5     DF 00 70 00 
06dd9     FF 00 80 00 
06ddd     FF 1C 8E 00 | 	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
06de1     FF 39 9C 00 
06de5     FF 55 AA 00 
06de9     FF 71 B8 00 
06ded     FF 8E C7 00 | 	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
06df1     FF AA D5 00 
06df5     FF C6 E3 00 
06df9     FF E3 F1 00 
06dfd     20 00 00 00 | 	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
06e01     40 00 00 00 
06e05     60 00 00 00 
06e09     80 00 00 00 
06e0d     9F 00 00 00 | 	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
06e11     BF 00 00 00 
06e15     DF 00 00 00 
06e19     FF 00 00 00 
06e1d     FF 1C 1C 00 | 	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
06e21     FF 39 39 00 
06e25     FF 55 55 00 
06e29     FF 71 71 00 
06e2d     FF 8E 8E 00 | 	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
06e31     FF AA AA 00 
06e35     FF C6 C6 00 
06e39     FF E3 E3 00 
06e3d     20 08 00 00 | 	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
06e41     40 10 00 00 
06e45     60 18 00 00 
06e49     80 20 00 00 
06e4d     9F 28 00 00 | 	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
06e51     BF 30 00 00 
06e55     DF 38 00 00 
06e59     FF 40 00 00 
06e5d     FF 55 1C 00 | 	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
06e61     FF 6A 39 00 
06e65     FF 80 55 00 
06e69     FF 95 71 00 
06e6d     FF AA 8E 00 | 	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
06e71     FF BF AA 00 
06e75     FF D5 C6 00 
06e79     FF EA E3 00 
06e7d     20 10 00 00 | 	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
06e81     40 20 00 00 
06e85     60 30 00 00 
06e89     80 40 00 00 
06e8d     9F 50 00 00 | 	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
06e91     BF 60 00 00 
06e95     DF 70 00 00 
06e99     FF 80 00 00 
06e9d     FF 8E 1C 00 | 	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
06ea1     FF 9C 39 00 
06ea5     FF AA 55 00 
06ea9     FF B8 71 00 
06ead     FF C7 8E 00 | 	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
06eb1     FF D5 AA 00 
06eb5     FF E3 C6 00 
06eb9     FF F1 E3 00 
06ebd     20 18 00 00 | 	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
06ec1     40 30 00 00 
06ec5     60 48 00 00 
06ec9     80 60 00 00 
06ecd     9F 78 00 00 | 	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
06ed1     BF 90 00 00 
06ed5     DF A8 00 00 
06ed9     FF C0 00 00 
06edd     FF C7 1C 00 | 	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
06ee1     FF CE 39 00 
06ee5     FF D5 55 00 
06ee9     FF DC 71 00 
06eed     FF E3 8E 00 | 	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
06ef1     FF EA AA 00 
06ef5     FF F1 C6 00 
06ef9     FF F8 E3 00 
06efd     18 20 00 00 | 	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
06f01     30 40 00 00 
06f05     48 60 00 00 
06f09     60 80 00 00 
06f0d     78 9F 00 00 | 	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
06f11     90 BF 00 00 
06f15     A8 DF 00 00 
06f19     C0 FF 00 00 
06f1d     C7 FF 1C 00 | 	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
06f21     CE FF 39 00 
06f25     D5 FF 55 00 
06f29     DC FF 71 00 
06f2d     E3 FF 8E 00 | 	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
06f31     EA FF AA 00 
06f35     F1 FF C6 00 
06f39     F8 FF E3 00 
06f3d     00 20 00 00 | 	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
06f41     00 40 00 00 
06f45     00 60 00 00 
06f49     00 80 00 00 
06f4d     00 9F 00 00 | 	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
06f51     00 BF 00 00 
06f55     00 DF 00 00 
06f59     00 FF 00 00 
06f5d     1C FF 1C 00 | 	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
06f61     39 FF 39 00 
06f65     55 FF 55 00 
06f69     71 FF 71 00 
06f6d     8E FF 8E 00 | 	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
06f71     AA FF AA 00 
06f75     C6 FF C6 00 
06f79     E3 FF E3 00 
06f7d     00 20 0A 00 | 	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
06f81     00 40 14 00 
06f85     00 60 1E 00 
06f89     00 80 28 00 
06f8d     00 9F 32 00 | 	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
06f91     00 BF 3C 00 
06f95     00 DF 46 00 
06f99     00 FF 50 00 
06f9d     1C FF 63 00 | 	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
06fa1     39 FF 77 00 
06fa5     55 FF 8A 00 
06fa9     71 FF 9E 00 
06fad     8E FF B1 00 | 	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
06fb1     AA FF C5 00 
06fb5     C6 FF D8 00 
06fb9     E3 FF EC 00 
06fbd     00 20 14 00 | 	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
06fc1     00 40 28 00 
06fc5     00 60 3C 00 
06fc9     00 80 50 00 
06fcd     00 9F 64 00 | 	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
06fd1     00 BF 78 00 
06fd5     00 DF 8C 00 
06fd9     00 FF A0 00 
06fdd     1C FF AB 00 | 	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
06fe1     39 FF B5 00 
06fe5     55 FF C0 00 
06fe9     71 FF CA 00 
06fed     8E FF D5 00 | 	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
06ff1     AA FF DF 00 
06ff5     C6 FF EA 00 
06ff9     E3 FF F4 00 
06ffd     00 20 20 00 | 	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
07001     00 40 40 00 
07005     00 60 60 00 
07009     00 80 80 00 
0700d     00 9F 9F 00 | 	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
07011     00 BF BF 00 
07015     00 DF DF 00 
07019     00 FF FF 00 
0701d     1C FF FF 00 | 	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
07021     39 FF FF 00 
07025     55 FF FF 00 
07029     71 FF FF 00 
0702d     8E FF FF 00 | 	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
07031     AA FF FF 00 
07035     C6 FF FF 00 
07039     E3 FF FF 00 
0703d     00 14 20 00 | 	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
07041     00 28 40 00 
07045     00 3C 60 00 
07049     00 50 80 00 
0704d     00 64 9F 00 | 	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
07051     00 78 BF 00 
07055     00 8C DF 00 
07059     00 A0 FF 00 
0705d     1C AB FF 00 | 	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
07061     39 B5 FF 00 
07065     55 C0 FF 00 
07069     71 CA FF 00 
0706d     8E D5 FF 00 | 	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
07071     AA DF FF 00 
07075     C6 EA FF 00 
07079     E3 F4 FF    | 	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
0707c     00 00 00 00 
07080     00          | ataripalette2  file "ataripalettep2.def"
07081     11 11 11 00 
07085     22 22 22 00 
07089     33 33 33 00 
0708d     44 44 44 00 | 	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
07091     55 55 55 00 
07095     66 66 66 00 
07099     77 77 77 00 
0709d     88 88 88 00 | 	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
070a1     99 99 99 00 
070a5     AA AA AA 00 
070a9     BB BB BB 00 
070ad     CC CC CC 00 | 	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
070b1     DD DD DD 00 
070b5     EE EE EE 00 
070b9     FF FF FF 00 
070bd     00 0A 20 00 | 	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
070c1     00 14 40 00 
070c5     00 1E 60 00 
070c9     00 28 80 00 
070cd     00 32 9F 00 | 	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
070d1     00 3C BF 00 
070d5     00 46 DF 00 
070d9     00 50 FF 00 
070dd     1C 63 FF 00 | 	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
070e1     39 77 FF 00 
070e5     55 8A FF 00 
070e9     71 9E FF 00 
070ed     8E B1 FF 00 | 	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
070f1     AA C5 FF 00 
070f5     C6 D8 FF 00 
070f9     E3 EC FF 00 
070fd     00 00 20 00 | 	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
07101     00 00 40 00 
07105     00 00 60 00 
07109     00 00 80 00 
0710d     00 00 9F 00 | 	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
07111     00 00 BF 00 
07115     00 00 DF 00 
07119     00 00 FF 00 
0711d     1C 1C FF 00 | 	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
07121     39 39 FF 00 
07125     55 55 FF 00 
07129     71 71 FF 00 
0712d     8E 8E FF 00 | 	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
07131     AA AA FF 00 
07135     C6 C6 FF 00 
07139     E3 E3 FF 00 
0713d     10 00 20 00 | 	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
07141     20 00 40 00 
07145     30 00 60 00 
07149     40 00 80 00 
0714d     50 00 9F 00 | 	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
07151     60 00 BF 00 
07155     70 00 DF 00 
07159     80 00 FF 00 
0715d     8E 1C FF 00 | 	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
07161     9C 39 FF 00 
07165     AA 55 FF 00 
07169     B8 71 FF 00 
0716d     C7 8E FF 00 | 	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
07171     D5 AA FF 00 
07175     E3 C6 FF 00 
07179     F1 E3 FF 00 
0717d     20 00 20 00 | 	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
07181     40 00 40 00 
07185     60 00 60 00 
07189     80 00 80 00 
0718d     9F 00 9F 00 | 	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
07191     BF 00 BF 00 
07195     DF 00 DF 00 
07199     FF 00 FF 00 
0719d     FF 1C FF 00 | 	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
071a1     FF 39 FF 00 
071a5     FF 55 FF 00 
071a9     FF 71 FF 00 
071ad     FF 8E FF 00 | 	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
071b1     FF AA FF 00 
071b5     FF C6 FF 00 
071b9     FF E3 FF 00 
071bd     20 00 10 00 | 	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
071c1     40 00 20 00 
071c5     60 00 30 00 
071c9     80 00 40 00 
071cd     9F 00 50 00 | 	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
071d1     BF 00 60 00 
071d5     DF 00 70 00 
071d9     FF 00 80 00 
071dd     FF 1C 8E 00 | 	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
071e1     FF 39 9C 00 
071e5     FF 55 AA 00 
071e9     FF 71 B8 00 
071ed     FF 8E C7 00 | 	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
071f1     FF AA D5 00 
071f5     FF C6 E3 00 
071f9     FF E3 F1 00 
071fd     20 00 00 00 | 	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
07201     40 00 00 00 
07205     60 00 00 00 
07209     80 00 00 00 
0720d     9F 00 00 00 | 	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
07211     BF 00 00 00 
07215     DF 00 00 00 
07219     FF 00 00 00 
0721d     FF 1C 1C 00 | 	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
07221     FF 39 39 00 
07225     FF 55 55 00 
07229     FF 71 71 00 
0722d     FF 8E 8E 00 | 	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
07231     FF AA AA 00 
07235     FF C6 C6 00 
07239     FF E3 E3 00 
0723d     20 08 00 00 | 	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
07241     40 10 00 00 
07245     60 18 00 00 
07249     80 20 00 00 
0724d     9F 28 00 00 | 	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
07251     BF 30 00 00 
07255     DF 38 00 00 
07259     FF 40 00 00 
0725d     FF 55 1C 00 | 	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
07261     FF 6A 39 00 
07265     FF 80 55 00 
07269     FF 95 71 00 
0726d     FF AA 8E 00 | 	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
07271     FF BF AA 00 
07275     FF D5 C6 00 
07279     FF EA E3 00 
0727d     20 10 00 00 | 	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
07281     40 20 00 00 
07285     60 30 00 00 
07289     80 40 00 00 
0728d     9F 50 00 00 | 	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
07291     BF 60 00 00 
07295     DF 70 00 00 
07299     FF 80 00 00 
0729d     FF 8E 1C 00 | 	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
072a1     FF 9C 39 00 
072a5     FF AA 55 00 
072a9     FF B8 71 00 
072ad     FF C7 8E 00 | 	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
072b1     FF D5 AA 00 
072b5     FF E3 C6 00 
072b9     FF F1 E3 00 
072bd     20 18 00 00 | 	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
072c1     40 30 00 00 
072c5     60 48 00 00 
072c9     80 60 00 00 
072cd     9F 78 00 00 | 	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
072d1     BF 90 00 00 
072d5     DF A8 00 00 
072d9     FF C0 00 00 
072dd     FF C7 1C 00 | 	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
072e1     FF CE 39 00 
072e5     FF D5 55 00 
072e9     FF DC 71 00 
072ed     FF E3 8E 00 | 	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
072f1     FF EA AA 00 
072f5     FF F1 C6 00 
072f9     FF F8 E3 00 
072fd     18 20 00 00 | 	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
07301     30 40 00 00 
07305     48 60 00 00 
07309     60 80 00 00 
0730d     78 9F 00 00 | 	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
07311     90 BF 00 00 
07315     A8 DF 00 00 
07319     C0 FF 00 00 
0731d     C7 FF 1C 00 | 	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
07321     CE FF 39 00 
07325     D5 FF 55 00 
07329     DC FF 71 00 
0732d     E3 FF 8E 00 | 	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
07331     EA FF AA 00 
07335     F1 FF C6 00 
07339     F8 FF E3 00 
0733d     00 20 00 00 | 	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
07341     00 40 00 00 
07345     00 60 00 00 
07349     00 80 00 00 
0734d     00 9F 00 00 | 	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
07351     00 BF 00 00 
07355     00 DF 00 00 
07359     00 FF 00 00 
0735d     1C FF 1C 00 | 	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
07361     39 FF 39 00 
07365     55 FF 55 00 
07369     71 FF 71 00 
0736d     8E FF 8E 00 | 	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
07371     AA FF AA 00 
07375     C6 FF C6 00 
07379     E3 FF E3 00 
0737d     00 20 0A 00 | 	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
07381     00 40 14 00 
07385     00 60 1E 00 
07389     00 80 28 00 
0738d     00 9F 32 00 | 	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
07391     00 BF 3C 00 
07395     00 DF 46 00 
07399     00 FF 50 00 
0739d     1C FF 63 00 | 	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
073a1     39 FF 77 00 
073a5     55 FF 8A 00 
073a9     71 FF 9E 00 
073ad     8E FF B1 00 | 	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
073b1     AA FF C5 00 
073b5     C6 FF D8 00 
073b9     E3 FF EC 00 
073bd     00 20 14 00 | 	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
073c1     00 40 28 00 
073c5     00 60 3C 00 
073c9     00 80 50 00 
073cd     00 9F 64 00 | 	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
073d1     00 BF 78 00 
073d5     00 DF 8C 00 
073d9     00 FF A0 00 
073dd     1C FF AB 00 | 	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
073e1     39 FF B5 00 
073e5     55 FF C0 00 
073e9     71 FF CA 00 
073ed     8E FF D5 00 | 	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
073f1     AA FF DF 00 
073f5     C6 FF EA 00 
073f9     E3 FF F4 00 
073fd     00 20 20 00 | 	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
07401     00 40 40 00 
07405     00 60 60 00 
07409     00 80 80 00 
0740d     00 9F 9F 00 | 	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
07411     00 BF BF 00 
07415     00 DF DF 00 
07419     00 FF FF 00 
0741d     1C FF FF 00 | 	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
07421     39 FF FF 00 
07425     55 FF FF 00 
07429     71 FF FF 00 
0742d     8E FF FF 00 | 	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
07431     AA FF FF 00 
07435     C6 FF FF 00 
07439     E3 FF FF 00 
0743d     00 14 20 00 | 	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
07441     00 28 40 00 
07445     00 3C 60 00 
07449     00 50 80 00 
0744d     00 64 9F 00 | 	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
07451     00 78 BF 00 
07455     00 8C DF 00 
07459     00 A0 FF 00 
0745d     1C AB FF 00 | 	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
07461     39 B5 FF 00 
07465     55 C0 FF 00 
07469     71 CA FF 00 
0746d     8E D5 FF 00 | 	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
07471     AA DF FF 00 
07475     C6 EA FF 00 
07479     E3 F4 FF    | 	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
0747c                 | 
0747c                 | '**********************************************************************************
0747c                 | '
0747c                 | '        Timings and colors definitions
0747c                 | '
0747c                 | '**********************************************************************************
0747c                 | 
0747c                 | '                      bf.hs, hs,  bf.vis  visible, up p., vsync, down p.,  cpl, total lines, clock,       hubset                                scanlines  ud bord mode reserved
0747c     08 00 00 00 
07480     3C 00 00 00 
07484     08 00 00 00 
07488     00 04 00 00 | timings         long   8,     60,  8,       1024,   7,     4,     1,        128, 600,         340500000,   %1_100111__10_1010_1000__1111_1011,   600,        0,     192, 0, 0
0748c     07 00 00 00 
07490     04 00 00 00 
07494     01 00 00 00 
07498     80 00 00 00 | 	byte	$07, $00, $00, $00, $04, $00, $00, $00, $01, $00, $00, $00, $80, $00, $00, $00
0749c     58 02 00 00 
074a0     20 9E 4B 14 
074a4     FB A8 9E 01 
074a8     58 02 00 00 | 	byte	$58, $02, $00, $00, $20, $9e, $4b, $14, $fb, $a8, $9e, $01, $58, $02, $00, $00
074ac     00 00 00 00 
074b0     C0 00 00 00 
074b4     00 00 00 00 
074b8     00 00 00 00 | 	byte	$00, $00, $00, $00, $c0, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
074bc                 | 'timings        long   16,    80,  12,      1024,   8,     4,     8,        128, 576,         336956522,   %1_101101__11_0000_0110__1111_1011,   576,        0,     192, 0, 0
074bc     00 75 C7 97 
074c0     27 47 F6 0A 
074c4     05 79 CB 9B 
074c8     2B 4B EA 0F | vgacolors       byte   0, 117, 199, 151, 39, 71, 246, 10, 5, 121, 203, 155, 43, 75, 234, 15
074cc                 | 
074cc                 | ''--------  Initialization  ----------------------------------------------------------------
074cc                 | 
074cc     28 0C 64 FD | hdmi            setq    #6
074d0     00 A5 05 FB |                 rdlong  vblankptr,  ptra                   ' read pointers
074d4     28 10 64 FD |                 setq    #8
074d8     D3 8A 01 FB |                 rdlong  m_bs,modeptr                       ' read timings
074dc                 | 
074dc     1F AC 1D F4 |                 bitl    hbase, #31 wcz                     ' if pin 31 is set, use full strength for Adafruit Pico HDMI board
074e0     3C 00 66 FD |                 setcmod #$100                              ' enable HDMI mode
074e4     C0 C7 05 F6 |                 mov     t1,#448                            ' 7 << 6          
074e8     D6 C6 01 F1 |                 add     t1,hbase
074ec     58 C6 61 FD |                 drvl    t1                                 ' #7<<6 + hdmi_base      ' enable HDMI pins
074f0     E3 00 08 AC |         if_z    wrpin   #0, t1  '#7<<6 + hdmi_base         ' for Adafruit breakout board - full logic as in Pico, the board has 220 Ohm resistors on it
074f4     7B 0B 80 5F 
074f8     E3 00 0B 5C | 	if_nz   wrpin   ##%10110_1111_0111_10_00000_0, t1  ' #7<<6 + hdmi_base      ' a '123 ohm BITDAC for Parallax breakout board
074fc     66 66 86 FF 
07500     1D 9A 65 FD |                 setxfrq ##$0CCCCCCC+1                      ' set streamer freq to 1/10th clk
07504                 | '
07504     D6 C6 01 F6 |                 mov 	t1,hbase			   '
07508     11 C6 65 F0 |                 shl 	t1,#17                             '
0750c     E3 A2 01 F1 |                 add 	lutg8,t1                           ' add the pin base to he streamer constant
07510     02 92 85 F1 |                 sub 	i_upporch,#2			   ' the driver will call 2 blank lines itself to preload the buffer, so sub #2 from up porch time
07514                 | 
07514     01 C6 61 FD |                 cogid   t1              		   ' get a cogid
07518     0C C6 05 FA |                 mul     t1, #12                            ' compute the offset to PSRAM mailbox 
0751c     E3 AE 01 F1 |                 add     mailbox, t1                        ' add offset to find this COG's mailbox
07520                 | 
07520                 | ''--------  frame rendering main loop  ---------------------------------------------------
07520                 | 
07520     28 06 64 FD | p101            setq 	#3
07524     00 A5 05 FB | 		rdlong  vblankptr,ptra
07528     28 6A 64 FD |                 setq    #47+6				   ' read sprite data
0752c     D8 DC 01 FB | 	 	rdlong  sprite1pointer,spriteptr
07530     00 4A 06 F6 | 		mov     spriteline,#0                      ' init the sprite line variable
07534     00 A0 05 F6 |                 mov     dlinum, #0
07538     01 9E 05 F1 |                 add     frames,#1			   ' increment the frame counter
0753c     D5 B8 01 F6 |                 mov     dlptr2,dlptr			   ' init the temporary DL pointer
07540                 | 
07540                 | 
07540     00 9C 05 F6 |                 mov     linenum,#0			   ' init the current line #
07544     00 CE 05 F6 |                 mov     rcnt,#0			   	   ' init the DL repeat counter
07548     ED D2 01 F6 |                 mov     rcnt2a,affffffff 		   ' why?!                
0754c                 |                 
0754c                 | 
0754c                 | 
0754c                 | '' ------- reload the palette. If bit31 set, don't reload, to prevent blinking while modifying the palette
0754c                 |   
0754c     1F A8 15 F4 |                 testb   paletteptr,#31 wc
07550     29 FE 65 3D |          if_nc  setq2   #255
07554     D4 00 00 3B |          if_nc  rdlong  $000, paletteptr                   'read palette
07558                 | 
07558                 | '' -----   up porch (before the picture)
07558                 | 
07558     C0 C2 01 F6 |                 mov     hsync0,sync_000      	           ' init constants for sync
0755c     C1 C4 01 F6 |                 mov     hsync1,sync_001	
07560     40 92 45 FB |                 callpa  i_upporch ,#blank                  ' call the porch line i_upporch (-2) times
07564     D2 00 68 FC |                 wrlong  #0,vblankptr                       ' the vblank time ends here
07568                 |  
07568                 |    
07568                 |  
07568     E1 8A C1 FC |                 xcont   m_bs,hsync0                        ' horizontal sync
0756c     E2 8C B1 FC |                 xzero   m_sn,hsync1
07570     60 00 B0 FD |          	     call    #dli	                  ' call DL interpreter for line #0 at line #(-2) - 2 lines earlier, so it can start preloading data from PSRAM
07574     E1 8E C1 FC |                 xcont   m_bv,hsync0     
07578     E1 90 C1 FC |                 xcont   m_vi,hsync0
0757c     DF 80 78 FC |                          rdfast  #64,buf1d                          ' prepare the HUB buffer for 4 scanlines
07580                 | 
07580     E1 8A C1 FC |                 xcont   m_bs,hsync0                        ' horizontal sync
07584     E2 8C B1 FC |                 xzero   m_sn,hsync1
07588     48 00 B0 FD | 		call    #dli
0758c     E1 8E C1 FC |                 xcont   m_bv,hsync0     
07590     E1 90 C1 FC |                 xcont   m_vi,hsync0
07594     20 01 B0 FD |                  call    #sprite				   ' sprites for line #0
07598                 |                 	
07598                 |                 
07598                 | 
07598                 |  
07598                 | '' ------- the main screen drawing starts here
07598                 | 
07598     E1 8A C1 FC | p301            xcont   m_bs,hsync0   			  ' make a right porch
0759c     E2 8C B1 FC |                 xzero   m_sn,hsync1                       ' make hsync
075a0     30 00 B0 FD |                 call    #dli                              ' process the DL for line+2                
075a4     E1 8E C1 FC |                 xcont   m_bv,hsync0
075a8     00 A2 C5 FC |                 xcont   lutg8,#0			  ' display the line 
075ac     01 9C 05 F1 |                  add     linenum,#1                        ' increment the current line number 
075b0     04 01 B0 FD |                  call    #sprite                           ' process sprites for line+1             
075b4                 |               
075b4                 | 
075b4     CD 9C 09 F2 |                 cmp     linenum,i_totalvis  wz            ' check if all lines displayed
075b8     DC FF 9F 5D |     if_nz       jmp     #p301                             ' if not, display the next line
075bc                 | 
075bc                 | ' ---------------- All visible lines displayed now, start vblank  
075bc                 | 
075bc     D2 02 68 FC | p112            wrlong  #1,vblankptr                       ' tell the system that the vblank started
075c0     28 96 45 FB |                 callpa  i_downporch ,#blank                ' bottom blanks
075c4     C2 C2 01 F6 |                 mov     hsync0,sync_222                    ' vsync on
075c8     C3 C4 01 F6 |                 mov     hsync1,sync_223
075cc     25 94 45 FB |                 callpa  i_vsync,#blank                     ' vertical sync blanks
075d0     4C FF 9F FD |                 jmp     #p101                              ' return to the main loop
075d4                 | 
075d4                 | '' --------------- END of frame rendering loop ---------------------------------------------------------------------------
075d4                 | 
075d4                 | '' --------------- Display list interpreter ---------------------------------------------------------------------------
075d4                 | 
075d4     00 CE 0D F2 | dli             cmp     rcnt,#0 wz			   ' check the DL repeat counter 
075d8                 | 
075d8     DC BA 01 AB |     if_z        rdlong  dl,dlptr2				
075dc     04 B8 05 A1 |     if_z        add     dlptr2,#4
075e0     14 00 90 AD |     if_z        jmp     #p307                              ' no repeat, goto read and interpret the next DL entry
075e4                 | 
075e4     01 CE 8D F1 |                 sub     rcnt,#1 wz                         ' decrement the repeat counter
075e8     EB BA 01 56 |     if_nz       mov     dl,rdl                             ' restore repeating DL entry from temporary buffer
075ec     E8 D2 19 F7 |                 incmod  rcnt2a,rcnt2 wcz                   ' address update counter
075f0     EA BA 01 C1 |     if_c        add     dl,roffset                         ' if it rollovers, add the offset to the data address
075f4     DD D6 01 F6 |                 mov     rdl,dl                             ' save the result
075f8                 | 
075f8     DD C0 19 F6 | p307	        mov     framebuf2,dl wcz                   ' move this to framebuf2. If normal DL entry, the frame buffer start will be extracted from this
075fc     DD C6 41 F8 |                 getnib  t1,dl,#0
07600     02 C6 0D F2 |                 cmp     t1,#%0010 wz			   ' 0010 - display a normal graphics line, preload it from the PSRAM
07604     70 00 90 AD |     if_z        jmp     #preload
07608     00 C6 0D F2 |     		cmp     t1,#%0000 wz			   ' 0000 - display a line from a PSRAM list
0760c     94 00 90 AD |     if_z        jmp     #preload2
07610     01 C6 0D F2 |                 cmp     t1,#%0001 wz			   ' 0001 - repeat
07614     0C 00 90 AD |     if_z        jmp     #p390
07618     03 C6 0D F2 |                 cmp     t1,#%0011 wz			   ' 0011 - palette reload
0761c     28 00 90 AD |     if_z        jmp     #p391  
07620                 | 
07620     2D 00 64 FD | p308            ret
07624                 |    
07624     DC D6 01 FB | p390            rdlong  rdl,dlptr2                         ' read the next DL entry to repeat
07628     E0 CE 39 F9 |                 getword rcnt,framebuf2,#1                  ' read the repeat count
0762c     04 CE 45 F0 |                 shr     rcnt,#4                            ' from 12 upper bits
07630     ED D2 01 F6 |                 mov     rcnt2a,affffffff                   ' I still don't know why?
07634     E0 D0 61 F8 |                 getnib  rcnt2,framebuf2,#4                 ' read the pointer update counter
07638     E0 D4 31 F9 |                 getword roffset,framebuf2,#0               ' read the offset to add
0763c     04 D4 45 F0 |                 shr     roffset,#4                         ' clean the command field from offset
07640     04 D4 65 F0 |                 shl     roffset,#4                         ' and make it ready to add to the DL entry (address=20 upper bits)
07644     8C FF 9F FD |                 jmp     #dli                               ' now start repeating 
07648                 |  
07648                 | '' --------  Reload palette. To do 
07648                 | 
07648     E0 C6 51 F8 | p391           	getnib  t1,framebuf2,#2			   ' get a bank (0..15) of 16 colors
0764c     04 C6 65 F0 |          	shl     t1,#4				   ' compute the LUT address
07650     0C C0 45 F0 |         	shr     framebuf2,#12			   ' compute the HUB address of 16 new colors
07654     29 1E 64 FD |          	setq2   #15				   ' load 16 entries
07658     00 C6 8D F9 |          	altd    t1                                 ' from t1 LUT address
0765c     E0 00 00 FB |         	rdlong  $000, framebuf2         	
07660     70 FF 9F FD |         	jmp     #dli                
07664                 |       
07664                 | '' --------------- A display list interpreter end ------------------------------------------------------------------------    
07664                 | 
07664                 | 
07664                 | '' --------------- Blank and vsync procedures called via callpa have to be in the middle of the code ---------------------
07664                 | 
07664     E1 8A C1 FC | blank           xcont   m_bs,hsync0                        ' horizontal sync
07668     E2 8C B1 FC |                 xzero   m_sn,hsync1
0766c     E1 8E C1 FC |                 xcont   m_bv,hsync0     
07670     E1 90 C1 FC |                 xcont   m_vi,hsync0
07674     FB ED 6F 0B |         _ret_   djnz    pa,#blank
07678                 |         
07678                 | '' -------------- Preload a line from PSRAM        
07678                 |         
07678     D0 BC 01 F6 | preload         mov     buf1c,dlinum			   ' preload a line buffer #dlinum (0..3)
0767c     0A BC 65 F0 |                 shl     buf1c,#10		           ' 1024 bytes per line
07680     DF BC 01 F1 |                 add     buf1c,buf1d			   ' add the start address (himem-debug-4096) : Todo: debug variable!
07684     DE B4 01 F6 |                 mov     buf1,buf1c
07688     03 A0 05 F7 |                 incmod  dlinum,#3
0768c                 | 
0768c     04 C0 45 F0 |                 shr     framebuf2,#4                      ' get the PSRAM start address from DL - Todo: use new DL format
07690     32 B7 01 F6 |                 mov     buf2,a1024
07694     E0 B2 01 F6 |                 mov     cmd,framebuf2                      ' set the address
07698     0B B2 3D F8 |                 setnib  cmd, #%1011, #7                    ' attach the command - read burst from the external memory
0769c     28 04 64 FD |                 setq    #2				   ' write 3 longs to the mailbox
076a0     D7 B2 61 0C |     _ret_       wrlong  cmd,mailbox			   ' read the PSRAM
076a4                 |  
076a4                 |  
076a4                 | preload2      '  incmod  dlinum,#3
076a4     04 C0 45 F0 |                 shr 	framebuf2,#4
076a8     ED B2 01 F6 |                 mov 	cmd,affffffff
076ac     E0 B4 01 F6 |                 mov 	buf1,framebuf2
076b0     28 02 64 FD |                 setq	#1
076b4     D7 B2 61 0C |     _ret_	wrlong  cmd,mailbox
076b8                 |                 
076b8                 | 
076b8                 | '' -------------- Draw sprites
076b8                 | 
076b8     CF 5C 02 F6 | sprite          mov t8,frames
076bc     10 5C 0E F5 | 		and t8,#16 wz
076c0     11 48 06 F6 |                 mov spritenum, #17			' 16 +2 sprites. Todo: this should be a parameter
076c4     10 48 06 A6 | 	if_z    mov spritenum, #16	
076c8                 | 		
076c8                 | 
076c8     24 57 02 F6 | p802            mov     t5,spritenum		   	' prepare a pointer to load sprite data
076cc     03 56 06 FA |                 mul     t5,#3          			' one sprite data set needs 3 longs
076d0     EF 56 96 F9 |                 alts    t5,#sprite1xy
076d4     00 4E 3A F9 |                 getword sprite_y,0-0,#1		        ' get a sprite y
076d8     0F 4E 66 F7 |                 signx	sprite_y,#15			' they can be negative
076dc     EF 56 96 F9 |                 alts    t5,#sprite1xy
076e0     00 4C 32 F9 |                 getword sprite_x,0-0,#0                 ' and x
076e4     0F 4C 66 F7 |                 signx	sprite_x,#15
076e8     F0 56 96 F9 |                 alts    t5,#sprite1wh
076ec     00 52 3A F9 |                 getword sprite_h,0-0,#1		       	' get a sprite height
076f0     01 52 86 F1 |                 sub     sprite_h,#1
076f4     F0 56 96 F9 |                 alts    t5,#sprite1wh
076f8     00 50 32 F9 |                 getword sprite_w,0-0,#0                 ' and width
076fc                 | 
076fc                 | 
076fc     32 4D 5A F2 |                	cmps	sprite_x,a1024 wcz	         
07700     BC 00 90 3D |      if_ge	jmp 	#p801                           ' go out if >1023
07704     00 50 5E F2 |               	cmps	sprite_w,#0 wcz	         
07708     B4 00 90 AD |      if_e	jmp 	#p801                           ' go out if w=0
0770c     00 52 5E F2 |               	cmps	sprite_h,#0 wcz	         
07710     AC 00 90 AD |      if_e	jmp 	#p801                           ' go out if h=0
07714     00 5E 06 F6 |                 mov 	t9,#0
07718     28 5F 82 F1 |                 sub 	t9,sprite_w                      	
0771c     2F 4D 5A F2 |      		cmps  	sprite_x,t9 wcz   		'
07720     9C 00 90 ED |      if_le	jmp 	#p801	                        ' go out if sprite out of screen at right
07724                 |      
07724     CE C8 01 F6 |   		mov     t2,linenum			' display line # to check if sprite has to be displayed
07728     27 C9 D9 F1 |   		subs    t2,sprite_y wcz                 ' check if the sprite has to be displayed
0772c     90 00 90 CD |      if_c       jmp     #p801				' if not, go out
07730     29 C9 19 F2 |                 cmp     t2,sprite_h wcz		    	' we have now the sprite line #, check, if it is not >= sprite height
07734     88 00 90 1D |      if_gt      jmp     #p801				' if yes, go out
07738                 |                 
07738     25 CB 01 F6 |                 mov     t3,spriteline			' compute the line buffer addres where to put the sprite line
0773c     0A CA 65 F0 |                 shl     t3,#10			       	' =1024*spriteline where spriteline=0..3		' 
07740     DF CA 01 F1 |                 add     t3,buf1d			' line buffer addr
07744                 |   		
07744     1F 4C 16 F4 |   		testb	sprite_x,#31 wc 		' check if sprite pos <0
07748     26 CB 01 31 |      if_nc      add     t3,sprite_x   			' if >=0 add xpos. If <0, the address is the start of the line  - now we have the address to where wmlong the sprite
0774c                 | 
0774c     28 C9 01 FA |                 mul 	t2,sprite_w			' compute the offset to the sprite line data
07750     26 51 02 C1 |      if_c	add     sprite_w,sprite_x		' if sprite_x negative, shorten the width
07754     26 C9 81 C1 |      if_c	sub 	t2,sprite_x			' and add the offset (sub negative) to the sprite data offset
07758                 |  
07758     EE 56 96 F9 |                 alts    t5,#sprite1pointer		' get the pointer to the sprite (3 longs per sprite data)
0775c     00 C8 01 F1 |                 add     t2,0-0				' then add the offset
07760     10 00 90 CD |      if_c 	jmp     #p899		
07764                 | 	
07764                 | 	
07764     26 CD 01 F6 | 		mov 	t4,sprite_x	'
07768     28 CD 01 F1 | 		add	t4,sprite_w
0776c     32 CD 99 F1 | 		sub     t4,a1024 wcz			' check if the sprite goes right off the screen
07770                 | 
07770     E6 50 82 31 | 	if_nc	sub	sprite_w,t4			' if yes, make it narrower
07774                 | 
07774     28 59 02 F6 | p899		mov 	t6,sprite_w
07778     01 58 86 F1 | 	 	sub     t6,#1
0777c     02 58 46 F0 | 	 	shr	t6,#2				' bytes to longs
07780                 | 
07780     28 58 62 FD |                 setq   	t6
07784     E4 E0 02 FB |                 rdlong 368,t2				' read sprite data to the cog
07788     28 5D 02 F6 |                 mov t8,sprite_w
0778c     03 5C 0E F5 |                 and t8,#3 wz				' if width mod 4=0 we have full longs, nothing to do
07790     24 00 90 AD |         if_z    jmp #p898
07794                 |          
07794                 |         
07794     70 5F 06 F6 |                 mov  t9,#368
07798     2C 5F 02 F1 |                 add t9,t6				' find the last long of the sprite
0779c                 | 
0779c     04 5C C6 F2 |                 subr t8,#4				' if modulo4=1, mask 3 bytes, if 2, mask 2, if 1, mask 3
077a0     08 5C 06 FA |                 mul t8,#8				' bits to shr
077a4     FF FF 7F FF 
077a8     FF 5B 06 F6 |                 mov t7,##-1				' full of 1s
077ac     2E 5B 42 F0 |                 shr t7,t8				' SHR to make 0s for masking
077b0     00 5E 8E F9 |                 altd t9,#0				' and mask 
077b4     2D 01 00 F5 |                 and 0-0, t7
077b8                 |                
077b8                 | 
077b8     28 58 62 FD | p898            setq   t6				' write the sprite data to the line buffer
077bc     E5 E0 7A FA |                 wmlong 368,t3				
077c0                 |                 
077c0     C1 49 7E FB | p801            djnf spritenum,#p802			' get the next sprite
077c4     03 4A 06 F7 |                 incmod spriteline,#3			' prepare to fill the next line
077c8     2D 00 64 FD |                 ret
077cc                 | 	
077cc                 | 	
077cc                 |                
077cc                 |  
077cc                 | '' -------------- Graphics line ------------------------------------------------------------
077cc                 |  
077cc                 | 
077cc                 | '' consts and vars
077cc                 | 
077cc     52 4D 35 D5 | sync_000        long    %1101010100_1101010100_1101010100_10    '
077d0     AE 42 35 D5 | sync_001        long    %1101010100_1101010100_0010101011_10    '        hsync
077d4     52 45 15 55 | sync_222        long    %0101010100_0101010100_0101010100_10    'vsync
077d8     AE 4A 15 55 | sync_223        long    %0101010100_0101010100_1010101011_10    'vsync + hsync
077dc                 | 
077dc     00 2C 1A 00 | border          long    %00000000_00011010_00101100_00000000
077e0                 | 
077e0                 | '------ these longs will be set by setmode function
077e0                 | 
077e0     00 00 00 00 | m_bs            long    0        'blanks before sync
077e4     00 00 00 00 | m_sn            long    0        'sync
077e8     00 00 00 00 | m_bv            long    0        'blanks before visible
077ec     00 00 00 00 | m_vi            long    0        'visible pixels #
077f0                 | 'm_border        long    0        'left/right borders
077f0     00 00 00 00 | i_upporch       long    0        'up porch lines
077f4     00 00 00 00 | i_vsync         long    0        'vsync lines
077f8     00 00 00 00 | i_downporch     long    0        'down porch lines
077fc     00 00 00 00 | i_cpl           long    0        'chars/longs per line
07800     00 00 00 00 | i_totalvis      long    0
07804                 | 
07804                 | '-------------------------------------
07804                 |  
07804     00 00 00 00 | linenum         long    0
07808     00 00 00 00 | frames          long    0
0780c     00 00 00 00 | dlinum long 0
07810     00 04 88 70 | lutg8           long    $70880400 ' 0111_0000_1000_1000
07814                 | 
07814     00 00 00 00 | vblankptr       long    0
07818     00 00 00 00 | modeptr         long    0
0781c     00 00 00 00 | paletteptr      long    0
07820     00 00 00 00 | dlptr           long    0
07824     01 00 00 00 | hbase           long    1
07828     00 00 00 00 | mailbox         long    0
0782c     00 00 00 00 | spriteptr          long 0
07830                 | 
07830     00 00 00 00 | cmd             long    0
07834     00 EC 07 00 | buf1            long    $80000-1024-4096
07838     00 04 00 00 | buf2            long    1024
0783c     01 00 00 00 | dlptr2          long    1
07840     01 00 00 00 | dl              long    1
07844                 | 
07844     00 00 00 00 | buf1c long 0
07848     00 EC 07 00 | buf1d            long    $80000-1024-4096
0784c     01 00 00 00 | framebuf2       long    1
07850     01 00 00 00 | hsync0          long    1
07854     01 00 00 00 | hsync1          long    1
07858                 | 
07858     01 00 00 00 | t1              long    1
0785c     00 00 00 00 | t2 long 0
07860     00 00 00 00 | t3 long 0
07864     00 00 00 00 | t4 long 0
07868                 | 
07868     00 00 00 00 | rcnt            long    0  'dl repeat count
0786c     00 00 00 00 | rcnt2           long    0
07870     00 00 00 00 | rcnt2a          long    0
07874     00 00 00 00 | roffset         long    0
07878     00 00 00 00 | rdl             long    0  'dl repeat line
0787c     00 00 00 00 | dlc             long    0  'dl command
07880                 | 
07880     FF FF FF FF | affffffff       long    $ffffffff
07884     00 00 00 00 | sprite1pointer long 0
07888     00 00 00 00 | sprite1xy      long 0
0788c     00 00 00 00 | sprite1wh      long 0
07890     00 00 00 00 | sprite2pointer long 0
07894     00 00 00 00 | sprite2xy      long 0
07898     00 00 00 00 | sprite2wh      long 0
0789c     00 00 00 00 | sprite3pointer long 0
078a0     00 00 00 00 | sprite3xy      long 0
078a4     00 00 00 00 | sprite3wh      long 0
078a8     00 00 00 00 | sprite4pointer long 0
078ac     00 00 00 00 | sprite4xy      long 0
078b0     00 00 00 00 | sprite4wh      long 0
078b4     00 00 00 00 | sprite5pointer long 0
078b8     00 00 00 00 | sprite5xy      long 0
078bc     00 00 00 00 | sprite5wh      long 0
078c0     00 00 00 00 | sprite6pointer long 0
078c4     00 00 00 00 | sprite6xy      long 0
078c8     00 00 00 00 | sprite6wh      long 0
078cc     00 00 00 00 | sprite7pointer long 0
078d0     00 00 00 00 | sprite7xy      long 0
078d4     00 00 00 00 | sprite7wh      long 0
078d8     00 00 00 00 | sprite8pointer long 0
078dc     00 00 00 00 | sprite8xy      long 0
078e0     00 00 00 00 | sprite8wh      long 0
078e4     00 00 00 00 | sprite9pointer long 0
078e8     00 00 00 00 | sprite9xy      long 0
078ec     00 00 00 00 | sprite9wh      long 0
078f0     00 00 00 00 | sprite10pointer long 0
078f4     00 00 00 00 | sprite10xy      long 0
078f8     00 00 00 00 | sprite10wh      long 0
078fc     00 00 00 00 | sprite11pointer long 0
07900     00 00 00 00 | sprite11xy      long 0
07904     00 00 00 00 | sprite11wh      long 0
07908     00 00 00 00 | sprite12pointer long 0
0790c     00 00 00 00 | sprite12xy      long 0
07910     00 00 00 00 | sprite12wh      long 0
07914     00 00 00 00 | sprite13pointer long 0
07918     00 00 00 00 | sprite13xy      long 0
0791c     00 00 00 00 | sprite13wh      long 0
07920     00 00 00 00 | sprite14pointer long 0
07924     00 00 00 00 | sprite14xy      long 0
07928     00 00 00 00 | sprite14wh      long 0
0792c     00 00 00 00 | sprite15pointer long 0
07930     00 00 00 00 | sprite15xy      long 0
07934     00 00 00 00 | sprite15wh      long 0
07938     00 00 00 00 | sprite16pointer long 0
0793c     00 00 00 00 | sprite16xy      long 0
07940     00 00 00 00 | sprite16wh      long 0
07944     00 00 00 00 | sprite17pointer long 0
07948     00 00 00 00 | sprite17xy      long 0
0794c     00 00 00 00 | sprite17wh      long 0
07950     00 00 00 00 | sprite18pointer long 0
07954     00 00 00 00 | sprite18xy      long 0
07958     00 00 00 00 | sprite18wh      long 0
0795c     00 00 00 00 | spritenum long 0
07960                 | 
07960     00 00 00 00 | spriteline long 0
07964     84 03 00 00 | sprite_x long 900
07968     00 00 00 00 | sprite_y long 0
0796c     10 00 00 00 | sprite_w long 16
07970     40 00 00 00 | sprite_h long 64
07974     00 00 00 00 | l2 long 0
07978     00 00 00 00 | t5 long 0
0797c     00 00 00 00 | t6 long 0
07980     00 00 00 00 | t7 long 0
07984     00 00 00 00 | t8 long 0
07988     00 00 00 00 | t9 long 0
0798c     00 00 00 00 | preloadaddr long 0
07990     00 00 00 00 | preloadlineaddr long 0
07994     00 04 00 00 | a1024 long 1024
07998                 | 
07998     E0 03 00 00 | aa long 992
0799c     FF 03 00 00 | a1023 long 1023
079a0     00 10 00 00 | a4096 long 4096
079a4                 |  fit 368
079a4                 |  fit 368
079a4                 | _psram_spin2_dat_
079a4     00 00 00 00 
      ...             
07a9c     00 00 00 00 
07aa0     00 00 00 00 |     listdata long 0[8*8]
07aa4                 |             orgh
07aa4                 | 
07aa4                 | ' driver state
07aa4     FF FF FF FF | drivercog   long    -1  ' COG id of driver
07aa8     FF FF FF FF | driverlock  long    -1  ' LOCK id of driver
07aac                 | 
07aac                 | ' delay profile
07aac     07 00 00 00 
07ab0     00 CF 7B 05 
07ab4     80 D1 F0 08 
07ab8     80 4F 47 0C | delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
07abc     80 C4 60 0F 
07ac0     80 39 7A 12 
07ac4     40 2D D9 13 
07ac8     00 00 00 00 | 	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
07acc                 | 
07acc                 | ' data to be passed to driver when starting it
07acc                 | startupData
07acc     00 00 00 00 |     long    0           ' current frequency
07ad0     00 00 00 00 |     long    FLAGS       ' optional flags for driver
07ad4     00 00 00 00 |     long    0           ' reset pin mask on port A for PSRAM (none)
07ad8     00 00 00 00 |     long    0           ' reset pin mask on port B for PSRAM (none)
07adc     28 00 00 00 |     long    DATABUS     ' PSRAM data bus start pin
07ae0     EC 7A 00 00 |     long    deviceData  ' address of devices data structure in HUBRAM
07ae4     6C 7B 00 00 |     long    qosData     ' address of QoS data structure in HUBRAM
07ae8     8C 7B 00 00 |     long    mailboxes   ' address of mailbox structure in HUBRAM
07aec                 | 
07aec                 | ' data for memory
07aec                 | deviceData
07aec                 |     ' 16 bank parameters follow (16MB per bank)
07aec     00 00 00 00 
      ...             
07b24     00 00 00 00 
07b28     00 00 00 00 |     long    0[16]                               ' banks 0-15
07b2c                 |     ' 16 banks of pin parameters follow
07b2c     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
07b30     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
07b34     FF FF FF FF 
      ...             
07b64     FF FF FF FF 
07b68     FF FF FF FF |     long    -1[14]                              ' banks 2-15
07b6c                 | 
07b6c                 | ' data for COG polling
07b6c                 | qosData 
07b6c     00 00 FF FF 
07b70     00 00 FF FF 
07b74     00 00 FF FF 
07b78     00 00 FF FF |     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
07b7c     00 00 FF FF 
07b80     00 00 FF FF 
07b84     00 00 FF FF 
07b88     00 00 FF FF | 	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
07b8c                 |     
07b8c                 | ' mailbox storage
07b8c                 | 
07b8c                 | mailboxes
07b8c     00 00 00 00 
      ...             
07be4     00 00 00 00 
07be8     00 00 00 00 |     long    0[8*3]          ' 3 longs per mailbox per COG
07bec                 | 	alignl
07bec                 | _psram16drv_spin2_dat_
07bec                 |                             orgh
07bec     00 00 00 00 
      ...             
07c04     00 00 00 00 
07c08     00 00 00 00 | scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
07c0c                 | 
07c0c                 | driver_start
07c0c                 |                             org
07c0c 000             | '..................................................................................................
07c0c 000             | ' Memory layout for COG RAM once operational:
07c0c 000             | '
07c0c 000             | '  COG RAM address      Usage
07c0c 000             | '  ---------------      ----
07c0c 000             | '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
07c0c 000             | '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
07c0c 000             | '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
07c0c 000             | '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
07c0c 000             | '   $100-$197           Mailbox poller, error handlers, and all driver management code
07c0c 000             | '  ~$198-$1F3           State and register variables
07c0c 000             | '
07c0c 000             | ' Also during driver COG startup:
07c0c 000             | '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
07c0c 000             | ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
07c0c 000             | '..................................................................................................
07c0c 000             |                             
07c0c 000             | ' Mailbox storage after vector initialization
07c0c 000             | 
07c0c 000 FC 01 B0 FD | req0                        call    #init                   'do HW setup/initialization
07c10 001 F0 E3 AB FA | data0                       rdlut   c, b wz                 'read bank info          
07c14 002 F0 DF 03 F6 | count0                      mov     a, b                    'set COGRAM address low nibble
07c18 003 68 F0 07 A6 | req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
07c1c 004 0A E2 17 F4 | data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
07c20 005 50 F0 07 16 | count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
07c24 006 58 F0 07 46 | req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
07c28 007 08 E2 07 F6 | data2                       mov     c, #$8                  'setup vector base to $80
07c2c 008 F1 DF 0B F8 | count2                      setnib  a, c, #1                'prepare vector base address for bank
07c30 009 00 DE 8F F9 | req3                        altd    a, #0                   'prepare COG destination read address
07c34 00a 61 01 A4 FA | data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
07c38 00b 0F E2 0F F7 | count3                      incmod  c, #15 wz               'next vector
07c3c 00c EC FF 9F 5D | req4        if_nz           jmp     #count2                 'repeat
07c40 00d 0F E0 0F F7 | data4                       incmod  b, #15 wz               'next bank
07c44 00e C8 FF 9F 5D | count4      if_nz           jmp     #data0                  'repeat
07c48 00f 20 F0 07 F6 | req5                        mov     ptra, #$20              'setup base LUT address to clear
07c4c 010 50 0A DC FC | data5                       rep     #5, #80                 'update next 80 longs      
07c50 011 E2 F1 13 F2 | count5                      cmp     ptra, header wc         'check if LUT address range 
07c54 012 E3 F1 93 32 | req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
07c58 013 61 01 3C CC | data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
07c5c 014 61 B1 37 3C | count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
07c60 015 A5 29 00 31 | req7        if_nc           add     $-1, const512           'increment source of LUT write data
07c64 016 FF C0 03 F6 | data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
07c68 017 26 FF 05 06 | count7      _ret_           mov     255, #dolist            'setup list address, return to notify
07c6c 018             | 
07c6c 018             | ' Mailbox parameter addresses per COG once patched
07c6c 018             |                             
07c6c 018 04 00 00 00 | cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
07c70 019 10 00 00 00 | cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
07c74 01a 1C 00 00 00 | cog2mboxdata                long    2*12+4                  '...
07c78 01b 28 00 00 00 | cog3mboxdata                long    3*12+4
07c7c 01c 34 00 00 00 | cog4mboxdata                long    4*12+4
07c80 01d 40 00 00 00 | cog5mboxdata                long    5*12+4
07c84 01e 4C 00 00 00 | cog6mboxdata                long    6*12+4
07c88 01f 58 00 00 00 | cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
07c8c 020             | 
07c8c 020             | '..................................................................................................
07c8c 020             | ' Per COG request and state setup and service branching
07c8c 020             |         
07c8c 020             | cog0                 
07c8c 020 20 F0 07 F6 |                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
07c90 021 18 F2 03 F6 |                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
07c94 022 D0 C3 03 F6 |                             mov     id, id0                 'get COG0 state
07c98 023 E1 47 3B F9 |                             getword limit, id, #1           'get COG0 burst limit
07c9c 024 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
07ca0 025 30 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
07ca4 026 00 B0 03 F6 |                             mov     addr1, req0             'get mailbox request parameter for COG0
07ca8 027 01 B2 03 F6 |                             mov     hubdata, data0          'get COG0 mailbox data parameter
07cac 028 02 B4 03 F6 |                             mov     count, count0           'get COG0 mailbox count parameter
07cb0 029 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
07cb4 02a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
07cb8 02b 33 CA 63 FD |                             execf   request-0               'jump to service
07cbc 02c             | cog1                        
07cbc 02c 2A F0 07 F6 |                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
07cc0 02d 19 F2 03 F6 |                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
07cc4 02e D1 C3 03 F6 |                             mov     id, id1                 'get COG1 state
07cc8 02f E1 47 3B F9 |                             getword limit, id, #1           'get COG1 burst limit
07ccc 030 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
07cd0 031 00 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
07cd4 032 03 B0 03 F6 |                             mov     addr1, req1             'get mailbox request parameter for COG1
07cd8 033 04 B2 03 F6 |                             mov     hubdata, data1          'get COG1 mailbox data parameter
07cdc 034 05 B4 03 F6 |                             mov     count, count1           'get COG1 mailbox count parameter
07ce0 035 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
07ce4 036 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
07ce8 037 33 CA 63 FD |                             execf   request-0               'jump to service
07cec 038             | cog2                         
07cec 038 34 F0 07 F6 |                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
07cf0 039 1A F2 03 F6 |                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
07cf4 03a D2 C3 03 F6 |                             mov     id, id2                 'get COG2 state
07cf8 03b E1 47 3B F9 |                             getword limit, id, #1           'get COG2 burst limit
07cfc 03c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
07d00 03d D0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
07d04 03e 06 B0 03 F6 |                             mov     addr1, req2             'get mailbox request parameter for COG2
07d08 03f 07 B2 03 F6 |                             mov     hubdata, data2          'get COG2 mailbox data parameter
07d0c 040 08 B4 03 F6 |                             mov     count, count2           'get COG2 mailbox count parameter
07d10 041 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
07d14 042 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
07d18 043 33 CA 63 FD |                             execf   request-0               'jump to service
07d1c 044             | cog3                        
07d1c 044 3E F0 07 F6 |                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
07d20 045 1B F2 03 F6 |                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
07d24 046 D3 C3 03 F6 |                             mov     id, id3                 'get COG3 state
07d28 047 E1 47 3B F9 |                             getword limit, id, #1           'get COG3 burst limit
07d2c 048 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
07d30 049 A0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
07d34 04a 09 B0 03 F6 |                             mov     addr1, req3             'get mailbox request parameter for COG3
07d38 04b 0A B2 03 F6 |                             mov     hubdata, data3          'get COG3 mailbox data parameter
07d3c 04c 0B B4 03 F6 |                             mov     count, count3           'get COG3 mailbox count parameter
07d40 04d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
07d44 04e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
07d48 04f 33 CA 63 FD |                             execf   request-0               'jump to service
07d4c 050             | cog4                        
07d4c 050 48 F0 07 F6 |                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
07d50 051 1C F2 03 F6 |                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
07d54 052 D4 C3 03 F6 |                             mov     id, id4                 'get COG4 state
07d58 053 E1 47 3B F9 |                             getword limit, id, #1           'get COG4 burst limit
07d5c 054 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
07d60 055 70 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
07d64 056 0C B0 03 F6 |                             mov     addr1, req4             'get mailbox request parameter for COG4
07d68 057 0D B2 03 F6 |                             mov     hubdata, data4          'get COG4 mailbox data parameter
07d6c 058 0E B4 03 F6 |                             mov     count, count4           'get COG4 mailbox count parameter
07d70 059 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
07d74 05a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
07d78 05b 33 CA 63 FD |                             execf   request-0               'jump to service
07d7c 05c             | cog5                        
07d7c 05c 52 F0 07 F6 |                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
07d80 05d 1D F2 03 F6 |                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
07d84 05e D5 C3 03 F6 |                             mov     id, id5                 'get COG5 state
07d88 05f E1 47 3B F9 |                             getword limit, id, #1           'get COG5 burst limit
07d8c 060 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
07d90 061 40 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
07d94 062 0F B0 03 F6 |                             mov     addr1, req5             'get mailbox request parameter for COG5
07d98 063 10 B2 03 F6 |                             mov     hubdata, data5          'get COG5 mailbox data parameter
07d9c 064 11 B4 03 F6 |                             mov     count, count5           'get COG5 mailbox count parameter
07da0 065 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
07da4 066 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
07da8 067 33 CA 63 FD |                             execf   request-0               'jump to service
07dac 068             | cog6                        
07dac 068 5C F0 07 F6 |                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
07db0 069 1E F2 03 F6 |                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
07db4 06a D6 C3 03 F6 |                             mov     id, id6                 'get COG6 state
07db8 06b E1 47 3B F9 |                             getword limit, id, #1           'get COG6 burst limit
07dbc 06c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
07dc0 06d 10 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
07dc4 06e 12 B0 03 F6 |                             mov     addr1, req6             'get mailbox request parameter for COG6
07dc8 06f 13 B2 03 F6 |                             mov     hubdata, data6          'get COG6 mailbox data parameter
07dcc 070 14 B4 03 F6 |                             mov     count, count6           'get COG6 mailbox count parameter
07dd0 071 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
07dd4 072 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
07dd8 073 33 CA 63 FD |                             execf   request-0               'jump to service
07ddc 074             | cog7                        
07ddc 074 66 F0 07 F6 |                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
07de0 075 1F F2 03 F6 |                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
07de4 076 D7 C3 03 F6 |                             mov     id, id7                 'get COG7 state
07de8 077 E1 47 3B F9 |                             getword limit, id, #1           'get COG7 burst limit
07dec 078 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
07df0 079 E0 02 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
07df4 07a 15 B0 03 F6 |                             mov     addr1, req7             'get mailbox request parameter for COG7
07df8 07b 16 B2 03 F6 |                             mov     hubdata, data7          'get COG7 mailbox data parameter
07dfc 07c 17 B4 03 F6 |                             mov     count, count7           'get COG7 mailbox count parameter
07e00 07d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
07e04 07e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
07e08 07f 33 CA 63 FD |                             execf   request-0               'jump to service
07e0c 080             | 
07e0c 080             |                             fit     128
07e0c 080             |                             fit     128
07e0c 080             | pad                         long    0[128-$]                'align init code to $80
07e0c 080             | 
07e0c 080             | '..................................................................................................
07e0c 080             | 
07e0c 080             | ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
07e0c 080             | 
07e0c 080             | init                        
07e0c 080             |                             ' get driver scratch long address in hub
07e0c 080 01 DA 63 FD |                             cogid   hubscratch              'get cogid
07e10 081 01 DA 07 F1 |                             add     hubscratch, #1          'increase by 1 from 1-8
07e14 082 04 DA 07 FA |                             mul     hubscratch, #4          'multiply by 4 to get 4-32
07e18 083 F9 DB C3 F2 |                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
07e1c 084             |                     
07e1c 084             |                             ' read in the additional LUT RAM code
07e1c 084 F9 41 03 F1 |                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
07e20 085 29 9E 67 FD |                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
07e24 086 A0 61 00 FB |                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
07e28 087             | 
07e28 087             |                             ' read the startup parameters
07e28 087 28 0E 64 FD |                             setq    #8-1                    'read 8 longs from hub
07e2c 088 00 41 07 FB |                             rdlong  startupparams, ptra     '.. as the startup parameters 
07e30 089             | 
07e30 089             |                             ' setup some of the config flag dependent state and patch LUTRAM
07e30 089 1C 42 0F F4 |                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
07e34 08a             | 
07e34 08a F9 71 03 A1 |             if_z            add     expansion, ptrb         'compensate for HUB address
07e38 08b 01 00 00 5F 
07e3c 08c FB 70 07 56 |             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
07e40 08d 1D 42 17 F4 |                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
07e44 08e AA 57 43 35 |             if_nc           or      clkconfig, registered   'enable this if so
07e48 08f 00 58 07 36 |             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
07e4c 090             | 
07e4c 090             |                             ' setup data pin modes and data bus pin group in streamer commands
07e4c 090 38 48 07 F5 |                             and     datapins, #%111000      'compute base pin
07e50 091 01 00 00 FF 
07e54 092 C0 49 47 F5 |                             or      datapins, ##(15<<6)     'configure 16 pins total
07e58 093 A4 DF 03 F6 |                             mov     a, datapins             'get data pin base
07e5c 094 A4 55 03 FC |                             wrpin   registered, datapins    'prepare data pins for address phase transfer
07e60 095 03 DE 47 F0 |                             shr     a, #3                   'determine data pin group
07e64 096 07 DE 07 F5 |                             and     a, #7                   'ignore the unwanted bits
07e68 097 08 DE 47 F5 |                             or      a, #8
07e6c 098 EF 2F 2B F8 |                             setnib  ximm8lut, a, #5         'setup bus group in streamer
07e70 099 EF 31 2B F8 |                             setnib  xrecvlo8, a, #5
07e74 09a EF 35 2B F8 |                             setnib  xrecvdata, a, #5
07e78 09b EF 37 2B F8 |                             setnib  xsenddata, a, #5
07e7c 09c EF 39 2B F8 |                             setnib  xsendimm, a, #5
07e80 09d 01 DE 07 F1 |                             add     a, #1
07e84 09e EF 33 2B F8 |                             setnib  xrecvhi8, a, #5         ' increase port by one
07e88 09f             |  
07e88 09f             |                             ' setup device control pin states
07e88 09f 29 3E 64 FD |                             setq2   #32-1                   'read 32 longs to LUTRAM
07e8c 0a0 A5 01 00 FB |                             rdlong  $000, devicelist        'read bank/pin data for all banks    
07e90 0a1 01 00 00 FF 
07e94 0a2 00 4A 07 F6 |                             mov     const512, ##512         'prepare constant
07e98 0a3             | 
07e98 0a3 10 F2 07 F6 |                             mov     ptrb, #16               'point to bank pin config data
07e9c 0a4 10 14 DC FC |                             rep     @pinloop, #16           'iterate through 16 banks
07ea0 0a5 E1 CF B7 FA |                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
07ea4 0a6 AF CF 03 F5 |                             and     pinconfig, pinmask      'save us from invalid bits in args
07ea8 0a7 E7 53 E3 38 |             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
07eac 0a8 A9 01 08 3C |             if_nc           wrpin   #0, cspin               'clear smart pin mode
07eb0 0a9 59 52 63 3D |             if_nc           drvh    cspin                   'setup pins for all banks
07eb4 0aa E7 51 EB 38 |             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
07eb8 0ab 50 50 63 3D |             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
07ebc 0ac A8 57 03 3C |             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
07ec0 0ad A8 03 18 3C |             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
07ec4 0ae 58 50 63 3D |             if_nc           drvl    clkpin                  'set clk state low
07ec8 0af             | pinloop
07ec8 0af             |                             ' generate minimum CE high time before access
07ec8 0af A1 07 00 FF 
07ecc 0b0 40 40 17 FD |                             qdiv    frequency, ##1000000    'convert from Hz to MHz
07ed0 0b1 18 E2 63 FD |                             getqx   c                       'get P2 clocks per microsecond
07ed4 0b2 96 DE 07 F6 |                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
07ed8 0b3 F1 DF 03 FA |                             mul     a, c                    'convert microseconds to clocks
07edc 0b4 1F DE 63 FD |                             waitx   a                       'delay
07ee0 0b5 E8 05 B0 FD |                             call    #hwinit                 'setup HW into QSPI mode
07ee4 0b6             | 
07ee4 0b6             |                             ' setup the COG mailboxes and addresses 
07ee4 0b6 08 04 DC FC |                             rep     #2, #8                  'setup loop to patch mailbox addresses
07ee8 0b7 38 70 A5 F9 |                             alti    $+1, #%111_000          'increase D field
07eec 0b8 A7 31 00 F1 |                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
07ef0 0b9             | 
07ef0 0b9 28 2E 64 FD |                             setq    #24-1
07ef4 0ba A7 01 68 FC |                             wrlong  #0, mbox                'clear out mailboxes ????
07ef8 0bb             | 
07ef8 0bb             |                             ' setup the polling loop for active COGs 
07ef8 0bb 01 C2 63 FD |                             cogid   id
07efc 0bc D0 C3 97 F9 |                             alts    id, #id0                'determine id register of control COG
07f00 0bd 00 90 B6 F9 |                             setd    patchid, #0             'patch into destination address
07f04 0be 2A F0 63 FD |                             push    ptra                    'save ptra before we lose it
07f08 0bf 0A F0 07 F6 |                             mov     ptra, #10
07f0c 0c0 E1 F1 03 FA |                             mul     ptra, id
07f10 0c1 20 F0 07 F1 |                             add     ptra, #$20              'prep ptra for reloadcogs
07f14 0c2 B0 C3 97 F9 |                             alts    id, #cog0_handler       'add to handler base
07f18 0c3 00 48 BE F9 |                             sets    ctrlpollinst, #0-0      'patch into jump instruction
07f1c 0c4 03 C2 07 FA |                             mul     id, #3
07f20 0c5 E1 49 B2 F9 |                             setd    ctrlpollinst, id
07f24 0c6 09 C3 A7 FA |                             rdlut   id, ptra[9]             'save original value
07f28 0c7 09 C1 37 FC |                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
07f2c 0c8 D8 01 B0 FD |                             call    #reloadcogs
07f30 0c9 09 C3 37 FC |                             wrlut   id, ptra[9]             'restore original value
07f34 0ca 2B F0 63 FD |                             pop     ptra                    'restore original ptra
07f38 0cb             |                             ' move LUT control vectors into temporary location to avoid clobbering them later
07f38 0cb D8 E5 B7 F9 |                             setd    d, #addr1
07f3c 0cc 60 E4 BF F9 |                             sets    d, #(ctrl_vect & $1ff)
07f40 0cd 08 04 DC FC |                             rep     #2, #8
07f44 0ce 3F E4 A7 F9 |                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
07f48 0cf 60 B0 A7 FA |                             rdlut   addr1-0, #$60-0
07f4c 0d0             | 
07f4c 0d0             |                             'setup control COG service handling, we need to patch 5 instructions
07f4c 0d0             |                             'one existing instruction is moved earlier and four instructions get replaced
07f4c 0d0 01 C2 63 FD |                             cogid   id
07f50 0d1 0C DE 07 F6 |                             mov     a, #(cog1-cog0)         'get code separation of handlers
07f54 0d2 E1 DF 03 FA |                             mul     a, id                   'scale ID by separation
07f58 0d3 24 DE 07 F1 |                             add     a, #cog0+4              'add to base for COG0 and offset
07f5c 0d4 EF E5 B3 F9 |                             setd    d, a                    'set this as the destination
07f60 0d5 02 DE 07 F1 |                             add     a, #2                   'increment COG address
07f64 0d6 EF E5 BB F9 |                             sets    d, a                    'set this as the source
07f68 0d7 3C E4 A7 F9 |                             alti    d, #%111_100             
07f6c 0d8 00 00 00 F6 |                             mov     0-0, 0-0                'move instruction
07f70 0d9 EE E4 BF F9 |                             sets    d, #controlpatch        'set source of patched instructions
07f74 0da 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
07f78 0db 3F E4 A7 F9 |                             alti    d, #%111_111
07f7c 0dc 00 00 00 F6 |                             mov     0-0, 0-0
07f80 0dd A5 E5 03 F1 |                             add     d, const512             'skip two instructions
07f84 0de A5 E5 03 F1 |                             add     d, const512
07f88 0df 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
07f8c 0e0 3F E4 A7 F9 |                             alti    d, #%111_111
07f90 0e1 00 00 00 F6 |                             mov     0-0, 0-0
07f94 0e2             |                             
07f94 0e2             |                             ' setup register values for control vector loop setup after we return
07f94 0e2 E1 C5 03 F6 |                             mov     header, id              'get cog ID
07f98 0e3 0A C4 07 FA |                             mul     header, #10             'multiply by size of state memory per COG
07f9c 0e4 20 C4 07 F1 |                             add     header, #$20            'add to COG state base address in LUT
07fa0 0e5 E2 C7 03 F6 |                             mov     trailer, header         'determine start/end LUT address
07fa4 0e6 09 C6 07 F1 |                             add     trailer, #9             '...for control region
07fa8 0e7 E0 C3 43 F5 |                             or      id, initctrl            'set id field for control COG
07fac 0e8 D0 C3 8F F9 |                             altd    id, #id0
07fb0 0e9 E1 01 00 F6 |                             mov     0-0, id                 'setup id field for notification
07fb4 0ea F8 F3 03 F6 |                             mov     ptrb, ptra              'get startup parameter address
07fb8 0eb 04 F2 07 F1 |                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
07fbc 0ec 00 E0 07 F6 |                             mov     b, #0                   'prepare b for upcoming loop
07fc0 0ed 2A 14 66 0D |                 _ret_       push    #notify                 'continue init in mailbox area
07fc4 0ee             |  
07fc4 0ee D8 CB 7B F8 | controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
07fc8 0ef 07 CA 07 F5 |                             and     request, #7
07fcc 0f0 F8 CB 03 F1 |                             add     request, ptra           'add request vector offset
07fd0 0f1 E5 CB A3 FA |                             rdlut   request, request        'lookup jump vector service table 
07fd4 0f2             | 
07fd4 0f2             |                             fit     $100                    'ensure all init code fits this space
07fd4 0f2             |                             fit     $100                    'ensure all init code fits this space
07fd4 0f2             | 
07fd4 0f2 00 00 00 00 
      ...             
08004 0fe 00 00 00 00 
08008 0ff 00 00 00 00 |                             long    0[$100-$]               'pad more if required until table ends
0800c 100             | 
0800c 100             | '..................................................................................................
0800c 100             | ' Error result handling and COG notification of request completion
0800c 100             | 
0800c 100 04 04 4C FB | unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
08010 101 03 02 4C FB | invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
08014 102 02 06 4C FB | invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
08018 103 01 08 4C FB | alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
0801c 104 05 EC 07 F6 | busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
08020 105 D0 C3 8F F9 | err                         altd    id, #id0                'adjust for the running COG
08024 106 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
08028 107 08 01 3C FC |                             wrlut   #0, ptra[8]             'cancel any resume state
0802c 108 32 04 64 FD |                             skipf   #%10                    'dont notify with success code 0 below
08030 109 BF ED 67 FC |                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
08034 10a BF 01 6C FC | notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
08038 10b 0B C2 0F F4 |                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
0803c 10c E1 DF C3 F9 |                             decod   a, id                   'convert COG ID to bitmask
08040 10d 3F DE 63 AD |             if_z            cogatn  a                       'notify COG via ATN
08044 10e             | ' Poller re-starts here after a COG is serviced
08044 10e 0F C2 0F F4 | poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
08048 10f E6 5F 03 57 |             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
0804c 110 AF 45 CB F9 |                             bmask   mask, rrcounter         'generate a RR skip mask from the count
08050 111             | ' Main dynamic polling loop repeats until a request arrives
08050 111 00 00 DC FC | polling_loop                rep     #0-0, #0                'repeat until we get a request for something
08054 112 28 2E 64 FD |                             setq    #24-1                   'read 24 longs
08058 113 A7 01 00 FB |                             rdlong  req0, mbox              'get all mailbox requests and data longs
0805c 114             | 
0805c 114 B0 01 B0 FB | polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
08060 115 32 44 63 FD |                             skipf   mask                    ']after all priority COG handlers if present
08064 116 B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
08068 117 B2 0D B0 FB |                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
0806c 118 B3 13 B0 FB |                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
08070 119 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
08074 11a B5 1F B0 FB |                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
08078 11b B6 25 B0 FB |                             tjs     req6, cog6_handler      ']based on the active COGs being polled
0807c 11c B7 2B B0 FB |                             tjs     req7, cog7_handler      ']and whether priority or round robin.
08080 11d B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
08084 11e B2 0D B0 FB |                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
08088 11f B3 13 B0 FB |                             tjs     req3, cog3_handler      ']have changed.
0808c 120 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
08090 121 B5 1F B0 FB |                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
08094 122 B6 25 B0 FB |                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
08098 123 B7 2B B0 FB | pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
0809c 124             | 
0809c 124 B0 01 B0 FB | ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
080a0 125 32 44 63 FD | skipfinst                   skipf   mask                    'instruction template for skipf
080a4 126             |  
080a4 126             | '..................................................................................................
080a4 126             | ' List handler                               
080a4 126             | 
080a4 126 01 B0 A7 FB | dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
080a8 127 33 C0 63 FD |                             execf   burstwrite              'otherwise do a burst write to this bank
080ac 128 28 0E 64 FD | real_list                   setq    #8-1                    'read 8 longs (largest request size)
080b0 129 D9 B1 03 FB |                             rdlong  addr1, hubdata          '..to update the request state
080b4 12a D7 B1 BF FB |                             tjns    addr1, #invalidlist     'error if request list item not valid
080b8 12b D0 C3 8F F9 |                             altd    id, #id0                'get COG state
080bc 12c 09 00 3C F4 |                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
080c0 12d 09 C2 27 F4 |                             bith    id, #LIST_BIT           'retain fact that we are in a list
080c4 12e 44 FF 9F AD |             if_z            jmp     #unsupported            'no list recursion is allowed!
080c8 12f D8 CB FB F8 |                             getbyte request, addr1, #3      'get upper byte of this request
080cc 130 00 CA 8F F9 | service_request             altd    request, #0             'get request address in COG RAM
080d0 131 33 00 60 FD |                             execf   0-0                     'process the request 
080d4 132             | 
080d4 132             | '..................................................................................................
080d4 132             | ' Restoring per COG state and resuming where we left off
080d4 132             | 
080d4 132 00 B1 A7 FA | restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
080d8 133 01 B3 A7 FA |                             rdlut   hubdata, ptra[1]
080dc 134 02 B5 A7 FA |                             rdlut   count, ptra[2]
080e0 135 03 B7 B7 FA |                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
080e4 136 D8 CB FB F8 |                             getbyte request, addr1, #3
080e8 137 33 D2 63 3D |             if_nc           execf   resume                  'if not extended then resume immediately
080ec 138 04 B9 A7 FA |                             rdlut   total, ptra[4]          'we need to read the extended parameters
080f0 139 05 BB A7 FA |                             rdlut   offset1, ptra[5]
080f4 13a 06 BD A7 FA |                             rdlut   offset2, ptra[6]
080f8 13b 07 BF A7 FA |                             rdlut   link, ptra[7]
080fc 13c 09 D5 A7 FA |                             rdlut   orighubsize, ptra[9]
08100 13d 33 D2 63 FD |                             execf   resume                  'then resume what we were doing last time
08104 13e             |                    
08104 13e             | '..................................................................................................
08104 13e             | ' Re-configuration of QoS settings and custom polling loop sequence generator
08104 13e             | 
08104 13e 2A 14 66 FD | reconfig                    push    #notify                 'setup return addr, then reload 
08108 13f 28 0E 64 FD | reloadcogs                  setq    #8-1                    'reload all per COG QoS params
0810c 140 A6 B1 03 FB |                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
08110 141 D0 DF B7 F9 |                             setd    a, #id0
08114 142 D8 DF BF F9 |                             sets    a, #addr1
08118 143 FE FF FF FF 
0811c 144 28 00 66 FD |                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
08120 145 08 04 DC FC |                             rep     #2, #8                  'repeat for 8 COGs
08124 146 3F DE A7 F9 |                             alti    a, #%111_111 
08128 147 00 00 F0 F9 |                             muxq    0-0, 0-0
0812c 148 09 01 A4 FA | patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
08130 149 01 E2 63 FD |                             cogid   c
08134 14a F1 41 C3 F9 |                             decod   excludedcogs, c         'exclude driver cog initially
08138 14b 08 DE 07 F6 |                             mov     a, #$8                  'a iterates through prio levels 8=lowest
0813c 14c 01 EC 67 F6 |                             neg     pa, #1                  'start with all ones
08140 14d 07 E2 07 F6 | fillprio                    mov     c, #7                   'c iterates through cogs
08144 14e D0 E3 97 F9 | prioloop                    alts    c, #id0
08148 14f 00 E0 03 F6 |                             mov     b, 0-0
0814c 150 F0 E5 3B F9 |                             getword d, b, #1                'get burst field
08150 151 F2 E5 CB F7 |                             test    d wz                    'if burst=0 
08154 152 F1 41 23 A4 |             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
08158 153 0C 00 90 AD |             if_z            jmp     #excluded               
0815c 154 F0 E5 5B F8 |                             getnib  d, b, #3                'get RR/PRI flag & priority
08160 155 EF E5 0B F2 |                             cmp     d, a wz                 'compare against current priority level
08164 156 F1 ED 83 A8 |             if_z            rolnib  pa, c, #0               'if matches include COG at this level
08168 157 F6 E3 7F FB | excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
0816c 158 0F DE 0F F7 |                             incmod  a, #15 wz               'next level
08170 159 CC FF 9F 5D |             if_nz           jmp     #fillprio 
08174 15a             | 
08174 15a             | 'determine priority cogs and build instructions for the polling sequence
08174 15a 00 EE 07 F6 |                             mov     pb, #0                  'clear out set of priority COGs
08178 15b 03 DE 07 F6 |                             mov     a, #3                   'start with no COGs being polled + 3 instructions
0817c 15c 14 E5 B7 F9 |                             setd    d, #polling_code        'initialize COGRAM write position
08180 15d             | 
08180 15d 08 18 DC FC |                             rep     @endprioloop, #8        'test all 8 priority slots
08184 15e 03 EC 17 F4 |                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
08188 15f F6 E3 43 F8 |                             getnib  c, pa, #0               'get cogid ID at this priority level
0818c 160 F1 EF 0B 34 |             if_nc           testb   pb, c wz                'check if already exists as priority COG
08190 161 F1 EF 23 14 |             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
08194 162 01 DE 07 11 |             if_nc_and_nz    add     a, #1                   'add another COG to poll 
08198 163 B0 E3 97 19 |             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
0819c 164 00 46 BE 19 |             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
081a0 165 03 E2 07 1A |             if_nc_and_nz    mul     c, #3
081a4 166 F1 47 B2 19 |             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
081a8 167 38 E4 A7 19 |             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
081ac 168 23 01 00 16 |             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
081b0 169 04 EC 07 F0 |                             ror     pa, #4                  'advance to next priority
081b4 16a             | endprioloop
081b4 16a FF EE 67 F5 |                             xor     pb, #$ff                'invert to find all the non-priority COGs
081b8 16b A0 EF 23 F5 |                             andn    pb, excludedcogs        'and remove any other excluded COGs
081bc 16c F7 CD AB F7 |                             ones    rrlimit, pb wz          'count the number of RR COGs
081c0 16d E6 DF 03 F1 |                             add     a, rrlimit              'account for this number of RR COGs to poll
081c4 16e 01 CC 87 F1 |                             sub     rrlimit, #1             'setup last RR count value for incmod
081c8 16f 38 E4 A7 F9 |                             alti    d, #%111_000            'generate the control polling instruction
081cc 170 24 01 00 F6 |                             mov     0-0, ctrlpollinst       'write the instruction
081d0 171 38 E4 A7 59 |             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
081d4 172 25 01 00 56 |             if_nz           mov     0-0, skipfinst          'add the skipf instruction
081d8 173 02 DE 07 51 |             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
081dc 174 EF 23 B2 F9 |                             setd    polling_loop, a         'save it as the repeat count
081e0 175 2D 00 64 AD |             if_z            ret                             'we are done now, if no round robin COGs
081e4 176             | 
081e4 176             | ' populate the round robin COG polling instructions
081e4 176 02 5E 07 F6 |                             mov     rrcounter, #2           'fill the RR poll instruction list twice
081e8 177 F7 E1 03 F6 | rrloop                      mov     b, pb                   'get the set of RR COGs
081ec 178 00 E2 07 F6 |                             mov     c, #0                   'start at COG ID = 0
081f0 179 00 DE 07 F6 |                             mov     a, #0                   'req mailbox COGRAM address for COG 0
081f4 17a 01 E0 5F F0 | nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
081f8 17b EF 47 B2 C9 |             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
081fc 17c B0 E3 97 C9 |             if_c            alts    c, #cog0_handler        'determine jump address
08200 17d 00 46 BE C9 |             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
08204 17e 38 E4 A7 C9 |             if_c            alti    d, #%111_000            'generate new COG RAM write address
08208 17f 23 01 00 C6 |             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
0820c 180 01 E2 07 F1 |                             add     c, #1                   'increment the COG ID
08210 181 03 DE 07 F1 |                             add     a, #3                   'increase the request address
08214 182 DC FF 9F 5D |             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
08218 183 F3 5F 6F 0B |             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
0821c 184             | '..................................................................................................
0821c 184             | ' Code to get/set driver settings per bank or to dump COG/LUT state
0821c 184             | 
0821c 184             | set_latency                                                 '            (a) set latency
0821c 184             | get_latency                                                 '            (b) get latency
0821c 184             | set_burst                                                   '            (c) set burst size of bank
0821c 184             | get_burst                                                   '            (d) get burst size of bank
0821c 184             |                                                             '            (e) dump state
0821c 184 D8 E1 73 F8 |                             getnib  b, addr1, #6            ' a b c d    get bank address
08220 185 28 FE 67 FD | dump_state                  setq    #511                    ' | | | | e  prepare burst write
08224 186 D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
08228 187             |                                                             ' | | | | e  account for following AUGS
08228 187 04 00 00 FF 
0822c 188 00 B2 07 F1 |                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
08230 189 29 FE 67 FD |                             setq2   #511                    ' | | | | e  prepare burst write
08234 18a D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
08238 18b 10 E0 07 F1 |                             add     b, #16                  ' a b | | |  point to latency params
0823c 18c F0 DF A3 FA |                             rdlut   a, b                    ' a b c d |  read data for bank
08240 18d D9 DF DB F8 |                             setbyte a, hubdata, #3          ' a | | | |  patch latency
08244 18e D9 DF 03 F6 |                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
08248 18f F0 DF 33 FC |                             wrlut   a, b                    ' a | c | |  if setting, save bank data
0824c 190 EF DF FB F8 |                             getbyte a, a, #3                ' | b | | |  extract latency field only
08250 191 80 DF 67 FC |                             wrlong  a, ptrb                 ' | b | d |  write result          
08254 192 DC FD 9F FD |                             jmp     #notify                 ' a b c d e  return success
08258 193             | 
08258 193             | '..................................................................................................
08258 193             | ' Misc EXECF code
08258 193             | 
08258 193 33 72 63 FD | start_read_exec             execf   newburstr
0825c 194 33 7C 63 FD | start_write_exec            execf   resumewrites
08260 195 33 78 63 FD | continue_read_exec          execf   lockedreads
08264 196 33 7A 63 FD | continue_write_exec         execf   lockedwrites
08268 197             | 
08268 197             | '..................................................................................................
08268 197             | ' Variables
08268 197             | 
08268 197 08 00 CF 20 | ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
0826c 198 01 00 C6 E0 | xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
08270 199 01 00 C6 E0 | xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
08274 19a 00 00 C0 F0 | xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
08278 19b 00 00 C0 B0 | xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
0827c 19c 02 00 C0 70 | xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
08280 19d             | 
08280 19d 00 00 00 80 | xfreq1          long    $80000000
08284 19e 00 00 00 40 | xfreq2          long    $40000000
08288 19f 03 00 00 00 | delay           long    3
0828c 1a0             | 
0828c 1a0             | lutcodeaddr                 
0828c 1a0             | startupparams
0828c 1a0             | excludedcogs                                    'careful: shared register use!
0828c 1a0 CC 07 00 00 | frequency       long    lut_code - driver_start 'determine offset of LUT code from base
08290 1a1 00 00 00 00 | flags           long    0
08294 1a2             | mask                                            'careful: shared register use!
08294 1a2 00 00 00 00 | resetmaskA      long    0
08298 1a3             | limit                                           'careful: shared register use!
08298 1a3 00 00 00 00 | resetmaskB      long    0
0829c 1a4 00 00 00 00 | datapins        long    0
082a0 1a5             | const512                                        'careful: shared register use!
082a0 1a5 00 00 00 00 | devicelist      long    0
082a4 1a6 00 00 00 00 | coglist         long    0
082a8 1a7 00 00 00 00 | mbox            long    0 
082ac 1a8             | 
082ac 1a8             | clkpin                                          'shared with code patched during init
082ac 1a8 A8 03 18 FC | clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
082b0 1a9             | cspin                                           'shared with code patched during init
082b0 1a9 1D 3A 63 FD | speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
082b4 1aa 00 00 01 00 | registered      long    %100_000_000_00_00000_0 'config pin for clocked input
082b8 1ab 4A 00 00 00 | clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
082bc 1ac 01 00 00 00 | clkdelay        long    1
082c0 1ad 00 00 00 00 | regdatabus      long    0
082c4 1ae             | 
082c4 1ae 10 00 00 00 | deviceaddr      long    $10
082c8 1af             | rrcounter
082c8 1af 7F 7F 3F FF | pinmask         long    $ff3f7f7f
082cc 1b0             | 
082cc 1b0             | ' jump addresses for the per COG handlers
082cc 1b0 20 00 00 00 | cog0_handler    long    cog0
082d0 1b1 2C 00 00 00 | cog1_handler    long    cog1
082d4 1b2 38 00 00 00 | cog2_handler    long    cog2
082d8 1b3 44 00 00 00 | cog3_handler    long    cog3
082dc 1b4 50 00 00 00 | cog4_handler    long    cog4
082e0 1b5 5C 00 00 00 | cog5_handler    long    cog5
082e4 1b6 68 00 00 00 | cog6_handler    long    cog6
082e8 1b7 74 00 00 00 | cog7_handler    long    cog7
082ec 1b8 0C 0F 00 00 | expansion       long    gfxexpansion - driver_start
082f0 1b9             | 
082f0 1b9             | ' EXECF sequences
082f0 1b9 70 7A 80 22 | newburstr       long    (%0010001010000000011110 << 10) + r_burst
082f4 1ba 48 9B EF 00 | lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
082f8 1bb 41 F3 05 74 | restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
082fc 1bc 80 22 3F 00 | lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
08300 1bd 4B F3 E0 0F | lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
08304 1be 4B 03 E0 0F | resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
08308 1bf 76 02 8A 84 | resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
0830c 1c0             | 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
0830c 1c0             | 
0830c 1c0             | 
0830c 1c0             | ' SKIPF sequences
0830c 1c0             | skiptable
0830c 1c0 7E 30 0C 00 |                 long    %11000011000001111110  ' read modify write byte
08310 1c1 0E 37 03 00 |                 long    %110011011100001110    ' read modify write word
08314 1c2 00 00 00 00 |                 long    0                      ' read modify write long
08318 1c3 7E 00 00 00 |                 long    %1111110               ' single byte read
0831c 1c4 8E 07 00 00 |                 long    %11110001110           ' single word read
08320 1c5 00 00 00 00 | pattern2        long    0
08324 1c6 00 00 00 00 | pattern3        long    0
08328 1c7 77 02 00 00 | singlelong      long    %1001110111  
0832c 1c8 FD 10 80 6F | skipcase_a      long    %01101111100000000001000011111101
08330 1c9 10 18 50 00 | skipcase_b      long    %00000000010100000001100000010000
08334 1ca 11 3E 60 00 | skipcase_c      long    %00000000011000000011111000010001
08338 1cb 02 0F 00 00 | skipseq_write   long    %00000000000000000000111100000010
0833c 1cc             | 
0833c 1cc             | ' LUT RAM address values
0833c 1cc FF 02 00 00 | complete_rw     long    complete_rw_lut
08340 1cd DD 02 00 00 | continue_read   long    continue_read_lut
08344 1ce DB 02 00 00 | continue_write  long    continue_write_lut
08348 1cf F6 02 00 00 | noread          long    noread_lut
0834c 1d0             | 
0834c 1d0 00 00 00 00 | id0             long    0
08350 1d1 01 00 00 00 | id1             long    1
08354 1d2 02 00 00 00 | id2             long    2
08358 1d3 03 00 00 00 | id3             long    3
0835c 1d4 04 00 00 00 | id4             long    4
08360 1d5 05 00 00 00 | id5             long    5
08364 1d6 06 00 00 00 | id6             long    6
08368 1d7 07 00 00 00 | id7             long    7
0836c 1d8             | 
0836c 1d8             | 'These next 10 request registers below are also temporarily reused during init 
0836c 1d8             | 'and COG updates and need to follow immediately after id0-id7
0836c 1d8 00 00 00 00 | addr1           long    0
08370 1d9 00 00 00 00 | hubdata         long    0
08374 1da 00 00 00 00 | count           long    0
08378 1db 00 00 00 00 | addr2           long    0
0837c 1dc 00 00 00 00 | total           long    0
08380 1dd 00 00 00 00 | offset1         long    0
08384 1de 00 00 00 00 | offset2         long    0
08388 1df 00 00 00 00 | link            long    0
0838c 1e0             | 
0838c 1e0             | burstwrite                                      'note shared register use during init
0838c 1e0 00 10 F0 FE | initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
08390 1e1 00 00 00 00 | id              long    0
08394 1e2             | 
08394 1e2 00 00 00 00 | header          long    0
08398 1e3 00 00 00 00 | trailer         long    0
0839c 1e4 00 00 00 00 | cmdaddr         long    0
083a0 1e5 00 00 00 00 | request         long    0
083a4 1e6 00 00 00 00 | rrlimit         long    0
083a8 1e7 00 00 00 00 | pinconfig       long    0
083ac 1e8 00 00 00 00 | clks            long    0
083b0 1e9 00 00 00 00 | resume          long    0
083b4 1ea 00 00 00 00 | orighubsize     long    0
083b8 1eb 00 00 00 00 | wrclks          long    0
083bc 1ec             | 
083bc 1ec 00 00 00 00 | pattern         long    0
083c0 1ed 00 00 00 00 | hubscratch      long    0
083c4 1ee 00 10 00 00 | val4k           long    4096
083c8 1ef             | 
083c8 1ef             | ' temporary general purpose regs
083c8 1ef 00 00 00 00 | a               long    0
083cc 1f0 00 00 00 00 | b               long    0
083d0 1f1 00 00 00 00 | c               long    0
083d4 1f2 00 00 00 00 | d               long    0
083d8 1f3             | 
083d8 1f3             |                 fit     502
083d8 1f3             |                 fit     502
083d8 1f3             | 
083d8 1f3             | '..................................................................................................
083d8 1f3             | 
083d8 1f3             |             orgh
083d8                 | 
083d8                 | lut_code
083d8                 | 'HW init code up to 80 longs
083d8                 | 
083d8                 | '..................................................................................................
083d8                 | ' Memory layout for LUT RAM once operational:
083d8                 | '
083d8                 | '  LUT RAM address      Usage
083d8                 | '  ---------------      ----
083d8                 | '    $200-$20F          Bank parameters: burst + type + size per bank (16)
083d8                 | '    $210-$21F          Pin parameters : latency + control pins per bank (16)
083d8                 | '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
083d8                 | '    $270-$3FF          Main PSRAM access code in LUTRAM 
083d8                 | '
083d8                 | ' Also during driver COG startup:
083d8                 | ' $230-$24F is used for HW init setup
083d8                 | ' $250-$26F is used as temporary vector storage 
083d8                 | '..................................................................................................
083d8                 | 
083d8                 |                 org $230    
083d8 230             | 
083d8 230             | ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
083d8 230 1D 3C 63 FD | hwinit                      setxfrq xfreq2
083dc 231 24 16 60 FD |                             pollxfi
083e0 232 FF AA 2A FF 
083e4 233 FF ED 07 F6 |                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
083e8 234 28 00 B0 FD |                             call    #sendqspi
083ec 235 07 F8 07 FF 
083f0 236 F0 ED 07 F6 |                             mov     pa, ##$0FF00FF0         '$66 - reset enable
083f4 237 28 00 B0 FD |                             call    #sendspi
083f8 238 F8 07 78 FF 
083fc 239 0F EC 07 F6 |                             mov     pa, ##$F00FF00F         '$99 - reset
08400 23a 1C 00 B0 FD |                             call    #sendspi
08404 23b 7F 78 78 FF 
08408 23c 00 ED 07 F6 |                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
0840c 23d 10 00 B0 FD |                             call    #sendspi 
08410 23e 2D 00 64 FD |                             ret
08414 23f             | 
08414 23f 04 D0 07 F6 | sendqspi                    mov     clks,#4
08418 240 32 0C 64 FD |                             skipf   #%110
0841c 241 9C EF 03 F6 |                             mov     pb, xsendimm
08420 242             | 
08420 242 10 D0 07 F6 | sendspi                     mov     clks, #16
08424 243 97 EF 03 F6 |                             mov     pb, ximm8lut
08428 244 58 52 63 FD |                             drvl    cspin                   'active low chip select
0842c 245 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
08430 246 F6 EF A3 FC |                             xinit   pb, pa                  'send 32 bit immediate data
08434 247 A8 D1 23 FC |                             wypin   clks, clkpin            'start memory clock output 
08438 248 24 36 60 FD |                             waitxfi                         'wait for the completion
0843c 249 50 48 63 FD |                             fltl    datapins                'float data bus
08440 24a 59 52 63 FD |                             drvh    cspin                   'raise chip select
08444 24b 1F 90 65 0D |             _ret_           waitx   #200                    'delay before return to ensure CS delay
08448 24c             | 
08448 24c 00 00 00 00 
0844c 24d 00 00 00 00 
08450 24e 00 00 00 00 
08454 24f 00 00 00 00 |                 long    0[$270-32-$]
08458 250             |     
08458 250             |                 fit     $270-32  ' keep room for 32 vector longs
08458 250             |                 fit     $270-32  ' keep room for 32 vector longs
08458 250             | ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
08458 250             | rw_vect ' PSRAM jump vectors
08458 250 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
0845c 251 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
08460 252 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
08464 253 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
08468 254 41 E3 00 74 |                 long    (%0111010000000000111000 << 10) + w_single
0846c 255 41 93 00 74 |                 long    (%0111010000000000100100 << 10) + w_single
08470 256 41 73 00 74 |                 long    (%0111010000000000011100 << 10) + w_single
08474 257 47 1B 00 FE |                 long    (%1111111000000000000110 << 10) + w_burst
08478 258             | ro_vect ' R/O PSRAM jump vectors
08478 258 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
0847c 259 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
08480 25a 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
08484 25b 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
08488 25c 00 01 00 00 |                 long    unsupported
0848c 25d 00 01 00 00 |                 long    unsupported
08490 25e 00 01 00 00 |                 long    unsupported
08494 25f 00 01 00 00 |                 long    unsupported
08498 260             | ctrl_vect ' Control jump vectors
08498 260 84 F9 39 00 |                 long    (%0000000000111001111110 << 10) + get_latency
0849c 261 00 01 00 00 |                 long    unsupported
084a0 262 84 F9 7B 00 |                 long    (%0000000001111011111110 << 10) + get_burst
084a4 263 85 01 7F 00 |                 long    (%0000000001111111000000 << 10) + dump_state
084a8 264 84 F9 D1 00 |                 long    (%0000000011010001111110 << 10) + set_latency
084ac 265 00 01 00 00 |                 long    unsupported
084b0 266 84 F9 CB 00 |                 long    (%0000000011001011111110 << 10) + set_burst
084b4 267 3E 01 00 00 |                 long    reconfig 
084b8 268             | no_vect ' Invalid bank jump vectors
084b8 268 01 01 00 00 |                 long    invalidbank
084bc 269 01 01 00 00 |                 long    invalidbank
084c0 26a 01 01 00 00 |                 long    invalidbank
084c4 26b 01 01 00 00 |                 long    invalidbank
084c8 26c 01 01 00 00 |                 long    invalidbank
084cc 26d 01 01 00 00 |                 long    invalidbank
084d0 26e 01 01 00 00 |                 long    invalidbank
084d4 26f 01 01 00 00 |                 long    invalidbank
084d8 270             | 
084d8 270             |                 fit     $270
084d8 270             |                 fit     $270
084d8 270             | '..................................................................................................
084d8 270             | ' PSRAM READS
084d8 270             |                                                             ' a b c d e f
084d8 270             |                                                             ' B W L B R L  (a) byte read
084d8 270             |                                                             ' Y O O U E O  (b) word read
084d8 270             |                                                             ' T R N R S C  (c) long read
084d8 270             |                                                             ' E D G S U K  (d) new burst read
084d8 270             |                                                             '       T M E  (e) resumed sub-burst
084d8 270             |                                                             '         E D  (f) locked sub-burst
084d8 270             | 
084d8 270             | 
084d8 270 DA D5 03 F6 | r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
084dc 271 DA B5 CB F7 | r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
084e0 272 36 D9 07 F6 |                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
084e4 273 20 D9 27 A5 |             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
084e8 274 02 34 27 F9 |                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
084ec 275 80 B4 97 FB |                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
084f0 276 E5 E1 43 F8 | r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
084f4 277 F0 E1 A3 FA |                             rdlut   b, b                    ' a b c d e    get bank limit/mask
084f8 278 F0 45 CB F9 |                             bmask   mask, b                 ' | | | d e    build mask for addr
084fc 279 F0 3F EB F8 |                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
08500 27a 11 E0 47 F0 | p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
08504 27b F0 47 23 F3 |                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
08508 27c 05 3E 57 F0 |                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
0850c 27d 10 5A 67 04 |             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
08510 27e 10 5A 67 F4 |                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
08514 27f F9 3B 83 FC |                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
08518 280 D9 3B 83 FC | r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
0851c 281 DA E3 03 F6 |                             mov     c, count                ' | | | d e f  get count of bytes left to read
08520 282 A3 E3 33 F3 |                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
08524 283 20 D0 17 F6 |                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
08528 284 CD D3 03 C6 |             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
0852c 285 CC D3 03 36 |             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
08530 286 32 20 64 FD |                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
08534 287 E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
08538 288 AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
0853c 289 E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
08540 28a E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
08544 28b 54 00 90 FD |                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
08548 28c             | 
08548 28c             |                             ' fall through to read bursts
08548 28c             |                         
08548 28c             | burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
08548 28c D8 E5 03 F6 |                             mov     d, addr1                'get start address
0854c 28d 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
08550 28e EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
08554 28f F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
08558 290 CD D3 03 C6 |             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
0855c 291 00 D8 07 F6 |                             mov     pattern, #0             'enable all by default
08560 292 01 B0 17 F4 |                             testb   addr1, #1 wc            'test if start addr starts in second word
08564 293 01 D8 67 F4 |                             bitnc   pattern, #1             'enable delay cycle if so
08568 294 6C D0 63 FD |                             wrc     clks                    'and account for its clock cycle
0856c 295 00 B0 17 F4 |                             testb   addr1, #0 wc            'test if start addr starts on odd byte
08570 296 02 D8 67 F4 |                             bitnc   pattern, #2             'add hi 8 transfer initially
08574 297 F1 E5 03 F6 |                             mov     d, c                    'get count of bytes to be read into HUB
08578 298 01 E4 87 C1 |             if_c            sub     d, #1                   'minus 1 if start addr was odd
0857c 299 01 E4 4F F0 |                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
08580 29a F2 D1 23 F1 |                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
08584 29b F2 35 23 F9 |                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
08588 29c 03 D8 87 F4 |                             bitz    pattern, #3             'adjust the pattern to include this
0858c 29d 00 E2 D7 F4 |                             testb   c, #0 xorc              'test for end address
08590 29e 04 D8 67 F4 |                             bitnc   pattern, #4             'include low 8 bit transfer if required
08594 29f 0E D0 27 F1 |                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
08598 2a0 E8 D1 03 F1 |                             add     clks, clks
0859c 2a1             | readcommon
0859c 2a1 D8 C9 03 F6 |                             mov     cmdaddr, addr1          'get start address of transfer
085a0 2a2 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
085a4 2a3 EB C8 DF F8 |                             setbyte cmdaddr, #$EB, #3       'add quad read command
085a8 2a4             | 
085a8 2a4 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
085ac 2a5 69 C8 63 FD |                             rev     cmdaddr
085b0 2a6 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
085b4 2a7 61 C8 63 FD |                             mergeb  cmdaddr
085b8 2a8             | 
085b8 2a8 58 52 63 FD |                             drvl    cspin                   'activate chip select
085bc 2a9 58 48 63 FD |                             drvl    datapins                'enable data bus
085c0 2aa             |             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
085c0 2aa E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'stream out command+address
085c4 2ab A8 D1 23 FC |                             wypin   clks, clkpin            'start clock output
085c8 2ac 00 00 CC FC |                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
085cc 2ad 00 0C CC FC |                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
085d0 2ae             |                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
085d0 2ae 50 48 63 FD |                             fltl    datapins                'safe to float the data bus, address has been sent by now
085d4 2af A4 5B 03 FC |                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
085d8 2b0 28 3A 63 FD |                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
085dc 2b1 00 3E C7 FC |                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
085e0 2b2 00 0C CC FC |                             xcont   #6, #0                  'fixed delay offset to expand delay range
085e4 2b3 32 D8 63 FD |                             skipf   pattern                 'choose path below
085e8 2b4             |                                                             'Bursts Bytes Words Longs  RMW FromWrites
085e8 2b4 28 3C 63 FD |                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
085ec 2b5 00 02 CC FC |                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
085f0 2b6 00 32 C7 FC |                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
085f4 2b7 00 34 C7 FC |                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
085f8 2b8 00 30 C7 FC |                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
085fc 2b9 2D D2 63 FD |                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
08600 2ba 24 36 60 FD |                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
08604 2bb A4 55 03 FC |                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
08608 2bc 59 52 63 0D |             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
0860c 2bd 59 52 63 FD |                             drvh    cspin                   '         b     c           e       deassert chip select and continue
08610 2be E5 E5 4B F8 |                             getnib  d, request, #1          'get request code value
08614 2bf 03 E4 87 51 |             if_nz           sub     d, #3                   'offset for table if RMW
08618 2c0 BB E5 8F F9 |                             altd    d, #skiptable-5         'patch next instruction
0861c 2c1 32 00 60 FD |                             skipf   0-0                     'generate skip sequence
08620 2c2             |                                                             ' B   W  RMWB RMWW RMLL 
08620 2c2 80 DF 07 FB |                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
08624 2c3 28 B4 63 FD |                             setq    count                   ' |   |   |    |    e   setup bit mux mask
08628 2c4 D9 DF F3 F9 |                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
0862c 2c5 40 00 90 FD |                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
08630 2c6 01 B0 17 F4 |                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
08634 2c7 EF EF 3B C9 |             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
08638 2c8 EF EF 33 39 |             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
0863c 2c9 D8 E5 03 F6 |                             mov     d, addr1                ' a   |   c    d
08640 2ca 03 E4 07 F5 |                             and     d, #3                   ' a   |   c    |        get LSBs of address
08644 2cb EF E5 6F F9 |                             altgb   d, #a                   ' a   |   c    |        index into long
08648 2cc 00 EE E3 F8 |                             getbyte pb                      ' a   |   c    |        and extract the byte
0864c 2cd 80 EF 67 FC |                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
08650 2ce C0 00 B0 FD |                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
08654 2cf 2D 00 64 FD |                             ret                             ' a   b   |    |        then return
08658 2d0 28 B4 63 FD |                             setq    count                   '         c    d        setup bit mux mask
0865c 2d1 D9 EF F3 F9 |                             muxq    pb, hubdata             '         c    d        apply bit mux
08660 2d2 EF E5 67 F9 |                             altsb   d, #a                   '         c    |
08664 2d3 F7 01 C0 F8 |                             setbyte 0-0, pb, #0             '         c    |
08668 2d4 F7 DF 2B C9 |             if_c            setword a, pb, #1               '         |    d
0866c 2d5 F7 DF 23 39 |             if_nc           setword a, pb, #0               '         |    d
08670 2d6 37 8A 07 F6 | writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
08674 2d7 EF B3 03 F6 |                             mov     hubdata, a              'write a to PSRAM
08678 2d8 14 D6 07 F6 |                             mov     wrclks, #20             '20 clocks to write a long
0867c 2d9 CC D3 03 F6 |                             mov     resume, complete_rw     'we'll complete the operation after this
08680 2da 10 03 90 FD |                             jmp     #writecommon
08684 2db             | 
08684 2db             | '..................................................................................................
08684 2db             | ' Burst continuation testing
08684 2db             | 
08684 2db 32 96 63 FD | continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
08688 2dc BE D3 03 F6 |                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
0868c 2dd             | continue_read_lut          
0868c 2dd BF D3 03 F6 |                             mov     resume, resumereads     ' | setup resume address to execf
08690 2de F1 B3 03 F1 |                             add     hubdata, c              ' a compute the next hub addr to use
08694 2df F1 B5 83 F1 |                             sub     count, c                ' a account for the bytes already sent
08698 2e0 D8 E3 03 F1 |                             add     c, addr1                ' a compute next external mem address
0869c 2e1 28 44 63 FD |                             setq    mask                    ' a configure mask for bit muxing
086a0 2e2 F1 B1 F3 F9 |                             muxq    addr1, c                ' a perform address bit muxing
086a4 2e3 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
086a8 2e4 14 00 90 5D |             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
086ac 2e5 E1 47 3B F9 |                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
086b0 2e6 F0 47 23 F3 |                             fle     limit, b                ' | also re-apply per bank limit
086b4 2e7 2A 2A 67 0D |             _ret_           push    #continue_read_exec     ' | 
086b8 2e8 04 00 90 5D |             if_nz           jmp     #yield                  ' a
086bc 2e9 2A 2C 67 0D |             _ret_           push    #continue_write_exec    ' a
086c0 2ea             | 
086c0 2ea 04 B9 37 FC | yield                       wrlut   total, ptra[4]          'save context for next time
086c4 2eb 05 BB 37 FC |                             wrlut   offset1, ptra[5]        'save context for next time
086c8 2ec 06 BD 37 FC |                             wrlut   offset2, ptra[6]        'save context for next time
086cc 2ed 07 BF 37 FC |                             wrlut   link, ptra[7]           'save context for next time
086d0 2ee 00 B1 37 FC | yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
086d4 2ef 01 B3 37 FC |                             wrlut   hubdata, ptra[1]        'save context for next time
086d8 2f0 02 B5 37 FC |                             wrlut   count, ptra[2]          'save context for next time
086dc 2f1 03 B7 37 FC |                             wrlut   addr2, ptra[3]          'save context for next time
086e0 2f2 08 D3 37 FC |                             wrlut   resume, ptra[8]         'save next resume address
086e4 2f3 09 D5 37 FC |                             wrlut   orighubsize, ptra[9]    'save original hub size
086e8 2f4 2A 1C 66 0D |             _ret_           push    #poller
086ec 2f5             | 
086ec 2f5             | 
086ec 2f5 32 BE 65 FD | notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
086f0 2f6             | nowrite_lut                                                 '  (a) new skip sequence 
086f0 2f6 32 00 64 FD | noread_lut                  skipf   #0                      ' | cancel skipping
086f4 2f7 08 01 3C FC |                             wrlut   #0, ptra[8]             ' | clear resume
086f8 2f8 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
086fc 2f9 40 F8 9F 5D |             if_nz           jmp     #notify                 ' | if not a request list then we are done
08700 2fa 1F B6 0F F4 |                             testb   addr2, #31 wz           ' | check if extended list item
08704 2fb DF B7 03 A6 | donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
08708 2fc 1C 00 B0 FD | checklist                   call    #checknext              ' | handle running from list
0870c 2fd 2D 00 64 FD |                             ret                             ' | continue processing
08710 2fe 2A 9E 63 0D |             _ret_           push    noread                  'continue end of transfer
08714 2ff             | '..................................................................................................
08714 2ff             | ' Completion of requests
08714 2ff             | 
08714 2ff             | complete_rw_lut             
08714 2ff 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        'test for running from a request list   
08718 300 32 04 64 AD |             if_z            skipf   #%10                    'if a request list then skip notification
0871c 301 08 01 3C FC |                             wrlut   #0, ptra[8]             ' a   default is not to resume
08720 302 2A 14 66 0D |             _ret_           push    #notify                 ' |   if not a request list then we are done
08724 303 0D B6 B7 FB |                             tjs     addr2, #extendedreq     '     test for special extended request  
08728 304 07 B6 97 FB | checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
0872c 305 BF ED 07 FB |                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
08730 306 05 EC BF FB |                             tjns    pa, #listcomplete       'exit if it has
08734 307 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz
08738 308 DB B3 03 A6 |             if_z            mov     hubdata, addr2
0873c 309 32 62 64 AD |             if_z            skipf   #%110001
08740 30a 32 10 64 5D |             if_nz           skipf   #%1000                  'do not notify if list is continuing
08744 30b 80 B7 67 FC |                             wrlong  addr2, ptrb             ' a  write back next list address
08748 30c D0 C3 8F F9 | listcomplete                altd    id, #id0                ' a  compute COG's state address
0874c 30d 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
08750 30e 2A 14 66 0D |             _ret_           push    #notify                 ' |  we are done with the list
08754 30f 2A 1C 66 0D |             _ret_           push    #poller                 ' a  we are still continuing the list
08758 310 2A 50 66 0D |             _ret_           push    #real_list              ' a  we are still continuing the list
0875c 311 E3 B5 97 FB | extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
08760 312 DB DF 7B F8 |                             getnib  a, addr2, #7            'check the request type
08764 313 0F DE 0F F2 |                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
08768 314 D8 DF 73 F8 |                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
0876c 315 32 90 63 5D |             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
08770 316             |                                                             ' skipcase (a) gfx copy to/from hub
08770 316             |                                                             ' skipcase (b) gfx copy extmem bank to bank
08770 316             |                                                             ' skipcase (c) linear copy extmem bank to bank
08770 316 DB DF 73 F8 |                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
08774 317 EF E5 AB FA |                             rdlut   d, a wz                 ' a      load bank information and check if valid
08778 318 31 02 64 5D |             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
0877c 319 2A 02 66 0D |             _ret_           push    #invalidbank            ' |      otherwise bail out after this
08780 31a DD BB CB F7 |                             test    offset1 wz              ' |      check for first offset being zero
08784 31b DE BD CB A7 |             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
08788 31c 32 94 63 AD |             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
0878c 31d 32 92 63 FD |                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
08790 31e F1 B3 03 F1 |                             add     hubdata, c              ' a b c  add bytes just sent to hub address
08794 31f EA B3 83 F1 |                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
08798 320 D8 E3 03 F1 |                             add     c, addr1                ' a b c  compute next address to use
0879c 321 DC B9 CB F7 |                             test    total wz                ' a b |  check for zero tranfers
087a0 322 DC D5 2B F3 |                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
087a4 323 44 FF 9F AD |             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
087a8 324 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a b c  check if reading/writing
087ac 325 EA B5 03 F6 |                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
087b0 326 EA E3 83 F1 |                             sub     c, orighubsize          ' a b |  rewind to original position
087b4 327 DD E3 03 A1 |             if_z            add     c, offset1              ' a b |  add any dst scanline offset
087b8 328 DE E3 03 51 |             if_nz           add     c, offset2              ' a b |  add any src scanline offset
087bc 329 DE B3 03 A1 |             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
087c0 32a DD B3 03 51 |             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
087c4 32b 28 44 63 FD |                             setq    mask                    ' a b c  configure mask for bit muxing
087c8 32c F1 B1 F3 F9 |                             muxq    addr1, c                ' a b c  perform address bit muxing
087cc 32d D8 DF 03 F6 |                             mov     a, addr1                ' | b c  ]
087d0 32e DB B1 03 F6 |                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
087d4 32f EF B7 03 F6 |                             mov     addr2, a                ' | b c  ]
087d8 330 1E B0 A7 F4 |                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
087dc 331 0F B6 3F F8 |                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
087e0 332 01 B8 8F F1 |                             sub     total, #1 wz            ' a | |  decrement scanline count
087e4 333 01 B8 8F A1 |             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
087e8 334 EA B9 8B A1 |             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
087ec 335 DF B7 03 A6 |             if_z            mov     addr2, link
087f0 336 34 FF 9F AD |             if_z            jmp     #checknext
087f4 337 D8 CB FB F8 | moretransfers               getbyte request, addr1, #3      'prepare next request
087f8 338 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
087fc 339 32 1C 64 AD |             if_z            skipf   #%1110                  '     skip some code if we are locked
08800 33a 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a   test if will be reading or writing
08804 33b BE D3 03 A6 |             if_z            mov     resume, resumewrites    ' |   resume burst writing
08808 33c B9 D3 03 56 |             if_nz           mov     resume, newburstr       ' |   resume burst reading
0880c 33d B0 FE 9F FD |                             jmp     #yield                  ' |   yield to poller
08810 33e 31 02 64 AD |             if_z            skip    #%1                     '     skip next instruction for writing case
08814 33f 2A 26 67 0D |             _ret_           push    #start_read_exec        '(|)  do new read burst next 
08818 340 2A 28 67 0D |             _ret_           push    #start_write_exec       'do new write burst next
0881c 341             | 
0881c 341             | '..................................................................................................
0881c 341             | ' PSRAM WRITES
0881c 341             |                                                             '  a b c d e f g h
0881c 341             | 
0881c 341             |                                                             '  B W L F B R L L (a) byte write(s)
0881c 341             |                                                             '  Y O O I U E O O (b) word write(s)
0881c 341             |                                                             '  T R N L R S C C (c) long write(s)
0881c 341             |                                                             '  E D G L S U K K (d) resumed fill
0881c 341             |                                                             '          T M E E (e) new burst write
0881c 341             |                                                             '            E D D (f) resumed burst
0881c 341             |                                                             '              F B (g) locked fill
0881c 341             |                                                             '              I U (h) locked burst write
0881c 341             |                                                             '              L R 
0881c 341             |                                                             '              L S 
0881c 341             |                                                             '                T 
0881c 341             | 
0881c 341             | w_single                   
0881c 341             | w_fill_cont           
0881c 341 D8 DF 7B F8 |                             getnib  a, addr1, #7            '  a b c d          obtain request
08820 342 03 DE 07 F5 |                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
08824 343 00 B2 FF F9 |                             movbyts hubdata, #0             '  a | | |          replicate byte across long
08828 344 44 B2 FF F9 |                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
0882c 345 01 B0 27 F5 |                             andn    addr1, #1               '  | b | |          align word addresses
08830 346 03 B0 27 F5 |                             andn    addr1, #3               '  | | c |          align long addresses
08834 347 DA D5 03 F6 | w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
08838 348 01 B4 0F F2 | w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
0883c 349 EF B5 63 F0 |                             shl     count, a                '  a b c | |   |    scale into bytes
08840 34a AB B5 97 FB |                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
08844 34b DA E3 03 F6 | w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
08848 34c 76 02 A0 FD |                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
0884c 34d             |                ' disable call to r_resume_burst for single longs when z=0
0884c 34d E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
08850 34e AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
08854 34f E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
08858 350 E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
0885c 351 3F 8A 0F F6 |                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
08860 352 A3 E3 33 F3 |                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
08864 353 CE D3 03 C6 |             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
08868 354 CC D3 03 36 |             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
0886c 355 D9 DF 03 F6 |                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
08870 356 14 D6 07 F6 |                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
08874 357 01 DE 17 F4 |                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
08878 358 C7 8B 03 F6 |                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
0887c 359 14 01 90 8D |             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
08880 35a 09 8A 67 25 |             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
08884 35b 5C 00 90 2D |             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
08888 35c 0F 8A 07 F6 |                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
0888c 35d             |         
0888c 35d             |             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
0888c 35d             |             '
0888c 35d             |             '  At least one of these 3 optional components will be sent
0888c 35d             |             '     header - first partial long of data, gets aligned to PSRAM long boundary
0888c 35d             |             '     body - N x full longs of data
0888c 35d             |             '     trailer - last partial long of data
0888c 35d             |             '
0888c 35d             |             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
0888c 35d             |             '
0888c 35d             |             'Case    Type                           Sends
0888c 35d             |             ' 1)     Single byte/word write         header only (takes its own optimized path)
0888c 35d             |             ' 2)     Single long write              body only (takes its own optimized path)
0888c 35d             |             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
0888c 35d             |             ' 4)     Multiple long fill             body only
0888c 35d             |             ' 5)     Burst write                    optional header, optional body, optional trailer
0888c 35d             | 
0888c 35d             |                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
0888c 35d D8 E5 03 F6 |                             mov     d, addr1                'get start address
08890 35e 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
08894 35f EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
08898 360 F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
0889c 361 CE D3 03 C6 |             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
088a0 362 13 8C 07 F6 |                             mov     pattern3, #%10011
088a4 363 D8 E5 03 F6 |                             mov     d, addr1                'get start address position 
088a8 364 03 E4 0F F5 |                             and     d, #3 wz                'get alignment
088ac 365 04 E2 17 F2 |                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
088b0 366 10 D6 07 F6 |                             mov     wrclks, #16             'clocks needed for address phase
088b4 367 F1 EF 03 F6 |                             mov     pb, c                   'get number of bytes to send
088b8 368 F2 EF 03 F1 |                             add     pb, d                   'and increase total to send, including initial re-alignment
088bc 369 40 00 90 2D |             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
088c0 36a             |                             
088c0 36a F0 CA 17 F2 |                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
088c4 36b 32 3C 64 CD |             if_c            skipf   #%11110                 'if fill skip burst write stuff
088c8 36c 04 D6 07 F1 |                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
088cc 36d F2 DF 83 F1 |                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
088d0 36e EF E5 03 FB |                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
088d4 36f 04 DE 07 F1 |                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
088d8 370 32 08 64 FD |                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
088dc 371 04 EE 9F F1 |                             sub     pb, #4 wcz              ' subtract a long from the total
088e0 372 00 8A 07 F4 |                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
088e4 373 D9 E5 03 F6 | single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
088e8 374 88 01 B0 FD |                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
088ec 375 5A B0 47 FB |                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
088f0 376 ED C5 03 FB |                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
088f4 377 28 EC 63 FD |                             setq    pa                      ' setup byte mux mask
088f8 378 F2 C5 F3 F9 |                             muxq    header, d               ' copy bytes into long
088fc 379 94 00 90 ED |             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
08900 37a             | 
08900 37a F0 CA 17 F2 | header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
08904 37b F7 E5 03 F6 |                             mov     d, pb                   'preserve the count
08908 37c 03 EE 2F F5 |                             andn    pb, #3 wz               'determine the number of full long bytes left to send
0890c 37d 07 EE 97 FB |                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
08910 37e             |                  
08910 37e F7 D7 03 F1 |                             add     wrclks, pb              'include this number of bytes as more clock transitions
08914 37f 32 14 64 CD |             if_c            skipf   #%1010                 'for fills we can skip burst stuff
08918 380 0C 8A 27 C5 |             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
0891c 381 01 8A 07 F4 |                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
08920 382 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute word count for bursts
08924 383 F7 37 23 F9 |                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
08928 384 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
0892c 385             | 
0892c 385 03 E4 07 F5 | body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
08930 386 17 E4 97 FB |                             tjz     d, #trailer_done        'no trailer to send, we exit now
08934 387 DA E3 0B C2 |             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
08938 388 CC D3 0B 32 |             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
0893c 389 F2 E3 83 51 |             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
08940 38a 4C 00 90 5D |             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
08944 38b             | 
08944 38b             |                             'we have 1-3 more aligned residual bytes left to send as the trailer
08944 38b F0 E5 47 F5 |                             or      d, #$1f0                'setup mux mask address
08948 38c F2 ED A3 FA |                             rdlut   pa, d                   'read mux mask for this length at offset 0
0894c 38d 2A B0 63 FD |                             push    addr1                   'save address
08950 38e             | 
08950 38e             | ' use this code (note: foldover can occur here in PSRAM bank)
08950 38e F1 B1 03 F1 |                             add     addr1, c                'find last long address in PSRAM
08954 38f 01 B0 87 F1 |                             sub     addr1, #1               '..to be rewritten
08958 390 18 01 B0 FD |                             call    #readlong               'read data from this external address
0895c 391             |             
0895c 391 D9 E5 03 C6 |             if_c            mov     d, hubdata              'get data to be sent for fills
08960 392 32 3C 64 CD |             if_c            skipf   #%11110                 'skip burst code for fills
08964 393 2B B0 63 FD |                             pop     addr1                   'restore address
08968 394 F7 E5 03 F6 |                             mov     d, pb                   ' | get number of full longs that were sent
0896c 395 02 E4 67 F0 |                             shl     d, #2                   ' | convert to bytes
08970 396 EF E5 03 F1 |                             add     d, a                    ' | add to start adress of longs to stream
08974 397 F2 E5 03 FB |                             rdlong  d, d                    ' | read this last long from HUB RAM
08978 398             | 
08978 398 ED C7 03 FB |                             rdlong  trailer, hubscratch     'read external RAM data value
0897c 399 28 EC 63 FD |                             setq    pa                      'setup byte mask
08980 39a F2 C7 F3 F9 |                             muxq    trailer, d              'apply byte mask to data via muxq
08984 39b 04 D6 07 F1 |                             add     wrclks, #4              'increase by 4 more clocks
08988 39c 05 8A 07 F4 |                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
0898c 39d 00 8C 07 F4 |                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
08990 39e             | 
08990 39e             |                             'trailer is done
08990 39e EF 3B 73 FC | trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
08994 39f             | 
08994 39f D8 C9 03 F6 | writecommon                 mov     cmdaddr, addr1          'get start address of transfer
08998 3a0 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
0899c 3a1 02 C8 DF F8 |                             setbyte cmdaddr, #$02, #3       'add quad write command
089a0 3a2             | 
089a0 3a2 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
089a4 3a3 69 C8 63 FD |                             rev     cmdaddr                 
089a8 3a4 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
089ac 3a5 61 C8 63 FD |                             mergeb  cmdaddr
089b0 3a6             |                             
089b0 3a6 58 52 63 FD |                             drvl    cspin                   'activate chip select
089b4 3a7 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
089b8 3a8 E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
089bc 3a9 A8 D7 23 FC |                             wypin   wrclks, clkpin          'start memory clock output 
089c0 3aa             |                                                          
089c0 3aa 32 8A 63 FD |                             skipf   pattern2                '   B W L Burst FB FW FL RMW
089c4 3ab E2 39 C3 FC |                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
089c8 3ac 00 36 C7 FC |                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
089cc 3ad F7 03 D8 FC |                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
089d0 3ae D9 39 C3 FC |                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
089d4 3af 32 8C 63 FD |                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
089d8 3b0 E3 39 C3 FC |                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
089dc 3b1 2D D2 63 FD |                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
089e0 3b2 24 36 60 FD |                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
089e4 3b3 50 48 63 FD |                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
089e8 3b4 59 52 63 0D |             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
089ec 3b5             |  
089ec 3b5 59 52 63 FD |                             drvh    cspin
089f0 3b6 09 C2 17 F4 | check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
089f4 3b7 F1 B5 8B F1 |                             sub     count, c wz             'account for bytes written
089f8 3b8 34 00 90 5D |             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
089fc 3b9 08 01 3C FC |                             wrlut   #0, ptra[8]             'default is not to resume
08a00 3ba 3C F5 9F 3D |             if_nc           jmp     #notify                 'if not a request list then we are done
08a04 3bb 40 B7 BF FB |                             tjns    addr2, #checklist       'if not extended, check next list entry
08a08 3bc 3E B9 67 FB |                             djz     total, #donerepeats     'check for repeats remaining
08a0c 3bd B8 B9 B3 FB |                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
08a10 3be EA E5 03 F6 |                             mov     d, orighubsize
08a14 3bf EF E5 63 F0 |                             shl     d, a
08a18 3c0 F2 E3 83 F1 |                             sub     c, d
08a1c 3c1 DD E3 03 F1 |                             add     c, offset1
08a20 3c2 F2 B5 03 F6 |                             mov     count, d                'restore original count
08a24 3c3 E5 E1 43 F8 | readmask                    getnib  b, request, #0          'get bank parameter LUT address
08a28 3c4 F0 E1 A3 FA |                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
08a2c 3c5 F0 45 CB F9 |                             bmask   mask, b                 'build mask for addr (in case count=1)
08a30 3c6 D8 E3 03 F1 | continue_fill               add     c, addr1                'add bytes to destination address
08a34 3c7 28 44 63 FD |                             setq    mask                    'setup bit mask
08a38 3c8 F1 B1 F3 F9 |                             muxq    addr1, c                'setup new external memory address
08a3c 3c9 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
08a40 3ca 33 74 63 AD |             if_z            execf   lockedfill              'continue next fill operation
08a44 3cb BB D3 03 F6 |                             mov     resume, restorefill
08a48 3cc 00 B6 07 36 |             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
08a4c 3cd 80 FC BF 3D |             if_nc           call    #yieldfill              'we have to yield now to other COGs
08a50 3ce 6C FC BF CD |             if_c            call    #yield
08a54 3cf 2D 00 64 FD |                             ret
08a58 3d0             |                            
08a58 3d0             | getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
08a58 3d0             |                       '     rczl    pa                      'rotate left into address offset
08a58 3d0             |                       '     rczl    c wcz                   'restore count and flags
08a58 3d0 03 E2 EF F7 |                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
08a5c 3d1 02 EC 67 F0 |                             shl     pa, #2
08a60 3d2 28 06 64 AD |             if_z            setq    #3
08a64 3d3 F1 ED F3 A9 |             if_z            muxq    pa, c
08a68 3d4 F0 ED 47 F5 |                             or      pa, #$1f0               'setup LUT address offset
08a6c 3d5 F6 ED A3 FA |            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
08a70 3d6 2D 00 7C FD |                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
08a74 3d7             | 
08a74 3d7 ED 3B 83 FC | readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
08a78 3d8 02 34 27 F9 |                             setword xrecvdata, #2, #0       'read 2x16 words
08a7c 3d9 20 D0 07 F6 |                             mov     clks, #32               '32 read clock transitions
08a80 3da 36 D8 07 F6 |                             mov     pattern, #%110110       'setup read skip pattern
08a84 3db 14 FB 9F FD |                             jmp     #readcommon             'read then return directly to caller
08a88 3dc             |         
08a88 3dc             | 
08a88 3dc             | '..................................................................................................
08a88 3dc             | 
08a88 3dc             |                 fit 1024-32
08a88 3dc             |                 fit 1024-32
08a88 3dc 00 00 00 00 
08a8c 3dd 00 00 00 00 
08a90 3de 00 00 00 00 
08a94 3df 00 00 00 00 |                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
08a98 3e0             |                 org 1024-32
08a98 000             | 
08a98 000             | ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
08a98 000 00 00 00 00 |                 long $0000
08a9c 001 11 11 00 00 |                 long $1111
08aa0 002 22 22 00 00 |                 long $2222
08aa4 003 33 33 00 00 |                 long $3333
08aa8 004 44 44 00 00 |                 long $4444
08aac 005 55 55 00 00 |                 long $5555
08ab0 006 66 66 00 00 |                 long $6666
08ab4 007 77 77 00 00 |                 long $7777
08ab8 008 88 88 00 00 |                 long $8888
08abc 009 99 99 00 00 |                 long $9999
08ac0 00a AA AA 00 00 |                 long $aaaa
08ac4 00b BB BB 00 00 |                 long $bbbb
08ac8 00c CC CC 00 00 |                 long $cccc
08acc 00d DD DD 00 00 |                 long $dddd
08ad0 00e EE EE 00 00 |                 long $eeee
08ad4 00f FF FF 00 00 |                 long $ffff
08ad8 010             | 
08ad8 010             | 'masks
08ad8 010 FF FF FF FF |                 long $ffffffff ' 00 aligned 0/4 length
08adc 011 FF 00 00 00 |                 long $000000ff ' 00 aligned 1 length
08ae0 012 FF FF 00 00 |                 long $0000ffff ' 00 aligned 2 length
08ae4 013 FF FF FF 00 |                 long $00ffffff ' 00 aligned 3 length
08ae8 014             | 
08ae8 014 00 FF FF FF |                 long $ffffff00 ' 01 aligned 0/4 length
08aec 015 00 FF 00 00 |                 long $0000ff00 ' 01 aligned 1 length
08af0 016 00 FF FF 00 |                 long $00ffff00 ' 01 aligned 2 length
08af4 017 00 FF FF FF |                 long $ffffff00 ' 01 aligned 3 length
08af8 018             | 
08af8 018 00 00 FF FF |                 long $ffff0000 ' 10 aligned 0/4 length
08afc 019 00 00 FF 00 |                 long $00ff0000 ' 10 aligned 1 length
08b00 01a 00 00 FF FF |                 long $ffff0000 ' 10 aligned 2 length
08b04 01b 00 00 FF FF |                 long $ffff0000 ' 10 aligned 3 length
08b08 01c             | 
08b08 01c 00 00 00 FF |                 long $ff000000 ' 11 aligned 0/4 length
08b0c 01d 00 00 00 FF |                 long $ff000000 ' 11 aligned 1 length
08b10 01e 00 00 00 FF |                 long $ff000000 ' 11 aligned 2 length
08b14 01f 00 00 00 FF |                 long $ff000000 ' 11 aligned 3 length
08b18 020             | 
08b18 020             |         fit 1024
08b18 020             |         fit 1024
08b18 020             | 
08b18 020             | '--------------------------------------------------------------------------------------------------
08b18 020             |         orgh
08b18                 | 
08b18                 | gfxexpansion
08b18                 |                             'simple line drawing graphics expansion of memory driver
08b18                 |                             'jmp     #donerepeats                'just return for now
08b18                 | 
08b18     DB B1 0B F2 |                             cmp     addr1, addr2 wz         'see if we've reached the end
08b1c     FB 02 80 AD |             if_z            jmp     #donerepeats            'nothing more to draw
08b20     01 B8 07 F1 |                             add     total, #1               'restore total after decrement
08b24     DD E1 03 F6 |                             mov     b, offset1              'get error term
08b28     01 E0 67 F0 |                             shl     b, #1                   'compute e2 = 2 x error
08b2c     DE E5 33 F9 |                             getword d, offset2, #0          'get dx = abs(x0-x1)
08b30     10 BC C7 F0 |                             sar     offset2, #16            'get dy = -abs(y0-y1)
08b34     DE E1 53 F2 |                             cmps    b, offset2 wc           'compare if e2 >= dy
08b38     00 E2 07 F6 |                             mov     c, #0                   'clear accumulator reg
08b3c     31 1C 64 CD |             if_c            skip    #%1110                  'if not, skip
08b40     EF DF C3 F9 |                             decod   a                       'decode as 1,2,or 4 byte size
08b44     DE BB 03 F1 |                             add     offset1, offset2        'err+=dy 
08b48     10 B8 0F F4 |                             testb   total, #16 wz           'check sign sx   
08b4c     EF E3 C3 F3 |                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
08b50     F0 E5 53 F2 |                             cmps    d, b wc                 'compare if e2 <= dx
08b54     31 3C 64 CD |             if_c            skip    #%11110                 'if not, skip
08b58     F2 BD 43 F9 |                             rolword offset2, d, #0          'restore offset
08b5c     F2 BB 03 F1 |                             add     offset1, d              'err+=dx
08b60     11 B8 0F F4 |                             testb   total, #17 wz           'check sign sy
08b64     DC E5 33 F9 |                             getword d, total, #0            'get line width
08b68     F2 E3 C3 F3 |                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
08b6c     EF DF 93 F7 |                             encod   a wc                    'restore size and set carry
08b70     EA B5 03 F6 |                             mov     count, orighubsize      'reset the fill width
08b74     EF B5 63 F0 |                             shl     count, a                '..for the type of transfer
08b78     C3 03 80 FD |                             jmp     #readmask               'continue filling
08b7c                 | 	alignl
08b7c                 | _usbnew_spin2_dat_
08b7c                 |                 org     $000
08b7c 000             | 
08b7c 000             | usb_host_start
08b7c 000 F9 8F 02 F6 |                 mov     hcog_base_addr, ptrb
08b80 001             | 
08b80 001 03 00 00 FF 
08b84 002 D0 72 07 F6 |                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
08b88 003 02 72 47 F0 |                 shr     htmp, #2                        ' so byte->long for the lut cell count
08b8c 004 B4 04 A0 FE |                 loc     pb, #@hlut_start - @usb_host_start
08b90 005 47 EF 03 F1 |                 add     pb, hcog_base_addr
08b94 006 29 72 63 FD |                 setq2   htmp
08b98 007 F7 01 00 FB |                 rdlong  0, pb                           ' Do the hub->lut copy
08b9c 008             | 
08b9c 008 88 0B A0 FE |                 loc     pb, #@usb_host_init - @usb_host_start
08ba0 009 47 EF 03 F1 |                 add     pb, hcog_base_addr
08ba4 00a 2C EE 63 FD |                 jmp     pb                              ' Initialize host and enter main processing loop
08ba8 00b             | 
08ba8 00b             | '------------------------------------------------------------------------------
08ba8 00b             | ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
08ba8 00b             | ' special because the receiving function must not respond with either STALL or
08ba8 00b             | ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
08ba8 00b             | ' non-control endpoint receives a SETUP token, or the function receives a
08ba8 00b             | ' corrupt packet, it must ignore the transaction
08ba8 00b             | '------------------------------------------------------------------------------
08ba8 00b             | ' On entry:
08ba8 00b             | '   PTRA - start address of the SETUP data struct.
08ba8 00b             | ' On exit:
08ba8 00b             | '   retval - PID_ACK on success, otherwise error code.
08ba8 00b             | '------------------------------------------------------------------------------
08ba8 00b             | txn_setup
08ba8 00b 2D BC C6 F8 |                 setbyte ep_addr_pid, #PID_SETUP, #0
08bac 00c 08 B0 06 F6 |                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
08bb0 00d 03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
08bb4 00e 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
08bb8 00f F8 ED 03 F6 |                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
08bbc 010             | .setup
08bbc 010 24 01 B0 FD |                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
08bc0 011 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
08bc4 012 2D 00 64 AD |         if_z    ret
08bc8 013 7C 0B B0 FD |                 call    #retry_wait
08bcc 014 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
08bd0 015 2D 00 64 AD |         if_z    ret
08bd4 016 F6 F1 03 F6 |                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
08bd8 017 E0 FF 9F FD |                 jmp     #.setup
08bdc 018             | 
08bdc 018             | '------------------------------------------------------------------------------
08bdc 018             | ' IN/INTERRUPT transaction.
08bdc 018             | ' Possible function response: STALL or NAK handshake, or DATAx packet.
08bdc 018             | '------------------------------------------------------------------------------
08bdc 018             | ' On entry:
08bdc 018             | '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
08bdc 018             | '     CRC(b19..23).
08bdc 018             | ' On exit:
08bdc 018             | '------------------------------------------------------------------------------
08bdc 018             | txn_in
08bdc 018 90 03 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
08be0 019 69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
08be4 01a BC 00 B0 FD |                 call    #utx_token                      ' Put IN request on the bus
08be8 01b             | 
08be8 01b             |                 ' Fall through to urx_packet
08be8 01b             | 
08be8 01b             | '------------------------------------------------------------------------------
08be8 01b             | ' Wait for a packet from a device/function. As host, the only two packet types
08be8 01b             | ' received are handshakes and IN DATAx.
08be8 01b             | '------------------------------------------------------------------------------
08be8 01b             | ' On entry:
08be8 01b             | ' On exit:
08be8 01b             | '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
08be8 01b             | '     returned.
08be8 01b             | '------------------------------------------------------------------------------
08be8 01b             | urx_packet
08be8 01b 22 A7 82 FA |                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
08bec 01c 04 A6 16 F4 |                 testb   urx, #SOPB              wc
08bf0 01d F4 FF 9F CD |         if_c    jmp     #urx_packet
08bf4 01e 1A 94 63 FD |                 getct   hct2
08bf8 01f 4E 95 6B FA |                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
08bfc 020 05 96 06 F4 |                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
08c00 021 00 A8 06 F6 |                 mov     newb_flg, #0                    ' Initialize for multi-byte read
08c04 022             | .wait_sop
08c04 022 22 A7 8A FA |                 rdpin   urx, dm
08c08 023 04 A6 16 F4 |                 testb   urx, #SOPB              wc
08c0c 024 08 00 90 CD |         if_c    jmp     #.get_pid
08c10 025 FC 25 CC FB |                 jnct2   #.wait_sop
08c14 026 05 BE 06 06 |         _ret_   mov     retval, #ERR_TAT
08c18 027             | .get_pid
08c18 027 28 02 B0 FD |                 call    #urx_next
08c1c 028 06 A6 16 F4 |                 testb   urx, #BUS_ERRB          wc
08c20 029 04 00 90 3D |         if_nc   jmp     #.chk_pid
08c24 02a 02 BE 06 06 |         _ret_   mov     retval, #ERR_URX
08c28 02b             | .chk_pid
08c28 02b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
08c2c 02c 5A BE 0E 52 |         if_nz   cmp     retval, #PID_NAK        wz
08c30 02d 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz
08c34 02e 38 00 90 AD |         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
08c38 02f 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
08c3c 030 C3 BE 0E F2 |                 cmp     retval, #PID_DATA0      wz
08c40 031 28 01 90 2D |    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
08c44 032 10 00 90 8D |    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
08c48 033 4B BE 0E F2 |                 cmp     retval, #PID_DATA1      wz
08c4c 034 1C 01 90 8D |    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
08c50 035 04 00 90 2D |    if_z_and_nc  jmp     #.ack_resend
08c54 036 04 BE 06 06 |         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
08c58 037             | .ack_resend
08c58 037 22 A7 82 FA |                 rqpin   urx, dm
08c5c 038 05 A6 16 F4 |                 testb   urx, #EOPB              wc
08c60 039 F4 FF 9F 3D |         if_nc   jmp     #.ack_resend
08c64 03a D2 BE 06 F6 |                 mov     retval, #PID_ACK
08c68 03b 98 01 B0 FD |                 call    #utx_handshake                  ' Send handshake PID and return to caller
08c6c 03c 09 BE 06 06 |         _ret_   mov     retval, #ERR_DATAX_SYNC
08c70 03d             | .chk_eop
08c70 03d 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
08c74 03e 1C 00 90 3D |         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
08c78 03f C8 01 B0 FD |                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
08c7c 040 05 96 16 F4 |                 testb   hstatus, #EOPB          wc
08c80 041 10 00 90 CD |         if_c    jmp     #.idle                          ' Low-speed EOP seen
08c84 042 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
08c88 043 04 BE 06 36 |         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
08c8c 044 02 BE 06 A6 |         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
08c90 045 2D 00 64 FD |                 ret
08c94 046             | .idle
08c94 046 22 A7 82 FA |                 rqpin   urx, dm
08c98 047 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
08c9c 048 F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
08ca0 049 2D 00 64 FD |                 ret
08ca4 04a             | 
08ca4 04a             | '------------------------------------------------------------------------------
08ca4 04a             | ' Send a token packet with CRC5 checksum of address and endpoint. It is the
08ca4 04a             | ' responsibility of the caller to append the appropriate inter-packet delay,
08ca4 04a             | ' if one is required.
08ca4 04a             | '------------------------------------------------------------------------------
08ca4 04a             | ' On entry:
08ca4 04a             | '   ep_addr_pid - packed with the PID, address and endpoint.
08ca4 04a             | ' On exit:
08ca4 04a             | '------------------------------------------------------------------------------
08ca4 04a             | utx_token
08ca4 04a 22 A7 82 FA |                 rqpin   urx, dm
08ca8 04b 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
08cac 04c F4 FF 9F 3D |         if_nc   jmp     #utx_token
08cb0 04d 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
08cb4 04e 34 0D B0 CD |         if_c    call    #utx_pre
08cb8 04f 80 A4 06 F6 |                 mov     utx, #OUT_SOP
08cbc 050 70 01 B0 FD |                 call    #utx_byte                       ' Send sync byte
08cc0 051 5E 73 03 F6 |                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
08cc4 052 03 B8 06 F6 |                 mov     pkt_cnt, #3
08cc8 053             | .next_byte
08cc8 053 B9 A5 E2 F8 |                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
08ccc 054 08 72 47 F0 |                 shr     htmp, #8                        ' Shift to next byte to send
08cd0 055             | .wait
08cd0 055 40 46 72 FD |                 testp   dp                      wc
08cd4 056 F8 FF 9F 3D |         if_nc   jmp     #.wait
08cd8 057 23 03 08 FC |                 akpin   dp
08cdc 058 22 A5 22 FC |                 wypin   utx, dm
08ce0 059 F9 B9 6E 0B |         _ret_   djnz    pkt_cnt, #.next_byte
08ce4 05a             | 
08ce4 05a             | '------------------------------------------------------------------------------
08ce4 05a             | ' SETUP/OUT/INTERRUPT transaction.
08ce4 05a             | ' Possible function response in order of precedence: STALL, ACK, NAK.
08ce4 05a             | '------------------------------------------------------------------------------
08ce4 05a             | ' On entry:
08ce4 05a             | '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
08ce4 05a             | '     CRC(b19..23).
08ce4 05a             | '   PTRA - start address of the data buff/struct that has the bytes to send.
08ce4 05a             | '   pkt_data - count of DATAx payload bytes to send.
08ce4 05a             | ' On exit:
08ce4 05a             | '------------------------------------------------------------------------------
08ce4 05a             | txn_out
08ce4 05a 88 02 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
08ce8 05b B8 FF BF FD |                 call    #utx_token                      ' Put SETUP/OUT token on the bus
08cec 05c 00 00 C0 FF 
08cf0 05d F8 01 78 FC |                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
08cf4 05e 58 B9 02 F6 |                 mov     pkt_cnt, pkt_data
08cf8 05f             | 
08cf8 05f             |                 ' Fall through to utx_data
08cf8 05f             | 
08cf8 05f             | '------------------------------------------------------------------------------
08cf8 05f             | ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
08cf8 05f             | ' calculated while the data byte is being shifted out. Since data stage
08cf8 05f             | ' success/fail is not determined until the status stage of the transaction,
08cf8 05f             | ' this routine is only concerned about the current DATAx packet.
08cf8 05f             | '------------------------------------------------------------------------------
08cf8 05f             | ' On entry:
08cf8 05f             | '   PTRA - hub start address of the data to read.
08cf8 05f             | '   pkt_cnt - data payload size.
08cf8 05f             | ' On exit:
08cf8 05f             | '------------------------------------------------------------------------------
08cf8 05f             | utx_data
08cf8 05f 22 A7 82 FA |                 rqpin   urx, dm
08cfc 060 04 A6 16 F4 |                 testb   urx, #SOPB              wc
08d00 061 F4 FF 9F CD |         if_c    jmp     #utx_data
08d04 062 4D 99 02 F6 |                 mov     hctwait, ip_delay
08d08 063 2C 0A B0 FD |                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
08d0c 064 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
08d10 065 D8 0C B0 CD |         if_c    call    #utx_pre
08d14 066 80 A4 06 F6 |                 mov     utx, #OUT_SOP
08d18 067 14 01 B0 FD |                 call    #utx_byte                       ' Send sync
08d1c 068 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
08d20 069 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
08d24 06a C3 A4 06 36 |         if_nc   mov     utx, #PID_DATA0
08d28 06b 4B A4 06 C6 |         if_c    mov     utx, #PID_DATA1
08d2c 06c 00 01 B0 FD |                 call    #utx_byte                       ' No CRC calc done on PID
08d30 06d 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
08d34 06e 1C 00 90 AD |         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
08d38 06f             | .read_byte
08d38 06f 10 A4 62 FD |                 rfbyte  utx                             ' Fetch data byte
08d3c 070 F0 00 B0 FD |                 call    #utx_byte
08d40 071 69 A4 62 FD |                 rev     utx                             ' Calculate CRC while the data is shifting out
08d44 072 28 A4 62 FD |                 setq    utx                             ' SETQ left-justifies the reflected data byte
08d48 073 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
08d4c 074 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
08d50 075 F9 B9 6E FB |                 djnz    pkt_cnt, #.read_byte
08d54 076             | .send_crc
08d54 076 E0 BB E6 F4 |                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
08d58 077 5D A5 E2 F8 |                 getbyte utx, crc, #0
08d5c 078 D0 00 B0 FD |                 call    #utx_byte
08d60 079 5D A5 EA F8 |                 getbyte utx, crc, #1
08d64 07a C8 00 B0 FD |                 call    #utx_byte                       ' Last CRC byte out
08d68 07b 7C FE 9F FD |                 jmp     #urx_packet                     ' Handle function response/error and back to caller
08d6c 07c             | 
08d6c 07c             | '------------------------------------------------------------------------------
08d6c 07c             | ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
08d6c 07c             | ' payload bytes are received. The routine reads bytes until EOP is detected and
08d6c 07c             | ' expects that the packet includes at least the CRC word.
08d6c 07c             | '
08d6c 07c             | ' In control transfers, it's possible to recieve fewer data bytes than what
08d6c 07c             | ' was requested, which makes it difficult to determine where the data stops
08d6c 07c             | ' and the CRC word begins. So the CRC calculation is done on every byte of the
08d6c 07c             | ' packet, including the CRC word. The CRC value should then be equal to the
08d6c 07c             | ' USB-16 expected residual value of 0xB001.
08d6c 07c             | '
08d6c 07c             | ' The routine writes the IN packet data to a static max_packet_size buffer
08d6c 07c             | ' so the caller can verify IN success before writing the data to its final
08d6c 07c             | ' destination.
08d6c 07c             | '------------------------------------------------------------------------------
08d6c 07c             | ' On entry:
08d6c 07c             | '   pkt_data - max byte count expected to be in the packet.
08d6c 07c             | '   newb_flg - signals new byte ready when toggled.
08d6c 07c             | ' On exit:
08d6c 07c             | '   pkt_cnt - actual number of bytes read.
08d6c 07c             | '------------------------------------------------------------------------------
08d6c 07c             | urx_data
08d6c 07c F7 77 03 F6 |                 mov     htmp2, pb
08d70 07d 27 EF 03 F6 |                 mov     pb, urx_buff_p
08d74 07e 00 00 C0 FF 
08d78 07f F7 01 88 FC |                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
08d7c 080 BB EF 03 F6 |                 mov     pb, htmp2
08d80 081 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
08d84 082 00 B8 06 F6 |                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
08d88 083 58 85 03 F6 |                 mov     pkt_tmp, pkt_data
08d8c 084 02 84 07 F1 |                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
08d90 085             | .wait_byte
08d90 085             | ' In-line rx for max speed
08d90 085 22 A7 82 FA |                 rqpin   urx, dm
08d94 086 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
08d98 087 53 A5 02 F5 |                 and     utx, urx
08d9c 088 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
08da0 089 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
08da4 08a 0C 00 90 5D |         if_nz   jmp     #.get_byte                      ' New byte!
08da8 08b 05 A6 16 F4 |                 testb   urx, #EOPB              wc
08dac 08c 38 00 90 CD |         if_c    jmp     #.chk_crc                       ' At end-of-packet
08db0 08d DC FF 9F FD |                 jmp     #.wait_byte
08db4 08e             | .get_byte
08db4 08e 53 BF EA F8 |                 getbyte retval, urx, #1                 ' New byte from smart pins
08db8 08f 15 BE 62 FD |                 wfbyte  retval                          ' Add it to the data buffer
08dbc 090 69 BE 62 FD |                 rev     retval                          ' Calculate CRC while next byte is shifting in
08dc0 091 28 BE 62 FD |                 setq    retval                          ' SETQ left-justifies the reflected data byte
08dc4 092 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
08dc8 093 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
08dcc 094             | .end_crc
08dcc 094 01 B8 06 F1 |                 add     pkt_cnt, #1
08dd0 095 C2 B9 1A F2 |                 cmp     pkt_cnt, pkt_tmp        wcz
08dd4 096 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
08dd8 097 2D 00 64 1D |         if_a    ret
08ddc 098             | ' For full-speed at 80MHz, the time it takes to do the final byte write and
08ddc 098             | ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
08ddc 098             | ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
08ddc 098             | ' to miss it, so cheat a bit and look for SOP clear here.
08ddc 098 22 A7 82 FA |                 rqpin   urx, dm
08de0 099 05 A6 16 F4 |                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
08de4 09a A8 FF 9F 3D |         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
08de8 09b             | ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
08de8 09b             | .chk_crc
08de8 09b 02 B8 86 F1 |                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
08dec 09c 58 00 00 FF 
08df0 09d 01 BA 6E F5 |                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
08df4 09e F0 FD 9F 5D |         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
08df8 09f D2 BE 06 F6 |                 mov     retval, #PID_ACK
08dfc 0a0 4D 99 02 F6 |                 mov     hctwait, ip_delay
08e00 0a1 34 09 B0 FD |                 call    #poll_waitx
08e04 0a2             | 
08e04 0a2             |                 ' Fall through to utx_handshake
08e04 0a2             | 
08e04 0a2             | '------------------------------------------------------------------------------
08e04 0a2             | ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
08e04 0a2             | ' the appropriate IP delay has been inserted.
08e04 0a2             | '------------------------------------------------------------------------------
08e04 0a2             | ' On entry:
08e04 0a2             | '   retval - handshake PID to send.
08e04 0a2             | ' On exit:
08e04 0a2             | '   retval unchanged.
08e04 0a2             | '------------------------------------------------------------------------------
08e04 0a2             | utx_handshake
08e04 0a2 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
08e08 0a3 E0 0B B0 CD |         if_c    call    #utx_pre
08e0c 0a4 80 A4 06 F6 |                 mov     utx, #OUT_SOP
08e10 0a5 1C 00 B0 FD |                 call    #utx_byte                       ' Send sync
08e14 0a6 5F A5 02 F6 |                 mov     utx, retval
08e18 0a7 14 00 B0 FD |                 call    #utx_byte                       ' Send handshake PID
08e1c 0a8             | .idle
08e1c 0a8 22 A7 82 FA |                 rqpin   urx, dm
08e20 0a9 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
08e24 0aa F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
08e28 0ab 4E 99 02 F6 |                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
08e2c 0ac 08 09 90 FD |                 jmp     #poll_waitx
08e30 0ad             | 
08e30 0ad             | '------------------------------------------------------------------------------
08e30 0ad             | ' Wait for the USB tx buffer to empty and feed it a new byte.
08e30 0ad             | '------------------------------------------------------------------------------
08e30 0ad             | ' On entry:
08e30 0ad             | '   utx - byte to transmit.
08e30 0ad             | ' On exit:
08e30 0ad             | '------------------------------------------------------------------------------
08e30 0ad             | utx_byte
08e30 0ad 40 46 72 FD |                 testp   dp                      wc
08e34 0ae F8 FF 9F 3D |         if_nc   jmp     #utx_byte
08e38 0af 23 03 08 FC |                 akpin   dp
08e3c 0b0 1F 94 62 FD |                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
08e40 0b1 22 A5 22 0C |         _ret_   wypin   utx, dm
08e44 0b2             | 
08e44 0b2             | '------------------------------------------------------------------------------
08e44 0b2             | ' Fetch the next data byte of a packet. Always check receiver status for EOP.
08e44 0b2             | '------------------------------------------------------------------------------
08e44 0b2             | ' On entry:
08e44 0b2             | ' On exit:
08e44 0b2             | '   retval - the byte read.
08e44 0b2             | '   urx - the receiver status. The caller must check the hstatus reg EOP flag
08e44 0b2             | '     on return. If EOP is set, the byte in reg retval remains as the last byte
08e44 0b2             | '     received.
08e44 0b2             | '------------------------------------------------------------------------------
08e44 0b2             | urx_next
08e44 0b2 22 A7 8A FA |                 rdpin   urx, dm
08e48 0b3 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
08e4c 0b4 53 A5 02 F5 |                 and     utx, urx
08e50 0b5 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
08e54 0b6 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
08e58 0b7 53 BF EA 58 |         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
08e5c 0b8 2D 00 64 5D |         if_nz   ret                                     ' New byte is priority, so return now
08e60 0b9 04 A6 16 F4 |                 testb   urx, #SOPB              wc
08e64 0ba 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
08e68 0bb D8 FF 9F 4D |    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
08e6c 0bc 05 96 26 34 |         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
08e70 0bd 2D 00 64 FD |                 ret
08e74 0be             | 
08e74 0be             | '------------------------------------------------------------------------------
08e74 0be             | ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
08e74 0be             | ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
08e74 0be             | ' length, and the PID is not included in the CRC calculation:
08e74 0be             | '  CRC5  FRAME_NUMBER SOF (full-speed)
08e74 0be             | '  CRC5  ENDP ADDRESS PID
08e74 0be             | ' %00000_1111_1111111_xxxxxxxx
08e74 0be             | '------------------------------------------------------------------------------
08e74 0be             | ' On entry:
08e74 0be             | '   ep_addr_pid - stuffed with the function endpoint, address and
08e74 0be             | '     SETUP/IN/OUT/SOF PID according to the USB standard.
08e74 0be             | ' On exit:
08e74 0be             | '   ep_addr_pid - CRC value appended to the packet.
08e74 0be             | '------------------------------------------------------------------------------
08e74 0be             | calc_crc5
08e74 0be FF 03 00 FF 
08e78 0bf FF BD 06 F5 |                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
08e7c 0c0 5E 73 03 F6 |                 mov     htmp, ep_addr_pid
08e80 0c1 08 72 47 F0 |                 shr     htmp, #8                        ' PID not included in CRC calc
08e84 0c2 1F BA 06 F6 |                 mov     crc, #$1f                       ' Initial CRC5 value
08e88 0c3 69 72 63 FD |                 rev     htmp                            ' Input data reflected
08e8c 0c4 28 72 63 FD |                 setq    htmp                            ' CRCNIB setup for data bits 0..7
08e90 0c5 14 BA DE F9 |                 crcnib  crc, #USB5_POLY
08e94 0c6 14 BA DE F9 |                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
08e98 0c7 09 72 77 F0 |                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
08e9c 0c8 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
08ea0 0c9 01 72 77 F0 |                 shl     htmp, #1                wc
08ea4 0ca 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
08ea8 0cb 01 72 77 F0 |                 shl     htmp, #1                wc
08eac 0cc 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
08eb0 0cd 1F BA 66 F5 |                 xor     crc, #$1f                       ' Final XOR value
08eb4 0ce 13 BA 66 F0 |                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
08eb8 0cf 5D BD 42 05 |         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
08ebc 0d0             | 
08ebc 0d0             | '------------------------------------------------------------------------------
08ebc 0d0             | ' Full-speed/low-speed frame timing interrupt service routine.
08ebc 0d0             | '------------------------------------------------------------------------------
08ebc 0d0             | isr1_fsframe
08ebc 0d0 1A 92 62 FD |                 getct   iframe_ct_base
08ec0 0d1 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
08ec4 0d2 B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
08ec8 0d3 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
08ecc 0d4             | .wait
08ecc 0d4 40 46 72 FD |                 testp   dp                      wc
08ed0 0d5 F8 FF 9F 3D |         if_nc   jmp     #.wait
08ed4 0d6 23 03 08 FC |                 akpin   dp
08ed8 0d7 A5 A4 06 F6 |                 mov     utx, #PID_SOF
08edc 0d8 22 01 29 FC |                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
08ee0 0d9 4C FF BF FD |                 call    #utx_byte                       ' Send token PID byte
08ee4 0da 1F B6 06 F6 |                 mov     icrc, #$1f                      ' Prime the CRC5 pump
08ee8 0db 59 B5 02 F6 |                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
08eec 0dc 69 B4 62 FD |                 rev     sof_pkt                         ' Input data reflected
08ef0 0dd 28 B4 62 FD |                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
08ef4 0de 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY
08ef8 0df 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
08efc 0e0 59 A5 E2 F8 |                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
08f00 0e1 2C FF BF FD |                 call    #utx_byte
08f04 0e2 08 B4 66 F0 |                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
08f08 0e3 03 04 DC FC |                 rep     #2, #3                          ' Three data bits left to process
08f0c 0e4 01 B4 76 F0 |                 shl     sof_pkt, #1             wc
08f10 0e5 14 B6 D6 F9 |                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
08f14 0e6 1F B6 66 F5 |                 xor     icrc, #$1f                      ' Final XOR value
08f18 0e7 59 A5 EA F8 |                 getbyte utx, frame, #1                  ' Send remaining frame number bits
08f1c 0e8 03 B6 66 F0 |                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
08f20 0e9 5B A5 42 F5 |                 or      utx, icrc
08f24 0ea 08 FF BF FD |                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
08f28 0eb A4 83 03 F6 |                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
08f2c 0ec 20 00 90 FD |                 jmp     #isr1_wait
08f30 0ed             | isr1_lsframe
08f30 0ed 1A 92 62 FD |                 getct   iframe_ct_base
08f34 0ee 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
08f38 0ef B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
08f3c 0f0             | .wait
08f3c 0f0 40 46 72 FD |                 testp   dp                      wc
08f40 0f1 F8 FF 9F 3D |         if_nc   jmp     #.wait
08f44 0f2 23 03 08 FC |                 akpin   dp
08f48 0f3 22 09 28 FC |                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
08f4c 0f4 A3 83 03 F6 |                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
08f50 0f5             | isr1_wait
08f50 0f5 22 A5 82 FA |                 rqpin   utx, dm
08f54 0f6 04 A4 16 F4 |                 testb   utx, #SOPB                 wc
08f58 0f7 F4 FF 9F CD |         if_c    jmp     #isr1_wait
08f5c 0f8 01 B2 06 F1 |                 add     frame, #1                       ' Next frame# and check for wrap around
08f60 0f9 03 00 00 FF 
08f64 0fa FF B3 06 F5 |                 and     frame, ##$7ff
08f68 0fb 1F 82 63 FD |                 waitx   isrtmp1                         ' Make sure bus is idle
08f6c 0fc F5 FF 3B FB |                 reti1
08f70 0fd             | 
08f70 0fd             | '------------------------------------------------------------------------------
08f70 0fd             | ' Wait for a window within the 1ms frame boundary that will ensure that a
08f70 0fd             | ' transaction will complete before the next frame is triggered.
08f70 0fd             | '------------------------------------------------------------------------------
08f70 0fd             | ' On entry:
08f70 0fd             | ' On exit:
08f70 0fd             | '------------------------------------------------------------------------------
08f70 0fd             | wait_txn_ok
08f70 0fd 1A 76 63 FD |                 getct   htmp2
08f74 0fe 49 77 83 F1 |                 sub     htmp2, iframe_ct_base
08f78 0ff 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
08f7c 100 A1 77 1B C2 |         if_c    cmp     htmp2, _txn_ok_ls_      wcz
08f80 101 A2 77 1B 32 |         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
08f84 102 E8 FF 9F 1D |         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
08f88 103 2D 00 64 FD |                 ret
08f8c 104             | 
08f8c 104             | '------------------------------------------------------------------------------
08f8c 104             | ' A device connection was detected, or a bus reset was requested by the USB
08f8c 104             | ' client. Set the appropriate smart pin FS/LS speed mode to match the device
08f8c 104             | ' and perform a reset sequence prior to device enumeration.
08f8c 104             | '------------------------------------------------------------------------------
08f8c 104             | dev_reset
08f8c 104 22 A7 82 FA |                 rqpin   urx, dm
08f90 105 01 A6 16 F4 |                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
08f94 106 F4 03 B0 CD |         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
08f98 107 E0 03 B0 3D |         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
08f9c 108             | reset
08f9c 108 25 00 64 FD |                 setint1 #0                              ' Don't want frame interrupt while in reset
08fa0 109 22 03 28 FC |                 wypin   #OUT_SE0, dm                    ' Assert bus reset
08fa4 10a 1F 5C 63 FD |                 waitx   _reset_hold_                    ' Spec is >= 10ms
08fa8 10b 22 01 28 FC |                 wypin   #OUT_IDLE, dm
08fac 10c 00 B2 06 F6 |                 mov     frame, #0                       ' Reset the frame timespan count
08fb0 10d 1A 92 62 FD |                 getct   iframe_ct_base
08fb4 10e 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
08fb8 10f B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
08fbc 110 59 73 03 F6 |                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
08fc0 111 24 72 07 F1 |                 add     htmp, #36
08fc4 112 25 02 64 FD |                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
08fc8 113             | .framewait
08fc8 113 B9 B3 1A F2 |                 cmp     frame, htmp             wcz
08fcc 114 F8 FF 9F CD |         if_b    jmp     #.framewait
08fd0 115 2D 00 64 FD |                 ret
08fd4 116             | 
08fd4 116             | '------------------------------------------------------------------------------
08fd4 116             | ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
08fd4 116             | '------------------------------------------------------------------------------
08fd4 116             | ' On entry:
08fd4 116             | '   PTRA - source address.
08fd4 116             | '   PB - destination address.
08fd4 116             | '   hr0 - length of copy, in bytes.
08fd4 116             | ' On exit:
08fd4 116             | '------------------------------------------------------------------------------
08fd4 116             | hmemcpy
08fd4 116 61 73 C7 FA |                 rdbyte  htmp, ptra++
08fd8 117 F7 73 43 FC |                 wrbyte  htmp, pb
08fdc 118 01 EE 07 F1 |                 add     pb, #1
08fe0 119 FC 87 6F 0B |         _ret_   djnz    hr0, #hmemcpy
08fe4 11a             | 
08fe4 11a             | '------------------------------------------------------------------------------
08fe4 11a             | ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
08fe4 11a             | ' loop until the errant device is disconnected.
08fe4 11a             | '------------------------------------------------------------------------------
08fe4 11a             | ' On entry:
08fe4 11a             | ' On exit:
08fe4 11a             | '------------------------------------------------------------------------------
08fe4 11a             | host_error
08fe4 11a             |           if ERROR_LED >= 0
08fe4 11a             |           end
08fe4 11a A0 07 90 FD |                 jmp     #host_reset                     ' See if it works...
08fe8 11b             | 
08fe8 11b             | '------------------------------------------------------------------------------
08fe8 11b             | ' Get HID descriptor buffer for current port
08fe8 11b             | '------------------------------------------------------------------------------
08fe8 11b             | ' On entry:
08fe8 11b             | ' On exit:
08fe8 11b             | '   PB - HID descriptor buffer pointer
08fe8 11b             | '------------------------------------------------------------------------------
08fe8 11b             | get_hid_descr_buffer
08fe8 11b 2D EF 03 F6 |                 mov     pb, hdev_port
08fec 11c 01 EE E7 F2 |                 cmpsub  pb, #1
08ff0 11d 00 EF 07 FA |                 mul     pb, #HID_DESCR_LEN
08ff4 11e 25 EF 03 01 |         _ret_   add     pb, hid_descr_p
08ff8 11f             | 
08ff8 11f             | 
08ff8 11f 01 A0 00 00 | usb16_poly_r    long    USB16_POLY
08ffc 120             | 
08ffc 120             | ' USB commands and error codes
08ffc 120 00 00 00 00 | cmd_data        long    0
09000 121 00 00 00 00 | usb_err_code    long    ERR_NONE
09004 122             | 
09004 122             | ' Parameters block assigned at cog startup
09004 122 12 00 00 00 | dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
09008 123 13 00 00 00 | dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
0900c 124 11 00 00 00 | usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
09010 125             | if ACTIVITY_LED >= 0
09010 125             | host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
09010 125             | end
09010 125             | if ERROR_LED >= 0
09010 125             | host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
09010 125             | end
09010 125 00 00 00 00 | hid_descr_p     long    0
09014 126             | 'hid_report_p    long    0, 0[MAX_DEVICES]
09014 126             | 'hkbd_report_p   long    0
09014 126 00 00 00 00 | hub_descr_p     long    0
09018 127 00 00 00 00 | urx_buff_p      long    0
0901c 128 00 00 00 00 | dev_desc_buff_p long    0
09020 129 00 00 00 00 | con_desc_buff_p long    0
09024 12a 00 00 00 00 | cache_start_p   long    0
09028 12b 00 00 00 00 | cache_end_p     long    0
0902c 12c             | if EMUPAD_MAX_PLAYER > 0
0902c 12c             | emupad_out_ptr  long    0
0902c 12c             | end
0902c 12c 00 00 00 00 | save_sysclk     long    0         ' Save the current sysclock as the client may change it
09030 12d             | 
09030 12d             | hdev_init_start
09030 12d             | hdev_port       res     1
09030 12d             | hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
09030 12d             | kbm_next_datax  res     1
09030 12d             | hub_intf_num    res     1
09030 12d             | hub_next_datax  res     1
09030 12d             | hub_status_chg  res     1
09030 12d             | hub_port_status res     1
09030 12d             | if HAVE_MOUSE
09030 12d             | ms_intf_num     res     1
09030 12d             | ms_in_max_pkt   res     1
09030 12d             | end
09030 12d             | kb_intf_num     res     1
09030 12d             | kb_interval     res     1
09030 12d             | kb_in_max_pkt   res     1
09030 12d             | kb_max_index    res     1
09030 12d             | kb_led_states   res     1
09030 12d             | gp_intf_num     res     1
09030 12d             | gp_interval     res     1
09030 12d             | gp_max_index    res     1
09030 12d             | gp_descr_len    res     1+MAX_DEVICES
09030 12d             | hdev_init_end
09030 12d             | 
09030 12d             | ' Initialized at cog startup:
09030 12d             | hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
09030 12d             | iframe_ct_new   res     1
09030 12d             | iframe_ct_base  res     1
09030 12d             | utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
09030 12d             | 
09030 12d             | ' This register block is reset to zero when a USB device connects
09030 12d             | hreg_init_start
09030 12d             | hstatus         res     1         ' Host status flags
09030 12d             | hctwait         res     1         ' Poll-based wait clocks
09030 12d             | ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
09030 12d             | tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
09030 12d             | nak_retry       res     1         ' NAK retry count, unlimited retries if zero
09030 12d             | xfer_retry      res     1         ' Control transfer retry count
09030 12d             | retry           res     1         ' Transaction retry count
09030 12d             | utx             res     1         ' Byte to transmit on USB
09030 12d             | urx             res     1         ' LSByte receiver status flags, MSByte received data
09030 12d             | newb_flg        res     1         ' Receive "new byte" bit toggle detector
09030 12d             | max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
09030 12d             | total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
09030 12d             | stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
09030 12d             | pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
09030 12d             | frame           res     1         ' USB 1ms frame counter value
09030 12d             | sof_pkt         res     1         ' ISR frame# packet and CRC5
09030 12d             | icrc            res     1         ' Only used by the 1ms frame output ISR routine
09030 12d             | pkt_cnt         res     1         ' Count of DATAx packet payload bytes
09030 12d             | crc             res     1         ' Used for CRC16 calculation
09030 12d             | ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
09030 12d             | retval          res     1         ' Global success/fail return parameter
09030 12d             | context_retval  res     1         ' Operation contextual return parameter
09030 12d             | ' Device stuff
09030 12d             | hdev_id         res     1+MAX_DEVICES
09030 12d             | hdev_bcd        res     1
09030 12d             | hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
09030 12d             | ' Keyboard/mouse stuff
09030 12d             | hctrl_ep_addr   res     1
09030 12d             | hctrl_max_pkt   res     1
09030 12d             | hconfig_base    res     1
09030 12d             | hcon_tot_len    res     1         ' Size of the complete config descriptor chain
09030 12d             | hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
09030 12d             | hdev_class      res     1
09030 12d             | hdev_subclass   res     1
09030 12d             | hdev_protocol   res     1
09030 12d             | hsearch_key     res     1         ' Descriptor type to search for in the config chain
09030 12d             | hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
09030 12d             | hhub_ctrl_ep    res     1         ' Hub control endpoint address
09030 12d             | hhub_ep_addr    res     1         ' Hub interface endpoint address
09030 12d             | hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
09030 12d             | hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
09030 12d             | if HAVE_MOUSE
09030 12d             | hmouse_ep_addr  res     1 ' Mouse interface endpoint address
09030 12d             | end
09030 12d             | hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
09030 12d             | hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
09030 12d             | hdev_ep_addr    res     1+MAX_DEVICES
09030 12d             | hdev_out_addr   res     1
09030 12d             | 
09030 12d             | if EMUPAD_MAX_PLAYER > 0
09030 12d             | hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
09030 12d             | hpad_emupad_buffer res EMUPAD_MAX_PLAYER
09030 12d             | hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
09030 12d             | end
09030 12d             | 
09030 12d             | hreg_init_end
09030 12d             | 
09030 12d             | hidr_start
09030 12d             | hidr_usage      res     1 ' <- can get trashed after parsing
09030 12d             | hidr_flags      res     1
09030 12d             | hidr_axis       res     4
09030 12d             | hidr_buttons    res     1
09030 12d             | hidr_hats       res     1
09030 12d             | '' Above are actually useful values, 6 longs
09030 12d             | hidr_type       res     1
09030 12d             | hidr_id         res     1
09030 12d             | hidr_offset     res     1
09030 12d             | hidr_usage_idx  res     1
09030 12d             | ' below need to be push/pop'd
09030 12d             | hidr_state      res     1
09030 12d             | hidr_size       res     1
09030 12d             | hidr_count      res     1
09030 12d             | hidr_lminmax    res     1
09030 12d             | hidr_pminmax    res     1
09030 12d             | hidr_end
09030 12d             | 
09030 12d             | ' Variables dependent on the system freqency
09030 12d             | _var_64_lower_  res     1
09030 12d             | _var_64_upper_  res     1
09030 12d             | _12Mbps_        res     1
09030 12d             | _1_5Mbps_       res     1
09030 12d             | _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
09030 12d             | _1us_           res     1         ' 1us
09030 12d             | _10us_          res     1         ' 10us
09030 12d             | _33us_          res     1         ' 33us
09030 12d             | _txn_err_       res     1         ' 250us
09030 12d             | _500us_         res     1         ' 500us
09030 12d             | _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
09030 12d             | _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
09030 12d             | _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
09030 12d             | _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
09030 12d             | _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
09030 12d             | _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
09030 12d             | _preamble_wait_ res     1
09030 12d             | _1ms_           res     1         ' 1ms
09030 12d             | _2ms_           res     1         ' 2ms
09030 12d             | _suspend_wait_  res     1         ' 3ms
09030 12d             | _4ms_           res     1         ' 4ms
09030 12d             | _xfer_wait_     res     1         ' 5ms
09030 12d             | _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
09030 12d             | _reset_hold_    res     1         ' 15ms
09030 12d             | _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
09030 12d             | _21ms_          res     1         ' 21ms
09030 12d             | _100ms_         res     1         ' 100ms
09030 12d             | _500ms_         res     1         ' 500ms
09030 12d             | _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
09030 12d             | _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
09030 12d             | '------------------------------------------------------------------------------
09030 12d             | _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
09030 12d             | _usb_d_ls_nco_  res     1
09030 12d             | _usb_h_fs_nco_  res     1
09030 12d             | _usb_d_fs_nco_  res     1
09030 12d             | '------------------------------------------------------------------------------
09030 12d             | ' Scratch registers
09030 12d             | htmp            res     1         ' Scratch registers whose context remains within the same code block
09030 12d             | htmp1           res     1
09030 12d             | htmp2           res     1
09030 12d             | htmp3           res     1
09030 12d             | hrep            res     1         ' Repeat count
09030 12d             | hsave0          res     1         ' Subroutine parameter saves
09030 12d             | hsave1          res     1
09030 12d             | hsave2          res     1
09030 12d             | isrtmp1         res     1
09030 12d             | pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
09030 12d             | hr0             res     1         ' Multi-purpose registers
09030 12d             | hr1             res     1
09030 12d             | hr2             res     1
09030 12d             | hr3             res     1
09030 12d             | hpar1           res     1         ' Routine entry/exit parameters
09030 12d             | hpar2           res     1
09030 12d             | hpar3           res     1
09030 12d             | hct2            res     1         ' Function response bus turn-around timer
09030 12d             | hct3            res     1         ' Keyboard/mouse poll timer
09030 12d             | mod_cnt         res     1         ' Used in idle loops
09030 12d             | 
09030 12d             |                 fit     $1F0
09030 12d             |                 fit     $1F0
09030 12d             |                 org     $200
09030 200             | hlut_start
09030 200             | 
09030 200             | '------------------------------------------------------------------------------
09030 200             | ' Full-speed is the host's native speed, so all that is needed is to set the FS
09030 200             | ' settings to startup defaults.
09030 200             | '------------------------------------------------------------------------------
09030 200             | ' On entry:
09030 200             | ' On exit: Save/restore caller C flag state if C is changed in this routine!
09030 200             | '------------------------------------------------------------------------------
09030 200             | set_speed_full
09030 200 D0 E8 07 F6 |                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
09034 201 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
09038 202 A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
0903c 203 A4 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
09040 204             | '                ret                             wcz     ' Restore caller flags on exit
09040 204             | 
09040 204             | '------------------------------------------------------------------------------
09040 204             | ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
09040 204             | ' is a downstream hub connected (not yet implemented), the baud generator
09040 204             | ' remains set at the full-speed rate, but signaling is switched to low-speed,
09040 204             | ' which reverses the D-/D+ polarity. The polarity can be changed without
09040 204             | ' putting the smart pins into reset.
09040 204             | '------------------------------------------------------------------------------
09040 204             | ' On entry:
09040 204             | ' On exit: CZ flags restored to caller states
09040 204             | '------------------------------------------------------------------------------
09040 204             | set_speed_low
09040 204 80 96 CE F7 |                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
09044 205 ED E8 07 A6 |         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
09048 206 22 6B 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
0904c 207 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
09050 208 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
09054 209 A3 9B 02 F6 |                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
09058 20a 02 96 26 F4 |                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
0905c 20b 2D 00 7C FD |                 ret                             wcz     ' Restore caller flags on exit
09060 20c             | 
09060 20c             | '------------------------------------------------------------------------------
09060 20c             | ' Perform configuration stuff required when a device intitially connects.
09060 20c             | '------------------------------------------------------------------------------
09060 20c             | ' On entry:
09060 20c             | ' On exit:
09060 20c             | '------------------------------------------------------------------------------
09060 20c             | on_connect
09060 20c 02 86 07 F6 |                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
09064 20d D8 FB BF FD |                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
09068 20e             | .retry
09068 20e 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
0906c 20f 01 8E 07 C6 |         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
09070 210 02 8E 07 36 |         if_nc   mov     hpar1, #USB_SPEED_FULL
09074 211 00 08 00 FF 
09078 212 00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
0907c 213 20 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
09080 214 47 F1 03 F1 |                 add     ptra, hcog_base_addr
09084 215 03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
09088 216 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
0908c 217 F4 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
09090 218 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09094 219 18 00 90 AD |         if_z    jmp     #.get_dev_desc
09098 21a B2 99 02 F6 |                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
0909c 21b 4C 03 B0 FD |                 call    #poll_waitx
090a0 21c 01 86 8F F1 |                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
090a4 21d F0 FB 9F AD |         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
090a8 21e A4 FB BF FD |                 call    #reset                          ' Try another reset to see if the device responds
090ac 21f B8 FF 9F FD |                 jmp     #.retry
090b0 220             | .get_dev_desc
090b0 220 28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
090b4 221 07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
090b8 222 F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
090bc 223 A8 99 02 F6 |                 mov     hctwait, _1ms_
090c0 224 28 03 B0 FD |                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
090c4 225 88 FB BF FD |                 call    #reset
090c8 226 38 1E C0 FE |                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
090cc 227 47 F1 03 F1 |                 add     ptra, hcog_base_addr
090d0 228 01 11 5C FC |                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
090d4 229 D8 01 B0 FD |                 call    #control_write                  ' Execute SetAddress()
090d8 22a D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
090dc 22b 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
090e0 22c AD 99 02 F6 |                 mov     hctwait, _8ms_
090e4 22d 04 03 B0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
090e8 22e 04 00 00 FF 
090ec 22f 00 BC 06 F6 |                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
090f0 230 34 FA BF FD |                 call    #calc_crc5
090f4 231 20 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
090f8 232 47 F1 03 F1 |                 add     ptra, hcog_base_addr
090fc 233 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
09100 234 F7 AD C2 FA |                 rdbyte  total_data, pb
09104 235 03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
09108 236 78 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
0910c 237 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09110 238 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
09114 239 5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
09118 23a 28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
0911c 23b 07 DB C6 FA |                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
09120 23c A0 99 02 F6 |                 mov     hctwait, _500us_
09124 23d C4 02 B0 FD |                 call    #poll_waitx
09128 23e 28 1E C0 FE |                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
0912c 23f 47 F1 03 F1 |                 add     ptra, hcog_base_addr
09130 240 03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
09134 241 29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
09138 242 48 00 B0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
0913c 243 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09140 244 2D 00 64 5D |         if_nz   ret
09144 245 29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
09148 246 F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
0914c 247 61 87 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
09150 248 61 89 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
09154 249 00 73 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
09158 24a 09 86 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
0915c 24b 02 88 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
09160 24c 56 73 1B A2 |         if_z    cmp     htmp, total_data        wcz
09164 24d 0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
09168 24e 2C FB 9F CD |         if_b    jmp     #host_error
0916c 24f 24 13 80 FE |                 loc     pa, #@init_kbdm_data - @usb_host_start
09170 250 47 ED 03 F1 |                 add     pa, hcog_base_addr
09174 251 2D EC 63 FD |                 call    pa
09178 252 B8 0D 80 FE |                 loc     pa, #@hparse_con_desc - @usb_host_start
0917c 253 47 ED 03 F1 |                 add     pa, hcog_base_addr
09180 254 2C EC 63 FD |                 jmp     pa
09184 255             | 
09184 255             | '------------------------------------------------------------------------------
09184 255             | ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
09184 255             | ' Status reporting is always in the function-to-host direction.
09184 255             | '------------------------------------------------------------------------------
09184 255             | ' On entry:
09184 255             | '   PTRA - start address of the SETUP data in hub.
09184 255             | '   PB - start address of the buffer/struct to be written to during the IN data
09184 255             | '     stage.
09184 255             | '   ep_addr_pid - device address, endpoint and CRC5.
09184 255             | ' On exit:
09184 255             | '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
09184 255             | '     contains the count of data stage bytes actually received, which must
09184 255             | '     always be <= the count requested.
09184 255             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
09184 255             | '     more specific USB operation error code.
09184 255             | '------------------------------------------------------------------------------
09184 255             | control_read
09184 255 5E 8F 03 F6 |                 mov     hpar1, ep_addr_pid
09188 256 F8 91 03 F6 |                 mov     hpar2, ptra
0918c 257 F7 93 03 F6 |                 mov     hpar3, pb                       ' Save dest buffer pointer
09190 258 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
09194 259             | .xfer_start
09194 259 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
09198 25a C0 F6 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
0919c 25b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
091a0 25c 2D 00 64 5D |         if_nz   ret                                     ' Back to caller to handle error
091a4 25d 00 AC 0E F2 |                 cmp     total_data, #0          wz
091a8 25e 90 01 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
091ac 25f 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
091b0 260 61 00 00 FF 
091b4 261 50 9F 06 F6 |                 mov     nak_retry, ##IN_NAK_RETRIES
091b8 262 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
091bc 263             | .data
091bc 263 56 B1 02 F6 |                 mov     pkt_data, total_data
091c0 264 57 B1 82 F1 |                 sub     pkt_data, stage_data
091c4 265 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
091c8 266 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
091cc 267             | .nak_retry
091cc 267 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
091d0 268             | .in_retry
091d0 268 BC F6 BF FD |                 call    #txn_in
091d4 269 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
091d8 26a 28 00 90 AD |         if_z    jmp     #.commit
091dc 26b 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
091e0 26c A8 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
091e4 26d 14 02 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
091e8 26e 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
091ec 26f DC FF 9F AD |         if_z    jmp     #.nak_retry                     ' Function not ready to send data
091f0 270 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
091f4 271 94 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
091f8 272 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
091fc 273 D0 FF 9F 5D |         if_nz   jmp     #.in_retry                      ' Bus error retry
09200 274 2D 00 64 FD |                 ret                                     ' The transfer has failed
09204 275             | .commit
09204 275 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
09208 276 38 00 90 AD |         if_z    jmp     #.pre_status                    ' and also end-of-data
0920c 277 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
09210 278 5C 87 03 F6 |                 mov     hr0, pkt_cnt
09214 279 F7 F1 0B F2 |                 cmp     ptra, pb                wz
09218 27a 6C FA BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
0921c 27b 5C AF 02 F1 |                 add     stage_data, pkt_cnt             ' Update bytes received on commit
09220 27c 56 AF 0A F2 |                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
09224 27d 1C 00 90 AD |         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
09228 27e 58 B9 1A F2 |                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
0922c 27f 14 00 90 CD |         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
09230 280 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET
09234 281 5F C1 02 16 |         if_a    mov     context_retval, retval          ' In this case overall and context are the same
09238 282 2D 00 64 1D |         if_a    ret                                     ' Caller must handle ERR_PACKET
0923c 283 03 96 E6 F4 |                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
09240 284 78 FF 9F FD |                 jmp     #.data                          ' Start next IN transaction
09244 285             | .pre_status
09244 285 57 AD 02 F6 |                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
09248 286 E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0
0924c 287 00 B0 06 F6 |                 mov     pkt_data, #0
09250 288 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
09254 289 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
09258 28a 61 00 00 FF 
0925c 28b 50 9F 06 F6 |                 mov     nak_retry, ##OUT_NAK_RETRIES
09260 28c             | .out_retry
09260 28c 34 F7 BF FD |                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
09264 28d D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09268 28e 2D 00 64 AD |         if_z    ret                                     ' All is good when ACK
0926c 28f 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
09270 290 18 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
09274 291 84 01 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
09278 292 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
0927c 293 0C 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
09280 294 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
09284 295 D8 FF 9F 5D |         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
09288 296 2D 00 64 FD |                 ret                                     ' Caller must handle transfer retirement
0928c 297             | ' I've encountered transfer STALL, even though the data looks correct, and
0928c 297             | ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
0928c 297             | ' ControlRead() transfer gets things unstuck most of the time...
0928c 297             | .xfer_retry
0928c 297 AC 99 02 F6 |                 mov     hctwait, _xfer_wait_
09290 298 58 01 B0 FD |                 call    #poll_waitx
09294 299 8C F9 BF FD |                 call    #wait_txn_ok
09298 29a C7 BD 02 F6 |                 mov     ep_addr_pid, hpar1
0929c 29b C8 F1 03 F6 |                 mov     ptra, hpar2
092a0 29c C9 EF 03 F6 |                 mov     pb, hpar3
092a4 29d BB A1 6E FB |                 djnz    xfer_retry, #.xfer_start
092a8 29e 5F C1 02 F6 |                 mov     context_retval, retval          ' Preserve the USB error code
092ac 29f 07 BE 06 06 |         _ret_   mov     retval, #ERR_XFER_RETRY
092b0 2a0             | 
092b0 2a0             | '------------------------------------------------------------------------------
092b0 2a0             | ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
092b0 2a0             | ' reporting is always in the function-to-host direction. It is assumed that
092b0 2a0             | ' the SETUP data struct is filled with the required values.
092b0 2a0             | '------------------------------------------------------------------------------
092b0 2a0             | ' On entry:
092b0 2a0             | '   PTRA - points to the start of the struct for the SETUP data.
092b0 2a0             | '   PB - the start address of the struct/buffer to be read for the OUT data
092b0 2a0             | '     stage.
092b0 2a0             | '   ep_addr_pid - the proper CRC'd address and endpoint to use.
092b0 2a0             | ' On exit:
092b0 2a0             | '   retval - used to convey the success/failure of each stage.
092b0 2a0             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
092b0 2a0             | '     more specific USB operation error code.
092b0 2a0             | '------------------------------------------------------------------------------
092b0 2a0             | control_write
092b0 2a0 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
092b4 2a1 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
092b8 2a2 0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
092bc 2a3             | 
092bc 2a3 5E 8F 03 F6 |                 mov     hpar1, ep_addr_pid
092c0 2a4 F8 91 03 F6 |                 mov     hpar2, ptra
092c4 2a5 F7 93 03 F6 |                 mov     hpar3, pb
092c8 2a6 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
092cc 2a7             | .xfer_start
092cc 2a7 00 9E 06 F6 |                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
092d0 2a8 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
092d4 2a9 84 F5 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
092d8 2aa D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
092dc 2ab EC 00 90 5D |         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
092e0 2ac 00 AC 0E F2 |                 cmp     total_data, #0          wz
092e4 2ad 54 00 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
092e8 2ae 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
092ec 2af E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
092f0 2b0 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
092f4 2b1 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
092f8 2b2             | .data
092f8 2b2 56 B1 02 F6 |                 mov     pkt_data, total_data
092fc 2b3 57 B1 82 F1 |                 sub     pkt_data, stage_data
09300 2b4 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
09304 2b5 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
09308 2b6             | .out_retry
09308 2b6 F7 F1 03 F6 |                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
0930c 2b7 88 F6 BF FD |                 call    #txn_out
09310 2b8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09314 2b9 10 00 90 AD |         if_z    jmp     #.commit                        ' Function got the data
09318 2ba E0 00 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
0931c 2bb 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
09320 2bc E4 FF 9F 5D |         if_nz   jmp     #.out_retry
09324 2bd A4 00 90 FD |                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
09328 2be             | .commit
09328 2be F8 EF 03 F6 |                 mov     pb, ptra                        ' Save the current buffer/struct location
0932c 2bf 58 AF 02 F1 |                 add     stage_data, pkt_data
09330 2c0 56 AF 0A F2 |                 cmp     stage_data, total_data  wz
09334 2c1 03 96 E6 54 |         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
09338 2c2 BC FF 9F 5D |         if_nz   jmp     #.data                          ' More data to send
0933c 2c3             | pre_status_in
0933c 2c3 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
09340 2c4 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
09344 2c5             | .status_retry
09344 2c5 00 B0 06 F6 |                 mov     pkt_data, #0
09348 2c6 44 F5 BF FD |                 call    #txn_in
0934c 2c7 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
09350 2c8 00 B0 0E A2 |         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
09354 2c9 74 00 90 AD |         if_z    jmp     #dwnstream_reset                ' Control Write finished
09358 2ca 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
0935c 2cb 2D 00 64 AD |         if_z    ret
09360 2cc 98 00 B0 FD |                 call    #retry_wait                     ' NAK or bus error, so delay a bit
09364 2cd 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
09368 2ce D8 FF 9F 5D |         if_nz   jmp     #.status_retry
0936c 2cf             | '               ret                                     ' Caller must handle transfer retirement
0936c 2cf             | 
0936c 2cf             | '------------------------------------------------------------------------------
0936c 2cf             | ' Execute an IN interrupt transaction.
0936c 2cf             | '------------------------------------------------------------------------------
0936c 2cf             | ' On entry:
0936c 2cf             | '   ep_addr_pid - The function address and endpoint for the IN request.
0936c 2cf             | '   hpar2 - Address of the IN data buffer
0936c 2cf             | '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
0936c 2cf             | ' On exit:
0936c 2cf             | '   retval - the result of the operation.
0936c 2cf             | '   hpar3 - the count of IN data bytes actually received.
0936c 2cf             | '------------------------------------------------------------------------------
0936c 2cf             | do_int_in
0936c 2cf 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
09370 2d0 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
09374 2d1 0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
09378 2d2             | 
09378 2d2 C9 73 33 F9 |                 getword htmp, hpar3, #0
0937c 2d3 C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz
09380 2d4 03 96 A6 F4 |                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
09384 2d5 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES
09388 2d6             | .retry
09388 2d6 C9 B1 3A F9 |                 getword pkt_data, hpar3, #1             ' IN max packet length
0938c 2d7 00 F5 BF FD |                 call    #txn_in
09390 2d8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK if data received
09394 2d9 1C 00 90 AD |         if_z    jmp     #.commit
09398 2da 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
0939c 2db 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
093a0 2dc 24 00 90 AD |         if_z    jmp     #.post_ret                      ' The caller must handle either
093a4 2dd 54 00 B0 FD |                 call    #retry_wait
093a8 2de 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
093ac 2df 18 00 90 AD |         if_z    jmp     #.post_ret
093b0 2e0 D4 FF 9F FD |                 jmp     #.retry
093b4 2e1             | .commit
093b4 2e1 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy the rx buffer
093b8 2e2 C8 EF 03 F6 |                 mov     pb, hpar2                       ' to the destination buffer
093bc 2e3 5C 87 0B F6 |                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
093c0 2e4 F7 F1 0B 52 |         if_nz   cmp     ptra, pb                wz
093c4 2e5 C0 F8 BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
093c8 2e6             | .post_ret
093c8 2e6 5C 93 03 F6 |                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
093cc 2e7             | 
093cc 2e7             | 
093cc 2e7             | '------------------------------------------------------------------------------
093cc 2e7             | ' Resets the downstream hub port to FS
093cc 2e7             | '------------------------------------------------------------------------------
093cc 2e7             | dwnstream_reset
093cc 2e7 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
093d0 2e8 2D 00 64 3D |         if_nc   ret                                     ' No LS device, reset not needed
093d4 2e9             | 
093d4 2e9 0E 6A 07 F4 |                 bitl    _usb_h_ls_nco_, #14
093d8 2ea 07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
093dc 2eb 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
093e0 2ec 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
093e4 2ed A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
093e8 2ee A4 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
093ec 2ef             | 
093ec 2ef             | '------------------------------------------------------------------------------
093ec 2ef             | ' The one millisecond frame timer is implemented as an interrupt service
093ec 2ef             | ' routine. Since this timing is critical, care must be taken to avoid any
093ec 2ef             | ' instructions that can delay the interrupt branch, which will likely upset
093ec 2ef             | ' the timer. WAITX is among those instructions, so any time you're inside
093ec 2ef             | ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
093ec 2ef             | '------------------------------------------------------------------------------
093ec 2ef             | ' On entry:
093ec 2ef             | '   hctwait - wait interval in sysclocks.
093ec 2ef             | ' On exit:
093ec 2ef             | '------------------------------------------------------------------------------
093ec 2ef             | poll_waitx
093ec 2ef 1A 94 63 FD |                 getct   hct2
093f0 2f0 4C 95 6B FA |                 addct2  hct2, hctwait
093f4 2f1             | .wait
093f4 2f1 FF 25 CC FB |                 jnct2   #.wait
093f8 2f2 2D 00 64 FD |                 ret
093fc 2f3             | 
093fc 2f3             | '------------------------------------------------------------------------------
093fc 2f3             | ' Transaction retry handling for NAK/STALL or bus error.
093fc 2f3             | '------------------------------------------------------------------------------
093fc 2f3             | ' On entry:
093fc 2f3             | '   retval - transaction response PID or error code.
093fc 2f3             | ' On exit:
093fc 2f3             | '------------------------------------------------------------------------------
093fc 2f3             | retry_wait
093fc 2f3 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
09400 2f4 2D 00 64 AD |         if_z    ret                                     ' STALL is special case
09404 2f5 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
09408 2f6 14 00 90 AD |         if_z    jmp     #.nak
0940c 2f7 9F 99 02 F6 |                 mov     hctwait, _txn_err_              ' Transaction error wait...
09410 2f8 D8 FF BF FD |                 call    #poll_waitx
09414 2f9             | .dec
09414 2f9 01 A2 8E F1 |                 sub     retry, #1               wz
09418 2fa 06 BE 06 A6 |         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
0941c 2fb 2D 00 64 FD |                 ret                                     ' Retry result to caller
09420 2fc             | .nak
09420 2fc 9E 99 02 F6 |                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
09424 2fd C4 FF BF FD |                 call    #poll_waitx
09428 2fe 00 9E 0E F2 |                 cmp     nak_retry, #NAK_NOLIMIT wz
0942c 2ff 2D 00 64 AD |         if_z    ret                                     ' Indefinite NAK retries
09430 300 01 9E 8E F1 |                 sub     nak_retry, #1           wz
09434 301 08 BE 06 A6 |         if_z    mov     retval, #ERR_NAK
09438 302 2D 00 64 FD |                 ret
0943c 303             | 
0943c 303             | host_reset
0943c 303 25 00 64 FD |                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
09440 304 14 72 07 FB |                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
09444 305             | ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
09444 305 BD 01 05 FF 
09448 306 00 72 1F F2 |                 cmp     htmp, ##168_000_000     wcz
0944c 307 00 94 06 E6 |         if_be   mov     utx_tweak, #0
09450 308 03 94 06 16 |         if_a    mov     utx_tweak, #3   '#20
09454 309             | ' Check to see if the system clock has been changed.
09454 309 2C 73 0B F2 |                 cmp     htmp, save_sysclk       wz
09458 30a C4 0B A0 5E |         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
0945c 30b 47 EF 03 51 |         if_nz   add     pb, hcog_base_addr
09460 30c 2D EE 63 5D |         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
09464 30d 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
09468 30e 40 46 62 FD |                 dirl    dp
0946c 30f             | 
0946c 30f 28 02 64 FD |                 setq    #1
09470 310 80 00 80 FF 
09474 311 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
09478 312 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
0947c 313             | .enable
0947c 313 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
09480 314 41 46 62 FD |                 dirh    dp
09484 315 1F 38 63 FD |                 waitx   _1us_
09488 316 22 01 28 FC |                 wypin   #OUT_IDLE, dm
0948c 317             | 
0948c 317             |                 ' Handle Port protection enable and startup delay
0948c 317 00 48 56 F2 |                 cmps    usb_enable_pin, #0      wc
09490 318 58 48 62 3D |         if_ae   drvl    usb_enable_pin                 ' disable port
09494 319 1F 60 63 FD |                 waitx   _21ms_                          ' Wait a while for everything to turn off
09498 31a 59 48 62 3D |         if_ae   drvh    usb_enable_pin                  ' Enable the port
0949c 31b 1F 60 63 FD |                 waitx   _21ms_                          ' Hold to let the idle state get settled
094a0 31c             | 
094a0 31c             |                 'call #dev_reset ' TODO THINK ABOUT THIS
094a0 31c             | 
094a0 31c             | discon_entry
094a0 31c 03 98 07 F6 |                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
094a4 31d             | 
094a4 31d 4B ED B7 F9 |                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
094a8 31e 3B 04 DC FC |                 rep     @.regloop,#hreg_init_end - hreg_init_start
094ac 31f 38 EC A7 F9 |                 alti    pa, #%000_111_000
094b0 320 00 00 04 F6 |                 mov     0-0, #0
094b4 321             | .regloop
094b4 321             |               
094b4 321             |         if HAVE_HIDPAD
094b4 321 F8 27 A0 FE |                 loc     pb, #@hidpad_report - @usb_host_start
094b8 322 47 EF 03 F1 |                 add     pb, hcog_base_addr
094bc 323 28 6E 64 FD |                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
094c0 324 F7 01 68 FC |                 wrlong  #0,pb
094c4 325             |         end
094c4 325             |         if EMUPAD_MAX_PLAYER > 0
094c4 325             |         end
094c4 325             | 
094c4 325             |                 ' Fall through to disconnected loop
094c4 325             | 
094c4 325             | '-----------------------------------------------------------------------------------------------------------------
094c4 325             | ' Device connect handling (Section 7.1.7.3).
094c4 325             | '-----------------------------------------------------------------------------------------------------------------
094c4 325             | ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
094c4 325             | ' device to connect (Section 7.1.7.3).
094c4 325             | '-----------------------------------------------------------------------------------------------------------------
094c4 325             | disconnected
094c4 325 14 88 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
094c8 326 2C 89 0B F2 |                 cmp     hr1, save_sysclk        wz
094cc 327 6C FF 9F 5D |         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
094d0 328 03 88 47 F0 |                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
094d4 329 1F 88 63 FD |                 waitx   hr1                             ' it down to smaller wait chunks
094d8 32a             |         if ACTIVITY_LED >= 0
094d8 32a             |         end
094d8 32a 22 A7 82 FA |                 rqpin   urx, dm
094dc 32b 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
094e0 32c E0 FF 9F AD |         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
094e4 32d 28 00 90 5D |         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
094e8 32e             | .se1_test
094e8 32e B1 99 02 F6 |                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
094ec 32f FC FE BF FD |                 call    #poll_waitx
094f0 330 22 A7 82 FA |                 rqpin   urx, dm
094f4 331 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
094f8 332 00 BE 06 56 |         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
094fc 333 A0 FF 9F 5D |         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
09500 334             | .se1            'SE1 is a fatal error condition
09500 334 B1 99 02 F6 |                 mov     hctwait, _100ms_
09504 335 E4 FE BF FD |                 call    #poll_waitx
09508 336 03 BE 06 F6 |                 mov     retval, #ERR_SE1
0950c 337 88 F7 BF FD |                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
09510 338             | .connect_test                                           ' Test lines until stable J/K state seen
09510 338 1F 62 63 FD |                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
09514 339 22 A7 82 FA |                 rqpin   urx, dm
09518 33a 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
0951c 33b 80 FF 9F AD |         if_z    jmp     #discon_entry                   ' D+ and D- low
09520 33c C4 FF 9F AD |         if_e    jmp     #.se1_test                      ' D+ and D- high
09524 33d             | connected
09524 33d 01 96 26 F4 |                 bith    hstatus, #CONNECTEDB            ' Device plugged in
09528 33e 34 FB BF FD |                 call    #on_connect                     ' Initial device configuration
0952c 33f D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
09530 340 6C FF 9F 5D |         if_nz   jmp     #discon_entry
09534 341             | .set_pulse
09534 341 1A 66 63 FD |                 getct   _pulse_time_
09538 342 B2 67 03 F1 |                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
0953c 343             | ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
0953c 343             | ' of 1ms and make a correction, if necessary.
0953c 343             | '                mov     htmp, _1ms_
0953c 343             | '                subs    htmp, iframe_delta
0953c 343             | '                adds    _frame1ms_clks_, htmp
0953c 343             | '                debug(udec(_frame1ms_clks_))
0953c 343             | 
0953c 343             |                 ' Fall through to idle/processing loop
0953c 343 07 5A 1E F2 |                 cmp     hdev_port, #MAX_DEVICES wcz
09540 344 00 5A 06 16 |         if_a    mov     hdev_port, #0 
09544 345             | 
09544 345             | hidle
09544 345 22 A7 82 FA |                 rqpin   urx, dm
09548 346 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
0954c 347 98 00 90 CD |         if_c    jmp     #.se0_test
09550 348 24 06 70 FD |                 pollct3                         wc
09554 349 68 00 90 3D |         if_nc   jmp     #.nopoll
09558 34a 1A 96 63 FD |                 getct   hct3
0955c 34b A8 97 73 FA |                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
09560 34c             | 
09560 34c 6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
09564 34d 00 72 E3 F8 |                 getbyte htmp
09568 34e             | 
09568 34e 09 72 0F F2 |                 cmp     htmp, #HUB_READY        wz
0956c 34f 8C 1B 80 AE |         if_z    loc     pa, #@hget_hub_status - @usb_host_start
09570 350 40 00 90 AD |         if_z    jmp     #.poll
09574 351             | 
09574 351             |         if _HAVE_GAMEPAD
09574 351 06 72 0F F2 |                 cmp     htmp, #HID_READY        wz
09578 352 08 72 0F 52 |         if_nz   cmp     htmp, #PS3_READY        wz
0957c 353 07 72 0F 52 |         if_nz   cmp     htmp, #XINPUT_READY     wz
09580 354 F4 15 80 AE |         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
09584 355 2C 00 90 AD |         if_z    jmp     #.poll
09588 356             |         end
09588 356             | 
09588 356             |         if HAVE_MOUSE
09588 356 04 72 0F F2 |                 cmp     htmp, #M_READY          wz
0958c 357 44 15 80 AE |         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
09590 358 20 00 90 AD |         if_z    jmp     #.poll
09594 359             |         end
09594 359             | 
09594 359 03 72 0F F2 |                 cmp     htmp, #KB_READY         wz
09598 35a AC 13 80 AE |         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
0959c 35b 14 00 90 AD |         if_z    jmp     #.poll
095a0 35c             | 
095a0 35c 05 72 0F F2 |                 cmp     htmp, #KBM_READY        wz
095a4 35d 14 00 90 5D |         if_nz   jmp     #.skip_poll
095a8 35e 09 96 FE F4 |                 bitnot  hstatus, #KBM_TOGGLEB   wcz
095ac 35f AC 13 80 3E |         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
095b0 360             |         if HAVE_MOUSE
095b0 360 44 15 80 CE |         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
095b4 361             |         else
095b4 361             |         end
095b4 361             | 
095b4 361             | .poll
095b4 361 47 ED 03 F1 |                 add     pa, hcog_base_addr
095b8 362 2D EC 63 FD |                 call    pa
095bc 363             | .skip_poll
095bc 363             | 
095bc 363 07 5A 06 F7 |                 incmod  hdev_port, #MAX_DEVICES
095c0 364             | 
095c0 364             | .nopoll
095c0 364 0E 40 0E F2 |                 cmp     cmd_data, #CMD_SUSPEND  wz
095c4 365 44 00 90 AD |         if_z    jmp     #hsuspend
095c8 366 10 40 0E F2 |                 cmp     cmd_data, #CMD_RESET    wz
095cc 367 00 40 06 A6 |         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
095d0 368 68 FE 9F AD |         if_z    jmp     #host_reset                     ' See if it works...
095d4 369 1A 86 63 FD |                 getct   hr0
095d8 36a B3 87 1B F2 |                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
095dc 36b             |         if ACTIVITY_LED >= 0
095dc 36b             |         end
095dc 36b 1A 66 63 3D |         if_ae   getct   _pulse_time_
095e0 36c B2 67 03 31 |         if_ae   add     _pulse_time_, _500ms_
095e4 36d 5C FF 9F FD |                 jmp     #hidle
095e8 36e             | ' Check for extended SE0 state on the bus
095e8 36e             | .se0_test
095e8 36e A8 99 02 F6 |                 mov     hctwait, _1ms_
095ec 36f FC FD BF FD |                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
095f0 370 22 A7 82 FA |                 rqpin   urx, dm
095f4 371 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
095f8 372 48 FF 9F 3D |         if_nc   jmp     #hidle                          ' Bus still IDLE
095fc 373 24 F6 BF FD |                 call    #wait_txn_ok
09600 374 00 00 80 FF 
09604 375 22 01 28 FC |                 wypin   ##OUT_IDLE, dm                  ' Float USB
09608 376             |                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
09608 376 94 FE 9F FD |                 jmp     #discon_entry                   ' Device disconnected
0960c 377             | 
0960c 377             | hsuspend
0960c 377 14 F6 BF FD |                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
09610 378 25 00 64 FD |                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
09614 379 1F 54 63 FD |                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
09618 37a 22 01 28 FC |                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
0961c 37b 00 40 06 F6 |                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
09620 37c 00 98 07 F6 |                 mov     mod_cnt, #0
09624 37d             | 
09624 37d             |                 ' Fall through to resume wait loop
09624 37d             | 
09624 37d             | hwait_resume
09624 37d 14 88 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
09628 37e 02 88 47 F0 |                 shr     hr1, #2
0962c 37f 1F 88 63 FD |                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
09630 380             |         if ACTIVITY_LED >= 0
09630 380             |         end
09630 380 0F 40 0E F2 |                 cmp     cmd_data, #CMD_RESUME   wz
09634 381 EC FF 9F 5D |         if_nz   jmp     #hwait_resume
09638 382 14 72 07 FB |                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
0963c 383 2C 73 0B F2 |                 cmp     htmp, save_sysclk       wz
09640 384 18 00 90 AD |         if_z    jmp     #.resume
09644 385 C4 0B A0 FE |                 loc     pb, #@hinit_usb_timings - @usb_host_start
09648 386 47 EF 03 F1 |                 add     pb, hcog_base_addr
0964c 387 2D EE 63 FD |                 call    pb                              ' Recalculate sysclk dependent timing values
09650 388 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
09654 389 22 6F 13 3C |         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
09658 38a 22 6B 13 CC |         if_c    wxpin   _usb_h_ls_nco_, dm
0965c 38b             | .resume
0965c 38b 22 05 28 FC |                 wypin   #OUT_K, dm
09660 38c 1F 5E 63 FD |                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
09664 38d 22 03 28 FC |                 wypin   #OUT_SE0, dm
09668 38e A3 73 03 F6 |                 mov     htmp, _ip_delay_ls_
0966c 38f 01 72 47 F0 |                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
09670 390 1F 72 63 FD |                 waitx   htmp
09674 391 22 07 28 FC |                 wypin   #OUT_J, dm
09678 392 01 72 47 F0 |                 shr     htmp, #1
0967c 393 1F 72 63 FD |                 waitx   htmp
09680 394 22 01 28 FC |                 wypin   #OUT_IDLE, dm
09684 395 1A 92 62 FD |                 getct   iframe_ct_base
09688 396 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
0968c 397 B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
09690 398 25 02 64 FD |                 setint1 #1                              ' Enable the 1ms frame ISR
09694 399 AB 99 02 F6 |                 mov     hctwait, _4ms_
09698 39a 50 FD BF FD |                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
0969c 39b 00 40 06 06 |         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
096a0 39c             | 
096a0 39c             | '------------------------------------------------------------------------------
096a0 39c             | ' Send preamble to enable low-speed HUB ports
096a0 39c             | '------------------------------------------------------------------------------
096a0 39c             | ' On entry:
096a0 39c             | ' On exit:
096a0 39c             | '   USB baud rate set to low-speed
096a0 39c             | '------------------------------------------------------------------------------
096a0 39c             | utx_pre
096a0 39c 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
096a4 39d 40 46 62 FD |                 dirl    dp
096a8 39e 28 02 64 FD |                 setq    #1
096ac 39f 22 01 08 FC |                 wrpin   #0, dm                          ' Disable smartpin mode
096b0 3a0 58 44 62 FD |                 drvl    dm
096b4 3a1 59 46 62 FD |                 drvh    dp
096b8 3a2             | 
096b8 3a2 1E 00 00 FF 
096bc 3a3 80 72 07 F6 |                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
096c0 3a4             | 
096c0 3a4 11 08 DC FC |                 rep     @.l1, #16 + 1
096c4 3a5 01 72 57 F0 |                 shr     htmp, #1        wc
096c8 3a6 28 02 64 3D |         if_nc   setq    #1
096cc 3a7 4F 44 62 3D |         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
096d0 3a8 1F 4E 63 FD |                 waitx   _preamble_wait_
096d4 3a9             | .l1
096d4 3a9             | 
096d4 3a9 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
096d8 3aa 40 46 62 FD |                 dirl    dp
096dc 3ab 28 02 64 FD |                 setq    #1
096e0 3ac 80 00 80 FF 
096e4 3ad 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
096e8 3ae 22 6B 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
096ec 3af 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
096f0 3b0 41 46 62 FD |                 dirh    dp
096f4 3b1 22 01 28 FC |                 wypin   #OUT_IDLE, dm
096f8 3b2             | 
096f8 3b2 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
096fc 3b3 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
09700 3b4 A3 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
09704 3b5             | 
09704 3b5             | hlut_end
09704 3b5             |                 fit     $400
09704 3b5             |                 fit     $400
09704 3b5             |                 orgh
09704                 | if OVERLAP_MEMORY
09704                 |                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
09704                 | end
09704                 | '------------------------------------------------------------------------------
09704                 | ' Routines called from cog space.
09704                 | '------------------------------------------------------------------------------
09704                 | ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
09704                 | '------------------------------------------------------------------------------
09704                 | 
09704                 | '------------------------------------------------------------------------------
09704                 | ' USB host cog initialization.
09704                 | '------------------------------------------------------------------------------
09704                 | usb_host_init
09704                 |                 ' Initialize buffer pointers
09704                 |         if OVERLAP_MEMORY
09704                 |         else
09704     4C 15 B0 FE |                 loc     pb, #hid_descr
09708                 |         end
09708     F7 4B 02 F6 |                 mov     hid_descr_p, pb
0970c                 |                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
0970c                 |                 {
0970c                 |                 }
0970c                 |         
0970c                 |                 {
0970c                 |                 }
0970c                 |                 'loc     pb,#hkbd_report
0970c                 |                 'mov     hkbd_report_p,pb
0970c                 | 
0970c     44 1D B0 FE |                 loc     pb, #hub_descr
09710     F7 4D 02 F6 |                 mov     hub_descr_p, pb
09714     59 1D B0 FE |                 loc     pb, #urx_buff
09718     F7 4F 02 F6 |                 mov     urx_buff_p, pb
0971c     D1 1D B0 FE |                 loc     pb, #dev_desc_buff
09720     F7 51 02 F6 |                 mov     dev_desc_buff_p, pb
09724     DB 1D B0 FE |                 loc     pb, #con_desc_buff
09728     F7 53 02 F6 |                 mov     con_desc_buff_p, pb
0972c     24 15 B0 FE |                 loc     pb, #usb_cache_start
09730     F7 55 02 F6 |                 mov     cache_start_p, pb
09734     25 1D B0 FE |                 loc     pb, #usb_cache_end
09738     F7 57 02 F6 |                 mov     cache_end_p, pb
0973c                 | 
0973c                 |         if ERROR_LED >= 0
0973c                 |         end
0973c                 | 
0973c                 |                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
0973c                 |                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
0973c                 |                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
0973c                 | ' Configure and enable the Serial Host USB port.
0973c     03 03 80 FD |                 jmp     #host_reset                     ' Initialize host and enter main processing loop
09740                 | 
09740                 | '------------------------------------------------------------------------------
09740                 | ' Timing calculations happen before any interrupt(s) are enabled.
09740                 | '------------------------------------------------------------------------------
09740                 | ' On entry:
09740                 | '   htmp - current CLKFREQ value.
09740                 | '------------------------------------------------------------------------------
09740                 | hinit_usb_timings
09740                 | '                getct   htmp2
09740     B9 59 02 F6 |                 mov     save_sysclk, htmp
09744     8D 5B 80 FF 
09748     2C 01 2A FD |                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
0974c     18 32 63 FD |                 getqx   _12Mbps_
09750     10 32 57 F0 |                 shr     _12Mbps_, #16           wc
09754     00 32 27 F1 |                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
09758     03 6E 07 F6 |                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
0975c     0E 6E 67 F0 |                 shl     _usb_h_fs_nco_, #14
09760     99 6F 03 F1 |                 add     _usb_h_fs_nco_, _12Mbps_
09764     01 70 07 F6 |                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
09768     0E 70 67 F0 |                 shl     _usb_d_fs_nco_, #14
0976c     99 71 03 F1 |                 add     _usb_d_fs_nco_, _12Mbps_
09770     99 35 03 F6 |                 mov     _1_5Mbps_, _12Mbps_
09774     03 34 47 F0 |                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
09778     02 6A 07 F6 |                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
0977c     0E 6A 67 F0 |                 shl     _usb_h_ls_nco_, #14
09780     9A 6B 03 F1 |                 add     _usb_h_ls_nco_, _1_5Mbps_
09784     9A 6D 03 F6 |                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
09788     80 00 00 FF 
0978c     00 58 06 FD |                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
09790     18 2E 63 FD |                 getqx   _var_64_lower_
09794     19 30 63 FD |                 getqy   _var_64_upper_
09798     28 2E 63 FD |                 setq    _var_64_lower_
0979c     65 CD 1D FF 
097a0     00 30 27 FD |                 qfrac   _var_64_upper_, ##_1b
097a4     18 36 63 FD |                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
097a8     01 00 00 FF 
097ac     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
097b0     18 2E 63 FD |                 getqx   _var_64_lower_
097b4     19 30 63 FD |                 getqy   _var_64_upper_
097b8     28 2E 63 FD |                 setq    _var_64_lower_
097bc     A1 07 00 FF 
097c0     40 30 27 FD |                 qfrac   _var_64_upper_, ##_1m
097c4     18 38 63 FD |                 getqx   _1us_                           ' 1us as 32,9 fixed point
097c8     9C 7D 03 F6 |                 mov     hsave0, _1us_                   ' Save it to compute other us values
097cc     09 38 57 F0 |                 shr     _1us_, #9               wc
097d0     00 38 27 F1 |                 addx    _1us_, #0                       ' Round to final value
097d4     0A 7C 07 FD |                 qmul    hsave0, #10                     ' Calc 10us
097d8     18 3A 63 FD |                 getqx   _10us_
097dc     09 3A 57 F0 |                 shr     _10us_, #9              wc
097e0     00 3A 27 F1 |                 addx    _10us_, #0                      ' 10us
097e4     21 7C 07 FD |                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
097e8     18 3C 63 FD |                 getqx   _33us_
097ec     09 3C 57 F0 |                 shr     _33us_, #9              wc
097f0     00 3C 27 F1 |                 addx    _33us_, #0                      ' 33us
097f4     FA 7C 07 FD |                 qmul    hsave0, #250                    ' Calc 250us
097f8     18 3E 63 FD |                 getqx   _txn_err_
097fc     09 3E 57 F0 |                 shr     _txn_err_, #9           wc
09800     00 3E 27 F1 |                 addx    _txn_err_, #0                   ' 250us
09804     F4 7D 07 FD |                 qmul    hsave0, #500                    ' Calc 500us
09808     18 40 63 FD |                 getqx   _500us_
0980c     09 40 57 F0 |                 shr     _500us_, #9             wc
09810     00 40 27 F1 |                 addx    _500us_, #0                     ' 500us
09814     01 00 00 FF 
09818     9A 7C 07 FD |                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
0981c     18 42 63 FD |                 getqx   _txn_ok_ls_
09820     09 42 57 F0 |                 shr     _txn_ok_ls_, #9         wc
09824     00 42 27 F1 |                 addx    _txn_ok_ls_, #0                 ' 666us
09828     01 00 00 FF 
0982c     52 7D 07 FD |                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
09830     18 44 63 FD |                 getqx   _txn_ok_fs_
09834     09 44 57 F0 |                 shr     _txn_ok_fs_, #9         wc
09838     00 44 27 F1 |                 addx    _txn_ok_fs_, #0                 ' 850us
0983c     9B 47 03 F6 |                 mov     _ip_delay_ls_, _1ns16fp_
09840     05 00 00 FF 
09844     80 46 07 FA |                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
09848     10 46 57 F0 |                 shr     _ip_delay_ls_, #16      wc
0984c     00 46 27 F1 |                 addx    _ip_delay_ls_, #0
09850     9B 4B 03 F6 |                 mov     _tat_wait_ls_, _1ns16fp_
09854     1C 00 00 FF 
09858     C0 4B 07 FA |                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
0985c     10 4A 57 F0 |                 shr     _tat_wait_ls_, #16      wc
09860     00 4A 27 F1 |                 addx    _tat_wait_ls_, #0
09864     9B 49 03 F6 |                 mov     _ip_delay_fs_, _1ns16fp_
09868     00 00 00 FF 
0986c     4E 49 07 FA |                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
09870     10 48 57 F0 |                 shr     _ip_delay_fs_, #16      wc
09874     00 48 27 F1 |                 addx    _ip_delay_fs_, #0
09878     9B 4D 03 F6 |                 mov     _tat_wait_fs_, _1ns16fp_
0987c     04 00 00 FF 
09880     23 4D 07 FA |                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
09884     10 4C 57 F0 |                 shr     _tat_wait_fs_, #16      wc
09888     00 4C 27 F1 |                 addx    _tat_wait_fs_, #0
0988c     8D 5B 00 FF 
09890     00 59 16 FD |                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
09894     18 4E 63 FD |                 getqx   _preamble_wait_
09898     08 4E 87 F1 |                 sub     _preamble_wait_,# 9 - 1
0989c     01 00 00 FF 
098a0     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
098a4     18 2E 63 FD |                 getqx   _var_64_lower_
098a8     19 30 63 FD |                 getqy   _var_64_upper_
098ac     28 2E 63 FD |                 setq    _var_64_lower_
098b0     01 00 00 FF 
098b4     E8 31 27 FD |                 qfrac   _var_64_upper_, ##_1thou
098b8     18 50 63 FD |                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
098bc     09 50 57 F0 |                 shr     _1ms_, #9               wc
098c0     00 50 27 F1 |                 addx    _1ms_, #0                       ' 1ms
098c4     FF FF 7F FF 
098c8     F2 69 07 F6 |                 mov     _frame1ms_clks_, ##-14
098cc     A8 69 43 F1 |                 adds    _frame1ms_clks_, _1ms_
098d0     A8 53 03 F6 |                 mov     _2ms_, _1ms_
098d4     01 52 67 F0 |                 shl     _2ms_, #1                       ' 2ms
098d8     A8 55 03 F6 |                 mov     _suspend_wait_, _1ms_
098dc     A8 55 03 F1 |                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
098e0     A8 57 03 F6 |                 mov     _4ms_, _1ms_
098e4     02 56 67 F0 |                 shl     _4ms_, #2                       ' 4ms
098e8     AB 59 03 F6 |                 mov     _xfer_wait_, _4ms_
098ec     A8 59 03 F1 |                 add     _xfer_wait_, _1ms_              ' 5ms
098f0     AC 5D 03 F6 |                 mov     _reset_hold_, _xfer_wait_       ' 5ms
098f4     AE 5F 03 F6 |                 mov     _resume_hold_, _reset_hold_
098f8     02 5E 67 F0 |                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
098fc     AF 63 03 F6 |                 mov     _100ms_, _resume_hold_          ' 20ms
09900     01 62 67 F0 |                 shl     _100ms_, #1                     ' 40ms
09904     A8 5B 03 F6 |                 mov     _8ms_, _1ms_
09908     03 5A 67 F0 |                 shl     _8ms_, #3                       ' 8ms
0990c     01 5C 67 F0 |                 shl     _reset_hold_, #1                ' 10ms
09910     AE 63 03 F1 |                 add     _100ms_, _reset_hold_           ' 50ms
09914     AC 5D 03 F1 |                 add     _reset_hold_, _xfer_wait_       ' 15ms
09918     AC 61 03 F6 |                 mov     _21ms_, _xfer_wait_             ' 5ms
0991c     02 60 67 F0 |                 shl     _21ms_, #2                      ' 20ms
09920     A8 61 03 F1 |                 add     _21ms_, _1ms_                   ' 21ms
09924     B1 65 03 F6 |                 mov     _500ms_, _100ms_                ' 50ms
09928     01 62 67 F0 |                 shl     _100ms_, #1                     ' 100ms
0992c     03 64 67 F0 |                 shl     _500ms_, #3                     ' 400ms
09930     B1 65 03 01 |         _ret_   add     _500ms_, _100ms_                ' 500ms
09934                 | '        _ret_   mov     _1sec_, save_sysclk
09934                 | '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
09934                 | '                ret
09934                 | {
09934                 | }
09934                 | 
09934                 | '------------------------------------------------------------------------------
09934                 | ' Parse a configuration descriptor chain to see if the device is a recognized
09934                 | ' one. If it is, start the task progression that will configure the device for
09934                 | ' use.
09934                 | '------------------------------------------------------------------------------
09934                 | ' On entry:
09934                 | '   hconfig_base - start address of the cached config descriptor chain.
09934                 | ' On exit:
09934                 | '------------------------------------------------------------------------------
09934                 | hparse_con_desc
09934     28 F3 03 F6 |                 mov     ptrb, dev_desc_buff_p
09938     82 73 07 FB |                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
0993c     61 5B 86 F9 |                 altr    hdev_port,#hdev_id
09940     4E 72 FF F9 |                 movbyts htmp,#%%1032
09944     86 D3 E6 FA |                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
09948                 |                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
09948                 | 
09948     02 EC 07 F6 |                 mov     pa, #CON_wTotalLen
0994c     6E ED 03 F1 |                 add     pa, hconfig_base
09950     F6 DF E2 FA |                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
09954                 |                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
09954                 | ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
09954                 | ' that defines a keyboard and/or mouse.
09954     6E EB C2 FA |                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
09958                 | .next_intf
09958     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
0995c     B8 01 90 3D |         if_ae   jmp     #hset_config
09960     6E F3 03 F6 |                 mov     ptrb, hconfig_base
09964     75 F3 03 F1 |                 add     ptrb, hnext_desc
09968     81 73 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
0996c     04 72 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
09970     0C 00 90 AD |         if_z    jmp     #.intf
09974     80 73 C7 FA |                 rdbyte  htmp, ptrb
09978     B9 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
0997c     D8 FF 9F FD |                 jmp     #.next_intf
09980                 | .intf
09980     00 90 07 F6 |                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
09984     00 92 07 F6 |                 mov     hpar3, #0
09988     82 E1 C6 FA |                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
0998c     85 E3 C6 FA |                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
09990     86 E5 C6 FA |                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
09994     87 E7 C6 FA |                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
09998                 |                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
09998                 | 
09998                 | .endp
09998     80 73 C7 FA |                 rdbyte  htmp, ptrb
0999c     B9 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
099a0     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
099a4     78 00 90 3D |         if_ae   jmp     #.get_device
099a8     6E F3 03 F6 |                 mov     ptrb, hconfig_base
099ac     75 F3 03 F1 |                 add     ptrb, hnext_desc
099b0     81 73 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
099b4     04 72 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
099b8     64 00 90 AD |         if_z    jmp     #.get_device
099bc     05 72 0F F2 |                 cmp     htmp, #TYPE_ENDPOINT    wz
099c0     04 00 90 AD |         if_z    jmp     #.get_ep
099c4     D0 FF 9F FD |                 jmp     #.endp
099c8                 | .get_ep
099c8     82 89 C7 FA |                 rdbyte  hr1, ptrb[ENDP_bAddress]
099cc     07 88 17 F4 |                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
099d0     0F 88 67 F0 |                 shl     hr1, #8 + 7
099d4     6C 73 03 F6 |                 mov     htmp, hctrl_ep_addr
099d8     3F 00 00 FF 
099dc     00 73 07 F5 |                 and     htmp, ##ADDR_MASK
099e0     C4 73 43 F5 |                 or      htmp, hr1                       ' endpoint address
099e4     00 90 0F F2 |                 cmp     hpar2, #0               wz
099e8     0C 00 90 8D |  if_z_and_c     jmp     #.in_ep
099ec     00 92 0F F2 |                 cmp     hpar3, #0               wz
099f0     18 00 90 2D |  if_z_and_nc    jmp     #.out_ep
099f4     A0 FF 9F FD |                 jmp     #.endp
099f8                 | .in_ep
099f8     B9 91 03 F6 |                 mov     hpar2, htmp                     ' IN endpoint
099fc     84 8B C7 FA |                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
09a00                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
09a00     86 87 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
09a04     C3 8B DB F8 |                 setbyte hr2, hr0, #3
09a08     8C FF 9F FD |                 jmp     #.endp
09a0c                 | .out_ep
09a0c     B9 93 03 F6 |                 mov     hpar3, htmp                     ' OUT endpoint
09a10     84 8D C7 FA |                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
09a14                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
09a14     86 87 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
09a18     C3 8D DB F8 |                 setbyte hr3, hr0, #3
09a1c     78 FF 9F FD |                 jmp     #.endp
09a20                 | 
09a20                 | .get_device
09a20     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
09a24     5D E4 0E A2 |         if_z    cmp     hdev_subclass, #$5D     wz
09a28     01 E6 0E A2 |         if_z    cmp     hdev_protocol, #$01     wz
09a2c     64 00 90 AD |         if_z    jmp     #.gamepad
09a30     09 E2 0E F2 |                 cmp     hdev_class, #CLASS_HUB  wz
09a34     A8 00 90 AD |         if_z    jmp     #.hub
09a38     03 E2 0E F2 |                 cmp     hdev_class, #CLASS_HID              wz
09a3c     18 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No HID class, ignore
09a40     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
09a44     4C 00 90 AD |         if_z    jmp     #.gamepad
09a48     01 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
09a4c     08 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
09a50                 | .keyboard
09a50     01 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
09a54                 |         if HAVE_MOUSE
09a54     1C 00 90 5D |         if_nz  jmp      #.mouse                         ' No Keyboard
09a58                 |         else
09a58                 |         end
09a58     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0    wz
09a5c     F8 FE 9F 5D |         if_nz   jmp     #.next_intf
09a60     70 6F E2 F8 |                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
09a64     C5 71 FA F8 |                 getbyte kb_interval, hr2, #3
09a68     C5 73 E2 F8 |                 getbyte kb_in_max_pkt, hr2, #0
09a6c     C8 F3 02 F6 |                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
09a70                 |                 'debug(udec(kb_intf_num))
09a70                 |                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
09a70     E4 FE 9F FD |                 jmp     #.next_intf
09a74                 | if HAVE_MOUSE
09a74                 | .mouse
09a74     02 E6 0E F2 |                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
09a78     DC FE 9F 5D |         if_nz   jmp     #.next_intf                     ' No Mouse
09a7c     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0      wz
09a80     D4 FE 9F 5D |         if_nz   jmp     #.next_intf
09a84     70 6B E2 F8 |                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
09a88                 |                 'getbyte ms_interval, hr2, #3
09a88     C5 6D E2 F8 |                 getbyte ms_in_max_pkt, hr2, #0
09a8c     C8 F5 02 F6 |                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
09a90                 |                 'debug(udec(kb_intf_num))
09a90                 |                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
09a90     C4 FE 9F FD |                 jmp     #.next_intf
09a94                 | end
09a94                 | .gamepad
09a94     79 73 03 F6 |                 mov     htmp, hkbd_ep_addr
09a98     C8 73 63 F5 |                 xor     htmp, hpar2
09a9c     3F 00 00 FF 
09aa0     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
09aa4     B0 FE 9F AD |         if_z    jmp     #.next_intf
09aa8                 |         if HAVE_MOUSE
09aa8     7A 73 03 F6 |                 mov     htmp, hmouse_ep_addr
09aac     C8 73 63 F5 |                 xor     htmp, hpar2
09ab0     3F 00 00 FF 
09ab4     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
09ab8     9C FE 9F AD |         if_z    jmp     #.next_intf
09abc                 |         end
09abc     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
09ac0     00 00 0C F2 |                 cmp     0-0, #0                 wz      ' |
09ac4     90 FE 9F 5D |         if_nz   jmp     #.next_intf
09ac8                 | 
09ac8     70 79 E2 F8 |                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
09acc     C5 7B FA F8 |                 getbyte gp_interval, hr2, #3
09ad0     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
09ad4     C8 01 00 F6 |                 mov     0-0, hpar2                      ' IN endpoint address
09ad8     C9 0B 03 F6 |                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
09adc                 |                 'debug(udec(gp_intf_num))
09adc                 |                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
09adc     78 FE 9F FD |                 jmp     #.next_intf
09ae0                 | .hub
09ae0     00 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
09ae4     70 FE 9F 5D |         if_nz   jmp     #.next_intf
09ae8     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
09aec     02 E6 0E 52 |         if_nz   cmp     hdev_protocol, #2                   wz
09af0     64 FE 9F 5D |         if_nz   jmp     #.next_intf
09af4     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
09af8     5C FE 9F 5D |         if_nz   jmp     #.next_intf
09afc     70 63 E2 F8 |                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
09b00     6C ED 02 F6 |                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
09b04     C8 BD 02 F6 |                 mov     ep_addr_pid, hpar2              ' IN endpoint address
09b08     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
09b0c     5E EF 02 F6 |                 mov     hhub_ep_addr, ep_addr_pid
09b10     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
09b14                 |                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
09b14     40 FE 9F FD |                 jmp     #.next_intf
09b18                 | 
09b18                 | '------------------------------------------------------------------------------
09b18                 | ' If a newly-connected device is recognized, do whatever is needed to configure
09b18                 | ' it according to its function, or functions. In the case of this boot protocol
09b18                 | ' keyboard/mouse class driver:
09b18                 | ' - SetConfiguration(config_num)
09b18                 | ' - SetProtocol(boot)
09b18                 | ' - SetIdle(indefinite)
09b18                 | ' - Enter the device interrupt IN polling task stage.
09b18                 | '------------------------------------------------------------------------------
09b18                 | ' On entry:
09b18                 | ' On exit:
09b18                 | '------------------------------------------------------------------------------
09b18                 | hset_config
09b18                 | '                mov     hkbd_ep_addr, #0                ' DEBUG
09b18                 | '                mov     hmouse_ep_addr, #0              ' DEBUG
09b18     02 76 07 F6 |                 mov     htmp2, #DEV_UNKNOWN
09b1c     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
09b20     00 00 0C F2 |                 cmp     0-0, #0                 wz
09b24     00 F2 0E A2 |         if_z    cmp     hkbd_ep_addr, #0        wz
09b28                 |         if HAVE_MOUSE
09b28     00 F4 0E A2 |         if_z    cmp     hmouse_ep_addr, #0      wz
09b2c                 |         end
09b2c     00 EE 0E A2 |         if_z    cmp     hhub_ep_addr, #0        wz
09b30     60 03 90 AD |         if_z    jmp     #.notify_client                 ' No known device
09b34                 | .set_config
09b34     74 0E D0 FE |                 loc     ptra, #set_config
09b38     05 EC 07 F6 |                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
09b3c     6E ED 03 F1 |                 add     pa, hconfig_base
09b40     F6 8F C3 FA |                 rdbyte  hpar1, pa
09b44                 |                 debug("SetConfiguration: ",udec_(hpar1))
09b44     01 8F 57 FC |                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
09b48     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
09b4c     00 EE 07 F6 |                 mov     pb, #0                          ' SetConfiguration() has no data stage
09b50     A0 02 A0 FD |                 call    #control_write
09b54     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09b58     2D 00 64 5D |         if_nz   ret
09b5c                 | .kbd_config
09b5c     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0        wz
09b60     98 00 90 AD |         if_z    jmp     #.mouse_config                  ' No keyboard
09b64                 | 
09b64     79 73 03 F6 |                 mov     htmp, hkbd_ep_addr
09b68     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
09b6c     3F 00 00 FF 
09b70     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
09b74     84 00 90 5D |         if_nz   jmp     #.mouse_config                  ' No keyboard
09b78                 | 
09b78     37 73 E3 F8 |                 getbyte htmp, kb_intf_num, #0
09b7c     3C 0E D0 FE |                 loc     ptra, #set_protocol
09b80     01 01 5C FC |                 wrword  #BOOT_PROTOCOL, ptra[wValue]
09b84     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
09b88     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
09b8c     A0 02 A0 FD |                 call    #control_write
09b90     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09b94     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
09b98     F8 02 90 5D |         if_nz   jmp     #.notify_client
09b9c     00 8E 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
09ba0     37 91 E3 F8 |                 getbyte hpar2, kb_intf_num, #0
09ba4     44 03 B0 FD |                 call    #hset_idle
09ba8                 |                 'cmp     retval, #PID_ACK        wz
09ba8                 |         'if_nz   mov     hkbd_ep_addr, #0
09ba8                 |         'if_nz   jmp     #.notify_client
09ba8     A9 99 02 F6 |                 mov     hctwait, _2ms_
09bac     EF 02 A0 FD |                 call    #poll_waitx
09bb0     00 76 06 F6 |                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
09bb4                 |         if NUMLOCK_DEFAULT_STATE && RPI_KEYBOARD_NUMLOCK_HACK
09bb4                 |         end
09bb4     3B F9 02 F6 |                 mov     hkbd_ledstates, kb_led_states
09bb8     A0 17 90 FE |                 loc     pa, #hkbd_led_rep
09bbc     F6 F9 42 FC |                 wrbyte  hkbd_ledstates,pa
09bc0     40 03 B0 FD |                 call    #hset_kbdled_report
09bc4     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09bc8     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
09bcc     C4 02 90 5D |         if_nz   jmp     #.notify_client
09bd0     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
09bd4     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
09bd8     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
09bdc     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
09be0     5E F3 02 F6 |                 mov     hkbd_ep_addr, ep_addr_pid
09be4     6C F1 02 F6 |                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
09be8     1F F0 46 F4 |                 bitc    hkbd_ctrl_ep, #31
09bec     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
09bf0     00 F6 06 F6 |                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
09bf4     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
09bf8     03 76 07 F6 |                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
09bfc                 |         if !!HAVE_MOUSE
09bfc                 |         end
09bfc                 | 
09bfc                 | .mouse_config
09bfc                 | if HAVE_MOUSE
09bfc     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0        wz
09c00     AC 00 90 AD |         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
09c04     7A 73 03 F6 |                 mov     htmp, hmouse_ep_addr
09c08     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
09c0c     3F 00 00 FF 
09c10     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
09c14     98 00 90 5D |         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
09c18                 | 
09c18                 |                 debug("mouse passed addr check")
09c18                 | 
09c18     B8 0D D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
09c1c     00 00 80 FF 
09c20     03 01 5E FC |                 wrword  ##HID_DESCR_LEN, ptra[wLength]
09c24     02 6B 56 FC |                 wrword  ms_intf_num,ptra[wIndex]
09c28     1B 01 A0 FD |                 call    #get_hid_descr_buffer
09c2c     55 02 A0 FD |                 call    #control_read
09c30     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09c34     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
09c38     58 02 90 5D |         if_nz   jmp     #.notify_client
09c3c     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
09c40     56 01 00 F6 |                 mov     0-0, total_data
09c44     1B 01 A0 FD |                 call    #get_hid_descr_buffer
09c48                 |                 debug(uhex(pb),uhex_byte_array(pb,total_data))
09c48                 | 
09c48     35 73 E3 F8 |                 getbyte htmp, ms_intf_num, #0
09c4c     6C 0D D0 FE |                 loc     ptra, #set_protocol
09c50     01 03 5C FC |                 wrword  #MOUSE_FULL_PROTOCOL ? REPORT_PROTOCOL : BOOT_PROTOCOL, ptra[wValue]
09c54     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
09c58     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
09c5c     A0 02 A0 FD |                 call    #control_write
09c60     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09c64     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
09c68     28 02 90 5D |         if_nz   jmp     #.notify_client
09c6c                 |                 debug("mouse passed SetProtocol")
09c6c     00 8E 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
09c70     35 91 E3 F8 |                 getbyte hpar2, ms_intf_num, #0
09c74     74 02 B0 FD |                 call    #hset_idle
09c78                 |                 'cmp     retval, #PID_ACK        wz
09c78                 |         'if_nz   mov     hmouse_ep_addr, #0
09c78                 |         'if_nz   jmp     #.notify_client
09c78                 |                 debug("mouse passed SetIdle")
09c78     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
09c7c     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
09c80     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
09c84     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
09c88     5E F5 02 F6 |                 mov     hmouse_ep_addr, ep_addr_pid
09c8c     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
09c90     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
09c94     79 77 03 F6 |                 mov     htmp2, hkbd_ep_addr
09c98     7A 77 63 F5 |                 xor     htmp2, hmouse_ep_addr
09c9c     3F 00 00 FF 
09ca0     00 77 0F F5 |                 and     htmp2, ##ADDR_MASK              wz
09ca4     05 76 07 A6 |         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
09ca8     04 76 07 56 |         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
09cac     E4 01 90 FD |                 jmp     #.notify_client
09cb0                 | end
09cb0                 | .gamepad_config
09cb0                 | if _HAVE_GAMEPAD
09cb0     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
09cb4     00 00 0C F2 |                 cmp     0-0, #0                 wz
09cb8     6C 01 90 AD |         if_z    jmp     #.hub_config                    ' No gamepad
09cbc     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
09cc0     00 72 03 F6 |                 mov     htmp, 0-0
09cc4     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
09cc8     3F 00 00 FF 
09ccc     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
09cd0     54 01 90 5D |         if_nz   jmp     #.hub_config                    ' No gamepad
09cd4                 | 
09cd4     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
09cd8     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
09cdc     69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
09ce0     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
09ce4     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
09ce8     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
09cec     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
09cf0     5E 01 00 F6 |                 mov     0-0, ep_addr_pid
09cf4     85 BD 0A F6 |                 mov     ep_addr_pid, hdev_out_addr  wz
09cf8     E1 BC C6 58 |         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
09cfc     BE 00 A0 5D |         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
09d00     09 68 16 54 |         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
09d04     1F BC 46 54 |         if_nz   bitc    ep_addr_pid, #31
09d08     5E 0B 03 56 |         if_nz   mov     hdev_out_addr, ep_addr_pid
09d0c     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
09d10                 | 
09d10                 |                 if EMUPAD_MAX_PLAYER > 0
09d10                 |                 
09d10                 | .rule_loop           
09d10                 |                 end
09d10                 | 
09d10     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
09d14     5C 00 90 AD |         if_e    jmp     #.xinput
09d18     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
09d1c     00 72 03 F6 |                 mov     htmp,0-0
09d20     01 A6 02 FF 
09d24     68 72 0F F2 |                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
09d28     8C 00 90 AD |         if_e    jmp     #.ps3
09d2c                 | 
09d2c     A4 0C D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
09d30     00 5A 0E F2 |                 cmp     hdev_port,#0            wz
09d34     00 00 80 5F 
09d38     03 01 5E 5C |         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
09d3c     03 00 80 AF 
09d40     03 01 5E AC |         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
09d44     02 01 5C FC |                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
09d48     1B 01 A0 FD |                 call    #get_hid_descr_buffer
09d4c     55 02 A0 FD |                 call    #control_read
09d50     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09d54     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
09d58     00 00 04 56 |         if_nz   mov     0-0, #0
09d5c     34 01 90 5D |         if_nz   jmp     #.notify_client
09d60     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
09d64     56 01 00 F6 |                 mov     0-0, total_data
09d68     1B 01 A0 FD |                 call    #get_hid_descr_buffer
09d6c                 |                 debug(uhex(pb),udec(total_data),uhex_byte_array(pb,total_data))
09d6c                 | 
09d6c     06 76 07 F6 |                 mov     htmp2, #HID_READY               ' Standard gamepad
09d70     20 01 90 FD |                 jmp     #.notify_client
09d74                 | .xinput
09d74     B8 0C D0 FE |                 loc     ptra, #xinp_led_cmd             ' Turn on LED
09d78     2D EF 03 F6 |                 mov     pb,hdev_port
09d7c     01 EE E7 F2 |                 cmpsub  pb,#1 ' root device is also player 1
09d80     03 EE 27 F3 |                 fle     pb,#3
09d84     06 EE 07 F1 |                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
09d88     02 EF 47 FC |                 wrbyte  pb, ptra[2]
09d8c                 | 
09d8c     03 B0 06 F6 |                 mov     pkt_data, #3
09d90     03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB
09d94     85 BD 02 F6 |                 mov     ep_addr_pid, hdev_out_addr
09d98                 |                 debug("XInput LED set ",uhex_long(ep_addr_pid),uhex_byte(pb))
09d98     5A 00 A0 FD |                 call    #txn_out
09d9c     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr
09da0                 | 
09da0     97 0C D0 FE |                 loc     ptra, #xinp_fix_8bitdo
09da4     27 EF 03 F6 |                 mov     pb, urx_buff_p          ' We don't actually care where it goes
09da8     55 02 A0 FD |                 call    #control_read           ' Execute GetDeviceDescriptor()
09dac                 |                 debug("8bitdo weird fix... ",uhex(retval))
09dac     D2 BE 06 F6 |                 mov retval,#PID_ACK             ' If we don't do this something else becomes sad (TODO fix?)
09db0                 | 
09db0                 | 
09db0     07 76 07 F6 |                 mov     htmp2, #XINPUT_READY
09db4     DC 00 90 FD |                 jmp     #.notify_client
09db8                 | .ps3
09db8     44 0C D0 FE |                 loc     ptra, #ps3_command_buff         ' Turn on LED
09dbc     2D EF 03 F6 |                 mov     pb,hdev_port
09dc0     01 EE 07 F3 |                 fge     pb,#1 ' root device is also player 1
09dc4     04 EE 27 F3 |                 fle     pb,#4
09dc8     F7 EF C3 F9 |                 decod   pb
09dcc     09 EF 47 FC |                 wrbyte  pb, ptra[9]
09dd0                 | 
09dd0     3C 73 E3 F8 |                 getbyte htmp, gp_intf_num, #0
09dd4     F4 0B D0 FE |                 loc     ptra, #set_report
09dd8     01 00 80 FF 
09ddc     01 03 5C FC |                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
09de0     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
09de4     03 61 5C FC |                 wrword  #48, ptra[wLength]
09de8     14 0C B0 FE |                 loc     pb, #ps3_command_buff
09dec     A0 02 A0 FD |                 call    #control_write
09df0                 | 
09df0     3C 73 E3 F8 |                 getbyte htmp, gp_intf_num, #0
09df4     D4 0B D0 FE |                 loc     ptra, #set_report
09df8     01 00 80 FF 
09dfc     01 E9 5F FC |                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
09e00     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
09e04     03 09 5C FC |                 wrword  #4, ptra[wLength]
09e08     F0 0B B0 FE |                 loc     pb, #ps3_enable_cmd             ' Enable PS3
09e0c     A0 02 A0 FD |                 call    #control_write
09e10     D2 BE 0E F2 |                 cmp     retval, #PID_ACK    wz
09e14     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
09e18     00 00 04 56 |         if_nz   mov     0-0, #0
09e1c     74 00 90 5D |         if_nz   jmp     #.notify_client
09e20                 | 
09e20     08 76 07 F6 |                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
09e24     6C 00 90 FD |                 jmp     #.notify_client
09e28                 | end
09e28                 | 
09e28                 | .hub_config
09e28     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
09e2c     64 00 90 AD |         if_z    jmp     #.notify_client                 ' No HUB
09e30     77 73 03 F6 |                 mov     htmp, hhub_ep_addr
09e34     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
09e38     3F 00 00 FF 
09e3c     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
09e40     50 00 90 5D |         if_nz   jmp     #.notify_client                 ' No HUB
09e44                 | 
09e44     94 0B D0 FE |                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
09e48     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]
09e4c     26 EF 03 F6 |                 mov     pb, hub_descr_p
09e50     55 02 A0 FD |                 call    #control_read
09e54     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09e58     00 EE 06 56 |         if_nz   mov     hhub_ep_addr, #0
09e5c     34 00 90 5D |         if_nz   jmp     #.notify_client
09e60                 |                 debug(uhex_byte_array(hub_descr_p,total_data))
09e60                 | 
09e60     26 F1 03 F6 |                 mov     ptra, hub_descr_p
09e64     02 79 C7 FA |                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
09e68     07 78 27 F3 |                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
09e6c                 |                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
09e6c                 | .pwr_loop
09e6c     74 0B D0 FE |                 loc     ptra, #set_port_feat            ' Power on ports
09e70     01 11 5C FC |                 wrword  #HUB_PORT_POWER, ptra[wValue]
09e74     02 79 57 FC |                 wrword  htmp3, ptra[wIndex]
09e78     A0 02 A0 FD |                 call    #control_write
09e7c     FB 79 6F FB |                 djnz    htmp3, #.pwr_loop
09e80                 | 
09e80     B2 99 02 F6 |                 mov     hctwait, _500ms_
09e84     B1 99 02 F1 |                 add     hctwait, _100ms_
09e88     EF 02 A0 FD |                 call    #poll_waitx
09e8c                 | 
09e8c     09 76 07 F6 |                 mov     htmp2, #HUB_READY               ' Hub ready
09e90     00 00 90 FD |                 jmp     #.notify_client
09e94                 | 
09e94                 | .notify_client
09e94     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
09e98     BB 01 C0 F8 |                 setbyte htmp2                           ' Save device ready
09e9c                 |                 debug(uhex_long(hdev_type,hdev_type+1))
09e9c                 |         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
09e9c     2D 00 64 FD |                 ret
09ea0                 | 
09ea0                 | '------------------------------------------------------------------------------
09ea0                 | ' Initialize the keyboard/mouse data area to start-up values.
09ea0                 | '------------------------------------------------------------------------------
09ea0                 | ' On entry:
09ea0                 | ' On exit:
09ea0                 | '------------------------------------------------------------------------------
09ea0                 | init_kbdm_data
09ea0     00 F2 06 F6 |                 mov     hkbd_ep_addr, #0
09ea4     00 FA 06 F6 |                 mov     hdev_ep_addr, #0
09ea8                 | 
09ea8     2A F1 03 F6 |                 mov     ptra, cache_start_p         ' Clear cached data buffers
09eac     2B ED 03 F6 |                 mov     pa, cache_end_p
09eb0                 | .loop
09eb0     61 01 4C FC |                 wrbyte  #0, ptra++
09eb4     F6 F1 1B F2 |                 cmp     ptra, pa                wcz
09eb8     F4 FF 9F CD |         if_b    jmp     #.loop
09ebc                 |         
09ebc                 |         if EMUPAD_MAX_PLAYER > 0
09ebc                 |         end
09ebc                 | 
09ebc                 | 
09ebc     2D ED 07 F6 |                 mov     pa, #hdev_init_start        ' Clear device data registers
09ec0                 | .regloop
09ec0     00 EC 8F F9 |                 altd    pa
09ec4     00 00 04 F6 |                 mov     0-0, #0
09ec8     01 EC 07 F1 |                 add     pa, #1
09ecc     47 ED 0F F2 |                 cmp     pa, #hdev_init_end      wz
09ed0     EC FF 9F 5D |         if_nz   jmp     #.regloop
09ed4                 | 
09ed4     E1 E1 61 FF 
09ed8     C3 5D 06 F6 |                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
09edc     2E 5F 02 F6 |                 mov     hdev_next_datax + 1,hdev_next_datax
09ee0     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0
09ee4     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1
09ee8                 | 
09ee8     C3 64 06 06 |         _ret_   mov     hub_next_datax, #PID_DATA0
09eec                 | 
09eec                 | '------------------------------------------------------------------------------
09eec                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
09eec                 | ' function.
09eec                 | '------------------------------------------------------------------------------
09eec                 | ' On entry:
09eec                 | '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
09eec                 | '   hpar2 - index number of the target interface.
09eec                 | ' On exit:
09eec                 | '------------------------------------------------------------------------------
09eec                 | hset_idle
09eec     A9 99 02 F6 |                 mov     hctwait, _2ms_
09ef0     EF 02 A0 FD |                 call    #poll_waitx
09ef4     CC 0A D0 FE |                 loc     ptra, #set_idle
09ef8     01 8F 57 FC |                 wrword  hpar1, ptra[wValue]
09efc     02 91 57 FC |                 wrword  hpar2, ptra[wIndex]
09f00     A0 02 80 FD |                 jmp     #control_write
09f04                 | 
09f04                 | '------------------------------------------------------------------------------
09f04                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
09f04                 | ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
09f04                 | '------------------------------------------------------------------------------
09f04                 | ' On entry:
09f04                 | '   ep_addr_pid - device address and enpoint for the request.
09f04                 | ' On exit:
09f04                 | '   retval - transaction result.
09f04                 | '------------------------------------------------------------------------------
09f04                 | hset_kbdled_report
09f04     37 73 E3 F8 |                 getbyte htmp, kb_intf_num, #0
09f08     C0 0A D0 FE |                 loc     ptra, #set_report
09f0c     01 00 80 FF 
09f10     01 01 5C FC |                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
09f14     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
09f18     03 03 5C FC |                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
09f1c     27 EF 03 F6 |                 mov     pb, urx_buff_p
09f20     F7 77 42 FC |                 wrbyte  kb_led_states, pb
09f24     A0 02 80 FD |                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
09f28                 | 
09f28                 | '------------------------------------------------------------------------------
09f28                 | ' Execute an IN interrupt transaction to poll for keyboard activity.
09f28                 | '------------------------------------------------------------------------------
09f28                 | ' On entry:
09f28                 | ' On exit:
09f28                 | '------------------------------------------------------------------------------
09f28                 | hget_kbd_in_report
09f28     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
09f2c     27 91 03 F6 |                 mov     hpar2, urx_buff_p
09f30     30 93 E3 F8 |                 getbyte hpar3, kbm_next_datax, #0
09f34     39 93 2B F9 |                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
09f38     CF 02 A0 FD |                 call    #do_int_in
09f3c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
09f40     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
09f44                 | 
09f44     00 92 0F F2 |                 cmp     hpar3, #0               wz
09f48     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
09f4c                 | 
09f4c     30 73 E3 F8 |                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
09f50     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
09f54     4B 60 C6 A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
09f58     C3 60 C6 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
09f5c                 | 
09f5c     C9 75 02 F6 |                 mov     kb_max_index, hpar3             ' Save actual bytes read
09f60     18 00 B0 FD |                 call    #hkbd_compare
09f64                 |         if EMUPAD_MAX_PLAYER > 0
09f64                 |         end
09f64                 | 
09f64                 | .led_check
09f64     3B 73 03 F6 |                 mov     htmp, kb_led_states
09f68     B9 F9 0A F2 |                 cmp     hkbd_ledstates, htmp    wz
09f6c     2D 00 64 AD |         if_z    ret                                     ' No toggle key indicator changes, so we're done
09f70     7C 77 02 F6 |                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
09f74     78 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ctrl_ep
09f78     88 FF 9F FD |                 jmp     #hset_kbdled_report             ' Set report and ignore errors
09f7c                 | 
09f7c                 | '------------------------------------------------------------------------------
09f7c                 | ' Compare current and previous keyboard data buffers for keypress changes.
09f7c                 | '------------------------------------------------------------------------------
09f7c                 | hkbd_compare
09f7c     27 F1 03 F6 |                 mov     ptra, urx_buff_p
09f80     D0 13 F0 FE |                 loc     ptrb, #hkbd_report
09f84     61 75 07 FB |                 rdlong  htmp1, ptra++
09f88     E1 77 07 FB |                 rdlong  htmp2, ptrb++
09f8c     BB 75 0B F2 |                 cmp     htmp1, htmp2    wz
09f90     61 75 07 FB |                 rdlong  htmp1, ptra++
09f94     E1 77 07 FB |                 rdlong  htmp2, ptrb++
09f98     BB 75 0B A2 |         if_z    cmp     htmp1, htmp2    wz
09f9c     2D 00 64 AD |         if_z    ret
09fa0                 | 
09fa0     B0 13 D0 FE |                 loc     ptra, #hkbd_report
09fa4                 | 
09fa4                 |                 ' Handle modifiers
09fa4     27 91 C3 FA |                 rdbyte  hpar2, urx_buff_p
09fa8     00 89 C7 FA |                 rdbyte  hr1, ptra
09fac     C8 89 43 F9 |                 rolword hr1,hpar2,#0
09fb0     63 88 63 FD |                 mergew  hr1
09fb4     08 EC 07 F6 |                 mov     pa,#8
09fb8                 | .modloop
09fb8     6A 88 7B FD |                 rczr    hr1     wcz ' New value in C, old value in Z
09fbc     E8 8E 07 F6 |                 mov     hpar1,#$E8
09fc0     F6 8F 83 F1 |                 sub     hpar1,pa
09fc4     A0 00 B0 6D |       if_c_ne_z call    #hkbd_translate
09fc8     FB ED 6F FB |                 djnz    pa,#.modloop
09fcc                 | 
09fcc     6F E0 75 FD | .release        modc    _set    wc
09fd0                 |                 'alts    hdev_port, #hid_report_p
09fd0                 |                 'mov     ptra, hid_report_p
09fd0     02 F0 07 F1 |                 add     ptra, #2
09fd4     06 EC 07 F6 |                 mov     pa, #6
09fd8     61 8F CF FA | .rl1            rdbyte  hpar1, ptra++   wz
09fdc     20 00 90 AD |         if_z    jmp     #.rl3
09fe0     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
09fe4     02 F2 07 F1 |                 add     ptrb, #2
09fe8     06 EE 07 F6 |                 mov     pb, #6
09fec     E1 73 C7 FA | .rl2            rdbyte  htmp, ptrb++
09ff0     B9 8F 0B F2 |                 cmp     hpar1, htmp     wz
09ff4     08 00 90 AD |         if_z    jmp     #.rl3
09ff8     FC EF 6F FB |                 djnz    pb, #.rl2
09ffc     68 00 B0 FD |                 call    #hkbd_translate
0a000     F5 ED 6F FB | .rl3            djnz    pa, #.rl1
0a004                 | 
0a004     00 92 07 F6 |                 mov     hpar3, #0
0a008     1F 92 27 F4 |                 bith    hpar3, #31
0a00c                 | 
0a00c     6F 00 74 FD | .press          modc    _clr    wc
0a010     27 F1 03 F6 |                 mov     ptra, urx_buff_p
0a014     02 F0 07 F1 |                 add     ptra, #2
0a018     06 EC 07 F6 |                 mov     pa, #6
0a01c     61 8F CF FA | .pl1            rdbyte  hpar1, ptra++   wz
0a020     20 00 90 AD |         if_z    jmp     #.pl3
0a024     2C 13 F0 FE |                 loc     ptrb, #hkbd_report
0a028     02 F2 07 F1 |                 add     ptrb, #2
0a02c     06 EE 07 F6 |                 mov     pb, #6
0a030     E1 73 C7 FA | .pl2            rdbyte  htmp, ptrb++
0a034     B9 8F 0B F2 |                 cmp     hpar1, htmp     wz
0a038     08 00 90 AD |         if_z    jmp     #.pl3
0a03c     FC EF 6F FB |                 djnz    pb, #.pl2
0a040     24 00 B0 FD |                 call    #hkbd_translate
0a044     F5 ED 6F FB | .pl3            djnz    pa, #.pl1
0a048                 | 
0a048     27 F1 03 F6 | .copy           mov     ptra, urx_buff_p
0a04c     04 13 F0 FE |                 loc     ptrb, #hkbd_report
0a050     28 02 64 FD |                 setq #1
0a054     61 75 07 FB |                 rdlong  htmp1, ptra++
0a058     28 02 64 FD |                 setq #1
0a05c     E1 75 67 FC |                 wrlong  htmp1, ptrb++
0a060     E1 F9 46 FC |                 wrbyte  hkbd_ledstates,ptrb++
0a064                 | 
0a064     2D 00 64 FD |                 ret
0a068                 | 
0a068                 | '------------------------------------------------------------------------------
0a068                 | ' Translate keyboard scancode to ASCII
0a068                 | '------------------------------------------------------------------------------
0a068                 | ' On entry:
0a068                 | '   hpar1 - scancode
0a068                 | '   hpar2 - key modifiers state
0a068                 | '       c - pressed (0) or released (1) flag
0a068                 | ' On exit:
0a068                 | '   hpar1 - bit     31 = 0 pressed, 1 released
0a068                 | '               30..17 = unused
0a068                 | '                   18 = scroll-lock state 
0a068                 | '                   17 = caps-lock state
0a068                 | '                   16 = num-lock state 
0a068                 | '                15..8 = key modifiers state
0a068                 | '                 7..0 = scancode
0a068                 | '------------------------------------------------------------------------------
0a068                 | hkbd_translate
0a068     39 8E 0F F2 |                 cmp     hpar1, #KEY_CAPSLOCK    wz
0a06c     01 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
0a070     53 8E 0F F2 |                 cmp     hpar1, #KEY_NUMLOCK     wz
0a074     00 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
0a078     47 8E 0F F2 |                 cmp     hpar1, #KEY_SCROLLLOCK  wz
0a07c     02 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
0a080                 | 
0a080                 |         if EMUPAD_MAX_PLAYER > 0
0a080                 | 
0a080                 |         if EMUPAD_BT0_BIT >= 0
0a080                 |         end
0a080                 |         if EMUPAD_BT1_BIT >= 0
0a080                 |         end
0a080                 |         if EMUPAD_BT2_BIT >= 0
0a080                 |         end
0a080                 |         if EMUPAD_BT3_BIT >= 0
0a080                 |         end
0a080                 |         if EMUPAD_BT4_BIT >= 0
0a080                 |         end
0a080                 |         if EMUPAD_BT5_BIT >= 0
0a080                 |         end
0a080                 |         if EMUPAD_BT6_BIT >= 0
0a080                 |         end
0a080                 |         if EMUPAD_BT7_BIT >= 0
0a080                 |         end
0a080                 |         if EMUPAD_BT8_BIT >= 0
0a080                 |         end
0a080                 |         if EMUPAD_BT9_BIT >= 0
0a080                 |         end
0a080                 | 
0a080                 |         end
0a080     C8 8F CB F8 |                 setbyte hpar1, hpar2, #1
0a084     7C 8F D3 F8 |                 setbyte hpar1, hkbd_ledstates,#2
0a088     1F 8E 47 F4 |                 bitc    hpar1, #31
0a08c                 |         if KEYQUEUE_SIZE > 0
0a08c     C0 09 B0 FE |                 loc pb,#keyq_head
0a090     F7 73 E3 FA |                 rdword htmp,pb
0a094     B9 75 EB F8 |                 getbyte htmp1,htmp,#1 ' tail
0a098     B9 73 E3 F8 |                 getbyte htmp,htmp,#0 ' head
0a09c     B9 77 03 F6 |                 mov htmp2,htmp
0a0a0     04 76 07 FA |                 mul htmp2,#4
0a0a4     F7 77 03 F1 |                 add htmp2,pb
0a0a8     02 76 07 F1 |                 add htmp2,#2
0a0ac     7F 72 07 F7 |                 incmod htmp,#KEYQUEUE_SIZE - 1
0a0b0     B9 75 0B F2 |                 cmp htmp1,htmp wz ' check buffer overflow
0a0b4     BB 8F 63 5C |         if_nz   wrlong hpar1,htmp2
0a0b8     F7 73 43 5C |         if_nz   wrbyte htmp,pb
0a0bc                 |         end
0a0bc     2D 00 7C FD |                 ret wcz
0a0c0                 | 
0a0c0                 | if HAVE_MOUSE
0a0c0                 | '------------------------------------------------------------------------------
0a0c0                 | ' Execute an IN interrupt transaction to poll for mouse activity.
0a0c0                 | '------------------------------------------------------------------------------
0a0c0                 | ' On entry:
0a0c0                 | ' On exit:
0a0c0                 | '------------------------------------------------------------------------------
0a0c0                 | hget_mouse_in_report
0a0c0     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
0a0c4     27 91 03 F6 |                 mov     hpar2, urx_buff_p
0a0c8     30 93 EB F8 |                 getbyte hpar3, kbm_next_datax, #1
0a0cc     36 93 2B F9 |                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
0a0d0     CF 02 A0 FD |                 call    #do_int_in
0a0d4     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
0a0d8     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
0a0dc                 | 
0a0dc     00 92 0F F2 |                 cmp     hpar3, #0               wz
0a0e0     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
0a0e4                 | 
0a0e4     30 73 EB F8 |                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
0a0e8     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
0a0ec     4B 60 CE A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
0a0f0     C3 60 CE 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
0a0f4                 | 
0a0f4                 |         'debug(uhex_byte_array(urx_buff_p,hpar3))
0a0f4                 | 
0a0f4                 |         if MOUSE_FULL_PROTOCOL
0a0f4     C8 00 B0 FD |                 call #hid_decode
0a0f8                 |         else
0a0f8                 |         end
0a0f8                 | 
0a0f8     48 09 90 FE |                 loc     pa, #mouse_limits
0a0fc     5D 13 F0 FE |                 loc     ptrb, #mouse_xacc
0a100                 | 
0a100                 |                 ' load xacc,yacc,zacc
0a100     28 04 64 FD |                 setq    #3-1
0a104     80 89 07 FB |                 rdlong  hr1,ptrb
0a108                 |                 ' load limits and outptr
0a108     28 04 64 FD |                 setq    #3-1
0a10c     F6 75 03 FB |                 rdlong  htmp1,pa
0a110                 | 
0a110                 |         if MOUSE_FULL_PROTOCOL
0a110     8C 19 47 FC |                 wrbyte  hidr_buttons, ptrb[12]
0a114                 |         else
0a114                 |                 { ' Currently not used
0a114                 |                 '}
0a114                 |         end
0a114                 | 
0a114                 |         if MOUSE_FULL_PROTOCOL
0a114     88 73 33 F9 |                 getword htmp, hidr_axis+0, #0
0a118     0F 72 67 F7 |                 signx   htmp, #15
0a11c                 |         else
0a11c                 |         end
0a11c     B9 89 03 F1 |                 add     hr1,htmp
0a120     00 74 0F F2 |                 cmp     htmp1,#0 wz
0a124     BA 89 63 53 |         if_ne   fles    hr1,htmp1
0a128     00 88 47 53 |         if_ne   fges    hr1,#0
0a12c                 | 
0a12c                 |         if MOUSE_FULL_PROTOCOL
0a12c     88 73 3B F9 |                 getword htmp, hidr_axis+0, #1
0a130     0F 72 67 F7 |                 signx   htmp, #15
0a134                 |         else
0a134                 |         end
0a134     B9 8B 03 F1 |                 add     hr2,htmp
0a138     00 76 0F F2 |                 cmp     htmp2,#0 wz
0a13c     BB 8B 63 53 |         if_ne   fles    hr2,htmp2
0a140     00 8A 47 53 |         if_ne   fges    hr2,#0
0a144                 |                 
0a144                 |         if MOUSE_FULL_PROTOCOL
0a144     8B 73 3B F9 |                 getword htmp, hidr_axis+3, #1           ' Mouse wheel is actually on the "wheel axis"
0a148     0F 72 67 F7 |                 signx   htmp, #15
0a14c     B9 8D 03 F1 |                 add     hr3, htmp
0a150                 |         else    
0a150                 |         end
0a150                 | 
0a150     90 73 CF FA |                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
0a154     2D 00 64 5D |         if_nz   ret                                     ' If so, don't write results
0a158                 | 
0a158                 |                 ' write back accumulators
0a158     28 04 64 FD |                 setq    #3-1
0a15c     80 89 67 FC |                 wrlong  hr1,ptrb
0a160                 |                 ' if outptr set, write X/Y words
0a160     00 78 0F F2 |                 cmp htmp3,#0                    wz
0a164     C5 89 2B 59 |         if_nz   setword hr1,hr2,#1
0a168     BC 89 63 5C |         if_nz   wrlong hr1,htmp3
0a16c     2D 00 64 FD |                 ret
0a170                 | end
0a170                 | 
0a170                 | '------------------------------------------------------------------------------
0a170                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
0a170                 | '------------------------------------------------------------------------------
0a170                 | ' On entry:
0a170                 | ' On exit:
0a170                 | '------------------------------------------------------------------------------
0a170                 | if _HAVE_GAMEPAD
0a170                 | hget_gp_in_report
0a170     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
0a174     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
0a178                 | 
0a178     27 91 03 F6 |                 mov     hpar2, urx_buff_p
0a17c     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax
0a180     00 92 E3 F8 |                 getbyte hpar3
0a184     FF 92 2F F9 |                 setword hpar3, #255, #1                 ' Always ask for max report size
0a188     CF 02 A0 FD |                 call    #do_int_in
0a18c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
0a190     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
0a194                 | 
0a194     00 92 0F F2 |                 cmp     hpar3, #0               wz
0a198     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
0a19c                 |                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
0a19c                 | 
0a19c     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
0a1a0     00 72 E3 F8 |                 getbyte htmp                            ' |
0a1a4     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
0a1a8     4B 72 07 A6 |         if_z    mov     htmp, #PID_DATA1                ' |
0a1ac     C3 72 07 56 |         if_nz   mov     htmp, #PID_DATA0                ' |
0a1b0     2E 5B 66 F9 |                 altsb   hdev_port, #hdev_next_datax     ' |
0a1b4     B9 01 C0 F8 |                 setbyte htmp                            ' |
0a1b8                 | 
0a1b8                 | ' Note: the following code compares the current and previous reports
0a1b8                 | ' and process the data if there are changes to ease the debug output.
0a1b8                 | ' Actual implementations should remove this block, along with hid_pre_rpt_p and
0a1b8                 | ' gpPreReport buffer.
0a1b8                 | 
0a1b8                 |                 ' ----- start of block to remove
0a1b8                 |                 {
0a1b8                 |                 }
0a1b8                 |                 ' ----- end of block to remove
0a1b8     14 05 90 FE |                 loc pa,#hpad_translate
0a1bc     2A EC 63 FD |                 push pa
0a1c0                 | 
0a1c0                 |                 ' FALL THROUGH !!!!
0a1c0                 | end
0a1c0                 | if _HAVE_GAMEPAD || MOUSE_FULL_PROTOCOL
0a1c0                 | '------------------------------------------------------------------------------
0a1c0                 | ' Decode controller report
0a1c0                 | '------------------------------------------------------------------------------
0a1c0                 | hid_decode
0a1c0                 |                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
0a1c0     28 20 64 FD |                 setq #(hidr_end-hidr_start)-1
0a1c4     00 04 00 FF 
0a1c8     00 0C 07 FB |                 rdlong  hidr_start,##$8_0000
0a1cc                 | 
0a1cc     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
0a1d0                 | 
0a1d0     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
0a1d4     00 1C E3 F8 |                 getbyte hidr_type
0a1d8                 |         if _HAVE_GAMEPAD
0a1d8     07 1C 0F F2 |                 cmp     hidr_type, #XINPUT_READY        wz
0a1dc     08 03 90 AD |         if_z    jmp     #hpad_xinput
0a1e0     08 1C 0F F2 |                 cmp     hidr_type, #PS3_READY           wz
0a1e4     EC 03 90 AD |         if_z    jmp     #hpad_ps3
0a1e8                 |         end
0a1e8     05 1C 0F F2 |                 cmp     hidr_type, #KBM_READY           wz
0a1ec     04 1C 07 A6 |         if_z    mov     hidr_type,#M_READY
0a1f0     04 1C 0F F2 |                 cmp     hidr_type, #M_READY             wz
0a1f4                 |                 
0a1f4                 | 
0a1f4                 | '------------------------------------------------------------------------------
0a1f4                 | ' Handle HID controller (or mouse now
0a1f4                 | ' On entry:
0a1f4                 | '   ptrb - controller report
0a1f4                 | '------------------------------------------------------------------------------
0a1f4                 | hpad_hid
0a1f4     1B 01 A0 FD |                 call    #get_hid_descr_buffer
0a1f8     F7 F1 03 F6 |                 mov     ptra, pb
0a1fc     3F 5B 96 F9 |                 alts    hdev_port, #gp_descr_len
0a200     00 EC 03 F6 |                 mov     pa, 0-0
0a204                 |                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
0a204     19 2A 3B FF 
0a208     10 0C 07 F6 |                 mov     hidr_usage, ##$76543210
0a20c                 | 
0a20c                 | .next
0a20c     00 EC 5F F2 |                 cmps    pa, #0      wcz
0a210     2D 00 7C ED |         if_be   ret     wcz
0a214                 | 
0a214     61 8F C7 FA |                 rdbyte  hpar1, ptra++
0a218     01 EC 87 F1 |                 sub     pa, #1
0a21c     00 90 07 F6 |                 mov     hpar2, #0
0a220                 | 
0a220     C7 73 03 F6 |                 mov     htmp, hpar1
0a224     03 72 07 F5 |                 and     htmp, #$03
0a228     01 72 0F F2 |                 cmp     htmp, #1    wz
0a22c     61 91 C7 AA |         if_z    rdbyte  hpar2, ptra++
0a230     07 90 67 A7 |         if_z    signx   hpar2,#7
0a234     01 EC 87 A1 |         if_z    sub     pa, #1
0a238     02 72 0F F2 |                 cmp     htmp, #2    wz
0a23c     61 91 E7 AA |         if_z    rdword  hpar2, ptra++
0a240     0F 90 67 A7 |         if_z    signx   hpar2,#15
0a244     02 EC 87 A1 |         if_z    sub     pa, #2
0a248     03 72 0F F2 |                 cmp     htmp, #3    wz
0a24c     61 91 07 AB |         if_z    rdlong  hpar2, ptra++
0a250     04 EC 87 A1 |         if_z    sub     pa, #4
0a254                 | 
0a254     FC 8E 07 F5 |                 and     hpar1, #$FC
0a258                 |                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
0a258                 | 
0a258     84 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_ID   wz
0a25c     18 01 90 AD |         if_z    jmp     #.report_id
0a260     04 8E 0F F2 |                 cmp     hpar1, #HID_USAGE_PAGE  wz
0a264     30 01 90 AD |         if_z    jmp     #.usage_page
0a268     08 8E 0F F2 |                 cmp     hpar1, #HID_USAGE       wz
0a26c     38 01 90 AD |         if_z    jmp     #.usage
0a270     14 8E 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MIN wz
0a274     C8 2B 2B A9 |         if_z    setword hidr_lminmax, hpar2, #1
0a278     24 8E 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MAX wz
0a27c     C8 2B 23 A9 |         if_z    setword hidr_lminmax, hpar2, #0
0a280     34 8E 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MIN wz
0a284     C8 2D 2B A9 |         if_z    setword hidr_pminmax, hpar2, #1
0a288     44 8E 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MAX wz
0a28c     C8 2D 23 A9 |         if_z    setword hidr_pminmax, hpar2, #0
0a290     74 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_SIZE wz
0a294     C8 27 03 A6 |         if_z    mov     hidr_size, hpar2
0a298     94 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_COUNT wz
0a29c     C8 29 03 A6 |         if_z    mov     hidr_count, hpar2
0a2a0     B4 8E 1F F2 |                 cmp     hpar1, #HID_POP wcz
0a2a4     A4 8E 0F 52 |         if_nz   cmp     hpar1, #HID_PUSH wz
0a2a8     64 01 90 AD |         if_z    jmp     #.pushpop ' Entering with C set if PUSH  
0a2ac     80 8E 0F F2 |                 cmp     hpar1, #HID_INPUT       wz
0a2b0     58 FF 9F 5D |         if_nz   jmp     #.next
0a2b4                 | 
0a2b4     D5 25 A7 FB |                 tjf     hidr_state,#.next
0a2b8                 | 
0a2b8     03 90 07 F5 |                 and     hpar2, #$03
0a2bc     02 90 0F F2 |                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
0a2c0     18 00 90 5D |         if_nz   jmp     #.skip
0a2c4                 | 
0a2c4     02 24 0F F2 |                 cmp     hidr_state, #2  wz
0a2c8     20 00 90 AD |         if_z    jmp     #.axes
0a2cc     03 24 0F F2 |                 cmp     hidr_state, #3  wz
0a2d0     5C 00 90 AD |         if_z    jmp     #.hats
0a2d4     04 24 0F F2 |                 cmp     hidr_state, #4  wz
0a2d8     70 00 90 AD |         if_z    jmp     #.buttons
0a2dc                 | .skip
0a2dc     93 73 03 F6 |                 mov     htmp, hidr_size
0a2e0     94 73 03 FA |                 mul     htmp, hidr_count
0a2e4     B9 21 03 F1 |                 add     hidr_offset, htmp
0a2e8     20 FF 9F FD |                 jmp     #.next
0a2ec                 | .axes
0a2ec                 |                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count),uhex_long(hidr_flags))
0a2ec     87 87 53 F8 |                 getnib  hr0, hidr_flags, #2
0a2f0     94 89 03 F6 |                 mov     hr1, hidr_count
0a2f4                 | .l1
0a2f4     90 8F 03 F6 |                 mov     hpar1, hidr_offset
0a2f8     93 91 03 F6 |                 mov     hpar2, hidr_size
0a2fc     28 01 B0 FD |                 call    #hpad_getbits
0a300     88 01 B0 FD |                 call    #hpad_normalize
0a304     08 86 1F F2 |                 cmp     hr0, #8         wcz
0a308     86 87 5F C9 |         if_b    altgn   hr0, #hidr_usage
0a30c     00 8A 43 C8 |         if_b    getnib  hr2
0a310     88 8B 77 C9 |         if_b    altsw   hr2, #hidr_axis
0a314     5F 01 20 C9 |         if_b    setword retval
0a318     01 86 07 C1 |         if_b    add     hr0, #1
0a31c     93 21 03 F1 |                 add     hidr_offset, hidr_size
0a320     F4 89 6F FB |                 djnz    hr1, #.l1
0a324                 | 
0a324     C3 0F 13 F8 |                 setnib  hidr_flags, hr0, #2
0a328     01 24 07 F6 |                 mov     hidr_state, #1
0a32c     DC FE 9F FD |                 jmp     #.next
0a330                 | .hats
0a330                 |                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
0a330     90 8F 03 F6 |                 mov     hpar1, hidr_offset
0a334     93 91 03 F6 |                 mov     hpar2, hidr_size
0a338     EC 00 B0 FD |                 call    #hpad_getbits
0a33c     5F 1B C3 F8 |                 setbyte hidr_hats, retval, #0
0a340     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
0a344     01 24 07 F6 |                 mov     hidr_state, #1
0a348     90 FF 9F FD |                 jmp     #.skip
0a34c                 | .buttons
0a34c                 |                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
0a34c     90 8F 03 F6 |                 mov     hpar1, hidr_offset
0a350     93 91 03 F6 |                 mov     hpar2, hidr_size
0a354     94 91 03 FA |                 mul     hpar2, hidr_count
0a358     CC 00 B0 FD |                 call    #hpad_getbits
0a35c     87 73 E3 F8 |                 getbyte htmp, hidr_flags, #0
0a360     B9 BF 62 F0 |                 shl     retval, htmp
0a364     5F 19 43 F5 |                 or      hidr_buttons, retval
0a368     94 73 03 F1 |                 add     htmp, hidr_count
0a36c     B9 0F C3 F8 |                 setbyte hidr_flags, htmp, #0
0a370     01 24 07 F6 |                 mov     hidr_state, #1
0a374     64 FF 9F FD |                 jmp     #.skip
0a378                 | .report_id
0a378     00 1E 0F F2 |                 cmp     hidr_id, #0     wz
0a37c     2D 00 7C 5D |         if_nz   ret     wcz
0a380     E1 73 C7 FA |                 rdbyte  htmp, ptrb++
0a384                 |                 'debug(".report_id",udec(htmp,hpar2))
0a384     C8 73 0B F2 |                 cmp     htmp, hpar2     wz
0a388     B9 1F 03 A6 |         if_z    mov     hidr_id, htmp
0a38c     01 24 67 56 |         if_nz   neg     hidr_state,#1
0a390     01 F2 87 51 |         if_nz   sub     ptrb,#1
0a394     74 FE 9F FD |                 jmp     #.next
0a398                 | .usage_page
0a398     09 90 0F F2 |                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
0a39c     01 24 0F A2 |         if_z    cmp     hidr_state, #1  wz
0a3a0     04 24 07 A6 |         if_z    mov     hidr_state, #4
0a3a4     64 FE 9F FD |                 jmp     #.next
0a3a8                 | .usage
0a3a8     04 90 0F F2 |                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
0a3ac     05 90 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
0a3b0     06 1C 0F A2 |         if_z    cmp     hidr_type,#HID_READY        wz
0a3b4     01 24 07 A6 |         if_z    mov     hidr_state, #1
0a3b8     50 FE 9F AD |         if_z    jmp     #.next
0a3bc     02 90 0F F2 |                 cmp     hpar2, #HID_USAGE_MOUSE     wz
0a3c0     04 1C 0F A2 |         if_z    cmp     hidr_type,#M_READY          wz
0a3c4     01 24 07 A6 |         if_z    mov     hidr_state, #1
0a3c8     40 FE 9F AD |         if_z    jmp     #.next
0a3cc     30 90 17 F2 |                 cmp     hpar2, #HID_USAGE_X     wc
0a3d0     38 90 97 32 |         if_nc   cmpr    hpar2, #HID_USAGE_WHEEL wc   
0a3d4     10 00 90 3D |         if_nc   jmp     #.usage_axis
0a3d8     39 90 0F F2 |                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
0a3dc     01 24 0F A2 |         if_z    cmp     hidr_state, #1      wz
0a3e0     03 24 07 A6 |         if_z    mov     hidr_state, #3
0a3e4     24 FE 9F FD |                 jmp     #.next
0a3e8                 | .usage_axis
0a3e8     01 24 57 F2 |                 cmps    hidr_state, #1          wc
0a3ec     1C FE 9F CD |         if_b    jmp     #.next
0a3f0     37 90 27 F3 |                 fle     hpar2, #HID_USAGE_DIAL   ' Let's just say wheel and dial are the same to keep sane
0a3f4     86 23 57 F9 |                 altsn   hidr_usage_idx, #hidr_usage
0a3f8     C8 01 00 F8 |                 setnib  hpar2
0a3fc                 | 
0a3fc     20 90 87 F1 |                 sub     hpar2, #HID_USAGE_X - 16
0a400     C8 0F 23 F4 |                 bith    hidr_flags, hpar2
0a404                 | 
0a404     01 22 07 F1 |                 add     hidr_usage_idx, #1
0a408     02 24 07 F6 |                 mov     hidr_state, #2
0a40c     FC FD 9F FD |                 jmp     #.next
0a410                 | .pushpop
0a410                 |                 ' Entering with C set if PUSH  
0a410     4C 0F B0 FE |                 loc     pb, #hid_stack
0a414     28 08 64 CD |         if_c    setq    #(hidr_end-hidr_state)-1
0a418     F7 25 63 CC |         if_c    wrlong  hidr_state, pb
0a41c     28 08 64 3D |         if_nc   setq    #(hidr_end-hidr_state)-1
0a420     F7 25 03 3B |         if_nc   rdlong  hidr_state, pb
0a424     E4 FD 9F FD |                 jmp     #.next
0a428                 | 
0a428                 | '------------------------------------------------------------------------------
0a428                 | ' Read bits from report data buffer
0a428                 | '------------------------------------------------------------------------------
0a428                 | ' On entry:
0a428                 | '   PTRB - report buffer
0a428                 | '   hpar1 - start bit
0a428                 | '   hpar2 - number of bits
0a428                 | ' On exit:
0a428                 | '   retval - bits
0a428                 | '------------------------------------------------------------------------------
0a428                 | hpad_getbits
0a428     C7 73 03 F6 |                 mov     htmp, hpar1
0a42c     03 72 47 F0 |                 shr     htmp, #3        ' byte offset
0a430     F9 73 03 F1 |                 add     htmp, ptrb
0a434     B9 BF 02 FB |                 rdlong  retval, htmp
0a438                 | 
0a438     C7 75 03 F6 |                 mov     htmp1, hpar1
0a43c     07 74 07 F5 |                 and     htmp1, #$07     ' shift
0a440     BA BF 42 F0 |                 shr     retval, htmp1
0a444                 | 
0a444     18 90 1F F2 |                 cmp     hpar2, #24      wcz
0a448     10 00 90 1D |         if_a    jmp     #.l1
0a44c                 | 
0a44c     C8 91 C3 F9 |                 decod   hpar2
0a450     01 90 87 F1 |                 sub     hpar2, #1
0a454     C8 BF 02 F5 |                 and     retval, hpar2
0a458     2D 00 64 FD |                 ret
0a45c                 | .l1
0a45c     FF 7F 00 FF 
0a460     FF BF 06 F5 |                 and     retval, ##$00_FFFFFF
0a464     03 72 07 F1 |                 add     htmp, #3
0a468     B9 77 03 FB |                 rdlong  htmp2, htmp
0a46c     18 90 87 F1 |                 sub     hpar2, #24
0a470     C8 91 C3 F9 |                 decod   hpar2
0a474     01 90 87 F1 |                 sub     hpar2, #1
0a478     BA 77 43 F0 |                 shr     htmp2, htmp1
0a47c     C8 77 03 F5 |                 and     htmp2, hpar2
0a480     18 76 67 F0 |                 shl     htmp2, #24
0a484     BB BF 42 F5 |                 or      retval, htmp2
0a488     2D 00 64 FD |                 ret
0a48c                 | 
0a48c                 | '------------------------------------------------------------------------------
0a48c                 | ' Normalize value to signed word (-32768 / 32767)
0a48c                 | '------------------------------------------------------------------------------
0a48c                 | ' On entry:
0a48c                 | '   retval - value to normalize
0a48c                 | '   hidr_lminmax - min (word 1) max (word 0) value range
0a48c                 | '   - or -
0a48c                 | '   hidr_pminmax - min (word 1) max (word 0) value range
0a48c                 | '   hidr_size - value bits length
0a48c                 | ' On exit:
0a48c                 | '   retval - normalized value
0a48c                 | '------------------------------------------------------------------------------
0a48c                 | hpad_normalize
0a48c     95 73 0B F6 |                 mov     htmp, hidr_lminmax  wz
0a490     96 73 0B A6 |         if_z    mov     htmp, hidr_pminmax  wz
0a494     2D 00 64 AD |         if_z    ret
0a498     B9 75 3B F9 |                 getword htmp1, htmp, #1     ' htmp1 = min
0a49c     B9 73 33 F9 |                 getword htmp, htmp, #0      ' htmp = max
0a4a0     0F 74 77 F7 |                 signx   htmp1, #15      wc
0a4a4     FF 27 97 C9 |         if_c    alts    hidr_size, #511
0a4a8     00 BE 66 C7 |         if_c    signx   retval, #0-0
0a4ac                 |                 ' slightly crappy hack: if in mouse mode, don't normalize
0a4ac     04 1C 0F F2 |                 cmp     hidr_type, #M_READY wz
0a4b0     2D 00 64 AD |         if_z    ret
0a4b4     BA 73 C3 F1 |                 subs    htmp, htmp1         ' htmp = (max - min)
0a4b8     BA BF C2 F1 |                 subs    retval, htmp1       ' retval = (retval - min)
0a4bc     10 BE 66 F0 |                 shl     retval, #16         ' retval = (retval - min) << 16
0a4c0     01 BE C6 F1 |                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
0a4c4     B9 73 53 F6 |                 abs     htmp            wc
0a4c8     1F BE 0E F4 |                 testb   retval, #31     wz
0a4cc     5F BF 42 F6 |                 abs     retval
0a4d0     B9 BF 12 FD |                 qdiv    retval, htmp
0a4d4     18 BE 62 FD |                 getqx   retval
0a4d8     5F BF 62 66 |     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
0a4dc     C0 FF 7F FF 
0a4e0     00 BE 46 F1 |                 adds    retval, ##$8000 signx 15
0a4e4     2D 00 64 FD |                 ret
0a4e8                 | end
0a4e8                 | 
0a4e8                 | if _HAVE_GAMEPAD
0a4e8                 | '------------------------------------------------------------------------------
0a4e8                 | ' Handle XInput controller
0a4e8                 | ' On entry:
0a4e8                 | '   ptrb - controller report
0a4e8                 | '------------------------------------------------------------------------------
0a4e8                 | '   Default implementation translates the report to a pseudo-defacto hid
0a4e8                 | '   standard and jumps to hpad_translate for actions.
0a4e8                 | '   Implementors may take specific actions for this kind of controller.
0a4e8                 | '------------------------------------------------------------------------------
0a4e8                 | hpad_xinput
0a4e8     80 73 CF FA |                 rdbyte  htmp, ptrb      wz
0a4ec     2D 00 64 5D |         if_nz   ret                         ' Ignore message type <> $00
0a4f0     81 73 C7 FA |                 rdbyte  htmp, ptrb[1]
0a4f4     14 72 0F F2 |                 cmp     htmp, #$14      wz
0a4f8     2D 00 64 5D |         if_nz   ret                         ' Ignore report length <> $14 (20)
0a4fc                 | 
0a4fc                 |                 'debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
0a4fc                 | 
0a4fc     B0 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
0a500     06 0E 17 F8 |                 setnib  hidr_flags, #6, #2
0a504                 | 
0a504     83 11 E7 FA |                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
0a508     84 BF E6 FA |                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
0a50c     5F BF 22 F6 |                 not     retval
0a510     5F 11 2B F9 |                 setword hidr_axis, retval, #1
0a514     85 13 E7 FA |                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
0a518     86 BF E6 FA |                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
0a51c     5F BF 22 F6 |                 not     retval
0a520     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
0a524                 | 
0a524     FF 2A 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
0a528     84 BF C6 FA |                 rdbyte  retval, ptrb[4]     ' left analog trigger
0a52c     C0 BE 1E F2 |                 cmp     retval, #192    wcz
0a530     06 18 27 34 |         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
0a534     54 FF BF FD |                 call    #hpad_normalize
0a538     5F 13 2B F9 |                 setword hidr_axis+1, retval, #1
0a53c     85 BF C6 FA |                 rdbyte  retval, ptrb[5]     ' right analog trigger
0a540     C0 BE 1E F2 |                 cmp     retval, #192    wcz
0a544     07 18 27 34 |         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
0a548     40 FF BF FD |                 call    #hpad_normalize
0a54c     5F 15 23 F9 |                 setword hidr_axis+2, retval, #0
0a550                 | 
0a550     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
0a554     81 BF E6 FA |                 rdword  retval, ptrb[1]
0a558     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
0a55c     00 18 47 F4 |                 bitc    hidr_buttons, #0
0a560     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
0a564     01 18 47 F4 |                 bitc    hidr_buttons, #1
0a568     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
0a56c     02 18 47 F4 |                 bitc    hidr_buttons, #2
0a570     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
0a574     03 18 47 F4 |                 bitc    hidr_buttons, #3
0a578     08 BE 16 F4 |                 testb   retval, #8      wc  ' LB
0a57c     04 18 47 F4 |                 bitc    hidr_buttons, #4
0a580     09 BE 16 F4 |                 testb   retval, #9      wc  ' RB
0a584     05 18 47 F4 |                 bitc    hidr_buttons, #5
0a588     05 BE 16 F4 |                 testb   retval, #5      wc  ' SELECT
0a58c     08 18 47 F4 |                 bitc    hidr_buttons, #8
0a590     04 BE 16 F4 |                 testb   retval, #4      wc  ' START
0a594     09 18 47 F4 |                 bitc    hidr_buttons, #9
0a598     06 BE 16 F4 |                 testb   retval, #6      wc  ' L3
0a59c     0A 18 47 F4 |                 bitc    hidr_buttons, #10
0a5a0     07 BE 16 F4 |                 testb   retval, #7      wc  ' R3
0a5a4     0B 18 47 F4 |                 bitc    hidr_buttons, #11
0a5a8     0A BE 16 F4 |                 testb   retval, #10     wc  ' XBOX
0a5ac     0C 18 47 F4 |                 bitc    hidr_buttons, #12
0a5b0                 | 
0a5b0     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
0a5b4     5F 73 43 F8 |                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
0a5b8     7A BB 7A FF 
0a5bc     0F 74 07 F6 |                 mov     htmp1, ##$F576_F40F
0a5c0     F9 FF 7F FF 
0a5c4     12 77 07 F6 |                 mov     htmp2, ##$FFFF_F312
0a5c8     BA 73 5F F9 |                 altgn   htmp, #htmp1
0a5cc     00 72 43 F8 |                 getnib  htmp
0a5d0     B9 1B C3 08 |         _ret_   setbyte hidr_hats, htmp, #0
0a5d4                 | 
0a5d4                 | '------------------------------------------------------------------------------
0a5d4                 | ' Handle PS3 controller
0a5d4                 | ' On entry:
0a5d4                 | '   ptrb - controller report
0a5d4                 | '------------------------------------------------------------------------------
0a5d4                 | '   Default implementation translates the report to a pseudo-defacto hid
0a5d4                 | '   standard and jumps to hpad_translate for actions.
0a5d4                 | '   Implementors may take specific actions for this kind of controller.
0a5d4                 | '------------------------------------------------------------------------------
0a5d4                 | hpad_ps3
0a5d4     E1 73 C7 FA |                 rdbyte  htmp, ptrb++
0a5d8     01 72 0F F2 |                 cmp     htmp, #$01      wz
0a5dc     2D 00 64 5D |         if_nz   ret                         ' Ignore report ID <> $01
0a5e0                 | 
0a5e0                 |                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
0a5e0                 | 
0a5e0     B0 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
0a5e4     06 0E 17 F8 |                 setnib  hidr_flags, #6, #2
0a5e8                 | 
0a5e8     FF 2A 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
0a5ec     85 BF C6 FA |                 rdbyte  retval, ptrb[5]         ' X = left stick X
0a5f0     98 FE BF FD |                 call    #hpad_normalize
0a5f4     5F 11 23 F9 |                 setword hidr_axis, retval, #0
0a5f8     86 BF C6 FA |                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
0a5fc     8C FE BF FD |                 call    #hpad_normalize
0a600     5F 11 2B F9 |                 setword hidr_axis, retval, #1
0a604     87 BF C6 FA |                 rdbyte  retval, ptrb[7]         ' Z = right stick X
0a608     80 FE BF FD |                 call    #hpad_normalize
0a60c     5F 13 23 F9 |                 setword hidr_axis+1, retval, #0
0a610     88 BF C6 FA |                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
0a614     74 FE BF FD |                 call    #hpad_normalize
0a618     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
0a61c     91 BF C6 FA |                 rdbyte  retval, ptrb[17]        ' RX = L2 analog
0a620     68 FE BF FD |                 call    #hpad_normalize
0a624     5F 13 2B F9 |                 setword hidr_axis+1, retval, #1
0a628     92 BF C6 FA |                 rdbyte  retval, ptrb[18]        ' RY = R2 analog
0a62c     5C FE BF FD |                 call    #hpad_normalize
0a630     5F 15 23 F9 |                 setword hidr_axis+2, retval, #0
0a634                 | 
0a634     08 8E 07 F6 |                 mov     hpar1, #8
0a638     13 90 07 F6 |                 mov     hpar2, #19
0a63c     E8 FD BF FD |                 call    #hpad_getbits
0a640                 | 
0a640     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
0a644     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
0a648     00 18 47 F4 |                 bitc    hidr_buttons, #0
0a64c     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
0a650     01 18 47 F4 |                 bitc    hidr_buttons, #1
0a654     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
0a658     02 18 47 F4 |                 bitc    hidr_buttons, #2
0a65c     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
0a660     03 18 47 F4 |                 bitc    hidr_buttons, #3
0a664     0A BE 16 F4 |                 testb   retval, #10     wc  ' L1
0a668     04 18 47 F4 |                 bitc    hidr_buttons, #4
0a66c     0B BE 16 F4 |                 testb   retval, #11     wc  ' R1
0a670     05 18 47 F4 |                 bitc    hidr_buttons, #5
0a674     08 BE 16 F4 |                 testb   retval, #8      wc  ' L2
0a678     06 18 47 F4 |                 bitc    hidr_buttons, #6
0a67c     09 BE 16 F4 |                 testb   retval, #9      wc  ' R2
0a680     07 18 47 F4 |                 bitc    hidr_buttons, #7
0a684     00 BE 16 F4 |                 testb   retval, #0      wc  ' SELECT
0a688     08 18 47 F4 |                 bitc    hidr_buttons, #8
0a68c     03 BE 16 F4 |                 testb   retval, #3      wc  ' START
0a690     09 18 47 F4 |                 bitc    hidr_buttons, #9
0a694     01 BE 16 F4 |                 testb   retval, #1      wc  ' LEFT STICK
0a698     0A 18 47 F4 |                 bitc    hidr_buttons, #10
0a69c     02 BE 16 F4 |                 testb   retval, #2      wc  ' RIGHT STICK
0a6a0     0B 18 47 F4 |                 bitc    hidr_buttons, #11
0a6a4     10 BE 16 F4 |                 testb   retval, #16     wc  ' HOME
0a6a8     0C 18 47 F4 |                 bitc    hidr_buttons, #12
0a6ac                 | 
0a6ac     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
0a6b0     5F 73 4B F8 |                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
0a6b4     09 FA 79 FF 
0a6b8     0F 74 07 F6 |                 mov     htmp1, ##$F3F4_120F
0a6bc     FF FA 7F FF 
0a6c0     76 77 07 F6 |                 mov     htmp2, ##$FFF5_FF76
0a6c4     BA 73 5F F9 |                 altgn   htmp, #htmp1
0a6c8     00 72 43 F8 |                 getnib  htmp
0a6cc     B9 1B C3 08 |         _ret_   setbyte hidr_hats, htmp, #0
0a6d0                 | 
0a6d0                 | 
0a6d0                 | '------------------------------------------------------------------------------
0a6d0                 | ' Perform controller actions
0a6d0                 | ' On entry:
0a6d0                 | '    hidr_id        report id
0a6d0                 | '    hidr_axis      axis value (signed word, 2 axes per long)
0a6d0                 | '                      X = hidr_axis+0, #0
0a6d0                 | '                      Y = hidr_axis+0, #1
0a6d0                 | '                      Z = hidr_axis+1, #0
0a6d0                 | '                     RX = hidr_axis+1, #1
0a6d0                 | '                     RY = hidr_axis+2, #0
0a6d0                 | '                     RZ = hidr_axis+2, #1
0a6d0                 | '                     Sl = hidr_axis+3, #0
0a6d0                 | '                     Wh = hidr_axis+3, #1
0a6d0                 | '    hidr_buttons   buttons state (bits 0 to 31)
0a6d0                 | '    hidr_hats      hats state (byte 0, 1, 2, 3)
0a6d0                 | '
0a6d0                 | '                     -------3 -------2 -------1 -------0 byte
0a6d0                 | '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
0a6d0                 | '    hidr_flags       xxxxxxxx_wsrrrzyx_hhhhaaaa_bbbbbbbb
0a6d0                 | '                              hlzyx||| |||||||| ++++++++ n. buttons
0a6d0                 | '                              |||||||| ||||++++--------- n. axes
0a6d0                 | '                              |||||||| ++++------------- n. hats
0a6d0                 | '                              ++++++++------------------ valid axes
0a6d0                 | '------------------------------------------------------------------------------
0a6d0                 | hpad_translate
0a6d0                 | 
0a6d0                 | 
0a6d0                 |         if HAVE_HIDPAD
0a6d0     A0 0C F0 FE |                 loc     ptrb,#hidpad_report
0a6d4     2D 73 0B F6 |                 mov     htmp,hdev_port          wz
0a6d8     8F 73 03 A6 |         if_z    mov     htmp,hidr_id
0a6dc     01 72 E7 F2 |                 cmpsub  htmp,#1
0a6e0     07 1E 17 A2 |         if_z    cmp     hidr_id, #MAX_DEVICES   wc
0a6e4     02 1E 17 52 |         if_nz   cmp     hidr_id, #2             wc
0a6e8     2D 00 7C 3D |         if_ae   ret     wcz
0a6ec     20 72 07 FA |                 mul     htmp, #HIDPAD_REPORT_SIZE
0a6f0     B9 F3 03 F1 |                 add     ptrb,htmp
0a6f4     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
0a6f8     00 0C 03 F6 |                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
0a6fc     28 0E 64 FD |                 setq    #8-1
0a700     80 0D 67 FC |                 wrlong  hidr_usage,ptrb
0a704                 |         end
0a704                 | 
0a704                 | 
0a704                 |         if EMUPAD_MAX_PLAYER > 0
0a704                 | .emupad_no_hat
0a704                 |         if EMUPAD_BT0_BIT >= 0
0a704                 |         end
0a704                 |         if EMUPAD_BT1_BIT >= 0
0a704                 |         end
0a704                 |         if EMUPAD_BT2_BIT >= 0
0a704                 |         end
0a704                 |         if EMUPAD_BT3_BIT >= 0
0a704                 |         end
0a704                 |         if EMUPAD_BT4_BIT >= 0
0a704                 |         end
0a704                 |         if EMUPAD_BT5_BIT >= 0
0a704                 |         end
0a704                 |         if EMUPAD_BT6_BIT >= 0
0a704                 |         end
0a704                 |         if EMUPAD_BT7_BIT >= 0
0a704                 |         end
0a704                 |         if EMUPAD_BT8_BIT >= 0
0a704                 |         end
0a704                 |         if EMUPAD_BT9_BIT >= 0
0a704                 |         end
0a704                 | .emupad_slot_over
0a704                 |         end
0a704                 | 
0a704                 |         if 0
0a704                 |                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
0a704                 | 
0a704                 |                 debug("    btn: ", ubin_long_(hidr_buttons))
0a704                 | 
0a704                 |         end
0a704     2D 00 64 FD |                 ret
0a708                 | end
0a708                 | 
0a708                 | if EMUPAD_MAX_PLAYER > 0
0a708                 | '------------------------------------------------------------------------------
0a708                 | ' Clear EmuPad state
0a708                 | '------------------------------------------------------------------------------
0a708                 | emupad_reset
0a708                 | 
0a708                 | '------------------------------------------------------------------------------
0a708                 | ' Get EmuPad Player number for current device (into retval)
0a708                 | ' Z flag is also set if current device is valid
0a708                 | ' (Value may be larger than EMUPAD_MAX_PLAYER !)
0a708                 | '------------------------------------------------------------------------------
0a708                 | emupad_getnum
0a708                 | .loop
0a708                 | '------------------------------------------------------------------------------
0a708                 | ' Handle disconnect of device (call after emupad_getnum returns with Z set)
0a708                 | '------------------------------------------------------------------------------
0a708                 | emupad_discon
0a708                 | .loop         
0a708                 |         
0a708                 |         ' FALL THROUGH!!!
0a708                 | 
0a708                 | '------------------------------------------------------------------------------
0a708                 | ' Update EmuPad reports (all of them...)
0a708                 | '------------------------------------------------------------------------------
0a708                 | emupad_write_reports
0a708                 | .devloop
0a708                 | 
0a708                 | end
0a708                 | 
0a708                 | 
0a708                 | '------------------------------------------------------------------------------
0a708                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
0a708                 | '------------------------------------------------------------------------------
0a708                 | ' On entry:
0a708                 | ' On exit:
0a708                 | '------------------------------------------------------------------------------
0a708                 | hget_hub_status
0a708     77 BD 02 F6 |                 mov     ep_addr_pid, hhub_ep_addr
0a70c     27 91 03 F6 |                 mov     hpar2, urx_buff_p
0a710     32 93 23 F9 |                 setword hpar3, hub_next_datax, #0
0a714     01 92 2F F9 |                 setword hpar3, #1, #1
0a718     CF 02 A0 FD |                 call    #do_int_in
0a71c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
0a720     0C 00 90 AD |         if_z    jmp     #.data
0a724     5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
0a728     1A 01 80 5D |         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
0a72c     2D 00 64 FD |                 ret
0a730                 | .data
0a730     00 92 0F F2 |                 cmp     hpar3, #0               wz
0a734     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
0a738                 | 
0a738     C3 64 0E F2 |                 cmp     hub_next_datax, #PID_DATA0  wz
0a73c     4B 64 06 A6 |         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
0a740     C3 64 06 56 |         if_nz   mov     hub_next_datax, #PID_DATA0
0a744     27 67 02 FB |                 rdlong  hub_status_chg, urx_buff_p
0a748                 |                 debug(ubin_long(hub_status_chg))
0a748                 | 
0a748     01 5A 06 F6 |                 mov     hdev_port, #1
0a74c                 | .loop
0a74c     2D 67 0A F4 |                 testb   hub_status_chg, hdev_port wz
0a750     0C 00 B0 AD |         if_x1   call    #hub_port_handler
0a754     07 5A 1E F7 |                 incmod  hdev_port, #7           wcz
0a758     F0 FF 9F 3D |         if_nc   jmp     #.loop
0a75c     2D 00 64 FD |                 ret
0a760                 | 
0a760                 | hub_port_handler
0a760     76 BD 02 F6 |                 mov     ep_addr_pid, hhub_ctrl_ep
0a764     8C 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
0a768     27 EF 03 F6 |                 mov     pb, urx_buff_p
0a76c     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
0a770     55 02 A0 FD |                 call    #control_read
0a774     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
0a778                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
0a778                 | 
0a778     10 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
0a77c     50 01 90 5D |         if_x0   jmp     #.other
0a780     68 02 D0 FE |                 loc     ptra, #clr_port_feat
0a784     01 21 5C FC |                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
0a788     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
0a78c     A0 02 A0 FD |                 call    #control_write
0a790     00 68 0E F4 |                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
0a794     7C 01 90 5D |         if_x0   jmp     #.disconnect
0a798     B1 99 02 F6 |                 mov     hctwait, _100ms_
0a79c     EF 02 A0 FD |                 call    #poll_waitx
0a7a0                 | 
0a7a0     40 02 D0 FE |                 loc     ptra, #set_port_feat            ' reset port
0a7a4     01 09 5C FC |                 wrword  #HUB_PORT_RESET, ptra[wValue]
0a7a8     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
0a7ac     A0 02 A0 FD |                 call    #control_write
0a7b0                 | 
0a7b0     02 78 07 F6 |                 mov     htmp3, #2
0a7b4                 | .wait_reset
0a7b4     AD 99 02 F6 |                 mov     hctwait, _8ms_
0a7b8     EF 02 A0 FD |                 call    #poll_waitx
0a7bc     34 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
0a7c0     27 EF 03 F6 |                 mov     pb, urx_buff_p
0a7c4     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
0a7c8     55 02 A0 FD |                 call    #control_read
0a7cc     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
0a7d0     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
0a7d4     F7 79 6F 5B |         if_x0   djnz    htmp3, #.wait_reset
0a7d8                 | 
0a7d8     10 02 D0 FE |                 loc     ptra, #clr_port_feat
0a7dc     01 29 5C FC |                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
0a7e0     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
0a7e4     A0 02 A0 FD |                 call    #control_write
0a7e8                 | 
0a7e8     24 72 07 F6 |                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
0a7ec                 | .wait_recover
0a7ec     A8 99 02 F6 |                 mov     hctwait, _1ms_
0a7f0     EF 02 A0 FD |                 call    #poll_waitx
0a7f4     FD 73 6F FB |                 djnz    htmp,#.wait_recover
0a7f8                 | 
0a7f8     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
0a7fc     07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
0a800     0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
0a804                 | 
0a804     00 08 00 FF 
0a808     00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
0a80c     8C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
0a810     03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
0a814     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
0a818     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
0a81c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
0a820     48 01 90 5D |         if_nz   jmp     #.done
0a824                 | .get_dev_desc
0a824     28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
0a828     07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
0a82c     F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
0a830     80 01 D0 FE |                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
0a834     2D 73 03 F6 |                 mov     htmp, hdev_port             ' Address is hub port number
0a838     01 73 57 FC |                 wrword  htmp, ptra[wValue]
0a83c     A0 02 A0 FD |                 call    #control_write                  ' Execute SetAddress()
0a840     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
0a844     24 01 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
0a848     AD 99 02 F6 |                 mov     hctwait, _8ms_
0a84c     EF 02 A0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
0a850     2D BD 02 F6 |                 mov     ep_addr_pid, hdev_port
0a854     08 BC 66 F0 |                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
0a858     BE 00 A0 FD |                 call    #calc_crc5
0a85c     3C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
0a860     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
0a864     F7 AD C2 FA |                 rdbyte  total_data, pb
0a868     03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
0a86c     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
0a870     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
0a874     F4 00 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
0a878     5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
0a87c     28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
0a880                 |                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
0a880     A0 99 02 F6 |                 mov     hctwait, _500us_
0a884     EF 02 A0 FD |                 call    #poll_waitx
0a888     18 01 D0 FE |                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
0a88c     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
0a890     29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
0a894     55 02 A0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
0a898     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
0a89c     CC 00 90 5D |         if_nz   jmp     #.done
0a8a0     29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
0a8a4     F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
0a8a8     61 87 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
0a8ac     61 89 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
0a8b0     00 73 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
0a8b4     09 86 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
0a8b8     02 88 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
0a8bc     56 73 1B A2 |         if_z    cmp     htmp, total_data        wcz
0a8c0     0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
0a8c4     A4 00 90 CD |         if_b    jmp     #.done
0a8c8     68 F0 BF FD |                 call    #hparse_con_desc
0a8cc     9C 00 90 FD |                 jmp     #.done
0a8d0                 | 
0a8d0                 | .other
0a8d0     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz
0a8d4     01 29 5C AC |         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
0a8d8     28 00 90 AD |         if_x1   jmp     #.reset_feature
0a8dc     11 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
0a8e0     01 23 5C AC |         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
0a8e4     1C 00 90 AD |         if_x1   jmp     #.reset_feature
0a8e8     12 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
0a8ec     01 25 5C AC |         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
0a8f0     10 00 90 AD |         if_x1   jmp     #.reset_feature
0a8f4     13 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
0a8f8     01 27 5C AC |         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
0a8fc     04 00 90 AD |         if_x1   jmp     #.reset_feature
0a900     68 00 90 FD |                 jmp     #.done
0a904                 | .reset_feature
0a904     E4 00 D0 FE |                 loc     ptra, #clr_port_feat
0a908     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
0a90c     A0 02 A0 FD |                 call    #control_write
0a910     58 00 90 FD |                 jmp     #.done
0a914                 | .disconnect
0a914                 | 
0a914     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
0a918     00 72 E3 F8 |                 getbyte htmp
0a91c     03 72 0F F2 |                 cmp     htmp,#KB_READY wz
0a920     05 72 0F 52 |         if_nz   cmp     htmp,#KBM_READY wz
0a924     00 F2 06 A6 |         if_z    mov     hkbd_ep_addr, #0
0a928     00 F0 06 A6 |         if_z    mov     hkbd_ctrl_ep, #0
0a92c     00 76 06 A6 |         if_z    mov     kb_led_states, #0
0a930     3B F9 02 A6 |         if_z    mov     hkbd_ledstates, kb_led_states
0a934                 |         if EMUPAD_MAX_PLAYER > 0
0a934                 |         end
0a934                 |         if HAVE_MOUSE
0a934     04 72 0F F2 |                 cmp     htmp, #M_READY          wz
0a938     05 72 0F 52 |         if_nz   cmp     htmp, #KBM_READY        wz
0a93c     00 F4 06 A6 |         if_z    mov     hmouse_ep_addr, #0
0a940                 |         end
0a940                 |         if HAVE_HIDPAD
0a940     30 0A F0 FE |                 loc ptrb,#hidpad_report
0a944     2D 73 03 F6 |                 mov htmp,hdev_port
0a948     01 72 E7 F2 |                 cmpsub htmp,#1
0a94c     20 72 07 FA |                 mul htmp,#HIDPAD_REPORT_SIZE
0a950     B9 F3 03 F1 |                 add ptrb,htmp
0a954     28 0E 64 FD |                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
0a958     80 01 6C FC |                 wrlong #0,ptrb
0a95c                 |         end
0a95c                 | 
0a95c     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
0a960     00 00 C4 F8 |                 setbyte #0
0a964     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
0a968     00 00 04 F6 |                 mov     0-0, #0
0a96c                 | 
0a96c                 | .done
0a96c     0E 6A 1F F4 |                 bitl    _usb_h_ls_nco_, #14     wcz
0a970     07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
0a974     22 6F 13 CC |         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
0a978     40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
0a97c     A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
0a980     A4 9B 02 F6 |                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
0a984                 | 
0a984     6C 00 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
0a988     27 EF 03 F6 |                 mov     pb, urx_buff_p
0a98c     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
0a990     55 02 A0 FD |                 call    #control_read
0a994     00 69 06 FB |                 rdlong  hub_port_status, ptra
0a998                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
0a998     2D 00 64 FD |                 ret
0a99c                 | 
0a99c                 | '------------------------------------------------------------------------------
0a99c                 | ' Partially populated SETUP packets
0a99c                 | '------------------------------------------------------------------------------
0a99c     80          | get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
0a99d     06          |                 byte    REQ_GET_DESC
0a99e     00 01       |                 word    TYPE_DEVICE << 8
0a9a0     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
0a9a2     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
0a9a4     80          | get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
0a9a5     06          |                 byte    REQ_GET_DESC
0a9a6     00 02       |                 word    TYPE_CONFIG << 8
0a9a8     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
0a9aa     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
0a9ac     00          | set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
0a9ad     09          |                 byte    REQ_SET_CONFIG
0a9ae     00 00       |                 word    0       ' Configuration value
0a9b0     00 00       |                 word    0       ' Zero
0a9b2     00 00       |                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
0a9b4     00          | set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
0a9b5     05          |                 byte    REQ_SET_ADDR
0a9b6     00 00       |                 word    0       ' Zero
0a9b8     00 00       |                 word    0       ' Zero
0a9ba     00 00       |                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
0a9bc                 | '------------------------------------------------------------------------------
0a9bc                 | ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
0a9bc                 | ' wValue field dictates which protocol should be used.
0a9bc                 | '
0a9bc                 | ' When initialized, all devices default to report protocol. However the host
0a9bc                 | ' should not make any assumptions about the device state and should set the
0a9bc                 | ' desired protocol whenever initializing a device.
0a9bc                 | '------------------------------------------------------------------------------
0a9bc     21          | set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
0a9bd     0B          |                 byte    HID_SET_PROTO
0a9be     00 00       |                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
0a9c0                 |                                                 ' (HID 1.11 Section 7.2.6).
0a9c0     00 00       |                 word    0               ' Interface index number.
0a9c2     00 00       |                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
0a9c4                 | '------------------------------------------------------------------------------
0a9c4     21          | set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
0a9c5     0A          |                 byte    HID_SET_IDLE
0a9c6     00 00       |                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
0a9c8                 |                                         ' reporting until a change is detected in the report data
0a9c8                 | 
0a9c8                 |                                         ' (HID 1.11 Section 7.2.4).
0a9c8     00 00       |                 word    0       ' Interface index number.
0a9ca     00 00       |                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
0a9cc     21          | set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
0a9cd     09          |                 byte    HID_SET_REPORT
0a9ce     00 00       |                 word    0       ' Byte1 = report type, byte0 = ReportID.
0a9d0                 |                                         ' (HID 1.11 Section 7.2.2).
0a9d0     00 00       |                 word    0       ' Interface index number.
0a9d2     00 00       |                 word    0       ' Size of the report, in bytes.
0a9d4     81          | get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
0a9d5     06          |                 byte    REQ_GET_DESC
0a9d6     00 22       |                 word    TYPE_REPORT << 8
0a9d8     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
0a9da     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
0a9dc                 | '------------------------------------------------------------------------------
0a9dc     A0          | get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
0a9dd     06          |                 byte    REQ_GET_DESC
0a9de     00 29       |                 word    TYPE_HUB << 8
0a9e0     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
0a9e2     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
0a9e4     23          | set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
0a9e5     03          |                 byte    REQ_SET_FEATURE
0a9e6     00 00       |                 word    0       ' port power
0a9e8     01 00       |                 word    1       ' Port index number (1+)
0a9ea     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
0a9ec     23          | clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
0a9ed     01          |                 byte    REQ_CLEAR_FEATURE
0a9ee     00 00       |                 word    0       ' port power
0a9f0     01 00       |                 word    1       ' Port index number (1+)
0a9f2     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
0a9f4     A3          | get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
0a9f5     00          |                 byte    REQ_GET_STATUS
0a9f6     00 00       |                 word    0
0a9f8     01 00       |                 word    1       ' Port index number (1+)
0a9fa     04 00       |                 word    4       ' Number of bytes to transfer if there is a data stage
0a9fc                 | '------------------------------------------------------------------------------
0a9fc                 | if _HAVE_GAMEPAD
0a9fc     42 0C 00 00 | ps3_enable_cmd  byte    $42, $0C, $00, $00
0aa00                 | ps3_command_buff
0aa00     00 00 00 00 
0aa04     00          |                 byte    $00, $00, $00, $00, $00
0aa05     00 00 00 00 
0aa09     02          |                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
0aa0a     FF 27 10 00 
0aa0e     32          |                 byte    $FF, $27, $10, $00, $32
0aa0f     FF 27 10 00 
0aa13     32          |                 byte    $FF, $27, $10, $00, $32
0aa14     FF 27 10 00 
0aa18     32          |                 byte    $FF, $27, $10, $00, $32
0aa19     FF 27 10 00 
0aa1d     32          |                 byte    $FF, $27, $10, $00, $32
0aa1e     00 00 00 00 
0aa22     00          |                 byte    $00, $00, $00, $00, $00
0aa23     00 00 00 00 
0aa27     00          |                 byte    $00, $00, $00, $00, $00
0aa28     00 00 00 00 
0aa2c     00          |                 byte    $00, $00, $00, $00, $00
0aa2d     00 00 00    |                 byte    $00, $00, $00
0aa30                 | '------------------------------------------------------------------------------
0aa30     01 03 06    | xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
0aa33                 |                                         ' 0x01 All blinking
0aa33                 |                                         ' 0x02 1 flashes, then on
0aa33                 |                                         ' 0x03 2 flashes, then on
0aa33                 |                                         ' 0x04 3 flashes, then on
0aa33                 |                                         ' 0x05 4 flashes, then on
0aa33                 |                                         ' 0x06 1 on
0aa33                 |                                         ' 0x07 2 on
0aa33                 |                                         ' 0x08 3 on
0aa33                 |                                         ' 0x09 4 on
0aa33                 |                                         ' 0x0A Rotating (e.g. 1-2-4-3)
0aa33                 |                                         ' 0x0B Blinking*
0aa33                 |                                         ' 0x0C Slow blinking*
0aa33                 |                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
0aa33     00 08 00    | xinp_rumble_cmd byte    $00, $08, $00
0aa36     00          |                 byte    $00             ' Left rumble
0aa37     00          |                 byte    $00             ' Right rumble
0aa38     00 00 00    |                 byte    $00, $00, $00
0aa3b                 | 
0aa3b                 | xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
0aa3b                 |                 '' of certain wired 8bitdo gamepads.
0aa3b     80          |                 byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
0aa3c     06          |                 byte    REQ_GET_DESC
0aa3d     04 03       |                 word    TYPE_STRING << 8 + 4
0aa3f     09 04       |                 word    $0409   ' Zero or Language ID (Section 9.6.7)
0aa41     02 00       |                 word    2       ' Number of bytes to transfer if there is a data stage
0aa43     00          | end
0aa44                 | alignl
0aa44                 | 
0aa44                 | if HAVE_MOUSE
0aa44     00 00 00 00 
0aa48     00 00 00 00 | mouse_limits long 0[2]
0aa4c     00 00 00 00 | mouse_outptr long 0
0aa50                 | end
0aa50                 | 
0aa50                 | if KEYQUEUE_SIZE > 0
0aa50     00          | keyq_head byte 0
0aa51     00          | keyq_tail byte 0
0aa52     00 00 00 00 
      ...             
0ac4e     00 00 00 00 
0ac52     00 00       | keyq_data long 0[KEYQUEUE_SIZE]
0ac54                 | alignl
0ac54                 | end
0ac54                 | 
0ac54                 | if EMUPAD_MAX_PLAYER > 0
0ac54                 | emupad_rule_buffer
0ac54                 | if EMUPAD_BUILTIN_RULES
0ac54                 | file "padmap_builtin.dat"
0ac54                 | end
0ac54                 | byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
0ac54                 | '' Default rule directly follows!
0ac54                 | byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
0ac54                 | end
0ac54                 | 
0ac54                 | '------------------------------------------------------------------------------
0ac54                 | ' The USB data cache area gets zero-filled at every device disconnect
0ac54                 | '------------------------------------------------------------------------------
0ac54                 | usb_cache_start
0ac54                 | 
0ac54                 | ' HID descriptor and report buffers
0ac54                 | if !!OVERLAP_MEMORY
0ac54     00 00 00 00 
      ...             
0b34c     00 00 00 00 
0b350     00 00 00 00 | hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
0b354                 | end
0b354     00 00 00 00 
0b358     00 00 00 00 | hkbd_report     byte    0[8]
0b35c     00 00 00 00 | hkbd_led_rep    byte    0
0b360                 | alignl
0b360                 | 
0b360     00 00 00 00 
0b364     00 00 00 00 
0b368     00 00 00 00 
0b36c     00 00 00 00 
0b370     00 00 00 00 | hid_stack       long 0[(hidr_end - hidr_state) * 1]
0b374                 | 
0b374                 | if HAVE_HIDPAD
0b374     00 00 00 00 
      ...             
0b44c     00 00 00 00 
0b450     00 00 00 00 | hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
0b454                 | end
0b454                 | 
0b454                 | ' HUB descriptor
0b454     00          | hub_descr       byte    0   ' bDescLength
0b455     00          |                 byte    0   ' bDescriptorType
0b456     00          |                 byte    0   ' bNbrPorts
0b457     00 00       |                 word    0   ' wHubCharacteristics
0b459     00          |                 byte    0   ' bPwrOn2PwrGood
0b45a     00          |                 byte    0   ' bHubContrCurrent
0b45b     00          |                 byte    0   ' DeviceRemoveable
0b45c     00          |                 byte    0   ' PortPwrCtrlMask
0b45d                 | 
0b45d                 | usb_cache_end
0b45d                 | 
0b45d                 | if HAVE_MOUSE
0b45d     00 00 00 00 | mouse_xacc      long 0
0b461     00 00 00 00 | mouse_yacc      long 0
0b465     00 00 00 00 | mouse_zacc      long 0
0b469     00          | mouse_bstate    byte 0
0b46a     00          | mouse_lpending  byte 0
0b46b     00          | mouse_rpending  byte 0
0b46c     00          | mouse_mpending  byte 0
0b46d     00          | mouse_lock      byte 0
0b46e     00 00 00    |                 byte 0[3] ' padding
0b471                 | end
0b471                 | 
0b471     00 00 00 00 
      ...             
0b4e9     00 00 00 00 
0b4ed     00 00 00 00 | urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
0b4f1     00 00 00 00 
0b4f5     00 00 00 00 
0b4f9     00 00 00 00 
0b4fd     00 00 00 00 
0b501     00 00       | dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
0b503     00 00 00 00 
      ...             
0b5fb     00 00 00 00 
0b5ff     00 00 00 00 | con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
0b603                 | 
0b603     00          | driver_cog      byte    0                       ' Current driver cog + 1
0b604                 | 	alignl
0b604                 | __system__dat_
0b604     00 00 00 00 
0b608     00 00 00 00 | 	byte	$00[8]
0b60c     03 00 00 00 
0b610     00 00 00 00 
0b614     00 00 00 00 
0b618     00 00 00 00 | 	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0b61c     00 00 00 00 
0b620     00 00 00 00 
0b624     00 00 00 00 
0b628     00 00 00 00 
0b62c     00 00 00 00 
0b630     00 00 00 00 | 	byte	$00[24]
0b634     01 80 00 00 
0b638     00 00 00 00 
0b63c     00 00 00 00 
0b640     00 00 00 00 | 	byte	$01, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0b644     00 00 00 00 | 	byte	$00, $00, $00, $00
0b648     00 00 00 00 | 	long	(0 {__system___tx})<<20
0b64c     00 00 10 00 | 	long	(1 {__system___rx})<<20
0b650     00 00 00 00 | 	byte	$00, $00, $00, $00
0b654     00 00 C0 00 | 	long	(12 {__system___rxtxioctl_0145})<<20
0b658     00 00 D0 00 | 	long	(13 {__system____dummy_flush_0146})<<20
0b65c     00 00 00 00 
0b660     00 00 00 00 | 	byte	$00[8]
0b664     01 00 00 00 
0b668     02 80 00 00 
0b66c     00 00 00 00 
0b670     00 00 00 00 | 	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0b674     00 00 00 00 
0b678     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
0b67c     00 00 00 00 | 	long	(0 {__system___tx})<<20
0b680     00 00 10 00 | 	long	(1 {__system___rx})<<20
0b684     00 00 00 00 | 	byte	$00, $00, $00, $00
0b688     00 00 C0 00 | 	long	(12 {__system___rxtxioctl_0145})<<20
0b68c     00 00 D0 00 | 	long	(13 {__system____dummy_flush_0146})<<20
0b690     00 00 00 00 
0b694     00 00 00 00 | 	byte	$00[8]
0b698     01 00 00 00 
0b69c     02 80 00 00 
0b6a0     00 00 00 00 
0b6a4     00 00 00 00 | 	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0b6a8     00 00 00 00 
0b6ac     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
0b6b0     00 00 00 00 | 	long	(0 {__system___tx})<<20
0b6b4     00 00 10 00 | 	long	(1 {__system___rx})<<20
0b6b8     00 00 00 00 | 	byte	$00, $00, $00, $00
0b6bc     00 00 C0 00 | 	long	(12 {__system___rxtxioctl_0145})<<20
0b6c0     00 00 D0 00 | 	long	(13 {__system____dummy_flush_0146})<<20
0b6c4     00 00 00 00 
      ...             
0b82c     00 00 00 00 
0b830     00 00 00 00 | 	byte	$00[368]
0b834                 | __methodtable__
0b834     78 27 00 00 | 	long	@__system___tx
0b838     B8 27 00 00 | 	long	@__system___rx
0b83c     6C 14 00 00 | 	long	@_hg010b_spin2_putchar
0b840     9C 1E 00 00 | 	long	@_usbnew_spin2_get_key
0b844     08 3B 00 00 | 	long	@__system___struct___bas_wrap_sender_tx_
0b848     4C 3B 00 00 | 	long	@__system___struct___bas_wrap_sender_rx_
0b84c     94 3B 00 00 | 	long	@__system___struct___bas_wrap_sender_close_
0b850     38 3A 00 00 | 	long	@__system___struct__s_vfs_file_t_putchar_
0b854     A8 3A 00 00 | 	long	@__system___struct__s_vfs_file_t_getchar_
0b858     68 35 00 00 | 	long	@__system____default_putc
0b85c     E4 34 00 00 | 	long	@__system____default_getc
0b860     14 36 00 00 | 	long	@__system____default_flush
0b864     08 39 00 00 | 	long	@__system___rxtxioctl_0145
0b868     60 39 00 00 | 	long	@__system____dummy_flush_0146
0b86c                 | __heap_base
0b86c     00 00 00 00 
      ...             
0cfdc     00 00 00 00 
0cfe0     00 00 00 00 | 	long	0[1502]
0cfe4                 | objmem
0cfe4     00 00 00 00 
      ...             
18c34     00 00 00 00 
18c38     00 00 00 00 | 	long	0[12054]
18c3c                 | stackspace
18c3c     00 00 00 00 | 	long	0[1]
18c40 13d             | 	org	COG_BSS_START
18c40 13d             | _var01
18c40 13d             | 	res	1
18c40 13e             | _var02
18c40 13e             | 	res	1
18c40 13f             | _var03
18c40 13f             | 	res	1
18c40 140             | _var04
18c40 140             | 	res	1
18c40 141             | _var05
18c40 141             | 	res	1
18c40 142             | _var06
18c40 142             | 	res	1
18c40 143             | _var07
18c40 143             | 	res	1
18c40 144             | _var08
18c40 144             | 	res	1
18c40 145             | arg01
18c40 145             | 	res	1
18c40 146             | arg02
18c40 146             | 	res	1
18c40 147             | arg03
18c40 147             | 	res	1
18c40 148             | arg04
18c40 148             | 	res	1
18c40 149             | arg05
18c40 149             | 	res	1
18c40 14a             | local01
18c40 14a             | 	res	1
18c40 14b             | local02
18c40 14b             | 	res	1
18c40 14c             | local03
18c40 14c             | 	res	1
18c40 14d             | local04
18c40 14d             | 	res	1
18c40 14e             | local05
18c40 14e             | 	res	1
18c40 14f             | local06
18c40 14f             | 	res	1
18c40 150             | local07
18c40 150             | 	res	1
18c40 151             | local08
18c40 151             | 	res	1
18c40 152             | local09
18c40 152             | 	res	1
18c40 153             | local10
18c40 153             | 	res	1
18c40 154             | local11
18c40 154             | 	res	1
18c40 155             | local12
18c40 155             | 	res	1
18c40 156             | local13
18c40 156             | 	res	1
18c40 157             | muldiva_
18c40 157             | 	res	1
18c40 158             | muldivb_
18c40 158             | 	res	1
18c40 159             | 	fit	480
18c40 159             | 
