00000                 | 
00000                 | #line 1 "D:/programowanie/P2-Retromachine-Basic/audiotest.p2asm"
00000                 | con
00000                 | 	_clkfreq = 160000000
00000                 | 	_clkmode = 16779259
00000                 | 	clkfreq = 340000000
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 160000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $10007fb
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 9C 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 02 90 5D |  if_ne	jmp	#spininit
0040c 002 CD F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 01 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 03 80 80 FF 
00420 007 00 F0 67 FD | 	hubset	##16779256
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 03 80 00 FF 
00430 00b FB ED 07 F6 | 	mov	pa, ##16779259
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e B4 C4 84 FF 
00440 00f 14 00 6C FC | 	wrlong	##160000000, #20
00444 010 BC 01 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
005fc 07e 00 00 00 00 
00600 07f 00 00 00 00 | 	orgf	128
00604 080             | skip_clock_set_
00604 080 44 07 A0 FD | 	call	#_program
00608 081             | cogexit
00608 081 38 01 80 FF 
0060c 082 1F 00 66 FD | 	waitx	##160000
00610 083 01 A6 61 FD | 	cogid	arg01
00614 084 03 A6 61 FD | 	cogstop	arg01
00618 085             | spininit
00618 085 61 8F 05 FB | 	rdlong	objptr, ptra++
0061c 086 61 9D 05 FB | 	rdlong	result1, ptra++
00620 087 28 06 64 FD | 	setq	#3
00624 088 00 A7 05 FB | 	rdlong	arg01, ptra
00628 089 04 F0 87 F1 | 	sub	ptra, #4
0062c 08a 2D 9C 61 FD | 	call	result1
00630 08b D4 FF 9F FD | 	jmp	#cogexit
00634 08c             | FCACHE_LOAD_
00634 08c F9 2D 01 F6 |     mov	fcache_tmpb_,ptrb
00638 08d 2B F2 63 FD |     pop	ptrb
0063c 08e 95 EC 8B F9 |     altd	pa,ret_instr_
00640 08f 95 00 00 F6 |     mov	 0-0, ret_instr_
00644 090 28 EC 63 FD |     setq	pa
00648 091 E1 01 04 FB |     rdlong	$0, ptrb++
0064c 092 2A F2 63 FD |     push	ptrb
00650 093 96 F2 03 F6 |     mov ptrb,fcache_tmpb_
00654 094 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00658 095             | ret_instr_
00658 095 00 FE 07 02 |     _ret_ cmp inb,#0
0065c 096             | fcache_tmpb_
0065c 096 00 00 00 00 |     long 0
00660 097             | fcache_load_ptr_
00660 097 8C 00 00 00 |     long FCACHE_LOAD_
00664 098             | builtin_bytefill_
00664 098 01 AA 55 F0 |         shr	arg03, #1 wc
00668 099 D3 A8 41 CC |  if_c   wrbyte	arg02, arg01
0066c 09a 01 A6 05 C1 |  if_c   add	arg01, #1
00670 09b 00 A8 FD F9 |         movbyts	arg02, #0
00674 09c             | builtin_wordfill_
00674 09c 01 AA 55 F0 |         shr	arg03, #1 wc
00678 09d D3 A8 51 CC |  if_c   wrword	arg02, arg01
0067c 09e 02 A6 05 C1 |  if_c   add	arg01, #2
00680 09f D4 A8 29 F9 |         setword	arg02, arg02, #1
00684 0a0             | builtin_longfill_
00684 0a0 D3 00 88 FC |         wrfast	#0,arg01
00688 0a1 00 AA 0D F2 |         cmp	arg03, #0 wz
0068c 0a2 D5 02 D8 5C |  if_nz  rep	#1, arg03
00690 0a3 17 A8 61 5D |  if_nz  wflong	arg02
00694 0a4 2D 00 64 FD |         ret
00698 0a5             | COUNT_
00698 0a5 00 00 00 00 |     long 0
0069c 0a6             | RETADDR_
0069c 0a6 00 00 00 00 |     long 0
006a0 0a7             | fp
006a0 0a7 00 00 00 00 |     long 0
006a4 0a8             | pushregs_
006a4 0a8 2B EC 63 FD |     pop  pa
006a8 0a9 2B 4C 61 FD |     pop  RETADDR_
006ac 0aa 03 4A 95 FB |     tjz  COUNT_, #pushregs_done_
006b0 0ab FF 4B 8D F9 |     altd  COUNT_, #511
006b4 0ac 28 00 64 FD |     setq #0-0
006b8 0ad 61 B3 65 FC |     wrlong local01, ptra++
006bc 0ae             | pushregs_done_
006bc 0ae 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
006c0 0af 61 4B 65 FC |     wrlong COUNT_, ptra++
006c4 0b0 F8 4F 01 F6 |     mov    fp, ptra
006c8 0b1 2C EC 63 FD |     jmp  pa
006cc 0b2             |  popregs_
006cc 0b2 2B EC 63 FD |     pop    pa
006d0 0b3 28 04 64 FD |     setq   #2
006d4 0b4 5F 4B 05 FB |     rdlong COUNT_, --ptra
006d8 0b5 02 4A 75 FB |     djf    COUNT_, #popregs__ret
006dc 0b6 28 4A 61 FD |     setq   COUNT_
006e0 0b7 5F B3 05 FB |     rdlong local01, --ptra
006e4 0b8             | popregs__ret
006e4 0b8 2A 4C 61 FD |     push   RETADDR_
006e8 0b9 2C EC 63 FD |     jmp    pa
006ec 0ba             | 
006ec 0ba             | divide_
006ec 0ba E7 CE 59 F6 |        abs     muldivb_,muldivb_     wcz      'abs(y)
006f0 0bb 6C 8C 61 FD |        wrc     itmp2_                         'store sign of y
006f4 0bc E6 CC 51 F6 |        abs     muldiva_,muldiva_     wc       'abs(x)
006f8 0bd E7 CC 11 FD |        qdiv    muldiva_, muldivb_             'queue divide
006fc 0be 01 8C 65 C5 |  if_c  xor     itmp2_,#1                      'store sign of x
00700 0bf 18 CE 61 FD |        getqx   muldivb_                       'get quotient
00704 0c0 19 CC 61 FD |        getqy   muldiva_                       'get remainder
00708 0c1 E6 CC 81 F6 |        negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
0070c 0c2 00 8C 15 F4 |        testb   itmp2_,#0             wc       'restore sign, division result
00710 0c3 E7 CE 81 06 |  _ret_ negc    muldivb_,muldivb_     
00714 0c4             | 
00714 0c4             | __methods__
00714 0c4 F4 42 00 00 | 	long	@__methodtable__
00718 0c5             | itmp1_
00718 0c5 00 00 00 00 | 	long	0
0071c 0c6             | itmp2_
0071c 0c6 00 00 00 00 | 	long	0
00720 0c7             | objptr
00720 0c7 24 43 00 00 | 	long	@objmem
00724 0c8             | ptr___system__dat__
00724 0c8 C4 40 00 00 | 	long	@__system__dat_
00728 0c9             | ptr__dat__
00728 0c9 48 1B 00 00 | 	long	@_dat_
0072c 0ca             | ptr__psram16drv_spin2_dat__
0072c 0ca 34 31 00 00 | 	long	@_psram16drv_spin2_dat_
00730 0cb             | ptr__psram_spin2_dat__
00730 0cb EC 2E 00 00 | 	long	@_psram_spin2_dat_
00734 0cc             | ptr__sa001_spin2_dat__
00734 0cc 58 23 00 00 | 	long	@_sa001_spin2_dat_
00738 0cd             | ptr_stackspace_
00738 0cd 30 45 00 00 | 	long	@stackspace
0073c 0ce             | result1
0073c 0ce 00 00 00 00 | 	long	0
00740 0cf             | result2
00740 0cf 01 00 00 00 | 	long	1
00744 0d0             | COG_BSS_START
00744 0d0             | 	fit	480
00744                 | 	orgh
00744                 | hubentry
00744                 | 
00744                 | _program
00744     01 00 00 FF 
00748     0C 8E 05 F1 | 	add	objptr, ##524
0074c                 | '     return startx(0, 0, 0, -1)
0074c     00 A6 05 F6 | 	mov	arg01, #0
00750     00 A8 05 F6 | 	mov	arg02, #0
00754     00 AA 05 F6 | 	mov	arg03, #0
00758     01 AC 65 F6 | 	neg	arg04, #1
0075c     4C 03 B0 FD | 	call	#_psram_spin2_startx
00760     C9 A6 01 F6 | 	mov	arg01, ptr__dat__
00764     10 A6 05 F1 | 	add	arg01, #16
00768     00 A8 05 F6 | 	mov	arg02, #0
0076c     0B AA C5 F9 | 	decod	arg03, #11
00770     64 05 B0 FD | 	call	#_psram_spin2_write
00774     01 00 00 FF 
00778     0C 8E 85 F1 | 	sub	objptr, ##524
0077c     FF 03 00 FF 
00780     00 A7 05 F6 | 	mov	arg01, ##524032
00784     00 A8 05 F6 | 	mov	arg02, #0
00788     80 03 00 FF 
0078c     00 AA 05 F6 | 	mov	arg03, ##458752
00790     78 00 B0 FD | 	call	#_sa001_spin2_start
00794     54 00 B0 FD | 	call	#_sa001_spin2_test
00798                 | ' 
00798                 | ' psram.start()
00798                 | ' psram.write(varptr(sinewave)+16,0,2048)
00798                 | ' audio.start($7FF00,0,$70000)
00798                 | ' audio.test()
00798                 | ' do: 
00798                 | LR__0001
00798                 | '   if lpeek($30)<>0 then print lpeek($30): lpoke $30,0
00798     30 9C 0D FB | 	rdlong	result1, #48 wz
0079c     F8 FF 9F AD |  if_e	jmp	#LR__0001
007a0     00 A6 05 F6 | 	mov	arg01, #0
007a4     84 10 B0 FD | 	call	#__system___getiolock_0095
007a8     CE A6 01 F6 | 	mov	arg01, result1
007ac     A4 07 B0 FD | 	call	#__system___lockmem
007b0     30 A8 05 FB | 	rdlong	arg02, #48
007b4     00 A6 05 F6 | 	mov	arg01, #0
007b8     00 AA 05 F6 | 	mov	arg03, #0
007bc     10 AC 05 F6 | 	mov	arg04, #16
007c0     38 09 B0 FD | 	call	#__system___basic_print_unsigned
007c4     00 A6 05 F6 | 	mov	arg01, #0
007c8     0A A8 05 F6 | 	mov	arg02, #10
007cc     00 AA 05 F6 | 	mov	arg03, #0
007d0     D0 08 B0 FD | 	call	#__system___basic_print_char
007d4     00 A6 05 F6 | 	mov	arg01, #0
007d8     50 10 B0 FD | 	call	#__system___getiolock_0095
007dc     CE 00 68 FC | 	wrlong	#0, result1
007e0     30 00 6C FC | 	wrlong	#0, #48
007e4     B0 FF 9F FD | 	jmp	#LR__0001
007e8                 | _program_ret
007e8     2D 00 64 FD | 	ret
007ec                 | 
007ec                 | ' 
007ec                 | ' 
007ec                 | ' pub test()
007ec                 | _sa001_spin2_test
007ec                 | ' 
007ec                 | ' 
007ec                 | ' play(2,0,$1000,16384,1024,0)  
007ec     02 A6 05 F6 | 	mov	arg01, #2
007f0     00 A8 05 F6 | 	mov	arg02, #0
007f4     0C AA C5 F9 | 	decod	arg03, #12
007f8     0E AC C5 F9 | 	decod	arg04, #14
007fc     0A AE C5 F9 | 	decod	arg05, #10
00800     00 B0 05 F6 | 	mov	arg06, #0
00804     F8 01 B0 FD | 	call	#_sa001_spin2_play
00808                 | _sa001_spin2_test_ret
00808     2D 00 64 FD | 	ret
0080c                 | 
0080c                 | ' 
0080c                 | ' '--------------------------------------------------------------
0080c                 | ' '---------- Init the variables, start the cog. ----------------
0080c                 | ' '--------------------------------------------------------------
0080c                 | ' 
0080c                 | ' pub start(mbox,scope,cache) :cog,base | iii
0080c                 | _sa001_spin2_start
0080c     04 4A 05 F6 | 	mov	COUNT_, #4
00810     A8 00 A0 FD | 	call	#pushregs_
00814     D3 B2 01 F6 | 	mov	local01, arg01
00818                 | ' 
00818                 | ' ' mbox: PSRAM mailbox or 0 if no PSRAM
00818                 | ' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
00818                 | ' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
00818                 | ' 
00818                 | ' mailboxaddr:=mbox 
00818     C7 B2 61 FC | 	wrlong	local01, objptr
0081c                 | ' scope_ptr:=scope
0081c     04 8E 05 F1 | 	add	objptr, #4
00820     C7 A8 61 FC | 	wrlong	arg02, objptr
00824                 | ' cache_ptr:=cache
00824     04 8E 05 F1 | 	add	objptr, #4
00828     C7 AA 61 FC | 	wrlong	arg03, objptr
0082c                 | ' base:=@channel1[0]
0082c     04 8E 05 F1 | 	add	objptr, #4
00830     C7 B4 01 F6 | 	mov	local02, objptr
00834                 | ' long[$40]:=mbox
00834     40 B2 65 FC | 	wrlong	local01, #64
00838                 | ' repeat iii from 0 to 7
00838     00 B6 05 F6 | 	mov	local03, #0
0083c     01 00 00 FF 
00840     7C 99 05 F1 | 	add	ptr__sa001_spin2_dat__, ##892
00844     0C 8E 85 F1 | 	sub	objptr, #12
00848     97 BC 48 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
0084c                 | LR__0010
0084c                 | '   long[base+64*iii]:=0
0084c     DA B2 01 F6 | 	mov	local01, local02
00850     DB 9E 01 F6 | 	mov	result2, local03
00854     06 9E 65 F0 | 	shl	result2, #6
00858     CF B2 01 F1 | 	add	local01, result2
0085c     D9 00 68 FC | 	wrlong	#0, local01
00860                 | '   long[base+64*iii+4]:=0
00860     DA B2 01 F6 | 	mov	local01, local02
00864     DB 9E 01 F6 | 	mov	result2, local03
00868     06 9E 65 F0 | 	shl	result2, #6
0086c     CF B2 01 F1 | 	add	local01, result2
00870     04 B2 05 F1 | 	add	local01, #4
00874     D9 00 68 FC | 	wrlong	#0, local01
00878                 | '   long[base+64*iii+12]:=0
00878     DA B8 01 F6 | 	mov	local04, local02
0087c     DB B2 01 F6 | 	mov	local01, local03
00880     06 B2 65 F0 | 	shl	local01, #6
00884     D9 B8 01 F1 | 	add	local04, local01
00888     0C B8 05 F1 | 	add	local04, #12
0088c     DC 00 68 FC | 	wrlong	#0, local04
00890                 | '   long[base+64*iii+16]:=2 
00890     DA B8 01 F6 | 	mov	local04, local02
00894     DB B2 01 F6 | 	mov	local01, local03
00898     06 B2 65 F0 | 	shl	local01, #6
0089c     D9 B8 01 F1 | 	add	local04, local01
008a0     10 B8 05 F1 | 	add	local04, #16
008a4     DC 04 68 FC | 	wrlong	#2, local04
008a8                 | '   word[base+64*iii+20]:=0
008a8     DA B8 01 F6 | 	mov	local04, local02
008ac     DB B2 01 F6 | 	mov	local01, local03
008b0     06 B2 65 F0 | 	shl	local01, #6
008b4     D9 B8 01 F1 | 	add	local04, local01
008b8     14 B8 05 F1 | 	add	local04, #20
008bc     DC 00 58 FC | 	wrword	#0, local04
008c0                 | '   word[base+64*iii+22]:=8192
008c0     DA B8 01 F6 | 	mov	local04, local02
008c4     DB B2 01 F6 | 	mov	local01, local03
008c8     06 B2 65 F0 | 	shl	local01, #6
008cc     D9 B8 01 F1 | 	add	local04, local01
008d0     16 B8 05 F1 | 	add	local04, #22
008d4     10 00 80 FF 
008d8     DC 00 58 FC | 	wrword	##8192, local04
008dc                 | '   word[base+64*iii+24]:=4000+2*iii
008dc     DB B8 01 F6 | 	mov	local04, local03
008e0     01 B8 65 F0 | 	shl	local04, #1
008e4     07 00 00 FF 
008e8     A0 B3 05 F6 | 	mov	local01, ##4000
008ec     DC B2 01 F1 | 	add	local01, local04
008f0     DA B8 01 F6 | 	mov	local04, local02
008f4     DB 9E 01 F6 | 	mov	result2, local03
008f8     06 9E 65 F0 | 	shl	result2, #6
008fc     CF B8 01 F1 | 	add	local04, result2
00900     18 B8 05 F1 | 	add	local04, #24
00904     DC B2 51 FC | 	wrword	local01, local04
00908                 | '   word[base+64*iii+26]:=2
00908     DA B8 01 F6 | 	mov	local04, local02
0090c     DB B2 01 F6 | 	mov	local01, local03
00910     06 B2 65 F0 | 	shl	local01, #6
00914     D9 B8 01 F1 | 	add	local04, local01
00918     1A B8 05 F1 | 	add	local04, #26
0091c     DC 04 58 FC | 	wrword	#2, local04
00920                 | '   long [base+64*iii+8]:=@null | $C0000000
00920     CC B2 01 F6 | 	mov	local01, ptr__sa001_spin2_dat__
00924     3E B2 25 F4 | 	bith	local01, #62
00928     DA B8 01 F6 | 	mov	local04, local02
0092c     DB AA 01 F6 | 	mov	arg03, local03
00930     06 AA 65 F0 | 	shl	arg03, #6
00934     D5 B8 01 F1 | 	add	local04, arg03
00938     08 B8 05 F1 | 	add	local04, #8
0093c     DC B2 61 FC | 	wrlong	local01, local04
00940                 | '   long[base+64*iii+32]:=0
00940     DA B8 01 F6 | 	mov	local04, local02
00944     DB B2 01 F6 | 	mov	local01, local03
00948     06 B2 65 F0 | 	shl	local01, #6
0094c     D9 B8 01 F1 | 	add	local04, local01
00950     20 B8 05 F1 | 	add	local04, #32
00954     DC 00 68 FC | 	wrlong	#0, local04
00958                 | '   long[base+64*iii+36]:=0
00958     DA B8 01 F6 | 	mov	local04, local02
0095c     DB B2 01 F6 | 	mov	local01, local03
00960     06 B2 65 F0 | 	shl	local01, #6
00964     D9 B8 01 F1 | 	add	local04, local01
00968     24 B8 05 F1 | 	add	local04, #36
0096c     DC 00 68 FC | 	wrlong	#0, local04
00970                 | '   long[base+64*iii+40]:=0
00970     DA B8 01 F6 | 	mov	local04, local02
00974     DB B2 01 F6 | 	mov	local01, local03
00978     06 B2 65 F0 | 	shl	local01, #6
0097c     D9 B8 01 F1 | 	add	local04, local01
00980     28 B8 05 F1 | 	add	local04, #40
00984     DC 00 68 FC | 	wrlong	#0, local04
00988                 | '   long[base+64*iii+44]:=0
00988     DA B8 01 F6 | 	mov	local04, local02
0098c     DB B2 01 F6 | 	mov	local01, local03
00990     06 B2 65 F0 | 	shl	local01, #6
00994     D9 B8 01 F1 | 	add	local04, local01
00998     2C B8 05 F1 | 	add	local04, #44
0099c     DC 00 68 FC | 	wrlong	#0, local04
009a0                 | '   long[base+64*iii+28]:=0
009a0     DA B8 01 F6 | 	mov	local04, local02
009a4     DB B2 01 F6 | 	mov	local01, local03
009a8     06 B2 65 F0 | 	shl	local01, #6
009ac     D9 B8 01 F1 | 	add	local04, local01
009b0     1C B8 05 F1 | 	add	local04, #28
009b4     DC 00 68 FC | 	wrlong	#0, local04
009b8     01 B6 05 F1 | 	add	local03, #1
009bc     08 B6 55 F2 | 	cmps	local03, #8 wc
009c0     88 FE 9F CD |  if_b	jmp	#LR__0010
009c4                 | LR__0011
009c4     01 00 00 FF 
009c8     7C 99 85 F1 | 	sub	ptr__sa001_spin2_dat__, ##892
009cc                 | '   
009cc                 | ' cog:=coginit(16,@audio,@mailboxaddr)
009cc     CC A8 01 F6 | 	mov	arg02, ptr__sa001_spin2_dat__
009d0     C7 AA 01 F6 | 	mov	arg03, objptr
009d4     10 B8 05 F6 | 	mov	local04, #16
009d8     28 AA 61 FD | 	setq	arg03
009dc     D4 B8 F1 FC | 	coginit	local04, arg02 wc
009e0     01 B8 65 C6 |  if_b	neg	local04, #1
009e4                 | ' waitms(100)
009e4     64 A6 05 F6 | 	mov	arg01, #100
009e8     4C 06 B0 FD | 	call	#__system___waitms
009ec                 | ' return cog,base
009ec     DA 9E 01 F6 | 	mov	result2, local02
009f0     DC 9C 01 F6 | 	mov	result1, local04
009f4     A7 F0 03 F6 | 	mov	ptra, fp
009f8     B2 00 A0 FD | 	call	#popregs_
009fc                 | _sa001_spin2_start_ret
009fc     2D 00 64 FD | 	ret
00a00                 | 
00a00                 | ' 
00a00                 | ' ' a simple play procedure to not poke everything. 
00a00                 | ' 
00a00                 | ' pub play(channel,sample,splfreq,vol,len,loop=-1) |base2
00a00                 | _sa001_spin2_play
00a00                 | ' 
00a00                 | ' base2:=@channel1[0]+64*channel
00a00     0C 8E 05 F1 | 	add	objptr, #12
00a04     C7 A0 01 F6 | 	mov	_var01, objptr
00a08     06 A6 65 F0 | 	shl	arg01, #6
00a0c     D3 A0 01 F1 | 	add	_var01, arg01
00a10                 | ' 
00a10                 | ' 
00a10                 | ' long[base2+12]:= len
00a10     D0 A6 01 F6 | 	mov	arg01, _var01
00a14     0C A6 05 F1 | 	add	arg01, #12
00a18     D3 AE 61 FC | 	wrlong	arg05, arg01
00a1c                 | ' if loop >=0 
00a1c     00 B0 55 F2 | 	cmps	arg06, #0 wc
00a20                 | '   long[base2+16]:= loop
00a20     0C 8E 85 F1 | 	sub	objptr, #12
00a24     D0 A6 01 36 |  if_ae	mov	arg01, _var01
00a28     10 A6 05 31 |  if_ae	add	arg01, #16
00a2c     D3 B0 61 3C |  if_ae	wrlong	arg06, arg01
00a30                 | ' else
00a30                 | '   long[base2+16]:= len+2
00a30     02 AE 05 C1 |  if_b	add	arg05, #2
00a34     D0 B0 01 C6 |  if_b	mov	arg06, _var01
00a38     10 B0 05 C1 |  if_b	add	arg06, #16
00a3c     D8 AE 61 CC |  if_b	wrlong	arg05, arg06
00a40                 | ' word[base2+20]:=vol
00a40     D0 A6 01 F6 | 	mov	arg01, _var01
00a44     14 A6 05 F1 | 	add	arg01, #20
00a48     D3 AC 51 FC | 	wrword	arg04, arg01
00a4c                 | ' long[base2+24]:= splfreq
00a4c     D0 A6 01 F6 | 	mov	arg01, _var01
00a50     18 A6 05 F1 | 	add	arg01, #24
00a54     D3 AA 61 FC | 	wrlong	arg03, arg01
00a58                 | ' 
00a58                 | ' long[base2+28]:=$40000000    
00a58     D0 A6 01 F6 | 	mov	arg01, _var01
00a5c     1C A6 05 F1 | 	add	arg01, #28
00a60     00 00 A0 FF 
00a64     D3 00 68 FC | 	wrlong	##1073741824, arg01
00a68                 | ' long[base2+32]:=0    
00a68     D0 A6 01 F6 | 	mov	arg01, _var01
00a6c     20 A6 05 F1 | 	add	arg01, #32
00a70     D3 00 68 FC | 	wrlong	#0, arg01
00a74                 | ' long[base2+36]:=0    
00a74     D0 A6 01 F6 | 	mov	arg01, _var01
00a78     24 A6 05 F1 | 	add	arg01, #36
00a7c     D3 00 68 FC | 	wrlong	#0, arg01
00a80                 | ' long[base2+40]:=0    
00a80     D0 A6 01 F6 | 	mov	arg01, _var01
00a84     28 A6 05 F1 | 	add	arg01, #40
00a88     D3 00 68 FC | 	wrlong	#0, arg01
00a8c                 | ' long[base2+44]:=0    
00a8c     D0 A6 01 F6 | 	mov	arg01, _var01
00a90     2C A6 05 F1 | 	add	arg01, #44
00a94     D3 00 68 FC | 	wrlong	#0, arg01
00a98                 | ' long[base2+8]:=sample+$C0000000     
00a98     00 00 60 FF 
00a9c     00 A8 05 F1 | 	add	arg02, ##-1073741824
00aa0     08 A0 05 F1 | 	add	_var01, #8
00aa4     D0 A8 61 FC | 	wrlong	arg02, _var01
00aa8                 | _sa001_spin2_play_ret
00aa8     2D 00 64 FD | 	ret
00aac                 | 
00aac                 | ' 
00aac                 | ' '..............................................................................
00aac                 | ' 
00aac                 | ' {{
00aac                 | ' }}
00aac                 | ' PUB startx(freq, burst, delay, desiredcog) : result | driverAddr
00aac                 | _psram_spin2_startx
00aac     04 4A 05 F6 | 	mov	COUNT_, #4
00ab0     A8 00 A0 FD | 	call	#pushregs_
00ab4     D3 B2 01 F6 | 	mov	local01, arg01
00ab8     D5 B4 01 F6 | 	mov	local02, arg03
00abc     D6 B6 01 F6 | 	mov	local03, arg04
00ac0                 | '     stop() ' restart driver if required
00ac0     54 01 B0 FD | 	call	#_psram_spin2_stop
00ac4     00 B2 0D F2 | 	cmp	local01, #0 wz
00ac8     14 B2 05 AB |  if_e	rdlong	local01, #20
00acc     D9 A8 51 F6 | 	abs	arg02, local01 wc
00ad0     A1 07 00 FF 
00ad4     40 A8 15 FD | 	qdiv	arg02, ##1000000
00ad8                 | ' 
00ad8                 | '     ' use current frequency if none specified
00ad8                 | ' 
00ad8                 | '     if freq == 0 
00ad8                 | '         freq := clkfreq 
00ad8                 | ' 
00ad8                 | '     ' compute the device burst size including overheads to keep CS low time below 8us
00ad8                 | ' 
00ad8                 | '     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
00ad8                 | '     if burst < 0
00ad8                 | '         return ERR_TOO_SLOW ' P2 frequency is too low for any 8us transfers
00ad8     18 A8 61 FD | 	getqx	arg02
00adc     D4 AC 81 F6 | 	negc	arg04, arg02
00ae0     03 AC 65 F0 | 	shl	arg04, #3
00ae4     84 AC 85 F1 | 	sub	arg04, #132
00ae8     04 AC 45 F0 | 	shr	arg04, #4
00aec     04 AC 65 F0 | 	shl	arg04, #4
00af0     00 AC 55 F2 | 	cmps	arg04, #0 wc
00af4     0E 9C 65 C6 |  if_b	neg	result1, #14
00af8     10 01 90 CD |  if_b	jmp	#LR__0023
00afc                 | ' 
00afc                 | '     ' compute the input delay
00afc                 | ' 
00afc                 | '     if delay <= 0
00afc     01 B4 55 F2 | 	cmps	local02, #1 wc
00b00     10 00 90 3D |  if_ae	jmp	#LR__0020
00b04                 | '         delay := lookupDelay(freq)
00b04     D9 A6 01 F6 | 	mov	arg01, local01
00b08     68 02 B0 FD | 	call	#_psram_spin2_lookupDelay
00b0c     CE B4 01 F6 | 	mov	local02, result1
00b10     04 00 90 FD | 	jmp	#LR__0021
00b14                 | LR__0020
00b14                 | '     else
00b14                 | '         delay <#= $f ' limit to 15
00b14     0F B4 65 F3 | 	fles	local02, #15
00b18                 | LR__0021
00b18                 | ' 
00b18                 | '     ' create our lock
00b18                 | ' 
00b18                 | '     driverlock := LOCKNEW()  
00b18     00 9C 05 F6 | 	mov	result1, #0
00b1c     04 9C 61 FD | 	locknew	result1
00b20     04 97 05 F1 | 	add	ptr__psram_spin2_dat__, #260
00b24     CB 9C 61 FC | 	wrlong	result1, ptr__psram_spin2_dat__
00b28                 | '     if driverlock == -1
00b28     04 97 85 F1 | 	sub	ptr__psram_spin2_dat__, #260
00b2c     FF FF 7F FF 
00b30     FF 9D 0D F2 | 	cmp	result1, ##-1 wz
00b34                 | '         return ERR_NO_LOCK
00b34     1A 9C 65 A6 |  if_e	neg	result1, #26
00b38     D0 00 90 AD |  if_e	jmp	#LR__0023
00b3c                 | ' 
00b3c                 | '     ' patch in the proper data and HUB addresses to the startup structure
00b3c                 | ' 
00b3c                 | '     long[@startupData][0]:=clkfreq
00b3c     14 B2 05 FB | 	rdlong	local01, #20
00b40     28 97 05 F1 | 	add	ptr__psram_spin2_dat__, #296
00b44     CB B2 61 FC | 	wrlong	local01, ptr__psram_spin2_dat__
00b48                 | ' '    long[@startupData][1]:=$1000_0000
00b48                 | '     long[@startupData][5]:=@deviceData
00b48     20 96 05 F1 | 	add	ptr__psram_spin2_dat__, #32
00b4c     CB B2 01 F6 | 	mov	local01, ptr__psram_spin2_dat__
00b50     20 96 85 F1 | 	sub	ptr__psram_spin2_dat__, #32
00b54     CB A8 01 F6 | 	mov	arg02, ptr__psram_spin2_dat__
00b58     14 A8 05 F1 | 	add	arg02, #20
00b5c     D4 B2 61 FC | 	wrlong	local01, arg02
00b60                 | '     long[@startupData][6]:=@qosData
00b60     A0 96 05 F1 | 	add	ptr__psram_spin2_dat__, #160
00b64     CB B2 01 F6 | 	mov	local01, ptr__psram_spin2_dat__
00b68     A0 96 85 F1 | 	sub	ptr__psram_spin2_dat__, #160
00b6c     CB A8 01 F6 | 	mov	arg02, ptr__psram_spin2_dat__
00b70     18 A8 05 F1 | 	add	arg02, #24
00b74     D4 B2 61 FC | 	wrlong	local01, arg02
00b78                 | '     long[@startupData][7]:=$7FF00
00b78     CB B2 01 F6 | 	mov	local01, ptr__psram_spin2_dat__
00b7c     1C B2 05 F1 | 	add	local01, #28
00b80     FF 03 80 FF 
00b84     D9 00 6A FC | 	wrlong	##524032, local01
00b88                 | ' 
00b88                 | '     ' setup some default bank and QoS parameter values
00b88                 | ' 
00b88                 | '     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
00b88     20 96 05 F1 | 	add	ptr__psram_spin2_dat__, #32
00b8c     CB A6 01 F6 | 	mov	arg01, ptr__psram_spin2_dat__
00b90     48 97 85 F1 | 	sub	ptr__psram_spin2_dat__, #328
00b94     10 AC 65 F0 | 	shl	arg04, #16
00b98     0C B4 65 F0 | 	shl	local02, #12
00b9c     DA AC 41 F5 | 	or	arg04, local02
00ba0     18 AC 45 F5 | 	or	arg04, #24
00ba4     D6 A8 01 F6 | 	mov	arg02, arg04
00ba8     02 AA 05 F6 | 	mov	arg03, #2
00bac     A0 00 A0 FD | 	call	#\builtin_longfill_
00bb0                 | '     longfill(@qosData, $FFFF0000, 8)
00bb0     C8 97 05 F1 | 	add	ptr__psram_spin2_dat__, #456
00bb4     07 AA 05 F6 | 	mov	arg03, #7
00bb8     28 AA 61 FD | 	setq	arg03
00bbc     80 FF FF FF 
00bc0     CB 00 68 FC | 	wrlong	##-65536, ptr__psram_spin2_dat__
00bc4                 | ' 
00bc4                 | '     ' get the address of the PSRAM memory driver so we can start it
00bc4                 | ' 
00bc4                 | '     driverAddr:= driver.getDriverAddr()
00bc4                 | '     return @driver_start
00bc4     20 94 05 F1 | 	add	ptr__psram16drv_spin2_dat__, #32
00bc8     CA A8 01 F6 | 	mov	arg02, ptr__psram16drv_spin2_dat__
00bcc     20 94 85 F1 | 	sub	ptr__psram16drv_spin2_dat__, #32
00bd0                 | ' 
00bd0                 | '     ' start the PSRAM memory driver and wait for it to complete initialization
00bd0                 | ' 
00bd0                 | '     if desiredcog < 0
00bd0     00 B6 55 F2 | 	cmps	local03, #0 wc
00bd4                 | '         desiredcog := NEWCOG
00bd4     10 B6 05 C6 |  if_b	mov	local03, #16
00bd8                 | '     drivercog := coginit(desiredcog, driverAddr, @startupData)
00bd8     A0 96 85 F1 | 	sub	ptr__psram_spin2_dat__, #160
00bdc     DB B8 01 F6 | 	mov	local04, local03
00be0     28 96 61 FD | 	setq	ptr__psram_spin2_dat__
00be4     D4 B8 F1 FC | 	coginit	local04, arg02 wc
00be8     01 B8 65 C6 |  if_b	neg	local04, #1
00bec     28 96 85 F1 | 	sub	ptr__psram_spin2_dat__, #40
00bf0     CB B8 61 FC | 	wrlong	local04, ptr__psram_spin2_dat__
00bf4                 | '     repeat until long[@startupData] == 0 
00bf4     28 96 05 F1 | 	add	ptr__psram_spin2_dat__, #40
00bf8                 | LR__0022
00bf8     CB B8 09 FB | 	rdlong	local04, ptr__psram_spin2_dat__ wz
00bfc     F8 FF 9F 5D |  if_ne	jmp	#LR__0022
00c00                 | ' 
00c00                 | '     return drivercog
00c00     28 96 85 F1 | 	sub	ptr__psram_spin2_dat__, #40
00c04     CB 9C 01 FB | 	rdlong	result1, ptr__psram_spin2_dat__
00c08     00 97 85 F1 | 	sub	ptr__psram_spin2_dat__, #256
00c0c                 | LR__0023
00c0c     A7 F0 03 F6 | 	mov	ptra, fp
00c10     B2 00 A0 FD | 	call	#popregs_
00c14                 | _psram_spin2_startx_ret
00c14     2D 00 64 FD | 	ret
00c18                 | 
00c18                 | ' 
00c18                 | ' '..............................................................................
00c18                 | ' 
00c18                 | ' {{
00c18                 | ' }}
00c18                 | ' PUB stop() : i
00c18                 | _psram_spin2_stop
00c18     00 A0 05 F6 | 	mov	_var01, #0
00c1c                 | '     if drivercog <> -1
00c1c     00 97 05 F1 | 	add	ptr__psram_spin2_dat__, #256
00c20     CB A6 01 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
00c24     00 97 85 F1 | 	sub	ptr__psram_spin2_dat__, #256
00c28     FF FF 7F FF 
00c2c     FF A7 0D F2 | 	cmp	arg01, ##-1 wz
00c30     70 00 90 AD |  if_e	jmp	#LR__0033
00c34                 | '         cogstop(drivercog) ' a rather brutal stop
00c34     00 97 05 F1 | 	add	ptr__psram_spin2_dat__, #256
00c38     CB A6 01 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
00c3c     00 97 85 F1 | 	sub	ptr__psram_spin2_dat__, #256
00c40     03 A6 61 FD | 	cogstop	arg01
00c44     97 26 48 FB | 	callpa	#(@LR__0032-@LR__0030)>>2,fcache_load_ptr_
00c48                 | '         repeat i from 0 to 7
00c48                 | LR__0030
00c48                 | '             if long[$7FF00][i*3] < 0
00c48     D0 9C 01 F6 | 	mov	result1, _var01
00c4c     01 9C 65 F0 | 	shl	result1, #1
00c50     D0 9C 01 F1 | 	add	result1, _var01
00c54     02 9C 65 F0 | 	shl	result1, #2
00c58     FF 03 00 FF 
00c5c     00 9D 05 F1 | 	add	result1, ##524032
00c60     CE 9C 01 FB | 	rdlong	result1, result1
00c64     00 9C 55 F2 | 	cmps	result1, #0 wc
00c68     1C 00 90 3D |  if_ae	jmp	#LR__0031
00c6c                 | '                 long[$7FF00][i*3] := -ERR_ABORTED ' abort request
00c6c     D0 9C 01 F6 | 	mov	result1, _var01
00c70     01 9C 65 F0 | 	shl	result1, #1
00c74     D0 9C 01 F1 | 	add	result1, _var01
00c78     02 9C 65 F0 | 	shl	result1, #2
00c7c     FF 03 00 FF 
00c80     00 9D 05 F1 | 	add	result1, ##524032
00c84     CE 20 68 FC | 	wrlong	#16, result1
00c88                 | LR__0031
00c88     01 A0 05 F1 | 	add	_var01, #1
00c8c     08 A0 55 F2 | 	cmps	_var01, #8 wc
00c90     B4 FF 9F CD |  if_b	jmp	#LR__0030
00c94                 | LR__0032
00c94                 | '         drivercog := -1
00c94     00 97 05 F1 | 	add	ptr__psram_spin2_dat__, #256
00c98     FF FF FF FF 
00c9c     CB FE 6B FC | 	wrlong	##-1, ptr__psram_spin2_dat__
00ca0     00 97 85 F1 | 	sub	ptr__psram_spin2_dat__, #256
00ca4                 | LR__0033
00ca4                 | '     if driverlock <> -1
00ca4     04 97 05 F1 | 	add	ptr__psram_spin2_dat__, #260
00ca8     CB A2 01 FB | 	rdlong	_var02, ptr__psram_spin2_dat__
00cac     04 97 85 F1 | 	sub	ptr__psram_spin2_dat__, #260
00cb0     FF FF 7F FF 
00cb4     FF A3 0D F2 | 	cmp	_var02, ##-1 wz
00cb8                 | '         LOCKRET(driverlock)
00cb8     04 97 05 51 |  if_ne	add	ptr__psram_spin2_dat__, #260
00cbc     CB A6 01 5B |  if_ne	rdlong	arg01, ptr__psram_spin2_dat__
00cc0     05 A6 61 5D |  if_ne	lockret	arg01
00cc4                 | '         driverlock := -1
00cc4     FF FF FF 5F 
00cc8     CB FE 6B 5C |  if_ne	wrlong	##-1, ptr__psram_spin2_dat__
00ccc     04 97 85 51 |  if_ne	sub	ptr__psram_spin2_dat__, #260
00cd0     D0 9C 01 F6 | 	mov	result1, _var01
00cd4                 | _psram_spin2_stop_ret
00cd4     2D 00 64 FD | 	ret
00cd8                 | 
00cd8                 | ' 
00cd8                 | ' '..............................................................................
00cd8                 | ' 
00cd8                 | ' {{
00cd8                 | ' }}
00cd8                 | ' PUB write(srcHubAddr, dstAddr, count) : result | mailbox
00cd8                 | _psram_spin2_write
00cd8                 | ' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
00cd8                 | '     if drivercog == -1 ' driver must be running
00cd8     00 97 05 F1 | 	add	ptr__psram_spin2_dat__, #256
00cdc     CB A0 01 FB | 	rdlong	_var01, ptr__psram_spin2_dat__
00ce0     00 97 85 F1 | 	sub	ptr__psram_spin2_dat__, #256
00ce4     FF FF 7F FF 
00ce8     FF A1 0D F2 | 	cmp	_var01, ##-1 wz
00cec                 | '         return ERR_INACTIVE
00cec     0F 9C 65 A6 |  if_e	neg	result1, #15
00cf0     7C 00 90 AD |  if_e	jmp	#LR__0041
00cf4                 | '     if count == 0 ' don't even bother writing
00cf4     00 AA 0D F2 | 	cmp	arg03, #0 wz
00cf8                 | '         return 0
00cf8     00 9C 05 A6 |  if_e	mov	result1, #0
00cfc     70 00 90 AD |  if_e	jmp	#LR__0041
00d00                 | '     mailbox := $7FF00 + cogid()*12     ' compute COG's mailbox address
00d00     00 9C 05 F6 | 	mov	result1, #0
00d04     01 9C 61 FD | 	cogid	result1
00d08     CE A0 01 F6 | 	mov	_var01, result1
00d0c     01 A0 65 F0 | 	shl	_var01, #1
00d10     CE A0 01 F1 | 	add	_var01, result1
00d14     02 A0 65 F0 | 	shl	_var01, #2
00d18     FF 03 00 FF 
00d1c     00 A3 05 F6 | 	mov	_var02, ##524032
00d20     D0 A2 01 F1 | 	add	_var02, _var01
00d24                 | '     if long[mailbox] < 0
00d24     D1 A0 01 FB | 	rdlong	_var01, _var02
00d28     00 A0 55 F2 | 	cmps	_var01, #0 wc
00d2c                 | '         return ERR_MAILBOX_BUSY
00d2c     1C 9C 65 C6 |  if_b	neg	result1, #28
00d30     3C 00 90 CD |  if_b	jmp	#LR__0041
00d34                 | '     long[mailbox][2] := count
00d34     08 A2 05 F1 | 	add	_var02, #8
00d38     D1 AA 61 FC | 	wrlong	arg03, _var02
00d3c                 | '     long[mailbox][1] := srcHubAddr
00d3c     04 A2 85 F1 | 	sub	_var02, #4
00d40     D1 A6 61 FC | 	wrlong	arg01, _var02
00d44     04 A2 85 F1 | 	sub	_var02, #4
00d48                 | '     long[mailbox] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
00d48     D4 A4 01 F6 | 	mov	_var03, arg02
00d4c     D9 A4 05 F4 | 	bitl	_var03, #217
00d50     00 00 78 FF 
00d54     00 A0 05 F6 | 	mov	_var01, ##-268435456
00d58     D2 A0 01 F1 | 	add	_var01, _var03
00d5c     D1 A0 61 FC | 	wrlong	_var01, _var02
00d60                 | '     repeat
00d60                 | LR__0040
00d60                 | '         result := long[mailbox]    
00d60     D1 A4 01 FB | 	rdlong	_var03, _var02
00d64     00 A4 55 F2 | 	cmps	_var03, #0 wc
00d68     F4 FF 9F CD |  if_b	jmp	#LR__0040
00d6c                 | '     while result < 0   
00d6c                 | '     return -result                       'return success or error
00d6c     D2 9C 61 F6 | 	neg	result1, _var03
00d70                 | LR__0041
00d70                 | _psram_spin2_write_ret
00d70     2D 00 64 FD | 	ret
00d74                 | 
00d74                 | ' 
00d74                 | ' '..............................................................................
00d74                 | ' 
00d74                 | ' {{
00d74                 | ' }}
00d74                 | ' PRI lookupDelay(freq) : delay | profile
00d74                 | _psram_spin2_lookupDelay
00d74                 | '     profile := @delayTable
00d74     08 97 05 F1 | 	add	ptr__psram_spin2_dat__, #264
00d78     CB A0 01 F6 | 	mov	_var01, ptr__psram_spin2_dat__
00d7c                 | '     delay := long[profile][0]
00d7c     D0 A2 01 FB | 	rdlong	_var02, _var01
00d80                 | '     repeat while long[profile][1] 
00d80     08 97 85 F1 | 	sub	ptr__psram_spin2_dat__, #264
00d84     97 16 48 FB | 	callpa	#(@LR__0051-@LR__0050)>>2,fcache_load_ptr_
00d88                 | LR__0050
00d88     04 A0 05 F1 | 	add	_var01, #4
00d8c     D0 9C 09 FB | 	rdlong	result1, _var01 wz
00d90     04 A0 85 F1 | 	sub	_var01, #4
00d94     1C 00 90 AD |  if_e	jmp	#LR__0052
00d98                 | '         if freq +< long[profile][1] 
00d98     04 A0 05 F1 | 	add	_var01, #4
00d9c     D0 9C 01 FB | 	rdlong	result1, _var01
00da0     04 A0 85 F1 | 	sub	_var01, #4
00da4     CE A6 11 F2 | 	cmp	arg01, result1 wc
00da8                 | '             quit
00da8                 | '         profile += 4
00da8     04 A0 05 31 |  if_ae	add	_var01, #4
00dac                 | '         delay++
00dac     01 A2 05 31 |  if_ae	add	_var02, #1
00db0     D4 FF 9F 3D |  if_ae	jmp	#LR__0050
00db4                 | LR__0051
00db4                 | LR__0052
00db4     D1 9C 01 F6 | 	mov	result1, _var02
00db8                 | _psram_spin2_lookupDelay_ret
00db8     2D 00 64 FD | 	ret
00dbc                 | hubexit
00dbc     81 00 80 FD | 	jmp	#cogexit
00dc0                 | 
00dc0                 | __system___setbaud
00dc0     14 CC 05 FB | 	rdlong	muldiva_, #20
00dc4     D3 CE 01 F6 | 	mov	muldivb_, arg01
00dc8     BA 00 A0 FD | 	call	#divide_
00dcc     97 06 48 FB | 	callpa	#(@LR__0061-@LR__0060)>>2,fcache_load_ptr_
00dd0                 | LR__0060
00dd0     3E 9C 9D FA | 	rdpin	result1, #62 wc
00dd4     CF 9E A1 F1 | 	subx	result2, result2
00dd8     F4 FF 9F CD |  if_b	jmp	#LR__0060
00ddc                 | LR__0061
00ddc     40 7C 64 FD | 	dirl	#62
00de0     40 7E 64 FD | 	dirl	#63
00de4     C8 CE 61 FC | 	wrlong	muldivb_, ptr___system__dat__
00de8     10 CE 65 F0 | 	shl	muldivb_, #16
00dec     07 A8 05 F6 | 	mov	arg02, #7
00df0     E7 A8 01 F1 | 	add	arg02, muldivb_
00df4     3E F8 0C FC | 	wrpin	#124, #62
00df8     3E A8 15 FC | 	wxpin	arg02, #62
00dfc     3F 7C 0C FC | 	wrpin	#62, #63
00e00     14 A8 05 F1 | 	add	arg02, #20
00e04     3F A8 15 FC | 	wxpin	arg02, #63
00e08     41 7C 64 FD | 	dirh	#62
00e0c     41 7E 64 FD | 	dirh	#63
00e10                 | __system___setbaud_ret
00e10     2D 00 64 FD | 	ret
00e14                 | 
00e14                 | __system___txraw
00e14     01 4A 05 F6 | 	mov	COUNT_, #1
00e18     A8 00 A0 FD | 	call	#pushregs_
00e1c     D3 B2 01 F6 | 	mov	local01, arg01
00e20     97 06 48 FB | 	callpa	#(@LR__0071-@LR__0070)>>2,fcache_load_ptr_
00e24                 | LR__0070
00e24     3E 9C 9D FA | 	rdpin	result1, #62 wc
00e28     CF 9E A1 F1 | 	subx	result2, result2
00e2c     F4 FF 9F CD |  if_b	jmp	#LR__0070
00e30                 | LR__0071
00e30     C8 9C 09 FB | 	rdlong	result1, ptr___system__dat__ wz
00e34     C2 01 00 AF 
00e38     00 A6 05 A6 |  if_e	mov	arg01, ##230400
00e3c     80 FF BF AD |  if_e	call	#__system___setbaud
00e40     58 7C 64 FD | 	drvl	#62
00e44     3E B2 25 FC | 	wypin	local01, #62
00e48     01 9C 05 F6 | 	mov	result1, #1
00e4c     A7 F0 03 F6 | 	mov	ptra, fp
00e50     B2 00 A0 FD | 	call	#popregs_
00e54                 | __system___txraw_ret
00e54     2D 00 64 FD | 	ret
00e58                 | 
00e58                 | __system___rxraw
00e58     0D 4A 05 F6 | 	mov	COUNT_, #13
00e5c     A8 00 A0 FD | 	call	#pushregs_
00e60     D3 B2 01 F6 | 	mov	local01, arg01
00e64     C8 B4 09 FB | 	rdlong	local02, ptr___system__dat__ wz
00e68     C2 01 00 AF 
00e6c     00 A6 05 A6 |  if_e	mov	arg01, ##230400
00e70     4C FF BF AD |  if_e	call	#__system___setbaud
00e74     00 B2 0D F2 | 	cmp	local01, #0 wz
00e78     20 00 90 AD |  if_e	jmp	#LR__0080
00e7c     14 B6 05 FB | 	rdlong	local03, #20
00e80     0A B6 45 F0 | 	shr	local03, #10
00e84     DB B2 01 FD | 	qmul	local01, local03
00e88     1A 9C 61 FD | 	getct	result1
00e8c     18 B8 61 FD | 	getqx	local04
00e90     DC 9C 01 F1 | 	add	result1, local04
00e94     CE BA 01 F6 | 	mov	local05, result1
00e98     04 00 90 FD | 	jmp	#LR__0081
00e9c                 | LR__0080
00e9c     00 BA 05 F6 | 	mov	local05, #0
00ea0                 | LR__0081
00ea0     01 BC 65 F6 | 	neg	local06, #1
00ea4     3F BE 05 F6 | 	mov	local07, #63
00ea8     00 C0 05 F6 | 	mov	local08, #0
00eac     04 90 05 F1 | 	add	ptr___system__dat__, #4
00eb0     C8 C2 01 FB | 	rdlong	local09, ptr___system__dat__
00eb4     04 90 85 F1 | 	sub	ptr___system__dat__, #4
00eb8                 | LR__0082
00eb8     08 C2 15 F4 | 	testb	local09, #8 wc
00ebc     09 C2 75 F4 | 	testbn	local09, #9 andc
00ec0     0A C2 45 F0 | 	shr	local09, #10
00ec4     01 C0 05 C6 |  if_b	mov	local08, #1
00ec8     40 7E 6C 3D |  if_ae	testp	#63 wz
00ecc     01 C0 05 26 |  if_nc_and_z	mov	local08, #1
00ed0     3F C2 8D 2A |  if_nc_and_z	rdpin	local09, #63
00ed4     04 C2 45 20 |  if_nc_and_z	shr	local09, #4
00ed8                 | LR__0083
00ed8     00 B4 05 F6 | 	mov	local02, #0
00edc     00 C0 0D F2 | 	cmp	local08, #0 wz
00ee0     01 B4 65 56 |  if_ne	neg	local02, #1
00ee4     00 C4 05 F6 | 	mov	local10, #0
00ee8     00 B6 05 F6 | 	mov	local03, #0
00eec     00 B2 0D F2 | 	cmp	local01, #0 wz
00ef0     01 B6 65 56 |  if_ne	neg	local03, #1
00ef4     00 B8 05 F6 | 	mov	local04, #0
00ef8     00 C6 05 F6 | 	mov	local11, #0
00efc     DD C8 01 F6 | 	mov	local12, local05
00f00     1A 9C 61 FD | 	getct	result1
00f04     CE CA 01 F6 | 	mov	local13, result1
00f08     E5 C8 81 F1 | 	sub	local12, local13
00f0c     00 C8 55 F2 | 	cmps	local12, #0 wc
00f10     00 C6 25 C6 |  if_b	not	local11, #0
00f14     00 C6 0D F2 | 	cmp	local11, #0 wz
00f18     00 B8 25 56 |  if_ne	not	local04, #0
00f1c     DC B6 C9 F7 | 	test	local03, local04 wz
00f20     00 C4 25 56 |  if_ne	not	local10, #0
00f24     E2 B4 49 F5 | 	or	local02, local10 wz
00f28     8C FF 9F AD |  if_e	jmp	#LR__0082
00f2c     00 C0 0D F2 | 	cmp	local08, #0 wz
00f30     E1 BC 01 56 |  if_ne	mov	local06, local09
00f34     DE BC E1 58 |  if_ne	getbyte	local06, local06, #0
00f38     04 90 05 F1 | 	add	ptr___system__dat__, #4
00f3c     C8 C2 61 FC | 	wrlong	local09, ptr___system__dat__
00f40     04 90 85 F1 | 	sub	ptr___system__dat__, #4
00f44     DE 9C 01 F6 | 	mov	result1, local06
00f48     A7 F0 03 F6 | 	mov	ptra, fp
00f4c     B2 00 A0 FD | 	call	#popregs_
00f50                 | __system___rxraw_ret
00f50     2D 00 64 FD | 	ret
00f54                 | 
00f54                 | __system___lockmem
00f54     00 9C 05 F6 | 	mov	result1, #0
00f58     01 9C 61 FD | 	cogid	result1
00f5c     00 9D 05 F1 | 	add	result1, #256
00f60                 | LR__0090
00f60     D3 A0 09 FB | 	rdlong	_var01, arg01 wz
00f64     D3 9C 61 AC |  if_e	wrlong	result1, arg01
00f68     D3 A0 01 AB |  if_e	rdlong	_var01, arg01
00f6c     D3 A0 01 AB |  if_e	rdlong	_var01, arg01
00f70     CE A0 09 F2 | 	cmp	_var01, result1 wz
00f74     E8 FF 9F 5D |  if_ne	jmp	#LR__0090
00f78                 | __system___lockmem_ret
00f78     2D 00 64 FD | 	ret
00f7c                 | 
00f7c                 | __system___tx
00f7c     02 4A 05 F6 | 	mov	COUNT_, #2
00f80     A8 00 A0 FD | 	call	#pushregs_
00f84     D3 B2 01 F6 | 	mov	local01, arg01
00f88     0A B2 0D F2 | 	cmp	local01, #10 wz
00f8c     18 00 90 5D |  if_ne	jmp	#LR__0100
00f90     08 90 05 F1 | 	add	ptr___system__dat__, #8
00f94     C8 B4 01 FB | 	rdlong	local02, ptr___system__dat__
00f98     08 90 85 F1 | 	sub	ptr___system__dat__, #8
00f9c     02 B4 CD F7 | 	test	local02, #2 wz
00fa0     0D A6 05 56 |  if_ne	mov	arg01, #13
00fa4     6C FE BF 5D |  if_ne	call	#__system___txraw
00fa8                 | LR__0100
00fa8     D9 A6 01 F6 | 	mov	arg01, local01
00fac     64 FE BF FD | 	call	#__system___txraw
00fb0     A7 F0 03 F6 | 	mov	ptra, fp
00fb4     B2 00 A0 FD | 	call	#popregs_
00fb8                 | __system___tx_ret
00fb8     2D 00 64 FD | 	ret
00fbc                 | 
00fbc                 | __system___rx
00fbc     01 4A 05 F6 | 	mov	COUNT_, #1
00fc0     A8 00 A0 FD | 	call	#pushregs_
00fc4                 | LR__0110
00fc4     00 A6 05 F6 | 	mov	arg01, #0
00fc8     8C FE BF FD | 	call	#__system___rxraw
00fcc     CE B2 01 F6 | 	mov	local01, result1
00fd0     FF FF 7F FF 
00fd4     FF B3 0D F2 | 	cmp	local01, ##-1 wz
00fd8     E8 FF 9F AD |  if_e	jmp	#LR__0110
00fdc     0D B2 0D F2 | 	cmp	local01, #13 wz
00fe0     14 00 90 5D |  if_ne	jmp	#LR__0111
00fe4     08 90 05 F1 | 	add	ptr___system__dat__, #8
00fe8     C8 9C 01 FB | 	rdlong	result1, ptr___system__dat__
00fec     08 90 85 F1 | 	sub	ptr___system__dat__, #8
00ff0     02 9C CD F7 | 	test	result1, #2 wz
00ff4     0A B2 05 56 |  if_ne	mov	local01, #10
00ff8                 | LR__0111
00ff8     08 90 05 F1 | 	add	ptr___system__dat__, #8
00ffc     C8 A6 01 FB | 	rdlong	arg01, ptr___system__dat__
01000     08 90 85 F1 | 	sub	ptr___system__dat__, #8
01004     01 A6 CD F7 | 	test	arg01, #1 wz
01008     1C 00 90 AD |  if_e	jmp	#LR__0114
0100c     7F B2 0D F2 | 	cmp	local01, #127 wz
01010     0C 00 90 5D |  if_ne	jmp	#LR__0112
01014     08 A6 05 F6 | 	mov	arg01, #8
01018     60 FF BF FD | 	call	#__system___tx
0101c     08 00 90 FD | 	jmp	#LR__0113
01020                 | LR__0112
01020     D9 A6 01 F6 | 	mov	arg01, local01
01024     54 FF BF FD | 	call	#__system___tx
01028                 | LR__0113
01028                 | LR__0114
01028     D9 9C 01 F6 | 	mov	result1, local01
0102c     A7 F0 03 F6 | 	mov	ptra, fp
01030     B2 00 A0 FD | 	call	#popregs_
01034                 | __system___rx_ret
01034     2D 00 64 FD | 	ret
01038                 | 
01038                 | __system___waitms
01038     D3 A0 01 F6 | 	mov	_var01, arg01
0103c     1A A2 61 FD | 	getct	_var02
01040     14 A4 05 FB | 	rdlong	_var03, #20
01044     97 14 48 FB | 	callpa	#(@LR__0121-@LR__0120)>>2,fcache_load_ptr_
01048                 | LR__0120
01048     01 00 00 FF 
0104c     E8 A1 55 F2 | 	cmps	_var01, ##1000 wc
01050     1C 00 90 CD |  if_b	jmp	#LR__0122
01054     D2 A2 01 F1 | 	add	_var02, _var03
01058     D1 A6 01 F6 | 	mov	arg01, _var02
0105c     00 A6 65 FA | 	addct1	arg01, #0
01060     24 22 60 FD | 	waitct1
01064     01 00 00 FF 
01068     E8 A1 85 F1 | 	sub	_var01, ##1000
0106c     D8 FF 9F FD | 	jmp	#LR__0120
01070                 | LR__0121
01070                 | LR__0122
01070     01 A0 55 F2 | 	cmps	_var01, #1 wc
01074     28 00 90 CD |  if_b	jmp	#LR__0123
01078     D2 A0 01 FD | 	qmul	_var01, _var03
0107c     01 00 00 FF 
01080     E8 AB 05 F6 | 	mov	arg03, ##1000
01084     19 9C 61 FD | 	getqy	result1
01088     18 A6 61 FD | 	getqx	arg01
0108c     28 9C 61 FD | 	setq	result1
01090     D5 A6 11 FD | 	qdiv	arg01, arg03
01094     18 A6 61 FD | 	getqx	arg01
01098     D1 A6 61 FA | 	addct1	arg01, _var02
0109c     24 22 60 FD | 	waitct1
010a0                 | LR__0123
010a0                 | __system___waitms_ret
010a0     2D 00 64 FD | 	ret
010a4                 | 
010a4                 | __system___basic_print_char
010a4     03 4A 05 F6 | 	mov	COUNT_, #3
010a8     A8 00 A0 FD | 	call	#pushregs_
010ac     D4 B2 01 F6 | 	mov	local01, arg02
010b0     38 07 B0 FD | 	call	#__system___gettxfunc
010b4     CE B4 09 F6 | 	mov	local02, result1 wz
010b8     00 9C 05 A6 |  if_e	mov	result1, #0
010bc     30 00 90 AD |  if_e	jmp	#LR__0130
010c0     DA B6 01 F6 | 	mov	local03, local02
010c4     13 B4 45 F7 | 	zerox	local02, #19
010c8     14 B6 45 F0 | 	shr	local03, #20
010cc     02 B6 65 F0 | 	shl	local03, #2
010d0     C4 B6 01 F1 | 	add	local03, __methods__
010d4     DB B6 01 FB | 	rdlong	local03, local03
010d8     D9 A6 01 F6 | 	mov	arg01, local01
010dc     C7 B2 01 F6 | 	mov	local01, objptr
010e0     DA 8E 01 F6 | 	mov	objptr, local02
010e4     2D B6 61 FD | 	call	local03
010e8     D9 8E 01 F6 | 	mov	objptr, local01
010ec     01 9C 05 F6 | 	mov	result1, #1
010f0                 | LR__0130
010f0     A7 F0 03 F6 | 	mov	ptra, fp
010f4     B2 00 A0 FD | 	call	#popregs_
010f8                 | __system___basic_print_char_ret
010f8     2D 00 64 FD | 	ret
010fc                 | 
010fc                 | __system___basic_print_unsigned
010fc     03 4A 05 F6 | 	mov	COUNT_, #3
01100     A8 00 A0 FD | 	call	#pushregs_
01104     D4 B2 01 F6 | 	mov	local01, arg02
01108     D5 B4 01 F6 | 	mov	local02, arg03
0110c     D6 B6 01 F6 | 	mov	local03, arg04
01110     D8 06 B0 FD | 	call	#__system___gettxfunc
01114     CE A6 09 F6 | 	mov	arg01, result1 wz
01118     00 9C 05 A6 |  if_e	mov	result1, #0
0111c     3A B4 25 54 |  if_ne	bith	local02, #58
01120     DA A8 01 56 |  if_ne	mov	arg02, local02
01124     D9 AA 01 56 |  if_ne	mov	arg03, local01
01128     DB AC 01 56 |  if_ne	mov	arg04, local03
0112c     50 01 B0 5D |  if_ne	call	#__system___fmtnum
01130     A7 F0 03 F6 | 	mov	ptra, fp
01134     B2 00 A0 FD | 	call	#popregs_
01138                 | __system___basic_print_unsigned_ret
01138     2D 00 64 FD | 	ret
0113c                 | 
0113c                 | __system___fmtchar
0113c     00 4A 05 F6 | 	mov	COUNT_, #0
01140     A8 00 A0 FD | 	call	#pushregs_
01144     10 F0 07 F1 | 	add	ptra, #16
01148     04 4E 05 F1 | 	add	fp, #4
0114c     A7 A6 61 FC | 	wrlong	arg01, fp
01150     04 4E 05 F1 | 	add	fp, #4
01154     A7 A8 61 FC | 	wrlong	arg02, fp
01158     04 4E 05 F1 | 	add	fp, #4
0115c     A7 AA 61 FC | 	wrlong	arg03, fp
01160     D5 AA E1 F8 | 	getbyte	arg03, arg03, #0
01164     A7 AA 61 FC | 	wrlong	arg03, fp
01168     08 4E 85 F1 | 	sub	fp, #8
0116c     A7 A6 01 FB | 	rdlong	arg01, fp
01170     04 4E 05 F1 | 	add	fp, #4
01174     A7 A8 01 FB | 	rdlong	arg02, fp
01178     04 4E 05 F1 | 	add	fp, #4
0117c     A7 AA 01 F6 | 	mov	arg03, fp
01180     0C 4E 85 F1 | 	sub	fp, #12
01184     0C 00 B0 FD | 	call	#__system___fmtstr
01188     A7 F0 03 F6 | 	mov	ptra, fp
0118c     B2 00 A0 FD | 	call	#popregs_
01190                 | __system___fmtchar_ret
01190     2D 00 64 FD | 	ret
01194                 | 
01194                 | __system___fmtstr
01194     09 4A 05 F6 | 	mov	COUNT_, #9
01198     A8 00 A0 FD | 	call	#pushregs_
0119c     D3 B2 01 F6 | 	mov	local01, arg01
011a0     D4 B4 01 F6 | 	mov	local02, arg02
011a4     D5 B6 01 F6 | 	mov	local03, arg03
011a8     DA AC E1 F8 | 	getbyte	arg04, local02, #0
011ac     DB A6 01 F6 | 	mov	arg01, local03
011b0     D3 B8 01 F6 | 	mov	local04, arg01
011b4     97 06 48 FB | 	callpa	#(@LR__0141-@LR__0140)>>2,fcache_load_ptr_
011b8                 | LR__0140
011b8     DC 9C C9 FA | 	rdbyte	result1, local04 wz
011bc     01 B8 05 51 |  if_ne	add	local04, #1
011c0     F4 FF 9F 5D |  if_ne	jmp	#LR__0140
011c4                 | LR__0141
011c4     D3 B8 81 F1 | 	sub	local04, arg01
011c8     00 AC 0D F2 | 	cmp	arg04, #0 wz
011cc     D6 B8 79 53 |  if_ne	fles	local04, arg04 wcz
011d0     DA A8 01 F6 | 	mov	arg02, local02
011d4     DC AA 01 F6 | 	mov	arg03, local04
011d8     D9 A6 01 F6 | 	mov	arg01, local01
011dc     02 AC 05 F6 | 	mov	arg04, #2
011e0     CC 04 B0 FD | 	call	#__system___fmtpad
011e4     CE BA 01 F6 | 	mov	local05, result1
011e8     00 BA 55 F2 | 	cmps	local05, #0 wc
011ec     DD 9C 01 C6 |  if_b	mov	result1, local05
011f0     80 00 90 CD |  if_b	jmp	#LR__0144
011f4     01 B8 55 F2 | 	cmps	local04, #1 wc
011f8     50 00 90 CD |  if_b	jmp	#LR__0143
011fc     DC BC 01 F6 | 	mov	local06, local04
01200                 | LR__0142
01200     D9 BE 01 F6 | 	mov	local07, local01
01204     D9 C0 01 F6 | 	mov	local08, local01
01208     13 BE 45 F7 | 	zerox	local07, #19
0120c     14 C0 45 F0 | 	shr	local08, #20
01210     02 C0 65 F0 | 	shl	local08, #2
01214     C4 C0 01 F1 | 	add	local08, __methods__
01218     E0 C0 01 FB | 	rdlong	local08, local08
0121c     DB A6 C1 FA | 	rdbyte	arg01, local03
01220     C7 C2 01 F6 | 	mov	local09, objptr
01224     DF 8E 01 F6 | 	mov	objptr, local07
01228     01 B6 05 F1 | 	add	local03, #1
0122c     2D C0 61 FD | 	call	local08
01230     E1 8E 01 F6 | 	mov	objptr, local09
01234     CE C2 01 F6 | 	mov	local09, result1
01238     00 C2 55 F2 | 	cmps	local09, #0 wc
0123c     E1 9C 01 C6 |  if_b	mov	result1, local09
01240     30 00 90 CD |  if_b	jmp	#LR__0144
01244     E1 BA 01 F1 | 	add	local05, local09
01248     ED BD 6D FB | 	djnz	local06, #LR__0142
0124c                 | LR__0143
0124c     DA A8 01 F6 | 	mov	arg02, local02
01250     DC AA 01 F6 | 	mov	arg03, local04
01254     D9 A6 01 F6 | 	mov	arg01, local01
01258     01 AC 05 F6 | 	mov	arg04, #1
0125c     50 04 B0 FD | 	call	#__system___fmtpad
01260     CE C2 01 F6 | 	mov	local09, result1
01264     00 C2 55 F2 | 	cmps	local09, #0 wc
01268     E1 9C 01 C6 |  if_b	mov	result1, local09
0126c     E1 BA 01 31 |  if_ae	add	local05, local09
01270     DD 9C 01 36 |  if_ae	mov	result1, local05
01274                 | LR__0144
01274     A7 F0 03 F6 | 	mov	ptra, fp
01278     B2 00 A0 FD | 	call	#popregs_
0127c                 | __system___fmtstr_ret
0127c     2D 00 64 FD | 	ret
01280                 | 
01280                 | __system___fmtnum
01280     0B 4A 05 F6 | 	mov	COUNT_, #11
01284     A8 00 A0 FD | 	call	#pushregs_
01288     D3 B2 01 F6 | 	mov	local01, arg01
0128c     D4 B4 01 F6 | 	mov	local02, arg02
01290     D5 B6 01 F6 | 	mov	local03, arg03
01294     D6 B8 01 F6 | 	mov	local04, arg04
01298     F8 BB 01 F6 | 	mov	local05, ptra
0129c     DD BC 01 F6 | 	mov	local06, local05
012a0     00 BE 05 F6 | 	mov	local07, #0
012a4     DA C0 01 F6 | 	mov	local08, local02
012a8     10 C0 45 F0 | 	shr	local08, #16
012ac     3F C0 05 F5 | 	and	local08, #63
012b0     DA C2 E1 F8 | 	getbyte	local09, local02, #0
012b4     DA C4 01 F6 | 	mov	local10, local02
012b8     1A C4 45 F0 | 	shr	local10, #26
012bc     03 C4 05 F5 | 	and	local10, #3
012c0     E2 C6 01 F6 | 	mov	local11, local10
012c4     01 C0 55 F2 | 	cmps	local08, #1 wc
012c8     44 F0 07 F1 | 	add	ptra, #68
012cc     01 C0 85 31 |  if_ae	sub	local08, #1
012d0     41 C2 55 F2 | 	cmps	local09, #65 wc
012d4     00 C2 0D C2 |  if_b	cmp	local09, #0 wz
012d8     40 C2 05 B6 |  if_nc_or_z	mov	local09, #64
012dc     03 C6 0D F2 | 	cmp	local11, #3 wz
012e0     00 C6 05 A6 |  if_e	mov	local11, #0
012e4     00 B6 55 52 |  if_ne	cmps	local03, #0 wc
012e8     04 C6 05 46 |  if_c_and_nz	mov	local11, #4
012ec     DB B6 61 46 |  if_c_and_nz	neg	local03, local03
012f0     00 C6 0D F2 | 	cmp	local11, #0 wz
012f4     4C 00 90 AD |  if_e	jmp	#LR__0153
012f8     01 BE 05 F6 | 	mov	local07, #1
012fc     E1 C0 09 F2 | 	cmp	local08, local09 wz
01300     18 00 90 5D |  if_ne	jmp	#LR__0151
01304     05 C0 6D FB | 	djnz	local08, #LR__0150
01308     D9 A6 01 F6 | 	mov	arg01, local01
0130c     DA A8 01 F6 | 	mov	arg02, local02
01310     23 AA 05 F6 | 	mov	arg03, #35
01314     24 FE BF FD | 	call	#__system___fmtchar
01318     88 00 90 FD | 	jmp	#LR__0157
0131c                 | LR__0150
0131c                 | LR__0151
0131c     02 C6 0D F2 | 	cmp	local11, #2 wz
01320     DE C4 01 A6 |  if_e	mov	local10, local06
01324     01 BC 05 A1 |  if_e	add	local06, #1
01328     E2 40 48 AC |  if_e	wrbyte	#32, local10
0132c     14 00 90 AD |  if_e	jmp	#LR__0152
01330     04 C6 0D F2 | 	cmp	local11, #4 wz
01334     DE 5A 48 AC |  if_e	wrbyte	#45, local06
01338     01 BC 05 A1 |  if_e	add	local06, #1
0133c     DE 56 48 5C |  if_ne	wrbyte	#43, local06
01340     01 BC 05 51 |  if_ne	add	local06, #1
01344                 | LR__0152
01344                 | LR__0153
01344     DE A6 01 F6 | 	mov	arg01, local06
01348     DB A8 01 F6 | 	mov	arg02, local03
0134c     DC AA 01 F6 | 	mov	arg03, local04
01350     E0 AC 01 F6 | 	mov	arg04, local08
01354     00 AE 05 F6 | 	mov	arg05, #0
01358     1D B4 2D F4 | 	testbn	local02, #29 wz
0135c     01 AE 05 56 |  if_ne	mov	arg05, #1
01360     14 04 B0 FD | 	call	#__system___uitoa
01364     CE BE 01 F1 | 	add	local07, result1
01368     E1 BE 59 F2 | 	cmps	local07, local09 wcz
0136c     24 00 90 ED |  if_be	jmp	#LR__0156
01370     97 0E 48 FB | 	callpa	#(@LR__0155-@LR__0154)>>2,fcache_load_ptr_
01374                 | LR__0154
01374     E1 C4 01 F6 | 	mov	local10, local09
01378     01 C4 55 F2 | 	cmps	local10, #1 wc
0137c     01 C2 85 F1 | 	sub	local09, #1
01380     DE C4 01 36 |  if_ae	mov	local10, local06
01384     01 BC 05 31 |  if_ae	add	local06, #1
01388     E2 46 48 3C |  if_ae	wrbyte	#35, local10
0138c     E4 FF 9F 3D |  if_ae	jmp	#LR__0154
01390                 | LR__0155
01390     DE 00 48 FC | 	wrbyte	#0, local06
01394                 | LR__0156
01394     D9 A6 01 F6 | 	mov	arg01, local01
01398     DA A8 01 F6 | 	mov	arg02, local02
0139c     DD AA 01 F6 | 	mov	arg03, local05
013a0     F0 FD BF FD | 	call	#__system___fmtstr
013a4                 | LR__0157
013a4     A7 F0 03 F6 | 	mov	ptra, fp
013a8     B2 00 A0 FD | 	call	#popregs_
013ac                 | __system___fmtnum_ret
013ac     2D 00 64 FD | 	ret
013b0                 | 
013b0                 | __system____default_getc
013b0     03 4A 05 F6 | 	mov	COUNT_, #3
013b4     A8 00 A0 FD | 	call	#pushregs_
013b8     D3 B2 01 F6 | 	mov	local01, arg01
013bc     D9 B4 01 FB | 	rdlong	local02, local01
013c0     08 B4 05 F1 | 	add	local02, #8
013c4     DA B6 01 FB | 	rdlong	local03, local02
013c8     02 B6 CD F7 | 	test	local03, #2 wz
013cc     D9 A6 01 56 |  if_ne	mov	arg01, local01
013d0     00 01 B0 5D |  if_ne	call	#__system____default_flush
013d4     DA B6 01 FB | 	rdlong	local03, local02
013d8     01 B6 45 F5 | 	or	local03, #1
013dc     DA B6 61 FC | 	wrlong	local03, local02
013e0     08 B4 85 F1 | 	sub	local02, #8
013e4     DA B6 09 FB | 	rdlong	local03, local02 wz
013e8     0C 00 90 5D |  if_ne	jmp	#LR__0160
013ec     D9 A6 01 F6 | 	mov	arg01, local01
013f0     E0 04 B0 FD | 	call	#__system____default_filbuf
013f4     CE B6 01 F6 | 	mov	local03, result1
013f8                 | LR__0160
013f8     01 B6 55 F2 | 	cmps	local03, #1 wc
013fc     01 9C 65 C6 |  if_b	neg	result1, #1
01400     1C 00 90 CD |  if_b	jmp	#LR__0161
01404     01 B6 85 F1 | 	sub	local03, #1
01408     DA B6 61 FC | 	wrlong	local03, local02
0140c     04 B4 05 F1 | 	add	local02, #4
01410     DA B6 01 FB | 	rdlong	local03, local02
01414     DB 9C C1 FA | 	rdbyte	result1, local03
01418     01 B6 05 F1 | 	add	local03, #1
0141c     DA B6 61 FC | 	wrlong	local03, local02
01420                 | LR__0161
01420     A7 F0 03 F6 | 	mov	ptra, fp
01424     B2 00 A0 FD | 	call	#popregs_
01428                 | __system____default_getc_ret
01428     2D 00 64 FD | 	ret
0142c                 | 
0142c                 | __system____default_putc
0142c     06 4A 05 F6 | 	mov	COUNT_, #6
01430     A8 00 A0 FD | 	call	#pushregs_
01434     D3 B2 01 F6 | 	mov	local01, arg01
01438     D4 B4 01 F6 | 	mov	local02, arg02
0143c     DA B6 01 FB | 	rdlong	local03, local02
01440     08 B6 05 F1 | 	add	local03, #8
01444     DB 9C 01 FB | 	rdlong	result1, local03
01448     01 9C CD F7 | 	test	result1, #1 wz
0144c     DA A6 01 56 |  if_ne	mov	arg01, local02
01450     80 00 B0 5D |  if_ne	call	#__system____default_flush
01454     DB B8 01 FB | 	rdlong	local04, local03
01458     02 B8 45 F5 | 	or	local04, #2
0145c     DB B8 61 FC | 	wrlong	local04, local03
01460     08 B6 85 F1 | 	sub	local03, #8
01464     DB BA 01 FB | 	rdlong	local05, local03
01468     10 B6 05 F1 | 	add	local03, #16
0146c     DB A8 01 FB | 	rdlong	arg02, local03
01470     10 B6 85 F1 | 	sub	local03, #16
01474     DD 9C 01 F6 | 	mov	result1, local05
01478     D4 9C 01 F1 | 	add	result1, arg02
0147c     CE B2 41 FC | 	wrbyte	local01, result1
01480     D9 B2 E1 F8 | 	getbyte	local01, local01, #0
01484     01 BA 05 F1 | 	add	local05, #1
01488     DB BA 61 FC | 	wrlong	local05, local03
0148c     06 B4 05 F1 | 	add	local02, #6
01490     DA BC E9 FA | 	rdword	local06, local02 wz
01494     06 B4 85 F1 | 	sub	local02, #6
01498     0C B6 05 51 |  if_ne	add	local03, #12
0149c     DB B8 01 5B |  if_ne	rdlong	local04, local03
014a0     DC BA 09 52 |  if_ne	cmp	local05, local04 wz
014a4     0C 00 90 AD |  if_e	jmp	#LR__0170
014a8     0A B2 0D F2 | 	cmp	local01, #10 wz
014ac     01 BC 0D A2 |  if_e	cmp	local06, #1 wz
014b0     10 00 90 5D |  if_ne	jmp	#LR__0171
014b4                 | LR__0170
014b4     DA A6 01 F6 | 	mov	arg01, local02
014b8     18 00 B0 FD | 	call	#__system____default_flush
014bc     00 9C 0D F2 | 	cmp	result1, #0 wz
014c0     01 B2 65 56 |  if_ne	neg	local01, #1
014c4                 | LR__0171
014c4     D9 9C 01 F6 | 	mov	result1, local01
014c8     A7 F0 03 F6 | 	mov	ptra, fp
014cc     B2 00 A0 FD | 	call	#popregs_
014d0                 | __system____default_putc_ret
014d0     2D 00 64 FD | 	ret
014d4                 | 
014d4                 | __system____default_flush
014d4     06 4A 05 F6 | 	mov	COUNT_, #6
014d8     A8 00 A0 FD | 	call	#pushregs_
014dc     D3 B2 01 F6 | 	mov	local01, arg01
014e0     D9 B4 01 FB | 	rdlong	local02, local01
014e4     DA B6 01 FB | 	rdlong	local03, local02
014e8     08 B4 05 F1 | 	add	local02, #8
014ec     DA 9C 01 FB | 	rdlong	result1, local02
014f0     08 B4 85 F1 | 	sub	local02, #8
014f4     02 9C CD F7 | 	test	result1, #2 wz
014f8     D0 00 90 AD |  if_e	jmp	#LR__0182
014fc     01 B6 55 F2 | 	cmps	local03, #1 wc
01500     20 01 90 CD |  if_b	jmp	#LR__0184
01504     08 B2 05 F1 | 	add	local01, #8
01508     D9 9C 01 FB | 	rdlong	result1, local01
0150c     08 B2 85 F1 | 	sub	local01, #8
01510     40 9C CD F7 | 	test	result1, #64 wz
01514     68 00 90 AD |  if_e	jmp	#LR__0181
01518     08 B2 05 F1 | 	add	local01, #8
0151c     D9 AA 01 FB | 	rdlong	arg03, local01
01520     08 B2 85 F1 | 	sub	local01, #8
01524     80 AA CD F7 | 	test	arg03, #128 wz
01528     54 00 90 AD |  if_e	jmp	#LR__0180
0152c     30 B2 05 F1 | 	add	local01, #48
01530     D9 B8 01 FB | 	rdlong	local04, local01
01534     DC BA 01 F6 | 	mov	local05, local04
01538     30 B2 85 F1 | 	sub	local01, #48
0153c     13 BA 45 F7 | 	zerox	local05, #19
01540     14 B8 45 F0 | 	shr	local04, #20
01544     02 B8 65 F0 | 	shl	local04, #2
01548     C4 B8 01 F1 | 	add	local04, __methods__
0154c     DC B8 01 FB | 	rdlong	local04, local04
01550     D9 A6 01 F6 | 	mov	arg01, local01
01554     00 A8 05 F6 | 	mov	arg02, #0
01558     02 AA 05 F6 | 	mov	arg03, #2
0155c     C7 BC 01 F6 | 	mov	local06, objptr
01560     DD 8E 01 F6 | 	mov	objptr, local05
01564     2D B8 61 FD | 	call	local04
01568     DE 8E 01 F6 | 	mov	objptr, local06
0156c     08 B2 05 F1 | 	add	local01, #8
01570     D9 BC 01 FB | 	rdlong	local06, local01
01574     80 BC 25 F5 | 	andn	local06, #128
01578     D9 BC 61 FC | 	wrlong	local06, local01
0157c     08 B2 85 F1 | 	sub	local01, #8
01580                 | LR__0180
01580                 | LR__0181
01580     18 B2 05 F1 | 	add	local01, #24
01584     D9 B8 01 FB | 	rdlong	local04, local01
01588     DC BA 01 F6 | 	mov	local05, local04
0158c     18 B2 85 F1 | 	sub	local01, #24
01590     13 BA 45 F7 | 	zerox	local05, #19
01594     14 B8 45 F0 | 	shr	local04, #20
01598     02 B8 65 F0 | 	shl	local04, #2
0159c     C4 B8 01 F1 | 	add	local04, __methods__
015a0     DC B8 01 FB | 	rdlong	local04, local04
015a4     10 B4 05 F1 | 	add	local02, #16
015a8     DA A8 01 FB | 	rdlong	arg02, local02
015ac     10 B4 85 F1 | 	sub	local02, #16
015b0     D9 A6 01 F6 | 	mov	arg01, local01
015b4     DB AA 01 F6 | 	mov	arg03, local03
015b8     C7 BC 01 F6 | 	mov	local06, objptr
015bc     DD 8E 01 F6 | 	mov	objptr, local05
015c0     2D B8 61 FD | 	call	local04
015c4     DE 8E 01 F6 | 	mov	objptr, local06
015c8     58 00 90 FD | 	jmp	#LR__0184
015cc                 | LR__0182
015cc     08 B4 05 F1 | 	add	local02, #8
015d0     DA BC 01 FB | 	rdlong	local06, local02
015d4     08 B4 85 F1 | 	sub	local02, #8
015d8     01 BC CD F7 | 	test	local06, #1 wz
015dc     00 B6 0D 52 |  if_ne	cmp	local03, #0 wz
015e0     40 00 90 AD |  if_e	jmp	#LR__0183
015e4     30 B2 05 F1 | 	add	local01, #48
015e8     D9 B8 01 FB | 	rdlong	local04, local01
015ec     DC BA 01 F6 | 	mov	local05, local04
015f0     30 B2 85 F1 | 	sub	local01, #48
015f4     13 BA 45 F7 | 	zerox	local05, #19
015f8     14 B8 45 F0 | 	shr	local04, #20
015fc     02 B8 65 F0 | 	shl	local04, #2
01600     C4 B8 01 F1 | 	add	local04, __methods__
01604     DC B8 01 FB | 	rdlong	local04, local04
01608     D9 A6 01 F6 | 	mov	arg01, local01
0160c     DB A8 61 F6 | 	neg	arg02, local03
01610     01 AA 05 F6 | 	mov	arg03, #1
01614     C7 BC 01 F6 | 	mov	local06, objptr
01618     DD 8E 01 F6 | 	mov	objptr, local05
0161c     2D B8 61 FD | 	call	local04
01620     DE 8E 01 F6 | 	mov	objptr, local06
01624                 | LR__0183
01624                 | LR__0184
01624     DA 00 68 FC | 	wrlong	#0, local02
01628     04 B4 05 F1 | 	add	local02, #4
0162c     DA 00 68 FC | 	wrlong	#0, local02
01630     04 B4 05 F1 | 	add	local02, #4
01634     DA 00 68 FC | 	wrlong	#0, local02
01638     00 9C 05 F6 | 	mov	result1, #0
0163c     A7 F0 03 F6 | 	mov	ptra, fp
01640     B2 00 A0 FD | 	call	#popregs_
01644                 | __system____default_flush_ret
01644     2D 00 64 FD | 	ret
01648                 | 
01648                 | __system____getftab
01648     0A A6 15 F2 | 	cmp	arg01, #10 wc
0164c     34 A6 05 CD |  if_b	qmul	arg01, #52
01650     00 9C 05 36 |  if_ae	mov	result1, #0
01654     28 90 05 C1 |  if_b	add	ptr___system__dat__, #40
01658     18 9C 61 CD |  if_b	getqx	result1
0165c     C8 9C 01 C1 |  if_b	add	result1, ptr___system__dat__
01660     28 90 85 C1 |  if_b	sub	ptr___system__dat__, #40
01664                 | __system____getftab_ret
01664     2D 00 64 FD | 	ret
01668                 | 
01668                 | __system___strrev
01668     D3 A0 C9 FA | 	rdbyte	_var01, arg01 wz
0166c     3C 00 90 AD |  if_e	jmp	#__system___strrev_ret
01670     D3 A2 01 F6 | 	mov	_var02, arg01
01674     97 1A 48 FB | 	callpa	#(@LR__0192-@LR__0190)>>2,fcache_load_ptr_
01678                 | LR__0190
01678     D1 A0 C9 FA | 	rdbyte	_var01, _var02 wz
0167c     01 A2 05 51 |  if_ne	add	_var02, #1
01680     F4 FF 9F 5D |  if_ne	jmp	#LR__0190
01684     01 A2 85 F1 | 	sub	_var02, #1
01688                 | LR__0191
01688     D3 A2 59 F2 | 	cmps	_var02, arg01 wcz
0168c     1C 00 90 ED |  if_be	jmp	#LR__0193
01690     D3 A0 C1 FA | 	rdbyte	_var01, arg01
01694     D1 A4 C1 FA | 	rdbyte	_var03, _var02
01698     D3 A4 41 FC | 	wrbyte	_var03, arg01
0169c     D1 A0 41 FC | 	wrbyte	_var01, _var02
016a0     01 A6 05 F1 | 	add	arg01, #1
016a4     01 A2 85 F1 | 	sub	_var02, #1
016a8     DC FF 9F FD | 	jmp	#LR__0191
016ac                 | LR__0192
016ac                 | LR__0193
016ac                 | __system___strrev_ret
016ac     2D 00 64 FD | 	ret
016b0                 | 
016b0                 | __system___fmtpad
016b0     06 4A 05 F6 | 	mov	COUNT_, #6
016b4     A8 00 A0 FD | 	call	#pushregs_
016b8     D3 B2 01 F6 | 	mov	local01, arg01
016bc     D4 B4 01 F6 | 	mov	local02, arg02
016c0     D5 B6 01 F6 | 	mov	local03, arg03
016c4     DA A6 E9 F8 | 	getbyte	arg01, local02, #1
016c8     16 B4 45 F0 | 	shr	local02, #22
016cc     03 B4 0D F5 | 	and	local02, #3 wz
016d0     00 B8 05 F6 | 	mov	local04, #0
016d4     01 B4 05 A6 |  if_e	mov	local02, #1
016d8     D6 B4 C9 F7 | 	test	local02, arg04 wz
016dc     00 9C 05 A6 |  if_e	mov	result1, #0
016e0     88 00 90 AD |  if_e	jmp	#LR__0203
016e4     D3 B6 C1 F2 | 	subr	local03, arg01
016e8     01 B6 55 F2 | 	cmps	local03, #1 wc
016ec     00 9C 05 C6 |  if_b	mov	result1, #0
016f0     78 00 90 CD |  if_b	jmp	#LR__0203
016f4     03 B4 0D F2 | 	cmp	local02, #3 wz
016f8     18 00 90 5D |  if_ne	jmp	#LR__0200
016fc     01 AC 0D F2 | 	cmp	arg04, #1 wz
01700     6E B4 61 FD | 	wrz	local02
01704     DA B6 01 F1 | 	add	local03, local02
01708     DB B6 51 F6 | 	abs	local03, local03 wc
0170c     01 B6 45 F0 | 	shr	local03, #1
01710     DB B6 81 F6 | 	negc	local03, local03
01714                 | LR__0200
01714     01 B6 55 F2 | 	cmps	local03, #1 wc
01718     4C 00 90 CD |  if_b	jmp	#LR__0202
0171c     DB BA 01 F6 | 	mov	local05, local03
01720                 | LR__0201
01720     D9 B4 01 F6 | 	mov	local02, local01
01724     D9 BC 01 F6 | 	mov	local06, local01
01728     13 B4 45 F7 | 	zerox	local02, #19
0172c     14 BC 45 F0 | 	shr	local06, #20
01730     02 BC 65 F0 | 	shl	local06, #2
01734     C4 BC 01 F1 | 	add	local06, __methods__
01738     DE BC 01 FB | 	rdlong	local06, local06
0173c     20 A6 05 F6 | 	mov	arg01, #32
01740     C7 B6 01 F6 | 	mov	local03, objptr
01744     DA 8E 01 F6 | 	mov	objptr, local02
01748     2D BC 61 FD | 	call	local06
0174c     DB 8E 01 F6 | 	mov	objptr, local03
01750     CE BC 01 F6 | 	mov	local06, result1
01754     00 BC 55 F2 | 	cmps	local06, #0 wc
01758     DE 9C 01 C6 |  if_b	mov	result1, local06
0175c     0C 00 90 CD |  if_b	jmp	#LR__0203
01760     DE B8 01 F1 | 	add	local04, local06
01764     EE BB 6D FB | 	djnz	local05, #LR__0201
01768                 | LR__0202
01768     DC 9C 01 F6 | 	mov	result1, local04
0176c                 | LR__0203
0176c     A7 F0 03 F6 | 	mov	ptra, fp
01770     B2 00 A0 FD | 	call	#popregs_
01774                 | __system___fmtpad_ret
01774     2D 00 64 FD | 	ret
01778                 | 
01778                 | __system___uitoa
01778     04 4A 05 F6 | 	mov	COUNT_, #4
0177c     A8 00 A0 FD | 	call	#pushregs_
01780     D3 B2 01 F6 | 	mov	local01, arg01
01784     00 AE 4D F2 | 	cmps	arg05, #0 wz
01788     D9 AE 01 F6 | 	mov	arg05, local01
0178c     00 B4 05 F6 | 	mov	local02, #0
01790     37 B6 05 56 |  if_ne	mov	local03, #55
01794     57 B6 05 A6 |  if_e	mov	local03, #87
01798                 | LR__0210
01798     D5 A8 11 FD | 	qdiv	arg02, arg03
0179c     19 B8 61 FD | 	getqy	local04
017a0     D5 A8 11 FD | 	qdiv	arg02, arg03
017a4     0A B8 15 F2 | 	cmp	local04, #10 wc
017a8     30 B8 05 C1 |  if_b	add	local04, #48
017ac     DB B8 01 31 |  if_ae	add	local04, local03
017b0     D7 B8 41 FC | 	wrbyte	local04, arg05
017b4     01 AE 05 F1 | 	add	arg05, #1
017b8     01 B4 05 F1 | 	add	local02, #1
017bc     18 A8 61 FD | 	getqx	arg02
017c0     00 A8 0D F2 | 	cmp	arg02, #0 wz
017c4     D0 FF 9F 5D |  if_ne	jmp	#LR__0210
017c8     D6 B4 11 F2 | 	cmp	local02, arg04 wc
017cc     C8 FF 9F CD |  if_b	jmp	#LR__0210
017d0     D7 00 48 FC | 	wrbyte	#0, arg05
017d4     D9 A6 01 F6 | 	mov	arg01, local01
017d8     8C FE BF FD | 	call	#__system___strrev
017dc     DA 9C 01 F6 | 	mov	result1, local02
017e0     A7 F0 03 F6 | 	mov	ptra, fp
017e4     B2 00 A0 FD | 	call	#popregs_
017e8                 | __system___uitoa_ret
017e8     2D 00 64 FD | 	ret
017ec                 | 
017ec                 | __system___gettxfunc
017ec     01 4A 05 F6 | 	mov	COUNT_, #1
017f0     A8 00 A0 FD | 	call	#pushregs_
017f4     50 FE BF FD | 	call	#__system____getftab
017f8     CE B2 09 F6 | 	mov	local01, result1 wz
017fc     10 00 90 AD |  if_e	jmp	#LR__0220
01800     08 B2 05 F1 | 	add	local01, #8
01804     D9 A8 09 FB | 	rdlong	arg02, local01 wz
01808     08 B2 85 F1 | 	sub	local01, #8
0180c     08 00 90 5D |  if_ne	jmp	#LR__0221
01810                 | LR__0220
01810     00 9C 05 F6 | 	mov	result1, #0
01814     08 00 90 FD | 	jmp	#LR__0222
01818                 | LR__0221
01818     34 B2 25 F4 | 	bith	local01, #52
0181c     D9 9C 01 F6 | 	mov	result1, local01
01820                 | LR__0222
01820     A7 F0 03 F6 | 	mov	ptra, fp
01824     B2 00 A0 FD | 	call	#popregs_
01828                 | __system___gettxfunc_ret
01828     2D 00 64 FD | 	ret
0182c                 | 
0182c                 | __system___getiolock_0095
0182c     01 4A 05 F6 | 	mov	COUNT_, #1
01830     A8 00 A0 FD | 	call	#pushregs_
01834     10 FE BF FD | 	call	#__system____getftab
01838     CE B2 09 F6 | 	mov	local01, result1 wz
0183c     10 00 90 AD |  if_e	jmp	#LR__0230
01840     08 B2 05 F1 | 	add	local01, #8
01844     D9 9C 09 FB | 	rdlong	result1, local01 wz
01848     08 B2 85 F1 | 	sub	local01, #8
0184c     10 00 90 5D |  if_ne	jmp	#LR__0231
01850                 | LR__0230
01850     24 90 05 F1 | 	add	ptr___system__dat__, #36
01854     C8 9C 01 F6 | 	mov	result1, ptr___system__dat__
01858     24 90 85 F1 | 	sub	ptr___system__dat__, #36
0185c     08 00 90 FD | 	jmp	#LR__0232
01860                 | LR__0231
01860     0C B2 05 F1 | 	add	local01, #12
01864     D9 9C 01 F6 | 	mov	result1, local01
01868                 | LR__0232
01868     A7 F0 03 F6 | 	mov	ptra, fp
0186c     B2 00 A0 FD | 	call	#popregs_
01870                 | __system___getiolock_0095_ret
01870     2D 00 64 FD | 	ret
01874                 | 
01874                 | __system___rxtxioctl_0142
01874     00 A9 0D F2 | 	cmp	arg02, #256 wz
01878     0C 00 90 AD |  if_e	jmp	#LR__0240
0187c     01 A9 0D F2 | 	cmp	arg02, #257 wz
01880     1C 00 90 AD |  if_e	jmp	#LR__0241
01884     30 00 90 FD | 	jmp	#LR__0242
01888                 | LR__0240
01888     08 90 05 F1 | 	add	ptr___system__dat__, #8
0188c     C8 9C 01 FB | 	rdlong	result1, ptr___system__dat__
01890     08 90 85 F1 | 	sub	ptr___system__dat__, #8
01894     D5 9C 61 FC | 	wrlong	result1, arg03
01898     00 9C 05 F6 | 	mov	result1, #0
0189c     28 00 90 FD | 	jmp	#LR__0243
018a0                 | LR__0241
018a0     D5 A6 01 FB | 	rdlong	arg01, arg03
018a4     08 90 05 F1 | 	add	ptr___system__dat__, #8
018a8     C8 A6 61 FC | 	wrlong	arg01, ptr___system__dat__
018ac     08 90 85 F1 | 	sub	ptr___system__dat__, #8
018b0     00 9C 05 F6 | 	mov	result1, #0
018b4     10 00 90 FD | 	jmp	#LR__0243
018b8                 | LR__0242
018b8     20 90 05 F1 | 	add	ptr___system__dat__, #32
018bc     C8 14 68 FC | 	wrlong	#10, ptr___system__dat__
018c0     20 90 85 F1 | 	sub	ptr___system__dat__, #32
018c4     01 9C 65 F6 | 	neg	result1, #1
018c8                 | LR__0243
018c8                 | __system___rxtxioctl_0142_ret
018c8     2D 00 64 FD | 	ret
018cc                 | 
018cc                 | __system____dummy_flush_0143
018cc     00 9C 05 F6 | 	mov	result1, #0
018d0                 | __system____dummy_flush_0143_ret
018d0     2D 00 64 FD | 	ret
018d4                 | 
018d4                 | __system____default_filbuf
018d4     04 4A 05 F6 | 	mov	COUNT_, #4
018d8     A8 00 A0 FD | 	call	#pushregs_
018dc     D3 B2 01 F6 | 	mov	local01, arg01
018e0     D9 B4 01 FB | 	rdlong	local02, local01
018e4     0C B4 05 F1 | 	add	local02, #12
018e8     DA 9C 09 FB | 	rdlong	result1, local02 wz
018ec     0C B4 85 F1 | 	sub	local02, #12
018f0     20 00 90 5D |  if_ne	jmp	#LR__0250
018f4     14 B4 05 F1 | 	add	local02, #20
018f8     DA 9C 01 F6 | 	mov	result1, local02
018fc     04 B4 85 F1 | 	sub	local02, #4
01900     DA 9C 61 FC | 	wrlong	result1, local02
01904     04 B4 85 F1 | 	sub	local02, #4
01908     02 00 80 FF 
0190c     DA 00 68 FC | 	wrlong	##1024, local02
01910     0C B4 85 F1 | 	sub	local02, #12
01914                 | LR__0250
01914     14 B2 05 F1 | 	add	local01, #20
01918     D9 B6 01 FB | 	rdlong	local03, local01
0191c     DB B8 01 F6 | 	mov	local04, local03
01920     14 B2 85 F1 | 	sub	local01, #20
01924     13 B8 45 F7 | 	zerox	local04, #19
01928     14 B6 45 F0 | 	shr	local03, #20
0192c     02 B6 65 F0 | 	shl	local03, #2
01930     C4 B6 01 F1 | 	add	local03, __methods__
01934     DB B6 01 FB | 	rdlong	local03, local03
01938     10 B4 05 F1 | 	add	local02, #16
0193c     DA A8 01 FB | 	rdlong	arg02, local02
01940     04 B4 85 F1 | 	sub	local02, #4
01944     DA AA 01 FB | 	rdlong	arg03, local02
01948     0C B4 85 F1 | 	sub	local02, #12
0194c     D9 A6 01 F6 | 	mov	arg01, local01
01950     C7 B2 01 F6 | 	mov	local01, objptr
01954     DC 8E 01 F6 | 	mov	objptr, local04
01958     2D B6 61 FD | 	call	local03
0195c     D9 8E 01 F6 | 	mov	objptr, local01
01960     CE B8 01 F6 | 	mov	local04, result1
01964     00 B8 55 F2 | 	cmps	local04, #0 wc
01968     01 9C 65 C6 |  if_b	neg	result1, #1
0196c     28 00 90 CD |  if_b	jmp	#LR__0251
01970     DA B8 61 FC | 	wrlong	local04, local02
01974     10 B4 05 F1 | 	add	local02, #16
01978     DA B6 01 FB | 	rdlong	local03, local02
0197c     0C B4 85 F1 | 	sub	local02, #12
01980     DA B6 61 FC | 	wrlong	local03, local02
01984     04 B4 05 F1 | 	add	local02, #4
01988     DA B6 01 FB | 	rdlong	local03, local02
0198c     01 B6 45 F5 | 	or	local03, #1
01990     DA B6 61 FC | 	wrlong	local03, local02
01994     DC 9C 01 F6 | 	mov	result1, local04
01998                 | LR__0251
01998     A7 F0 03 F6 | 	mov	ptra, fp
0199c     B2 00 A0 FD | 	call	#popregs_
019a0                 | __system____default_filbuf_ret
019a0     2D 00 64 FD | 	ret
019a4                 | 
019a4                 | __struct__s_vfs_file_t_putchar
019a4     04 4A 05 F6 | 	mov	COUNT_, #4
019a8     A8 00 A0 FD | 	call	#pushregs_
019ac     1C 8E 05 F1 | 	add	objptr, #28
019b0     C7 B2 09 FB | 	rdlong	local01, objptr wz
019b4     1C 8E 85 F1 | 	sub	objptr, #28
019b8     00 9C 05 A6 |  if_e	mov	result1, #0
019bc     48 00 90 AD |  if_e	jmp	#LR__0260
019c0     1C 8E 05 F1 | 	add	objptr, #28
019c4     C7 B4 01 FB | 	rdlong	local02, objptr
019c8     DA B6 01 F6 | 	mov	local03, local02
019cc     1C 8E 85 F1 | 	sub	objptr, #28
019d0     13 B6 45 F7 | 	zerox	local03, #19
019d4     14 B4 45 F0 | 	shr	local02, #20
019d8     02 B4 65 F0 | 	shl	local02, #2
019dc     C4 B4 01 F1 | 	add	local02, __methods__
019e0     DA B4 01 FB | 	rdlong	local02, local02
019e4     C7 A8 01 F6 | 	mov	arg02, objptr
019e8     C7 B8 01 F6 | 	mov	local04, objptr
019ec     DB 8E 01 F6 | 	mov	objptr, local03
019f0     2D B4 61 FD | 	call	local02
019f4     DC 8E 01 F6 | 	mov	objptr, local04
019f8                 | '     return (i < 0) ? 0 : 1;
019f8     00 9C 55 F2 | 	cmps	result1, #0 wc
019fc     00 B2 05 C6 |  if_b	mov	local01, #0
01a00     01 B2 05 36 |  if_ae	mov	local01, #1
01a04     D9 9C 01 F6 | 	mov	result1, local01
01a08                 | LR__0260
01a08     A7 F0 03 F6 | 	mov	ptra, fp
01a0c     B2 00 A0 FD | 	call	#popregs_
01a10                 | __struct__s_vfs_file_t_putchar_ret
01a10     2D 00 64 FD | 	ret
01a14                 | 
01a14                 | __struct__s_vfs_file_t_getchar
01a14     03 4A 05 F6 | 	mov	COUNT_, #3
01a18     A8 00 A0 FD | 	call	#pushregs_
01a1c     20 8E 05 F1 | 	add	objptr, #32
01a20     C7 A6 09 FB | 	rdlong	arg01, objptr wz
01a24     20 8E 85 F1 | 	sub	objptr, #32
01a28     01 9C 65 A6 |  if_e	neg	result1, #1
01a2c     38 00 90 AD |  if_e	jmp	#LR__0270
01a30                 | '     return getcf(__this);
01a30     20 8E 05 F1 | 	add	objptr, #32
01a34     C7 B2 01 FB | 	rdlong	local01, objptr
01a38     D9 B4 01 F6 | 	mov	local02, local01
01a3c     20 8E 85 F1 | 	sub	objptr, #32
01a40     13 B4 45 F7 | 	zerox	local02, #19
01a44     14 B2 45 F0 | 	shr	local01, #20
01a48     02 B2 65 F0 | 	shl	local01, #2
01a4c     C4 B2 01 F1 | 	add	local01, __methods__
01a50     D9 B2 01 FB | 	rdlong	local01, local01
01a54     C7 A6 01 F6 | 	mov	arg01, objptr
01a58     C7 B6 01 F6 | 	mov	local03, objptr
01a5c     DA 8E 01 F6 | 	mov	objptr, local02
01a60     2D B2 61 FD | 	call	local01
01a64     DB 8E 01 F6 | 	mov	objptr, local03
01a68                 | LR__0270
01a68     A7 F0 03 F6 | 	mov	ptra, fp
01a6c     B2 00 A0 FD | 	call	#popregs_
01a70                 | __struct__s_vfs_file_t_getchar_ret
01a70     2D 00 64 FD | 	ret
01a74                 | 
01a74                 | __struct___bas_wrap_sender_tx
01a74     03 4A 05 F6 | 	mov	COUNT_, #3
01a78     A8 00 A0 FD | 	call	#pushregs_
01a7c     C7 B2 01 FB | 	rdlong	local01, objptr
01a80     D9 B4 01 F6 | 	mov	local02, local01
01a84     13 B2 45 F7 | 	zerox	local01, #19
01a88     14 B4 45 F0 | 	shr	local02, #20
01a8c     02 B4 65 F0 | 	shl	local02, #2
01a90     C4 B4 01 F1 | 	add	local02, __methods__
01a94     DA B4 01 FB | 	rdlong	local02, local02
01a98     C7 B6 01 F6 | 	mov	local03, objptr
01a9c     D9 8E 01 F6 | 	mov	objptr, local01
01aa0     2D B4 61 FD | 	call	local02
01aa4     DB 8E 01 F6 | 	mov	objptr, local03
01aa8     01 9C 05 F6 | 	mov	result1, #1
01aac     A7 F0 03 F6 | 	mov	ptra, fp
01ab0     B2 00 A0 FD | 	call	#popregs_
01ab4                 | __struct___bas_wrap_sender_tx_ret
01ab4     2D 00 64 FD | 	ret
01ab8                 | 
01ab8                 | __struct___bas_wrap_sender_rx
01ab8     03 4A 05 F6 | 	mov	COUNT_, #3
01abc     A8 00 A0 FD | 	call	#pushregs_
01ac0     04 8E 05 F1 | 	add	objptr, #4
01ac4     C7 B2 01 FB | 	rdlong	local01, objptr
01ac8     D9 B4 01 F6 | 	mov	local02, local01
01acc     04 8E 85 F1 | 	sub	objptr, #4
01ad0     13 B4 45 F7 | 	zerox	local02, #19
01ad4     14 B2 45 F0 | 	shr	local01, #20
01ad8     02 B2 65 F0 | 	shl	local01, #2
01adc     C4 B2 01 F1 | 	add	local01, __methods__
01ae0     D9 B2 01 FB | 	rdlong	local01, local01
01ae4     C7 B6 01 F6 | 	mov	local03, objptr
01ae8     DA 8E 01 F6 | 	mov	objptr, local02
01aec     2D B2 61 FD | 	call	local01
01af0     DB 8E 01 F6 | 	mov	objptr, local03
01af4     A7 F0 03 F6 | 	mov	ptra, fp
01af8     B2 00 A0 FD | 	call	#popregs_
01afc                 | __struct___bas_wrap_sender_rx_ret
01afc     2D 00 64 FD | 	ret
01b00                 | 
01b00                 | __struct___bas_wrap_sender_close
01b00     03 4A 05 F6 | 	mov	COUNT_, #3
01b04     A8 00 A0 FD | 	call	#pushregs_
01b08     08 8E 05 F1 | 	add	objptr, #8
01b0c     C7 B2 01 FB | 	rdlong	local01, objptr
01b10     D9 B4 01 F6 | 	mov	local02, local01
01b14     08 8E 85 F1 | 	sub	objptr, #8
01b18     13 B4 45 F7 | 	zerox	local02, #19
01b1c     14 B2 45 F0 | 	shr	local01, #20
01b20     02 B2 65 F0 | 	shl	local01, #2
01b24     C4 B2 01 F1 | 	add	local01, __methods__
01b28     D9 B2 01 FB | 	rdlong	local01, local01
01b2c     C7 B6 01 F6 | 	mov	local03, objptr
01b30     DA 8E 01 F6 | 	mov	objptr, local02
01b34     2D B2 61 FD | 	call	local01
01b38     DB 8E 01 F6 | 	mov	objptr, local03
01b3c     A7 F0 03 F6 | 	mov	ptra, fp
01b40     B2 00 A0 FD | 	call	#popregs_
01b44                 | __struct___bas_wrap_sender_close_ret
01b44     2D 00 64 FD | 	ret
01b48                 | 	alignl
01b48                 | _dat_
01b48     73 32 00 04 
01b4c     00 00 10 00 
01b50     00 00 00 00 
01b54     00 00 00 00 | sinewave file "sinus.s2"
01b58     00 00 C9 00 
01b5c     92 01 5B 02 
01b60     24 03 ED 03 
01b64     B6 04 7F 05 | 	byte	$00, $00, $c9, $00, $92, $01, $5b, $02, $24, $03, $ed, $03, $b6, $04, $7f, $05
01b68     48 06 11 07 
01b6c     D9 07 A2 08 
01b70     6A 09 33 0A 
01b74     FB 0A C4 0B | 	byte	$48, $06, $11, $07, $d9, $07, $a2, $08, $6a, $09, $33, $0a, $fb, $0a, $c4, $0b
01b78     8C 0C 54 0D 
01b7c     1C 0E E3 0E 
01b80     AB 0F 72 10 
01b84     3A 11 01 12 | 	byte	$8c, $0c, $54, $0d, $1c, $0e, $e3, $0e, $ab, $0f, $72, $10, $3a, $11, $01, $12
01b88     C8 12 8F 13 
01b8c     55 14 1C 15 
01b90     E2 15 A8 16 
01b94     6E 17 33 18 | 	byte	$c8, $12, $8f, $13, $55, $14, $1c, $15, $e2, $15, $a8, $16, $6e, $17, $33, $18
01b98     F9 18 BE 19 
01b9c     82 1A 47 1B 
01ba0     0B 1C CF 1C 
01ba4     93 1D 57 1E | 	byte	$f9, $18, $be, $19, $82, $1a, $47, $1b, $0b, $1c, $cf, $1c, $93, $1d, $57, $1e
01ba8     1A 1F DD 1F 
01bac     9F 20 61 21 
01bb0     23 22 E5 22 
01bb4     A6 23 67 24 | 	byte	$1a, $1f, $dd, $1f, $9f, $20, $61, $21, $23, $22, $e5, $22, $a6, $23, $67, $24
01bb8     28 25 E8 25 
01bbc     A8 26 67 27 
01bc0     26 28 E5 28 
01bc4     A3 29 61 2A | 	byte	$28, $25, $e8, $25, $a8, $26, $67, $27, $26, $28, $e5, $28, $a3, $29, $61, $2a
01bc8     1F 2B DC 2B 
01bcc     99 2C 55 2D 
01bd0     11 2E CC 2E 
01bd4     87 2F 41 30 | 	byte	$1f, $2b, $dc, $2b, $99, $2c, $55, $2d, $11, $2e, $cc, $2e, $87, $2f, $41, $30
01bd8     FB 30 B5 31 
01bdc     6E 32 26 33 
01be0     DF 33 96 34 
01be4     4D 35 04 36 | 	byte	$fb, $30, $b5, $31, $6e, $32, $26, $33, $df, $33, $96, $34, $4d, $35, $04, $36
01be8     BA 36 6F 37 
01bec     24 38 D9 38 
01bf0     8C 39 40 3A 
01bf4     F2 3A A5 3B | 	byte	$ba, $36, $6f, $37, $24, $38, $d9, $38, $8c, $39, $40, $3a, $f2, $3a, $a5, $3b
01bf8     56 3C 07 3D 
01bfc     B8 3D 68 3E 
01c00     17 3F C5 3F 
01c04     73 40 21 41 | 	byte	$56, $3c, $07, $3d, $b8, $3d, $68, $3e, $17, $3f, $c5, $3f, $73, $40, $21, $41
01c08     CE 41 7A 42 
01c0c     25 43 D0 43 
01c10     7A 44 24 45 
01c14     CD 45 75 46 | 	byte	$ce, $41, $7a, $42, $25, $43, $d0, $43, $7a, $44, $24, $45, $cd, $45, $75, $46
01c18     1C 47 C3 47 
01c1c     69 48 0F 49 
01c20     B4 49 58 4A 
01c24     FB 4A 9D 4B | 	byte	$1c, $47, $c3, $47, $69, $48, $0f, $49, $b4, $49, $58, $4a, $fb, $4a, $9d, $4b
01c28     3F 4C E0 4C 
01c2c     81 4D 20 4E 
01c30     BF 4E 5D 4F 
01c34     FB 4F 97 50 | 	byte	$3f, $4c, $e0, $4c, $81, $4d, $20, $4e, $bf, $4e, $5d, $4f, $fb, $4f, $97, $50
01c38     33 51 CE 51 
01c3c     68 52 02 53 
01c40     9B 53 32 54 
01c44     C9 54 60 55 | 	byte	$33, $51, $ce, $51, $68, $52, $02, $53, $9b, $53, $32, $54, $c9, $54, $60, $55
01c48     F5 55 8A 56 
01c4c     1D 57 B0 57 
01c50     42 58 D3 58 
01c54     64 59 F3 59 | 	byte	$f5, $55, $8a, $56, $1d, $57, $b0, $57, $42, $58, $d3, $58, $64, $59, $f3, $59
01c58     82 5A 0F 5B 
01c5c     9C 5B 28 5C 
01c60     B3 5C 3E 5D 
01c64     C7 5D 4F 5E | 	byte	$82, $5a, $0f, $5b, $9c, $5b, $28, $5c, $b3, $5c, $3e, $5d, $c7, $5d, $4f, $5e
01c68     D7 5E 5D 5F 
01c6c     E3 5F 68 60 
01c70     EB 60 6E 61 
01c74     F0 61 71 62 | 	byte	$d7, $5e, $5d, $5f, $e3, $5f, $68, $60, $eb, $60, $6e, $61, $f0, $61, $71, $62
01c78     F1 62 70 63 
01c7c     EE 63 6C 64 
01c80     E8 64 63 65 
01c84     DD 65 56 66 | 	byte	$f1, $62, $70, $63, $ee, $63, $6c, $64, $e8, $64, $63, $65, $dd, $65, $56, $66
01c88     CF 66 46 67 
01c8c     BC 67 32 68 
01c90     A6 68 19 69 
01c94     8B 69 FD 69 | 	byte	$cf, $66, $46, $67, $bc, $67, $32, $68, $a6, $68, $19, $69, $8b, $69, $fd, $69
01c98     6D 6A DC 6A 
01c9c     4A 6B B7 6B 
01ca0     23 6C 8E 6C 
01ca4     F8 6C 61 6D | 	byte	$6d, $6a, $dc, $6a, $4a, $6b, $b7, $6b, $23, $6c, $8e, $6c, $f8, $6c, $61, $6d
01ca8     C9 6D 30 6E 
01cac     96 6E FB 6E 
01cb0     5E 6F C1 6F 
01cb4     22 70 83 70 | 	byte	$c9, $6d, $30, $6e, $96, $6e, $fb, $6e, $5e, $6f, $c1, $6f, $22, $70, $83, $70
01cb8     E2 70 40 71 
01cbc     9D 71 F9 71 
01cc0     54 72 AE 72 
01cc4     07 73 5E 73 | 	byte	$e2, $70, $40, $71, $9d, $71, $f9, $71, $54, $72, $ae, $72, $07, $73, $5e, $73
01cc8     B5 73 0A 74 
01ccc     5F 74 B2 74 
01cd0     04 75 55 75 
01cd4     A5 75 F3 75 | 	byte	$b5, $73, $0a, $74, $5f, $74, $b2, $74, $04, $75, $55, $75, $a5, $75, $f3, $75
01cd8     41 76 8D 76 
01cdc     D8 76 22 77 
01ce0     6B 77 B3 77 
01ce4     FA 77 3F 78 | 	byte	$41, $76, $8d, $76, $d8, $76, $22, $77, $6b, $77, $b3, $77, $fa, $77, $3f, $78
01ce8     84 78 C7 78 
01cec     09 79 4A 79 
01cf0     89 79 C8 79 
01cf4     05 7A 41 7A | 	byte	$84, $78, $c7, $78, $09, $79, $4a, $79, $89, $79, $c8, $79, $05, $7a, $41, $7a
01cf8     7C 7A B6 7A 
01cfc     EE 7A 26 7B 
01d00     5C 7B 91 7B 
01d04     C5 7B F8 7B | 	byte	$7c, $7a, $b6, $7a, $ee, $7a, $26, $7b, $5c, $7b, $91, $7b, $c5, $7b, $f8, $7b
01d08     29 7C 59 7C 
01d0c     88 7C B6 7C 
01d10     E3 7C 0E 7D 
01d14     39 7D 62 7D | 	byte	$29, $7c, $59, $7c, $88, $7c, $b6, $7c, $e3, $7c, $0e, $7d, $39, $7d, $62, $7d
01d18     89 7D B0 7D 
01d1c     D5 7D FA 7D 
01d20     1D 7E 3E 7E 
01d24     5F 7E 7E 7E | 	byte	$89, $7d, $b0, $7d, $d5, $7d, $fa, $7d, $1d, $7e, $3e, $7e, $5f, $7e, $7e, $7e
01d28     9C 7E B9 7E 
01d2c     D5 7E EF 7E 
01d30     09 7F 21 7F 
01d34     37 7F 4D 7F | 	byte	$9c, $7e, $b9, $7e, $d5, $7e, $ef, $7e, $09, $7f, $21, $7f, $37, $7f, $4d, $7f
01d38     61 7F 74 7F 
01d3c     86 7F 97 7F 
01d40     A6 7F B4 7F 
01d44     C1 7F CD 7F | 	byte	$61, $7f, $74, $7f, $86, $7f, $97, $7f, $a6, $7f, $b4, $7f, $c1, $7f, $cd, $7f
01d48     D8 7F E1 7F 
01d4c     E9 7F F0 7F 
01d50     F5 7F F9 7F 
01d54     FD 7F FE 7F | 	byte	$d8, $7f, $e1, $7f, $e9, $7f, $f0, $7f, $f5, $7f, $f9, $7f, $fd, $7f, $fe, $7f
01d58     FF 7F FE 7F 
01d5c     FD 7F F9 7F 
01d60     F5 7F F0 7F 
01d64     E9 7F E1 7F | 	byte	$ff, $7f, $fe, $7f, $fd, $7f, $f9, $7f, $f5, $7f, $f0, $7f, $e9, $7f, $e1, $7f
01d68     D8 7F CD 7F 
01d6c     C1 7F B4 7F 
01d70     A6 7F 97 7F 
01d74     86 7F 74 7F | 	byte	$d8, $7f, $cd, $7f, $c1, $7f, $b4, $7f, $a6, $7f, $97, $7f, $86, $7f, $74, $7f
01d78     61 7F 4D 7F 
01d7c     37 7F 21 7F 
01d80     09 7F EF 7E 
01d84     D5 7E B9 7E | 	byte	$61, $7f, $4d, $7f, $37, $7f, $21, $7f, $09, $7f, $ef, $7e, $d5, $7e, $b9, $7e
01d88     9C 7E 7E 7E 
01d8c     5F 7E 3E 7E 
01d90     1D 7E FA 7D 
01d94     D5 7D B0 7D | 	byte	$9c, $7e, $7e, $7e, $5f, $7e, $3e, $7e, $1d, $7e, $fa, $7d, $d5, $7d, $b0, $7d
01d98     89 7D 62 7D 
01d9c     39 7D 0E 7D 
01da0     E3 7C B6 7C 
01da4     88 7C 59 7C | 	byte	$89, $7d, $62, $7d, $39, $7d, $0e, $7d, $e3, $7c, $b6, $7c, $88, $7c, $59, $7c
01da8     29 7C F8 7B 
01dac     C5 7B 91 7B 
01db0     5C 7B 26 7B 
01db4     EE 7A B6 7A | 	byte	$29, $7c, $f8, $7b, $c5, $7b, $91, $7b, $5c, $7b, $26, $7b, $ee, $7a, $b6, $7a
01db8     7C 7A 41 7A 
01dbc     05 7A C8 79 
01dc0     89 79 4A 79 
01dc4     09 79 C7 78 | 	byte	$7c, $7a, $41, $7a, $05, $7a, $c8, $79, $89, $79, $4a, $79, $09, $79, $c7, $78
01dc8     84 78 3F 78 
01dcc     FA 77 B3 77 
01dd0     6B 77 22 77 
01dd4     D8 76 8D 76 | 	byte	$84, $78, $3f, $78, $fa, $77, $b3, $77, $6b, $77, $22, $77, $d8, $76, $8d, $76
01dd8     41 76 F3 75 
01ddc     A5 75 55 75 
01de0     04 75 B2 74 
01de4     5F 74 0A 74 | 	byte	$41, $76, $f3, $75, $a5, $75, $55, $75, $04, $75, $b2, $74, $5f, $74, $0a, $74
01de8     B5 73 5E 73 
01dec     07 73 AE 72 
01df0     54 72 F9 71 
01df4     9D 71 40 71 | 	byte	$b5, $73, $5e, $73, $07, $73, $ae, $72, $54, $72, $f9, $71, $9d, $71, $40, $71
01df8     E2 70 83 70 
01dfc     22 70 C1 6F 
01e00     5E 6F FB 6E 
01e04     96 6E 30 6E | 	byte	$e2, $70, $83, $70, $22, $70, $c1, $6f, $5e, $6f, $fb, $6e, $96, $6e, $30, $6e
01e08     C9 6D 61 6D 
01e0c     F8 6C 8E 6C 
01e10     23 6C B7 6B 
01e14     4A 6B DC 6A | 	byte	$c9, $6d, $61, $6d, $f8, $6c, $8e, $6c, $23, $6c, $b7, $6b, $4a, $6b, $dc, $6a
01e18     6D 6A FD 69 
01e1c     8B 69 19 69 
01e20     A6 68 32 68 
01e24     BC 67 46 67 | 	byte	$6d, $6a, $fd, $69, $8b, $69, $19, $69, $a6, $68, $32, $68, $bc, $67, $46, $67
01e28     CF 66 56 66 
01e2c     DD 65 63 65 
01e30     E8 64 6C 64 
01e34     EE 63 70 63 | 	byte	$cf, $66, $56, $66, $dd, $65, $63, $65, $e8, $64, $6c, $64, $ee, $63, $70, $63
01e38     F1 62 71 62 
01e3c     F0 61 6E 61 
01e40     EB 60 68 60 
01e44     E3 5F 5D 5F | 	byte	$f1, $62, $71, $62, $f0, $61, $6e, $61, $eb, $60, $68, $60, $e3, $5f, $5d, $5f
01e48     D7 5E 4F 5E 
01e4c     C7 5D 3E 5D 
01e50     B3 5C 28 5C 
01e54     9C 5B 0F 5B | 	byte	$d7, $5e, $4f, $5e, $c7, $5d, $3e, $5d, $b3, $5c, $28, $5c, $9c, $5b, $0f, $5b
01e58     82 5A F3 59 
01e5c     64 59 D3 58 
01e60     42 58 B0 57 
01e64     1D 57 8A 56 | 	byte	$82, $5a, $f3, $59, $64, $59, $d3, $58, $42, $58, $b0, $57, $1d, $57, $8a, $56
01e68     F5 55 60 55 
01e6c     C9 54 32 54 
01e70     9B 53 02 53 
01e74     68 52 CE 51 | 	byte	$f5, $55, $60, $55, $c9, $54, $32, $54, $9b, $53, $02, $53, $68, $52, $ce, $51
01e78     33 51 97 50 
01e7c     FB 4F 5D 4F 
01e80     BF 4E 20 4E 
01e84     81 4D E0 4C | 	byte	$33, $51, $97, $50, $fb, $4f, $5d, $4f, $bf, $4e, $20, $4e, $81, $4d, $e0, $4c
01e88     3F 4C 9D 4B 
01e8c     FB 4A 58 4A 
01e90     B4 49 0F 49 
01e94     69 48 C3 47 | 	byte	$3f, $4c, $9d, $4b, $fb, $4a, $58, $4a, $b4, $49, $0f, $49, $69, $48, $c3, $47
01e98     1C 47 75 46 
01e9c     CD 45 24 45 
01ea0     7A 44 D0 43 
01ea4     25 43 7A 42 | 	byte	$1c, $47, $75, $46, $cd, $45, $24, $45, $7a, $44, $d0, $43, $25, $43, $7a, $42
01ea8     CE 41 21 41 
01eac     73 40 C5 3F 
01eb0     17 3F 68 3E 
01eb4     B8 3D 07 3D | 	byte	$ce, $41, $21, $41, $73, $40, $c5, $3f, $17, $3f, $68, $3e, $b8, $3d, $07, $3d
01eb8     56 3C A5 3B 
01ebc     F2 3A 40 3A 
01ec0     8C 39 D9 38 
01ec4     24 38 6F 37 | 	byte	$56, $3c, $a5, $3b, $f2, $3a, $40, $3a, $8c, $39, $d9, $38, $24, $38, $6f, $37
01ec8     BA 36 04 36 
01ecc     4D 35 96 34 
01ed0     DF 33 26 33 
01ed4     6E 32 B5 31 | 	byte	$ba, $36, $04, $36, $4d, $35, $96, $34, $df, $33, $26, $33, $6e, $32, $b5, $31
01ed8     FB 30 41 30 
01edc     87 2F CC 2E 
01ee0     11 2E 55 2D 
01ee4     99 2C DC 2B | 	byte	$fb, $30, $41, $30, $87, $2f, $cc, $2e, $11, $2e, $55, $2d, $99, $2c, $dc, $2b
01ee8     1F 2B 61 2A 
01eec     A3 29 E5 28 
01ef0     26 28 67 27 
01ef4     A8 26 E8 25 | 	byte	$1f, $2b, $61, $2a, $a3, $29, $e5, $28, $26, $28, $67, $27, $a8, $26, $e8, $25
01ef8     28 25 67 24 
01efc     A6 23 E5 22 
01f00     23 22 61 21 
01f04     9F 20 DD 1F | 	byte	$28, $25, $67, $24, $a6, $23, $e5, $22, $23, $22, $61, $21, $9f, $20, $dd, $1f
01f08     1A 1F 57 1E 
01f0c     93 1D CF 1C 
01f10     0B 1C 47 1B 
01f14     82 1A BE 19 | 	byte	$1a, $1f, $57, $1e, $93, $1d, $cf, $1c, $0b, $1c, $47, $1b, $82, $1a, $be, $19
01f18     F9 18 33 18 
01f1c     6E 17 A8 16 
01f20     E2 15 1C 15 
01f24     55 14 8F 13 | 	byte	$f9, $18, $33, $18, $6e, $17, $a8, $16, $e2, $15, $1c, $15, $55, $14, $8f, $13
01f28     C8 12 01 12 
01f2c     3A 11 72 10 
01f30     AB 0F E3 0E 
01f34     1C 0E 54 0D | 	byte	$c8, $12, $01, $12, $3a, $11, $72, $10, $ab, $0f, $e3, $0e, $1c, $0e, $54, $0d
01f38     8C 0C C4 0B 
01f3c     FB 0A 33 0A 
01f40     6A 09 A2 08 
01f44     D9 07 11 07 | 	byte	$8c, $0c, $c4, $0b, $fb, $0a, $33, $0a, $6a, $09, $a2, $08, $d9, $07, $11, $07
01f48     48 06 7F 05 
01f4c     B6 04 ED 03 
01f50     24 03 5B 02 
01f54     92 01 C9 00 | 	byte	$48, $06, $7f, $05, $b6, $04, $ed, $03, $24, $03, $5b, $02, $92, $01, $c9, $00
01f58     00 00 37 FF 
01f5c     6E FE A5 FD 
01f60     DC FC 13 FC 
01f64     4A FB 81 FA | 	byte	$00, $00, $37, $ff, $6e, $fe, $a5, $fd, $dc, $fc, $13, $fc, $4a, $fb, $81, $fa
01f68     B8 F9 EF F8 
01f6c     27 F8 5E F7 
01f70     96 F6 CD F5 
01f74     05 F5 3C F4 | 	byte	$b8, $f9, $ef, $f8, $27, $f8, $5e, $f7, $96, $f6, $cd, $f5, $05, $f5, $3c, $f4
01f78     74 F3 AC F2 
01f7c     E4 F1 1D F1 
01f80     55 F0 8E EF 
01f84     C6 EE FF ED | 	byte	$74, $f3, $ac, $f2, $e4, $f1, $1d, $f1, $55, $f0, $8e, $ef, $c6, $ee, $ff, $ed
01f88     38 ED 71 EC 
01f8c     AB EB E4 EA 
01f90     1E EA 58 E9 
01f94     92 E8 CD E7 | 	byte	$38, $ed, $71, $ec, $ab, $eb, $e4, $ea, $1e, $ea, $58, $e9, $92, $e8, $cd, $e7
01f98     07 E7 42 E6 
01f9c     7E E5 B9 E4 
01fa0     F5 E3 31 E3 
01fa4     6D E2 A9 E1 | 	byte	$07, $e7, $42, $e6, $7e, $e5, $b9, $e4, $f5, $e3, $31, $e3, $6d, $e2, $a9, $e1
01fa8     E6 E0 23 E0 
01fac     61 DF 9F DE 
01fb0     DD DD 1B DD 
01fb4     5A DC 99 DB | 	byte	$e6, $e0, $23, $e0, $61, $df, $9f, $de, $dd, $dd, $1b, $dd, $5a, $dc, $99, $db
01fb8     D8 DA 18 DA 
01fbc     58 D9 99 D8 
01fc0     DA D7 1B D7 
01fc4     5D D6 9F D5 | 	byte	$d8, $da, $18, $da, $58, $d9, $99, $d8, $da, $d7, $1b, $d7, $5d, $d6, $9f, $d5
01fc8     E1 D4 24 D4 
01fcc     67 D3 AB D2 
01fd0     EF D1 34 D1 
01fd4     79 D0 BF CF | 	byte	$e1, $d4, $24, $d4, $67, $d3, $ab, $d2, $ef, $d1, $34, $d1, $79, $d0, $bf, $cf
01fd8     05 CF 4B CE 
01fdc     92 CD DA CC 
01fe0     21 CC 6A CB 
01fe4     B3 CA FC C9 | 	byte	$05, $cf, $4b, $ce, $92, $cd, $da, $cc, $21, $cc, $6a, $cb, $b3, $ca, $fc, $c9
01fe8     46 C9 91 C8 
01fec     DC C7 27 C7 
01ff0     74 C6 C0 C5 
01ff4     0E C5 5B C4 | 	byte	$46, $c9, $91, $c8, $dc, $c7, $27, $c7, $74, $c6, $c0, $c5, $0e, $c5, $5b, $c4
01ff8     AA C3 F9 C2 
01ffc     48 C2 98 C1 
02000     E9 C0 3B C0 
02004     8D BF DF BE | 	byte	$aa, $c3, $f9, $c2, $48, $c2, $98, $c1, $e9, $c0, $3b, $c0, $8d, $bf, $df, $be
02008     32 BE 86 BD 
0200c     DB BC 30 BC 
02010     86 BB DC BA 
02014     33 BA 8B B9 | 	byte	$32, $be, $86, $bd, $db, $bc, $30, $bc, $86, $bb, $dc, $ba, $33, $ba, $8b, $b9
02018     E4 B8 3D B8 
0201c     97 B7 F1 B6 
02020     4C B6 A8 B5 
02024     05 B5 63 B4 | 	byte	$e4, $b8, $3d, $b8, $97, $b7, $f1, $b6, $4c, $b6, $a8, $b5, $05, $b5, $63, $b4
02028     C1 B3 20 B3 
0202c     7F B2 E0 B1 
02030     41 B1 A3 B0 
02034     05 B0 69 AF | 	byte	$c1, $b3, $20, $b3, $7f, $b2, $e0, $b1, $41, $b1, $a3, $b0, $05, $b0, $69, $af
02038     CD AE 32 AE 
0203c     98 AD FE AC 
02040     65 AC CE AB 
02044     37 AB A0 AA | 	byte	$cd, $ae, $32, $ae, $98, $ad, $fe, $ac, $65, $ac, $ce, $ab, $37, $ab, $a0, $aa
02048     0B AA 76 A9 
0204c     E3 A8 50 A8 
02050     BE A7 2D A7 
02054     9C A6 0D A6 | 	byte	$0b, $aa, $76, $a9, $e3, $a8, $50, $a8, $be, $a7, $2d, $a7, $9c, $a6, $0d, $a6
02058     7E A5 F1 A4 
0205c     64 A4 D8 A3 
02060     4D A3 C2 A2 
02064     39 A2 B1 A1 | 	byte	$7e, $a5, $f1, $a4, $64, $a4, $d8, $a3, $4d, $a3, $c2, $a2, $39, $a2, $b1, $a1
02068     29 A1 A3 A0 
0206c     1D A0 98 9F 
02070     15 9F 92 9E 
02074     10 9E 8F 9D | 	byte	$29, $a1, $a3, $a0, $1d, $a0, $98, $9f, $15, $9f, $92, $9e, $10, $9e, $8f, $9d
02078     0F 9D 90 9C 
0207c     12 9C 94 9B 
02080     18 9B 9D 9A 
02084     23 9A AA 99 | 	byte	$0f, $9d, $90, $9c, $12, $9c, $94, $9b, $18, $9b, $9d, $9a, $23, $9a, $aa, $99
02088     31 99 BA 98 
0208c     44 98 CE 97 
02090     5A 97 E7 96 
02094     75 96 03 96 | 	byte	$31, $99, $ba, $98, $44, $98, $ce, $97, $5a, $97, $e7, $96, $75, $96, $03, $96
02098     93 95 24 95 
0209c     B6 94 49 94 
020a0     DD 93 72 93 
020a4     08 93 9F 92 | 	byte	$93, $95, $24, $95, $b6, $94, $49, $94, $dd, $93, $72, $93, $08, $93, $9f, $92
020a8     37 92 D0 91 
020ac     6A 91 05 91 
020b0     A2 90 3F 90 
020b4     DE 8F 7D 8F | 	byte	$37, $92, $d0, $91, $6a, $91, $05, $91, $a2, $90, $3f, $90, $de, $8f, $7d, $8f
020b8     1E 8F C0 8E 
020bc     63 8E 07 8E 
020c0     AC 8D 52 8D 
020c4     F9 8C A2 8C | 	byte	$1e, $8f, $c0, $8e, $63, $8e, $07, $8e, $ac, $8d, $52, $8d, $f9, $8c, $a2, $8c
020c8     4B 8C F6 8B 
020cc     A1 8B 4E 8B 
020d0     FC 8A AB 8A 
020d4     5B 8A 0D 8A | 	byte	$4b, $8c, $f6, $8b, $a1, $8b, $4e, $8b, $fc, $8a, $ab, $8a, $5b, $8a, $0d, $8a
020d8     BF 89 73 89 
020dc     28 89 DE 88 
020e0     95 88 4D 88 
020e4     06 88 C1 87 | 	byte	$bf, $89, $73, $89, $28, $89, $de, $88, $95, $88, $4d, $88, $06, $88, $c1, $87
020e8     7C 87 39 87 
020ec     F7 86 B6 86 
020f0     77 86 38 86 
020f4     FB 85 BF 85 | 	byte	$7c, $87, $39, $87, $f7, $86, $b6, $86, $77, $86, $38, $86, $fb, $85, $bf, $85
020f8     84 85 4A 85 
020fc     12 85 DA 84 
02100     A4 84 6F 84 
02104     3B 84 08 84 | 	byte	$84, $85, $4a, $85, $12, $85, $da, $84, $a4, $84, $6f, $84, $3b, $84, $08, $84
02108     D7 83 A7 83 
0210c     78 83 4A 83 
02110     1D 83 F2 82 
02114     C7 82 9E 82 | 	byte	$d7, $83, $a7, $83, $78, $83, $4a, $83, $1d, $83, $f2, $82, $c7, $82, $9e, $82
02118     77 82 50 82 
0211c     2B 82 06 82 
02120     E3 81 C2 81 
02124     A1 81 82 81 | 	byte	$77, $82, $50, $82, $2b, $82, $06, $82, $e3, $81, $c2, $81, $a1, $81, $82, $81
02128     64 81 47 81 
0212c     2B 81 11 81 
02130     F7 80 DF 80 
02134     C9 80 B3 80 | 	byte	$64, $81, $47, $81, $2b, $81, $11, $81, $f7, $80, $df, $80, $c9, $80, $b3, $80
02138     9F 80 8C 80 
0213c     7A 80 69 80 
02140     5A 80 4C 80 
02144     3F 80 33 80 | 	byte	$9f, $80, $8c, $80, $7a, $80, $69, $80, $5a, $80, $4c, $80, $3f, $80, $33, $80
02148     28 80 1F 80 
0214c     17 80 10 80 
02150     0B 80 07 80 
02154     03 80 02 80 | 	byte	$28, $80, $1f, $80, $17, $80, $10, $80, $0b, $80, $07, $80, $03, $80, $02, $80
02158     01 80 02 80 
0215c     03 80 07 80 
02160     0B 80 10 80 
02164     17 80 1F 80 | 	byte	$01, $80, $02, $80, $03, $80, $07, $80, $0b, $80, $10, $80, $17, $80, $1f, $80
02168     28 80 33 80 
0216c     3F 80 4C 80 
02170     5A 80 69 80 
02174     7A 80 8C 80 | 	byte	$28, $80, $33, $80, $3f, $80, $4c, $80, $5a, $80, $69, $80, $7a, $80, $8c, $80
02178     9F 80 B3 80 
0217c     C9 80 DF 80 
02180     F7 80 11 81 
02184     2B 81 47 81 | 	byte	$9f, $80, $b3, $80, $c9, $80, $df, $80, $f7, $80, $11, $81, $2b, $81, $47, $81
02188     64 81 82 81 
0218c     A1 81 C2 81 
02190     E3 81 06 82 
02194     2B 82 50 82 | 	byte	$64, $81, $82, $81, $a1, $81, $c2, $81, $e3, $81, $06, $82, $2b, $82, $50, $82
02198     77 82 9E 82 
0219c     C7 82 F2 82 
021a0     1D 83 4A 83 
021a4     78 83 A7 83 | 	byte	$77, $82, $9e, $82, $c7, $82, $f2, $82, $1d, $83, $4a, $83, $78, $83, $a7, $83
021a8     D7 83 08 84 
021ac     3B 84 6F 84 
021b0     A4 84 DA 84 
021b4     12 85 4A 85 | 	byte	$d7, $83, $08, $84, $3b, $84, $6f, $84, $a4, $84, $da, $84, $12, $85, $4a, $85
021b8     84 85 BF 85 
021bc     FB 85 38 86 
021c0     77 86 B6 86 
021c4     F7 86 39 87 | 	byte	$84, $85, $bf, $85, $fb, $85, $38, $86, $77, $86, $b6, $86, $f7, $86, $39, $87
021c8     7C 87 C1 87 
021cc     06 88 4D 88 
021d0     95 88 DE 88 
021d4     28 89 73 89 | 	byte	$7c, $87, $c1, $87, $06, $88, $4d, $88, $95, $88, $de, $88, $28, $89, $73, $89
021d8     BF 89 0D 8A 
021dc     5B 8A AB 8A 
021e0     FC 8A 4E 8B 
021e4     A1 8B F6 8B | 	byte	$bf, $89, $0d, $8a, $5b, $8a, $ab, $8a, $fc, $8a, $4e, $8b, $a1, $8b, $f6, $8b
021e8     4B 8C A2 8C 
021ec     F9 8C 52 8D 
021f0     AC 8D 07 8E 
021f4     63 8E C0 8E | 	byte	$4b, $8c, $a2, $8c, $f9, $8c, $52, $8d, $ac, $8d, $07, $8e, $63, $8e, $c0, $8e
021f8     1E 8F 7D 8F 
021fc     DE 8F 3F 90 
02200     A2 90 05 91 
02204     6A 91 D0 91 | 	byte	$1e, $8f, $7d, $8f, $de, $8f, $3f, $90, $a2, $90, $05, $91, $6a, $91, $d0, $91
02208     37 92 9F 92 
0220c     08 93 72 93 
02210     DD 93 49 94 
02214     B6 94 24 95 | 	byte	$37, $92, $9f, $92, $08, $93, $72, $93, $dd, $93, $49, $94, $b6, $94, $24, $95
02218     93 95 03 96 
0221c     75 96 E7 96 
02220     5A 97 CE 97 
02224     44 98 BA 98 | 	byte	$93, $95, $03, $96, $75, $96, $e7, $96, $5a, $97, $ce, $97, $44, $98, $ba, $98
02228     31 99 AA 99 
0222c     23 9A 9D 9A 
02230     18 9B 94 9B 
02234     12 9C 90 9C | 	byte	$31, $99, $aa, $99, $23, $9a, $9d, $9a, $18, $9b, $94, $9b, $12, $9c, $90, $9c
02238     0F 9D 8F 9D 
0223c     10 9E 92 9E 
02240     15 9F 98 9F 
02244     1D A0 A3 A0 | 	byte	$0f, $9d, $8f, $9d, $10, $9e, $92, $9e, $15, $9f, $98, $9f, $1d, $a0, $a3, $a0
02248     29 A1 B1 A1 
0224c     39 A2 C2 A2 
02250     4D A3 D8 A3 
02254     64 A4 F1 A4 | 	byte	$29, $a1, $b1, $a1, $39, $a2, $c2, $a2, $4d, $a3, $d8, $a3, $64, $a4, $f1, $a4
02258     7E A5 0D A6 
0225c     9C A6 2D A7 
02260     BE A7 50 A8 
02264     E3 A8 76 A9 | 	byte	$7e, $a5, $0d, $a6, $9c, $a6, $2d, $a7, $be, $a7, $50, $a8, $e3, $a8, $76, $a9
02268     0B AA A0 AA 
0226c     37 AB CE AB 
02270     65 AC FE AC 
02274     98 AD 32 AE | 	byte	$0b, $aa, $a0, $aa, $37, $ab, $ce, $ab, $65, $ac, $fe, $ac, $98, $ad, $32, $ae
02278     CD AE 69 AF 
0227c     05 B0 A3 B0 
02280     41 B1 E0 B1 
02284     7F B2 20 B3 | 	byte	$cd, $ae, $69, $af, $05, $b0, $a3, $b0, $41, $b1, $e0, $b1, $7f, $b2, $20, $b3
02288     C1 B3 63 B4 
0228c     05 B5 A8 B5 
02290     4C B6 F1 B6 
02294     97 B7 3D B8 | 	byte	$c1, $b3, $63, $b4, $05, $b5, $a8, $b5, $4c, $b6, $f1, $b6, $97, $b7, $3d, $b8
02298     E4 B8 8B B9 
0229c     33 BA DC BA 
022a0     86 BB 30 BC 
022a4     DB BC 86 BD | 	byte	$e4, $b8, $8b, $b9, $33, $ba, $dc, $ba, $86, $bb, $30, $bc, $db, $bc, $86, $bd
022a8     32 BE DF BE 
022ac     8D BF 3B C0 
022b0     E9 C0 98 C1 
022b4     48 C2 F9 C2 | 	byte	$32, $be, $df, $be, $8d, $bf, $3b, $c0, $e9, $c0, $98, $c1, $48, $c2, $f9, $c2
022b8     AA C3 5B C4 
022bc     0E C5 C0 C5 
022c0     74 C6 27 C7 
022c4     DC C7 91 C8 | 	byte	$aa, $c3, $5b, $c4, $0e, $c5, $c0, $c5, $74, $c6, $27, $c7, $dc, $c7, $91, $c8
022c8     46 C9 FC C9 
022cc     B3 CA 6A CB 
022d0     21 CC DA CC 
022d4     92 CD 4B CE | 	byte	$46, $c9, $fc, $c9, $b3, $ca, $6a, $cb, $21, $cc, $da, $cc, $92, $cd, $4b, $ce
022d8     05 CF BF CF 
022dc     79 D0 34 D1 
022e0     EF D1 AB D2 
022e4     67 D3 24 D4 | 	byte	$05, $cf, $bf, $cf, $79, $d0, $34, $d1, $ef, $d1, $ab, $d2, $67, $d3, $24, $d4
022e8     E1 D4 9F D5 
022ec     5D D6 1B D7 
022f0     DA D7 99 D8 
022f4     58 D9 18 DA | 	byte	$e1, $d4, $9f, $d5, $5d, $d6, $1b, $d7, $da, $d7, $99, $d8, $58, $d9, $18, $da
022f8     D8 DA 99 DB 
022fc     5A DC 1B DD 
02300     DD DD 9F DE 
02304     61 DF 23 E0 | 	byte	$d8, $da, $99, $db, $5a, $dc, $1b, $dd, $dd, $dd, $9f, $de, $61, $df, $23, $e0
02308     E6 E0 A9 E1 
0230c     6D E2 31 E3 
02310     F5 E3 B9 E4 
02314     7E E5 42 E6 | 	byte	$e6, $e0, $a9, $e1, $6d, $e2, $31, $e3, $f5, $e3, $b9, $e4, $7e, $e5, $42, $e6
02318     07 E7 CD E7 
0231c     92 E8 58 E9 
02320     1E EA E4 EA 
02324     AB EB 71 EC | 	byte	$07, $e7, $cd, $e7, $92, $e8, $58, $e9, $1e, $ea, $e4, $ea, $ab, $eb, $71, $ec
02328     38 ED FF ED 
0232c     C6 EE 8E EF 
02330     55 F0 1D F1 
02334     E4 F1 AC F2 | 	byte	$38, $ed, $ff, $ed, $c6, $ee, $8e, $ef, $55, $f0, $1d, $f1, $e4, $f1, $ac, $f2
02338     74 F3 3C F4 
0233c     05 F5 CD F5 
02340     96 F6 5E F7 
02344     27 F8 EF F8 | 	byte	$74, $f3, $3c, $f4, $05, $f5, $cd, $f5, $96, $f6, $5e, $f7, $27, $f8, $ef, $f8
02348     B8 F9 81 FA 
0234c     4A FB 13 FC 
02350     DC FC A5 FD 
02354     6E FE 37 FF | 	byte	$b8, $f9, $81, $fa, $4a, $fb, $13, $fc, $dc, $fc, $a5, $fd, $6e, $fe, $37, $ff
02358                 | 	alignl
02358                 | _sa001_spin2_dat_
02358                 | 
02358                 | audio       org     0
02358                 | 
02358     61 3B 05 FB |             rdlong  mailbox2, ptra++     ' get start address of all mailboxes
0235c     61 89 05 FB |             rdlong  scbase, ptra++       ' get start address of scope buffer
02360     61 95 05 FB |             rdlong  hubptr, ptra++       ' get start address of PSRAM cache
02364                 |  
02364     01 EC 63 FD |             cogid   pa                   ' compute cogid
02368     0C EC 07 FA |             mul     pa, #12              ' and mailbox spacing
0236c     F6 3B 01 F1 |             add     mailbox2, pa         ' add offset to find this COG's mailbox
02370     9D 38 01 F6 |             mov     mailbox,mailbox2     ' we need 2 copies of this to ensble switching between hub and psram
02374                 | 
02374     00 F2 07 F6 |             mov     ptrb,#0              ' A tail pointer for the buffer
02378     0E 92 05 FC |             wrpin   dac2,#left           ' PWM DAC at 264600=6*44100
0237c     A0 25 A6 FF 
02380     0E 00 1C FC |             wxpin   ##5000000*256,#left        ' Set initial DACs sample rate. It is now controlled via a register by the main program
02384     0F 92 05 FC |             wrpin   dac2,#right
02388     A0 25 A6 FF 
0238c     0F 00 1C FC |             wxpin   ##5000000*256,#right    
02390     41 9C 64 FD |             dirh    #left addpins 1
02394     20 9C 64 FD |             setse1  #%001<<6 + left      ' Set the event - DAC empty
02398     00 6E 05 F6 |             mov     cn,#0
0239c                 |             
0239c                 | '---------------------------------------------------------------------------------        
0239c                 | '----------------- The main loop -------------------------------------------------
0239c                 | '---------------------------------------------------------------------------------
0239c                 | 
0239c     07 6E 1D F7 | loop       incmod cn,#7 wcz
023a0                 | 
023a0                 | 
023a0     66 03 81 AF 
023a4     1F 00 65 AD | 	   if_z   waitx ##34000000 ' waitse1
023a8     0E 74 25 AC | 	   if_z wypin oldls,#left
023ac     0F 76 25 AC |            if_z wypin oldrs,#right
023b0                 |            
023b0                 | '----------------------------------------------------------------------------------
023b0                 | '------------- Compute channel samples --------------------------------------------
023b0                 | '----------------------------------------------------------------------------------
023b0                 | 
023b0                 | 
023b0     B7 2E 01 F6 | p401        mov     channeladd,cn             	' compute the pointer to channel parameters block
023b4     06 2E 65 F0 |             shl     channeladd,#6
023b8     97 F0 03 F1 |             add     ptra,channeladd
023bc                 | 
023bc     28 16 64 FD |             setq    #11                        	' read parameters
023c0     00 45 05 FB |             rdlong  pointer0,ptra
023c4                 |     	    
023c4                 | p408        
023c4                 |             
023c4     1E 52 1D F4 | p404        bitl    command0,#30 wcz          	' bit #30: select PSRAM/HUB
023c8     9D 38 01 56 |     if_nz   mov     mailbox,mailbox2            ' if not set, use PSRAM
023cc     00 38 05 A6 |     if_z    mov     mailbox,#0                  ' if set, use HUB 
023d0                 | 
023d0     A3 74 31 F9 | p405        getword oldls,sample0,#0          ' extract old sample value
023d4     A3 76 39 F9 |             getword oldrs,sample0,#1
023d8     A7 6A 39 F9 |      	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
023dc     A7 68 31 F9 |     	    getword avol0,volpan0,#0
023e0                 | 
023e0                 |             
023e0                 | '---- envelopes
023e0                 |             
023e0     00 56 1D F2 |             cmp     envptr0,#0 wcz    		' read the pointer
023e4     20 00 00 AF 
023e8     00 B6 05 A6 |     if_z    mov     envs1,##$4000		' if 0, no envelope, load $4000=1 for scas
023ec     54 00 90 AD |     if_z    jmp     #p410			' and run away	
023f0                 | 
023f0     AC 54 01 F1 |             add     envph0,envspd0 
023f4     AA B2 01 F6 |       	    mov     envhi, envph0		' move phase acc to high part of env pointer
023f8     06 B2 45 F0 | 	    shr     envhi,#6			' leave 10 bits in hi
023fc     D9 B4 31 F9 | 	    getword envlo,envhi,#0              ' and 16 bit in lo
02400     10 B2 45 F0 | 	    shr     envhi,#16			' move 10 bits of hi to the lower word
02404     AD B2 19 F2 | 	    cmp     envhi,envlen0 wcz		' compare this to envelope length
02408     AD B2 01 36 |     if_ge   mov     envhi,envlen0		' if greater than, set it at envlen
0240c     00 B4 05 36 |     if_ge   mov     envlo,#0
02410     AD 54 01 36 |     if_ge   mov     envph0,envlen0
02414     16 54 65 30 |     if_ge   shl     envph0,#22
02418                 | 
02418     D9 B6 01 F6 |             mov     envs1,envhi			' get the phase acc
0241c     01 B6 65 F0 |             shl     envs1,#1			' env defs are words, so phase acc*=2
02420     AB B6 01 F1 |             add     envs1,envptr0		' and add the pointer
02424     DB B6 01 FB |             rdlong  envs1,envs1			' then read 2 entries
02428     DB B8 39 F9 |             getword envs2,envs1,#1		' next value
0242c     DB B6 31 F9 |             getword envs1,envs1,#0		' current value
02430     DA B8 01 FA |             mul     envs2,envlo			' linear interpolate : new val x envlo
02434     DA B4 21 F6 |             not     envlo			' sum of envlo and not envlo is always $FFFF
02438     DA B6 01 FA |             mul     envs1,envlo
0243c     DC B6 01 F1 |             add     envs1,envs2
02440     12 B6 45 F0 |             shr     envs1,#18			' normalize it to $4000
02444                 |             
02444     1B 48 0D F4 | p410        testb   sstart0, #27 wz
02448     1B 34 61 AD |     if_z    getrnd  spl
0244c     AC 00 90 AD |     if_z    jmp     #p406
02450                 |  
02450                 |  
02450                 |  
02450     A8 44 01 F1 |             add     pointer0,freq0          	' compute the pointer to the next sample       
02454     02 6E 0D F2 |          	   cmp cn,#2 wz
02458     30 44 65 AC |          if_z	   wrlong pointer0, #$30
0245c                 |          	   
0245c     1F 48 0D F4 |             testb   sstart0,#31 wz            
02460     01 44 65 A0 |     if_z    shl     pointer0,#1        
02464     1C 48 0D F4 |             testb   sstart0,#28 wz            
02468     01 44 65 A0 |     if_z    shl     pointer0,#1        
0246c                 |         
0246c     A6 44 19 F2 |             cmp     pointer0,lend0 wcz
02470     A6 44 81 31 |     if_ge   sub     pointer0,lend0	      	' and loop if needed     
02474     A5 44 01 31 |     if_ge   add     pointer0,lstart0       
02478                 |             
02478     A2 32 01 F6 |             mov     qq,pointer0               	' compute place in the memory from where the sample will be loaded
0247c     0C 32 45 F0 |             shr     qq,#12  			' 20:12 pointer
02480     A4 32 01 F1 |             add     qq,sstart0            
02484                 | 
02484     4C 00 90 FD |   jmp #p701
02488                 | 
02488                 | 
02488     99 AC E1 F8 | cache_read  getbyte addrlo,qq,#0 		' when this is called, qq is the addres of the sample			
0248c                 |             
0248c     99 AE 01 F6 | 	    mov     addrhi,qq		
02490     08 AE 45 F0 | 	    shr     addrhi,#8		        ' get 24 upper bits
02494     CB 6E 95 F9 | 	    alts    cn,#cache1            
02498     00 AE 09 F2 | 	    cmp	    addrhi,0-0 wz               ' and compare with the cache pointer for the channel
0249c     34 00 90 AD |     if_z    jmp     #p701	    		' if equal, cache hit, read the sample from it
024a0                 | 	
024a0     CB 6E 8D F9 | p702	    altd    cn,#cache1			' cache miss. 
024a4     D7 00 00 F6 | 	    mov     0-0,addrhi                  ' update the pointer
024a8     D7 A6 01 F6 | 	    mov     cmd,addrhi			' prepare the mailbox
024ac     08 A6 65 F0 | 	    shl     cmd,#8
024b0     0B A6 3D F8 |             setnib  cmd, #%1011, #7             ' read burst from the external memory
024b4     B7 A8 01 F6 |             mov     hubaddr,cn                  ' to the channel cache
024b8     08 A8 65 F0 |             shl     hubaddr,#8                  '
024bc     CA A8 01 F1 |             add     hubaddr,hubptr 
024c0     00 AB 05 F6 |             mov     count,#256                  ' 256 bytes
024c4     28 04 64 FD |             setq    #2                          ' write 3 longs
024c8     9C A6 61 FC |             wrlong  cmd, mailbox                ' run it
024cc     9C A6 01 FB | poll1       rdlong  cmd, mailbox                ' poll mailbox for result
024d0     FE A7 B5 FB |             tjs     cmd, #poll1                 ' retry until valid 
024d4                 |             
024d4                 | 	
024d4     B7 32 01 F6 | p701	    mov     qq,cn			' cache hit
024d8     08 32 65 F0 | 	    shl     qq,#8			' compute the cache start
024dc     CA 32 01 F1 | 	    add     qq,hubptr
024e0     D6 32 01 F1 | 	    add	    qq,addrlo			' add 8 lower bits to the cache addredd
024e4     99 34 E1 FA |             rdword  spl,qq                      ' read a word
024e8                 |          
024e8     1F 48 0D F4 |             testb   sstart0,#31 wz 
024ec     08 34 65 50 |     if_nz   shl     spl,#8
024f0                 | 
024f0     01 44 45 A0 |     if_z    shr     pointer0,#1
024f4     1C 48 0D F4 |             testb   sstart0,#28 wz            
024f8     01 44 45 A0 |     if_z    shr     pointer0,#1    
024fc                 | 	   
024fc                 | 
024fc                 | 
024fc     DB 34 31 FA | p406        scas    spl,envs1			' apply envelope
02500     00 34 01 F6 |             mov     spl,0-0
02504     B4 34 31 FA |             scas    spl,avol0                 	' apply volume
02508     00 34 01 F6 |             mov     spl,0-0
0250c                 | 
0250c     B5 34 31 FA |             scas    spl,apan0                 	' apply pan
02510     00 78 01 F6 |             mov     ls0,0-0
02514     20 00 00 FF 
02518     00 32 05 F6 |             mov     qq,##16384
0251c     B5 32 81 F1 |             sub     qq,apan0
02520     99 34 31 FA |             scas    spl,qq
02524     00 7A 01 F6 |             mov     rs0, 0-0
02528                 | 
02528     BB 7E 81 F1 |             sub     rs,oldrs 		      	' replace the old sample with the new one in the mix
0252c     BD 7E 01 F1 |             add     rs,rs0
02530     BA 7C 81 F1 |             sub     ls,oldls
02534     BC 7C 01 F1 |             add     ls,ls0
02538                 |    
02538     BD 46 29 F9 |             setword sample0,rs0,#1           	' pack samples into long
0253c     BC 46 21 F9 |             setword sample0,ls0,#0
02540                 |             
02540     1E 48 1D F4 |             bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
02544     00 44 05 A6 |     if_z    mov     pointer0, #0  		
02548     00 54 05 A6 |     if_z    mov     envph0, #0  		' reset also envelope pha and sample value
0254c                 |   '  if_z    mov     sample0,#0
0254c     02 49 65 AC |     if_z    wrlong  sstart0, ptra[2]          	' reset bit #30 in hub
02550     1D 48 1D F4 |             bitl    sstart0, #29 wcz	      	' if bit #29 is set, synchronize stereo at channels 1 and 2
02554     04 00 00 AF 
02558     00 1E 05 A1 |     if_z    add     time1,##2048
0255c     8F 20 01 A6 |     if_z    mov     time2,time1
02560     02 49 65 AC |     if_z    wrlong  sstart0,ptra[2]
02564                 | 
02564     28 02 64 FD | p403        setq    #1                         	' write new pointer and sample value to the hub
02568     00 45 65 FC |             wrlong  pointer0,ptra
0256c     08 55 65 FC |             wrlong  envph0,ptra[8]
02570     97 F0 83 F1 |             sub     ptra, channeladd         	' reset the pointer to channel parameters
02574                 |                       
02574     BE 74 31 F9 |             getword oldls,ls,#0              ' reuse oldls variable to convert the sample to unsigned
02578     BF 76 31 F9 |  	    getword oldrs,rs,#0              ' getword instead of mov makes the upper bits=0
0257c     0F 74 E5 F4 |             bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
02580     0F 76 E5 F4 |             bitnot  oldrs,#15		     ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
02584                 | 		
02584                 | '	    cmp     scbase,#0 wz
02584                 | '    if_z    jmp     #p302	   
02584                 | '  
02584                 | '            incmod  scope,#63 wc            ' save every 127th sample to the scope buffer
02584                 | '    if_c    mov     scptr2,scptr
02584                 | '    if_c    shl     scptr2,#2
02584                 | '    if_c    add     scptr2,scbase     
02584                 | '            wrlong  scptr2,#$60
02584                 | '    if_c    wrlong  oldsample,scptr2
02584                 | '    if_c    incmod  scptr,##639
02584                 | 
02584     14 FE 9F FD | p302        jmp     #loop            'loop
02588                 | 
02588                 | '----------------------------------------------------------------------------------
02588                 | '------------- This is the end of the main loop -----------------------------------
02588                 | '----------------------------------------------------------------------------------
02588                 | 
02588                 | '----------------------------------------------------------------------------------
02588                 | '------------- PSRAM cache ----------- --------------------------------------------
02588                 | '----------------------------------------------------------------------------------
02588                 | 
02588                 | ' There are 8 cache pointers for 8 channels
02588                 | ' if 24 higher bits of address=cache, then get a word from the cache
02588                 | ' else load the cache from PSRAM, update the pointer, then read a sample
02588                 | 
02588                 | 
02588                 | 
02588                 |           
02588                 | 
02588                 | 
02588                 | 
02588                 | '---------------------------------------------------------------------------
02588                 | '------- Variables ---------------------------------------------------------
02588                 | '---------------------------------------------------------------------------
02588                 | 
02588                 | ' constants
02588                 | 
02588     00 00 00 40 | a40000000   long $40000000
0258c     00 00 00 41 | a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before
02590                 | 
02590                 | ' Time variables
02590                 | 
02590     00 00 00 00 | time0       long 0    ' Global sample computing time
02594     01 00 00 00 | time1       long 1    ' Local channels time
02598     02 00 00 00 | time2       long 2
0259c     03 00 00 00 | time3       long 3
025a0     04 00 00 00 | time4       long 4
025a4     05 00 00 00 | time5       long 5
025a8     06 00 00 00 | time6       long 6
025ac     07 00 00 00 | time7       long 7
025b0     08 00 00 00 | time8       long 8
025b4                 | 
025b4     00 00 00 00 | channeladd long 0
025b8                 | 
025b8     00 00 00 00 | front       long 0
025bc                 | 
025bc                 | ' temporary variables 
025bc     00 00 00 00 | qq          long 0
025c0     00 00 00 00 | spl         long 0
025c4     00 00 00 00 | zero        long 0
025c8     00 00 00 00 | mailbox     long 0
025cc     00 00 00 00 | mailbox2 long 0
025d0                 | 
025d0                 | ' Interrupt ISR variables
025d0                 | 
025d0     00 00 00 00 | lsample     long 0
025d4     00 00 00 00 | rsample     long 0
025d8     00 00 00 00 | lsnext      long 0
025dc     00 00 00 00 | rsnext      long 0 
025e0                 | 
025e0                 | ' channel parameter block
025e0                 | 
025e0     00 00 00 00 | pointer0    long 0     
025e4     00 00 00 00 | sample0     long 0
025e8     00 00 00 00 | sstart0     long 0     ' start pointer and type at bit 31
025ec     00 00 00 00 | lstart0     long 0
025f0     00 00 00 00 | lend0       long 0
025f4     00 00 00 00 | volpan0     long 0
025f8     00 00 00 00 | freq0       long 0
025fc     00 00 00 00 | command0    long 0
02600     00 00 00 00 | envph0	    long 0
02604     00 00 00 00 | envptr0	    long 0
02608     00 00 00 00 | envspd0	    long 0
0260c     00 00 00 00 | envlen0	    long 0
02610     00 00 00 00 | res5	    long 0
02614     00 00 00 00 | res6	    long 0
02618     00 00 00 00 | res7	    long 0
0261c     00 00 00 00 | res8	    long 0
02620                 | 
02620     00 00 00 00 | afreq0      long 0
02624     00 00 00 00 | askip0      long 0
02628     00 00 00 00 | avol0       long 0
0262c     00 00 00 00 | apan0       long 0
02630                 | 
02630     FF FF FF FF | oldt0       long $FFFFFFFF    'Temporary time variables
02634     00 00 00 00 | cn          long 0
02638     00 00 00 00 | ct          long 0
0263c     00 00 00 00 | dt0         long 0
02640                 | 
02640                 | ' Samples
02640     00 00 00 00 | oldls       long 0
02644     00 00 00 00 | oldrs       long 0
02648                 | 
02648     00 00 00 00 | ls0         long 0
0264c     00 00 00 00 | rs0         long 0
02650                 | 
02650     00 00 00 00 | ls          long 0    
02654     00 00 00 00 | rs          long 0
02658                 | 
02658     00 00 00 00 | oldsample   long 0
0265c     00 00 00 00 | newsample   long 0
02660                 | 
02660     00 00 00 00 | nrsample    long 0
02664     00 00 00 00 | nlsample    long 0
02668                 | 
02668     00 00 00 00 | scbase long 0
0266c     00 00 00 00 | scptr long 0
02670     00 00 00 00 | scptr2 long 0
02674     00 00 00 00 | scope long 0
02678                 | 
02678     44 00 17 00 | dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
0267c     46 00 17 00 | dac2        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   
02680                 | 
02680     00 18 07 00 | hubptr      long $71800
02684     00 00 00 00 | cache1      long 0
02688     00 00 00 00 | cache2      long 0
0268c     00 00 00 00 | cache3      long 0
02690     00 00 00 00 | cache4      long 0
02694     00 00 00 00 | cache5      long 0
02698     00 00 00 00 | cache6      long 0
0269c     00 00 00 00 | cache7      long 0
026a0     00 00 00 00 | cache8      long 0
026a4                 | 
026a4                 | 
026a4     00 00 00 00 | cmd         long 0
026a8     00 00 00 00 | hubaddr     long 0
026ac     00 01 00 00 | count       long 256
026b0     00 00 00 00 | addrlo long 0
026b4     00 00 00 00 | addrhi long 0
026b8     00 00 00 00 | pointer00 long 0
026bc     00 00 00 00 | envhi long 0
026c0     00 00 00 00 | envlo long 0
026c4     00 00 00 00 | envs1 long 0
026c8     00 00 00 00 | envs2 long 0
026cc     00 00 00 00 | noise0 long 0
026d0     92 92 92 92 | dropper long %10010010_10010010_10010010_10010010
026d4     00 00 00 00 
026d8     00 00 00 00 | null  			long 	0,0           ' for channel reset
026dc     73 32 00 04 
026e0     00 00 10 00 
026e4     00 00 00 00 
026e8     00 00 00 00 | sinewave 		file 	"sinus.s2"    ' for testing
026ec     00 00 C9 00 
026f0     92 01 5B 02 
026f4     24 03 ED 03 
026f8     B6 04 7F 05 | 	byte	$00, $00, $c9, $00, $92, $01, $5b, $02, $24, $03, $ed, $03, $b6, $04, $7f, $05
026fc     48 06 11 07 
02700     D9 07 A2 08 
02704     6A 09 33 0A 
02708     FB 0A C4 0B | 	byte	$48, $06, $11, $07, $d9, $07, $a2, $08, $6a, $09, $33, $0a, $fb, $0a, $c4, $0b
0270c     8C 0C 54 0D 
02710     1C 0E E3 0E 
02714     AB 0F 72 10 
02718     3A 11 01 12 | 	byte	$8c, $0c, $54, $0d, $1c, $0e, $e3, $0e, $ab, $0f, $72, $10, $3a, $11, $01, $12
0271c     C8 12 8F 13 
02720     55 14 1C 15 
02724     E2 15 A8 16 
02728     6E 17 33 18 | 	byte	$c8, $12, $8f, $13, $55, $14, $1c, $15, $e2, $15, $a8, $16, $6e, $17, $33, $18
0272c     F9 18 BE 19 
02730     82 1A 47 1B 
02734     0B 1C CF 1C 
02738     93 1D 57 1E | 	byte	$f9, $18, $be, $19, $82, $1a, $47, $1b, $0b, $1c, $cf, $1c, $93, $1d, $57, $1e
0273c     1A 1F DD 1F 
02740     9F 20 61 21 
02744     23 22 E5 22 
02748     A6 23 67 24 | 	byte	$1a, $1f, $dd, $1f, $9f, $20, $61, $21, $23, $22, $e5, $22, $a6, $23, $67, $24
0274c     28 25 E8 25 
02750     A8 26 67 27 
02754     26 28 E5 28 
02758     A3 29 61 2A | 	byte	$28, $25, $e8, $25, $a8, $26, $67, $27, $26, $28, $e5, $28, $a3, $29, $61, $2a
0275c     1F 2B DC 2B 
02760     99 2C 55 2D 
02764     11 2E CC 2E 
02768     87 2F 41 30 | 	byte	$1f, $2b, $dc, $2b, $99, $2c, $55, $2d, $11, $2e, $cc, $2e, $87, $2f, $41, $30
0276c     FB 30 B5 31 
02770     6E 32 26 33 
02774     DF 33 96 34 
02778     4D 35 04 36 | 	byte	$fb, $30, $b5, $31, $6e, $32, $26, $33, $df, $33, $96, $34, $4d, $35, $04, $36
0277c     BA 36 6F 37 
02780     24 38 D9 38 
02784     8C 39 40 3A 
02788     F2 3A A5 3B | 	byte	$ba, $36, $6f, $37, $24, $38, $d9, $38, $8c, $39, $40, $3a, $f2, $3a, $a5, $3b
0278c     56 3C 07 3D 
02790     B8 3D 68 3E 
02794     17 3F C5 3F 
02798     73 40 21 41 | 	byte	$56, $3c, $07, $3d, $b8, $3d, $68, $3e, $17, $3f, $c5, $3f, $73, $40, $21, $41
0279c     CE 41 7A 42 
027a0     25 43 D0 43 
027a4     7A 44 24 45 
027a8     CD 45 75 46 | 	byte	$ce, $41, $7a, $42, $25, $43, $d0, $43, $7a, $44, $24, $45, $cd, $45, $75, $46
027ac     1C 47 C3 47 
027b0     69 48 0F 49 
027b4     B4 49 58 4A 
027b8     FB 4A 9D 4B | 	byte	$1c, $47, $c3, $47, $69, $48, $0f, $49, $b4, $49, $58, $4a, $fb, $4a, $9d, $4b
027bc     3F 4C E0 4C 
027c0     81 4D 20 4E 
027c4     BF 4E 5D 4F 
027c8     FB 4F 97 50 | 	byte	$3f, $4c, $e0, $4c, $81, $4d, $20, $4e, $bf, $4e, $5d, $4f, $fb, $4f, $97, $50
027cc     33 51 CE 51 
027d0     68 52 02 53 
027d4     9B 53 32 54 
027d8     C9 54 60 55 | 	byte	$33, $51, $ce, $51, $68, $52, $02, $53, $9b, $53, $32, $54, $c9, $54, $60, $55
027dc     F5 55 8A 56 
027e0     1D 57 B0 57 
027e4     42 58 D3 58 
027e8     64 59 F3 59 | 	byte	$f5, $55, $8a, $56, $1d, $57, $b0, $57, $42, $58, $d3, $58, $64, $59, $f3, $59
027ec     82 5A 0F 5B 
027f0     9C 5B 28 5C 
027f4     B3 5C 3E 5D 
027f8     C7 5D 4F 5E | 	byte	$82, $5a, $0f, $5b, $9c, $5b, $28, $5c, $b3, $5c, $3e, $5d, $c7, $5d, $4f, $5e
027fc     D7 5E 5D 5F 
02800     E3 5F 68 60 
02804     EB 60 6E 61 
02808     F0 61 71 62 | 	byte	$d7, $5e, $5d, $5f, $e3, $5f, $68, $60, $eb, $60, $6e, $61, $f0, $61, $71, $62
0280c     F1 62 70 63 
02810     EE 63 6C 64 
02814     E8 64 63 65 
02818     DD 65 56 66 | 	byte	$f1, $62, $70, $63, $ee, $63, $6c, $64, $e8, $64, $63, $65, $dd, $65, $56, $66
0281c     CF 66 46 67 
02820     BC 67 32 68 
02824     A6 68 19 69 
02828     8B 69 FD 69 | 	byte	$cf, $66, $46, $67, $bc, $67, $32, $68, $a6, $68, $19, $69, $8b, $69, $fd, $69
0282c     6D 6A DC 6A 
02830     4A 6B B7 6B 
02834     23 6C 8E 6C 
02838     F8 6C 61 6D | 	byte	$6d, $6a, $dc, $6a, $4a, $6b, $b7, $6b, $23, $6c, $8e, $6c, $f8, $6c, $61, $6d
0283c     C9 6D 30 6E 
02840     96 6E FB 6E 
02844     5E 6F C1 6F 
02848     22 70 83 70 | 	byte	$c9, $6d, $30, $6e, $96, $6e, $fb, $6e, $5e, $6f, $c1, $6f, $22, $70, $83, $70
0284c     E2 70 40 71 
02850     9D 71 F9 71 
02854     54 72 AE 72 
02858     07 73 5E 73 | 	byte	$e2, $70, $40, $71, $9d, $71, $f9, $71, $54, $72, $ae, $72, $07, $73, $5e, $73
0285c     B5 73 0A 74 
02860     5F 74 B2 74 
02864     04 75 55 75 
02868     A5 75 F3 75 | 	byte	$b5, $73, $0a, $74, $5f, $74, $b2, $74, $04, $75, $55, $75, $a5, $75, $f3, $75
0286c     41 76 8D 76 
02870     D8 76 22 77 
02874     6B 77 B3 77 
02878     FA 77 3F 78 | 	byte	$41, $76, $8d, $76, $d8, $76, $22, $77, $6b, $77, $b3, $77, $fa, $77, $3f, $78
0287c     84 78 C7 78 
02880     09 79 4A 79 
02884     89 79 C8 79 
02888     05 7A 41 7A | 	byte	$84, $78, $c7, $78, $09, $79, $4a, $79, $89, $79, $c8, $79, $05, $7a, $41, $7a
0288c     7C 7A B6 7A 
02890     EE 7A 26 7B 
02894     5C 7B 91 7B 
02898     C5 7B F8 7B | 	byte	$7c, $7a, $b6, $7a, $ee, $7a, $26, $7b, $5c, $7b, $91, $7b, $c5, $7b, $f8, $7b
0289c     29 7C 59 7C 
028a0     88 7C B6 7C 
028a4     E3 7C 0E 7D 
028a8     39 7D 62 7D | 	byte	$29, $7c, $59, $7c, $88, $7c, $b6, $7c, $e3, $7c, $0e, $7d, $39, $7d, $62, $7d
028ac     89 7D B0 7D 
028b0     D5 7D FA 7D 
028b4     1D 7E 3E 7E 
028b8     5F 7E 7E 7E | 	byte	$89, $7d, $b0, $7d, $d5, $7d, $fa, $7d, $1d, $7e, $3e, $7e, $5f, $7e, $7e, $7e
028bc     9C 7E B9 7E 
028c0     D5 7E EF 7E 
028c4     09 7F 21 7F 
028c8     37 7F 4D 7F | 	byte	$9c, $7e, $b9, $7e, $d5, $7e, $ef, $7e, $09, $7f, $21, $7f, $37, $7f, $4d, $7f
028cc     61 7F 74 7F 
028d0     86 7F 97 7F 
028d4     A6 7F B4 7F 
028d8     C1 7F CD 7F | 	byte	$61, $7f, $74, $7f, $86, $7f, $97, $7f, $a6, $7f, $b4, $7f, $c1, $7f, $cd, $7f
028dc     D8 7F E1 7F 
028e0     E9 7F F0 7F 
028e4     F5 7F F9 7F 
028e8     FD 7F FE 7F | 	byte	$d8, $7f, $e1, $7f, $e9, $7f, $f0, $7f, $f5, $7f, $f9, $7f, $fd, $7f, $fe, $7f
028ec     FF 7F FE 7F 
028f0     FD 7F F9 7F 
028f4     F5 7F F0 7F 
028f8     E9 7F E1 7F | 	byte	$ff, $7f, $fe, $7f, $fd, $7f, $f9, $7f, $f5, $7f, $f0, $7f, $e9, $7f, $e1, $7f
028fc     D8 7F CD 7F 
02900     C1 7F B4 7F 
02904     A6 7F 97 7F 
02908     86 7F 74 7F | 	byte	$d8, $7f, $cd, $7f, $c1, $7f, $b4, $7f, $a6, $7f, $97, $7f, $86, $7f, $74, $7f
0290c     61 7F 4D 7F 
02910     37 7F 21 7F 
02914     09 7F EF 7E 
02918     D5 7E B9 7E | 	byte	$61, $7f, $4d, $7f, $37, $7f, $21, $7f, $09, $7f, $ef, $7e, $d5, $7e, $b9, $7e
0291c     9C 7E 7E 7E 
02920     5F 7E 3E 7E 
02924     1D 7E FA 7D 
02928     D5 7D B0 7D | 	byte	$9c, $7e, $7e, $7e, $5f, $7e, $3e, $7e, $1d, $7e, $fa, $7d, $d5, $7d, $b0, $7d
0292c     89 7D 62 7D 
02930     39 7D 0E 7D 
02934     E3 7C B6 7C 
02938     88 7C 59 7C | 	byte	$89, $7d, $62, $7d, $39, $7d, $0e, $7d, $e3, $7c, $b6, $7c, $88, $7c, $59, $7c
0293c     29 7C F8 7B 
02940     C5 7B 91 7B 
02944     5C 7B 26 7B 
02948     EE 7A B6 7A | 	byte	$29, $7c, $f8, $7b, $c5, $7b, $91, $7b, $5c, $7b, $26, $7b, $ee, $7a, $b6, $7a
0294c     7C 7A 41 7A 
02950     05 7A C8 79 
02954     89 79 4A 79 
02958     09 79 C7 78 | 	byte	$7c, $7a, $41, $7a, $05, $7a, $c8, $79, $89, $79, $4a, $79, $09, $79, $c7, $78
0295c     84 78 3F 78 
02960     FA 77 B3 77 
02964     6B 77 22 77 
02968     D8 76 8D 76 | 	byte	$84, $78, $3f, $78, $fa, $77, $b3, $77, $6b, $77, $22, $77, $d8, $76, $8d, $76
0296c     41 76 F3 75 
02970     A5 75 55 75 
02974     04 75 B2 74 
02978     5F 74 0A 74 | 	byte	$41, $76, $f3, $75, $a5, $75, $55, $75, $04, $75, $b2, $74, $5f, $74, $0a, $74
0297c     B5 73 5E 73 
02980     07 73 AE 72 
02984     54 72 F9 71 
02988     9D 71 40 71 | 	byte	$b5, $73, $5e, $73, $07, $73, $ae, $72, $54, $72, $f9, $71, $9d, $71, $40, $71
0298c     E2 70 83 70 
02990     22 70 C1 6F 
02994     5E 6F FB 6E 
02998     96 6E 30 6E | 	byte	$e2, $70, $83, $70, $22, $70, $c1, $6f, $5e, $6f, $fb, $6e, $96, $6e, $30, $6e
0299c     C9 6D 61 6D 
029a0     F8 6C 8E 6C 
029a4     23 6C B7 6B 
029a8     4A 6B DC 6A | 	byte	$c9, $6d, $61, $6d, $f8, $6c, $8e, $6c, $23, $6c, $b7, $6b, $4a, $6b, $dc, $6a
029ac     6D 6A FD 69 
029b0     8B 69 19 69 
029b4     A6 68 32 68 
029b8     BC 67 46 67 | 	byte	$6d, $6a, $fd, $69, $8b, $69, $19, $69, $a6, $68, $32, $68, $bc, $67, $46, $67
029bc     CF 66 56 66 
029c0     DD 65 63 65 
029c4     E8 64 6C 64 
029c8     EE 63 70 63 | 	byte	$cf, $66, $56, $66, $dd, $65, $63, $65, $e8, $64, $6c, $64, $ee, $63, $70, $63
029cc     F1 62 71 62 
029d0     F0 61 6E 61 
029d4     EB 60 68 60 
029d8     E3 5F 5D 5F | 	byte	$f1, $62, $71, $62, $f0, $61, $6e, $61, $eb, $60, $68, $60, $e3, $5f, $5d, $5f
029dc     D7 5E 4F 5E 
029e0     C7 5D 3E 5D 
029e4     B3 5C 28 5C 
029e8     9C 5B 0F 5B | 	byte	$d7, $5e, $4f, $5e, $c7, $5d, $3e, $5d, $b3, $5c, $28, $5c, $9c, $5b, $0f, $5b
029ec     82 5A F3 59 
029f0     64 59 D3 58 
029f4     42 58 B0 57 
029f8     1D 57 8A 56 | 	byte	$82, $5a, $f3, $59, $64, $59, $d3, $58, $42, $58, $b0, $57, $1d, $57, $8a, $56
029fc     F5 55 60 55 
02a00     C9 54 32 54 
02a04     9B 53 02 53 
02a08     68 52 CE 51 | 	byte	$f5, $55, $60, $55, $c9, $54, $32, $54, $9b, $53, $02, $53, $68, $52, $ce, $51
02a0c     33 51 97 50 
02a10     FB 4F 5D 4F 
02a14     BF 4E 20 4E 
02a18     81 4D E0 4C | 	byte	$33, $51, $97, $50, $fb, $4f, $5d, $4f, $bf, $4e, $20, $4e, $81, $4d, $e0, $4c
02a1c     3F 4C 9D 4B 
02a20     FB 4A 58 4A 
02a24     B4 49 0F 49 
02a28     69 48 C3 47 | 	byte	$3f, $4c, $9d, $4b, $fb, $4a, $58, $4a, $b4, $49, $0f, $49, $69, $48, $c3, $47
02a2c     1C 47 75 46 
02a30     CD 45 24 45 
02a34     7A 44 D0 43 
02a38     25 43 7A 42 | 	byte	$1c, $47, $75, $46, $cd, $45, $24, $45, $7a, $44, $d0, $43, $25, $43, $7a, $42
02a3c     CE 41 21 41 
02a40     73 40 C5 3F 
02a44     17 3F 68 3E 
02a48     B8 3D 07 3D | 	byte	$ce, $41, $21, $41, $73, $40, $c5, $3f, $17, $3f, $68, $3e, $b8, $3d, $07, $3d
02a4c     56 3C A5 3B 
02a50     F2 3A 40 3A 
02a54     8C 39 D9 38 
02a58     24 38 6F 37 | 	byte	$56, $3c, $a5, $3b, $f2, $3a, $40, $3a, $8c, $39, $d9, $38, $24, $38, $6f, $37
02a5c     BA 36 04 36 
02a60     4D 35 96 34 
02a64     DF 33 26 33 
02a68     6E 32 B5 31 | 	byte	$ba, $36, $04, $36, $4d, $35, $96, $34, $df, $33, $26, $33, $6e, $32, $b5, $31
02a6c     FB 30 41 30 
02a70     87 2F CC 2E 
02a74     11 2E 55 2D 
02a78     99 2C DC 2B | 	byte	$fb, $30, $41, $30, $87, $2f, $cc, $2e, $11, $2e, $55, $2d, $99, $2c, $dc, $2b
02a7c     1F 2B 61 2A 
02a80     A3 29 E5 28 
02a84     26 28 67 27 
02a88     A8 26 E8 25 | 	byte	$1f, $2b, $61, $2a, $a3, $29, $e5, $28, $26, $28, $67, $27, $a8, $26, $e8, $25
02a8c     28 25 67 24 
02a90     A6 23 E5 22 
02a94     23 22 61 21 
02a98     9F 20 DD 1F | 	byte	$28, $25, $67, $24, $a6, $23, $e5, $22, $23, $22, $61, $21, $9f, $20, $dd, $1f
02a9c     1A 1F 57 1E 
02aa0     93 1D CF 1C 
02aa4     0B 1C 47 1B 
02aa8     82 1A BE 19 | 	byte	$1a, $1f, $57, $1e, $93, $1d, $cf, $1c, $0b, $1c, $47, $1b, $82, $1a, $be, $19
02aac     F9 18 33 18 
02ab0     6E 17 A8 16 
02ab4     E2 15 1C 15 
02ab8     55 14 8F 13 | 	byte	$f9, $18, $33, $18, $6e, $17, $a8, $16, $e2, $15, $1c, $15, $55, $14, $8f, $13
02abc     C8 12 01 12 
02ac0     3A 11 72 10 
02ac4     AB 0F E3 0E 
02ac8     1C 0E 54 0D | 	byte	$c8, $12, $01, $12, $3a, $11, $72, $10, $ab, $0f, $e3, $0e, $1c, $0e, $54, $0d
02acc     8C 0C C4 0B 
02ad0     FB 0A 33 0A 
02ad4     6A 09 A2 08 
02ad8     D9 07 11 07 | 	byte	$8c, $0c, $c4, $0b, $fb, $0a, $33, $0a, $6a, $09, $a2, $08, $d9, $07, $11, $07
02adc     48 06 7F 05 
02ae0     B6 04 ED 03 
02ae4     24 03 5B 02 
02ae8     92 01 C9 00 | 	byte	$48, $06, $7f, $05, $b6, $04, $ed, $03, $24, $03, $5b, $02, $92, $01, $c9, $00
02aec     00 00 37 FF 
02af0     6E FE A5 FD 
02af4     DC FC 13 FC 
02af8     4A FB 81 FA | 	byte	$00, $00, $37, $ff, $6e, $fe, $a5, $fd, $dc, $fc, $13, $fc, $4a, $fb, $81, $fa
02afc     B8 F9 EF F8 
02b00     27 F8 5E F7 
02b04     96 F6 CD F5 
02b08     05 F5 3C F4 | 	byte	$b8, $f9, $ef, $f8, $27, $f8, $5e, $f7, $96, $f6, $cd, $f5, $05, $f5, $3c, $f4
02b0c     74 F3 AC F2 
02b10     E4 F1 1D F1 
02b14     55 F0 8E EF 
02b18     C6 EE FF ED | 	byte	$74, $f3, $ac, $f2, $e4, $f1, $1d, $f1, $55, $f0, $8e, $ef, $c6, $ee, $ff, $ed
02b1c     38 ED 71 EC 
02b20     AB EB E4 EA 
02b24     1E EA 58 E9 
02b28     92 E8 CD E7 | 	byte	$38, $ed, $71, $ec, $ab, $eb, $e4, $ea, $1e, $ea, $58, $e9, $92, $e8, $cd, $e7
02b2c     07 E7 42 E6 
02b30     7E E5 B9 E4 
02b34     F5 E3 31 E3 
02b38     6D E2 A9 E1 | 	byte	$07, $e7, $42, $e6, $7e, $e5, $b9, $e4, $f5, $e3, $31, $e3, $6d, $e2, $a9, $e1
02b3c     E6 E0 23 E0 
02b40     61 DF 9F DE 
02b44     DD DD 1B DD 
02b48     5A DC 99 DB | 	byte	$e6, $e0, $23, $e0, $61, $df, $9f, $de, $dd, $dd, $1b, $dd, $5a, $dc, $99, $db
02b4c     D8 DA 18 DA 
02b50     58 D9 99 D8 
02b54     DA D7 1B D7 
02b58     5D D6 9F D5 | 	byte	$d8, $da, $18, $da, $58, $d9, $99, $d8, $da, $d7, $1b, $d7, $5d, $d6, $9f, $d5
02b5c     E1 D4 24 D4 
02b60     67 D3 AB D2 
02b64     EF D1 34 D1 
02b68     79 D0 BF CF | 	byte	$e1, $d4, $24, $d4, $67, $d3, $ab, $d2, $ef, $d1, $34, $d1, $79, $d0, $bf, $cf
02b6c     05 CF 4B CE 
02b70     92 CD DA CC 
02b74     21 CC 6A CB 
02b78     B3 CA FC C9 | 	byte	$05, $cf, $4b, $ce, $92, $cd, $da, $cc, $21, $cc, $6a, $cb, $b3, $ca, $fc, $c9
02b7c     46 C9 91 C8 
02b80     DC C7 27 C7 
02b84     74 C6 C0 C5 
02b88     0E C5 5B C4 | 	byte	$46, $c9, $91, $c8, $dc, $c7, $27, $c7, $74, $c6, $c0, $c5, $0e, $c5, $5b, $c4
02b8c     AA C3 F9 C2 
02b90     48 C2 98 C1 
02b94     E9 C0 3B C0 
02b98     8D BF DF BE | 	byte	$aa, $c3, $f9, $c2, $48, $c2, $98, $c1, $e9, $c0, $3b, $c0, $8d, $bf, $df, $be
02b9c     32 BE 86 BD 
02ba0     DB BC 30 BC 
02ba4     86 BB DC BA 
02ba8     33 BA 8B B9 | 	byte	$32, $be, $86, $bd, $db, $bc, $30, $bc, $86, $bb, $dc, $ba, $33, $ba, $8b, $b9
02bac     E4 B8 3D B8 
02bb0     97 B7 F1 B6 
02bb4     4C B6 A8 B5 
02bb8     05 B5 63 B4 | 	byte	$e4, $b8, $3d, $b8, $97, $b7, $f1, $b6, $4c, $b6, $a8, $b5, $05, $b5, $63, $b4
02bbc     C1 B3 20 B3 
02bc0     7F B2 E0 B1 
02bc4     41 B1 A3 B0 
02bc8     05 B0 69 AF | 	byte	$c1, $b3, $20, $b3, $7f, $b2, $e0, $b1, $41, $b1, $a3, $b0, $05, $b0, $69, $af
02bcc     CD AE 32 AE 
02bd0     98 AD FE AC 
02bd4     65 AC CE AB 
02bd8     37 AB A0 AA | 	byte	$cd, $ae, $32, $ae, $98, $ad, $fe, $ac, $65, $ac, $ce, $ab, $37, $ab, $a0, $aa
02bdc     0B AA 76 A9 
02be0     E3 A8 50 A8 
02be4     BE A7 2D A7 
02be8     9C A6 0D A6 | 	byte	$0b, $aa, $76, $a9, $e3, $a8, $50, $a8, $be, $a7, $2d, $a7, $9c, $a6, $0d, $a6
02bec     7E A5 F1 A4 
02bf0     64 A4 D8 A3 
02bf4     4D A3 C2 A2 
02bf8     39 A2 B1 A1 | 	byte	$7e, $a5, $f1, $a4, $64, $a4, $d8, $a3, $4d, $a3, $c2, $a2, $39, $a2, $b1, $a1
02bfc     29 A1 A3 A0 
02c00     1D A0 98 9F 
02c04     15 9F 92 9E 
02c08     10 9E 8F 9D | 	byte	$29, $a1, $a3, $a0, $1d, $a0, $98, $9f, $15, $9f, $92, $9e, $10, $9e, $8f, $9d
02c0c     0F 9D 90 9C 
02c10     12 9C 94 9B 
02c14     18 9B 9D 9A 
02c18     23 9A AA 99 | 	byte	$0f, $9d, $90, $9c, $12, $9c, $94, $9b, $18, $9b, $9d, $9a, $23, $9a, $aa, $99
02c1c     31 99 BA 98 
02c20     44 98 CE 97 
02c24     5A 97 E7 96 
02c28     75 96 03 96 | 	byte	$31, $99, $ba, $98, $44, $98, $ce, $97, $5a, $97, $e7, $96, $75, $96, $03, $96
02c2c     93 95 24 95 
02c30     B6 94 49 94 
02c34     DD 93 72 93 
02c38     08 93 9F 92 | 	byte	$93, $95, $24, $95, $b6, $94, $49, $94, $dd, $93, $72, $93, $08, $93, $9f, $92
02c3c     37 92 D0 91 
02c40     6A 91 05 91 
02c44     A2 90 3F 90 
02c48     DE 8F 7D 8F | 	byte	$37, $92, $d0, $91, $6a, $91, $05, $91, $a2, $90, $3f, $90, $de, $8f, $7d, $8f
02c4c     1E 8F C0 8E 
02c50     63 8E 07 8E 
02c54     AC 8D 52 8D 
02c58     F9 8C A2 8C | 	byte	$1e, $8f, $c0, $8e, $63, $8e, $07, $8e, $ac, $8d, $52, $8d, $f9, $8c, $a2, $8c
02c5c     4B 8C F6 8B 
02c60     A1 8B 4E 8B 
02c64     FC 8A AB 8A 
02c68     5B 8A 0D 8A | 	byte	$4b, $8c, $f6, $8b, $a1, $8b, $4e, $8b, $fc, $8a, $ab, $8a, $5b, $8a, $0d, $8a
02c6c     BF 89 73 89 
02c70     28 89 DE 88 
02c74     95 88 4D 88 
02c78     06 88 C1 87 | 	byte	$bf, $89, $73, $89, $28, $89, $de, $88, $95, $88, $4d, $88, $06, $88, $c1, $87
02c7c     7C 87 39 87 
02c80     F7 86 B6 86 
02c84     77 86 38 86 
02c88     FB 85 BF 85 | 	byte	$7c, $87, $39, $87, $f7, $86, $b6, $86, $77, $86, $38, $86, $fb, $85, $bf, $85
02c8c     84 85 4A 85 
02c90     12 85 DA 84 
02c94     A4 84 6F 84 
02c98     3B 84 08 84 | 	byte	$84, $85, $4a, $85, $12, $85, $da, $84, $a4, $84, $6f, $84, $3b, $84, $08, $84
02c9c     D7 83 A7 83 
02ca0     78 83 4A 83 
02ca4     1D 83 F2 82 
02ca8     C7 82 9E 82 | 	byte	$d7, $83, $a7, $83, $78, $83, $4a, $83, $1d, $83, $f2, $82, $c7, $82, $9e, $82
02cac     77 82 50 82 
02cb0     2B 82 06 82 
02cb4     E3 81 C2 81 
02cb8     A1 81 82 81 | 	byte	$77, $82, $50, $82, $2b, $82, $06, $82, $e3, $81, $c2, $81, $a1, $81, $82, $81
02cbc     64 81 47 81 
02cc0     2B 81 11 81 
02cc4     F7 80 DF 80 
02cc8     C9 80 B3 80 | 	byte	$64, $81, $47, $81, $2b, $81, $11, $81, $f7, $80, $df, $80, $c9, $80, $b3, $80
02ccc     9F 80 8C 80 
02cd0     7A 80 69 80 
02cd4     5A 80 4C 80 
02cd8     3F 80 33 80 | 	byte	$9f, $80, $8c, $80, $7a, $80, $69, $80, $5a, $80, $4c, $80, $3f, $80, $33, $80
02cdc     28 80 1F 80 
02ce0     17 80 10 80 
02ce4     0B 80 07 80 
02ce8     03 80 02 80 | 	byte	$28, $80, $1f, $80, $17, $80, $10, $80, $0b, $80, $07, $80, $03, $80, $02, $80
02cec     01 80 02 80 
02cf0     03 80 07 80 
02cf4     0B 80 10 80 
02cf8     17 80 1F 80 | 	byte	$01, $80, $02, $80, $03, $80, $07, $80, $0b, $80, $10, $80, $17, $80, $1f, $80
02cfc     28 80 33 80 
02d00     3F 80 4C 80 
02d04     5A 80 69 80 
02d08     7A 80 8C 80 | 	byte	$28, $80, $33, $80, $3f, $80, $4c, $80, $5a, $80, $69, $80, $7a, $80, $8c, $80
02d0c     9F 80 B3 80 
02d10     C9 80 DF 80 
02d14     F7 80 11 81 
02d18     2B 81 47 81 | 	byte	$9f, $80, $b3, $80, $c9, $80, $df, $80, $f7, $80, $11, $81, $2b, $81, $47, $81
02d1c     64 81 82 81 
02d20     A1 81 C2 81 
02d24     E3 81 06 82 
02d28     2B 82 50 82 | 	byte	$64, $81, $82, $81, $a1, $81, $c2, $81, $e3, $81, $06, $82, $2b, $82, $50, $82
02d2c     77 82 9E 82 
02d30     C7 82 F2 82 
02d34     1D 83 4A 83 
02d38     78 83 A7 83 | 	byte	$77, $82, $9e, $82, $c7, $82, $f2, $82, $1d, $83, $4a, $83, $78, $83, $a7, $83
02d3c     D7 83 08 84 
02d40     3B 84 6F 84 
02d44     A4 84 DA 84 
02d48     12 85 4A 85 | 	byte	$d7, $83, $08, $84, $3b, $84, $6f, $84, $a4, $84, $da, $84, $12, $85, $4a, $85
02d4c     84 85 BF 85 
02d50     FB 85 38 86 
02d54     77 86 B6 86 
02d58     F7 86 39 87 | 	byte	$84, $85, $bf, $85, $fb, $85, $38, $86, $77, $86, $b6, $86, $f7, $86, $39, $87
02d5c     7C 87 C1 87 
02d60     06 88 4D 88 
02d64     95 88 DE 88 
02d68     28 89 73 89 | 	byte	$7c, $87, $c1, $87, $06, $88, $4d, $88, $95, $88, $de, $88, $28, $89, $73, $89
02d6c     BF 89 0D 8A 
02d70     5B 8A AB 8A 
02d74     FC 8A 4E 8B 
02d78     A1 8B F6 8B | 	byte	$bf, $89, $0d, $8a, $5b, $8a, $ab, $8a, $fc, $8a, $4e, $8b, $a1, $8b, $f6, $8b
02d7c     4B 8C A2 8C 
02d80     F9 8C 52 8D 
02d84     AC 8D 07 8E 
02d88     63 8E C0 8E | 	byte	$4b, $8c, $a2, $8c, $f9, $8c, $52, $8d, $ac, $8d, $07, $8e, $63, $8e, $c0, $8e
02d8c     1E 8F 7D 8F 
02d90     DE 8F 3F 90 
02d94     A2 90 05 91 
02d98     6A 91 D0 91 | 	byte	$1e, $8f, $7d, $8f, $de, $8f, $3f, $90, $a2, $90, $05, $91, $6a, $91, $d0, $91
02d9c     37 92 9F 92 
02da0     08 93 72 93 
02da4     DD 93 49 94 
02da8     B6 94 24 95 | 	byte	$37, $92, $9f, $92, $08, $93, $72, $93, $dd, $93, $49, $94, $b6, $94, $24, $95
02dac     93 95 03 96 
02db0     75 96 E7 96 
02db4     5A 97 CE 97 
02db8     44 98 BA 98 | 	byte	$93, $95, $03, $96, $75, $96, $e7, $96, $5a, $97, $ce, $97, $44, $98, $ba, $98
02dbc     31 99 AA 99 
02dc0     23 9A 9D 9A 
02dc4     18 9B 94 9B 
02dc8     12 9C 90 9C | 	byte	$31, $99, $aa, $99, $23, $9a, $9d, $9a, $18, $9b, $94, $9b, $12, $9c, $90, $9c
02dcc     0F 9D 8F 9D 
02dd0     10 9E 92 9E 
02dd4     15 9F 98 9F 
02dd8     1D A0 A3 A0 | 	byte	$0f, $9d, $8f, $9d, $10, $9e, $92, $9e, $15, $9f, $98, $9f, $1d, $a0, $a3, $a0
02ddc     29 A1 B1 A1 
02de0     39 A2 C2 A2 
02de4     4D A3 D8 A3 
02de8     64 A4 F1 A4 | 	byte	$29, $a1, $b1, $a1, $39, $a2, $c2, $a2, $4d, $a3, $d8, $a3, $64, $a4, $f1, $a4
02dec     7E A5 0D A6 
02df0     9C A6 2D A7 
02df4     BE A7 50 A8 
02df8     E3 A8 76 A9 | 	byte	$7e, $a5, $0d, $a6, $9c, $a6, $2d, $a7, $be, $a7, $50, $a8, $e3, $a8, $76, $a9
02dfc     0B AA A0 AA 
02e00     37 AB CE AB 
02e04     65 AC FE AC 
02e08     98 AD 32 AE | 	byte	$0b, $aa, $a0, $aa, $37, $ab, $ce, $ab, $65, $ac, $fe, $ac, $98, $ad, $32, $ae
02e0c     CD AE 69 AF 
02e10     05 B0 A3 B0 
02e14     41 B1 E0 B1 
02e18     7F B2 20 B3 | 	byte	$cd, $ae, $69, $af, $05, $b0, $a3, $b0, $41, $b1, $e0, $b1, $7f, $b2, $20, $b3
02e1c     C1 B3 63 B4 
02e20     05 B5 A8 B5 
02e24     4C B6 F1 B6 
02e28     97 B7 3D B8 | 	byte	$c1, $b3, $63, $b4, $05, $b5, $a8, $b5, $4c, $b6, $f1, $b6, $97, $b7, $3d, $b8
02e2c     E4 B8 8B B9 
02e30     33 BA DC BA 
02e34     86 BB 30 BC 
02e38     DB BC 86 BD | 	byte	$e4, $b8, $8b, $b9, $33, $ba, $dc, $ba, $86, $bb, $30, $bc, $db, $bc, $86, $bd
02e3c     32 BE DF BE 
02e40     8D BF 3B C0 
02e44     E9 C0 98 C1 
02e48     48 C2 F9 C2 | 	byte	$32, $be, $df, $be, $8d, $bf, $3b, $c0, $e9, $c0, $98, $c1, $48, $c2, $f9, $c2
02e4c     AA C3 5B C4 
02e50     0E C5 C0 C5 
02e54     74 C6 27 C7 
02e58     DC C7 91 C8 | 	byte	$aa, $c3, $5b, $c4, $0e, $c5, $c0, $c5, $74, $c6, $27, $c7, $dc, $c7, $91, $c8
02e5c     46 C9 FC C9 
02e60     B3 CA 6A CB 
02e64     21 CC DA CC 
02e68     92 CD 4B CE | 	byte	$46, $c9, $fc, $c9, $b3, $ca, $6a, $cb, $21, $cc, $da, $cc, $92, $cd, $4b, $ce
02e6c     05 CF BF CF 
02e70     79 D0 34 D1 
02e74     EF D1 AB D2 
02e78     67 D3 24 D4 | 	byte	$05, $cf, $bf, $cf, $79, $d0, $34, $d1, $ef, $d1, $ab, $d2, $67, $d3, $24, $d4
02e7c     E1 D4 9F D5 
02e80     5D D6 1B D7 
02e84     DA D7 99 D8 
02e88     58 D9 18 DA | 	byte	$e1, $d4, $9f, $d5, $5d, $d6, $1b, $d7, $da, $d7, $99, $d8, $58, $d9, $18, $da
02e8c     D8 DA 99 DB 
02e90     5A DC 1B DD 
02e94     DD DD 9F DE 
02e98     61 DF 23 E0 | 	byte	$d8, $da, $99, $db, $5a, $dc, $1b, $dd, $dd, $dd, $9f, $de, $61, $df, $23, $e0
02e9c     E6 E0 A9 E1 
02ea0     6D E2 31 E3 
02ea4     F5 E3 B9 E4 
02ea8     7E E5 42 E6 | 	byte	$e6, $e0, $a9, $e1, $6d, $e2, $31, $e3, $f5, $e3, $b9, $e4, $7e, $e5, $42, $e6
02eac     07 E7 CD E7 
02eb0     92 E8 58 E9 
02eb4     1E EA E4 EA 
02eb8     AB EB 71 EC | 	byte	$07, $e7, $cd, $e7, $92, $e8, $58, $e9, $1e, $ea, $e4, $ea, $ab, $eb, $71, $ec
02ebc     38 ED FF ED 
02ec0     C6 EE 8E EF 
02ec4     55 F0 1D F1 
02ec8     E4 F1 AC F2 | 	byte	$38, $ed, $ff, $ed, $c6, $ee, $8e, $ef, $55, $f0, $1d, $f1, $e4, $f1, $ac, $f2
02ecc     74 F3 3C F4 
02ed0     05 F5 CD F5 
02ed4     96 F6 5E F7 
02ed8     27 F8 EF F8 | 	byte	$74, $f3, $3c, $f4, $05, $f5, $cd, $f5, $96, $f6, $5e, $f7, $27, $f8, $ef, $f8
02edc     B8 F9 81 FA 
02ee0     4A FB 13 FC 
02ee4     DC FC A5 FD 
02ee8     6E FE 37 FF | 	byte	$b8, $f9, $81, $fa, $4a, $fb, $13, $fc, $dc, $fc, $a5, $fd, $6e, $fe, $37, $ff
02eec                 | 	alignl
02eec                 | _psram_spin2_dat_
02eec     00 00 00 00 
      ...             
02fe4     00 00 00 00 
02fe8     00 00 00 00 |     listdata long 0[8*8]
02fec                 |             orgh
02fec                 | 
02fec                 | ' driver state
02fec     FF FF FF FF | drivercog   long    -1  ' COG id of driver
02ff0     FF FF FF FF | driverlock  long    -1  ' LOCK id of driver
02ff4                 | 
02ff4                 | ' delay profile
02ff4     07 00 00 00 
02ff8     00 CF 7B 05 
02ffc     80 D1 F0 08 
03000     80 4F 47 0C | delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
03004     80 C4 60 0F 
03008     80 39 7A 12 
0300c     40 2D D9 13 
03010     00 00 00 00 | 	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
03014                 | 
03014                 | ' data to be passed to driver when starting it
03014                 | startupData
03014     00 00 00 00 |     long    0           ' current frequency
03018     00 00 00 00 |     long    FLAGS       ' optional flags for driver
0301c     00 00 00 00 |     long    0           ' reset pin mask on port A for PSRAM (none)
03020     00 00 00 00 |     long    0           ' reset pin mask on port B for PSRAM (none)
03024     28 00 00 00 |     long    DATABUS     ' PSRAM data bus start pin
03028     34 30 00 00 |     long    deviceData  ' address of devices data structure in HUBRAM
0302c     B4 30 00 00 |     long    qosData     ' address of QoS data structure in HUBRAM
03030     D4 30 00 00 |     long    mailboxes   ' address of mailbox structure in HUBRAM
03034                 | 
03034                 | ' data for memory
03034                 | deviceData
03034                 |     ' 16 bank parameters follow (16MB per bank)
03034     00 00 00 00 
      ...             
0306c     00 00 00 00 
03070     00 00 00 00 |     long    0[16]                               ' banks 0-15
03074                 |     ' 16 banks of pin parameters follow
03074     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
03078     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
0307c     FF FF FF FF 
      ...             
030ac     FF FF FF FF 
030b0     FF FF FF FF |     long    -1[14]                              ' banks 2-15
030b4                 | 
030b4                 | ' data for COG polling
030b4                 | qosData 
030b4     00 00 FF FF 
030b8     00 00 FF FF 
030bc     00 00 FF FF 
030c0     00 00 FF FF |     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
030c4     00 00 FF FF 
030c8     00 00 FF FF 
030cc     00 00 FF FF 
030d0     00 00 FF FF | 	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
030d4                 |     
030d4                 | ' mailbox storage
030d4                 | 
030d4                 | mailboxes
030d4     00 00 00 00 
      ...             
0312c     00 00 00 00 
03130     00 00 00 00 |     long    0[8*3]          ' 3 longs per mailbox per COG
03134                 | 	alignl
03134                 | _psram16drv_spin2_dat_
03134                 |                             orgh
03134     00 00 00 00 
      ...             
0314c     00 00 00 00 
03150     00 00 00 00 | scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
03154                 | 
03154                 | driver_start
03154                 |                             org
03154 000             | '..................................................................................................
03154 000             | ' Memory layout for COG RAM once operational:
03154 000             | '
03154 000             | '  COG RAM address      Usage
03154 000             | '  ---------------      ----
03154 000             | '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
03154 000             | '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
03154 000             | '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
03154 000             | '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
03154 000             | '   $100-$197           Mailbox poller, error handlers, and all driver management code
03154 000             | '  ~$198-$1F3           State and register variables
03154 000             | '
03154 000             | ' Also during driver COG startup:
03154 000             | '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
03154 000             | ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
03154 000             | '..................................................................................................
03154 000             |                             
03154 000             | ' Mailbox storage after vector initialization
03154 000             | 
03154 000 FC 01 B0 FD | req0                        call    #init                   'do HW setup/initialization
03158 001 F0 E3 AB FA | data0                       rdlut   c, b wz                 'read bank info          
0315c 002 F0 DF 03 F6 | count0                      mov     a, b                    'set COGRAM address low nibble
03160 003 68 F0 07 A6 | req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
03164 004 0A E2 17 F4 | data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
03168 005 50 F0 07 16 | count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
0316c 006 58 F0 07 46 | req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
03170 007 08 E2 07 F6 | data2                       mov     c, #$8                  'setup vector base to $80
03174 008 F1 DF 0B F8 | count2                      setnib  a, c, #1                'prepare vector base address for bank
03178 009 00 DE 8F F9 | req3                        altd    a, #0                   'prepare COG destination read address
0317c 00a 61 01 A4 FA | data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
03180 00b 0F E2 0F F7 | count3                      incmod  c, #15 wz               'next vector
03184 00c EC FF 9F 5D | req4        if_nz           jmp     #count2                 'repeat
03188 00d 0F E0 0F F7 | data4                       incmod  b, #15 wz               'next bank
0318c 00e C8 FF 9F 5D | count4      if_nz           jmp     #data0                  'repeat
03190 00f 20 F0 07 F6 | req5                        mov     ptra, #$20              'setup base LUT address to clear
03194 010 50 0A DC FC | data5                       rep     #5, #80                 'update next 80 longs      
03198 011 E2 F1 13 F2 | count5                      cmp     ptra, header wc         'check if LUT address range 
0319c 012 E3 F1 93 32 | req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
031a0 013 61 01 3C CC | data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
031a4 014 61 B1 37 3C | count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
031a8 015 A5 29 00 31 | req7        if_nc           add     $-1, const512           'increment source of LUT write data
031ac 016 FF C0 03 F6 | data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
031b0 017 26 FF 05 06 | count7      _ret_           mov     255, #dolist            'setup list address, return to notify
031b4 018             | 
031b4 018             | ' Mailbox parameter addresses per COG once patched
031b4 018             |                             
031b4 018 04 00 00 00 | cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
031b8 019 10 00 00 00 | cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
031bc 01a 1C 00 00 00 | cog2mboxdata                long    2*12+4                  '...
031c0 01b 28 00 00 00 | cog3mboxdata                long    3*12+4
031c4 01c 34 00 00 00 | cog4mboxdata                long    4*12+4
031c8 01d 40 00 00 00 | cog5mboxdata                long    5*12+4
031cc 01e 4C 00 00 00 | cog6mboxdata                long    6*12+4
031d0 01f 58 00 00 00 | cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
031d4 020             | 
031d4 020             | '..................................................................................................
031d4 020             | ' Per COG request and state setup and service branching
031d4 020             |         
031d4 020             | cog0                 
031d4 020 20 F0 07 F6 |                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
031d8 021 18 F2 03 F6 |                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
031dc 022 D0 C3 03 F6 |                             mov     id, id0                 'get COG0 state
031e0 023 E1 47 3B F9 |                             getword limit, id, #1           'get COG0 burst limit
031e4 024 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
031e8 025 30 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
031ec 026 00 B0 03 F6 |                             mov     addr1, req0             'get mailbox request parameter for COG0
031f0 027 01 B2 03 F6 |                             mov     hubdata, data0          'get COG0 mailbox data parameter
031f4 028 02 B4 03 F6 |                             mov     count, count0           'get COG0 mailbox count parameter
031f8 029 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
031fc 02a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
03200 02b 33 CA 63 FD |                             execf   request-0               'jump to service
03204 02c             | cog1                        
03204 02c 2A F0 07 F6 |                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
03208 02d 19 F2 03 F6 |                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
0320c 02e D1 C3 03 F6 |                             mov     id, id1                 'get COG1 state
03210 02f E1 47 3B F9 |                             getword limit, id, #1           'get COG1 burst limit
03214 030 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
03218 031 00 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
0321c 032 03 B0 03 F6 |                             mov     addr1, req1             'get mailbox request parameter for COG1
03220 033 04 B2 03 F6 |                             mov     hubdata, data1          'get COG1 mailbox data parameter
03224 034 05 B4 03 F6 |                             mov     count, count1           'get COG1 mailbox count parameter
03228 035 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
0322c 036 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
03230 037 33 CA 63 FD |                             execf   request-0               'jump to service
03234 038             | cog2                         
03234 038 34 F0 07 F6 |                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
03238 039 1A F2 03 F6 |                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
0323c 03a D2 C3 03 F6 |                             mov     id, id2                 'get COG2 state
03240 03b E1 47 3B F9 |                             getword limit, id, #1           'get COG2 burst limit
03244 03c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
03248 03d D0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
0324c 03e 06 B0 03 F6 |                             mov     addr1, req2             'get mailbox request parameter for COG2
03250 03f 07 B2 03 F6 |                             mov     hubdata, data2          'get COG2 mailbox data parameter
03254 040 08 B4 03 F6 |                             mov     count, count2           'get COG2 mailbox count parameter
03258 041 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
0325c 042 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
03260 043 33 CA 63 FD |                             execf   request-0               'jump to service
03264 044             | cog3                        
03264 044 3E F0 07 F6 |                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
03268 045 1B F2 03 F6 |                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
0326c 046 D3 C3 03 F6 |                             mov     id, id3                 'get COG3 state
03270 047 E1 47 3B F9 |                             getword limit, id, #1           'get COG3 burst limit
03274 048 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
03278 049 A0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
0327c 04a 09 B0 03 F6 |                             mov     addr1, req3             'get mailbox request parameter for COG3
03280 04b 0A B2 03 F6 |                             mov     hubdata, data3          'get COG3 mailbox data parameter
03284 04c 0B B4 03 F6 |                             mov     count, count3           'get COG3 mailbox count parameter
03288 04d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
0328c 04e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
03290 04f 33 CA 63 FD |                             execf   request-0               'jump to service
03294 050             | cog4                        
03294 050 48 F0 07 F6 |                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
03298 051 1C F2 03 F6 |                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
0329c 052 D4 C3 03 F6 |                             mov     id, id4                 'get COG4 state
032a0 053 E1 47 3B F9 |                             getword limit, id, #1           'get COG4 burst limit
032a4 054 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
032a8 055 70 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
032ac 056 0C B0 03 F6 |                             mov     addr1, req4             'get mailbox request parameter for COG4
032b0 057 0D B2 03 F6 |                             mov     hubdata, data4          'get COG4 mailbox data parameter
032b4 058 0E B4 03 F6 |                             mov     count, count4           'get COG4 mailbox count parameter
032b8 059 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
032bc 05a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
032c0 05b 33 CA 63 FD |                             execf   request-0               'jump to service
032c4 05c             | cog5                        
032c4 05c 52 F0 07 F6 |                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
032c8 05d 1D F2 03 F6 |                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
032cc 05e D5 C3 03 F6 |                             mov     id, id5                 'get COG5 state
032d0 05f E1 47 3B F9 |                             getword limit, id, #1           'get COG5 burst limit
032d4 060 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
032d8 061 40 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
032dc 062 0F B0 03 F6 |                             mov     addr1, req5             'get mailbox request parameter for COG5
032e0 063 10 B2 03 F6 |                             mov     hubdata, data5          'get COG5 mailbox data parameter
032e4 064 11 B4 03 F6 |                             mov     count, count5           'get COG5 mailbox count parameter
032e8 065 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
032ec 066 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
032f0 067 33 CA 63 FD |                             execf   request-0               'jump to service
032f4 068             | cog6                        
032f4 068 5C F0 07 F6 |                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
032f8 069 1E F2 03 F6 |                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
032fc 06a D6 C3 03 F6 |                             mov     id, id6                 'get COG6 state
03300 06b E1 47 3B F9 |                             getword limit, id, #1           'get COG6 burst limit
03304 06c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
03308 06d 10 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
0330c 06e 12 B0 03 F6 |                             mov     addr1, req6             'get mailbox request parameter for COG6
03310 06f 13 B2 03 F6 |                             mov     hubdata, data6          'get COG6 mailbox data parameter
03314 070 14 B4 03 F6 |                             mov     count, count6           'get COG6 mailbox count parameter
03318 071 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
0331c 072 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
03320 073 33 CA 63 FD |                             execf   request-0               'jump to service
03324 074             | cog7                        
03324 074 66 F0 07 F6 |                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
03328 075 1F F2 03 F6 |                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
0332c 076 D7 C3 03 F6 |                             mov     id, id7                 'get COG7 state
03330 077 E1 47 3B F9 |                             getword limit, id, #1           'get COG7 burst limit
03334 078 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
03338 079 E0 02 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
0333c 07a 15 B0 03 F6 |                             mov     addr1, req7             'get mailbox request parameter for COG7
03340 07b 16 B2 03 F6 |                             mov     hubdata, data7          'get COG7 mailbox data parameter
03344 07c 17 B4 03 F6 |                             mov     count, count7           'get COG7 mailbox count parameter
03348 07d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
0334c 07e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
03350 07f 33 CA 63 FD |                             execf   request-0               'jump to service
03354 080             |                             fit     128
03354 080             | 
03354 080             |                             fit     128
03354 080             | pad                         long    0[128-$]                'align init code to $80
03354 080             | 
03354 080             | '..................................................................................................
03354 080             | 
03354 080             | ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
03354 080             | 
03354 080             | init                        
03354 080             |                             ' get driver scratch long address in hub
03354 080 01 DA 63 FD |                             cogid   hubscratch              'get cogid
03358 081 01 DA 07 F1 |                             add     hubscratch, #1          'increase by 1 from 1-8
0335c 082 04 DA 07 FA |                             mul     hubscratch, #4          'multiply by 4 to get 4-32
03360 083 F9 DB C3 F2 |                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
03364 084             |                     
03364 084             |                             ' read in the additional LUT RAM code
03364 084 F9 41 03 F1 |                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
03368 085 29 9E 67 FD |                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
0336c 086 A0 61 00 FB |                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
03370 087             | 
03370 087             |                             ' read the startup parameters
03370 087 28 0E 64 FD |                             setq    #8-1                    'read 8 longs from hub
03374 088 00 41 07 FB |                             rdlong  startupparams, ptra     '.. as the startup parameters 
03378 089             | 
03378 089             |                             ' setup some of the config flag dependent state and patch LUTRAM
03378 089 1C 42 0F F4 |                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
0337c 08a             | 
0337c 08a F9 71 03 A1 |             if_z            add     expansion, ptrb         'compensate for HUB address
03380 08b 01 00 00 5F 
03384 08c FB 70 07 56 |             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
03388 08d 1D 42 17 F4 |                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
0338c 08e AA 57 43 35 |             if_nc           or      clkconfig, registered   'enable this if so
03390 08f 00 58 07 36 |             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
03394 090             | 
03394 090             |                             ' setup data pin modes and data bus pin group in streamer commands
03394 090 38 48 07 F5 |                             and     datapins, #%111000      'compute base pin
03398 091 01 00 00 FF 
0339c 092 C0 49 47 F5 |                             or      datapins, ##(15<<6)     'configure 16 pins total
033a0 093 A4 DF 03 F6 |                             mov     a, datapins             'get data pin base
033a4 094 A4 55 03 FC |                             wrpin   registered, datapins    'prepare data pins for address phase transfer
033a8 095 03 DE 47 F0 |                             shr     a, #3                   'determine data pin group
033ac 096 07 DE 07 F5 |                             and     a, #7                   'ignore the unwanted bits
033b0 097 08 DE 47 F5 |                             or      a, #8
033b4 098 EF 2F 2B F8 |                             setnib  ximm8lut, a, #5         'setup bus group in streamer
033b8 099 EF 31 2B F8 |                             setnib  xrecvlo8, a, #5
033bc 09a EF 35 2B F8 |                             setnib  xrecvdata, a, #5
033c0 09b EF 37 2B F8 |                             setnib  xsenddata, a, #5
033c4 09c EF 39 2B F8 |                             setnib  xsendimm, a, #5
033c8 09d 01 DE 07 F1 |                             add     a, #1
033cc 09e EF 33 2B F8 |                             setnib  xrecvhi8, a, #5         ' increase port by one
033d0 09f             |  
033d0 09f             |                             ' setup device control pin states
033d0 09f 29 3E 64 FD |                             setq2   #32-1                   'read 32 longs to LUTRAM
033d4 0a0 A5 01 00 FB |                             rdlong  $000, devicelist        'read bank/pin data for all banks    
033d8 0a1 01 00 00 FF 
033dc 0a2 00 4A 07 F6 |                             mov     const512, ##512         'prepare constant
033e0 0a3             | 
033e0 0a3 10 F2 07 F6 |                             mov     ptrb, #16               'point to bank pin config data
033e4 0a4 10 14 DC FC |                             rep     @pinloop, #16           'iterate through 16 banks
033e8 0a5 E1 CF B7 FA |                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
033ec 0a6 AF CF 03 F5 |                             and     pinconfig, pinmask      'save us from invalid bits in args
033f0 0a7 E7 53 E3 38 |             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
033f4 0a8 A9 01 08 3C |             if_nc           wrpin   #0, cspin               'clear smart pin mode
033f8 0a9 59 52 63 3D |             if_nc           drvh    cspin                   'setup pins for all banks
033fc 0aa E7 51 EB 38 |             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
03400 0ab 50 50 63 3D |             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
03404 0ac A8 57 03 3C |             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
03408 0ad A8 03 18 3C |             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
0340c 0ae 58 50 63 3D |             if_nc           drvl    clkpin                  'set clk state low
03410 0af             | pinloop
03410 0af             |                             ' generate minimum CE high time before access
03410 0af A1 07 00 FF 
03414 0b0 40 40 17 FD |                             qdiv    frequency, ##1000000    'convert from Hz to MHz
03418 0b1 18 E2 63 FD |                             getqx   c                       'get P2 clocks per microsecond
0341c 0b2 96 DE 07 F6 |                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
03420 0b3 F1 DF 03 FA |                             mul     a, c                    'convert microseconds to clocks
03424 0b4 1F DE 63 FD |                             waitx   a                       'delay
03428 0b5 E8 05 B0 FD |                             call    #hwinit                 'setup HW into QSPI mode
0342c 0b6             | 
0342c 0b6             |                             ' setup the COG mailboxes and addresses 
0342c 0b6 08 04 DC FC |                             rep     #2, #8                  'setup loop to patch mailbox addresses
03430 0b7 38 70 A5 F9 |                             alti    $+1, #%111_000          'increase D field
03434 0b8 A7 31 00 F1 |                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
03438 0b9             | 
03438 0b9 28 2E 64 FD |                             setq    #24-1
0343c 0ba A7 01 68 FC |                             wrlong  #0, mbox                'clear out mailboxes ????
03440 0bb             | 
03440 0bb             |                             ' setup the polling loop for active COGs 
03440 0bb 01 C2 63 FD |                             cogid   id
03444 0bc D0 C3 97 F9 |                             alts    id, #id0                'determine id register of control COG
03448 0bd 00 90 B6 F9 |                             setd    patchid, #0             'patch into destination address
0344c 0be 2A F0 63 FD |                             push    ptra                    'save ptra before we lose it
03450 0bf 0A F0 07 F6 |                             mov     ptra, #10
03454 0c0 E1 F1 03 FA |                             mul     ptra, id
03458 0c1 20 F0 07 F1 |                             add     ptra, #$20              'prep ptra for reloadcogs
0345c 0c2 B0 C3 97 F9 |                             alts    id, #cog0_handler       'add to handler base
03460 0c3 00 48 BE F9 |                             sets    ctrlpollinst, #0-0      'patch into jump instruction
03464 0c4 03 C2 07 FA |                             mul     id, #3
03468 0c5 E1 49 B2 F9 |                             setd    ctrlpollinst, id
0346c 0c6 09 C3 A7 FA |                             rdlut   id, ptra[9]             'save original value
03470 0c7 09 C1 37 FC |                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
03474 0c8 D8 01 B0 FD |                             call    #reloadcogs
03478 0c9 09 C3 37 FC |                             wrlut   id, ptra[9]             'restore original value
0347c 0ca 2B F0 63 FD |                             pop     ptra                    'restore original ptra
03480 0cb             |                             ' move LUT control vectors into temporary location to avoid clobbering them later
03480 0cb D8 E5 B7 F9 |                             setd    d, #addr1
03484 0cc 60 E4 BF F9 |                             sets    d, #(ctrl_vect & $1ff)
03488 0cd 08 04 DC FC |                             rep     #2, #8
0348c 0ce 3F E4 A7 F9 |                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
03490 0cf 60 B0 A7 FA |                             rdlut   addr1-0, #$60-0
03494 0d0             | 
03494 0d0             |                             'setup control COG service handling, we need to patch 5 instructions
03494 0d0             |                             'one existing instruction is moved earlier and four instructions get replaced
03494 0d0 01 C2 63 FD |                             cogid   id
03498 0d1 0C DE 07 F6 |                             mov     a, #(cog1-cog0)         'get code separation of handlers
0349c 0d2 E1 DF 03 FA |                             mul     a, id                   'scale ID by separation
034a0 0d3 24 DE 07 F1 |                             add     a, #cog0+4              'add to base for COG0 and offset
034a4 0d4 EF E5 B3 F9 |                             setd    d, a                    'set this as the destination
034a8 0d5 02 DE 07 F1 |                             add     a, #2                   'increment COG address
034ac 0d6 EF E5 BB F9 |                             sets    d, a                    'set this as the source
034b0 0d7 3C E4 A7 F9 |                             alti    d, #%111_100             
034b4 0d8 00 00 00 F6 |                             mov     0-0, 0-0                'move instruction
034b8 0d9 EE E4 BF F9 |                             sets    d, #controlpatch        'set source of patched instructions
034bc 0da 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
034c0 0db 3F E4 A7 F9 |                             alti    d, #%111_111
034c4 0dc 00 00 00 F6 |                             mov     0-0, 0-0
034c8 0dd A5 E5 03 F1 |                             add     d, const512             'skip two instructions
034cc 0de A5 E5 03 F1 |                             add     d, const512
034d0 0df 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
034d4 0e0 3F E4 A7 F9 |                             alti    d, #%111_111
034d8 0e1 00 00 00 F6 |                             mov     0-0, 0-0
034dc 0e2             |                             
034dc 0e2             |                             ' setup register values for control vector loop setup after we return
034dc 0e2 E1 C5 03 F6 |                             mov     header, id              'get cog ID
034e0 0e3 0A C4 07 FA |                             mul     header, #10             'multiply by size of state memory per COG
034e4 0e4 20 C4 07 F1 |                             add     header, #$20            'add to COG state base address in LUT
034e8 0e5 E2 C7 03 F6 |                             mov     trailer, header         'determine start/end LUT address
034ec 0e6 09 C6 07 F1 |                             add     trailer, #9             '...for control region
034f0 0e7 E0 C3 43 F5 |                             or      id, initctrl            'set id field for control COG
034f4 0e8 D0 C3 8F F9 |                             altd    id, #id0
034f8 0e9 E1 01 00 F6 |                             mov     0-0, id                 'setup id field for notification
034fc 0ea F8 F3 03 F6 |                             mov     ptrb, ptra              'get startup parameter address
03500 0eb 04 F2 07 F1 |                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
03504 0ec 00 E0 07 F6 |                             mov     b, #0                   'prepare b for upcoming loop
03508 0ed 2A 14 66 0D |                 _ret_       push    #notify                 'continue init in mailbox area
0350c 0ee             |  
0350c 0ee D8 CB 7B F8 | controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
03510 0ef 07 CA 07 F5 |                             and     request, #7
03514 0f0 F8 CB 03 F1 |                             add     request, ptra           'add request vector offset
03518 0f1 E5 CB A3 FA |                             rdlut   request, request        'lookup jump vector service table 
0351c 0f2             |                             fit     $100                    'ensure all init code fits this space
0351c 0f2             | 
0351c 0f2             |                             fit     $100                    'ensure all init code fits this space
0351c 0f2             | 
0351c 0f2 00 00 00 00 
      ...             
0354c 0fe 00 00 00 00 
03550 0ff 00 00 00 00 |                             long    0[$100-$]               'pad more if required until table ends
03554 100             | 
03554 100             | '..................................................................................................
03554 100             | ' Error result handling and COG notification of request completion
03554 100             | 
03554 100 04 04 4C FB | unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
03558 101 03 02 4C FB | invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
0355c 102 02 06 4C FB | invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
03560 103 01 08 4C FB | alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
03564 104 05 EC 07 F6 | busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
03568 105 D0 C3 8F F9 | err                         altd    id, #id0                'adjust for the running COG
0356c 106 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
03570 107 08 01 3C FC |                             wrlut   #0, ptra[8]             'cancel any resume state
03574 108 32 04 64 FD |                             skipf   #%10                    'dont notify with success code 0 below
03578 109 BF ED 67 FC |                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
0357c 10a BF 01 6C FC | notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
03580 10b 0B C2 0F F4 |                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
03584 10c E1 DF C3 F9 |                             decod   a, id                   'convert COG ID to bitmask
03588 10d 3F DE 63 AD |             if_z            cogatn  a                       'notify COG via ATN
0358c 10e             | ' Poller re-starts here after a COG is serviced
0358c 10e 0F C2 0F F4 | poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
03590 10f E6 5F 03 57 |             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
03594 110 AF 45 CB F9 |                             bmask   mask, rrcounter         'generate a RR skip mask from the count
03598 111             | ' Main dynamic polling loop repeats until a request arrives
03598 111 00 00 DC FC | polling_loop                rep     #0-0, #0                'repeat until we get a request for something
0359c 112 28 2E 64 FD |                             setq    #24-1                   'read 24 longs
035a0 113 A7 01 00 FB |                             rdlong  req0, mbox              'get all mailbox requests and data longs
035a4 114             | 
035a4 114 B0 01 B0 FB | polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
035a8 115 32 44 63 FD |                             skipf   mask                    ']after all priority COG handlers if present
035ac 116 B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
035b0 117 B2 0D B0 FB |                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
035b4 118 B3 13 B0 FB |                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
035b8 119 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
035bc 11a B5 1F B0 FB |                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
035c0 11b B6 25 B0 FB |                             tjs     req6, cog6_handler      ']based on the active COGs being polled
035c4 11c B7 2B B0 FB |                             tjs     req7, cog7_handler      ']and whether priority or round robin.
035c8 11d B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
035cc 11e B2 0D B0 FB |                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
035d0 11f B3 13 B0 FB |                             tjs     req3, cog3_handler      ']have changed.
035d4 120 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
035d8 121 B5 1F B0 FB |                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
035dc 122 B6 25 B0 FB |                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
035e0 123 B7 2B B0 FB | pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
035e4 124             | 
035e4 124 B0 01 B0 FB | ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
035e8 125 32 44 63 FD | skipfinst                   skipf   mask                    'instruction template for skipf
035ec 126             |  
035ec 126             | '..................................................................................................
035ec 126             | ' List handler                               
035ec 126             | 
035ec 126 01 B0 A7 FB | dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
035f0 127 33 C0 63 FD |                             execf   burstwrite              'otherwise do a burst write to this bank
035f4 128 28 0E 64 FD | real_list                   setq    #8-1                    'read 8 longs (largest request size)
035f8 129 D9 B1 03 FB |                             rdlong  addr1, hubdata          '..to update the request state
035fc 12a D7 B1 BF FB |                             tjns    addr1, #invalidlist     'error if request list item not valid
03600 12b D0 C3 8F F9 |                             altd    id, #id0                'get COG state
03604 12c 09 00 3C F4 |                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
03608 12d 09 C2 27 F4 |                             bith    id, #LIST_BIT           'retain fact that we are in a list
0360c 12e 44 FF 9F AD |             if_z            jmp     #unsupported            'no list recursion is allowed!
03610 12f D8 CB FB F8 |                             getbyte request, addr1, #3      'get upper byte of this request
03614 130 00 CA 8F F9 | service_request             altd    request, #0             'get request address in COG RAM
03618 131 33 00 60 FD |                             execf   0-0                     'process the request 
0361c 132             | 
0361c 132             | '..................................................................................................
0361c 132             | ' Restoring per COG state and resuming where we left off
0361c 132             | 
0361c 132 00 B1 A7 FA | restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
03620 133 01 B3 A7 FA |                             rdlut   hubdata, ptra[1]
03624 134 02 B5 A7 FA |                             rdlut   count, ptra[2]
03628 135 03 B7 B7 FA |                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
0362c 136 D8 CB FB F8 |                             getbyte request, addr1, #3
03630 137 33 D2 63 3D |             if_nc           execf   resume                  'if not extended then resume immediately
03634 138 04 B9 A7 FA |                             rdlut   total, ptra[4]          'we need to read the extended parameters
03638 139 05 BB A7 FA |                             rdlut   offset1, ptra[5]
0363c 13a 06 BD A7 FA |                             rdlut   offset2, ptra[6]
03640 13b 07 BF A7 FA |                             rdlut   link, ptra[7]
03644 13c 09 D5 A7 FA |                             rdlut   orighubsize, ptra[9]
03648 13d 33 D2 63 FD |                             execf   resume                  'then resume what we were doing last time
0364c 13e             |                    
0364c 13e             | '..................................................................................................
0364c 13e             | ' Re-configuration of QoS settings and custom polling loop sequence generator
0364c 13e             | 
0364c 13e 2A 14 66 FD | reconfig                    push    #notify                 'setup return addr, then reload 
03650 13f 28 0E 64 FD | reloadcogs                  setq    #8-1                    'reload all per COG QoS params
03654 140 A6 B1 03 FB |                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
03658 141 D0 DF B7 F9 |                             setd    a, #id0
0365c 142 D8 DF BF F9 |                             sets    a, #addr1
03660 143 FE FF FF FF 
03664 144 28 00 66 FD |                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
03668 145 08 04 DC FC |                             rep     #2, #8                  'repeat for 8 COGs
0366c 146 3F DE A7 F9 |                             alti    a, #%111_111 
03670 147 00 00 F0 F9 |                             muxq    0-0, 0-0
03674 148 09 01 A4 FA | patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
03678 149 01 E2 63 FD |                             cogid   c
0367c 14a F1 41 C3 F9 |                             decod   excludedcogs, c         'exclude driver cog initially
03680 14b 08 DE 07 F6 |                             mov     a, #$8                  'a iterates through prio levels 8=lowest
03684 14c 01 EC 67 F6 |                             neg     pa, #1                  'start with all ones
03688 14d 07 E2 07 F6 | fillprio                    mov     c, #7                   'c iterates through cogs
0368c 14e D0 E3 97 F9 | prioloop                    alts    c, #id0
03690 14f 00 E0 03 F6 |                             mov     b, 0-0
03694 150 F0 E5 3B F9 |                             getword d, b, #1                'get burst field
03698 151 F2 E5 CB F7 |                             test    d wz                    'if burst=0 
0369c 152 F1 41 23 A4 |             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
036a0 153 0C 00 90 AD |             if_z            jmp     #excluded               
036a4 154 F0 E5 5B F8 |                             getnib  d, b, #3                'get RR/PRI flag & priority
036a8 155 EF E5 0B F2 |                             cmp     d, a wz                 'compare against current priority level
036ac 156 F1 ED 83 A8 |             if_z            rolnib  pa, c, #0               'if matches include COG at this level
036b0 157 F6 E3 7F FB | excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
036b4 158 0F DE 0F F7 |                             incmod  a, #15 wz               'next level
036b8 159 CC FF 9F 5D |             if_nz           jmp     #fillprio 
036bc 15a             | 
036bc 15a             | 'determine priority cogs and build instructions for the polling sequence
036bc 15a 00 EE 07 F6 |                             mov     pb, #0                  'clear out set of priority COGs
036c0 15b 03 DE 07 F6 |                             mov     a, #3                   'start with no COGs being polled + 3 instructions
036c4 15c 14 E5 B7 F9 |                             setd    d, #polling_code        'initialize COGRAM write position
036c8 15d             | 
036c8 15d 08 18 DC FC |                             rep     @endprioloop, #8        'test all 8 priority slots
036cc 15e 03 EC 17 F4 |                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
036d0 15f F6 E3 43 F8 |                             getnib  c, pa, #0               'get cogid ID at this priority level
036d4 160 F1 EF 0B 34 |             if_nc           testb   pb, c wz                'check if already exists as priority COG
036d8 161 F1 EF 23 14 |             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
036dc 162 01 DE 07 11 |             if_nc_and_nz    add     a, #1                   'add another COG to poll 
036e0 163 B0 E3 97 19 |             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
036e4 164 00 46 BE 19 |             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
036e8 165 03 E2 07 1A |             if_nc_and_nz    mul     c, #3
036ec 166 F1 47 B2 19 |             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
036f0 167 38 E4 A7 19 |             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
036f4 168 23 01 00 16 |             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
036f8 169 04 EC 07 F0 |                             ror     pa, #4                  'advance to next priority
036fc 16a             | endprioloop
036fc 16a FF EE 67 F5 |                             xor     pb, #$ff                'invert to find all the non-priority COGs
03700 16b A0 EF 23 F5 |                             andn    pb, excludedcogs        'and remove any other excluded COGs
03704 16c F7 CD AB F7 |                             ones    rrlimit, pb wz          'count the number of RR COGs
03708 16d E6 DF 03 F1 |                             add     a, rrlimit              'account for this number of RR COGs to poll
0370c 16e 01 CC 87 F1 |                             sub     rrlimit, #1             'setup last RR count value for incmod
03710 16f 38 E4 A7 F9 |                             alti    d, #%111_000            'generate the control polling instruction
03714 170 24 01 00 F6 |                             mov     0-0, ctrlpollinst       'write the instruction
03718 171 38 E4 A7 59 |             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
0371c 172 25 01 00 56 |             if_nz           mov     0-0, skipfinst          'add the skipf instruction
03720 173 02 DE 07 51 |             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
03724 174 EF 23 B2 F9 |                             setd    polling_loop, a         'save it as the repeat count
03728 175 2D 00 64 AD |             if_z            ret                             'we are done now, if no round robin COGs
0372c 176             | 
0372c 176             | ' populate the round robin COG polling instructions
0372c 176 02 5E 07 F6 |                             mov     rrcounter, #2           'fill the RR poll instruction list twice
03730 177 F7 E1 03 F6 | rrloop                      mov     b, pb                   'get the set of RR COGs
03734 178 00 E2 07 F6 |                             mov     c, #0                   'start at COG ID = 0
03738 179 00 DE 07 F6 |                             mov     a, #0                   'req mailbox COGRAM address for COG 0
0373c 17a 01 E0 5F F0 | nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
03740 17b EF 47 B2 C9 |             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
03744 17c B0 E3 97 C9 |             if_c            alts    c, #cog0_handler        'determine jump address
03748 17d 00 46 BE C9 |             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
0374c 17e 38 E4 A7 C9 |             if_c            alti    d, #%111_000            'generate new COG RAM write address
03750 17f 23 01 00 C6 |             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
03754 180 01 E2 07 F1 |                             add     c, #1                   'increment the COG ID
03758 181 03 DE 07 F1 |                             add     a, #3                   'increase the request address
0375c 182 DC FF 9F 5D |             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
03760 183 F3 5F 6F 0B |             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
03764 184             | '..................................................................................................
03764 184             | ' Code to get/set driver settings per bank or to dump COG/LUT state
03764 184             | 
03764 184             | set_latency                                                 '            (a) set latency
03764 184             | get_latency                                                 '            (b) get latency
03764 184             | set_burst                                                   '            (c) set burst size of bank
03764 184             | get_burst                                                   '            (d) get burst size of bank
03764 184             |                                                             '            (e) dump state
03764 184 D8 E1 73 F8 |                             getnib  b, addr1, #6            ' a b c d    get bank address
03768 185 28 FE 67 FD | dump_state                  setq    #511                    ' | | | | e  prepare burst write
0376c 186 D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
03770 187             |                                                             ' | | | | e  account for following AUGS
03770 187 04 00 00 FF 
03774 188 00 B2 07 F1 |                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
03778 189 29 FE 67 FD |                             setq2   #511                    ' | | | | e  prepare burst write
0377c 18a D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
03780 18b 10 E0 07 F1 |                             add     b, #16                  ' a b | | |  point to latency params
03784 18c F0 DF A3 FA |                             rdlut   a, b                    ' a b c d |  read data for bank
03788 18d D9 DF DB F8 |                             setbyte a, hubdata, #3          ' a | | | |  patch latency
0378c 18e D9 DF 03 F6 |                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
03790 18f F0 DF 33 FC |                             wrlut   a, b                    ' a | c | |  if setting, save bank data
03794 190 EF DF FB F8 |                             getbyte a, a, #3                ' | b | | |  extract latency field only
03798 191 80 DF 67 FC |                             wrlong  a, ptrb                 ' | b | d |  write result          
0379c 192 DC FD 9F FD |                             jmp     #notify                 ' a b c d e  return success
037a0 193             | 
037a0 193             | '..................................................................................................
037a0 193             | ' Misc EXECF code
037a0 193             | 
037a0 193 33 72 63 FD | start_read_exec             execf   newburstr
037a4 194 33 7C 63 FD | start_write_exec            execf   resumewrites
037a8 195 33 78 63 FD | continue_read_exec          execf   lockedreads
037ac 196 33 7A 63 FD | continue_write_exec         execf   lockedwrites
037b0 197             | 
037b0 197             | '..................................................................................................
037b0 197             | ' Variables
037b0 197             | 
037b0 197 08 00 CF 20 | ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
037b4 198 01 00 C6 E0 | xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
037b8 199 01 00 C6 E0 | xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
037bc 19a 00 00 C0 F0 | xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
037c0 19b 00 00 C0 B0 | xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
037c4 19c 02 00 C0 70 | xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
037c8 19d             | 
037c8 19d 00 00 00 80 | xfreq1          long    $80000000
037cc 19e 00 00 00 40 | xfreq2          long    $40000000
037d0 19f 03 00 00 00 | delay           long    3
037d4 1a0             | 
037d4 1a0             | lutcodeaddr                 
037d4 1a0             | startupparams
037d4 1a0             | excludedcogs                                    'careful: shared register use!
037d4 1a0 CC 07 00 00 | frequency       long    lut_code - driver_start 'determine offset of LUT code from base
037d8 1a1 00 00 00 00 | flags           long    0
037dc 1a2             | mask                                            'careful: shared register use!
037dc 1a2 00 00 00 00 | resetmaskA      long    0
037e0 1a3             | limit                                           'careful: shared register use!
037e0 1a3 00 00 00 00 | resetmaskB      long    0
037e4 1a4 00 00 00 00 | datapins        long    0
037e8 1a5             | const512                                        'careful: shared register use!
037e8 1a5 00 00 00 00 | devicelist      long    0
037ec 1a6 00 00 00 00 | coglist         long    0
037f0 1a7 00 00 00 00 | mbox            long    0 
037f4 1a8             | 
037f4 1a8             | clkpin                                          'shared with code patched during init
037f4 1a8 A8 03 18 FC | clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
037f8 1a9             | cspin                                           'shared with code patched during init
037f8 1a9 1D 3A 63 FD | speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
037fc 1aa 00 00 01 00 | registered      long    %100_000_000_00_00000_0 'config pin for clocked input
03800 1ab 4A 00 00 00 | clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
03804 1ac 01 00 00 00 | clkdelay        long    1
03808 1ad 00 00 00 00 | regdatabus      long    0
0380c 1ae             | 
0380c 1ae 10 00 00 00 | deviceaddr      long    $10
03810 1af             | rrcounter
03810 1af 7F 7F 3F FF | pinmask         long    $ff3f7f7f
03814 1b0             | 
03814 1b0             | ' jump addresses for the per COG handlers
03814 1b0 20 00 00 00 | cog0_handler    long    cog0
03818 1b1 2C 00 00 00 | cog1_handler    long    cog1
0381c 1b2 38 00 00 00 | cog2_handler    long    cog2
03820 1b3 44 00 00 00 | cog3_handler    long    cog3
03824 1b4 50 00 00 00 | cog4_handler    long    cog4
03828 1b5 5C 00 00 00 | cog5_handler    long    cog5
0382c 1b6 68 00 00 00 | cog6_handler    long    cog6
03830 1b7 74 00 00 00 | cog7_handler    long    cog7
03834 1b8 0C 0F 00 00 | expansion       long    gfxexpansion - driver_start
03838 1b9             | 
03838 1b9             | ' EXECF sequences
03838 1b9 70 7A 80 22 | newburstr       long    (%0010001010000000011110 << 10) + r_burst
0383c 1ba 48 9B EF 00 | lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
03840 1bb 41 F3 05 74 | restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
03844 1bc 80 22 3F 00 | lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
03848 1bd 4B F3 E0 0F | lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
0384c 1be 4B 03 E0 0F | resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
03850 1bf 76 02 8A 84 | resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
03854 1c0             | 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
03854 1c0             | 
03854 1c0             | 
03854 1c0             | ' SKIPF sequences
03854 1c0             | skiptable
03854 1c0 7E 30 0C 00 |                 long    %11000011000001111110  ' read modify write byte
03858 1c1 0E 37 03 00 |                 long    %110011011100001110    ' read modify write word
0385c 1c2 00 00 00 00 |                 long    0                      ' read modify write long
03860 1c3 7E 00 00 00 |                 long    %1111110               ' single byte read
03864 1c4 8E 07 00 00 |                 long    %11110001110           ' single word read
03868 1c5 00 00 00 00 | pattern2        long    0
0386c 1c6 00 00 00 00 | pattern3        long    0
03870 1c7 77 02 00 00 | singlelong      long    %1001110111  
03874 1c8 FD 10 80 6F | skipcase_a      long    %01101111100000000001000011111101
03878 1c9 10 18 50 00 | skipcase_b      long    %00000000010100000001100000010000
0387c 1ca 11 3E 60 00 | skipcase_c      long    %00000000011000000011111000010001
03880 1cb 02 0F 00 00 | skipseq_write   long    %00000000000000000000111100000010
03884 1cc             | 
03884 1cc             | ' LUT RAM address values
03884 1cc FF 02 00 00 | complete_rw     long    complete_rw_lut
03888 1cd DD 02 00 00 | continue_read   long    continue_read_lut
0388c 1ce DB 02 00 00 | continue_write  long    continue_write_lut
03890 1cf F6 02 00 00 | noread          long    noread_lut
03894 1d0             | 
03894 1d0 00 00 00 00 | id0             long    0
03898 1d1 01 00 00 00 | id1             long    1
0389c 1d2 02 00 00 00 | id2             long    2
038a0 1d3 03 00 00 00 | id3             long    3
038a4 1d4 04 00 00 00 | id4             long    4
038a8 1d5 05 00 00 00 | id5             long    5
038ac 1d6 06 00 00 00 | id6             long    6
038b0 1d7 07 00 00 00 | id7             long    7
038b4 1d8             | 
038b4 1d8             | 'These next 10 request registers below are also temporarily reused during init 
038b4 1d8             | 'and COG updates and need to follow immediately after id0-id7
038b4 1d8 00 00 00 00 | addr1           long    0
038b8 1d9 00 00 00 00 | hubdata         long    0
038bc 1da 00 00 00 00 | count           long    0
038c0 1db 00 00 00 00 | addr2           long    0
038c4 1dc 00 00 00 00 | total           long    0
038c8 1dd 00 00 00 00 | offset1         long    0
038cc 1de 00 00 00 00 | offset2         long    0
038d0 1df 00 00 00 00 | link            long    0
038d4 1e0             | 
038d4 1e0             | burstwrite                                      'note shared register use during init
038d4 1e0 00 10 F0 FE | initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
038d8 1e1 00 00 00 00 | id              long    0
038dc 1e2             | 
038dc 1e2 00 00 00 00 | header          long    0
038e0 1e3 00 00 00 00 | trailer         long    0
038e4 1e4 00 00 00 00 | cmdaddr         long    0
038e8 1e5 00 00 00 00 | request         long    0
038ec 1e6 00 00 00 00 | rrlimit         long    0
038f0 1e7 00 00 00 00 | pinconfig       long    0
038f4 1e8 00 00 00 00 | clks            long    0
038f8 1e9 00 00 00 00 | resume          long    0
038fc 1ea 00 00 00 00 | orighubsize     long    0
03900 1eb 00 00 00 00 | wrclks          long    0
03904 1ec             | 
03904 1ec 00 00 00 00 | pattern         long    0
03908 1ed 00 00 00 00 | hubscratch      long    0
0390c 1ee 00 10 00 00 | val4k           long    4096
03910 1ef             | 
03910 1ef             | ' temporary general purpose regs
03910 1ef 00 00 00 00 | a               long    0
03914 1f0 00 00 00 00 | b               long    0
03918 1f1 00 00 00 00 | c               long    0
0391c 1f2 00 00 00 00 | d               long    0
03920 1f3             |                 fit     502
03920 1f3             | 
03920 1f3             |                 fit     502
03920 1f3             | 
03920 1f3             | '..................................................................................................
03920 1f3             | 
03920 1f3             |             orgh
03920                 | 
03920                 | lut_code
03920                 | 'HW init code up to 80 longs
03920                 | 
03920                 | '..................................................................................................
03920                 | ' Memory layout for LUT RAM once operational:
03920                 | '
03920                 | '  LUT RAM address      Usage
03920                 | '  ---------------      ----
03920                 | '    $200-$20F          Bank parameters: burst + type + size per bank (16)
03920                 | '    $210-$21F          Pin parameters : latency + control pins per bank (16)
03920                 | '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
03920                 | '    $270-$3FF          Main PSRAM access code in LUTRAM 
03920                 | '
03920                 | ' Also during driver COG startup:
03920                 | ' $230-$24F is used for HW init setup
03920                 | ' $250-$26F is used as temporary vector storage 
03920                 | '..................................................................................................
03920                 | 
03920                 |                 org $230    
03920 230             | 
03920 230             | ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
03920 230 1D 3C 63 FD | hwinit                      setxfrq xfreq2
03924 231 24 16 60 FD |                             pollxfi
03928 232 FF AA 2A FF 
0392c 233 FF ED 07 F6 |                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
03930 234 28 00 B0 FD |                             call    #sendqspi
03934 235 07 F8 07 FF 
03938 236 F0 ED 07 F6 |                             mov     pa, ##$0FF00FF0         '$66 - reset enable
0393c 237 28 00 B0 FD |                             call    #sendspi
03940 238 F8 07 78 FF 
03944 239 0F EC 07 F6 |                             mov     pa, ##$F00FF00F         '$99 - reset
03948 23a 1C 00 B0 FD |                             call    #sendspi
0394c 23b 7F 78 78 FF 
03950 23c 00 ED 07 F6 |                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
03954 23d 10 00 B0 FD |                             call    #sendspi 
03958 23e 2D 00 64 FD |                             ret
0395c 23f             | 
0395c 23f 04 D0 07 F6 | sendqspi                    mov     clks,#4
03960 240 32 0C 64 FD |                             skipf   #%110
03964 241 9C EF 03 F6 |                             mov     pb, xsendimm
03968 242             | 
03968 242 10 D0 07 F6 | sendspi                     mov     clks, #16
0396c 243 97 EF 03 F6 |                             mov     pb, ximm8lut
03970 244 58 52 63 FD |                             drvl    cspin                   'active low chip select
03974 245 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
03978 246 F6 EF A3 FC |                             xinit   pb, pa                  'send 32 bit immediate data
0397c 247 A8 D1 23 FC |                             wypin   clks, clkpin            'start memory clock output 
03980 248 24 36 60 FD |                             waitxfi                         'wait for the completion
03984 249 50 48 63 FD |                             fltl    datapins                'float data bus
03988 24a 59 52 63 FD |                             drvh    cspin                   'raise chip select
0398c 24b 1F 90 65 0D |             _ret_           waitx   #200                    'delay before return to ensure CS delay
03990 24c             | 
03990 24c 00 00 00 00 
03994 24d 00 00 00 00 
03998 24e 00 00 00 00 
0399c 24f 00 00 00 00 |                 long    0[$270-32-$]
039a0 250             |                 fit     $270-32  ' keep room for 32 vector longs
039a0 250             |     
039a0 250             |                 fit     $270-32  ' keep room for 32 vector longs
039a0 250             | ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
039a0 250             | rw_vect ' PSRAM jump vectors
039a0 250 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
039a4 251 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
039a8 252 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
039ac 253 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
039b0 254 41 E3 00 74 |                 long    (%0111010000000000111000 << 10) + w_single
039b4 255 41 93 00 74 |                 long    (%0111010000000000100100 << 10) + w_single
039b8 256 41 73 00 74 |                 long    (%0111010000000000011100 << 10) + w_single
039bc 257 47 1B 00 FE |                 long    (%1111111000000000000110 << 10) + w_burst
039c0 258             | ro_vect ' R/O PSRAM jump vectors
039c0 258 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
039c4 259 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
039c8 25a 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
039cc 25b 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
039d0 25c 00 01 00 00 |                 long    unsupported
039d4 25d 00 01 00 00 |                 long    unsupported
039d8 25e 00 01 00 00 |                 long    unsupported
039dc 25f 00 01 00 00 |                 long    unsupported
039e0 260             | ctrl_vect ' Control jump vectors
039e0 260 84 F9 39 00 |                 long    (%0000000000111001111110 << 10) + get_latency
039e4 261 00 01 00 00 |                 long    unsupported
039e8 262 84 F9 7B 00 |                 long    (%0000000001111011111110 << 10) + get_burst
039ec 263 85 01 7F 00 |                 long    (%0000000001111111000000 << 10) + dump_state
039f0 264 84 F9 D1 00 |                 long    (%0000000011010001111110 << 10) + set_latency
039f4 265 00 01 00 00 |                 long    unsupported
039f8 266 84 F9 CB 00 |                 long    (%0000000011001011111110 << 10) + set_burst
039fc 267 3E 01 00 00 |                 long    reconfig 
03a00 268             | no_vect ' Invalid bank jump vectors
03a00 268 01 01 00 00 |                 long    invalidbank
03a04 269 01 01 00 00 |                 long    invalidbank
03a08 26a 01 01 00 00 |                 long    invalidbank
03a0c 26b 01 01 00 00 |                 long    invalidbank
03a10 26c 01 01 00 00 |                 long    invalidbank
03a14 26d 01 01 00 00 |                 long    invalidbank
03a18 26e 01 01 00 00 |                 long    invalidbank
03a1c 26f 01 01 00 00 |                 long    invalidbank
03a20 270             |                 fit     $270
03a20 270             | 
03a20 270             |                 fit     $270
03a20 270             | '..................................................................................................
03a20 270             | ' PSRAM READS
03a20 270             |                                                             ' a b c d e f
03a20 270             |                                                             ' B W L B R L  (a) byte read
03a20 270             |                                                             ' Y O O U E O  (b) word read
03a20 270             |                                                             ' T R N R S C  (c) long read
03a20 270             |                                                             ' E D G S U K  (d) new burst read
03a20 270             |                                                             '       T M E  (e) resumed sub-burst
03a20 270             |                                                             '         E D  (f) locked sub-burst
03a20 270             | 
03a20 270             | 
03a20 270 DA D5 03 F6 | r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
03a24 271 DA B5 CB F7 | r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
03a28 272 36 D9 07 F6 |                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
03a2c 273 20 D9 27 A5 |             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
03a30 274 02 34 27 F9 |                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
03a34 275 80 B4 97 FB |                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
03a38 276 E5 E1 43 F8 | r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
03a3c 277 F0 E1 A3 FA |                             rdlut   b, b                    ' a b c d e    get bank limit/mask
03a40 278 F0 45 CB F9 |                             bmask   mask, b                 ' | | | d e    build mask for addr
03a44 279 F0 3F EB F8 |                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
03a48 27a 11 E0 47 F0 | p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
03a4c 27b F0 47 23 F3 |                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
03a50 27c 05 3E 57 F0 |                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
03a54 27d 10 5A 67 04 |             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
03a58 27e 10 5A 67 F4 |                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
03a5c 27f F9 3B 83 FC |                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
03a60 280 D9 3B 83 FC | r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
03a64 281 DA E3 03 F6 |                             mov     c, count                ' | | | d e f  get count of bytes left to read
03a68 282 A3 E3 33 F3 |                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
03a6c 283 20 D0 17 F6 |                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
03a70 284 CD D3 03 C6 |             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
03a74 285 CC D3 03 36 |             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
03a78 286 32 20 64 FD |                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
03a7c 287 E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
03a80 288 AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
03a84 289 E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
03a88 28a E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
03a8c 28b 54 00 90 FD |                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
03a90 28c             | 
03a90 28c             |                             ' fall through to read bursts
03a90 28c             |                         
03a90 28c             | burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
03a90 28c D8 E5 03 F6 |                             mov     d, addr1                'get start address
03a94 28d 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
03a98 28e EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
03a9c 28f F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
03aa0 290 CD D3 03 C6 |             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
03aa4 291 00 D8 07 F6 |                             mov     pattern, #0             'enable all by default
03aa8 292 01 B0 17 F4 |                             testb   addr1, #1 wc            'test if start addr starts in second word
03aac 293 01 D8 67 F4 |                             bitnc   pattern, #1             'enable delay cycle if so
03ab0 294 6C D0 63 FD |                             wrc     clks                    'and account for its clock cycle
03ab4 295 00 B0 17 F4 |                             testb   addr1, #0 wc            'test if start addr starts on odd byte
03ab8 296 02 D8 67 F4 |                             bitnc   pattern, #2             'add hi 8 transfer initially
03abc 297 F1 E5 03 F6 |                             mov     d, c                    'get count of bytes to be read into HUB
03ac0 298 01 E4 87 C1 |             if_c            sub     d, #1                   'minus 1 if start addr was odd
03ac4 299 01 E4 4F F0 |                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
03ac8 29a F2 D1 23 F1 |                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
03acc 29b F2 35 23 F9 |                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
03ad0 29c 03 D8 87 F4 |                             bitz    pattern, #3             'adjust the pattern to include this
03ad4 29d 00 E2 D7 F4 |                             testb   c, #0 xorc              'test for end address
03ad8 29e 04 D8 67 F4 |                             bitnc   pattern, #4             'include low 8 bit transfer if required
03adc 29f 0E D0 27 F1 |                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
03ae0 2a0 E8 D1 03 F1 |                             add     clks, clks
03ae4 2a1             | readcommon
03ae4 2a1 D8 C9 03 F6 |                             mov     cmdaddr, addr1          'get start address of transfer
03ae8 2a2 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
03aec 2a3 EB C8 DF F8 |                             setbyte cmdaddr, #$EB, #3       'add quad read command
03af0 2a4             | 
03af0 2a4 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
03af4 2a5 69 C8 63 FD |                             rev     cmdaddr
03af8 2a6 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
03afc 2a7 61 C8 63 FD |                             mergeb  cmdaddr
03b00 2a8             | 
03b00 2a8 58 52 63 FD |                             drvl    cspin                   'activate chip select
03b04 2a9 58 48 63 FD |                             drvl    datapins                'enable data bus
03b08 2aa             |             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
03b08 2aa E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'stream out command+address
03b0c 2ab A8 D1 23 FC |                             wypin   clks, clkpin            'start clock output
03b10 2ac 00 00 CC FC |                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
03b14 2ad 00 0C CC FC |                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
03b18 2ae             |                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
03b18 2ae 50 48 63 FD |                             fltl    datapins                'safe to float the data bus, address has been sent by now
03b1c 2af A4 5B 03 FC |                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
03b20 2b0 28 3A 63 FD |                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
03b24 2b1 00 3E C7 FC |                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
03b28 2b2 00 0C CC FC |                             xcont   #6, #0                  'fixed delay offset to expand delay range
03b2c 2b3 32 D8 63 FD |                             skipf   pattern                 'choose path below
03b30 2b4             |                                                             'Bursts Bytes Words Longs  RMW FromWrites
03b30 2b4 28 3C 63 FD |                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
03b34 2b5 00 02 CC FC |                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
03b38 2b6 00 32 C7 FC |                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
03b3c 2b7 00 34 C7 FC |                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
03b40 2b8 00 30 C7 FC |                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
03b44 2b9 2D D2 63 FD |                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
03b48 2ba 24 36 60 FD |                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
03b4c 2bb A4 55 03 FC |                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
03b50 2bc 59 52 63 0D |             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
03b54 2bd 59 52 63 FD |                             drvh    cspin                   '         b     c           e       deassert chip select and continue
03b58 2be E5 E5 4B F8 |                             getnib  d, request, #1          'get request code value
03b5c 2bf 03 E4 87 51 |             if_nz           sub     d, #3                   'offset for table if RMW
03b60 2c0 BB E5 8F F9 |                             altd    d, #skiptable-5         'patch next instruction
03b64 2c1 32 00 60 FD |                             skipf   0-0                     'generate skip sequence
03b68 2c2             |                                                             ' B   W  RMWB RMWW RMLL 
03b68 2c2 80 DF 07 FB |                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
03b6c 2c3 28 B4 63 FD |                             setq    count                   ' |   |   |    |    e   setup bit mux mask
03b70 2c4 D9 DF F3 F9 |                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
03b74 2c5 40 00 90 FD |                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
03b78 2c6 01 B0 17 F4 |                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
03b7c 2c7 EF EF 3B C9 |             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
03b80 2c8 EF EF 33 39 |             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
03b84 2c9 D8 E5 03 F6 |                             mov     d, addr1                ' a   |   c    d
03b88 2ca 03 E4 07 F5 |                             and     d, #3                   ' a   |   c    |        get LSBs of address
03b8c 2cb EF E5 6F F9 |                             altgb   d, #a                   ' a   |   c    |        index into long
03b90 2cc 00 EE E3 F8 |                             getbyte pb                      ' a   |   c    |        and extract the byte
03b94 2cd 80 EF 67 FC |                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
03b98 2ce C0 00 B0 FD |                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
03b9c 2cf 2D 00 64 FD |                             ret                             ' a   b   |    |        then return
03ba0 2d0 28 B4 63 FD |                             setq    count                   '         c    d        setup bit mux mask
03ba4 2d1 D9 EF F3 F9 |                             muxq    pb, hubdata             '         c    d        apply bit mux
03ba8 2d2 EF E5 67 F9 |                             altsb   d, #a                   '         c    |
03bac 2d3 F7 01 C0 F8 |                             setbyte 0-0, pb, #0             '         c    |
03bb0 2d4 F7 DF 2B C9 |             if_c            setword a, pb, #1               '         |    d
03bb4 2d5 F7 DF 23 39 |             if_nc           setword a, pb, #0               '         |    d
03bb8 2d6 37 8A 07 F6 | writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
03bbc 2d7 EF B3 03 F6 |                             mov     hubdata, a              'write a to PSRAM
03bc0 2d8 14 D6 07 F6 |                             mov     wrclks, #20             '20 clocks to write a long
03bc4 2d9 CC D3 03 F6 |                             mov     resume, complete_rw     'we'll complete the operation after this
03bc8 2da 10 03 90 FD |                             jmp     #writecommon
03bcc 2db             | 
03bcc 2db             | '..................................................................................................
03bcc 2db             | ' Burst continuation testing
03bcc 2db             | 
03bcc 2db 32 96 63 FD | continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
03bd0 2dc BE D3 03 F6 |                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
03bd4 2dd             | continue_read_lut          
03bd4 2dd BF D3 03 F6 |                             mov     resume, resumereads     ' | setup resume address to execf
03bd8 2de F1 B3 03 F1 |                             add     hubdata, c              ' a compute the next hub addr to use
03bdc 2df F1 B5 83 F1 |                             sub     count, c                ' a account for the bytes already sent
03be0 2e0 D8 E3 03 F1 |                             add     c, addr1                ' a compute next external mem address
03be4 2e1 28 44 63 FD |                             setq    mask                    ' a configure mask for bit muxing
03be8 2e2 F1 B1 F3 F9 |                             muxq    addr1, c                ' a perform address bit muxing
03bec 2e3 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
03bf0 2e4 14 00 90 5D |             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
03bf4 2e5 E1 47 3B F9 |                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
03bf8 2e6 F0 47 23 F3 |                             fle     limit, b                ' | also re-apply per bank limit
03bfc 2e7 2A 2A 67 0D |             _ret_           push    #continue_read_exec     ' | 
03c00 2e8 04 00 90 5D |             if_nz           jmp     #yield                  ' a
03c04 2e9 2A 2C 67 0D |             _ret_           push    #continue_write_exec    ' a
03c08 2ea             | 
03c08 2ea 04 B9 37 FC | yield                       wrlut   total, ptra[4]          'save context for next time
03c0c 2eb 05 BB 37 FC |                             wrlut   offset1, ptra[5]        'save context for next time
03c10 2ec 06 BD 37 FC |                             wrlut   offset2, ptra[6]        'save context for next time
03c14 2ed 07 BF 37 FC |                             wrlut   link, ptra[7]           'save context for next time
03c18 2ee 00 B1 37 FC | yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
03c1c 2ef 01 B3 37 FC |                             wrlut   hubdata, ptra[1]        'save context for next time
03c20 2f0 02 B5 37 FC |                             wrlut   count, ptra[2]          'save context for next time
03c24 2f1 03 B7 37 FC |                             wrlut   addr2, ptra[3]          'save context for next time
03c28 2f2 08 D3 37 FC |                             wrlut   resume, ptra[8]         'save next resume address
03c2c 2f3 09 D5 37 FC |                             wrlut   orighubsize, ptra[9]    'save original hub size
03c30 2f4 2A 1C 66 0D |             _ret_           push    #poller
03c34 2f5             | 
03c34 2f5             | 
03c34 2f5 32 BE 65 FD | notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
03c38 2f6             | nowrite_lut                                                 '  (a) new skip sequence 
03c38 2f6 32 00 64 FD | noread_lut                  skipf   #0                      ' | cancel skipping
03c3c 2f7 08 01 3C FC |                             wrlut   #0, ptra[8]             ' | clear resume
03c40 2f8 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
03c44 2f9 40 F8 9F 5D |             if_nz           jmp     #notify                 ' | if not a request list then we are done
03c48 2fa 1F B6 0F F4 |                             testb   addr2, #31 wz           ' | check if extended list item
03c4c 2fb DF B7 03 A6 | donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
03c50 2fc 1C 00 B0 FD | checklist                   call    #checknext              ' | handle running from list
03c54 2fd 2D 00 64 FD |                             ret                             ' | continue processing
03c58 2fe 2A 9E 63 0D |             _ret_           push    noread                  'continue end of transfer
03c5c 2ff             | '..................................................................................................
03c5c 2ff             | ' Completion of requests
03c5c 2ff             | 
03c5c 2ff             | complete_rw_lut             
03c5c 2ff 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        'test for running from a request list   
03c60 300 32 04 64 AD |             if_z            skipf   #%10                    'if a request list then skip notification
03c64 301 08 01 3C FC |                             wrlut   #0, ptra[8]             ' a   default is not to resume
03c68 302 2A 14 66 0D |             _ret_           push    #notify                 ' |   if not a request list then we are done
03c6c 303 0D B6 B7 FB |                             tjs     addr2, #extendedreq     '     test for special extended request  
03c70 304 07 B6 97 FB | checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
03c74 305 BF ED 07 FB |                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
03c78 306 05 EC BF FB |                             tjns    pa, #listcomplete       'exit if it has
03c7c 307 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz
03c80 308 DB B3 03 A6 |             if_z            mov     hubdata, addr2
03c84 309 32 62 64 AD |             if_z            skipf   #%110001
03c88 30a 32 10 64 5D |             if_nz           skipf   #%1000                  'do not notify if list is continuing
03c8c 30b 80 B7 67 FC |                             wrlong  addr2, ptrb             ' a  write back next list address
03c90 30c D0 C3 8F F9 | listcomplete                altd    id, #id0                ' a  compute COG's state address
03c94 30d 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
03c98 30e 2A 14 66 0D |             _ret_           push    #notify                 ' |  we are done with the list
03c9c 30f 2A 1C 66 0D |             _ret_           push    #poller                 ' a  we are still continuing the list
03ca0 310 2A 50 66 0D |             _ret_           push    #real_list              ' a  we are still continuing the list
03ca4 311 E3 B5 97 FB | extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
03ca8 312 DB DF 7B F8 |                             getnib  a, addr2, #7            'check the request type
03cac 313 0F DE 0F F2 |                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
03cb0 314 D8 DF 73 F8 |                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
03cb4 315 32 90 63 5D |             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
03cb8 316             |                                                             ' skipcase (a) gfx copy to/from hub
03cb8 316             |                                                             ' skipcase (b) gfx copy extmem bank to bank
03cb8 316             |                                                             ' skipcase (c) linear copy extmem bank to bank
03cb8 316 DB DF 73 F8 |                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
03cbc 317 EF E5 AB FA |                             rdlut   d, a wz                 ' a      load bank information and check if valid
03cc0 318 31 02 64 5D |             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
03cc4 319 2A 02 66 0D |             _ret_           push    #invalidbank            ' |      otherwise bail out after this
03cc8 31a DD BB CB F7 |                             test    offset1 wz              ' |      check for first offset being zero
03ccc 31b DE BD CB A7 |             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
03cd0 31c 32 94 63 AD |             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
03cd4 31d 32 92 63 FD |                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
03cd8 31e F1 B3 03 F1 |                             add     hubdata, c              ' a b c  add bytes just sent to hub address
03cdc 31f EA B3 83 F1 |                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
03ce0 320 D8 E3 03 F1 |                             add     c, addr1                ' a b c  compute next address to use
03ce4 321 DC B9 CB F7 |                             test    total wz                ' a b |  check for zero tranfers
03ce8 322 DC D5 2B F3 |                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
03cec 323 44 FF 9F AD |             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
03cf0 324 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a b c  check if reading/writing
03cf4 325 EA B5 03 F6 |                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
03cf8 326 EA E3 83 F1 |                             sub     c, orighubsize          ' a b |  rewind to original position
03cfc 327 DD E3 03 A1 |             if_z            add     c, offset1              ' a b |  add any dst scanline offset
03d00 328 DE E3 03 51 |             if_nz           add     c, offset2              ' a b |  add any src scanline offset
03d04 329 DE B3 03 A1 |             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
03d08 32a DD B3 03 51 |             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
03d0c 32b 28 44 63 FD |                             setq    mask                    ' a b c  configure mask for bit muxing
03d10 32c F1 B1 F3 F9 |                             muxq    addr1, c                ' a b c  perform address bit muxing
03d14 32d D8 DF 03 F6 |                             mov     a, addr1                ' | b c  ]
03d18 32e DB B1 03 F6 |                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
03d1c 32f EF B7 03 F6 |                             mov     addr2, a                ' | b c  ]
03d20 330 1E B0 A7 F4 |                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
03d24 331 0F B6 3F F8 |                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
03d28 332 01 B8 8F F1 |                             sub     total, #1 wz            ' a | |  decrement scanline count
03d2c 333 01 B8 8F A1 |             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
03d30 334 EA B9 8B A1 |             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
03d34 335 DF B7 03 A6 |             if_z            mov     addr2, link
03d38 336 34 FF 9F AD |             if_z            jmp     #checknext
03d3c 337 D8 CB FB F8 | moretransfers               getbyte request, addr1, #3      'prepare next request
03d40 338 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
03d44 339 32 1C 64 AD |             if_z            skipf   #%1110                  '     skip some code if we are locked
03d48 33a 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a   test if will be reading or writing
03d4c 33b BE D3 03 A6 |             if_z            mov     resume, resumewrites    ' |   resume burst writing
03d50 33c B9 D3 03 56 |             if_nz           mov     resume, newburstr       ' |   resume burst reading
03d54 33d B0 FE 9F FD |                             jmp     #yield                  ' |   yield to poller
03d58 33e 31 02 64 AD |             if_z            skip    #%1                     '     skip next instruction for writing case
03d5c 33f 2A 26 67 0D |             _ret_           push    #start_read_exec        '(|)  do new read burst next 
03d60 340 2A 28 67 0D |             _ret_           push    #start_write_exec       'do new write burst next
03d64 341             | 
03d64 341             | '..................................................................................................
03d64 341             | ' PSRAM WRITES
03d64 341             |                                                             '  a b c d e f g h
03d64 341             | 
03d64 341             |                                                             '  B W L F B R L L (a) byte write(s)
03d64 341             |                                                             '  Y O O I U E O O (b) word write(s)
03d64 341             |                                                             '  T R N L R S C C (c) long write(s)
03d64 341             |                                                             '  E D G L S U K K (d) resumed fill
03d64 341             |                                                             '          T M E E (e) new burst write
03d64 341             |                                                             '            E D D (f) resumed burst
03d64 341             |                                                             '              F B (g) locked fill
03d64 341             |                                                             '              I U (h) locked burst write
03d64 341             |                                                             '              L R 
03d64 341             |                                                             '              L S 
03d64 341             |                                                             '                T 
03d64 341             | 
03d64 341             | w_single                   
03d64 341             | w_fill_cont           
03d64 341 D8 DF 7B F8 |                             getnib  a, addr1, #7            '  a b c d          obtain request
03d68 342 03 DE 07 F5 |                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
03d6c 343 00 B2 FF F9 |                             movbyts hubdata, #0             '  a | | |          replicate byte across long
03d70 344 44 B2 FF F9 |                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
03d74 345 01 B0 27 F5 |                             andn    addr1, #1               '  | b | |          align word addresses
03d78 346 03 B0 27 F5 |                             andn    addr1, #3               '  | | c |          align long addresses
03d7c 347 DA D5 03 F6 | w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
03d80 348 01 B4 0F F2 | w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
03d84 349 EF B5 63 F0 |                             shl     count, a                '  a b c | |   |    scale into bytes
03d88 34a AB B5 97 FB |                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
03d8c 34b DA E3 03 F6 | w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
03d90 34c 76 02 A0 FD |                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
03d94 34d             |                ' disable call to r_resume_burst for single longs when z=0
03d94 34d E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
03d98 34e AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
03d9c 34f E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
03da0 350 E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
03da4 351 3F 8A 0F F6 |                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
03da8 352 A3 E3 33 F3 |                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
03dac 353 CE D3 03 C6 |             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
03db0 354 CC D3 03 36 |             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
03db4 355 D9 DF 03 F6 |                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
03db8 356 14 D6 07 F6 |                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
03dbc 357 01 DE 17 F4 |                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
03dc0 358 C7 8B 03 F6 |                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
03dc4 359 14 01 90 8D |             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
03dc8 35a 09 8A 67 25 |             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
03dcc 35b 5C 00 90 2D |             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
03dd0 35c 0F 8A 07 F6 |                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
03dd4 35d             |         
03dd4 35d             |             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
03dd4 35d             |             '
03dd4 35d             |             '  At least one of these 3 optional components will be sent
03dd4 35d             |             '     header - first partial long of data, gets aligned to PSRAM long boundary
03dd4 35d             |             '     body - N x full longs of data
03dd4 35d             |             '     trailer - last partial long of data
03dd4 35d             |             '
03dd4 35d             |             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
03dd4 35d             |             '
03dd4 35d             |             'Case    Type                           Sends
03dd4 35d             |             ' 1)     Single byte/word write         header only (takes its own optimized path)
03dd4 35d             |             ' 2)     Single long write              body only (takes its own optimized path)
03dd4 35d             |             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
03dd4 35d             |             ' 4)     Multiple long fill             body only
03dd4 35d             |             ' 5)     Burst write                    optional header, optional body, optional trailer
03dd4 35d             | 
03dd4 35d             |                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
03dd4 35d D8 E5 03 F6 |                             mov     d, addr1                'get start address
03dd8 35e 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
03ddc 35f EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
03de0 360 F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
03de4 361 CE D3 03 C6 |             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
03de8 362 13 8C 07 F6 |                             mov     pattern3, #%10011
03dec 363 D8 E5 03 F6 |                             mov     d, addr1                'get start address position 
03df0 364 03 E4 0F F5 |                             and     d, #3 wz                'get alignment
03df4 365 04 E2 17 F2 |                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
03df8 366 10 D6 07 F6 |                             mov     wrclks, #16             'clocks needed for address phase
03dfc 367 F1 EF 03 F6 |                             mov     pb, c                   'get number of bytes to send
03e00 368 F2 EF 03 F1 |                             add     pb, d                   'and increase total to send, including initial re-alignment
03e04 369 40 00 90 2D |             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
03e08 36a             |                             
03e08 36a F0 CA 17 F2 |                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
03e0c 36b 32 3C 64 CD |             if_c            skipf   #%11110                 'if fill skip burst write stuff
03e10 36c 04 D6 07 F1 |                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
03e14 36d F2 DF 83 F1 |                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
03e18 36e EF E5 03 FB |                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
03e1c 36f 04 DE 07 F1 |                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
03e20 370 32 08 64 FD |                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
03e24 371 04 EE 9F F1 |                             sub     pb, #4 wcz              ' subtract a long from the total
03e28 372 00 8A 07 F4 |                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
03e2c 373 D9 E5 03 F6 | single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
03e30 374 88 01 B0 FD |                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
03e34 375 5A B0 47 FB |                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
03e38 376 ED C5 03 FB |                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
03e3c 377 28 EC 63 FD |                             setq    pa                      ' setup byte mux mask
03e40 378 F2 C5 F3 F9 |                             muxq    header, d               ' copy bytes into long
03e44 379 94 00 90 ED |             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
03e48 37a             | 
03e48 37a F0 CA 17 F2 | header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
03e4c 37b F7 E5 03 F6 |                             mov     d, pb                   'preserve the count
03e50 37c 03 EE 2F F5 |                             andn    pb, #3 wz               'determine the number of full long bytes left to send
03e54 37d 07 EE 97 FB |                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
03e58 37e             |                  
03e58 37e F7 D7 03 F1 |                             add     wrclks, pb              'include this number of bytes as more clock transitions
03e5c 37f 32 14 64 CD |             if_c            skipf   #%1010                 'for fills we can skip burst stuff
03e60 380 0C 8A 27 C5 |             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
03e64 381 01 8A 07 F4 |                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
03e68 382 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute word count for bursts
03e6c 383 F7 37 23 F9 |                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
03e70 384 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
03e74 385             | 
03e74 385 03 E4 07 F5 | body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
03e78 386 17 E4 97 FB |                             tjz     d, #trailer_done        'no trailer to send, we exit now
03e7c 387 DA E3 0B C2 |             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
03e80 388 CC D3 0B 32 |             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
03e84 389 F2 E3 83 51 |             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
03e88 38a 4C 00 90 5D |             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
03e8c 38b             | 
03e8c 38b             |                             'we have 1-3 more aligned residual bytes left to send as the trailer
03e8c 38b F0 E5 47 F5 |                             or      d, #$1f0                'setup mux mask address
03e90 38c F2 ED A3 FA |                             rdlut   pa, d                   'read mux mask for this length at offset 0
03e94 38d 2A B0 63 FD |                             push    addr1                   'save address
03e98 38e             | 
03e98 38e             | ' use this code (note: foldover can occur here in PSRAM bank)
03e98 38e F1 B1 03 F1 |                             add     addr1, c                'find last long address in PSRAM
03e9c 38f 01 B0 87 F1 |                             sub     addr1, #1               '..to be rewritten
03ea0 390 18 01 B0 FD |                             call    #readlong               'read data from this external address
03ea4 391             |             
03ea4 391 D9 E5 03 C6 |             if_c            mov     d, hubdata              'get data to be sent for fills
03ea8 392 32 3C 64 CD |             if_c            skipf   #%11110                 'skip burst code for fills
03eac 393 2B B0 63 FD |                             pop     addr1                   'restore address
03eb0 394 F7 E5 03 F6 |                             mov     d, pb                   ' | get number of full longs that were sent
03eb4 395 02 E4 67 F0 |                             shl     d, #2                   ' | convert to bytes
03eb8 396 EF E5 03 F1 |                             add     d, a                    ' | add to start adress of longs to stream
03ebc 397 F2 E5 03 FB |                             rdlong  d, d                    ' | read this last long from HUB RAM
03ec0 398             | 
03ec0 398 ED C7 03 FB |                             rdlong  trailer, hubscratch     'read external RAM data value
03ec4 399 28 EC 63 FD |                             setq    pa                      'setup byte mask
03ec8 39a F2 C7 F3 F9 |                             muxq    trailer, d              'apply byte mask to data via muxq
03ecc 39b 04 D6 07 F1 |                             add     wrclks, #4              'increase by 4 more clocks
03ed0 39c 05 8A 07 F4 |                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
03ed4 39d 00 8C 07 F4 |                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
03ed8 39e             | 
03ed8 39e             |                             'trailer is done
03ed8 39e EF 3B 73 FC | trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
03edc 39f             | 
03edc 39f D8 C9 03 F6 | writecommon                 mov     cmdaddr, addr1          'get start address of transfer
03ee0 3a0 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
03ee4 3a1 02 C8 DF F8 |                             setbyte cmdaddr, #$02, #3       'add quad write command
03ee8 3a2             | 
03ee8 3a2 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
03eec 3a3 69 C8 63 FD |                             rev     cmdaddr                 
03ef0 3a4 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
03ef4 3a5 61 C8 63 FD |                             mergeb  cmdaddr
03ef8 3a6             |                             
03ef8 3a6 58 52 63 FD |                             drvl    cspin                   'activate chip select
03efc 3a7 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
03f00 3a8 E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
03f04 3a9 A8 D7 23 FC |                             wypin   wrclks, clkpin          'start memory clock output 
03f08 3aa             |                                                          
03f08 3aa 32 8A 63 FD |                             skipf   pattern2                '   B W L Burst FB FW FL RMW
03f0c 3ab E2 39 C3 FC |                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
03f10 3ac 00 36 C7 FC |                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
03f14 3ad F7 03 D8 FC |                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
03f18 3ae D9 39 C3 FC |                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
03f1c 3af 32 8C 63 FD |                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
03f20 3b0 E3 39 C3 FC |                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
03f24 3b1 2D D2 63 FD |                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
03f28 3b2 24 36 60 FD |                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
03f2c 3b3 50 48 63 FD |                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
03f30 3b4 59 52 63 0D |             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
03f34 3b5             |  
03f34 3b5 59 52 63 FD |                             drvh    cspin
03f38 3b6 09 C2 17 F4 | check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
03f3c 3b7 F1 B5 8B F1 |                             sub     count, c wz             'account for bytes written
03f40 3b8 34 00 90 5D |             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
03f44 3b9 08 01 3C FC |                             wrlut   #0, ptra[8]             'default is not to resume
03f48 3ba 3C F5 9F 3D |             if_nc           jmp     #notify                 'if not a request list then we are done
03f4c 3bb 40 B7 BF FB |                             tjns    addr2, #checklist       'if not extended, check next list entry
03f50 3bc 3E B9 67 FB |                             djz     total, #donerepeats     'check for repeats remaining
03f54 3bd B8 B9 B3 FB |                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
03f58 3be EA E5 03 F6 |                             mov     d, orighubsize
03f5c 3bf EF E5 63 F0 |                             shl     d, a
03f60 3c0 F2 E3 83 F1 |                             sub     c, d
03f64 3c1 DD E3 03 F1 |                             add     c, offset1
03f68 3c2 F2 B5 03 F6 |                             mov     count, d                'restore original count
03f6c 3c3 E5 E1 43 F8 | readmask                    getnib  b, request, #0          'get bank parameter LUT address
03f70 3c4 F0 E1 A3 FA |                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
03f74 3c5 F0 45 CB F9 |                             bmask   mask, b                 'build mask for addr (in case count=1)
03f78 3c6 D8 E3 03 F1 | continue_fill               add     c, addr1                'add bytes to destination address
03f7c 3c7 28 44 63 FD |                             setq    mask                    'setup bit mask
03f80 3c8 F1 B1 F3 F9 |                             muxq    addr1, c                'setup new external memory address
03f84 3c9 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
03f88 3ca 33 74 63 AD |             if_z            execf   lockedfill              'continue next fill operation
03f8c 3cb BB D3 03 F6 |                             mov     resume, restorefill
03f90 3cc 00 B6 07 36 |             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
03f94 3cd 80 FC BF 3D |             if_nc           call    #yieldfill              'we have to yield now to other COGs
03f98 3ce 6C FC BF CD |             if_c            call    #yield
03f9c 3cf 2D 00 64 FD |                             ret
03fa0 3d0             |                            
03fa0 3d0             | getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
03fa0 3d0             |                       '     rczl    pa                      'rotate left into address offset
03fa0 3d0             |                       '     rczl    c wcz                   'restore count and flags
03fa0 3d0 03 E2 EF F7 |                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
03fa4 3d1 02 EC 67 F0 |                             shl     pa, #2
03fa8 3d2 28 06 64 AD |             if_z            setq    #3
03fac 3d3 F1 ED F3 A9 |             if_z            muxq    pa, c
03fb0 3d4 F0 ED 47 F5 |                             or      pa, #$1f0               'setup LUT address offset
03fb4 3d5 F6 ED A3 FA |            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
03fb8 3d6 2D 00 7C FD |                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
03fbc 3d7             | 
03fbc 3d7 ED 3B 83 FC | readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
03fc0 3d8 02 34 27 F9 |                             setword xrecvdata, #2, #0       'read 2x16 words
03fc4 3d9 20 D0 07 F6 |                             mov     clks, #32               '32 read clock transitions
03fc8 3da 36 D8 07 F6 |                             mov     pattern, #%110110       'setup read skip pattern
03fcc 3db 14 FB 9F FD |                             jmp     #readcommon             'read then return directly to caller
03fd0 3dc             |                 fit 1024-32
03fd0 3dc             |         
03fd0 3dc             | 
03fd0 3dc             | '..................................................................................................
03fd0 3dc             | 
03fd0 3dc             |                 fit 1024-32
03fd0 3dc 00 00 00 00 
03fd4 3dd 00 00 00 00 
03fd8 3de 00 00 00 00 
03fdc 3df 00 00 00 00 |                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
03fe0 3e0             |                 org 1024-32
03fe0 000             | 
03fe0 000             | ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
03fe0 000 00 00 00 00 |                 long $0000
03fe4 001 11 11 00 00 |                 long $1111
03fe8 002 22 22 00 00 |                 long $2222
03fec 003 33 33 00 00 |                 long $3333
03ff0 004 44 44 00 00 |                 long $4444
03ff4 005 55 55 00 00 |                 long $5555
03ff8 006 66 66 00 00 |                 long $6666
03ffc 007 77 77 00 00 |                 long $7777
04000 008 88 88 00 00 |                 long $8888
04004 009 99 99 00 00 |                 long $9999
04008 00a AA AA 00 00 |                 long $aaaa
0400c 00b BB BB 00 00 |                 long $bbbb
04010 00c CC CC 00 00 |                 long $cccc
04014 00d DD DD 00 00 |                 long $dddd
04018 00e EE EE 00 00 |                 long $eeee
0401c 00f FF FF 00 00 |                 long $ffff
04020 010             | 
04020 010             | 'masks
04020 010 FF FF FF FF |                 long $ffffffff ' 00 aligned 0/4 length
04024 011 FF 00 00 00 |                 long $000000ff ' 00 aligned 1 length
04028 012 FF FF 00 00 |                 long $0000ffff ' 00 aligned 2 length
0402c 013 FF FF FF 00 |                 long $00ffffff ' 00 aligned 3 length
04030 014             | 
04030 014 00 FF FF FF |                 long $ffffff00 ' 01 aligned 0/4 length
04034 015 00 FF 00 00 |                 long $0000ff00 ' 01 aligned 1 length
04038 016 00 FF FF 00 |                 long $00ffff00 ' 01 aligned 2 length
0403c 017 00 FF FF FF |                 long $ffffff00 ' 01 aligned 3 length
04040 018             | 
04040 018 00 00 FF FF |                 long $ffff0000 ' 10 aligned 0/4 length
04044 019 00 00 FF 00 |                 long $00ff0000 ' 10 aligned 1 length
04048 01a 00 00 FF FF |                 long $ffff0000 ' 10 aligned 2 length
0404c 01b 00 00 FF FF |                 long $ffff0000 ' 10 aligned 3 length
04050 01c             | 
04050 01c 00 00 00 FF |                 long $ff000000 ' 11 aligned 0/4 length
04054 01d 00 00 00 FF |                 long $ff000000 ' 11 aligned 1 length
04058 01e 00 00 00 FF |                 long $ff000000 ' 11 aligned 2 length
0405c 01f 00 00 00 FF |                 long $ff000000 ' 11 aligned 3 length
04060 020             |         fit 1024
04060 020             | 
04060 020             |         fit 1024
04060 020             | 
04060 020             | '--------------------------------------------------------------------------------------------------
04060 020             |         orgh
04060                 | 
04060                 | gfxexpansion
04060                 |                             'simple line drawing graphics expansion of memory driver
04060                 |                             'jmp     #donerepeats                'just return for now
04060                 | 
04060     DB B1 0B F2 |                             cmp     addr1, addr2 wz         'see if we've reached the end
04064     FB 02 80 AD |             if_z            jmp     #donerepeats            'nothing more to draw
04068     01 B8 07 F1 |                             add     total, #1               'restore total after decrement
0406c     DD E1 03 F6 |                             mov     b, offset1              'get error term
04070     01 E0 67 F0 |                             shl     b, #1                   'compute e2 = 2 x error
04074     DE E5 33 F9 |                             getword d, offset2, #0          'get dx = abs(x0-x1)
04078     10 BC C7 F0 |                             sar     offset2, #16            'get dy = -abs(y0-y1)
0407c     DE E1 53 F2 |                             cmps    b, offset2 wc           'compare if e2 >= dy
04080     00 E2 07 F6 |                             mov     c, #0                   'clear accumulator reg
04084     31 1C 64 CD |             if_c            skip    #%1110                  'if not, skip
04088     EF DF C3 F9 |                             decod   a                       'decode as 1,2,or 4 byte size
0408c     DE BB 03 F1 |                             add     offset1, offset2        'err+=dy 
04090     10 B8 0F F4 |                             testb   total, #16 wz           'check sign sx   
04094     EF E3 C3 F3 |                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
04098     F0 E5 53 F2 |                             cmps    d, b wc                 'compare if e2 <= dx
0409c     31 3C 64 CD |             if_c            skip    #%11110                 'if not, skip
040a0     F2 BD 43 F9 |                             rolword offset2, d, #0          'restore offset
040a4     F2 BB 03 F1 |                             add     offset1, d              'err+=dx
040a8     11 B8 0F F4 |                             testb   total, #17 wz           'check sign sy
040ac     DC E5 33 F9 |                             getword d, total, #0            'get line width
040b0     F2 E3 C3 F3 |                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
040b4     EF DF 93 F7 |                             encod   a wc                    'restore size and set carry
040b8     EA B5 03 F6 |                             mov     count, orighubsize      'reset the fill width
040bc     EF B5 63 F0 |                             shl     count, a                '..for the type of transfer
040c0     C3 03 80 FD |                             jmp     #readmask               'continue filling
040c4                 | 	alignl
040c4                 | __system__dat_
040c4     00 00 00 00 
040c8     00 00 00 00 | 	byte	$00[8]
040cc     03 00 00 00 
040d0     00 00 00 00 
040d4     00 00 00 00 
040d8     00 00 00 00 | 	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
040dc     00 00 00 00 
040e0     00 00 00 00 
040e4     00 00 00 00 
040e8     00 00 00 00 
040ec     00 00 00 00 
040f0     00 00 00 00 | 	byte	$00[24]
040f4     05 00 00 00 
040f8     00 00 00 00 
040fc     00 00 00 00 
04100     00 00 00 00 | 	byte	$05, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04104     00 00 00 00 | 	byte	$00, $00, $00, $00
04108     00 00 80 00 | 	long	(8 {__system___tx})<<20
0410c     00 00 90 00 | 	long	(9 {__system___rx})<<20
04110     00 00 00 00 | 	byte	$00, $00, $00, $00
04114     00 00 A0 00 | 	long	(10 {__system___rxtxioctl_0142})<<20
04118     00 00 B0 00 | 	long	(11 {__system____dummy_flush_0143})<<20
0411c     00 00 00 00 
04120     00 00 00 00 | 	byte	$00[8]
04124     01 00 00 00 
04128     06 00 00 00 
0412c     00 00 00 00 
04130     00 00 00 00 | 	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04134     00 00 00 00 
04138     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
0413c     00 00 80 00 | 	long	(8 {__system___tx})<<20
04140     00 00 90 00 | 	long	(9 {__system___rx})<<20
04144     00 00 00 00 | 	byte	$00, $00, $00, $00
04148     00 00 A0 00 | 	long	(10 {__system___rxtxioctl_0142})<<20
0414c     00 00 B0 00 | 	long	(11 {__system____dummy_flush_0143})<<20
04150     00 00 00 00 
04154     00 00 00 00 | 	byte	$00[8]
04158     01 00 00 00 
0415c     06 00 00 00 
04160     00 00 00 00 
04164     00 00 00 00 | 	byte	$01, $00, $00, $00, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
04168     00 00 00 00 
0416c     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
04170     00 00 80 00 | 	long	(8 {__system___tx})<<20
04174     00 00 90 00 | 	long	(9 {__system___rx})<<20
04178     00 00 00 00 | 	byte	$00, $00, $00, $00
0417c     00 00 A0 00 | 	long	(10 {__system___rxtxioctl_0142})<<20
04180     00 00 B0 00 | 	long	(11 {__system____dummy_flush_0143})<<20
04184     00 00 00 00 
      ...             
042ec     00 00 00 00 
042f0     00 00 00 00 | 	byte	$00[368]
042f4                 | __methodtable__
042f4     74 1A 00 00 | 	long	@__struct___bas_wrap_sender_tx
042f8     B8 1A 00 00 | 	long	@__struct___bas_wrap_sender_rx
042fc     00 1B 00 00 | 	long	@__struct___bas_wrap_sender_close
04300     A4 19 00 00 | 	long	@__struct__s_vfs_file_t_putchar
04304     14 1A 00 00 | 	long	@__struct__s_vfs_file_t_getchar
04308     2C 14 00 00 | 	long	@__system____default_putc
0430c     B0 13 00 00 | 	long	@__system____default_getc
04310     D4 14 00 00 | 	long	@__system____default_flush
04314     7C 0F 00 00 | 	long	@__system___tx
04318     BC 0F 00 00 | 	long	@__system___rx
0431c     74 18 00 00 | 	long	@__system___rxtxioctl_0142
04320     CC 18 00 00 | 	long	@__system____dummy_flush_0143
04324                 | objmem
04324     00 00 00 00 
      ...             
04528     00 00 00 00 
0452c     00 00 00 00 | 	long	0[131]
04530                 | stackspace
04530     00 00 00 00 | 	long	0[1]
04534 0d0             | 	org	COG_BSS_START
04534 0d0             | _var01
04534 0d0             | 	res	1
04534 0d1             | _var02
04534 0d1             | 	res	1
04534 0d2             | _var03
04534 0d2             | 	res	1
04534 0d3             | arg01
04534 0d3             | 	res	1
04534 0d4             | arg02
04534 0d4             | 	res	1
04534 0d5             | arg03
04534 0d5             | 	res	1
04534 0d6             | arg04
04534 0d6             | 	res	1
04534 0d7             | arg05
04534 0d7             | 	res	1
04534 0d8             | arg06
04534 0d8             | 	res	1
04534 0d9             | local01
04534 0d9             | 	res	1
04534 0da             | local02
04534 0da             | 	res	1
04534 0db             | local03
04534 0db             | 	res	1
04534 0dc             | local04
04534 0dc             | 	res	1
04534 0dd             | local05
04534 0dd             | 	res	1
04534 0de             | local06
04534 0de             | 	res	1
04534 0df             | local07
04534 0df             | 	res	1
04534 0e0             | local08
04534 0e0             | 	res	1
04534 0e1             | local09
04534 0e1             | 	res	1
04534 0e2             | local10
04534 0e2             | 	res	1
04534 0e3             | local11
04534 0e3             | 	res	1
04534 0e4             | local12
04534 0e4             | 	res	1
04534 0e5             | local13
04534 0e5             | 	res	1
04534 0e6             | muldiva_
04534 0e6             | 	res	1
04534 0e7             | muldivb_
04534 0e7             | 	res	1
04534 0e8             | 	fit	480
04534 0e8             | 
