00000                 | 
00000                 | #line 1 "D:/programowanie/P2-Retromachine-Basic/audio096.p2asm"
00000                 | con
00000                 | 	_clkfreq = 20000000
00000                 | 	_clkmode = 16779595
00000                 | ' 
00000                 | ' 
00000                 | ' left= 14
00000                 | 	left = 14
00000                 | ' right=15
00000                 | 	right = 15
00000                 | ' 
00000                 | ' c4=262
00000                 | 	c4 = 262
00000                 | ' d4=294
00000                 | 	d4 = 294
00000                 | ' e4=330
00000                 | 	e4 = 330
00000                 | ' f4=349
00000                 | 	f4 = 349
00000                 | ' g4=392
00000                 | 	g4 = 392
00000                 | ' a4=440
00000                 | 	a4 = 440
00000                 | ' h4=494
00000                 | 	h4 = 494
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 20000000
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $100094b
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 7A 05 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 02 90 5D |  if_ne	jmp	#spininit
0040c 002 BC F0 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 01 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 04 80 80 FF 
00420 007 00 90 66 FD | 	hubset	##16779592
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 04 80 00 FF 
00430 00b 4B ED 07 F6 | 	mov	pa, ##16779595
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 96 98 80 FF 
00440 00f 14 00 6E FC | 	wrlong	##20000000, #20
00444 010 BC 01 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
005fc 07e 00 00 00 00 
00600 07f 00 00 00 00 | 	orgf	128
00604 080             | skip_clock_set_
00604 080 00 07 A0 FD | 	call	#_start
00608 081             | cogexit
00608 081 38 01 80 FF 
0060c 082 1F 00 66 FD | 	waitx	##160000
00610 083 01 84 61 FD | 	cogid	arg01
00614 084 03 84 61 FD | 	cogstop	arg01
00618 085             | spininit
00618 085 61 75 05 FB | 	rdlong	objptr, ptra++
0061c 086 61 7B 05 FB | 	rdlong	result1, ptra++
00620 087 28 06 64 FD | 	setq	#3
00624 088 00 85 05 FB | 	rdlong	arg01, ptra
00628 089 04 F0 87 F1 | 	sub	ptra, #4
0062c 08a 2D 7A 61 FD | 	call	result1
00630 08b D4 FF 9F FD | 	jmp	#cogexit
00634 08c             | FCACHE_LOAD_
00634 08c F9 2D 01 F6 |     mov	fcache_tmpb_,ptrb
00638 08d 2B F2 63 FD |     pop	ptrb
0063c 08e 95 EC 8B F9 |     altd	pa,ret_instr_
00640 08f 95 00 00 F6 |     mov	 0-0, ret_instr_
00644 090 28 EC 63 FD |     setq	pa
00648 091 E1 01 04 FB |     rdlong	$0, ptrb++
0064c 092 2A F2 63 FD |     push	ptrb
00650 093 96 F2 03 F6 |     mov ptrb,fcache_tmpb_
00654 094 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00658 095             | ret_instr_
00658 095 00 FE 07 02 |     _ret_ cmp inb,#0
0065c 096             | fcache_tmpb_
0065c 096 00 00 00 00 |     long 0
00660 097             | fcache_load_ptr_
00660 097 8C 00 00 00 |     long FCACHE_LOAD_
00664 098             | builtin_bytefill_
00664 098 01 88 55 F0 |         shr	arg03, #1 wc
00668 099 C2 86 41 CC |  if_c   wrbyte	arg02, arg01
0066c 09a 01 84 05 C1 |  if_c   add	arg01, #1
00670 09b 00 86 FD F9 |         movbyts	arg02, #0
00674 09c             | builtin_wordfill_
00674 09c 01 88 55 F0 |         shr	arg03, #1 wc
00678 09d C2 86 51 CC |  if_c   wrword	arg02, arg01
0067c 09e 02 84 05 C1 |  if_c   add	arg01, #2
00680 09f C3 86 29 F9 |         setword	arg02, arg02, #1
00684 0a0             | builtin_longfill_
00684 0a0 C2 00 88 FC |         wrfast	#0,arg01
00688 0a1 00 88 0D F2 |         cmp	arg03, #0 wz
0068c 0a2 C4 02 D8 5C |  if_nz  rep	#1, arg03
00690 0a3 17 86 61 5D |  if_nz  wflong	arg02
00694 0a4 2D 00 64 FD |         ret
00698 0a5             | COUNT_
00698 0a5 00 00 00 00 |     long 0
0069c 0a6             | RETADDR_
0069c 0a6 00 00 00 00 |     long 0
006a0 0a7             | fp
006a0 0a7 00 00 00 00 |     long 0
006a4 0a8             | pushregs_
006a4 0a8 2B EC 63 FD |     pop  pa
006a8 0a9 2B 4C 61 FD |     pop  RETADDR_
006ac 0aa 03 4A 95 FB |     tjz  COUNT_, #pushregs_done_
006b0 0ab FF 4B 8D F9 |     altd  COUNT_, #511
006b4 0ac 28 00 64 FD |     setq #0-0
006b8 0ad 61 8D 65 FC |     wrlong local01, ptra++
006bc 0ae             | pushregs_done_
006bc 0ae 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
006c0 0af 61 4B 65 FC |     wrlong COUNT_, ptra++
006c4 0b0 F8 4F 01 F6 |     mov    fp, ptra
006c8 0b1 2C EC 63 FD |     jmp  pa
006cc 0b2             |  popregs_
006cc 0b2 2B EC 63 FD |     pop    pa
006d0 0b3 28 04 64 FD |     setq   #2
006d4 0b4 5F 4B 05 FB |     rdlong COUNT_, --ptra
006d8 0b5 02 4A 75 FB |     djf    COUNT_, #popregs__ret
006dc 0b6 28 4A 61 FD |     setq   COUNT_
006e0 0b7 5F 8D 05 FB |     rdlong local01, --ptra
006e4 0b8             | popregs__ret
006e4 0b8 2A 4C 61 FD |     push   RETADDR_
006e8 0b9 2C EC 63 FD |     jmp    pa
006ec 0ba             | 
006ec 0ba             | objptr
006ec 0ba 0C 0E 00 00 | 	long	@objmem
006f0 0bb             | ptr__dat__
006f0 0bb 64 09 00 00 | 	long	@_dat_
006f4 0bc             | ptr_stackspace_
006f4 0bc 18 10 00 00 | 	long	@stackspace
006f8 0bd             | result1
006f8 0bd 00 00 00 00 | 	long	0
006fc 0be             | result2
006fc 0be 01 00 00 00 | 	long	1
00700 0bf             | COG_BSS_START
00700 0bf             | 	fit	480
00700                 | 	orgh
00700                 | hubentry
00700                 | 
00700                 | ' 
00700                 | ' 
00700                 | ' '--------------------------------------------------------------
00700                 | ' '---------- Init the variables, start the cog. ----------------
00700                 | ' '--------------------------------------------------------------
00700                 | ' 
00700                 | ' pub start(mbox,scope,cache) :cog,base | iii
00700                 | _start
00700     04 4A 05 F6 | 	mov	COUNT_, #4
00704     A8 00 A0 FD | 	call	#pushregs_
00708     C2 8C 01 F6 | 	mov	local01, arg01
0070c                 | ' 
0070c                 | ' ' mbox: PSRAM mailbox or 0 if no PSRAM
0070c                 | ' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
0070c                 | ' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
0070c                 | ' 
0070c                 | ' mailboxaddr:=mbox 
0070c     BA 8C 61 FC | 	wrlong	local01, objptr
00710                 | ' scope_ptr:=scope
00710     04 74 05 F1 | 	add	objptr, #4
00714     BA 86 61 FC | 	wrlong	arg02, objptr
00718                 | ' cache_ptr:=cache
00718     04 74 05 F1 | 	add	objptr, #4
0071c     BA 88 61 FC | 	wrlong	arg03, objptr
00720                 | ' base:=@channel1[0]
00720     04 74 05 F1 | 	add	objptr, #4
00724     BA 8E 01 F6 | 	mov	local02, objptr
00728                 | ' long[$40]:=mbox
00728     40 8C 65 FC | 	wrlong	local01, #64
0072c                 | ' repeat iii from 0 to 7
0072c     00 90 05 F6 | 	mov	local03, #0
00730     02 00 00 FF 
00734     A0 76 05 F1 | 	add	ptr__dat__, ##1184
00738     0C 74 85 F1 | 	sub	objptr, #12
0073c     97 BC 48 FB | 	callpa	#(@LR__0002-@LR__0001)>>2,fcache_load_ptr_
00740                 | LR__0001
00740                 | '   long[base+64*iii]:=0
00740     C7 8C 01 F6 | 	mov	local01, local02
00744     C8 7C 01 F6 | 	mov	result2, local03
00748     06 7C 65 F0 | 	shl	result2, #6
0074c     BE 8C 01 F1 | 	add	local01, result2
00750     C6 00 68 FC | 	wrlong	#0, local01
00754                 | '   long[base+64*iii+4]:=0
00754     C7 8C 01 F6 | 	mov	local01, local02
00758     C8 7C 01 F6 | 	mov	result2, local03
0075c     06 7C 65 F0 | 	shl	result2, #6
00760     BE 8C 01 F1 | 	add	local01, result2
00764     04 8C 05 F1 | 	add	local01, #4
00768     C6 00 68 FC | 	wrlong	#0, local01
0076c                 | '   long[base+64*iii+12]:=0
0076c     C7 92 01 F6 | 	mov	local04, local02
00770     C8 8C 01 F6 | 	mov	local01, local03
00774     06 8C 65 F0 | 	shl	local01, #6
00778     C6 92 01 F1 | 	add	local04, local01
0077c     0C 92 05 F1 | 	add	local04, #12
00780     C9 00 68 FC | 	wrlong	#0, local04
00784                 | '   long[base+64*iii+16]:=2 
00784     C7 92 01 F6 | 	mov	local04, local02
00788     C8 8C 01 F6 | 	mov	local01, local03
0078c     06 8C 65 F0 | 	shl	local01, #6
00790     C6 92 01 F1 | 	add	local04, local01
00794     10 92 05 F1 | 	add	local04, #16
00798     C9 04 68 FC | 	wrlong	#2, local04
0079c                 | '   word[base+64*iii+20]:=0
0079c     C7 92 01 F6 | 	mov	local04, local02
007a0     C8 8C 01 F6 | 	mov	local01, local03
007a4     06 8C 65 F0 | 	shl	local01, #6
007a8     C6 92 01 F1 | 	add	local04, local01
007ac     14 92 05 F1 | 	add	local04, #20
007b0     C9 00 58 FC | 	wrword	#0, local04
007b4                 | '   word[base+64*iii+22]:=8192
007b4     C7 92 01 F6 | 	mov	local04, local02
007b8     C8 8C 01 F6 | 	mov	local01, local03
007bc     06 8C 65 F0 | 	shl	local01, #6
007c0     C6 92 01 F1 | 	add	local04, local01
007c4     16 92 05 F1 | 	add	local04, #22
007c8     10 00 80 FF 
007cc     C9 00 58 FC | 	wrword	##8192, local04
007d0                 | '   word[base+64*iii+24]:=4000+2*iii
007d0     C8 92 01 F6 | 	mov	local04, local03
007d4     01 92 65 F0 | 	shl	local04, #1
007d8     07 00 00 FF 
007dc     A0 8D 05 F6 | 	mov	local01, ##4000
007e0     C9 8C 01 F1 | 	add	local01, local04
007e4     C7 92 01 F6 | 	mov	local04, local02
007e8     C8 7C 01 F6 | 	mov	result2, local03
007ec     06 7C 65 F0 | 	shl	result2, #6
007f0     BE 92 01 F1 | 	add	local04, result2
007f4     18 92 05 F1 | 	add	local04, #24
007f8     C9 8C 51 FC | 	wrword	local01, local04
007fc                 | '   word[base+64*iii+26]:=2
007fc     C7 92 01 F6 | 	mov	local04, local02
00800     C8 8C 01 F6 | 	mov	local01, local03
00804     06 8C 65 F0 | 	shl	local01, #6
00808     C6 92 01 F1 | 	add	local04, local01
0080c     1A 92 05 F1 | 	add	local04, #26
00810     C9 04 58 FC | 	wrword	#2, local04
00814                 | '   long [base+64*iii+8]:=@null | $C0000000
00814     BB 8C 01 F6 | 	mov	local01, ptr__dat__
00818     3E 8C 25 F4 | 	bith	local01, #62
0081c     C7 92 01 F6 | 	mov	local04, local02
00820     C8 88 01 F6 | 	mov	arg03, local03
00824     06 88 65 F0 | 	shl	arg03, #6
00828     C4 92 01 F1 | 	add	local04, arg03
0082c     08 92 05 F1 | 	add	local04, #8
00830     C9 8C 61 FC | 	wrlong	local01, local04
00834                 | '   long[base+64*iii+32]:=0
00834     C7 92 01 F6 | 	mov	local04, local02
00838     C8 8C 01 F6 | 	mov	local01, local03
0083c     06 8C 65 F0 | 	shl	local01, #6
00840     C6 92 01 F1 | 	add	local04, local01
00844     20 92 05 F1 | 	add	local04, #32
00848     C9 00 68 FC | 	wrlong	#0, local04
0084c                 | '   long[base+64*iii+36]:=0
0084c     C7 92 01 F6 | 	mov	local04, local02
00850     C8 8C 01 F6 | 	mov	local01, local03
00854     06 8C 65 F0 | 	shl	local01, #6
00858     C6 92 01 F1 | 	add	local04, local01
0085c     24 92 05 F1 | 	add	local04, #36
00860     C9 00 68 FC | 	wrlong	#0, local04
00864                 | '   long[base+64*iii+40]:=0
00864     C7 92 01 F6 | 	mov	local04, local02
00868     C8 8C 01 F6 | 	mov	local01, local03
0086c     06 8C 65 F0 | 	shl	local01, #6
00870     C6 92 01 F1 | 	add	local04, local01
00874     28 92 05 F1 | 	add	local04, #40
00878     C9 00 68 FC | 	wrlong	#0, local04
0087c                 | '   long[base+64*iii+44]:=0
0087c     C7 92 01 F6 | 	mov	local04, local02
00880     C8 8C 01 F6 | 	mov	local01, local03
00884     06 8C 65 F0 | 	shl	local01, #6
00888     C6 92 01 F1 | 	add	local04, local01
0088c     2C 92 05 F1 | 	add	local04, #44
00890     C9 00 68 FC | 	wrlong	#0, local04
00894                 | '   long[base+64*iii+28]:=0
00894     C7 92 01 F6 | 	mov	local04, local02
00898     C8 8C 01 F6 | 	mov	local01, local03
0089c     06 8C 65 F0 | 	shl	local01, #6
008a0     C6 92 01 F1 | 	add	local04, local01
008a4     1C 92 05 F1 | 	add	local04, #28
008a8     C9 00 68 FC | 	wrlong	#0, local04
008ac     01 90 05 F1 | 	add	local03, #1
008b0     08 90 55 F2 | 	cmps	local03, #8 wc
008b4     88 FE 9F CD |  if_b	jmp	#LR__0001
008b8                 | LR__0002
008b8     02 00 00 FF 
008bc     A0 76 85 F1 | 	sub	ptr__dat__, ##1184
008c0                 | '   
008c0                 | ' cog:=coginit(16,@audio,@mailboxaddr)
008c0     BB 86 01 F6 | 	mov	arg02, ptr__dat__
008c4     BA 88 01 F6 | 	mov	arg03, objptr
008c8     10 92 05 F6 | 	mov	local04, #16
008cc     28 88 61 FD | 	setq	arg03
008d0     C3 92 F1 FC | 	coginit	local04, arg02 wc
008d4     01 92 65 C6 |  if_b	neg	local04, #1
008d8                 | ' waitms(100)
008d8     64 84 05 F6 | 	mov	arg01, #100
008dc     18 00 B0 FD | 	call	#__system___waitms
008e0                 | ' return cog,base
008e0     C7 7C 01 F6 | 	mov	result2, local02
008e4     C9 7A 01 F6 | 	mov	result1, local04
008e8     A7 F0 03 F6 | 	mov	ptra, fp
008ec     B2 00 A0 FD | 	call	#popregs_
008f0                 | _start_ret
008f0     2D 00 64 FD | 	ret
008f4                 | hubexit
008f4     81 00 80 FD | 	jmp	#cogexit
008f8                 | 
008f8                 | __system___waitms
008f8     C2 7E 01 F6 | 	mov	_var01, arg01
008fc     1A 80 61 FD | 	getct	_var02
00900     14 82 05 FB | 	rdlong	_var03, #20
00904     97 14 48 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
00908                 | LR__0010
00908     01 00 00 FF 
0090c     E8 7F 55 F2 | 	cmps	_var01, ##1000 wc
00910     1C 00 90 CD |  if_b	jmp	#LR__0012
00914     C1 80 01 F1 | 	add	_var02, _var03
00918     C0 84 01 F6 | 	mov	arg01, _var02
0091c     00 84 65 FA | 	addct1	arg01, #0
00920     24 22 60 FD | 	waitct1
00924     01 00 00 FF 
00928     E8 7F 85 F1 | 	sub	_var01, ##1000
0092c     D8 FF 9F FD | 	jmp	#LR__0010
00930                 | LR__0011
00930                 | LR__0012
00930     01 7E 55 F2 | 	cmps	_var01, #1 wc
00934     28 00 90 CD |  if_b	jmp	#LR__0013
00938     C1 7E 01 FD | 	qmul	_var01, _var03
0093c     01 00 00 FF 
00940     E8 89 05 F6 | 	mov	arg03, ##1000
00944     19 7A 61 FD | 	getqy	result1
00948     18 84 61 FD | 	getqx	arg01
0094c     28 7A 61 FD | 	setq	result1
00950     C4 84 11 FD | 	qdiv	arg01, arg03
00954     18 84 61 FD | 	getqx	arg01
00958     C0 84 61 FA | 	addct1	arg01, _var02
0095c     24 22 60 FD | 	waitct1
00960                 | LR__0013
00960                 | __system___waitms_ret
00960     2D 00 64 FD | 	ret
00964                 | 	alignl
00964                 | _dat_
00964                 | 
00964                 | audio       org     0
00964                 | 
00964     61 CD 05 FB |             rdlong  mailbox2, ptra++     ' get start address of all mailboxes
00968     61 1B 06 FB |             rdlong  scbase, ptra++       ' get start address of scope buffer
0096c     61 27 06 FB |             rdlong  hubptr, ptra++       ' get start address of PSRAM cache
00970                 |  
00970     01 EC 63 FD |             cogid   pa                   ' compute cogid
00974     0C EC 07 FA |             mul     pa, #12              ' and mailbox spacing
00978     F6 CD 01 F1 |             add     mailbox2, pa         ' add offset to find this COG's mailbox
0097c     E6 CA 01 F6 |             mov     mailbox,mailbox2     ' we need 2 copies of this to ensble switching between hub and psram
00980                 | 
00980     00 F2 07 F6 |             mov     ptrb,#0              ' A tail pointer for the buffer
00984     0E 24 06 FC |             wrpin   dac2,#left            ' Noise dither DACs at clk/95
00988     0E 00 1E FC |             wxpin   #256,#left       	 ' Set initial DACs sample rate. It is now controlled via a register by the main program
0098c     0F 24 06 FC |             wrpin   dac2,#right
00990     0F 00 1E FC |             wxpin   #256,#right    
00994     41 9C 64 FD |             dirh    #left addpins 1
00998     20 9C 64 FD |             setse1  #%001<<6 + left      ' Set the event - DAC empty
0099c     CD E8 07 F6 |             mov     ijmp1,#isr1          ' Init the interrupt
009a0     25 08 64 FD |             setint1 #4                   ' Interrupt from DAC empty event
009a4                 |             
009a4                 | '---------------------------------------------------------------------------------        
009a4                 | '----------------- The main loop -------------------------------------------------
009a4                 | '---------------------------------------------------------------------------------
009a4                 | 
009a4     D6 AE 11 F2 | loop        cmp     time0,a41000000 wc  ' time counter overflow protection
009a8     10 00 90 CD |       if_c  jmp     #loop1
009ac                 |   
009ac     09 00 06 F6 |             mov     cn,#9               ' Substract $40000000 from all the channel times and the main timer
009b0     D6 00 8E F9 | p402        altd    cn,#a41000000       ' this has to be done at once for all channels
009b4     D5 00 80 F1 |             sub     0-0,a40000000
009b8     FD 01 6E FB |             djnz    cn,#p402
009bc                 |     
009bc     00 00 06 F6 | loop1       mov     cn,#0               ' Find the channel to compute
009c0     D8 02 02 F6 |             mov     ct,time1            ' with the lowest next sample time
009c4     D9 02 3A F3 |             fle     ct,time2 wcz        ' How to size-optimize this???
009c8     01 00 06 C6 |     if_c    mov     cn,#1
009cc     DA 02 3A F3 |             fle     ct,time3 wcz
009d0     02 00 06 C6 |     if_c    mov     cn,#2     
009d4     DB 02 3A F3 |             fle     ct,time4 wcz
009d8     03 00 06 C6 |     if_c    mov     cn,#3
009dc     DC 02 3A F3 |             fle     ct,time5 wcz
009e0     04 00 06 C6 |     if_c    mov     cn,#4
009e4     DD 02 3A F3 |             fle     ct,time6 wcz
009e8     05 00 06 C6 |     if_c    mov     cn,#5
009ec     DE 02 3A F3 |             fle     ct,time7 wcz
009f0     06 00 06 C6 |     if_c    mov     cn,#6
009f4     DF 02 3A F3 |             fle     ct,time8 wcz
009f8     07 00 06 C6 |     if_c    mov     cn,#7
009fc                 | 
009fc                 | 
009fc                 | '----------------------------------------------------------------------------------
009fc                 | '------------- Compute channel samples --------------------------------------------
009fc                 | '----------------------------------------------------------------------------------
009fc                 | 
009fc                 | 
009fc     00 C1 01 F6 | p401        mov     channeladd,cn             	' compute the pointer to channel parameters block
00a00     06 C0 65 F0 |             shl     channeladd,#6
00a04     E0 F0 03 F1 |             add     ptra,channeladd
00a08                 | 
00a08     28 16 64 FD |             setq    #11                        	' read parameters
00a0c     00 D7 05 FB |             rdlong  pointer0,ptra
00a10                 |     	    
00a10     1F E4 0D F4 | p408        testb   command0,#31 wz	      	' bit #31 command - set the DAC sample rate
00a14     18 00 90 5D |     if_nz   jmp     #p404                     	' if not set, proceed
00a18     F2 C4 31 F9 |             getword qq,command0,#0            	' get the new rate
00a1c     4E C4 15 FC |             wxpin   qq,#left addpins 1        	' and program the pins
00a20     E2 C4 E1 F8 |             getbyte qq,qq,#0 		      	' check if the rate is n*256
00a24     00 C4 0D F2 |             cmp     qq,#0 wz                         
00a28     4E 24 06 AC |     if_z    wrpin   dac2,#left addpins 1      	' if yes, set PWM DAC mode
00a2c     4E 22 06 5C |     if_nz   wrpin   dac,#left addpins 1       	' else set noise DAC mode
00a30                 |             
00a30     1E E4 1D F4 | p404        bitl    command0,#30 wcz          	' bit #30: select PSRAM/HUB
00a34     E6 CA 01 56 |     if_nz   mov     mailbox,mailbox2            ' if not set, use PSRAM
00a38     00 CA 05 A6 |     if_z    mov     mailbox,#0                  ' if set, use HUB 
00a3c                 | 
00a3c     EC 06 32 F9 | p405        getword oldls,sample0,#0          ' extract old sample value
00a40     EC 08 3A F9 |             getword oldrs,sample0,#1
00a44     F0 FC 39 F9 |      	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
00a48     F0 FA 31 F9 |     	    getword avol0,volpan0,#0
00a4c     F1 F8 39 F9 |             getword askip0,freqskip0,#1    	    
00a50     F1 F6 31 F9 |             getword afreq0,freqskip0,#0
00a54                 | 
00a54     D8 00 96 F9 |             alts    cn, #time1                ' compute the time difference between this and previous sample
00a58     00 04 02 F6 |             mov     dt0,0-0    
00a5c     D7 04 82 F1 |             sub     dt0,time0
00a60                 |             
00a60     D8 00 8E F9 |             altd    cn, #time1                ' add channel period to channel time
00a64     FB 00 00 F1 |             add     0-0,afreq0  	
00a68                 |             
00a68                 | '---- envelopes
00a68                 |             
00a68     00 E8 1D F2 |             cmp     envptr0,#0 wcz    		' read the pointer
00a6c     20 00 00 AF 
00a70     00 48 06 A6 |     if_z    mov     envs1,##$4000		' if 0, no envelope, load $4000=1 for scas
00a74     5C 00 90 AD |     if_z    jmp     #p410			' and run away	
00a78                 | 
00a78     FB 48 02 F6 |             mov     envs1,afreq0
00a7c     F5 48 02 FA |             mul     envs1,envspd0
00a80     24 E7 01 F1 |             add     envph0,envs1 
00a84                 | 
00a84     F3 44 02 F6 |       	    mov     envhi, envph0		' move phase acc to high part of env pointer
00a88     06 44 46 F0 | 	    shr     envhi,#6			' leave 10 bits in hi
00a8c     22 47 32 F9 | 	    getword envlo,envhi,#0              ' and 16 bit in lo
00a90     10 44 46 F0 | 	    shr     envhi,#16			' move 10 bits of hi to the lower word
00a94     F6 44 1A F2 | 	    cmp     envhi,envlen0 wcz		' compare this to envelope length
00a98     F6 44 02 36 |     if_ge   mov     envhi,envlen0		' if greater than, set it at envlen
00a9c     00 46 06 36 |     if_ge   mov     envlo,#0
00aa0     F6 E6 01 36 |     if_ge   mov     envph0,envlen0
00aa4     16 E6 65 30 |     if_ge   shl     envph0,#22
00aa8                 | 
00aa8     22 49 02 F6 |             mov     envs1,envhi			' get the phase acc
00aac     01 48 66 F0 |             shl     envs1,#1			' env defs are words, so phase acc*=2
00ab0     F4 48 02 F1 |             add     envs1,envptr0		' and add the pointer
00ab4     24 49 02 FB |             rdlong  envs1,envs1			' then read 2 entries
00ab8     24 4B 3A F9 |             getword envs2,envs1,#1		' next value
00abc     24 49 32 F9 |             getword envs1,envs1,#0		' current value
00ac0     23 4B 02 FA |             mul     envs2,envlo			' linear interpolate : new val x envlo
00ac4     23 47 22 F6 |             not     envlo			' sum of envlo and not envlo is always $FFFF
00ac8     23 49 02 FA |             mul     envs1,envlo
00acc     25 49 02 F1 |             add     envs1,envs2
00ad0     12 48 46 F0 |             shr     envs1,#18			' normalize it to $4000
00ad4                 |             
00ad4     1B DA 0D F4 | p410        testb   sstart0, #27 wz
00ad8     1B C6 61 AD |     if_z    getrnd  spl
00adc     58 00 90 AD |     if_z    jmp     #p406
00ae0                 |  
00ae0     FC D6 01 F1 |             add     pointer0,askip0           	' compute the pointer to the next sample       
00ae4     EB 42 C2 F8 |             setbyte pointer00,pointer0,#0
00ae8     08 D6 45 F0 |             shr     pointer0,#8
00aec                 |          
00aec     1F DA 0D F4 |             testb   sstart0,#31 wz            
00af0     01 D6 65 A0 |     if_z    shl     pointer0,#1        
00af4     1C DA 0D F4 |             testb   sstart0,#28 wz            
00af8     01 D6 65 A0 |     if_z    shl     pointer0,#1        
00afc                 |         
00afc     EF D6 19 F2 |             cmp     pointer0,lend0 wcz
00b00     EF D6 81 31 |     if_ge   sub     pointer0,lend0	      	' and loop if needed     
00b04     EE D6 01 31 |     if_ge   add     pointer0,lstart0       
00b08                 |             
00b08     EB C4 01 F6 |             mov     qq,pointer0               	' compute place in the memory from where the sample will be loaded
00b0c     ED C4 01 F1 |             add     qq,sstart0            
00b10                 | 
00b10     FF CB 5D F2 |             cmps    mailbox,#$1FF wcz          	' the mailbox has to point somewhere not at the start of HUB RAM
00b14     E2 C6 E1 EA |     if_le   rdword  spl,qq                     	' if not, use HUB RAM for samples
00b18     1C 01 B0 1D |     if_gt   call    #cache_read
00b1c                 |          
00b1c     1F DA 0D F4 |             testb   sstart0,#31 wz 
00b20     08 C6 65 50 |     if_nz   shl     spl,#8
00b24     08 D6 65 50 |     if_nz   shl     pointer0,#8
00b28     07 D6 65 A0 |     if_z    shl     pointer0,#7
00b2c     1C DA 0D F4 |             testb   sstart0,#28 wz            
00b30     01 D6 45 A0 |     if_z    shr     pointer0,#1    
00b34     21 D7 C1 F8 | 	    setbyte pointer0,pointer00,#0       
00b38                 | 
00b38                 | 
00b38     24 C7 31 FA | p406        scas    spl,envs1			' apply envelope
00b3c     00 C6 01 F6 |             mov     spl,0-0
00b40     FD C6 31 FA |             scas    spl,avol0                 	' apply volume
00b44     00 C6 01 F6 |             mov     spl,0-0
00b48                 | 
00b48     FE C6 31 FA |             scas    spl,apan0                 	' apply pan
00b4c     00 0A 02 F6 |             mov     ls0,0-0
00b50     20 00 00 FF 
00b54     00 C4 05 F6 |             mov     qq,##16384
00b58     FE C4 81 F1 |             sub     qq,apan0
00b5c     E2 C6 31 FA |             scas    spl,qq
00b60     00 0C 02 F6 |             mov     rs0, 0-0
00b64                 | 
00b64     04 11 82 F1 |             sub     rs,oldrs 		      	' replace the old sample with the new one in the mix
00b68     06 11 02 F1 |             add     rs,rs0
00b6c     03 0F 82 F1 |             sub     ls,oldls
00b70     05 0F 02 F1 |             add     ls,ls0
00b74                 |    
00b74     06 D9 29 F9 |             setword sample0,rs0,#1           	' pack samples into long
00b78     05 D9 21 F9 |             setword sample0,ls0,#0
00b7c                 |             
00b7c     1E DA 1D F4 |             bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
00b80     00 D6 05 A6 |     if_z    mov     pointer0, #0  		
00b84     00 E6 05 A6 |     if_z    mov     envph0, #0  		' reset also envelope pha and sample value
00b88                 |   '  if_z    mov     sample0,#0
00b88     02 DB 65 AC |     if_z    wrlong  sstart0, ptra[2]          	' reset bit #30 in hub
00b8c     1D DA 1D F4 |             bitl    sstart0, #29 wcz	      	' if bit #29 is set, synchronize stereo at channels 1 and 2
00b90     04 00 00 AF 
00b94     00 B0 05 A1 |     if_z    add     time1,##2048
00b98     D8 B2 01 A6 |     if_z    mov     time2,time1
00b9c     02 DB 65 AC |     if_z    wrlong  sstart0,ptra[2]
00ba0                 | 
00ba0     28 02 64 FD | p403        setq    #1                         	' write new pointer and sample value to the hub
00ba4     00 D7 65 FC |             wrlong  pointer0,ptra
00ba8     08 E7 65 FC |             wrlong  envph0,ptra[8]
00bac     E0 F0 83 F1 |             sub     ptra, channeladd         	' reset the pointer to channel parameters
00bb0                 |                       
00bb0     D7 FE 09 F2 |             cmp     oldt0,time0 wz           ' If more than 1 sample is computed at the same time, write only the last result
00bb4     FF C3 25 A7 |     if_z    decmod  front, #511          
00bb8                 |          
00bb8     07 07 32 F9 |             getword oldls,ls,#0              ' reuse oldls variable to convert the sample to unsigned
00bbc     08 09 32 F9 |  	    getword oldrs,rs,#0              ' getword instead of mov makes the upper bits=0
00bc0     0F 06 E6 F4 |             bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
00bc4     0F 08 E6 F4 |             bitnot  oldrs,#15		     ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
00bc8                 | 	    
00bc8                 | 		    
00bc8     03 09 2A F9 |             setword oldrs,oldls,#1           ' Pack L and R to one long    		
00bcc     0A 13 02 F6 |             mov     oldsample, newsample     ' The new computed sample will be outputted in the next loop, now we have to fill the buffer with the old one
00bd0     04 15 02 F6 |             mov     newsample, oldrs       
00bd4                 | 
00bd4     D7 FE 01 F6 |             mov     oldt0,time0              ' update global time
00bd8     02 AF 01 F1 |             add     time0,dt0    
00bdc                 |                                      
00bdc     00 04 0E F2 |             cmp     dt0,#0 wz                ' now push dt0 samples to the buffer
00be0     D8 FD 9F AD |     if_z    jmp     #loop1
00be4     02 C5 01 F6 |             mov     qq,dt0
00be8                 | 
00be8                 |     
00be8                 |             
00be8     01 4E 36 F0 | p301        rol     dropper,#1 wc
00bec     40 00 90 3D |     if_nc   jmp     #p399
00bf0     FF F3 97 F9 | p398        alts    ptrb,#511                ' checking if the buffer is full - Wuerfel_21's magic stuff
00bf4     00 C2 9D F2 |             cmpr    front, #0-0 wcz
00bf8     F4 FF 9F AD |     if_e    jmp     #p398   
00bfc                 | 		
00bfc     00 1A 0E F2 | 	    cmp     scbase,#0 wz
00c00     20 00 90 AD |     if_z    jmp     #p302	   
00c04                 |   
00c04     3F 20 16 F7 |             incmod  scope,#63 wc            ' save every 127th sample to the scope buffer
00c08     0E 1F 02 C6 |     if_c    mov     scptr2,scptr
00c0c     02 1E 66 C0 |     if_c    shl     scptr2,#2
00c10     0D 1F 02 C1 |     if_c    add     scptr2,scbase     
00c14     60 1E 66 FC |             wrlong  scptr2,#$60
00c18     0F 13 62 CC |     if_c    wrlong  oldsample,scptr2
00c1c     01 00 00 CF 
00c20     7F 1C 06 C7 |     if_c    incmod  scptr,##639
00c24                 | 			    
00c24     E1 12 32 FC | p302        wrlut   oldsample, front        ' if there is a free slot, put the sample into the buffer
00c28     00 00 00 FF 
00c2c     FF C3 05 F7 |             incmod  front, ##511
00c30     ED C5 6D FB | p399        djnz    qq,#p301
00c34                 |             
00c34     6C FD 9F FD |             jmp     #loop            'loop
00c38                 | 
00c38                 | '----------------------------------------------------------------------------------
00c38                 | '------------- This is the end of the main loop -----------------------------------
00c38                 | '----------------------------------------------------------------------------------
00c38                 | 
00c38                 | '----------------------------------------------------------------------------------
00c38                 | '------------- PSRAM cache ----------- --------------------------------------------
00c38                 | '----------------------------------------------------------------------------------
00c38                 | 
00c38                 | ' There are 8 cache pointers for 8 channels
00c38                 | ' if 24 higher bits of address=cache, then get a word from the cache
00c38                 | ' else load the cache from PSRAM, update the pointer, then read a sample
00c38                 | 
00c38                 | 
00c38     E2 3E E2 F8 | cache_read  getbyte addrlo,qq,#0 		' when this is called, qq is the addres of the sample			
00c3c                 |             
00c3c     E2 40 02 F6 | 	    mov     addrhi,qq		
00c40     08 40 46 F0 | 	    shr     addrhi,#8		        ' get 24 upper bits
00c44     14 01 96 F9 | 	    alts    cn,#cache1            
00c48     00 40 0A F2 | 	    cmp	    addrhi,0-0 wz               ' and compare with the cache pointer for the channel
00c4c     34 00 90 AD |     if_z    jmp     #p701	    		' if equal, cache hit, read the sample from it
00c50                 | 	
00c50     14 01 8E F9 | p702	    altd    cn,#cache1			' cache miss. 
00c54     20 01 00 F6 | 	    mov     0-0,addrhi                  ' update the pointer
00c58     20 39 02 F6 | 	    mov     cmd,addrhi			' prepare the mailbox
00c5c     08 38 66 F0 | 	    shl     cmd,#8
00c60     0B 38 3E F8 |             setnib  cmd, #%1011, #7             ' read burst from the external memory
00c64     00 3B 02 F6 |             mov     hubaddr,cn                  ' to the channel cache
00c68     08 3A 66 F0 |             shl     hubaddr,#8                  '
00c6c     13 3B 02 F1 |             add     hubaddr,hubptr 
00c70     00 3D 06 F6 |             mov     count,#256                  ' 256 bytes
00c74     28 04 64 FD |             setq    #2                          ' write 3 longs
00c78     E5 38 62 FC |             wrlong  cmd, mailbox                ' run it
00c7c     E5 38 02 FB | poll1       rdlong  cmd, mailbox                ' poll mailbox for result
00c80     FE 39 B6 FB |             tjs     cmd, #poll1                 ' retry until valid 
00c84                 |             
00c84                 | 	
00c84     00 C5 01 F6 | p701	    mov     qq,cn			' cache hit
00c88     08 C4 65 F0 | 	    shl     qq,#8			' compute the cache start
00c8c     13 C5 01 F1 | 	    add     qq,hubptr
00c90     1F C5 01 F1 | 	    add	    qq,addrlo			' add 8 lower bits to the cache addredd
00c94     E2 C6 E1 0A |     _ret_   rdword  spl,qq                      ' read a word
00c98                 |           
00c98                 | 
00c98                 | '--------------------------------------------------------------------------
00c98                 | '------ Interrupt service -------------------------------------------------
00c98                 | '------ Output the sample, get the next one if exists ---------------------
00c98                 | '--------------------------------------------------------------------------
00c98                 | 
00c98     0E CE 25 FC | isr1        wypin   lsample,#left        '2     The sample has to be outputted every 95 cycles     
00c9c     0F D0 25 FC |             wypin   rsample,#right       '4
00ca0     E1 F2 1B F2 |             cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
00ca4     80 D3 A5 5A |     if_ne   rdlut   lsnext,ptrb          '11    else read the sample and its time from LUT
00ca8     FF F3 07 57 |     if_ne   incmod  ptrb,#511
00cac     E9 D0 39 59 |     if_ne   getword rsample,lsnext,#1    '13
00cb0     E9 CE 31 59 |     if_ne   getword lsample,lsnext,#0    '15
00cb4                 |     
00cb4     F5 FF 3B FB |             reti1                        '17/19 
00cb8                 |           
00cb8                 | '---------------------------------------------------------------------------
00cb8                 | '-------- End of interrupt -------------------------------------------------
00cb8                 | '---------------------------------------------------------------------------    
00cb8                 | 
00cb8                 | 
00cb8                 | '---------------------------------------------------------------------------
00cb8                 | '------- Variables ---------------------------------------------------------
00cb8                 | '---------------------------------------------------------------------------
00cb8                 | 
00cb8                 | ' constants
00cb8                 | 
00cb8     00 00 00 40 | a40000000   long $40000000
00cbc     00 00 00 41 | a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before
00cc0                 | 
00cc0                 | ' Time variables
00cc0                 | 
00cc0     00 00 00 00 | time0       long 0    ' Global sample computing time
00cc4     01 00 00 00 | time1       long 1    ' Local channels time
00cc8     02 00 00 00 | time2       long 2
00ccc     03 00 00 00 | time3       long 3
00cd0     04 00 00 00 | time4       long 4
00cd4     05 00 00 00 | time5       long 5
00cd8     06 00 00 00 | time6       long 6
00cdc     07 00 00 00 | time7       long 7
00ce0     08 00 00 00 | time8       long 8
00ce4                 | 
00ce4     00 00 00 00 | channeladd long 0
00ce8                 | 
00ce8     00 00 00 00 | front       long 0
00cec                 | 
00cec                 | ' temporary variables 
00cec     00 00 00 00 | qq          long 0
00cf0     00 00 00 00 | spl         long 0
00cf4     00 00 00 00 | zero        long 0
00cf8     00 00 00 00 | mailbox     long 0
00cfc     00 00 00 00 | mailbox2 long 0
00d00                 | 
00d00                 | ' Interrupt ISR variables
00d00                 | 
00d00     00 00 00 00 | lsample     long 0
00d04     00 00 00 00 | rsample     long 0
00d08     00 00 00 00 | lsnext      long 0
00d0c     00 00 00 00 | rsnext      long 0 
00d10                 | 
00d10                 | ' channel parameter block
00d10                 | 
00d10     00 00 00 00 | pointer0    long 0     
00d14     00 00 00 00 | sample0     long 0
00d18     00 00 00 00 | sstart0     long 0     ' start pointer and type at bit 31
00d1c     00 00 00 00 | lstart0     long 0
00d20     00 00 00 00 | lend0       long 0
00d24     00 00 00 00 | volpan0     long 0
00d28     00 00 00 00 | freqskip0   long 0
00d2c     00 00 00 00 | command0    long 0
00d30     00 00 00 00 | envph0	    long 0
00d34     00 00 00 00 | envptr0	    long 0
00d38     00 00 00 00 | envspd0	    long 0
00d3c     00 00 00 00 | envlen0	    long 0
00d40     00 00 00 00 | res5	    long 0
00d44     00 00 00 00 | res6	    long 0
00d48     00 00 00 00 | res7	    long 0
00d4c     00 00 00 00 | res8	    long 0
00d50                 | 
00d50     00 00 00 00 | afreq0      long 0
00d54     00 00 00 00 | askip0      long 0
00d58     00 00 00 00 | avol0       long 0
00d5c     00 00 00 00 | apan0       long 0
00d60                 | 
00d60     FF FF FF FF | oldt0       long $FFFFFFFF    'Temporary time variables
00d64     00 00 00 00 | cn          long 0
00d68     00 00 00 00 | ct          long 0
00d6c     00 00 00 00 | dt0         long 0
00d70                 | 
00d70                 | ' Samples
00d70     00 00 00 00 | oldls       long 0
00d74     00 00 00 00 | oldrs       long 0
00d78                 | 
00d78     00 00 00 00 | ls0         long 0
00d7c     00 00 00 00 | rs0         long 0
00d80                 | 
00d80     00 00 00 00 | ls          long 0    
00d84     00 00 00 00 | rs          long 0
00d88                 | 
00d88     00 00 00 00 | oldsample   long 0
00d8c     00 00 00 00 | newsample   long 0
00d90                 | 
00d90     00 00 00 00 | nrsample    long 0
00d94     00 00 00 00 | nlsample    long 0
00d98                 | 
00d98     00 00 00 00 | scbase long 0
00d9c     00 00 00 00 | scptr long 0
00da0     00 00 00 00 | scptr2 long 0
00da4     00 00 00 00 | scope long 0
00da8                 | 
00da8     44 00 17 00 | dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
00dac     46 00 17 00 | dac2        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   
00db0                 | 
00db0     00 18 07 00 | hubptr      long $71800
00db4     00 00 00 00 | cache1      long 0
00db8     00 00 00 00 | cache2      long 0
00dbc     00 00 00 00 | cache3      long 0
00dc0     00 00 00 00 | cache4      long 0
00dc4     00 00 00 00 | cache5      long 0
00dc8     00 00 00 00 | cache6      long 0
00dcc     00 00 00 00 | cache7      long 0
00dd0     00 00 00 00 | cache8      long 0
00dd4                 | 
00dd4                 | 
00dd4     00 00 00 00 | cmd         long 0
00dd8     00 00 00 00 | hubaddr     long 0
00ddc     00 01 00 00 | count       long 256
00de0     00 00 00 00 | addrlo long 0
00de4     00 00 00 00 | addrhi long 0
00de8     00 00 00 00 | pointer00 long 0
00dec     00 00 00 00 | envhi long 0
00df0     00 00 00 00 | envlo long 0
00df4     00 00 00 00 | envs1 long 0
00df8     00 00 00 00 | envs2 long 0
00dfc     00 00 00 00 | noise0 long 0
00e00     92 92 92 92 | dropper long %10010010_10010010_10010010_10010010
00e04     00 00 00 00 
00e08     00 00 00 00 | null  			long 	0,0           ' for channel reset
00e0c                 | objmem
00e0c     00 00 00 00 
      ...             
01010     00 00 00 00 
01014     00 00 00 00 | 	long	0[131]
01018                 | stackspace
01018     00 00 00 00 | 	long	0[1]
0101c 0bf             | 	org	COG_BSS_START
0101c 0bf             | _var01
0101c 0bf             | 	res	1
0101c 0c0             | _var02
0101c 0c0             | 	res	1
0101c 0c1             | _var03
0101c 0c1             | 	res	1
0101c 0c2             | arg01
0101c 0c2             | 	res	1
0101c 0c3             | arg02
0101c 0c3             | 	res	1
0101c 0c4             | arg03
0101c 0c4             | 	res	1
0101c 0c5             | arg04
0101c 0c5             | 	res	1
0101c 0c6             | local01
0101c 0c6             | 	res	1
0101c 0c7             | local02
0101c 0c7             | 	res	1
0101c 0c8             | local03
0101c 0c8             | 	res	1
0101c 0c9             | local04
0101c 0c9             | 	res	1
0101c 0ca             | 	fit	480
0101c 0ca             | 
