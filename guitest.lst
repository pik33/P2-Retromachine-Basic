00000                 | 
00000                 | #line 1 "D:/Programowanie/P2-Retromachine-Basic/guitest.p2asm"
00000                 | con
00000                 | 	_clkfreq = 338695652
00000                 | 	_clkmode = 28773115
00000                 | 	fbReadOnly = 1
00000                 | 	fbHidden = 2
00000                 | 	fbSystem = 4
00000                 | 	fbDirectory = 16
00000                 | 	fbArchive = 32
00000                 | 	fbNormal = 33
00000                 | 	HEAPSIZE = 96000
00000                 | dat
00000 000 00 00 00 00 | 	nop
00004 001 01 EC 63 FD | 	cogid	pa
00008 002 02 00 00 FF 
0000c 003 04 EC E7 FC | 	coginit	pa,##$404
00010                 | 	orgh	$10
00010     00 00 00 00 | 	long	0	'reserved
00014     00 00 00 00 | 	long	0 ' clock frequency: will default to 338695652
00018     00 00 00 00 | 	long	0 ' clock mode: will default to $1b70afb
0001c     00 00 00 00 
      ...             
003f8     00 00 00 00 
003fc     00 00 00 00 | 	orgh	$400
00400     00 76 06 06 |  _ret_	mov	result1, #0
00404 000             | 	org	0
00404 000             | entry
00404 000 00 F0 0F F2 | 	cmp	ptra, #0 wz
00408 001 0C 03 90 5D |  if_ne	jmp	#spininit
0040c 002 3A F1 03 F6 | 	mov	ptra, ptr_stackspace_
00410 003 14 EC 0F FB | 	rdlong	pa, #20 wz
00414 004 EC 02 90 5D |  if_ne	jmp	#skip_clock_set_
00418 005 00 00 64 FD | 	hubset	#0
0041c 006 85 DB 80 FF 
00420 007 00 F0 65 FD | 	hubset	##28773112
00424 008 86 01 80 FF 
00428 009 1F 80 66 FD | 	waitx	##200000
0042c 00a 85 DB 00 FF 
00430 00b FB EC 07 F6 | 	mov	pa, ##28773115
00434 00c 00 EC 63 FD | 	hubset	pa
00438 00d 18 EC 67 FC | 	wrlong	pa, #24
0043c 00e 0A 18 8A FF 
00440 00f 14 C8 6F FC | 	wrlong	##338695652, #20
00444 010 BC 02 90 FD | 	jmp	#skip_clock_set_
00448 011 00 00 00 00 
      ...             
006fc 0be 00 00 00 00 
00700 0bf 00 00 00 00 | 	orgf	192
00704 0c0             | skip_clock_set_
00704 0c0 E0 09 A0 FD | 	call	#_program
00708 0c1             | cogexit
00708 0c1 38 01 80 FF 
0070c 0c2 1F 00 66 FD | 	waitx	##160000
00710 0c3 01 90 62 FD | 	cogid	arg01
00714 0c4 03 90 62 FD | 	cogstop	arg01
00718 0c5             | spininit
00718 0c5 61 63 06 FB | 	rdlong	objptr, ptra++
0071c 0c6 61 77 06 FB | 	rdlong	result1, ptra++
00720 0c7 28 06 64 FD | 	setq	#3
00724 0c8 00 91 06 FB | 	rdlong	arg01, ptra
00728 0c9 04 F0 87 F1 | 	sub	ptra, #4
0072c 0ca 2D 76 62 FD | 	call	result1
00730 0cb D4 FF 9F FD | 	jmp	#cogexit
00734 0cc             | FCACHE_LOAD_
00734 0cc F9 AD 01 F6 |     mov	fcache_tmpb_,ptrb
00738 0cd 2B F2 63 FD |     pop	ptrb
0073c 0ce D5 EC 8B F9 |     altd	pa,ret_instr_
00740 0cf D5 00 00 F6 |     mov	 0-0, ret_instr_
00744 0d0 28 EC 63 FD |     setq	pa
00748 0d1 E1 01 04 FB |     rdlong	$0, ptrb++
0074c 0d2 2A F2 63 FD |     push	ptrb
00750 0d3 D6 F2 03 F6 |     mov ptrb,fcache_tmpb_
00754 0d4 00 00 80 FD |     jmp	#\$0 ' jmp to cache
00758 0d5             | ret_instr_
00758 0d5 00 FE 07 02 |     _ret_ cmp inb,#0
0075c 0d6             | fcache_tmpb_
0075c 0d6 00 00 00 00 |     long 0
00760 0d7             | fcache_load_ptr_
00760 0d7 CC 00 00 00 |     long FCACHE_LOAD_
00764 0d8             | builtin_bytefill_
00764 0d8 01 94 56 F0 |         shr	arg03, #1 wc
00768 0d9 48 93 42 CC |  if_c   wrbyte	arg02, arg01
0076c 0da 01 90 06 C1 |  if_c   add	arg01, #1
00770 0db 00 92 FE F9 |         movbyts	arg02, #0
00774 0dc             | builtin_wordfill_
00774 0dc 01 94 56 F0 |         shr	arg03, #1 wc
00778 0dd 48 93 52 CC |  if_c   wrword	arg02, arg01
0077c 0de 02 90 06 C1 |  if_c   add	arg01, #2
00780 0df 49 93 2A F9 |         setword	arg02, arg02, #1
00784 0e0             | builtin_longfill_
00784 0e0 48 01 88 FC |         wrfast	#0,arg01
00788 0e1 00 94 0E F2 |         cmp	arg03, #0 wz
0078c 0e2 4A 03 D8 5C |  if_nz  rep	#1, arg03
00790 0e3 17 92 62 5D |  if_nz  wflong	arg02
00794 0e4 2D 00 64 FD |         ret
00798 0e5             | COUNT_
00798 0e5 00 00 00 00 |     long 0
0079c 0e6             | RETADDR_
0079c 0e6 00 00 00 00 |     long 0
007a0 0e7             | fp
007a0 0e7 00 00 00 00 |     long 0
007a4 0e8             | pushregs_
007a4 0e8 2B EC 63 FD |     pop  pa
007a8 0e9 2B CC 61 FD |     pop  RETADDR_
007ac 0ea 03 CA 95 FB |     tjz  COUNT_, #pushregs_done_
007b0 0eb FF CB 8D F9 |     altd  COUNT_, #511
007b4 0ec 28 00 64 FD |     setq #0-0
007b8 0ed 61 A7 66 FC |     wrlong local01, ptra++
007bc 0ee             | pushregs_done_
007bc 0ee 28 04 64 FD |     setq #2 ' push 3 registers starting at COUNT_
007c0 0ef 61 CB 65 FC |     wrlong COUNT_, ptra++
007c4 0f0 F8 CF 01 F6 |     mov    fp, ptra
007c8 0f1 2C EC 63 FD |     jmp  pa
007cc 0f2             |  popregs_
007cc 0f2 2B EC 63 FD |     pop    pa
007d0 0f3 28 04 64 FD |     setq   #2
007d4 0f4 5F CB 05 FB |     rdlong COUNT_, --ptra
007d8 0f5 02 CA 75 FB |     djf    COUNT_, #popregs__ret
007dc 0f6 28 CA 61 FD |     setq   COUNT_
007e0 0f7 5F A7 06 FB |     rdlong local01, --ptra
007e4 0f8             | popregs__ret
007e4 0f8 2A CC 61 FD |     push   RETADDR_
007e8 0f9 2C EC 63 FD |     jmp    pa
007ec 0fa             | 
007ec 0fa             | divide_
007ec 0fa 7D FB 5A F6 |        abs     muldivb_,muldivb_     wcz      'abs(y)
007f0 0fb 6C 60 62 FD |        wrc     itmp2_                         'store sign of y
007f4 0fc 7C F9 52 F6 |        abs     muldiva_,muldiva_     wc       'abs(x)
007f8 0fd 7D F9 12 FD |        qdiv    muldiva_, muldivb_             'queue divide
007fc 0fe 01 60 66 C5 |  if_c  xor     itmp2_,#1                      'store sign of x
00800 0ff 18 FA 62 FD |        getqx   muldivb_                       'get quotient
00804 100 19 F8 62 FD |        getqy   muldiva_                       'get remainder
00808 101 7C F9 82 F6 |        negc    muldiva_,muldiva_              'restore sign, remainder (sign of x)
0080c 102 00 60 16 F4 |        testb   itmp2_,#0             wc       'restore sign, division result
00810 103 7D FB 82 06 |  _ret_ negc    muldivb_,muldivb_     
00814 104             | __pc long 0
00814 104 00 00 00 00 
00818 105             | __setjmp
00818 105 2B 08 62 FD |     pop __pc
0081c 106 00 76 06 F6 |     mov result1, #0
00820 107 00 78 06 F6 |     mov result2, #0
00824 108 48 5D 02 F6 |     mov abortchain, arg01
00828 109 48 CF 61 FC |     wrlong fp, arg01
0082c 10a 04 90 06 F1 |     add arg01, #4
00830 10b 48 F1 63 FC |     wrlong ptra, arg01
00834 10c 04 90 06 F1 |     add arg01, #4
00838 10d 48 63 62 FC |     wrlong objptr, arg01
0083c 10e 04 90 06 F1 |     add arg01, #4
00840 10f 48 09 62 FC |     wrlong __pc, arg01
00844 110 2C 08 62 FD |     jmp __pc
00848 111             | __unwind_pc long 0
00848 111 00 00 00 00 
0084c 112             | __unwind_stack
0084c 112 2B 22 62 FD |    pop  __unwind_pc
00850 113             | __unwind_loop
00850 113 49 91 0A F2 |    cmp  arg01, arg02 wz
00854 114 10 00 90 AD |   if_z jmp #__unwind_stack_ret
00858 115 48 F1 03 F6 |    mov   ptra, arg01
0085c 116 6C FF BF FD |    call  #popregs_
00860 117 E7 90 02 F6 |    mov   arg01, fp
00864 118 E8 FF 9F FD |    jmp   #__unwind_loop
00868 119             | __unwind_stack_ret
00868 119 2C 22 62 FD |    jmp  __unwind_pc
0086c 11a             | __longjmp
0086c 11a 2B 08 62 FD |     pop __pc
00870 11b 00 90 0E F2 |     cmp    arg01, #0 wz
00874 11c 30 00 90 AD |  if_z jmp #nocatch
00878 11d 49 77 02 F6 |     mov result1, arg02
0087c 11e 01 78 06 F6 |     mov result2, #1
00880 11f 48 93 02 FB |     rdlong arg02, arg01
00884 120 04 90 06 F1 |     add arg01, #4
00888 121 48 F1 03 FB |     rdlong ptra, arg01
0088c 122 04 90 06 F1 |     add arg01, #4
00890 123 48 63 02 FB |     rdlong objptr, arg01
00894 124 04 90 06 F1 |     add arg01, #4
00898 125 48 09 02 FB |     rdlong __pc, arg01
0089c 126 E7 90 02 F6 |     mov arg01, fp
008a0 127 A8 FF BF FD |     call #__unwind_stack
008a4 128             | __longjmp_ret
008a4 128 2C 08 62 FD |     jmp  __pc
008a8 129             | nocatch
008a8 129 00 94 0E F2 |     cmp arg03, #0 wz
008ac 12a 58 FE 9F AD |  if_z jmp #cogexit
008b0 12b F0 FF 9F FD |     jmp #__longjmp_ret
008b4 12c             | 
008b4 12c             | __heap_ptr
008b4 12c 68 72 01 00 | 	long	@__heap_base
008b8 12d             | __methods__
008b8 12d B4 71 01 00 | 	long	@__methodtable__
008bc 12e             | abortchain
008bc 12e 00 00 00 00 | 	long	0
008c0 12f             | itmp1_
008c0 12f 00 00 00 00 | 	long	0
008c4 130             | itmp2_
008c4 130 00 00 00 00 | 	long	0
008c8 131             | objptr
008c8 131 70 E9 02 00 | 	long	@objmem
008cc 132             | ptr__Audio2_004_spin2_dat__
008cc 132 3C 63 01 00 | 	long	@_Audio2_004_spin2_dat_
008d0 133             | ptr___system__dat__
008d0 133 38 67 01 00 | 	long	@__system__dat_
008d4 134             | ptr__dat__
008d4 134 74 E3 00 00 | 	long	@_dat_
008d8 135             | ptr__fatfs_cc_dat__
008d8 135 24 6C 01 00 | 	long	@_fatfs_cc_dat_
008dc 136             | ptr__hg010b_spin2_dat__
008dc 136 74 E9 00 00 | 	long	@_hg010b_spin2_dat_
008e0 137             | ptr__psram16drv_spin2_dat__
008e0 137 24 29 01 00 | 	long	@_psram16drv_spin2_dat_
008e4 138             | ptr__psram_spin2_dat__
008e4 138 DC 26 01 00 | 	long	@_psram_spin2_dat_
008e8 139             | ptr__usbnew_spin2_dat__
008e8 139 B4 38 01 00 | 	long	@_usbnew_spin2_dat_
008ec 13a             | ptr_stackspace_
008ec 13a D4 33 03 00 | 	long	@stackspace
008f0 13b             | result1
008f0 13b 00 00 00 00 | 	long	0
008f4 13c             | result2
008f4 13c 01 00 00 00 | 	long	1
008f8 13d             | result3
008f8 13d 02 00 00 00 | 	long	2
008fc 13e             | COG_BSS_START
008fc 13e             | 	fit	480
008fc                 | 	orgh
008fc                 | hubentry
008fc                 | 
008fc                 | ' trackbar1.create(v,100,100,16,300)
008fc                 | ' window1.create(v,200,200,300,300,"Window test 1234567890")
008fc                 | ' 
008fc                 | ' 
008fc                 | ' sub startpsram
008fc                 | _startpsram
008fc     00 90 06 F6 | 	mov	arg01, #0
00900     0A 92 C6 F9 | 	decod	arg02, #10
00904     0B 94 06 F6 | 	mov	arg03, #11
00908     07 96 06 F6 | 	mov	arg04, #7
0090c     0B 00 00 FF 
00910     F4 62 06 F1 | 	add	objptr, ##5876
00914     F4 15 B0 FD | 	call	#_psram_spin2_startx
00918     0B 00 00 FF 
0091c     E8 62 86 F1 | 	sub	objptr, ##5864
00920     31 77 62 FC | 	wrlong	result1, objptr
00924     04 62 06 F1 | 	add	objptr, #4
00928     31 79 62 FC | 	wrlong	result2, objptr
0092c     10 62 86 F1 | 	sub	objptr, #16
00930                 | _startpsram_ret
00930     2D 00 64 FD | 	ret
00934                 | 
00934                 | ' 
00934                 | ' function startvideo(mode=64, pin=0, mb=0) 'todo return a cog#
00934                 | _startvideo
00934     01 CA 05 F6 | 	mov	COUNT_, #1
00938     E8 00 A0 FD | 	call	#pushregs_
0093c     10 62 06 F1 | 	add	objptr, #16
00940     31 97 02 FB | 	rdlong	arg04, objptr
00944     49 91 02 F6 | 	mov	arg01, arg02
00948     4B 93 02 F6 | 	mov	arg02, arg04
0094c     14 62 06 F1 | 	add	objptr, #20
00950     1C 03 B0 FD | 	call	#_hg010b_spin2_start
00954     10 62 86 F1 | 	sub	objptr, #16
00958     31 77 62 FC | 	wrlong	result1, objptr
0095c                 | ' 
0095c                 | ' videocog=v.start(pin,mbox)
0095c                 | ' for thecog=0 to 7:psram.setQos(thecog, 80 << 16) :next thecog
0095c     00 A6 06 F6 | 	mov	local01, #0
00960     0B 00 00 FF 
00964     E0 62 06 F1 | 	add	objptr, ##5856
00968                 | LR__0001
00968     53 91 02 F6 | 	mov	arg01, local01
0096c     00 28 00 FF 
00970     00 92 06 F6 | 	mov	arg02, ##5242880
00974     14 1A B0 FD | 	call	#_psram_spin2_setQos
00978     01 A6 06 F1 | 	add	local01, #1
0097c     08 A6 56 F2 | 	cmps	local01, #8 wc
00980     E4 FF 9F CD |  if_b	jmp	#LR__0001
00984     0B 00 00 FF 
00988     E0 62 86 F1 | 	sub	objptr, ##5856
0098c     31 91 02 FB | 	rdlong	arg01, objptr
00990     7A 00 02 FF 
00994     00 92 06 F6 | 	mov	arg02, ##67171328
00998     0B 00 00 FF 
0099c     E0 62 06 F1 | 	add	objptr, ##5856
009a0     E8 19 B0 FD | 	call	#_psram_spin2_setQos
009a4                 | ' psram.setQoS(videocog, $0400f400) 
009a4                 | ' open SendRecvDevice(@v.putchar, nil, nil) as #0
009a4     0B 00 00 FF 
009a8     D0 62 86 F1 | 	sub	objptr, ##5840
009ac     31 93 02 F6 | 	mov	arg02, objptr
009b0     24 62 86 F1 | 	sub	objptr, #36
009b4     14 92 26 F4 | 	bith	arg02, #20
009b8     00 94 06 F6 | 	mov	arg03, #0
009bc     00 96 06 F6 | 	mov	arg04, #0
009c0     00 90 06 F6 | 	mov	arg01, #0
009c4     14 30 B0 FD | 	call	#__system___basic_open
009c8                 | ' return videocog
009c8     14 62 06 F1 | 	add	objptr, #20
009cc     31 77 02 FB | 	rdlong	result1, objptr
009d0     14 62 86 F1 | 	sub	objptr, #20
009d4     E7 F0 03 F6 | 	mov	ptra, fp
009d8     F2 00 A0 FD | 	call	#popregs_
009dc                 | _startvideo_ret
009dc     2D 00 64 FD | 	ret
009e0                 | 
009e0                 | _program
009e0     01 CA 05 F6 | 	mov	COUNT_, #1
009e4     E8 00 A0 FD | 	call	#pushregs_
009e8     10 FF BF FD | 	call	#_startpsram
009ec     10 62 06 F1 | 	add	objptr, #16
009f0     31 91 02 FB | 	rdlong	arg01, objptr
009f4     00 92 06 F6 | 	mov	arg02, #0
009f8     F0 03 00 FF 
009fc     00 94 06 F6 | 	mov	arg03, ##516096
00a00     0B 00 00 FF 
00a04     E4 62 06 F1 | 	add	objptr, ##5860
00a08     7C 1B B0 FD | 	call	#_Audio2_004_spin2_start
00a0c     0B 00 00 FF 
00a10     F4 62 86 F1 | 	sub	objptr, ##5876
00a14     3C A3 02 F6 | 	mov	arg10, result2
00a18     31 77 62 FC | 	wrlong	result1, objptr
00a1c     04 62 06 F1 | 	add	objptr, #4
00a20     31 A3 62 FC | 	wrlong	arg10, objptr
00a24     04 62 86 F1 | 	sub	objptr, #4
00a28     32 90 06 F6 | 	mov	arg01, #50
00a2c     50 28 B0 FD | 	call	#__system___waitms
00a30     5C 1A B0 FD | 	call	#_usbnew_spin2_start
00a34     08 62 06 F1 | 	add	objptr, #8
00a38     31 77 62 FC | 	wrlong	result1, objptr
00a3c     08 62 86 F1 | 	sub	objptr, #8
00a40     40 90 06 F6 | 	mov	arg01, #64
00a44     00 92 06 F6 | 	mov	arg02, #0
00a48     00 94 06 F6 | 	mov	arg03, #0
00a4c     E4 FE BF FD | 	call	#_startvideo
00a50                 | '   mouse_limits[0] := xlim
00a50     0F 00 00 FF 
00a54     C8 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##7880
00a58     01 00 80 FF 
00a5c     39 FF 6B FC | 	wrlong	##1023, ptr__usbnew_spin2_dat__
00a60                 | '   mouse_limits[1] := ylim
00a60     04 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, #4
00a64     01 00 80 FF 
00a68     39 AF 68 FC | 	wrlong	##599, ptr__usbnew_spin2_dat__
00a6c     31 91 02 F6 | 	mov	arg01, objptr
00a70     FD 91 06 F1 | 	add	arg01, #509
00a74                 | '   mouse_outptr := ptr
00a74     04 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, #4
00a78     39 91 62 FC | 	wrlong	arg01, ptr__usbnew_spin2_dat__
00a7c     0F 00 00 FF 
00a80     D0 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##7888
00a84     34 93 02 F6 | 	mov	arg02, ptr__dat__
00a88     01 00 00 FF 
00a8c     00 92 06 F1 | 	add	arg02, ##512
00a90     10 90 06 F6 | 	mov	arg01, #16
00a94     24 62 06 F1 | 	add	objptr, #36
00a98     9C 07 B0 FD | 	call	#_hg010b_spin2_setspriteptr
00a9c     10 90 06 F6 | 	mov	arg01, #16
00aa0     20 92 06 F6 | 	mov	arg02, #32
00aa4     20 94 06 F6 | 	mov	arg03, #32
00aa8     18 08 B0 FD | 	call	#_hg010b_spin2_setspritesize
00aac     24 62 86 F1 | 	sub	objptr, #36
00ab0     09 90 C6 F9 | 	decod	arg01, #9
00ab4     2C 93 06 F6 | 	mov	arg02, #300
00ab8     30 1A B0 FD | 	call	#_usbnew_spin2_mouse_move
00abc     18 62 06 F1 | 	add	objptr, #24
00ac0     31 27 69 FC | 	wrlong	#147, objptr
00ac4     04 62 06 F1 | 	add	objptr, #4
00ac8     31 35 69 FC | 	wrlong	#154, objptr
00acc     04 62 06 F1 | 	add	objptr, #4
00ad0     31 09 68 FC | 	wrlong	#4, objptr
00ad4     04 62 86 F1 | 	sub	objptr, #4
00ad8     31 91 02 FB | 	rdlong	arg01, objptr
00adc     04 62 86 F1 | 	sub	objptr, #4
00ae0     31 93 02 FB | 	rdlong	arg02, objptr
00ae4     0C 62 06 F1 | 	add	objptr, #12
00ae8     E8 0E B0 FD | 	call	#_hg010b_spin2_cls
00aec     04 62 86 F1 | 	sub	objptr, #4
00af0     31 91 02 FB | 	rdlong	arg01, objptr
00af4     04 62 06 F1 | 	add	objptr, #4
00af8     2C 0E B0 FD | 	call	#_hg010b_spin2_setfontfamily
00afc                 | ' 
00afc                 | ' leading_spaces:=amount
00afc     01 00 00 FF 
00b00     BA 62 06 F1 | 	add	objptr, ##698
00b04     31 05 68 FC | 	wrlong	#2, objptr
00b08     01 00 00 FF 
00b0c     DE 62 86 F1 | 	sub	objptr, ##734
00b10     71 00 00 FF 
00b14     40 A7 06 F6 | 	mov	local01, ##@LR__2172
00b18     3D 90 06 F6 | 	mov	arg01, #61
00b1c     3C 92 06 F6 | 	mov	arg02, #60
00b20     3B 94 06 F6 | 	mov	arg03, #59
00b24     3A 96 06 F6 | 	mov	arg04, #58
00b28     60 4F B0 FD | 	call	#__system___vfs_open_sdcardx
00b2c     3B 93 02 F6 | 	mov	arg02, result1
00b30     53 91 02 F6 | 	mov	arg01, local01
00b34     20 28 B0 FD | 	call	#__system___mount
00b38     71 00 00 FF 
00b3c     44 91 06 F6 | 	mov	arg01, ##@LR__2173
00b40     D8 2A B0 FD | 	call	#__system___chdir
00b44     71 00 00 FF 
00b48     4C A7 06 F6 | 	mov	local01, ##@LR__2174
00b4c     0E 00 00 FF 
00b50     60 62 06 F1 | 	add	objptr, ##7264
00b54     31 A7 62 FC | 	wrlong	local01, objptr
00b58     0E 00 00 FF 
00b5c     60 62 86 F1 | 	sub	objptr, ##7264
00b60                 | ' print: print "kwas"
00b60     00 90 06 F6 | 	mov	arg01, #0
00b64     74 5A B0 FD | 	call	#__system___getiolock_0133
00b68     3B 91 02 F6 | 	mov	arg01, result1
00b6c     2C 26 B0 FD | 	call	#__system___lockmem
00b70     00 90 06 F6 | 	mov	arg01, #0
00b74     0A 92 06 F6 | 	mov	arg02, #10
00b78     00 94 06 F6 | 	mov	arg03, #0
00b7c     04 30 B0 FD | 	call	#__system___basic_print_char
00b80     00 90 06 F6 | 	mov	arg01, #0
00b84     54 5A B0 FD | 	call	#__system___getiolock_0133
00b88     3B 01 68 FC | 	wrlong	#0, result1
00b8c     00 90 06 F6 | 	mov	arg01, #0
00b90     48 5A B0 FD | 	call	#__system___getiolock_0133
00b94     3B 91 02 F6 | 	mov	arg01, result1
00b98     00 26 B0 FD | 	call	#__system___lockmem
00b9c     71 00 00 FF 
00ba0     54 93 06 F6 | 	mov	arg02, ##@LR__2175
00ba4     00 90 06 F6 | 	mov	arg01, #0
00ba8     00 94 06 F6 | 	mov	arg03, #0
00bac     2C 30 B0 FD | 	call	#__system___basic_print_string
00bb0     00 90 06 F6 | 	mov	arg01, #0
00bb4     0A 92 06 F6 | 	mov	arg02, #10
00bb8     00 94 06 F6 | 	mov	arg03, #0
00bbc     C4 2F B0 FD | 	call	#__system___basic_print_char
00bc0     00 90 06 F6 | 	mov	arg01, #0
00bc4     14 5A B0 FD | 	call	#__system___getiolock_0133
00bc8     3B 01 68 FC | 	wrlong	#0, result1
00bcc     00 92 06 F6 | 	mov	arg02, #0
00bd0     01 92 D6 F7 | 	test	arg02, #1 wc
00bd4     5A 4C 64 FD | 	drvc	#38
00bd8     01 92 D6 F7 | 	test	arg02, #1 wc
00bdc     5A 4E 64 FD | 	drvc	#39
00be0     24 62 06 F1 | 	add	objptr, #36
00be4     31 91 02 F6 | 	mov	arg01, objptr
00be8     71 00 00 FF 
00bec     59 A5 06 F6 | 	mov	arg11, ##@LR__2176
00bf0     64 92 06 F6 | 	mov	arg02, #100
00bf4     64 94 06 F6 | 	mov	arg03, #100
00bf8     10 96 06 F6 | 	mov	arg04, #16
00bfc     2C 99 06 F6 | 	mov	arg05, #300
00c00     00 9A 06 F6 | 	mov	arg06, #0
00c04     0A 9C 06 F6 | 	mov	arg07, #10
00c08     0B 9E 06 F6 | 	mov	arg08, #11
00c0c     F4 A0 06 F6 | 	mov	arg09, #244
00c10     F8 A2 06 F6 | 	mov	arg10, #248
00c14     0E 00 00 FF 
00c18     40 62 06 F1 | 	add	objptr, ##7232
00c1c     E4 1D B0 FD | 	call	#_trackbar_create
00c20     0E 00 00 FF 
00c24     40 62 86 F1 | 	sub	objptr, ##7232
00c28     31 91 02 F6 | 	mov	arg01, objptr
00c2c     71 00 00 FF 
00c30     5A 9B 06 F6 | 	mov	arg06, ##@LR__2177
00c34     C8 92 06 F6 | 	mov	arg02, #200
00c38     C8 94 06 F6 | 	mov	arg03, #200
00c3c     2C 97 06 F6 | 	mov	arg04, #300
00c40     2C 99 06 F6 | 	mov	arg05, #300
00c44     0A 9C 06 F6 | 	mov	arg07, #10
00c48     0F 9E 06 F6 | 	mov	arg08, #15
00c4c     78 A0 06 F6 | 	mov	arg09, #120
00c50     19 00 00 FF 
00c54     3C 63 06 F1 | 	add	objptr, ##13116
00c58     C8 1B B0 FD | 	call	#_window_create
00c5c     19 00 00 FF 
00c60     60 63 86 F1 | 	sub	objptr, ##13152
00c64     E7 F0 03 F6 | 	mov	ptra, fp
00c68     F2 00 A0 FD | 	call	#popregs_
00c6c                 | _program_ret
00c6c     2D 00 64 FD | 	ret
00c70                 | 
00c70                 | ' '' this is not a main program.
00c70                 | ' 
00c70                 | ' '****************************************************************************************************************
00c70                 | ' '                                                                                                             	*
00c70                 | ' 'Start the driver  at pins 'base'                            					rev 20230829 	*
00c70                 | ' '                                                                                                            	*
00c70                 | ' ' base - HDMI base pin												*
00c70                 | ' ' mb - PSRAM mailbox pointer, 0 if no PSRAM									*
00c70                 | ' '														*
00c70                 | ' '														*
00c70                 | ' '****************************************************************************************************************
00c70                 | ' 
00c70                 | ' pub start(base,mb):result |i
00c70                 | _hg010b_spin2_start
00c70                 | ' 
00c70                 | ' '--------------------------- initialize pointers and variables
00c70                 | ' 
00c70                 | ' border_ptr:=@bordercolor					' Initial border color pointer, can be changed via DL
00c70     34 62 06 F1 | 	add	objptr, #52
00c74     31 77 02 F6 | 	mov	result1, objptr
00c78     28 62 86 F1 | 	sub	objptr, #40
00c7c     31 77 62 FC | 	wrlong	result1, objptr
00c80                 | ' 'font_ptr:=@amiga_font						' Initial 8x16 font definition
00c80                 | ' hdmibase:=base							' HDMI base pin, 8*n
00c80     18 62 06 F1 | 	add	objptr, #24
00c84     31 91 62 FC | 	wrlong	arg01, objptr
00c88                 | ' mailbox_ptr:=mb		
00c88     04 62 06 F1 | 	add	objptr, #4
00c8c     31 93 62 FC | 	wrlong	arg02, objptr
00c90                 | ' mailbox0:=mb				' PSRAM mailbox pointer
00c90     C5 63 06 F1 | 	add	objptr, #453
00c94     31 93 62 FC | 	wrlong	arg02, objptr
00c98                 | ' sprite_ptr:=@spr1ptr
00c98     D8 62 86 F1 | 	sub	objptr, #216
00c9c     31 77 02 F6 | 	mov	result1, objptr
00ca0     E9 62 86 F1 | 	sub	objptr, #233
00ca4     31 77 62 FC | 	wrlong	result1, objptr
00ca8                 | ' 
00ca8                 | ' 		'
00ca8                 | ' word[spr1ptr+17*12+4]:=8				' spr18w
00ca8     E9 62 06 F1 | 	add	objptr, #233
00cac     31 77 02 FB | 	rdlong	result1, objptr
00cb0     D0 76 06 F1 | 	add	result1, #208
00cb4     3B 11 58 FC | 	wrword	#8, result1
00cb8                 | ' word[spr1ptr+17*12+6]:=16				' for a blinking cursor
00cb8     31 95 02 FB | 	rdlong	arg03, objptr
00cbc     D2 94 06 F1 | 	add	arg03, #210
00cc0     4A 21 58 FC | 	wrword	#16, arg03
00cc4                 | ' leading_spaces:=0				'
00cc4     A5 63 06 F1 | 	add	objptr, #421
00cc8     31 01 68 FC | 	wrlong	#0, objptr
00ccc                 | ' 
00ccc                 | ' emptydl[0]:=%0100_0000_0000_0000_0000_0000_0000_0111
00ccc     99 62 86 F1 | 	sub	objptr, #153
00cd0     00 00 A0 FF 
00cd4     31 0F 68 FC | 	wrlong	##1073741831, objptr
00cd8                 | ' emptydl[1]:=0
00cd8     04 62 06 F1 | 	add	objptr, #4
00cdc     31 01 68 FC | 	wrlong	#0, objptr
00ce0                 | ' 
00ce0                 | ' '---------------------------- the mode has to be set here to enable computing the buffer length
00ce0                 | ' 
00ce0                 | ' s_debug:=debugger						' check if debug mode defined (eats 16 kB upper RAM so don't use it)					' 
00ce0     28 63 86 F1 | 	sub	objptr, #296
00ce4     31 03 68 FC | 	wrlong	#1, objptr
00ce8                 | ' if s_debug<>0
00ce8                 | '   s_debug:=16384						' the buffers adresses will be corrected to not interfere with the debugger
00ce8     20 00 80 FF 
00cec     31 01 68 FC | 	wrlong	##16384, objptr
00cf0     FD 62 86 F1 | 	sub	objptr, #253
00cf4                 | ' setmode()							' set the mode, see below
00cf4     34 02 B0 FD | 	call	#_hg010b_spin2_setmode
00cf8                 | ' vblank_ptr:=@vblank						' set pointers before starting the driver
00cf8     49 62 06 F1 | 	add	objptr, #73
00cfc     31 77 02 F6 | 	mov	result1, objptr
00d00     35 62 86 F1 | 	sub	objptr, #53
00d04     31 77 62 FC | 	wrlong	result1, objptr
00d08                 | ' cursor_ptr:=@cursor_x						
00d08     28 62 06 F1 | 	add	objptr, #40
00d0c     31 95 02 F6 | 	mov	arg03, objptr
00d10     2C 62 86 F1 | 	sub	objptr, #44
00d14     31 95 62 FC | 	wrlong	arg03, objptr
00d18                 | ' fontnum:=0  							' start with a PC type font 
00d18     55 62 06 F1 | 	add	objptr, #85
00d1c     31 01 68 FC | 	wrlong	#0, objptr
00d20                 | ' bytemove(@colors,@vgacolors,16)					' prepare standard DOS VGA colors
00d20     1C 62 06 F1 | 	add	objptr, #28
00d24     31 91 02 F6 | 	mov	arg01, objptr
00d28     81 62 86 F1 | 	sub	objptr, #129
00d2c     36 93 02 F6 | 	mov	arg02, ptr__hg010b_spin2_dat__
00d30     1C 00 00 FF 
00d34     80 92 06 F1 | 	add	arg02, ##14464
00d38     10 94 06 F6 | 	mov	arg03, #16
00d3c     7C 23 B0 FD | 	call	#__system____builtin_memmove
00d40                 | ' leading_spaces:=0
00d40     01 00 00 FF 
00d44     BA 62 06 F1 | 	add	objptr, ##698
00d48     31 01 68 FC | 	wrlong	#0, objptr
00d4c     01 00 00 FF 
00d50     BA 62 86 F1 | 	sub	objptr, ##698
00d54                 | ' '---------------------------- initialize a cursor (MSDOS type)
00d54                 | ' 
00d54                 | ' initcursor(154)
00d54     9A 90 06 F6 | 	mov	arg01, #154
00d58     4C 00 B0 FD | 	call	#_hg010b_spin2_initcursor
00d5c                 | ' font_family8:=6
00d5c     99 62 06 F1 | 	add	objptr, #153
00d60     31 0D 68 FC | 	wrlong	#6, objptr
00d64                 | ' 
00d64                 | ' '---------------------------- start the cog
00d64                 | ' 
00d64                 | ' cog:=coginit(16,@hdmi, @vblank_ptr)				' start the driver cog			
00d64     36 93 02 F6 | 	mov	arg02, ptr__hg010b_spin2_dat__
00d68     1C 00 00 FF 
00d6c     90 92 06 F1 | 	add	arg02, ##14480
00d70     85 62 86 F1 | 	sub	objptr, #133
00d74     10 76 06 F6 | 	mov	result1, #16
00d78     28 62 62 FD | 	setq	objptr
00d7c     49 77 F2 FC | 	coginit	result1, arg02 wc
00d80     01 76 66 C6 |  if_b	neg	result1, #1
00d84     1C 62 06 F1 | 	add	objptr, #28
00d88     31 77 62 FC | 	wrlong	result1, objptr
00d8c     30 62 86 F1 | 	sub	objptr, #48
00d90                 | ' waitms(40)							' wait for stabilize
00d90     28 90 06 F6 | 	mov	arg01, #40
00d94     E8 24 B0 FD | 	call	#__system___waitms
00d98                 | ' return cog							' return the driver's cog #
00d98     30 62 06 F1 | 	add	objptr, #48
00d9c     31 77 02 FB | 	rdlong	result1, objptr
00da0     30 62 86 F1 | 	sub	objptr, #48
00da4                 | _hg010b_spin2_start_ret
00da4     2D 00 64 FD | 	ret
00da8                 | 
00da8                 | ' 
00da8                 | ' '---------------------------- initialize a cursor (MSDOS type)
00da8                 | ' pub initcursor(color) |i
00da8                 | _hg010b_spin2_initcursor
00da8     03 CA 05 F6 | 	mov	COUNT_, #3
00dac     E8 00 A0 FD | 	call	#pushregs_
00db0     48 A7 02 F6 | 	mov	local01, arg01
00db4                 | ' 
00db4                 | ' cursor_x:=0							' place the cursor at 0:0
00db4     3C 62 06 F1 | 	add	objptr, #60
00db8     31 01 58 FC | 	wrword	#0, objptr
00dbc                 | ' cursor_y:=0
00dbc     02 62 06 F1 | 	add	objptr, #2
00dc0     31 01 48 FC | 	wrbyte	#0, objptr
00dc4                 | ' repeat i from 0 to 111
00dc4     00 A8 06 F6 | 	mov	local02, #0
00dc8     FC 63 06 F1 | 	add	objptr, #508
00dcc     D7 0C 48 FB | 	callpa	#(@LR__0011-@LR__0010)>>2,fcache_load_ptr_
00dd0                 | LR__0010
00dd0                 | '   cursor[i]:=0
00dd0     54 AB 02 F6 | 	mov	local03, local02
00dd4     31 AB 02 F1 | 	add	local03, objptr
00dd8     55 01 48 FC | 	wrbyte	#0, local03
00ddc     01 A8 06 F1 | 	add	local02, #1
00de0     70 A8 56 F2 | 	cmps	local02, #112 wc
00de4     E8 FF 9F CD |  if_b	jmp	#LR__0010
00de8                 | LR__0011
00de8                 | ' repeat i from 112 to 127
00de8     70 A8 06 F6 | 	mov	local02, #112
00dec     D7 0C 48 FB | 	callpa	#(@LR__0013-@LR__0012)>>2,fcache_load_ptr_
00df0                 | LR__0012
00df0                 | '   cursor[i]:=color  
00df0     54 AB 02 F6 | 	mov	local03, local02
00df4     31 AB 02 F1 | 	add	local03, objptr
00df8     55 A7 42 FC | 	wrbyte	local01, local03
00dfc     01 A8 06 F1 | 	add	local02, #1
00e00     80 A8 16 F2 | 	cmp	local02, #128 wc
00e04     E8 FF 9F CD |  if_b	jmp	#LR__0012
00e08                 | LR__0013
00e08     01 00 00 FF 
00e0c     3A 62 86 F1 | 	sub	objptr, ##570
00e10                 | ' 'repeat i from 0 to 127
00e10                 | ' '  if ((i/8)//2)
00e10                 | ' '    cursor[i]:=15
00e10                 | ' '  else
00e10                 | ' '    cursor[i]:=0
00e10                 | ' '  if i>=120    
00e10                 | ' '    cursor[i]:=40
00e10                 | ' setspriteptr(17,@cursor)
00e10     31 93 02 F6 | 	mov	arg02, objptr
00e14     01 00 00 FF 
00e18     3A 92 06 F1 | 	add	arg02, ##570
00e1c     11 90 06 F6 | 	mov	arg01, #17
00e20     14 04 B0 FD | 	call	#_hg010b_spin2_setspriteptr
00e24                 | ' setspritesize(17,8,16)
00e24     11 90 06 F6 | 	mov	arg01, #17
00e28     08 92 06 F6 | 	mov	arg02, #8
00e2c     10 94 06 F6 | 	mov	arg03, #16
00e30     90 04 B0 FD | 	call	#_hg010b_spin2_setspritesize
00e34                 | ' setspritepos(17,0,0)
00e34     11 90 06 F6 | 	mov	arg01, #17
00e38     00 92 06 F6 | 	mov	arg02, #0
00e3c     00 94 06 F6 | 	mov	arg03, #0
00e40     18 04 B0 FD | 	call	#_hg010b_spin2_setspritepos
00e44                 | ' cursorshape:=14
00e44     0B 00 00 FF 
00e48     CA 62 06 F1 | 	add	objptr, ##5834
00e4c     31 1D 68 FC | 	wrlong	#14, objptr
00e50                 | ' cursorcolor:=color
00e50     04 62 86 F1 | 	sub	objptr, #4
00e54     31 A7 62 FC | 	wrlong	local01, objptr
00e58     0B 00 00 FF 
00e5c     C6 62 86 F1 | 	sub	objptr, ##5830
00e60     E7 F0 03 F6 | 	mov	ptra, fp
00e64     F2 00 A0 FD | 	call	#popregs_
00e68                 | _hg010b_spin2_initcursor_ret
00e68     2D 00 64 FD | 	ret
00e6c                 | 
00e6c                 | ' 
00e6c                 | ' pub setcursorcolor(color) | i
00e6c                 | _hg010b_spin2_setcursorcolor
00e6c                 | ' 
00e6c                 | ' cursorcolor:=color
00e6c     0B 00 00 FF 
00e70     C6 62 06 F1 | 	add	objptr, ##5830
00e74     31 91 62 FC | 	wrlong	arg01, objptr
00e78                 | ' repeat i from 0 to (8*cursorshape)-1
00e78     00 90 06 F6 | 	mov	arg01, #0
00e7c     04 62 06 F1 | 	add	objptr, #4
00e80     31 7D 02 FB | 	rdlong	_var01, objptr
00e84     03 7C 66 F0 | 	shl	_var01, #3
00e88     01 7C 86 F1 | 	sub	_var01, #1
00e8c     00 7C 56 F2 | 	cmps	_var01, #0 wc
00e90     01 7E 86 F6 | 	negc	_var02, #1
00e94     3F 81 02 F6 | 	mov	_var03, _var02
00e98     3F 7D 02 F1 | 	add	_var01, _var02
00e9c     0A 00 00 FF 
00ea0     90 62 86 F1 | 	sub	objptr, ##5264
00ea4     D7 0C 48 FB | 	callpa	#(@LR__0021-@LR__0020)>>2,fcache_load_ptr_
00ea8                 | LR__0020
00ea8                 | '   cursor[i]:=0
00ea8     48 7F 02 F6 | 	mov	_var02, arg01
00eac     31 7F 02 F1 | 	add	_var02, objptr
00eb0     3F 01 48 FC | 	wrbyte	#0, _var02
00eb4     40 91 02 F1 | 	add	arg01, _var03
00eb8     3E 91 0A F2 | 	cmp	arg01, _var01 wz
00ebc     E8 FF 9F 5D |  if_ne	jmp	#LR__0020
00ec0                 | LR__0021
00ec0                 | ' repeat i from 8*cursorshape to 127
00ec0     0A 00 00 FF 
00ec4     90 62 06 F1 | 	add	objptr, ##5264
00ec8     31 81 02 FB | 	rdlong	_var03, objptr
00ecc     40 91 02 F6 | 	mov	arg01, _var03
00ed0     03 90 66 F0 | 	shl	arg01, #3
00ed4     0B 00 00 FF 
00ed8     CA 62 86 F1 | 	sub	objptr, ##5834
00edc     03 80 66 F0 | 	shl	_var03, #3
00ee0     80 80 56 F2 | 	cmps	_var03, #128 wc
00ee4     01 7E A6 F6 | 	negnc	_var02, #1
00ee8     7F 7C 06 F6 | 	mov	_var01, #127
00eec     3F 7D 02 F1 | 	add	_var01, _var02
00ef0     D7 1A 48 FB | 	callpa	#(@LR__0023-@LR__0022)>>2,fcache_load_ptr_
00ef4                 | LR__0022
00ef4                 | '   cursor[i]:=cursorcolor
00ef4     48 81 02 F6 | 	mov	_var03, arg01
00ef8     01 00 00 FF 
00efc     3A 62 06 F1 | 	add	objptr, ##570
00f00     31 81 02 F1 | 	add	_var03, objptr
00f04     0A 00 00 FF 
00f08     8C 62 06 F1 | 	add	objptr, ##5260
00f0c     31 83 02 FB | 	rdlong	_var04, objptr
00f10     0B 00 00 FF 
00f14     C6 62 86 F1 | 	sub	objptr, ##5830
00f18     40 83 42 FC | 	wrbyte	_var04, _var03
00f1c     3F 91 02 F1 | 	add	arg01, _var02
00f20     3E 91 0A F2 | 	cmp	arg01, _var01 wz
00f24     CC FF 9F 5D |  if_ne	jmp	#LR__0022
00f28                 | LR__0023
00f28                 | _hg010b_spin2_setcursorcolor_ret
00f28     2D 00 64 FD | 	ret
00f2c                 | 
00f2c                 | '   
00f2c                 | '   
00f2c                 | '   
00f2c                 | ' pub setmode() | i', 'xzoom, yzoom, azoom
00f2c                 | _hg010b_spin2_setmode
00f2c     02 CA 05 F6 | 	mov	COUNT_, #2
00f30     E8 00 A0 FD | 	call	#pushregs_
00f34                 | ' 
00f34                 | ' 
00f34                 | ' dl_ptr:=@emptydl[0]
00f34     01 00 00 FF 
00f38     21 62 06 F1 | 	add	objptr, ##545
00f3c     31 99 02 F6 | 	mov	arg05, objptr
00f40     01 00 00 FF 
00f44     01 62 86 F1 | 	sub	objptr, ##513
00f48     31 99 62 FC | 	wrlong	arg05, objptr
00f4c                 | ' 
00f4c                 | ' if cog>0 
00f4c     10 62 06 F1 | 	add	objptr, #16
00f50     31 99 02 FB | 	rdlong	arg05, objptr
00f54     30 62 86 F1 | 	sub	objptr, #48
00f58     01 98 56 F2 | 	cmps	arg05, #1 wc
00f5c                 | '    waitvbl(1)						    	' if the driver is active, wait for vblank to set the new mode and DL	
00f5c     01 90 06 36 |  if_ae	mov	arg01, #1
00f60     00 0A B0 3D |  if_ae	call	#_hg010b_spin2_waitvbl
00f64                 | ' xres:=1024
00f64     01 00 00 FF 
00f68     2A 62 06 F1 | 	add	objptr, ##554
00f6c     02 00 80 FF 
00f70     31 01 68 FC | 	wrlong	##1024, objptr
00f74                 | ' yres:=600
00f74     04 62 06 F1 | 	add	objptr, #4
00f78     01 00 80 FF 
00f7c     31 B1 68 FC | 	wrlong	##600, objptr
00f80                 | ' ppl:=(timings[3])
00f80     1C 00 00 FF 
00f84     4C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14412
00f88     36 99 02 FB | 	rdlong	arg05, ptr__hg010b_spin2_dat__
00f8c     51 63 86 F1 | 	sub	objptr, #337
00f90     31 99 62 FC | 	wrlong	arg05, objptr
00f94                 | ' cpl:=timings[7]<<1                                      	' now cpl is longs per line
00f94     10 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, #16
00f98     36 A7 02 FB | 	rdlong	local01, ptr__hg010b_spin2_dat__
00f9c     01 A6 66 F0 | 	shl	local01, #1
00fa0     84 62 86 F1 | 	sub	objptr, #132
00fa4     31 A7 62 FC | 	wrlong	local01, objptr
00fa8                 | ' cpl1:=cpl '' todo remove
00fa8     04 62 06 F1 | 	add	objptr, #4
00fac     31 A7 62 FC | 	wrlong	local01, objptr
00fb0                 | ' palette_ptr:=@ataripalette				    	' use 256-colors palettr
00fb0     04 00 00 FF 
00fb4     1C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##2076
00fb8     41 62 86 F1 | 	sub	objptr, #65
00fbc     31 6D 62 FC | 	wrlong	ptr__hg010b_spin2_dat__, objptr
00fc0                 | ' repeat i from 0 to 3
00fc0     00 A8 06 F6 | 	mov	local02, #0
00fc4     04 00 00 FF 
00fc8     00 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##2048
00fcc     08 62 06 F1 | 	add	objptr, #8
00fd0     D7 20 48 FB | 	callpa	#(@LR__0031-@LR__0030)>>2,fcache_load_ptr_
00fd4                 | LR__0030
00fd4                 | '   timings[i]:=timings[i]+hdmibase<<17+ timingsxxt          	' add a streamer config (imm->pins) to horizontal timings 
00fd4     54 A7 02 F6 | 	mov	local01, local02
00fd8     02 A6 66 F0 | 	shl	local01, #2
00fdc     36 A7 02 F1 | 	add	local01, ptr__hg010b_spin2_dat__
00fe0     31 99 02 FB | 	rdlong	arg05, objptr
00fe4     11 98 66 F0 | 	shl	arg05, #17
00fe8     53 A7 02 FB | 	rdlong	local01, local01
00fec     4C A7 02 F1 | 	add	local01, arg05
00ff0     80 40 38 FF 
00ff4     00 A6 06 F1 | 	add	local01, ##1887502336
00ff8     54 99 02 F6 | 	mov	arg05, local02
00ffc     02 98 66 F0 | 	shl	arg05, #2
01000     36 99 02 F1 | 	add	arg05, ptr__hg010b_spin2_dat__
01004     4C A7 62 FC | 	wrlong	local01, arg05
01008     01 A8 06 F1 | 	add	local02, #1
0100c     04 A8 56 F2 | 	cmps	local02, #4 wc
01010     C0 FF 9F CD |  if_b	jmp	#LR__0030
01014                 | LR__0031
01014     24 62 86 F1 | 	sub	objptr, #36
01018     1C 00 00 FF 
0101c     40 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14400
01020                 | ' 'clkfreq:=timings[9]					    	' set the clock frequency for the mode
01020                 | ' 'hubset(timings[10])
01020                 | ' waitms(1)                                                   	' wait for stabilization
01020     01 90 06 F6 | 	mov	arg01, #1
01024     58 22 B0 FD | 	call	#__system___waitms
01028     1C 00 00 FF 
0102c     6C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14444
01030     36 A9 02 FB | 	rdlong	local02, ptr__hg010b_spin2_dat__
01034     61 62 06 F1 | 	add	objptr, #97
01038     31 A9 62 FC | 	wrlong	local02, objptr
0103c     54 A7 52 F6 | 	abs	local01, local02 wc
01040     04 A6 46 F0 | 	shr	local01, #4
01044     53 A7 82 F6 | 	negc	local01, local01
01048     A0 62 06 F1 | 	add	objptr, #160
0104c     31 A7 62 FC | 	wrlong	local01, objptr
01050     A8 62 86 F1 | 	sub	objptr, #168
01054     31 A9 02 FB | 	rdlong	local02, objptr
01058     08 62 06 F1 | 	add	objptr, #8
0105c     31 A7 02 FB | 	rdlong	local01, objptr
01060     53 A9 02 FD | 	qmul	local02, local01
01064                 | ' lines:=timings[11]
01064                 | ' t_lines:=lines/16
01064                 | ' buflen:=cpl*lines						' framebuffer length in longs
01064     29 62 86 F1 | 	sub	objptr, #41
01068     19 A6 C6 F9 | 	decod	local01, #25
0106c     10 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, #16
01070     18 A8 62 FD | 	getqx	local02
01074     31 A9 62 FC | 	wrlong	local02, objptr
01078     38 62 86 F1 | 	sub	objptr, #56
0107c     02 A8 66 F0 | 	shl	local02, #2
01080     54 A7 82 F1 | 	sub	local01, local02
01084     31 A7 62 FC | 	wrlong	local01, objptr
01088     01 63 06 F1 | 	add	objptr, #257
0108c     31 A9 02 FB | 	rdlong	local02, objptr
01090     36 99 02 FB | 	rdlong	arg05, ptr__hg010b_spin2_dat__
01094     4C A9 02 FD | 	qmul	local02, arg05
01098                 | ' buf_ptr:=$2000000-4*buflen                          	     	' todo: get a PSRAM real himem 
01098                 | ' textbuf_ptr:=buf_ptr-t_lines*timings[7]
01098     FD 62 86 F1 | 	sub	objptr, #253
0109c                 | ' mode_ptr:=@timings						' set pointers to timings
0109c     1C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, #28
010a0                 | ' graphmode:=1024+512+192+48							' det global variable
010a0                 | ' makedl(graphmode)							' make a DL for the mode
010a0     03 00 00 FF 
010a4     F0 90 06 F6 | 	mov	arg01, ##1776
010a8     18 A8 62 FD | 	getqx	local02
010ac     54 A7 82 F1 | 	sub	local01, local02
010b0     31 A7 62 FC | 	wrlong	local01, objptr
010b4     14 62 06 F1 | 	add	objptr, #20
010b8     31 6D 62 FC | 	wrlong	ptr__hg010b_spin2_dat__, objptr
010bc     79 62 06 F1 | 	add	objptr, #121
010c0     03 00 80 FF 
010c4     31 E1 69 FC | 	wrlong	##1776, objptr
010c8     91 62 86 F1 | 	sub	objptr, #145
010cc     1C 00 00 FF 
010d0     40 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14400
010d4     E0 00 B0 FD | 	call	#_hg010b_spin2_makedl
010d8                 | ' s_buf_ptr:=buf_ptr						' secondary copies of main framebuffer parameters 
010d8     31 A7 02 FB | 	rdlong	local01, objptr
010dc     E1 62 06 F1 | 	add	objptr, #225
010e0     31 A7 62 FC | 	wrlong	local01, objptr
010e4                 | ' s_font_ptr:=font_ptr
010e4     D9 62 86 F1 | 	sub	objptr, #217
010e8     31 A7 02 FB | 	rdlong	local01, objptr
010ec     DD 62 06 F1 | 	add	objptr, #221
010f0     31 A7 62 FC | 	wrlong	local01, objptr
010f4                 | ' s_lines:=lines
010f4     84 62 86 F1 | 	sub	objptr, #132
010f8     31 A7 02 FB | 	rdlong	local01, objptr
010fc     88 62 06 F1 | 	add	objptr, #136
01100     31 A7 62 FC | 	wrlong	local01, objptr
01104                 | ' s_buflen:=buflen
01104     B1 62 86 F1 | 	sub	objptr, #177
01108     31 A7 02 FB | 	rdlong	local01, objptr
0110c     B9 62 06 F1 | 	add	objptr, #185
01110     31 A7 62 FC | 	wrlong	local01, objptr
01114                 | ' s_cpl:=cpl
01114     98 62 86 F1 | 	sub	objptr, #152
01118     31 A7 02 FB | 	rdlong	local01, objptr
0111c     94 62 06 F1 | 	add	objptr, #148
01120     31 A7 62 FC | 	wrlong	local01, objptr
01124                 | ' s_cpl1:=cpl
01124     94 62 86 F1 | 	sub	objptr, #148
01128     31 A7 02 FB | 	rdlong	local01, objptr
0112c     9C 62 06 F1 | 	add	objptr, #156
01130     31 A7 62 FC | 	wrlong	local01, objptr
01134                 | ' st_lines:=t_lines
01134     0C 62 06 F1 | 	add	objptr, #12
01138     31 A7 02 FB | 	rdlong	local01, objptr
0113c     04 62 06 F1 | 	add	objptr, #4
01140     31 A7 62 FC | 	wrlong	local01, objptr
01144                 | ' ppl:=ppl/xzoom  
01144     28 62 86 F1 | 	sub	objptr, #40
01148     31 F9 02 FB | 	rdlong	muldiva_, objptr
0114c     2C 62 06 F1 | 	add	objptr, #44
01150     31 FB 02 FB | 	rdlong	muldivb_, objptr
01154     09 63 86 F1 | 	sub	objptr, #265
01158     FA 00 A0 FD | 	call	#divide_
0115c     DD 62 06 F1 | 	add	objptr, #221
01160     31 FB 62 FC | 	wrlong	muldivb_, objptr
01164                 | ' s_ppl:=ppl
01164     1C 62 06 F1 | 	add	objptr, #28
01168     31 FB 62 FC | 	wrlong	muldivb_, objptr
0116c     F9 62 86 F1 | 	sub	objptr, #249
01170                 | ' waitms(20)							' wait 
01170     14 90 06 F6 | 	mov	arg01, #20
01174     08 21 B0 FD | 	call	#__system___waitms
01178                 | ' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
01178     04 62 06 F1 | 	add	objptr, #4
0117c     31 91 02 FB | 	rdlong	arg01, objptr
01180     04 62 86 F1 | 	sub	objptr, #4
01184     31 95 02 FB | 	rdlong	arg03, objptr
01188     48 95 82 F1 | 	sub	arg03, arg01
0118c     20 92 06 F6 | 	mov	arg02, #32
01190     00 96 06 F6 | 	mov	arg04, #0
01194     01 98 06 F6 | 	mov	arg05, #1
01198     0B 00 00 FF 
0119c     D0 62 06 F1 | 	add	objptr, ##5840
011a0     F0 10 B0 FD | 	call	#_psram_spin2_fill
011a4     0B 00 00 FF 
011a8     D0 62 86 F1 | 	sub	objptr, ##5840
011ac     E7 F0 03 F6 | 	mov	ptra, fp
011b0     F2 00 A0 FD | 	call	#popregs_
011b4                 | _hg010b_spin2_setmode_ret
011b4     2D 00 64 FD | 	ret
011b8                 | 
011b8                 | ' 
011b8                 | ' '****************************************************************************************************************
011b8                 | ' '                                                                                                             	*
011b8                 | ' '  Make a display list for simple standard modes                                             	rev.20220319    *
011b8                 | ' '                                                                                                             	*
011b8                 | ' '****************************************************************************************************************
011b8                 | ' 
011b8                 | ' pub makedl(mode) |i,vzoom,border,psbuf,lines2
011b8                 | _hg010b_spin2_makedl
011b8                 | ' 
011b8                 | ' psbuf:=$80000-s_debug-1024                                                     ' HUB line buffer on the top of HUB RAM (-16 kB if debug enabled)
011b8                 | ' vzoom:=1<<((mode>>2) & 3)                                                      ' real vzoom from mode#
011b8                 | ' repeat i from 0 to 11                                                           ' clear DL
011b8     00 7C 06 F6 | 	mov	_var01, #0
011bc     F1 63 06 F1 | 	add	objptr, #497
011c0     D7 0E 48 FB | 	callpa	#(@LR__0041-@LR__0040)>>2,fcache_load_ptr_
011c4                 | LR__0040
011c4                 | '   displaylist[i]:=0 
011c4     3E 7F 02 F6 | 	mov	_var02, _var01
011c8     02 7E 66 F0 | 	shl	_var02, #2
011cc     31 7F 02 F1 | 	add	_var02, objptr
011d0     3F 01 68 FC | 	wrlong	#0, _var02
011d4     01 7C 06 F1 | 	add	_var01, #1
011d8     0C 7C 56 F2 | 	cmps	_var01, #12 wc
011dc     E4 FF 9F CD |  if_b	jmp	#LR__0040
011e0                 | LR__0041
011e0                 | '                         ' 
011e0                 | ' displaylist[0]:=lines<<20+(0)<<16+%0001+ (0+(cpl1<<2)) <<4             
011e0     90 63 86 F1 | 	sub	objptr, #400
011e4     31 7F 02 FB | 	rdlong	_var02, objptr
011e8     14 7E 66 F0 | 	shl	_var02, #20
011ec     01 7E 06 F1 | 	add	_var02, #1
011f0     04 62 86 F1 | 	sub	objptr, #4
011f4     31 7D 02 FB | 	rdlong	_var01, objptr
011f8     06 7C 66 F0 | 	shl	_var01, #6
011fc     3E 7F 02 F1 | 	add	_var02, _var01
01200     94 63 06 F1 | 	add	objptr, #404
01204     31 7F 62 FC | 	wrlong	_var02, objptr
01208     F1 63 86 F1 | 	sub	objptr, #497
0120c                 | ' displaylist[1]:=buf_ptr<<4+%10  
0120c     31 7F 02 FB | 	rdlong	_var02, objptr
01210     04 7E 66 F0 | 	shl	_var02, #4
01214     02 7E 06 F1 | 	add	_var02, #2
01218     F5 63 06 F1 | 	add	objptr, #501
0121c     31 7F 62 FC | 	wrlong	_var02, objptr
01220                 | ' dl_ptr:=@displaylist[0] 						      ' tell the driver where to find the DL
01220     04 62 86 F1 | 	sub	objptr, #4
01224     31 7F 02 F6 | 	mov	_var02, objptr
01228     D1 63 86 F1 | 	sub	objptr, #465
0122c     31 7F 62 FC | 	wrlong	_var02, objptr
01230     20 62 86 F1 | 	sub	objptr, #32
01234                 | _hg010b_spin2_makedl_ret
01234     2D 00 64 FD | 	ret
01238                 | 
01238                 | ' 
01238                 | ' 
01238                 | ' '****************************************************************************************************************
01238                 | ' '                                                                        					*
01238                 | ' '  Graphic primitives                                                    					*
01238                 | ' '                                                                        					*
01238                 | ' '****************************************************************************************************************
01238                 | ' 
01238                 | ' pub setspriteptr(num,ptr)
01238                 | _hg010b_spin2_setspriteptr
01238                 | ' long[@spr1ptr+12*num]:=ptr
01238     31 7D 02 F6 | 	mov	_var01, objptr
0123c     15 7D 06 F1 | 	add	_var01, #277
01240     48 7F 02 F6 | 	mov	_var02, arg01
01244     01 7E 66 F0 | 	shl	_var02, #1
01248     48 7F 02 F1 | 	add	_var02, arg01
0124c     02 7E 66 F0 | 	shl	_var02, #2
01250     3F 7D 02 F1 | 	add	_var01, _var02
01254     3E 93 62 FC | 	wrlong	arg02, _var01
01258                 | _hg010b_spin2_setspriteptr_ret
01258     2D 00 64 FD | 	ret
0125c                 | 
0125c                 | ' 
0125c                 | ' pub setspritepos(num,x,y)
0125c                 | _hg010b_spin2_setspritepos
0125c                 | ' if y>601
0125c     01 00 00 FF 
01260     5A 94 56 F2 | 	cmps	arg03, ##602 wc
01264                 | '   y:=601
01264     01 00 00 3F 
01268     59 94 06 36 |  if_ae	mov	arg03, ##601
0126c                 | ' if x>1024
0126c     02 00 00 FF 
01270     01 92 56 F2 | 	cmps	arg02, ##1025 wc
01274                 | '   x:=1024
01274     0A 92 C6 39 |  if_ae	decod	arg02, #10
01278                 | ' word[@spr1ptr+12*num+4]:=x
01278     15 63 06 F1 | 	add	objptr, #277
0127c     31 7D 02 F6 | 	mov	_var01, objptr
01280     48 7F 02 F6 | 	mov	_var02, arg01
01284     01 7E 66 F0 | 	shl	_var02, #1
01288     48 7F 02 F1 | 	add	_var02, arg01
0128c     02 7E 66 F0 | 	shl	_var02, #2
01290     3F 7D 02 F1 | 	add	_var01, _var02
01294     04 7C 06 F1 | 	add	_var01, #4
01298     3E 93 52 FC | 	wrword	arg02, _var01
0129c                 | ' word[@spr1ptr+12*num+6]:=y
0129c     31 7D 02 F6 | 	mov	_var01, objptr
012a0     48 7F 02 F6 | 	mov	_var02, arg01
012a4     01 7E 66 F0 | 	shl	_var02, #1
012a8     48 7F 02 F1 | 	add	_var02, arg01
012ac     02 7E 66 F0 | 	shl	_var02, #2
012b0     3F 7D 02 F1 | 	add	_var01, _var02
012b4     06 7C 06 F1 | 	add	_var01, #6
012b8     3E 95 52 FC | 	wrword	arg03, _var01
012bc     15 63 86 F1 | 	sub	objptr, #277
012c0                 | _hg010b_spin2_setspritepos_ret
012c0     2D 00 64 FD | 	ret
012c4                 | 
012c4                 | ' 
012c4                 | ' pub setspritesize(num,w,h)
012c4                 | _hg010b_spin2_setspritesize
012c4                 | ' word[@spr1ptr+12*num+8]:=w
012c4     15 63 06 F1 | 	add	objptr, #277
012c8     31 7D 02 F6 | 	mov	_var01, objptr
012cc     48 7F 02 F6 | 	mov	_var02, arg01
012d0     01 7E 66 F0 | 	shl	_var02, #1
012d4     48 7F 02 F1 | 	add	_var02, arg01
012d8     02 7E 66 F0 | 	shl	_var02, #2
012dc     3F 7D 02 F1 | 	add	_var01, _var02
012e0     08 7C 06 F1 | 	add	_var01, #8
012e4     3E 93 52 FC | 	wrword	arg02, _var01
012e8                 | ' word[@spr1ptr+12*num+10]:=h
012e8     31 7D 02 F6 | 	mov	_var01, objptr
012ec     48 7F 02 F6 | 	mov	_var02, arg01
012f0     01 7E 66 F0 | 	shl	_var02, #1
012f4     48 7F 02 F1 | 	add	_var02, arg01
012f8     02 7E 66 F0 | 	shl	_var02, #2
012fc     3F 7D 02 F1 | 	add	_var01, _var02
01300     0A 7C 06 F1 | 	add	_var01, #10
01304     3E 95 52 FC | 	wrword	arg03, _var01
01308     15 63 86 F1 | 	sub	objptr, #277
0130c                 | _hg010b_spin2_setspritesize_ret
0130c     2D 00 64 FD | 	ret
01310                 | 
01310                 | ' 
01310                 | ' 
01310                 | ' ''---------- putpixel - put a pixel on the screen - a mother of all graphic functions ---------------------------
01310                 | ' 
01310                 | ' 
01310                 | ' pub putpixel(x,y,c)
01310                 | _hg010b_spin2_putpixel
01310     04 CA 05 F6 | 	mov	COUNT_, #4
01314     E8 00 A0 FD | 	call	#pushregs_
01318     48 A7 02 F6 | 	mov	local01, arg01
0131c                 | ' 
0131c                 | ' if ((x>=0) & (x<4*s_cpl) & (y>=0) & (y<s_lines))
0131c     00 A8 06 F6 | 	mov	local02, #0
01320     00 A6 56 F2 | 	cmps	local01, #0 wc
01324     01 A8 66 36 |  if_ae	neg	local02, #1
01328     ED 62 06 F1 | 	add	objptr, #237
0132c     31 99 02 FB | 	rdlong	arg05, objptr
01330     02 98 66 F0 | 	shl	arg05, #2
01334     4C A7 52 F2 | 	cmps	local01, arg05 wc
01338     55 AB A2 F1 | 	subx	local03, local03
0133c     55 A9 02 F5 | 	and	local02, local03
01340     00 AA 06 F6 | 	mov	local03, #0
01344     00 92 56 F2 | 	cmps	arg02, #0 wc
01348     01 AA 66 36 |  if_ae	neg	local03, #1
0134c     55 A9 02 F5 | 	and	local02, local03
01350     04 62 86 F1 | 	sub	objptr, #4
01354     31 AB 02 FB | 	rdlong	local03, objptr
01358     E9 62 86 F1 | 	sub	objptr, #233
0135c     55 93 52 F2 | 	cmps	arg02, local03 wc
01360     56 AD A2 F1 | 	subx	local04, local04
01364     56 A9 CA F7 | 	test	local02, local04 wz
01368     48 00 90 AD |  if_e	jmp	#LR__0050
0136c     E1 62 06 F1 | 	add	objptr, #225
01370     31 91 02 FB | 	rdlong	arg01, objptr
01374     14 62 06 F1 | 	add	objptr, #20
01378     31 AD 02 FB | 	rdlong	local04, objptr
0137c     02 AC 66 F0 | 	shl	local04, #2
01380     49 AD 02 FD | 	qmul	local04, arg02
01384                 | '   ram.fill(s_buf_ptr+(4*s_cpl1*y+x),c,1,0,1)
01384     4A 93 02 F6 | 	mov	arg02, arg03
01388     01 94 06 F6 | 	mov	arg03, #1
0138c     00 96 06 F6 | 	mov	arg04, #0
01390     01 98 06 F6 | 	mov	arg05, #1
01394     0A 00 00 FF 
01398     DB 63 06 F1 | 	add	objptr, ##5595
0139c     18 AC 62 FD | 	getqx	local04
013a0     53 AD 02 F1 | 	add	local04, local01
013a4     56 91 02 F1 | 	add	arg01, local04
013a8     E8 0E B0 FD | 	call	#_psram_spin2_fill
013ac     0B 00 00 FF 
013b0     D0 62 86 F1 | 	sub	objptr, ##5840
013b4                 | LR__0050
013b4     E7 F0 03 F6 | 	mov	ptra, fp
013b8     F2 00 A0 FD | 	call	#popregs_
013bc                 | _hg010b_spin2_putpixel_ret
013bc     2D 00 64 FD | 	ret
013c0                 | 
013c0                 | '   
013c0                 | ' '----------- A line drawing family. BASIC doesn't like the name, so it is named "draw" and aliased  -----------------------------
013c0                 | ' 
013c0                 | ' pub fastline(x1,x2,y,c)									' a fast 8bpp horizontal line
013c0                 | _hg010b_spin2_fastline
013c0     02 CA 05 F6 | 	mov	COUNT_, #2
013c4     E8 00 A0 FD | 	call	#pushregs_
013c8     48 A7 02 F6 | 	mov	local01, arg01
013cc     49 A9 02 F6 | 	mov	local02, arg02
013d0                 | ' 
013d0                 | ' if y<0 || y>=yres || (x1<0 && x2<0) || (x1>xres && x2>xres)
013d0     00 94 56 F2 | 	cmps	arg03, #0 wc
013d4     F4 00 90 CD |  if_b	jmp	#LR__0060
013d8     01 00 00 FF 
013dc     2E 62 06 F1 | 	add	objptr, ##558
013e0     31 99 02 FB | 	rdlong	arg05, objptr
013e4     01 00 00 FF 
013e8     2E 62 86 F1 | 	sub	objptr, ##558
013ec     4C 95 52 F2 | 	cmps	arg03, arg05 wc
013f0     D8 00 90 3D |  if_ae	jmp	#LR__0060
013f4     00 A6 56 F2 | 	cmps	local01, #0 wc
013f8     00 A8 56 C2 |  if_b	cmps	local02, #0 wc
013fc     CC 00 90 CD |  if_b	jmp	#LR__0060
01400     01 00 00 FF 
01404     2A 62 06 F1 | 	add	objptr, ##554
01408     31 99 02 FB | 	rdlong	arg05, objptr
0140c     01 00 00 FF 
01410     2A 62 86 F1 | 	sub	objptr, ##554
01414     4C A7 5A F2 | 	cmps	local01, arg05 wcz
01418     01 00 00 1F 
0141c     2A 62 06 11 |  if_a	add	objptr, ##554
01420     31 91 02 1B |  if_a	rdlong	arg01, objptr
01424     01 00 00 1F 
01428     2A 62 86 11 |  if_a	sub	objptr, ##554
0142c     48 A9 5A 12 |  if_a	cmps	local02, arg01 wcz
01430                 | '   return
01430     98 00 90 1D |  if_a	jmp	#LR__0060
01434     54 A7 5A F2 | 	cmps	local01, local02 wcz
01438     53 99 02 16 |  if_a	mov	arg05, local01
0143c     54 A7 02 16 |  if_a	mov	local01, local02
01440     4C A9 02 16 |  if_a	mov	local02, arg05
01444     00 A6 56 F2 | 	cmps	local01, #0 wc
01448     00 A6 06 C6 |  if_b	mov	local01, #0
0144c     01 00 00 FF 
01450     2A 62 06 F1 | 	add	objptr, ##554
01454     31 99 02 FB | 	rdlong	arg05, objptr
01458     01 00 00 FF 
0145c     2A 62 86 F1 | 	sub	objptr, ##554
01460     4C A9 52 F2 | 	cmps	local02, arg05 wc
01464     01 00 00 3F 
01468     2A 62 06 31 |  if_ae	add	objptr, ##554
0146c     31 A9 02 3B |  if_ae	rdlong	local02, objptr
01470     01 00 00 3F 
01474     2A 62 86 31 |  if_ae	sub	objptr, ##554
01478     E1 62 06 F1 | 	add	objptr, #225
0147c     31 91 02 FB | 	rdlong	arg01, objptr
01480     14 62 06 F1 | 	add	objptr, #20
01484     31 99 02 FB | 	rdlong	arg05, objptr
01488     02 98 66 F0 | 	shl	arg05, #2
0148c     4A 99 02 FD | 	qmul	arg05, arg03
01490                 | ' if x1>x2
01490                 | '   x1,x2:=x2,x1
01490                 | ' if x1<0 
01490                 | '   x1:=0
01490                 | ' if x2>=xres
01490                 | '   x2:=xres-1  
01490     01 A8 86 31 |  if_ae	sub	local02, #1
01494                 | ' ram.fill(s_buf_ptr+(4*s_cpl1*y+x1),c,1+x2-x1,0,1)
01494     01 94 06 F6 | 	mov	arg03, #1
01498     54 95 02 F1 | 	add	arg03, local02
0149c     53 95 82 F1 | 	sub	arg03, local01
014a0     4B 93 02 F6 | 	mov	arg02, arg04
014a4     00 96 06 F6 | 	mov	arg04, #0
014a8     01 98 06 F6 | 	mov	arg05, #1
014ac     0A 00 00 FF 
014b0     DB 63 06 F1 | 	add	objptr, ##5595
014b4     18 A8 62 FD | 	getqx	local02
014b8     53 A9 02 F1 | 	add	local02, local01
014bc     54 91 02 F1 | 	add	arg01, local02
014c0     D0 0D B0 FD | 	call	#_psram_spin2_fill
014c4     0B 00 00 FF 
014c8     D0 62 86 F1 | 	sub	objptr, ##5840
014cc                 | LR__0060
014cc     E7 F0 03 F6 | 	mov	ptra, fp
014d0     F2 00 A0 FD | 	call	#popregs_
014d4                 | _hg010b_spin2_fastline_ret
014d4     2D 00 64 FD | 	ret
014d8                 | 
014d8                 | ' 
014d8                 | ' pub draw(x1,y1,x2,y2,c) | d,dx,dy,ai,bi,xi,yi,x,y					' I had to rename the function for BASIC	
014d8                 | _hg010b_spin2_draw
014d8     0E CA 05 F6 | 	mov	COUNT_, #14
014dc     E8 00 A0 FD | 	call	#pushregs_
014e0     48 A7 02 F6 | 	mov	local01, arg01
014e4     49 A9 02 F6 | 	mov	local02, arg02
014e8     4A AB 02 F6 | 	mov	local03, arg03
014ec     4B AD 02 F6 | 	mov	local04, arg04
014f0     4C AF 02 F6 | 	mov	local05, arg05
014f4                 | ' 
014f4                 | ' if (y1==y2)
014f4     56 A9 0A F2 | 	cmp	local02, local04 wz
014f8     18 00 90 5D |  if_ne	jmp	#LR__0070
014fc                 | '   fastline(x1,x2,y1,c)
014fc     53 91 02 F6 | 	mov	arg01, local01
01500     55 93 02 F6 | 	mov	arg02, local03
01504     54 95 02 F6 | 	mov	arg03, local02
01508     57 97 02 F6 | 	mov	arg04, local05
0150c     B0 FE BF FD | 	call	#_hg010b_spin2_fastline
01510     F8 00 90 FD | 	jmp	#LR__0076
01514                 | LR__0070
01514                 | ' else  
01514                 | '   x:=x1
01514     53 B1 02 F6 | 	mov	local06, local01
01518                 | '   y:=y1
01518     54 B3 02 F6 | 	mov	local07, local02
0151c                 | ' 
0151c                 | '   if (x1<x2) 
0151c     55 A7 52 F2 | 	cmps	local01, local03 wc
01520                 | '     xi:=1
01520     01 B4 06 C6 |  if_b	mov	local08, #1
01524                 | '     dx:=x2-x1
01524     55 B7 02 C6 |  if_b	mov	local09, local03
01528     53 B7 82 C1 |  if_b	sub	local09, local01
0152c                 | '   else
0152c                 | '     xi:=-1
0152c     01 B4 66 36 |  if_ae	neg	local08, #1
01530                 | '     dx:=x1-x2
01530     55 A7 82 31 |  if_ae	sub	local01, local03
01534     53 B7 02 36 |  if_ae	mov	local09, local01
01538                 | '   
01538                 | '   if (y1<y2) 
01538     56 A9 52 F2 | 	cmps	local02, local04 wc
0153c                 | '     yi:=1
0153c     01 B8 06 C6 |  if_b	mov	local10, #1
01540                 | '     dy:=y2-y1
01540     56 BB 02 C6 |  if_b	mov	local11, local04
01544     54 BB 82 C1 |  if_b	sub	local11, local02
01548                 | '   else
01548                 | '     yi:=-1
01548     01 B8 66 36 |  if_ae	neg	local10, #1
0154c                 | '     dy:=y1-y2
0154c     56 A9 82 31 |  if_ae	sub	local02, local04
01550     54 BB 02 36 |  if_ae	mov	local11, local02
01554                 | ' 
01554                 | '   putpixel(x,y,c)
01554     57 95 02 F6 | 	mov	arg03, local05
01558     58 91 02 F6 | 	mov	arg01, local06
0155c     59 93 02 F6 | 	mov	arg02, local07
01560     AC FD BF FD | 	call	#_hg010b_spin2_putpixel
01564                 | ' 
01564                 | '   if (dx>dy)
01564     5D B7 5A F2 | 	cmps	local09, local11 wcz
01568     50 00 90 ED |  if_be	jmp	#LR__0072
0156c                 | '     ai:=(dy-dx)*2
0156c     5D BD 02 F6 | 	mov	local12, local11
01570     5B BD 82 F1 | 	sub	local12, local09
01574     01 BC 66 F0 | 	shl	local12, #1
01578                 | '     bi:=dy*2
01578     01 BA 66 F0 | 	shl	local11, #1
0157c     5D BF 02 F6 | 	mov	local13, local11
01580                 | '     d:= bi-dx
01580     5F C1 02 F6 | 	mov	local14, local13
01584     5B C1 82 F1 | 	sub	local14, local09
01588                 | '     repeat while (x<>x2) 
01588                 | LR__0071
01588     55 B1 0A F2 | 	cmp	local06, local03 wz
0158c     7C 00 90 AD |  if_e	jmp	#LR__0075
01590                 | '       if (d>=0) 
01590     00 C0 56 F2 | 	cmps	local14, #0 wc
01594                 | '         x+=xi
01594     5A B1 02 31 |  if_ae	add	local06, local08
01598                 | '         y+=yi
01598     5C B3 02 31 |  if_ae	add	local07, local10
0159c                 | '         d+=ai
0159c     5E C1 02 31 |  if_ae	add	local14, local12
015a0                 | '       else
015a0                 | '         d+=bi
015a0     5F C1 02 C1 |  if_b	add	local14, local13
015a4                 | '         x+=xi
015a4     5A B1 02 C1 |  if_b	add	local06, local08
015a8                 | '       putpixel(x,y,c)
015a8     58 91 02 F6 | 	mov	arg01, local06
015ac     59 93 02 F6 | 	mov	arg02, local07
015b0     57 95 02 F6 | 	mov	arg03, local05
015b4     58 FD BF FD | 	call	#_hg010b_spin2_putpixel
015b8     CC FF 9F FD | 	jmp	#LR__0071
015bc                 | LR__0072
015bc                 | '   else
015bc                 | '     ai:=(dx-dy)*2
015bc     5B BD 02 F6 | 	mov	local12, local09
015c0     5D BD 82 F1 | 	sub	local12, local11
015c4     01 BC 66 F0 | 	shl	local12, #1
015c8                 | '     bi:=dx*2
015c8     01 B6 66 F0 | 	shl	local09, #1
015cc     5B BF 02 F6 | 	mov	local13, local09
015d0                 | '     d:=bi-dy
015d0     5F C1 02 F6 | 	mov	local14, local13
015d4     5D C1 82 F1 | 	sub	local14, local11
015d8                 | '     repeat while (y<>y2)
015d8                 | LR__0073
015d8     56 B3 0A F2 | 	cmp	local07, local04 wz
015dc     2C 00 90 AD |  if_e	jmp	#LR__0074
015e0                 | '       if (d>=0)
015e0     00 C0 56 F2 | 	cmps	local14, #0 wc
015e4                 | '         x+=xi
015e4     5A B1 02 31 |  if_ae	add	local06, local08
015e8                 | '         y+=yi
015e8     5C B3 02 31 |  if_ae	add	local07, local10
015ec                 | '         d+=ai
015ec     5E C1 02 31 |  if_ae	add	local14, local12
015f0                 | '       else
015f0                 | '         d+=bi
015f0     5F C1 02 C1 |  if_b	add	local14, local13
015f4                 | '         y+=yi
015f4     5C B3 02 C1 |  if_b	add	local07, local10
015f8                 | '       putpixel(x, y,c)
015f8     58 91 02 F6 | 	mov	arg01, local06
015fc     59 93 02 F6 | 	mov	arg02, local07
01600     57 95 02 F6 | 	mov	arg03, local05
01604     08 FD BF FD | 	call	#_hg010b_spin2_putpixel
01608     CC FF 9F FD | 	jmp	#LR__0073
0160c                 | LR__0074
0160c                 | LR__0075
0160c                 | LR__0076
0160c     E7 F0 03 F6 | 	mov	ptra, fp
01610     F2 00 A0 FD | 	call	#popregs_
01614                 | _hg010b_spin2_draw_ret
01614     2D 00 64 FD | 	ret
01618                 | 
01618                 | '     
01618                 | ' '-- A frame (an empty rectangle) ---------------------------------------
01618                 | ' 
01618                 | ' pub frame(x1,y1,x2,y2,c)
01618                 | _hg010b_spin2_frame
01618     05 CA 05 F6 | 	mov	COUNT_, #5
0161c     E8 00 A0 FD | 	call	#pushregs_
01620     48 A7 02 F6 | 	mov	local01, arg01
01624     49 A9 02 F6 | 	mov	local02, arg02
01628     4A AB 02 F6 | 	mov	local03, arg03
0162c     4B AD 02 F6 | 	mov	local04, arg04
01630     4C AF 02 F6 | 	mov	local05, arg05
01634                 | ' 
01634                 | ' fastline(x1,x2,y1,c)
01634     53 91 02 F6 | 	mov	arg01, local01
01638     55 93 02 F6 | 	mov	arg02, local03
0163c     54 95 02 F6 | 	mov	arg03, local02
01640     57 97 02 F6 | 	mov	arg04, local05
01644     78 FD BF FD | 	call	#_hg010b_spin2_fastline
01648                 | ' fastline(x1,x2,y2,c)
01648     53 91 02 F6 | 	mov	arg01, local01
0164c     55 93 02 F6 | 	mov	arg02, local03
01650     56 95 02 F6 | 	mov	arg03, local04
01654     57 97 02 F6 | 	mov	arg04, local05
01658     64 FD BF FD | 	call	#_hg010b_spin2_fastline
0165c                 | ' line(x1,y1,x1,y2,c)
0165c     53 91 02 F6 | 	mov	arg01, local01
01660     54 93 02 F6 | 	mov	arg02, local02
01664     53 95 02 F6 | 	mov	arg03, local01
01668     56 97 02 F6 | 	mov	arg04, local04
0166c     57 99 02 F6 | 	mov	arg05, local05
01670                 | ' draw(x1,y1,x2,y2,c)
01670     64 FE BF FD | 	call	#_hg010b_spin2_draw
01674                 | ' line(x2,y1,x2,y2,c)
01674     55 91 02 F6 | 	mov	arg01, local03
01678     54 93 02 F6 | 	mov	arg02, local02
0167c     55 95 02 F6 | 	mov	arg03, local03
01680     56 97 02 F6 | 	mov	arg04, local04
01684     57 99 02 F6 | 	mov	arg05, local05
01688                 | ' draw(x1,y1,x2,y2,c)
01688     4C FE BF FD | 	call	#_hg010b_spin2_draw
0168c     E7 F0 03 F6 | 	mov	ptra, fp
01690     F2 00 A0 FD | 	call	#popregs_
01694                 | _hg010b_spin2_frame_ret
01694     2D 00 64 FD | 	ret
01698                 | 
01698                 | ' 
01698                 | ' '-- A box (a filled rectangle) ----------------------------------------
01698                 | ' 
01698                 | ' pub box(x1,y1,x2,y2,c) |yy
01698                 | _hg010b_spin2_box
01698     06 CA 05 F6 | 	mov	COUNT_, #6
0169c     E8 00 A0 FD | 	call	#pushregs_
016a0     48 A7 02 F6 | 	mov	local01, arg01
016a4     49 A9 02 F6 | 	mov	local02, arg02
016a8     4A AB 02 F6 | 	mov	local03, arg03
016ac     4B AD 02 F6 | 	mov	local04, arg04
016b0     4C AF 02 F6 | 	mov	local05, arg05
016b4                 | ' 
016b4                 | ' repeat yy from y1 to y2
016b4     54 AD 52 F2 | 	cmps	local04, local02 wc
016b8     01 B0 86 F6 | 	negc	local06, #1
016bc     58 AD 02 F1 | 	add	local04, local06
016c0                 | LR__0080
016c0                 | '   fastline(x1,x2,yy,c)
016c0     53 91 02 F6 | 	mov	arg01, local01
016c4     55 93 02 F6 | 	mov	arg02, local03
016c8     57 97 02 F6 | 	mov	arg04, local05
016cc     54 95 02 F6 | 	mov	arg03, local02
016d0     EC FC BF FD | 	call	#_hg010b_spin2_fastline
016d4     58 A9 02 F1 | 	add	local02, local06
016d8     56 A9 0A F2 | 	cmp	local02, local04 wz
016dc     E0 FF 9F 5D |  if_ne	jmp	#LR__0080
016e0     E7 F0 03 F6 | 	mov	ptra, fp
016e4     F2 00 A0 FD | 	call	#popregs_
016e8                 | _hg010b_spin2_box_ret
016e8     2D 00 64 FD | 	ret
016ec                 | 
016ec                 | '     
016ec                 | ' '****************************************************************************************************************
016ec                 | ' '                                                                       		 			*
016ec                 | ' '  Characters on graphic screen                                          					*
016ec                 | ' '                                                                       					*
016ec                 | ' '****************************************************************************************************************    
016ec                 | ' 
016ec                 | ' ' ------  Transparent character
016ec                 | ' 
016ec                 | ' pub putcharxycf(x,y,achar,f) |xx, yy, bb
016ec                 | _hg010b_spin2_putcharxycf
016ec     07 CA 05 F6 | 	mov	COUNT_, #7
016f0     E8 00 A0 FD | 	call	#pushregs_
016f4     48 A7 02 F6 | 	mov	local01, arg01
016f8     49 A9 02 F6 | 	mov	local02, arg02
016fc     4A AB 02 F6 | 	mov	local03, arg03
01700     4B AD 02 F6 | 	mov	local04, arg04
01704                 | ' 
01704                 | ' repeat yy from 0 to 15
01704     00 AE 06 F6 | 	mov	local05, #0
01708                 | LR__0090
01708                 | '   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
01708     36 97 02 F6 | 	mov	arg04, ptr__hg010b_spin2_dat__
0170c     95 62 06 F1 | 	add	objptr, #149
01710     31 95 02 FB | 	rdlong	arg03, objptr
01714     95 62 86 F1 | 	sub	objptr, #149
01718     0A 94 66 F0 | 	shl	arg03, #10
0171c     4A 97 02 F1 | 	add	arg04, arg03
01720     55 95 02 F6 | 	mov	arg03, local03
01724     04 94 66 F0 | 	shl	arg03, #4
01728     4A 97 02 F1 | 	add	arg04, arg03
0172c     57 97 02 F1 | 	add	arg04, local05
01730     4B B1 C2 FA | 	rdbyte	local06, arg04
01734                 | '   repeat xx from 0 to 7
01734     00 B2 06 F6 | 	mov	local07, #0
01738                 | LR__0091
01738                 | '     if (bb&(1<<xx))<>0
01738     59 97 C2 F9 | 	decod	arg04, local07
0173c     4B B1 CA F7 | 	test	local06, arg04 wz
01740     18 00 90 AD |  if_e	jmp	#LR__0092
01744                 | '       putpixel(xx+x,yy+y,f)
01744     59 91 02 F6 | 	mov	arg01, local07
01748     53 91 02 F1 | 	add	arg01, local01
0174c     57 93 02 F6 | 	mov	arg02, local05
01750     54 93 02 F1 | 	add	arg02, local02
01754     56 95 02 F6 | 	mov	arg03, local04
01758     B4 FB BF FD | 	call	#_hg010b_spin2_putpixel
0175c                 | LR__0092
0175c     01 B2 06 F1 | 	add	local07, #1
01760     08 B2 56 F2 | 	cmps	local07, #8 wc
01764     D0 FF 9F CD |  if_b	jmp	#LR__0091
01768     01 AE 06 F1 | 	add	local05, #1
0176c     10 AE 56 F2 | 	cmps	local05, #16 wc
01770     94 FF 9F CD |  if_b	jmp	#LR__0090
01774     E7 F0 03 F6 | 	mov	ptra, fp
01778     F2 00 A0 FD | 	call	#popregs_
0177c                 | _hg010b_spin2_putcharxycf_ret
0177c     2D 00 64 FD | 	ret
01780                 | 
01780                 | '       
01780                 | ' pub putcharxycgf(x,y,achar,f,b) |xx, yy,bb,c1,c2
01780                 | _hg010b_spin2_putcharxycgf
01780                 | ' 
01780                 | '  
01780                 | ' repeat yy from 0 to 15
01780     00 7C 06 F6 | 	mov	_var01, #0
01784     D7 8A 48 FB | 	callpa	#(@LR__0102-@LR__0100)>>2,fcache_load_ptr_
01788                 | LR__0100
01788                 | ' 
01788                 | '   bb:=byte[@vga_font+font_family<<10+achar<<4+yy]
01788     95 62 06 F1 | 	add	objptr, #149
0178c     31 7F 02 FB | 	rdlong	_var02, objptr
01790     0A 7E 66 F0 | 	shl	_var02, #10
01794     36 81 02 F6 | 	mov	_var03, ptr__hg010b_spin2_dat__
01798     3F 81 02 F1 | 	add	_var03, _var02
0179c     4A 7F 02 F6 | 	mov	_var02, arg03
017a0     04 7E 66 F0 | 	shl	_var02, #4
017a4     3F 81 02 F1 | 	add	_var03, _var02
017a8     3E 81 02 F1 | 	add	_var03, _var01
017ac     40 81 C2 FA | 	rdbyte	_var03, _var03
017b0                 | '   asm
017b0     00 80 0E F4 | 	testb	_var03, #0 wz
017b4     4B 83 C2 A8 |  if_e	setbyte	_var04, arg04, #0
017b8     4C 83 C2 58 |  if_ne	setbyte	_var04, arg05, #0
017bc     01 80 0E F4 | 	testb	_var03, #1 wz
017c0     4B 83 CA A8 |  if_e	setbyte	_var04, arg04, #1
017c4     4C 83 CA 58 |  if_ne	setbyte	_var04, arg05, #1
017c8     02 80 0E F4 | 	testb	_var03, #2 wz
017cc     4B 83 D2 A8 |  if_e	setbyte	_var04, arg04, #2
017d0     4C 83 D2 58 |  if_ne	setbyte	_var04, arg05, #2
017d4     03 80 0E F4 | 	testb	_var03, #3 wz
017d8     4B 83 DA A8 |  if_e	setbyte	_var04, arg04, #3
017dc     4C 83 DA 58 |  if_ne	setbyte	_var04, arg05, #3
017e0     04 80 0E F4 | 	testb	_var03, #4 wz
017e4     4B 85 C2 A8 |  if_e	setbyte	_var05, arg04, #0
017e8     4C 85 C2 58 |  if_ne	setbyte	_var05, arg05, #0
017ec     05 80 0E F4 | 	testb	_var03, #5 wz
017f0     4B 85 CA A8 |  if_e	setbyte	_var05, arg04, #1
017f4     4C 85 CA 58 |  if_ne	setbyte	_var05, arg05, #1
017f8     06 80 0E F4 | 	testb	_var03, #6 wz
017fc     4B 85 D2 A8 |  if_e	setbyte	_var05, arg04, #2
01800     4C 85 D2 58 |  if_ne	setbyte	_var05, arg05, #2
01804     07 80 0E F4 | 	testb	_var03, #7 wz
01808     4B 85 DA A8 |  if_e	setbyte	_var05, arg04, #3
0180c     4C 85 DA 58 |  if_ne	setbyte	_var05, arg05, #3
01810                 | '   
01810                 | '   ccc[0]:=c1
01810     9D 63 06 F1 | 	add	objptr, #413
01814     31 83 62 FC | 	wrlong	_var04, objptr
01818                 | '   ccc[1]:=c2 
01818     04 62 06 F1 | 	add	objptr, #4
0181c     31 85 62 FC | 	wrlong	_var05, objptr
01820                 | '   long[mailbox0][2]:=8
01820     49 62 86 F1 | 	sub	objptr, #73
01824     31 81 02 FB | 	rdlong	_var03, objptr
01828     08 80 06 F1 | 	add	_var03, #8
0182c     40 11 68 FC | 	wrlong	#8, _var03
01830                 | '   long[mailbox0][1]:=@ccc
01830     31 81 02 F6 | 	mov	_var03, objptr
01834     45 80 06 F1 | 	add	_var03, #69
01838     31 7F 02 FB | 	rdlong	_var02, objptr
0183c     04 7E 06 F1 | 	add	_var02, #4
01840     3F 81 62 FC | 	wrlong	_var03, _var02
01844                 | '   long[mailbox0]:= s_buf_ptr+((y+yy)<<10+x<<2)+$f0000000   
01844     0C 63 86 F1 | 	sub	objptr, #268
01848     31 81 02 FB | 	rdlong	_var03, objptr
0184c     49 7F 02 F6 | 	mov	_var02, arg02
01850     3E 7F 02 F1 | 	add	_var02, _var01
01854     0A 7E 66 F0 | 	shl	_var02, #10
01858     48 87 02 F6 | 	mov	_var06, arg01
0185c     02 86 66 F0 | 	shl	_var06, #2
01860     43 7F 02 F1 | 	add	_var02, _var06
01864     3F 81 02 F1 | 	add	_var03, _var02
01868     00 00 78 FF 
0186c     00 80 06 F1 | 	add	_var03, ##-268435456
01870     0C 63 06 F1 | 	add	objptr, #268
01874     31 87 02 FB | 	rdlong	_var06, objptr
01878     43 81 62 FC | 	wrlong	_var03, _var06
0187c                 | '   repeat
0187c                 | LR__0101
0187c     31 81 02 FB | 	rdlong	_var03, objptr
01880     40 7F 02 FB | 	rdlong	_var02, _var03
01884     00 7E 56 F2 | 	cmps	_var02, #0 wc
01888     F0 FF 9F CD |  if_b	jmp	#LR__0101
0188c     ED 63 86 F1 | 	sub	objptr, #493
01890     01 7C 06 F1 | 	add	_var01, #1
01894     10 7C 56 F2 | 	cmps	_var01, #16 wc
01898     EC FE 9F CD |  if_b	jmp	#LR__0100
0189c                 | LR__0102
0189c                 | _hg010b_spin2_putcharxycgf_ret
0189c     2D 00 64 FD | 	ret
018a0                 | 
018a0                 | '   
018a0                 | ' pub outtextxycf(x,y,text,f) | iii,c
018a0                 | _hg010b_spin2_outtextxycf
018a0     07 CA 05 F6 | 	mov	COUNT_, #7
018a4     E8 00 A0 FD | 	call	#pushregs_
018a8     48 A7 02 F6 | 	mov	local01, arg01
018ac     49 A9 02 F6 | 	mov	local02, arg02
018b0     4A AB 02 F6 | 	mov	local03, arg03
018b4     4B AD 02 F6 | 	mov	local04, arg04
018b8                 | ' 
018b8                 | ' repeat iii from 0 to strsize(text)-1
018b8     00 AE 06 F6 | 	mov	local05, #0
018bc     55 91 02 F6 | 	mov	arg01, local03
018c0     48 B1 02 F6 | 	mov	local06, arg01
018c4     D7 06 48 FB | 	callpa	#(@LR__0111-@LR__0110)>>2,fcache_load_ptr_
018c8                 | LR__0110
018c8     58 77 CA FA | 	rdbyte	result1, local06 wz
018cc     01 B0 06 51 |  if_ne	add	local06, #1
018d0     F4 FF 9F 5D |  if_ne	jmp	#LR__0110
018d4                 | LR__0111
018d4     48 B1 82 F1 | 	sub	local06, arg01
018d8     01 B0 86 F1 | 	sub	local06, #1
018dc     00 B0 56 F2 | 	cmps	local06, #0 wc
018e0     01 B2 86 F6 | 	negc	local07, #1
018e4     59 B1 02 F1 | 	add	local06, local07
018e8                 | LR__0112
018e8                 | '   putcharxycf(x+8*iii,y,byte[text+iii],f)
018e8     53 91 02 F6 | 	mov	arg01, local01
018ec     57 97 02 F6 | 	mov	arg04, local05
018f0     03 96 66 F0 | 	shl	arg04, #3
018f4     4B 91 02 F1 | 	add	arg01, arg04
018f8     54 93 02 F6 | 	mov	arg02, local02
018fc     55 97 02 F6 | 	mov	arg04, local03
01900     57 97 02 F1 | 	add	arg04, local05
01904     4B 95 C2 FA | 	rdbyte	arg03, arg04
01908     56 97 02 F6 | 	mov	arg04, local04
0190c     DC FD BF FD | 	call	#_hg010b_spin2_putcharxycf
01910     59 AF 02 F1 | 	add	local05, local07
01914     58 AF 0A F2 | 	cmp	local05, local06 wz
01918     CC FF 9F 5D |  if_ne	jmp	#LR__0112
0191c     E7 F0 03 F6 | 	mov	ptra, fp
01920     F2 00 A0 FD | 	call	#popregs_
01924                 | _hg010b_spin2_outtextxycf_ret
01924     2D 00 64 FD | 	ret
01928                 | 
01928                 | ' 
01928                 | ' 
01928                 | ' '**********************************************************************r***
01928                 | ' '                                                                        *
01928                 | ' ' Font related functions                                                 *
01928                 | ' '                                                                        *
01928                 | ' '*************************************************************************
01928                 | ' 
01928                 | ' ''--------- Set a font offset. TODO: remove, use byte#1 instead
01928                 | ' 
01928                 | ' pub setfontfamily(afontnum)
01928                 | _hg010b_spin2_setfontfamily
01928                 | ' 
01928                 | ' font_family:=afontnum
01928     95 62 06 F1 | 	add	objptr, #149
0192c     31 91 62 FC | 	wrlong	arg01, objptr
01930     95 62 86 F1 | 	sub	objptr, #149
01934                 | ' 'if afontnum==8
01934                 | ' '  font_ptr:=@amiga_font
01934                 | ' 
01934                 | ' if afontnum==4
01934     04 90 0E F2 | 	cmp	arg01, #4 wz
01938                 | '   font_ptr:=@st_font
01938     36 7D 02 A6 |  if_e	mov	_var01, ptr__hg010b_spin2_dat__
0193c     08 00 00 AF 
01940     00 7C 06 A1 |  if_e	add	_var01, ##4096
01944     08 62 06 A1 |  if_e	add	objptr, #8
01948     31 7D 62 AC |  if_e	wrlong	_var01, objptr
0194c     08 62 86 A1 |  if_e	sub	objptr, #8
01950                 | ' if afontnum==0
01950     00 90 0E F2 | 	cmp	arg01, #0 wz
01954                 | '   font_ptr:=@vga_font
01954     08 62 06 A1 |  if_e	add	objptr, #8
01958     31 6D 62 AC |  if_e	wrlong	ptr__hg010b_spin2_dat__, objptr
0195c     08 62 86 A1 |  if_e	sub	objptr, #8
01960                 | _hg010b_spin2_setfontfamily_ret
01960     2D 00 64 FD | 	ret
01964                 | 
01964                 | ' 
01964                 | ' '*************************************************************************
01964                 | ' '                                                                        *
01964                 | ' '  VBlank functions                                                      *
01964                 | ' '                                                                        *
01964                 | ' '*************************************************************************
01964                 | ' 
01964                 | ' pub waitvbl(amount) | i
01964                 | _hg010b_spin2_waitvbl
01964     03 CA 05 F6 | 	mov	COUNT_, #3
01968     E8 00 A0 FD | 	call	#pushregs_
0196c     48 A7 02 F6 | 	mov	local01, arg01
01970                 | ' 
01970                 | ' ''---------- Wait for start of vblank. Amount=delay in frames
01970                 | ' 
01970                 | ' repeat i from 1 to amount
01970     01 A8 06 F6 | 	mov	local02, #1
01974     01 A6 56 F2 | 	cmps	local01, #1 wc
01978     01 AA 86 F6 | 	negc	local03, #1
0197c     55 A7 02 F1 | 	add	local01, local03
01980                 | LR__0120
01980                 | '   repeat until vblank==0
01980                 | LR__0121
01980     49 62 06 F1 | 	add	objptr, #73
01984     31 91 0A FB | 	rdlong	arg01, objptr wz
01988     49 62 86 F1 | 	sub	objptr, #73
0198c     0C 00 90 AD |  if_e	jmp	#LR__0122
01990                 | '     waitus(100)
01990     64 90 06 F6 | 	mov	arg01, #100
01994     54 19 B0 FD | 	call	#__system___waitus
01998     E4 FF 9F FD | 	jmp	#LR__0121
0199c                 | LR__0122
0199c                 | '   repeat until vblank==1
0199c                 | LR__0123
0199c     49 62 06 F1 | 	add	objptr, #73
019a0     31 91 02 FB | 	rdlong	arg01, objptr
019a4     49 62 86 F1 | 	sub	objptr, #73
019a8     01 90 0E F2 | 	cmp	arg01, #1 wz
019ac     0C 00 90 AD |  if_e	jmp	#LR__0124
019b0                 | '     waitus(100)
019b0     64 90 06 F6 | 	mov	arg01, #100
019b4     34 19 B0 FD | 	call	#__system___waitus
019b8     E0 FF 9F FD | 	jmp	#LR__0123
019bc                 | LR__0124
019bc     55 A9 02 F1 | 	add	local02, local03
019c0     53 A9 0A F2 | 	cmp	local02, local01 wz
019c4     B8 FF 9F 5D |  if_ne	jmp	#LR__0120
019c8     E7 F0 03 F6 | 	mov	ptra, fp
019cc     F2 00 A0 FD | 	call	#popregs_
019d0                 | _hg010b_spin2_waitvbl_ret
019d0     2D 00 64 FD | 	ret
019d4                 | 
019d4                 | ' 
019d4                 | ' 
019d4                 | ' pub cls(fc,bc)   :c,i
019d4                 | _hg010b_spin2_cls
019d4     02 CA 05 F6 | 	mov	COUNT_, #2
019d8     E8 00 A0 FD | 	call	#pushregs_
019dc     48 A7 02 F6 | 	mov	local01, arg01
019e0     49 A9 02 F6 | 	mov	local02, arg02
019e4                 | ' 
019e4                 | ' c:=bc
019e4                 | ' ram.fill(s_buf_ptr,c,4*buflen,0,1)  
019e4     E1 62 06 F1 | 	add	objptr, #225
019e8     31 91 02 FB | 	rdlong	arg01, objptr
019ec     A9 62 86 F1 | 	sub	objptr, #169
019f0     31 95 02 FB | 	rdlong	arg03, objptr
019f4     02 94 66 F0 | 	shl	arg03, #2
019f8     54 93 02 F6 | 	mov	arg02, local02
019fc     00 96 06 F6 | 	mov	arg04, #0
01a00     01 98 06 F6 | 	mov	arg05, #1
01a04     0B 00 00 FF 
01a08     98 62 06 F1 | 	add	objptr, ##5784
01a0c     84 08 B0 FD | 	call	#_psram_spin2_fill
01a10                 | ' ram.fill(textbuf_ptr,32,buf_ptr-textbuf_ptr,0,1)
01a10     0B 00 00 FF 
01a14     CC 62 86 F1 | 	sub	objptr, ##5836
01a18     31 91 02 FB | 	rdlong	arg01, objptr
01a1c     04 62 86 F1 | 	sub	objptr, #4
01a20     31 95 02 FB | 	rdlong	arg03, objptr
01a24     48 95 82 F1 | 	sub	arg03, arg01
01a28     20 92 06 F6 | 	mov	arg02, #32
01a2c     00 96 06 F6 | 	mov	arg04, #0
01a30     01 98 06 F6 | 	mov	arg05, #1
01a34     0B 00 00 FF 
01a38     D0 62 06 F1 | 	add	objptr, ##5840
01a3c     54 08 B0 FD | 	call	#_psram_spin2_fill
01a40                 | ' setwritecolors(fc,bc)
01a40                 | ' 
01a40                 | ' write_color:=ff
01a40     0B 00 00 FF 
01a44     8F 62 86 F1 | 	sub	objptr, ##5775
01a48     31 A7 62 FC | 	wrlong	local01, objptr
01a4c                 | ' write_background:=bb
01a4c     04 62 06 F1 | 	add	objptr, #4
01a50     31 A9 62 FC | 	wrlong	local02, objptr
01a54                 | ' cursor_x:=0
01a54     09 62 86 F1 | 	sub	objptr, #9
01a58     31 01 58 FC | 	wrword	#0, objptr
01a5c                 | ' cursor_y:=0
01a5c     02 62 06 F1 | 	add	objptr, #2
01a60     31 01 48 FC | 	wrbyte	#0, objptr
01a64                 | ' setspritepos(17,4*cursor_x,16*cursor_y+4 )
01a64     02 62 86 F1 | 	sub	objptr, #2
01a68     31 93 E2 FA | 	rdword	arg02, objptr
01a6c     02 92 66 F0 | 	shl	arg02, #2
01a70     3C 62 86 F1 | 	sub	objptr, #60
01a74     04 94 06 F6 | 	mov	arg03, #4
01a78     11 90 06 F6 | 	mov	arg01, #17
01a7c     DC F7 BF FD | 	call	#_hg010b_spin2_setspritepos
01a80                 | ' setcursorcolor(fc)
01a80     53 91 02 F6 | 	mov	arg01, local01
01a84     E4 F3 BF FD | 	call	#_hg010b_spin2_setcursorcolor
01a88     54 77 02 F6 | 	mov	result1, local02
01a8c     00 78 06 F6 | 	mov	result2, #0
01a90     E7 F0 03 F6 | 	mov	ptra, fp
01a94     F2 00 A0 FD | 	call	#popregs_
01a98                 | _hg010b_spin2_cls_ret
01a98     2D 00 64 FD | 	ret
01a9c                 | 
01a9c                 | ' 
01a9c                 | ' ''---------- Output a char at the cursor position, move the cursor 
01a9c                 | ' 
01a9c                 | ' pub putchar(achar) | c,x,y,l,newcpl
01a9c                 | _hg010b_spin2_putchar
01a9c     02 CA 05 F6 | 	mov	COUNT_, #2
01aa0     E8 00 A0 FD | 	call	#pushregs_
01aa4     48 A7 02 F6 | 	mov	local01, arg01
01aa8                 | ' 
01aa8                 | ' if achar==10
01aa8     0A A6 0E F2 | 	cmp	local01, #10 wz
01aac                 | '   crlf()
01aac     B8 03 B0 AD |  if_e	call	#_hg010b_spin2_crlf
01ab0                 | ' if achar==9
01ab0     09 A6 0E F2 | 	cmp	local01, #9 wz
01ab4     18 00 90 5D |  if_ne	jmp	#LR__0130
01ab8                 | '   cursor_x:=(cursor_x& %11110000)+16
01ab8     3C 62 06 F1 | 	add	objptr, #60
01abc     31 95 E2 FA | 	rdword	arg03, objptr
01ac0     F0 94 06 F5 | 	and	arg03, #240
01ac4     10 94 06 F1 | 	add	arg03, #16
01ac8     31 95 52 FC | 	wrword	arg03, objptr
01acc     3C 62 86 F1 | 	sub	objptr, #60
01ad0                 | LR__0130
01ad0                 | '   
01ad0                 | ' if (achar<>9) && (achar<>10) 
01ad0     09 A6 0E F2 | 	cmp	local01, #9 wz
01ad4     0A A6 0E 52 |  if_ne	cmp	local01, #10 wz
01ad8     A8 00 90 AD |  if_e	jmp	#LR__0131
01adc                 | '   putcharxycgf(cursor_x,16*cursor_y+4,achar,write_color,write_background)
01adc     3C 62 06 F1 | 	add	objptr, #60
01ae0     31 91 E2 FA | 	rdword	arg01, objptr
01ae4     02 62 06 F1 | 	add	objptr, #2
01ae8     31 93 C2 FA | 	rdbyte	arg02, objptr
01aec     04 92 66 F0 | 	shl	arg02, #4
01af0     04 92 06 F1 | 	add	arg02, #4
01af4     03 62 06 F1 | 	add	objptr, #3
01af8     31 97 02 FB | 	rdlong	arg04, objptr
01afc     04 62 06 F1 | 	add	objptr, #4
01b00     31 99 02 FB | 	rdlong	arg05, objptr
01b04     45 62 86 F1 | 	sub	objptr, #69
01b08     53 95 02 F6 | 	mov	arg03, local01
01b0c     70 FC BF FD | 	call	#_hg010b_spin2_putcharxycgf
01b10     04 62 06 F1 | 	add	objptr, #4
01b14     31 91 02 FB | 	rdlong	arg01, objptr
01b18     1C 00 00 FF 
01b1c     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01b20     36 95 02 FB | 	rdlong	arg03, ptr__hg010b_spin2_dat__
01b24     3A 62 06 F1 | 	add	objptr, #58
01b28     31 99 C2 FA | 	rdbyte	arg05, objptr
01b2c     4C 95 02 FD | 	qmul	arg03, arg05
01b30                 | '   ram.fill(textbuf_ptr+(timings[7]*cursor_y+(cursor_x>>1)),achar,1,0,1)
01b30     1C 00 00 FF 
01b34     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01b38     02 62 86 F1 | 	sub	objptr, #2
01b3c     31 A9 E2 FA | 	rdword	local02, objptr
01b40     01 A8 46 F0 | 	shr	local02, #1
01b44     53 93 02 F6 | 	mov	arg02, local01
01b48     01 94 06 F6 | 	mov	arg03, #1
01b4c     00 96 06 F6 | 	mov	arg04, #0
01b50     01 98 06 F6 | 	mov	arg05, #1
01b54     0B 00 00 FF 
01b58     94 62 06 F1 | 	add	objptr, ##5780
01b5c     18 A6 62 FD | 	getqx	local01
01b60     54 A7 02 F1 | 	add	local01, local02
01b64     53 91 02 F1 | 	add	arg01, local01
01b68     28 07 B0 FD | 	call	#_psram_spin2_fill
01b6c                 | '   cursor_x+=2
01b6c     0B 00 00 FF 
01b70     94 62 86 F1 | 	sub	objptr, ##5780
01b74     31 A9 E2 FA | 	rdword	local02, objptr
01b78     02 A8 06 F1 | 	add	local02, #2
01b7c     31 A9 52 FC | 	wrword	local02, objptr
01b80     3C 62 86 F1 | 	sub	objptr, #60
01b84                 | LR__0131
01b84                 | ' 
01b84                 | ' if cursor_x>=256
01b84     3C 62 06 F1 | 	add	objptr, #60
01b88     31 A9 E2 FA | 	rdword	local02, objptr
01b8c     3C 62 86 F1 | 	sub	objptr, #60
01b90     00 A9 56 F2 | 	cmps	local02, #256 wc
01b94     64 00 90 CD |  if_b	jmp	#LR__0133
01b98                 | '   cursor_x:=0
01b98     3C 62 06 F1 | 	add	objptr, #60
01b9c     31 01 58 FC | 	wrword	#0, objptr
01ba0                 | '   cursor_y+=1
01ba0     02 62 06 F1 | 	add	objptr, #2
01ba4     31 A9 C2 FA | 	rdbyte	local02, objptr
01ba8     01 A8 06 F1 | 	add	local02, #1
01bac     31 A9 42 FC | 	wrbyte	local02, objptr
01bb0                 | '   if cursor_y>st_lines-1
01bb0     C7 62 06 F1 | 	add	objptr, #199
01bb4     31 A9 02 FB | 	rdlong	local02, objptr
01bb8     01 A8 86 F1 | 	sub	local02, #1
01bbc     C7 62 86 F1 | 	sub	objptr, #199
01bc0     31 95 C2 FA | 	rdbyte	arg03, objptr
01bc4     3E 62 86 F1 | 	sub	objptr, #62
01bc8     54 95 5A F2 | 	cmps	arg03, local02 wcz
01bcc     2C 00 90 ED |  if_be	jmp	#LR__0132
01bd0                 | '     scrollup2()
01bd0     00 90 06 F6 | 	mov	arg01, #0
01bd4     01 00 00 FF 
01bd8     58 92 06 F6 | 	mov	arg02, ##600
01bdc     10 94 06 F6 | 	mov	arg03, #16
01be0     4C 00 B0 FD | 	call	#_hg010b_spin2_scrollup2
01be4                 | '     cursor_y:=st_lines-1
01be4     05 63 06 F1 | 	add	objptr, #261
01be8     31 A9 02 FB | 	rdlong	local02, objptr
01bec     01 A8 86 F1 | 	sub	local02, #1
01bf0     C7 62 86 F1 | 	sub	objptr, #199
01bf4     31 A9 42 FC | 	wrbyte	local02, objptr
01bf8     3E 62 86 F1 | 	sub	objptr, #62
01bfc                 | LR__0132
01bfc                 | LR__0133
01bfc                 | ' setspritepos(17,4*cursor_x,16*cursor_y+4 )
01bfc     3C 62 06 F1 | 	add	objptr, #60
01c00     31 93 E2 FA | 	rdword	arg02, objptr
01c04     02 92 66 F0 | 	shl	arg02, #2
01c08     02 62 06 F1 | 	add	objptr, #2
01c0c     31 95 C2 FA | 	rdbyte	arg03, objptr
01c10     3E 62 86 F1 | 	sub	objptr, #62
01c14     04 94 66 F0 | 	shl	arg03, #4
01c18     04 94 06 F1 | 	add	arg03, #4
01c1c     11 90 06 F6 | 	mov	arg01, #17
01c20     38 F6 BF FD | 	call	#_hg010b_spin2_setspritepos
01c24     E7 F0 03 F6 | 	mov	ptra, fp
01c28     F2 00 A0 FD | 	call	#popregs_
01c2c                 | _hg010b_spin2_putchar_ret
01c2c     2D 00 64 FD | 	ret
01c30                 | 
01c30                 | '    
01c30                 | ' ' a version for text scrolling in Basic shifted 4 lines down
01c30                 | ' 
01c30                 | ' pub scrollup2(start=0, end=600 , amount=16) | i
01c30                 | _hg010b_spin2_scrollup2
01c30     03 CA 05 F6 | 	mov	COUNT_, #3
01c34     E8 00 A0 FD | 	call	#pushregs_
01c38                 | ' 	
01c38                 | ' repeat i from 4 to 579 
01c38     04 A6 06 F6 | 	mov	local01, #4
01c3c                 | LR__0140
01c3c     E1 62 06 F1 | 	add	objptr, #225
01c40     31 93 02 FB | 	rdlong	arg02, objptr
01c44     53 99 02 F6 | 	mov	arg05, local01
01c48     10 98 06 F1 | 	add	arg05, #16
01c4c     02 98 66 F0 | 	shl	arg05, #2
01c50     14 62 06 F1 | 	add	objptr, #20
01c54     31 95 02 FB | 	rdlong	arg03, objptr
01c58     4A 99 02 FD | 	qmul	arg05, arg03
01c5c                 | '   ram.read1($7E800, s_buf_ptr+(i+16)*4*s_cpl1, 4*s_cpl1)
01c5c     02 94 66 F0 | 	shl	arg03, #2
01c60     F4 03 00 FF 
01c64     00 90 06 F6 | 	mov	arg01, ##518144
01c68     0A 00 00 FF 
01c6c     DB 63 06 F1 | 	add	objptr, ##5595
01c70     18 98 62 FD | 	getqx	arg05
01c74     4C 93 02 F1 | 	add	arg02, arg05
01c78     DC 04 B0 FD | 	call	#_psram_spin2_read1
01c7c     0A 00 00 FF 
01c80     EF 63 86 F1 | 	sub	objptr, ##5615
01c84     31 93 02 FB | 	rdlong	arg02, objptr
01c88     53 99 02 F6 | 	mov	arg05, local01
01c8c     02 98 66 F0 | 	shl	arg05, #2
01c90     14 62 06 F1 | 	add	objptr, #20
01c94     31 95 02 FB | 	rdlong	arg03, objptr
01c98     4A 99 02 FD | 	qmul	arg05, arg03
01c9c                 | '   ram.write($7E800, s_buf_ptr+i*4*s_cpl1, 4*s_cpl1)
01c9c     02 94 66 F0 | 	shl	arg03, #2
01ca0     F4 03 00 FF 
01ca4     00 90 06 F6 | 	mov	arg01, ##518144
01ca8     0A 00 00 FF 
01cac     DB 63 06 F1 | 	add	objptr, ##5595
01cb0     18 98 62 FD | 	getqx	arg05
01cb4     4C 93 02 F1 | 	add	arg02, arg05
01cb8     38 05 B0 FD | 	call	#_psram_spin2_write
01cbc     0B 00 00 FF 
01cc0     D0 62 86 F1 | 	sub	objptr, ##5840
01cc4     01 A6 06 F1 | 	add	local01, #1
01cc8     01 00 00 FF 
01ccc     44 A6 16 F2 | 	cmp	local01, ##580 wc
01cd0     68 FF 9F CD |  if_b	jmp	#LR__0140
01cd4                 | ' 
01cd4                 | ' repeat i from 580 to 599
01cd4     01 00 00 FF 
01cd8     44 A6 06 F6 | 	mov	local01, ##580
01cdc                 | LR__0141
01cdc                 | '    fastline(0,1023,i,write_background)   
01cdc     45 62 06 F1 | 	add	objptr, #69
01ce0     31 97 02 FB | 	rdlong	arg04, objptr
01ce4     45 62 86 F1 | 	sub	objptr, #69
01ce8     00 90 06 F6 | 	mov	arg01, #0
01cec     09 92 CE F9 | 	bmask	arg02, #9
01cf0     53 95 02 F6 | 	mov	arg03, local01
01cf4     C8 F6 BF FD | 	call	#_hg010b_spin2_fastline
01cf8     01 A6 06 F1 | 	add	local01, #1
01cfc     01 00 00 FF 
01d00     58 A6 16 F2 | 	cmp	local01, ##600 wc
01d04     D4 FF 9F CD |  if_b	jmp	#LR__0141
01d08                 | ' repeat i from 0 to 3
01d08     00 A6 06 F6 | 	mov	local01, #0
01d0c                 | LR__0142
01d0c                 | '    fastline(0,1023,i,write_background)      
01d0c     45 62 06 F1 | 	add	objptr, #69
01d10     31 97 02 FB | 	rdlong	arg04, objptr
01d14     45 62 86 F1 | 	sub	objptr, #69
01d18     00 90 06 F6 | 	mov	arg01, #0
01d1c     09 92 CE F9 | 	bmask	arg02, #9
01d20     53 95 02 F6 | 	mov	arg03, local01
01d24     98 F6 BF FD | 	call	#_hg010b_spin2_fastline
01d28     01 A6 06 F1 | 	add	local01, #1
01d2c     04 A6 56 F2 | 	cmps	local01, #4 wc
01d30     D8 FF 9F CD |  if_b	jmp	#LR__0142
01d34                 | ' 
01d34                 | ' repeat i from 0 to 35
01d34     00 A6 06 F6 | 	mov	local01, #0
01d38                 | LR__0143
01d38     53 99 02 F6 | 	mov	arg05, local01
01d3c     01 98 06 F1 | 	add	arg05, #1
01d40     1C 00 00 FF 
01d44     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01d48     36 95 02 FB | 	rdlong	arg03, ptr__hg010b_spin2_dat__
01d4c     4A 99 02 FD | 	qmul	arg05, arg03
01d50                 | '   ram.read1($7E800, textbuf_ptr+(i+1)*timings[7], timings[7])
01d50     04 62 06 F1 | 	add	objptr, #4
01d54     31 93 02 FB | 	rdlong	arg02, objptr
01d58     1C 00 00 FF 
01d5c     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01d60     F4 03 00 FF 
01d64     00 90 06 F6 | 	mov	arg01, ##518144
01d68     0B 00 00 FF 
01d6c     CC 62 06 F1 | 	add	objptr, ##5836
01d70     18 98 62 FD | 	getqx	arg05
01d74     4C 93 02 F1 | 	add	arg02, arg05
01d78     DC 03 B0 FD | 	call	#_psram_spin2_read1
01d7c     1C 00 00 FF 
01d80     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01d84     36 95 02 FB | 	rdlong	arg03, ptr__hg010b_spin2_dat__
01d88     4A A7 02 FD | 	qmul	local01, arg03
01d8c                 | '   ram.write($7E800, textbuf_ptr+i*timings[7], timings[7])
01d8c     0B 00 00 FF 
01d90     CC 62 86 F1 | 	sub	objptr, ##5836
01d94     31 93 02 FB | 	rdlong	arg02, objptr
01d98     1C 00 00 FF 
01d9c     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01da0     F4 03 00 FF 
01da4     00 90 06 F6 | 	mov	arg01, ##518144
01da8     0B 00 00 FF 
01dac     CC 62 06 F1 | 	add	objptr, ##5836
01db0     18 98 62 FD | 	getqx	arg05
01db4     4C 93 02 F1 | 	add	arg02, arg05
01db8     38 04 B0 FD | 	call	#_psram_spin2_write
01dbc     0B 00 00 FF 
01dc0     D0 62 86 F1 | 	sub	objptr, ##5840
01dc4     01 A6 06 F1 | 	add	local01, #1
01dc8     24 A6 56 F2 | 	cmps	local01, #36 wc
01dcc     68 FF 9F CD |  if_b	jmp	#LR__0143
01dd0                 | ' repeat i from 0 to timings[7]-1
01dd0     00 A6 06 F6 | 	mov	local01, #0
01dd4     1C 00 00 FF 
01dd8     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01ddc     36 A9 02 FB | 	rdlong	local02, ptr__hg010b_spin2_dat__
01de0     1C 00 00 FF 
01de4     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01de8     01 A8 86 F1 | 	sub	local02, #1
01dec     00 A8 56 F2 | 	cmps	local02, #0 wc
01df0     01 AA 86 F6 | 	negc	local03, #1
01df4     55 A9 02 F1 | 	add	local02, local03
01df8                 | LR__0144
01df8                 | '   ram.fill(textbuf_ptr+(36*timings[7]+i),32,1,0,1) 
01df8     04 62 06 F1 | 	add	objptr, #4
01dfc     31 91 02 FB | 	rdlong	arg01, objptr
01e00     1C 00 00 FF 
01e04     5C 6C 06 F1 | 	add	ptr__hg010b_spin2_dat__, ##14428
01e08     36 99 02 FB | 	rdlong	arg05, ptr__hg010b_spin2_dat__
01e0c     1C 00 00 FF 
01e10     5C 6C 86 F1 | 	sub	ptr__hg010b_spin2_dat__, ##14428
01e14     4C 97 02 F6 | 	mov	arg04, arg05
01e18     03 96 66 F0 | 	shl	arg04, #3
01e1c     4C 97 02 F1 | 	add	arg04, arg05
01e20     02 96 66 F0 | 	shl	arg04, #2
01e24     53 97 02 F1 | 	add	arg04, local01
01e28     4B 91 02 F1 | 	add	arg01, arg04
01e2c     20 92 06 F6 | 	mov	arg02, #32
01e30     01 94 06 F6 | 	mov	arg03, #1
01e34     00 96 06 F6 | 	mov	arg04, #0
01e38     01 98 06 F6 | 	mov	arg05, #1
01e3c     0B 00 00 FF 
01e40     CC 62 06 F1 | 	add	objptr, ##5836
01e44     4C 04 B0 FD | 	call	#_psram_spin2_fill
01e48     0B 00 00 FF 
01e4c     D0 62 86 F1 | 	sub	objptr, ##5840
01e50     55 A7 02 F1 | 	add	local01, local03
01e54     54 A7 0A F2 | 	cmp	local01, local02 wz
01e58     9C FF 9F 5D |  if_ne	jmp	#LR__0144
01e5c     E7 F0 03 F6 | 	mov	ptra, fp
01e60     F2 00 A0 FD | 	call	#popregs_
01e64                 | _hg010b_spin2_scrollup2_ret
01e64     2D 00 64 FD | 	ret
01e68                 | 
01e68                 | ' 
01e68                 | ' ''----------- Set cursor at the first character in a new line, scroll if needed 
01e68                 | ' 
01e68                 | ' pub crlf()
01e68                 | _hg010b_spin2_crlf
01e68                 | ' 
01e68                 | ' cursor_x:=leading_spaces*2
01e68     01 00 00 FF 
01e6c     BA 62 06 F1 | 	add	objptr, ##698
01e70     31 95 02 FB | 	rdlong	arg03, objptr
01e74     01 94 66 F0 | 	shl	arg03, #1
01e78     01 00 00 FF 
01e7c     7E 62 86 F1 | 	sub	objptr, ##638
01e80     31 95 52 FC | 	wrword	arg03, objptr
01e84                 | ' cursor_y+=1
01e84     02 62 06 F1 | 	add	objptr, #2
01e88     31 95 C2 FA | 	rdbyte	arg03, objptr
01e8c     01 94 06 F1 | 	add	arg03, #1
01e90     31 95 42 FC | 	wrbyte	arg03, objptr
01e94                 | ' if cursor_y>st_lines-1
01e94     C7 62 06 F1 | 	add	objptr, #199
01e98     31 95 02 FB | 	rdlong	arg03, objptr
01e9c     01 94 86 F1 | 	sub	arg03, #1
01ea0     C7 62 86 F1 | 	sub	objptr, #199
01ea4     31 93 C2 FA | 	rdbyte	arg02, objptr
01ea8     3E 62 86 F1 | 	sub	objptr, #62
01eac     4A 93 5A F2 | 	cmps	arg02, arg03 wcz
01eb0     2C 00 90 ED |  if_be	jmp	#LR__0150
01eb4                 | '   scrollup2()
01eb4     00 90 06 F6 | 	mov	arg01, #0
01eb8     01 00 00 FF 
01ebc     58 92 06 F6 | 	mov	arg02, ##600
01ec0     10 94 06 F6 | 	mov	arg03, #16
01ec4     68 FD BF FD | 	call	#_hg010b_spin2_scrollup2
01ec8                 | '   cursor_y:=st_lines-1
01ec8     05 63 06 F1 | 	add	objptr, #261
01ecc     31 95 02 FB | 	rdlong	arg03, objptr
01ed0     01 94 86 F1 | 	sub	arg03, #1
01ed4     C7 62 86 F1 | 	sub	objptr, #199
01ed8     31 95 42 FC | 	wrbyte	arg03, objptr
01edc     3E 62 86 F1 | 	sub	objptr, #62
01ee0                 | LR__0150
01ee0                 | ' setspritepos(17,4*cursor_x,16*cursor_y+4 )  
01ee0     3C 62 06 F1 | 	add	objptr, #60
01ee4     31 93 E2 FA | 	rdword	arg02, objptr
01ee8     02 92 66 F0 | 	shl	arg02, #2
01eec     02 62 06 F1 | 	add	objptr, #2
01ef0     31 95 C2 FA | 	rdbyte	arg03, objptr
01ef4     3E 62 86 F1 | 	sub	objptr, #62
01ef8     04 94 66 F0 | 	shl	arg03, #4
01efc     04 94 06 F1 | 	add	arg03, #4
01f00     11 90 06 F6 | 	mov	arg01, #17
01f04     54 F3 BF FD | 	call	#_hg010b_spin2_setspritepos
01f08                 | _hg010b_spin2_crlf_ret
01f08     2D 00 64 FD | 	ret
01f0c                 | 
01f0c                 | ' 
01f0c                 | ' '..............................................................................
01f0c                 | ' 
01f0c                 | ' {{
01f0c                 | ' }}
01f0c                 | ' PUB startx(freq, burst, delay, desiredcog) : cog,mail | driverAddr
01f0c                 | _psram_spin2_startx
01f0c     04 CA 05 F6 | 	mov	COUNT_, #4
01f10     E8 00 A0 FD | 	call	#pushregs_
01f14     48 A7 02 F6 | 	mov	local01, arg01
01f18     4A A9 02 F6 | 	mov	local02, arg03
01f1c     4B AB 02 F6 | 	mov	local03, arg04
01f20                 | '     stop() ' restart driver if required
01f20     74 01 B0 FD | 	call	#_psram_spin2_stop
01f24     00 A6 0E F2 | 	cmp	local01, #0 wz
01f28     14 A6 06 AB |  if_e	rdlong	local01, #20
01f2c     53 93 52 F6 | 	abs	arg02, local01 wc
01f30     A1 07 00 FF 
01f34     40 92 16 FD | 	qdiv	arg02, ##1000000
01f38                 | ' 
01f38                 | '     ' use current frequency if none specified
01f38                 | ' 
01f38                 | '     if freq == 0 
01f38                 | '         freq := clkfreq 
01f38                 | ' 
01f38                 | '     ' compute the device burst size including overheads to keep CS low time below 8us
01f38                 | ' 
01f38                 | '     burst := (((MAX_CS_LOW_USEC*(freq/1000000)) - 132) >> 4) << 4  ' some sane rounded value
01f38                 | '     if burst < 0
01f38                 | '         return ERR_TOO_SLOW,0 ' P2 frequency is too low for any 8us transfers
01f38     18 92 62 FD | 	getqx	arg02
01f3c     49 97 82 F6 | 	negc	arg04, arg02
01f40     03 96 66 F0 | 	shl	arg04, #3
01f44     84 96 86 F1 | 	sub	arg04, #132
01f48     04 96 46 F0 | 	shr	arg04, #4
01f4c     04 96 66 F0 | 	shl	arg04, #4
01f50     00 96 56 F2 | 	cmps	arg04, #0 wc
01f54     00 78 06 C6 |  if_b	mov	result2, #0
01f58     0E 76 66 C6 |  if_b	neg	result1, #14
01f5c     2C 01 90 CD |  if_b	jmp	#LR__0164
01f60                 | ' 
01f60                 | '     ' compute the input delay
01f60                 | ' 
01f60                 | '     if delay <= 0
01f60     01 A8 56 F2 | 	cmps	local02, #1 wc
01f64     10 00 90 3D |  if_ae	jmp	#LR__0160
01f68                 | '         delay := lookupDelay(freq)
01f68     53 91 02 F6 | 	mov	arg01, local01
01f6c     DC 04 B0 FD | 	call	#_psram_spin2_lookupDelay
01f70     3B A9 02 F6 | 	mov	local02, result1
01f74     04 00 90 FD | 	jmp	#LR__0161
01f78                 | LR__0160
01f78                 | '     else
01f78                 | '         delay <#= $f ' limit to 15
01f78     0F A8 66 F3 | 	fles	local02, #15
01f7c                 | LR__0161
01f7c                 | ' 
01f7c                 | '     ' create our lock
01f7c                 | ' 
01f7c                 | '     driverlock := LOCKNEW()  
01f7c     00 76 06 F6 | 	mov	result1, #0
01f80     04 76 62 FD | 	locknew	result1
01f84     04 71 06 F1 | 	add	ptr__psram_spin2_dat__, #260
01f88     38 77 62 FC | 	wrlong	result1, ptr__psram_spin2_dat__
01f8c                 | '     if driverlock == -1
01f8c     04 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
01f90     FF FF 7F FF 
01f94     FF 77 0E F2 | 	cmp	result1, ##-1 wz
01f98                 | '         return ERR_NO_LOCK,0
01f98     00 78 06 A6 |  if_e	mov	result2, #0
01f9c     1A 76 66 A6 |  if_e	neg	result1, #26
01fa0     E8 00 90 AD |  if_e	jmp	#LR__0164
01fa4                 | ' 
01fa4                 | '     ' patch in the proper data and HUB addresses to the startup structure
01fa4                 | ' 
01fa4                 | '     long[@startupData][0]:=clkfreq
01fa4     14 A6 06 FB | 	rdlong	local01, #20
01fa8     28 71 06 F1 | 	add	ptr__psram_spin2_dat__, #296
01fac     38 A7 62 FC | 	wrlong	local01, ptr__psram_spin2_dat__
01fb0                 | ' '    long[@startupData][1]:=$1000_0000
01fb0                 | '     long[@startupData][5]:=@deviceData
01fb0     38 A7 02 F6 | 	mov	local01, ptr__psram_spin2_dat__
01fb4     20 A6 06 F1 | 	add	local01, #32
01fb8     38 93 02 F6 | 	mov	arg02, ptr__psram_spin2_dat__
01fbc     14 92 06 F1 | 	add	arg02, #20
01fc0     49 A7 62 FC | 	wrlong	local01, arg02
01fc4                 | '     long[@startupData][6]:=@qosData
01fc4     38 A7 02 F6 | 	mov	local01, ptr__psram_spin2_dat__
01fc8     A0 A6 06 F1 | 	add	local01, #160
01fcc     38 93 02 F6 | 	mov	arg02, ptr__psram_spin2_dat__
01fd0     18 92 06 F1 | 	add	arg02, #24
01fd4     49 A7 62 FC | 	wrlong	local01, arg02
01fd8                 | ' 
01fd8                 | ' 
01fd8                 | '     long[@startupData][7]:=mailbox
01fd8     38 A7 02 F6 | 	mov	local01, ptr__psram_spin2_dat__
01fdc     1C A6 06 F1 | 	add	local01, #28
01fe0     DF 03 80 FF 
01fe4     53 01 6A FC | 	wrlong	##507648, local01
01fe8                 | '   
01fe8                 | '     ' setup some default bank and QoS parameter values
01fe8                 | ' 
01fe8                 | '     longfill(@deviceData, (burst << 16) | (delay << 12) | (ADDRSIZE-1), 2)
01fe8     20 70 06 F1 | 	add	ptr__psram_spin2_dat__, #32
01fec     38 91 02 F6 | 	mov	arg01, ptr__psram_spin2_dat__
01ff0     48 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #328
01ff4     10 96 66 F0 | 	shl	arg04, #16
01ff8     0C A8 66 F0 | 	shl	local02, #12
01ffc     54 97 42 F5 | 	or	arg04, local02
02000     18 96 46 F5 | 	or	arg04, #24
02004     4B 93 02 F6 | 	mov	arg02, arg04
02008     02 94 06 F6 | 	mov	arg03, #2
0200c     E0 00 A0 FD | 	call	#\builtin_longfill_
02010                 | '     longfill(@qosData, $FFFF0000, 8)
02010     38 91 02 F6 | 	mov	arg01, ptr__psram_spin2_dat__
02014     C8 91 06 F1 | 	add	arg01, #456
02018     07 94 06 F6 | 	mov	arg03, #7
0201c     28 94 62 FD | 	setq	arg03
02020     80 FF FF FF 
02024     48 01 68 FC | 	wrlong	##-65536, arg01
02028                 | ' 
02028                 | '     ' get the address of the PSRAM memory driver so we can start it
02028                 | ' 
02028                 | '     driverAddr:= driver.getDriverAddr()
02028                 | '     return @driver_start
02028     37 93 02 F6 | 	mov	arg02, ptr__psram16drv_spin2_dat__
0202c     20 92 06 F1 | 	add	arg02, #32
02030                 | ' 
02030                 | '     ' start the PSRAM memory driver and wait for it to complete initialization
02030                 | ' 
02030                 | '     if desiredcog < 0
02030     00 AA 56 F2 | 	cmps	local03, #0 wc
02034                 | '         desiredcog := NEWCOG
02034     10 AA 06 C6 |  if_b	mov	local03, #16
02038                 | '     drivercog := coginit(desiredcog, driverAddr, @startupData)
02038     38 95 02 F6 | 	mov	arg03, ptr__psram_spin2_dat__
0203c     28 95 06 F1 | 	add	arg03, #296
02040     55 AD 02 F6 | 	mov	local04, local03
02044     28 94 62 FD | 	setq	arg03
02048     49 AD F2 FC | 	coginit	local04, arg02 wc
0204c     01 AC 66 C6 |  if_b	neg	local04, #1
02050     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
02054     38 AD 62 FC | 	wrlong	local04, ptr__psram_spin2_dat__
02058     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
0205c     D7 08 48 FB | 	callpa	#(@LR__0163-@LR__0162)>>2,fcache_load_ptr_
02060                 | '     repeat until long[@startupData] == 0 
02060                 | LR__0162
02060     38 AD 02 F6 | 	mov	local04, ptr__psram_spin2_dat__
02064     28 AD 06 F1 | 	add	local04, #296
02068     56 AD 0A FB | 	rdlong	local04, local04 wz
0206c     F0 FF 9F 5D |  if_ne	jmp	#LR__0162
02070                 | LR__0163
02070                 | ' 
02070                 | '     return drivercog,long[@startupData][7]
02070     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
02074     38 77 02 FB | 	rdlong	result1, ptr__psram_spin2_dat__
02078     28 70 06 F1 | 	add	ptr__psram_spin2_dat__, #40
0207c     38 AD 02 F6 | 	mov	local04, ptr__psram_spin2_dat__
02080     1C AC 06 F1 | 	add	local04, #28
02084     56 79 02 FB | 	rdlong	result2, local04
02088     28 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #296
0208c                 | LR__0164
0208c     E7 F0 03 F6 | 	mov	ptra, fp
02090     F2 00 A0 FD | 	call	#popregs_
02094                 | _psram_spin2_startx_ret
02094     2D 00 64 FD | 	ret
02098                 | 
02098                 | ' 
02098                 | ' '..............................................................................
02098                 | ' 
02098                 | ' {{
02098                 | ' }}
02098                 | ' PUB stop() : i
02098                 | _psram_spin2_stop
02098     00 7C 06 F6 | 	mov	_var01, #0
0209c                 | '     if drivercog <> -1
0209c     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
020a0     38 91 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
020a4     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
020a8     FF FF 7F FF 
020ac     FF 91 0E F2 | 	cmp	arg01, ##-1 wz
020b0     70 00 90 AD |  if_e	jmp	#LR__0173
020b4                 | '         cogstop(drivercog) ' a rather brutal stop
020b4     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
020b8     38 91 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
020bc     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
020c0     03 90 62 FD | 	cogstop	arg01
020c4     D7 26 48 FB | 	callpa	#(@LR__0172-@LR__0170)>>2,fcache_load_ptr_
020c8                 | '         repeat i from 0 to 7
020c8                 | LR__0170
020c8                 | '             if long[mailbox][i*3] < 0
020c8     3E 77 02 F6 | 	mov	result1, _var01
020cc     01 76 66 F0 | 	shl	result1, #1
020d0     3E 77 02 F1 | 	add	result1, _var01
020d4     02 76 66 F0 | 	shl	result1, #2
020d8     DF 03 00 FF 
020dc     00 77 06 F1 | 	add	result1, ##507648
020e0     3B 77 02 FB | 	rdlong	result1, result1
020e4     00 76 56 F2 | 	cmps	result1, #0 wc
020e8     1C 00 90 3D |  if_ae	jmp	#LR__0171
020ec                 | '                 long[mailbox][i*3] := -ERR_ABORTED ' abort request
020ec     3E 77 02 F6 | 	mov	result1, _var01
020f0     01 76 66 F0 | 	shl	result1, #1
020f4     3E 77 02 F1 | 	add	result1, _var01
020f8     02 76 66 F0 | 	shl	result1, #2
020fc     DF 03 00 FF 
02100     00 77 06 F1 | 	add	result1, ##507648
02104     3B 21 68 FC | 	wrlong	#16, result1
02108                 | LR__0171
02108     01 7C 06 F1 | 	add	_var01, #1
0210c     08 7C 56 F2 | 	cmps	_var01, #8 wc
02110     B4 FF 9F CD |  if_b	jmp	#LR__0170
02114                 | LR__0172
02114                 | '         drivercog := -1
02114     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
02118     FF FF FF FF 
0211c     38 FF 6B FC | 	wrlong	##-1, ptr__psram_spin2_dat__
02120     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
02124                 | LR__0173
02124                 | '     if driverlock <> -1
02124     04 71 06 F1 | 	add	ptr__psram_spin2_dat__, #260
02128     38 7F 02 FB | 	rdlong	_var02, ptr__psram_spin2_dat__
0212c     04 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
02130     FF FF 7F FF 
02134     FF 7F 0E F2 | 	cmp	_var02, ##-1 wz
02138                 | '         LOCKRET(driverlock)
02138     04 71 06 51 |  if_ne	add	ptr__psram_spin2_dat__, #260
0213c     38 91 02 5B |  if_ne	rdlong	arg01, ptr__psram_spin2_dat__
02140     05 90 62 5D |  if_ne	lockret	arg01
02144                 | '         driverlock := -1
02144     FF FF FF 5F 
02148     38 FF 6B 5C |  if_ne	wrlong	##-1, ptr__psram_spin2_dat__
0214c     04 71 86 51 |  if_ne	sub	ptr__psram_spin2_dat__, #260
02150     3E 77 02 F6 | 	mov	result1, _var01
02154                 | _psram_spin2_stop_ret
02154     2D 00 64 FD | 	ret
02158                 | 
02158                 | ' 
02158                 | ' '..............................................................................
02158                 | ' 
02158                 | ' {{
02158                 | ' }}
02158                 | ' PUB read1(dstHubAddr, srcAddr, count) : result | mailbox1
02158                 | _psram_spin2_read1
02158                 | ' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
02158                 | '     if drivercog == -1 ' driver must be running
02158     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
0215c     38 7D 02 FB | 	rdlong	_var01, ptr__psram_spin2_dat__
02160     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
02164     FF FF 7F FF 
02168     FF 7D 0E F2 | 	cmp	_var01, ##-1 wz
0216c                 | '         return ERR_INACTIVE
0216c     0F 76 66 A6 |  if_e	neg	result1, #15
02170     7C 00 90 AD |  if_e	jmp	#LR__0181
02174                 | '     if count == 0 ' don't even bother reading
02174     00 94 0E F2 | 	cmp	arg03, #0 wz
02178                 | '         return 0
02178     00 76 06 A6 |  if_e	mov	result1, #0
0217c     70 00 90 AD |  if_e	jmp	#LR__0181
02180                 | '     mailbox1 := mailbox + cogid()*12     ' compute COG's mailbox address
02180     DF 03 00 FF 
02184     00 7F 06 F6 | 	mov	_var02, ##507648
02188     00 76 06 F6 | 	mov	result1, #0
0218c     01 76 62 FD | 	cogid	result1
02190     3B 7D 02 F6 | 	mov	_var01, result1
02194     01 7C 66 F0 | 	shl	_var01, #1
02198     3B 7D 02 F1 | 	add	_var01, result1
0219c     02 7C 66 F0 | 	shl	_var01, #2
021a0     3E 7F 02 F1 | 	add	_var02, _var01
021a4                 | '     if long[mailbox1] < 0
021a4     3F 7D 02 FB | 	rdlong	_var01, _var02
021a8     00 7C 56 F2 | 	cmps	_var01, #0 wc
021ac                 | '         return ERR_MAILBOX_BUSY
021ac     1C 76 66 C6 |  if_b	neg	result1, #28
021b0     3C 00 90 CD |  if_b	jmp	#LR__0181
021b4                 | '     long[mailbox1][2] := count
021b4     08 7E 06 F1 | 	add	_var02, #8
021b8     3F 95 62 FC | 	wrlong	arg03, _var02
021bc                 | '     long[mailbox1][1] := dstHubAddr
021bc     04 7E 86 F1 | 	sub	_var02, #4
021c0     3F 91 62 FC | 	wrlong	arg01, _var02
021c4     04 7E 86 F1 | 	sub	_var02, #4
021c8                 | '     long[mailbox1] := driver.R_READBURST + (srcAddr & $1ffffff) ' trigger burst read operation
021c8     49 81 02 F6 | 	mov	_var03, arg02
021cc     D9 80 06 F4 | 	bitl	_var03, #217
021d0     00 00 58 FF 
021d4     00 7C 06 F6 | 	mov	_var01, ##-1342177280
021d8     40 7D 02 F1 | 	add	_var01, _var03
021dc     3F 7D 62 FC | 	wrlong	_var01, _var02
021e0                 | '     repeat
021e0                 | LR__0180
021e0                 | '         result := long[mailbox1]    
021e0     3F 81 02 FB | 	rdlong	_var03, _var02
021e4     00 80 56 F2 | 	cmps	_var03, #0 wc
021e8     F4 FF 9F CD |  if_b	jmp	#LR__0180
021ec                 | '     while result < 0   
021ec                 | '     return -result                       'return success or error
021ec     40 77 62 F6 | 	neg	result1, _var03
021f0                 | LR__0181
021f0                 | _psram_spin2_read1_ret
021f0     2D 00 64 FD | 	ret
021f4                 | 
021f4                 | ' 
021f4                 | ' '..............................................................................
021f4                 | ' 
021f4                 | ' {{
021f4                 | ' }}
021f4                 | ' PUB write(srcHubAddr, dstAddr, count) : result | mailbox1
021f4                 | _psram_spin2_write
021f4                 | ' 'TODO: potential candidate for inline PASM to improve performance in SPIN2
021f4                 | '     if drivercog == -1 ' driver must be running
021f4     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
021f8     38 7D 02 FB | 	rdlong	_var01, ptr__psram_spin2_dat__
021fc     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
02200     FF FF 7F FF 
02204     FF 7D 0E F2 | 	cmp	_var01, ##-1 wz
02208                 | '         return ERR_INACTIVE
02208     0F 76 66 A6 |  if_e	neg	result1, #15
0220c     80 00 90 AD |  if_e	jmp	#LR__0191
02210                 | '     if count == 0 ' don't even bother writing
02210     00 94 0E F2 | 	cmp	arg03, #0 wz
02214                 | '         return 0
02214     00 76 06 A6 |  if_e	mov	result1, #0
02218     74 00 90 AD |  if_e	jmp	#LR__0191
0221c                 | '     mailbox1 := mailbox + cogid()*12     ' compute COG's mailbox address
0221c     DF 03 00 FF 
02220     00 7F 06 F6 | 	mov	_var02, ##507648
02224     00 76 06 F6 | 	mov	result1, #0
02228     01 76 62 FD | 	cogid	result1
0222c     3B 7D 02 F6 | 	mov	_var01, result1
02230     01 7C 66 F0 | 	shl	_var01, #1
02234     3B 7D 02 F1 | 	add	_var01, result1
02238     02 7C 66 F0 | 	shl	_var01, #2
0223c     3E 7F 02 F1 | 	add	_var02, _var01
02240                 | '     if long[mailbox] < 0
02240     DF 03 00 FF 
02244     00 7D 06 FB | 	rdlong	_var01, ##507648
02248     00 7C 56 F2 | 	cmps	_var01, #0 wc
0224c                 | '         return ERR_MAILBOX_BUSY
0224c     1C 76 66 C6 |  if_b	neg	result1, #28
02250     3C 00 90 CD |  if_b	jmp	#LR__0191
02254                 | '     long[mailbox1][2] := count
02254     08 7E 06 F1 | 	add	_var02, #8
02258     3F 95 62 FC | 	wrlong	arg03, _var02
0225c                 | '     long[mailbox1][1] := srcHubAddr
0225c     04 7E 86 F1 | 	sub	_var02, #4
02260     3F 91 62 FC | 	wrlong	arg01, _var02
02264     04 7E 86 F1 | 	sub	_var02, #4
02268                 | '     long[mailbox1] := driver.R_WRITEBURST + (dstAddr & $1ffffff) ' trigger burst write operation
02268     49 81 02 F6 | 	mov	_var03, arg02
0226c     D9 80 06 F4 | 	bitl	_var03, #217
02270     00 00 78 FF 
02274     00 7C 06 F6 | 	mov	_var01, ##-268435456
02278     40 7D 02 F1 | 	add	_var01, _var03
0227c     3F 7D 62 FC | 	wrlong	_var01, _var02
02280                 | '     repeat
02280                 | LR__0190
02280                 | '         result := long[mailbox1]    
02280     3F 81 02 FB | 	rdlong	_var03, _var02
02284     00 80 56 F2 | 	cmps	_var03, #0 wc
02288     F4 FF 9F CD |  if_b	jmp	#LR__0190
0228c                 | '     while result < 0   
0228c                 | '     return -result                       'return success or error
0228c     40 77 62 F6 | 	neg	result1, _var03
02290                 | LR__0191
02290                 | _psram_spin2_write_ret
02290     2D 00 64 FD | 	ret
02294                 | 
02294                 | ' 
02294                 | ' ' generalized fill
02294                 | ' PUB fill(addr, pattern, count, listPtr, datasize) : r | mailbox1, req
02294                 | _psram_spin2_fill
02294     48 7D 02 F6 | 	mov	_var01, arg01
02298     49 7F 02 F6 | 	mov	_var02, arg02
0229c     4A 81 02 F6 | 	mov	_var03, arg03
022a0     4C 83 02 F6 | 	mov	_var04, arg05
022a4                 | '     case datasize 
022a4     01 82 86 F1 | 	sub	_var04, #1
022a8     04 82 26 F3 | 	fle	_var04, #4
022ac     30 82 62 FD | 	jmprel	_var04
022b0                 | LR__0200
022b0     10 00 90 FD | 	jmp	#LR__0201
022b4     18 00 90 FD | 	jmp	#LR__0202
022b8     2C 00 90 FD | 	jmp	#LR__0204
022bc     1C 00 90 FD | 	jmp	#LR__0203
022c0     24 00 90 FD | 	jmp	#LR__0204
022c4                 | LR__0201
022c4                 | '         1: req := driver.R_WRITEBYTE
022c4     00 00 60 FF 
022c8     00 84 06 F6 | 	mov	_var05, ##-1073741824
022cc     20 00 90 FD | 	jmp	#LR__0205
022d0                 | LR__0202
022d0                 | '         2: req := driver.R_WRITEWORD
022d0     00 00 68 FF 
022d4     00 84 06 F6 | 	mov	_var05, ##-805306368
022d8     14 00 90 FD | 	jmp	#LR__0205
022dc                 | LR__0203
022dc                 | '         4: req := driver.R_WRITELONG
022dc     00 00 70 FF 
022e0     00 84 06 F6 | 	mov	_var05, ##-536870912
022e4     08 00 90 FD | 	jmp	#LR__0205
022e8                 | LR__0204
022e8                 | '         other : return ERR_INVALID
022e8     06 76 66 F6 | 	neg	result1, #6
022ec     98 00 90 FD | 	jmp	#LR__0207
022f0                 | LR__0205
022f0                 | '     if count == 0   ' nothing to do
022f0     00 80 0E F2 | 	cmp	_var03, #0 wz
022f4                 | '         return 0
022f4     00 76 06 A6 |  if_e	mov	result1, #0
022f8     8C 00 90 AD |  if_e	jmp	#LR__0207
022fc                 | '     if drivercog == -1
022fc     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
02300     38 83 02 FB | 	rdlong	_var04, ptr__psram_spin2_dat__
02304     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
02308     FF FF 7F FF 
0230c     FF 83 0E F2 | 	cmp	_var04, ##-1 wz
02310                 | '         return ERR_INACTIVE
02310     0F 76 66 A6 |  if_e	neg	result1, #15
02314     70 00 90 AD |  if_e	jmp	#LR__0207
02318                 | '     mailbox1 := mailbox + 12*cogid() ' get mailbox base address for this COG
02318     DF 03 00 FF 
0231c     00 87 06 F6 | 	mov	_var06, ##507648
02320     00 76 06 F6 | 	mov	result1, #0
02324     01 76 62 FD | 	cogid	result1
02328     3B 83 02 F6 | 	mov	_var04, result1
0232c     01 82 66 F0 | 	shl	_var04, #1
02330     3B 83 02 F1 | 	add	_var04, result1
02334     02 82 66 F0 | 	shl	_var04, #2
02338     41 87 02 F1 | 	add	_var06, _var04
0233c                 | '     if long[mailbox] < 0
0233c     DF 03 00 FF 
02340     00 83 06 FB | 	rdlong	_var04, ##507648
02344     00 82 56 F2 | 	cmps	_var04, #0 wc
02348                 | '         return ERR_MAILBOX_BUSY
02348     1C 76 66 C6 |  if_b	neg	result1, #28
0234c     38 00 90 CD |  if_b	jmp	#LR__0207
02350                 | '     long[mailbox1][2] := count
02350     08 86 06 F1 | 	add	_var06, #8
02354     43 81 62 FC | 	wrlong	_var03, _var06
02358                 | '     long[mailbox1][1] := pattern
02358     04 86 86 F1 | 	sub	_var06, #4
0235c     43 7F 62 FC | 	wrlong	_var02, _var06
02360     04 86 86 F1 | 	sub	_var06, #4
02364                 | '     long[mailbox1] := req + (addr & $1ffffff)
02364     42 89 02 F6 | 	mov	_var07, _var05
02368     3E 8B 02 F6 | 	mov	_var08, _var01
0236c     D9 8A 06 F4 | 	bitl	_var08, #217
02370     45 89 02 F1 | 	add	_var07, _var08
02374     43 89 62 FC | 	wrlong	_var07, _var06
02378                 | '     repeat
02378                 | LR__0206
02378                 | '         r := long[mailbox1]
02378     43 8B 02 FB | 	rdlong	_var08, _var06
0237c     00 8A 56 F2 | 	cmps	_var08, #0 wc
02380     F4 FF 9F CD |  if_b	jmp	#LR__0206
02384                 | '     while r < 0
02384                 | '     return -r                  ' return 0 for success or negated error code
02384     45 77 62 F6 | 	neg	result1, _var08
02388                 | LR__0207
02388                 | _psram_spin2_fill_ret
02388     2D 00 64 FD | 	ret
0238c                 | 
0238c                 | ' 
0238c                 | ' '..............................................................................
0238c                 | ' 
0238c                 | ' {{
0238c                 | ' }}
0238c                 | ' PUB setQos(cog, qos) : result | mailbox1
0238c                 | _psram_spin2_setQos
0238c     48 7D 02 F6 | 	mov	_var01, arg01
02390                 | '     if drivercog == -1 ' driver must be running
02390     00 71 06 F1 | 	add	ptr__psram_spin2_dat__, #256
02394     38 7F 02 FB | 	rdlong	_var02, ptr__psram_spin2_dat__
02398     00 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #256
0239c     FF FF 7F FF 
023a0     FF 7F 0E F2 | 	cmp	_var02, ##-1 wz
023a4                 | '         return ERR_INACTIVE
023a4     0F 76 66 A6 |  if_e	neg	result1, #15
023a8     9C 00 90 AD |  if_e	jmp	#LR__0214
023ac                 | '     if cog < 0 or cog > 7 ' enforce cog id range
023ac     00 7C 56 F2 | 	cmps	_var01, #0 wc
023b0     08 00 90 CD |  if_b	jmp	#LR__0210
023b4     08 7C 56 F2 | 	cmps	_var01, #8 wc
023b8     08 00 90 CD |  if_b	jmp	#LR__0211
023bc                 | LR__0210
023bc                 | '         return ERR_INVALID
023bc     06 76 66 F6 | 	neg	result1, #6
023c0     84 00 90 FD | 	jmp	#LR__0214
023c4                 | LR__0211
023c4                 | '     long[@qosData][cog] := qos & !$1ff
023c4     FF 93 26 F5 | 	andn	arg02, #511
023c8     C8 71 06 F1 | 	add	ptr__psram_spin2_dat__, #456
023cc     02 7C 66 F0 | 	shl	_var01, #2
023d0     38 7D 02 F1 | 	add	_var01, ptr__psram_spin2_dat__
023d4     3E 93 62 FC | 	wrlong	arg02, _var01
023d8                 | '     mailbox1 := mailbox + drivercog*12
023d8     DF 03 00 FF 
023dc     00 81 06 F6 | 	mov	_var03, ##507648
023e0     C8 70 86 F1 | 	sub	ptr__psram_spin2_dat__, #200
023e4     38 83 02 FB | 	rdlong	_var04, ptr__psram_spin2_dat__
023e8     41 85 02 F6 | 	mov	_var05, _var04
023ec     01 84 66 F0 | 	shl	_var05, #1
023f0     41 85 02 F1 | 	add	_var05, _var04
023f4     02 84 66 F0 | 	shl	_var05, #2
023f8     42 81 02 F1 | 	add	_var03, _var05
023fc                 | '     repeat until LOCKTRY(driverlock)
023fc     04 70 06 F1 | 	add	ptr__psram_spin2_dat__, #4
02400                 | LR__0212
02400     38 91 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
02404     06 90 72 FD | 	locktry	arg01 wc
02408     F4 FF 9F 3D |  if_ae	jmp	#LR__0212
0240c     04 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
02410                 | '     long[mailbox1] := driver.R_CONFIG + cogid()
02410     00 84 06 F6 | 	mov	_var05, #0
02414     01 84 62 FD | 	cogid	_var05
02418     00 00 78 FF 
0241c     00 7E 06 F6 | 	mov	_var02, ##-268435456
02420     42 7F 02 F1 | 	add	_var02, _var05
02424     40 7F 62 FC | 	wrlong	_var02, _var03
02428                 | '     repeat while long[mailbox1] < 0
02428                 | LR__0213
02428     40 7F 02 FB | 	rdlong	_var02, _var03
0242c     00 7E 56 F2 | 	cmps	_var02, #0 wc
02430     F4 FF 9F CD |  if_b	jmp	#LR__0213
02434                 | '     LOCKREL(driverlock)
02434     04 71 06 F1 | 	add	ptr__psram_spin2_dat__, #260
02438     38 91 02 FB | 	rdlong	arg01, ptr__psram_spin2_dat__
0243c     04 71 86 F1 | 	sub	ptr__psram_spin2_dat__, #260
02440     07 90 72 FD | 	lockrel	arg01 wc
02444     00 76 06 F6 | 	mov	result1, #0
02448                 | LR__0214
02448                 | _psram_spin2_setQos_ret
02448     2D 00 64 FD | 	ret
0244c                 | 
0244c                 | ' 
0244c                 | ' '..............................................................................
0244c                 | ' 
0244c                 | ' {{
0244c                 | ' }}
0244c                 | ' PRI lookupDelay(freq) : delay | profile
0244c                 | _psram_spin2_lookupDelay
0244c                 | '     profile := @delayTable
0244c     38 7D 02 F6 | 	mov	_var01, ptr__psram_spin2_dat__
02450     08 7D 06 F1 | 	add	_var01, #264
02454                 | '     delay := long[profile][0]
02454     3E 7F 02 FB | 	rdlong	_var02, _var01
02458     D7 16 48 FB | 	callpa	#(@LR__0221-@LR__0220)>>2,fcache_load_ptr_
0245c                 | '     repeat while long[profile][1] 
0245c                 | LR__0220
0245c     04 7C 06 F1 | 	add	_var01, #4
02460     3E 77 0A FB | 	rdlong	result1, _var01 wz
02464     04 7C 86 F1 | 	sub	_var01, #4
02468     1C 00 90 AD |  if_e	jmp	#LR__0222
0246c                 | '         if freq +< long[profile][1] 
0246c     04 7C 06 F1 | 	add	_var01, #4
02470     3E 77 02 FB | 	rdlong	result1, _var01
02474     04 7C 86 F1 | 	sub	_var01, #4
02478     3B 91 12 F2 | 	cmp	arg01, result1 wc
0247c                 | '             quit
0247c                 | '         profile += 4
0247c     04 7C 06 31 |  if_ae	add	_var01, #4
02480                 | '         delay++
02480     01 7E 06 31 |  if_ae	add	_var02, #1
02484     D4 FF 9F 3D |  if_ae	jmp	#LR__0220
02488                 | LR__0221
02488                 | LR__0222
02488     3F 77 02 F6 | 	mov	result1, _var02
0248c                 | _psram_spin2_lookupDelay_ret
0248c     2D 00 64 FD | 	ret
02490                 | 
02490                 | ' 
02490                 | ' PUB start() : r
02490                 | _usbnew_spin2_start
02490     00 7C 06 F6 | 	mov	_var01, #0
02494                 | '   ifnot driver_cog
02494     15 00 00 FF 
02498     87 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##10887
0249c     39 7F CA FA | 	rdbyte	_var02, ptr__usbnew_spin2_dat__ wz
024a0     15 00 00 FF 
024a4     87 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##10887
024a8     38 00 90 5D |  if_ne	jmp	#LR__0230
024ac                 | '     r := coginit(COGEXEC_NEW,@usb_host_start,0)
024ac     39 93 02 F6 | 	mov	arg02, ptr__usbnew_spin2_dat__
024b0     10 7C 06 F6 | 	mov	_var01, #16
024b4     00 94 06 F6 | 	mov	arg03, #0
024b8     28 94 62 FD | 	setq	arg03
024bc     49 7D F2 FC | 	coginit	_var01, arg02 wc
024c0     01 7C 66 C6 |  if_b	neg	_var01, #1
024c4                 | '     if r >= 0
024c4     00 7C 56 F2 | 	cmps	_var01, #0 wc
024c8                 | '       driver_cog := r+1
024c8     3E 7F 02 36 |  if_ae	mov	_var02, _var01
024cc     01 7E 06 31 |  if_ae	add	_var02, #1
024d0     15 00 00 3F 
024d4     87 72 06 31 |  if_ae	add	ptr__usbnew_spin2_dat__, ##10887
024d8     39 7F 42 3C |  if_ae	wrbyte	_var02, ptr__usbnew_spin2_dat__
024dc     15 00 00 3F 
024e0     87 72 86 31 |  if_ae	sub	ptr__usbnew_spin2_dat__, ##10887
024e4                 | LR__0230
024e4     3E 77 02 F6 | 	mov	result1, _var01
024e8                 | _usbnew_spin2_start_ret
024e8     2D 00 64 FD | 	ret
024ec                 | 
024ec                 | ' 
024ec                 | ' '' Emulate mouse movement
024ec                 | ' PUB mouse_move(x,y)
024ec                 | _usbnew_spin2_mouse_move
024ec     02 CA 05 F6 | 	mov	COUNT_, #2
024f0     E8 00 A0 FD | 	call	#pushregs_
024f4     48 A7 02 F6 | 	mov	local01, arg01
024f8     49 A9 02 F6 | 	mov	local02, arg02
024fc                 | '   mouse_lock := 1
024fc     14 00 00 FF 
02500     F1 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##10481
02504     39 03 48 FC | 	wrbyte	#1, ptr__usbnew_spin2_dat__
02508     14 00 00 FF 
0250c     F1 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##10481
02510                 | '   waitus(2) ' hope driver is now done
02510     02 90 06 F6 | 	mov	arg01, #2
02514     D4 0D B0 FD | 	call	#__system___waitus
02518                 | '   mouse_xacc := x
02518     14 00 00 FF 
0251c     E1 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##10465
02520     39 A7 62 FC | 	wrlong	local01, ptr__usbnew_spin2_dat__
02524                 | '   mouse_yacc := y
02524     04 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, #4
02528     39 A9 62 FC | 	wrlong	local02, ptr__usbnew_spin2_dat__
0252c                 | '   if mouse_outptr
0252c     05 00 00 FF 
02530     15 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##2581
02534     39 93 0A FB | 	rdlong	arg02, ptr__usbnew_spin2_dat__ wz
02538     0F 00 00 FF 
0253c     D0 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##7888
02540     24 00 90 AD |  if_e	jmp	#LR__0240
02544                 | '     long[mouse_outptr] := y << 16 | x & $FFFF
02544     10 A8 66 F0 | 	shl	local02, #16
02548     53 A7 32 F9 | 	getword	local01, local01, #0
0254c     53 A9 42 F5 | 	or	local02, local01
02550     0F 00 00 FF 
02554     D0 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##7888
02558     39 A7 02 FB | 	rdlong	local01, ptr__usbnew_spin2_dat__
0255c     0F 00 00 FF 
02560     D0 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##7888
02564     53 A9 62 FC | 	wrlong	local02, local01
02568                 | LR__0240
02568                 | '   mouse_lock := 0
02568     14 00 00 FF 
0256c     F1 72 06 F1 | 	add	ptr__usbnew_spin2_dat__, ##10481
02570     39 01 48 FC | 	wrbyte	#0, ptr__usbnew_spin2_dat__
02574     14 00 00 FF 
02578     F1 72 86 F1 | 	sub	ptr__usbnew_spin2_dat__, ##10481
0257c     E7 F0 03 F6 | 	mov	ptra, fp
02580     F2 00 A0 FD | 	call	#popregs_
02584                 | _usbnew_spin2_mouse_move_ret
02584     2D 00 64 FD | 	ret
02588                 | 
02588                 | ' 
02588                 | ' '--------------------------------------------------------------
02588                 | ' '---------- Init the variables, start the cog. ----------------
02588                 | ' '--------------------------------------------------------------
02588                 | ' 
02588                 | ' pub start(mbox,scope,cache) :cog,base | iii
02588                 | _Audio2_004_spin2_start
02588     04 CA 05 F6 | 	mov	COUNT_, #4
0258c     E8 00 A0 FD | 	call	#pushregs_
02590     48 A7 02 F6 | 	mov	local01, arg01
02594                 | ' 
02594                 | ' ' mbox: PSRAM mailbox or 0 if no PSRAM
02594                 | ' ' scope: a pointer to 640 long oscilloscope data in HUB wor visualization
02594                 | ' ' cache: a pointer to 2 KB long HUB cache for PSRAM audio data
02594                 | ' 
02594                 | ' mailboxaddr:=mbox 
02594     31 A7 62 FC | 	wrlong	local01, objptr
02598                 | ' scope_ptr:=scope
02598     04 62 06 F1 | 	add	objptr, #4
0259c     31 93 62 FC | 	wrlong	arg02, objptr
025a0                 | ' cache_ptr:=cache
025a0     04 62 06 F1 | 	add	objptr, #4
025a4     31 95 62 FC | 	wrlong	arg03, objptr
025a8                 | ' base:=@channel0[0]
025a8     04 62 06 F1 | 	add	objptr, #4
025ac     31 A9 02 F6 | 	mov	local02, objptr
025b0                 | ' 
025b0                 | ' repeat iii from 0 to 15
025b0     00 AA 06 F6 | 	mov	local03, #0
025b4     0C 62 86 F1 | 	sub	objptr, #12
025b8     D7 1A 49 FB | 	callpa	#(@LR__0251-@LR__0250)>>2,fcache_load_ptr_
025bc                 | LR__0250
025bc                 | '   long[base+64*iii]:=0
025bc     54 A7 02 F6 | 	mov	local01, local02
025c0     55 79 02 F6 | 	mov	result2, local03
025c4     06 78 66 F0 | 	shl	result2, #6
025c8     3C A7 02 F1 | 	add	local01, result2
025cc     53 01 68 FC | 	wrlong	#0, local01
025d0                 | '   long[base+64*iii+4]:=0  		
025d0     54 A7 02 F6 | 	mov	local01, local02
025d4     55 79 02 F6 | 	mov	result2, local03
025d8     06 78 66 F0 | 	shl	result2, #6
025dc     3C A7 02 F1 | 	add	local01, result2
025e0     04 A6 06 F1 | 	add	local01, #4
025e4     53 01 68 FC | 	wrlong	#0, local01
025e8                 | '   long[base+64*iii+8]:=0
025e8     54 AD 02 F6 | 	mov	local04, local02
025ec     55 A7 02 F6 | 	mov	local01, local03
025f0     06 A6 66 F0 | 	shl	local01, #6
025f4     53 AD 02 F1 | 	add	local04, local01
025f8     08 AC 06 F1 | 	add	local04, #8
025fc     56 01 68 FC | 	wrlong	#0, local04
02600                 | '   long[base+64*iii+12]:=0
02600     54 AD 02 F6 | 	mov	local04, local02
02604     55 A7 02 F6 | 	mov	local01, local03
02608     06 A6 66 F0 | 	shl	local01, #6
0260c     53 AD 02 F1 | 	add	local04, local01
02610     0C AC 06 F1 | 	add	local04, #12
02614     56 01 68 FC | 	wrlong	#0, local04
02618                 | '   long[base+64*iii+16]:=0
02618     54 AD 02 F6 | 	mov	local04, local02
0261c     55 A7 02 F6 | 	mov	local01, local03
02620     06 A6 66 F0 | 	shl	local01, #6
02624     53 AD 02 F1 | 	add	local04, local01
02628     10 AC 06 F1 | 	add	local04, #16
0262c     56 01 68 FC | 	wrlong	#0, local04
02630                 | '   long[base+64*iii+20]:=0
02630     54 AD 02 F6 | 	mov	local04, local02
02634     55 A7 02 F6 | 	mov	local01, local03
02638     06 A6 66 F0 | 	shl	local01, #6
0263c     53 AD 02 F1 | 	add	local04, local01
02640     14 AC 06 F1 | 	add	local04, #20
02644     56 01 68 FC | 	wrlong	#0, local04
02648                 | '   long[base+64*iii+24]:=0
02648     54 AD 02 F6 | 	mov	local04, local02
0264c     55 A7 02 F6 | 	mov	local01, local03
02650     06 A6 66 F0 | 	shl	local01, #6
02654     53 AD 02 F1 | 	add	local04, local01
02658     18 AC 06 F1 | 	add	local04, #24
0265c     56 01 68 FC | 	wrlong	#0, local04
02660                 | '   long[base+64*iii+28]:=0
02660     54 AD 02 F6 | 	mov	local04, local02
02664     55 A7 02 F6 | 	mov	local01, local03
02668     06 A6 66 F0 | 	shl	local01, #6
0266c     53 AD 02 F1 | 	add	local04, local01
02670     1C AC 06 F1 | 	add	local04, #28
02674     56 01 68 FC | 	wrlong	#0, local04
02678                 | '   word[base+64*iii+32]:=8192
02678     54 AD 02 F6 | 	mov	local04, local02
0267c     55 A7 02 F6 | 	mov	local01, local03
02680     06 A6 66 F0 | 	shl	local01, #6
02684     53 AD 02 F1 | 	add	local04, local01
02688     20 AC 06 F1 | 	add	local04, #32
0268c     10 00 80 FF 
02690     56 01 58 FC | 	wrword	##8192, local04
02694                 | '   word[base+64*iii+34]:=8192
02694     54 AD 02 F6 | 	mov	local04, local02
02698     55 A7 02 F6 | 	mov	local01, local03
0269c     06 A6 66 F0 | 	shl	local01, #6
026a0     53 AD 02 F1 | 	add	local04, local01
026a4     22 AC 06 F1 | 	add	local04, #34
026a8     10 00 80 FF 
026ac     56 01 58 FC | 	wrword	##8192, local04
026b0                 | '   long[base+64*iii+36]:=0
026b0     54 AD 02 F6 | 	mov	local04, local02
026b4     55 A7 02 F6 | 	mov	local01, local03
026b8     06 A6 66 F0 | 	shl	local01, #6
026bc     53 AD 02 F1 | 	add	local04, local01
026c0     24 AC 06 F1 | 	add	local04, #36
026c4     56 01 68 FC | 	wrlong	#0, local04
026c8                 | '   long[base+64*iii+40]:=0
026c8     54 AD 02 F6 | 	mov	local04, local02
026cc     55 A7 02 F6 | 	mov	local01, local03
026d0     06 A6 66 F0 | 	shl	local01, #6
026d4     53 AD 02 F1 | 	add	local04, local01
026d8     28 AC 06 F1 | 	add	local04, #40
026dc     56 01 68 FC | 	wrlong	#0, local04
026e0                 | '   long[base+64*iii+44]:=0
026e0     54 AD 02 F6 | 	mov	local04, local02
026e4     55 A7 02 F6 | 	mov	local01, local03
026e8     06 A6 66 F0 | 	shl	local01, #6
026ec     53 AD 02 F1 | 	add	local04, local01
026f0     2C AC 06 F1 | 	add	local04, #44
026f4     56 01 68 FC | 	wrlong	#0, local04
026f8                 | '   long[base+64*iii+48]:=0
026f8     54 AD 02 F6 | 	mov	local04, local02
026fc     55 A7 02 F6 | 	mov	local01, local03
02700     06 A6 66 F0 | 	shl	local01, #6
02704     53 AD 02 F1 | 	add	local04, local01
02708     30 AC 06 F1 | 	add	local04, #48
0270c     56 01 68 FC | 	wrlong	#0, local04
02710                 | '   long[base+64*iii+52]:=0
02710     54 AD 02 F6 | 	mov	local04, local02
02714     55 A7 02 F6 | 	mov	local01, local03
02718     06 A6 66 F0 | 	shl	local01, #6
0271c     53 AD 02 F1 | 	add	local04, local01
02720     34 AC 06 F1 | 	add	local04, #52
02724     56 01 68 FC | 	wrlong	#0, local04
02728                 | '   freqs[iii]:=440000
02728     55 AD 02 F6 | 	mov	local04, local03
0272c     02 AC 66 F0 | 	shl	local04, #2
02730     02 00 00 FF 
02734     0C 62 06 F1 | 	add	objptr, ##1036
02738     31 AD 02 F1 | 	add	local04, objptr
0273c     5B 03 80 FF 
02740     56 81 69 FC | 	wrlong	##440000, local04
02744                 | '   delays[iii]:=0
02744     55 AD 02 F6 | 	mov	local04, local03
02748     01 AC 66 F0 | 	shl	local04, #1
0274c     40 62 06 F1 | 	add	objptr, #64
02750     31 AD 02 F1 | 	add	local04, objptr
02754     56 01 58 FC | 	wrword	#0, local04
02758                 | '   volumes[iii]:=4096
02758     55 AD 02 F6 | 	mov	local04, local03
0275c     01 AC 66 F0 | 	shl	local04, #1
02760     20 62 06 F1 | 	add	objptr, #32
02764     31 AD 02 F1 | 	add	local04, objptr
02768     08 00 80 FF 
0276c     56 01 58 FC | 	wrword	##4096, local04
02770                 | '   waveforms[iii]:=0
02770     55 AD 02 F6 | 	mov	local04, local03
02774     02 AC 66 F0 | 	shl	local04, #2
02778     20 62 06 F1 | 	add	objptr, #32
0277c     31 AD 02 F1 | 	add	local04, objptr
02780     56 01 68 FC | 	wrlong	#0, local04
02784                 | '   envelopes[iii]:=0
02784     55 AD 02 F6 | 	mov	local04, local03
02788     02 AC 66 F0 | 	shl	local04, #2
0278c     40 62 06 F1 | 	add	objptr, #64
02790     31 AD 02 F1 | 	add	local04, objptr
02794     56 01 68 FC | 	wrlong	#0, local04
02798                 | '   lengths[iii]:=1000
02798     55 AD 02 F6 | 	mov	local04, local03
0279c     01 AC 66 F0 | 	shl	local04, #1
027a0     40 62 06 F1 | 	add	objptr, #64
027a4     31 AD 02 F1 | 	add	local04, objptr
027a8     01 00 80 FF 
027ac     56 D1 5B FC | 	wrword	##1000, local04
027b0                 | '   pans[iii]:=8192
027b0     55 AD 02 F6 | 	mov	local04, local03
027b4     01 AC 66 F0 | 	shl	local04, #1
027b8     20 62 06 F1 | 	add	objptr, #32
027bc     31 AD 02 F1 | 	add	local04, objptr
027c0     10 00 80 FF 
027c4     56 01 58 FC | 	wrword	##8192, local04
027c8                 | '   sustains[iii]:=255
027c8     55 AD 02 F6 | 	mov	local04, local03
027cc     01 AC 66 F0 | 	shl	local04, #1
027d0     20 62 06 F1 | 	add	objptr, #32
027d4     31 AD 02 F1 | 	add	local04, objptr
027d8     56 FF 59 FC | 	wrword	#255, local04
027dc     01 AA 06 F1 | 	add	local03, #1
027e0     10 AA 56 F2 | 	cmps	local03, #16 wc
027e4     02 00 00 FF 
027e8     4C 63 86 F1 | 	sub	objptr, ##1356
027ec     CC FD 9F CD |  if_b	jmp	#LR__0250
027f0                 | LR__0251
027f0                 | '   
027f0                 | ' cog:=coginit(16,@audio,@mailboxaddr)
027f0     32 93 02 F6 | 	mov	arg02, ptr__Audio2_004_spin2_dat__
027f4     31 95 02 F6 | 	mov	arg03, objptr
027f8     10 AC 06 F6 | 	mov	local04, #16
027fc     28 94 62 FD | 	setq	arg03
02800     49 AD F2 FC | 	coginit	local04, arg02 wc
02804     01 AC 66 C6 |  if_b	neg	local04, #1
02808                 | ' waitms(10)
02808     0A 90 06 F6 | 	mov	arg01, #10
0280c     70 0A B0 FD | 	call	#__system___waitms
02810                 | ' return cog,base
02810     54 79 02 F6 | 	mov	result2, local02
02814     56 77 02 F6 | 	mov	result1, local04
02818     E7 F0 03 F6 | 	mov	ptra, fp
0281c     F2 00 A0 FD | 	call	#popregs_
02820                 | _Audio2_004_spin2_start_ret
02820     2D 00 64 FD | 	ret
02824                 | 
02824                 | ' 
02824                 | ' sub create(avdrv as vdrv,ax=0,ay=0,aw=16,ah=128,alabel$="",ac1=10,ac2=15, ac3=120 )
02824                 | _window_create
02824     04 62 06 F1 | 	add	objptr, #4
02828     31 93 62 FC | 	wrlong	arg02, objptr
0282c     04 62 06 F1 | 	add	objptr, #4
02830     31 95 62 FC | 	wrlong	arg03, objptr
02834     04 62 06 F1 | 	add	objptr, #4
02838     31 97 62 FC | 	wrlong	arg04, objptr
0283c     04 62 06 F1 | 	add	objptr, #4
02840     31 99 62 FC | 	wrlong	arg05, objptr
02844     10 62 06 F1 | 	add	objptr, #16
02848     31 9D 62 FC | 	wrlong	arg07, objptr
0284c     04 62 06 F1 | 	add	objptr, #4
02850     31 9F 62 FC | 	wrlong	arg08, objptr
02854     04 62 06 F1 | 	add	objptr, #4
02858     31 A1 62 FC | 	wrlong	arg09, objptr
0285c     04 62 06 F1 | 	add	objptr, #4
02860     31 9B 62 FC | 	wrlong	arg06, objptr
02864     08 62 06 F1 | 	add	objptr, #8
02868     48 93 02 F6 | 	mov	arg02, arg01
0286c     31 91 02 F6 | 	mov	arg01, objptr
02870     0B 00 00 FF 
02874     D0 94 06 F6 | 	mov	arg03, ##5840
02878     34 62 86 F1 | 	sub	objptr, #52
0287c     3C 08 B0 FD | 	call	#__system____builtin_memmove
02880     04 00 B0 FD | 	call	#_window_draw
02884                 | _window_create_ret
02884     2D 00 64 FD | 	ret
02888                 | 
02888                 | ' 
02888                 | ' 
02888                 | ' sub draw
02888                 | _window_draw
02888     01 CA 05 F6 | 	mov	COUNT_, #1
0288c     E8 00 A0 FD | 	call	#pushregs_
02890     04 62 06 F1 | 	add	objptr, #4
02894     31 91 02 FB | 	rdlong	arg01, objptr
02898     04 62 06 F1 | 	add	objptr, #4
0289c     31 93 02 FB | 	rdlong	arg02, objptr
028a0     48 95 02 F6 | 	mov	arg03, arg01
028a4     04 62 06 F1 | 	add	objptr, #4
028a8     31 77 02 FB | 	rdlong	result1, objptr
028ac     3B 95 02 F1 | 	add	arg03, result1
028b0     01 94 86 F1 | 	sub	arg03, #1
028b4     49 97 02 F6 | 	mov	arg04, arg02
028b8     04 62 06 F1 | 	add	objptr, #4
028bc     31 77 02 FB | 	rdlong	result1, objptr
028c0     3B 97 02 F1 | 	add	arg04, result1
028c4     01 96 86 F1 | 	sub	arg04, #1
028c8     10 62 06 F1 | 	add	objptr, #16
028cc     31 99 02 FB | 	rdlong	arg05, objptr
028d0     14 62 06 F1 | 	add	objptr, #20
028d4     40 ED BF FD | 	call	#_hg010b_spin2_frame
028d8     30 62 86 F1 | 	sub	objptr, #48
028dc     31 91 02 FB | 	rdlong	arg01, objptr
028e0     01 90 06 F1 | 	add	arg01, #1
028e4     04 62 06 F1 | 	add	objptr, #4
028e8     31 93 02 FB | 	rdlong	arg02, objptr
028ec     01 92 06 F1 | 	add	arg02, #1
028f0     04 62 86 F1 | 	sub	objptr, #4
028f4     31 95 02 FB | 	rdlong	arg03, objptr
028f8     08 62 06 F1 | 	add	objptr, #8
028fc     31 77 02 FB | 	rdlong	result1, objptr
02900     3B 95 02 F1 | 	add	arg03, result1
02904     02 94 86 F1 | 	sub	arg03, #2
02908     04 62 86 F1 | 	sub	objptr, #4
0290c     31 97 02 FB | 	rdlong	arg04, objptr
02910     08 62 06 F1 | 	add	objptr, #8
02914     31 77 02 FB | 	rdlong	result1, objptr
02918     3B 97 02 F1 | 	add	arg04, result1
0291c     02 96 86 F1 | 	sub	arg04, #2
02920     14 62 06 F1 | 	add	objptr, #20
02924     31 99 02 FB | 	rdlong	arg05, objptr
02928     10 62 06 F1 | 	add	objptr, #16
0292c     68 ED BF FD | 	call	#_hg010b_spin2_box
02930     30 62 86 F1 | 	sub	objptr, #48
02934     31 91 02 FB | 	rdlong	arg01, objptr
02938     02 90 06 F1 | 	add	arg01, #2
0293c     04 62 06 F1 | 	add	objptr, #4
02940     31 93 02 FB | 	rdlong	arg02, objptr
02944     02 92 06 F1 | 	add	arg02, #2
02948     04 62 86 F1 | 	sub	objptr, #4
0294c     31 95 02 FB | 	rdlong	arg03, objptr
02950     08 62 06 F1 | 	add	objptr, #8
02954     31 77 02 FB | 	rdlong	result1, objptr
02958     3B 95 02 F1 | 	add	arg03, result1
0295c     03 94 86 F1 | 	sub	arg03, #3
02960     04 62 86 F1 | 	sub	objptr, #4
02964     31 97 02 FB | 	rdlong	arg04, objptr
02968     14 96 06 F1 | 	add	arg04, #20
0296c     20 62 06 F1 | 	add	objptr, #32
02970     31 99 02 FB | 	rdlong	arg05, objptr
02974     0C 62 06 F1 | 	add	objptr, #12
02978     1C ED BF FD | 	call	#_hg010b_spin2_box
0297c     30 62 86 F1 | 	sub	objptr, #48
02980     31 99 02 FB | 	rdlong	arg05, objptr
02984     02 98 06 F1 | 	add	arg05, #2
02988     08 62 06 F1 | 	add	objptr, #8
0298c     31 77 02 FB | 	rdlong	result1, objptr
02990     3B 97 52 F6 | 	abs	arg04, result1 wc
02994     01 96 46 F0 | 	shr	arg04, #1
02998     4B 99 82 F3 | 	sumc	arg05, arg04
0299c     20 62 06 F1 | 	add	objptr, #32
029a0     31 91 02 FB | 	rdlong	arg01, objptr
029a4     2C 62 86 F1 | 	sub	objptr, #44
029a8     48 A7 02 F6 | 	mov	local01, arg01
029ac     D7 06 48 FB | 	callpa	#(@LR__0261-@LR__0260)>>2,fcache_load_ptr_
029b0                 | LR__0260
029b0     53 77 CA FA | 	rdbyte	result1, local01 wz
029b4     01 A6 06 51 |  if_ne	add	local01, #1
029b8     F4 FF 9F 5D |  if_ne	jmp	#LR__0260
029bc                 | LR__0261
029bc     48 A7 82 F1 | 	sub	local01, arg01
029c0     53 77 02 F6 | 	mov	result1, local01
029c4     02 76 66 F0 | 	shl	result1, #2
029c8     3B 99 82 F1 | 	sub	arg05, result1
029cc     08 62 06 F1 | 	add	objptr, #8
029d0     31 93 02 FB | 	rdlong	arg02, objptr
029d4     03 92 06 F1 | 	add	arg02, #3
029d8     24 62 06 F1 | 	add	objptr, #36
029dc     31 95 02 FB | 	rdlong	arg03, objptr
029e0     08 62 86 F1 | 	sub	objptr, #8
029e4     31 97 02 FB | 	rdlong	arg04, objptr
029e8     4C 91 02 F6 | 	mov	arg01, arg05
029ec     10 62 06 F1 | 	add	objptr, #16
029f0     AC EE BF FD | 	call	#_hg010b_spin2_outtextxycf
029f4     34 62 86 F1 | 	sub	objptr, #52
029f8     E7 F0 03 F6 | 	mov	ptra, fp
029fc     F2 00 A0 FD | 	call	#popregs_
02a00                 | _window_draw_ret
02a00     2D 00 64 FD | 	ret
02a04                 | 
02a04                 | ' 
02a04                 | ' sub create(avdrv as vdrv,ax=0,ay=0,aw=16,ah=128,amin=0,amax=10,aticks=11,ac1=244,ac2=248,alabel$="")
02a04                 | _trackbar_create
02a04     04 62 06 F1 | 	add	objptr, #4
02a08     31 93 62 FC | 	wrlong	arg02, objptr
02a0c     04 62 06 F1 | 	add	objptr, #4
02a10     31 95 62 FC | 	wrlong	arg03, objptr
02a14     04 62 06 F1 | 	add	objptr, #4
02a18     31 97 62 FC | 	wrlong	arg04, objptr
02a1c     04 62 06 F1 | 	add	objptr, #4
02a20     31 99 62 FC | 	wrlong	arg05, objptr
02a24     04 62 06 F1 | 	add	objptr, #4
02a28     31 9B 62 FC | 	wrlong	arg06, objptr
02a2c     04 62 06 F1 | 	add	objptr, #4
02a30     31 9D 62 FC | 	wrlong	arg07, objptr
02a34     04 62 06 F1 | 	add	objptr, #4
02a38     31 9F 62 FC | 	wrlong	arg08, objptr
02a3c     04 62 06 F1 | 	add	objptr, #4
02a40     31 A1 62 FC | 	wrlong	arg09, objptr
02a44     04 62 06 F1 | 	add	objptr, #4
02a48     31 A3 62 FC | 	wrlong	arg10, objptr
02a4c     04 62 06 F1 | 	add	objptr, #4
02a50     31 A5 62 FC | 	wrlong	arg11, objptr
02a54     04 62 06 F1 | 	add	objptr, #4
02a58     48 93 02 F6 | 	mov	arg02, arg01
02a5c     31 91 02 F6 | 	mov	arg01, objptr
02a60     0B 00 00 FF 
02a64     D0 94 06 F6 | 	mov	arg03, ##5840
02a68     2C 62 86 F1 | 	sub	objptr, #44
02a6c     4C 06 B0 FD | 	call	#__system____builtin_memmove
02a70     04 00 B0 FD | 	call	#_trackbar_draw
02a74                 | _trackbar_create_ret
02a74     2D 00 64 FD | 	ret
02a78                 | 
02a78                 | ' 
02a78                 | ' 
02a78                 | ' sub draw
02a78                 | _trackbar_draw
02a78     09 CA 05 F6 | 	mov	COUNT_, #9
02a7c     E8 00 A0 FD | 	call	#pushregs_
02a80     04 62 06 F1 | 	add	objptr, #4
02a84     31 91 02 FB | 	rdlong	arg01, objptr
02a88     04 62 06 F1 | 	add	objptr, #4
02a8c     31 93 02 FB | 	rdlong	arg02, objptr
02a90     48 95 02 F6 | 	mov	arg03, arg01
02a94     04 62 06 F1 | 	add	objptr, #4
02a98     31 77 02 FB | 	rdlong	result1, objptr
02a9c     3B 95 02 F1 | 	add	arg03, result1
02aa0     01 94 86 F1 | 	sub	arg03, #1
02aa4     49 97 02 F6 | 	mov	arg04, arg02
02aa8     04 62 06 F1 | 	add	objptr, #4
02aac     31 77 02 FB | 	rdlong	result1, objptr
02ab0     3B 97 02 F1 | 	add	arg04, result1
02ab4     01 96 86 F1 | 	sub	arg04, #1
02ab8     10 62 06 F1 | 	add	objptr, #16
02abc     31 99 02 FB | 	rdlong	arg05, objptr
02ac0     0C 62 06 F1 | 	add	objptr, #12
02ac4     D0 EB BF FD | 	call	#_hg010b_spin2_box
02ac8     28 62 86 F1 | 	sub	objptr, #40
02acc     31 91 02 FB | 	rdlong	arg01, objptr
02ad0     03 90 06 F1 | 	add	arg01, #3
02ad4     04 62 06 F1 | 	add	objptr, #4
02ad8     31 93 02 FB | 	rdlong	arg02, objptr
02adc     03 92 06 F1 | 	add	arg02, #3
02ae0     04 62 86 F1 | 	sub	objptr, #4
02ae4     31 95 02 FB | 	rdlong	arg03, objptr
02ae8     08 62 06 F1 | 	add	objptr, #8
02aec     31 77 02 FB | 	rdlong	result1, objptr
02af0     3B 95 02 F1 | 	add	arg03, result1
02af4     04 94 86 F1 | 	sub	arg03, #4
02af8     04 62 86 F1 | 	sub	objptr, #4
02afc     31 97 02 FB | 	rdlong	arg04, objptr
02b00     08 62 06 F1 | 	add	objptr, #8
02b04     31 77 02 FB | 	rdlong	result1, objptr
02b08     3B 97 02 F1 | 	add	arg04, result1
02b0c     04 96 86 F1 | 	sub	arg04, #4
02b10     14 62 06 F1 | 	add	objptr, #20
02b14     31 99 02 FB | 	rdlong	arg05, objptr
02b18     08 62 06 F1 | 	add	objptr, #8
02b1c     78 EB BF FD | 	call	#_hg010b_spin2_box
02b20     1C 62 86 F1 | 	sub	objptr, #28
02b24     31 91 02 FB | 	rdlong	arg01, objptr
02b28     10 62 86 F1 | 	sub	objptr, #16
02b2c     48 91 52 F6 | 	abs	arg01, arg01 wc
02b30     1F A6 C6 C9 |  if_b	decod	local01, #31
02b34     00 A6 06 36 |  if_ae	mov	local01, #0
02b38     74 1A B0 FD | 	call	#__system___float_fromuns
02b3c     53 77 62 F5 | 	xor	result1, local01
02b40     3B A9 02 F6 | 	mov	local02, result1
02b44     1C 62 06 F1 | 	add	objptr, #28
02b48     31 91 02 FB | 	rdlong	arg01, objptr
02b4c     1C 62 86 F1 | 	sub	objptr, #28
02b50     01 90 86 F1 | 	sub	arg01, #1
02b54     48 91 52 F6 | 	abs	arg01, arg01 wc
02b58     1F A6 C6 C9 |  if_b	decod	local01, #31
02b5c     00 A6 06 36 |  if_ae	mov	local01, #0
02b60     4C 1A B0 FD | 	call	#__system___float_fromuns
02b64     53 77 62 F5 | 	xor	result1, local01
02b68     3B 93 02 F6 | 	mov	arg02, result1
02b6c     54 91 02 F6 | 	mov	arg01, local02
02b70     6C 1F B0 FD | 	call	#__system___float_div
02b74     3B AB 02 F6 | 	mov	local03, result1
02b78     00 90 06 F6 | 	mov	arg01, #0
02b7c     5C 3A B0 FD | 	call	#__system___getiolock_0133
02b80     3B 91 02 F6 | 	mov	arg01, result1
02b84     14 06 B0 FD | 	call	#__system___lockmem
02b88     00 90 06 F6 | 	mov	arg01, #0
02b8c     55 93 02 F6 | 	mov	arg02, local03
02b90     00 94 06 F6 | 	mov	arg03, #0
02b94     23 96 06 F6 | 	mov	arg04, #35
02b98     64 23 B0 FD | 	call	#__system___basic_print_float
02b9c     00 90 06 F6 | 	mov	arg01, #0
02ba0     0A 92 06 F6 | 	mov	arg02, #10
02ba4     00 94 06 F6 | 	mov	arg03, #0
02ba8     D8 0F B0 FD | 	call	#__system___basic_print_char
02bac     00 90 06 F6 | 	mov	arg01, #0
02bb0     28 3A B0 FD | 	call	#__system___getiolock_0133
02bb4     3B 01 68 FC | 	wrlong	#0, result1
02bb8     18 62 06 F1 | 	add	objptr, #24
02bbc     31 91 02 FB | 	rdlong	arg01, objptr
02bc0     04 62 86 F1 | 	sub	objptr, #4
02bc4     31 A9 02 FB | 	rdlong	local02, objptr
02bc8     14 62 86 F1 | 	sub	objptr, #20
02bcc     54 91 82 F1 | 	sub	arg01, local02
02bd0     48 91 52 F6 | 	abs	arg01, arg01 wc
02bd4     1F A6 C6 C9 |  if_b	decod	local01, #31
02bd8     00 A6 06 36 |  if_ae	mov	local01, #0
02bdc     D0 19 B0 FD | 	call	#__system___float_fromuns
02be0     53 77 62 F5 | 	xor	result1, local01
02be4     3B A9 02 F6 | 	mov	local02, result1
02be8     1C 62 06 F1 | 	add	objptr, #28
02bec     31 91 02 FB | 	rdlong	arg01, objptr
02bf0     1C 62 86 F1 | 	sub	objptr, #28
02bf4     01 90 86 F1 | 	sub	arg01, #1
02bf8     48 91 52 F6 | 	abs	arg01, arg01 wc
02bfc     1F A6 C6 C9 |  if_b	decod	local01, #31
02c00     00 A6 06 36 |  if_ae	mov	local01, #0
02c04     A8 19 B0 FD | 	call	#__system___float_fromuns
02c08     53 77 62 F5 | 	xor	result1, local01
02c0c     3B 93 02 F6 | 	mov	arg02, result1
02c10     54 91 02 F6 | 	mov	arg01, local02
02c14     C8 1E B0 FD | 	call	#__system___float_div
02c18     3B AD 02 F6 | 	mov	local04, result1
02c1c     00 90 06 F6 | 	mov	arg01, #0
02c20     B8 39 B0 FD | 	call	#__system___getiolock_0133
02c24     3B 91 02 F6 | 	mov	arg01, result1
02c28     70 05 B0 FD | 	call	#__system___lockmem
02c2c     00 90 06 F6 | 	mov	arg01, #0
02c30     56 93 02 F6 | 	mov	arg02, local04
02c34     00 94 06 F6 | 	mov	arg03, #0
02c38     23 96 06 F6 | 	mov	arg04, #35
02c3c     C0 22 B0 FD | 	call	#__system___basic_print_float
02c40     00 90 06 F6 | 	mov	arg01, #0
02c44     0A 92 06 F6 | 	mov	arg02, #10
02c48     00 94 06 F6 | 	mov	arg03, #0
02c4c     34 0F B0 FD | 	call	#__system___basic_print_char
02c50     00 90 06 F6 | 	mov	arg01, #0
02c54     84 39 B0 FD | 	call	#__system___getiolock_0133
02c58     3B 01 68 FC | 	wrlong	#0, result1
02c5c                 | ' 
02c5c                 | ' for i=0 to ticks-1: v.fastline(x,x+3,round(y+h-i*hr),0) : v.outtextxycf(x-8-4*len(str$(round(min+i*dv))),round(y+h-i*hr)-8,str$(round(min+i*dv)),c2):next i
02c5c     00 AE 06 F6 | 	mov	local05, #0
02c60     1C 62 06 F1 | 	add	objptr, #28
02c64     31 B1 02 FB | 	rdlong	local06, objptr
02c68     1C 62 86 F1 | 	sub	objptr, #28
02c6c                 | LR__0270
02c6c     58 AF 52 F2 | 	cmps	local05, local06 wc
02c70     54 02 90 3D |  if_ae	jmp	#LR__0273
02c74     04 62 06 F1 | 	add	objptr, #4
02c78     31 B3 02 FB | 	rdlong	local07, objptr
02c7c     59 A9 02 F6 | 	mov	local02, local07
02c80     04 62 06 F1 | 	add	objptr, #4
02c84     31 91 02 FB | 	rdlong	arg01, objptr
02c88     08 62 06 F1 | 	add	objptr, #8
02c8c     31 99 02 FB | 	rdlong	arg05, objptr
02c90     10 62 86 F1 | 	sub	objptr, #16
02c94     4C 91 02 F1 | 	add	arg01, arg05
02c98     03 B2 06 F1 | 	add	local07, #3
02c9c     48 91 52 F6 | 	abs	arg01, arg01 wc
02ca0     1F A6 C6 C9 |  if_b	decod	local01, #31
02ca4     00 A6 06 36 |  if_ae	mov	local01, #0
02ca8     04 19 B0 FD | 	call	#__system___float_fromuns
02cac     53 77 62 F5 | 	xor	result1, local01
02cb0     3B B5 02 F6 | 	mov	local08, result1
02cb4     57 91 52 F6 | 	abs	arg01, local05 wc
02cb8     1F A6 C6 C9 |  if_b	decod	local01, #31
02cbc     00 A6 06 36 |  if_ae	mov	local01, #0
02cc0     EC 18 B0 FD | 	call	#__system___float_fromuns
02cc4     53 77 62 F5 | 	xor	result1, local01
02cc8     3B 91 02 F6 | 	mov	arg01, result1
02ccc     55 93 02 F6 | 	mov	arg02, local03
02cd0     08 1C B0 FD | 	call	#__system___float_mul
02cd4     3B 93 02 F6 | 	mov	arg02, result1
02cd8     5A 91 02 F6 | 	mov	arg01, local08
02cdc     1F 92 E6 F4 | 	bitnot	arg02, #31
02ce0     00 19 B0 FD | 	call	#__system___float_add
02ce4     3B 91 02 F6 | 	mov	arg01, result1
02ce8     01 92 06 F6 | 	mov	arg02, #1
02cec     B4 20 B0 FD | 	call	#__system___float_tointeger
02cf0     3B 95 02 F6 | 	mov	arg03, result1
02cf4     54 91 02 F6 | 	mov	arg01, local02
02cf8     59 93 02 F6 | 	mov	arg02, local07
02cfc     00 96 06 F6 | 	mov	arg04, #0
02d00     2C 62 06 F1 | 	add	objptr, #44
02d04     B8 E6 BF FD | 	call	#_hg010b_spin2_fastline
02d08     28 62 86 F1 | 	sub	objptr, #40
02d0c     31 A9 02 FB | 	rdlong	local02, objptr
02d10     08 A8 86 F1 | 	sub	local02, #8
02d14     10 62 06 F1 | 	add	objptr, #16
02d18     31 91 02 FB | 	rdlong	arg01, objptr
02d1c     14 62 86 F1 | 	sub	objptr, #20
02d20     48 91 52 F6 | 	abs	arg01, arg01 wc
02d24     1F A6 C6 C9 |  if_b	decod	local01, #31
02d28     00 A6 06 36 |  if_ae	mov	local01, #0
02d2c     80 18 B0 FD | 	call	#__system___float_fromuns
02d30     53 77 62 F5 | 	xor	result1, local01
02d34     3B B5 02 F6 | 	mov	local08, result1
02d38     57 91 52 F6 | 	abs	arg01, local05 wc
02d3c     1F A6 C6 C9 |  if_b	decod	local01, #31
02d40     00 A6 06 36 |  if_ae	mov	local01, #0
02d44     68 18 B0 FD | 	call	#__system___float_fromuns
02d48     53 77 62 F5 | 	xor	result1, local01
02d4c     3B 91 02 F6 | 	mov	arg01, result1
02d50     56 93 02 F6 | 	mov	arg02, local04
02d54     84 1B B0 FD | 	call	#__system___float_mul
02d58     3B 93 02 F6 | 	mov	arg02, result1
02d5c     5A 91 02 F6 | 	mov	arg01, local08
02d60     80 18 B0 FD | 	call	#__system___float_add
02d64     3B 91 02 F6 | 	mov	arg01, result1
02d68     01 92 06 F6 | 	mov	arg02, #1
02d6c     34 20 B0 FD | 	call	#__system___float_tointeger
02d70     3B 91 52 F6 | 	abs	arg01, result1 wc
02d74     1F A6 C6 C9 |  if_b	decod	local01, #31
02d78     00 A6 06 36 |  if_ae	mov	local01, #0
02d7c     30 18 B0 FD | 	call	#__system___float_fromuns
02d80     53 77 62 F5 | 	xor	result1, local01
02d84     3B 91 02 F6 | 	mov	arg01, result1
02d88     E0 16 B0 FD | 	call	#__system__str_S
02d8c     3B 91 02 F6 | 	mov	arg01, result1
02d90     48 B7 02 F6 | 	mov	local09, arg01
02d94     D7 06 48 FB | 	callpa	#(@LR__0272-@LR__0271)>>2,fcache_load_ptr_
02d98                 | LR__0271
02d98     5B 77 CA FA | 	rdbyte	result1, local09 wz
02d9c     01 B6 06 51 |  if_ne	add	local09, #1
02da0     F4 FF 9F 5D |  if_ne	jmp	#LR__0271
02da4                 | LR__0272
02da4     48 B7 82 F1 | 	sub	local09, arg01
02da8     5B 77 02 F6 | 	mov	result1, local09
02dac     02 76 66 F0 | 	shl	result1, #2
02db0     3B A9 82 F1 | 	sub	local02, result1
02db4     08 62 06 F1 | 	add	objptr, #8
02db8     31 91 02 FB | 	rdlong	arg01, objptr
02dbc     08 62 06 F1 | 	add	objptr, #8
02dc0     31 B5 02 FB | 	rdlong	local08, objptr
02dc4     10 62 86 F1 | 	sub	objptr, #16
02dc8     5A 91 02 F1 | 	add	arg01, local08
02dcc     48 91 52 F6 | 	abs	arg01, arg01 wc
02dd0     1F A6 C6 C9 |  if_b	decod	local01, #31
02dd4     00 A6 06 36 |  if_ae	mov	local01, #0
02dd8     D4 17 B0 FD | 	call	#__system___float_fromuns
02ddc     53 77 62 F5 | 	xor	result1, local01
02de0     3B B5 02 F6 | 	mov	local08, result1
02de4     57 91 52 F6 | 	abs	arg01, local05 wc
02de8     1F A6 C6 C9 |  if_b	decod	local01, #31
02dec     00 A6 06 36 |  if_ae	mov	local01, #0
02df0     BC 17 B0 FD | 	call	#__system___float_fromuns
02df4     53 77 62 F5 | 	xor	result1, local01
02df8     3B 91 02 F6 | 	mov	arg01, result1
02dfc     55 93 02 F6 | 	mov	arg02, local03
02e00     D8 1A B0 FD | 	call	#__system___float_mul
02e04     3B 93 02 F6 | 	mov	arg02, result1
02e08     5A 91 02 F6 | 	mov	arg01, local08
02e0c     1F 92 E6 F4 | 	bitnot	arg02, #31
02e10     D0 17 B0 FD | 	call	#__system___float_add
02e14     3B 91 02 F6 | 	mov	arg01, result1
02e18     01 92 06 F6 | 	mov	arg02, #1
02e1c     84 1F B0 FD | 	call	#__system___float_tointeger
02e20     08 76 86 F1 | 	sub	result1, #8
02e24     3B B3 02 F6 | 	mov	local07, result1
02e28     14 62 06 F1 | 	add	objptr, #20
02e2c     31 91 02 FB | 	rdlong	arg01, objptr
02e30     14 62 86 F1 | 	sub	objptr, #20
02e34     48 91 52 F6 | 	abs	arg01, arg01 wc
02e38     1F A6 C6 C9 |  if_b	decod	local01, #31
02e3c     00 A6 06 36 |  if_ae	mov	local01, #0
02e40     6C 17 B0 FD | 	call	#__system___float_fromuns
02e44     53 77 62 F5 | 	xor	result1, local01
02e48     3B B5 02 F6 | 	mov	local08, result1
02e4c     57 91 52 F6 | 	abs	arg01, local05 wc
02e50     1F A6 C6 C9 |  if_b	decod	local01, #31
02e54     00 A6 06 36 |  if_ae	mov	local01, #0
02e58     54 17 B0 FD | 	call	#__system___float_fromuns
02e5c     53 77 62 F5 | 	xor	result1, local01
02e60     3B 91 02 F6 | 	mov	arg01, result1
02e64     56 93 02 F6 | 	mov	arg02, local04
02e68     70 1A B0 FD | 	call	#__system___float_mul
02e6c     3B 93 02 F6 | 	mov	arg02, result1
02e70     5A 91 02 F6 | 	mov	arg01, local08
02e74     6C 17 B0 FD | 	call	#__system___float_add
02e78     3B 91 02 F6 | 	mov	arg01, result1
02e7c     01 92 06 F6 | 	mov	arg02, #1
02e80     20 1F B0 FD | 	call	#__system___float_tointeger
02e84     3B 91 52 F6 | 	abs	arg01, result1 wc
02e88     1F A6 C6 C9 |  if_b	decod	local01, #31
02e8c     00 A6 06 36 |  if_ae	mov	local01, #0
02e90     1C 17 B0 FD | 	call	#__system___float_fromuns
02e94     53 77 62 F5 | 	xor	result1, local01
02e98     3B 91 02 F6 | 	mov	arg01, result1
02e9c     CC 15 B0 FD | 	call	#__system__str_S
02ea0     3B 95 02 F6 | 	mov	arg03, result1
02ea4     24 62 06 F1 | 	add	objptr, #36
02ea8     31 97 02 FB | 	rdlong	arg04, objptr
02eac     54 91 02 F6 | 	mov	arg01, local02
02eb0     59 93 02 F6 | 	mov	arg02, local07
02eb4     08 62 06 F1 | 	add	objptr, #8
02eb8     E4 E9 BF FD | 	call	#_hg010b_spin2_outtextxycf
02ebc     2C 62 86 F1 | 	sub	objptr, #44
02ec0     01 AE 06 F1 | 	add	local05, #1
02ec4     A4 FD 9F FD | 	jmp	#LR__0270
02ec8                 | LR__0273
02ec8     E7 F0 03 F6 | 	mov	ptra, fp
02ecc     F2 00 A0 FD | 	call	#popregs_
02ed0                 | _trackbar_draw_ret
02ed0     2D 00 64 FD | 	ret
02ed4                 | hubexit
02ed4     C1 00 80 FD | 	jmp	#cogexit
02ed8                 | 
02ed8                 | __system___setbaud
02ed8     14 F8 06 FB | 	rdlong	muldiva_, #20
02edc     48 FB 02 F6 | 	mov	muldivb_, arg01
02ee0     FA 00 A0 FD | 	call	#divide_
02ee4     D7 06 48 FB | 	callpa	#(@LR__0281-@LR__0280)>>2,fcache_load_ptr_
02ee8                 | LR__0280
02ee8     3E 76 9E FA | 	rdpin	result1, #62 wc
02eec     3C 79 A2 F1 | 	subx	result2, result2
02ef0     F4 FF 9F CD |  if_b	jmp	#LR__0280
02ef4                 | LR__0281
02ef4     40 7C 64 FD | 	dirl	#62
02ef8     40 7E 64 FD | 	dirl	#63
02efc     33 FB 62 FC | 	wrlong	muldivb_, ptr___system__dat__
02f00     10 FA 66 F0 | 	shl	muldivb_, #16
02f04     07 92 06 F6 | 	mov	arg02, #7
02f08     7D 93 02 F1 | 	add	arg02, muldivb_
02f0c     3E F8 0C FC | 	wrpin	#124, #62
02f10     3E 92 16 FC | 	wxpin	arg02, #62
02f14     3F 7C 0C FC | 	wrpin	#62, #63
02f18     14 92 06 F1 | 	add	arg02, #20
02f1c     3F 92 16 FC | 	wxpin	arg02, #63
02f20     41 7C 64 FD | 	dirh	#62
02f24     41 7E 64 FD | 	dirh	#63
02f28                 | __system___setbaud_ret
02f28     2D 00 64 FD | 	ret
02f2c                 | 
02f2c                 | __system___txraw
02f2c     01 CA 05 F6 | 	mov	COUNT_, #1
02f30     E8 00 A0 FD | 	call	#pushregs_
02f34     48 A7 02 F6 | 	mov	local01, arg01
02f38     D7 06 48 FB | 	callpa	#(@LR__0291-@LR__0290)>>2,fcache_load_ptr_
02f3c                 | LR__0290
02f3c     3E 76 9E FA | 	rdpin	result1, #62 wc
02f40     3C 79 A2 F1 | 	subx	result2, result2
02f44     F4 FF 9F CD |  if_b	jmp	#LR__0290
02f48                 | LR__0291
02f48     33 77 0A FB | 	rdlong	result1, ptr___system__dat__ wz
02f4c     42 0F 00 AF 
02f50     80 90 06 A6 |  if_e	mov	arg01, ##2000000
02f54     80 FF BF AD |  if_e	call	#__system___setbaud
02f58     58 7C 64 FD | 	drvl	#62
02f5c     3E A6 26 FC | 	wypin	local01, #62
02f60     01 76 06 F6 | 	mov	result1, #1
02f64     E7 F0 03 F6 | 	mov	ptra, fp
02f68     F2 00 A0 FD | 	call	#popregs_
02f6c                 | __system___txraw_ret
02f6c     2D 00 64 FD | 	ret
02f70                 | 
02f70                 | __system___rxraw
02f70     0D CA 05 F6 | 	mov	COUNT_, #13
02f74     E8 00 A0 FD | 	call	#pushregs_
02f78     48 A7 02 F6 | 	mov	local01, arg01
02f7c     33 A9 0A FB | 	rdlong	local02, ptr___system__dat__ wz
02f80     42 0F 00 AF 
02f84     80 90 06 A6 |  if_e	mov	arg01, ##2000000
02f88     4C FF BF AD |  if_e	call	#__system___setbaud
02f8c     00 A6 0E F2 | 	cmp	local01, #0 wz
02f90     20 00 90 AD |  if_e	jmp	#LR__0300
02f94     14 AA 06 FB | 	rdlong	local03, #20
02f98     0A AA 46 F0 | 	shr	local03, #10
02f9c     55 A7 02 FD | 	qmul	local01, local03
02fa0     1A 76 62 FD | 	getct	result1
02fa4     18 AC 62 FD | 	getqx	local04
02fa8     56 77 02 F1 | 	add	result1, local04
02fac     3B AF 02 F6 | 	mov	local05, result1
02fb0     04 00 90 FD | 	jmp	#LR__0301
02fb4                 | LR__0300
02fb4     00 AE 06 F6 | 	mov	local05, #0
02fb8                 | LR__0301
02fb8     01 B0 66 F6 | 	neg	local06, #1
02fbc     3F B2 06 F6 | 	mov	local07, #63
02fc0     00 B4 06 F6 | 	mov	local08, #0
02fc4     04 66 06 F1 | 	add	ptr___system__dat__, #4
02fc8     33 B7 02 FB | 	rdlong	local09, ptr___system__dat__
02fcc     04 66 86 F1 | 	sub	ptr___system__dat__, #4
02fd0                 | LR__0302
02fd0     08 B6 16 F4 | 	testb	local09, #8 wc
02fd4     09 B6 76 F4 | 	testbn	local09, #9 andc
02fd8     0A B6 46 F0 | 	shr	local09, #10
02fdc     01 B4 06 C6 |  if_b	mov	local08, #1
02fe0     40 7E 6C 3D |  if_ae	testp	#63 wz
02fe4     01 B4 06 26 |  if_nc_and_z	mov	local08, #1
02fe8     3F B6 8E 2A |  if_nc_and_z	rdpin	local09, #63
02fec     04 B6 46 20 |  if_nc_and_z	shr	local09, #4
02ff0                 | LR__0303
02ff0     00 A8 06 F6 | 	mov	local02, #0
02ff4     00 B4 0E F2 | 	cmp	local08, #0 wz
02ff8     01 A8 66 56 |  if_ne	neg	local02, #1
02ffc     00 B8 06 F6 | 	mov	local10, #0
03000     00 AA 06 F6 | 	mov	local03, #0
03004     00 A6 0E F2 | 	cmp	local01, #0 wz
03008     01 AA 66 56 |  if_ne	neg	local03, #1
0300c     00 AC 06 F6 | 	mov	local04, #0
03010     00 BA 06 F6 | 	mov	local11, #0
03014     57 BD 02 F6 | 	mov	local12, local05
03018     1A 76 62 FD | 	getct	result1
0301c     3B BF 02 F6 | 	mov	local13, result1
03020     5F BD 82 F1 | 	sub	local12, local13
03024     00 BC 56 F2 | 	cmps	local12, #0 wc
03028     00 BA 26 C6 |  if_b	not	local11, #0
0302c     00 BA 0E F2 | 	cmp	local11, #0 wz
03030     00 AC 26 56 |  if_ne	not	local04, #0
03034     56 AB CA F7 | 	test	local03, local04 wz
03038     00 B8 26 56 |  if_ne	not	local10, #0
0303c     5C A9 4A F5 | 	or	local02, local10 wz
03040     8C FF 9F AD |  if_e	jmp	#LR__0302
03044     00 B4 0E F2 | 	cmp	local08, #0 wz
03048     5B B1 02 56 |  if_ne	mov	local06, local09
0304c     58 B1 E2 58 |  if_ne	getbyte	local06, local06, #0
03050     04 66 06 F1 | 	add	ptr___system__dat__, #4
03054     33 B7 62 FC | 	wrlong	local09, ptr___system__dat__
03058     04 66 86 F1 | 	sub	ptr___system__dat__, #4
0305c     58 77 02 F6 | 	mov	result1, local06
03060     E7 F0 03 F6 | 	mov	ptra, fp
03064     F2 00 A0 FD | 	call	#popregs_
03068                 | __system___rxraw_ret
03068     2D 00 64 FD | 	ret
0306c                 | 
0306c                 | __system___getus
0306c     1A 78 72 FD | 	getct	result2 wc
03070     1A 7C 62 FD | 	getct	_var01
03074     10 66 06 F1 | 	add	ptr___system__dat__, #16
03078     33 7F 0A FB | 	rdlong	_var02, ptr___system__dat__ wz
0307c     10 66 86 F1 | 	sub	ptr___system__dat__, #16
03080     20 00 90 5D |  if_ne	jmp	#LR__0310
03084     14 7E 06 FB | 	rdlong	_var02, #20
03088     A1 07 00 FF 
0308c     40 7E 16 FD | 	qdiv	_var02, ##1000000
03090     10 66 06 F1 | 	add	ptr___system__dat__, #16
03094     18 76 62 FD | 	getqx	result1
03098     3B 7F 02 F6 | 	mov	_var02, result1
0309c     33 77 62 FC | 	wrlong	result1, ptr___system__dat__
030a0     10 66 86 F1 | 	sub	ptr___system__dat__, #16
030a4                 | LR__0310
030a4     3F 79 12 FD | 	qdiv	result2, _var02
030a8     19 78 62 FD | 	getqy	result2
030ac     28 78 62 FD | 	setq	result2
030b0     3F 7D 12 FD | 	qdiv	_var01, _var02
030b4     18 76 62 FD | 	getqx	result1
030b8                 | __system___getus_ret
030b8     2D 00 64 FD | 	ret
030bc                 | 
030bc                 | __system____builtin_memmove
030bc     48 7D 02 F6 | 	mov	_var01, arg01
030c0     49 91 52 F2 | 	cmps	arg01, arg02 wc
030c4     10 00 90 CD |  if_b	jmp	#LR__0320
030c8     49 7F 02 F6 | 	mov	_var02, arg02
030cc     4A 7F 02 F1 | 	add	_var02, arg03
030d0     3F 91 52 F2 | 	cmps	arg01, _var02 wc
030d4     48 00 90 CD |  if_b	jmp	#LR__0326
030d8                 | LR__0320
030d8     4A 81 02 F6 | 	mov	_var03, arg03
030dc     02 80 4E F0 | 	shr	_var03, #2 wz
030e0     18 00 90 AD |  if_e	jmp	#LR__0325
030e4     D7 0A 48 FB | 	callpa	#(@LR__0323-@LR__0321)>>2,fcache_load_ptr_
030e8                 | LR__0321
030e8     40 09 D8 FC | 	rep	@LR__0324, _var03
030ec                 | LR__0322
030ec     49 81 02 FB | 	rdlong	_var03, arg02
030f0     48 81 62 FC | 	wrlong	_var03, arg01
030f4     04 90 06 F1 | 	add	arg01, #4
030f8     04 92 06 F1 | 	add	arg02, #4
030fc                 | LR__0323
030fc                 | LR__0324
030fc                 | LR__0325
030fc     02 94 CE F7 | 	test	arg03, #2 wz
03100     49 7F E2 5A |  if_ne	rdword	_var02, arg02
03104     48 7F 52 5C |  if_ne	wrword	_var02, arg01
03108     02 90 06 51 |  if_ne	add	arg01, #2
0310c     02 92 06 51 |  if_ne	add	arg02, #2
03110     01 94 CE F7 | 	test	arg03, #1 wz
03114     49 7F C2 5A |  if_ne	rdbyte	_var02, arg02
03118     48 7F 42 5C |  if_ne	wrbyte	_var02, arg01
0311c     28 00 90 FD | 	jmp	#LR__0332
03120                 | LR__0326
03120     4A 91 02 F1 | 	add	arg01, arg03
03124     4A 93 02 F1 | 	add	arg02, arg03
03128     4A 83 0A F6 | 	mov	_var04, arg03 wz
0312c     18 00 90 AD |  if_e	jmp	#LR__0331
03130     D7 0A 48 FB | 	callpa	#(@LR__0329-@LR__0327)>>2,fcache_load_ptr_
03134                 | LR__0327
03134     41 09 D8 FC | 	rep	@LR__0330, _var04
03138                 | LR__0328
03138     01 90 86 F1 | 	sub	arg01, #1
0313c     01 92 86 F1 | 	sub	arg02, #1
03140     49 7F C2 FA | 	rdbyte	_var02, arg02
03144     48 7F 42 FC | 	wrbyte	_var02, arg01
03148                 | LR__0329
03148                 | LR__0330
03148                 | LR__0331
03148                 | LR__0332
03148     3E 77 02 F6 | 	mov	result1, _var01
0314c                 | __system____builtin_memmove_ret
0314c     2D 00 64 FD | 	ret
03150                 | 
03150                 | __system____builtin_strcpy
03150     48 7D 02 F6 | 	mov	_var01, arg01
03154     D7 0A 48 FB | 	callpa	#(@LR__0341-@LR__0340)>>2,fcache_load_ptr_
03158                 | LR__0340
03158     49 77 CA FA | 	rdbyte	result1, arg02 wz
0315c     48 77 42 FC | 	wrbyte	result1, arg01
03160     01 92 06 F1 | 	add	arg02, #1
03164     01 90 06 F1 | 	add	arg01, #1
03168     EC FF 9F 5D |  if_ne	jmp	#LR__0340
0316c                 | LR__0341
0316c     3E 77 02 F6 | 	mov	result1, _var01
03170                 | __system____builtin_strcpy_ret
03170     2D 00 64 FD | 	ret
03174                 | 
03174                 | __system____topofstack
03174     00 CA 05 F6 | 	mov	COUNT_, #0
03178     E8 00 A0 FD | 	call	#pushregs_
0317c     08 F0 07 F1 | 	add	ptra, #8
03180     04 CE 05 F1 | 	add	fp, #4
03184     E7 90 62 FC | 	wrlong	arg01, fp
03188     E7 76 02 F6 | 	mov	result1, fp
0318c     04 CE 85 F1 | 	sub	fp, #4
03190     E7 F0 03 F6 | 	mov	ptra, fp
03194     F2 00 A0 FD | 	call	#popregs_
03198                 | __system____topofstack_ret
03198     2D 00 64 FD | 	ret
0319c                 | 
0319c                 | __system___lockmem
0319c     00 76 06 F6 | 	mov	result1, #0
031a0     01 76 62 FD | 	cogid	result1
031a4     00 77 06 F1 | 	add	result1, #256
031a8                 | LR__0350
031a8     48 7D 0A FB | 	rdlong	_var01, arg01 wz
031ac     48 77 62 AC |  if_e	wrlong	result1, arg01
031b0     48 7D 02 AB |  if_e	rdlong	_var01, arg01
031b4     48 7D 02 AB |  if_e	rdlong	_var01, arg01
031b8     3B 7D 0A F2 | 	cmp	_var01, result1 wz
031bc     E8 FF 9F 5D |  if_ne	jmp	#LR__0350
031c0                 | __system___lockmem_ret
031c0     2D 00 64 FD | 	ret
031c4                 | 
031c4                 | __system___tx
031c4     02 CA 05 F6 | 	mov	COUNT_, #2
031c8     E8 00 A0 FD | 	call	#pushregs_
031cc     48 A7 02 F6 | 	mov	local01, arg01
031d0     0A A6 0E F2 | 	cmp	local01, #10 wz
031d4     18 00 90 5D |  if_ne	jmp	#LR__0360
031d8     08 66 06 F1 | 	add	ptr___system__dat__, #8
031dc     33 A9 02 FB | 	rdlong	local02, ptr___system__dat__
031e0     08 66 86 F1 | 	sub	ptr___system__dat__, #8
031e4     02 A8 CE F7 | 	test	local02, #2 wz
031e8     0D 90 06 56 |  if_ne	mov	arg01, #13
031ec     3C FD BF 5D |  if_ne	call	#__system___txraw
031f0                 | LR__0360
031f0     53 91 02 F6 | 	mov	arg01, local01
031f4     34 FD BF FD | 	call	#__system___txraw
031f8     E7 F0 03 F6 | 	mov	ptra, fp
031fc     F2 00 A0 FD | 	call	#popregs_
03200                 | __system___tx_ret
03200     2D 00 64 FD | 	ret
03204                 | 
03204                 | __system___rx
03204     01 CA 05 F6 | 	mov	COUNT_, #1
03208     E8 00 A0 FD | 	call	#pushregs_
0320c                 | LR__0370
0320c     00 90 06 F6 | 	mov	arg01, #0
03210     5C FD BF FD | 	call	#__system___rxraw
03214     3B A7 02 F6 | 	mov	local01, result1
03218     FF FF 7F FF 
0321c     FF A7 0E F2 | 	cmp	local01, ##-1 wz
03220     E8 FF 9F AD |  if_e	jmp	#LR__0370
03224     0D A6 0E F2 | 	cmp	local01, #13 wz
03228     14 00 90 5D |  if_ne	jmp	#LR__0371
0322c     08 66 06 F1 | 	add	ptr___system__dat__, #8
03230     33 77 02 FB | 	rdlong	result1, ptr___system__dat__
03234     08 66 86 F1 | 	sub	ptr___system__dat__, #8
03238     02 76 CE F7 | 	test	result1, #2 wz
0323c     0A A6 06 56 |  if_ne	mov	local01, #10
03240                 | LR__0371
03240     08 66 06 F1 | 	add	ptr___system__dat__, #8
03244     33 91 02 FB | 	rdlong	arg01, ptr___system__dat__
03248     08 66 86 F1 | 	sub	ptr___system__dat__, #8
0324c     01 90 CE F7 | 	test	arg01, #1 wz
03250     1C 00 90 AD |  if_e	jmp	#LR__0374
03254     7F A6 0E F2 | 	cmp	local01, #127 wz
03258     0C 00 90 5D |  if_ne	jmp	#LR__0372
0325c     08 90 06 F6 | 	mov	arg01, #8
03260     60 FF BF FD | 	call	#__system___tx
03264     08 00 90 FD | 	jmp	#LR__0373
03268                 | LR__0372
03268     53 91 02 F6 | 	mov	arg01, local01
0326c     54 FF BF FD | 	call	#__system___tx
03270                 | LR__0373
03270                 | LR__0374
03270     53 77 02 F6 | 	mov	result1, local01
03274     E7 F0 03 F6 | 	mov	ptra, fp
03278     F2 00 A0 FD | 	call	#popregs_
0327c                 | __system___rx_ret
0327c     2D 00 64 FD | 	ret
03280                 | 
03280                 | __system___waitms
03280     48 7D 02 F6 | 	mov	_var01, arg01
03284     1A 7E 62 FD | 	getct	_var02
03288     14 80 06 FB | 	rdlong	_var03, #20
0328c     D7 14 48 FB | 	callpa	#(@LR__0381-@LR__0380)>>2,fcache_load_ptr_
03290                 | LR__0380
03290     01 00 00 FF 
03294     E8 7D 56 F2 | 	cmps	_var01, ##1000 wc
03298     1C 00 90 CD |  if_b	jmp	#LR__0382
0329c     40 7F 02 F1 | 	add	_var02, _var03
032a0     3F 91 02 F6 | 	mov	arg01, _var02
032a4     00 90 66 FA | 	addct1	arg01, #0
032a8     24 22 60 FD | 	waitct1
032ac     01 00 00 FF 
032b0     E8 7D 86 F1 | 	sub	_var01, ##1000
032b4     D8 FF 9F FD | 	jmp	#LR__0380
032b8                 | LR__0381
032b8                 | LR__0382
032b8     01 7C 56 F2 | 	cmps	_var01, #1 wc
032bc     28 00 90 CD |  if_b	jmp	#LR__0383
032c0     40 7D 02 FD | 	qmul	_var01, _var03
032c4     01 00 00 FF 
032c8     E8 95 06 F6 | 	mov	arg03, ##1000
032cc     19 76 62 FD | 	getqy	result1
032d0     18 90 62 FD | 	getqx	arg01
032d4     28 76 62 FD | 	setq	result1
032d8     4A 91 12 FD | 	qdiv	arg01, arg03
032dc     18 90 62 FD | 	getqx	arg01
032e0     3F 91 62 FA | 	addct1	arg01, _var02
032e4     24 22 60 FD | 	waitct1
032e8                 | LR__0383
032e8                 | __system___waitms_ret
032e8     2D 00 64 FD | 	ret
032ec                 | 
032ec                 | __system___waitus
032ec     48 7D 02 F6 | 	mov	_var01, arg01
032f0     1A 7E 62 FD | 	getct	_var02
032f4     14 80 06 FB | 	rdlong	_var03, #20
032f8     D7 14 48 FB | 	callpa	#(@LR__0391-@LR__0390)>>2,fcache_load_ptr_
032fc                 | LR__0390
032fc     A1 07 00 FF 
03300     40 7C 56 F2 | 	cmps	_var01, ##1000000 wc
03304     1C 00 90 CD |  if_b	jmp	#LR__0392
03308     40 7F 02 F1 | 	add	_var02, _var03
0330c     3F 91 02 F6 | 	mov	arg01, _var02
03310     00 90 66 FA | 	addct1	arg01, #0
03314     24 22 60 FD | 	waitct1
03318     A1 07 00 FF 
0331c     40 7C 86 F1 | 	sub	_var01, ##1000000
03320     D8 FF 9F FD | 	jmp	#LR__0390
03324                 | LR__0391
03324                 | LR__0392
03324     01 7C 56 F2 | 	cmps	_var01, #1 wc
03328     28 00 90 CD |  if_b	jmp	#LR__0393
0332c     40 7D 02 FD | 	qmul	_var01, _var03
03330     A1 07 00 FF 
03334     40 94 06 F6 | 	mov	arg03, ##1000000
03338     19 76 62 FD | 	getqy	result1
0333c     18 90 62 FD | 	getqx	arg01
03340     28 76 62 FD | 	setq	result1
03344     4A 91 12 FD | 	qdiv	arg01, arg03
03348     18 76 62 FD | 	getqx	result1
0334c     3B 7F 62 FA | 	addct1	_var02, result1
03350     24 22 60 FD | 	waitct1
03354                 | LR__0393
03354                 | __system___waitus_ret
03354     2D 00 64 FD | 	ret
03358                 | 
03358                 | __system___mount
03358     09 CA 05 F6 | 	mov	COUNT_, #9
0335c     E8 00 A0 FD | 	call	#pushregs_
03360     48 A7 02 F6 | 	mov	local01, arg01
03364     49 A9 0A F6 | 	mov	local02, arg02 wz
03368     01 AA 66 F6 | 	neg	local03, #1
0336c     01 76 66 A6 |  if_e	neg	result1, #1
03370     9C 02 90 AD |  if_e	jmp	#LR__0415
03374     53 77 C2 FA | 	rdbyte	result1, local01
03378     2F 76 0E F2 | 	cmp	result1, #47 wz
0337c     28 00 90 5D |  if_ne	jmp	#LR__0402
03380     53 91 02 F6 | 	mov	arg01, local01
03384     48 AD 02 F6 | 	mov	local04, arg01
03388     D7 06 48 FB | 	callpa	#(@LR__0401-@LR__0400)>>2,fcache_load_ptr_
0338c                 | LR__0400
0338c     56 77 CA FA | 	rdbyte	result1, local04 wz
03390     01 AC 06 51 |  if_ne	add	local04, #1
03394     F4 FF 9F 5D |  if_ne	jmp	#LR__0400
03398                 | LR__0401
03398     48 AD 82 F1 | 	sub	local04, arg01
0339c     56 77 02 F6 | 	mov	result1, local04
033a0     10 76 56 F2 | 	cmps	result1, #16 wc
033a4     14 00 90 CD |  if_b	jmp	#LR__0403
033a8                 | LR__0402
033a8     20 66 06 F1 | 	add	ptr___system__dat__, #32
033ac     33 15 68 FC | 	wrlong	#10, ptr___system__dat__
033b0     20 66 86 F1 | 	sub	ptr___system__dat__, #32
033b4     01 76 66 F6 | 	neg	result1, #1
033b8     54 02 90 FD | 	jmp	#LR__0415
033bc                 | LR__0403
033bc     00 AE 06 F6 | 	mov	local05, #0
033c0                 | LR__0404
033c0     04 AE 56 F2 | 	cmps	local05, #4 wc
033c4     B4 00 90 3D |  if_ae	jmp	#LR__0409
033c8     57 91 02 F6 | 	mov	arg01, local05
033cc     02 90 66 F0 | 	shl	arg01, #2
033d0     33 77 02 F6 | 	mov	result1, ptr___system__dat__
033d4     64 76 06 F1 | 	add	result1, #100
033d8     3B 91 02 F1 | 	add	arg01, result1
033dc     48 77 0A FB | 	rdlong	result1, arg01 wz
033e0     00 AA 56 A2 |  if_e	cmps	local03, #0 wc
033e4     57 AB 02 86 |  if_c_and_z	mov	local03, local05
033e8     88 00 90 8D |  if_c_and_z	jmp	#LR__0408
033ec     57 91 02 F6 | 	mov	arg01, local05
033f0     02 90 66 F0 | 	shl	arg01, #2
033f4     33 AD 02 F6 | 	mov	local04, ptr___system__dat__
033f8     64 AC 06 F1 | 	add	local04, #100
033fc     56 91 02 F1 | 	add	arg01, local04
03400     48 91 02 FB | 	rdlong	arg01, arg01
03404     48 AD 02 F6 | 	mov	local04, arg01
03408     D7 06 48 FB | 	callpa	#(@LR__0406-@LR__0405)>>2,fcache_load_ptr_
0340c                 | LR__0405
0340c     56 77 CA FA | 	rdbyte	result1, local04 wz
03410     01 AC 06 51 |  if_ne	add	local04, #1
03414     F4 FF 9F 5D |  if_ne	jmp	#LR__0405
03418                 | LR__0406
03418     48 AD 82 F1 | 	sub	local04, arg01
0341c     56 77 02 F6 | 	mov	result1, local04
03420     3B B1 02 F6 | 	mov	local06, result1
03424     58 91 02 F6 | 	mov	arg01, local06
03428     53 91 02 F1 | 	add	arg01, local01
0342c     48 AD C2 FA | 	rdbyte	local04, arg01
03430     2F AC 0E F2 | 	cmp	local04, #47 wz
03434     58 B3 02 56 |  if_ne	mov	local07, local06
03438     53 B3 02 51 |  if_ne	add	local07, local01
0343c     59 91 CA 5A |  if_ne	rdbyte	arg01, local07 wz
03440     30 00 90 5D |  if_ne	jmp	#LR__0407
03444     57 AD 02 F6 | 	mov	local04, local05
03448     02 AC 66 F0 | 	shl	local04, #2
0344c     33 95 02 F6 | 	mov	arg03, ptr___system__dat__
03450     64 94 06 F1 | 	add	arg03, #100
03454     4A AD 02 F1 | 	add	local04, arg03
03458     56 93 02 FB | 	rdlong	arg02, local04
0345c     53 91 02 F6 | 	mov	arg01, local01
03460     58 95 02 F6 | 	mov	arg03, local06
03464     F0 2A B0 FD | 	call	#__system__strncmp
03468     00 76 0E F2 | 	cmp	result1, #0 wz
0346c     57 AB 02 A6 |  if_e	mov	local03, local05
03470     08 00 90 AD |  if_e	jmp	#LR__0409
03474                 | LR__0407
03474                 | LR__0408
03474     01 AE 06 F1 | 	add	local05, #1
03478     44 FF 9F FD | 	jmp	#LR__0404
0347c                 | LR__0409
0347c     FF FF 7F FF 
03480     FF AB 0E F2 | 	cmp	local03, ##-1 wz
03484     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
03488     33 17 68 AC |  if_e	wrlong	#11, ptr___system__dat__
0348c     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
03490     01 76 66 A6 |  if_e	neg	result1, #1
03494     78 01 90 AD |  if_e	jmp	#LR__0415
03498     55 AF 02 F6 | 	mov	local05, local03
0349c     57 B3 02 F6 | 	mov	local07, local05
034a0     02 B2 66 F0 | 	shl	local07, #2
034a4     33 B1 02 F6 | 	mov	local06, ptr___system__dat__
034a8     74 B0 06 F1 | 	add	local06, #116
034ac     58 B3 02 F1 | 	add	local07, local06
034b0     59 B1 0A FB | 	rdlong	local06, local07 wz
034b4     58 00 90 AD |  if_e	jmp	#LR__0410
034b8     4C B0 06 F1 | 	add	local06, #76
034bc     58 B3 0A FB | 	rdlong	local07, local06 wz
034c0     4C B0 86 F1 | 	sub	local06, #76
034c4     48 00 90 AD |  if_e	jmp	#LR__0410
034c8     4C B0 06 F1 | 	add	local06, #76
034cc     58 B3 02 FB | 	rdlong	local07, local06
034d0     59 AD 02 F6 | 	mov	local04, local07
034d4     13 B2 46 F7 | 	zerox	local07, #19
034d8     14 AC 46 F0 | 	shr	local04, #20
034dc     02 AC 66 F0 | 	shl	local04, #2
034e0     2D AD 02 F1 | 	add	local04, __methods__
034e4     56 AD 02 FB | 	rdlong	local04, local04
034e8     57 B1 02 F6 | 	mov	local06, local05
034ec     02 B0 66 F0 | 	shl	local06, #2
034f0     33 AB 02 F6 | 	mov	local03, ptr___system__dat__
034f4     64 AA 06 F1 | 	add	local03, #100
034f8     55 B1 02 F1 | 	add	local06, local03
034fc     58 91 02 FB | 	rdlong	arg01, local06
03500     31 B1 02 F6 | 	mov	local06, objptr
03504     59 63 02 F6 | 	mov	objptr, local07
03508     2D AC 62 FD | 	call	local04
0350c     58 63 02 F6 | 	mov	objptr, local06
03510                 | LR__0410
03510     57 B1 02 F6 | 	mov	local06, local05
03514     02 B0 66 F0 | 	shl	local06, #2
03518     33 B3 02 F6 | 	mov	local07, ptr___system__dat__
0351c     74 B2 06 F1 | 	add	local07, #116
03520     59 B1 02 F1 | 	add	local06, local07
03524     58 A9 62 FC | 	wrlong	local02, local06
03528     00 A8 0E F2 | 	cmp	local02, #0 wz
0352c     18 00 90 5D |  if_ne	jmp	#LR__0411
03530     02 AE 66 F0 | 	shl	local05, #2
03534     33 B3 02 F6 | 	mov	local07, ptr___system__dat__
03538     64 B2 06 F1 | 	add	local07, #100
0353c     59 AF 02 F1 | 	add	local05, local07
03540     57 01 68 FC | 	wrlong	#0, local05
03544     C4 00 90 FD | 	jmp	#LR__0414
03548                 | LR__0411
03548     57 B5 02 F6 | 	mov	local08, local05
0354c     04 B4 66 F0 | 	shl	local08, #4
03550     33 B3 02 F6 | 	mov	local07, ptr___system__dat__
03554     24 B2 06 F1 | 	add	local07, #36
03558     59 B5 02 F1 | 	add	local08, local07
0355c     5A 91 02 F6 | 	mov	arg01, local08
03560     53 93 02 F6 | 	mov	arg02, local01
03564     10 94 06 F6 | 	mov	arg03, #16
03568     30 29 B0 FD | 	call	#__system__strncpy
0356c     48 A8 06 F1 | 	add	local02, #72
03570     54 B3 0A FB | 	rdlong	local07, local02 wz
03574     48 A8 86 F1 | 	sub	local02, #72
03578     7C 00 90 AD |  if_e	jmp	#LR__0413
0357c     48 A8 06 F1 | 	add	local02, #72
03580     54 B3 02 FB | 	rdlong	local07, local02
03584     59 B7 02 F6 | 	mov	local09, local07
03588     13 B2 46 F7 | 	zerox	local07, #19
0358c     14 B6 46 F0 | 	shr	local09, #20
03590     02 B6 66 F0 | 	shl	local09, #2
03594     2D B7 02 F1 | 	add	local09, __methods__
03598     5B B7 02 FB | 	rdlong	local09, local09
0359c     5A 91 02 F6 | 	mov	arg01, local08
035a0     31 B1 02 F6 | 	mov	local06, objptr
035a4     59 63 02 F6 | 	mov	objptr, local07
035a8     2D B6 62 FD | 	call	local09
035ac     58 63 02 F6 | 	mov	objptr, local06
035b0     3B 91 0A F6 | 	mov	arg01, result1 wz
035b4     40 00 90 AD |  if_e	jmp	#LR__0412
035b8     57 B5 02 F6 | 	mov	local08, local05
035bc     02 B4 66 F0 | 	shl	local08, #2
035c0     74 66 06 F1 | 	add	ptr___system__dat__, #116
035c4     33 B5 02 F1 | 	add	local08, ptr___system__dat__
035c8     5A 01 68 FC | 	wrlong	#0, local08
035cc     02 AE 66 F0 | 	shl	local05, #2
035d0     10 66 86 F1 | 	sub	ptr___system__dat__, #16
035d4     33 AF 02 F1 | 	add	local05, ptr___system__dat__
035d8     57 01 68 FC | 	wrlong	#0, local05
035dc     48 91 6A F6 | 	neg	arg01, arg01 wz
035e0     44 66 86 F1 | 	sub	ptr___system__dat__, #68
035e4     33 91 62 FC | 	wrlong	arg01, ptr___system__dat__
035e8     20 66 86 F1 | 	sub	ptr___system__dat__, #32
035ec     01 76 66 56 |  if_ne	neg	result1, #1
035f0     00 76 06 A6 |  if_e	mov	result1, #0
035f4     18 00 90 FD | 	jmp	#LR__0415
035f8                 | LR__0412
035f8                 | LR__0413
035f8     02 AE 66 F0 | 	shl	local05, #2
035fc     33 B3 02 F6 | 	mov	local07, ptr___system__dat__
03600     64 B2 06 F1 | 	add	local07, #100
03604     59 AF 02 F1 | 	add	local05, local07
03608     57 B5 62 FC | 	wrlong	local08, local05
0360c                 | LR__0414
0360c     00 76 06 F6 | 	mov	result1, #0
03610                 | LR__0415
03610     E7 F0 03 F6 | 	mov	ptra, fp
03614     F2 00 A0 FD | 	call	#popregs_
03618                 | __system___mount_ret
03618     2D 00 64 FD | 	ret
0361c                 | 
0361c                 | __system___chdir
0361c     02 CA 05 F6 | 	mov	COUNT_, #2
03620     E8 00 A0 FD | 	call	#pushregs_
03624     44 F0 07 F1 | 	add	ptra, #68
03628     48 A7 02 F6 | 	mov	local01, arg01
0362c     E7 92 02 F6 | 	mov	arg02, fp
03630     08 92 06 F1 | 	add	arg02, #8
03634     53 91 02 F6 | 	mov	arg01, local01
03638     78 27 B0 FD | 	call	#__system__stat
0363c     00 76 0E F2 | 	cmp	result1, #0 wz
03640     88 00 90 5D |  if_ne	jmp	#LR__0422
03644     10 CE 05 F1 | 	add	fp, #16
03648     E7 90 02 FB | 	rdlong	arg01, fp
0364c     10 CE 85 F1 | 	sub	fp, #16
03650     78 00 00 FF 
03654     00 90 06 F5 | 	and	arg01, ##61440
03658     08 00 00 FF 
0365c     00 90 0E F2 | 	cmp	arg01, ##4096 wz
03660     20 66 06 51 |  if_ne	add	ptr___system__dat__, #32
03664     33 1B 68 5C |  if_ne	wrlong	#13, ptr___system__dat__
03668     20 66 86 51 |  if_ne	sub	ptr___system__dat__, #32
0366c     01 76 66 56 |  if_ne	neg	result1, #1
03670     58 00 90 5D |  if_ne	jmp	#LR__0422
03674     53 95 C2 FA | 	rdbyte	arg03, local01
03678     2F 94 0E F2 | 	cmp	arg03, #47 wz
0367c     18 00 90 5D |  if_ne	jmp	#LR__0420
03680     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
03684     84 90 06 F1 | 	add	arg01, #132
03688     53 93 02 F6 | 	mov	arg02, local01
0368c     00 95 06 F6 | 	mov	arg03, #256
03690     08 28 B0 FD | 	call	#__system__strncpy
03694     30 00 90 FD | 	jmp	#LR__0421
03698                 | LR__0420
03698     33 A9 02 F6 | 	mov	local02, ptr___system__dat__
0369c     84 A9 06 F1 | 	add	local02, #388
036a0     33 93 02 F6 | 	mov	arg02, ptr___system__dat__
036a4     84 92 06 F1 | 	add	arg02, #132
036a8     54 91 02 F6 | 	mov	arg01, local02
036ac     00 95 06 F6 | 	mov	arg03, #256
036b0     E8 27 B0 FD | 	call	#__system__strncpy
036b4     33 95 02 F6 | 	mov	arg03, ptr___system__dat__
036b8     84 94 06 F1 | 	add	arg03, #132
036bc     54 91 02 F6 | 	mov	arg01, local02
036c0     53 93 02 F6 | 	mov	arg02, local01
036c4     10 00 B0 FD | 	call	#__system____getvfsforfile
036c8                 | LR__0421
036c8     00 76 06 F6 | 	mov	result1, #0
036cc                 | LR__0422
036cc     E7 F0 03 F6 | 	mov	ptra, fp
036d0     F2 00 A0 FD | 	call	#popregs_
036d4                 | __system___chdir_ret
036d4     2D 00 64 FD | 	ret
036d8                 | 
036d8                 | __system____getvfsforfile
036d8     0E CA 05 F6 | 	mov	COUNT_, #14
036dc     E8 00 A0 FD | 	call	#pushregs_
036e0     48 A7 02 F6 | 	mov	local01, arg01
036e4     49 A9 02 F6 | 	mov	local02, arg02
036e8     4A AB 02 F6 | 	mov	local03, arg03
036ec     D7 10 48 FB | 	callpa	#(@LR__0431-@LR__0430)>>2,fcache_load_ptr_
036f0                 | LR__0430
036f0     54 77 C2 FA | 	rdbyte	result1, local02
036f4     2F 76 0E F2 | 	cmp	result1, #47 wz
036f8     01 A8 06 A1 |  if_e	add	local02, #1
036fc     54 AD C2 AA |  if_e	rdbyte	local04, local02
03700     01 A8 86 A1 |  if_e	sub	local02, #1
03704     2F AC 0E A2 |  if_e	cmp	local04, #47 wz
03708     01 A8 06 A1 |  if_e	add	local02, #1
0370c     E0 FF 9F AD |  if_e	jmp	#LR__0430
03710                 | LR__0431
03710     54 AD C2 FA | 	rdbyte	local04, local02
03714     2F AC 0E F2 | 	cmp	local04, #47 wz
03718     14 00 90 5D |  if_ne	jmp	#LR__0432
0371c     53 91 02 F6 | 	mov	arg01, local01
03720     54 93 02 F6 | 	mov	arg02, local02
03724     00 95 06 F6 | 	mov	arg03, #256
03728     70 27 B0 FD | 	call	#__system__strncpy
0372c     78 00 90 FD | 	jmp	#LR__0434
03730                 | LR__0432
03730     33 93 02 F6 | 	mov	arg02, ptr___system__dat__
03734     84 92 06 F1 | 	add	arg02, #132
03738     53 91 02 F6 | 	mov	arg01, local01
0373c     00 95 06 F6 | 	mov	arg03, #256
03740     58 27 B0 FD | 	call	#__system__strncpy
03744     54 AD CA FA | 	rdbyte	local04, local02 wz
03748     5C 00 90 AD |  if_e	jmp	#LR__0433
0374c     54 AD C2 FA | 	rdbyte	local04, local02
03750     2E AC 0E F2 | 	cmp	local04, #46 wz
03754     01 A8 06 A1 |  if_e	add	local02, #1
03758     54 AF C2 AA |  if_e	rdbyte	local05, local02
0375c     01 A8 86 A1 |  if_e	sub	local02, #1
03760     57 B1 02 A6 |  if_e	mov	local06, local05
03764     07 B0 4E A7 |  if_e	zerox	local06, #7 wz
03768     3C 00 90 AD |  if_e	jmp	#LR__0433
0376c     53 AF C2 FA | 	rdbyte	local05, local01
03770     2F AE 0E F2 | 	cmp	local05, #47 wz
03774     01 A6 06 A1 |  if_e	add	local01, #1
03778     53 AD C2 AA |  if_e	rdbyte	local04, local01
0377c     01 A6 86 A1 |  if_e	sub	local01, #1
03780     00 AC 4E A2 |  if_e	cmps	local04, #0 wz
03784     71 00 00 5F 
03788     C4 92 06 56 |  if_ne	mov	arg02, ##@LR__2160
0378c     53 91 02 56 |  if_ne	mov	arg01, local01
03790     00 95 06 56 |  if_ne	mov	arg03, #256
03794     5C 27 B0 5D |  if_ne	call	#__system__strncat
03798     53 91 02 F6 | 	mov	arg01, local01
0379c     54 93 02 F6 | 	mov	arg02, local02
037a0     00 95 06 F6 | 	mov	arg03, #256
037a4     4C 27 B0 FD | 	call	#__system__strncat
037a8                 | LR__0433
037a8                 | LR__0434
037a8     53 91 02 F6 | 	mov	arg01, local01
037ac     08 29 B0 FD | 	call	#__system___normalizeName
037b0     53 AD CA FA | 	rdbyte	local04, local01 wz
037b4     1C 00 90 AD |  if_e	jmp	#LR__0435
037b8     53 AD C2 FA | 	rdbyte	local04, local01
037bc     2F AC 0E F2 | 	cmp	local04, #47 wz
037c0     01 A6 06 A1 |  if_e	add	local01, #1
037c4     53 B1 C2 AA |  if_e	rdbyte	local06, local01
037c8     01 A6 86 A1 |  if_e	sub	local01, #1
037cc     00 B0 4E A2 |  if_e	cmps	local06, #0 wz
037d0     10 00 90 5D |  if_ne	jmp	#LR__0436
037d4                 | LR__0435
037d4     33 77 02 F6 | 	mov	result1, ptr___system__dat__
037d8     01 00 00 FF 
037dc     84 76 06 F1 | 	add	result1, ##644
037e0     EC 01 90 FD | 	jmp	#LR__0450
037e4                 | LR__0436
037e4     00 B2 06 F6 | 	mov	local07, #0
037e8                 | LR__0437
037e8     04 B2 56 F2 | 	cmps	local07, #4 wc
037ec     CC 01 90 3D |  if_ae	jmp	#LR__0449
037f0     59 B1 02 F6 | 	mov	local06, local07
037f4     02 B0 66 F0 | 	shl	local06, #2
037f8     33 AD 02 F6 | 	mov	local04, ptr___system__dat__
037fc     64 AC 06 F1 | 	add	local04, #100
03800     56 B1 02 F1 | 	add	local06, local04
03804     58 B1 0A FB | 	rdlong	local06, local06 wz
03808     A8 01 90 AD |  if_e	jmp	#LR__0448
0380c     59 AD 02 F6 | 	mov	local04, local07
03810     02 AC 66 F0 | 	shl	local04, #2
03814     33 B1 02 F6 | 	mov	local06, ptr___system__dat__
03818     64 B0 06 F1 | 	add	local06, #100
0381c     58 AD 02 F1 | 	add	local04, local06
03820     56 91 02 FB | 	rdlong	arg01, local04
03824     48 B5 02 F6 | 	mov	local08, arg01
03828     D7 06 48 FB | 	callpa	#(@LR__0439-@LR__0438)>>2,fcache_load_ptr_
0382c                 | LR__0438
0382c     5A 77 CA FA | 	rdbyte	result1, local08 wz
03830     01 B4 06 51 |  if_ne	add	local08, #1
03834     F4 FF 9F 5D |  if_ne	jmp	#LR__0438
03838                 | LR__0439
03838     48 B5 82 F1 | 	sub	local08, arg01
0383c     5A B7 02 F6 | 	mov	local09, local08
03840     5B AD 02 F6 | 	mov	local04, local09
03844     53 AD 02 F1 | 	add	local04, local01
03848     56 B1 C2 FA | 	rdbyte	local06, local04
0384c     2F B0 0E F2 | 	cmp	local06, #47 wz
03850     5B B9 02 56 |  if_ne	mov	local10, local09
03854     53 B9 02 51 |  if_ne	add	local10, local01
03858     5C AF CA 5A |  if_ne	rdbyte	local05, local10 wz
0385c     54 01 90 5D |  if_ne	jmp	#LR__0447
03860     59 AD 02 F6 | 	mov	local04, local07
03864     02 AC 66 F0 | 	shl	local04, #2
03868     33 95 02 F6 | 	mov	arg03, ptr___system__dat__
0386c     64 94 06 F1 | 	add	arg03, #100
03870     4A AD 02 F1 | 	add	local04, arg03
03874     56 93 02 FB | 	rdlong	arg02, local04
03878     5B 95 02 F6 | 	mov	arg03, local09
0387c     53 91 02 F6 | 	mov	arg01, local01
03880     D4 26 B0 FD | 	call	#__system__strncmp
03884     00 76 4E F2 | 	cmps	result1, #0 wz
03888     28 01 90 5D |  if_ne	jmp	#LR__0447
0388c     59 BB 02 F6 | 	mov	local11, local07
03890     02 BA 66 F0 | 	shl	local11, #2
03894     33 AD 02 F6 | 	mov	local04, ptr___system__dat__
03898     74 AC 06 F1 | 	add	local04, #116
0389c     56 BB 02 F1 | 	add	local11, local04
038a0     5D BD 02 FB | 	rdlong	local12, local11
038a4     D7 22 48 FB | 	callpa	#(@LR__0441-@LR__0440)>>2,fcache_load_ptr_
038a8                 | LR__0440
038a8     5B B1 02 F6 | 	mov	local06, local09
038ac     01 B0 06 F1 | 	add	local06, #1
038b0     53 B1 02 F1 | 	add	local06, local01
038b4     58 BB C2 FA | 	rdbyte	local11, local06
038b8     2E BA 0E F2 | 	cmp	local11, #46 wz
038bc     2C 00 90 5D |  if_ne	jmp	#LR__0442
038c0     5B BB 02 F6 | 	mov	local11, local09
038c4     02 BA 06 F1 | 	add	local11, #2
038c8     53 BB 02 F1 | 	add	local11, local01
038cc     5D B9 C2 FA | 	rdbyte	local10, local11
038d0     2F B8 0E F2 | 	cmp	local10, #47 wz
038d4     5B BF 02 56 |  if_ne	mov	local13, local09
038d8     02 BE 06 51 |  if_ne	add	local13, #2
038dc     53 BF 02 51 |  if_ne	add	local13, local01
038e0     5F C1 CA 5A |  if_ne	rdbyte	local14, local13 wz
038e4     01 B6 06 A1 |  if_e	add	local09, #1
038e8     BC FF 9F AD |  if_e	jmp	#LR__0440
038ec                 | LR__0441
038ec                 | LR__0442
038ec     00 AA 0E F2 | 	cmp	local03, #0 wz
038f0     55 91 02 56 |  if_ne	mov	arg01, local03
038f4     53 93 02 56 |  if_ne	mov	arg02, local01
038f8     00 95 06 56 |  if_ne	mov	arg03, #256
038fc     9C 25 B0 5D |  if_ne	call	#__system__strncpy
03900     53 93 02 F6 | 	mov	arg02, local01
03904     5B 93 02 F1 | 	add	arg02, local09
03908     01 92 06 F1 | 	add	arg02, #1
0390c     53 91 02 F6 | 	mov	arg01, local01
03910     3C F8 BF FD | 	call	#__system____builtin_strcpy
03914     53 91 02 F6 | 	mov	arg01, local01
03918     48 B5 02 F6 | 	mov	local08, arg01
0391c     D7 06 48 FB | 	callpa	#(@LR__0444-@LR__0443)>>2,fcache_load_ptr_
03920                 | LR__0443
03920     5A 77 CA FA | 	rdbyte	result1, local08 wz
03924     01 B4 06 51 |  if_ne	add	local08, #1
03928     F4 FF 9F 5D |  if_ne	jmp	#LR__0443
0392c                 | LR__0444
0392c     48 B5 82 F1 | 	sub	local08, arg01
03930     5A B7 02 F6 | 	mov	local09, local08
03934                 | LR__0445
03934     01 B6 56 F2 | 	cmps	local09, #1 wc
03938     70 00 90 CD |  if_b	jmp	#LR__0446
0393c     5B AD 02 F6 | 	mov	local04, local09
03940     53 AD 02 F1 | 	add	local04, local01
03944     56 BB C2 FA | 	rdbyte	local11, local04
03948     2F BA 0E F2 | 	cmp	local11, #47 wz
0394c     5B BB 02 A6 |  if_e	mov	local11, local09
03950     53 BB 02 A1 |  if_e	add	local11, local01
03954     5D 01 48 AC |  if_e	wrbyte	#0, local11
03958     01 B6 86 A1 |  if_e	sub	local09, #1
0395c     D4 FF 9F AD |  if_e	jmp	#LR__0445
03960     5B AD 02 F6 | 	mov	local04, local09
03964     53 AD 02 F1 | 	add	local04, local01
03968     56 BB C2 FA | 	rdbyte	local11, local04
0396c     2E BA 0E F2 | 	cmp	local11, #46 wz
03970     38 00 90 5D |  if_ne	jmp	#LR__0446
03974     02 B6 56 F2 | 	cmps	local09, #2 wc
03978     30 00 90 CD |  if_b	jmp	#LR__0446
0397c     5B C1 02 F6 | 	mov	local14, local09
03980     01 C0 86 F1 | 	sub	local14, #1
03984     53 C1 02 F1 | 	add	local14, local01
03988     60 AF C2 FA | 	rdbyte	local05, local14
0398c     2F AE 0E F2 | 	cmp	local05, #47 wz
03990     18 00 90 5D |  if_ne	jmp	#LR__0446
03994     5B AD 02 F6 | 	mov	local04, local09
03998     01 AC 86 F1 | 	sub	local04, #1
0399c     53 AD 02 F1 | 	add	local04, local01
039a0     56 01 48 FC | 	wrbyte	#0, local04
039a4     02 B6 86 F1 | 	sub	local09, #2
039a8     88 FF 9F FD | 	jmp	#LR__0445
039ac                 | LR__0446
039ac     5E 77 02 F6 | 	mov	result1, local12
039b0     1C 00 90 FD | 	jmp	#LR__0450
039b4                 | LR__0447
039b4                 | LR__0448
039b4     01 B2 06 F1 | 	add	local07, #1
039b8     2C FE 9F FD | 	jmp	#LR__0437
039bc                 | LR__0449
039bc     02 00 00 FF 
039c0     E8 66 06 F1 | 	add	ptr___system__dat__, ##1256
039c4     33 77 02 FB | 	rdlong	result1, ptr___system__dat__
039c8     02 00 00 FF 
039cc     E8 66 86 F1 | 	sub	ptr___system__dat__, ##1256
039d0                 | LR__0450
039d0     E7 F0 03 F6 | 	mov	ptra, fp
039d4     F2 00 A0 FD | 	call	#popregs_
039d8                 | __system____getvfsforfile_ret
039d8     2D 00 64 FD | 	ret
039dc                 | 
039dc                 | __system___basic_open
039dc     05 CA 05 F6 | 	mov	COUNT_, #5
039e0     E8 00 A0 FD | 	call	#pushregs_
039e4     49 A7 02 F6 | 	mov	local01, arg02
039e8     4A A9 02 F6 | 	mov	local02, arg03
039ec     4B AB 02 F6 | 	mov	local03, arg04
039f0     00 AC 06 F6 | 	mov	local04, #0
039f4     80 24 B0 FD | 	call	#__system____getftab
039f8     3B AF 0A F6 | 	mov	local05, result1 wz
039fc     18 00 90 5D |  if_ne	jmp	#LR__0460
03a00     2E 91 02 F6 | 	mov	arg01, abortchain
03a04     0C 92 06 F6 | 	mov	arg02, #12
03a08     01 94 06 F6 | 	mov	arg03, #1
03a0c     1A 01 A0 FD | 	call	#__longjmp
03a10     01 76 66 F6 | 	neg	result1, #1
03a14     0C 01 90 FD | 	jmp	#LR__0469
03a18                 | LR__0460
03a18     08 AE 06 F1 | 	add	local05, #8
03a1c     57 77 0A FB | 	rdlong	result1, local05 wz
03a20     08 AE 86 F1 | 	sub	local05, #8
03a24     57 91 02 56 |  if_ne	mov	arg01, local05
03a28     D0 1E B0 5D |  if_ne	call	#__system___closeraw
03a2c     00 A6 0E F2 | 	cmp	local01, #0 wz
03a30     00 A8 0E A2 |  if_e	cmp	local02, #0 wz
03a34     00 AA 0E A2 |  if_e	cmp	local03, #0 wz
03a38     3C 00 90 AD |  if_e	jmp	#LR__0462
03a3c     0C 90 06 F6 | 	mov	arg01, #12
03a40     78 18 B0 FD | 	call	#__system___gc_alloc_managed
03a44     3B AD 0A F6 | 	mov	local04, result1 wz
03a48     18 00 90 5D |  if_ne	jmp	#LR__0461
03a4c     2E 91 02 F6 | 	mov	arg01, abortchain
03a50     07 92 06 F6 | 	mov	arg02, #7
03a54     01 94 06 F6 | 	mov	arg03, #1
03a58     1A 01 A0 FD | 	call	#__longjmp
03a5c     01 76 66 F6 | 	neg	result1, #1
03a60     C0 00 90 FD | 	jmp	#LR__0469
03a64                 | LR__0461
03a64     56 01 68 FC | 	wrlong	#0, local04
03a68     04 AC 06 F1 | 	add	local04, #4
03a6c     56 01 68 FC | 	wrlong	#0, local04
03a70     04 AC 86 F1 | 	sub	local04, #4
03a74     57 AD 62 FC | 	wrlong	local04, local05
03a78                 | LR__0462
03a78     00 A6 0E F2 | 	cmp	local01, #0 wz
03a7c     1C 00 90 AD |  if_e	jmp	#LR__0463
03a80     56 A7 62 FC | 	wrlong	local01, local04
03a84     56 77 02 F6 | 	mov	result1, local04
03a88     15 76 26 F4 | 	bith	result1, #21
03a8c     1C AE 06 F1 | 	add	local05, #28
03a90     57 77 62 FC | 	wrlong	result1, local05
03a94     1C AE 86 F1 | 	sub	local05, #28
03a98     0C 00 90 FD | 	jmp	#LR__0464
03a9c                 | LR__0463
03a9c     1C AE 06 F1 | 	add	local05, #28
03aa0     57 01 68 FC | 	wrlong	#0, local05
03aa4     1C AE 86 F1 | 	sub	local05, #28
03aa8                 | LR__0464
03aa8     00 A8 0E F2 | 	cmp	local02, #0 wz
03aac     24 00 90 AD |  if_e	jmp	#LR__0465
03ab0     04 AC 06 F1 | 	add	local04, #4
03ab4     56 A9 62 FC | 	wrlong	local02, local04
03ab8     04 AC 86 F1 | 	sub	local04, #4
03abc     56 77 02 F6 | 	mov	result1, local04
03ac0     34 76 26 F4 | 	bith	result1, #52
03ac4     20 AE 06 F1 | 	add	local05, #32
03ac8     57 77 62 FC | 	wrlong	result1, local05
03acc     20 AE 86 F1 | 	sub	local05, #32
03ad0     0C 00 90 FD | 	jmp	#LR__0466
03ad4                 | LR__0465
03ad4     20 AE 06 F1 | 	add	local05, #32
03ad8     57 01 68 FC | 	wrlong	#0, local05
03adc     20 AE 86 F1 | 	sub	local05, #32
03ae0                 | LR__0466
03ae0     00 AA 0E F2 | 	cmp	local03, #0 wz
03ae4     20 00 90 AD |  if_e	jmp	#LR__0467
03ae8     08 AC 06 F1 | 	add	local04, #8
03aec     56 AB 62 FC | 	wrlong	local03, local04
03af0     08 AC 86 F1 | 	sub	local04, #8
03af4     16 AC 26 F4 | 	bith	local04, #22
03af8     24 AE 06 F1 | 	add	local05, #36
03afc     57 AD 62 FC | 	wrlong	local04, local05
03b00     24 AE 86 F1 | 	sub	local05, #36
03b04     0C 00 90 FD | 	jmp	#LR__0468
03b08                 | LR__0467
03b08     24 AE 06 F1 | 	add	local05, #36
03b0c     57 01 68 FC | 	wrlong	#0, local05
03b10     24 AE 86 F1 | 	sub	local05, #36
03b14                 | LR__0468
03b14     08 AE 06 F1 | 	add	local05, #8
03b18     40 00 80 FF 
03b1c     57 07 68 FC | 	wrlong	##32771, local05
03b20     00 76 06 F6 | 	mov	result1, #0
03b24                 | LR__0469
03b24     E7 F0 03 F6 | 	mov	ptra, fp
03b28     F2 00 A0 FD | 	call	#popregs_
03b2c                 | __system___basic_open_ret
03b2c     2D 00 64 FD | 	ret
03b30                 | 
03b30                 | __system___find_free_file
03b30     33 7D 02 F6 | 	mov	_var01, ptr___system__dat__
03b34     01 00 00 FF 
03b38     E0 7C 06 F1 | 	add	_var01, ##736
03b3c     00 7E 06 F6 | 	mov	_var02, #0
03b40     D7 12 48 FB | 	callpa	#(@LR__0471-@LR__0470)>>2,fcache_load_ptr_
03b44                 | LR__0470
03b44     0A 7E 56 F2 | 	cmps	_var02, #10 wc
03b48     1C 00 90 3D |  if_ae	jmp	#LR__0472
03b4c     34 7E 06 FD | 	qmul	_var02, #52
03b50     18 76 62 FD | 	getqx	result1
03b54     3E 77 02 F1 | 	add	result1, _var01
03b58     08 76 06 F1 | 	add	result1, #8
03b5c     3B 77 0A FB | 	rdlong	result1, result1 wz
03b60     01 7E 06 51 |  if_ne	add	_var02, #1
03b64     DC FF 9F 5D |  if_ne	jmp	#LR__0470
03b68                 | LR__0471
03b68                 | LR__0472
03b68     0A 7E 0E F2 | 	cmp	_var02, #10 wz
03b6c     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
03b70     33 17 68 AC |  if_e	wrlong	#11, ptr___system__dat__
03b74     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
03b78     01 76 66 A6 |  if_e	neg	result1, #1
03b7c     3F 77 02 56 |  if_ne	mov	result1, _var02
03b80                 | __system___find_free_file_ret
03b80     2D 00 64 FD | 	ret
03b84                 | 
03b84                 | __system___basic_print_char
03b84     03 CA 05 F6 | 	mov	COUNT_, #3
03b88     E8 00 A0 FD | 	call	#pushregs_
03b8c     49 A7 02 F6 | 	mov	local01, arg02
03b90     90 2A B0 FD | 	call	#__system___gettxfunc
03b94     3B A9 0A F6 | 	mov	local02, result1 wz
03b98     00 76 06 A6 |  if_e	mov	result1, #0
03b9c     30 00 90 AD |  if_e	jmp	#LR__0480
03ba0     54 AB 02 F6 | 	mov	local03, local02
03ba4     13 A8 46 F7 | 	zerox	local02, #19
03ba8     14 AA 46 F0 | 	shr	local03, #20
03bac     02 AA 66 F0 | 	shl	local03, #2
03bb0     2D AB 02 F1 | 	add	local03, __methods__
03bb4     55 AB 02 FB | 	rdlong	local03, local03
03bb8     53 91 02 F6 | 	mov	arg01, local01
03bbc     31 A7 02 F6 | 	mov	local01, objptr
03bc0     54 63 02 F6 | 	mov	objptr, local02
03bc4     2D AA 62 FD | 	call	local03
03bc8     53 63 02 F6 | 	mov	objptr, local01
03bcc     01 76 06 F6 | 	mov	result1, #1
03bd0                 | LR__0480
03bd0     E7 F0 03 F6 | 	mov	ptra, fp
03bd4     F2 00 A0 FD | 	call	#popregs_
03bd8                 | __system___basic_print_char_ret
03bd8     2D 00 64 FD | 	ret
03bdc                 | 
03bdc                 | __system___basic_print_string
03bdc     03 CA 05 F6 | 	mov	COUNT_, #3
03be0     E8 00 A0 FD | 	call	#pushregs_
03be4     49 A7 02 F6 | 	mov	local01, arg02
03be8     4A A9 02 F6 | 	mov	local02, arg03
03bec     34 2A B0 FD | 	call	#__system___gettxfunc
03bf0     3B AB 0A F6 | 	mov	local03, result1 wz
03bf4     00 76 06 A6 |  if_e	mov	result1, #0
03bf8     18 00 90 AD |  if_e	jmp	#LR__0490
03bfc     00 A6 0E F2 | 	cmp	local01, #0 wz
03c00     00 76 06 A6 |  if_e	mov	result1, #0
03c04     55 91 02 56 |  if_ne	mov	arg01, local03
03c08     54 93 02 56 |  if_ne	mov	arg02, local02
03c0c     53 95 02 56 |  if_ne	mov	arg03, local01
03c10     0C 00 B0 5D |  if_ne	call	#__system___fmtstr
03c14                 | LR__0490
03c14     E7 F0 03 F6 | 	mov	ptra, fp
03c18     F2 00 A0 FD | 	call	#popregs_
03c1c                 | __system___basic_print_string_ret
03c1c     2D 00 64 FD | 	ret
03c20                 | 
03c20                 | __system___fmtstr
03c20     09 CA 05 F6 | 	mov	COUNT_, #9
03c24     E8 00 A0 FD | 	call	#pushregs_
03c28     48 A7 02 F6 | 	mov	local01, arg01
03c2c     49 A9 02 F6 | 	mov	local02, arg02
03c30     4A AB 02 F6 | 	mov	local03, arg03
03c34     54 97 E2 F8 | 	getbyte	arg04, local02, #0
03c38     55 91 02 F6 | 	mov	arg01, local03
03c3c     48 AD 02 F6 | 	mov	local04, arg01
03c40     D7 06 48 FB | 	callpa	#(@LR__0501-@LR__0500)>>2,fcache_load_ptr_
03c44                 | LR__0500
03c44     56 77 CA FA | 	rdbyte	result1, local04 wz
03c48     01 AC 06 51 |  if_ne	add	local04, #1
03c4c     F4 FF 9F 5D |  if_ne	jmp	#LR__0500
03c50                 | LR__0501
03c50     48 AD 82 F1 | 	sub	local04, arg01
03c54     00 96 0E F2 | 	cmp	arg04, #0 wz
03c58     4B AD 7A 53 |  if_ne	fles	local04, arg04 wcz
03c5c     54 93 02 F6 | 	mov	arg02, local02
03c60     56 95 02 F6 | 	mov	arg03, local04
03c64     53 91 02 F6 | 	mov	arg01, local01
03c68     02 96 06 F6 | 	mov	arg04, #2
03c6c     0C 26 B0 FD | 	call	#__system___fmtpad
03c70     3B AF 02 F6 | 	mov	local05, result1
03c74     00 AE 56 F2 | 	cmps	local05, #0 wc
03c78     57 77 02 C6 |  if_b	mov	result1, local05
03c7c     80 00 90 CD |  if_b	jmp	#LR__0504
03c80     01 AC 56 F2 | 	cmps	local04, #1 wc
03c84     50 00 90 CD |  if_b	jmp	#LR__0503
03c88     56 B1 02 F6 | 	mov	local06, local04
03c8c                 | LR__0502
03c8c     53 B3 02 F6 | 	mov	local07, local01
03c90     53 B5 02 F6 | 	mov	local08, local01
03c94     13 B2 46 F7 | 	zerox	local07, #19
03c98     14 B4 46 F0 | 	shr	local08, #20
03c9c     02 B4 66 F0 | 	shl	local08, #2
03ca0     2D B5 02 F1 | 	add	local08, __methods__
03ca4     5A B5 02 FB | 	rdlong	local08, local08
03ca8     55 91 C2 FA | 	rdbyte	arg01, local03
03cac     31 B7 02 F6 | 	mov	local09, objptr
03cb0     59 63 02 F6 | 	mov	objptr, local07
03cb4     01 AA 06 F1 | 	add	local03, #1
03cb8     2D B4 62 FD | 	call	local08
03cbc     5B 63 02 F6 | 	mov	objptr, local09
03cc0     3B B7 02 F6 | 	mov	local09, result1
03cc4     00 B6 56 F2 | 	cmps	local09, #0 wc
03cc8     5B 77 02 C6 |  if_b	mov	result1, local09
03ccc     30 00 90 CD |  if_b	jmp	#LR__0504
03cd0     5B AF 02 F1 | 	add	local05, local09
03cd4     ED B1 6E FB | 	djnz	local06, #LR__0502
03cd8                 | LR__0503
03cd8     54 93 02 F6 | 	mov	arg02, local02
03cdc     56 95 02 F6 | 	mov	arg03, local04
03ce0     53 91 02 F6 | 	mov	arg01, local01
03ce4     01 96 06 F6 | 	mov	arg04, #1
03ce8     90 25 B0 FD | 	call	#__system___fmtpad
03cec     3B B7 02 F6 | 	mov	local09, result1
03cf0     00 B6 56 F2 | 	cmps	local09, #0 wc
03cf4     5B 77 02 C6 |  if_b	mov	result1, local09
03cf8     5B AF 02 31 |  if_ae	add	local05, local09
03cfc     57 77 02 36 |  if_ae	mov	result1, local05
03d00                 | LR__0504
03d00     E7 F0 03 F6 | 	mov	ptra, fp
03d04     F2 00 A0 FD | 	call	#popregs_
03d08                 | __system___fmtstr_ret
03d08     2D 00 64 FD | 	ret
03d0c                 | 
03d0c                 | __system___fmtfloat
03d0c     29 CA 05 F6 | 	mov	COUNT_, #41
03d10     E8 00 A0 FD | 	call	#pushregs_
03d14     24 F1 07 F1 | 	add	ptra, #292
03d18     48 A7 02 F6 | 	mov	local01, arg01
03d1c     49 A9 02 F6 | 	mov	local02, arg02
03d20     4A AB 02 F6 | 	mov	local03, arg03
03d24     4B AD 02 F6 | 	mov	local04, arg04
03d28     0A AE 06 F6 | 	mov	local05, #10
03d2c     00 B0 06 F6 | 	mov	local06, #0
03d30     00 B2 06 F6 | 	mov	local07, #0
03d34     02 B4 06 F6 | 	mov	local08, #2
03d38     00 B6 06 F6 | 	mov	local09, #0
03d3c     00 B8 06 F6 | 	mov	local10, #0
03d40     00 BA 06 F6 | 	mov	local11, #0
03d44     E7 BC 02 F6 | 	mov	local12, fp
03d48     C8 BC 06 F1 | 	add	local12, #200
03d4c     5E BF 02 F6 | 	mov	local13, local12
03d50     54 C1 02 F6 | 	mov	local14, local02
03d54     10 C0 46 F0 | 	shr	local14, #16
03d58     3F C0 0E F5 | 	and	local14, #63 wz
03d5c     54 C3 02 F6 | 	mov	local15, local02
03d60     1C C2 46 F0 | 	shr	local15, #28
03d64     01 C2 06 F5 | 	and	local15, #1
03d68     18 00 90 5D |  if_ne	jmp	#LR__0510
03d6c     61 AC 0E F2 | 	cmp	local04, #97 wz
03d70     0D C0 06 A6 |  if_e	mov	local14, #13
03d74     01 B2 06 A6 |  if_e	mov	local07, #1
03d78     0C 00 90 AD |  if_e	jmp	#LR__0511
03d7c     06 C0 06 F6 | 	mov	local14, #6
03d80     04 00 90 FD | 	jmp	#LR__0511
03d84                 | LR__0510
03d84     01 C0 86 F1 | 	sub	local14, #1
03d88                 | LR__0511
03d88     54 C5 02 F6 | 	mov	local16, local02
03d8c     16 C4 46 F0 | 	shr	local16, #22
03d90     03 C4 06 F5 | 	and	local16, #3
03d94     54 C7 02 F6 | 	mov	local17, local02
03d98     1D C6 46 F0 | 	shr	local17, #29
03d9c     01 C6 06 F5 | 	and	local17, #1
03da0     54 C9 EA F8 | 	getbyte	local18, local02, #1
03da4     54 CB E2 F8 | 	getbyte	local19, local02, #0
03da8     65 AC 0E F2 | 	cmp	local04, #101 wz
03dac     6E CC 62 FD | 	wrz	local20
03db0     66 CF 02 F6 | 	mov	local21, local20
03db4     00 C6 0E F2 | 	cmp	local17, #0 wz
03db8     45 CC 06 56 |  if_ne	mov	local20, #69
03dbc     65 CC 06 A6 |  if_e	mov	local20, #101
03dc0     66 D1 02 F6 | 	mov	local22, local20
03dc4     61 AC 0E F2 | 	cmp	local04, #97 wz
03dc8     2C 00 90 5D |  if_ne	jmp	#LR__0512
03dcc     01 CE 06 F6 | 	mov	local21, #1
03dd0     00 C6 0E F2 | 	cmp	local17, #0 wz
03dd4     50 CC 06 56 |  if_ne	mov	local20, #80
03dd8     70 CC 06 A6 |  if_e	mov	local20, #112
03ddc     66 D1 02 F6 | 	mov	local22, local20
03de0     02 AE 06 F6 | 	mov	local05, #2
03de4     01 B4 06 F6 | 	mov	local08, #1
03de8     00 C6 0E F2 | 	cmp	local17, #0 wz
03dec     58 CC 06 56 |  if_ne	mov	local20, #88
03df0     78 CC 06 A6 |  if_e	mov	local20, #120
03df4     66 B7 02 F6 | 	mov	local09, local20
03df8                 | LR__0512
03df8     23 AC 0E F2 | 	cmp	local04, #35 wz
03dfc     14 00 90 5D |  if_ne	jmp	#LR__0513
03e00     01 B8 06 F6 | 	mov	local10, #1
03e04     00 C2 0E F2 | 	cmp	local15, #0 wz
03e08     66 AC 06 56 |  if_ne	mov	local04, #102
03e0c     00 C2 06 56 |  if_ne	mov	local15, #0
03e10     01 C2 06 A6 |  if_e	mov	local15, #1
03e14                 | LR__0513
03e14     54 D3 02 F6 | 	mov	local23, local02
03e18     1A D2 46 F0 | 	shr	local23, #26
03e1c     03 D2 06 F5 | 	and	local23, #3
03e20     55 77 02 F6 | 	mov	result1, local03
03e24     1F 76 4E F0 | 	shr	result1, #31 wz
03e28     2D B0 06 56 |  if_ne	mov	local06, #45
03e2c     1F AA E6 54 |  if_ne	bitnot	local03, #31
03e30     14 00 90 5D |  if_ne	jmp	#LR__0515
03e34     01 D2 0E F2 | 	cmp	local23, #1 wz
03e38     2B B0 06 A6 |  if_e	mov	local06, #43
03e3c     08 00 90 AD |  if_e	jmp	#LR__0514
03e40     02 D2 0E F2 | 	cmp	local23, #2 wz
03e44     20 B0 06 A6 |  if_e	mov	local06, #32
03e48                 | LR__0514
03e48                 | LR__0515
03e48     54 D5 02 F6 | 	mov	local24, local02
03e4c     18 D4 46 F0 | 	shr	local24, #24
03e50     03 D4 06 F5 | 	and	local24, #3
03e54     00 CC 06 F6 | 	mov	local20, #0
03e58     00 B0 0E F2 | 	cmp	local06, #0 wz
03e5c     0A AE 0E A2 |  if_e	cmp	local05, #10 wz
03e60     01 CC 06 56 |  if_ne	mov	local20, #1
03e64     66 D7 0A F6 | 	mov	local25, local20 wz
03e68     60 00 90 AD |  if_e	jmp	#LR__0517
03e6c     02 D4 0E F2 | 	cmp	local24, #2 wz
03e70     58 00 90 5D |  if_ne	jmp	#LR__0517
03e74     02 C4 0E F2 | 	cmp	local16, #2 wz
03e78     50 00 90 AD |  if_e	jmp	#LR__0517
03e7c     58 93 02 F6 | 	mov	arg02, local06
03e80     5B D9 02 F6 | 	mov	local26, local09
03e84     5E 91 02 F6 | 	mov	arg01, local12
03e88     6C 95 02 F6 | 	mov	arg03, local26
03e8c     1C 27 B0 FD | 	call	#__system__emitsign_0095
03e90     3B DB 02 F6 | 	mov	local27, result1
03e94     00 DA 56 F2 | 	cmps	local27, #0 wc
03e98     6D 77 02 C6 |  if_b	mov	result1, local27
03e9c     C0 05 90 CD |  if_b	jmp	#LR__0560
03ea0     6D DD 02 F6 | 	mov	local28, local27
03ea4     6D BD 02 F1 | 	add	local12, local27
03ea8     00 C8 0E F2 | 	cmp	local18, #0 wz
03eac     18 00 90 AD |  if_e	jmp	#LR__0516
03eb0     6D C9 82 F1 | 	sub	local18, local27
03eb4     00 C8 56 F3 | 	fges	local18, #0 wc
03eb8     E8 A8 06 F4 | 	bitl	local02, #232
03ebc     64 DD 02 F6 | 	mov	local28, local18
03ec0     08 DC 66 F0 | 	shl	local28, #8
03ec4     6E A9 42 F5 | 	or	local02, local28
03ec8                 | LR__0516
03ec8     00 D6 06 F6 | 	mov	local25, #0
03ecc                 | LR__0517
03ecc     55 91 02 F6 | 	mov	arg01, local03
03ed0     8C 10 B0 FD | 	call	#__system____builtin_ilogb
03ed4     FF FF 3F FF 
03ed8     FF 77 0E F2 | 	cmp	result1, ##2147483647 wz
03edc     24 00 90 5D |  if_ne	jmp	#LR__0518
03ee0     00 B0 0E F2 | 	cmp	local06, #0 wz
03ee4     5E CD 02 56 |  if_ne	mov	local20, local12
03ee8     01 BC 06 51 |  if_ne	add	local12, #1
03eec     66 B1 42 5C |  if_ne	wrbyte	local06, local20
03ef0     71 00 00 FF 
03ef4     C6 92 06 F6 | 	mov	arg02, ##@LR__2161
03ef8     5E 91 02 F6 | 	mov	arg01, local12
03efc     50 F2 BF FD | 	call	#__system____builtin_strcpy
03f00     AC 04 90 FD | 	jmp	#LR__0550
03f04                 | LR__0518
03f04     55 91 02 F6 | 	mov	arg01, local03
03f08     54 10 B0 FD | 	call	#__system____builtin_ilogb
03f0c     3B CD 02 F6 | 	mov	local20, result1
03f10     00 00 40 FF 
03f14     00 CC 0E F2 | 	cmp	local20, ##-2147483648 wz
03f18     24 00 90 5D |  if_ne	jmp	#LR__0519
03f1c     00 B0 0E F2 | 	cmp	local06, #0 wz
03f20     5E CD 02 56 |  if_ne	mov	local20, local12
03f24     01 BC 06 51 |  if_ne	add	local12, #1
03f28     66 B1 42 5C |  if_ne	wrbyte	local06, local20
03f2c     5E 91 02 F6 | 	mov	arg01, local12
03f30     71 00 00 FF 
03f34     CA 92 06 F6 | 	mov	arg02, ##@LR__2162
03f38     14 F2 BF FD | 	call	#__system____builtin_strcpy
03f3c     70 04 90 FD | 	jmp	#LR__0550
03f40                 | LR__0519
03f40     67 AC 0E F2 | 	cmp	local04, #103 wz
03f44     23 AC 0E 52 |  if_ne	cmp	local04, #35 wz
03f48     0C 01 90 5D |  if_ne	jmp	#LR__0524
03f4c     14 CE 05 F1 | 	add	fp, #20
03f50     E7 92 02 F6 | 	mov	arg02, fp
03f54     0C CE 05 F1 | 	add	fp, #12
03f58     E7 94 02 F6 | 	mov	arg03, fp
03f5c     20 CE 85 F1 | 	sub	fp, #32
03f60     60 97 02 F6 | 	mov	arg04, local14
03f64     57 99 02 F6 | 	mov	arg05, local05
03f68     55 91 02 F6 | 	mov	arg01, local03
03f6c     48 24 B0 FD | 	call	#__system__disassemble_0093
03f70     23 AC 0E F2 | 	cmp	local04, #35 wz
03f74     6C 00 90 5D |  if_ne	jmp	#LR__0521
03f78     20 CE 05 F1 | 	add	fp, #32
03f7c     E7 CC 02 FB | 	rdlong	local20, fp
03f80     20 CE 85 F1 | 	sub	fp, #32
03f84     60 CD 5A F2 | 	cmps	local20, local14 wcz
03f88     01 CE 06 16 |  if_a	mov	local21, #1
03f8c     24 01 90 1D |  if_a	jmp	#LR__0527
03f90     20 CE 05 F1 | 	add	fp, #32
03f94     E7 CC 02 FB | 	rdlong	local20, fp
03f98     20 CE 85 F1 | 	sub	fp, #32
03f9c     00 CC 56 F2 | 	cmps	local20, #0 wc
03fa0     1C 00 90 3D |  if_ae	jmp	#LR__0520
03fa4     60 CD 62 F6 | 	neg	local20, local14
03fa8     20 CE 05 F1 | 	add	fp, #32
03fac     E7 DC 02 FB | 	rdlong	local28, fp
03fb0     20 CE 85 F1 | 	sub	fp, #32
03fb4     66 DD 5A F2 | 	cmps	local28, local20 wcz
03fb8     01 CE 06 E6 |  if_be	mov	local21, #1
03fbc     F4 00 90 FD | 	jmp	#LR__0527
03fc0                 | LR__0520
03fc0     20 CE 05 F1 | 	add	fp, #32
03fc4     E7 CC 02 FB | 	rdlong	local20, fp
03fc8     20 CE 85 F1 | 	sub	fp, #32
03fcc     01 CC 56 F2 | 	cmps	local20, #1 wc
03fd0     20 CE 05 31 |  if_ae	add	fp, #32
03fd4     E7 DC 02 3B |  if_ae	rdlong	local28, fp
03fd8     20 CE 85 31 |  if_ae	sub	fp, #32
03fdc     6E C1 82 31 |  if_ae	sub	local14, local28
03fe0     D0 00 90 FD | 	jmp	#LR__0527
03fe4                 | LR__0521
03fe4     00 B2 06 F6 | 	mov	local07, #0
03fe8     1C A8 2E F4 | 	testbn	local02, #28 wz
03fec     01 B2 06 A6 |  if_e	mov	local07, #1
03ff0     20 CE 05 F1 | 	add	fp, #32
03ff4     E7 CC 02 FB | 	rdlong	local20, fp
03ff8     20 CE 85 F1 | 	sub	fp, #32
03ffc     60 CD 52 F2 | 	cmps	local20, local14 wc
04000     18 00 90 3D |  if_ae	jmp	#LR__0522
04004     20 CE 05 F1 | 	add	fp, #32
04008     E7 D8 02 FB | 	rdlong	local26, fp
0400c     20 CE 85 F1 | 	sub	fp, #32
04010     FF FF 7F FF 
04014     FC D9 56 F2 | 	cmps	local26, ##-4 wc
04018     08 00 90 3D |  if_ae	jmp	#LR__0523
0401c                 | LR__0522
0401c     01 CE 06 F6 | 	mov	local21, #1
04020     90 00 90 FD | 	jmp	#LR__0527
04024                 | LR__0523
04024     20 CE 05 F1 | 	add	fp, #32
04028     E7 DC 02 FB | 	rdlong	local28, fp
0402c     6E C1 82 F1 | 	sub	local14, local28
04030     0C CE 85 F1 | 	sub	fp, #12
04034     E7 92 02 F6 | 	mov	arg02, fp
04038     0C CE 05 F1 | 	add	fp, #12
0403c     E7 94 02 F6 | 	mov	arg03, fp
04040     20 CE 85 F1 | 	sub	fp, #32
04044     60 97 62 F6 | 	neg	arg04, local14
04048     55 91 02 F6 | 	mov	arg01, local03
0404c     57 99 02 F6 | 	mov	arg05, local05
04050     64 23 B0 FD | 	call	#__system__disassemble_0093
04054     5C 00 90 FD | 	jmp	#LR__0527
04058                 | LR__0524
04058     00 CE 0E F2 | 	cmp	local21, #0 wz
0405c     28 00 90 AD |  if_e	jmp	#LR__0525
04060     14 CE 05 F1 | 	add	fp, #20
04064     E7 92 02 F6 | 	mov	arg02, fp
04068     0C CE 05 F1 | 	add	fp, #12
0406c     E7 94 02 F6 | 	mov	arg03, fp
04070     20 CE 85 F1 | 	sub	fp, #32
04074     55 91 02 F6 | 	mov	arg01, local03
04078     60 97 02 F6 | 	mov	arg04, local14
0407c     57 99 02 F6 | 	mov	arg05, local05
04080     34 23 B0 FD | 	call	#__system__disassemble_0093
04084     2C 00 90 FD | 	jmp	#LR__0526
04088                 | LR__0525
04088     14 CE 05 F1 | 	add	fp, #20
0408c     E7 92 02 F6 | 	mov	arg02, fp
04090     0C CE 05 F1 | 	add	fp, #12
04094     E7 94 02 F6 | 	mov	arg03, fp
04098     20 CE 85 F1 | 	sub	fp, #32
0409c     60 DD 02 F6 | 	mov	local28, local14
040a0     01 DC 06 F1 | 	add	local28, #1
040a4     6E 97 62 F6 | 	neg	arg04, local28
040a8     55 91 02 F6 | 	mov	arg01, local03
040ac     57 99 02 F6 | 	mov	arg05, local05
040b0     04 23 B0 FD | 	call	#__system__disassemble_0093
040b4                 | LR__0526
040b4                 | LR__0527
040b4     02 AE 0E F2 | 	cmp	local05, #2 wz
040b8     44 00 90 5D |  if_ne	jmp	#LR__0530
040bc     10 AE 06 F6 | 	mov	local05, #16
040c0                 | LR__0528
040c0     14 CE 05 F1 | 	add	fp, #20
040c4     E7 CC 0A FB | 	rdlong	local20, fp wz
040c8     14 CE 85 F1 | 	sub	fp, #20
040cc     30 00 90 AD |  if_e	jmp	#LR__0529
040d0     14 CE 05 F1 | 	add	fp, #20
040d4     E7 D8 02 FB | 	rdlong	local26, fp
040d8     14 CE 85 F1 | 	sub	fp, #20
040dc     00 80 00 FF 
040e0     00 D8 16 F2 | 	cmp	local26, ##16777216 wc
040e4     18 00 90 3D |  if_ae	jmp	#LR__0529
040e8     14 CE 05 F1 | 	add	fp, #20
040ec     E7 CC 02 FB | 	rdlong	local20, fp
040f0     01 CC 66 F0 | 	shl	local20, #1
040f4     E7 CC 62 FC | 	wrlong	local20, fp
040f8     14 CE 85 F1 | 	sub	fp, #20
040fc     C0 FF 9F FD | 	jmp	#LR__0528
04100                 | LR__0529
04100                 | LR__0530
04100     70 CE 05 F1 | 	add	fp, #112
04104     E7 90 02 F6 | 	mov	arg01, fp
04108     5C CE 85 F1 | 	sub	fp, #92
0410c     E7 92 02 FB | 	rdlong	arg02, fp
04110     14 CE 85 F1 | 	sub	fp, #20
04114     57 95 02 F6 | 	mov	arg03, local05
04118     01 96 06 F6 | 	mov	arg04, #1
0411c     63 99 02 F6 | 	mov	arg05, local17
04120     20 22 B0 FD | 	call	#__system___uitoa
04124     3B DF 02 F6 | 	mov	local29, result1
04128     20 CE 05 F1 | 	add	fp, #32
0412c     E7 CC 02 FB | 	rdlong	local20, fp
04130     20 CE 85 F1 | 	sub	fp, #32
04134     00 CC 56 F2 | 	cmps	local20, #0 wc
04138     44 00 90 3D |  if_ae	jmp	#LR__0531
0413c     2D BA 06 F6 | 	mov	local11, #45
04140     B0 CE 05 F1 | 	add	fp, #176
04144     E7 90 02 F6 | 	mov	arg01, fp
04148     90 CE 85 F1 | 	sub	fp, #144
0414c     E7 D8 02 FB | 	rdlong	local26, fp
04150     20 CE 85 F1 | 	sub	fp, #32
04154     6C DD 62 F6 | 	neg	local28, local26
04158     0A D8 06 F6 | 	mov	local26, #10
0415c     5A E1 02 F6 | 	mov	local30, local08
04160     63 E3 02 F6 | 	mov	local31, local17
04164     6E 93 02 F6 | 	mov	arg02, local28
04168     0A 94 06 F6 | 	mov	arg03, #10
0416c     70 97 02 F6 | 	mov	arg04, local30
04170     71 99 02 F6 | 	mov	arg05, local31
04174     CC 21 B0 FD | 	call	#__system___uitoa
04178     3B E5 02 F6 | 	mov	local32, result1
0417c     3C 00 90 FD | 	jmp	#LR__0532
04180                 | LR__0531
04180     2B BA 06 F6 | 	mov	local11, #43
04184     B0 CE 05 F1 | 	add	fp, #176
04188     E7 90 02 F6 | 	mov	arg01, fp
0418c     90 CE 85 F1 | 	sub	fp, #144
04190     E7 DC 02 FB | 	rdlong	local28, fp
04194     20 CE 85 F1 | 	sub	fp, #32
04198     0A D8 06 F6 | 	mov	local26, #10
0419c     5A E1 02 F6 | 	mov	local30, local08
041a0     63 E3 02 F6 | 	mov	local31, local17
041a4     6E 93 02 F6 | 	mov	arg02, local28
041a8     0A 94 06 F6 | 	mov	arg03, #10
041ac     70 97 02 F6 | 	mov	arg04, local30
041b0     71 99 02 F6 | 	mov	arg05, local31
041b4     8C 21 B0 FD | 	call	#__system___uitoa
041b8     3B E5 02 F6 | 	mov	local32, result1
041bc                 | LR__0532
041bc     00 CE 0E F2 | 	cmp	local21, #0 wz
041c0     00 E6 06 56 |  if_ne	mov	local33, #0
041c4     00 E8 06 56 |  if_ne	mov	local34, #0
041c8     60 EB 02 56 |  if_ne	mov	local35, local14
041cc     01 EA 06 51 |  if_ne	add	local35, #1
041d0     54 00 90 5D |  if_ne	jmp	#LR__0535
041d4     20 CE 05 F1 | 	add	fp, #32
041d8     E7 DC 02 FB | 	rdlong	local28, fp
041dc     20 CE 85 F1 | 	sub	fp, #32
041e0     00 DC 56 F2 | 	cmps	local28, #0 wc
041e4     24 00 90 3D |  if_ae	jmp	#LR__0533
041e8     20 CE 05 F1 | 	add	fp, #32
041ec     E7 DC 02 FB | 	rdlong	local28, fp
041f0     6E E7 02 F6 | 	mov	local33, local28
041f4     73 E9 02 F6 | 	mov	local34, local33
041f8     20 CE 85 F1 | 	sub	fp, #32
041fc     6E EB 02 F6 | 	mov	local35, local28
04200     60 EB 02 F1 | 	add	local35, local14
04204     01 EA 06 F1 | 	add	local35, #1
04208     1C 00 90 FD | 	jmp	#LR__0534
0420c                 | LR__0533
0420c     00 E8 06 F6 | 	mov	local34, #0
04210     20 CE 05 F1 | 	add	fp, #32
04214     E7 E6 02 FB | 	rdlong	local33, fp
04218     20 CE 85 F1 | 	sub	fp, #32
0421c     73 EB 02 F6 | 	mov	local35, local33
04220     60 EB 02 F1 | 	add	local35, local14
04224     01 EA 06 F1 | 	add	local35, #1
04228                 | LR__0534
04228                 | LR__0535
04228     75 CD 02 F6 | 	mov	local20, local35
0422c     74 CD 82 F1 | 	sub	local20, local34
04230     01 CC 06 F1 | 	add	local20, #1
04234     66 ED 02 F6 | 	mov	local36, local20
04238     00 B0 0E F2 | 	cmp	local06, #0 wz
0423c     76 CD 02 56 |  if_ne	mov	local20, local36
04240     76 DD 02 56 |  if_ne	mov	local28, local36
04244     01 DC 06 51 |  if_ne	add	local28, #1
04248     6E ED 02 56 |  if_ne	mov	local36, local28
0424c     10 AE 0E F2 | 	cmp	local05, #16 wz
04250     02 EC 06 A1 |  if_e	add	local36, #2
04254     00 CE 0E F2 | 	cmp	local21, #0 wz
04258     02 DC 06 56 |  if_ne	mov	local28, #2
0425c     72 DD 02 51 |  if_ne	add	local28, local32
04260     6E ED 02 51 |  if_ne	add	local36, local28
04264     41 EC 56 F2 | 	cmps	local36, #65 wc
04268     01 76 66 36 |  if_ae	neg	result1, #1
0426c     F0 01 90 3D |  if_ae	jmp	#LR__0560
04270     00 D6 0E F2 | 	cmp	local25, #0 wz
04274     28 00 90 AD |  if_e	jmp	#LR__0536
04278     58 93 02 F6 | 	mov	arg02, local06
0427c     5E 91 02 F6 | 	mov	arg01, local12
04280     5B 95 02 F6 | 	mov	arg03, local09
04284     24 23 B0 FD | 	call	#__system__emitsign_0095
04288     3B EF 02 F6 | 	mov	local37, result1
0428c     00 EE 56 F2 | 	cmps	local37, #0 wc
04290     77 77 02 C6 |  if_b	mov	result1, local37
04294     C8 01 90 CD |  if_b	jmp	#LR__0560
04298     77 DD 02 F6 | 	mov	local28, local37
0429c     77 BD 02 F1 | 	add	local12, local37
042a0                 | LR__0536
042a0     74 F1 02 F6 | 	mov	local38, local34
042a4     D7 42 48 FB | 	callpa	#(@LR__0541-@LR__0537)>>2,fcache_load_ptr_
042a8                 | LR__0537
042a8     75 F1 52 F2 | 	cmps	local38, local35 wc
042ac     7C 00 90 3D |  if_ae	jmp	#LR__0542
042b0     00 F0 56 F2 | 	cmps	local38, #0 wc
042b4     2C 00 90 CD |  if_b	jmp	#LR__0538
042b8     6F F1 52 F2 | 	cmps	local38, local29 wc
042bc     24 00 90 3D |  if_ae	jmp	#LR__0538
042c0     5E CD 02 F6 | 	mov	local20, local12
042c4     78 D9 02 F6 | 	mov	local26, local38
042c8     E7 E0 02 F6 | 	mov	local30, fp
042cc     70 E0 06 F1 | 	add	local30, #112
042d0     70 D9 02 F1 | 	add	local26, local30
042d4     6C E3 C2 FA | 	rdbyte	local31, local26
042d8     66 E3 42 FC | 	wrbyte	local31, local20
042dc     01 BC 06 F1 | 	add	local12, #1
042e0     10 00 90 FD | 	jmp	#LR__0539
042e4                 | LR__0538
042e4     5E CD 02 F6 | 	mov	local20, local12
042e8     30 D8 06 F6 | 	mov	local26, #48
042ec     66 61 48 FC | 	wrbyte	#48, local20
042f0     01 BC 06 F1 | 	add	local12, #1
042f4                 | LR__0539
042f4     73 F1 0A F2 | 	cmp	local38, local33 wz
042f8     20 00 90 5D |  if_ne	jmp	#LR__0540
042fc     00 C2 0E F2 | 	cmp	local15, #0 wz
04300     75 CD 02 A6 |  if_e	mov	local20, local35
04304     01 CC 86 A1 |  if_e	sub	local20, #1
04308     66 F1 52 A2 |  if_e	cmps	local38, local20 wc
0430c     5E CD 02 D6 |  if_c_or_nz	mov	local20, local12
04310     2E D8 06 D6 |  if_c_or_nz	mov	local26, #46
04314     66 5D 48 DC |  if_c_or_nz	wrbyte	#46, local20
04318     01 BC 06 D1 |  if_c_or_nz	add	local12, #1
0431c                 | LR__0540
0431c     78 DD 02 F6 | 	mov	local28, local38
04320     01 DC 06 F1 | 	add	local28, #1
04324     6E F1 02 F6 | 	mov	local38, local28
04328     7C FF 9F FD | 	jmp	#LR__0537
0432c                 | LR__0541
0432c                 | LR__0542
0432c     00 B2 0E F2 | 	cmp	local07, #0 wz
04330     30 00 90 AD |  if_e	jmp	#LR__0546
04334     01 BC 86 F1 | 	sub	local12, #1
04338     D7 0C 48 FB | 	callpa	#(@LR__0544-@LR__0543)>>2,fcache_load_ptr_
0433c                 | LR__0543
0433c     5F BD 5A F2 | 	cmps	local12, local13 wcz
04340     10 00 90 ED |  if_be	jmp	#LR__0545
04344     5E CD C2 FA | 	rdbyte	local20, local12
04348     30 CC 0E F2 | 	cmp	local20, #48 wz
0434c     01 BC 86 A1 |  if_e	sub	local12, #1
04350     E8 FF 9F AD |  if_e	jmp	#LR__0543
04354                 | LR__0544
04354                 | LR__0545
04354     5E CD C2 FA | 	rdbyte	local20, local12
04358     2E CC 0E F2 | 	cmp	local20, #46 wz
0435c     01 BC 86 A1 |  if_e	sub	local12, #1
04360     01 BC 06 F1 | 	add	local12, #1
04364                 | LR__0546
04364     00 CE 0E F2 | 	cmp	local21, #0 wz
04368     40 00 90 AD |  if_e	jmp	#LR__0549
0436c     5E D1 42 FC | 	wrbyte	local22, local12
04370     01 BC 06 F1 | 	add	local12, #1
04374     5E BB 42 FC | 	wrbyte	local11, local12
04378     00 F0 06 F6 | 	mov	local38, #0
0437c     01 BC 06 F1 | 	add	local12, #1
04380                 | LR__0547
04380     72 F1 52 F2 | 	cmps	local38, local32 wc
04384     24 00 90 3D |  if_ae	jmp	#LR__0548
04388     78 D9 02 F6 | 	mov	local26, local38
0438c     E7 E0 02 F6 | 	mov	local30, fp
04390     B0 E0 06 F1 | 	add	local30, #176
04394     70 D9 02 F1 | 	add	local26, local30
04398     6C E3 C2 FA | 	rdbyte	local31, local26
0439c     5E E3 42 FC | 	wrbyte	local31, local12
043a0     01 F0 06 F1 | 	add	local38, #1
043a4     01 BC 06 F1 | 	add	local12, #1
043a8     D4 FF 9F FD | 	jmp	#LR__0547
043ac                 | LR__0548
043ac                 | LR__0549
043ac     5E 01 48 FC | 	wrbyte	#0, local12
043b0                 | LR__0550
043b0     00 CA 0E F2 | 	cmp	local19, #0 wz
043b4     00 B8 0E 52 |  if_ne	cmp	local10, #0 wz
043b8     94 00 90 AD |  if_e	jmp	#LR__0559
043bc     5F 91 02 F6 | 	mov	arg01, local13
043c0     48 F3 02 F6 | 	mov	local39, arg01
043c4     D7 06 48 FB | 	callpa	#(@LR__0552-@LR__0551)>>2,fcache_load_ptr_
043c8                 | LR__0551
043c8     79 77 CA FA | 	rdbyte	result1, local39 wz
043cc     01 F2 06 51 |  if_ne	add	local39, #1
043d0     F4 FF 9F 5D |  if_ne	jmp	#LR__0551
043d4                 | LR__0552
043d4     48 F3 82 F1 | 	sub	local39, arg01
043d8     65 F3 5A F2 | 	cmps	local39, local19 wcz
043dc     70 00 90 ED |  if_be	jmp	#LR__0559
043e0     5F F5 02 F6 | 	mov	local40, local13
043e4     00 CE 0E F2 | 	cmp	local21, #0 wz
043e8     00 C0 06 56 |  if_ne	mov	local14, #0
043ec     65 F7 02 56 |  if_ne	mov	local41, local19
043f0     01 CA 86 A1 |  if_e	sub	local19, #1
043f4     60 CB 82 A1 |  if_e	sub	local19, local14
043f8     65 F7 02 A6 |  if_e	mov	local41, local19
043fc     00 F6 0E F2 | 	cmp	local41, #0 wz
04400     14 00 90 AD |  if_e	jmp	#LR__0555
04404     D7 08 48 FB | 	callpa	#(@LR__0554-@LR__0553)>>2,fcache_load_ptr_
04408                 | LR__0553
04408     7A 55 48 FC | 	wrbyte	#42, local40
0440c     01 F6 8E F1 | 	sub	local41, #1 wz
04410     01 F4 06 F1 | 	add	local40, #1
04414     F0 FF 9F 5D |  if_ne	jmp	#LR__0553
04418                 | LR__0554
04418                 | LR__0555
04418     00 C0 0E F2 | 	cmp	local14, #0 wz
0441c     2C 00 90 AD |  if_e	jmp	#LR__0558
04420     7A CD 02 F6 | 	mov	local20, local40
04424     66 5D 48 FC | 	wrbyte	#46, local20
04428     00 F6 06 F6 | 	mov	local41, #0
0442c     01 F4 06 F1 | 	add	local40, #1
04430     D7 0C 48 FB | 	callpa	#(@LR__0557-@LR__0556)>>2,fcache_load_ptr_
04434                 | LR__0556
04434     60 F7 52 F2 | 	cmps	local41, local14 wc
04438     7A CD 02 C6 |  if_b	mov	local20, local40
0443c     01 F4 06 C1 |  if_b	add	local40, #1
04440     66 55 48 CC |  if_b	wrbyte	#42, local20
04444     01 F6 06 C1 |  if_b	add	local41, #1
04448     E8 FF 9F CD |  if_b	jmp	#LR__0556
0444c                 | LR__0557
0444c                 | LR__0558
0444c     7A 01 48 FC | 	wrbyte	#0, local40
04450                 | LR__0559
04450     53 91 02 F6 | 	mov	arg01, local01
04454     54 93 02 F6 | 	mov	arg02, local02
04458     5F 95 02 F6 | 	mov	arg03, local13
0445c     C0 F7 BF FD | 	call	#__system___fmtstr
04460                 | LR__0560
04460     E7 F0 03 F6 | 	mov	ptra, fp
04464     F2 00 A0 FD | 	call	#popregs_
04468                 | __system___fmtfloat_ret
04468     2D 00 64 FD | 	ret
0446c                 | 
0446c                 | __system__str_S
0446c     02 CA 05 F6 | 	mov	COUNT_, #2
04470     E8 00 A0 FD | 	call	#pushregs_
04474     48 A7 02 F6 | 	mov	local01, arg01
04478     10 90 06 F6 | 	mov	arg01, #16
0447c     3C 0E B0 FD | 	call	#__system___gc_alloc_managed
04480     3B A9 0A F6 | 	mov	local02, result1 wz
04484     2C 00 90 AD |  if_e	jmp	#LR__0570
04488     F8 91 02 F6 | 	mov	arg01, ptra
0448c     08 F0 07 F1 | 	add	ptra, #8
04490     48 A9 62 FC | 	wrlong	local02, arg01
04494     04 90 06 F1 | 	add	arg01, #4
04498     48 01 68 FC | 	wrlong	#0, arg01
0449c     04 90 86 F1 | 	sub	arg01, #4
044a0     54 90 26 F4 | 	bith	arg01, #84
044a4     00 92 06 F6 | 	mov	arg02, #0
044a8     53 95 02 F6 | 	mov	arg03, local01
044ac     67 96 06 F6 | 	mov	arg04, #103
044b0     58 F8 BF FD | 	call	#__system___fmtfloat
044b4                 | LR__0570
044b4     54 77 02 F6 | 	mov	result1, local02
044b8     E7 F0 03 F6 | 	mov	ptra, fp
044bc     F2 00 A0 FD | 	call	#popregs_
044c0                 | __system__str_S_ret
044c0     2D 00 64 FD | 	ret
044c4                 | 
044c4                 | __system___int64_shl
044c4     20 94 CE F7 | 	test	arg03, #32 wz
044c8     48 93 02 56 |  if_ne	mov	arg02, arg01
044cc     00 90 06 56 |  if_ne	mov	arg01, #0
044d0     1F 94 CE F7 | 	test	arg03, #31 wz
044d4     18 00 90 AD |  if_e	jmp	#LR__0580
044d8     4A 93 62 F0 | 	shl	arg02, arg03
044dc     48 77 02 F6 | 	mov	result1, arg01
044e0     4A 79 62 F6 | 	neg	result2, arg03
044e4     3C 77 42 F0 | 	shr	result1, result2
044e8     3B 93 42 F5 | 	or	arg02, result1
044ec     4A 91 62 F0 | 	shl	arg01, arg03
044f0                 | LR__0580
044f0     49 79 02 F6 | 	mov	result2, arg02
044f4     48 77 02 F6 | 	mov	result1, arg01
044f8                 | __system___int64_shl_ret
044f8     2D 00 64 FD | 	ret
044fc                 | 
044fc                 | __system___int64_sar
044fc     20 94 CE F7 | 	test	arg03, #32 wz
04500     49 91 02 56 |  if_ne	mov	arg01, arg02
04504     1F 92 C6 50 |  if_ne	sar	arg02, #31
04508     1F 94 CE F7 | 	test	arg03, #31 wz
0450c     18 00 90 AD |  if_e	jmp	#LR__0590
04510     4A 91 42 F0 | 	shr	arg01, arg03
04514     49 77 02 F6 | 	mov	result1, arg02
04518     4A 79 62 F6 | 	neg	result2, arg03
0451c     3C 77 62 F0 | 	shl	result1, result2
04520     3B 91 42 F5 | 	or	arg01, result1
04524     4A 93 C2 F0 | 	sar	arg02, arg03
04528                 | LR__0590
04528     49 79 02 F6 | 	mov	result2, arg02
0452c     48 77 02 F6 | 	mov	result1, arg01
04530                 | __system___int64_sar_ret
04530     2D 00 64 FD | 	ret
04534                 | 
04534                 | __system___usepins
04534     14 66 06 F1 | 	add	ptr___system__dat__, #20
04538     33 7D 02 FB | 	rdlong	_var01, ptr___system__dat__
0453c     14 66 86 F1 | 	sub	ptr___system__dat__, #20
04540     3E 91 CA F7 | 	test	arg01, _var01 wz
04544     18 66 06 A1 |  if_e	add	ptr___system__dat__, #24
04548     33 7F 02 AB |  if_e	rdlong	_var02, ptr___system__dat__
0454c     18 66 86 A1 |  if_e	sub	ptr___system__dat__, #24
04550     3F 93 CA A7 |  if_e	test	arg02, _var02 wz
04554     00 76 06 56 |  if_ne	mov	result1, #0
04558     28 00 90 5D |  if_ne	jmp	#__system___usepins_ret
0455c     14 66 06 F1 | 	add	ptr___system__dat__, #20
04560     33 7F 02 FB | 	rdlong	_var02, ptr___system__dat__
04564     48 7F 42 F5 | 	or	_var02, arg01
04568     33 7F 62 FC | 	wrlong	_var02, ptr___system__dat__
0456c     04 66 06 F1 | 	add	ptr___system__dat__, #4
04570     33 7F 02 FB | 	rdlong	_var02, ptr___system__dat__
04574     49 7F 42 F5 | 	or	_var02, arg02
04578     33 7F 62 FC | 	wrlong	_var02, ptr___system__dat__
0457c     18 66 86 F1 | 	sub	ptr___system__dat__, #24
04580     01 76 66 F6 | 	neg	result1, #1
04584                 | __system___usepins_ret
04584     2D 00 64 FD | 	ret
04588                 | 
04588                 | __system___freepins
04588     14 66 06 F1 | 	add	ptr___system__dat__, #20
0458c     33 7D 02 FB | 	rdlong	_var01, ptr___system__dat__
04590     48 7D 22 F5 | 	andn	_var01, arg01
04594     33 7D 62 FC | 	wrlong	_var01, ptr___system__dat__
04598     04 66 06 F1 | 	add	ptr___system__dat__, #4
0459c     33 7D 02 FB | 	rdlong	_var01, ptr___system__dat__
045a0     49 7D 22 F5 | 	andn	_var01, arg02
045a4     33 7D 62 FC | 	wrlong	_var01, ptr___system__dat__
045a8     18 66 86 F1 | 	sub	ptr___system__dat__, #24
045ac                 | __system___freepins_ret
045ac     2D 00 64 FD | 	ret
045b0                 | 
045b0                 | __system___float_fromuns
045b0     48 95 0A F6 | 	mov	arg03, arg01 wz
045b4     4A 77 02 A6 |  if_e	mov	result1, arg03
045b8     24 00 90 AD |  if_e	jmp	#LR__0600
045bc     4A 93 92 F7 | 	encod	arg02, arg03 wc
045c0     01 92 06 C1 |  if_b	add	arg02, #1
045c4     01 92 86 F1 | 	sub	arg02, #1
045c8     1F 90 06 F6 | 	mov	arg01, #31
045cc     49 91 82 F1 | 	sub	arg01, arg02
045d0     48 95 62 F0 | 	shl	arg03, arg01
045d4     02 94 46 F0 | 	shr	arg03, #2
045d8     00 90 06 F6 | 	mov	arg01, #0
045dc     80 08 B0 FD | 	call	#__system___float_Pack
045e0                 | LR__0600
045e0                 | __system___float_fromuns_ret
045e0     2D 00 64 FD | 	ret
045e4                 | 
045e4                 | __system___float_add
045e4     0F CA 05 F6 | 	mov	COUNT_, #15
045e8     E8 00 A0 FD | 	call	#pushregs_
045ec     48 A7 02 F6 | 	mov	local01, arg01
045f0     49 A9 02 F6 | 	mov	local02, arg02
045f4     00 AA 06 F6 | 	mov	local03, #0
045f8     53 AD 02 F6 | 	mov	local04, local01
045fc     56 AF 02 F6 | 	mov	local05, local04
04600     16 AE 46 F7 | 	zerox	local05, #22
04604     56 B1 02 F6 | 	mov	local06, local04
04608     01 B0 66 F0 | 	shl	local06, #1
0460c     18 B0 46 F0 | 	shr	local06, #24
04610     1F AC 46 F0 | 	shr	local04, #31
04614     54 91 02 F6 | 	mov	arg01, local02
04618     48 77 02 F6 | 	mov	result1, arg01
0461c     3B B3 02 F6 | 	mov	local07, result1
04620     59 B5 02 F6 | 	mov	local08, local07
04624     16 B4 46 F7 | 	zerox	local08, #22
04628     59 B7 02 F6 | 	mov	local09, local07
0462c     01 B6 66 F0 | 	shl	local09, #1
04630     18 B6 46 F0 | 	shr	local09, #24
04634     5B B9 02 F6 | 	mov	local10, local09
04638     1F B2 46 F0 | 	shr	local07, #31
0463c     00 BA 06 F6 | 	mov	local11, #0
04640     00 BC 06 F6 | 	mov	local12, #0
04644     5C B1 12 F2 | 	cmp	local06, local10 wc
04648     5C B1 0A 32 |  if_ae	cmp	local06, local10 wz
0464c     2C 00 90 1D |  if_a	jmp	#LR__0610
04650     5A AF 12 32 |  if_ae	cmp	local05, local08 wc
04654     24 00 90 3D |  if_ae	jmp	#LR__0610
04658     57 BF 02 F6 | 	mov	local13, local05
0465c     5A AF 02 F6 | 	mov	local05, local08
04660     5F B5 02 F6 | 	mov	local08, local13
04664     58 BF 02 F6 | 	mov	local13, local06
04668     5C B1 02 F6 | 	mov	local06, local10
0466c     5F B9 02 F6 | 	mov	local10, local13
04670     56 BF 02 F6 | 	mov	local13, local04
04674     59 AD 02 F6 | 	mov	local04, local07
04678     5F B3 02 F6 | 	mov	local07, local13
0467c                 | LR__0610
0467c     FF B0 0E F2 | 	cmp	local06, #255 wz
04680     70 01 90 AD |  if_e	jmp	#LR__0625
04684     00 B0 0E F2 | 	cmp	local06, #0 wz
04688     AC 01 90 AD |  if_e	jmp	#LR__0627
0468c     17 AE 26 F4 | 	bith	local05, #23
04690                 | LR__0611
04690     00 B8 0E F2 | 	cmp	local10, #0 wz
04694     F0 01 90 AD |  if_e	jmp	#LR__0631
04698     17 B4 26 F4 | 	bith	local08, #23
0469c                 | LR__0612
0469c     7F B0 86 F1 | 	sub	local06, #127
046a0     7F B8 86 F1 | 	sub	local10, #127
046a4     58 C1 02 F6 | 	mov	local14, local06
046a8     5C C1 82 F1 | 	sub	local14, local10
046ac     D7 14 48 FB | 	callpa	#(@LR__0614-@LR__0613)>>2,fcache_load_ptr_
046b0                 | LR__0613
046b0     20 C0 56 F2 | 	cmps	local14, #32 wc
046b4     20 00 90 CD |  if_b	jmp	#LR__0615
046b8     5A B7 02 F6 | 	mov	local09, local08
046bc     00 BA 0E F2 | 	cmp	local11, #0 wz
046c0     6F BA 62 FD | 	wrnz	local11
046c4     5D B7 42 F5 | 	or	local09, local11
046c8     5B BB 02 F6 | 	mov	local11, local09
046cc     00 B4 06 F6 | 	mov	local08, #0
046d0     20 C0 86 F1 | 	sub	local14, #32
046d4     D8 FF 9F FD | 	jmp	#LR__0613
046d8                 | LR__0614
046d8                 | LR__0615
046d8     00 C0 0E F2 | 	cmp	local14, #0 wz
046dc     38 00 90 AD |  if_e	jmp	#LR__0616
046e0     5A BF 02 F6 | 	mov	local13, local08
046e4     20 B8 06 F6 | 	mov	local10, #32
046e8     60 B9 82 F1 | 	sub	local10, local14
046ec     5C BF 62 F0 | 	shl	local13, local10
046f0     5D B9 02 F6 | 	mov	local10, local11
046f4     20 B6 06 F6 | 	mov	local09, #32
046f8     60 B7 82 F1 | 	sub	local09, local14
046fc     5B B9 6A F0 | 	shl	local10, local09 wz
04700     60 BB 42 F0 | 	shr	local11, local14
04704     60 B5 42 F0 | 	shr	local08, local14
04708     5F BB 42 F5 | 	or	local11, local13
0470c     00 C2 06 F6 | 	mov	local15, #0
04710     01 C2 06 56 |  if_ne	mov	local15, #1
04714     61 BB 42 F5 | 	or	local11, local15
04718                 | LR__0616
04718     56 C3 02 F6 | 	mov	local15, local04
0471c     59 C3 62 F5 | 	xor	local15, local07
04720     01 C2 CE F7 | 	test	local15, #1 wz
04724     18 00 90 AD |  if_e	jmp	#LR__0617
04728     5A B5 22 F6 | 	not	local08, local08
0472c     5D BB 22 F6 | 	not	local11, local11
04730     01 BA 0E F1 | 	add	local11, #1 wz
04734     00 C2 06 F6 | 	mov	local15, #0
04738     01 C2 06 A6 |  if_e	mov	local15, #1
0473c     61 B5 02 F1 | 	add	local08, local15
04740                 | LR__0617
04740     5D BD 12 F1 | 	add	local12, local11 wc
04744     5A AF 22 F1 | 	addx	local05, local08
04748     00 AE 56 F2 | 	cmps	local05, #0 wc
0474c     1C 00 90 3D |  if_ae	jmp	#LR__0618
04750     01 AC 66 F5 | 	xor	local04, #1
04754     57 AF 22 F6 | 	not	local05, local05
04758     5E BD 22 F6 | 	not	local12, local12
0475c     01 BC 0E F1 | 	add	local12, #1 wz
04760     00 C2 06 F6 | 	mov	local15, #0
04764     01 C2 06 A6 |  if_e	mov	local15, #1
04768     61 AF 02 F1 | 	add	local05, local15
0476c                 | LR__0618
0476c     00 80 00 FF 
04770     00 AE 16 F2 | 	cmp	local05, ##16777216 wc
04774     28 00 90 CD |  if_b	jmp	#LR__0619
04778     01 B0 06 F1 | 	add	local06, #1
0477c     5E C1 02 F6 | 	mov	local14, local12
04780     01 C0 06 F5 | 	and	local14, #1
04784     01 BC 46 F0 | 	shr	local12, #1
04788     57 C3 02 F6 | 	mov	local15, local05
0478c     1F C2 66 F0 | 	shl	local15, #31
04790     61 BD 42 F5 | 	or	local12, local15
04794     60 BD 42 F5 | 	or	local12, local14
04798     01 AE 46 F0 | 	shr	local05, #1
0479c     3C 00 90 FD | 	jmp	#LR__0624
047a0                 | LR__0619
047a0     00 40 00 FF 
047a4     00 AE 16 F2 | 	cmp	local05, ##8388608 wc
047a8     30 00 90 3D |  if_ae	jmp	#LR__0623
047ac     00 AE 0E F2 | 	cmp	local05, #0 wz
047b0     00 BC 0E A2 |  if_e	cmp	local12, #0 wz
047b4     08 AC 46 A5 |  if_e	or	local04, #8
047b8     01 AC 26 A5 |  if_e	andn	local04, #1
047bc     1C 00 90 AD |  if_e	jmp	#LR__0622
047c0                 | LR__0620
047c0     00 40 00 FF 
047c4     00 AE 16 F2 | 	cmp	local05, ##8388608 wc
047c8     10 00 90 3D |  if_ae	jmp	#LR__0621
047cc     5E BD 12 F1 | 	add	local12, local12 wc
047d0     57 AF 22 F1 | 	addx	local05, local05
047d4     01 B0 86 F1 | 	sub	local06, #1
047d8     E4 FF 9F FD | 	jmp	#LR__0620
047dc                 | LR__0621
047dc                 | LR__0622
047dc                 | LR__0623
047dc                 | LR__0624
047dc     57 91 02 F6 | 	mov	arg01, local05
047e0     5E 93 02 F6 | 	mov	arg02, local12
047e4     58 95 02 F6 | 	mov	arg03, local06
047e8     56 97 02 F6 | 	mov	arg04, local04
047ec     78 1E B0 FD | 	call	#__system__pack_0176
047f0     DC 00 90 FD | 	jmp	#LR__0635
047f4                 | LR__0625
047f4     FF B8 0E F2 | 	cmp	local10, #255 wz
047f8     10 00 90 5D |  if_ne	jmp	#LR__0626
047fc     56 B3 0A F2 | 	cmp	local07, local04 wz
04800     00 F8 3F 5F 
04804     00 76 06 56 |  if_ne	mov	result1, ##2146435072
04808     C4 00 90 5D |  if_ne	jmp	#LR__0635
0480c                 | LR__0626
0480c     00 AE 0E F2 | 	cmp	local05, #0 wz
04810     00 F8 3F 5F 
04814     00 76 06 56 |  if_ne	mov	result1, ##2146435072
04818     B4 00 90 5D |  if_ne	jmp	#LR__0635
0481c     5E 93 02 F6 | 	mov	arg02, local12
04820     58 95 02 F6 | 	mov	arg03, local06
04824     56 97 02 F6 | 	mov	arg04, local04
04828     02 96 46 F5 | 	or	arg04, #2
0482c     57 91 02 F6 | 	mov	arg01, local05
04830     34 1E B0 FD | 	call	#__system__pack_0176
04834     98 00 90 FD | 	jmp	#LR__0635
04838                 | LR__0627
04838     00 AE 0E F2 | 	cmp	local05, #0 wz
0483c     28 00 90 AD |  if_e	jmp	#LR__0630
04840     01 AE 66 F0 | 	shl	local05, #1
04844     D7 0E 48 FB | 	callpa	#(@LR__0629-@LR__0628)>>2,fcache_load_ptr_
04848                 | LR__0628
04848     00 40 00 FF 
0484c     00 AE 16 F2 | 	cmp	local05, ##8388608 wc
04850     58 C3 02 C6 |  if_b	mov	local15, local06
04854     01 C2 86 C1 |  if_b	sub	local15, #1
04858     61 B1 02 C6 |  if_b	mov	local06, local15
0485c     01 AE 66 C0 |  if_b	shl	local05, #1
04860     E4 FF 9F CD |  if_b	jmp	#LR__0628
04864                 | LR__0629
04864     28 FE 9F FD | 	jmp	#LR__0611
04868                 | LR__0630
04868     59 AD 02 F5 | 	and	local04, local07
0486c     56 97 02 F6 | 	mov	arg04, local04
04870     08 96 46 F5 | 	or	arg04, #8
04874     00 90 06 F6 | 	mov	arg01, #0
04878     00 92 06 F6 | 	mov	arg02, #0
0487c     00 94 06 F6 | 	mov	arg03, #0
04880     E4 1D B0 FD | 	call	#__system__pack_0176
04884     48 00 90 FD | 	jmp	#LR__0635
04888                 | LR__0631
04888     00 B4 0E F2 | 	cmp	local08, #0 wz
0488c     28 00 90 AD |  if_e	jmp	#LR__0634
04890     01 B4 66 F0 | 	shl	local08, #1
04894     D7 0E 48 FB | 	callpa	#(@LR__0633-@LR__0632)>>2,fcache_load_ptr_
04898                 | LR__0632
04898     00 40 00 FF 
0489c     00 B4 16 F2 | 	cmp	local08, ##8388608 wc
048a0     5C C3 02 C6 |  if_b	mov	local15, local10
048a4     01 C2 86 C1 |  if_b	sub	local15, #1
048a8     61 B9 02 C6 |  if_b	mov	local10, local15
048ac     01 B4 66 C0 |  if_b	shl	local08, #1
048b0     E4 FF 9F CD |  if_b	jmp	#LR__0632
048b4                 | LR__0633
048b4     E4 FD 9F FD | 	jmp	#LR__0612
048b8                 | LR__0634
048b8     7F B0 86 F1 | 	sub	local06, #127
048bc     57 91 02 F6 | 	mov	arg01, local05
048c0     5E 93 02 F6 | 	mov	arg02, local12
048c4     58 95 02 F6 | 	mov	arg03, local06
048c8     56 97 02 F6 | 	mov	arg04, local04
048cc     98 1D B0 FD | 	call	#__system__pack_0176
048d0                 | LR__0635
048d0     E7 F0 03 F6 | 	mov	ptra, fp
048d4     F2 00 A0 FD | 	call	#popregs_
048d8                 | __system___float_add_ret
048d8     2D 00 64 FD | 	ret
048dc                 | 
048dc                 | __system___float_mul
048dc     0B CA 05 F6 | 	mov	COUNT_, #11
048e0     E8 00 A0 FD | 	call	#pushregs_
048e4     48 A7 02 F6 | 	mov	local01, arg01
048e8     49 A9 02 F6 | 	mov	local02, arg02
048ec     53 AB 02 F6 | 	mov	local03, local01
048f0     55 AD 02 F6 | 	mov	local04, local03
048f4     16 AC 46 F7 | 	zerox	local04, #22
048f8     55 AF 02 F6 | 	mov	local05, local03
048fc     01 AE 66 F0 | 	shl	local05, #1
04900     18 AE 46 F0 | 	shr	local05, #24
04904     1F AA 46 F0 | 	shr	local03, #31
04908     54 77 02 F6 | 	mov	result1, local02
0490c     3B B1 02 F6 | 	mov	local06, result1
04910     58 B3 02 F6 | 	mov	local07, local06
04914     16 B2 46 F7 | 	zerox	local07, #22
04918     58 B5 02 F6 | 	mov	local08, local06
0491c     01 B4 66 F0 | 	shl	local08, #1
04920     18 B4 46 F0 | 	shr	local08, #24
04924     1F B0 46 F0 | 	shr	local06, #31
04928     58 AB 62 F5 | 	xor	local03, local06
0492c     FF AE 0E F2 | 	cmp	local05, #255 wz
04930     90 00 90 AD |  if_e	jmp	#LR__0643
04934     FF B4 0E F2 | 	cmp	local08, #255 wz
04938     D8 00 90 AD |  if_e	jmp	#LR__0645
0493c     00 AE 0E F2 | 	cmp	local05, #0 wz
04940     0C 01 90 AD |  if_e	jmp	#LR__0646
04944     17 AC 26 F4 | 	bith	local04, #23
04948                 | LR__0640
04948     00 B4 0E F2 | 	cmp	local08, #0 wz
0494c     44 01 90 AD |  if_e	jmp	#LR__0650
04950     17 B2 26 F4 | 	bith	local07, #23
04954                 | LR__0641
04954     56 A9 02 F6 | 	mov	local02, local04
04958     04 A8 66 F0 | 	shl	local02, #4
0495c     59 B1 02 F6 | 	mov	local06, local07
04960     05 B0 66 F0 | 	shl	local06, #5
04964     58 A9 02 FD | 	qmul	local02, local06
04968     5A AF 02 F1 | 	add	local05, local08
0496c     FE AE 86 F1 | 	sub	local05, #254
04970     57 B7 02 F6 | 	mov	local09, local05
04974     04 AC 66 F0 | 	shl	local04, #4
04978     05 B2 66 F0 | 	shl	local07, #5
0497c     18 B8 62 FD | 	getqx	local10
04980     59 AD 02 FD | 	qmul	local04, local07
04984     19 BA 62 FD | 	getqy	local11
04988     00 80 00 FF 
0498c     00 BA 16 F2 | 	cmp	local11, ##16777216 wc
04990     18 00 90 CD |  if_b	jmp	#LR__0642
04994     01 B6 06 F1 | 	add	local09, #1
04998     01 B8 46 F0 | 	shr	local10, #1
0499c     5D B5 02 F6 | 	mov	local08, local11
049a0     1F B4 66 F0 | 	shl	local08, #31
049a4     5A B9 42 F5 | 	or	local10, local08
049a8     01 BA 46 F0 | 	shr	local11, #1
049ac                 | LR__0642
049ac     5D 91 02 F6 | 	mov	arg01, local11
049b0     5C 93 02 F6 | 	mov	arg02, local10
049b4     5B 95 02 F6 | 	mov	arg03, local09
049b8     55 97 02 F6 | 	mov	arg04, local03
049bc     A8 1C B0 FD | 	call	#__system__pack_0176
049c0     10 01 90 FD | 	jmp	#LR__0654
049c4                 | LR__0643
049c4     00 AC 0E F2 | 	cmp	local04, #0 wz
049c8     53 77 02 56 |  if_ne	mov	result1, local01
049cc     04 01 90 5D |  if_ne	jmp	#LR__0654
049d0     FF B4 56 F2 | 	cmps	local08, #255 wc
049d4     00 B4 0E C2 |  if_b	cmp	local08, #0 wz
049d8     00 B2 0E 82 |  if_c_and_z	cmp	local07, #0 wz
049dc     18 00 90 4D |  if_c_and_nz	jmp	#LR__0644
049e0     00 F8 3F CF 
049e4     00 76 06 C6 |  if_b	mov	result1, ##2146435072
049e8     E8 00 90 CD |  if_b	jmp	#LR__0654
049ec     00 B2 0E F2 | 	cmp	local07, #0 wz
049f0     54 77 02 56 |  if_ne	mov	result1, local02
049f4     DC 00 90 5D |  if_ne	jmp	#LR__0654
049f8                 | LR__0644
049f8     02 AA 46 F5 | 	or	local03, #2
049fc     00 90 06 F6 | 	mov	arg01, #0
04a00     00 92 06 F6 | 	mov	arg02, #0
04a04     57 95 02 F6 | 	mov	arg03, local05
04a08     55 97 02 F6 | 	mov	arg04, local03
04a0c     58 1C B0 FD | 	call	#__system__pack_0176
04a10     C0 00 90 FD | 	jmp	#LR__0654
04a14                 | LR__0645
04a14     00 AE 0E F2 | 	cmp	local05, #0 wz
04a18     00 AC 0E A2 |  if_e	cmp	local04, #0 wz
04a1c     00 F8 3F AF 
04a20     00 76 06 A6 |  if_e	mov	result1, ##2146435072
04a24     AC 00 90 AD |  if_e	jmp	#LR__0654
04a28     00 B2 0E F2 | 	cmp	local07, #0 wz
04a2c     54 77 02 56 |  if_ne	mov	result1, local02
04a30     A0 00 90 5D |  if_ne	jmp	#LR__0654
04a34     5A 95 02 F6 | 	mov	arg03, local08
04a38     55 97 02 F6 | 	mov	arg04, local03
04a3c     02 96 46 F5 | 	or	arg04, #2
04a40     00 90 06 F6 | 	mov	arg01, #0
04a44     00 92 06 F6 | 	mov	arg02, #0
04a48     1C 1C B0 FD | 	call	#__system__pack_0176
04a4c     84 00 90 FD | 	jmp	#LR__0654
04a50                 | LR__0646
04a50     00 AC 0E F2 | 	cmp	local04, #0 wz
04a54     20 00 90 AD |  if_e	jmp	#LR__0649
04a58     01 AC 66 F0 | 	shl	local04, #1
04a5c     D7 0A 48 FB | 	callpa	#(@LR__0648-@LR__0647)>>2,fcache_load_ptr_
04a60                 | LR__0647
04a60     00 40 00 FF 
04a64     00 AC 16 F2 | 	cmp	local04, ##8388608 wc
04a68     01 AE 86 C1 |  if_b	sub	local05, #1
04a6c     01 AC 66 C0 |  if_b	shl	local04, #1
04a70     EC FF 9F CD |  if_b	jmp	#LR__0647
04a74                 | LR__0648
04a74     D0 FE 9F FD | 	jmp	#LR__0640
04a78                 | LR__0649
04a78     08 AA 46 F5 | 	or	local03, #8
04a7c     00 90 06 F6 | 	mov	arg01, #0
04a80     00 92 06 F6 | 	mov	arg02, #0
04a84     00 94 06 F6 | 	mov	arg03, #0
04a88     55 97 02 F6 | 	mov	arg04, local03
04a8c     D8 1B B0 FD | 	call	#__system__pack_0176
04a90     40 00 90 FD | 	jmp	#LR__0654
04a94                 | LR__0650
04a94     00 B2 0E F2 | 	cmp	local07, #0 wz
04a98     20 00 90 AD |  if_e	jmp	#LR__0653
04a9c     01 B2 66 F0 | 	shl	local07, #1
04aa0     D7 0A 48 FB | 	callpa	#(@LR__0652-@LR__0651)>>2,fcache_load_ptr_
04aa4                 | LR__0651
04aa4     00 40 00 FF 
04aa8     00 B2 16 F2 | 	cmp	local07, ##8388608 wc
04aac     01 B4 86 C1 |  if_b	sub	local08, #1
04ab0     01 B2 66 C0 |  if_b	shl	local07, #1
04ab4     EC FF 9F CD |  if_b	jmp	#LR__0651
04ab8                 | LR__0652
04ab8     98 FE 9F FD | 	jmp	#LR__0641
04abc                 | LR__0653
04abc     08 AA 46 F5 | 	or	local03, #8
04ac0     00 90 06 F6 | 	mov	arg01, #0
04ac4     00 92 06 F6 | 	mov	arg02, #0
04ac8     00 94 06 F6 | 	mov	arg03, #0
04acc     55 97 02 F6 | 	mov	arg04, local03
04ad0     94 1B B0 FD | 	call	#__system__pack_0176
04ad4                 | LR__0654
04ad4     E7 F0 03 F6 | 	mov	ptra, fp
04ad8     F2 00 A0 FD | 	call	#popregs_
04adc                 | __system___float_mul_ret
04adc     2D 00 64 FD | 	ret
04ae0                 | 
04ae0                 | __system___float_div
04ae0     0E CA 05 F6 | 	mov	COUNT_, #14
04ae4     E8 00 A0 FD | 	call	#pushregs_
04ae8     48 AB 02 F6 | 	mov	local03, arg01
04aec     49 AD 02 F6 | 	mov	local04, arg02
04af0     55 AF 02 F6 | 	mov	local05, local03
04af4     57 B1 02 F6 | 	mov	local06, local05
04af8     16 B0 46 F7 | 	zerox	local06, #22
04afc     57 B3 02 F6 | 	mov	local07, local05
04b00     01 B2 66 F0 | 	shl	local07, #1
04b04     18 B2 46 F0 | 	shr	local07, #24
04b08     1F AE 46 F0 | 	shr	local05, #31
04b0c     56 77 02 F6 | 	mov	result1, local04
04b10     3B B5 02 F6 | 	mov	local08, result1
04b14     5A B7 02 F6 | 	mov	local09, local08
04b18     16 B6 46 F7 | 	zerox	local09, #22
04b1c     5A B9 02 F6 | 	mov	local10, local08
04b20     01 B8 66 F0 | 	shl	local10, #1
04b24     18 B8 46 F0 | 	shr	local10, #24
04b28     1F B4 46 F0 | 	shr	local08, #31
04b2c     5A AF 62 F5 | 	xor	local05, local08
04b30     FF B2 0E F2 | 	cmp	local07, #255 wz
04b34     D4 00 90 AD |  if_e	jmp	#LR__0665
04b38     FF B8 0E F2 | 	cmp	local10, #255 wz
04b3c     04 01 90 AD |  if_e	jmp	#LR__0666
04b40     00 B2 0E F2 | 	cmp	local07, #0 wz
04b44     24 01 90 AD |  if_e	jmp	#LR__0667
04b48     17 B0 26 F4 | 	bith	local06, #23
04b4c                 | LR__0660
04b4c     00 B8 0E F2 | 	cmp	local10, #0 wz
04b50     70 01 90 AD |  if_e	jmp	#LR__0671
04b54     17 B6 26 F4 | 	bith	local09, #23
04b58                 | LR__0661
04b58     5C B3 82 F1 | 	sub	local07, local10
04b5c     59 BB 02 F6 | 	mov	local11, local07
04b60     58 91 02 F6 | 	mov	arg01, local06
04b64     02 90 46 F0 | 	shr	arg01, #2
04b68     1E B0 66 F0 | 	shl	local06, #30
04b6c     58 93 02 F6 | 	mov	arg02, local06
04b70     5B 95 02 F6 | 	mov	arg03, local09
04b74     28 90 62 FD | 	setq	arg01
04b78     4A 93 12 FD | 	qdiv	arg02, arg03
04b7c     00 BC 06 F6 | 	mov	local12, #0
04b80     18 A6 62 FD | 	getqx	local01
04b84     19 78 62 FD | 	getqy	result2
04b88     3C A9 02 F6 | 	mov	local02, result2
04b8c     53 BF 02 F6 | 	mov	local13, local01
04b90     00 A8 4E F2 | 	cmps	local02, #0 wz
04b94     5F C1 02 F6 | 	mov	local14, local13
04b98     19 C0 66 F0 | 	shl	local14, #25
04b9c     01 BC 06 56 |  if_ne	mov	local12, #1
04ba0     5E C1 42 F5 | 	or	local14, local12
04ba4     07 BE 46 F0 | 	shr	local13, #7
04ba8     00 80 00 FF 
04bac     00 BE 16 F2 | 	cmp	local13, ##16777216 wc
04bb0     1C 00 90 CD |  if_b	jmp	#LR__0662
04bb4     01 BA 06 F1 | 	add	local11, #1
04bb8     01 C0 46 F0 | 	shr	local14, #1
04bbc     5F BD 02 F6 | 	mov	local12, local13
04bc0     1F BC 66 F0 | 	shl	local12, #31
04bc4     5E C1 42 F5 | 	or	local14, local12
04bc8     01 BE 46 F0 | 	shr	local13, #1
04bcc     24 00 90 FD | 	jmp	#LR__0664
04bd0                 | LR__0662
04bd0     00 40 00 FF 
04bd4     00 BE 16 F2 | 	cmp	local13, ##8388608 wc
04bd8     18 00 90 3D |  if_ae	jmp	#LR__0663
04bdc     01 BA 86 F1 | 	sub	local11, #1
04be0     01 BE 66 F0 | 	shl	local13, #1
04be4     60 BD 02 F6 | 	mov	local12, local14
04be8     1F BC 46 F0 | 	shr	local12, #31
04bec     5E BF 42 F5 | 	or	local13, local12
04bf0     01 C0 66 F0 | 	shl	local14, #1
04bf4                 | LR__0663
04bf4                 | LR__0664
04bf4     5F 91 02 F6 | 	mov	arg01, local13
04bf8     60 93 02 F6 | 	mov	arg02, local14
04bfc     5D 95 02 F6 | 	mov	arg03, local11
04c00     57 97 02 F6 | 	mov	arg04, local05
04c04     60 1A B0 FD | 	call	#__system__pack_0176
04c08     F8 00 90 FD | 	jmp	#LR__0675
04c0c                 | LR__0665
04c0c     00 B0 0E F2 | 	cmp	local06, #0 wz
04c10     55 77 02 56 |  if_ne	mov	result1, local03
04c14     EC 00 90 5D |  if_ne	jmp	#LR__0675
04c18     FF B8 0E F2 | 	cmp	local10, #255 wz
04c1c     00 F8 3F AF 
04c20     00 76 06 A6 |  if_e	mov	result1, ##2146435072
04c24     DC 00 90 AD |  if_e	jmp	#LR__0675
04c28     02 AE 46 F5 | 	or	local05, #2
04c2c     00 90 06 F6 | 	mov	arg01, #0
04c30     00 92 06 F6 | 	mov	arg02, #0
04c34     59 95 02 F6 | 	mov	arg03, local07
04c38     57 97 02 F6 | 	mov	arg04, local05
04c3c     28 1A B0 FD | 	call	#__system__pack_0176
04c40     C0 00 90 FD | 	jmp	#LR__0675
04c44                 | LR__0666
04c44     00 B6 0E F2 | 	cmp	local09, #0 wz
04c48     56 77 02 56 |  if_ne	mov	result1, local04
04c4c     B4 00 90 5D |  if_ne	jmp	#LR__0675
04c50     57 97 02 F6 | 	mov	arg04, local05
04c54     08 96 46 F5 | 	or	arg04, #8
04c58     00 90 06 F6 | 	mov	arg01, #0
04c5c     00 92 06 F6 | 	mov	arg02, #0
04c60     00 94 06 F6 | 	mov	arg03, #0
04c64     00 1A B0 FD | 	call	#__system__pack_0176
04c68     98 00 90 FD | 	jmp	#LR__0675
04c6c                 | LR__0667
04c6c     00 B0 0E F2 | 	cmp	local06, #0 wz
04c70     20 00 90 AD |  if_e	jmp	#LR__0670
04c74     01 B0 66 F0 | 	shl	local06, #1
04c78     D7 0A 48 FB | 	callpa	#(@LR__0669-@LR__0668)>>2,fcache_load_ptr_
04c7c                 | LR__0668
04c7c     00 40 00 FF 
04c80     00 B0 16 F2 | 	cmp	local06, ##8388608 wc
04c84     01 B2 86 C1 |  if_b	sub	local07, #1
04c88     01 B0 66 C0 |  if_b	shl	local06, #1
04c8c     EC FF 9F CD |  if_b	jmp	#LR__0668
04c90                 | LR__0669
04c90     B8 FE 9F FD | 	jmp	#LR__0660
04c94                 | LR__0670
04c94     00 B8 0E F2 | 	cmp	local10, #0 wz
04c98     00 B6 0E A2 |  if_e	cmp	local09, #0 wz
04c9c     00 F8 3F AF 
04ca0     00 76 06 A6 |  if_e	mov	result1, ##2146435072
04ca4     5C 00 90 AD |  if_e	jmp	#LR__0675
04ca8     57 97 02 F6 | 	mov	arg04, local05
04cac     08 96 46 F5 | 	or	arg04, #8
04cb0     00 90 06 F6 | 	mov	arg01, #0
04cb4     00 92 06 F6 | 	mov	arg02, #0
04cb8     00 94 06 F6 | 	mov	arg03, #0
04cbc     A8 19 B0 FD | 	call	#__system__pack_0176
04cc0     40 00 90 FD | 	jmp	#LR__0675
04cc4                 | LR__0671
04cc4     00 B6 0E F2 | 	cmp	local09, #0 wz
04cc8     20 00 90 AD |  if_e	jmp	#LR__0674
04ccc     01 B6 66 F0 | 	shl	local09, #1
04cd0     D7 0A 48 FB | 	callpa	#(@LR__0673-@LR__0672)>>2,fcache_load_ptr_
04cd4                 | LR__0672
04cd4     00 40 00 FF 
04cd8     00 B6 16 F2 | 	cmp	local09, ##8388608 wc
04cdc     01 B8 86 C1 |  if_b	sub	local10, #1
04ce0     01 B6 66 C0 |  if_b	shl	local09, #1
04ce4     EC FF 9F CD |  if_b	jmp	#LR__0672
04ce8                 | LR__0673
04ce8     6C FE 9F FD | 	jmp	#LR__0661
04cec                 | LR__0674
04cec     02 AE 46 F5 | 	or	local05, #2
04cf0     00 90 06 F6 | 	mov	arg01, #0
04cf4     00 92 06 F6 | 	mov	arg02, #0
04cf8     00 94 06 F6 | 	mov	arg03, #0
04cfc     57 97 02 F6 | 	mov	arg04, local05
04d00     64 19 B0 FD | 	call	#__system__pack_0176
04d04                 | LR__0675
04d04     E7 F0 03 F6 | 	mov	ptra, fp
04d08     F2 00 A0 FD | 	call	#popregs_
04d0c                 | __system___float_div_ret
04d0c     2D 00 64 FD | 	ret
04d10                 | 
04d10                 | __system___float_cmp
04d10     00 C0 3F FF 
04d14     01 90 56 F2 | 	cmps	arg01, ##2139095041 wc
04d18     00 C0 3F CF 
04d1c     01 92 56 C2 |  if_b	cmps	arg02, ##2139095041 wc
04d20     4A 77 02 36 |  if_ae	mov	result1, arg03
04d24     78 00 90 3D |  if_ae	jmp	#__system___float_cmp_ret
04d28     00 C0 7F FF 
04d2c     01 90 16 F2 | 	cmp	arg01, ##-8388607 wc
04d30     00 C0 7F CF 
04d34     01 90 16 C2 |  if_b	cmp	arg01, ##-8388607 wc
04d38     4A 77 02 36 |  if_ae	mov	result1, arg03
04d3c     60 00 90 3D |  if_ae	jmp	#__system___float_cmp_ret
04d40     00 90 56 F2 | 	cmps	arg01, #0 wc
04d44     2C 00 90 3D |  if_ae	jmp	#LR__0680
04d48     00 92 56 F2 | 	cmps	arg02, #0 wc
04d4c     49 77 02 C6 |  if_b	mov	result1, arg02
04d50     48 77 82 C1 |  if_b	sub	result1, arg01
04d54     48 00 90 CD |  if_b	jmp	#__system___float_cmp_ret
04d58     00 92 0E F2 | 	cmp	arg02, #0 wz
04d5c     00 00 40 AF 
04d60     00 90 0E A2 |  if_e	cmp	arg01, ##-2147483648 wz
04d64     00 76 06 A6 |  if_e	mov	result1, #0
04d68     34 00 90 AD |  if_e	jmp	#__system___float_cmp_ret
04d6c     01 76 66 F6 | 	neg	result1, #1
04d70     2C 00 90 FD | 	jmp	#__system___float_cmp_ret
04d74                 | LR__0680
04d74     00 92 56 F2 | 	cmps	arg02, #0 wc
04d78     1C 00 90 3D |  if_ae	jmp	#LR__0681
04d7c     00 90 0E F2 | 	cmp	arg01, #0 wz
04d80     00 00 40 AF 
04d84     00 92 0E A2 |  if_e	cmp	arg02, ##-2147483648 wz
04d88     00 76 06 A6 |  if_e	mov	result1, #0
04d8c     10 00 90 AD |  if_e	jmp	#__system___float_cmp_ret
04d90     01 76 06 F6 | 	mov	result1, #1
04d94     08 00 90 FD | 	jmp	#__system___float_cmp_ret
04d98                 | LR__0681
04d98     49 91 82 F1 | 	sub	arg01, arg02
04d9c     48 77 02 F6 | 	mov	result1, arg01
04da0                 | __system___float_cmp_ret
04da0     2D 00 64 FD | 	ret
04da4                 | 
04da4                 | __system___float_tointeger
04da4     02 CA 05 F6 | 	mov	COUNT_, #2
04da8     E8 00 A0 FD | 	call	#pushregs_
04dac     5C 00 B0 FD | 	call	#__system___float_Unpack
04db0     3B A7 02 F6 | 	mov	local01, result1
04db4     1F 78 56 F2 | 	cmps	result2, #31 wc
04db8     00 A6 0E 32 |  if_ae	cmp	local01, #0 wz
04dbc     1F A8 C6 19 |  if_a	decod	local02, #31
04dc0     1E A8 CE 29 |  if_nc_and_z	bmask	local02, #30
04dc4     54 7B 02 36 |  if_ae	mov	result3, local02
04dc8     30 00 90 3D |  if_ae	jmp	#LR__0691
04dcc     FF FF 7F FF 
04dd0     FF 79 56 F2 | 	cmps	result2, ##-1 wc
04dd4     00 7A 06 C6 |  if_b	mov	result3, #0
04dd8     20 00 90 CD |  if_b	jmp	#LR__0690
04ddc     02 7A 66 F0 | 	shl	result3, #2
04de0     1E A8 06 F6 | 	mov	local02, #30
04de4     3C A9 82 F1 | 	sub	local02, result2
04de8     54 7B 42 F0 | 	shr	result3, local02
04dec     49 7B 02 F1 | 	add	result3, arg02
04df0     01 7A 46 F0 | 	shr	result3, #1
04df4     00 A6 0E F2 | 	cmp	local01, #0 wz
04df8     3D 7B 62 56 |  if_ne	neg	result3, result3
04dfc                 | LR__0690
04dfc                 | LR__0691
04dfc     3D 77 02 F6 | 	mov	result1, result3
04e00     E7 F0 03 F6 | 	mov	ptra, fp
04e04     F2 00 A0 FD | 	call	#popregs_
04e08                 | __system___float_tointeger_ret
04e08     2D 00 64 FD | 	ret
04e0c                 | 
04e0c                 | __system___float_Unpack
04e0c     48 7D 02 F6 | 	mov	_var01, arg01
04e10     1F 7C 46 F0 | 	shr	_var01, #31
04e14     48 7F 02 F6 | 	mov	_var02, arg01
04e18     01 7E 66 F0 | 	shl	_var02, #1
04e1c     18 7E 4E F0 | 	shr	_var02, #24 wz
04e20     17 91 06 F4 | 	bitl	arg01, #279
04e24     06 90 66 50 |  if_ne	shl	arg01, #6
04e28     1D 90 26 54 |  if_ne	bith	arg01, #29
04e2c     1C 00 90 5D |  if_ne	jmp	#LR__0700
04e30     48 81 92 F7 | 	encod	_var03, arg01 wc
04e34     01 80 06 C1 |  if_b	add	_var03, #1
04e38     17 80 86 F1 | 	sub	_var03, #23
04e3c     40 7F 02 F6 | 	mov	_var02, _var03
04e40     07 78 06 F6 | 	mov	result2, #7
04e44     40 79 82 F1 | 	sub	result2, _var03
04e48     3C 91 62 F0 | 	shl	arg01, result2
04e4c                 | LR__0700
04e4c     7F 7E 86 F1 | 	sub	_var02, #127
04e50     48 7B 02 F6 | 	mov	result3, arg01
04e54     3E 77 02 F6 | 	mov	result1, _var01
04e58     3F 79 02 F6 | 	mov	result2, _var02
04e5c                 | __system___float_Unpack_ret
04e5c     2D 00 64 FD | 	ret
04e60                 | 
04e60                 | __system___float_Pack
04e60     00 7C 06 F6 | 	mov	_var01, #0
04e64     00 94 0E F2 | 	cmp	arg03, #0 wz
04e68     8C 00 90 AD |  if_e	jmp	#LR__0711
04e6c     4A 7F 92 F7 | 	encod	_var02, arg03 wc
04e70     01 7E 06 C1 |  if_b	add	_var02, #1
04e74     21 7C 06 F6 | 	mov	_var01, #33
04e78     3F 7D 82 F1 | 	sub	_var01, _var02
04e7c     3E 95 62 F0 | 	shl	arg03, _var01
04e80     03 7E 06 F6 | 	mov	_var02, #3
04e84     3E 7F 82 F1 | 	sub	_var02, _var01
04e88     3F 93 02 F1 | 	add	arg02, _var02
04e8c     49 81 02 F6 | 	mov	_var03, arg02
04e90     00 95 06 F1 | 	add	arg03, #256
04e94     4A 7F 02 F6 | 	mov	_var02, arg03
04e98     FF 7E 2E F5 | 	andn	_var02, #255 wz
04e9c     01 80 06 A1 |  if_e	add	_var03, #1
04ea0     7F 80 06 F1 | 	add	_var03, #127
04ea4     FF FF 7F FF 
04ea8     E9 81 46 F3 | 	fges	_var03, ##-23
04eac     FF 80 66 F3 | 	fles	_var03, #255
04eb0     01 80 56 F2 | 	cmps	_var03, #1 wc
04eb4     1C 00 90 3D |  if_ae	jmp	#LR__0710
04eb8     01 94 46 F0 | 	shr	arg03, #1
04ebc     1F 7E C6 F9 | 	decod	_var02, #31
04ec0     4A 7F 02 F1 | 	add	_var02, arg03
04ec4     40 81 62 F6 | 	neg	_var03, _var03
04ec8     40 7F 42 F0 | 	shr	_var02, _var03
04ecc     3F 95 02 F6 | 	mov	arg03, _var02
04ed0     00 80 06 F6 | 	mov	_var03, #0
04ed4                 | LR__0710
04ed4     48 77 02 F6 | 	mov	result1, arg01
04ed8     1F 76 66 F0 | 	shl	result1, #31
04edc     40 7F 02 F6 | 	mov	_var02, _var03
04ee0     17 7E 66 F0 | 	shl	_var02, #23
04ee4     3F 77 42 F5 | 	or	result1, _var02
04ee8     4A 83 02 F6 | 	mov	_var04, arg03
04eec     09 82 46 F0 | 	shr	_var04, #9
04ef0     41 77 42 F5 | 	or	result1, _var04
04ef4     04 00 90 FD | 	jmp	#__system___float_Pack_ret
04ef8                 | LR__0711
04ef8     3E 77 02 F6 | 	mov	result1, _var01
04efc                 | __system___float_Pack_ret
04efc     2D 00 64 FD | 	ret
04f00                 | 
04f00                 | __system___basic_print_float
04f00     05 CA 05 F6 | 	mov	COUNT_, #5
04f04     E8 00 A0 FD | 	call	#pushregs_
04f08     48 A7 02 F6 | 	mov	local01, arg01
04f0c     49 A9 02 F6 | 	mov	local02, arg02
04f10     4A AB 0A F6 | 	mov	local03, arg03 wz
04f14     4B AD 02 F6 | 	mov	local04, arg04
04f18     14 00 90 5D |  if_ne	jmp	#LR__0720
04f1c     23 AC 0E F2 | 	cmp	local04, #35 wz
04f20     80 02 10 AF 
04f24     00 AE 06 A6 |  if_e	mov	local05, ##537198592
04f28     1D AE C6 59 |  if_ne	decod	local05, #29
04f2c     57 AB 02 F6 | 	mov	local03, local05
04f30                 | LR__0720
04f30     53 91 02 F6 | 	mov	arg01, local01
04f34     EC 16 B0 FD | 	call	#__system___gettxfunc
04f38     3B AF 0A F6 | 	mov	local05, result1 wz
04f3c     00 76 06 A6 |  if_e	mov	result1, #0
04f40     57 91 02 56 |  if_ne	mov	arg01, local05
04f44     55 93 02 56 |  if_ne	mov	arg02, local03
04f48     54 95 02 56 |  if_ne	mov	arg03, local02
04f4c     56 97 02 56 |  if_ne	mov	arg04, local04
04f50     B8 ED BF 5D |  if_ne	call	#__system___fmtfloat
04f54     E7 F0 03 F6 | 	mov	ptra, fp
04f58     F2 00 A0 FD | 	call	#popregs_
04f5c                 | __system___basic_print_float_ret
04f5c     2D 00 64 FD | 	ret
04f60                 | 
04f60                 | __system____builtin_ilogb
04f60     A8 FE BF FD | 	call	#__system___float_Unpack
04f64     00 7A 0E F2 | 	cmp	result3, #0 wz
04f68     00 00 40 AF 
04f6c     01 76 06 A6 |  if_e	mov	result1, ##-2147483647
04f70     24 00 90 AD |  if_e	jmp	#LR__0731
04f74     80 78 0E F2 | 	cmp	result2, #128 wz
04f78     18 00 90 5D |  if_ne	jmp	#LR__0730
04f7c     00 00 10 FF 
04f80     00 7A 0E F2 | 	cmp	result3, ##536870912 wz
04f84     1E 76 CE A9 |  if_e	bmask	result1, #30
04f88     0C 00 90 AD |  if_e	jmp	#LR__0731
04f8c     1F 76 C6 F9 | 	decod	result1, #31
04f90     04 00 90 FD | 	jmp	#LR__0731
04f94                 | LR__0730
04f94     3C 77 02 F6 | 	mov	result1, result2
04f98                 | LR__0731
04f98                 | __system____builtin_ilogb_ret
04f98     2D 00 64 FD | 	ret
04f9c                 | 
04f9c                 | __system___float_pow_n
04f9c     05 CA 05 F6 | 	mov	COUNT_, #5
04fa0     E8 00 A0 FD | 	call	#pushregs_
04fa4     48 A7 02 F6 | 	mov	local01, arg01
04fa8     49 A9 02 F6 | 	mov	local02, arg02
04fac     4A AB 02 F6 | 	mov	local03, arg03
04fb0     00 AA 56 F2 | 	cmps	local03, #0 wc
04fb4     18 00 90 3D |  if_ae	jmp	#LR__0740
04fb8     01 AC 06 F6 | 	mov	local04, #1
04fbc     55 AB 62 F6 | 	neg	local03, local03
04fc0     00 AA 56 F2 | 	cmps	local03, #0 wc
04fc4     00 76 06 C6 |  if_b	mov	result1, #0
04fc8     94 00 90 CD |  if_b	jmp	#LR__0748
04fcc     04 00 90 FD | 	jmp	#LR__0741
04fd0                 | LR__0740
04fd0     00 AC 06 F6 | 	mov	local04, #0
04fd4                 | LR__0741
04fd4     00 C0 1F FF 
04fd8     00 AE 06 F6 | 	mov	local05, ##1065353216
04fdc                 | LR__0742
04fdc     01 AA 56 F2 | 	cmps	local03, #1 wc
04fe0     30 00 90 CD |  if_b	jmp	#LR__0744
04fe4     01 AA CE F7 | 	test	local03, #1 wz
04fe8     10 00 90 AD |  if_e	jmp	#LR__0743
04fec     57 91 02 F6 | 	mov	arg01, local05
04ff0     54 93 02 F6 | 	mov	arg02, local02
04ff4     E4 F8 BF FD | 	call	#__system___float_mul
04ff8     3B AF 02 F6 | 	mov	local05, result1
04ffc                 | LR__0743
04ffc     01 AA C6 F0 | 	sar	local03, #1
05000     54 91 02 F6 | 	mov	arg01, local02
05004     54 93 02 F6 | 	mov	arg02, local02
05008     D0 F8 BF FD | 	call	#__system___float_mul
0500c     3B A9 02 F6 | 	mov	local02, result1
05010     C8 FF 9F FD | 	jmp	#LR__0742
05014                 | LR__0744
05014     00 AC 0E F2 | 	cmp	local04, #0 wz
05018     14 00 90 AD |  if_e	jmp	#LR__0745
0501c     53 91 02 F6 | 	mov	arg01, local01
05020     57 93 02 F6 | 	mov	arg02, local05
05024     B8 FA BF FD | 	call	#__system___float_div
05028     3B AF 02 F6 | 	mov	local05, result1
0502c     2C 00 90 FD | 	jmp	#LR__0747
05030                 | LR__0745
05030     53 91 02 F6 | 	mov	arg01, local01
05034     00 C0 1F FF 
05038     00 92 06 F6 | 	mov	arg02, ##1065353216
0503c     01 94 06 F6 | 	mov	arg03, #1
05040     CC FC BF FD | 	call	#__system___float_cmp
05044     00 76 0E F2 | 	cmp	result1, #0 wz
05048     10 00 90 AD |  if_e	jmp	#LR__0746
0504c     53 91 02 F6 | 	mov	arg01, local01
05050     57 93 02 F6 | 	mov	arg02, local05
05054     84 F8 BF FD | 	call	#__system___float_mul
05058     3B AF 02 F6 | 	mov	local05, result1
0505c                 | LR__0746
0505c                 | LR__0747
0505c     57 77 02 F6 | 	mov	result1, local05
05060                 | LR__0748
05060     E7 F0 03 F6 | 	mov	ptra, fp
05064     F2 00 A0 FD | 	call	#popregs_
05068                 | __system___float_pow_n_ret
05068     2D 00 64 FD | 	ret
0506c                 | 
0506c                 | __system___gc_ptrs
0506c     2C 7D 02 F6 | 	mov	_var01, __heap_ptr
05070     3E 7F 02 F6 | 	mov	_var02, _var01
05074     BB 00 00 FF 
05078     F8 7E 06 F1 | 	add	_var02, ##95992
0507c     3E 79 0A FB | 	rdlong	result2, _var01 wz
05080     74 00 90 5D |  if_ne	jmp	#LR__0750
05084     3F 79 02 F6 | 	mov	result2, _var02
05088     3E 79 82 F1 | 	sub	result2, _var01
0508c     3E 03 58 FC | 	wrword	#1, _var01
05090     3E 77 02 F6 | 	mov	result1, _var01
05094     02 76 06 F1 | 	add	result1, #2
05098     36 00 80 FF 
0509c     3B 21 59 FC | 	wrword	##27792, result1
050a0     3E 77 02 F6 | 	mov	result1, _var01
050a4     04 76 06 F1 | 	add	result1, #4
050a8     3B 01 58 FC | 	wrword	#0, result1
050ac     3E 77 02 F6 | 	mov	result1, _var01
050b0     06 76 06 F1 | 	add	result1, #6
050b4     3B 03 58 FC | 	wrword	#1, result1
050b8     10 7C 06 F1 | 	add	_var01, #16
050bc     3C 79 52 F6 | 	abs	result2, result2 wc
050c0     04 78 46 F0 | 	shr	result2, #4
050c4     3C 79 82 F6 | 	negc	result2, result2
050c8     3E 79 52 FC | 	wrword	result2, _var01
050cc     3E 79 02 F6 | 	mov	result2, _var01
050d0     02 78 06 F1 | 	add	result2, #2
050d4     36 00 80 FF 
050d8     3C 1F 59 FC | 	wrword	##27791, result2
050dc     3E 79 02 F6 | 	mov	result2, _var01
050e0     04 78 06 F1 | 	add	result2, #4
050e4     3C 01 58 FC | 	wrword	#0, result2
050e8     3E 79 02 F6 | 	mov	result2, _var01
050ec     06 78 06 F1 | 	add	result2, #6
050f0     3C 01 58 FC | 	wrword	#0, result2
050f4     10 7C 86 F1 | 	sub	_var01, #16
050f8                 | LR__0750
050f8     3E 77 02 F6 | 	mov	result1, _var01
050fc     3F 79 02 F6 | 	mov	result2, _var02
05100                 | __system___gc_ptrs_ret
05100     2D 00 64 FD | 	ret
05104                 | 
05104                 | __system___gc_tryalloc
05104     0B CA 05 F6 | 	mov	COUNT_, #11
05108     E8 00 A0 FD | 	call	#pushregs_
0510c     48 A7 02 F6 | 	mov	local01, arg01
05110     49 A9 02 F6 | 	mov	local02, arg02
05114     54 FF BF FD | 	call	#__system___gc_ptrs
05118     3B AB 02 F6 | 	mov	local03, result1
0511c     3C AD 02 F6 | 	mov	local04, result2
05120     55 AF 02 F6 | 	mov	local05, local03
05124     00 B0 06 F6 | 	mov	local06, #0
05128     D7 1E 48 FB | 	callpa	#(@LR__0761-@LR__0760)>>2,fcache_load_ptr_
0512c                 | LR__0760
0512c     57 B3 02 F6 | 	mov	local07, local05
05130     06 AE 06 F1 | 	add	local05, #6
05134     57 93 EA FA | 	rdword	arg02, local05 wz
05138     55 91 02 F6 | 	mov	arg01, local03
0513c     00 76 06 A6 |  if_e	mov	result1, #0
05140     04 92 66 50 |  if_ne	shl	arg02, #4
05144     49 91 02 51 |  if_ne	add	arg01, arg02
05148     48 77 02 56 |  if_ne	mov	result1, arg01
0514c     3B AF 0A F6 | 	mov	local05, result1 wz
05150     57 B1 E2 5A |  if_ne	rdword	local06, local05
05154     00 AE 0E F2 | 	cmp	local05, #0 wz
05158     56 AF 52 52 |  if_ne	cmps	local05, local04 wc
0515c     08 00 90 1D |  if_a	jmp	#LR__0762
05160     58 A7 5A 52 |  if_ne	cmps	local01, local06 wcz
05164     C4 FF 9F 1D |  if_a	jmp	#LR__0760
05168                 | LR__0761
05168                 | LR__0762
05168     00 AE 0E F2 | 	cmp	local05, #0 wz
0516c     57 77 02 A6 |  if_e	mov	result1, local05
05170     3C 01 90 AD |  if_e	jmp	#LR__0765
05174     57 79 02 F6 | 	mov	result2, local05
05178     06 78 06 F1 | 	add	result2, #6
0517c     3C B5 E2 FA | 	rdword	local08, result2
05180     58 A7 52 F2 | 	cmps	local01, local06 wc
05184     C0 00 90 3D |  if_ae	jmp	#LR__0764
05188     57 A7 52 FC | 	wrword	local01, local05
0518c     57 91 02 F6 | 	mov	arg01, local05
05190     53 B5 02 F6 | 	mov	local08, local01
05194     04 B4 66 F0 | 	shl	local08, #4
05198     5A 91 02 F1 | 	add	arg01, local08
0519c     53 B1 82 F1 | 	sub	local06, local01
051a0     48 B1 52 FC | 	wrword	local06, arg01
051a4     48 B5 02 F6 | 	mov	local08, arg01
051a8     02 B4 06 F1 | 	add	local08, #2
051ac     36 00 80 FF 
051b0     5A 1F 59 FC | 	wrword	##27791, local08
051b4     57 93 0A F6 | 	mov	arg02, local05 wz
051b8     00 76 06 A6 |  if_e	mov	result1, #0
051bc     55 93 82 51 |  if_ne	sub	arg02, local03
051c0     04 92 46 50 |  if_ne	shr	arg02, #4
051c4     49 77 02 56 |  if_ne	mov	result1, arg02
051c8     48 B5 02 F6 | 	mov	local08, arg01
051cc     04 B4 06 F1 | 	add	local08, #4
051d0     5A 77 52 FC | 	wrword	result1, local08
051d4     57 B5 02 F6 | 	mov	local08, local05
051d8     06 B4 06 F1 | 	add	local08, #6
051dc     48 93 02 F6 | 	mov	arg02, arg01
051e0     5A B5 E2 FA | 	rdword	local08, local08
051e4     06 92 06 F1 | 	add	arg02, #6
051e8     49 B5 52 FC | 	wrword	local08, arg02
051ec     48 B7 02 F6 | 	mov	local09, arg01
051f0     5B 93 0A F6 | 	mov	arg02, local09 wz
051f4     00 76 06 A6 |  if_e	mov	result1, #0
051f8     55 93 82 51 |  if_ne	sub	arg02, local03
051fc     04 92 46 50 |  if_ne	shr	arg02, #4
05200     49 77 02 56 |  if_ne	mov	result1, arg02
05204     3B B5 02 F6 | 	mov	local08, result1
05208     48 B9 EA FA | 	rdword	local10, arg01 wz
0520c     00 76 06 A6 |  if_e	mov	result1, #0
05210     04 B8 66 50 |  if_ne	shl	local10, #4
05214     5C 91 02 51 |  if_ne	add	arg01, local10
05218     48 77 02 56 |  if_ne	mov	result1, arg01
0521c     3B BB 0A F6 | 	mov	local11, result1 wz
05220     24 00 90 AD |  if_e	jmp	#LR__0763
05224     56 BB 52 F2 | 	cmps	local11, local04 wc
05228     1C 00 90 3D |  if_ae	jmp	#LR__0763
0522c     5B 93 0A F6 | 	mov	arg02, local09 wz
05230     00 76 06 A6 |  if_e	mov	result1, #0
05234     55 93 82 51 |  if_ne	sub	arg02, local03
05238     04 92 46 50 |  if_ne	shr	arg02, #4
0523c     49 77 02 56 |  if_ne	mov	result1, arg02
05240     04 BA 06 F1 | 	add	local11, #4
05244     5D 77 52 FC | 	wrword	result1, local11
05248                 | LR__0763
05248                 | LR__0764
05248     06 B2 06 F1 | 	add	local07, #6
0524c     59 B5 52 FC | 	wrword	local08, local07
05250     36 00 00 FF 
05254     80 B6 06 F6 | 	mov	local09, ##27776
05258     54 B7 42 F5 | 	or	local09, local02
0525c     00 76 06 F6 | 	mov	result1, #0
05260     01 76 62 FD | 	cogid	result1
05264     3B B7 42 F5 | 	or	local09, result1
05268     57 BB 02 F6 | 	mov	local11, local05
0526c     02 BA 06 F1 | 	add	local11, #2
05270     5D B7 52 FC | 	wrword	local09, local11
05274     55 B7 02 F6 | 	mov	local09, local03
05278     08 B6 06 F1 | 	add	local09, #8
0527c     57 BB 02 F6 | 	mov	local11, local05
05280     5B B7 E2 FA | 	rdword	local09, local09
05284     06 BA 06 F1 | 	add	local11, #6
05288     5D B7 52 FC | 	wrword	local09, local11
0528c     57 93 0A F6 | 	mov	arg02, local05 wz
05290     00 76 06 A6 |  if_e	mov	result1, #0
05294     55 93 82 51 |  if_ne	sub	arg02, local03
05298     04 92 46 50 |  if_ne	shr	arg02, #4
0529c     49 77 02 56 |  if_ne	mov	result1, arg02
052a0     08 AA 06 F1 | 	add	local03, #8
052a4     55 77 52 FC | 	wrword	result1, local03
052a8     08 AE 06 F1 | 	add	local05, #8
052ac     57 77 02 F6 | 	mov	result1, local05
052b0                 | LR__0765
052b0     E7 F0 03 F6 | 	mov	ptra, fp
052b4     F2 00 A0 FD | 	call	#popregs_
052b8                 | __system___gc_tryalloc_ret
052b8     2D 00 64 FD | 	ret
052bc                 | 
052bc                 | __system___gc_alloc_managed
052bc     01 CA 05 F6 | 	mov	COUNT_, #1
052c0     E8 00 A0 FD | 	call	#pushregs_
052c4     48 A7 02 F6 | 	mov	local01, arg01
052c8     00 92 06 F6 | 	mov	arg02, #0
052cc     1C 00 B0 FD | 	call	#__system___gc_doalloc
052d0     3B 93 0A F6 | 	mov	arg02, result1 wz
052d4     01 A6 56 A2 |  if_e	cmps	local01, #1 wc
052d8     00 76 06 26 |  if_nc_and_z	mov	result1, #0
052dc     49 77 02 D6 |  if_c_or_nz	mov	result1, arg02
052e0     E7 F0 03 F6 | 	mov	ptra, fp
052e4     F2 00 A0 FD | 	call	#popregs_
052e8                 | __system___gc_alloc_managed_ret
052e8     2D 00 64 FD | 	ret
052ec                 | 
052ec                 | __system___gc_doalloc
052ec     06 CA 05 F6 | 	mov	COUNT_, #6
052f0     E8 00 A0 FD | 	call	#pushregs_
052f4     48 A7 0A F6 | 	mov	local01, arg01 wz
052f8     49 A9 02 F6 | 	mov	local02, arg02
052fc     00 76 06 A6 |  if_e	mov	result1, #0
05300     84 00 90 AD |  if_e	jmp	#LR__0777
05304     17 A6 06 F1 | 	add	local01, #23
05308     0F A6 26 F5 | 	andn	local01, #15
0530c     04 A6 46 F0 | 	shr	local01, #4
05310     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
05314     1C 90 06 F1 | 	add	arg01, #28
05318     80 DE BF FD | 	call	#__system___lockmem
0531c     53 91 02 F6 | 	mov	arg01, local01
05320     54 93 02 F6 | 	mov	arg02, local02
05324     DC FD BF FD | 	call	#__system___gc_tryalloc
05328     3B AB 0A F6 | 	mov	local03, result1 wz
0532c     14 00 90 5D |  if_ne	jmp	#LR__0770
05330     64 03 B0 FD | 	call	#__system___gc_docollect
05334     53 91 02 F6 | 	mov	arg01, local01
05338     54 93 02 F6 | 	mov	arg02, local02
0533c     C4 FD BF FD | 	call	#__system___gc_tryalloc
05340     3B AB 02 F6 | 	mov	local03, result1
05344                 | LR__0770
05344     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
05348     1C 90 06 F1 | 	add	arg01, #28
0534c     48 01 68 FC | 	wrlong	#0, arg01
05350     00 AA 0E F2 | 	cmp	local03, #0 wz
05354     2C 00 90 AD |  if_e	jmp	#LR__0776
05358     04 A6 66 F0 | 	shl	local01, #4
0535c     08 A6 86 F1 | 	sub	local01, #8
05360     53 AD 52 F6 | 	abs	local04, local01 wc
05364     02 AC 46 F0 | 	shr	local04, #2
05368     56 AF 8A F6 | 	negc	local05, local04 wz
0536c     55 B1 02 F6 | 	mov	local06, local03
05370     10 00 90 AD |  if_e	jmp	#LR__0775
05374     D7 06 48 FB | 	callpa	#(@LR__0773-@LR__0771)>>2,fcache_load_ptr_
05378                 | LR__0771
05378     57 05 D8 FC | 	rep	@LR__0774, local05
0537c                 | LR__0772
0537c     58 01 68 FC | 	wrlong	#0, local06
05380     04 B0 06 F1 | 	add	local06, #4
05384                 | LR__0773
05384                 | LR__0774
05384                 | LR__0775
05384                 | LR__0776
05384     55 77 02 F6 | 	mov	result1, local03
05388                 | LR__0777
05388     E7 F0 03 F6 | 	mov	ptra, fp
0538c     F2 00 A0 FD | 	call	#popregs_
05390                 | __system___gc_doalloc_ret
05390     2D 00 64 FD | 	ret
05394                 | 
05394                 | __system___gc_isvalidptr
05394     F8 94 06 F4 | 	bitl	arg03, #248
05398     08 94 86 F1 | 	sub	arg03, #8
0539c     48 95 52 F2 | 	cmps	arg03, arg01 wc
053a0     08 00 90 CD |  if_b	jmp	#LR__0780
053a4     49 95 52 F2 | 	cmps	arg03, arg02 wc
053a8     08 00 90 CD |  if_b	jmp	#LR__0781
053ac                 | LR__0780
053ac     00 76 06 F6 | 	mov	result1, #0
053b0     38 00 90 FD | 	jmp	#__system___gc_isvalidptr_ret
053b4                 | LR__0781
053b4     4A 7D 02 F6 | 	mov	_var01, arg03
053b8     48 7D 62 F5 | 	xor	_var01, arg01
053bc     0F 7C CE F7 | 	test	_var01, #15 wz
053c0     00 76 06 56 |  if_ne	mov	result1, #0
053c4     24 00 90 5D |  if_ne	jmp	#__system___gc_isvalidptr_ret
053c8     4A 7D 02 F6 | 	mov	_var01, arg03
053cc     02 7C 06 F1 | 	add	_var01, #2
053d0     3E 7D E2 FA | 	rdword	_var01, _var01
053d4     7F 00 00 FF 
053d8     C0 7D 06 F5 | 	and	_var01, ##65472
053dc     36 00 00 FF 
053e0     80 7C 0E F2 | 	cmp	_var01, ##27776 wz
053e4     00 76 06 56 |  if_ne	mov	result1, #0
053e8     4A 77 02 A6 |  if_e	mov	result1, arg03
053ec                 | __system___gc_isvalidptr_ret
053ec     2D 00 64 FD | 	ret
053f0                 | 
053f0                 | __system___gc_free
053f0     48 95 02 F6 | 	mov	arg03, arg01
053f4     74 FC BF FD | 	call	#__system___gc_ptrs
053f8     3B 91 02 F6 | 	mov	arg01, result1
053fc     3C 93 02 F6 | 	mov	arg02, result2
05400     90 FF BF FD | 	call	#__system___gc_isvalidptr
05404     3B 93 0A F6 | 	mov	arg02, result1 wz
05408     20 00 90 AD |  if_e	jmp	#LR__0790
0540c     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
05410     1C 90 06 F1 | 	add	arg01, #28
05414     84 DD BF FD | 	call	#__system___lockmem
05418     49 91 02 F6 | 	mov	arg01, arg02
0541c     10 00 B0 FD | 	call	#__system___gc_dofree
05420     33 91 02 F6 | 	mov	arg01, ptr___system__dat__
05424     1C 90 06 F1 | 	add	arg01, #28
05428     48 01 68 FC | 	wrlong	#0, arg01
0542c                 | LR__0790
0542c                 | __system___gc_free_ret
0542c     2D 00 64 FD | 	ret
05430                 | 
05430                 | __system___gc_dofree
05430     06 CA 05 F6 | 	mov	COUNT_, #6
05434     E8 00 A0 FD | 	call	#pushregs_
05438     48 A7 02 F6 | 	mov	local01, arg01
0543c     2C FC BF FD | 	call	#__system___gc_ptrs
05440     3B A9 02 F6 | 	mov	local02, result1
05444     3C AB 02 F6 | 	mov	local03, result2
05448     53 93 02 F6 | 	mov	arg02, local01
0544c     02 92 06 F1 | 	add	arg02, #2
05450     36 00 80 FF 
05454     49 1F 59 FC | 	wrword	##27791, arg02
05458     53 AD 02 F6 | 	mov	local04, local01
0545c     53 91 02 F6 | 	mov	arg01, local01
05460     48 AF EA FA | 	rdword	local05, arg01 wz
05464     00 76 06 A6 |  if_e	mov	result1, #0
05468     04 AE 66 50 |  if_ne	shl	local05, #4
0546c     57 91 02 51 |  if_ne	add	arg01, local05
05470     48 77 02 56 |  if_ne	mov	result1, arg01
05474     3B B1 02 F6 | 	mov	local06, result1
05478     D7 24 48 FB | 	callpa	#(@LR__0801-@LR__0800)>>2,fcache_load_ptr_
0547c                 | LR__0800
0547c     04 AC 06 F1 | 	add	local04, #4
05480     56 93 EA FA | 	rdword	arg02, local04 wz
05484     54 91 02 F6 | 	mov	arg01, local02
05488     00 76 06 A6 |  if_e	mov	result1, #0
0548c     04 92 66 50 |  if_ne	shl	arg02, #4
05490     49 91 02 51 |  if_ne	add	arg01, arg02
05494     48 77 02 56 |  if_ne	mov	result1, arg01
05498     3B AD 0A F6 | 	mov	local04, result1 wz
0549c     24 00 90 AD |  if_e	jmp	#LR__0802
054a0     56 91 02 F6 | 	mov	arg01, local04
054a4     00 76 06 F6 | 	mov	result1, #0
054a8     02 90 06 F1 | 	add	arg01, #2
054ac     48 91 E2 FA | 	rdword	arg01, arg01
054b0     36 00 00 FF 
054b4     8F 90 0E F2 | 	cmp	arg01, ##27791 wz
054b8     01 76 66 A6 |  if_e	neg	result1, #1
054bc     00 76 0E F2 | 	cmp	result1, #0 wz
054c0     B8 FF 9F AD |  if_e	jmp	#LR__0800
054c4                 | LR__0801
054c4                 | LR__0802
054c4     00 AC 0E F2 | 	cmp	local04, #0 wz
054c8     54 AD 02 A6 |  if_e	mov	local04, local02
054cc     56 93 02 F6 | 	mov	arg02, local04
054d0     06 92 06 F1 | 	add	arg02, #6
054d4     53 91 02 F6 | 	mov	arg01, local01
054d8     49 93 E2 FA | 	rdword	arg02, arg02
054dc     06 90 06 F1 | 	add	arg01, #6
054e0     48 93 52 FC | 	wrword	arg02, arg01
054e4     53 93 0A F6 | 	mov	arg02, local01 wz
054e8     00 76 06 A6 |  if_e	mov	result1, #0
054ec     54 93 82 51 |  if_ne	sub	arg02, local02
054f0     04 92 46 50 |  if_ne	shr	arg02, #4
054f4     49 77 02 56 |  if_ne	mov	result1, arg02
054f8     56 93 02 F6 | 	mov	arg02, local04
054fc     06 92 06 F1 | 	add	arg02, #6
05500     49 77 52 FC | 	wrword	result1, arg02
05504     54 AD 0A F2 | 	cmp	local04, local02 wz
05508     A4 00 90 AD |  if_e	jmp	#LR__0805
0550c     56 91 02 F6 | 	mov	arg01, local04
05510     48 AF EA FA | 	rdword	local05, arg01 wz
05514     00 76 06 A6 |  if_e	mov	result1, #0
05518     04 AE 66 50 |  if_ne	shl	local05, #4
0551c     57 91 02 51 |  if_ne	add	arg01, local05
05520     48 77 02 56 |  if_ne	mov	result1, arg01
05524     53 77 0A F2 | 	cmp	result1, local01 wz
05528     84 00 90 5D |  if_ne	jmp	#LR__0804
0552c     56 B1 E2 FA | 	rdword	local06, local04
05530     53 93 E2 FA | 	rdword	arg02, local01
05534     49 B1 02 F1 | 	add	local06, arg02
05538     56 B1 52 FC | 	wrword	local06, local04
0553c     53 B1 02 F6 | 	mov	local06, local01
05540     02 B0 06 F1 | 	add	local06, #2
05544     58 01 58 FC | 	wrword	#0, local06
05548     53 91 02 F6 | 	mov	arg01, local01
0554c     48 AF EA FA | 	rdword	local05, arg01 wz
05550     00 76 06 A6 |  if_e	mov	result1, #0
05554     04 AE 66 50 |  if_ne	shl	local05, #4
05558     57 91 02 51 |  if_ne	add	arg01, local05
0555c     48 77 02 56 |  if_ne	mov	result1, arg01
05560     3B B1 02 F6 | 	mov	local06, result1
05564     55 B1 52 F2 | 	cmps	local06, local03 wc
05568     20 00 90 3D |  if_ae	jmp	#LR__0803
0556c     56 93 0A F6 | 	mov	arg02, local04 wz
05570     00 76 06 A6 |  if_e	mov	result1, #0
05574     54 93 82 51 |  if_ne	sub	arg02, local02
05578     04 92 46 50 |  if_ne	shr	arg02, #4
0557c     49 77 02 56 |  if_ne	mov	result1, arg02
05580     58 93 02 F6 | 	mov	arg02, local06
05584     04 92 06 F1 | 	add	arg02, #4
05588     49 77 52 FC | 	wrword	result1, arg02
0558c                 | LR__0803
0558c     53 93 02 F6 | 	mov	arg02, local01
05590     06 92 06 F1 | 	add	arg02, #6
05594     56 79 02 F6 | 	mov	result2, local04
05598     49 93 E2 FA | 	rdword	arg02, arg02
0559c     06 78 06 F1 | 	add	result2, #6
055a0     3C 93 52 FC | 	wrword	arg02, result2
055a4     06 A6 06 F1 | 	add	local01, #6
055a8     53 01 58 FC | 	wrword	#0, local01
055ac     56 A7 02 F6 | 	mov	local01, local04
055b0                 | LR__0804
055b0                 | LR__0805
055b0     53 91 02 F6 | 	mov	arg01, local01
055b4     48 AF EA FA | 	rdword	local05, arg01 wz
055b8     00 76 06 A6 |  if_e	mov	result1, #0
055bc     04 AE 66 50 |  if_ne	shl	local05, #4
055c0     57 91 02 51 |  if_ne	add	arg01, local05
055c4     48 77 02 56 |  if_ne	mov	result1, arg01
055c8     3B 93 0A F6 | 	mov	arg02, result1 wz
055cc     B8 00 90 AD |  if_e	jmp	#LR__0807
055d0     55 93 52 F2 | 	cmps	arg02, local03 wc
055d4     B0 00 90 3D |  if_ae	jmp	#LR__0807
055d8     49 91 02 F6 | 	mov	arg01, arg02
055dc     00 76 06 F6 | 	mov	result1, #0
055e0     02 90 06 F1 | 	add	arg01, #2
055e4     48 91 E2 FA | 	rdword	arg01, arg01
055e8     36 00 00 FF 
055ec     8F 90 0E F2 | 	cmp	arg01, ##27791 wz
055f0     01 76 66 A6 |  if_e	neg	result1, #1
055f4     00 76 0E F2 | 	cmp	result1, #0 wz
055f8     8C 00 90 AD |  if_e	jmp	#LR__0807
055fc     53 AD 02 F6 | 	mov	local04, local01
05600     56 B1 E2 FA | 	rdword	local06, local04
05604     49 91 02 F6 | 	mov	arg01, arg02
05608     48 A7 E2 FA | 	rdword	local01, arg01
0560c     53 B1 02 F1 | 	add	local06, local01
05610     56 B1 52 FC | 	wrword	local06, local04
05614     48 B1 02 F6 | 	mov	local06, arg01
05618     06 B0 06 F1 | 	add	local06, #6
0561c     56 A7 02 F6 | 	mov	local01, local04
05620     58 B1 E2 FA | 	rdword	local06, local06
05624     06 A6 06 F1 | 	add	local01, #6
05628     53 B1 52 FC | 	wrword	local06, local01
0562c     48 B1 02 F6 | 	mov	local06, arg01
05630     02 B0 06 F1 | 	add	local06, #2
05634     58 55 59 FC | 	wrword	#170, local06
05638     48 B1 02 F6 | 	mov	local06, arg01
0563c     06 B0 06 F1 | 	add	local06, #6
05640     58 01 58 FC | 	wrword	#0, local06
05644     48 AF EA FA | 	rdword	local05, arg01 wz
05648     00 76 06 A6 |  if_e	mov	result1, #0
0564c     04 AE 66 50 |  if_ne	shl	local05, #4
05650     57 91 02 51 |  if_ne	add	arg01, local05
05654     48 77 02 56 |  if_ne	mov	result1, arg01
05658     3B B1 0A F6 | 	mov	local06, result1 wz
0565c     28 00 90 AD |  if_e	jmp	#LR__0806
05660     55 B1 52 F2 | 	cmps	local06, local03 wc
05664     20 00 90 3D |  if_ae	jmp	#LR__0806
05668     56 93 0A F6 | 	mov	arg02, local04 wz
0566c     00 76 06 A6 |  if_e	mov	result1, #0
05670     54 93 82 51 |  if_ne	sub	arg02, local02
05674     04 92 46 50 |  if_ne	shr	arg02, #4
05678     49 77 02 56 |  if_ne	mov	result1, arg02
0567c     58 AD 02 F6 | 	mov	local04, local06
05680     04 AC 06 F1 | 	add	local04, #4
05684     56 77 52 FC | 	wrword	result1, local04
05688                 | LR__0806
05688                 | LR__0807
05688     58 77 02 F6 | 	mov	result1, local06
0568c     E7 F0 03 F6 | 	mov	ptra, fp
05690     F2 00 A0 FD | 	call	#popregs_
05694                 | __system___gc_dofree_ret
05694     2D 00 64 FD | 	ret
05698                 | 
05698                 | __system___gc_docollect
05698     05 CA 05 F6 | 	mov	COUNT_, #5
0569c     E8 00 A0 FD | 	call	#pushregs_
056a0     C8 F9 BF FD | 	call	#__system___gc_ptrs
056a4     3C A7 02 F6 | 	mov	local01, result2
056a8     3B A9 02 F6 | 	mov	local02, result1
056ac     54 91 02 F6 | 	mov	arg01, local02
056b0     48 AB EA FA | 	rdword	local03, arg01 wz
056b4     00 76 06 A6 |  if_e	mov	result1, #0
056b8     04 AA 66 50 |  if_ne	shl	local03, #4
056bc     55 91 02 51 |  if_ne	add	arg01, local03
056c0     48 77 02 56 |  if_ne	mov	result1, arg01
056c4     3B AD 0A F6 | 	mov	local04, result1 wz
056c8     00 76 06 F6 | 	mov	result1, #0
056cc     01 76 62 FD | 	cogid	result1
056d0     3B AF 02 F6 | 	mov	local05, result1
056d4     48 00 90 AD |  if_e	jmp	#LR__0812
056d8     D7 22 48 FB | 	callpa	#(@LR__0811-@LR__0810)>>2,fcache_load_ptr_
056dc                 | LR__0810
056dc     53 AD 52 F2 | 	cmps	local04, local01 wc
056e0     3C 00 90 3D |  if_ae	jmp	#LR__0812
056e4     56 93 02 F6 | 	mov	arg02, local04
056e8     02 92 06 F1 | 	add	arg02, #2
056ec     49 93 E2 FA | 	rdword	arg02, arg02
056f0     20 92 26 F5 | 	andn	arg02, #32
056f4     56 91 02 F6 | 	mov	arg01, local04
056f8     02 90 06 F1 | 	add	arg01, #2
056fc     48 93 52 FC | 	wrword	arg02, arg01
05700     56 91 02 F6 | 	mov	arg01, local04
05704     48 AB EA FA | 	rdword	local03, arg01 wz
05708     00 76 06 A6 |  if_e	mov	result1, #0
0570c     04 AA 66 50 |  if_ne	shl	local03, #4
05710     55 91 02 51 |  if_ne	add	arg01, local03
05714     48 77 02 56 |  if_ne	mov	result1, arg01
05718     3B AD 0A F6 | 	mov	local04, result1 wz
0571c     BC FF 9F 5D |  if_ne	jmp	#LR__0810
05720                 | LR__0811
05720                 | LR__0812
05720     00 AA 06 F6 | 	mov	local03, #0
05724     00 90 06 F6 | 	mov	arg01, #0
05728     48 DA BF FD | 	call	#__system____topofstack
0572c     3B 93 02 F6 | 	mov	arg02, result1
05730     55 91 02 F6 | 	mov	arg01, local03
05734     90 00 B0 FD | 	call	#__system___gc_markhub
05738     1C 01 B0 FD | 	call	#__system___gc_markcog
0573c     54 91 02 F6 | 	mov	arg01, local02
05740     48 AB EA FA | 	rdword	local03, arg01 wz
05744     00 76 06 A6 |  if_e	mov	result1, #0
05748     04 AA 66 50 |  if_ne	shl	local03, #4
0574c     55 91 02 51 |  if_ne	add	arg01, local03
05750     48 77 02 56 |  if_ne	mov	result1, arg01
05754     3B A9 0A F6 | 	mov	local02, result1 wz
05758     60 00 90 AD |  if_e	jmp	#LR__0816
0575c                 | LR__0813
0575c     54 AD 02 F6 | 	mov	local04, local02
05760     56 91 02 F6 | 	mov	arg01, local04
05764     48 AB EA FA | 	rdword	local03, arg01 wz
05768     00 76 06 A6 |  if_e	mov	result1, #0
0576c     04 AA 66 50 |  if_ne	shl	local03, #4
05770     55 91 02 51 |  if_ne	add	arg01, local03
05774     48 77 02 56 |  if_ne	mov	result1, arg01
05778     3B A9 02 F6 | 	mov	local02, result1
0577c     56 93 02 F6 | 	mov	arg02, local04
05780     02 92 06 F1 | 	add	arg02, #2
05784     49 93 E2 FA | 	rdword	arg02, arg02
05788     20 92 CE F7 | 	test	arg02, #32 wz
0578c     10 92 CE A7 |  if_e	test	arg02, #16 wz
05790     1C 00 90 5D |  if_ne	jmp	#LR__0815
05794     49 93 42 F8 | 	getnib	arg02, arg02, #0
05798     57 93 0A F2 | 	cmp	arg02, local05 wz
0579c     0E 92 0E 52 |  if_ne	cmp	arg02, #14 wz
057a0     0C 00 90 5D |  if_ne	jmp	#LR__0814
057a4     56 91 02 F6 | 	mov	arg01, local04
057a8     84 FC BF FD | 	call	#__system___gc_dofree
057ac     3B A9 02 F6 | 	mov	local02, result1
057b0                 | LR__0814
057b0                 | LR__0815
057b0     00 A8 0E F2 | 	cmp	local02, #0 wz
057b4     53 A9 52 52 |  if_ne	cmps	local02, local01 wc
057b8     A0 FF 9F 4D |  if_c_and_nz	jmp	#LR__0813
057bc                 | LR__0816
057bc     E7 F0 03 F6 | 	mov	ptra, fp
057c0     F2 00 A0 FD | 	call	#popregs_
057c4                 | __system___gc_docollect_ret
057c4     2D 00 64 FD | 	ret
057c8                 | 
057c8                 | __system___gc_markhub
057c8     04 CA 05 F6 | 	mov	COUNT_, #4
057cc     E8 00 A0 FD | 	call	#pushregs_
057d0     48 A7 02 F6 | 	mov	local01, arg01
057d4     49 A9 02 F6 | 	mov	local02, arg02
057d8     90 F8 BF FD | 	call	#__system___gc_ptrs
057dc     3B AB 02 F6 | 	mov	local03, result1
057e0     3C AD 02 F6 | 	mov	local04, result2
057e4                 | LR__0820
057e4     54 A7 52 F2 | 	cmps	local01, local02 wc
057e8     60 00 90 3D |  if_ae	jmp	#LR__0821
057ec     53 95 02 FB | 	rdlong	arg03, local01
057f0     04 A6 06 F1 | 	add	local01, #4
057f4     56 93 02 F6 | 	mov	arg02, local04
057f8     55 91 02 F6 | 	mov	arg01, local03
057fc     94 FB BF FD | 	call	#__system___gc_isvalidptr
05800     3B 95 0A F6 | 	mov	arg03, result1 wz
05804     DC FF 9F AD |  if_e	jmp	#LR__0820
05808     4A 91 02 F6 | 	mov	arg01, arg03
0580c     00 76 06 F6 | 	mov	result1, #0
05810     02 90 06 F1 | 	add	arg01, #2
05814     48 91 E2 FA | 	rdword	arg01, arg01
05818     36 00 00 FF 
0581c     8F 90 0E F2 | 	cmp	arg01, ##27791 wz
05820     01 76 66 A6 |  if_e	neg	result1, #1
05824     00 76 0E F2 | 	cmp	result1, #0 wz
05828     B8 FF 9F 5D |  if_ne	jmp	#LR__0820
0582c     4A 79 02 F6 | 	mov	result2, arg03
05830     02 78 06 F1 | 	add	result2, #2
05834     3C 79 E2 FA | 	rdword	result2, result2
05838     0F 78 26 F5 | 	andn	result2, #15
0583c     2E 78 46 F5 | 	or	result2, #46
05840     02 94 06 F1 | 	add	arg03, #2
05844     4A 79 52 FC | 	wrword	result2, arg03
05848     98 FF 9F FD | 	jmp	#LR__0820
0584c                 | LR__0821
0584c     E7 F0 03 F6 | 	mov	ptra, fp
05850     F2 00 A0 FD | 	call	#popregs_
05854                 | __system___gc_markhub_ret
05854     2D 00 64 FD | 	ret
05858                 | 
05858                 | __system___gc_markcog
05858     04 CA 05 F6 | 	mov	COUNT_, #4
0585c     E8 00 A0 FD | 	call	#pushregs_
05860     08 F8 BF FD | 	call	#__system___gc_ptrs
05864     3B A7 02 F6 | 	mov	local01, result1
05868     3C A9 02 F6 | 	mov	local02, result2
0586c     EF AB 06 F6 | 	mov	local03, #495
05870                 | LR__0830
05870                 | 	'.live	local03
05870     00 AA 96 F9 | 	alts	local03, #0
05874     55 AD 02 F6 | 	mov	local04, local03
05878     53 91 02 F6 | 	mov	arg01, local01
0587c     54 93 02 F6 | 	mov	arg02, local02
05880     56 95 02 F6 | 	mov	arg03, local04
05884     0C FB BF FD | 	call	#__system___gc_isvalidptr
05888     00 76 0E F2 | 	cmp	result1, #0 wz
0588c     18 00 90 AD |  if_e	jmp	#LR__0831
05890     3B AD 02 F6 | 	mov	local04, result1
05894     02 AC 06 F1 | 	add	local04, #2
05898     56 AD E2 FA | 	rdword	local04, local04
0589c     20 AC 46 F5 | 	or	local04, #32
058a0     02 76 06 F1 | 	add	result1, #2
058a4     3B AD 52 FC | 	wrword	local04, result1
058a8                 | LR__0831
058a8     01 AA 86 F1 | 	sub	local03, #1
058ac     00 AA 56 F2 | 	cmps	local03, #0 wc
058b0     BC FF 9F 3D |  if_ae	jmp	#LR__0830
058b4     E7 F0 03 F6 | 	mov	ptra, fp
058b8     F2 00 A0 FD | 	call	#popregs_
058bc                 | __system___gc_markcog_ret
058bc     2D 00 64 FD | 	ret
058c0                 | 
058c0                 | __system___get_vfs_file_handle
058c0     01 CA 05 F6 | 	mov	COUNT_, #1
058c4     E8 00 A0 FD | 	call	#pushregs_
058c8     64 E2 BF FD | 	call	#__system___find_free_file
058cc     3B A7 02 F6 | 	mov	local01, result1
058d0     00 A6 56 F2 | 	cmps	local01, #0 wc
058d4     34 A6 06 3D |  if_ae	qmul	local01, #52
058d8     00 76 06 C6 |  if_b	mov	result1, #0
058dc     33 A7 02 36 |  if_ae	mov	local01, ptr___system__dat__
058e0     01 00 00 3F 
058e4     E0 A6 06 31 |  if_ae	add	local01, ##736
058e8     18 76 62 3D |  if_ae	getqx	result1
058ec     53 77 02 31 |  if_ae	add	result1, local01
058f0     E7 F0 03 F6 | 	mov	ptra, fp
058f4     F2 00 A0 FD | 	call	#popregs_
058f8                 | __system___get_vfs_file_handle_ret
058f8     2D 00 64 FD | 	ret
058fc                 | 
058fc                 | __system___closeraw
058fc     05 CA 05 F6 | 	mov	COUNT_, #5
05900     E8 00 A0 FD | 	call	#pushregs_
05904     48 A7 02 F6 | 	mov	local01, arg01
05908     00 A8 06 F6 | 	mov	local02, #0
0590c     08 A6 06 F1 | 	add	local01, #8
05910     53 77 0A FB | 	rdlong	result1, local01 wz
05914     08 A6 86 F1 | 	sub	local01, #8
05918     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0591c     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
05920     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
05924     01 76 66 A6 |  if_e	neg	result1, #1
05928     A8 00 90 AD |  if_e	jmp	#LR__0842
0592c     2C A6 06 F1 | 	add	local01, #44
05930     53 77 0A FB | 	rdlong	result1, local01 wz
05934     2C A6 86 F1 | 	sub	local01, #44
05938     38 00 90 AD |  if_e	jmp	#LR__0840
0593c     2C A6 06 F1 | 	add	local01, #44
05940     53 AB 02 FB | 	rdlong	local03, local01
05944     55 AD 02 F6 | 	mov	local04, local03
05948     2C A6 86 F1 | 	sub	local01, #44
0594c     13 AC 46 F7 | 	zerox	local04, #19
05950     14 AA 46 F0 | 	shr	local03, #20
05954     02 AA 66 F0 | 	shl	local03, #2
05958     2D AB 02 F1 | 	add	local03, __methods__
0595c     55 AB 02 FB | 	rdlong	local03, local03
05960     53 91 02 F6 | 	mov	arg01, local01
05964     31 AF 02 F6 | 	mov	local05, objptr
05968     56 63 02 F6 | 	mov	objptr, local04
0596c     2D AA 62 FD | 	call	local03
05970     57 63 02 F6 | 	mov	objptr, local05
05974                 | LR__0840
05974     24 A6 06 F1 | 	add	local01, #36
05978     53 AF 0A FB | 	rdlong	local05, local01 wz
0597c     24 A6 86 F1 | 	sub	local01, #36
05980     3C 00 90 AD |  if_e	jmp	#LR__0841
05984     24 A6 06 F1 | 	add	local01, #36
05988     53 AB 02 FB | 	rdlong	local03, local01
0598c     55 AD 02 F6 | 	mov	local04, local03
05990     24 A6 86 F1 | 	sub	local01, #36
05994     13 AC 46 F7 | 	zerox	local04, #19
05998     14 AA 46 F0 | 	shr	local03, #20
0599c     02 AA 66 F0 | 	shl	local03, #2
059a0     2D AB 02 F1 | 	add	local03, __methods__
059a4     55 AB 02 FB | 	rdlong	local03, local03
059a8     53 91 02 F6 | 	mov	arg01, local01
059ac     31 AF 02 F6 | 	mov	local05, objptr
059b0     56 63 02 F6 | 	mov	objptr, local04
059b4     2D AA 62 FD | 	call	local03
059b8     57 63 02 F6 | 	mov	objptr, local05
059bc     3B A9 02 F6 | 	mov	local02, result1
059c0                 | LR__0841
059c0     53 91 02 F6 | 	mov	arg01, local01
059c4     00 92 06 F6 | 	mov	arg02, #0
059c8     34 94 06 F6 | 	mov	arg03, #52
059cc     D8 00 A0 FD | 	call	#\builtin_bytefill_
059d0     54 77 02 F6 | 	mov	result1, local02
059d4                 | LR__0842
059d4     E7 F0 03 F6 | 	mov	ptra, fp
059d8     F2 00 A0 FD | 	call	#popregs_
059dc                 | __system___closeraw_ret
059dc     2D 00 64 FD | 	ret
059e0                 | 
059e0                 | __system___vfs_open_fat_handle
059e0     03 CA 05 F6 | 	mov	COUNT_, #3
059e4     E8 00 A0 FD | 	call	#pushregs_
059e8     48 A7 0A F6 | 	mov	local01, arg01 wz
059ec     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
059f0     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
059f4     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
059f8     00 76 06 A6 |  if_e	mov	result1, #0
059fc     80 00 90 AD |  if_e	jmp	#LR__0851
05a00     01 00 00 FF 
05a04     14 90 06 F6 | 	mov	arg01, ##532
05a08     B0 F8 BF FD | 	call	#__system___gc_alloc_managed
05a0c     3B A9 02 F6 | 	mov	local02, result1
05a10     01 00 00 FF 
05a14     34 90 06 F6 | 	mov	arg01, ##564
05a18     A0 F8 BF FD | 	call	#__system___gc_alloc_managed
05a1c     31 AB 02 F6 | 	mov	local03, objptr
05a20     54 63 02 F6 | 	mov	objptr, local02
05a24     01 00 00 FF 
05a28     10 62 06 F1 | 	add	objptr, ##528
05a2c     31 A7 62 FC | 	wrlong	local01, objptr
05a30                 | ' #line 4 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/diskio.cc"
05a30                 | ' 
05a30                 | ' 
05a30                 | ' vfs_file_t *fh;
05a30                 | ' 
05a30                 | ' DRESULT disk_sethandle(BYTE pdrv, vfs_file_t *fhandle) {
05a30                 | '     fh = fhandle;
05a30                 | '     return RES_OK;
05a30     71 00 00 FF 
05a34     20 93 06 F6 | 	mov	arg02, ##@LR__2166
05a38     3B 91 02 F6 | 	mov	arg01, result1
05a3c     00 94 06 F6 | 	mov	arg03, #0
05a40     54 63 02 F6 | 	mov	objptr, local02
05a44     CC 59 B0 FD | 	call	#_fatfs_cc_f_mount
05a48     55 63 02 F6 | 	mov	objptr, local03
05a4c     3B 91 0A F6 | 	mov	arg01, result1 wz
05a50     18 00 90 AD |  if_e	jmp	#LR__0850
05a54     48 91 6A F6 | 	neg	arg01, arg01 wz
05a58     20 66 06 F1 | 	add	ptr___system__dat__, #32
05a5c     33 91 62 FC | 	wrlong	arg01, ptr___system__dat__
05a60     20 66 86 F1 | 	sub	ptr___system__dat__, #32
05a64     00 76 06 F6 | 	mov	result1, #0
05a68     14 00 90 FD | 	jmp	#LR__0851
05a6c                 | LR__0850
05a6c     54 91 02 F6 | 	mov	arg01, local02
05a70     31 AB 02 F6 | 	mov	local03, objptr
05a74     54 63 02 F6 | 	mov	objptr, local02
05a78     08 80 B0 FD | 	call	#_fatfs_cc_get_vfs
05a7c     55 63 02 F6 | 	mov	objptr, local03
05a80                 | LR__0851
05a80     E7 F0 03 F6 | 	mov	ptra, fp
05a84     F2 00 A0 FD | 	call	#popregs_
05a88                 | __system___vfs_open_fat_handle_ret
05a88     2D 00 64 FD | 	ret
05a8c                 | 
05a8c                 | __system___vfs_open_sdcardx
05a8c     04 CA 05 F6 | 	mov	COUNT_, #4
05a90     E8 00 A0 FD | 	call	#pushregs_
05a94     38 0D B0 FD | 	call	#__system___sdmm_open
05a98     3B A7 0A F6 | 	mov	local01, result1 wz
05a9c     00 76 06 A6 |  if_e	mov	result1, #0
05aa0     4C 00 90 AD |  if_e	jmp	#LR__0861
05aa4     53 91 02 F6 | 	mov	arg01, local01
05aa8     34 FF BF FD | 	call	#__system___vfs_open_fat_handle
05aac     3B A9 0A F6 | 	mov	local02, result1 wz
05ab0     38 00 90 5D |  if_ne	jmp	#LR__0860
05ab4     24 A6 06 F1 | 	add	local01, #36
05ab8     53 AB 02 FB | 	rdlong	local03, local01
05abc     55 AD 02 F6 | 	mov	local04, local03
05ac0     24 A6 86 F1 | 	sub	local01, #36
05ac4     13 AC 46 F7 | 	zerox	local04, #19
05ac8     14 AA 46 F0 | 	shr	local03, #20
05acc     02 AA 66 F0 | 	shl	local03, #2
05ad0     2D AB 02 F1 | 	add	local03, __methods__
05ad4     55 AB 02 FB | 	rdlong	local03, local03
05ad8     53 91 02 F6 | 	mov	arg01, local01
05adc     31 A7 02 F6 | 	mov	local01, objptr
05ae0     56 63 02 F6 | 	mov	objptr, local04
05ae4     2D AA 62 FD | 	call	local03
05ae8     53 63 02 F6 | 	mov	objptr, local01
05aec                 | LR__0860
05aec     54 77 02 F6 | 	mov	result1, local02
05af0                 | LR__0861
05af0     E7 F0 03 F6 | 	mov	ptra, fp
05af4     F2 00 A0 FD | 	call	#popregs_
05af8                 | __system___vfs_open_sdcardx_ret
05af8     2D 00 64 FD | 	ret
05afc                 | 
05afc                 | __system____default_getc
05afc     03 CA 05 F6 | 	mov	COUNT_, #3
05b00     E8 00 A0 FD | 	call	#pushregs_
05b04     48 A7 02 F6 | 	mov	local01, arg01
05b08     53 A9 02 FB | 	rdlong	local02, local01
05b0c     08 A6 06 F1 | 	add	local01, #8
05b10     53 AB 02 FB | 	rdlong	local03, local01
05b14     08 A6 86 F1 | 	sub	local01, #8
05b18     08 AA CE F7 | 	test	local03, #8 wz
05b1c     53 91 02 56 |  if_ne	mov	arg01, local01
05b20     08 01 B0 5D |  if_ne	call	#__system____default_flush
05b24     08 A6 06 F1 | 	add	local01, #8
05b28     53 AB 02 FB | 	rdlong	local03, local01
05b2c     04 AA 46 F5 | 	or	local03, #4
05b30     53 AB 62 FC | 	wrlong	local03, local01
05b34     08 A6 86 F1 | 	sub	local01, #8
05b38     54 AB 0A FB | 	rdlong	local03, local02 wz
05b3c     0C 00 90 5D |  if_ne	jmp	#LR__0870
05b40     53 91 02 F6 | 	mov	arg01, local01
05b44     CC 0E B0 FD | 	call	#__system____default_filbuf
05b48     3B AB 02 F6 | 	mov	local03, result1
05b4c                 | LR__0870
05b4c     01 AA 56 F2 | 	cmps	local03, #1 wc
05b50     01 76 66 C6 |  if_b	neg	result1, #1
05b54     1C 00 90 CD |  if_b	jmp	#LR__0871
05b58     01 AA 86 F1 | 	sub	local03, #1
05b5c     54 AB 62 FC | 	wrlong	local03, local02
05b60     04 A8 06 F1 | 	add	local02, #4
05b64     54 AB 02 FB | 	rdlong	local03, local02
05b68     55 77 C2 FA | 	rdbyte	result1, local03
05b6c     01 AA 06 F1 | 	add	local03, #1
05b70     54 AB 62 FC | 	wrlong	local03, local02
05b74                 | LR__0871
05b74     E7 F0 03 F6 | 	mov	ptra, fp
05b78     F2 00 A0 FD | 	call	#popregs_
05b7c                 | __system____default_getc_ret
05b7c     2D 00 64 FD | 	ret
05b80                 | 
05b80                 | __system____default_putc
05b80     06 CA 05 F6 | 	mov	COUNT_, #6
05b84     E8 00 A0 FD | 	call	#pushregs_
05b88     48 A7 02 F6 | 	mov	local01, arg01
05b8c     49 A9 02 F6 | 	mov	local02, arg02
05b90     54 AB 02 FB | 	rdlong	local03, local02
05b94     08 A8 06 F1 | 	add	local02, #8
05b98     54 93 02 FB | 	rdlong	arg02, local02
05b9c     08 A8 86 F1 | 	sub	local02, #8
05ba0     04 92 CE F7 | 	test	arg02, #4 wz
05ba4     54 91 02 56 |  if_ne	mov	arg01, local02
05ba8     80 00 B0 5D |  if_ne	call	#__system____default_flush
05bac     08 A8 06 F1 | 	add	local02, #8
05bb0     54 AD 02 FB | 	rdlong	local04, local02
05bb4     08 AC 46 F5 | 	or	local04, #8
05bb8     54 AD 62 FC | 	wrlong	local04, local02
05bbc     55 AF 02 FB | 	rdlong	local05, local03
05bc0     0C AA 06 F1 | 	add	local03, #12
05bc4     55 93 02 FB | 	rdlong	arg02, local03
05bc8     0C AA 86 F1 | 	sub	local03, #12
05bcc     57 77 02 F6 | 	mov	result1, local05
05bd0     49 77 02 F1 | 	add	result1, arg02
05bd4     3B A7 42 FC | 	wrbyte	local01, result1
05bd8     53 A7 E2 F8 | 	getbyte	local01, local01, #0
05bdc     01 AE 06 F1 | 	add	local05, #1
05be0     55 AF 62 FC | 	wrlong	local05, local03
05be4     02 A8 86 F1 | 	sub	local02, #2
05be8     54 B1 EA FA | 	rdword	local06, local02 wz
05bec     06 A8 86 F1 | 	sub	local02, #6
05bf0     08 AA 06 51 |  if_ne	add	local03, #8
05bf4     55 AD 02 5B |  if_ne	rdlong	local04, local03
05bf8     56 AF 0A 52 |  if_ne	cmp	local05, local04 wz
05bfc     0C 00 90 AD |  if_e	jmp	#LR__0880
05c00     0A A6 0E F2 | 	cmp	local01, #10 wz
05c04     01 B0 0E A2 |  if_e	cmp	local06, #1 wz
05c08     10 00 90 5D |  if_ne	jmp	#LR__0881
05c0c                 | LR__0880
05c0c     54 91 02 F6 | 	mov	arg01, local02
05c10     18 00 B0 FD | 	call	#__system____default_flush
05c14     00 76 0E F2 | 	cmp	result1, #0 wz
05c18     01 A6 66 56 |  if_ne	neg	local01, #1
05c1c                 | LR__0881
05c1c     53 77 02 F6 | 	mov	result1, local01
05c20     E7 F0 03 F6 | 	mov	ptra, fp
05c24     F2 00 A0 FD | 	call	#popregs_
05c28                 | __system____default_putc_ret
05c28     2D 00 64 FD | 	ret
05c2c                 | 
05c2c                 | __system____default_flush
05c2c     07 CA 05 F6 | 	mov	COUNT_, #7
05c30     E8 00 A0 FD | 	call	#pushregs_
05c34     48 A7 02 F6 | 	mov	local01, arg01
05c38     53 A9 02 FB | 	rdlong	local02, local01
05c3c     54 AB 02 FB | 	rdlong	local03, local02
05c40     08 A6 06 F1 | 	add	local01, #8
05c44     53 79 02 FB | 	rdlong	result2, local01
05c48     08 A6 86 F1 | 	sub	local01, #8
05c4c     08 78 CE F7 | 	test	result2, #8 wz
05c50     D4 00 90 AD |  if_e	jmp	#LR__0892
05c54     01 AA 56 F2 | 	cmps	local03, #1 wc
05c58     2C 01 90 CD |  if_b	jmp	#LR__0894
05c5c     08 A6 06 F1 | 	add	local01, #8
05c60     53 79 02 FB | 	rdlong	result2, local01
05c64     08 A6 86 F1 | 	sub	local01, #8
05c68     80 78 CE F7 | 	test	result2, #128 wz
05c6c     6C 00 90 AD |  if_e	jmp	#LR__0891
05c70     08 A6 06 F1 | 	add	local01, #8
05c74     53 95 02 FB | 	rdlong	arg03, local01
05c78     08 A6 86 F1 | 	sub	local01, #8
05c7c     00 95 CE F7 | 	test	arg03, #256 wz
05c80     58 00 90 AD |  if_e	jmp	#LR__0890
05c84     30 A6 06 F1 | 	add	local01, #48
05c88     53 AD 02 FB | 	rdlong	local04, local01
05c8c     56 AF 02 F6 | 	mov	local05, local04
05c90     30 A6 86 F1 | 	sub	local01, #48
05c94     13 AE 46 F7 | 	zerox	local05, #19
05c98     14 AC 46 F0 | 	shr	local04, #20
05c9c     02 AC 66 F0 | 	shl	local04, #2
05ca0     2D AD 02 F1 | 	add	local04, __methods__
05ca4     56 AD 02 FB | 	rdlong	local04, local04
05ca8     53 91 02 F6 | 	mov	arg01, local01
05cac     00 92 06 F6 | 	mov	arg02, #0
05cb0     00 94 06 F6 | 	mov	arg03, #0
05cb4     02 96 06 F6 | 	mov	arg04, #2
05cb8     31 B1 02 F6 | 	mov	local06, objptr
05cbc     57 63 02 F6 | 	mov	objptr, local05
05cc0     2D AC 62 FD | 	call	local04
05cc4     58 63 02 F6 | 	mov	objptr, local06
05cc8     08 A6 06 F1 | 	add	local01, #8
05ccc     53 B1 02 FB | 	rdlong	local06, local01
05cd0     00 B1 26 F5 | 	andn	local06, #256
05cd4     53 B1 62 FC | 	wrlong	local06, local01
05cd8     08 A6 86 F1 | 	sub	local01, #8
05cdc                 | LR__0890
05cdc                 | LR__0891
05cdc     18 A6 06 F1 | 	add	local01, #24
05ce0     53 AD 02 FB | 	rdlong	local04, local01
05ce4     56 AF 02 F6 | 	mov	local05, local04
05ce8     18 A6 86 F1 | 	sub	local01, #24
05cec     13 AE 46 F7 | 	zerox	local05, #19
05cf0     14 AC 46 F0 | 	shr	local04, #20
05cf4     02 AC 66 F0 | 	shl	local04, #2
05cf8     2D AD 02 F1 | 	add	local04, __methods__
05cfc     56 AD 02 FB | 	rdlong	local04, local04
05d00     0C A8 06 F1 | 	add	local02, #12
05d04     54 93 02 FB | 	rdlong	arg02, local02
05d08     0C A8 86 F1 | 	sub	local02, #12
05d0c     53 91 02 F6 | 	mov	arg01, local01
05d10     55 95 02 F6 | 	mov	arg03, local03
05d14     31 B1 02 F6 | 	mov	local06, objptr
05d18     57 63 02 F6 | 	mov	objptr, local05
05d1c     2D AC 62 FD | 	call	local04
05d20     58 63 02 F6 | 	mov	objptr, local06
05d24     60 00 90 FD | 	jmp	#LR__0894
05d28                 | LR__0892
05d28     08 A6 06 F1 | 	add	local01, #8
05d2c     53 B1 02 FB | 	rdlong	local06, local01
05d30     08 A6 86 F1 | 	sub	local01, #8
05d34     04 B0 CE F7 | 	test	local06, #4 wz
05d38     00 AA 0E 52 |  if_ne	cmp	local03, #0 wz
05d3c     48 00 90 AD |  if_e	jmp	#LR__0893
05d40     55 93 62 F6 | 	neg	arg02, local03
05d44     49 95 02 F6 | 	mov	arg03, arg02
05d48     1F 94 C6 F0 | 	sar	arg03, #31
05d4c     30 A6 06 F1 | 	add	local01, #48
05d50     53 AD 02 FB | 	rdlong	local04, local01
05d54     56 AF 02 F6 | 	mov	local05, local04
05d58     30 A6 86 F1 | 	sub	local01, #48
05d5c     13 AE 46 F7 | 	zerox	local05, #19
05d60     14 AC 46 F0 | 	shr	local04, #20
05d64     02 AC 66 F0 | 	shl	local04, #2
05d68     2D AD 02 F1 | 	add	local04, __methods__
05d6c     56 AD 02 FB | 	rdlong	local04, local04
05d70     53 91 02 F6 | 	mov	arg01, local01
05d74     01 96 06 F6 | 	mov	arg04, #1
05d78     31 B1 02 F6 | 	mov	local06, objptr
05d7c     57 63 02 F6 | 	mov	objptr, local05
05d80     2D AC 62 FD | 	call	local04
05d84     58 63 02 F6 | 	mov	objptr, local06
05d88                 | LR__0893
05d88                 | LR__0894
05d88     54 01 68 FC | 	wrlong	#0, local02
05d8c     04 A8 06 F1 | 	add	local02, #4
05d90     54 01 68 FC | 	wrlong	#0, local02
05d94     08 A6 06 F1 | 	add	local01, #8
05d98     53 B3 02 FB | 	rdlong	local07, local01
05d9c     0C B2 26 F5 | 	andn	local07, #12
05da0     53 B3 62 FC | 	wrlong	local07, local01
05da4     00 76 06 F6 | 	mov	result1, #0
05da8     E7 F0 03 F6 | 	mov	ptra, fp
05dac     F2 00 A0 FD | 	call	#popregs_
05db0                 | __system____default_flush_ret
05db0     2D 00 64 FD | 	ret
05db4                 | 
05db4                 | __system__stat
05db4     04 CA 05 F6 | 	mov	COUNT_, #4
05db8     E8 00 A0 FD | 	call	#pushregs_
05dbc     49 A7 02 F6 | 	mov	local01, arg02
05dc0     33 A9 02 F6 | 	mov	local02, ptr___system__dat__
05dc4     84 A9 06 F1 | 	add	local02, #388
05dc8     48 93 02 F6 | 	mov	arg02, arg01
05dcc     54 91 02 F6 | 	mov	arg01, local02
05dd0     00 94 06 F6 | 	mov	arg03, #0
05dd4     00 D9 BF FD | 	call	#__system____getvfsforfile
05dd8     3B AB 0A F6 | 	mov	local03, result1 wz
05ddc     10 00 90 AD |  if_e	jmp	#LR__0900
05de0     34 AA 06 F1 | 	add	local03, #52
05de4     55 95 0A FB | 	rdlong	arg03, local03 wz
05de8     34 AA 86 F1 | 	sub	local03, #52
05dec     14 00 90 5D |  if_ne	jmp	#LR__0901
05df0                 | LR__0900
05df0     20 66 06 F1 | 	add	ptr___system__dat__, #32
05df4     33 21 68 FC | 	wrlong	#16, ptr___system__dat__
05df8     20 66 86 F1 | 	sub	ptr___system__dat__, #32
05dfc     01 76 66 F6 | 	neg	result1, #1
05e00     68 00 90 FD | 	jmp	#LR__0902
05e04                 | LR__0901
05e04     53 91 02 F6 | 	mov	arg01, local01
05e08     00 92 06 F6 | 	mov	arg02, #0
05e0c     34 94 06 F6 | 	mov	arg03, #52
05e10     48 AD 02 F6 | 	mov	local04, arg01
05e14     D8 00 A0 FD | 	call	#\builtin_bytefill_
05e18     56 77 02 F6 | 	mov	result1, local04
05e1c     54 91 CA FA | 	rdbyte	arg01, local02 wz
05e20     08 A6 06 A1 |  if_e	add	local01, #8
05e24     08 00 80 AF 
05e28     53 FF 6B AC |  if_e	wrlong	##4607, local01
05e2c     00 76 06 A6 |  if_e	mov	result1, #0
05e30     38 00 90 AD |  if_e	jmp	#LR__0902
05e34     34 AA 06 F1 | 	add	local03, #52
05e38     55 AB 02 FB | 	rdlong	local03, local03
05e3c     55 AD 02 F6 | 	mov	local04, local03
05e40     13 AA 46 F7 | 	zerox	local03, #19
05e44     14 AC 46 F0 | 	shr	local04, #20
05e48     02 AC 66 F0 | 	shl	local04, #2
05e4c     2D AD 02 F1 | 	add	local04, __methods__
05e50     56 AD 02 FB | 	rdlong	local04, local04
05e54     54 91 02 F6 | 	mov	arg01, local02
05e58     53 93 02 F6 | 	mov	arg02, local01
05e5c     31 A9 02 F6 | 	mov	local02, objptr
05e60     55 63 02 F6 | 	mov	objptr, local03
05e64     2D AC 62 FD | 	call	local04
05e68     54 63 02 F6 | 	mov	objptr, local02
05e6c                 | LR__0902
05e6c     E7 F0 03 F6 | 	mov	ptra, fp
05e70     F2 00 A0 FD | 	call	#popregs_
05e74                 | __system__stat_ret
05e74     2D 00 64 FD | 	ret
05e78                 | 
05e78                 | __system____getftab
05e78     0A 90 16 F2 | 	cmp	arg01, #10 wc
05e7c     34 90 06 CD |  if_b	qmul	arg01, #52
05e80     00 76 06 36 |  if_ae	mov	result1, #0
05e84     33 91 02 C6 |  if_b	mov	arg01, ptr___system__dat__
05e88     01 00 00 CF 
05e8c     E0 90 06 C1 |  if_b	add	arg01, ##736
05e90     18 76 62 CD |  if_b	getqx	result1
05e94     48 77 02 C1 |  if_b	add	result1, arg01
05e98                 | __system____getftab_ret
05e98     2D 00 64 FD | 	ret
05e9c                 | 
05e9c                 | __system__strncpy
05e9c     48 7D 02 F6 | 	mov	_var01, arg01
05ea0                 | LR__0910
05ea0     01 94 86 F1 | 	sub	arg03, #1
05ea4     00 94 56 F2 | 	cmps	arg03, #0 wc
05ea8     24 00 90 CD |  if_b	jmp	#LR__0911
05eac     49 77 02 F6 | 	mov	result1, arg02
05eb0     01 76 06 F1 | 	add	result1, #1
05eb4     49 7F C2 FA | 	rdbyte	_var02, arg02
05eb8     3B 93 02 F6 | 	mov	arg02, result1
05ebc     3E 7F 42 FC | 	wrbyte	_var02, _var01
05ec0     3F 7F E2 F8 | 	getbyte	_var02, _var02, #0
05ec4     07 7E 4E F7 | 	zerox	_var02, #7 wz
05ec8     01 7C 06 F1 | 	add	_var01, #1
05ecc     D0 FF 9F 5D |  if_ne	jmp	#LR__0910
05ed0                 | LR__0911
05ed0     D7 0C 48 FB | 	callpa	#(@LR__0913-@LR__0912)>>2,fcache_load_ptr_
05ed4                 | LR__0912
05ed4     01 94 86 F1 | 	sub	arg03, #1
05ed8     00 94 56 F2 | 	cmps	arg03, #0 wc
05edc     3E 81 02 36 |  if_ae	mov	_var03, _var01
05ee0     01 7C 06 31 |  if_ae	add	_var01, #1
05ee4     40 01 48 3C |  if_ae	wrbyte	#0, _var03
05ee8     E8 FF 9F 3D |  if_ae	jmp	#LR__0912
05eec                 | LR__0913
05eec     48 77 02 F6 | 	mov	result1, arg01
05ef0                 | __system__strncpy_ret
05ef0     2D 00 64 FD | 	ret
05ef4                 | 
05ef4                 | __system__strncat
05ef4     00 92 4E F2 | 	cmps	arg02, #0 wz
05ef8     54 00 90 AD |  if_e	jmp	#LR__0925
05efc     01 94 16 F2 | 	cmp	arg03, #1 wc
05f00     4C 00 90 CD |  if_b	jmp	#LR__0925
05f04     48 7D 02 F6 | 	mov	_var01, arg01
05f08     D7 06 48 FB | 	callpa	#(@LR__0921-@LR__0920)>>2,fcache_load_ptr_
05f0c                 | LR__0920
05f0c     3E 77 CA FA | 	rdbyte	result1, _var01 wz
05f10     01 7C 06 51 |  if_ne	add	_var01, #1
05f14     F4 FF 9F 5D |  if_ne	jmp	#LR__0920
05f18                 | LR__0921
05f18     4A 7F 02 F6 | 	mov	_var02, arg03
05f1c     D7 16 48 FB | 	callpa	#(@LR__0923-@LR__0922)>>2,fcache_load_ptr_
05f20                 | LR__0922
05f20     49 81 C2 FA | 	rdbyte	_var03, arg02
05f24     40 83 02 F6 | 	mov	_var04, _var03
05f28     07 82 4E F7 | 	zerox	_var04, #7 wz
05f2c     01 92 06 F1 | 	add	arg02, #1
05f30     18 00 90 AD |  if_e	jmp	#LR__0924
05f34     01 7E 86 F1 | 	sub	_var02, #1
05f38     00 7E 56 F2 | 	cmps	_var02, #0 wc
05f3c     3E 83 02 36 |  if_ae	mov	_var04, _var01
05f40     01 7C 06 31 |  if_ae	add	_var01, #1
05f44     41 81 42 3C |  if_ae	wrbyte	_var03, _var04
05f48     D4 FF 9F 3D |  if_ae	jmp	#LR__0922
05f4c                 | LR__0923
05f4c                 | LR__0924
05f4c     3E 01 48 FC | 	wrbyte	#0, _var01
05f50                 | LR__0925
05f50     48 77 02 F6 | 	mov	result1, arg01
05f54                 | __system__strncat_ret
05f54     2D 00 64 FD | 	ret
05f58                 | 
05f58                 | __system__strncmp
05f58     48 7D 0A F6 | 	mov	_var01, arg01 wz
05f5c     14 00 90 5D |  if_ne	jmp	#LR__0930
05f60     00 92 0E F2 | 	cmp	arg02, #0 wz
05f64     01 7E 66 56 |  if_ne	neg	_var02, #1
05f68     00 7E 06 A6 |  if_e	mov	_var02, #0
05f6c     3F 77 02 F6 | 	mov	result1, _var02
05f70     74 00 90 FD | 	jmp	#__system__strncmp_ret
05f74                 | LR__0930
05f74     00 92 0E F2 | 	cmp	arg02, #0 wz
05f78     01 76 06 A6 |  if_e	mov	result1, #1
05f7c     68 00 90 AD |  if_e	jmp	#__system__strncmp_ret
05f80     4A 81 02 F6 | 	mov	_var03, arg03
05f84     D7 16 48 FB | 	callpa	#(@LR__0932-@LR__0931)>>2,fcache_load_ptr_
05f88                 | LR__0931
05f88     3E 83 C2 FA | 	rdbyte	_var04, _var01
05f8c     49 85 02 F6 | 	mov	_var05, arg02
05f90     42 87 C2 FA | 	rdbyte	_var06, _var05
05f94     01 80 86 F1 | 	sub	_var03, #1
05f98     00 80 56 F2 | 	cmps	_var03, #0 wc
05f9c     01 7C 06 F1 | 	add	_var01, #1
05fa0     01 92 06 F1 | 	add	arg02, #1
05fa4     00 82 0E 32 |  if_ae	cmp	_var04, #0 wz
05fa8     08 00 90 2D |  if_nc_and_z	jmp	#LR__0933
05fac     43 83 0A 32 |  if_ae	cmp	_var04, _var06 wz
05fb0     D4 FF 9F 2D |  if_nc_and_z	jmp	#LR__0931
05fb4                 | LR__0932
05fb4                 | LR__0933
05fb4     00 80 56 F2 | 	cmps	_var03, #0 wc
05fb8     00 76 06 C6 |  if_b	mov	result1, #0
05fbc     28 00 90 CD |  if_b	jmp	#__system__strncmp_ret
05fc0     43 83 0A F2 | 	cmp	_var04, _var06 wz
05fc4     00 76 06 A6 |  if_e	mov	result1, #0
05fc8     1C 00 90 AD |  if_e	jmp	#__system__strncmp_ret
05fcc     00 82 0E F2 | 	cmp	_var04, #0 wz
05fd0     01 76 66 A6 |  if_e	neg	result1, #1
05fd4     10 00 90 AD |  if_e	jmp	#__system__strncmp_ret
05fd8     00 86 0E F2 | 	cmp	_var06, #0 wz
05fdc     01 76 06 A6 |  if_e	mov	result1, #1
05fe0     41 77 02 56 |  if_ne	mov	result1, _var04
05fe4     43 77 82 51 |  if_ne	sub	result1, _var06
05fe8                 | __system__strncmp_ret
05fe8     2D 00 64 FD | 	ret
05fec                 | 
05fec                 | __system____root_opendir
05fec     33 77 02 F6 | 	mov	result1, ptr___system__dat__
05ff0     64 76 06 F1 | 	add	result1, #100
05ff4     04 90 06 F1 | 	add	arg01, #4
05ff8     48 77 62 FC | 	wrlong	result1, arg01
05ffc     00 76 06 F6 | 	mov	result1, #0
06000                 | __system____root_opendir_ret
06000     2D 00 64 FD | 	ret
06004                 | 
06004                 | __system____root_readdir
06004     03 CA 05 F6 | 	mov	COUNT_, #3
06008     E8 00 A0 FD | 	call	#pushregs_
0600c     48 A7 02 F6 | 	mov	local01, arg01
06010     49 A9 02 F6 | 	mov	local02, arg02
06014     04 A6 06 F1 | 	add	local01, #4
06018     53 AB 02 FB | 	rdlong	local03, local01
0601c     04 A6 86 F1 | 	sub	local01, #4
06020                 | LR__0940
06020     33 95 02 F6 | 	mov	arg03, ptr___system__dat__
06024     74 94 06 F1 | 	add	arg03, #116
06028     4A AB 0A F2 | 	cmp	local03, arg03 wz
0602c     01 76 66 A6 |  if_e	neg	result1, #1
06030     48 00 90 AD |  if_e	jmp	#LR__0941
06034     55 95 0A FB | 	rdlong	arg03, local03 wz
06038     04 AA 06 A1 |  if_e	add	local03, #4
0603c     E0 FF 9F AD |  if_e	jmp	#LR__0940
06040     55 93 02 FB | 	rdlong	arg02, local03
06044     01 92 06 F1 | 	add	arg02, #1
06048     54 91 02 F6 | 	mov	arg01, local02
0604c     40 94 06 F6 | 	mov	arg03, #64
06050     48 FE BF FD | 	call	#__system__strncpy
06054     50 A8 06 F1 | 	add	local02, #80
06058     54 03 48 FC | 	wrbyte	#1, local02
0605c     08 A8 86 F1 | 	sub	local02, #8
06060     54 01 68 FC | 	wrlong	#0, local02
06064     04 A8 06 F1 | 	add	local02, #4
06068     54 01 68 FC | 	wrlong	#0, local02
0606c     04 AA 06 F1 | 	add	local03, #4
06070     04 A6 06 F1 | 	add	local01, #4
06074     53 AB 62 FC | 	wrlong	local03, local01
06078     00 76 06 F6 | 	mov	result1, #0
0607c                 | LR__0941
0607c     E7 F0 03 F6 | 	mov	ptra, fp
06080     F2 00 A0 FD | 	call	#popregs_
06084                 | __system____root_readdir_ret
06084     2D 00 64 FD | 	ret
06088                 | 
06088                 | __system____root_closedir
06088     00 76 06 F6 | 	mov	result1, #0
0608c                 | __system____root_closedir_ret
0608c     2D 00 64 FD | 	ret
06090                 | 
06090                 | __system____root_stat
06090     49 7D 02 F6 | 	mov	_var01, arg02
06094     3E 91 02 F6 | 	mov	arg01, _var01
06098     00 92 06 F6 | 	mov	arg02, #0
0609c     34 94 06 F6 | 	mov	arg03, #52
060a0     D8 00 A0 FD | 	call	#\builtin_bytefill_
060a4     08 7C 06 F1 | 	add	_var01, #8
060a8     08 00 80 FF 
060ac     3E FF 6B FC | 	wrlong	##4607, _var01
060b0     00 76 06 F6 | 	mov	result1, #0
060b4                 | __system____root_stat_ret
060b4     2D 00 64 FD | 	ret
060b8                 | 
060b8                 | __system___normalizeName
060b8     00 7C 06 F6 | 	mov	_var01, #0
060bc     48 7F 02 F6 | 	mov	_var02, arg01
060c0     3F 81 02 F6 | 	mov	_var03, _var02
060c4                 | LR__0950
060c4     3F 83 CA FA | 	rdbyte	_var04, _var02 wz
060c8     5C 01 90 AD |  if_e	jmp	#LR__0969
060cc     00 7C 0E F2 | 	cmp	_var01, #0 wz
060d0     40 83 02 56 |  if_ne	mov	_var04, _var03
060d4     01 80 06 51 |  if_ne	add	_var03, #1
060d8     41 5F 48 5C |  if_ne	wrbyte	#47, _var04
060dc     00 7C 06 56 |  if_ne	mov	_var01, #0
060e0     3F 83 C2 FA | 	rdbyte	_var04, _var02
060e4     2E 82 0E F2 | 	cmp	_var04, #46 wz
060e8     D8 00 90 5D |  if_ne	jmp	#LR__0962
060ec     01 7E 06 F1 | 	add	_var02, #1
060f0     3F 83 C2 FA | 	rdbyte	_var04, _var02
060f4     01 7E 86 F1 | 	sub	_var02, #1
060f8     2F 82 0E F2 | 	cmp	_var04, #47 wz
060fc     18 00 90 AD |  if_e	jmp	#LR__0951
06100     01 7E 06 F1 | 	add	_var02, #1
06104     3F 85 C2 FA | 	rdbyte	_var05, _var02
06108     01 7E 86 F1 | 	sub	_var02, #1
0610c     42 87 02 F6 | 	mov	_var06, _var05
06110     07 86 4E F7 | 	zerox	_var06, #7 wz
06114     10 00 90 5D |  if_ne	jmp	#LR__0952
06118                 | LR__0951
06118     3F 89 02 F6 | 	mov	_var07, _var02
0611c     01 88 06 F1 | 	add	_var07, #1
06120     44 7F 02 F6 | 	mov	_var02, _var07
06124     E0 00 90 FD | 	jmp	#LR__0966
06128                 | LR__0952
06128     01 7E 06 F1 | 	add	_var02, #1
0612c     3F 89 C2 FA | 	rdbyte	_var07, _var02
06130     01 7E 86 F1 | 	sub	_var02, #1
06134     44 83 E2 F8 | 	getbyte	_var04, _var07, #0
06138     2E 82 0E F2 | 	cmp	_var04, #46 wz
0613c     84 00 90 5D |  if_ne	jmp	#LR__0961
06140     02 7E 06 F1 | 	add	_var02, #2
06144     3F 89 C2 FA | 	rdbyte	_var07, _var02
06148     02 7E 86 F1 | 	sub	_var02, #2
0614c     44 83 E2 F8 | 	getbyte	_var04, _var07, #0
06150     2F 82 0E F2 | 	cmp	_var04, #47 wz
06154     18 00 90 AD |  if_e	jmp	#LR__0953
06158     02 7E 06 F1 | 	add	_var02, #2
0615c     3F 85 C2 FA | 	rdbyte	_var05, _var02
06160     02 7E 86 F1 | 	sub	_var02, #2
06164     42 87 02 F6 | 	mov	_var06, _var05
06168     07 86 4E F7 | 	zerox	_var06, #7 wz
0616c     54 00 90 5D |  if_ne	jmp	#LR__0960
06170                 | LR__0953
06170     02 7E 06 F1 | 	add	_var02, #2
06174     48 81 5A F2 | 	cmps	_var03, arg01 wcz
06178     40 00 90 ED |  if_be	jmp	#LR__0959
0617c     40 8B 02 F6 | 	mov	_var08, _var03
06180     01 8A 86 F1 | 	sub	_var08, #1
06184                 | LR__0954
06184     45 83 C2 FA | 	rdbyte	_var04, _var08
06188     2F 82 0E F2 | 	cmp	_var04, #47 wz
0618c     0C 00 90 5D |  if_ne	jmp	#LR__0955
06190     48 8B 5A F2 | 	cmps	_var08, arg01 wcz
06194     01 8A 86 11 |  if_a	sub	_var08, #1
06198     E8 FF 9F 1D |  if_a	jmp	#LR__0954
0619c                 | LR__0955
0619c     D7 0C 48 FB | 	callpa	#(@LR__0957-@LR__0956)>>2,fcache_load_ptr_
061a0                 | LR__0956
061a0     48 8B 5A F2 | 	cmps	_var08, arg01 wcz
061a4     10 00 90 ED |  if_be	jmp	#LR__0958
061a8     45 83 C2 FA | 	rdbyte	_var04, _var08
061ac     2F 82 0E F2 | 	cmp	_var04, #47 wz
061b0     01 8A 86 51 |  if_ne	sub	_var08, #1
061b4     E8 FF 9F 5D |  if_ne	jmp	#LR__0956
061b8                 | LR__0957
061b8                 | LR__0958
061b8     45 81 02 F6 | 	mov	_var03, _var08
061bc                 | LR__0959
061bc     01 7C 06 F6 | 	mov	_var01, #1
061c0     44 00 90 FD | 	jmp	#LR__0966
061c4                 | LR__0960
061c4                 | LR__0961
061c4                 | LR__0962
061c4     D7 18 48 FB | 	callpa	#(@LR__0964-@LR__0963)>>2,fcache_load_ptr_
061c8                 | LR__0963
061c8     3F 83 CA FA | 	rdbyte	_var04, _var02 wz
061cc     41 89 02 56 |  if_ne	mov	_var07, _var04
061d0     2F 88 0E 52 |  if_ne	cmp	_var07, #47 wz
061d4     20 00 90 AD |  if_e	jmp	#LR__0965
061d8     3F 87 02 F6 | 	mov	_var06, _var02
061dc     3F 85 02 F6 | 	mov	_var05, _var02
061e0     01 84 06 F1 | 	add	_var05, #1
061e4     43 8D C2 FA | 	rdbyte	_var09, _var06
061e8     42 7F 02 F6 | 	mov	_var02, _var05
061ec     40 8D 42 FC | 	wrbyte	_var09, _var03
061f0     01 80 06 F1 | 	add	_var03, #1
061f4     D0 FF 9F FD | 	jmp	#LR__0963
061f8                 | LR__0964
061f8                 | LR__0965
061f8     3F 83 C2 FA | 	rdbyte	_var04, _var02
061fc     2F 82 0E F2 | 	cmp	_var04, #47 wz
06200     C0 FE 9F 5D |  if_ne	jmp	#LR__0950
06204     01 7C 06 F6 | 	mov	_var01, #1
06208                 | LR__0966
06208     D7 0C 48 FB | 	callpa	#(@LR__0968-@LR__0967)>>2,fcache_load_ptr_
0620c                 | LR__0967
0620c     3F 83 C2 FA | 	rdbyte	_var04, _var02
06210     2F 82 0E F2 | 	cmp	_var04, #47 wz
06214     3F 89 02 A6 |  if_e	mov	_var07, _var02
06218     01 88 06 A1 |  if_e	add	_var07, #1
0621c     44 7F 02 A6 |  if_e	mov	_var02, _var07
06220     E8 FF 9F AD |  if_e	jmp	#LR__0967
06224                 | LR__0968
06224     9C FE 9F FD | 	jmp	#LR__0950
06228                 | LR__0969
06228     40 01 48 FC | 	wrbyte	#0, _var03
0622c                 | __system___normalizeName_ret
0622c     2D 00 64 FD | 	ret
06230                 | 
06230                 | __system___strrev
06230     48 7D CA FA | 	rdbyte	_var01, arg01 wz
06234     40 00 90 AD |  if_e	jmp	#__system___strrev_ret
06238     48 7F 02 F6 | 	mov	_var02, arg01
0623c     D7 06 48 FB | 	callpa	#(@LR__0971-@LR__0970)>>2,fcache_load_ptr_
06240                 | LR__0970
06240     3F 7D CA FA | 	rdbyte	_var01, _var02 wz
06244     01 7E 06 51 |  if_ne	add	_var02, #1
06248     F4 FF 9F 5D |  if_ne	jmp	#LR__0970
0624c                 | LR__0971
0624c     01 7E 86 F1 | 	sub	_var02, #1
06250     D7 12 48 FB | 	callpa	#(@LR__0973-@LR__0972)>>2,fcache_load_ptr_
06254                 | LR__0972
06254     48 7F 5A F2 | 	cmps	_var02, arg01 wcz
06258     1C 00 90 ED |  if_be	jmp	#LR__0974
0625c     48 7D C2 FA | 	rdbyte	_var01, arg01
06260     3F 81 C2 FA | 	rdbyte	_var03, _var02
06264     48 81 42 FC | 	wrbyte	_var03, arg01
06268     3F 7D 42 FC | 	wrbyte	_var01, _var02
0626c     01 90 06 F1 | 	add	arg01, #1
06270     01 7E 86 F1 | 	sub	_var02, #1
06274     DC FF 9F FD | 	jmp	#LR__0972
06278                 | LR__0973
06278                 | LR__0974
06278                 | __system___strrev_ret
06278     2D 00 64 FD | 	ret
0627c                 | 
0627c                 | __system___fmtpad
0627c     06 CA 05 F6 | 	mov	COUNT_, #6
06280     E8 00 A0 FD | 	call	#pushregs_
06284     48 A7 02 F6 | 	mov	local01, arg01
06288     49 A9 02 F6 | 	mov	local02, arg02
0628c     4A AB 02 F6 | 	mov	local03, arg03
06290     54 91 EA F8 | 	getbyte	arg01, local02, #1
06294     16 A8 46 F0 | 	shr	local02, #22
06298     03 A8 0E F5 | 	and	local02, #3 wz
0629c     00 AC 06 F6 | 	mov	local04, #0
062a0     01 A8 06 A6 |  if_e	mov	local02, #1
062a4     4B A9 CA F7 | 	test	local02, arg04 wz
062a8     00 76 06 A6 |  if_e	mov	result1, #0
062ac     88 00 90 AD |  if_e	jmp	#LR__0983
062b0     48 AB C2 F2 | 	subr	local03, arg01
062b4     01 AA 56 F2 | 	cmps	local03, #1 wc
062b8     00 76 06 C6 |  if_b	mov	result1, #0
062bc     78 00 90 CD |  if_b	jmp	#LR__0983
062c0     03 A8 0E F2 | 	cmp	local02, #3 wz
062c4     18 00 90 5D |  if_ne	jmp	#LR__0980
062c8     01 96 0E F2 | 	cmp	arg04, #1 wz
062cc     6E A8 62 FD | 	wrz	local02
062d0     54 AB 02 F1 | 	add	local03, local02
062d4     55 AB 52 F6 | 	abs	local03, local03 wc
062d8     01 AA 46 F0 | 	shr	local03, #1
062dc     55 AB 82 F6 | 	negc	local03, local03
062e0                 | LR__0980
062e0     01 AA 56 F2 | 	cmps	local03, #1 wc
062e4     4C 00 90 CD |  if_b	jmp	#LR__0982
062e8     55 AF 02 F6 | 	mov	local05, local03
062ec                 | LR__0981
062ec     53 A9 02 F6 | 	mov	local02, local01
062f0     53 B1 02 F6 | 	mov	local06, local01
062f4     13 A8 46 F7 | 	zerox	local02, #19
062f8     14 B0 46 F0 | 	shr	local06, #20
062fc     02 B0 66 F0 | 	shl	local06, #2
06300     2D B1 02 F1 | 	add	local06, __methods__
06304     58 B1 02 FB | 	rdlong	local06, local06
06308     20 90 06 F6 | 	mov	arg01, #32
0630c     31 AB 02 F6 | 	mov	local03, objptr
06310     54 63 02 F6 | 	mov	objptr, local02
06314     2D B0 62 FD | 	call	local06
06318     55 63 02 F6 | 	mov	objptr, local03
0631c     3B B1 02 F6 | 	mov	local06, result1
06320     00 B0 56 F2 | 	cmps	local06, #0 wc
06324     58 77 02 C6 |  if_b	mov	result1, local06
06328     0C 00 90 CD |  if_b	jmp	#LR__0983
0632c     58 AD 02 F1 | 	add	local04, local06
06330     EE AF 6E FB | 	djnz	local05, #LR__0981
06334                 | LR__0982
06334     56 77 02 F6 | 	mov	result1, local04
06338                 | LR__0983
06338     E7 F0 03 F6 | 	mov	ptra, fp
0633c     F2 00 A0 FD | 	call	#popregs_
06340                 | __system___fmtpad_ret
06340     2D 00 64 FD | 	ret
06344                 | 
06344                 | __system___uitoa
06344     04 CA 05 F6 | 	mov	COUNT_, #4
06348     E8 00 A0 FD | 	call	#pushregs_
0634c     48 A7 02 F6 | 	mov	local01, arg01
06350     00 98 4E F2 | 	cmps	arg05, #0 wz
06354     53 99 02 F6 | 	mov	arg05, local01
06358     00 A8 06 F6 | 	mov	local02, #0
0635c     37 AA 06 56 |  if_ne	mov	local03, #55
06360     57 AA 06 A6 |  if_e	mov	local03, #87
06364                 | LR__0990
06364     4A 93 12 FD | 	qdiv	arg02, arg03
06368     19 AC 62 FD | 	getqy	local04
0636c     4A 93 12 FD | 	qdiv	arg02, arg03
06370     0A AC 16 F2 | 	cmp	local04, #10 wc
06374     30 AC 06 C1 |  if_b	add	local04, #48
06378     55 AD 02 31 |  if_ae	add	local04, local03
0637c     4C AD 42 FC | 	wrbyte	local04, arg05
06380     01 98 06 F1 | 	add	arg05, #1
06384     01 A8 06 F1 | 	add	local02, #1
06388     18 92 62 FD | 	getqx	arg02
0638c     00 92 0E F2 | 	cmp	arg02, #0 wz
06390     D0 FF 9F 5D |  if_ne	jmp	#LR__0990
06394     4B A9 12 F2 | 	cmp	local02, arg04 wc
06398     C8 FF 9F CD |  if_b	jmp	#LR__0990
0639c     4C 01 48 FC | 	wrbyte	#0, arg05
063a0     53 91 02 F6 | 	mov	arg01, local01
063a4     88 FE BF FD | 	call	#__system___strrev
063a8     54 77 02 F6 | 	mov	result1, local02
063ac     E7 F0 03 F6 | 	mov	ptra, fp
063b0     F2 00 A0 FD | 	call	#popregs_
063b4                 | __system___uitoa_ret
063b4     2D 00 64 FD | 	ret
063b8                 | 
063b8                 | __system__disassemble_0093
063b8     10 CA 05 F6 | 	mov	COUNT_, #16
063bc     E8 00 A0 FD | 	call	#pushregs_
063c0     48 A7 02 F6 | 	mov	local01, arg01
063c4     49 A9 02 F6 | 	mov	local02, arg02
063c8     4A AB 02 F6 | 	mov	local03, arg03
063cc     4B AD 02 F6 | 	mov	local04, arg04
063d0     4C AF 02 F6 | 	mov	local05, arg05
063d4     57 91 52 F6 | 	abs	arg01, local05 wc
063d8     1F B0 C6 C9 |  if_b	decod	local06, #31
063dc     00 B0 06 36 |  if_ae	mov	local06, #0
063e0     CC E1 BF FD | 	call	#__system___float_fromuns
063e4     58 77 62 F5 | 	xor	result1, local06
063e8     3B B3 02 F6 | 	mov	local07, result1
063ec     00 B4 06 F6 | 	mov	local08, #0
063f0     53 91 02 F6 | 	mov	arg01, local01
063f4     00 92 06 F6 | 	mov	arg02, #0
063f8     01 94 06 F6 | 	mov	arg03, #1
063fc     10 E9 BF FD | 	call	#__system___float_cmp
06400     00 76 0E F2 | 	cmp	result1, #0 wz
06404     00 B6 06 A6 |  if_e	mov	local09, #0
06408     54 01 68 AC |  if_e	wrlong	#0, local02
0640c     55 B7 62 AC |  if_e	wrlong	local09, local03
06410     8C 01 90 AD |  if_e	jmp	#LR__1012
06414     53 91 02 F6 | 	mov	arg01, local01
06418     44 EB BF FD | 	call	#__system____builtin_ilogb
0641c     3B B9 02 F6 | 	mov	local10, result1
06420     0A AE 0E F2 | 	cmp	local05, #10 wz
06424     24 00 90 5D |  if_ne	jmp	#LR__1000
06428     5C B7 02 F6 | 	mov	local09, local10
0642c     01 B6 66 F0 | 	shl	local09, #1
06430     5C B7 02 F1 | 	add	local09, local10
06434     5B B9 52 F6 | 	abs	local10, local09 wc
06438     0A B8 16 FD | 	qdiv	local10, #10
0643c     09 BA 06 F6 | 	mov	local11, #9
06440     18 B8 62 FD | 	getqx	local10
06444     5C B9 82 F6 | 	negc	local10, local10
06448     04 00 90 FD | 	jmp	#LR__1001
0644c                 | LR__1000
0644c     18 BA 06 F6 | 	mov	local11, #24
06450                 | LR__1001
06450                 | LR__1002
06450     08 B4 56 F2 | 	cmps	local08, #8 wc
06454     01 B4 06 F1 | 	add	local08, #1
06458     60 00 90 3D |  if_ae	jmp	#LR__1003
0645c     00 C0 1F FF 
06460     00 90 06 F6 | 	mov	arg01, ##1065353216
06464     59 93 02 F6 | 	mov	arg02, local07
06468     5C 95 02 F6 | 	mov	arg03, local10
0646c     2C EB BF FD | 	call	#__system___float_pow_n
06470     3B 93 02 F6 | 	mov	arg02, result1
06474     53 91 02 F6 | 	mov	arg01, local01
06478     64 E6 BF FD | 	call	#__system___float_div
0647c     3B BD 02 F6 | 	mov	local12, result1
06480     5E 91 02 F6 | 	mov	arg01, local12
06484     00 C0 1F FF 
06488     00 92 06 F6 | 	mov	arg02, ##1065353216
0648c     01 94 06 F6 | 	mov	arg03, #1
06490     7C E8 BF FD | 	call	#__system___float_cmp
06494     00 76 56 F2 | 	cmps	result1, #0 wc
06498     01 B8 86 C1 |  if_b	sub	local10, #1
0649c     B0 FF 9F CD |  if_b	jmp	#LR__1002
064a0     59 93 02 F6 | 	mov	arg02, local07
064a4     5E 91 02 F6 | 	mov	arg01, local12
064a8     01 94 66 F6 | 	neg	arg03, #1
064ac     60 E8 BF FD | 	call	#__system___float_cmp
064b0     00 76 56 F2 | 	cmps	result1, #0 wc
064b4     01 B8 06 31 |  if_ae	add	local10, #1
064b8     94 FF 9F 3D |  if_ae	jmp	#LR__1002
064bc                 | LR__1003
064bc     5E 91 02 F6 | 	mov	arg01, local12
064c0     9C EA BF FD | 	call	#__system____builtin_ilogb
064c4     3B BF 02 F6 | 	mov	local13, result1
064c8     5E C1 02 F6 | 	mov	local14, local12
064cc     17 C1 06 F4 | 	bitl	local14, #279
064d0     17 C0 26 F4 | 	bith	local14, #23
064d4     5F C1 62 F0 | 	shl	local14, local13
064d8     02 AE 0E F2 | 	cmp	local05, #2 wz
064dc     02 AC 66 A0 |  if_e	shl	local04, #2
064e0     00 C2 06 F6 | 	mov	local15, #0
064e4     00 AC 56 F2 | 	cmps	local04, #0 wc
064e8     10 00 90 3D |  if_ae	jmp	#LR__1004
064ec     5C AD C2 F2 | 	subr	local04, local10
064f0     00 AC 56 F2 | 	cmps	local04, #0 wc
064f4     A0 00 90 CD |  if_b	jmp	#LR__1011
064f8     04 00 90 FD | 	jmp	#LR__1005
064fc                 | LR__1004
064fc     01 AC 06 F1 | 	add	local04, #1
06500                 | LR__1005
06500     5D AD 7A F3 | 	fles	local04, local11 wcz
06504     01 C4 06 F6 | 	mov	local16, #1
06508     D7 22 48 FB | 	callpa	#(@LR__1007-@LR__1006)>>2,fcache_load_ptr_
0650c                 | LR__1006
0650c     00 40 00 FF 
06510     00 C2 16 F2 | 	cmp	local15, ##8388608 wc
06514     38 00 90 3D |  if_ae	jmp	#LR__1008
06518     01 AC 56 F2 | 	cmps	local04, #1 wc
0651c     01 AC 86 F1 | 	sub	local04, #1
06520     2C 00 90 CD |  if_b	jmp	#LR__1008
06524     57 C3 02 FD | 	qmul	local15, local05
06528     60 BF 02 F6 | 	mov	local13, local14
0652c     17 BE 46 F0 | 	shr	local13, #23
06530     17 C1 06 F4 | 	bitl	local14, #279
06534     18 C2 62 FD | 	getqx	local15
06538     57 C5 02 FD | 	qmul	local16, local05
0653c     18 C4 62 FD | 	getqx	local16
06540     57 C1 02 FD | 	qmul	local14, local05
06544     5F C3 02 F1 | 	add	local15, local13
06548     18 C0 62 FD | 	getqx	local14
0654c     BC FF 9F FD | 	jmp	#LR__1006
06550                 | LR__1007
06550                 | LR__1008
06550     57 B7 02 F6 | 	mov	local09, local05
06554     17 B6 66 F0 | 	shl	local09, #23
06558     5B BF 52 F6 | 	abs	local13, local09 wc
0655c     01 BE 46 F0 | 	shr	local13, #1
06560     5F BF 82 F6 | 	negc	local13, local13
06564     5F C1 1A F2 | 	cmp	local14, local13 wcz
06568     20 00 90 1D |  if_a	jmp	#LR__1009
0656c     17 AE 66 F0 | 	shl	local05, #23
06570     57 BF 52 F6 | 	abs	local13, local05 wc
06574     01 BE 46 F0 | 	shr	local13, #1
06578     5F BF 82 F6 | 	negc	local13, local13
0657c     5F C1 0A F2 | 	cmp	local14, local13 wz
06580     14 00 90 5D |  if_ne	jmp	#LR__1010
06584     01 C2 CE F7 | 	test	local15, #1 wz
06588     0C 00 90 AD |  if_e	jmp	#LR__1010
0658c                 | LR__1009
0658c     01 C2 06 F1 | 	add	local15, #1
06590     62 C3 0A F2 | 	cmp	local15, local16 wz
06594     01 B8 06 A1 |  if_e	add	local10, #1
06598                 | LR__1010
06598                 | LR__1011
06598     54 C3 62 FC | 	wrlong	local15, local02
0659c     55 B9 62 FC | 	wrlong	local10, local03
065a0                 | LR__1012
065a0     E7 F0 03 F6 | 	mov	ptra, fp
065a4     F2 00 A0 FD | 	call	#popregs_
065a8                 | __system__disassemble_0093_ret
065a8     2D 00 64 FD | 	ret
065ac                 | 
065ac                 | __system__emitsign_0095
065ac     00 76 06 F6 | 	mov	result1, #0
065b0     00 92 0E F2 | 	cmp	arg02, #0 wz
065b4     48 7D 02 56 |  if_ne	mov	_var01, arg01
065b8     01 90 06 51 |  if_ne	add	arg01, #1
065bc     3E 93 42 5C |  if_ne	wrbyte	arg02, _var01
065c0     01 76 06 56 |  if_ne	mov	result1, #1
065c4     00 94 0E F2 | 	cmp	arg03, #0 wz
065c8     48 61 48 5C |  if_ne	wrbyte	#48, arg01
065cc     01 90 06 51 |  if_ne	add	arg01, #1
065d0     48 95 42 5C |  if_ne	wrbyte	arg03, arg01
065d4     02 76 06 51 |  if_ne	add	result1, #2
065d8                 | __system__emitsign_0095_ret
065d8     2D 00 64 FD | 	ret
065dc                 | 
065dc                 | __system___getiolock_0133
065dc     01 CA 05 F6 | 	mov	COUNT_, #1
065e0     E8 00 A0 FD | 	call	#pushregs_
065e4     90 F8 BF FD | 	call	#__system____getftab
065e8     3B A7 0A F6 | 	mov	local01, result1 wz
065ec     10 00 90 AD |  if_e	jmp	#LR__1020
065f0     08 A6 06 F1 | 	add	local01, #8
065f4     53 77 0A FB | 	rdlong	result1, local01 wz
065f8     08 A6 86 F1 | 	sub	local01, #8
065fc     10 00 90 5D |  if_ne	jmp	#LR__1021
06600                 | LR__1020
06600     33 77 02 F6 | 	mov	result1, ptr___system__dat__
06604     01 00 00 FF 
06608     DC 76 06 F1 | 	add	result1, ##732
0660c     08 00 90 FD | 	jmp	#LR__1022
06610                 | LR__1021
06610     0C A6 06 F1 | 	add	local01, #12
06614     53 77 02 F6 | 	mov	result1, local01
06618                 | LR__1022
06618     E7 F0 03 F6 | 	mov	ptra, fp
0661c     F2 00 A0 FD | 	call	#popregs_
06620                 | __system___getiolock_0133_ret
06620     2D 00 64 FD | 	ret
06624                 | 
06624                 | __system___gettxfunc
06624     01 CA 05 F6 | 	mov	COUNT_, #1
06628     E8 00 A0 FD | 	call	#pushregs_
0662c     48 F8 BF FD | 	call	#__system____getftab
06630     3B A7 0A F6 | 	mov	local01, result1 wz
06634     10 00 90 AD |  if_e	jmp	#LR__1030
06638     08 A6 06 F1 | 	add	local01, #8
0663c     53 93 0A FB | 	rdlong	arg02, local01 wz
06640     08 A6 86 F1 | 	sub	local01, #8
06644     08 00 90 5D |  if_ne	jmp	#LR__1031
06648                 | LR__1030
06648     00 76 06 F6 | 	mov	result1, #0
0664c     0C 00 90 FD | 	jmp	#LR__1032
06650                 | LR__1031
06650     00 28 00 FF 
06654     00 A6 46 F5 | 	or	local01, ##5242880
06658     53 77 02 F6 | 	mov	result1, local01
0665c                 | LR__1032
0665c     E7 F0 03 F6 | 	mov	ptra, fp
06660     F2 00 A0 FD | 	call	#popregs_
06664                 | __system___gettxfunc_ret
06664     2D 00 64 FD | 	ret
06668                 | 
06668                 | __system__pack_0176
06668     48 7D 02 F6 | 	mov	_var01, arg01
0666c     7F 94 06 F1 | 	add	arg03, #127
06670     04 96 CE F7 | 	test	arg04, #4 wz
06674     10 00 90 AD |  if_e	jmp	#LR__1040
06678     00 7C 0E F2 | 	cmp	_var01, #0 wz
0667c     16 7C C6 A9 |  if_e	decod	_var01, #22
06680     F7 7C 26 F4 | 	bith	_var01, #247
06684     B4 00 90 FD | 	jmp	#LR__1049
06688                 | LR__1040
06688     02 96 CE F7 | 	test	arg04, #2 wz
0668c     00 C0 3F 5F 
06690     00 7C 06 56 |  if_ne	mov	_var01, ##2139095040
06694     00 92 06 56 |  if_ne	mov	arg02, #0
06698     A0 00 90 5D |  if_ne	jmp	#LR__1048
0669c     08 96 CE F7 | 	test	arg04, #8 wz
066a0     00 7C 06 56 |  if_ne	mov	_var01, #0
066a4     94 00 90 5D |  if_ne	jmp	#LR__1047
066a8     FF 94 56 F2 | 	cmps	arg03, #255 wc
066ac     00 C0 3F 3F 
066b0     00 7C 06 36 |  if_ae	mov	_var01, ##2139095040
066b4     00 92 06 36 |  if_ae	mov	arg02, #0
066b8     80 00 90 3D |  if_ae	jmp	#LR__1046
066bc     01 94 56 F2 | 	cmps	arg03, #1 wc
066c0     6C 00 90 3D |  if_ae	jmp	#LR__1044
066c4     01 92 46 F0 | 	shr	arg02, #1
066c8     3E 7F 02 F6 | 	mov	_var02, _var01
066cc     01 7E 06 F5 | 	and	_var02, #1
066d0     1F 7E 66 F0 | 	shl	_var02, #31
066d4     3F 93 42 F5 | 	or	arg02, _var02
066d8     01 7C 46 F0 | 	shr	_var01, #1
066dc     D7 1E 48 FB | 	callpa	#(@LR__1042-@LR__1041)>>2,fcache_load_ptr_
066e0                 | LR__1041
066e0     00 94 56 F2 | 	cmps	arg03, #0 wc
066e4     34 00 90 3D |  if_ae	jmp	#LR__1043
066e8     00 7C 0E F2 | 	cmp	_var01, #0 wz
066ec     2C 00 90 AD |  if_e	jmp	#LR__1043
066f0     49 91 02 F6 | 	mov	arg01, arg02
066f4     01 90 06 F5 | 	and	arg01, #1
066f8     01 94 06 F1 | 	add	arg03, #1
066fc     01 92 46 F0 | 	shr	arg02, #1
06700     3E 7F 02 F6 | 	mov	_var02, _var01
06704     01 7E 06 F5 | 	and	_var02, #1
06708     1F 7E 66 F0 | 	shl	_var02, #31
0670c     3F 93 42 F5 | 	or	arg02, _var02
06710     48 93 42 F5 | 	or	arg02, arg01
06714     01 7C 46 F0 | 	shr	_var01, #1
06718     C4 FF 9F FD | 	jmp	#LR__1041
0671c                 | LR__1042
0671c                 | LR__1043
0671c     00 94 56 F2 | 	cmps	arg03, #0 wc
06720     18 00 90 3D |  if_ae	jmp	#LR__1045
06724     00 92 0E F2 | 	cmp	arg02, #0 wz
06728     6F 92 62 FD | 	wrnz	arg02
0672c     0C 00 90 FD | 	jmp	#LR__1045
06730                 | LR__1044
06730     17 7D 06 F4 | 	bitl	_var01, #279
06734     17 94 66 F0 | 	shl	arg03, #23
06738     4A 7D 42 F5 | 	or	_var01, arg03
0673c                 | LR__1045
0673c                 | LR__1046
0673c                 | LR__1047
0673c                 | LR__1048
0673c                 | LR__1049
0673c     01 7C CE F7 | 	test	_var01, #1 wz
06740     01 92 46 55 |  if_ne	or	arg02, #1
06744     49 95 02 F6 | 	mov	arg03, arg02
06748     00 7E 06 F6 | 	mov	_var02, #0
0674c     FF FF 3F FF 
06750     FF 93 06 F1 | 	add	arg02, ##2147483647
06754     4A 93 12 F2 | 	cmp	arg02, arg03 wc
06758     01 7E 06 C6 |  if_b	mov	_var02, #1
0675c     3F 7D 02 F1 | 	add	_var01, _var02
06760     01 96 CE F7 | 	test	arg04, #1 wz
06764     1F 7C 26 54 |  if_ne	bith	_var01, #31
06768     3E 77 02 F6 | 	mov	result1, _var01
0676c                 | __system__pack_0176_ret
0676c     2D 00 64 FD | 	ret
06770                 | 
06770                 | __system___rxtxioctl_0227
06770     00 93 0E F2 | 	cmp	arg02, #256 wz
06774     0C 00 90 AD |  if_e	jmp	#LR__1050
06778     01 93 0E F2 | 	cmp	arg02, #257 wz
0677c     1C 00 90 AD |  if_e	jmp	#LR__1051
06780     30 00 90 FD | 	jmp	#LR__1052
06784                 | LR__1050
06784     08 66 06 F1 | 	add	ptr___system__dat__, #8
06788     33 77 02 FB | 	rdlong	result1, ptr___system__dat__
0678c     08 66 86 F1 | 	sub	ptr___system__dat__, #8
06790     4A 77 62 FC | 	wrlong	result1, arg03
06794     00 76 06 F6 | 	mov	result1, #0
06798     28 00 90 FD | 	jmp	#LR__1053
0679c                 | LR__1051
0679c     4A 91 02 FB | 	rdlong	arg01, arg03
067a0     08 66 06 F1 | 	add	ptr___system__dat__, #8
067a4     33 91 62 FC | 	wrlong	arg01, ptr___system__dat__
067a8     08 66 86 F1 | 	sub	ptr___system__dat__, #8
067ac     00 76 06 F6 | 	mov	result1, #0
067b0     10 00 90 FD | 	jmp	#LR__1053
067b4                 | LR__1052
067b4     20 66 06 F1 | 	add	ptr___system__dat__, #32
067b8     33 15 68 FC | 	wrlong	#10, ptr___system__dat__
067bc     20 66 86 F1 | 	sub	ptr___system__dat__, #32
067c0     01 76 66 F6 | 	neg	result1, #1
067c4                 | LR__1053
067c4                 | __system___rxtxioctl_0227_ret
067c4     2D 00 64 FD | 	ret
067c8                 | 
067c8                 | __system____dummy_flush_0228
067c8     00 76 06 F6 | 	mov	result1, #0
067cc                 | __system____dummy_flush_0228_ret
067cc     2D 00 64 FD | 	ret
067d0                 | 
067d0                 | __system___sdmm_open
067d0     0B CA 05 F6 | 	mov	COUNT_, #11
067d4     E8 00 A0 FD | 	call	#pushregs_
067d8     48 AB 02 F6 | 	mov	local03, arg01
067dc     49 AD 02 F6 | 	mov	local04, arg02
067e0     4A AF 02 F6 | 	mov	local05, arg03
067e4     4B B1 02 F6 | 	mov	local06, arg04
067e8     28 90 06 F6 | 	mov	arg01, #40
067ec     CC EA BF FD | 	call	#__system___gc_alloc_managed
067f0     3B B3 02 F6 | 	mov	local07, result1
067f4     55 97 02 F6 | 	mov	arg04, local03
067f8     1F 96 C6 F0 | 	sar	arg04, #31
067fc     55 95 02 F6 | 	mov	arg03, local03
06800     01 90 06 F6 | 	mov	arg01, #1
06804     00 92 06 F6 | 	mov	arg02, #0
06808     B8 DC BF FD | 	call	#__system___int64_shl
0680c     3B A7 02 F6 | 	mov	local01, result1
06810     3C B5 02 F6 | 	mov	local08, result2
06814     56 97 02 F6 | 	mov	arg04, local04
06818     1F 96 C6 F0 | 	sar	arg04, #31
0681c     56 95 02 F6 | 	mov	arg03, local04
06820     01 90 06 F6 | 	mov	arg01, #1
06824     00 92 06 F6 | 	mov	arg02, #0
06828     98 DC BF FD | 	call	#__system___int64_shl
0682c     3B A7 42 F5 | 	or	local01, result1
06830     3C B5 42 F5 | 	or	local08, result2
06834     57 97 02 F6 | 	mov	arg04, local05
06838     1F 96 C6 F0 | 	sar	arg04, #31
0683c     57 95 02 F6 | 	mov	arg03, local05
06840     01 90 06 F6 | 	mov	arg01, #1
06844     00 92 06 F6 | 	mov	arg02, #0
06848     78 DC BF FD | 	call	#__system___int64_shl
0684c     3B A7 42 F5 | 	or	local01, result1
06850     3C B5 42 F5 | 	or	local08, result2
06854     58 97 02 F6 | 	mov	arg04, local06
06858     1F 96 C6 F0 | 	sar	arg04, #31
0685c     58 95 02 F6 | 	mov	arg03, local06
06860     01 90 06 F6 | 	mov	arg01, #1
06864     00 92 06 F6 | 	mov	arg02, #0
06868     58 DC BF FD | 	call	#__system___int64_shl
0686c     5A 93 02 F6 | 	mov	arg02, local08
06870     3B A7 42 F5 | 	or	local01, result1
06874     49 79 42 F5 | 	or	result2, arg02
06878     3C A9 02 F6 | 	mov	local02, result2
0687c     53 91 02 F6 | 	mov	arg01, local01
06880     54 93 02 F6 | 	mov	arg02, local02
06884     AC DC BF FD | 	call	#__system___usepins
06888     00 76 0E F2 | 	cmp	result1, #0 wz
0688c     1C 00 90 5D |  if_ne	jmp	#LR__1060
06890     59 91 02 F6 | 	mov	arg01, local07
06894     58 EB BF FD | 	call	#__system___gc_free
06898     20 66 06 F1 | 	add	ptr___system__dat__, #32
0689c     33 2D 68 FC | 	wrlong	#22, ptr___system__dat__
068a0     20 66 86 F1 | 	sub	ptr___system__dat__, #32
068a4     00 76 06 F6 | 	mov	result1, #0
068a8     5C 01 90 FD | 	jmp	#LR__1063
068ac                 | LR__1060
068ac     53 B7 02 F6 | 	mov	local09, local01
068b0     54 99 02 F6 | 	mov	arg05, local02
068b4     20 B2 06 F1 | 	add	local07, #32
068b8     59 B7 62 FC | 	wrlong	local09, local07
068bc     04 B2 06 F1 | 	add	local07, #4
068c0     59 99 62 FC | 	wrlong	arg05, local07
068c4     24 B2 86 F1 | 	sub	local07, #36
068c8     57 97 02 F6 | 	mov	arg04, local05
068cc     58 99 02 F6 | 	mov	arg05, local06
068d0     00 90 06 F6 | 	mov	arg01, #0
068d4     55 93 02 F6 | 	mov	arg02, local03
068d8     56 95 02 F6 | 	mov	arg03, local04
068dc     31 B9 02 F6 | 	mov	local10, objptr
068e0     59 63 02 F6 | 	mov	objptr, local07
068e4     C8 0D B0 FD | 	call	#_sdmm_cc_disk_setpins
068e8     5C 63 02 F6 | 	mov	objptr, local10
068ec     3B BB 0A F6 | 	mov	local11, result1 wz
068f0     18 00 90 5D |  if_ne	jmp	#LR__1061
068f4     00 90 06 F6 | 	mov	arg01, #0
068f8     31 BB 02 F6 | 	mov	local11, objptr
068fc     59 63 02 F6 | 	mov	objptr, local07
06900     E0 01 B0 FD | 	call	#_sdmm_cc_disk_initialize
06904     5D 63 02 F6 | 	mov	objptr, local11
06908     3B BB E2 F8 | 	getbyte	local11, result1, #0
0690c                 | LR__1061
0690c     00 BA 0E F2 | 	cmp	local11, #0 wz
06910     D0 00 90 5D |  if_ne	jmp	#LR__1062
06914     A8 EF BF FD | 	call	#__system___get_vfs_file_handle
06918     3B BB 0A F6 | 	mov	local11, result1 wz
0691c     C4 00 90 AD |  if_e	jmp	#LR__1062
06920     04 BA 06 F1 | 	add	local11, #4
06924     5D 05 58 FC | 	wrword	#2, local11
06928     02 BA 06 F1 | 	add	local11, #2
0692c     5D 01 58 FC | 	wrword	#0, local11
06930     02 BA 06 F1 | 	add	local11, #2
06934     40 00 80 FF 
06938     5D 07 68 FC | 	wrlong	##32771, local11
0693c     59 77 02 F6 | 	mov	result1, local07
06940     00 08 01 FF 
06944     00 76 46 F5 | 	or	result1, ##34603008
06948     0C BA 06 F1 | 	add	local11, #12
0694c     5D 77 62 FC | 	wrlong	result1, local11
06950     59 77 02 F6 | 	mov	result1, local07
06954     00 10 01 FF 
06958     00 76 46 F5 | 	or	result1, ##35651584
0695c     04 BA 06 F1 | 	add	local11, #4
06960     5D 77 62 FC | 	wrlong	result1, local11
06964     59 77 02 F6 | 	mov	result1, local07
06968     00 18 01 FF 
0696c     00 76 46 F5 | 	or	result1, ##36700160
06970     0C BA 06 F1 | 	add	local11, #12
06974     5D 77 62 FC | 	wrlong	result1, local11
06978     59 77 02 F6 | 	mov	result1, local07
0697c     00 20 01 FF 
06980     00 76 46 F5 | 	or	result1, ##37748736
06984     04 BA 06 F1 | 	add	local11, #4
06988     5D 77 62 FC | 	wrlong	result1, local11
0698c     59 77 02 F6 | 	mov	result1, local07
06990     00 28 01 FF 
06994     00 76 46 F5 | 	or	result1, ##38797312
06998     04 BA 06 F1 | 	add	local11, #4
0699c     5D 77 62 FC | 	wrlong	result1, local11
069a0     59 77 02 F6 | 	mov	result1, local07
069a4     00 30 01 FF 
069a8     00 76 46 F5 | 	or	result1, ##39845888
069ac     04 BA 06 F1 | 	add	local11, #4
069b0     5D 77 62 FC | 	wrlong	result1, local11
069b4     59 77 02 F6 | 	mov	result1, local07
069b8     00 38 01 FF 
069bc     00 76 46 F5 | 	or	result1, ##40894464
069c0     14 BA 86 F1 | 	sub	local11, #20
069c4     5D 77 62 FC | 	wrlong	result1, local11
069c8     00 40 01 FF 
069cc     00 B2 46 F5 | 	or	local07, ##41943040
069d0     04 BA 06 F1 | 	add	local11, #4
069d4     5D B3 62 FC | 	wrlong	local07, local11
069d8     20 BA 86 F1 | 	sub	local11, #32
069dc     5D 77 02 F6 | 	mov	result1, local11
069e0     24 00 90 FD | 	jmp	#LR__1063
069e4                 | LR__1062
069e4     53 91 02 F6 | 	mov	arg01, local01
069e8     54 93 02 F6 | 	mov	arg02, local02
069ec     98 DB BF FD | 	call	#__system___freepins
069f0     59 91 02 F6 | 	mov	arg01, local07
069f4     F8 E9 BF FD | 	call	#__system___gc_free
069f8     20 66 06 F1 | 	add	ptr___system__dat__, #32
069fc     33 19 68 FC | 	wrlong	#12, ptr___system__dat__
06a00     20 66 86 F1 | 	sub	ptr___system__dat__, #32
06a04     00 76 06 F6 | 	mov	result1, #0
06a08                 | LR__1063
06a08     E7 F0 03 F6 | 	mov	ptra, fp
06a0c     F2 00 A0 FD | 	call	#popregs_
06a10                 | __system___sdmm_open_ret
06a10     2D 00 64 FD | 	ret
06a14                 | 
06a14                 | __system____default_filbuf
06a14     05 CA 05 F6 | 	mov	COUNT_, #5
06a18     E8 00 A0 FD | 	call	#pushregs_
06a1c     48 A7 02 F6 | 	mov	local01, arg01
06a20     53 A9 02 FB | 	rdlong	local02, local01
06a24     08 A8 06 F1 | 	add	local02, #8
06a28     54 77 0A FB | 	rdlong	result1, local02 wz
06a2c     08 A8 86 F1 | 	sub	local02, #8
06a30     20 00 90 5D |  if_ne	jmp	#LR__1070
06a34     10 A8 06 F1 | 	add	local02, #16
06a38     54 77 02 F6 | 	mov	result1, local02
06a3c     04 A8 86 F1 | 	sub	local02, #4
06a40     54 77 62 FC | 	wrlong	result1, local02
06a44     04 A8 86 F1 | 	sub	local02, #4
06a48     02 00 80 FF 
06a4c     54 01 68 FC | 	wrlong	##1024, local02
06a50     08 A8 86 F1 | 	sub	local02, #8
06a54                 | LR__1070
06a54     14 A6 06 F1 | 	add	local01, #20
06a58     53 AB 02 FB | 	rdlong	local03, local01
06a5c     55 AD 02 F6 | 	mov	local04, local03
06a60     14 A6 86 F1 | 	sub	local01, #20
06a64     13 AC 46 F7 | 	zerox	local04, #19
06a68     14 AA 46 F0 | 	shr	local03, #20
06a6c     02 AA 66 F0 | 	shl	local03, #2
06a70     2D AB 02 F1 | 	add	local03, __methods__
06a74     55 AB 02 FB | 	rdlong	local03, local03
06a78     53 91 02 F6 | 	mov	arg01, local01
06a7c     0C A8 06 F1 | 	add	local02, #12
06a80     54 93 02 FB | 	rdlong	arg02, local02
06a84     04 A8 86 F1 | 	sub	local02, #4
06a88     54 95 02 FB | 	rdlong	arg03, local02
06a8c     08 A8 86 F1 | 	sub	local02, #8
06a90     31 AF 02 F6 | 	mov	local05, objptr
06a94     56 63 02 F6 | 	mov	objptr, local04
06a98     2D AA 62 FD | 	call	local03
06a9c     57 63 02 F6 | 	mov	objptr, local05
06aa0     3B AF 02 F6 | 	mov	local05, result1
06aa4     00 AE 56 F2 | 	cmps	local05, #0 wc
06aa8     01 76 66 C6 |  if_b	neg	result1, #1
06aac     28 00 90 CD |  if_b	jmp	#LR__1071
06ab0     54 AF 62 FC | 	wrlong	local05, local02
06ab4     0C A8 06 F1 | 	add	local02, #12
06ab8     54 AB 02 FB | 	rdlong	local03, local02
06abc     08 A8 86 F1 | 	sub	local02, #8
06ac0     54 AB 62 FC | 	wrlong	local03, local02
06ac4     08 A6 06 F1 | 	add	local01, #8
06ac8     53 AD 02 FB | 	rdlong	local04, local01
06acc     04 AC 46 F5 | 	or	local04, #4
06ad0     53 AD 62 FC | 	wrlong	local04, local01
06ad4     57 77 02 F6 | 	mov	result1, local05
06ad8                 | LR__1071
06ad8     E7 F0 03 F6 | 	mov	ptra, fp
06adc     F2 00 A0 FD | 	call	#popregs_
06ae0                 | __system____default_filbuf_ret
06ae0     2D 00 64 FD | 	ret
06ae4                 | 
06ae4                 | _sdmm_cc_disk_initialize
06ae4     0F CA 05 F6 | 	mov	COUNT_, #15
06ae8     E8 00 A0 FD | 	call	#pushregs_
06aec     48 A7 0A F6 | 	mov	local01, arg01 wz
06af0     F8 A9 02 F6 | 	mov	local02, ptra
06af4     31 AB 02 FB | 	rdlong	local03, objptr
06af8     04 62 06 F1 | 	add	objptr, #4
06afc     31 AD 02 FB | 	rdlong	local04, objptr
06b00     04 62 06 F1 | 	add	objptr, #4
06b04     31 AF 02 FB | 	rdlong	local05, objptr
06b08     04 62 06 F1 | 	add	objptr, #4
06b0c     31 B1 02 FB | 	rdlong	local06, objptr
06b10     08 62 06 F1 | 	add	objptr, #8
06b14     31 03 48 FC | 	wrbyte	#1, objptr
06b18     14 62 86 F1 | 	sub	objptr, #20
06b1c                 | ' #line 539 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
06b1c                 | ' 		return RES_NOTRDY;
06b1c     0C F0 07 F1 | 	add	ptra, #12
06b20     03 76 06 56 |  if_ne	mov	result1, #3
06b24     68 04 90 5D |  if_ne	jmp	#LR__1100
06b28     13 00 00 FF 
06b2c     10 91 06 F6 | 	mov	arg01, ##10000
06b30     B8 C7 BF FD | 	call	#__system___waitus
06b34     55 97 02 F6 | 	mov	arg04, local03
06b38     57 97 82 F1 | 	sub	arg04, local05
06b3c     4B 97 42 F6 | 	abs	arg04, arg04
06b40     04 96 56 F2 | 	cmps	arg04, #4 wc
06b44     04 76 06 36 |  if_ae	mov	result1, #4
06b48     44 04 90 3D |  if_ae	jmp	#LR__1100
06b4c     55 B3 02 F6 | 	mov	local07, local03
06b50     58 B3 82 F1 | 	sub	local07, local06
06b54     59 B3 42 F6 | 	abs	local07, local07
06b58     04 B2 56 F2 | 	cmps	local07, #4 wc
06b5c     34 00 90 3D |  if_ae	jmp	#LR__1080
06b60     55 B5 02 F6 | 	mov	local08, local03
06b64     58 B5 82 F1 | 	sub	local08, local06
06b68     07 B4 06 F5 | 	and	local08, #7
06b6c     18 B4 66 F0 | 	shl	local08, #24
06b70     29 00 00 FF 
06b74     7A B4 46 F5 | 	or	local08, ##21114
06b78     58 B7 02 F6 | 	mov	local09, local06
06b7c     0C 62 06 F1 | 	add	objptr, #12
06b80     31 B7 62 FC | 	wrlong	local09, objptr
06b84     04 62 06 F1 | 	add	objptr, #4
06b88     31 B7 62 FC | 	wrlong	local09, objptr
06b8c     10 62 86 F1 | 	sub	objptr, #16
06b90     A4 00 90 FD | 	jmp	#LR__1083
06b94                 | LR__1080
06b94     58 AB 5A F2 | 	cmps	local03, local06 wcz
06b98     28 00 90 ED |  if_be	jmp	#LR__1081
06b9c     55 B7 02 F6 | 	mov	local09, local03
06ba0     03 B6 86 F1 | 	sub	local09, #3
06ba4     57 B7 0A F2 | 	cmp	local09, local05 wz
06ba8     56 B7 0A 52 |  if_ne	cmp	local09, local04 wz
06bac     01 B6 06 A1 |  if_e	add	local09, #1
06bb0     57 B7 0A F2 | 	cmp	local09, local05 wz
06bb4     56 B7 0A 52 |  if_ne	cmp	local09, local04 wz
06bb8     28 00 90 5D |  if_ne	jmp	#LR__1082
06bbc     01 B6 06 F1 | 	add	local09, #1
06bc0     20 00 90 FD | 	jmp	#LR__1082
06bc4                 | LR__1081
06bc4     55 B7 02 F6 | 	mov	local09, local03
06bc8     03 B6 06 F1 | 	add	local09, #3
06bcc     57 B7 0A F2 | 	cmp	local09, local05 wz
06bd0     56 B7 0A 52 |  if_ne	cmp	local09, local04 wz
06bd4     01 B6 86 A1 |  if_e	sub	local09, #1
06bd8     57 B7 0A F2 | 	cmp	local09, local05 wz
06bdc     56 B7 0A 52 |  if_ne	cmp	local09, local04 wz
06be0     01 B6 86 A1 |  if_e	sub	local09, #1
06be4                 | LR__1082
06be4     58 B3 02 F6 | 	mov	local07, local06
06be8     5B B3 82 F1 | 	sub	local07, local09
06bec     59 B3 42 F6 | 	abs	local07, local07
06bf0     04 B2 56 F2 | 	cmps	local07, #4 wc
06bf4     04 76 06 36 |  if_ae	mov	result1, #4
06bf8     94 03 90 3D |  if_ae	jmp	#LR__1100
06bfc     58 B5 02 F6 | 	mov	local08, local06
06c00     5B B5 82 F1 | 	sub	local08, local09
06c04     07 B4 06 F5 | 	and	local08, #7
06c08     1C B4 66 F0 | 	shl	local08, #28
06c0c     55 B3 02 F6 | 	mov	local07, local03
06c10     5B B3 82 F1 | 	sub	local07, local09
06c14     07 B2 06 F5 | 	and	local07, #7
06c18     18 B2 66 F0 | 	shl	local07, #24
06c1c     59 B5 42 F5 | 	or	local08, local07
06c20     3A B4 46 F5 | 	or	local08, #58
06c24     10 62 06 F1 | 	add	objptr, #16
06c28     31 B1 62 FC | 	wrlong	local06, objptr
06c2c     04 62 86 F1 | 	sub	objptr, #4
06c30     31 B7 62 FC | 	wrlong	local09, objptr
06c34     0C 62 86 F1 | 	sub	objptr, #12
06c38                 | LR__1083
06c38     56 01 08 FC | 	wrpin	#0, local04
06c3c     59 AC 62 FD | 	drvh	local04
06c40     00 08 00 FF 
06c44     20 B8 06 F6 | 	mov	local10, ##1048608
06c48     40 AA 62 FD | 	dirl	local03
06c4c     A0 03 80 FF 
06c50     55 91 08 FC | 	wrpin	##475208, local03
06c54     00 08 80 FF 
06c58     55 41 18 FC | 	wxpin	##1048608, local03
06c5c     55 01 28 FC | 	wypin	#0, local03
06c60     41 AA 62 FD | 	dirh	local03
06c64     55 B3 02 F6 | 	mov	local07, local03
06c68     57 B3 82 F1 | 	sub	local07, local05
06c6c     07 B2 06 F5 | 	and	local07, #7
06c70     18 B2 66 F0 | 	shl	local07, #24
06c74     78 BA 06 F6 | 	mov	local11, #120
06c78     59 BB 42 F5 | 	or	local11, local07
06c7c     5D 93 02 F6 | 	mov	arg02, local11
06c80     10 92 26 F4 | 	bith	arg02, #16
06c84     40 AE 62 FD | 	dirl	local05
06c88     57 93 02 FC | 	wrpin	arg02, local05
06c8c     57 3F 18 FC | 	wxpin	#31, local05
06c90     FF FF FF FF 
06c94     57 FF 2B FC | 	wypin	##-1, local05
06c98     41 AE 62 FD | 	dirh	local05
06c9c     29 00 80 FF 
06ca0     58 01 08 FC | 	wrpin	##20992, local06
06ca4     40 B6 62 FD | 	dirl	local09
06ca8     5B B5 02 FC | 	wrpin	local08, local09
06cac     5B 4F 18 FC | 	wxpin	#39, local09
06cb0     5B 01 28 FC | 	wypin	#0, local09
06cb4     41 B6 62 FD | 	dirh	local09
06cb8     54 91 02 F6 | 	mov	arg01, local02
06cbc     0A 92 06 F6 | 	mov	arg02, #10
06cc0     5C 06 B0 FD | 	call	#_sdmm_cc_rcvr_mmc_0287
06cc4     00 90 06 F6 | 	mov	arg01, #0
06cc8     00 92 06 F6 | 	mov	arg02, #0
06ccc     D4 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06cd0     20 07 B0 FD | 	call	#_sdmm_cc_deselect_0297
06cd4     64 90 06 F6 | 	mov	arg01, #100
06cd8     10 C6 BF FD | 	call	#__system___waitus
06cdc     54 91 02 F6 | 	mov	arg01, local02
06ce0     0A 92 06 F6 | 	mov	arg02, #10
06ce4     38 06 B0 FD | 	call	#_sdmm_cc_rcvr_mmc_0287
06ce8     00 BC 06 F6 | 	mov	local12, #0
06cec     00 90 06 F6 | 	mov	arg01, #0
06cf0     00 92 06 F6 | 	mov	arg02, #0
06cf4     AC 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06cf8     3B B3 E2 F8 | 	getbyte	local07, result1, #0
06cfc     01 B2 0E F2 | 	cmp	local07, #1 wz
06d00     5C 02 90 5D |  if_ne	jmp	#LR__1099
06d04     08 90 06 F6 | 	mov	arg01, #8
06d08     AA 93 06 F6 | 	mov	arg02, #426
06d0c     94 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06d10     3B 77 E2 F8 | 	getbyte	result1, result1, #0
06d14     01 76 0E F2 | 	cmp	result1, #1 wz
06d18     30 01 90 5D |  if_ne	jmp	#LR__1088
06d1c     54 91 02 F6 | 	mov	arg01, local02
06d20     04 92 06 F6 | 	mov	arg02, #4
06d24     F8 05 B0 FD | 	call	#_sdmm_cc_rcvr_mmc_0287
06d28     02 A8 06 F1 | 	add	local02, #2
06d2c     54 B3 C2 FA | 	rdbyte	local07, local02
06d30     02 A8 86 F1 | 	sub	local02, #2
06d34     01 B2 0E F2 | 	cmp	local07, #1 wz
06d38     03 A8 06 A1 |  if_e	add	local02, #3
06d3c     54 BF C2 AA |  if_e	rdbyte	local13, local02
06d40     03 A8 86 A1 |  if_e	sub	local02, #3
06d44     AA BE 0E A2 |  if_e	cmp	local13, #170 wz
06d48     14 02 90 5D |  if_ne	jmp	#LR__1098
06d4c                 | ' 				for (tmr = 1000; tmr; tmr--) {
06d4c     01 00 00 FF 
06d50     E8 C1 06 F6 | 	mov	local14, ##1000
06d54                 | LR__1084
06d54     A9 90 06 F6 | 	mov	arg01, #169
06d58     1E 92 C6 F9 | 	decod	arg02, #30
06d5c     44 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06d60     3B B3 02 F6 | 	mov	local07, result1
06d64     07 B2 4E F7 | 	zerox	local07, #7 wz
06d68     18 00 90 AD |  if_e	jmp	#LR__1085
06d6c     01 00 00 FF 
06d70     E8 91 06 F6 | 	mov	arg01, ##1000
06d74     74 C5 BF FD | 	call	#__system___waitus
06d78     60 B3 02 F6 | 	mov	local07, local14
06d7c     01 C0 8E F1 | 	sub	local14, #1 wz
06d80     D0 FF 9F 5D |  if_ne	jmp	#LR__1084
06d84                 | LR__1085
06d84     00 C0 0E F2 | 	cmp	local14, #0 wz
06d88     38 00 90 AD |  if_e	jmp	#LR__1086
06d8c     3A 90 06 F6 | 	mov	arg01, #58
06d90     00 92 06 F6 | 	mov	arg02, #0
06d94     0C 08 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06d98     3B B3 02 F6 | 	mov	local07, result1
06d9c     07 B2 4E F7 | 	zerox	local07, #7 wz
06da0     20 00 90 5D |  if_ne	jmp	#LR__1086
06da4     54 91 02 F6 | 	mov	arg01, local02
06da8     04 92 06 F6 | 	mov	arg02, #4
06dac     70 05 B0 FD | 	call	#_sdmm_cc_rcvr_mmc_0287
06db0     54 C1 C2 FA | 	rdbyte	local14, local02
06db4     40 C0 CE F7 | 	test	local14, #64 wz
06db8     0C B2 06 56 |  if_ne	mov	local07, #12
06dbc     04 B2 06 A6 |  if_e	mov	local07, #4
06dc0     59 BD 02 F6 | 	mov	local12, local07
06dc4                 | LR__1086
06dc4     14 C0 06 FB | 	rdlong	local14, #20
06dc8     F0 FA 02 FF 
06dcc     01 C1 16 F2 | 	cmp	local14, ##100000001 wc
06dd0     5D B3 02 C6 |  if_b	mov	local07, local11
06dd4     1B B2 26 C4 |  if_b	bith	local07, #27
06dd8     59 BB 02 C6 |  if_b	mov	local11, local07
06ddc     10 00 90 CD |  if_b	jmp	#LR__1087
06de0     E1 F5 05 FF 
06de4     01 C0 16 F2 | 	cmp	local14, ##200000001 wc
06de8     80 00 04 CF 
06dec     00 BA 46 C5 |  if_b	or	local11, ##134283264
06df0                 | LR__1087
06df0     F0 FA 02 FF 
06df4     01 C1 16 F2 | 	cmp	local14, ##100000001 wc
06df8     00 01 00 CF 
06dfc     04 B8 06 C6 |  if_b	mov	local10, ##131076
06e00     5C 01 90 CD |  if_b	jmp	#LR__1098
06e04     68 78 04 FF 
06e08     81 C1 16 F2 | 	cmp	local14, ##150000001 wc
06e0c     80 01 00 CF 
06e10     06 B8 06 C6 |  if_b	mov	local10, ##196614
06e14     48 01 90 CD |  if_b	jmp	#LR__1098
06e18     E1 F5 05 FF 
06e1c     01 C0 16 F2 | 	cmp	local14, ##200000001 wc
06e20     00 02 00 CF 
06e24     08 B8 06 C6 |  if_b	mov	local10, ##262152
06e28     34 01 90 CD |  if_b	jmp	#LR__1098
06e2c     59 73 07 FF 
06e30     81 C0 16 F2 | 	cmp	local14, ##250000001 wc
06e34     80 02 00 CF 
06e38     0A B8 06 C6 |  if_b	mov	local10, ##327690
06e3c     20 01 90 CD |  if_b	jmp	#LR__1098
06e40     00 03 00 FF 
06e44     0C B8 06 F6 | 	mov	local10, ##393228
06e48     14 01 90 FD | 	jmp	#LR__1098
06e4c                 | LR__1088
06e4c     A9 90 06 F6 | 	mov	arg01, #169
06e50     00 92 06 F6 | 	mov	arg02, #0
06e54     4C 07 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06e58     3B B3 E2 F8 | 	getbyte	local07, result1, #0
06e5c     02 B2 16 F2 | 	cmp	local07, #2 wc
06e60     02 BC 06 C6 |  if_b	mov	local12, #2
06e64     A9 C2 06 C6 |  if_b	mov	local15, #169
06e68     01 BC 06 36 |  if_ae	mov	local12, #1
06e6c     01 C2 06 36 |  if_ae	mov	local15, #1
06e70                 | ' 				ty =  0x01 ; cmd =  (1) ;
06e70                 | ' 			}
06e70                 | ' 			for (tmr = 1000; tmr; tmr--) {
06e70     01 00 00 FF 
06e74     E8 C1 06 F6 | 	mov	local14, ##1000
06e78                 | LR__1089
06e78     61 91 02 F6 | 	mov	arg01, local15
06e7c     00 92 06 F6 | 	mov	arg02, #0
06e80     20 07 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06e84     3B B3 02 F6 | 	mov	local07, result1
06e88     07 B2 4E F7 | 	zerox	local07, #7 wz
06e8c     18 00 90 AD |  if_e	jmp	#LR__1090
06e90     01 00 00 FF 
06e94     E8 91 06 F6 | 	mov	arg01, ##1000
06e98     50 C4 BF FD | 	call	#__system___waitus
06e9c     60 B3 02 F6 | 	mov	local07, local14
06ea0     01 C0 8E F1 | 	sub	local14, #1 wz
06ea4     D0 FF 9F 5D |  if_ne	jmp	#LR__1089
06ea8                 | LR__1090
06ea8     00 C0 0E F2 | 	cmp	local14, #0 wz
06eac     18 00 90 AD |  if_e	jmp	#LR__1091
06eb0     10 90 06 F6 | 	mov	arg01, #16
06eb4     09 92 C6 F9 | 	decod	arg02, #9
06eb8     E8 06 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
06ebc     3B B3 02 F6 | 	mov	local07, result1
06ec0     07 B2 4E F7 | 	zerox	local07, #7 wz
06ec4     04 00 90 AD |  if_e	jmp	#LR__1092
06ec8                 | LR__1091
06ec8     00 BC 06 F6 | 	mov	local12, #0
06ecc                 | LR__1092
06ecc     14 C0 06 FB | 	rdlong	local14, #20
06ed0     F0 FA 02 FF 
06ed4     01 C1 16 F2 | 	cmp	local14, ##100000001 wc
06ed8     5D B3 02 C6 |  if_b	mov	local07, local11
06edc     1B B2 26 C4 |  if_b	bith	local07, #27
06ee0     59 BB 02 C6 |  if_b	mov	local11, local07
06ee4     10 00 90 CD |  if_b	jmp	#LR__1093
06ee8     E1 F5 05 FF 
06eec     01 C0 16 F2 | 	cmp	local14, ##200000001 wc
06ef0     80 00 04 CF 
06ef4     00 BA 46 C5 |  if_b	or	local11, ##134283264
06ef8                 | LR__1093
06ef8     F0 FA 02 FF 
06efc     01 C1 16 F2 | 	cmp	local14, ##100000001 wc
06f00     00 01 00 CF 
06f04     04 B8 06 C6 |  if_b	mov	local10, ##131076
06f08     54 00 90 CD |  if_b	jmp	#LR__1097
06f0c     68 78 04 FF 
06f10     81 C1 16 F2 | 	cmp	local14, ##150000001 wc
06f14     80 01 00 CF 
06f18     06 B8 06 C6 |  if_b	mov	local10, ##196614
06f1c     40 00 90 CD |  if_b	jmp	#LR__1096
06f20     E1 F5 05 FF 
06f24     01 C0 16 F2 | 	cmp	local14, ##200000001 wc
06f28     00 02 00 CF 
06f2c     08 B8 06 C6 |  if_b	mov	local10, ##262152
06f30     2C 00 90 CD |  if_b	jmp	#LR__1095
06f34     59 73 07 FF 
06f38     81 C0 16 F2 | 	cmp	local14, ##250000001 wc
06f3c     80 02 00 CF 
06f40     0A B8 06 C6 |  if_b	mov	local10, ##327690
06f44     18 00 90 CD |  if_b	jmp	#LR__1094
06f48     D1 F0 08 FF 
06f4c     01 C1 16 F2 | 	cmp	local14, ##300000001 wc
06f50     00 03 00 CF 
06f54     0C B8 06 C6 |  if_b	mov	local10, ##393228
06f58     80 03 00 3F 
06f5c     0E B8 06 36 |  if_ae	mov	local10, ##458766
06f60                 | LR__1094
06f60                 | LR__1095
06f60                 | LR__1096
06f60                 | LR__1097
06f60                 | LR__1098
06f60                 | LR__1099
06f60     15 62 06 F1 | 	add	objptr, #21
06f64     31 BD 42 FC | 	wrbyte	local12, objptr
06f68     00 BC 0E F2 | 	cmp	local12, #0 wz
06f6c     00 B2 06 56 |  if_ne	mov	local07, #0
06f70     01 B2 06 A6 |  if_e	mov	local07, #1
06f74     01 62 86 F1 | 	sub	objptr, #1
06f78     31 B3 42 FC | 	wrbyte	local07, objptr
06f7c     14 62 86 F1 | 	sub	objptr, #20
06f80     70 04 B0 FD | 	call	#_sdmm_cc_deselect_0297
06f84     55 B9 12 FC | 	wxpin	local10, local03
06f88     57 BB 02 FC | 	wrpin	local11, local05
06f8c                 | ' #line 682 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
06f8c                 | ' 		}
06f8c                 | ' 	}
06f8c                 | ' #line 687 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
06f8c                 | ' 	CardType = ty;
06f8c                 | ' 	s = ty ? 0 :  0x01 ;
06f8c                 | ' 	Stat = s;
06f8c                 | ' 
06f8c                 | ' 	deselect();
06f8c                 | ' 
06f8c                 | ' 
06f8c                 | ' 	_wxpin( PIN_CLK, ck_div );
06f8c                 | ' 	_wrpin( PIN_DI, spm_tx );
06f8c                 | ' #line 700 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
06f8c                 | ' 	return s;
06f8c     59 77 02 F6 | 	mov	result1, local07
06f90                 | LR__1100
06f90     E7 F0 03 F6 | 	mov	ptra, fp
06f94     F2 00 A0 FD | 	call	#popregs_
06f98                 | _sdmm_cc_disk_initialize_ret
06f98     2D 00 64 FD | 	ret
06f9c                 | 
06f9c                 | _sdmm_cc_disk_read
06f9c     05 CA 05 F6 | 	mov	COUNT_, #5
06fa0     E8 00 A0 FD | 	call	#pushregs_
06fa4     49 A7 02 F6 | 	mov	local01, arg02
06fa8     4A A9 02 F6 | 	mov	local02, arg03
06fac     4B AB 02 F6 | 	mov	local03, arg04
06fb0     00 90 0E F2 | 	cmp	arg01, #0 wz
06fb4     01 76 06 56 |  if_ne	mov	result1, #1
06fb8                 | ' 
06fb8                 | ' 	return Stat;
06fb8     14 62 06 A1 |  if_e	add	objptr, #20
06fbc     31 77 C2 AA |  if_e	rdbyte	result1, objptr
06fc0     14 62 86 A1 |  if_e	sub	objptr, #20
06fc4     3B 77 E2 F8 | 	getbyte	result1, result1, #0
06fc8     01 76 CE F7 | 	test	result1, #1 wz
06fcc     03 76 06 56 |  if_ne	mov	result1, #3
06fd0     7C 00 90 5D |  if_ne	jmp	#LR__1112
06fd4     15 62 06 F1 | 	add	objptr, #21
06fd8     31 AD C2 FA | 	rdbyte	local04, objptr
06fdc     15 62 86 F1 | 	sub	objptr, #21
06fe0     08 AC CE F7 | 	test	local04, #8 wz
06fe4     09 A8 66 A0 |  if_e	shl	local02, #9
06fe8     02 AA 16 F2 | 	cmp	local03, #2 wc
06fec     12 AC 06 36 |  if_ae	mov	local04, #18
06ff0     11 AC 06 C6 |  if_b	mov	local04, #17
06ff4     54 93 02 F6 | 	mov	arg02, local02
06ff8     56 91 02 F6 | 	mov	arg01, local04
06ffc     A4 05 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
07000     3B AF 02 F6 | 	mov	local05, result1
07004     07 AE 4E F7 | 	zerox	local05, #7 wz
07008     30 00 90 5D |  if_ne	jmp	#LR__1111
0700c                 | ' 		do {
0700c                 | LR__1110
0700c     53 91 02 F6 | 	mov	arg01, local01
07010     09 92 C6 F9 | 	decod	arg02, #9
07014     7C 04 B0 FD | 	call	#_sdmm_cc_rcvr_datablock_0305
07018     00 76 0E F2 | 	cmp	result1, #0 wz
0701c     01 00 00 5F 
07020     00 A6 06 51 |  if_ne	add	local01, ##512
07024     F9 AB 6E 5B |  if_ne	djnz	local03, #LR__1110
07028     56 AD E2 F8 | 	getbyte	local04, local04, #0
0702c     12 AC 0E F2 | 	cmp	local04, #18 wz
07030     0C 90 06 A6 |  if_e	mov	arg01, #12
07034     00 92 06 A6 |  if_e	mov	arg02, #0
07038     68 05 B0 AD |  if_e	call	#_sdmm_cc_send_cmd_0310
0703c                 | LR__1111
0703c     B4 03 B0 FD | 	call	#_sdmm_cc_deselect_0297
07040                 | ' 	}
07040                 | ' 	deselect();
07040                 | ' 
07040                 | ' 	return count ? RES_ERROR : RES_OK;
07040     00 AA 0E F2 | 	cmp	local03, #0 wz
07044     01 AE 06 56 |  if_ne	mov	local05, #1
07048     00 AE 06 A6 |  if_e	mov	local05, #0
0704c     57 77 02 F6 | 	mov	result1, local05
07050                 | LR__1112
07050     E7 F0 03 F6 | 	mov	ptra, fp
07054     F2 00 A0 FD | 	call	#popregs_
07058                 | _sdmm_cc_disk_read_ret
07058     2D 00 64 FD | 	ret
0705c                 | 
0705c                 | _sdmm_cc_disk_write
0705c     04 CA 05 F6 | 	mov	COUNT_, #4
07060     E8 00 A0 FD | 	call	#pushregs_
07064     49 A7 02 F6 | 	mov	local01, arg02
07068     4B A9 02 F6 | 	mov	local02, arg04
0706c     4A AB 02 F6 | 	mov	local03, arg03
07070     00 90 0E F2 | 	cmp	arg01, #0 wz
07074     01 76 06 56 |  if_ne	mov	result1, #1
07078                 | ' 
07078                 | ' 	return Stat;
07078     14 62 06 A1 |  if_e	add	objptr, #20
0707c     31 77 C2 AA |  if_e	rdbyte	result1, objptr
07080     14 62 86 A1 |  if_e	sub	objptr, #20
07084     3B 77 E2 F8 | 	getbyte	result1, result1, #0
07088     01 76 CE F7 | 	test	result1, #1 wz
0708c     03 76 06 56 |  if_ne	mov	result1, #3
07090     C4 00 90 5D |  if_ne	jmp	#LR__1124
07094     15 62 06 F1 | 	add	objptr, #21
07098     31 95 C2 FA | 	rdbyte	arg03, objptr
0709c     15 62 86 F1 | 	sub	objptr, #21
070a0     08 94 CE F7 | 	test	arg03, #8 wz
070a4     09 AA 66 A0 |  if_e	shl	local03, #9
070a8     01 A8 0E F2 | 	cmp	local02, #1 wz
070ac     30 00 90 5D |  if_ne	jmp	#LR__1120
070b0     18 90 06 F6 | 	mov	arg01, #24
070b4     55 93 02 F6 | 	mov	arg02, local03
070b8     E8 04 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
070bc     3B AD 02 F6 | 	mov	local04, result1
070c0     07 AC 4E F7 | 	zerox	local04, #7 wz
070c4     7C 00 90 5D |  if_ne	jmp	#LR__1123
070c8     53 91 02 F6 | 	mov	arg01, local01
070cc     FE 92 06 F6 | 	mov	arg02, #254
070d0     44 04 B0 FD | 	call	#_sdmm_cc_xmit_datablock_0307
070d4     00 76 0E F2 | 	cmp	result1, #0 wz
070d8     00 A8 06 56 |  if_ne	mov	local02, #0
070dc     64 00 90 FD | 	jmp	#LR__1123
070e0                 | LR__1120
070e0     15 62 06 F1 | 	add	objptr, #21
070e4     31 AD C2 FA | 	rdbyte	local04, objptr
070e8     15 62 86 F1 | 	sub	objptr, #21
070ec     06 AC CE F7 | 	test	local04, #6 wz
070f0     97 90 06 56 |  if_ne	mov	arg01, #151
070f4     54 93 02 56 |  if_ne	mov	arg02, local02
070f8     A8 04 B0 5D |  if_ne	call	#_sdmm_cc_send_cmd_0310
070fc     55 93 02 F6 | 	mov	arg02, local03
07100     19 90 06 F6 | 	mov	arg01, #25
07104     9C 04 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
07108     3B AD 02 F6 | 	mov	local04, result1
0710c     07 AC 4E F7 | 	zerox	local04, #7 wz
07110     30 00 90 5D |  if_ne	jmp	#LR__1122
07114                 | ' 			do {
07114                 | LR__1121
07114     53 91 02 F6 | 	mov	arg01, local01
07118     FC 92 06 F6 | 	mov	arg02, #252
0711c     F8 03 B0 FD | 	call	#_sdmm_cc_xmit_datablock_0307
07120     00 76 0E F2 | 	cmp	result1, #0 wz
07124     01 00 00 5F 
07128     00 A6 06 51 |  if_ne	add	local01, ##512
0712c     F9 A9 6E 5B |  if_ne	djnz	local02, #LR__1121
07130     00 90 06 F6 | 	mov	arg01, #0
07134     FD 92 06 F6 | 	mov	arg02, #253
07138     DC 03 B0 FD | 	call	#_sdmm_cc_xmit_datablock_0307
0713c     00 76 0E F2 | 	cmp	result1, #0 wz
07140     01 A8 06 A6 |  if_e	mov	local02, #1
07144                 | LR__1122
07144                 | LR__1123
07144     AC 02 B0 FD | 	call	#_sdmm_cc_deselect_0297
07148                 | ' 				count = 1;
07148                 | ' 		}
07148                 | ' 	}
07148                 | ' 	deselect();
07148                 | ' 
07148                 | ' 	return count ? RES_ERROR : RES_OK;
07148     00 A8 0E F2 | 	cmp	local02, #0 wz
0714c     01 AC 06 56 |  if_ne	mov	local04, #1
07150     00 AC 06 A6 |  if_e	mov	local04, #0
07154     56 77 02 F6 | 	mov	result1, local04
07158                 | LR__1124
07158     E7 F0 03 F6 | 	mov	ptra, fp
0715c     F2 00 A0 FD | 	call	#popregs_
07160                 | _sdmm_cc_disk_write_ret
07160     2D 00 64 FD | 	ret
07164                 | 
07164                 | _sdmm_cc_disk_ioctl
07164     06 CA 05 F6 | 	mov	COUNT_, #6
07168     E8 00 A0 FD | 	call	#pushregs_
0716c     30 F0 07 F1 | 	add	ptra, #48
07170     49 A7 02 F6 | 	mov	local01, arg02
07174     4A A9 02 F6 | 	mov	local02, arg03
07178     00 90 0E F2 | 	cmp	arg01, #0 wz
0717c     01 76 06 56 |  if_ne	mov	result1, #1
07180                 | ' 
07180                 | ' 	return Stat;
07180     14 62 06 A1 |  if_e	add	objptr, #20
07184     31 77 C2 AA |  if_e	rdbyte	result1, objptr
07188     14 62 86 A1 |  if_e	sub	objptr, #20
0718c     3B 77 E2 F8 | 	getbyte	result1, result1, #0
07190     01 76 CE F7 | 	test	result1, #1 wz
07194     03 76 06 56 |  if_ne	mov	result1, #3
07198     F4 00 90 5D |  if_ne	jmp	#LR__1137
0719c     01 AA 06 F6 | 	mov	local03, #1
071a0                 | ' 
071a0                 | ' 	res = RES_ERROR;
071a0                 | ' 	switch (ctrl) {
071a0     53 AD E2 F8 | 	getbyte	local04, local01, #0
071a4     04 AC 26 F3 | 	fle	local04, #4
071a8     30 AC 62 FD | 	jmprel	local04
071ac                 | LR__1130
071ac     10 00 90 FD | 	jmp	#LR__1131
071b0     1C 00 90 FD | 	jmp	#LR__1132
071b4     CC 00 90 FD | 	jmp	#LR__1135
071b8     BC 00 90 FD | 	jmp	#LR__1134
071bc     C4 00 90 FD | 	jmp	#LR__1135
071c0                 | LR__1131
071c0     6C 02 B0 FD | 	call	#_sdmm_cc_select_0301
071c4     00 76 0E F2 | 	cmp	result1, #0 wz
071c8     00 AA 06 56 |  if_ne	mov	local03, #0
071cc                 | ' 			break;
071cc     B8 00 90 FD | 	jmp	#LR__1136
071d0                 | LR__1132
071d0     09 90 06 F6 | 	mov	arg01, #9
071d4     00 92 06 F6 | 	mov	arg02, #0
071d8     C8 03 B0 FD | 	call	#_sdmm_cc_send_cmd_0310
071dc     3B AD 02 F6 | 	mov	local04, result1
071e0     07 AC 4E F7 | 	zerox	local04, #7 wz
071e4     A0 00 90 5D |  if_ne	jmp	#LR__1136
071e8     E7 90 02 F6 | 	mov	arg01, fp
071ec     18 90 06 F1 | 	add	arg01, #24
071f0     10 92 06 F6 | 	mov	arg02, #16
071f4     9C 02 B0 FD | 	call	#_sdmm_cc_rcvr_datablock_0305
071f8     00 76 0E F2 | 	cmp	result1, #0 wz
071fc     88 00 90 AD |  if_e	jmp	#LR__1136
07200     E7 90 02 F6 | 	mov	arg01, fp
07204     18 90 06 F1 | 	add	arg01, #24
07208     48 77 02 F6 | 	mov	result1, arg01
0720c     06 90 06 F1 | 	add	arg01, #6
07210     48 AF 02 FB | 	rdlong	local05, arg01
07214     1B AE FE F9 | 	movbyts	local05, #27
07218     3B 91 C2 FA | 	rdbyte	arg01, result1
0721c     06 90 46 F0 | 	shr	arg01, #6
07220     01 90 0E F2 | 	cmp	arg01, #1 wz
07224     36 AF 06 A4 |  if_e	bitl	local05, #310
07228     01 AE 06 A1 |  if_e	add	local05, #1
0722c     0A B0 06 A6 |  if_e	mov	local06, #10
07230     34 00 90 AD |  if_e	jmp	#LR__1133
07234     0E AE 46 F0 | 	shr	local05, #14
07238     0B AE 46 F7 | 	zerox	local05, #11
0723c     01 AE 06 F1 | 	add	local05, #1
07240     05 76 06 F1 | 	add	result1, #5
07244     3B B1 C2 FA | 	rdbyte	local06, result1
07248     58 B1 42 F8 | 	getnib	local06, local06, #0
0724c     04 76 06 F1 | 	add	result1, #4
07250     3B 77 E2 FA | 	rdword	result1, result1
07254     1B 76 FE F9 | 	movbyts	result1, #27
07258     17 76 46 F0 | 	shr	result1, #23
0725c     07 76 06 F5 | 	and	result1, #7
07260     3B B1 02 F1 | 	add	local06, result1
07264     07 B0 86 F1 | 	sub	local06, #7
07268                 | LR__1133
07268                 | '         cs = (LBA_t)(cs>>14 & 0xfff)+1;
07268                 | '         n = (csd[5] & 15) + (__builtin_bswap32(*(uint16_t*)(&csd[9]))>>23 & 0x7)+(2-9);
07268                 | '     }
07268                 | '     return (LBA_t)cs << n;
07268     58 AF 62 F0 | 	shl	local05, local06
0726c     54 AF 62 FC | 	wrlong	local05, local02
07270     00 AA 06 F6 | 	mov	local03, #0
07274                 | '                			*(LBA_t*)buff = disc_size(csd);
07274                 | ' 				res = RES_OK;
07274                 | ' 			}
07274                 | ' 			break;
07274     10 00 90 FD | 	jmp	#LR__1136
07278                 | LR__1134
07278     54 01 69 FC | 	wrlong	#128, local02
0727c     00 AA 06 F6 | 	mov	local03, #0
07280                 | ' 			*(DWORD*)buff = 128;
07280                 | ' 			res = RES_OK;
07280                 | ' 			break;
07280     04 00 90 FD | 	jmp	#LR__1136
07284                 | LR__1135
07284     04 AA 06 F6 | 	mov	local03, #4
07288                 | LR__1136
07288     68 01 B0 FD | 	call	#_sdmm_cc_deselect_0297
0728c                 | ' 			res = RES_PARERR;
0728c                 | ' 	}
0728c                 | ' 
0728c                 | ' 	deselect();
0728c                 | ' 
0728c                 | ' 	return res;
0728c     55 77 02 F6 | 	mov	result1, local03
07290                 | LR__1137
07290     E7 F0 03 F6 | 	mov	ptra, fp
07294     F2 00 A0 FD | 	call	#popregs_
07298                 | _sdmm_cc_disk_ioctl_ret
07298     2D 00 64 FD | 	ret
0729c                 | 
0729c                 | _sdmm_cc_xmit_mmc_0280
0729c     31 7D 02 FB | 	rdlong	_var01, objptr
072a0     08 62 06 F1 | 	add	objptr, #8
072a4     31 7F 02 FB | 	rdlong	_var02, objptr
072a8     08 62 86 F1 | 	sub	objptr, #8
072ac     40 7E 62 FD | 	dirl	_var02
072b0     28 02 64 FD | 	setq	#1
072b4     48 81 02 FB | 	rdlong	_var03, arg01
072b8     69 80 62 FD | 	rev	_var03
072bc     1B 80 FE F9 | 	movbyts	_var03, #27
072c0     3F 81 22 FC | 	wypin	_var03, _var02
072c4     49 81 02 F6 | 	mov	_var03, arg02
072c8     02 92 4E F0 | 	shr	arg02, #2 wz
072cc     03 80 66 F0 | 	shl	_var03, #3
072d0     3E 81 22 FC | 	wypin	_var03, _var01
072d4     41 7E 62 FD | 	dirh	_var02
072d8     08 90 06 F1 | 	add	arg01, #8
072dc     69 82 62 FD | 	rev	_var04
072e0     1B 82 FE F9 | 	movbyts	_var04, #27
072e4                 | LR__1140
072e4     3F 83 22 5C |  if_ne	wypin	_var04, _var02
072e8     48 83 02 5B |  if_ne	rdlong	_var04, arg01
072ec     04 90 06 51 |  if_ne	add	arg01, #4
072f0     69 82 62 5D |  if_ne	rev	_var04
072f4     1B 82 FE 59 |  if_ne	movbyts	_var04, #27
072f8                 | LR__1141
072f8     40 7E 72 5D |  if_ne	testp	_var02 wc
072fc     F8 FF 9F 1D |  if_a	jmp	#LR__1141
07300     F8 93 6E 5B |  if_ne	djnz	arg02, #LR__1140
07304                 | LR__1142
07304     40 7C 72 FD | 	testp	_var01 wc
07308     F8 FF 9F 3D |  if_ae	jmp	#LR__1142
0730c     40 7E 62 FD | 	dirl	_var02
07310     FF FF FF FF 
07314     3F FF 2B FC | 	wypin	##-1, _var02
07318     41 7E 62 FD | 	dirh	_var02
0731c                 | _sdmm_cc_xmit_mmc_0280_ret
0731c     2D 00 64 FD | 	ret
07320                 | 
07320                 | _sdmm_cc_rcvr_mmc_0287
07320     31 7D 02 FB | 	rdlong	_var01, objptr
07324     0C 62 06 F1 | 	add	objptr, #12
07328     31 7F 02 FB | 	rdlong	_var02, objptr
0732c     0C 62 86 F1 | 	sub	objptr, #12
07330     3F 03 08 FC | 	akpin	_var02
07334     49 81 0A F6 | 	mov	_var03, arg02 wz
07338     02 80 4E F0 | 	shr	_var03, #2 wz
0733c     30 00 90 AD |  if_e	jmp	#LR__1152
07340     40 83 02 F6 | 	mov	_var04, _var03
07344     05 82 66 F0 | 	shl	_var04, #5
07348     3E 83 22 FC | 	wypin	_var04, _var01
0734c     3F 7F 18 FC | 	wxpin	#63, _var02
07350                 | LR__1150
07350                 | LR__1151
07350     40 7E 72 FD | 	testp	_var02 wc
07354     F8 FF 9F 3D |  if_ae	jmp	#LR__1151
07358     3F 83 8A FA | 	rdpin	_var04, _var02
0735c     69 82 62 FD | 	rev	_var04
07360     1B 82 FE F9 | 	movbyts	_var04, #27
07364     48 83 62 FC | 	wrlong	_var04, arg01
07368     04 90 06 F1 | 	add	arg01, #4
0736c     F8 81 6E FB | 	djnz	_var03, #LR__1150
07370                 | LR__1152
07370     03 92 0E F5 | 	and	arg02, #3 wz
07374     24 00 90 AD |  if_e	jmp	#LR__1155
07378     3F 4F 18 FC | 	wxpin	#39, _var02
0737c                 | LR__1153
0737c     3E 11 28 FC | 	wypin	#8, _var01
07380                 | LR__1154
07380     40 7E 72 FD | 	testp	_var02 wc
07384     F8 FF 9F 3D |  if_ae	jmp	#LR__1154
07388     3F 83 8A FA | 	rdpin	_var04, _var02
0738c     69 82 62 FD | 	rev	_var04
07390     48 83 42 FC | 	wrbyte	_var04, arg01
07394     01 90 06 F1 | 	add	arg01, #1
07398     F8 93 6E FB | 	djnz	arg02, #LR__1153
0739c                 | LR__1155
0739c                 | _sdmm_cc_rcvr_mmc_0287_ret
0739c     2D 00 64 FD | 	ret
073a0                 | 
073a0                 | _sdmm_cc_wait_ready_0291
073a0     03 CA 05 F6 | 	mov	COUNT_, #3
073a4     E8 00 A0 FD | 	call	#pushregs_
073a8     F8 A7 02 F6 | 	mov	local01, ptra
073ac     1A A8 62 FD | 	getct	local02
073b0     14 AA 06 FB | 	rdlong	local03, #20
073b4     01 AA 46 F0 | 	shr	local03, #1
073b8                 | ' 	UINT tmr, tmout;
073b8                 | ' 
073b8                 | ' 	tmr = _cnt();
073b8                 | ' 	tmout =  (*(uint32_t *)0x14)  >> 1;
073b8                 | ' 	for(;;) {
073b8     04 F0 07 F1 | 	add	ptra, #4
073bc                 | LR__1160
073bc     53 91 02 F6 | 	mov	arg01, local01
073c0     01 92 06 F6 | 	mov	arg02, #1
073c4     58 FF BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
073c8     53 93 C2 FA | 	rdbyte	arg02, local01
073cc     FF 92 0E F2 | 	cmp	arg02, #255 wz
073d0     01 76 06 A6 |  if_e	mov	result1, #1
073d4     1A 76 62 5D |  if_ne	getct	result1
073d8     54 77 82 51 |  if_ne	sub	result1, local02
073dc     55 77 12 52 |  if_ne	cmp	result1, local03 wc
073e0     00 76 06 16 |  if_a	mov	result1, #0
073e4     D4 FF 9F 4D |  if_c_and_nz	jmp	#LR__1160
073e8     E7 F0 03 F6 | 	mov	ptra, fp
073ec     F2 00 A0 FD | 	call	#popregs_
073f0                 | _sdmm_cc_wait_ready_0291_ret
073f0     2D 00 64 FD | 	ret
073f4                 | 
073f4                 | _sdmm_cc_deselect_0297
073f4     00 CA 05 F6 | 	mov	COUNT_, #0
073f8     E8 00 A0 FD | 	call	#pushregs_
073fc     F8 93 02 F6 | 	mov	arg02, ptra
07400     04 62 06 F1 | 	add	objptr, #4
07404     31 91 02 FB | 	rdlong	arg01, objptr
07408     04 62 86 F1 | 	sub	objptr, #4
0740c     04 F0 07 F1 | 	add	ptra, #4
07410     59 90 62 FD | 	drvh	arg01
07414     1F 20 64 FD | 	waitx	#16
07418     49 91 02 F6 | 	mov	arg01, arg02
0741c     01 92 06 F6 | 	mov	arg02, #1
07420     FC FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07424     E7 F0 03 F6 | 	mov	ptra, fp
07428     F2 00 A0 FD | 	call	#popregs_
0742c                 | _sdmm_cc_deselect_0297_ret
0742c     2D 00 64 FD | 	ret
07430                 | 
07430                 | _sdmm_cc_select_0301
07430     01 CA 05 F6 | 	mov	COUNT_, #1
07434     E8 00 A0 FD | 	call	#pushregs_
07438     F8 93 02 F6 | 	mov	arg02, ptra
0743c     04 62 06 F1 | 	add	objptr, #4
07440     31 91 02 FB | 	rdlong	arg01, objptr
07444     08 62 06 F1 | 	add	objptr, #8
07448     31 A7 02 FB | 	rdlong	local01, objptr
0744c     0C 62 86 F1 | 	sub	objptr, #12
07450     04 F0 07 F1 | 	add	ptra, #4
07454     50 A6 62 FD | 	fltl	local01
07458     58 90 62 FD | 	drvl	arg01
0745c     1F 20 64 FD | 	waitx	#16
07460     41 A6 62 FD | 	dirh	local01
07464     49 91 02 F6 | 	mov	arg01, arg02
07468     01 92 06 F6 | 	mov	arg02, #1
0746c     B0 FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07470     2C FF BF FD | 	call	#_sdmm_cc_wait_ready_0291
07474     00 76 0E F2 | 	cmp	result1, #0 wz
07478     01 76 06 56 |  if_ne	mov	result1, #1
0747c     08 00 90 5D |  if_ne	jmp	#LR__1170
07480     70 FF BF FD | 	call	#_sdmm_cc_deselect_0297
07484                 | ' 
07484                 | ' 	deselect();
07484                 | ' 	return 0;
07484     00 76 06 F6 | 	mov	result1, #0
07488                 | LR__1170
07488     E7 F0 03 F6 | 	mov	ptra, fp
0748c     F2 00 A0 FD | 	call	#popregs_
07490                 | _sdmm_cc_select_0301_ret
07490     2D 00 64 FD | 	ret
07494                 | 
07494                 | _sdmm_cc_rcvr_datablock_0305
07494     05 CA 05 F6 | 	mov	COUNT_, #5
07498     E8 00 A0 FD | 	call	#pushregs_
0749c     48 A7 02 F6 | 	mov	local01, arg01
074a0     49 A9 02 F6 | 	mov	local02, arg02
074a4     F8 AB 02 F6 | 	mov	local03, ptra
074a8     1A AC 62 FD | 	getct	local04
074ac     14 AE 06 FB | 	rdlong	local05, #20
074b0     03 AE 46 F0 | 	shr	local05, #3
074b4                 | ' 	UINT tmr, tmout;
074b4                 | ' 
074b4                 | ' 	tmr = _cnt();
074b4                 | ' 	tmout =  (*(uint32_t *)0x14)  >> 3;
074b4                 | ' 	for(;;) {
074b4     04 F0 07 F1 | 	add	ptra, #4
074b8                 | LR__1180
074b8     55 91 02 F6 | 	mov	arg01, local03
074bc     01 92 06 F6 | 	mov	arg02, #1
074c0     5C FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
074c4     55 93 C2 FA | 	rdbyte	arg02, local03
074c8     FF 92 0E F2 | 	cmp	arg02, #255 wz
074cc     1A 76 62 AD |  if_e	getct	result1
074d0     3B 93 02 A6 |  if_e	mov	arg02, result1
074d4     56 93 82 A1 |  if_e	sub	arg02, local04
074d8     57 93 12 A2 |  if_e	cmp	arg02, local05 wc
074dc     D8 FF 9F 8D |  if_c_and_z	jmp	#LR__1180
074e0     55 AF C2 FA | 	rdbyte	local05, local03
074e4     FE AE 0E F2 | 	cmp	local05, #254 wz
074e8     00 76 06 56 |  if_ne	mov	result1, #0
074ec     1C 00 90 5D |  if_ne	jmp	#LR__1181
074f0     53 91 02 F6 | 	mov	arg01, local01
074f4     54 93 02 F6 | 	mov	arg02, local02
074f8     24 FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
074fc     55 91 02 F6 | 	mov	arg01, local03
07500     02 92 06 F6 | 	mov	arg02, #2
07504     18 FE BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07508                 | ' 
07508                 | ' 	rcvr_mmc(buff, btr);
07508                 | ' 	rcvr_mmc(d, 2);
07508                 | ' 
07508                 | ' 	return 1;
07508     01 76 06 F6 | 	mov	result1, #1
0750c                 | LR__1181
0750c     E7 F0 03 F6 | 	mov	ptra, fp
07510     F2 00 A0 FD | 	call	#popregs_
07514                 | _sdmm_cc_rcvr_datablock_0305_ret
07514     2D 00 64 FD | 	ret
07518                 | 
07518                 | _sdmm_cc_xmit_datablock_0307
07518     03 CA 05 F6 | 	mov	COUNT_, #3
0751c     E8 00 A0 FD | 	call	#pushregs_
07520     48 A7 02 F6 | 	mov	local01, arg01
07524     49 A9 02 F6 | 	mov	local02, arg02
07528     F8 AB 02 F6 | 	mov	local03, ptra
0752c     04 F0 07 F1 | 	add	ptra, #4
07530     6C FE BF FD | 	call	#_sdmm_cc_wait_ready_0291
07534     00 76 0E F2 | 	cmp	result1, #0 wz
07538     00 76 06 A6 |  if_e	mov	result1, #0
0753c     58 00 90 AD |  if_e	jmp	#LR__1191
07540     55 A9 42 FC | 	wrbyte	local02, local03
07544     55 91 02 F6 | 	mov	arg01, local03
07548     01 92 06 F6 | 	mov	arg02, #1
0754c     4C FD BF FD | 	call	#_sdmm_cc_xmit_mmc_0280
07550     54 A9 E2 F8 | 	getbyte	local02, local02, #0
07554     FD A8 0E F2 | 	cmp	local02, #253 wz
07558     38 00 90 AD |  if_e	jmp	#LR__1190
0755c     53 91 02 F6 | 	mov	arg01, local01
07560     09 92 C6 F9 | 	decod	arg02, #9
07564     34 FD BF FD | 	call	#_sdmm_cc_xmit_mmc_0280
07568     55 91 02 F6 | 	mov	arg01, local03
0756c     02 92 06 F6 | 	mov	arg02, #2
07570     AC FD BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07574     55 91 02 F6 | 	mov	arg01, local03
07578     01 92 06 F6 | 	mov	arg02, #1
0757c     A0 FD BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07580     55 AB C2 FA | 	rdbyte	local03, local03
07584     1F AA 06 F5 | 	and	local03, #31
07588     05 AA 0E F2 | 	cmp	local03, #5 wz
0758c                 | ' 			return 0;
0758c     00 76 06 56 |  if_ne	mov	result1, #0
07590     04 00 90 5D |  if_ne	jmp	#LR__1191
07594                 | LR__1190
07594                 | ' 	}
07594                 | ' 
07594                 | ' 	return 1;
07594     01 76 06 F6 | 	mov	result1, #1
07598                 | LR__1191
07598     E7 F0 03 F6 | 	mov	ptra, fp
0759c     F2 00 A0 FD | 	call	#popregs_
075a0                 | _sdmm_cc_xmit_datablock_0307_ret
075a0     2D 00 64 FD | 	ret
075a4                 | 
075a4                 | _sdmm_cc_send_cmd_0310
075a4     04 CA 05 F6 | 	mov	COUNT_, #4
075a8     E8 00 A0 FD | 	call	#pushregs_
075ac                 | _sdmm_cc_send_cmd_0310_enter
075ac     48 A7 02 F6 | 	mov	local01, arg01
075b0     49 A9 02 F6 | 	mov	local02, arg02
075b4     F8 AB 02 F6 | 	mov	local03, ptra
075b8     53 77 E2 F8 | 	getbyte	result1, local01, #0
075bc     80 76 CE F7 | 	test	result1, #128 wz
075c0     08 F0 07 F1 | 	add	ptra, #8
075c4     20 00 90 AD |  if_e	jmp	#LR__1200
075c8     53 A7 E2 F8 | 	getbyte	local01, local01, #0
075cc     7F A6 06 F5 | 	and	local01, #127
075d0     37 90 06 F6 | 	mov	arg01, #55
075d4     00 92 06 F6 | 	mov	arg02, #0
075d8     C8 FF BF FD | 	call	#_sdmm_cc_send_cmd_0310
075dc     3B 93 E2 F8 | 	getbyte	arg02, result1, #0
075e0     02 92 16 F2 | 	cmp	arg02, #2 wc
075e4     BC 00 90 3D |  if_ae	jmp	#LR__1203
075e8                 | LR__1200
075e8     53 77 E2 F8 | 	getbyte	result1, local01, #0
075ec     0C 76 0E F2 | 	cmp	result1, #12 wz
075f0     14 00 90 AD |  if_e	jmp	#LR__1201
075f4     FC FD BF FD | 	call	#_sdmm_cc_deselect_0297
075f8     34 FE BF FD | 	call	#_sdmm_cc_select_0301
075fc     00 76 0E F2 | 	cmp	result1, #0 wz
07600     FF 76 06 A6 |  if_e	mov	result1, #255
07604     9C 00 90 AD |  if_e	jmp	#LR__1203
07608                 | LR__1201
07608     53 93 E2 F8 | 	getbyte	arg02, local01, #0
0760c     40 76 06 F6 | 	mov	result1, #64
07610     49 77 42 F5 | 	or	result1, arg02
07614     55 77 42 FC | 	wrbyte	result1, local03
07618     55 93 02 F6 | 	mov	arg02, local03
0761c     01 92 06 F1 | 	add	arg02, #1
07620     1B A8 FE F9 | 	movbyts	local02, #27
07624     49 A9 62 FC | 	wrlong	local02, arg02
07628     01 AC 06 F6 | 	mov	local04, #1
0762c     53 A9 02 F6 | 	mov	local02, local01
07630     07 A8 4E F7 | 	zerox	local02, #7 wz
07634     95 AC 06 A6 |  if_e	mov	local04, #149
07638     53 A9 E2 F8 | 	getbyte	local02, local01, #0
0763c     08 A8 0E F2 | 	cmp	local02, #8 wz
07640     87 AC 06 A6 |  if_e	mov	local04, #135
07644     05 AA 06 F1 | 	add	local03, #5
07648     55 AD 42 FC | 	wrbyte	local04, local03
0764c     05 AA 86 F1 | 	sub	local03, #5
07650     55 91 02 F6 | 	mov	arg01, local03
07654     06 92 06 F6 | 	mov	arg02, #6
07658     40 FC BF FD | 	call	#_sdmm_cc_xmit_mmc_0280
0765c     53 A7 E2 F8 | 	getbyte	local01, local01, #0
07660     0C A6 0E F2 | 	cmp	local01, #12 wz
07664     55 91 02 A6 |  if_e	mov	arg01, local03
07668     06 90 06 A1 |  if_e	add	arg01, #6
0766c     01 92 06 A6 |  if_e	mov	arg02, #1
07670     AC FC BF AD |  if_e	call	#_sdmm_cc_rcvr_mmc_0287
07674     0A AC 06 F6 | 	mov	local04, #10
07678                 | ' 	n = 10;
07678                 | ' 	do
07678                 | LR__1202
07678     55 91 02 F6 | 	mov	arg01, local03
0767c     06 90 06 F1 | 	add	arg01, #6
07680     01 92 06 F6 | 	mov	arg02, #1
07684     98 FC BF FD | 	call	#_sdmm_cc_rcvr_mmc_0287
07688     06 AA 06 F1 | 	add	local03, #6
0768c     55 A9 C2 FA | 	rdbyte	local02, local03
07690     06 AA 86 F1 | 	sub	local03, #6
07694     80 A8 CE F7 | 	test	local02, #128 wz
07698     F7 AD 6E 5B |  if_ne	djnz	local04, #LR__1202
0769c                 | ' 
0769c                 | ' 	return buf[6];
0769c     06 AA 06 F1 | 	add	local03, #6
076a0     55 77 C2 FA | 	rdbyte	result1, local03
076a4                 | LR__1203
076a4     E7 F0 03 F6 | 	mov	ptra, fp
076a8     F2 00 A0 FD | 	call	#popregs_
076ac                 | _sdmm_cc_send_cmd_0310_ret
076ac     2D 00 64 FD | 	ret
076b0                 | 
076b0                 | _sdmm_cc_disk_setpins
076b0     00 90 0E F2 | 	cmp	arg01, #0 wz
076b4     01 76 66 56 |  if_ne	neg	result1, #1
076b8     24 00 90 5D |  if_ne	jmp	#_sdmm_cc_disk_setpins_ret
076bc     31 93 62 FC | 	wrlong	arg02, objptr
076c0     04 62 06 F1 | 	add	objptr, #4
076c4     31 95 62 FC | 	wrlong	arg03, objptr
076c8     04 62 06 F1 | 	add	objptr, #4
076cc     31 97 62 FC | 	wrlong	arg04, objptr
076d0     04 62 06 F1 | 	add	objptr, #4
076d4     31 99 62 FC | 	wrlong	arg05, objptr
076d8     0C 62 86 F1 | 	sub	objptr, #12
076dc                 | '     _pin_clk = pclk;
076dc                 | '     _pin_ss = pss;
076dc                 | '     _pin_di = pdi;
076dc                 | '     _pin_do = pdo;
076dc                 | ' #line 848 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
076dc                 | '     return 0;
076dc     00 76 06 F6 | 	mov	result1, #0
076e0                 | _sdmm_cc_disk_setpins_ret
076e0     2D 00 64 FD | 	ret
076e4                 | 
076e4                 | _sdmm_cc_disk_deinitialize
076e4     04 CA 05 F6 | 	mov	COUNT_, #4
076e8     E8 00 A0 FD | 	call	#pushregs_
076ec     00 90 4E F2 | 	cmps	arg01, #0 wz
076f0     31 A7 02 FB | 	rdlong	local01, objptr
076f4     04 62 06 F1 | 	add	objptr, #4
076f8     31 A9 02 FB | 	rdlong	local02, objptr
076fc     04 62 06 F1 | 	add	objptr, #4
07700     31 AB 02 FB | 	rdlong	local03, objptr
07704     08 62 06 F1 | 	add	objptr, #8
07708     31 AD 02 FB | 	rdlong	local04, objptr
0770c     04 62 86 F1 | 	sub	objptr, #4
07710     31 91 02 FB | 	rdlong	arg01, objptr
07714     0C 62 86 F1 | 	sub	objptr, #12
07718                 | ' #line 865 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
07718                 | '         return RES_NOTRDY;
07718     03 76 06 56 |  if_ne	mov	result1, #3
0771c     34 00 90 5D |  if_ne	jmp	#LR__1210
07720     50 90 62 FD | 	fltl	arg01
07724     48 01 08 FC | 	wrpin	#0, arg01
07728     50 AC 62 FD | 	fltl	local04
0772c     56 01 08 FC | 	wrpin	#0, local04
07730     50 AA 62 FD | 	fltl	local03
07734     55 01 08 FC | 	wrpin	#0, local03
07738     50 A6 62 FD | 	fltl	local01
0773c     53 01 08 FC | 	wrpin	#0, local01
07740     50 A8 62 FD | 	fltl	local02
07744     54 01 08 FC | 	wrpin	#0, local02
07748     0A 90 06 F6 | 	mov	arg01, #10
0774c     30 BB BF FD | 	call	#__system___waitms
07750                 | '     }
07750                 | ' #line 871 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/block/sdmm.cc"
07750                 | '     _pinclear(SMPIN_DO);
07750                 | '     _pinclear(PIN_DO);
07750                 | '     _pinclear(PIN_DI);
07750                 | '     _pinclear(PIN_CLK);
07750                 | '     _pinclear(PIN_SS);
07750                 | ' 
07750                 | '     _waitms(10);
07750                 | ' 
07750                 | '     return 0;
07750     00 76 06 F6 | 	mov	result1, #0
07754                 | LR__1210
07754     E7 F0 03 F6 | 	mov	ptra, fp
07758     F2 00 A0 FD | 	call	#popregs_
0775c                 | _sdmm_cc_disk_deinitialize_ret
0775c     2D 00 64 FD | 	ret
07760                 | 
07760                 | _sdmm_cc_v_do_io
07760     08 CA 05 F6 | 	mov	COUNT_, #8
07764     E8 00 A0 FD | 	call	#pushregs_
07768     4A A7 02 F6 | 	mov	local01, arg03
0776c     4B A9 02 F6 | 	mov	local02, arg04
07770     49 AB 02 F6 | 	mov	local03, arg02
07774     18 62 06 F1 | 	add	objptr, #24
07778     31 AD 02 FB | 	rdlong	local04, objptr
0777c     00 96 06 F6 | 	mov	arg04, #0
07780     FF AD 06 F5 | 	and	local04, #511
07784     00 AE 06 F6 | 	mov	local05, #0
07788     31 91 02 FB | 	rdlong	arg01, objptr
0778c     04 62 06 F1 | 	add	objptr, #4
07790     31 93 02 FB | 	rdlong	arg02, objptr
07794     1C 62 86 F1 | 	sub	objptr, #28
07798     09 94 06 F6 | 	mov	arg03, #9
0779c     5C CD BF FD | 	call	#__system___int64_sar
077a0     3B B1 02 F6 | 	mov	local06, result1
077a4     00 AC 0E F2 | 	cmp	local04, #0 wz
077a8                 | ' 
077a8                 | ' 
077a8                 | '         return -1;
077a8     01 76 66 56 |  if_ne	neg	result1, #1
077ac     84 00 90 5D |  if_ne	jmp	#LR__1223
077b0     53 B3 02 F6 | 	mov	local07, local01
077b4     09 B2 46 F0 | 	shr	local07, #9
077b8     00 A8 0E F2 | 	cmp	local02, #0 wz
077bc     1C 00 90 AD |  if_e	jmp	#LR__1220
077c0     00 90 06 F6 | 	mov	arg01, #0
077c4     55 93 02 F6 | 	mov	arg02, local03
077c8     58 95 02 F6 | 	mov	arg03, local06
077cc     59 97 02 F6 | 	mov	arg04, local07
077d0     88 F8 BF FD | 	call	#_sdmm_cc_disk_write
077d4     3B B5 02 F6 | 	mov	local08, result1
077d8     18 00 90 FD | 	jmp	#LR__1221
077dc                 | LR__1220
077dc     00 90 06 F6 | 	mov	arg01, #0
077e0     55 93 02 F6 | 	mov	arg02, local03
077e4     58 95 02 F6 | 	mov	arg03, local06
077e8     59 97 02 F6 | 	mov	arg04, local07
077ec     AC F7 BF FD | 	call	#_sdmm_cc_disk_read
077f0     3B B5 02 F6 | 	mov	local08, result1
077f4                 | LR__1221
077f4     00 B4 0E F2 | 	cmp	local08, #0 wz
077f8     34 00 90 5D |  if_ne	jmp	#LR__1222
077fc     09 B2 66 F0 | 	shl	local07, #9
07800     59 AF 02 F1 | 	add	local05, local07
07804     18 62 06 F1 | 	add	objptr, #24
07808     31 77 02 FB | 	rdlong	result1, objptr
0780c     04 62 06 F1 | 	add	objptr, #4
07810     31 79 02 FB | 	rdlong	result2, objptr
07814     59 77 12 F1 | 	add	result1, local07 wc
07818     00 78 26 F1 | 	addx	result2, #0
0781c     04 62 86 F1 | 	sub	objptr, #4
07820     31 77 62 FC | 	wrlong	result1, objptr
07824     04 62 06 F1 | 	add	objptr, #4
07828     31 79 62 FC | 	wrlong	result2, objptr
0782c     1C 62 86 F1 | 	sub	objptr, #28
07830                 | LR__1222
07830                 | ' 
07830                 | ' 
07830                 | '     }
07830                 | '     return bytes_io;
07830     57 77 02 F6 | 	mov	result1, local05
07834                 | LR__1223
07834     E7 F0 03 F6 | 	mov	ptra, fp
07838     F2 00 A0 FD | 	call	#popregs_
0783c                 | _sdmm_cc_v_do_io_ret
0783c     2D 00 64 FD | 	ret
07840                 | 
07840                 | _sdmm_cc_v_read
07840                 | ' {
07840                 | '     return v_do_io(fil, buf, count,  (0) );
07840     00 96 06 F6 | 	mov	arg04, #0
07844     18 FF BF FD | 	call	#_sdmm_cc_v_do_io
07848                 | _sdmm_cc_v_read_ret
07848     2D 00 64 FD | 	ret
0784c                 | 
0784c                 | _sdmm_cc_v_write
0784c                 | ' {
0784c                 | '     return v_do_io(fil, buf, count,  (1) );
0784c     01 96 06 F6 | 	mov	arg04, #1
07850     0C FF BF FD | 	call	#_sdmm_cc_v_do_io
07854                 | _sdmm_cc_v_write_ret
07854     2D 00 64 FD | 	ret
07858                 | 
07858                 | _sdmm_cc_v_ioctl
07858     00 90 06 F6 | 	mov	arg01, #0
0785c     04 F9 BF FD | 	call	#_sdmm_cc_disk_ioctl
07860     00 76 0E F2 | 	cmp	result1, #0 wz
07864                 | '         return _seterror( 10 );
07864     20 66 06 51 |  if_ne	add	ptr___system__dat__, #32
07868     33 15 68 5C |  if_ne	wrlong	#10, ptr___system__dat__
0786c     20 66 86 51 |  if_ne	sub	ptr___system__dat__, #32
07870     01 76 66 56 |  if_ne	neg	result1, #1
07874                 | '     return 0;
07874     00 76 06 A6 |  if_e	mov	result1, #0
07878                 | _sdmm_cc_v_ioctl_ret
07878     2D 00 64 FD | 	ret
0787c                 | 
0787c                 | _sdmm_cc_v_lseek
0787c     49 7D 02 F6 | 	mov	_var01, arg02
07880     4B 81 0A F6 | 	mov	_var03, arg04 wz
07884     1C 00 90 5D |  if_ne	jmp	#LR__1230
07888     4A 81 02 F6 | 	mov	_var03, arg03
0788c     18 62 06 F1 | 	add	objptr, #24
07890     31 7D 62 FC | 	wrlong	_var01, objptr
07894     04 62 06 F1 | 	add	objptr, #4
07898     31 81 62 FC | 	wrlong	_var03, objptr
0789c     1C 62 86 F1 | 	sub	objptr, #28
078a0     64 00 90 FD | 	jmp	#LR__1233
078a4                 | LR__1230
078a4     01 80 0E F2 | 	cmp	_var03, #1 wz
078a8     30 00 90 5D |  if_ne	jmp	#LR__1231
078ac     18 62 06 F1 | 	add	objptr, #24
078b0     31 77 02 FB | 	rdlong	result1, objptr
078b4     04 62 06 F1 | 	add	objptr, #4
078b8     31 79 02 FB | 	rdlong	result2, objptr
078bc     3E 77 12 F1 | 	add	result1, _var01 wc
078c0     4A 79 22 F1 | 	addx	result2, arg03
078c4     04 62 86 F1 | 	sub	objptr, #4
078c8     31 77 62 FC | 	wrlong	result1, objptr
078cc     04 62 06 F1 | 	add	objptr, #4
078d0     31 79 62 FC | 	wrlong	result2, objptr
078d4     1C 62 86 F1 | 	sub	objptr, #28
078d8     2C 00 90 FD | 	jmp	#LR__1232
078dc                 | LR__1231
078dc     3E 77 22 F6 | 	not	result1, _var01
078e0     01 76 0E F1 | 	add	result1, #1 wz
078e4     4A 79 22 F6 | 	not	result2, arg03
078e8     00 92 06 F6 | 	mov	arg02, #0
078ec     01 92 66 A6 |  if_e	neg	arg02, #1
078f0     49 79 82 F1 | 	sub	result2, arg02
078f4     18 62 06 F1 | 	add	objptr, #24
078f8     31 77 62 FC | 	wrlong	result1, objptr
078fc     04 62 06 F1 | 	add	objptr, #4
07900     31 79 62 FC | 	wrlong	result2, objptr
07904     1C 62 86 F1 | 	sub	objptr, #28
07908                 | LR__1232
07908                 | LR__1233
07908                 | '         curpos = -off;
07908                 | '     }
07908                 | '     return curpos;
07908     18 62 06 F1 | 	add	objptr, #24
0790c     31 77 02 FB | 	rdlong	result1, objptr
07910     04 62 06 F1 | 	add	objptr, #4
07914     31 79 02 FB | 	rdlong	result2, objptr
07918     1C 62 86 F1 | 	sub	objptr, #28
0791c                 | _sdmm_cc_v_lseek_ret
0791c     2D 00 64 FD | 	ret
07920                 | 
07920                 | _sdmm_cc_v_flush
07920                 | ' {
07920                 | '     return 0;
07920     00 76 06 F6 | 	mov	result1, #0
07924                 | _sdmm_cc_v_flush_ret
07924     2D 00 64 FD | 	ret
07928                 | 
07928                 | _sdmm_cc_v_close
07928     00 90 06 F6 | 	mov	arg01, #0
0792c     B4 FD BF FD | 	call	#_sdmm_cc_disk_deinitialize
07930     20 62 06 F1 | 	add	objptr, #32
07934     31 91 02 FB | 	rdlong	arg01, objptr
07938     04 62 06 F1 | 	add	objptr, #4
0793c     31 93 02 FB | 	rdlong	arg02, objptr
07940     24 62 86 F1 | 	sub	objptr, #36
07944     40 CC BF FD | 	call	#__system___freepins
07948                 | ' {
07948                 | '     disk_deinitialize(0);
07948                 | '     _freepins(f_pinmask);
07948                 | '     return 0;
07948     00 76 06 F6 | 	mov	result1, #0
0794c                 | _sdmm_cc_v_close_ret
0794c     2D 00 64 FD | 	ret
07950                 | 
07950                 | _sdmm_cc_v_putc
07950     00 CA 05 F6 | 	mov	COUNT_, #0
07954     E8 00 A0 FD | 	call	#pushregs_
07958     0C F0 07 F1 | 	add	ptra, #12
0795c     04 CE 05 F1 | 	add	fp, #4
07960     E7 90 62 FC | 	wrlong	arg01, fp
07964     49 91 02 F6 | 	mov	arg01, arg02
07968     E7 92 02 F6 | 	mov	arg02, fp
0796c     01 94 06 F6 | 	mov	arg03, #1
07970     04 CE 85 F1 | 	sub	fp, #4
07974                 | ' {
07974                 | '     return v_do_io(fil, buf, count,  (1) );
07974     01 96 06 F6 | 	mov	arg04, #1
07978     E4 FD BF FD | 	call	#_sdmm_cc_v_do_io
0797c     01 76 0E F2 | 	cmp	result1, #1 wz
07980     04 CE 05 A1 |  if_e	add	fp, #4
07984     E7 76 02 AB |  if_e	rdlong	result1, fp
07988     04 CE 85 A1 |  if_e	sub	fp, #4
0798c                 | '     return -1;
0798c     01 76 66 56 |  if_ne	neg	result1, #1
07990     E7 F0 03 F6 | 	mov	ptra, fp
07994     F2 00 A0 FD | 	call	#popregs_
07998                 | _sdmm_cc_v_putc_ret
07998     2D 00 64 FD | 	ret
0799c                 | 
0799c                 | _sdmm_cc_v_getc
0799c     00 CA 05 F6 | 	mov	COUNT_, #0
079a0     E8 00 A0 FD | 	call	#pushregs_
079a4     0C F0 07 F1 | 	add	ptra, #12
079a8     08 CE 05 F1 | 	add	fp, #8
079ac     E7 00 68 FC | 	wrlong	#0, fp
079b0     E7 92 02 F6 | 	mov	arg02, fp
079b4     08 CE 85 F1 | 	sub	fp, #8
079b8     01 94 06 F6 | 	mov	arg03, #1
079bc                 | ' {
079bc                 | '     return v_do_io(fil, buf, count,  (0) );
079bc     00 96 06 F6 | 	mov	arg04, #0
079c0     9C FD BF FD | 	call	#_sdmm_cc_v_do_io
079c4     01 76 0E F2 | 	cmp	result1, #1 wz
079c8     08 CE 05 A1 |  if_e	add	fp, #8
079cc     E7 76 02 AB |  if_e	rdlong	result1, fp
079d0     08 CE 85 A1 |  if_e	sub	fp, #8
079d4                 | '     return -1;
079d4     01 76 66 56 |  if_ne	neg	result1, #1
079d8     E7 F0 03 F6 | 	mov	ptra, fp
079dc     F2 00 A0 FD | 	call	#popregs_
079e0                 | _sdmm_cc_v_getc_ret
079e0     2D 00 64 FD | 	ret
079e4                 | 
079e4                 | _fatfs_cc_ff_uni2oem
079e4     00 7C 06 F6 | 	mov	_var01, #0
079e8     80 90 16 F2 | 	cmp	arg01, #128 wc
079ec     48 7D 02 C6 |  if_b	mov	_var01, arg01
079f0     58 00 90 CD |  if_b	jmp	#LR__1244
079f4     80 00 00 FF 
079f8     00 90 16 F2 | 	cmp	arg01, ##65536 wc
079fc     4C 00 90 3D |  if_ae	jmp	#LR__1243
07a00     49 77 32 F9 | 	getword	result1, arg02, #0
07a04     01 00 00 FF 
07a08     52 77 0E F2 | 	cmp	result1, ##850 wz
07a0c     3C 00 90 5D |  if_ne	jmp	#LR__1243
07a10                 | ' 			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
07a10     00 7C 06 F6 | 	mov	_var01, #0
07a14     D7 14 48 FB | 	callpa	#(@LR__1241-@LR__1240)>>2,fcache_load_ptr_
07a18                 | LR__1240
07a18     3E 77 32 F9 | 	getword	result1, _var01, #0
07a1c     80 76 16 F2 | 	cmp	result1, #128 wc
07a20     1C 00 90 3D |  if_ae	jmp	#LR__1242
07a24     3E 77 32 F9 | 	getword	result1, _var01, #0
07a28     01 76 66 F0 | 	shl	result1, #1
07a2c     35 77 02 F1 | 	add	result1, ptr__fatfs_cc_dat__
07a30     3B 77 E2 FA | 	rdword	result1, result1
07a34     3B 91 0A F2 | 	cmp	arg01, result1 wz
07a38     01 7C 06 51 |  if_ne	add	_var01, #1
07a3c     D8 FF 9F 5D |  if_ne	jmp	#LR__1240
07a40                 | LR__1241
07a40                 | LR__1242
07a40     3E 7D 32 F9 | 	getword	_var01, _var01, #0
07a44     80 7C 06 F1 | 	add	_var01, #128
07a48     3E 7D E2 F8 | 	getbyte	_var01, _var01, #0
07a4c                 | LR__1243
07a4c                 | LR__1244
07a4c                 | ' 			c = (c + 0x80) & 0xFF;
07a4c                 | ' 		}
07a4c                 | ' 	}
07a4c                 | ' 
07a4c                 | ' 	return c;
07a4c     3E 77 02 F6 | 	mov	result1, _var01
07a50                 | _fatfs_cc_ff_uni2oem_ret
07a50     2D 00 64 FD | 	ret
07a54                 | 
07a54                 | _fatfs_cc_ff_oem2uni
07a54     00 7C 06 F6 | 	mov	_var01, #0
07a58     48 77 32 F9 | 	getword	result1, arg01, #0
07a5c     80 76 16 F2 | 	cmp	result1, #128 wc
07a60     48 7D 02 C6 |  if_b	mov	_var01, arg01
07a64     2C 00 90 CD |  if_b	jmp	#LR__1251
07a68     49 93 32 F9 | 	getword	arg02, arg02, #0
07a6c     01 00 00 FF 
07a70     52 93 0E F2 | 	cmp	arg02, ##850 wz
07a74     1C 00 90 5D |  if_ne	jmp	#LR__1250
07a78     48 77 32 F9 | 	getword	result1, arg01, #0
07a7c     00 77 16 F2 | 	cmp	result1, #256 wc
07a80     48 91 32 C9 |  if_b	getword	arg01, arg01, #0
07a84     80 90 86 C1 |  if_b	sub	arg01, #128
07a88     01 90 66 C0 |  if_b	shl	arg01, #1
07a8c     35 91 02 C1 |  if_b	add	arg01, ptr__fatfs_cc_dat__
07a90     48 7D E2 CA |  if_b	rdword	_var01, arg01
07a94                 | LR__1250
07a94                 | LR__1251
07a94                 | ' 		}
07a94                 | ' 	}
07a94                 | ' 
07a94                 | ' 	return c;
07a94     3E 77 02 F6 | 	mov	result1, _var01
07a98                 | _fatfs_cc_ff_oem2uni_ret
07a98     2D 00 64 FD | 	ret
07a9c                 | 
07a9c                 | _fatfs_cc_ff_wtoupper
07a9c     48 7D 02 F6 | 	mov	_var01, arg01
07aa0     80 00 00 FF 
07aa4     00 7C 16 F2 | 	cmp	_var01, ##65536 wc
07aa8     58 01 90 3D |  if_ae	jmp	#LR__1273
07aac     3E 7F 02 F6 | 	mov	_var02, _var01
07ab0     3F 7D 32 F9 | 	getword	_var01, _var02, #0
07ab4     08 00 00 FF 
07ab8     00 7C 16 F2 | 	cmp	_var01, ##4096 wc
07abc     35 81 02 C6 |  if_b	mov	_var03, ptr__fatfs_cc_dat__
07ac0     00 81 06 C1 |  if_b	add	_var03, #256
07ac4     35 81 02 36 |  if_ae	mov	_var03, ptr__fatfs_cc_dat__
07ac8     01 00 00 3F 
07acc     F2 80 06 31 |  if_ae	add	_var03, ##754
07ad0     40 83 02 F6 | 	mov	_var04, _var03
07ad4                 | ' 		uc = (WORD)uni;
07ad4                 | ' 		p = uc < 0x1000 ? cvt1 : cvt2;
07ad4                 | ' 		for (;;) {
07ad4                 | LR__1260
07ad4     41 85 E2 FA | 	rdword	_var05, _var04
07ad8     42 81 02 F6 | 	mov	_var03, _var05
07adc     0F 80 4E F7 | 	zerox	_var03, #15 wz
07ae0     02 82 06 F1 | 	add	_var04, #2
07ae4     18 01 90 AD |  if_e	jmp	#LR__1272
07ae8     3F 81 32 F9 | 	getword	_var03, _var02, #0
07aec     42 7D 32 F9 | 	getword	_var01, _var05, #0
07af0     3E 81 12 F2 | 	cmp	_var03, _var01 wc
07af4     08 01 90 CD |  if_b	jmp	#LR__1272
07af8     41 87 E2 FA | 	rdword	_var06, _var04
07afc     43 89 32 F9 | 	getword	_var07, _var06, #0
07b00     08 88 46 F0 | 	shr	_var07, #8
07b04     43 87 32 F9 | 	getword	_var06, _var06, #0
07b08     43 87 E2 F8 | 	getbyte	_var06, _var06, #0
07b0c     3F 8B 32 F9 | 	getword	_var08, _var02, #0
07b10     42 8D 32 F9 | 	getword	_var09, _var05, #0
07b14     43 81 32 F9 | 	getword	_var03, _var06, #0
07b18     40 8D 02 F1 | 	add	_var09, _var03
07b1c     46 8B 52 F2 | 	cmps	_var08, _var09 wc
07b20     02 82 06 F1 | 	add	_var04, #2
07b24     C4 00 90 3D |  if_ae	jmp	#LR__1271
07b28                 | ' 				switch (cmd) {
07b28     44 8F 32 F9 | 	getword	_var10, _var07, #0
07b2c     09 8E 26 F3 | 	fle	_var10, #9
07b30     30 8E 62 FD | 	jmprel	_var10
07b34                 | LR__1261
07b34     24 00 90 FD | 	jmp	#LR__1262
07b38     3C 00 90 FD | 	jmp	#LR__1263
07b3c     54 00 90 FD | 	jmp	#LR__1264
07b40     5C 00 90 FD | 	jmp	#LR__1265
07b44     64 00 90 FD | 	jmp	#LR__1266
07b48     6C 00 90 FD | 	jmp	#LR__1267
07b4c     74 00 90 FD | 	jmp	#LR__1268
07b50     7C 00 90 FD | 	jmp	#LR__1269
07b54     84 00 90 FD | 	jmp	#LR__1270
07b58     A4 00 90 FD | 	jmp	#LR__1272
07b5c                 | LR__1262
07b5c     3F 7F 32 F9 | 	getword	_var02, _var02, #0
07b60     42 85 32 F9 | 	getword	_var05, _var05, #0
07b64     42 7F 82 F1 | 	sub	_var02, _var05
07b68     01 7E 66 F0 | 	shl	_var02, #1
07b6c     41 7F 02 F1 | 	add	_var02, _var04
07b70     3F 7F E2 FA | 	rdword	_var02, _var02
07b74     88 00 90 FD | 	jmp	#LR__1272
07b78                 | LR__1263
07b78     3F 8B 32 F9 | 	getword	_var08, _var02, #0
07b7c     3F 7F 32 F9 | 	getword	_var02, _var02, #0
07b80     42 85 32 F9 | 	getword	_var05, _var05, #0
07b84     42 7F 82 F1 | 	sub	_var02, _var05
07b88     01 7E 06 F5 | 	and	_var02, #1
07b8c     45 7F C2 F2 | 	subr	_var02, _var08
07b90     6C 00 90 FD | 	jmp	#LR__1272
07b94                 | LR__1264
07b94     3F 7F 32 F9 | 	getword	_var02, _var02, #0
07b98     10 7E 86 F1 | 	sub	_var02, #16
07b9c     60 00 90 FD | 	jmp	#LR__1272
07ba0                 | LR__1265
07ba0     3F 7F 32 F9 | 	getword	_var02, _var02, #0
07ba4     20 7E 86 F1 | 	sub	_var02, #32
07ba8     54 00 90 FD | 	jmp	#LR__1272
07bac                 | LR__1266
07bac     3F 7F 32 F9 | 	getword	_var02, _var02, #0
07bb0     30 7E 86 F1 | 	sub	_var02, #48
07bb4     48 00 90 FD | 	jmp	#LR__1272
07bb8                 | LR__1267
07bb8     3F 7F 32 F9 | 	getword	_var02, _var02, #0
07bbc     1A 7E 86 F1 | 	sub	_var02, #26
07bc0     3C 00 90 FD | 	jmp	#LR__1272
07bc4                 | LR__1268
07bc4     3F 7F 32 F9 | 	getword	_var02, _var02, #0
07bc8     08 7E 06 F1 | 	add	_var02, #8
07bcc     30 00 90 FD | 	jmp	#LR__1272
07bd0                 | LR__1269
07bd0     3F 7F 32 F9 | 	getword	_var02, _var02, #0
07bd4     50 7E 86 F1 | 	sub	_var02, #80
07bd8     24 00 90 FD | 	jmp	#LR__1272
07bdc                 | LR__1270
07bdc     3F 7F 32 F9 | 	getword	_var02, _var02, #0
07be0     0E 00 00 FF 
07be4     60 7E 86 F1 | 	sub	_var02, ##7264
07be8                 | ' 				}
07be8                 | ' 				break;
07be8     14 00 90 FD | 	jmp	#LR__1272
07bec                 | LR__1271
07bec     0F 88 4E F7 | 	zerox	_var07, #15 wz
07bf0     43 87 32 A9 |  if_e	getword	_var06, _var06, #0
07bf4     01 86 66 A0 |  if_e	shl	_var06, #1
07bf8     43 83 02 A1 |  if_e	add	_var04, _var06
07bfc     D4 FE 9F FD | 	jmp	#LR__1260
07c00                 | LR__1272
07c00     3F 7D 32 F9 | 	getword	_var01, _var02, #0
07c04                 | LR__1273
07c04                 | ' 		}
07c04                 | ' 		uni = uc;
07c04                 | ' 	}
07c04                 | ' 
07c04                 | ' 	return uni;
07c04     3E 77 02 F6 | 	mov	result1, _var01
07c08                 | _fatfs_cc_ff_wtoupper_ret
07c08     2D 00 64 FD | 	ret
07c0c                 | 
07c0c                 | _fatfs_cc_strncpy
07c0c     48 7D 02 F6 | 	mov	_var01, arg01
07c10     D7 18 48 FB | 	callpa	#(@LR__1281-@LR__1280)>>2,fcache_load_ptr_
07c14                 | ' 
07c14                 | ' 	dscan = dst;
07c14                 | ' 	sscan = src;
07c14                 | ' 	count = n;
07c14                 | ' 	while (--count >= 0 && (*dscan++ = *sscan++) != '\0')
07c14                 | LR__1280
07c14     01 94 86 F1 | 	sub	arg03, #1
07c18     00 94 56 F2 | 	cmps	arg03, #0 wc
07c1c     24 00 90 CD |  if_b	jmp	#LR__1282
07c20     49 77 02 F6 | 	mov	result1, arg02
07c24     01 76 06 F1 | 	add	result1, #1
07c28     49 7F C2 FA | 	rdbyte	_var02, arg02
07c2c     3B 93 02 F6 | 	mov	arg02, result1
07c30     3E 7F 42 FC | 	wrbyte	_var02, _var01
07c34     3F 7F E2 F8 | 	getbyte	_var02, _var02, #0
07c38     07 7E 4E F7 | 	zerox	_var02, #7 wz
07c3c                 | ' 		continue;
07c3c     01 7C 06 F1 | 	add	_var01, #1
07c40     D0 FF 9F 5D |  if_ne	jmp	#LR__1280
07c44                 | LR__1281
07c44                 | LR__1282
07c44     D7 0C 48 FB | 	callpa	#(@LR__1284-@LR__1283)>>2,fcache_load_ptr_
07c48                 | ' 	while (--count >= 0)
07c48                 | LR__1283
07c48     01 94 86 F1 | 	sub	arg03, #1
07c4c     00 94 56 F2 | 	cmps	arg03, #0 wc
07c50     3E 81 02 36 |  if_ae	mov	_var03, _var01
07c54     01 7C 06 31 |  if_ae	add	_var01, #1
07c58     40 01 48 3C |  if_ae	wrbyte	#0, _var03
07c5c     E8 FF 9F 3D |  if_ae	jmp	#LR__1283
07c60                 | LR__1284
07c60                 | ' 		*dscan++ = '\0';
07c60                 | ' 	return(dst);
07c60     48 77 02 F6 | 	mov	result1, arg01
07c64                 | _fatfs_cc_strncpy_ret
07c64     2D 00 64 FD | 	ret
07c68                 | 
07c68                 | _fatfs_cc_memcmp
07c68                 | ' 	for (n = size; n > 0; n--)
07c68     00 94 0E F2 | 	cmp	arg03, #0 wz
07c6c     28 00 90 AD |  if_e	jmp	#LR__1291
07c70                 | LR__1290
07c70     48 7D C2 FA | 	rdbyte	_var01, arg01
07c74     49 7F C2 FA | 	rdbyte	_var02, arg02
07c78     3F 7D 0A F2 | 	cmp	_var01, _var02 wz
07c7c     01 90 06 A1 |  if_e	add	arg01, #1
07c80     01 92 06 A1 |  if_e	add	arg02, #1
07c84                 | ' 			return( ((unsigned char)(*scan1))  -  ((unsigned char)(*scan2)) );
07c84     48 77 C2 5A |  if_ne	rdbyte	result1, arg01
07c88     49 7F C2 5A |  if_ne	rdbyte	_var02, arg02
07c8c     3F 77 82 51 |  if_ne	sub	result1, _var02
07c90     08 00 90 5D |  if_ne	jmp	#_fatfs_cc_memcmp_ret
07c94     F6 95 6E FB | 	djnz	arg03, #LR__1290
07c98                 | LR__1291
07c98                 | ' 
07c98                 | ' 	return(0);
07c98     00 76 06 F6 | 	mov	result1, #0
07c9c                 | _fatfs_cc_memcmp_ret
07c9c     2D 00 64 FD | 	ret
07ca0                 | 
07ca0                 | _fatfs_cc_strncmp
07ca0     48 7D 0A F6 | 	mov	_var01, arg01 wz
07ca4     14 00 90 5D |  if_ne	jmp	#LR__1300
07ca8                 | ' 		return scan2 ? -1 : 0;
07ca8     00 92 0E F2 | 	cmp	arg02, #0 wz
07cac     01 7E 66 56 |  if_ne	neg	_var02, #1
07cb0     00 7E 06 A6 |  if_e	mov	_var02, #0
07cb4     3F 77 02 F6 | 	mov	result1, _var02
07cb8     74 00 90 FD | 	jmp	#_fatfs_cc_strncmp_ret
07cbc                 | LR__1300
07cbc     00 92 0E F2 | 	cmp	arg02, #0 wz
07cc0     01 76 06 A6 |  if_e	mov	result1, #1
07cc4     68 00 90 AD |  if_e	jmp	#_fatfs_cc_strncmp_ret
07cc8     4A 81 02 F6 | 	mov	_var03, arg03
07ccc     D7 16 48 FB | 	callpa	#(@LR__1302-@LR__1301)>>2,fcache_load_ptr_
07cd0                 | ' 	count = n;
07cd0                 | ' 	do {
07cd0                 | LR__1301
07cd0     3E 83 C2 FA | 	rdbyte	_var04, _var01
07cd4     49 85 02 F6 | 	mov	_var05, arg02
07cd8     42 87 C2 FA | 	rdbyte	_var06, _var05
07cdc     01 80 86 F1 | 	sub	_var03, #1
07ce0     00 80 56 F2 | 	cmps	_var03, #0 wc
07ce4     01 7C 06 F1 | 	add	_var01, #1
07ce8     01 92 06 F1 | 	add	arg02, #1
07cec     00 82 0E 32 |  if_ae	cmp	_var04, #0 wz
07cf0     08 00 90 2D |  if_nc_and_z	jmp	#LR__1303
07cf4     43 83 0A 32 |  if_ae	cmp	_var04, _var06 wz
07cf8     D4 FF 9F 2D |  if_nc_and_z	jmp	#LR__1301
07cfc                 | LR__1302
07cfc                 | LR__1303
07cfc     00 80 56 F2 | 	cmps	_var03, #0 wc
07d00                 | ' 		return(0);
07d00     00 76 06 C6 |  if_b	mov	result1, #0
07d04     28 00 90 CD |  if_b	jmp	#_fatfs_cc_strncmp_ret
07d08     43 83 0A F2 | 	cmp	_var04, _var06 wz
07d0c                 | ' 		return(0);
07d0c     00 76 06 A6 |  if_e	mov	result1, #0
07d10     1C 00 90 AD |  if_e	jmp	#_fatfs_cc_strncmp_ret
07d14     00 82 0E F2 | 	cmp	_var04, #0 wz
07d18                 | ' 		return(-1);
07d18     01 76 66 A6 |  if_e	neg	result1, #1
07d1c     10 00 90 AD |  if_e	jmp	#_fatfs_cc_strncmp_ret
07d20     00 86 0E F2 | 	cmp	_var06, #0 wz
07d24                 | ' 		return(1);
07d24     01 76 06 A6 |  if_e	mov	result1, #1
07d28                 | ' 		return(c1 - c2);
07d28     41 77 02 56 |  if_ne	mov	result1, _var04
07d2c     43 77 82 51 |  if_ne	sub	result1, _var06
07d30                 | _fatfs_cc_strncmp_ret
07d30     2D 00 64 FD | 	ret
07d34                 | 
07d34                 | _fatfs_cc_strchr
07d34                 | ' #line 16 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/libc/string/strchr.c"
07d34                 | ' 	while ((c = *s++) != (char) charwanted)
07d34                 | LR__1310
07d34     48 7D 02 F6 | 	mov	_var01, arg01
07d38     3E 7F C2 FA | 	rdbyte	_var02, _var01
07d3c     3F 81 E2 F8 | 	getbyte	_var03, _var02, #0
07d40     49 83 E2 F8 | 	getbyte	_var04, arg02, #0
07d44     41 81 0A F2 | 	cmp	_var03, _var04 wz
07d48     01 90 06 F1 | 	add	arg01, #1
07d4c     14 00 90 AD |  if_e	jmp	#LR__1311
07d50     3F 81 02 F6 | 	mov	_var03, _var02
07d54     07 80 4E F7 | 	zerox	_var03, #7 wz
07d58     00 76 06 A6 |  if_e	mov	result1, #0
07d5c     0C 00 90 AD |  if_e	jmp	#_fatfs_cc_strchr_ret
07d60     D0 FF 9F FD | 	jmp	#LR__1310
07d64                 | LR__1311
07d64                 | ' 	return((char *)--s);
07d64     01 90 86 F1 | 	sub	arg01, #1
07d68     48 77 02 F6 | 	mov	result1, arg01
07d6c                 | _fatfs_cc_strchr_ret
07d6c     2D 00 64 FD | 	ret
07d70                 | 
07d70                 | _fatfs_cc_time
07d70     01 CA 05 F6 | 	mov	COUNT_, #1
07d74     E8 00 A0 FD | 	call	#pushregs_
07d78     14 F0 07 F1 | 	add	ptra, #20
07d7c     48 A7 02 F6 | 	mov	local01, arg01
07d80     E7 90 02 F6 | 	mov	arg01, fp
07d84     08 90 06 F1 | 	add	arg01, #8
07d88     00 92 06 F6 | 	mov	arg02, #0
07d8c     88 5E B0 FD | 	call	#_fatfs_cc_gettimeofday
07d90     08 CE 05 F1 | 	add	fp, #8
07d94     E7 76 02 FB | 	rdlong	result1, fp
07d98     08 CE 85 F1 | 	sub	fp, #8
07d9c     00 A6 0E F2 | 	cmp	local01, #0 wz
07da0     53 77 62 5C |  if_ne	wrlong	result1, local01
07da4                 | '         *tp = now;
07da4                 | '     return now;
07da4     E7 F0 03 F6 | 	mov	ptra, fp
07da8     F2 00 A0 FD | 	call	#popregs_
07dac                 | _fatfs_cc_time_ret
07dac     2D 00 64 FD | 	ret
07db0                 | 
07db0                 | _fatfs_cc_mktime
07db0     06 CA 05 F6 | 	mov	COUNT_, #6
07db4     E8 00 A0 FD | 	call	#pushregs_
07db8     48 A7 02 F6 | 	mov	local01, arg01
07dbc     14 A6 06 F1 | 	add	local01, #20
07dc0     53 91 02 FB | 	rdlong	arg01, local01
07dc4     14 A6 86 F1 | 	sub	local01, #20
07dc8     46 90 56 F2 | 	cmps	arg01, #70 wc
07dcc                 | '                 return (time_t) -1;
07dcc     01 76 66 C6 |  if_b	neg	result1, #1
07dd0     78 01 90 CD |  if_b	jmp	#LR__1324
07dd4     03 00 00 FF 
07dd8     6C A9 06 F6 | 	mov	local02, ##1900
07ddc     14 A6 06 F1 | 	add	local01, #20
07de0     53 77 02 FB | 	rdlong	result1, local01
07de4     3B A9 02 F1 | 	add	local02, result1
07de8     08 A6 86 F1 | 	sub	local01, #8
07dec     53 AB 02 FB | 	rdlong	local03, local01
07df0     01 AA 86 F1 | 	sub	local03, #1
07df4     04 A6 06 F1 | 	add	local01, #4
07df8     53 91 02 FB | 	rdlong	arg01, local01
07dfc     10 A6 86 F1 | 	sub	local01, #16
07e00     02 90 66 F0 | 	shl	arg01, #2
07e04     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
07e08     02 00 00 FF 
07e0c     78 76 06 F1 | 	add	result1, ##1144
07e10     3B 91 02 F1 | 	add	arg01, result1
07e14     48 77 02 FB | 	rdlong	result1, arg01
07e18     3B AB 02 F1 | 	add	local03, result1
07e1c     54 91 02 F6 | 	mov	arg01, local02
07e20     9C 5E B0 FD | 	call	#_fatfs_cc__is_leap_year
07e24     00 76 0E F2 | 	cmp	result1, #0 wz
07e28     1C 00 90 AD |  if_e	jmp	#LR__1320
07e2c     00 AC 06 F6 | 	mov	local04, #0
07e30     10 A6 06 F1 | 	add	local01, #16
07e34     53 77 02 FB | 	rdlong	result1, local01
07e38     10 A6 86 F1 | 	sub	local01, #16
07e3c     02 76 56 F2 | 	cmps	result1, #2 wc
07e40     01 AC 06 36 |  if_ae	mov	local04, #1
07e44     04 00 90 FD | 	jmp	#LR__1321
07e48                 | LR__1320
07e48     00 AC 06 F6 | 	mov	local04, #0
07e4c                 | LR__1321
07e4c     04 A6 06 F1 | 	add	local01, #4
07e50     53 91 02 FB | 	rdlong	arg01, local01
07e54     04 A6 86 F1 | 	sub	local01, #4
07e58     53 AF 02 FB | 	rdlong	local05, local01
07e5c     08 A6 06 F1 | 	add	local01, #8
07e60     53 77 02 FB | 	rdlong	result1, local01
07e64     07 00 00 FF 
07e68     10 76 06 FD | 	qmul	result1, ##3600
07e6c     56 AB 02 F1 | 	add	local03, local04
07e70     48 AD 02 F6 | 	mov	local04, arg01
07e74     04 AC 66 F0 | 	shl	local04, #4
07e78     48 AD 82 F1 | 	sub	local04, arg01
07e7c     02 AC 66 F0 | 	shl	local04, #2
07e80     56 AF 02 F1 | 	add	local05, local04
07e84     08 A6 86 F1 | 	sub	local01, #8
07e88     18 AC 62 FD | 	getqx	local04
07e8c     A8 00 00 FF 
07e90     80 AB 06 FD | 	qmul	local03, ##86400
07e94     56 AF 02 F1 | 	add	local05, local04
07e98     54 AB 02 F6 | 	mov	local03, local02
07e9c     03 00 00 FF 
07ea0     B2 AB 86 F1 | 	sub	local03, ##1970
07ea4     18 AC 62 FD | 	getqx	local04
07ea8     99 F0 00 FF 
07eac     80 AB 06 FD | 	qmul	local03, ##31536000
07eb0     56 AF 02 F1 | 	add	local05, local04
07eb4     54 AB 02 F6 | 	mov	local03, local02
07eb8     03 00 00 FF 
07ebc     B1 AB 86 F1 | 	sub	local03, ##1969
07ec0     55 B1 52 F6 | 	abs	local06, local03 wc
07ec4     02 B0 46 F0 | 	shr	local06, #2
07ec8     58 B1 82 F6 | 	negc	local06, local06
07ecc     03 00 00 FF 
07ed0     D1 A9 56 F2 | 	cmps	local02, ##2001 wc
07ed4     18 AC 62 FD | 	getqx	local04
07ed8     56 AF 02 F1 | 	add	local05, local04
07edc     18 00 90 CD |  if_b	jmp	#LR__1322
07ee0     03 00 00 FF 
07ee4     D0 A9 86 F1 | 	sub	local02, ##2000
07ee8     54 AD 52 F6 | 	abs	local04, local02 wc
07eec     64 AC 16 FD | 	qdiv	local04, #100
07ef0     18 AC 62 FD | 	getqx	local04
07ef4     56 B1 A2 F3 | 	sumnc	local06, local04
07ef8                 | LR__1322
07ef8     A8 00 00 FF 
07efc     80 B1 06 FD | 	qmul	local06, ##86400
07f00     18 B0 62 FD | 	getqx	local06
07f04     58 AF 02 F1 | 	add	local05, local06
07f08     E8 01 B0 FD | 	call	#_fatfs_cc__tzset
07f0c     02 00 00 FF 
07f10     44 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1092
07f14     35 B1 02 FB | 	rdlong	local06, ptr__fatfs_cc_dat__
07f18     58 AF 02 F1 | 	add	local05, local06
07f1c     68 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, #104
07f20     35 AB 02 FB | 	rdlong	local03, ptr__fatfs_cc_dat__
07f24     02 00 00 FF 
07f28     AC 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1196
07f2c     01 AA 0E F2 | 	cmp	local03, #1 wz
07f30     14 00 90 5D |  if_ne	jmp	#LR__1323
07f34     53 91 02 F6 | 	mov	arg01, local01
07f38     70 60 B0 FD | 	call	#_fatfs_cc___indst
07f3c     00 76 0E F2 | 	cmp	result1, #0 wz
07f40     07 00 00 5F 
07f44     10 AE 86 51 |  if_ne	sub	local05, ##3600
07f48                 | LR__1323
07f48                 | '                 s -=  (3600L) ;
07f48                 | ' 
07f48                 | '         return s;
07f48     57 77 02 F6 | 	mov	result1, local05
07f4c                 | LR__1324
07f4c     E7 F0 03 F6 | 	mov	ptra, fp
07f50     F2 00 A0 FD | 	call	#popregs_
07f54                 | _fatfs_cc_mktime_ret
07f54     2D 00 64 FD | 	ret
07f58                 | 
07f58                 | _fatfs_cc__gmtime_r
07f58     03 CA 05 F6 | 	mov	COUNT_, #3
07f5c     E8 00 A0 FD | 	call	#pushregs_
07f60     48 A7 02 FB | 	rdlong	local01, arg01
07f64     A8 00 00 FF 
07f68     80 A7 16 FD | 	qdiv	local01, ##86400
07f6c     18 76 62 FD | 	getqx	result1
07f70     04 76 06 F1 | 	add	result1, #4
07f74     07 76 16 FD | 	qdiv	result1, #7
07f78     18 92 06 F1 | 	add	arg02, #24
07f7c     D1 7F 27 FF 
07f80     00 A6 16 F2 | 	cmp	local01, ##1325376000 wc
07f84     D1 7F 27 3F 
07f88     00 A6 86 31 |  if_ae	sub	local01, ##1325376000
07f8c     03 00 00 3F 
07f90     DC A9 06 36 |  if_ae	mov	local02, ##2012
07f94     03 00 00 CF 
07f98     B2 A9 06 C6 |  if_b	mov	local02, ##1970
07f9c                 | ' 	  year = 1970;
07f9c                 | ' 	}
07f9c                 | ' 
07f9c                 | ' 	for(;;) {
07f9c     19 76 62 FD | 	getqy	result1
07fa0     49 77 62 FC | 	wrlong	result1, arg02
07fa4     18 92 86 F1 | 	sub	arg02, #24
07fa8                 | LR__1330
07fa8     54 91 02 F6 | 	mov	arg01, local02
07fac     10 5D B0 FD | 	call	#_fatfs_cc__is_leap_year
07fb0     00 76 0E F2 | 	cmp	result1, #0 wz
07fb4     42 F1 00 5F 
07fb8     00 AB 06 56 |  if_ne	mov	local03, ##31622400
07fbc     99 F0 00 AF 
07fc0     80 AB 06 A6 |  if_e	mov	local03, ##31536000
07fc4     55 A7 12 F2 | 	cmp	local01, local03 wc
07fc8                 | ' 	    break;
07fc8     01 A8 06 31 |  if_ae	add	local02, #1
07fcc     55 A7 82 31 |  if_ae	sub	local01, local03
07fd0     D4 FF 9F 3D |  if_ae	jmp	#LR__1330
07fd4     A8 00 00 FF 
07fd8     80 A7 16 FD | 	qdiv	local01, ##86400
07fdc     54 AB 02 F6 | 	mov	local03, local02
07fe0     03 00 00 FF 
07fe4     6C AB 86 F1 | 	sub	local03, ##1900
07fe8     14 92 06 F1 | 	add	arg02, #20
07fec     49 AB 62 FC | 	wrlong	local03, arg02
07ff0     08 92 06 F1 | 	add	arg02, #8
07ff4     54 91 02 F6 | 	mov	arg01, local02
07ff8     18 A8 62 FD | 	getqx	local02
07ffc     49 A9 62 FC | 	wrlong	local02, arg02
08000     1C 92 86 F1 | 	sub	arg02, #28
08004     B8 5C B0 FD | 	call	#_fatfs_cc__is_leap_year
08008     00 76 0E F2 | 	cmp	result1, #0 wz
0800c     1D AA 06 56 |  if_ne	mov	local03, #29
08010     1C AA 06 A6 |  if_e	mov	local03, #28
08014     02 00 00 FF 
08018     4C 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1100
0801c     35 AB 62 FC | 	wrlong	local03, ptr__fatfs_cc_dat__
08020     02 00 00 FF 
08024     4C 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1100
08028                 | ' 
08028                 | '         days_per_mth[1] = _is_leap_year(year) ? 29 : 28;
08028                 | '         for (i = 0; mday >= days_per_mth[i]; i++)
08028     00 90 06 F6 | 	mov	arg01, #0
0802c     D7 26 48 FB | 	callpa	#(@LR__1332-@LR__1331)>>2,fcache_load_ptr_
08030                 | LR__1331
08030     48 AB 02 F6 | 	mov	local03, arg01
08034     02 AA 66 F0 | 	shl	local03, #2
08038     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0803c     02 00 00 FF 
08040     48 76 06 F1 | 	add	result1, ##1096
08044     3B AB 02 F1 | 	add	local03, result1
08048     55 AB 02 FB | 	rdlong	local03, local03
0804c     55 A9 52 F2 | 	cmps	local02, local03 wc
08050     28 00 90 CD |  if_b	jmp	#LR__1333
08054     48 77 02 F6 | 	mov	result1, arg01
08058     02 76 66 F0 | 	shl	result1, #2
0805c     35 AB 02 F6 | 	mov	local03, ptr__fatfs_cc_dat__
08060     02 00 00 FF 
08064     48 AA 06 F1 | 	add	local03, ##1096
08068     55 77 02 F1 | 	add	result1, local03
0806c     3B 77 02 FB | 	rdlong	result1, result1
08070     3B A9 82 F1 | 	sub	local02, result1
08074     01 90 06 F1 | 	add	arg01, #1
08078     B4 FF 9F FD | 	jmp	#LR__1331
0807c                 | LR__1332
0807c                 | LR__1333
0807c     A8 00 00 FF 
08080     80 A7 16 FD | 	qdiv	local01, ##86400
08084     10 92 06 F1 | 	add	arg02, #16
08088     49 91 62 FC | 	wrlong	arg01, arg02
0808c     01 A8 06 F1 | 	add	local02, #1
08090     04 92 86 F1 | 	sub	arg02, #4
08094     49 A9 62 FC | 	wrlong	local02, arg02
08098     19 A6 62 FD | 	getqy	local01
0809c     07 00 00 FF 
080a0     10 A6 16 FD | 	qdiv	local01, ##3600
080a4     18 AA 62 FD | 	getqx	local03
080a8     07 00 00 FF 
080ac     10 A6 16 FD | 	qdiv	local01, ##3600
080b0     04 92 86 F1 | 	sub	arg02, #4
080b4     49 AB 62 FC | 	wrlong	local03, arg02
080b8     19 A6 62 FD | 	getqy	local01
080bc     3C A6 16 FD | 	qdiv	local01, #60
080c0     18 AA 62 FD | 	getqx	local03
080c4     3C A6 16 FD | 	qdiv	local01, #60
080c8     04 92 86 F1 | 	sub	arg02, #4
080cc     49 AB 62 FC | 	wrlong	local03, arg02
080d0     04 92 86 F1 | 	sub	arg02, #4
080d4                 | '         stm->tm_isdst = 0;
080d4                 | ' 
080d4                 | ' ;
080d4                 | '         return stm;
080d4     49 77 02 F6 | 	mov	result1, arg02
080d8     19 AA 62 FD | 	getqy	local03
080dc     49 AB 62 FC | 	wrlong	local03, arg02
080e0     20 92 06 F1 | 	add	arg02, #32
080e4     49 01 68 FC | 	wrlong	#0, arg02
080e8     E7 F0 03 F6 | 	mov	ptra, fp
080ec     F2 00 A0 FD | 	call	#popregs_
080f0                 | _fatfs_cc__gmtime_r_ret
080f0     2D 00 64 FD | 	ret
080f4                 | 
080f4                 | _fatfs_cc__tzset
080f4     71 00 00 FF 
080f8     22 91 06 F6 | 	mov	arg01, ##@LR__2167
080fc     0C 50 B0 FD | 	call	#_fatfs_cc_getenv
08100     3B 91 02 F6 | 	mov	arg01, result1
08104     35 93 02 F6 | 	mov	arg02, ptr__fatfs_cc_dat__
08108     02 00 00 FF 
0810c     AC 92 06 F1 | 	add	arg02, ##1196
08110     FC 5B B0 FD | 	call	#_fatfs_cc___tzoffset
08114     02 00 00 FF 
08118     44 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1092
0811c     35 77 62 FC | 	wrlong	result1, ptr__fatfs_cc_dat__
08120     02 00 00 FF 
08124     44 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1092
08128                 | _fatfs_cc__tzset_ret
08128     2D 00 64 FD | 	ret
0812c                 | 
0812c                 | _fatfs_cc_disk_read
0812c     09 CA 05 F6 | 	mov	COUNT_, #9
08130     E8 00 A0 FD | 	call	#pushregs_
08134     49 AF 02 F6 | 	mov	local05, arg02
08138     4B B1 02 F6 | 	mov	local06, arg04
0813c     4A 91 02 F6 | 	mov	arg01, arg03
08140     00 92 06 F6 | 	mov	arg02, #0
08144     09 94 06 F6 | 	mov	arg03, #9
08148     00 96 06 F6 | 	mov	arg04, #0
0814c     74 C3 BF FD | 	call	#__system___int64_shl
08150     3B A7 02 F6 | 	mov	local01, result1
08154     3C A9 02 F6 | 	mov	local02, result2
08158     01 00 00 FF 
0815c     10 62 06 F1 | 	add	objptr, ##528
08160     31 79 0A FB | 	rdlong	result2, objptr wz
08164     01 00 00 FF 
08168     10 62 86 F1 | 	sub	objptr, ##528
0816c                 | '         return RES_NOTRDY;
0816c     03 76 06 A6 |  if_e	mov	result1, #3
08170     E8 00 90 AD |  if_e	jmp	#LR__1340
08174     53 93 02 F6 | 	mov	arg02, local01
08178     54 95 02 F6 | 	mov	arg03, local02
0817c     01 00 00 FF 
08180     10 62 06 F1 | 	add	objptr, ##528
08184     31 91 02 FB | 	rdlong	arg01, objptr
08188     48 97 02 F6 | 	mov	arg04, arg01
0818c     30 96 06 F1 | 	add	arg04, #48
08190     4B B3 02 FB | 	rdlong	local07, arg04
08194     59 B5 02 F6 | 	mov	local08, local07
08198     13 B2 46 F7 | 	zerox	local07, #19
0819c     14 B4 46 F0 | 	shr	local08, #20
081a0     02 B4 66 F0 | 	shl	local08, #2
081a4     2D B5 02 F1 | 	add	local08, __methods__
081a8     5A B5 02 FB | 	rdlong	local08, local08
081ac     01 00 00 FF 
081b0     10 62 86 F1 | 	sub	objptr, ##528
081b4     00 96 06 F6 | 	mov	arg04, #0
081b8     31 B7 02 F6 | 	mov	local09, objptr
081bc     59 63 02 F6 | 	mov	objptr, local07
081c0     2D B4 62 FD | 	call	local08
081c4     5B 63 02 F6 | 	mov	objptr, local09
081c8     3B AB 02 F6 | 	mov	local03, result1
081cc     3C AD 02 F6 | 	mov	local04, result2
081d0     55 91 02 F6 | 	mov	arg01, local03
081d4     56 93 02 F6 | 	mov	arg02, local04
081d8     53 95 02 F6 | 	mov	arg03, local01
081dc     54 97 02 F6 | 	mov	arg04, local02
081e0     00 76 06 F6 | 	mov	result1, #0
081e4     4A 91 1A F2 | 	cmp	arg01, arg03 wcz
081e8     4B 93 7A F2 | 	cmpsx	arg02, arg04 wcz
081ec     01 76 86 56 |  if_ne	negc	result1, #1
081f0     00 76 0E F2 | 	cmp	result1, #0 wz
081f4                 | '         return RES_ERROR;
081f4     01 76 06 56 |  if_ne	mov	result1, #1
081f8     60 00 90 5D |  if_ne	jmp	#LR__1340
081fc     09 B0 66 F0 | 	shl	local06, #9
08200     01 00 00 FF 
08204     10 62 06 F1 | 	add	objptr, ##528
08208     31 91 02 FB | 	rdlong	arg01, objptr
0820c     48 AB 02 F6 | 	mov	local03, arg01
08210     14 AA 06 F1 | 	add	local03, #20
08214     55 AB 02 FB | 	rdlong	local03, local03
08218     55 B7 02 F6 | 	mov	local09, local03
0821c     13 B6 46 F7 | 	zerox	local09, #19
08220     14 AA 46 F0 | 	shr	local03, #20
08224     02 AA 66 F0 | 	shl	local03, #2
08228     2D AB 02 F1 | 	add	local03, __methods__
0822c     55 AB 02 FB | 	rdlong	local03, local03
08230     01 00 00 FF 
08234     10 62 86 F1 | 	sub	objptr, ##528
08238     57 93 02 F6 | 	mov	arg02, local05
0823c     58 95 02 F6 | 	mov	arg03, local06
08240     31 B5 02 F6 | 	mov	local08, objptr
08244     5B 63 02 F6 | 	mov	objptr, local09
08248     2D AA 62 FD | 	call	local03
0824c     5A 63 02 F6 | 	mov	objptr, local08
08250     58 77 0A F2 | 	cmp	result1, local06 wz
08254                 | '         return RES_ERROR;
08254     01 76 06 56 |  if_ne	mov	result1, #1
08258                 | '     }
08258                 | '     return RES_OK;
08258     00 76 06 A6 |  if_e	mov	result1, #0
0825c                 | LR__1340
0825c     E7 F0 03 F6 | 	mov	ptra, fp
08260     F2 00 A0 FD | 	call	#popregs_
08264                 | _fatfs_cc_disk_read_ret
08264     2D 00 64 FD | 	ret
08268                 | 
08268                 | _fatfs_cc_disk_write
08268     09 CA 05 F6 | 	mov	COUNT_, #9
0826c     E8 00 A0 FD | 	call	#pushregs_
08270     49 AF 02 F6 | 	mov	local05, arg02
08274     4B B1 02 F6 | 	mov	local06, arg04
08278     4A 91 02 F6 | 	mov	arg01, arg03
0827c     00 92 06 F6 | 	mov	arg02, #0
08280     09 94 06 F6 | 	mov	arg03, #9
08284     00 96 06 F6 | 	mov	arg04, #0
08288     38 C2 BF FD | 	call	#__system___int64_shl
0828c     3B A7 02 F6 | 	mov	local01, result1
08290     3C A9 02 F6 | 	mov	local02, result2
08294     01 00 00 FF 
08298     10 62 06 F1 | 	add	objptr, ##528
0829c     31 79 0A FB | 	rdlong	result2, objptr wz
082a0     01 00 00 FF 
082a4     10 62 86 F1 | 	sub	objptr, ##528
082a8                 | '         return RES_NOTRDY;
082a8     03 76 06 A6 |  if_e	mov	result1, #3
082ac     E8 00 90 AD |  if_e	jmp	#LR__1350
082b0     53 93 02 F6 | 	mov	arg02, local01
082b4     54 95 02 F6 | 	mov	arg03, local02
082b8     01 00 00 FF 
082bc     10 62 06 F1 | 	add	objptr, ##528
082c0     31 91 02 FB | 	rdlong	arg01, objptr
082c4     48 97 02 F6 | 	mov	arg04, arg01
082c8     30 96 06 F1 | 	add	arg04, #48
082cc     4B B3 02 FB | 	rdlong	local07, arg04
082d0     59 B5 02 F6 | 	mov	local08, local07
082d4     13 B2 46 F7 | 	zerox	local07, #19
082d8     14 B4 46 F0 | 	shr	local08, #20
082dc     02 B4 66 F0 | 	shl	local08, #2
082e0     2D B5 02 F1 | 	add	local08, __methods__
082e4     5A B5 02 FB | 	rdlong	local08, local08
082e8     01 00 00 FF 
082ec     10 62 86 F1 | 	sub	objptr, ##528
082f0     00 96 06 F6 | 	mov	arg04, #0
082f4     31 B7 02 F6 | 	mov	local09, objptr
082f8     59 63 02 F6 | 	mov	objptr, local07
082fc     2D B4 62 FD | 	call	local08
08300     5B 63 02 F6 | 	mov	objptr, local09
08304     3B AB 02 F6 | 	mov	local03, result1
08308     3C AD 02 F6 | 	mov	local04, result2
0830c     55 91 02 F6 | 	mov	arg01, local03
08310     56 93 02 F6 | 	mov	arg02, local04
08314     53 95 02 F6 | 	mov	arg03, local01
08318     54 97 02 F6 | 	mov	arg04, local02
0831c     00 76 06 F6 | 	mov	result1, #0
08320     4A 91 1A F2 | 	cmp	arg01, arg03 wcz
08324     4B 93 7A F2 | 	cmpsx	arg02, arg04 wcz
08328     01 76 86 56 |  if_ne	negc	result1, #1
0832c     00 76 0E F2 | 	cmp	result1, #0 wz
08330                 | '         return RES_ERROR;
08330     01 76 06 56 |  if_ne	mov	result1, #1
08334     60 00 90 5D |  if_ne	jmp	#LR__1350
08338     09 B0 66 F0 | 	shl	local06, #9
0833c     01 00 00 FF 
08340     10 62 06 F1 | 	add	objptr, ##528
08344     31 91 02 FB | 	rdlong	arg01, objptr
08348     48 AB 02 F6 | 	mov	local03, arg01
0834c     18 AA 06 F1 | 	add	local03, #24
08350     55 AB 02 FB | 	rdlong	local03, local03
08354     55 B7 02 F6 | 	mov	local09, local03
08358     13 B6 46 F7 | 	zerox	local09, #19
0835c     14 AA 46 F0 | 	shr	local03, #20
08360     02 AA 66 F0 | 	shl	local03, #2
08364     2D AB 02 F1 | 	add	local03, __methods__
08368     55 AB 02 FB | 	rdlong	local03, local03
0836c     01 00 00 FF 
08370     10 62 86 F1 | 	sub	objptr, ##528
08374     57 93 02 F6 | 	mov	arg02, local05
08378     58 95 02 F6 | 	mov	arg03, local06
0837c     31 B5 02 F6 | 	mov	local08, objptr
08380     5B 63 02 F6 | 	mov	objptr, local09
08384     2D AA 62 FD | 	call	local03
08388     5A 63 02 F6 | 	mov	objptr, local08
0838c     58 77 0A F2 | 	cmp	result1, local06 wz
08390                 | '         return RES_ERROR;
08390     01 76 06 56 |  if_ne	mov	result1, #1
08394                 | '     }
08394                 | '     return RES_OK;
08394     00 76 06 A6 |  if_e	mov	result1, #0
08398                 | LR__1350
08398     E7 F0 03 F6 | 	mov	ptra, fp
0839c     F2 00 A0 FD | 	call	#popregs_
083a0                 | _fatfs_cc_disk_write_ret
083a0     2D 00 64 FD | 	ret
083a4                 | 
083a4                 | _fatfs_cc_disk_ioctl
083a4     03 CA 05 F6 | 	mov	COUNT_, #3
083a8     E8 00 A0 FD | 	call	#pushregs_
083ac     01 00 00 FF 
083b0     10 62 06 F1 | 	add	objptr, ##528
083b4     31 91 0A FB | 	rdlong	arg01, objptr wz
083b8     01 00 00 FF 
083bc     10 62 86 F1 | 	sub	objptr, ##528
083c0                 | '         return RES_NOTRDY;
083c0     03 76 06 A6 |  if_e	mov	result1, #3
083c4     58 00 90 AD |  if_e	jmp	#LR__1360
083c8     01 00 00 FF 
083cc     10 62 06 F1 | 	add	objptr, ##528
083d0     31 91 02 FB | 	rdlong	arg01, objptr
083d4     48 A7 02 F6 | 	mov	local01, arg01
083d8     28 A6 06 F1 | 	add	local01, #40
083dc     53 A7 02 FB | 	rdlong	local01, local01
083e0     53 A9 02 F6 | 	mov	local02, local01
083e4     13 A8 46 F7 | 	zerox	local02, #19
083e8     14 A6 46 F0 | 	shr	local01, #20
083ec     02 A6 66 F0 | 	shl	local01, #2
083f0     2D A7 02 F1 | 	add	local01, __methods__
083f4     53 A7 02 FB | 	rdlong	local01, local01
083f8     01 00 00 FF 
083fc     10 62 86 F1 | 	sub	objptr, ##528
08400     49 93 E2 F8 | 	getbyte	arg02, arg02, #0
08404     31 AB 02 F6 | 	mov	local03, objptr
08408     54 63 02 F6 | 	mov	objptr, local02
0840c     2D A6 62 FD | 	call	local01
08410     55 63 02 F6 | 	mov	objptr, local03
08414     00 76 0E F2 | 	cmp	result1, #0 wz
08418                 | '         return RES_ERROR;
08418     01 76 06 56 |  if_ne	mov	result1, #1
0841c                 | '     return RES_OK;
0841c     00 76 06 A6 |  if_e	mov	result1, #0
08420                 | LR__1360
08420     E7 F0 03 F6 | 	mov	ptra, fp
08424     F2 00 A0 FD | 	call	#popregs_
08428                 | _fatfs_cc_disk_ioctl_ret
08428     2D 00 64 FD | 	ret
0842c                 | 
0842c                 | _fatfs_cc_tchar2uni
0842c     48 7D 02 FB | 	rdlong	_var01, arg01
08430     3E 7F 02 F6 | 	mov	_var02, _var01
08434     01 7C 06 F1 | 	add	_var01, #1
08438     3E 81 02 F6 | 	mov	_var03, _var01
0843c     3F 83 C2 FA | 	rdbyte	_var04, _var02
08440     80 82 CE F7 | 	test	_var04, #128 wz
08444     E8 00 90 AD |  if_e	jmp	#LR__1377
08448     41 85 02 F6 | 	mov	_var05, _var04
0844c     E0 84 06 F5 | 	and	_var05, #224
08450     C0 84 0E F2 | 	cmp	_var05, #192 wz
08454     1F 82 06 A5 |  if_e	and	_var04, #31
08458     01 86 06 A6 |  if_e	mov	_var06, #1
0845c     34 00 90 AD |  if_e	jmp	#LR__1371
08460     41 85 02 F6 | 	mov	_var05, _var04
08464     F0 84 06 F5 | 	and	_var05, #240
08468     E0 84 0E F2 | 	cmp	_var05, #224 wz
0846c     41 83 42 A8 |  if_e	getnib	_var04, _var04, #0
08470     02 86 06 A6 |  if_e	mov	_var06, #2
08474     1C 00 90 AD |  if_e	jmp	#LR__1370
08478     41 85 02 F6 | 	mov	_var05, _var04
0847c     F8 84 06 F5 | 	and	_var05, #248
08480     F0 84 0E F2 | 	cmp	_var05, #240 wz
08484     07 82 06 A5 |  if_e	and	_var04, #7
08488     03 86 06 A6 |  if_e	mov	_var06, #3
0848c                 | ' 			return 0xFFFFFFFF;
0848c     01 76 66 56 |  if_ne	neg	result1, #1
08490     A4 00 90 5D |  if_ne	jmp	#_fatfs_cc_tchar2uni_ret
08494                 | LR__1370
08494                 | LR__1371
08494                 | ' 		}
08494                 | ' 		do {
08494                 | LR__1372
08494     40 89 C2 FA | 	rdbyte	_var07, _var03
08498     44 85 E2 F8 | 	getbyte	_var05, _var07, #0
0849c     C0 84 06 F5 | 	and	_var05, #192
084a0     80 84 0E F2 | 	cmp	_var05, #128 wz
084a4     01 80 06 F1 | 	add	_var03, #1
084a8     01 76 66 56 |  if_ne	neg	result1, #1
084ac     88 00 90 5D |  if_ne	jmp	#_fatfs_cc_tchar2uni_ret
084b0     06 82 66 F0 | 	shl	_var04, #6
084b4     44 7F E2 F8 | 	getbyte	_var02, _var07, #0
084b8     3F 7E 06 F5 | 	and	_var02, #63
084bc     3F 83 42 F5 | 	or	_var04, _var02
084c0     F4 87 6E FB | 	djnz	_var06, #LR__1372
084c4     80 82 16 F2 | 	cmp	_var04, #128 wc
084c8     24 00 90 CD |  if_b	jmp	#LR__1374
084cc     6C 00 00 FF 
084d0     00 82 16 F2 | 	cmp	_var04, ##55296 wc
084d4     0C 00 90 CD |  if_b	jmp	#LR__1373
084d8     70 00 00 FF 
084dc     00 82 16 F2 | 	cmp	_var04, ##57344 wc
084e0     0C 00 90 CD |  if_b	jmp	#LR__1374
084e4                 | LR__1373
084e4     80 08 00 FF 
084e8     00 82 16 F2 | 	cmp	_var04, ##1114112 wc
084ec     08 00 90 CD |  if_b	jmp	#LR__1375
084f0                 | LR__1374
084f0     01 76 66 F6 | 	neg	result1, #1
084f4     40 00 90 FD | 	jmp	#_fatfs_cc_tchar2uni_ret
084f8                 | LR__1375
084f8     80 00 00 FF 
084fc     00 82 16 F2 | 	cmp	_var04, ##65536 wc
08500     2C 00 90 CD |  if_b	jmp	#LR__1376
08504     41 7F 02 F6 | 	mov	_var02, _var04
08508     80 00 00 FF 
0850c     00 7E 86 F1 | 	sub	_var02, ##65536
08510     06 7E 66 F0 | 	shl	_var02, #6
08514     80 FF 01 FF 
08518     00 7E 06 F5 | 	and	_var02, ##67043328
0851c     6E 00 6C FF 
08520     00 84 06 F6 | 	mov	_var05, ##-671032320
08524     3F 85 42 F5 | 	or	_var05, _var02
08528     09 82 46 F7 | 	zerox	_var04, #9
0852c     42 83 42 F5 | 	or	_var04, _var05
08530                 | LR__1376
08530                 | LR__1377
08530     48 81 62 FC | 	wrlong	_var03, arg01
08534                 | ' 	}
08534                 | ' #line 811 "ff.c"
08534                 | ' 	*str = p;
08534                 | ' 	return uc;
08534     41 77 02 F6 | 	mov	result1, _var04
08538                 | _fatfs_cc_tchar2uni_ret
08538     2D 00 64 FD | 	ret
0853c                 | 
0853c                 | _fatfs_cc_put_utf
0853c     80 90 16 F2 | 	cmp	arg01, #128 wc
08540     18 00 90 3D |  if_ae	jmp	#LR__1380
08544     01 94 16 F2 | 	cmp	arg03, #1 wc
08548     00 76 06 C6 |  if_b	mov	result1, #0
0854c     8C 01 90 CD |  if_b	jmp	#_fatfs_cc_put_utf_ret
08550     49 91 42 FC | 	wrbyte	arg01, arg02
08554                 | ' 		*buf = (TCHAR)chr;
08554                 | ' 		return 1;
08554     01 76 06 F6 | 	mov	result1, #1
08558     80 01 90 FD | 	jmp	#_fatfs_cc_put_utf_ret
0855c                 | LR__1380
0855c     04 00 00 FF 
08560     00 90 16 F2 | 	cmp	arg01, ##2048 wc
08564     40 00 90 3D |  if_ae	jmp	#LR__1381
08568     02 94 16 F2 | 	cmp	arg03, #2 wc
0856c     00 76 06 C6 |  if_b	mov	result1, #0
08570     68 01 90 CD |  if_b	jmp	#_fatfs_cc_put_utf_ret
08574     48 77 02 F6 | 	mov	result1, arg01
08578     06 76 46 F0 | 	shr	result1, #6
0857c     1F 76 06 F5 | 	and	result1, #31
08580     C0 94 06 F6 | 	mov	arg03, #192
08584     3B 95 42 F5 | 	or	arg03, result1
08588     49 95 42 FC | 	wrbyte	arg03, arg02
0858c     01 92 06 F1 | 	add	arg02, #1
08590     3F 90 06 F5 | 	and	arg01, #63
08594     80 76 06 F6 | 	mov	result1, #128
08598     48 77 42 F5 | 	or	result1, arg01
0859c     49 77 42 FC | 	wrbyte	result1, arg02
085a0                 | ' 		*buf++ = (TCHAR)(0xC0 | (chr >> 6 & 0x1F));
085a0                 | ' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
085a0                 | ' 		return 2;
085a0     02 76 06 F6 | 	mov	result1, #2
085a4     34 01 90 FD | 	jmp	#_fatfs_cc_put_utf_ret
085a8                 | LR__1381
085a8     80 00 00 FF 
085ac     00 90 16 F2 | 	cmp	arg01, ##65536 wc
085b0     70 00 90 3D |  if_ae	jmp	#LR__1384
085b4     03 94 16 F2 | 	cmp	arg03, #3 wc
085b8     18 00 90 CD |  if_b	jmp	#LR__1382
085bc     6C 00 00 FF 
085c0     00 90 16 F2 | 	cmp	arg01, ##55296 wc
085c4     14 00 90 CD |  if_b	jmp	#LR__1383
085c8     70 00 00 FF 
085cc     00 90 16 F2 | 	cmp	arg01, ##57344 wc
085d0     08 00 90 3D |  if_ae	jmp	#LR__1383
085d4                 | LR__1382
085d4     00 76 06 F6 | 	mov	result1, #0
085d8     00 01 90 FD | 	jmp	#_fatfs_cc_put_utf_ret
085dc                 | LR__1383
085dc     48 77 5A F8 | 	getnib	result1, arg01, #3
085e0     E0 94 06 F6 | 	mov	arg03, #224
085e4     3B 95 42 F5 | 	or	arg03, result1
085e8     49 95 42 FC | 	wrbyte	arg03, arg02
085ec     01 92 06 F1 | 	add	arg02, #1
085f0     48 77 02 F6 | 	mov	result1, arg01
085f4     06 76 46 F0 | 	shr	result1, #6
085f8     3F 76 06 F5 | 	and	result1, #63
085fc     80 94 06 F6 | 	mov	arg03, #128
08600     3B 95 42 F5 | 	or	arg03, result1
08604     49 95 42 FC | 	wrbyte	arg03, arg02
08608     01 92 06 F1 | 	add	arg02, #1
0860c     3F 90 06 F5 | 	and	arg01, #63
08610     80 76 06 F6 | 	mov	result1, #128
08614     48 77 42 F5 | 	or	result1, arg01
08618     49 77 42 FC | 	wrbyte	result1, arg02
0861c                 | ' 		*buf++ = (TCHAR)(0xE0 | (chr >> 12 & 0x0F));
0861c                 | ' 		*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
0861c                 | ' 		*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
0861c                 | ' 		return 3;
0861c     03 76 06 F6 | 	mov	result1, #3
08620     B8 00 90 FD | 	jmp	#_fatfs_cc_put_utf_ret
08624                 | LR__1384
08624     04 94 16 F2 | 	cmp	arg03, #4 wc
08628     00 76 06 C6 |  if_b	mov	result1, #0
0862c     AC 00 90 CD |  if_b	jmp	#_fatfs_cc_put_utf_ret
08630     48 7D 02 F6 | 	mov	_var01, arg01
08634     E0 7D 06 F4 | 	bitl	_var01, #480
08638     00 00 6C FF 
0863c     00 7C 86 F1 | 	sub	_var01, ##-671088640
08640     06 7C 46 F0 | 	shr	_var01, #6
08644     48 91 32 F9 | 	getword	arg01, arg01, #0
08648     6E 00 00 FF 
0864c     00 90 86 F1 | 	sub	arg01, ##56320
08650     00 08 00 FF 
08654     00 7C 16 F2 | 	cmp	_var01, ##1048576 wc
08658     02 00 00 CF 
0865c     00 90 16 C2 |  if_b	cmp	arg01, ##1024 wc
08660     00 76 06 36 |  if_ae	mov	result1, #0
08664     74 00 90 3D |  if_ae	jmp	#_fatfs_cc_put_utf_ret
08668     48 7D 42 F5 | 	or	_var01, arg01
0866c     80 00 00 FF 
08670     00 7C 06 F1 | 	add	_var01, ##65536
08674     3E 77 02 F6 | 	mov	result1, _var01
08678     12 76 46 F0 | 	shr	result1, #18
0867c     07 76 06 F5 | 	and	result1, #7
08680     F0 94 06 F6 | 	mov	arg03, #240
08684     3B 95 42 F5 | 	or	arg03, result1
08688     49 95 42 FC | 	wrbyte	arg03, arg02
0868c     01 92 06 F1 | 	add	arg02, #1
08690     3E 77 02 F6 | 	mov	result1, _var01
08694     0C 76 46 F0 | 	shr	result1, #12
08698     3F 76 06 F5 | 	and	result1, #63
0869c     80 94 06 F6 | 	mov	arg03, #128
086a0     3B 95 42 F5 | 	or	arg03, result1
086a4     49 95 42 FC | 	wrbyte	arg03, arg02
086a8     01 92 06 F1 | 	add	arg02, #1
086ac     3E 77 02 F6 | 	mov	result1, _var01
086b0     06 76 46 F0 | 	shr	result1, #6
086b4     3F 76 06 F5 | 	and	result1, #63
086b8     80 94 06 F6 | 	mov	arg03, #128
086bc     3B 95 42 F5 | 	or	arg03, result1
086c0     49 95 42 FC | 	wrbyte	arg03, arg02
086c4     01 92 06 F1 | 	add	arg02, #1
086c8     3F 7C 06 F5 | 	and	_var01, #63
086cc     80 76 06 F6 | 	mov	result1, #128
086d0     3E 77 42 F5 | 	or	result1, _var01
086d4     49 77 42 FC | 	wrbyte	result1, arg02
086d8                 | ' 	chr = (hc | chr) + 0x10000;
086d8                 | ' 	*buf++ = (TCHAR)(0xF0 | (chr >> 18 & 0x07));
086d8                 | ' 	*buf++ = (TCHAR)(0x80 | (chr >> 12 & 0x3F));
086d8                 | ' 	*buf++ = (TCHAR)(0x80 | (chr >> 6 & 0x3F));
086d8                 | ' 	*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
086d8                 | ' 	return 4;
086d8     04 76 06 F6 | 	mov	result1, #4
086dc                 | _fatfs_cc_put_utf_ret
086dc     2D 00 64 FD | 	ret
086e0                 | 
086e0                 | _fatfs_cc_sync_window
086e0     02 CA 05 F6 | 	mov	COUNT_, #2
086e4     E8 00 A0 FD | 	call	#pushregs_
086e8     48 A7 02 F6 | 	mov	local01, arg01
086ec     00 A8 06 F6 | 	mov	local02, #0
086f0     03 A6 06 F1 | 	add	local01, #3
086f4     53 77 CA FA | 	rdbyte	result1, local01 wz
086f8     03 A6 86 F1 | 	sub	local01, #3
086fc     A4 00 90 AD |  if_e	jmp	#LR__1392
08700     01 A6 06 F1 | 	add	local01, #1
08704     53 91 C2 FA | 	rdbyte	arg01, local01
08708     33 A6 06 F1 | 	add	local01, #51
0870c     53 93 02 F6 | 	mov	arg02, local01
08710     04 A6 86 F1 | 	sub	local01, #4
08714     53 95 02 FB | 	rdlong	arg03, local01
08718     30 A6 86 F1 | 	sub	local01, #48
0871c     01 96 06 F6 | 	mov	arg04, #1
08720     44 FB BF FD | 	call	#_fatfs_cc_disk_write
08724     00 76 0E F2 | 	cmp	result1, #0 wz
08728     74 00 90 5D |  if_ne	jmp	#LR__1390
0872c     03 A6 06 F1 | 	add	local01, #3
08730     53 01 48 FC | 	wrbyte	#0, local01
08734     2D A6 06 F1 | 	add	local01, #45
08738     53 77 02 FB | 	rdlong	result1, local01
0873c     0C A6 86 F1 | 	sub	local01, #12
08740     53 97 02 FB | 	rdlong	arg04, local01
08744     4B 77 82 F1 | 	sub	result1, arg04
08748     08 A6 86 F1 | 	sub	local01, #8
0874c     53 97 02 FB | 	rdlong	arg04, local01
08750     1C A6 86 F1 | 	sub	local01, #28
08754     4B 77 12 F2 | 	cmp	result1, arg04 wc
08758     48 00 90 3D |  if_ae	jmp	#LR__1391
0875c     02 A6 06 F1 | 	add	local01, #2
08760     53 97 C2 FA | 	rdbyte	arg04, local01
08764     02 A6 86 F1 | 	sub	local01, #2
08768     02 96 0E F2 | 	cmp	arg04, #2 wz
0876c     34 00 90 5D |  if_ne	jmp	#LR__1391
08770     01 A6 06 F1 | 	add	local01, #1
08774     53 91 C2 FA | 	rdbyte	arg01, local01
08778     33 A6 06 F1 | 	add	local01, #51
0877c     53 93 02 F6 | 	mov	arg02, local01
08780     04 A6 86 F1 | 	sub	local01, #4
08784     53 95 02 FB | 	rdlong	arg03, local01
08788     14 A6 86 F1 | 	sub	local01, #20
0878c     53 A7 02 FB | 	rdlong	local01, local01
08790     53 95 02 F1 | 	add	arg03, local01
08794     01 96 06 F6 | 	mov	arg04, #1
08798     CC FA BF FD | 	call	#_fatfs_cc_disk_write
0879c     04 00 90 FD | 	jmp	#LR__1391
087a0                 | LR__1390
087a0     01 A8 06 F6 | 	mov	local02, #1
087a4                 | LR__1391
087a4                 | LR__1392
087a4                 | ' 			res = FR_DISK_ERR;
087a4                 | ' 		}
087a4                 | ' 	}
087a4                 | ' 	return res;
087a4     54 77 02 F6 | 	mov	result1, local02
087a8     E7 F0 03 F6 | 	mov	ptra, fp
087ac     F2 00 A0 FD | 	call	#popregs_
087b0                 | _fatfs_cc_sync_window_ret
087b0     2D 00 64 FD | 	ret
087b4                 | 
087b4                 | _fatfs_cc_move_window
087b4     03 CA 05 F6 | 	mov	COUNT_, #3
087b8     E8 00 A0 FD | 	call	#pushregs_
087bc     48 A7 02 F6 | 	mov	local01, arg01
087c0     49 A9 02 F6 | 	mov	local02, arg02
087c4     00 AA 06 F6 | 	mov	local03, #0
087c8     30 A6 06 F1 | 	add	local01, #48
087cc     53 97 02 FB | 	rdlong	arg04, local01
087d0     30 A6 86 F1 | 	sub	local01, #48
087d4     4B A9 0A F2 | 	cmp	local02, arg04 wz
087d8     40 00 90 AD |  if_e	jmp	#LR__1401
087dc     53 91 02 F6 | 	mov	arg01, local01
087e0     FC FE BF FD | 	call	#_fatfs_cc_sync_window
087e4     3B AB 0A F6 | 	mov	local03, result1 wz
087e8     30 00 90 5D |  if_ne	jmp	#LR__1400
087ec     01 A6 06 F1 | 	add	local01, #1
087f0     53 91 C2 FA | 	rdbyte	arg01, local01
087f4     33 A6 06 F1 | 	add	local01, #51
087f8     53 93 02 F6 | 	mov	arg02, local01
087fc     54 95 02 F6 | 	mov	arg03, local02
08800     01 96 06 F6 | 	mov	arg04, #1
08804     24 F9 BF FD | 	call	#_fatfs_cc_disk_read
08808     00 76 0E F2 | 	cmp	result1, #0 wz
0880c     01 A8 66 56 |  if_ne	neg	local02, #1
08810     01 AA 06 56 |  if_ne	mov	local03, #1
08814     04 A6 86 F1 | 	sub	local01, #4
08818     53 A9 62 FC | 	wrlong	local02, local01
0881c                 | LR__1400
0881c                 | LR__1401
0881c                 | ' 				sect = (LBA_t)0 - 1;
0881c                 | ' 				res = FR_DISK_ERR;
0881c                 | ' 			}
0881c                 | ' 			fs->winsect = sect;
0881c                 | ' 		}
0881c                 | ' 	}
0881c                 | ' 	return res;
0881c     55 77 02 F6 | 	mov	result1, local03
08820     E7 F0 03 F6 | 	mov	ptra, fp
08824     F2 00 A0 FD | 	call	#popregs_
08828                 | _fatfs_cc_move_window_ret
08828     2D 00 64 FD | 	ret
0882c                 | 
0882c                 | _fatfs_cc_sync_fs
0882c     02 CA 05 F6 | 	mov	COUNT_, #2
08830     E8 00 A0 FD | 	call	#pushregs_
08834     48 A7 02 F6 | 	mov	local01, arg01
08838     A4 FE BF FD | 	call	#_fatfs_cc_sync_window
0883c     3B A9 0A F6 | 	mov	local02, result1 wz
08840     D8 00 90 5D |  if_ne	jmp	#LR__1411
08844     53 97 C2 FA | 	rdbyte	arg04, local01
08848     03 96 0E F2 | 	cmp	arg04, #3 wz
0884c     04 A6 06 A1 |  if_e	add	local01, #4
08850     53 97 C2 AA |  if_e	rdbyte	arg04, local01
08854     04 A6 86 A1 |  if_e	sub	local01, #4
08858     01 96 0E A2 |  if_e	cmp	arg04, #1 wz
0885c     A0 00 90 5D |  if_ne	jmp	#LR__1410
08860     34 A6 06 F1 | 	add	local01, #52
08864     53 91 02 F6 | 	mov	arg01, local01
08868     00 92 06 F6 | 	mov	arg02, #0
0886c     09 94 C6 F9 | 	decod	arg03, #9
08870     D8 00 A0 FD | 	call	#\builtin_bytefill_
08874     53 91 02 F6 | 	mov	arg01, local01
08878     FE 91 06 F1 | 	add	arg01, #510
0887c     55 00 80 FF 
08880     48 AB 58 FC | 	wrword	##43605, arg01
08884     A9 B0 A0 FF 
08888     53 A5 68 FC | 	wrlong	##1096897106, local01
0888c     53 91 02 F6 | 	mov	arg01, local01
08890     E4 91 06 F1 | 	add	arg01, #484
08894     B9 A0 B0 FF 
08898     48 E5 68 FC | 	wrlong	##1631679090, arg01
0889c     53 91 02 F6 | 	mov	arg01, local01
088a0     E8 91 06 F1 | 	add	arg01, #488
088a4     20 A6 86 F1 | 	sub	local01, #32
088a8     53 93 02 FB | 	rdlong	arg02, local01
088ac     48 93 62 FC | 	wrlong	arg02, arg01
088b0     20 A6 06 F1 | 	add	local01, #32
088b4     53 91 02 F6 | 	mov	arg01, local01
088b8     EC 91 06 F1 | 	add	arg01, #492
088bc     24 A6 86 F1 | 	sub	local01, #36
088c0     53 93 02 FB | 	rdlong	arg02, local01
088c4     48 93 62 FC | 	wrlong	arg02, arg01
088c8     10 A6 06 F1 | 	add	local01, #16
088cc     53 95 02 FB | 	rdlong	arg03, local01
088d0     01 94 06 F1 | 	add	arg03, #1
088d4     10 A6 06 F1 | 	add	local01, #16
088d8     53 95 62 FC | 	wrlong	arg03, local01
088dc     2F A6 86 F1 | 	sub	local01, #47
088e0     53 91 C2 FA | 	rdbyte	arg01, local01
088e4     33 A6 06 F1 | 	add	local01, #51
088e8     53 93 02 F6 | 	mov	arg02, local01
088ec     01 96 06 F6 | 	mov	arg04, #1
088f0     74 F9 BF FD | 	call	#_fatfs_cc_disk_write
088f4     30 A6 86 F1 | 	sub	local01, #48
088f8     53 01 48 FC | 	wrbyte	#0, local01
088fc     04 A6 86 F1 | 	sub	local01, #4
08900                 | LR__1410
08900     01 A6 06 F1 | 	add	local01, #1
08904     53 91 C2 FA | 	rdbyte	arg01, local01
08908     00 92 06 F6 | 	mov	arg02, #0
0890c     00 94 06 F6 | 	mov	arg03, #0
08910     90 FA BF FD | 	call	#_fatfs_cc_disk_ioctl
08914     00 76 0E F2 | 	cmp	result1, #0 wz
08918     01 A8 06 56 |  if_ne	mov	local02, #1
0891c                 | LR__1411
0891c                 | ' 	}
0891c                 | ' 
0891c                 | ' 	return res;
0891c     54 77 02 F6 | 	mov	result1, local02
08920     E7 F0 03 F6 | 	mov	ptra, fp
08924     F2 00 A0 FD | 	call	#popregs_
08928                 | _fatfs_cc_sync_fs_ret
08928     2D 00 64 FD | 	ret
0892c                 | 
0892c                 | _fatfs_cc_clst2sect
0892c     02 92 86 F1 | 	sub	arg02, #2
08930     18 90 06 F1 | 	add	arg01, #24
08934     48 7D 02 FB | 	rdlong	_var01, arg01
08938     18 90 86 F1 | 	sub	arg01, #24
0893c     02 7C 86 F1 | 	sub	_var01, #2
08940     3E 93 12 F2 | 	cmp	arg02, _var01 wc
08944     00 76 06 36 |  if_ae	mov	result1, #0
08948     1C 00 90 3D |  if_ae	jmp	#_fatfs_cc_clst2sect_ret
0894c     0A 90 06 F1 | 	add	arg01, #10
08950     48 7D E2 FA | 	rdword	_var01, arg01
08954     49 7D 02 FD | 	qmul	_var01, arg02
08958                 | ' 	return fs->database + (LBA_t)fs->csize * clst;
08958     22 90 06 F1 | 	add	arg01, #34
0895c     48 77 02 FB | 	rdlong	result1, arg01
08960     18 7C 62 FD | 	getqx	_var01
08964     3E 77 02 F1 | 	add	result1, _var01
08968                 | _fatfs_cc_clst2sect_ret
08968     2D 00 64 FD | 	ret
0896c                 | 
0896c                 | _fatfs_cc_get_fat
0896c     07 CA 05 F6 | 	mov	COUNT_, #7
08970     E8 00 A0 FD | 	call	#pushregs_
08974     49 A7 02 F6 | 	mov	local01, arg02
08978     48 A9 02 FB | 	rdlong	local02, arg01
0897c     02 A6 16 F2 | 	cmp	local01, #2 wc
08980     14 00 90 CD |  if_b	jmp	#LR__1420
08984     18 A8 06 F1 | 	add	local02, #24
08988     54 AB 02 FB | 	rdlong	local03, local02
0898c     18 A8 86 F1 | 	sub	local02, #24
08990     55 A7 12 F2 | 	cmp	local01, local03 wc
08994     08 00 90 CD |  if_b	jmp	#LR__1421
08998                 | LR__1420
08998     01 AC 06 F6 | 	mov	local04, #1
0899c     60 01 90 FD | 	jmp	#LR__1428
089a0                 | LR__1421
089a0     01 AC 66 F6 | 	neg	local04, #1
089a4                 | ' 		val = 0xFFFFFFFF;
089a4                 | ' 
089a4                 | ' 		switch (fs->fs_type) {
089a4     54 AF C2 FA | 	rdbyte	local05, local02
089a8     01 AE 86 F1 | 	sub	local05, #1
089ac     03 AE 26 F3 | 	fle	local05, #3
089b0     30 AE 62 FD | 	jmprel	local05
089b4                 | LR__1422
089b4     0C 00 90 FD | 	jmp	#LR__1423
089b8     B8 00 90 FD | 	jmp	#LR__1424
089bc     F8 00 90 FD | 	jmp	#LR__1425
089c0     38 01 90 FD | 	jmp	#LR__1426
089c4                 | LR__1423
089c4     53 AF 02 F6 | 	mov	local05, local01
089c8     53 91 02 F6 | 	mov	arg01, local01
089cc     01 90 46 F0 | 	shr	arg01, #1
089d0     48 AF 02 F1 | 	add	local05, arg01
089d4     54 91 02 F6 | 	mov	arg01, local02
089d8     57 B1 02 F6 | 	mov	local06, local05
089dc     09 B0 46 F0 | 	shr	local06, #9
089e0     24 A8 06 F1 | 	add	local02, #36
089e4     54 93 02 FB | 	rdlong	arg02, local02
089e8     24 A8 86 F1 | 	sub	local02, #36
089ec     58 93 02 F1 | 	add	arg02, local06
089f0     C0 FD BF FD | 	call	#_fatfs_cc_move_window
089f4     00 76 0E F2 | 	cmp	result1, #0 wz
089f8     04 01 90 5D |  if_ne	jmp	#LR__1427
089fc     57 B1 02 F6 | 	mov	local06, local05
08a00     FF B1 06 F5 | 	and	local06, #511
08a04     54 91 02 F6 | 	mov	arg01, local02
08a08     34 90 06 F1 | 	add	arg01, #52
08a0c     48 B1 02 F1 | 	add	local06, arg01
08a10     58 B3 C2 FA | 	rdbyte	local07, local06
08a14     54 91 02 F6 | 	mov	arg01, local02
08a18     01 AE 06 F1 | 	add	local05, #1
08a1c     57 B1 02 F6 | 	mov	local06, local05
08a20     09 B0 46 F0 | 	shr	local06, #9
08a24     24 A8 06 F1 | 	add	local02, #36
08a28     54 93 02 FB | 	rdlong	arg02, local02
08a2c     24 A8 86 F1 | 	sub	local02, #36
08a30     58 93 02 F1 | 	add	arg02, local06
08a34     7C FD BF FD | 	call	#_fatfs_cc_move_window
08a38     00 76 0E F2 | 	cmp	result1, #0 wz
08a3c     C0 00 90 5D |  if_ne	jmp	#LR__1427
08a40     FF AF 06 F5 | 	and	local05, #511
08a44     34 A8 06 F1 | 	add	local02, #52
08a48     54 AF 02 F1 | 	add	local05, local02
08a4c     57 B1 C2 FA | 	rdbyte	local06, local05
08a50     08 B0 66 F0 | 	shl	local06, #8
08a54     58 B3 42 F5 | 	or	local07, local06
08a58     01 A6 CE F7 | 	test	local01, #1 wz
08a5c     04 B2 46 50 |  if_ne	shr	local07, #4
08a60     59 AB 02 56 |  if_ne	mov	local03, local07
08a64     0B B2 46 A7 |  if_e	zerox	local07, #11
08a68     59 AB 02 A6 |  if_e	mov	local03, local07
08a6c     55 AD 02 F6 | 	mov	local04, local03
08a70                 | ' 			wc |= fs->win[bc %  ((UINT) 512 ) ] << 8;
08a70                 | ' 			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
08a70                 | ' 			break;
08a70     8C 00 90 FD | 	jmp	#LR__1427
08a74                 | LR__1424
08a74     54 91 02 F6 | 	mov	arg01, local02
08a78     53 B1 02 F6 | 	mov	local06, local01
08a7c     08 B0 46 F0 | 	shr	local06, #8
08a80     24 A8 06 F1 | 	add	local02, #36
08a84     54 93 02 FB | 	rdlong	arg02, local02
08a88     24 A8 86 F1 | 	sub	local02, #36
08a8c     58 93 02 F1 | 	add	arg02, local06
08a90     20 FD BF FD | 	call	#_fatfs_cc_move_window
08a94     00 76 0E F2 | 	cmp	result1, #0 wz
08a98     64 00 90 5D |  if_ne	jmp	#LR__1427
08a9c     34 A8 06 F1 | 	add	local02, #52
08aa0     01 A6 66 F0 | 	shl	local01, #1
08aa4     FF A7 06 F5 | 	and	local01, #511
08aa8     53 A9 02 F1 | 	add	local02, local01
08aac                 | ' {
08aac                 | ' 
08aac                 | ' 	return *((WORD*)ptr);
08aac     54 77 E2 FA | 	rdword	result1, local02
08ab0     3B AD 32 F9 | 	getword	local04, result1, #0
08ab4                 | ' 			val = ld_word(fs->win + clst * 2 %  ((UINT) 512 ) );
08ab4                 | ' 			break;
08ab4     48 00 90 FD | 	jmp	#LR__1427
08ab8                 | LR__1425
08ab8     54 91 02 F6 | 	mov	arg01, local02
08abc     53 B1 02 F6 | 	mov	local06, local01
08ac0     07 B0 46 F0 | 	shr	local06, #7
08ac4     24 A8 06 F1 | 	add	local02, #36
08ac8     54 93 02 FB | 	rdlong	arg02, local02
08acc     24 A8 86 F1 | 	sub	local02, #36
08ad0     58 93 02 F1 | 	add	arg02, local06
08ad4     DC FC BF FD | 	call	#_fatfs_cc_move_window
08ad8     00 76 0E F2 | 	cmp	result1, #0 wz
08adc     20 00 90 5D |  if_ne	jmp	#LR__1427
08ae0     34 A8 06 F1 | 	add	local02, #52
08ae4     02 A6 66 F0 | 	shl	local01, #2
08ae8     FF A7 06 F5 | 	and	local01, #511
08aec     53 A9 02 F1 | 	add	local02, local01
08af0                 | ' {
08af0                 | ' 
08af0                 | ' 	return *((DWORD*)ptr);
08af0     54 AD 02 FB | 	rdlong	local04, local02
08af4     7C AC 06 F4 | 	bitl	local04, #124
08af8                 | ' 			val = ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0x0FFFFFFF;
08af8                 | ' 			break;
08af8     04 00 90 FD | 	jmp	#LR__1427
08afc                 | LR__1426
08afc     01 AC 06 F6 | 	mov	local04, #1
08b00                 | LR__1427
08b00                 | LR__1428
08b00                 | ' 			val = 1;
08b00                 | ' 		}
08b00                 | ' 	}
08b00                 | ' 
08b00                 | ' 	return val;
08b00     56 77 02 F6 | 	mov	result1, local04
08b04     E7 F0 03 F6 | 	mov	ptra, fp
08b08     F2 00 A0 FD | 	call	#popregs_
08b0c                 | _fatfs_cc_get_fat_ret
08b0c     2D 00 64 FD | 	ret
08b10                 | 
08b10                 | _fatfs_cc_put_fat
08b10     08 CA 05 F6 | 	mov	COUNT_, #8
08b14     E8 00 A0 FD | 	call	#pushregs_
08b18     48 A7 02 F6 | 	mov	local01, arg01
08b1c     49 A9 02 F6 | 	mov	local02, arg02
08b20     4A AB 02 F6 | 	mov	local03, arg03
08b24     02 AC 06 F6 | 	mov	local04, #2
08b28     02 A8 16 F2 | 	cmp	local02, #2 wc
08b2c     E0 01 90 CD |  if_b	jmp	#LR__1437
08b30     18 A6 06 F1 | 	add	local01, #24
08b34     53 AF 02 FB | 	rdlong	local05, local01
08b38     18 A6 86 F1 | 	sub	local01, #24
08b3c     57 A9 12 F2 | 	cmp	local02, local05 wc
08b40     CC 01 90 3D |  if_ae	jmp	#LR__1437
08b44                 | ' 		switch (fs->fs_type) {
08b44     53 B1 C2 FA | 	rdbyte	local06, local01
08b48     01 B0 86 F1 | 	sub	local06, #1
08b4c     03 B0 26 F3 | 	fle	local06, #3
08b50     30 B0 62 FD | 	jmprel	local06
08b54                 | LR__1430
08b54     0C 00 90 FD | 	jmp	#LR__1431
08b58     F4 00 90 FD | 	jmp	#LR__1434
08b5c     3C 01 90 FD | 	jmp	#LR__1435
08b60     AC 01 90 FD | 	jmp	#LR__1436
08b64                 | LR__1431
08b64     54 B3 02 F6 | 	mov	local07, local02
08b68     54 AF 02 F6 | 	mov	local05, local02
08b6c     01 AE 46 F0 | 	shr	local05, #1
08b70     57 B3 02 F1 | 	add	local07, local05
08b74     53 91 02 F6 | 	mov	arg01, local01
08b78     59 B1 02 F6 | 	mov	local06, local07
08b7c     09 B0 46 F0 | 	shr	local06, #9
08b80     24 A6 06 F1 | 	add	local01, #36
08b84     53 93 02 FB | 	rdlong	arg02, local01
08b88     24 A6 86 F1 | 	sub	local01, #36
08b8c     58 93 02 F1 | 	add	arg02, local06
08b90     20 FC BF FD | 	call	#_fatfs_cc_move_window
08b94     3B AD 0A F6 | 	mov	local04, result1 wz
08b98     74 01 90 5D |  if_ne	jmp	#LR__1436
08b9c     53 B5 02 F6 | 	mov	local08, local01
08ba0     34 B4 06 F1 | 	add	local08, #52
08ba4     59 AF 02 F6 | 	mov	local05, local07
08ba8     FF AF 06 F5 | 	and	local05, #511
08bac     57 B5 02 F1 | 	add	local08, local05
08bb0     01 A8 CE F7 | 	test	local02, #1 wz
08bb4     01 B2 06 F1 | 	add	local07, #1
08bb8     18 00 90 AD |  if_e	jmp	#LR__1432
08bbc     5A AF C2 FA | 	rdbyte	local05, local08
08bc0     57 AF 42 F8 | 	getnib	local05, local05, #0
08bc4     55 B1 E2 F8 | 	getbyte	local06, local03, #0
08bc8     04 B0 66 F0 | 	shl	local06, #4
08bcc     58 AF 42 F5 | 	or	local05, local06
08bd0     04 00 90 FD | 	jmp	#LR__1433
08bd4                 | LR__1432
08bd4     55 AF 02 F6 | 	mov	local05, local03
08bd8                 | LR__1433
08bd8     5A AF 42 FC | 	wrbyte	local05, local08
08bdc     03 A6 06 F1 | 	add	local01, #3
08be0     53 03 48 FC | 	wrbyte	#1, local01
08be4     03 A6 86 F1 | 	sub	local01, #3
08be8     53 91 02 F6 | 	mov	arg01, local01
08bec     59 B5 02 F6 | 	mov	local08, local07
08bf0     09 B4 46 F0 | 	shr	local08, #9
08bf4     24 A6 06 F1 | 	add	local01, #36
08bf8     53 93 02 FB | 	rdlong	arg02, local01
08bfc     24 A6 86 F1 | 	sub	local01, #36
08c00     5A 93 02 F1 | 	add	arg02, local08
08c04     AC FB BF FD | 	call	#_fatfs_cc_move_window
08c08     3B AD 0A F6 | 	mov	local04, result1 wz
08c0c     00 01 90 5D |  if_ne	jmp	#LR__1436
08c10     53 B5 02 F6 | 	mov	local08, local01
08c14     34 B4 06 F1 | 	add	local08, #52
08c18     FF B3 06 F5 | 	and	local07, #511
08c1c     59 B5 02 F1 | 	add	local08, local07
08c20     01 A8 CE F7 | 	test	local02, #1 wz
08c24     04 AA 46 50 |  if_ne	shr	local03, #4
08c28     55 AF 02 56 |  if_ne	mov	local05, local03
08c2c     5A AF C2 AA |  if_e	rdbyte	local05, local08
08c30     F0 AE 06 A5 |  if_e	and	local05, #240
08c34     55 AB EA A8 |  if_e	getbyte	local03, local03, #1
08c38     55 AB 42 A8 |  if_e	getnib	local03, local03, #0
08c3c     55 AF 42 A5 |  if_e	or	local05, local03
08c40     5A AF 42 FC | 	wrbyte	local05, local08
08c44     03 A6 06 F1 | 	add	local01, #3
08c48     53 03 48 FC | 	wrbyte	#1, local01
08c4c                 | ' 			p = fs->win + bc %  ((UINT) 512 ) ;
08c4c                 | ' 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
08c4c                 | ' 			fs->wflag = 1;
08c4c                 | ' 			break;
08c4c     C0 00 90 FD | 	jmp	#LR__1436
08c50                 | LR__1434
08c50     53 91 02 F6 | 	mov	arg01, local01
08c54     54 B5 02 F6 | 	mov	local08, local02
08c58     08 B4 46 F0 | 	shr	local08, #8
08c5c     24 A6 06 F1 | 	add	local01, #36
08c60     53 93 02 FB | 	rdlong	arg02, local01
08c64     24 A6 86 F1 | 	sub	local01, #36
08c68     5A 93 02 F1 | 	add	arg02, local08
08c6c     44 FB BF FD | 	call	#_fatfs_cc_move_window
08c70     3B AD 0A F6 | 	mov	local04, result1 wz
08c74     98 00 90 5D |  if_ne	jmp	#LR__1436
08c78     34 A6 06 F1 | 	add	local01, #52
08c7c     53 91 02 F6 | 	mov	arg01, local01
08c80     01 A8 66 F0 | 	shl	local02, #1
08c84     FF A9 06 F5 | 	and	local02, #511
08c88     54 91 02 F1 | 	add	arg01, local02
08c8c     48 AB 52 FC | 	wrword	local03, arg01
08c90     31 A6 86 F1 | 	sub	local01, #49
08c94     53 03 48 FC | 	wrbyte	#1, local01
08c98                 | ' 			st_word(fs->win + clst * 2 %  ((UINT) 512 ) , (WORD)val);
08c98                 | ' 			fs->wflag = 1;
08c98                 | ' 			break;
08c98     74 00 90 FD | 	jmp	#LR__1436
08c9c                 | LR__1435
08c9c     53 91 02 F6 | 	mov	arg01, local01
08ca0     54 B5 02 F6 | 	mov	local08, local02
08ca4     07 B4 46 F0 | 	shr	local08, #7
08ca8     24 A6 06 F1 | 	add	local01, #36
08cac     53 93 02 FB | 	rdlong	arg02, local01
08cb0     24 A6 86 F1 | 	sub	local01, #36
08cb4     5A 93 02 F1 | 	add	arg02, local08
08cb8     F8 FA BF FD | 	call	#_fatfs_cc_move_window
08cbc     3B AD 0A F6 | 	mov	local04, result1 wz
08cc0     4C 00 90 5D |  if_ne	jmp	#LR__1436
08cc4     7C AA 06 F4 | 	bitl	local03, #124
08cc8     53 91 02 F6 | 	mov	arg01, local01
08ccc     34 90 06 F1 | 	add	arg01, #52
08cd0     54 B5 02 F6 | 	mov	local08, local02
08cd4     02 B4 66 F0 | 	shl	local08, #2
08cd8     FF B5 06 F5 | 	and	local08, #511
08cdc     5A 91 02 F1 | 	add	arg01, local08
08ce0                 | ' {
08ce0                 | ' 
08ce0                 | ' 	return *((DWORD*)ptr);
08ce0     48 B5 02 FB | 	rdlong	local08, arg01
08ce4     00 00 78 FF 
08ce8     00 B4 06 F5 | 	and	local08, ##-268435456
08cec     5A AB 42 F5 | 	or	local03, local08
08cf0     34 A6 06 F1 | 	add	local01, #52
08cf4     53 91 02 F6 | 	mov	arg01, local01
08cf8     02 A8 66 F0 | 	shl	local02, #2
08cfc     FF A9 06 F5 | 	and	local02, #511
08d00     54 91 02 F1 | 	add	arg01, local02
08d04     48 AB 62 FC | 	wrlong	local03, arg01
08d08     31 A6 86 F1 | 	sub	local01, #49
08d0c     53 03 48 FC | 	wrbyte	#1, local01
08d10                 | ' 				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 %  ((UINT) 512 ) ) & 0xF0000000);
08d10                 | ' 			}
08d10                 | ' 			st_dword(fs->win + clst * 4 %  ((UINT) 512 ) , val);
08d10                 | ' 			fs->wflag = 1;
08d10                 | ' 			break;
08d10                 | LR__1436
08d10                 | LR__1437
08d10                 | ' 		}
08d10                 | ' 	}
08d10                 | ' 	return res;
08d10     56 77 02 F6 | 	mov	result1, local04
08d14     E7 F0 03 F6 | 	mov	ptra, fp
08d18     F2 00 A0 FD | 	call	#popregs_
08d1c                 | _fatfs_cc_put_fat_ret
08d1c     2D 00 64 FD | 	ret
08d20                 | 
08d20                 | _fatfs_cc_remove_chain
08d20     05 CA 05 F6 | 	mov	COUNT_, #5
08d24     E8 00 A0 FD | 	call	#pushregs_
08d28     48 A7 02 F6 | 	mov	local01, arg01
08d2c     49 A9 02 F6 | 	mov	local02, arg02
08d30     4A AB 02 F6 | 	mov	local03, arg03
08d34     53 AD 02 FB | 	rdlong	local04, local01
08d38     02 A8 16 F2 | 	cmp	local02, #2 wc
08d3c     14 00 90 CD |  if_b	jmp	#LR__1440
08d40     18 AC 06 F1 | 	add	local04, #24
08d44     56 77 02 FB | 	rdlong	result1, local04
08d48     18 AC 86 F1 | 	sub	local04, #24
08d4c     3B A9 12 F2 | 	cmp	local02, result1 wc
08d50     08 00 90 CD |  if_b	jmp	#LR__1441
08d54                 | LR__1440
08d54     02 76 06 F6 | 	mov	result1, #2
08d58     CC 00 90 FD | 	jmp	#LR__1446
08d5c                 | LR__1441
08d5c     00 AA 0E F2 | 	cmp	local03, #0 wz
08d60     18 00 90 AD |  if_e	jmp	#LR__1442
08d64     55 93 02 F6 | 	mov	arg02, local03
08d68     56 91 02 F6 | 	mov	arg01, local04
08d6c     01 94 66 F6 | 	neg	arg03, #1
08d70     9C FD BF FD | 	call	#_fatfs_cc_put_fat
08d74     00 76 0E F2 | 	cmp	result1, #0 wz
08d78     AC 00 90 5D |  if_ne	jmp	#LR__1446
08d7c                 | LR__1442
08d7c                 | ' 	}
08d7c                 | ' 
08d7c                 | ' 
08d7c                 | ' 	do {
08d7c                 | LR__1443
08d7c     54 93 02 F6 | 	mov	arg02, local02
08d80     53 91 02 F6 | 	mov	arg01, local01
08d84     E4 FB BF FD | 	call	#_fatfs_cc_get_fat
08d88     3B AF 0A F6 | 	mov	local05, result1 wz
08d8c     94 00 90 AD |  if_e	jmp	#LR__1445
08d90     01 AE 0E F2 | 	cmp	local05, #1 wz
08d94     02 76 06 A6 |  if_e	mov	result1, #2
08d98     8C 00 90 AD |  if_e	jmp	#LR__1446
08d9c     FF FF 7F FF 
08da0     FF AF 0E F2 | 	cmp	local05, ##-1 wz
08da4     01 76 06 A6 |  if_e	mov	result1, #1
08da8     7C 00 90 AD |  if_e	jmp	#LR__1446
08dac     54 93 02 F6 | 	mov	arg02, local02
08db0     56 91 02 F6 | 	mov	arg01, local04
08db4     00 94 06 F6 | 	mov	arg03, #0
08db8     54 FD BF FD | 	call	#_fatfs_cc_put_fat
08dbc     3B AB 0A F6 | 	mov	local03, result1 wz
08dc0     55 77 02 56 |  if_ne	mov	result1, local03
08dc4     60 00 90 5D |  if_ne	jmp	#LR__1446
08dc8     18 AC 06 F1 | 	add	local04, #24
08dcc     56 AB 02 FB | 	rdlong	local03, local04
08dd0     02 AA 86 F1 | 	sub	local03, #2
08dd4     04 AC 86 F1 | 	sub	local04, #4
08dd8     56 A9 02 FB | 	rdlong	local02, local04
08ddc     14 AC 86 F1 | 	sub	local04, #20
08de0     55 A9 12 F2 | 	cmp	local02, local03 wc
08de4     24 00 90 3D |  if_ae	jmp	#LR__1444
08de8     14 AC 06 F1 | 	add	local04, #20
08dec     56 AB 02 FB | 	rdlong	local03, local04
08df0     01 AA 06 F1 | 	add	local03, #1
08df4     56 AB 62 FC | 	wrlong	local03, local04
08df8     10 AC 86 F1 | 	sub	local04, #16
08dfc     56 AB C2 FA | 	rdbyte	local03, local04
08e00     01 AA 46 F5 | 	or	local03, #1
08e04     56 AB 42 FC | 	wrbyte	local03, local04
08e08     04 AC 86 F1 | 	sub	local04, #4
08e0c                 | LR__1444
08e0c     57 A9 02 F6 | 	mov	local02, local05
08e10     18 AC 06 F1 | 	add	local04, #24
08e14     56 AF 02 FB | 	rdlong	local05, local04
08e18     18 AC 86 F1 | 	sub	local04, #24
08e1c     57 A9 12 F2 | 	cmp	local02, local05 wc
08e20     58 FF 9F CD |  if_b	jmp	#LR__1443
08e24                 | LR__1445
08e24                 | ' #line 1500 "ff.c"
08e24                 | ' 	return FR_OK;
08e24     00 76 06 F6 | 	mov	result1, #0
08e28                 | LR__1446
08e28     E7 F0 03 F6 | 	mov	ptra, fp
08e2c     F2 00 A0 FD | 	call	#popregs_
08e30                 | _fatfs_cc_remove_chain_ret
08e30     2D 00 64 FD | 	ret
08e34                 | 
08e34                 | _fatfs_cc_create_chain
08e34     09 CA 05 F6 | 	mov	COUNT_, #9
08e38     E8 00 A0 FD | 	call	#pushregs_
08e3c     48 A7 02 F6 | 	mov	local01, arg01
08e40     49 A9 0A F6 | 	mov	local02, arg02 wz
08e44     53 AB 02 FB | 	rdlong	local03, local01
08e48     28 00 90 5D |  if_ne	jmp	#LR__1450
08e4c     10 AA 06 F1 | 	add	local03, #16
08e50     55 AD 0A FB | 	rdlong	local04, local03 wz
08e54     10 AA 86 F1 | 	sub	local03, #16
08e58     18 AA 06 51 |  if_ne	add	local03, #24
08e5c     55 AF 02 5B |  if_ne	rdlong	local05, local03
08e60     18 AA 86 51 |  if_ne	sub	local03, #24
08e64     57 AD 12 52 |  if_ne	cmp	local04, local05 wc
08e68     50 00 90 4D |  if_c_and_nz	jmp	#LR__1451
08e6c     01 AC 06 F6 | 	mov	local04, #1
08e70     48 00 90 FD | 	jmp	#LR__1451
08e74                 | LR__1450
08e74     54 93 02 F6 | 	mov	arg02, local02
08e78     53 91 02 F6 | 	mov	arg01, local01
08e7c     EC FA BF FD | 	call	#_fatfs_cc_get_fat
08e80     3B AD 02 F6 | 	mov	local04, result1
08e84     02 AC 16 F2 | 	cmp	local04, #2 wc
08e88     01 76 06 C6 |  if_b	mov	result1, #1
08e8c     BC 01 90 CD |  if_b	jmp	#LR__1461
08e90     FF FF 7F FF 
08e94     FF AD 0E F2 | 	cmp	local04, ##-1 wz
08e98     56 77 02 A6 |  if_e	mov	result1, local04
08e9c     AC 01 90 AD |  if_e	jmp	#LR__1461
08ea0     18 AA 06 F1 | 	add	local03, #24
08ea4     55 AF 02 FB | 	rdlong	local05, local03
08ea8     18 AA 86 F1 | 	sub	local03, #24
08eac     57 AD 12 F2 | 	cmp	local04, local05 wc
08eb0     56 77 02 C6 |  if_b	mov	result1, local04
08eb4     94 01 90 CD |  if_b	jmp	#LR__1461
08eb8     54 AD 02 F6 | 	mov	local04, local02
08ebc                 | LR__1451
08ebc     14 AA 06 F1 | 	add	local03, #20
08ec0     55 AF 0A FB | 	rdlong	local05, local03 wz
08ec4     14 AA 86 F1 | 	sub	local03, #20
08ec8     00 76 06 A6 |  if_e	mov	result1, #0
08ecc     7C 01 90 AD |  if_e	jmp	#LR__1461
08ed0     00 B0 06 F6 | 	mov	local06, #0
08ed4     54 AD 0A F2 | 	cmp	local04, local02 wz
08ed8     74 00 90 5D |  if_ne	jmp	#LR__1454
08edc     56 B1 02 F6 | 	mov	local06, local04
08ee0     01 B0 06 F1 | 	add	local06, #1
08ee4     18 AA 06 F1 | 	add	local03, #24
08ee8     55 AF 02 FB | 	rdlong	local05, local03
08eec     18 AA 86 F1 | 	sub	local03, #24
08ef0     57 B1 12 F2 | 	cmp	local06, local05 wc
08ef4     02 B0 06 36 |  if_ae	mov	local06, #2
08ef8     58 93 02 F6 | 	mov	arg02, local06
08efc     53 91 02 F6 | 	mov	arg01, local01
08f00     68 FA BF FD | 	call	#_fatfs_cc_get_fat
08f04     3B AF 02 F6 | 	mov	local05, result1
08f08     01 AE 0E F2 | 	cmp	local05, #1 wz
08f0c     FF FF 7F 5F 
08f10     FF AF 0E 52 |  if_ne	cmp	local05, ##-1 wz
08f14     57 77 02 A6 |  if_e	mov	result1, local05
08f18     30 01 90 AD |  if_e	jmp	#LR__1461
08f1c     00 AE 0E F2 | 	cmp	local05, #0 wz
08f20     2C 00 90 AD |  if_e	jmp	#LR__1453
08f24     10 AA 06 F1 | 	add	local03, #16
08f28     55 B3 02 FB | 	rdlong	local07, local03
08f2c     10 AA 86 F1 | 	sub	local03, #16
08f30     02 B2 16 F2 | 	cmp	local07, #2 wc
08f34     14 00 90 CD |  if_b	jmp	#LR__1452
08f38     18 AA 06 F1 | 	add	local03, #24
08f3c     55 AF 02 FB | 	rdlong	local05, local03
08f40     18 AA 86 F1 | 	sub	local03, #24
08f44     57 B3 12 F2 | 	cmp	local07, local05 wc
08f48     59 AD 02 C6 |  if_b	mov	local04, local07
08f4c                 | LR__1452
08f4c     00 B0 06 F6 | 	mov	local06, #0
08f50                 | LR__1453
08f50                 | LR__1454
08f50     00 B0 0E F2 | 	cmp	local06, #0 wz
08f54     60 00 90 5D |  if_ne	jmp	#LR__1457
08f58     56 B1 02 F6 | 	mov	local06, local04
08f5c                 | ' 			ncl = scl;
08f5c                 | ' 			for (;;) {
08f5c                 | LR__1455
08f5c     01 B0 06 F1 | 	add	local06, #1
08f60     18 AA 06 F1 | 	add	local03, #24
08f64     55 AF 02 FB | 	rdlong	local05, local03
08f68     18 AA 86 F1 | 	sub	local03, #24
08f6c     57 B1 12 F2 | 	cmp	local06, local05 wc
08f70     02 B0 06 36 |  if_ae	mov	local06, #2
08f74     56 B1 1A 32 |  if_ae	cmp	local06, local04 wcz
08f78     00 76 06 16 |  if_a	mov	result1, #0
08f7c     CC 00 90 1D |  if_a	jmp	#LR__1461
08f80     58 93 02 F6 | 	mov	arg02, local06
08f84     53 91 02 F6 | 	mov	arg01, local01
08f88     E0 F9 BF FD | 	call	#_fatfs_cc_get_fat
08f8c     3B B3 0A F6 | 	mov	local07, result1 wz
08f90     24 00 90 AD |  if_e	jmp	#LR__1456
08f94     01 B2 0E F2 | 	cmp	local07, #1 wz
08f98     FF FF 7F 5F 
08f9c     FF B3 0E 52 |  if_ne	cmp	local07, ##-1 wz
08fa0     59 77 02 A6 |  if_e	mov	result1, local07
08fa4     A4 00 90 AD |  if_e	jmp	#LR__1461
08fa8     56 B1 0A F2 | 	cmp	local06, local04 wz
08fac     00 76 06 A6 |  if_e	mov	result1, #0
08fb0     98 00 90 AD |  if_e	jmp	#LR__1461
08fb4     A4 FF 9F FD | 	jmp	#LR__1455
08fb8                 | LR__1456
08fb8                 | LR__1457
08fb8     55 91 02 F6 | 	mov	arg01, local03
08fbc     58 93 02 F6 | 	mov	arg02, local06
08fc0     01 94 66 F6 | 	neg	arg03, #1
08fc4     48 FB BF FD | 	call	#_fatfs_cc_put_fat
08fc8     3B B5 0A F6 | 	mov	local08, result1 wz
08fcc     1C 00 90 5D |  if_ne	jmp	#LR__1458
08fd0     00 A8 0E F2 | 	cmp	local02, #0 wz
08fd4     14 00 90 AD |  if_e	jmp	#LR__1458
08fd8     55 91 02 F6 | 	mov	arg01, local03
08fdc     54 93 02 F6 | 	mov	arg02, local02
08fe0     58 95 02 F6 | 	mov	arg03, local06
08fe4     28 FB BF FD | 	call	#_fatfs_cc_put_fat
08fe8     3B B5 02 F6 | 	mov	local08, result1
08fec                 | LR__1458
08fec     00 B4 0E F2 | 	cmp	local08, #0 wz
08ff0     4C 00 90 5D |  if_ne	jmp	#LR__1459
08ff4     10 AA 06 F1 | 	add	local03, #16
08ff8     55 B1 62 FC | 	wrlong	local06, local03
08ffc     08 AA 06 F1 | 	add	local03, #8
09000     55 AF 02 FB | 	rdlong	local05, local03
09004     02 AE 86 F1 | 	sub	local05, #2
09008     04 AA 86 F1 | 	sub	local03, #4
0900c     55 B7 02 FB | 	rdlong	local09, local03
09010     14 AA 86 F1 | 	sub	local03, #20
09014     57 B7 1A F2 | 	cmp	local09, local05 wcz
09018     14 AA 06 E1 |  if_be	add	local03, #20
0901c     55 B7 02 EB |  if_be	rdlong	local09, local03
09020     01 B6 86 E1 |  if_be	sub	local09, #1
09024     55 B7 62 EC |  if_be	wrlong	local09, local03
09028     14 AA 86 E1 |  if_be	sub	local03, #20
0902c     04 AA 06 F1 | 	add	local03, #4
09030     55 AF C2 FA | 	rdbyte	local05, local03
09034     01 AE 46 F5 | 	or	local05, #1
09038     55 AF 42 FC | 	wrbyte	local05, local03
0903c     08 00 90 FD | 	jmp	#LR__1460
09040                 | LR__1459
09040     01 B4 0E F2 | 	cmp	local08, #1 wz
09044     01 B0 C6 F6 | 	negz	local06, #1
09048                 | LR__1460
09048                 | ' 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
09048                 | ' 	}
09048                 | ' 
09048                 | ' 	return ncl;
09048     58 77 02 F6 | 	mov	result1, local06
0904c                 | LR__1461
0904c     E7 F0 03 F6 | 	mov	ptra, fp
09050     F2 00 A0 FD | 	call	#popregs_
09054                 | _fatfs_cc_create_chain_ret
09054     2D 00 64 FD | 	ret
09058                 | 
09058                 | _fatfs_cc_dir_clear
09058     06 CA 05 F6 | 	mov	COUNT_, #6
0905c     E8 00 A0 FD | 	call	#pushregs_
09060     48 A7 02 F6 | 	mov	local01, arg01
09064     49 A9 02 F6 | 	mov	local02, arg02
09068     53 91 02 F6 | 	mov	arg01, local01
0906c     70 F6 BF FD | 	call	#_fatfs_cc_sync_window
09070     00 76 0E F2 | 	cmp	result1, #0 wz
09074     01 76 06 56 |  if_ne	mov	result1, #1
09078     90 00 90 5D |  if_ne	jmp	#LR__1472
0907c     53 91 02 F6 | 	mov	arg01, local01
09080     54 93 02 F6 | 	mov	arg02, local02
09084     A4 F8 BF FD | 	call	#_fatfs_cc_clst2sect
09088     3B AB 02 F6 | 	mov	local03, result1
0908c     30 A6 06 F1 | 	add	local01, #48
09090     53 AB 62 FC | 	wrlong	local03, local01
09094     04 A6 06 F1 | 	add	local01, #4
09098     53 91 02 F6 | 	mov	arg01, local01
0909c     00 92 06 F6 | 	mov	arg02, #0
090a0     09 94 C6 F9 | 	decod	arg03, #9
090a4     D8 00 A0 FD | 	call	#\builtin_bytefill_
090a8     53 AD 02 F6 | 	mov	local04, local01
090ac                 | ' #line 1667 "ff.c"
090ac                 | ' 	{
090ac                 | ' 		ibuf = fs->win; szb = 1;
090ac                 | ' 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
090ac     00 AE 06 F6 | 	mov	local05, #0
090b0     34 A6 86 F1 | 	sub	local01, #52
090b4                 | LR__1470
090b4     0A A6 06 F1 | 	add	local01, #10
090b8     53 B1 E2 FA | 	rdword	local06, local01
090bc     0A A6 86 F1 | 	sub	local01, #10
090c0     58 AF 12 F2 | 	cmp	local05, local06 wc
090c4     2C 00 90 3D |  if_ae	jmp	#LR__1471
090c8     01 A6 06 F1 | 	add	local01, #1
090cc     53 91 C2 FA | 	rdbyte	arg01, local01
090d0     01 A6 86 F1 | 	sub	local01, #1
090d4     56 93 02 F6 | 	mov	arg02, local04
090d8     55 95 02 F6 | 	mov	arg03, local03
090dc     57 95 02 F1 | 	add	arg03, local05
090e0     01 96 06 F6 | 	mov	arg04, #1
090e4     80 F1 BF FD | 	call	#_fatfs_cc_disk_write
090e8     00 76 0E F2 | 	cmp	result1, #0 wz
090ec     01 AE 06 A1 |  if_e	add	local05, #1
090f0     C0 FF 9F AD |  if_e	jmp	#LR__1470
090f4                 | LR__1471
090f4                 | ' 	}
090f4                 | ' 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
090f4     0A A6 06 F1 | 	add	local01, #10
090f8     53 AD E2 FA | 	rdword	local04, local01
090fc     56 AF 0A F2 | 	cmp	local05, local04 wz
09100     00 B0 06 A6 |  if_e	mov	local06, #0
09104     01 B0 06 56 |  if_ne	mov	local06, #1
09108     58 77 02 F6 | 	mov	result1, local06
0910c                 | LR__1472
0910c     E7 F0 03 F6 | 	mov	ptra, fp
09110     F2 00 A0 FD | 	call	#popregs_
09114                 | _fatfs_cc_dir_clear_ret
09114     2D 00 64 FD | 	ret
09118                 | 
09118                 | _fatfs_cc_dir_sdi
09118     06 CA 05 F6 | 	mov	COUNT_, #6
0911c     E8 00 A0 FD | 	call	#pushregs_
09120     48 A7 02 F6 | 	mov	local01, arg01
09124     49 A9 02 F6 | 	mov	local02, arg02
09128     53 AB 02 FB | 	rdlong	local03, local01
0912c     00 10 00 FF 
09130     00 A8 16 F2 | 	cmp	local02, ##2097152 wc
09134     1F A8 CE C7 |  if_b	test	local02, #31 wz
09138                 | ' 		return FR_INT_ERR;
09138     02 76 06 76 |  if_nc_or_nz	mov	result1, #2
0913c     34 01 90 7D |  if_nc_or_nz	jmp	#LR__1486
09140     10 A6 06 F1 | 	add	local01, #16
09144     53 A9 62 FC | 	wrlong	local02, local01
09148     08 A6 86 F1 | 	sub	local01, #8
0914c     53 AD 0A FB | 	rdlong	local04, local01 wz
09150     08 A6 86 F1 | 	sub	local01, #8
09154     55 AF C2 AA |  if_e	rdbyte	local05, local03
09158     03 AE 16 A2 |  if_e	cmp	local05, #3 wc
0915c     28 AA 06 21 |  if_nc_and_z	add	local03, #40
09160     55 AD 02 2B |  if_nc_and_z	rdlong	local04, local03
09164     28 AA 86 21 |  if_nc_and_z	sub	local03, #40
09168     00 AC 0E F2 | 	cmp	local04, #0 wz
0916c     3C 00 90 5D |  if_ne	jmp	#LR__1480
09170     54 AF 02 F6 | 	mov	local05, local02
09174     05 AE 46 F0 | 	shr	local05, #5
09178     08 AA 06 F1 | 	add	local03, #8
0917c     55 93 E2 FA | 	rdword	arg02, local03
09180     08 AA 86 F1 | 	sub	local03, #8
09184     49 AF 12 F2 | 	cmp	local05, arg02 wc
09188     02 76 06 36 |  if_ae	mov	result1, #2
0918c     E4 00 90 3D |  if_ae	jmp	#LR__1486
09190     28 AA 06 F1 | 	add	local03, #40
09194     55 AF 02 FB | 	rdlong	local05, local03
09198     28 AA 86 F1 | 	sub	local03, #40
0919c     18 A6 06 F1 | 	add	local01, #24
091a0     53 AF 62 FC | 	wrlong	local05, local01
091a4     18 A6 86 F1 | 	sub	local01, #24
091a8     7C 00 90 FD | 	jmp	#LR__1485
091ac                 | LR__1480
091ac     0A AA 06 F1 | 	add	local03, #10
091b0     55 B1 E2 FA | 	rdword	local06, local03
091b4     0A AA 86 F1 | 	sub	local03, #10
091b8     09 B0 66 F0 | 	shl	local06, #9
091bc                 | ' 		csz = (DWORD)fs->csize *  ((UINT) 512 ) ;
091bc                 | ' 		while (ofs >= csz) {
091bc                 | LR__1481
091bc     58 A9 12 F2 | 	cmp	local02, local06 wc
091c0     4C 00 90 CD |  if_b	jmp	#LR__1484
091c4     53 91 02 F6 | 	mov	arg01, local01
091c8     56 93 02 F6 | 	mov	arg02, local04
091cc     9C F7 BF FD | 	call	#_fatfs_cc_get_fat
091d0     3B AD 02 F6 | 	mov	local04, result1
091d4     FF FF 7F FF 
091d8     FF AD 0E F2 | 	cmp	local04, ##-1 wz
091dc     01 76 06 A6 |  if_e	mov	result1, #1
091e0     90 00 90 AD |  if_e	jmp	#LR__1486
091e4     02 AC 16 F2 | 	cmp	local04, #2 wc
091e8     14 00 90 CD |  if_b	jmp	#LR__1482
091ec     18 AA 06 F1 | 	add	local03, #24
091f0     55 AF 02 FB | 	rdlong	local05, local03
091f4     18 AA 86 F1 | 	sub	local03, #24
091f8     57 AD 12 F2 | 	cmp	local04, local05 wc
091fc     08 00 90 CD |  if_b	jmp	#LR__1483
09200                 | LR__1482
09200     02 76 06 F6 | 	mov	result1, #2
09204     6C 00 90 FD | 	jmp	#LR__1486
09208                 | LR__1483
09208     58 A9 82 F1 | 	sub	local02, local06
0920c     AC FF 9F FD | 	jmp	#LR__1481
09210                 | LR__1484
09210     55 91 02 F6 | 	mov	arg01, local03
09214     56 93 02 F6 | 	mov	arg02, local04
09218     10 F7 BF FD | 	call	#_fatfs_cc_clst2sect
0921c     18 A6 06 F1 | 	add	local01, #24
09220     53 77 62 FC | 	wrlong	result1, local01
09224     18 A6 86 F1 | 	sub	local01, #24
09228                 | LR__1485
09228     14 A6 06 F1 | 	add	local01, #20
0922c     53 AD 62 FC | 	wrlong	local04, local01
09230     04 A6 06 F1 | 	add	local01, #4
09234     53 AF 0A FB | 	rdlong	local05, local01 wz
09238     18 A6 86 F1 | 	sub	local01, #24
0923c     02 76 06 A6 |  if_e	mov	result1, #2
09240     30 00 90 AD |  if_e	jmp	#LR__1486
09244     54 B1 02 F6 | 	mov	local06, local02
09248     09 B0 46 F0 | 	shr	local06, #9
0924c     18 A6 06 F1 | 	add	local01, #24
09250     53 AF 02 FB | 	rdlong	local05, local01
09254     58 AF 02 F1 | 	add	local05, local06
09258     53 AF 62 FC | 	wrlong	local05, local01
0925c     34 AA 06 F1 | 	add	local03, #52
09260     FF A9 06 F5 | 	and	local02, #511
09264     54 AB 02 F1 | 	add	local03, local02
09268     04 A6 06 F1 | 	add	local01, #4
0926c     53 AB 62 FC | 	wrlong	local03, local01
09270                 | ' 	dp->sect += ofs /  ((UINT) 512 ) ;
09270                 | ' 	dp->dir = fs->win + (ofs %  ((UINT) 512 ) );
09270                 | ' 
09270                 | ' 	return FR_OK;
09270     00 76 06 F6 | 	mov	result1, #0
09274                 | LR__1486
09274     E7 F0 03 F6 | 	mov	ptra, fp
09278     F2 00 A0 FD | 	call	#popregs_
0927c                 | _fatfs_cc_dir_sdi_ret
0927c     2D 00 64 FD | 	ret
09280                 | 
09280                 | _fatfs_cc_dir_next
09280     05 CA 05 F6 | 	mov	COUNT_, #5
09284     E8 00 A0 FD | 	call	#pushregs_
09288     48 A7 02 F6 | 	mov	local01, arg01
0928c     49 A9 02 F6 | 	mov	local02, arg02
09290     53 AB 02 FB | 	rdlong	local03, local01
09294     10 A6 06 F1 | 	add	local01, #16
09298     53 AD 02 FB | 	rdlong	local04, local01
0929c     10 A6 86 F1 | 	sub	local01, #16
092a0     20 AC 06 F1 | 	add	local04, #32
092a4     00 10 00 FF 
092a8     00 AC 16 F2 | 	cmp	local04, ##2097152 wc
092ac     18 A6 06 31 |  if_ae	add	local01, #24
092b0     53 01 68 3C |  if_ae	wrlong	#0, local01
092b4     18 A6 86 31 |  if_ae	sub	local01, #24
092b8     18 A6 06 F1 | 	add	local01, #24
092bc     53 93 0A FB | 	rdlong	arg02, local01 wz
092c0     18 A6 86 F1 | 	sub	local01, #24
092c4     04 76 06 A6 |  if_e	mov	result1, #4
092c8     64 01 90 AD |  if_e	jmp	#LR__1495
092cc     FF AD CE F7 | 	test	local04, #511 wz
092d0     3C 01 90 5D |  if_ne	jmp	#LR__1494
092d4     18 A6 06 F1 | 	add	local01, #24
092d8     53 93 02 FB | 	rdlong	arg02, local01
092dc     01 92 06 F1 | 	add	arg02, #1
092e0     53 93 62 FC | 	wrlong	arg02, local01
092e4     04 A6 86 F1 | 	sub	local01, #4
092e8     53 93 0A FB | 	rdlong	arg02, local01 wz
092ec     14 A6 86 F1 | 	sub	local01, #20
092f0     2C 00 90 5D |  if_ne	jmp	#LR__1490
092f4     56 93 02 F6 | 	mov	arg02, local04
092f8     05 92 46 F0 | 	shr	arg02, #5
092fc     08 AA 06 F1 | 	add	local03, #8
09300     55 A9 E2 FA | 	rdword	local02, local03
09304     08 AA 86 F1 | 	sub	local03, #8
09308     54 93 12 F2 | 	cmp	arg02, local02 wc
0930c     18 A6 06 31 |  if_ae	add	local01, #24
09310     53 01 68 3C |  if_ae	wrlong	#0, local01
09314                 | ' 				dp->sect = 0; return FR_NO_FILE;
09314     04 76 06 36 |  if_ae	mov	result1, #4
09318     14 01 90 3D |  if_ae	jmp	#LR__1495
0931c     F0 00 90 FD | 	jmp	#LR__1493
09320                 | LR__1490
09320     56 91 02 F6 | 	mov	arg01, local04
09324     09 90 46 F0 | 	shr	arg01, #9
09328     0A AA 06 F1 | 	add	local03, #10
0932c     55 93 E2 FA | 	rdword	arg02, local03
09330     0A AA 86 F1 | 	sub	local03, #10
09334     01 92 86 F1 | 	sub	arg02, #1
09338     49 91 CA F7 | 	test	arg01, arg02 wz
0933c     D0 00 90 5D |  if_ne	jmp	#LR__1492
09340     53 91 02 F6 | 	mov	arg01, local01
09344     14 A6 06 F1 | 	add	local01, #20
09348     53 93 02 FB | 	rdlong	arg02, local01
0934c     14 A6 86 F1 | 	sub	local01, #20
09350     18 F6 BF FD | 	call	#_fatfs_cc_get_fat
09354     3B AF 02 F6 | 	mov	local05, result1
09358     02 AE 16 F2 | 	cmp	local05, #2 wc
0935c     02 76 06 C6 |  if_b	mov	result1, #2
09360     CC 00 90 CD |  if_b	jmp	#LR__1495
09364     FF FF 7F FF 
09368     FF AF 0E F2 | 	cmp	local05, ##-1 wz
0936c     01 76 06 A6 |  if_e	mov	result1, #1
09370     BC 00 90 AD |  if_e	jmp	#LR__1495
09374     18 AA 06 F1 | 	add	local03, #24
09378     55 93 02 FB | 	rdlong	arg02, local03
0937c     18 AA 86 F1 | 	sub	local03, #24
09380     49 AF 12 F2 | 	cmp	local05, arg02 wc
09384     68 00 90 CD |  if_b	jmp	#LR__1491
09388     00 A8 0E F2 | 	cmp	local02, #0 wz
0938c     18 A6 06 A1 |  if_e	add	local01, #24
09390     53 01 68 AC |  if_e	wrlong	#0, local01
09394                 | ' 						dp->sect = 0; return FR_NO_FILE;
09394     04 76 06 A6 |  if_e	mov	result1, #4
09398     94 00 90 AD |  if_e	jmp	#LR__1495
0939c     53 91 02 F6 | 	mov	arg01, local01
093a0     14 A6 06 F1 | 	add	local01, #20
093a4     53 93 02 FB | 	rdlong	arg02, local01
093a8     14 A6 86 F1 | 	sub	local01, #20
093ac     84 FA BF FD | 	call	#_fatfs_cc_create_chain
093b0     3B AF 0A F6 | 	mov	local05, result1 wz
093b4     07 76 06 A6 |  if_e	mov	result1, #7
093b8     74 00 90 AD |  if_e	jmp	#LR__1495
093bc     01 AE 0E F2 | 	cmp	local05, #1 wz
093c0     02 76 06 A6 |  if_e	mov	result1, #2
093c4     68 00 90 AD |  if_e	jmp	#LR__1495
093c8     FF FF 7F FF 
093cc     FF AF 0E F2 | 	cmp	local05, ##-1 wz
093d0     01 76 06 A6 |  if_e	mov	result1, #1
093d4     58 00 90 AD |  if_e	jmp	#LR__1495
093d8     57 93 02 F6 | 	mov	arg02, local05
093dc     55 91 02 F6 | 	mov	arg01, local03
093e0     74 FC BF FD | 	call	#_fatfs_cc_dir_clear
093e4     00 76 0E F2 | 	cmp	result1, #0 wz
093e8     01 76 06 56 |  if_ne	mov	result1, #1
093ec     40 00 90 5D |  if_ne	jmp	#LR__1495
093f0                 | LR__1491
093f0     14 A6 06 F1 | 	add	local01, #20
093f4     53 AF 62 FC | 	wrlong	local05, local01
093f8     55 91 02 F6 | 	mov	arg01, local03
093fc     57 93 02 F6 | 	mov	arg02, local05
09400     28 F5 BF FD | 	call	#_fatfs_cc_clst2sect
09404     04 A6 06 F1 | 	add	local01, #4
09408     53 77 62 FC | 	wrlong	result1, local01
0940c     18 A6 86 F1 | 	sub	local01, #24
09410                 | LR__1492
09410                 | LR__1493
09410                 | LR__1494
09410     10 A6 06 F1 | 	add	local01, #16
09414     53 AD 62 FC | 	wrlong	local04, local01
09418     34 AA 06 F1 | 	add	local03, #52
0941c     FF AD 06 F5 | 	and	local04, #511
09420     56 AB 02 F1 | 	add	local03, local04
09424     0C A6 06 F1 | 	add	local01, #12
09428     53 AB 62 FC | 	wrlong	local03, local01
0942c                 | ' #line 1771 "ff.c"
0942c                 | ' 				}
0942c                 | ' 				dp->clust = clst;
0942c                 | ' 				dp->sect = clst2sect(fs, clst);
0942c                 | ' 			}
0942c                 | ' 		}
0942c                 | ' 	}
0942c                 | ' 	dp->dptr = ofs;
0942c                 | ' 	dp->dir = fs->win + ofs %  ((UINT) 512 ) ;
0942c                 | ' 
0942c                 | ' 	return FR_OK;
0942c     00 76 06 F6 | 	mov	result1, #0
09430                 | LR__1495
09430     E7 F0 03 F6 | 	mov	ptra, fp
09434     F2 00 A0 FD | 	call	#popregs_
09438                 | _fatfs_cc_dir_next_ret
09438     2D 00 64 FD | 	ret
0943c                 | 
0943c                 | _fatfs_cc_dir_alloc
0943c     08 CA 05 F6 | 	mov	COUNT_, #8
09440     E8 00 A0 FD | 	call	#pushregs_
09444     48 A7 02 F6 | 	mov	local01, arg01
09448     49 A9 02 F6 | 	mov	local02, arg02
0944c     53 AB 02 FB | 	rdlong	local03, local01
09450     53 91 02 F6 | 	mov	arg01, local01
09454     00 92 06 F6 | 	mov	arg02, #0
09458     BC FC BF FD | 	call	#_fatfs_cc_dir_sdi
0945c     3B AD 0A F6 | 	mov	local04, result1 wz
09460     70 00 90 5D |  if_ne	jmp	#LR__1504
09464     00 AE 06 F6 | 	mov	local05, #0
09468                 | ' 		n = 0;
09468                 | ' 		do {
09468                 | LR__1500
09468     18 A6 06 F1 | 	add	local01, #24
0946c     53 93 02 FB | 	rdlong	arg02, local01
09470     18 A6 86 F1 | 	sub	local01, #24
09474     55 91 02 F6 | 	mov	arg01, local03
09478     38 F3 BF FD | 	call	#_fatfs_cc_move_window
0947c     3B AD 0A F6 | 	mov	local04, result1 wz
09480     50 00 90 5D |  if_ne	jmp	#LR__1503
09484     1C A6 06 F1 | 	add	local01, #28
09488     53 B1 02 FB | 	rdlong	local06, local01
0948c     1C A6 86 F1 | 	sub	local01, #28
09490     58 B1 C2 FA | 	rdbyte	local06, local06
09494     E5 B0 0E F2 | 	cmp	local06, #229 wz
09498     1C A6 06 51 |  if_ne	add	local01, #28
0949c     53 B3 02 5B |  if_ne	rdlong	local07, local01
094a0     1C A6 86 51 |  if_ne	sub	local01, #28
094a4     59 B5 CA 5A |  if_ne	rdbyte	local08, local07 wz
094a8     10 00 90 5D |  if_ne	jmp	#LR__1501
094ac     01 AE 06 F1 | 	add	local05, #1
094b0     54 AF 0A F2 | 	cmp	local05, local02 wz
094b4     1C 00 90 AD |  if_e	jmp	#LR__1503
094b8     04 00 90 FD | 	jmp	#LR__1502
094bc                 | LR__1501
094bc     00 AE 06 F6 | 	mov	local05, #0
094c0                 | LR__1502
094c0     53 91 02 F6 | 	mov	arg01, local01
094c4     01 92 06 F6 | 	mov	arg02, #1
094c8     B4 FD BF FD | 	call	#_fatfs_cc_dir_next
094cc     3B AD 0A F6 | 	mov	local04, result1 wz
094d0     94 FF 9F AD |  if_e	jmp	#LR__1500
094d4                 | LR__1503
094d4                 | LR__1504
094d4     04 AC 0E F2 | 	cmp	local04, #4 wz
094d8     07 AC 06 A6 |  if_e	mov	local04, #7
094dc                 | ' 	return res;
094dc     56 77 02 F6 | 	mov	result1, local04
094e0     E7 F0 03 F6 | 	mov	ptra, fp
094e4     F2 00 A0 FD | 	call	#popregs_
094e8                 | _fatfs_cc_dir_alloc_ret
094e8     2D 00 64 FD | 	ret
094ec                 | 
094ec                 | _fatfs_cc_ld_clust
094ec     48 7D 02 F6 | 	mov	_var01, arg01
094f0     49 91 02 F6 | 	mov	arg01, arg02
094f4     1A 90 06 F1 | 	add	arg01, #26
094f8                 | ' {
094f8                 | ' 
094f8                 | ' 	return *((WORD*)ptr);
094f8     48 77 E2 FA | 	rdword	result1, arg01
094fc     3B 91 32 F9 | 	getword	arg01, result1, #0
09500     3E 7D C2 FA | 	rdbyte	_var01, _var01
09504     03 7C 0E F2 | 	cmp	_var01, #3 wz
09508     14 92 06 A1 |  if_e	add	arg02, #20
0950c                 | ' {
0950c                 | ' 
0950c                 | ' 	return *((WORD*)ptr);
0950c     49 77 E2 AA |  if_e	rdword	result1, arg02
09510     10 76 66 A0 |  if_e	shl	result1, #16
09514     3B 91 42 A5 |  if_e	or	arg01, result1
09518                 | ' 		cl |= (DWORD)ld_word(dir +  20 ) << 16;
09518                 | ' 	}
09518                 | ' 
09518                 | ' 	return cl;
09518     48 77 02 F6 | 	mov	result1, arg01
0951c                 | _fatfs_cc_ld_clust_ret
0951c     2D 00 64 FD | 	ret
09520                 | 
09520                 | _fatfs_cc_st_clust
09520     48 7D 02 F6 | 	mov	_var01, arg01
09524     49 91 02 F6 | 	mov	arg01, arg02
09528     1A 90 06 F1 | 	add	arg01, #26
0952c     48 95 52 FC | 	wrword	arg03, arg01
09530     3E 7D C2 FA | 	rdbyte	_var01, _var01
09534     03 7C 0E F2 | 	cmp	_var01, #3 wz
09538     14 92 06 A1 |  if_e	add	arg02, #20
0953c     10 94 46 A0 |  if_e	shr	arg03, #16
09540     49 95 52 AC |  if_e	wrword	arg03, arg02
09544                 | _fatfs_cc_st_clust_ret
09544     2D 00 64 FD | 	ret
09548                 | 
09548                 | _fatfs_cc_cmp_lfn
09548     07 CA 05 F6 | 	mov	COUNT_, #7
0954c     E8 00 A0 FD | 	call	#pushregs_
09550     48 A7 02 F6 | 	mov	local01, arg01
09554     49 91 02 F6 | 	mov	arg01, arg02
09558     1A 90 06 F1 | 	add	arg01, #26
0955c                 | ' {
0955c                 | ' 
0955c                 | ' 	return *((WORD*)ptr);
0955c     48 77 EA FA | 	rdword	result1, arg01 wz
09560     00 76 06 56 |  if_ne	mov	result1, #0
09564     D8 00 90 5D |  if_ne	jmp	#LR__1516
09568     49 A9 C2 FA | 	rdbyte	local02, arg02
0956c     3F A8 06 F5 | 	and	local02, #63
09570     01 A8 86 F1 | 	sub	local02, #1
09574     0D A8 06 FD | 	qmul	local02, #13
09578                 | ' 
09578                 | ' 	i = ((dir[ 0 ] & 0x3F) - 1) * 13;
09578                 | ' 
09578                 | ' 	for (wc = 1, s = 0; s < 13; s++) {
09578     01 AA 06 F6 | 	mov	local03, #1
0957c     00 AC 06 F6 | 	mov	local04, #0
09580     18 AE 62 FD | 	getqx	local05
09584                 | LR__1510
09584     0D AC 16 F2 | 	cmp	local04, #13 wc
09588     94 00 90 3D |  if_ae	jmp	#LR__1515
0958c     49 91 02 F6 | 	mov	arg01, arg02
09590     56 A9 02 F6 | 	mov	local02, local04
09594     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
09598     01 00 00 FF 
0959c     AE 77 06 F1 | 	add	result1, ##942
095a0     3B A9 02 F1 | 	add	local02, result1
095a4     54 A9 C2 FA | 	rdbyte	local02, local02
095a8     54 91 02 F1 | 	add	arg01, local02
095ac                 | ' {
095ac                 | ' 
095ac                 | ' 	return *((WORD*)ptr);
095ac     48 77 E2 FA | 	rdword	result1, arg01
095b0     3B B1 02 F6 | 	mov	local06, result1
095b4     55 A9 02 F6 | 	mov	local02, local03
095b8     0F A8 4E F7 | 	zerox	local02, #15 wz
095bc     44 00 90 AD |  if_e	jmp	#LR__1513
095c0     00 AF 16 F2 | 	cmp	local05, #256 wc
095c4     2C 00 90 3D |  if_ae	jmp	#LR__1511
095c8     58 91 32 F9 | 	getword	arg01, local06, #0
095cc     CC E4 BF FD | 	call	#_fatfs_cc_ff_wtoupper
095d0     3B A9 02 F6 | 	mov	local02, result1
095d4     57 AB 02 F6 | 	mov	local03, local05
095d8     01 AA 66 F0 | 	shl	local03, #1
095dc     53 AB 02 F1 | 	add	local03, local01
095e0     55 91 E2 FA | 	rdword	arg01, local03
095e4     01 AE 06 F1 | 	add	local05, #1
095e8     B0 E4 BF FD | 	call	#_fatfs_cc_ff_wtoupper
095ec     3B A9 0A F2 | 	cmp	local02, result1 wz
095f0     08 00 90 AD |  if_e	jmp	#LR__1512
095f4                 | LR__1511
095f4                 | ' 				return 0;
095f4     00 76 06 F6 | 	mov	result1, #0
095f8     44 00 90 FD | 	jmp	#LR__1516
095fc                 | LR__1512
095fc     58 AB 02 F6 | 	mov	local03, local06
09600     14 00 90 FD | 	jmp	#LR__1514
09604                 | LR__1513
09604     58 B1 32 F9 | 	getword	local06, local06, #0
09608     7F 00 00 FF 
0960c     FF B1 0E F2 | 	cmp	local06, ##65535 wz
09610     00 76 06 56 |  if_ne	mov	result1, #0
09614     28 00 90 5D |  if_ne	jmp	#LR__1516
09618                 | LR__1514
09618     01 AC 06 F1 | 	add	local04, #1
0961c     64 FF 9F FD | 	jmp	#LR__1510
09620                 | LR__1515
09620     49 A9 C2 FA | 	rdbyte	local02, arg02
09624     40 A8 CE F7 | 	test	local02, #64 wz
09628     00 AA 0E 52 |  if_ne	cmp	local03, #0 wz
0962c     01 AE 66 50 |  if_ne	shl	local05, #1
09630     53 AF 02 51 |  if_ne	add	local05, local01
09634     57 B3 EA 5A |  if_ne	rdword	local07, local05 wz
09638     00 76 06 56 |  if_ne	mov	result1, #0
0963c                 | ' 
0963c                 | ' 	return 1;
0963c     01 76 06 A6 |  if_e	mov	result1, #1
09640                 | LR__1516
09640     E7 F0 03 F6 | 	mov	ptra, fp
09644     F2 00 A0 FD | 	call	#popregs_
09648                 | _fatfs_cc_cmp_lfn_ret
09648     2D 00 64 FD | 	ret
0964c                 | 
0964c                 | _fatfs_cc_pick_lfn
0964c     48 7D 02 F6 | 	mov	_var01, arg01
09650     49 91 02 F6 | 	mov	arg01, arg02
09654     1A 90 06 F1 | 	add	arg01, #26
09658                 | ' {
09658                 | ' 
09658                 | ' 	return *((WORD*)ptr);
09658     48 77 EA FA | 	rdword	result1, arg01 wz
0965c     00 76 06 56 |  if_ne	mov	result1, #0
09660     CC 00 90 5D |  if_ne	jmp	#LR__1525
09664     49 7F C2 FA | 	rdbyte	_var02, arg02
09668     40 7E 26 F5 | 	andn	_var02, #64
0966c     01 7E 86 F1 | 	sub	_var02, #1
09670     0D 7E 06 FD | 	qmul	_var02, #13
09674                 | ' 
09674                 | ' 	i = ((dir[ 0 ] & ~ 0x40 ) - 1) * 13;
09674                 | ' 
09674                 | ' 	for (wc = 1, s = 0; s < 13; s++) {
09674     01 80 06 F6 | 	mov	_var03, #1
09678     00 82 06 F6 | 	mov	_var04, #0
0967c     18 84 62 FD | 	getqx	_var05
09680                 | LR__1520
09680     0D 82 16 F2 | 	cmp	_var04, #13 wc
09684     78 00 90 3D |  if_ae	jmp	#LR__1523
09688     49 91 02 F6 | 	mov	arg01, arg02
0968c     41 7F 02 F6 | 	mov	_var02, _var04
09690     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
09694     01 00 00 FF 
09698     AE 77 06 F1 | 	add	result1, ##942
0969c     3B 7F 02 F1 | 	add	_var02, result1
096a0     3F 7F C2 FA | 	rdbyte	_var02, _var02
096a4     3F 91 02 F1 | 	add	arg01, _var02
096a8                 | ' {
096a8                 | ' 
096a8                 | ' 	return *((WORD*)ptr);
096a8     48 77 E2 FA | 	rdword	result1, arg01
096ac     3B 87 02 F6 | 	mov	_var06, result1
096b0     40 7F 02 F6 | 	mov	_var02, _var03
096b4     0F 7E 4E F7 | 	zerox	_var02, #15 wz
096b8     28 00 90 AD |  if_e	jmp	#LR__1521
096bc     00 85 16 F2 | 	cmp	_var05, #256 wc
096c0     00 76 06 36 |  if_ae	mov	result1, #0
096c4     68 00 90 3D |  if_ae	jmp	#LR__1525
096c8     42 7F 02 F6 | 	mov	_var02, _var05
096cc     01 7E 66 F0 | 	shl	_var02, #1
096d0     3E 7F 02 F1 | 	add	_var02, _var01
096d4     43 81 02 F6 | 	mov	_var03, _var06
096d8     3F 81 52 FC | 	wrword	_var03, _var02
096dc     01 84 06 F1 | 	add	_var05, #1
096e0     14 00 90 FD | 	jmp	#LR__1522
096e4                 | LR__1521
096e4     43 87 32 F9 | 	getword	_var06, _var06, #0
096e8     7F 00 00 FF 
096ec     FF 87 0E F2 | 	cmp	_var06, ##65535 wz
096f0     00 76 06 56 |  if_ne	mov	result1, #0
096f4     38 00 90 5D |  if_ne	jmp	#LR__1525
096f8                 | LR__1522
096f8     01 82 06 F1 | 	add	_var04, #1
096fc     80 FF 9F FD | 	jmp	#LR__1520
09700                 | LR__1523
09700     49 7F C2 FA | 	rdbyte	_var02, arg02
09704     40 7E CE F7 | 	test	_var02, #64 wz
09708     40 89 02 56 |  if_ne	mov	_var07, _var03
0970c     0F 88 4E 57 |  if_ne	zerox	_var07, #15 wz
09710     18 00 90 AD |  if_e	jmp	#LR__1524
09714     00 85 16 F2 | 	cmp	_var05, #256 wc
09718     00 76 06 36 |  if_ae	mov	result1, #0
0971c     10 00 90 3D |  if_ae	jmp	#LR__1525
09720     01 84 66 F0 | 	shl	_var05, #1
09724     3E 85 02 F1 | 	add	_var05, _var01
09728     42 01 58 FC | 	wrword	#0, _var05
0972c                 | LR__1524
0972c                 | ' 		lfnbuf[i] = 0;
0972c                 | ' 	}
0972c                 | ' 
0972c                 | ' 	return 1;
0972c     01 76 06 F6 | 	mov	result1, #1
09730                 | LR__1525
09730                 | _fatfs_cc_pick_lfn_ret
09730     2D 00 64 FD | 	ret
09734                 | 
09734                 | _fatfs_cc_put_lfn
09734     49 7D 02 F6 | 	mov	_var01, arg02
09738     0D 7C 06 F1 | 	add	_var01, #13
0973c     3E 97 42 FC | 	wrbyte	arg04, _var01
09740     4A 97 E2 F8 | 	getbyte	arg04, arg03, #0
09744     01 96 86 F1 | 	sub	arg04, #1
09748     0D 96 06 FD | 	qmul	arg04, #13
0974c     48 7F 02 F6 | 	mov	_var02, arg01
09750     02 7C 86 F1 | 	sub	_var01, #2
09754     3E 1F 48 FC | 	wrbyte	#15, _var01
09758     01 7C 06 F1 | 	add	_var01, #1
0975c     3E 01 48 FC | 	wrbyte	#0, _var01
09760     0C 7C 86 F1 | 	sub	_var01, #12
09764     3E 91 02 F6 | 	mov	arg01, _var01
09768     1A 90 06 F1 | 	add	arg01, #26
0976c     48 01 58 FC | 	wrword	#0, arg01
09770     00 80 06 F6 | 	mov	_var03, #0
09774     00 82 06 F6 | 	mov	_var04, #0
09778                 | ' 	BYTE* dir,
09778                 | ' 	BYTE ord,
09778                 | ' 	BYTE sum
09778                 | ' )
09778                 | ' {
09778                 | ' 	UINT i, s;
09778                 | ' 	WCHAR wc;
09778                 | ' 
09778                 | ' 
09778                 | ' 	dir[ 13 ] = sum;
09778                 | ' 	dir[ 11 ] =  0x0F ;
09778                 | ' 	dir[ 12 ] = 0;
09778                 | ' 	st_word(dir +  26 , 0);
09778                 | ' 
09778                 | ' 	i = (ord - 1) * 13;
09778                 | ' 	s = wc = 0;
09778                 | ' 	do {
09778     18 84 62 FD | 	getqx	_var05
0977c     D7 2E 48 FB | 	callpa	#(@LR__1531-@LR__1530)>>2,fcache_load_ptr_
09780                 | LR__1530
09780     40 97 32 F9 | 	getword	arg04, _var03, #0
09784     7F 00 00 FF 
09788     FF 97 0E F2 | 	cmp	arg04, ##65535 wz
0978c     42 91 02 56 |  if_ne	mov	arg01, _var05
09790     01 84 06 51 |  if_ne	add	_var05, #1
09794     01 90 66 50 |  if_ne	shl	arg01, #1
09798     3F 91 02 51 |  if_ne	add	arg01, _var02
0979c     48 81 E2 5A |  if_ne	rdword	_var03, arg01
097a0     3E 91 02 F6 | 	mov	arg01, _var01
097a4     41 97 02 F6 | 	mov	arg04, _var04
097a8     35 93 02 F6 | 	mov	arg02, ptr__fatfs_cc_dat__
097ac     01 00 00 FF 
097b0     AE 93 06 F1 | 	add	arg02, ##942
097b4     49 97 02 F1 | 	add	arg04, arg02
097b8     4B 97 C2 FA | 	rdbyte	arg04, arg04
097bc     4B 91 02 F1 | 	add	arg01, arg04
097c0     48 81 52 FC | 	wrword	_var03, arg01
097c4     40 97 02 F6 | 	mov	arg04, _var03
097c8     0F 96 4E F7 | 	zerox	arg04, #15 wz
097cc     0F 80 CE A9 |  if_e	bmask	_var03, #15
097d0     01 82 06 F1 | 	add	_var04, #1
097d4     0D 82 16 F2 | 	cmp	_var04, #13 wc
097d8     A4 FF 9F CD |  if_b	jmp	#LR__1530
097dc                 | LR__1531
097dc     40 81 32 F9 | 	getword	_var03, _var03, #0
097e0     7F 00 00 FF 
097e4     FF 81 0E F2 | 	cmp	_var03, ##65535 wz
097e8     01 84 66 50 |  if_ne	shl	_var05, #1
097ec     3F 85 02 51 |  if_ne	add	_var05, _var02
097f0     42 85 EA 5A |  if_ne	rdword	_var05, _var05 wz
097f4     4A 95 E2 A8 |  if_e	getbyte	arg03, arg03, #0
097f8     40 94 46 A5 |  if_e	or	arg03, #64
097fc     3E 95 42 FC | 	wrbyte	arg03, _var01
09800                 | _fatfs_cc_put_lfn_ret
09800     2D 00 64 FD | 	ret
09804                 | 
09804                 | _fatfs_cc_gen_numname
09804     08 CA 05 F6 | 	mov	COUNT_, #8
09808     E8 00 A0 FD | 	call	#pushregs_
0980c     2C F0 07 F1 | 	add	ptra, #44
09810     48 A7 02 F6 | 	mov	local01, arg01
09814     49 A9 02 F6 | 	mov	local02, arg02
09818     4A AB 02 F6 | 	mov	local03, arg03
0981c     4B AD 02 F6 | 	mov	local04, arg04
09820     53 91 02 F6 | 	mov	arg01, local01
09824     54 93 02 F6 | 	mov	arg02, local02
09828     0B 94 06 F6 | 	mov	arg03, #11
0982c     8C 98 BF FD | 	call	#__system____builtin_memmove
09830     06 AC 16 F2 | 	cmp	local04, #6 wc
09834     48 00 90 CD |  if_b	jmp	#LR__1545
09838     56 AF 02 F6 | 	mov	local05, local04
0983c     D7 1E 48 FB | 	callpa	#(@LR__1543-@LR__1540)>>2,fcache_load_ptr_
09840                 | ' 		sreg = seq;
09840                 | ' 		while (*lfn) {
09840                 | LR__1540
09840     55 B1 EA FA | 	rdword	local06, local03 wz
09844     34 00 90 AD |  if_e	jmp	#LR__1544
09848     55 B3 E2 FA | 	rdword	local07, local03
0984c                 | ' 			wc = *lfn++;
0984c                 | ' 			for (i = 0; i < 16; i++) {
0984c     02 AA 06 F1 | 	add	local03, #2
09850     10 12 DC FC | 	rep	@LR__1542, #16
09854                 | LR__1541
09854     01 AE 66 F0 | 	shl	local05, #1
09858     59 B1 32 F9 | 	getword	local06, local07, #0
0985c     01 B0 06 F5 | 	and	local06, #1
09860     58 AF 02 F1 | 	add	local05, local06
09864     59 B3 32 F9 | 	getword	local07, local07, #0
09868     01 B2 46 F0 | 	shr	local07, #1
0986c     10 AE 2E F4 | 	testbn	local05, #16 wz
09870     88 00 00 5F 
09874     21 AE 66 55 |  if_ne	xor	local05, ##69665
09878                 | LR__1542
09878     C4 FF 9F FD | 	jmp	#LR__1540
0987c                 | LR__1543
0987c                 | LR__1544
0987c     57 AD 02 F6 | 	mov	local04, local05
09880                 | LR__1545
09880     07 B2 06 F6 | 	mov	local07, #7
09884     D7 1E 48 FB | 	callpa	#(@LR__1547-@LR__1546)>>2,fcache_load_ptr_
09888                 | ' 			}
09888                 | ' 		}
09888                 | ' 		seq = (UINT)sreg;
09888                 | ' 	}
09888                 | ' 
09888                 | ' 
09888                 | ' 	i = 7;
09888                 | ' 	do {
09888                 | LR__1546
09888     56 AF 42 F8 | 	getnib	local05, local04, #0
0988c     30 AE 06 F1 | 	add	local05, #48
09890     04 AC 46 F0 | 	shr	local04, #4
09894     57 B1 E2 F8 | 	getbyte	local06, local05, #0
09898     3A B0 16 F2 | 	cmp	local06, #58 wc
0989c     57 AF E2 38 |  if_ae	getbyte	local05, local05, #0
098a0     07 AE 06 31 |  if_ae	add	local05, #7
098a4     59 B1 02 F6 | 	mov	local06, local07
098a8     01 B2 8E F1 | 	sub	local07, #1 wz
098ac     E7 AA 02 F6 | 	mov	local03, fp
098b0     10 AA 06 F1 | 	add	local03, #16
098b4     55 B1 02 F1 | 	add	local06, local03
098b8     58 AF 42 FC | 	wrbyte	local05, local06
098bc     00 AC 0E 52 |  if_ne	cmp	local04, #0 wz
098c0     C4 FF 9F 5D |  if_ne	jmp	#LR__1546
098c4                 | LR__1547
098c4     59 B1 02 F6 | 	mov	local06, local07
098c8     E7 AE 02 F6 | 	mov	local05, fp
098cc     10 AE 06 F1 | 	add	local05, #16
098d0     57 B1 02 F1 | 	add	local06, local05
098d4     58 FD 48 FC | 	wrbyte	#126, local06
098d8                 | ' 	ns[i] = '~';
098d8                 | ' 
098d8                 | ' 
098d8                 | ' 	for (j = 0; j < i && dst[j] != ' '; j++) {
098d8     00 AC 06 F6 | 	mov	local04, #0
098dc     D7 2A 48 FB | 	callpa	#(@LR__1550-@LR__1548)>>2,fcache_load_ptr_
098e0                 | LR__1548
098e0     59 AD 12 F2 | 	cmp	local04, local07 wc
098e4     4C 00 90 3D |  if_ae	jmp	#LR__1551
098e8     56 AF 02 F6 | 	mov	local05, local04
098ec     53 AF 02 F1 | 	add	local05, local01
098f0     57 B1 C2 FA | 	rdbyte	local06, local05
098f4     20 B0 0E F2 | 	cmp	local06, #32 wz
098f8     38 00 90 AD |  if_e	jmp	#LR__1551
098fc     56 AB 02 F6 | 	mov	local03, local04
09900     53 AB 02 F1 | 	add	local03, local01
09904     55 91 CA FA | 	rdbyte	arg01, local03 wz
09908     00 76 06 56 |  if_ne	mov	result1, #0
0990c                 | ' 
0990c                 | ' 	return 0;
0990c     00 76 06 A6 |  if_e	mov	result1, #0
09910     00 76 0E F2 | 	cmp	result1, #0 wz
09914     14 00 90 AD |  if_e	jmp	#LR__1549
09918     59 AB 02 F6 | 	mov	local03, local07
0991c     01 AA 86 F1 | 	sub	local03, #1
09920     55 AD 0A F2 | 	cmp	local04, local03 wz
09924     0C 00 90 AD |  if_e	jmp	#LR__1551
09928     01 AC 06 F1 | 	add	local04, #1
0992c                 | LR__1549
0992c     01 AC 06 F1 | 	add	local04, #1
09930     AC FF 9F FD | 	jmp	#LR__1548
09934                 | LR__1550
09934                 | LR__1551
09934     D7 20 48 FB | 	callpa	#(@LR__1555-@LR__1552)>>2,fcache_load_ptr_
09938                 | ' 			j++;
09938                 | ' 		}
09938                 | ' 	}
09938                 | ' 	do {
09938                 | LR__1552
09938     56 B1 02 F6 | 	mov	local06, local04
0993c     53 B1 02 F1 | 	add	local06, local01
09940     08 B2 16 F2 | 	cmp	local07, #8 wc
09944     01 AC 06 F1 | 	add	local04, #1
09948     1C 00 90 3D |  if_ae	jmp	#LR__1553
0994c     59 AF 02 F6 | 	mov	local05, local07
09950     E7 AA 02 F6 | 	mov	local03, fp
09954     10 AA 06 F1 | 	add	local03, #16
09958     55 AF 02 F1 | 	add	local05, local03
0995c     57 B5 C2 FA | 	rdbyte	local08, local05
09960     01 B2 06 F1 | 	add	local07, #1
09964     04 00 90 FD | 	jmp	#LR__1554
09968                 | LR__1553
09968     20 B4 06 F6 | 	mov	local08, #32
0996c                 | LR__1554
0996c     58 B5 42 FC | 	wrbyte	local08, local06
09970     08 AC 16 F2 | 	cmp	local04, #8 wc
09974     C0 FF 9F CD |  if_b	jmp	#LR__1552
09978                 | LR__1555
09978     E7 F0 03 F6 | 	mov	ptra, fp
0997c     F2 00 A0 FD | 	call	#popregs_
09980                 | _fatfs_cc_gen_numname_ret
09980     2D 00 64 FD | 	ret
09984                 | 
09984                 | _fatfs_cc_sum_sfn
09984     00 7C 06 F6 | 	mov	_var01, #0
09988                 | ' )
09988                 | ' {
09988                 | ' 	BYTE sum = 0;
09988                 | ' 	UINT n = 11;
09988                 | ' 
09988                 | ' 	do {
09988     D7 12 48 FB | 	callpa	#(@LR__1562-@LR__1560)>>2,fcache_load_ptr_
0998c                 | LR__1560
0998c     0B 10 DC FC | 	rep	@LR__1563, #11
09990                 | LR__1561
09990     3E 77 E2 F8 | 	getbyte	result1, _var01, #0
09994     01 76 46 F0 | 	shr	result1, #1
09998     3E 7D E2 F8 | 	getbyte	_var01, _var01, #0
0999c     07 7C 66 F0 | 	shl	_var01, #7
099a0     3E 77 02 F1 | 	add	result1, _var01
099a4     48 7D C2 FA | 	rdbyte	_var01, arg01
099a8     3B 7D 02 F1 | 	add	_var01, result1
099ac     01 90 06 F1 | 	add	arg01, #1
099b0                 | LR__1562
099b0                 | LR__1563
099b0                 | ' 	return sum;
099b0     3E 77 02 F6 | 	mov	result1, _var01
099b4                 | _fatfs_cc_sum_sfn_ret
099b4     2D 00 64 FD | 	ret
099b8                 | 
099b8                 | _fatfs_cc_dir_read
099b8     0C CA 05 F6 | 	mov	COUNT_, #12
099bc     E8 00 A0 FD | 	call	#pushregs_
099c0     48 A7 02 F6 | 	mov	local01, arg01
099c4     49 A9 02 F6 | 	mov	local02, arg02
099c8     04 AA 06 F6 | 	mov	local03, #4
099cc     53 AD 02 FB | 	rdlong	local04, local01
099d0     FF AE 06 F6 | 	mov	local05, #255
099d4     FF B0 06 F6 | 	mov	local06, #255
099d8                 | ' )
099d8                 | ' {
099d8                 | ' 	FRESULT res = FR_NO_FILE;
099d8                 | ' 	FATFS *fs = dp->obj.fs;
099d8                 | ' 	BYTE attr, b;
099d8                 | ' 
099d8                 | ' 	BYTE ord = 0xFF, sum = 0xFF;
099d8                 | ' 
099d8                 | ' 
099d8                 | ' 	while (dp->sect) {
099d8                 | LR__1570
099d8     18 A6 06 F1 | 	add	local01, #24
099dc     53 77 0A FB | 	rdlong	result1, local01 wz
099e0     18 A6 86 F1 | 	sub	local01, #24
099e4     AC 01 90 AD |  if_e	jmp	#LR__1580
099e8     18 A6 06 F1 | 	add	local01, #24
099ec     53 93 02 FB | 	rdlong	arg02, local01
099f0     18 A6 86 F1 | 	sub	local01, #24
099f4     56 91 02 F6 | 	mov	arg01, local04
099f8     B8 ED BF FD | 	call	#_fatfs_cc_move_window
099fc     3B AB 0A F6 | 	mov	local03, result1 wz
09a00     90 01 90 5D |  if_ne	jmp	#LR__1580
09a04     1C A6 06 F1 | 	add	local01, #28
09a08     53 77 02 FB | 	rdlong	result1, local01
09a0c     1C A6 86 F1 | 	sub	local01, #28
09a10     3B B3 C2 FA | 	rdbyte	local07, result1
09a14     59 77 02 F6 | 	mov	result1, local07
09a18     07 76 4E F7 | 	zerox	result1, #7 wz
09a1c     04 AA 06 A6 |  if_e	mov	local03, #4
09a20                 | ' 			res = FR_NO_FILE; break;
09a20     70 01 90 AD |  if_e	jmp	#LR__1580
09a24     1C A6 06 F1 | 	add	local01, #28
09a28     53 B5 02 FB | 	rdlong	local08, local01
09a2c     0B B4 06 F1 | 	add	local08, #11
09a30     5A B7 C2 FA | 	rdbyte	local09, local08
09a34     3F B6 06 F5 | 	and	local09, #63
09a38     16 A6 86 F1 | 	sub	local01, #22
09a3c     53 B7 42 FC | 	wrbyte	local09, local01
09a40     06 A6 86 F1 | 	sub	local01, #6
09a44     59 77 E2 F8 | 	getbyte	result1, local07, #0
09a48     E5 76 0E F2 | 	cmp	result1, #229 wz
09a4c     59 B5 02 56 |  if_ne	mov	local08, local07
09a50     5A B5 E2 58 |  if_ne	getbyte	local08, local08, #0
09a54     2E B4 0E 52 |  if_ne	cmp	local08, #46 wz
09a58     1C 00 90 AD |  if_e	jmp	#LR__1571
09a5c     00 B8 06 F6 | 	mov	local10, #0
09a60     5B B5 E2 F8 | 	getbyte	local08, local09, #0
09a64     20 B4 26 F5 | 	andn	local08, #32
09a68     08 B4 0E F2 | 	cmp	local08, #8 wz
09a6c     01 B8 06 A6 |  if_e	mov	local10, #1
09a70     54 B9 0A F2 | 	cmp	local10, local02 wz
09a74     08 00 90 AD |  if_e	jmp	#LR__1572
09a78                 | LR__1571
09a78     FF AE 06 F6 | 	mov	local05, #255
09a7c     00 01 90 FD | 	jmp	#LR__1579
09a80                 | LR__1572
09a80     5B B7 E2 F8 | 	getbyte	local09, local09, #0
09a84     0F B6 0E F2 | 	cmp	local09, #15 wz
09a88     B4 00 90 5D |  if_ne	jmp	#LR__1576
09a8c     59 BB E2 F8 | 	getbyte	local11, local07, #0
09a90     40 BA CE F7 | 	test	local11, #64 wz
09a94     30 00 90 AD |  if_e	jmp	#LR__1573
09a98     1C A6 06 F1 | 	add	local01, #28
09a9c     53 BB 02 FB | 	rdlong	local11, local01
09aa0     0D BA 06 F1 | 	add	local11, #13
09aa4     5D B1 C2 FA | 	rdbyte	local06, local11
09aa8     59 B3 E2 F8 | 	getbyte	local07, local07, #0
09aac     BF B2 06 F5 | 	and	local07, #191
09ab0     59 AF 02 F6 | 	mov	local05, local07
09ab4     0C A6 86 F1 | 	sub	local01, #12
09ab8     53 BB 02 FB | 	rdlong	local11, local01
09abc     1C A6 06 F1 | 	add	local01, #28
09ac0     53 BB 62 FC | 	wrlong	local11, local01
09ac4     2C A6 86 F1 | 	sub	local01, #44
09ac8                 | LR__1573
09ac8     59 B5 E2 F8 | 	getbyte	local08, local07, #0
09acc     57 B9 E2 F8 | 	getbyte	local10, local05, #0
09ad0     5C B5 0A F2 | 	cmp	local08, local10 wz
09ad4     5C 00 90 5D |  if_ne	jmp	#LR__1574
09ad8     58 B9 E2 F8 | 	getbyte	local10, local06, #0
09adc     1C A6 06 F1 | 	add	local01, #28
09ae0     53 B7 02 FB | 	rdlong	local09, local01
09ae4     1C A6 86 F1 | 	sub	local01, #28
09ae8     0D B6 06 F1 | 	add	local09, #13
09aec     5B B5 C2 FA | 	rdbyte	local08, local09
09af0     5A B7 E2 F8 | 	getbyte	local09, local08, #0
09af4     5B B9 0A F2 | 	cmp	local10, local09 wz
09af8     38 00 90 5D |  if_ne	jmp	#LR__1574
09afc     0C AC 06 F1 | 	add	local04, #12
09b00     56 91 02 FB | 	rdlong	arg01, local04
09b04     0C AC 86 F1 | 	sub	local04, #12
09b08     1C A6 06 F1 | 	add	local01, #28
09b0c     53 BD 02 FB | 	rdlong	local12, local01
09b10     1C A6 86 F1 | 	sub	local01, #28
09b14     5E 93 02 F6 | 	mov	arg02, local12
09b18     30 FB BF FD | 	call	#_fatfs_cc_pick_lfn
09b1c     00 76 4E F2 | 	cmps	result1, #0 wz
09b20     57 BD 02 56 |  if_ne	mov	local12, local05
09b24     5E BD E2 58 |  if_ne	getbyte	local12, local12, #0
09b28     01 BC 86 51 |  if_ne	sub	local12, #1
09b2c     5E BB 02 56 |  if_ne	mov	local11, local12
09b30     04 00 90 5D |  if_ne	jmp	#LR__1575
09b34                 | LR__1574
09b34     FF BA 06 F6 | 	mov	local11, #255
09b38                 | LR__1575
09b38     5D AF 02 F6 | 	mov	local05, local11
09b3c     40 00 90 FD | 	jmp	#LR__1578
09b40                 | LR__1576
09b40     57 BB 02 F6 | 	mov	local11, local05
09b44     07 BA 4E F7 | 	zerox	local11, #7 wz
09b48     20 00 90 5D |  if_ne	jmp	#LR__1577
09b4c     58 B1 E2 F8 | 	getbyte	local06, local06, #0
09b50     1C A6 06 F1 | 	add	local01, #28
09b54     53 91 02 FB | 	rdlong	arg01, local01
09b58     1C A6 86 F1 | 	sub	local01, #28
09b5c     24 FE BF FD | 	call	#_fatfs_cc_sum_sfn
09b60     3B 77 E2 F8 | 	getbyte	result1, result1, #0
09b64     3B B1 0A F2 | 	cmp	local06, result1 wz
09b68     28 00 90 AD |  if_e	jmp	#LR__1580
09b6c                 | LR__1577
09b6c     2C A6 06 F1 | 	add	local01, #44
09b70     FF FF FF FF 
09b74     53 FF 6B FC | 	wrlong	##-1, local01
09b78     2C A6 86 F1 | 	sub	local01, #44
09b7c                 | ' 						dp->blk_ofs = 0xFFFFFFFF;
09b7c                 | ' 					}
09b7c                 | ' 					break;
09b7c     14 00 90 FD | 	jmp	#LR__1580
09b80                 | LR__1578
09b80                 | LR__1579
09b80     53 91 02 F6 | 	mov	arg01, local01
09b84     00 92 06 F6 | 	mov	arg02, #0
09b88     F4 F6 BF FD | 	call	#_fatfs_cc_dir_next
09b8c     3B AB 0A F6 | 	mov	local03, result1 wz
09b90     44 FE 9F AD |  if_e	jmp	#LR__1570
09b94                 | LR__1580
09b94     00 AA 0E F2 | 	cmp	local03, #0 wz
09b98     18 A6 06 51 |  if_ne	add	local01, #24
09b9c     53 01 68 5C |  if_ne	wrlong	#0, local01
09ba0                 | ' 	return res;
09ba0     55 77 02 F6 | 	mov	result1, local03
09ba4     E7 F0 03 F6 | 	mov	ptra, fp
09ba8     F2 00 A0 FD | 	call	#popregs_
09bac                 | _fatfs_cc_dir_read_ret
09bac     2D 00 64 FD | 	ret
09bb0                 | 
09bb0                 | _fatfs_cc_dir_find
09bb0     0B CA 05 F6 | 	mov	COUNT_, #11
09bb4     E8 00 A0 FD | 	call	#pushregs_
09bb8     48 A7 02 F6 | 	mov	local01, arg01
09bbc     53 A9 02 FB | 	rdlong	local02, local01
09bc0     53 91 02 F6 | 	mov	arg01, local01
09bc4     00 92 06 F6 | 	mov	arg02, #0
09bc8     4C F5 BF FD | 	call	#_fatfs_cc_dir_sdi
09bcc     00 76 0E F2 | 	cmp	result1, #0 wz
09bd0     18 02 90 5D |  if_ne	jmp	#LR__1602
09bd4     FF AA 06 F6 | 	mov	local03, #255
09bd8     FF AC 06 F6 | 	mov	local04, #255
09bdc     2C A6 06 F1 | 	add	local01, #44
09be0     FF FF FF FF 
09be4     53 FF 6B FC | 	wrlong	##-1, local01
09be8     2C A6 86 F1 | 	sub	local01, #44
09bec                 | ' #line 2404 "ff.c"
09bec                 | ' 	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;
09bec                 | ' 
09bec                 | ' 	do {
09bec                 | LR__1590
09bec     18 A6 06 F1 | 	add	local01, #24
09bf0     53 93 02 FB | 	rdlong	arg02, local01
09bf4     18 A6 86 F1 | 	sub	local01, #24
09bf8     54 91 02 F6 | 	mov	arg01, local02
09bfc     B4 EB BF FD | 	call	#_fatfs_cc_move_window
09c00     3B AF 0A F6 | 	mov	local05, result1 wz
09c04     E0 01 90 5D |  if_ne	jmp	#LR__1601
09c08     1C A6 06 F1 | 	add	local01, #28
09c0c     53 95 02 FB | 	rdlong	arg03, local01
09c10     1C A6 86 F1 | 	sub	local01, #28
09c14     4A B1 C2 FA | 	rdbyte	local06, arg03
09c18     58 95 02 F6 | 	mov	arg03, local06
09c1c     07 94 4E F7 | 	zerox	arg03, #7 wz
09c20     04 AE 06 A6 |  if_e	mov	local05, #4
09c24     C0 01 90 AD |  if_e	jmp	#LR__1601
09c28     1C A6 06 F1 | 	add	local01, #28
09c2c     53 B3 02 FB | 	rdlong	local07, local01
09c30     59 95 02 F6 | 	mov	arg03, local07
09c34     0B 94 06 F1 | 	add	arg03, #11
09c38     4A B5 C2 FA | 	rdbyte	local08, arg03
09c3c     3F B4 06 F5 | 	and	local08, #63
09c40     16 A6 86 F1 | 	sub	local01, #22
09c44     53 B5 42 FC | 	wrbyte	local08, local01
09c48     06 A6 86 F1 | 	sub	local01, #6
09c4c     58 95 E2 F8 | 	getbyte	arg03, local06, #0
09c50     E5 94 0E F2 | 	cmp	arg03, #229 wz
09c54     18 00 90 AD |  if_e	jmp	#LR__1591
09c58     5A 95 E2 F8 | 	getbyte	arg03, local08, #0
09c5c     08 94 CE F7 | 	test	arg03, #8 wz
09c60     5A B3 02 56 |  if_ne	mov	local07, local08
09c64     59 B3 E2 58 |  if_ne	getbyte	local07, local07, #0
09c68     0F B2 0E 52 |  if_ne	cmp	local07, #15 wz
09c6c     18 00 90 AD |  if_e	jmp	#LR__1592
09c70                 | LR__1591
09c70     FF AC 06 F6 | 	mov	local04, #255
09c74     2C A6 06 F1 | 	add	local01, #44
09c78     FF FF FF FF 
09c7c     53 FF 6B FC | 	wrlong	##-1, local01
09c80     2C A6 86 F1 | 	sub	local01, #44
09c84     4C 01 90 FD | 	jmp	#LR__1600
09c88                 | LR__1592
09c88     5A B5 E2 F8 | 	getbyte	local08, local08, #0
09c8c     0F B4 0E F2 | 	cmp	local08, #15 wz
09c90     C8 00 90 5D |  if_ne	jmp	#LR__1596
09c94     2B A6 06 F1 | 	add	local01, #43
09c98     53 B5 C2 FA | 	rdbyte	local08, local01
09c9c     2B A6 86 F1 | 	sub	local01, #43
09ca0     40 B4 CE F7 | 	test	local08, #64 wz
09ca4     2C 01 90 5D |  if_ne	jmp	#LR__1599
09ca8     58 B7 E2 F8 | 	getbyte	local09, local06, #0
09cac     40 B6 CE F7 | 	test	local09, #64 wz
09cb0     30 00 90 AD |  if_e	jmp	#LR__1593
09cb4     1C A6 06 F1 | 	add	local01, #28
09cb8     53 B7 02 FB | 	rdlong	local09, local01
09cbc     0D B6 06 F1 | 	add	local09, #13
09cc0     5B AB C2 FA | 	rdbyte	local03, local09
09cc4     58 B1 E2 F8 | 	getbyte	local06, local06, #0
09cc8     BF B0 06 F5 | 	and	local06, #191
09ccc     58 AD 02 F6 | 	mov	local04, local06
09cd0     0C A6 86 F1 | 	sub	local01, #12
09cd4     53 B7 02 FB | 	rdlong	local09, local01
09cd8     1C A6 06 F1 | 	add	local01, #28
09cdc     53 B7 62 FC | 	wrlong	local09, local01
09ce0     2C A6 86 F1 | 	sub	local01, #44
09ce4                 | LR__1593
09ce4     58 B9 E2 F8 | 	getbyte	local10, local06, #0
09ce8     56 B3 E2 F8 | 	getbyte	local07, local04, #0
09cec     59 B9 0A F2 | 	cmp	local10, local07 wz
09cf0     5C 00 90 5D |  if_ne	jmp	#LR__1594
09cf4     55 B5 E2 F8 | 	getbyte	local08, local03, #0
09cf8     1C A6 06 F1 | 	add	local01, #28
09cfc     53 B3 02 FB | 	rdlong	local07, local01
09d00     1C A6 86 F1 | 	sub	local01, #28
09d04     0D B2 06 F1 | 	add	local07, #13
09d08     59 B1 C2 FA | 	rdbyte	local06, local07
09d0c     58 B3 E2 F8 | 	getbyte	local07, local06, #0
09d10     59 B5 0A F2 | 	cmp	local08, local07 wz
09d14     38 00 90 5D |  if_ne	jmp	#LR__1594
09d18     0C A8 06 F1 | 	add	local02, #12
09d1c     54 91 02 FB | 	rdlong	arg01, local02
09d20     0C A8 86 F1 | 	sub	local02, #12
09d24     1C A6 06 F1 | 	add	local01, #28
09d28     53 BB 02 FB | 	rdlong	local11, local01
09d2c     1C A6 86 F1 | 	sub	local01, #28
09d30     5D 93 02 F6 | 	mov	arg02, local11
09d34     10 F8 BF FD | 	call	#_fatfs_cc_cmp_lfn
09d38     00 76 4E F2 | 	cmps	result1, #0 wz
09d3c     56 BB 02 56 |  if_ne	mov	local11, local04
09d40     5D BB E2 58 |  if_ne	getbyte	local11, local11, #0
09d44     01 BA 86 51 |  if_ne	sub	local11, #1
09d48     5D B7 02 56 |  if_ne	mov	local09, local11
09d4c     04 00 90 5D |  if_ne	jmp	#LR__1595
09d50                 | LR__1594
09d50     FF B6 06 F6 | 	mov	local09, #255
09d54                 | LR__1595
09d54     5B AD 02 F6 | 	mov	local04, local09
09d58     78 00 90 FD | 	jmp	#LR__1599
09d5c                 | LR__1596
09d5c     56 B7 02 F6 | 	mov	local09, local04
09d60     07 B6 4E F7 | 	zerox	local09, #7 wz
09d64     20 00 90 5D |  if_ne	jmp	#LR__1597
09d68     55 B9 E2 F8 | 	getbyte	local10, local03, #0
09d6c     1C A6 06 F1 | 	add	local01, #28
09d70     53 91 02 FB | 	rdlong	arg01, local01
09d74     1C A6 86 F1 | 	sub	local01, #28
09d78     08 FC BF FD | 	call	#_fatfs_cc_sum_sfn
09d7c     3B 77 E2 F8 | 	getbyte	result1, result1, #0
09d80     3B B9 0A F2 | 	cmp	local10, result1 wz
09d84     60 00 90 AD |  if_e	jmp	#LR__1601
09d88                 | LR__1597
09d88     2B A6 06 F1 | 	add	local01, #43
09d8c     53 B7 C2 FA | 	rdbyte	local09, local01
09d90     2B A6 86 F1 | 	sub	local01, #43
09d94     01 B6 CE F7 | 	test	local09, #1 wz
09d98     24 00 90 5D |  if_ne	jmp	#LR__1598
09d9c     1C A6 06 F1 | 	add	local01, #28
09da0     53 91 02 FB | 	rdlong	arg01, local01
09da4     04 A6 06 F1 | 	add	local01, #4
09da8     53 93 02 F6 | 	mov	arg02, local01
09dac     20 A6 86 F1 | 	sub	local01, #32
09db0     0B 94 06 F6 | 	mov	arg03, #11
09db4     B0 DE BF FD | 	call	#_fatfs_cc_memcmp
09db8     00 76 0E F2 | 	cmp	result1, #0 wz
09dbc     28 00 90 AD |  if_e	jmp	#LR__1601
09dc0                 | LR__1598
09dc0     FF AC 06 F6 | 	mov	local04, #255
09dc4     2C A6 06 F1 | 	add	local01, #44
09dc8     FF FF FF FF 
09dcc     53 FF 6B FC | 	wrlong	##-1, local01
09dd0     2C A6 86 F1 | 	sub	local01, #44
09dd4                 | LR__1599
09dd4                 | LR__1600
09dd4     53 91 02 F6 | 	mov	arg01, local01
09dd8     00 92 06 F6 | 	mov	arg02, #0
09ddc     A0 F4 BF FD | 	call	#_fatfs_cc_dir_next
09de0     3B AF 0A F6 | 	mov	local05, result1 wz
09de4     04 FE 9F AD |  if_e	jmp	#LR__1590
09de8                 | LR__1601
09de8                 | ' 
09de8                 | ' 	return res;
09de8     57 77 02 F6 | 	mov	result1, local05
09dec                 | LR__1602
09dec     E7 F0 03 F6 | 	mov	ptra, fp
09df0     F2 00 A0 FD | 	call	#popregs_
09df4                 | _fatfs_cc_dir_find_ret
09df4     2D 00 64 FD | 	ret
09df8                 | 
09df8                 | _fatfs_cc_dir_register
09df8     09 CA 05 F6 | 	mov	COUNT_, #9
09dfc     E8 00 A0 FD | 	call	#pushregs_
09e00     2C F0 07 F1 | 	add	ptra, #44
09e04     48 A7 02 F6 | 	mov	local01, arg01
09e08     53 A9 02 FB | 	rdlong	local02, local01
09e0c     2B A6 06 F1 | 	add	local01, #43
09e10     53 AB C2 FA | 	rdbyte	local03, local01
09e14     2B A6 86 F1 | 	sub	local01, #43
09e18     A0 AA CE F7 | 	test	local03, #160 wz
09e1c     06 76 06 56 |  if_ne	mov	result1, #6
09e20     2C 02 90 5D |  if_ne	jmp	#LR__1621
09e24                 | ' 	for (len = 0; fs->lfnbuf[len]; len++) ;
09e24     00 AC 06 F6 | 	mov	local04, #0
09e28     0C A8 06 F1 | 	add	local02, #12
09e2c     D7 12 48 FB | 	callpa	#(@LR__1611-@LR__1610)>>2,fcache_load_ptr_
09e30                 | LR__1610
09e30     54 AB 02 FB | 	rdlong	local03, local02
09e34     56 97 02 F6 | 	mov	arg04, local04
09e38     01 96 66 F0 | 	shl	arg04, #1
09e3c     55 97 02 F1 | 	add	arg04, local03
09e40     4B AB EA FA | 	rdword	local03, arg04 wz
09e44     56 AF 02 56 |  if_ne	mov	local05, local04
09e48     01 AE 06 51 |  if_ne	add	local05, #1
09e4c     57 AD 02 56 |  if_ne	mov	local04, local05
09e50     DC FF 9F 5D |  if_ne	jmp	#LR__1610
09e54                 | LR__1611
09e54     0C A8 86 F1 | 	sub	local02, #12
09e58     E7 90 02 F6 | 	mov	arg01, fp
09e5c     1C 90 06 F1 | 	add	arg01, #28
09e60     53 93 02 F6 | 	mov	arg02, local01
09e64     20 92 06 F1 | 	add	arg02, #32
09e68     0C 94 06 F6 | 	mov	arg03, #12
09e6c     4C 92 BF FD | 	call	#__system____builtin_memmove
09e70     27 CE 05 F1 | 	add	fp, #39
09e74     E7 AA C2 FA | 	rdbyte	local03, fp
09e78     27 CE 85 F1 | 	sub	fp, #39
09e7c     01 AA CE F7 | 	test	local03, #1 wz
09e80     80 00 90 AD |  if_e	jmp	#LR__1614
09e84     2B A6 06 F1 | 	add	local01, #43
09e88     53 81 48 FC | 	wrbyte	#64, local01
09e8c     2B A6 86 F1 | 	sub	local01, #43
09e90                 | ' 		dp->fn[ 11 ] =  0x40 ;
09e90                 | ' 		for (n = 1; n < 100; n++) {
09e90     01 B0 06 F6 | 	mov	local06, #1
09e94                 | LR__1612
09e94     64 B0 16 F2 | 	cmp	local06, #100 wc
09e98     38 00 90 3D |  if_ae	jmp	#LR__1613
09e9c     53 91 02 F6 | 	mov	arg01, local01
09ea0     20 90 06 F1 | 	add	arg01, #32
09ea4     E7 92 02 F6 | 	mov	arg02, fp
09ea8     1C 92 06 F1 | 	add	arg02, #28
09eac     0C A8 06 F1 | 	add	local02, #12
09eb0     54 95 02 FB | 	rdlong	arg03, local02
09eb4     0C A8 86 F1 | 	sub	local02, #12
09eb8     58 97 02 F6 | 	mov	arg04, local06
09ebc     44 F9 BF FD | 	call	#_fatfs_cc_gen_numname
09ec0     53 91 02 F6 | 	mov	arg01, local01
09ec4     E8 FC BF FD | 	call	#_fatfs_cc_dir_find
09ec8     3B B3 0A F6 | 	mov	local07, result1 wz
09ecc     01 B0 06 A1 |  if_e	add	local06, #1
09ed0     C0 FF 9F AD |  if_e	jmp	#LR__1612
09ed4                 | LR__1613
09ed4     64 B0 0E F2 | 	cmp	local06, #100 wz
09ed8     07 76 06 A6 |  if_e	mov	result1, #7
09edc     70 01 90 AD |  if_e	jmp	#LR__1621
09ee0     04 B2 0E F2 | 	cmp	local07, #4 wz
09ee4     59 77 02 56 |  if_ne	mov	result1, local07
09ee8     64 01 90 5D |  if_ne	jmp	#LR__1621
09eec     27 CE 05 F1 | 	add	fp, #39
09ef0     E7 AA C2 FA | 	rdbyte	local03, fp
09ef4     27 CE 85 F1 | 	sub	fp, #39
09ef8     2B A6 06 F1 | 	add	local01, #43
09efc     53 AB 42 FC | 	wrbyte	local03, local01
09f00     2B A6 86 F1 | 	sub	local01, #43
09f04                 | LR__1614
09f04     27 CE 05 F1 | 	add	fp, #39
09f08     E7 B2 C2 FA | 	rdbyte	local07, fp
09f0c     02 B2 CE F7 | 	test	local07, #2 wz
09f10     0C AC 06 51 |  if_ne	add	local04, #12
09f14     0D AC 16 5D |  if_ne	qdiv	local04, #13
09f18     27 CE 85 F1 | 	sub	fp, #39
09f1c     53 91 02 F6 | 	mov	arg01, local01
09f20     18 AA 62 5D |  if_ne	getqx	local03
09f24     01 AA 06 51 |  if_ne	add	local03, #1
09f28     01 AA 06 A6 |  if_e	mov	local03, #1
09f2c     55 B5 02 F6 | 	mov	local08, local03
09f30     5A 93 02 F6 | 	mov	arg02, local08
09f34     04 F5 BF FD | 	call	#_fatfs_cc_dir_alloc
09f38     3B B3 0A F6 | 	mov	local07, result1 wz
09f3c     9C 00 90 5D |  if_ne	jmp	#LR__1618
09f40     01 B4 8E F1 | 	sub	local08, #1 wz
09f44     94 00 90 AD |  if_e	jmp	#LR__1618
09f48     53 91 02 F6 | 	mov	arg01, local01
09f4c     5A B3 02 F6 | 	mov	local07, local08
09f50     05 B2 66 F0 | 	shl	local07, #5
09f54     10 A6 06 F1 | 	add	local01, #16
09f58     53 93 02 FB | 	rdlong	arg02, local01
09f5c     10 A6 86 F1 | 	sub	local01, #16
09f60     59 93 82 F1 | 	sub	arg02, local07
09f64     B0 F1 BF FD | 	call	#_fatfs_cc_dir_sdi
09f68     3B B3 0A F6 | 	mov	local07, result1 wz
09f6c     6C 00 90 5D |  if_ne	jmp	#LR__1617
09f70     53 91 02 F6 | 	mov	arg01, local01
09f74     20 90 06 F1 | 	add	arg01, #32
09f78     08 FA BF FD | 	call	#_fatfs_cc_sum_sfn
09f7c     3B B7 02 F6 | 	mov	local09, result1
09f80                 | ' 			sum = sum_sfn(dp->fn);
09f80                 | ' 			do {
09f80                 | LR__1615
09f80     18 A6 06 F1 | 	add	local01, #24
09f84     53 93 02 FB | 	rdlong	arg02, local01
09f88     18 A6 86 F1 | 	sub	local01, #24
09f8c     54 91 02 F6 | 	mov	arg01, local02
09f90     20 E8 BF FD | 	call	#_fatfs_cc_move_window
09f94     3B B3 0A F6 | 	mov	local07, result1 wz
09f98     40 00 90 5D |  if_ne	jmp	#LR__1616
09f9c     0C A8 06 F1 | 	add	local02, #12
09fa0     54 91 02 FB | 	rdlong	arg01, local02
09fa4     1C A6 06 F1 | 	add	local01, #28
09fa8     53 93 02 FB | 	rdlong	arg02, local01
09fac     1C A6 86 F1 | 	sub	local01, #28
09fb0     5B 97 02 F6 | 	mov	arg04, local09
09fb4     5A 95 02 F6 | 	mov	arg03, local08
09fb8     78 F7 BF FD | 	call	#_fatfs_cc_put_lfn
09fbc     09 A8 86 F1 | 	sub	local02, #9
09fc0     54 03 48 FC | 	wrbyte	#1, local02
09fc4     03 A8 86 F1 | 	sub	local02, #3
09fc8     53 91 02 F6 | 	mov	arg01, local01
09fcc     00 92 06 F6 | 	mov	arg02, #0
09fd0     AC F2 BF FD | 	call	#_fatfs_cc_dir_next
09fd4     3B B3 0A F6 | 	mov	local07, result1 wz
09fd8     E9 B5 6E AB |  if_e	djnz	local08, #LR__1615
09fdc                 | LR__1616
09fdc                 | LR__1617
09fdc                 | LR__1618
09fdc     00 B2 0E F2 | 	cmp	local07, #0 wz
09fe0     68 00 90 5D |  if_ne	jmp	#LR__1620
09fe4     18 A6 06 F1 | 	add	local01, #24
09fe8     53 93 02 FB | 	rdlong	arg02, local01
09fec     18 A6 86 F1 | 	sub	local01, #24
09ff0     54 91 02 F6 | 	mov	arg01, local02
09ff4     BC E7 BF FD | 	call	#_fatfs_cc_move_window
09ff8     3B B3 0A F6 | 	mov	local07, result1 wz
09ffc     4C 00 90 5D |  if_ne	jmp	#LR__1619
0a000     1C A6 06 F1 | 	add	local01, #28
0a004     53 91 02 FB | 	rdlong	arg01, local01
0a008     00 92 06 F6 | 	mov	arg02, #0
0a00c     20 94 06 F6 | 	mov	arg03, #32
0a010     D8 00 A0 FD | 	call	#\builtin_bytefill_
0a014     53 91 02 FB | 	rdlong	arg01, local01
0a018     04 A6 06 F1 | 	add	local01, #4
0a01c     53 93 02 F6 | 	mov	arg02, local01
0a020     0B 94 06 F6 | 	mov	arg03, #11
0a024     94 90 BF FD | 	call	#__system____builtin_memmove
0a028     04 A6 86 F1 | 	sub	local01, #4
0a02c     53 AB 02 FB | 	rdlong	local03, local01
0a030     0F A6 06 F1 | 	add	local01, #15
0a034     53 B7 C2 FA | 	rdbyte	local09, local01
0a038     18 B6 06 F5 | 	and	local09, #24
0a03c     0C AA 06 F1 | 	add	local03, #12
0a040     55 B7 42 FC | 	wrbyte	local09, local03
0a044     03 A8 06 F1 | 	add	local02, #3
0a048     54 03 48 FC | 	wrbyte	#1, local02
0a04c                 | LR__1619
0a04c                 | LR__1620
0a04c                 | ' 			__builtin_memset(dp->dir, 0, 32 ) ;
0a04c                 | ' 			__builtin_memcpy(dp->dir + 0 , dp->fn, 11) ;
0a04c                 | ' 
0a04c                 | ' 			dp->dir[ 12 ] = dp->fn[ 11 ] & ( 0x08  |  0x10 );
0a04c                 | ' 
0a04c                 | ' 			fs->wflag = 1;
0a04c                 | ' 		}
0a04c                 | ' 	}
0a04c                 | ' 
0a04c                 | ' 	return res;
0a04c     59 77 02 F6 | 	mov	result1, local07
0a050                 | LR__1621
0a050     E7 F0 03 F6 | 	mov	ptra, fp
0a054     F2 00 A0 FD | 	call	#popregs_
0a058                 | _fatfs_cc_dir_register_ret
0a058     2D 00 64 FD | 	ret
0a05c                 | 
0a05c                 | _fatfs_cc_dir_remove
0a05c     05 CA 05 F6 | 	mov	COUNT_, #5
0a060     E8 00 A0 FD | 	call	#pushregs_
0a064     48 A7 02 F6 | 	mov	local01, arg01
0a068     53 A9 02 FB | 	rdlong	local02, local01
0a06c     10 A6 06 F1 | 	add	local01, #16
0a070     53 AB 02 FB | 	rdlong	local03, local01
0a074     1C A6 06 F1 | 	add	local01, #28
0a078     53 93 02 FB | 	rdlong	arg02, local01
0a07c     2C A6 86 F1 | 	sub	local01, #44
0a080     FF FF 7F FF 
0a084     FF 93 0E F2 | 	cmp	arg02, ##-1 wz
0a088     00 AC 06 A6 |  if_e	mov	local04, #0
0a08c     18 00 90 AD |  if_e	jmp	#LR__1630
0a090     53 91 02 F6 | 	mov	arg01, local01
0a094     2C A6 06 F1 | 	add	local01, #44
0a098     53 93 02 FB | 	rdlong	arg02, local01
0a09c     2C A6 86 F1 | 	sub	local01, #44
0a0a0     74 F0 BF FD | 	call	#_fatfs_cc_dir_sdi
0a0a4     3B AD 02 F6 | 	mov	local04, result1
0a0a8                 | LR__1630
0a0a8     56 AF 0A F6 | 	mov	local05, local04 wz
0a0ac     64 00 90 5D |  if_ne	jmp	#LR__1633
0a0b0                 | ' 		do {
0a0b0                 | LR__1631
0a0b0     18 A6 06 F1 | 	add	local01, #24
0a0b4     53 93 02 FB | 	rdlong	arg02, local01
0a0b8     18 A6 86 F1 | 	sub	local01, #24
0a0bc     54 91 02 F6 | 	mov	arg01, local02
0a0c0     F0 E6 BF FD | 	call	#_fatfs_cc_move_window
0a0c4     3B AF 0A F6 | 	mov	local05, result1 wz
0a0c8     40 00 90 5D |  if_ne	jmp	#LR__1632
0a0cc     1C A6 06 F1 | 	add	local01, #28
0a0d0     53 AD 02 FB | 	rdlong	local04, local01
0a0d4     56 CB 49 FC | 	wrbyte	#229, local04
0a0d8     03 A8 06 F1 | 	add	local02, #3
0a0dc     54 03 48 FC | 	wrbyte	#1, local02
0a0e0     03 A8 86 F1 | 	sub	local02, #3
0a0e4     0C A6 86 F1 | 	sub	local01, #12
0a0e8     53 AD 02 FB | 	rdlong	local04, local01
0a0ec     10 A6 86 F1 | 	sub	local01, #16
0a0f0     55 AD 12 F2 | 	cmp	local04, local03 wc
0a0f4     14 00 90 3D |  if_ae	jmp	#LR__1632
0a0f8     53 91 02 F6 | 	mov	arg01, local01
0a0fc     00 92 06 F6 | 	mov	arg02, #0
0a100     7C F1 BF FD | 	call	#_fatfs_cc_dir_next
0a104     3B AF 0A F6 | 	mov	local05, result1 wz
0a108     A4 FF 9F AD |  if_e	jmp	#LR__1631
0a10c                 | LR__1632
0a10c     04 AE 0E F2 | 	cmp	local05, #4 wz
0a110     02 AE 06 A6 |  if_e	mov	local05, #2
0a114                 | LR__1633
0a114                 | ' 	}
0a114                 | ' #line 2590 "ff.c"
0a114                 | ' 	return res;
0a114     57 77 02 F6 | 	mov	result1, local05
0a118     E7 F0 03 F6 | 	mov	ptra, fp
0a11c     F2 00 A0 FD | 	call	#popregs_
0a120                 | _fatfs_cc_dir_remove_ret
0a120     2D 00 64 FD | 	ret
0a124                 | 
0a124                 | _fatfs_cc_get_fileinfo
0a124     0C CA 05 F6 | 	mov	COUNT_, #12
0a128     E8 00 A0 FD | 	call	#pushregs_
0a12c     48 A7 02 F6 | 	mov	local01, arg01
0a130     49 A9 02 F6 | 	mov	local02, arg02
0a134     53 AB 02 FB | 	rdlong	local03, local01
0a138     1C A8 06 F1 | 	add	local02, #28
0a13c     54 01 48 FC | 	wrbyte	#0, local02
0a140     1C A8 86 F1 | 	sub	local02, #28
0a144     18 A6 06 F1 | 	add	local01, #24
0a148     53 AD 0A FB | 	rdlong	local04, local01 wz
0a14c     18 A6 86 F1 | 	sub	local01, #24
0a150     90 03 90 AD |  if_e	jmp	#LR__1654
0a154     2C A6 06 F1 | 	add	local01, #44
0a158     53 AD 02 FB | 	rdlong	local04, local01
0a15c     2C A6 86 F1 | 	sub	local01, #44
0a160     FF FF 7F FF 
0a164     FF AD 0E F2 | 	cmp	local04, ##-1 wz
0a168     D8 00 90 AD |  if_e	jmp	#LR__1643
0a16c     00 AE 06 F6 | 	mov	local05, #0
0a170     00 B0 06 F6 | 	mov	local06, #0
0a174     00 B2 06 F6 | 	mov	local07, #0
0a178                 | ' 			si = di = 0;
0a178                 | ' 			hs = 0;
0a178                 | ' 			while (fs->lfnbuf[si] != 0) {
0a178                 | LR__1640
0a178     0C AA 06 F1 | 	add	local03, #12
0a17c     55 AD 02 FB | 	rdlong	local04, local03
0a180     0C AA 86 F1 | 	sub	local03, #12
0a184     58 B5 02 F6 | 	mov	local08, local06
0a188     01 B4 66 F0 | 	shl	local08, #1
0a18c     56 B5 02 F1 | 	add	local08, local04
0a190     5A AD EA FA | 	rdword	local04, local08 wz
0a194     90 00 90 AD |  if_e	jmp	#LR__1642
0a198     0C AA 06 F1 | 	add	local03, #12
0a19c     55 B7 02 FB | 	rdlong	local09, local03
0a1a0     0C AA 86 F1 | 	sub	local03, #12
0a1a4     58 AD 02 F6 | 	mov	local04, local06
0a1a8     01 AC 66 F0 | 	shl	local04, #1
0a1ac     5B AD 02 F1 | 	add	local04, local09
0a1b0     56 B9 E2 FA | 	rdword	local10, local04
0a1b4     59 AD 02 F6 | 	mov	local04, local07
0a1b8     0F AC 4E F7 | 	zerox	local04, #15 wz
0a1bc     01 B0 06 F1 | 	add	local06, #1
0a1c0     24 00 90 5D |  if_ne	jmp	#LR__1641
0a1c4     5C AD 32 F9 | 	getword	local04, local10, #0
0a1c8     6C 00 00 FF 
0a1cc     00 AC 16 F2 | 	cmp	local04, ##55296 wc
0a1d0     14 00 90 CD |  if_b	jmp	#LR__1641
0a1d4     5C BB 32 F9 | 	getword	local11, local10, #0
0a1d8     70 00 00 FF 
0a1dc     00 BA 16 F2 | 	cmp	local11, ##57344 wc
0a1e0     5C B3 02 C6 |  if_b	mov	local07, local10
0a1e4                 | ' 					hs = wc; continue;
0a1e4     90 FF 9F CD |  if_b	jmp	#LR__1640
0a1e8                 | LR__1641
0a1e8     59 91 32 F9 | 	getword	arg01, local07, #0
0a1ec     10 90 66 F0 | 	shl	arg01, #16
0a1f0     5C B9 32 F9 | 	getword	local10, local10, #0
0a1f4     5C 91 42 F5 | 	or	arg01, local10
0a1f8     57 93 02 F6 | 	mov	arg02, local05
0a1fc     54 B9 02 F6 | 	mov	local10, local02
0a200     1C B8 06 F1 | 	add	local10, #28
0a204     5C 93 02 F1 | 	add	arg02, local10
0a208     FF 94 06 F6 | 	mov	arg03, #255
0a20c     57 95 82 F1 | 	sub	arg03, local05
0a210     28 E3 BF FD | 	call	#_fatfs_cc_put_utf
0a214     3B B9 0A F6 | 	mov	local10, result1 wz
0a218     00 AE 06 A6 |  if_e	mov	local05, #0
0a21c     5C AF 02 51 |  if_ne	add	local05, local10
0a220     00 B2 06 56 |  if_ne	mov	local07, #0
0a224     50 FF 9F 5D |  if_ne	jmp	#LR__1640
0a228                 | LR__1642
0a228     59 AD 02 F6 | 	mov	local04, local07
0a22c     0F AC 4E F7 | 	zerox	local04, #15 wz
0a230     00 AE 06 56 |  if_ne	mov	local05, #0
0a234     54 B9 02 F6 | 	mov	local10, local02
0a238     1C B8 06 F1 | 	add	local10, #28
0a23c     5C AF 02 F1 | 	add	local05, local10
0a240     57 01 48 FC | 	wrbyte	#0, local05
0a244                 | LR__1643
0a244     00 AE 06 F6 | 	mov	local05, #0
0a248     00 B0 06 F6 | 	mov	local06, #0
0a24c                 | ' 			fno->fname[di] = 0;
0a24c                 | ' 		}
0a24c                 | ' 	}
0a24c                 | ' 
0a24c                 | ' 	si = di = 0;
0a24c                 | ' 	while (si < 11) {
0a24c                 | LR__1644
0a24c     0B B0 16 F2 | 	cmp	local06, #11 wc
0a250     20 01 90 3D |  if_ae	jmp	#LR__1647
0a254     1C A6 06 F1 | 	add	local01, #28
0a258     53 B7 02 FB | 	rdlong	local09, local01
0a25c     1C A6 86 F1 | 	sub	local01, #28
0a260     58 B9 02 F6 | 	mov	local10, local06
0a264     5B B9 02 F1 | 	add	local10, local09
0a268     5C B9 C2 FA | 	rdbyte	local10, local10
0a26c     5C AD 32 F9 | 	getword	local04, local10, #0
0a270     20 AC 0E F2 | 	cmp	local04, #32 wz
0a274     01 B0 06 F1 | 	add	local06, #1
0a278     D0 FF 9F AD |  if_e	jmp	#LR__1644
0a27c     5C AD 32 F9 | 	getword	local04, local10, #0
0a280     05 AC 0E F2 | 	cmp	local04, #5 wz
0a284     E5 B8 06 A6 |  if_e	mov	local10, #229
0a288     09 B0 0E F2 | 	cmp	local06, #9 wz
0a28c     20 00 90 5D |  if_ne	jmp	#LR__1645
0a290     0C AE 16 F2 | 	cmp	local05, #12 wc
0a294     18 00 90 3D |  if_ae	jmp	#LR__1645
0a298     57 BB 02 F6 | 	mov	local11, local05
0a29c     54 B5 02 F6 | 	mov	local08, local02
0a2a0     0C B4 06 F1 | 	add	local08, #12
0a2a4     5A BB 02 F1 | 	add	local11, local08
0a2a8     5D 5D 48 FC | 	wrbyte	#46, local11
0a2ac     01 AE 06 F1 | 	add	local05, #1
0a2b0                 | LR__1645
0a2b0     5C 91 32 F9 | 	getword	arg01, local10, #0
0a2b4     07 90 4E F7 | 	zerox	arg01, #7 wz
0a2b8     00 76 06 56 |  if_ne	mov	result1, #0
0a2bc                 | ' 
0a2bc                 | ' 	return 0;
0a2bc     00 76 06 A6 |  if_e	mov	result1, #0
0a2c0     00 76 0E F2 | 	cmp	result1, #0 wz
0a2c4     08 B0 0E 52 |  if_ne	cmp	local06, #8 wz
0a2c8     0B B0 0E 52 |  if_ne	cmp	local06, #11 wz
0a2cc     50 00 90 AD |  if_e	jmp	#LR__1646
0a2d0     1C A6 06 F1 | 	add	local01, #28
0a2d4     53 BB 02 FB | 	rdlong	local11, local01
0a2d8     1C A6 86 F1 | 	sub	local01, #28
0a2dc     58 B5 02 F6 | 	mov	local08, local06
0a2e0     5D B5 02 F1 | 	add	local08, local11
0a2e4     5A 91 CA FA | 	rdbyte	arg01, local08 wz
0a2e8     00 76 06 56 |  if_ne	mov	result1, #0
0a2ec                 | ' 
0a2ec                 | ' 	return 0;
0a2ec     00 76 06 A6 |  if_e	mov	result1, #0
0a2f0     00 76 0E F2 | 	cmp	result1, #0 wz
0a2f4     28 00 90 AD |  if_e	jmp	#LR__1646
0a2f8     5C B9 32 F9 | 	getword	local10, local10, #0
0a2fc     08 B8 66 F0 | 	shl	local10, #8
0a300     1C A6 06 F1 | 	add	local01, #28
0a304     53 BB 02 FB | 	rdlong	local11, local01
0a308     1C A6 86 F1 | 	sub	local01, #28
0a30c     58 B7 02 F6 | 	mov	local09, local06
0a310     5D B7 02 F1 | 	add	local09, local11
0a314     5B BB C2 FA | 	rdbyte	local11, local09
0a318     5D B9 42 F5 | 	or	local10, local11
0a31c     01 B0 06 F1 | 	add	local06, #1
0a320                 | LR__1646
0a320     5C 91 02 F6 | 	mov	arg01, local10
0a324     01 00 00 FF 
0a328     52 93 06 F6 | 	mov	arg02, ##850
0a32c     24 D7 BF FD | 	call	#_fatfs_cc_ff_oem2uni
0a330     3B B9 02 F6 | 	mov	local10, result1
0a334     5C AD 02 F6 | 	mov	local04, local10
0a338     0F AC 4E F7 | 	zerox	local04, #15 wz
0a33c     00 AE 06 A6 |  if_e	mov	local05, #0
0a340     30 00 90 AD |  if_e	jmp	#LR__1647
0a344     5C 91 32 F9 | 	getword	arg01, local10, #0
0a348     57 93 02 F6 | 	mov	arg02, local05
0a34c     54 BB 02 F6 | 	mov	local11, local02
0a350     0C BA 06 F1 | 	add	local11, #12
0a354     5D 93 02 F1 | 	add	arg02, local11
0a358     0C 94 06 F6 | 	mov	arg03, #12
0a35c     57 95 82 F1 | 	sub	arg03, local05
0a360     D8 E1 BF FD | 	call	#_fatfs_cc_put_utf
0a364     3B BB 0A F6 | 	mov	local11, result1 wz
0a368     00 AE 06 A6 |  if_e	mov	local05, #0
0a36c     5D AF 02 51 |  if_ne	add	local05, local11
0a370     D8 FE 9F 5D |  if_ne	jmp	#LR__1644
0a374                 | LR__1647
0a374     57 AD 02 F6 | 	mov	local04, local05
0a378     0C A8 06 F1 | 	add	local02, #12
0a37c     54 AD 02 F1 | 	add	local04, local02
0a380     56 01 48 FC | 	wrbyte	#0, local04
0a384     10 A8 06 F1 | 	add	local02, #16
0a388     54 AD CA FA | 	rdbyte	local04, local02 wz
0a38c     1C A8 86 F1 | 	sub	local02, #28
0a390     F8 00 90 5D |  if_ne	jmp	#LR__1653
0a394     00 AE 0E F2 | 	cmp	local05, #0 wz
0a398     1C 00 90 5D |  if_ne	jmp	#LR__1648
0a39c     57 BB 02 F6 | 	mov	local11, local05
0a3a0     54 B9 02 F6 | 	mov	local10, local02
0a3a4     1C B8 06 F1 | 	add	local10, #28
0a3a8     5C BB 02 F1 | 	add	local11, local10
0a3ac     5D 7F 48 FC | 	wrbyte	#63, local11
0a3b0     01 AE 06 F1 | 	add	local05, #1
0a3b4     A4 00 90 FD | 	jmp	#LR__1652
0a3b8                 | LR__1648
0a3b8                 | ' 			for (si = di = 0, lcf =  0x08 ; fno->altname[si]; si++, di++) {
0a3b8     00 AE 06 F6 | 	mov	local05, #0
0a3bc     00 B0 06 F6 | 	mov	local06, #0
0a3c0     08 BC 06 F6 | 	mov	local12, #8
0a3c4                 | LR__1649
0a3c4     58 AD 02 F6 | 	mov	local04, local06
0a3c8     54 BB 02 F6 | 	mov	local11, local02
0a3cc     0C BA 06 F1 | 	add	local11, #12
0a3d0     5D AD 02 F1 | 	add	local04, local11
0a3d4     56 BB CA FA | 	rdbyte	local11, local04 wz
0a3d8     80 00 90 AD |  if_e	jmp	#LR__1651
0a3dc     58 B5 02 F6 | 	mov	local08, local06
0a3e0     54 BB 02 F6 | 	mov	local11, local02
0a3e4     0C BA 06 F1 | 	add	local11, #12
0a3e8     5D B5 02 F1 | 	add	local08, local11
0a3ec     5A B9 C2 FA | 	rdbyte	local10, local08
0a3f0     5C BB 32 F9 | 	getword	local11, local10, #0
0a3f4     2E BA 0E F2 | 	cmp	local11, #46 wz
0a3f8     10 BC 06 A6 |  if_e	mov	local12, #16
0a3fc     5C BB 32 F9 | 	getword	local11, local10, #0
0a400     41 BA 16 F2 | 	cmp	local11, #65 wc
0a404     30 00 90 CD |  if_b	jmp	#LR__1650
0a408     5C B5 32 F9 | 	getword	local08, local10, #0
0a40c     5B B4 16 F2 | 	cmp	local08, #91 wc
0a410     24 00 90 3D |  if_ae	jmp	#LR__1650
0a414     1C A6 06 F1 | 	add	local01, #28
0a418     53 B7 02 FB | 	rdlong	local09, local01
0a41c     1C A6 86 F1 | 	sub	local01, #28
0a420     0C B6 06 F1 | 	add	local09, #12
0a424     5B B7 C2 FA | 	rdbyte	local09, local09
0a428     5E BB E2 F8 | 	getbyte	local11, local12, #0
0a42c     5D B7 CA F7 | 	test	local09, local11 wz
0a430     5C B9 32 59 |  if_ne	getword	local10, local10, #0
0a434     20 B8 06 51 |  if_ne	add	local10, #32
0a438                 | LR__1650
0a438     57 BB 02 F6 | 	mov	local11, local05
0a43c     54 B5 02 F6 | 	mov	local08, local02
0a440     1C B4 06 F1 | 	add	local08, #28
0a444     5A BB 02 F1 | 	add	local11, local08
0a448     5C B9 32 F9 | 	getword	local10, local10, #0
0a44c     5D B9 42 FC | 	wrbyte	local10, local11
0a450     01 B0 06 F1 | 	add	local06, #1
0a454     01 AE 06 F1 | 	add	local05, #1
0a458     68 FF 9F FD | 	jmp	#LR__1649
0a45c                 | LR__1651
0a45c                 | LR__1652
0a45c     54 BD 02 F6 | 	mov	local12, local02
0a460     1C BC 06 F1 | 	add	local12, #28
0a464     5E AF 02 F1 | 	add	local05, local12
0a468     57 01 48 FC | 	wrbyte	#0, local05
0a46c     1C A6 06 F1 | 	add	local01, #28
0a470     53 AD 02 FB | 	rdlong	local04, local01
0a474     1C A6 86 F1 | 	sub	local01, #28
0a478     0C AC 06 F1 | 	add	local04, #12
0a47c     56 BB CA FA | 	rdbyte	local11, local04 wz
0a480     0C A8 06 A1 |  if_e	add	local02, #12
0a484     54 01 48 AC |  if_e	wrbyte	#0, local02
0a488     0C A8 86 A1 |  if_e	sub	local02, #12
0a48c                 | LR__1653
0a48c     1C A6 06 F1 | 	add	local01, #28
0a490     53 BD 02 FB | 	rdlong	local12, local01
0a494     0B BC 06 F1 | 	add	local12, #11
0a498     5E AD C2 FA | 	rdbyte	local04, local12
0a49c     3F AC 06 F5 | 	and	local04, #63
0a4a0     08 A8 06 F1 | 	add	local02, #8
0a4a4     54 AD 42 FC | 	wrbyte	local04, local02
0a4a8     08 A8 86 F1 | 	sub	local02, #8
0a4ac     53 91 02 FB | 	rdlong	arg01, local01
0a4b0     1C 90 06 F1 | 	add	arg01, #28
0a4b4                 | ' {
0a4b4                 | ' 
0a4b4                 | ' 	return *((DWORD*)ptr);
0a4b4     48 77 02 FB | 	rdlong	result1, arg01
0a4b8     54 77 62 FC | 	wrlong	result1, local02
0a4bc     53 91 02 FB | 	rdlong	arg01, local01
0a4c0     16 90 06 F1 | 	add	arg01, #22
0a4c4                 | ' {
0a4c4                 | ' 
0a4c4                 | ' 	return *((WORD*)ptr);
0a4c4     48 77 E2 FA | 	rdword	result1, arg01
0a4c8     06 A8 06 F1 | 	add	local02, #6
0a4cc     54 77 52 FC | 	wrword	result1, local02
0a4d0     53 91 02 FB | 	rdlong	arg01, local01
0a4d4     18 90 06 F1 | 	add	arg01, #24
0a4d8                 | ' {
0a4d8                 | ' 
0a4d8                 | ' 	return *((WORD*)ptr);
0a4d8     48 77 E2 FA | 	rdword	result1, arg01
0a4dc     02 A8 86 F1 | 	sub	local02, #2
0a4e0     54 77 52 FC | 	wrword	result1, local02
0a4e4                 | LR__1654
0a4e4     E7 F0 03 F6 | 	mov	ptra, fp
0a4e8     F2 00 A0 FD | 	call	#popregs_
0a4ec                 | _fatfs_cc_get_fileinfo_ret
0a4ec     2D 00 64 FD | 	ret
0a4f0                 | 
0a4f0                 | _fatfs_cc_create_name
0a4f0     12 CA 05 F6 | 	mov	COUNT_, #18
0a4f4     E8 00 A0 FD | 	call	#pushregs_
0a4f8     34 F0 07 F1 | 	add	ptra, #52
0a4fc     48 A7 02 F6 | 	mov	local01, arg01
0a500     49 A9 02 F6 | 	mov	local02, arg02
0a504     54 77 02 FB | 	rdlong	result1, local02
0a508     30 CE 05 F1 | 	add	fp, #48
0a50c     E7 76 62 FC | 	wrlong	result1, fp
0a510     30 CE 85 F1 | 	sub	fp, #48
0a514     53 AB 02 FB | 	rdlong	local03, local01
0a518     0C AA 06 F1 | 	add	local03, #12
0a51c     55 AD 02 FB | 	rdlong	local04, local03
0a520     00 AE 06 F6 | 	mov	local05, #0
0a524                 | ' 
0a524                 | ' 
0a524                 | ' 
0a524                 | ' 	p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
0a524                 | ' 	for (;;) {
0a524                 | LR__1660
0a524     E7 90 02 F6 | 	mov	arg01, fp
0a528     30 90 06 F1 | 	add	arg01, #48
0a52c     FC DE BF FD | 	call	#_fatfs_cc_tchar2uni
0a530     3B B1 02 F6 | 	mov	local06, result1
0a534     FF FF 7F FF 
0a538     FF B1 0E F2 | 	cmp	local06, ##-1 wz
0a53c     06 76 06 A6 |  if_e	mov	result1, #6
0a540     84 04 90 AD |  if_e	jmp	#LR__1694
0a544     80 00 00 FF 
0a548     00 B0 16 F2 | 	cmp	local06, ##65536 wc
0a54c     20 00 90 CD |  if_b	jmp	#LR__1661
0a550     57 AB 02 F6 | 	mov	local03, local05
0a554     01 AA 66 F0 | 	shl	local03, #1
0a558     56 B3 02 F6 | 	mov	local07, local04
0a55c     56 AB 02 F1 | 	add	local03, local04
0a560     58 B5 02 F6 | 	mov	local08, local06
0a564     10 B4 46 F0 | 	shr	local08, #16
0a568     55 B5 52 FC | 	wrword	local08, local03
0a56c     01 AE 06 F1 | 	add	local05, #1
0a570                 | LR__1661
0a570     58 B7 02 F6 | 	mov	local09, local06
0a574     5B AB 32 F9 | 	getword	local03, local09, #0
0a578     20 AA 16 F2 | 	cmp	local03, #32 wc
0a57c     68 00 90 CD |  if_b	jmp	#LR__1663
0a580     5B B9 32 F9 | 	getword	local10, local09, #0
0a584     2F B8 0E F2 | 	cmp	local10, #47 wz
0a588     5B AB 02 56 |  if_ne	mov	local03, local09
0a58c     55 AB 32 59 |  if_ne	getword	local03, local03, #0
0a590     5C AA 0E 52 |  if_ne	cmp	local03, #92 wz
0a594     50 00 90 AD |  if_e	jmp	#LR__1663
0a598     5B AB 32 F9 | 	getword	local03, local09, #0
0a59c     80 AA 16 F2 | 	cmp	local03, #128 wc
0a5a0     1C 00 90 3D |  if_ae	jmp	#LR__1662
0a5a4     71 00 00 FF 
0a5a8     25 91 06 F6 | 	mov	arg01, ##@LR__2168
0a5ac     5B 93 32 F9 | 	getword	arg02, local09, #0
0a5b0     80 D7 BF FD | 	call	#_fatfs_cc_strchr
0a5b4     3B B9 0A F6 | 	mov	local10, result1 wz
0a5b8     06 76 06 56 |  if_ne	mov	result1, #6
0a5bc     08 04 90 5D |  if_ne	jmp	#LR__1694
0a5c0                 | LR__1662
0a5c0     FF AE 16 F2 | 	cmp	local05, #255 wc
0a5c4     06 76 06 36 |  if_ae	mov	result1, #6
0a5c8     FC 03 90 3D |  if_ae	jmp	#LR__1694
0a5cc     57 B1 02 F6 | 	mov	local06, local05
0a5d0     01 B0 66 F0 | 	shl	local06, #1
0a5d4     56 B3 02 F6 | 	mov	local07, local04
0a5d8     56 B1 02 F1 | 	add	local06, local04
0a5dc     58 B7 52 FC | 	wrword	local09, local06
0a5e0     01 AE 06 F1 | 	add	local05, #1
0a5e4     3C FF 9F FD | 	jmp	#LR__1660
0a5e8                 | LR__1663
0a5e8     5B AB 32 F9 | 	getword	local03, local09, #0
0a5ec     20 AA 16 F2 | 	cmp	local03, #32 wc
0a5f0     04 BA 06 C6 |  if_b	mov	local11, #4
0a5f4     68 00 90 CD |  if_b	jmp	#LR__1668
0a5f8     D7 24 48 FB | 	callpa	#(@LR__1666-@LR__1664)>>2,fcache_load_ptr_
0a5fc                 | ' 		while ( ((*p) == '/' || (*p) == '\\') ) p++;
0a5fc                 | LR__1664
0a5fc     30 CE 05 F1 | 	add	fp, #48
0a600     E7 B8 02 FB | 	rdlong	local10, fp
0a604     30 CE 85 F1 | 	sub	fp, #48
0a608     5C AB C2 FA | 	rdbyte	local03, local10
0a60c     2F AA 0E F2 | 	cmp	local03, #47 wz
0a610     18 00 90 AD |  if_e	jmp	#LR__1665
0a614     30 CE 05 F1 | 	add	fp, #48
0a618     E7 B4 02 FB | 	rdlong	local08, fp
0a61c     30 CE 85 F1 | 	sub	fp, #48
0a620     5A BB C2 FA | 	rdbyte	local11, local08
0a624     5C BA 0E F2 | 	cmp	local11, #92 wz
0a628     18 00 90 5D |  if_ne	jmp	#LR__1667
0a62c                 | LR__1665
0a62c     30 CE 05 F1 | 	add	fp, #48
0a630     E7 BA 02 FB | 	rdlong	local11, fp
0a634     01 BA 06 F1 | 	add	local11, #1
0a638     E7 BA 62 FC | 	wrlong	local11, fp
0a63c     30 CE 85 F1 | 	sub	fp, #48
0a640     B8 FF 9F FD | 	jmp	#LR__1664
0a644                 | LR__1666
0a644                 | LR__1667
0a644     00 BA 06 F6 | 	mov	local11, #0
0a648     30 CE 05 F1 | 	add	fp, #48
0a64c     E7 B8 02 FB | 	rdlong	local10, fp
0a650     30 CE 85 F1 | 	sub	fp, #48
0a654     5C AB C2 FA | 	rdbyte	local03, local10
0a658     20 AA 16 F2 | 	cmp	local03, #32 wc
0a65c     04 BA 06 C6 |  if_b	mov	local11, #4
0a660                 | LR__1668
0a660     30 CE 05 F1 | 	add	fp, #48
0a664     E7 AA 02 FB | 	rdlong	local03, fp
0a668     30 CE 85 F1 | 	sub	fp, #48
0a66c     54 AB 62 FC | 	wrlong	local03, local02
0a670                 | ' 	}
0a670                 | ' 	*path = p;
0a670                 | ' #line 2862 "ff.c"
0a670                 | ' 	while (di) {
0a670     00 AE 0E F2 | 	cmp	local05, #0 wz
0a674     30 00 90 AD |  if_e	jmp	#LR__1671
0a678     D7 16 48 FB | 	callpa	#(@LR__1670-@LR__1669)>>2,fcache_load_ptr_
0a67c                 | LR__1669
0a67c     57 B7 02 F6 | 	mov	local09, local05
0a680     01 B6 86 F1 | 	sub	local09, #1
0a684     01 B6 66 F0 | 	shl	local09, #1
0a688     56 B7 02 F1 | 	add	local09, local04
0a68c     5B B7 E2 FA | 	rdword	local09, local09
0a690     5B AB 32 F9 | 	getword	local03, local09, #0
0a694     20 AA 0E F2 | 	cmp	local03, #32 wz
0a698     5B B9 02 56 |  if_ne	mov	local10, local09
0a69c     5C B9 32 59 |  if_ne	getword	local10, local10, #0
0a6a0     2E B8 0E 52 |  if_ne	cmp	local10, #46 wz
0a6a4     F5 AF 6E AB |  if_e	djnz	local05, #LR__1669
0a6a8                 | LR__1670
0a6a8                 | LR__1671
0a6a8     57 B9 02 F6 | 	mov	local10, local05
0a6ac     01 B8 66 F0 | 	shl	local10, #1
0a6b0     56 B9 02 F1 | 	add	local10, local04
0a6b4     5C 01 58 FC | 	wrword	#0, local10
0a6b8     00 AE 0E F2 | 	cmp	local05, #0 wz
0a6bc     06 76 06 A6 |  if_e	mov	result1, #6
0a6c0     04 03 90 AD |  if_e	jmp	#LR__1694
0a6c4                 | ' 
0a6c4                 | ' 
0a6c4                 | ' 	for (si = 0; lfn[si] == ' '; si++) ;
0a6c4     00 BC 06 F6 | 	mov	local12, #0
0a6c8     D7 12 48 FB | 	callpa	#(@LR__1673-@LR__1672)>>2,fcache_load_ptr_
0a6cc                 | LR__1672
0a6cc     5E B7 02 F6 | 	mov	local09, local12
0a6d0     01 B6 66 F0 | 	shl	local09, #1
0a6d4     56 B7 02 F1 | 	add	local09, local04
0a6d8     5B AB E2 FA | 	rdword	local03, local09
0a6dc     20 AA 0E F2 | 	cmp	local03, #32 wz
0a6e0     5E B5 02 A6 |  if_e	mov	local08, local12
0a6e4     01 B4 06 A1 |  if_e	add	local08, #1
0a6e8     5A BD 02 A6 |  if_e	mov	local12, local08
0a6ec     DC FF 9F AD |  if_e	jmp	#LR__1672
0a6f0                 | LR__1673
0a6f0     01 BC 16 F2 | 	cmp	local12, #1 wc
0a6f4     18 00 90 3D |  if_ae	jmp	#LR__1674
0a6f8     5E B7 02 F6 | 	mov	local09, local12
0a6fc     01 B6 66 F0 | 	shl	local09, #1
0a700     56 B7 02 F1 | 	add	local09, local04
0a704     5B AB E2 FA | 	rdword	local03, local09
0a708     2E AA 0E F2 | 	cmp	local03, #46 wz
0a70c     08 00 90 5D |  if_ne	jmp	#LR__1675
0a710                 | LR__1674
0a710     5D BB E2 F8 | 	getbyte	local11, local11, #0
0a714     03 BA 46 F5 | 	or	local11, #3
0a718                 | LR__1675
0a718     D7 14 48 FB | 	callpa	#(@LR__1677-@LR__1676)>>2,fcache_load_ptr_
0a71c                 | ' 	while (di > 0 && lfn[di - 1] != '.') di--;
0a71c                 | LR__1676
0a71c     01 AE 16 F2 | 	cmp	local05, #1 wc
0a720     20 00 90 CD |  if_b	jmp	#LR__1678
0a724     57 B7 02 F6 | 	mov	local09, local05
0a728     01 B6 86 F1 | 	sub	local09, #1
0a72c     01 B6 66 F0 | 	shl	local09, #1
0a730     56 B7 02 F1 | 	add	local09, local04
0a734     5B AB E2 FA | 	rdword	local03, local09
0a738     2E AA 0E F2 | 	cmp	local03, #46 wz
0a73c     01 AE 86 51 |  if_ne	sub	local05, #1
0a740     D8 FF 9F 5D |  if_ne	jmp	#LR__1676
0a744                 | LR__1677
0a744                 | LR__1678
0a744     53 91 02 F6 | 	mov	arg01, local01
0a748     20 90 06 F1 | 	add	arg01, #32
0a74c     20 92 06 F6 | 	mov	arg02, #32
0a750     0B 94 06 F6 | 	mov	arg03, #11
0a754     48 BF 02 F6 | 	mov	local13, arg01
0a758     D8 00 A0 FD | 	call	#\builtin_bytefill_
0a75c     5F 77 02 F6 | 	mov	result1, local13
0a760     00 C0 06 F6 | 	mov	local14, #0
0a764     00 C2 06 F6 | 	mov	local15, #0
0a768     08 C4 06 F6 | 	mov	local16, #8
0a76c                 | ' 
0a76c                 | ' 	__builtin_memset(dp->fn, ' ', 11) ;
0a76c                 | ' 	i = b = 0; ni = 8;
0a76c                 | ' 	for (;;) {
0a76c                 | LR__1679
0a76c     5E C7 02 F6 | 	mov	local17, local12
0a770     63 C9 02 F6 | 	mov	local18, local17
0a774     01 C8 66 F0 | 	shl	local18, #1
0a778     56 B3 02 F6 | 	mov	local07, local04
0a77c     56 C9 02 F1 | 	add	local18, local04
0a780     64 B7 E2 FA | 	rdword	local09, local18
0a784     5B AB 02 F6 | 	mov	local03, local09
0a788     0F AA 4E F7 | 	zerox	local03, #15 wz
0a78c     01 BC 06 F1 | 	add	local12, #1
0a790     B0 01 90 AD |  if_e	jmp	#LR__1692
0a794     5B AB 32 F9 | 	getword	local03, local09, #0
0a798     20 AA 0E F2 | 	cmp	local03, #32 wz
0a79c     14 00 90 AD |  if_e	jmp	#LR__1680
0a7a0     5B B9 32 F9 | 	getword	local10, local09, #0
0a7a4     2E B8 0E F2 | 	cmp	local10, #46 wz
0a7a8     14 00 90 5D |  if_ne	jmp	#LR__1681
0a7ac     57 BD 0A F2 | 	cmp	local12, local05 wz
0a7b0     0C 00 90 AD |  if_e	jmp	#LR__1681
0a7b4                 | LR__1680
0a7b4     5D BB E2 F8 | 	getbyte	local11, local11, #0
0a7b8     03 BA 46 F5 | 	or	local11, #3
0a7bc                 | ' 			cf |=  0x01  |  0x02 ;
0a7bc                 | ' 			continue;
0a7bc     AC FF 9F FD | 	jmp	#LR__1679
0a7c0                 | LR__1681
0a7c0     62 C3 12 F2 | 	cmp	local15, local16 wc
0a7c4     57 BD 0A C2 |  if_b	cmp	local12, local05 wz
0a7c8     3C 00 90 4D |  if_c_and_nz	jmp	#LR__1682
0a7cc     0B C4 0E F2 | 	cmp	local16, #11 wz
0a7d0     5D BB E2 A8 |  if_e	getbyte	local11, local11, #0
0a7d4     03 BA 46 A5 |  if_e	or	local11, #3
0a7d8                 | ' 				cf |=  0x01  |  0x02 ;
0a7d8                 | ' 				break;
0a7d8     68 01 90 AD |  if_e	jmp	#LR__1692
0a7dc     57 BD 0A F2 | 	cmp	local12, local05 wz
0a7e0     5D BB E2 58 |  if_ne	getbyte	local11, local11, #0
0a7e4     03 BA 46 55 |  if_ne	or	local11, #3
0a7e8     57 BD 1A F2 | 	cmp	local12, local05 wcz
0a7ec     54 01 90 1D |  if_a	jmp	#LR__1692
0a7f0     57 BD 02 F6 | 	mov	local12, local05
0a7f4     08 C2 06 F6 | 	mov	local15, #8
0a7f8     0B C4 06 F6 | 	mov	local16, #11
0a7fc     60 C1 E2 F8 | 	getbyte	local14, local14, #0
0a800     02 C0 66 F0 | 	shl	local14, #2
0a804                 | ' 			si = di; i = 8; ni = 11; b <<= 2;
0a804                 | ' 			continue;
0a804     64 FF 9F FD | 	jmp	#LR__1679
0a808                 | LR__1682
0a808     5B AB 32 F9 | 	getword	local03, local09, #0
0a80c     80 AA 16 F2 | 	cmp	local03, #128 wc
0a810     50 00 90 CD |  if_b	jmp	#LR__1684
0a814     5D BB E2 F8 | 	getbyte	local11, local11, #0
0a818     02 BA 46 F5 | 	or	local11, #2
0a81c     5B 91 32 F9 | 	getword	arg01, local09, #0
0a820     01 00 00 FF 
0a824     52 B9 06 F6 | 	mov	local10, ##850
0a828     01 00 00 FF 
0a82c     52 93 06 F6 | 	mov	arg02, ##850
0a830     B0 D1 BF FD | 	call	#_fatfs_cc_ff_uni2oem
0a834     3B B7 02 F6 | 	mov	local09, result1
0a838     5B AB 32 F9 | 	getword	local03, local09, #0
0a83c     80 AA CE F7 | 	test	local03, #128 wz
0a840     20 00 90 AD |  if_e	jmp	#LR__1683
0a844     5B B9 32 F9 | 	getword	local10, local09, #0
0a848     7F B8 06 F5 | 	and	local10, #127
0a84c     5C C7 02 F6 | 	mov	local17, local10
0a850     35 C9 02 F6 | 	mov	local18, ptr__fatfs_cc_dat__
0a854     01 00 00 FF 
0a858     BB C9 06 F1 | 	add	local18, ##955
0a85c     64 C7 02 F1 | 	add	local17, local18
0a860     63 B7 C2 FA | 	rdbyte	local09, local17
0a864                 | LR__1683
0a864                 | LR__1684
0a864     5B AB 32 F9 | 	getword	local03, local09, #0
0a868     00 AB 16 F2 | 	cmp	local03, #256 wc
0a86c     40 00 90 CD |  if_b	jmp	#LR__1685
0a870     62 AB 02 F6 | 	mov	local03, local16
0a874     01 AA 86 F1 | 	sub	local03, #1
0a878     55 C3 12 F2 | 	cmp	local15, local03 wc
0a87c     5D BB E2 38 |  if_ae	getbyte	local11, local11, #0
0a880     03 BA 46 35 |  if_ae	or	local11, #3
0a884     62 C3 02 36 |  if_ae	mov	local15, local16
0a888                 | ' 				cf |=  0x01  |  0x02 ;
0a888                 | ' 				i = ni; continue;
0a888     E0 FE 9F 3D |  if_ae	jmp	#LR__1679
0a88c     61 C7 02 F6 | 	mov	local17, local15
0a890     53 C9 02 F6 | 	mov	local18, local01
0a894     20 C8 06 F1 | 	add	local18, #32
0a898     64 C7 02 F1 | 	add	local17, local18
0a89c     5B B3 32 F9 | 	getword	local07, local09, #0
0a8a0     08 B2 46 F0 | 	shr	local07, #8
0a8a4     63 B3 42 FC | 	wrbyte	local07, local17
0a8a8     01 C2 06 F1 | 	add	local15, #1
0a8ac     74 00 90 FD | 	jmp	#LR__1691
0a8b0                 | LR__1685
0a8b0     5B AB 02 F6 | 	mov	local03, local09
0a8b4     0F AA 4E F7 | 	zerox	local03, #15 wz
0a8b8     18 00 90 AD |  if_e	jmp	#LR__1686
0a8bc     71 00 00 FF 
0a8c0     2E 91 06 F6 | 	mov	arg01, ##@LR__2169
0a8c4     5B 93 32 F9 | 	getword	arg02, local09, #0
0a8c8     68 D4 BF FD | 	call	#_fatfs_cc_strchr
0a8cc     00 76 0E F2 | 	cmp	result1, #0 wz
0a8d0     10 00 90 AD |  if_e	jmp	#LR__1687
0a8d4                 | LR__1686
0a8d4     5F B6 06 F6 | 	mov	local09, #95
0a8d8     5D BB E2 F8 | 	getbyte	local11, local11, #0
0a8dc     03 BA 46 F5 | 	or	local11, #3
0a8e0     40 00 90 FD | 	jmp	#LR__1690
0a8e4                 | LR__1687
0a8e4     5B AB 32 F9 | 	getword	local03, local09, #0
0a8e8     41 AA 16 F2 | 	cmp	local03, #65 wc
0a8ec     10 00 90 CD |  if_b	jmp	#LR__1688
0a8f0     5B B9 32 F9 | 	getword	local10, local09, #0
0a8f4     5B B8 16 F2 | 	cmp	local10, #91 wc
0a8f8     60 C1 E2 C8 |  if_b	getbyte	local14, local14, #0
0a8fc     02 C0 46 C5 |  if_b	or	local14, #2
0a900                 | LR__1688
0a900     5B AB 32 F9 | 	getword	local03, local09, #0
0a904     61 AA 16 F2 | 	cmp	local03, #97 wc
0a908     18 00 90 CD |  if_b	jmp	#LR__1689
0a90c     5B B9 32 F9 | 	getword	local10, local09, #0
0a910     7B B8 16 F2 | 	cmp	local10, #123 wc
0a914     60 C1 E2 C8 |  if_b	getbyte	local14, local14, #0
0a918     01 C0 46 C5 |  if_b	or	local14, #1
0a91c     5B B7 32 C9 |  if_b	getword	local09, local09, #0
0a920     20 B6 86 C1 |  if_b	sub	local09, #32
0a924                 | LR__1689
0a924                 | LR__1690
0a924                 | LR__1691
0a924     61 C7 02 F6 | 	mov	local17, local15
0a928     53 C9 02 F6 | 	mov	local18, local01
0a92c     20 C8 06 F1 | 	add	local18, #32
0a930     64 C7 02 F1 | 	add	local17, local18
0a934     5B B7 32 F9 | 	getword	local09, local09, #0
0a938     63 B7 42 FC | 	wrbyte	local09, local17
0a93c     01 C2 06 F1 | 	add	local15, #1
0a940     28 FE 9F FD | 	jmp	#LR__1679
0a944                 | LR__1692
0a944     20 A6 06 F1 | 	add	local01, #32
0a948     53 AB C2 FA | 	rdbyte	local03, local01
0a94c     20 A6 86 F1 | 	sub	local01, #32
0a950     E5 AA 0E F2 | 	cmp	local03, #229 wz
0a954     20 A6 06 A1 |  if_e	add	local01, #32
0a958     53 0B 48 AC |  if_e	wrbyte	#5, local01
0a95c     20 A6 86 A1 |  if_e	sub	local01, #32
0a960     08 C4 0E F2 | 	cmp	local16, #8 wz
0a964     60 C1 E2 A8 |  if_e	getbyte	local14, local14, #0
0a968     02 C0 66 A0 |  if_e	shl	local14, #2
0a96c     60 AB E2 F8 | 	getbyte	local03, local14, #0
0a970     0C AA 06 F5 | 	and	local03, #12
0a974     0C AA 0E F2 | 	cmp	local03, #12 wz
0a978     60 B9 02 56 |  if_ne	mov	local10, local14
0a97c     5C B9 E2 58 |  if_ne	getbyte	local10, local10, #0
0a980     03 B8 06 55 |  if_ne	and	local10, #3
0a984     03 B8 0E 52 |  if_ne	cmp	local10, #3 wz
0a988     5D BB E2 A8 |  if_e	getbyte	local11, local11, #0
0a98c     02 BA 46 A5 |  if_e	or	local11, #2
0a990     5D AB E2 F8 | 	getbyte	local03, local11, #0
0a994     02 AA CE F7 | 	test	local03, #2 wz
0a998     20 00 90 5D |  if_ne	jmp	#LR__1693
0a99c     60 AB E2 F8 | 	getbyte	local03, local14, #0
0a9a0     01 AA CE F7 | 	test	local03, #1 wz
0a9a4     5D BB E2 58 |  if_ne	getbyte	local11, local11, #0
0a9a8     10 BA 46 55 |  if_ne	or	local11, #16
0a9ac     60 C1 E2 F8 | 	getbyte	local14, local14, #0
0a9b0     04 C0 CE F7 | 	test	local14, #4 wz
0a9b4     5D BB E2 58 |  if_ne	getbyte	local11, local11, #0
0a9b8     08 BA 46 55 |  if_ne	or	local11, #8
0a9bc                 | LR__1693
0a9bc     2B A6 06 F1 | 	add	local01, #43
0a9c0     53 BB 42 FC | 	wrbyte	local11, local01
0a9c4                 | ' 	}
0a9c4                 | ' 
0a9c4                 | ' 	dp->fn[ 11 ] = cf;
0a9c4                 | ' 
0a9c4                 | ' 	return FR_OK;
0a9c4     00 76 06 F6 | 	mov	result1, #0
0a9c8                 | LR__1694
0a9c8     E7 F0 03 F6 | 	mov	ptra, fp
0a9cc     F2 00 A0 FD | 	call	#popregs_
0a9d0                 | _fatfs_cc_create_name_ret
0a9d0     2D 00 64 FD | 	ret
0a9d4                 | 
0a9d4                 | _fatfs_cc_follow_path
0a9d4     04 CA 05 F6 | 	mov	COUNT_, #4
0a9d8     E8 00 A0 FD | 	call	#pushregs_
0a9dc     18 F0 07 F1 | 	add	ptra, #24
0a9e0     48 A7 02 F6 | 	mov	local01, arg01
0a9e4     08 CE 05 F1 | 	add	fp, #8
0a9e8     E7 92 62 FC | 	wrlong	arg02, fp
0a9ec     08 CE 85 F1 | 	sub	fp, #8
0a9f0     53 A9 02 FB | 	rdlong	local02, local01
0a9f4     D7 24 48 FB | 	callpa	#(@LR__1702-@LR__1700)>>2,fcache_load_ptr_
0a9f8                 | ' )
0a9f8                 | ' {
0a9f8                 | ' 	FRESULT res;
0a9f8                 | ' 	BYTE ns;
0a9f8                 | ' 	FATFS *fs = dp->obj.fs;
0a9f8                 | ' #line 3034 "ff.c"
0a9f8                 | ' 	{
0a9f8                 | ' 		while ( ((*path) == '/' || (*path) == '\\') ) path++;
0a9f8                 | LR__1700
0a9f8     08 CE 05 F1 | 	add	fp, #8
0a9fc     E7 76 02 FB | 	rdlong	result1, fp
0aa00     08 CE 85 F1 | 	sub	fp, #8
0aa04     3B 77 C2 FA | 	rdbyte	result1, result1
0aa08     2F 76 0E F2 | 	cmp	result1, #47 wz
0aa0c     18 00 90 AD |  if_e	jmp	#LR__1701
0aa10     08 CE 05 F1 | 	add	fp, #8
0aa14     E7 76 02 FB | 	rdlong	result1, fp
0aa18     08 CE 85 F1 | 	sub	fp, #8
0aa1c     3B 77 C2 FA | 	rdbyte	result1, result1
0aa20     5C 76 0E F2 | 	cmp	result1, #92 wz
0aa24     18 00 90 5D |  if_ne	jmp	#LR__1703
0aa28                 | LR__1701
0aa28     08 CE 05 F1 | 	add	fp, #8
0aa2c     E7 76 02 FB | 	rdlong	result1, fp
0aa30     01 76 06 F1 | 	add	result1, #1
0aa34     E7 76 62 FC | 	wrlong	result1, fp
0aa38     08 CE 85 F1 | 	sub	fp, #8
0aa3c     B8 FF 9F FD | 	jmp	#LR__1700
0aa40                 | LR__1702
0aa40                 | LR__1703
0aa40     08 A6 06 F1 | 	add	local01, #8
0aa44     53 01 68 FC | 	wrlong	#0, local01
0aa48     08 A6 86 F1 | 	sub	local01, #8
0aa4c     08 CE 05 F1 | 	add	fp, #8
0aa50     E7 92 02 FB | 	rdlong	arg02, fp
0aa54     08 CE 85 F1 | 	sub	fp, #8
0aa58     49 93 C2 FA | 	rdbyte	arg02, arg02
0aa5c     20 92 16 F2 | 	cmp	arg02, #32 wc
0aa60     20 00 90 3D |  if_ae	jmp	#LR__1704
0aa64     2B A6 06 F1 | 	add	local01, #43
0aa68     53 01 49 FC | 	wrbyte	#128, local01
0aa6c     2B A6 86 F1 | 	sub	local01, #43
0aa70     53 91 02 F6 | 	mov	arg01, local01
0aa74     00 92 06 F6 | 	mov	arg02, #0
0aa78     9C E6 BF FD | 	call	#_fatfs_cc_dir_sdi
0aa7c     3B AB 02 F6 | 	mov	local03, result1
0aa80     A0 00 90 FD | 	jmp	#LR__1708
0aa84                 | LR__1704
0aa84                 | ' 		for (;;) {
0aa84                 | LR__1705
0aa84     E7 92 02 F6 | 	mov	arg02, fp
0aa88     08 92 06 F1 | 	add	arg02, #8
0aa8c     53 91 02 F6 | 	mov	arg01, local01
0aa90     5C FA BF FD | 	call	#_fatfs_cc_create_name
0aa94     3B AB 0A F6 | 	mov	local03, result1 wz
0aa98     88 00 90 5D |  if_ne	jmp	#LR__1707
0aa9c     53 91 02 F6 | 	mov	arg01, local01
0aaa0     0C F1 BF FD | 	call	#_fatfs_cc_dir_find
0aaa4     3B AB 0A F6 | 	mov	local03, result1 wz
0aaa8     2B A6 06 F1 | 	add	local01, #43
0aaac     53 AD C2 FA | 	rdbyte	local04, local01
0aab0     2B A6 86 F1 | 	sub	local01, #43
0aab4     18 00 90 AD |  if_e	jmp	#LR__1706
0aab8     04 AA 0E F2 | 	cmp	local03, #4 wz
0aabc     64 00 90 5D |  if_ne	jmp	#LR__1707
0aac0     56 AD E2 F8 | 	getbyte	local04, local04, #0
0aac4     04 AC CE F7 | 	test	local04, #4 wz
0aac8     05 AA 06 A6 |  if_e	mov	local03, #5
0aacc                 | ' 					}
0aacc                 | ' 				}
0aacc                 | ' 				break;
0aacc     54 00 90 FD | 	jmp	#LR__1707
0aad0                 | LR__1706
0aad0     56 AD E2 F8 | 	getbyte	local04, local04, #0
0aad4     04 AC CE F7 | 	test	local04, #4 wz
0aad8     48 00 90 5D |  if_ne	jmp	#LR__1707
0aadc     06 A6 06 F1 | 	add	local01, #6
0aae0     53 AD C2 FA | 	rdbyte	local04, local01
0aae4     06 A6 86 F1 | 	sub	local01, #6
0aae8     10 AC CE F7 | 	test	local04, #16 wz
0aaec     05 AA 06 A6 |  if_e	mov	local03, #5
0aaf0                 | ' 				res = FR_NO_PATH; break;
0aaf0     30 00 90 AD |  if_e	jmp	#LR__1707
0aaf4     54 91 02 F6 | 	mov	arg01, local02
0aaf8     54 93 02 F6 | 	mov	arg02, local02
0aafc     34 92 06 F1 | 	add	arg02, #52
0ab00     10 A6 06 F1 | 	add	local01, #16
0ab04     53 AD 02 FB | 	rdlong	local04, local01
0ab08     FF AD 06 F5 | 	and	local04, #511
0ab0c     56 93 02 F1 | 	add	arg02, local04
0ab10     D8 E9 BF FD | 	call	#_fatfs_cc_ld_clust
0ab14     08 A6 86 F1 | 	sub	local01, #8
0ab18     53 77 62 FC | 	wrlong	result1, local01
0ab1c     08 A6 86 F1 | 	sub	local01, #8
0ab20     60 FF 9F FD | 	jmp	#LR__1705
0ab24                 | LR__1707
0ab24                 | LR__1708
0ab24                 | ' 			}
0ab24                 | ' #line 3090 "ff.c"
0ab24                 | ' 			{
0ab24                 | ' 				dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr %  ((UINT) 512 ) );
0ab24                 | ' 			}
0ab24                 | ' 		}
0ab24                 | ' 	}
0ab24                 | ' 
0ab24                 | ' 	return res;
0ab24     55 77 02 F6 | 	mov	result1, local03
0ab28     E7 F0 03 F6 | 	mov	ptra, fp
0ab2c     F2 00 A0 FD | 	call	#popregs_
0ab30                 | _fatfs_cc_follow_path_ret
0ab30     2D 00 64 FD | 	ret
0ab34                 | 
0ab34                 | _fatfs_cc_get_ldnumber
0ab34     01 7C 66 F6 | 	neg	_var01, #1
0ab38     48 7F 0A FB | 	rdlong	_var02, arg01 wz
0ab3c     3F 81 02 F6 | 	mov	_var03, _var02
0ab40     01 76 66 A6 |  if_e	neg	result1, #1
0ab44     74 00 90 AD |  if_e	jmp	#_fatfs_cc_get_ldnumber_ret
0ab48     D7 10 48 FB | 	callpa	#(@LR__1711-@LR__1710)>>2,fcache_load_ptr_
0ab4c                 | ' 	do tc = *tt++; while (! ((UINT)(tc) < ( 1 ? ' ' : '!'))  && tc != ':');
0ab4c                 | LR__1710
0ab4c     40 83 C2 FA | 	rdbyte	_var04, _var03
0ab50     41 77 E2 F8 | 	getbyte	result1, _var04, #0
0ab54     20 76 16 F2 | 	cmp	result1, #32 wc
0ab58     01 80 06 F1 | 	add	_var03, #1
0ab5c     41 85 02 36 |  if_ae	mov	_var05, _var04
0ab60     42 85 E2 38 |  if_ae	getbyte	_var05, _var05, #0
0ab64     3A 84 0E 32 |  if_ae	cmp	_var05, #58 wz
0ab68     E0 FF 9F 1D |  if_a	jmp	#LR__1710
0ab6c                 | LR__1711
0ab6c     41 83 E2 F8 | 	getbyte	_var04, _var04, #0
0ab70     3A 82 0E F2 | 	cmp	_var04, #58 wz
0ab74     40 00 90 5D |  if_ne	jmp	#LR__1713
0ab78     01 86 06 F6 | 	mov	_var06, #1
0ab7c     3F 85 C2 FA | 	rdbyte	_var05, _var02
0ab80     30 84 16 F2 | 	cmp	_var05, #48 wc
0ab84     1C 00 90 CD |  if_b	jmp	#LR__1712
0ab88     3F 85 C2 FA | 	rdbyte	_var05, _var02
0ab8c     3A 84 16 F2 | 	cmp	_var05, #58 wc
0ab90     3F 89 02 C6 |  if_b	mov	_var07, _var02
0ab94     02 88 06 C1 |  if_b	add	_var07, #2
0ab98     40 89 0A C2 |  if_b	cmp	_var07, _var03 wz
0ab9c     42 87 02 86 |  if_c_and_z	mov	_var06, _var05
0aba0     30 86 86 81 |  if_c_and_z	sub	_var06, #48
0aba4                 | LR__1712
0aba4     01 86 56 F2 | 	cmps	_var06, #1 wc
0aba8     43 7D 02 C6 |  if_b	mov	_var01, _var06
0abac     48 81 62 CC |  if_b	wrlong	_var03, arg01
0abb0                 | ' 			vol = i;
0abb0                 | ' 			*path = tt;
0abb0                 | ' 		}
0abb0                 | ' 		return vol;
0abb0     3E 77 02 F6 | 	mov	result1, _var01
0abb4     04 00 90 FD | 	jmp	#_fatfs_cc_get_ldnumber_ret
0abb8                 | LR__1713
0abb8                 | ' 	}
0abb8                 | ' #line 3170 "ff.c"
0abb8                 | ' 	vol = 0;
0abb8                 | ' 
0abb8                 | ' 	return vol;
0abb8     00 76 06 F6 | 	mov	result1, #0
0abbc                 | _fatfs_cc_get_ldnumber_ret
0abbc     2D 00 64 FD | 	ret
0abc0                 | 
0abc0                 | _fatfs_cc_check_fs
0abc0     04 CA 05 F6 | 	mov	COUNT_, #4
0abc4     E8 00 A0 FD | 	call	#pushregs_
0abc8     48 A7 02 F6 | 	mov	local01, arg01
0abcc     03 A6 06 F1 | 	add	local01, #3
0abd0     53 01 48 FC | 	wrbyte	#0, local01
0abd4     2D A6 06 F1 | 	add	local01, #45
0abd8     FF FF FF FF 
0abdc     53 FF 6B FC | 	wrlong	##-1, local01
0abe0     30 A6 86 F1 | 	sub	local01, #48
0abe4     53 91 02 F6 | 	mov	arg01, local01
0abe8     C8 DB BF FD | 	call	#_fatfs_cc_move_window
0abec     00 76 0E F2 | 	cmp	result1, #0 wz
0abf0     04 76 06 56 |  if_ne	mov	result1, #4
0abf4     64 01 90 5D |  if_ne	jmp	#LR__1723
0abf8     34 A6 06 F1 | 	add	local01, #52
0abfc     53 91 02 F6 | 	mov	arg01, local01
0ac00     FE 91 06 F1 | 	add	arg01, #510
0ac04                 | ' {
0ac04                 | ' 
0ac04                 | ' 	return *((WORD*)ptr);
0ac04     48 A9 E2 FA | 	rdword	local02, arg01
0ac08     53 AB C2 FA | 	rdbyte	local03, local01
0ac0c     34 A6 86 F1 | 	sub	local01, #52
0ac10     55 AD E2 F8 | 	getbyte	local04, local03, #0
0ac14     EB AC 0E F2 | 	cmp	local04, #235 wz
0ac18     55 95 02 56 |  if_ne	mov	arg03, local03
0ac1c     4A 95 E2 58 |  if_ne	getbyte	arg03, arg03, #0
0ac20     E9 94 0E 52 |  if_ne	cmp	arg03, #233 wz
0ac24     55 AB E2 58 |  if_ne	getbyte	local03, local03, #0
0ac28     E8 AA 0E 52 |  if_ne	cmp	local03, #232 wz
0ac2c     14 01 90 5D |  if_ne	jmp	#LR__1722
0ac30     54 AD 32 F9 | 	getword	local04, local02, #0
0ac34     55 00 00 FF 
0ac38     55 AC 0E F2 | 	cmp	local04, ##43605 wz
0ac3c     24 00 90 5D |  if_ne	jmp	#LR__1720
0ac40     53 91 02 F6 | 	mov	arg01, local01
0ac44     86 90 06 F1 | 	add	arg01, #134
0ac48     71 00 00 FF 
0ac4c     35 93 06 F6 | 	mov	arg02, ##@LR__2170
0ac50     08 94 06 F6 | 	mov	arg03, #8
0ac54     10 D0 BF FD | 	call	#_fatfs_cc_memcmp
0ac58     00 76 0E F2 | 	cmp	result1, #0 wz
0ac5c                 | ' 			return 0;
0ac5c     00 76 06 A6 |  if_e	mov	result1, #0
0ac60     F8 00 90 AD |  if_e	jmp	#LR__1723
0ac64                 | LR__1720
0ac64     34 A6 06 F1 | 	add	local01, #52
0ac68     53 91 02 F6 | 	mov	arg01, local01
0ac6c     0B 90 06 F1 | 	add	arg01, #11
0ac70                 | ' {
0ac70                 | ' 
0ac70                 | ' 	return *((WORD*)ptr);
0ac70     48 77 E2 FA | 	rdword	result1, arg01
0ac74     0D A6 06 F1 | 	add	local01, #13
0ac78     53 AB C2 FA | 	rdbyte	local03, local01
0ac7c     41 A6 86 F1 | 	sub	local01, #65
0ac80     3B AD 32 F9 | 	getword	local04, result1, #0
0ac84     3B 93 32 F9 | 	getword	arg02, result1, #0
0ac88     01 92 86 F1 | 	sub	arg02, #1
0ac8c     49 AD CA F7 | 	test	local04, arg02 wz
0ac90     B0 00 90 5D |  if_ne	jmp	#LR__1721
0ac94     3B 93 32 F9 | 	getword	arg02, result1, #0
0ac98     01 00 00 FF 
0ac9c     00 92 16 F2 | 	cmp	arg02, ##512 wc
0aca0     A0 00 90 CD |  if_b	jmp	#LR__1721
0aca4     3B 93 32 F9 | 	getword	arg02, result1, #0
0aca8     01 00 00 FF 
0acac     01 92 16 F2 | 	cmp	arg02, ##513 wc
0acb0     90 00 90 3D |  if_ae	jmp	#LR__1721
0acb4     55 91 02 F6 | 	mov	arg01, local03
0acb8     07 90 4E F7 | 	zerox	arg01, #7 wz
0acbc     84 00 90 AD |  if_e	jmp	#LR__1721
0acc0     55 91 E2 F8 | 	getbyte	arg01, local03, #0
0acc4     55 AB E2 F8 | 	getbyte	local03, local03, #0
0acc8     01 AA 86 F1 | 	sub	local03, #1
0accc     55 91 CA F7 | 	test	arg01, local03 wz
0acd0     70 00 90 5D |  if_ne	jmp	#LR__1721
0acd4     53 91 02 F6 | 	mov	arg01, local01
0acd8     42 90 06 F1 | 	add	arg01, #66
0acdc                 | ' {
0acdc                 | ' 
0acdc                 | ' 	return *((WORD*)ptr);
0acdc     48 77 EA FA | 	rdword	result1, arg01 wz
0ace0     60 00 90 AD |  if_e	jmp	#LR__1721
0ace4     44 A6 06 F1 | 	add	local01, #68
0ace8     53 91 C2 FA | 	rdbyte	arg01, local01
0acec     44 A6 86 F1 | 	sub	local01, #68
0acf0     01 90 86 F1 | 	sub	arg01, #1
0acf4     02 90 16 F2 | 	cmp	arg01, #2 wc
0acf8     48 00 90 3D |  if_ae	jmp	#LR__1721
0acfc     53 91 02 F6 | 	mov	arg01, local01
0ad00     45 90 06 F1 | 	add	arg01, #69
0ad04                 | ' {
0ad04                 | ' 
0ad04                 | ' 	return *((WORD*)ptr);
0ad04     48 77 EA FA | 	rdword	result1, arg01 wz
0ad08     38 00 90 AD |  if_e	jmp	#LR__1721
0ad0c     53 91 02 F6 | 	mov	arg01, local01
0ad10     47 90 06 F1 | 	add	arg01, #71
0ad14                 | ' {
0ad14                 | ' 
0ad14                 | ' 	return *((WORD*)ptr);
0ad14     48 77 E2 FA | 	rdword	result1, arg01
0ad18     3B AB 32 F9 | 	getword	local03, result1, #0
0ad1c     80 AA 16 F2 | 	cmp	local03, #128 wc
0ad20     53 91 02 C6 |  if_b	mov	arg01, local01
0ad24     54 90 06 C1 |  if_b	add	arg01, #84
0ad28                 | ' {
0ad28                 | ' 
0ad28                 | ' 	return *((DWORD*)ptr);
0ad28     48 77 02 CB |  if_b	rdlong	result1, arg01
0ad2c     80 00 00 CF 
0ad30     00 76 16 C2 |  if_b	cmp	result1, ##65536 wc
0ad34     4A A6 06 31 |  if_ae	add	local01, #74
0ad38                 | ' {
0ad38                 | ' 
0ad38                 | ' 	return *((WORD*)ptr);
0ad38     53 77 EA 3A |  if_ae	rdword	result1, local01 wz
0ad3c                 | ' 			&& b != 0 && (b & (b - 1)) == 0
0ad3c                 | ' 			&& ld_word(fs->win +  14 ) != 0
0ad3c                 | ' 			&& (UINT)fs->win[ 16 ] - 1 <= 1
0ad3c                 | ' 			&& ld_word(fs->win +  17 ) != 0
0ad3c                 | ' 			&& (ld_word(fs->win +  19 ) >= 128 || ld_dword(fs->win +  32 ) >= 0x10000)
0ad3c                 | ' 			&& ld_word(fs->win +  22 ) != 0) {
0ad3c                 | ' 				return 0;
0ad3c     00 76 06 16 |  if_a	mov	result1, #0
0ad40     18 00 90 1D |  if_a	jmp	#LR__1723
0ad44                 | LR__1721
0ad44                 | LR__1722
0ad44                 | ' 		}
0ad44                 | ' 	}
0ad44                 | ' 	return sign == 0xAA55 ? 2 : 3;
0ad44     54 AB 32 F9 | 	getword	local03, local02, #0
0ad48     55 00 00 FF 
0ad4c     55 AA 0E F2 | 	cmp	local03, ##43605 wz
0ad50     02 AC 06 A6 |  if_e	mov	local04, #2
0ad54     03 AC 06 56 |  if_ne	mov	local04, #3
0ad58     56 77 02 F6 | 	mov	result1, local04
0ad5c                 | LR__1723
0ad5c     E7 F0 03 F6 | 	mov	ptra, fp
0ad60     F2 00 A0 FD | 	call	#popregs_
0ad64                 | _fatfs_cc_check_fs_ret
0ad64     2D 00 64 FD | 	ret
0ad68                 | 
0ad68                 | _fatfs_cc_find_volume
0ad68     05 CA 05 F6 | 	mov	COUNT_, #5
0ad6c     E8 00 A0 FD | 	call	#pushregs_
0ad70     24 F0 07 F1 | 	add	ptra, #36
0ad74     48 A7 02 F6 | 	mov	local01, arg01
0ad78     49 A9 02 F6 | 	mov	local02, arg02
0ad7c     53 91 02 F6 | 	mov	arg01, local01
0ad80     00 92 06 F6 | 	mov	arg02, #0
0ad84     38 FE BF FD | 	call	#_fatfs_cc_check_fs
0ad88     02 76 0E F2 | 	cmp	result1, #2 wz
0ad8c     0C 00 90 AD |  if_e	jmp	#LR__1730
0ad90     03 76 16 F2 | 	cmp	result1, #3 wc
0ad94     00 A8 0E C2 |  if_b	cmp	local02, #0 wz
0ad98     C8 00 90 BD |  if_nc_or_z	jmp	#LR__1738
0ad9c                 | LR__1730
0ad9c                 | ' 	for (i = 0; i < 4; i++) {
0ad9c     00 AA 06 F6 | 	mov	local03, #0
0ada0     D7 22 48 FB | 	callpa	#(@LR__1732-@LR__1731)>>2,fcache_load_ptr_
0ada4                 | LR__1731
0ada4     04 AA 16 F2 | 	cmp	local03, #4 wc
0ada8     3C 00 90 3D |  if_ae	jmp	#LR__1733
0adac     55 AD 02 F6 | 	mov	local04, local03
0adb0     02 AC 66 F0 | 	shl	local04, #2
0adb4     E7 92 02 F6 | 	mov	arg02, fp
0adb8     14 92 06 F1 | 	add	arg02, #20
0adbc     49 AD 02 F1 | 	add	local04, arg02
0adc0     53 91 02 F6 | 	mov	arg01, local01
0adc4     F2 91 06 F1 | 	add	arg01, #498
0adc8     55 93 02 F6 | 	mov	arg02, local03
0adcc     04 92 66 F0 | 	shl	arg02, #4
0add0     49 91 02 F1 | 	add	arg01, arg02
0add4     08 90 06 F1 | 	add	arg01, #8
0add8                 | ' {
0add8                 | ' 
0add8                 | ' 	return *((DWORD*)ptr);
0add8     48 77 02 FB | 	rdlong	result1, arg01
0addc     56 77 62 FC | 	wrlong	result1, local04
0ade0     01 AA 06 F1 | 	add	local03, #1
0ade4     BC FF 9F FD | 	jmp	#LR__1731
0ade8                 | LR__1732
0ade8                 | LR__1733
0ade8     00 A8 0E F2 | 	cmp	local02, #0 wz
0adec     54 AD 02 56 |  if_ne	mov	local04, local02
0adf0     01 AC 86 51 |  if_ne	sub	local04, #1
0adf4     00 AC 06 A6 |  if_e	mov	local04, #0
0adf8     56 AB 02 F6 | 	mov	local03, local04
0adfc                 | ' 		mbr_pt[i] = ld_dword(fs->win +  446  + i *  16  +  8 );
0adfc                 | ' 	}
0adfc                 | ' 	i = part ? part - 1 : 0;
0adfc                 | ' 	do {
0adfc                 | LR__1734
0adfc     55 AD 02 F6 | 	mov	local04, local03
0ae00     02 AC 66 F0 | 	shl	local04, #2
0ae04     E7 92 02 F6 | 	mov	arg02, fp
0ae08     14 92 06 F1 | 	add	arg02, #20
0ae0c     49 AD 02 F1 | 	add	local04, arg02
0ae10     56 AD 0A FB | 	rdlong	local04, local04 wz
0ae14     28 00 90 AD |  if_e	jmp	#LR__1735
0ae18     55 AD 02 F6 | 	mov	local04, local03
0ae1c     02 AC 66 F0 | 	shl	local04, #2
0ae20     E7 92 02 F6 | 	mov	arg02, fp
0ae24     14 92 06 F1 | 	add	arg02, #20
0ae28     49 AD 02 F1 | 	add	local04, arg02
0ae2c     56 93 02 FB | 	rdlong	arg02, local04
0ae30     53 91 02 F6 | 	mov	arg01, local01
0ae34     88 FD BF FD | 	call	#_fatfs_cc_check_fs
0ae38     3B AD 02 F6 | 	mov	local04, result1
0ae3c     04 00 90 FD | 	jmp	#LR__1736
0ae40                 | LR__1735
0ae40     03 AC 06 F6 | 	mov	local04, #3
0ae44                 | LR__1736
0ae44     56 AF 02 F6 | 	mov	local05, local04
0ae48     00 A8 0E F2 | 	cmp	local02, #0 wz
0ae4c     02 AE 16 A2 |  if_e	cmp	local05, #2 wc
0ae50     0C 00 90 8D |  if_c_and_z	jmp	#LR__1737
0ae54     01 AA 06 A1 |  if_e	add	local03, #1
0ae58     04 AA 16 A2 |  if_e	cmp	local03, #4 wc
0ae5c     9C FF 9F 8D |  if_c_and_z	jmp	#LR__1734
0ae60                 | LR__1737
0ae60                 | ' 	return fmt;
0ae60     57 77 02 F6 | 	mov	result1, local05
0ae64                 | LR__1738
0ae64     E7 F0 03 F6 | 	mov	ptra, fp
0ae68     F2 00 A0 FD | 	call	#popregs_
0ae6c                 | _fatfs_cc_find_volume_ret
0ae6c     2D 00 64 FD | 	ret
0ae70                 | 
0ae70                 | _fatfs_cc_mount_volume
0ae70     0A CA 05 F6 | 	mov	COUNT_, #10
0ae74     E8 00 A0 FD | 	call	#pushregs_
0ae78     4A A7 02 F6 | 	mov	local01, arg03
0ae7c     49 01 68 FC | 	wrlong	#0, arg02
0ae80     B0 FC BF FD | 	call	#_fatfs_cc_get_ldnumber
0ae84     3B A9 02 F6 | 	mov	local02, result1
0ae88     00 A8 56 F2 | 	cmps	local02, #0 wc
0ae8c     0B 76 06 C6 |  if_b	mov	result1, #11
0ae90     00 05 90 CD |  if_b	jmp	#LR__1749
0ae94     54 95 02 F6 | 	mov	arg03, local02
0ae98     02 94 66 F0 | 	shl	arg03, #2
0ae9c     31 95 02 F1 | 	add	arg03, objptr
0aea0     4A AB 0A FB | 	rdlong	local03, arg03 wz
0aea4     0C 76 06 A6 |  if_e	mov	result1, #12
0aea8     E8 04 90 AD |  if_e	jmp	#LR__1749
0aeac     49 AB 62 FC | 	wrlong	local03, arg02
0aeb0     53 A7 E2 F8 | 	getbyte	local01, local01, #0
0aeb4     FE A6 06 F5 | 	and	local01, #254
0aeb8     55 95 CA FA | 	rdbyte	arg03, local03 wz
0aebc     44 00 90 AD |  if_e	jmp	#LR__1741
0aec0     01 00 00 FF 
0aec4     10 62 06 F1 | 	add	objptr, ##528
0aec8     31 91 0A FB | 	rdlong	arg01, objptr wz
0aecc     01 00 00 FF 
0aed0     10 62 86 F1 | 	sub	objptr, ##528
0aed4                 | '         return RES_NOTRDY;
0aed4     03 76 06 A6 |  if_e	mov	result1, #3
0aed8                 | '     }
0aed8                 | '     return RES_OK;
0aed8     00 76 06 56 |  if_ne	mov	result1, #0
0aedc     3B 95 E2 F8 | 	getbyte	arg03, result1, #0
0aee0     01 94 CE F7 | 	test	arg03, #1 wz
0aee4     1C 00 90 5D |  if_ne	jmp	#LR__1740
0aee8     00 A6 0E F2 | 	cmp	local01, #0 wz
0aeec     3B 77 E2 58 |  if_ne	getbyte	result1, result1, #0
0aef0     04 76 CE 57 |  if_ne	test	result1, #4 wz
0aef4                 | ' 				return FR_WRITE_PROTECTED;
0aef4     0A 76 06 56 |  if_ne	mov	result1, #10
0aef8     98 04 90 5D |  if_ne	jmp	#LR__1749
0aefc                 | ' 			}
0aefc                 | ' 			return FR_OK;
0aefc     00 76 06 F6 | 	mov	result1, #0
0af00     90 04 90 FD | 	jmp	#LR__1749
0af04                 | LR__1740
0af04                 | LR__1741
0af04     55 01 48 FC | 	wrbyte	#0, local03
0af08     01 AA 06 F1 | 	add	local03, #1
0af0c     55 A9 42 FC | 	wrbyte	local02, local03
0af10     01 AA 86 F1 | 	sub	local03, #1
0af14     01 00 00 FF 
0af18     10 62 06 F1 | 	add	objptr, ##528
0af1c     31 A9 0A FB | 	rdlong	local02, objptr wz
0af20     01 00 00 FF 
0af24     10 62 86 F1 | 	sub	objptr, ##528
0af28                 | ' 
0af28                 | '         return RES_NOTRDY;
0af28     03 76 06 A6 |  if_e	mov	result1, #3
0af2c                 | '     }
0af2c                 | '     return RES_OK;
0af2c     00 76 06 56 |  if_ne	mov	result1, #0
0af30     3B 95 02 F6 | 	mov	arg03, result1
0af34     4A AD E2 F8 | 	getbyte	local04, arg03, #0
0af38     01 AC CE F7 | 	test	local04, #1 wz
0af3c                 | ' 		return FR_NOT_READY;
0af3c     03 76 06 56 |  if_ne	mov	result1, #3
0af40     50 04 90 5D |  if_ne	jmp	#LR__1749
0af44     00 A6 0E F2 | 	cmp	local01, #0 wz
0af48     4A AD 02 56 |  if_ne	mov	local04, arg03
0af4c     56 AD E2 58 |  if_ne	getbyte	local04, local04, #0
0af50     04 AC CE 57 |  if_ne	test	local04, #4 wz
0af54                 | ' 		return FR_WRITE_PROTECTED;
0af54     0A 76 06 56 |  if_ne	mov	result1, #10
0af58     38 04 90 5D |  if_ne	jmp	#LR__1749
0af5c     55 91 02 F6 | 	mov	arg01, local03
0af60     00 92 06 F6 | 	mov	arg02, #0
0af64     00 FE BF FD | 	call	#_fatfs_cc_find_volume
0af68     3B 91 02 F6 | 	mov	arg01, result1
0af6c     04 90 0E F2 | 	cmp	arg01, #4 wz
0af70     01 76 06 A6 |  if_e	mov	result1, #1
0af74     1C 04 90 AD |  if_e	jmp	#LR__1749
0af78     02 90 16 F2 | 	cmp	arg01, #2 wc
0af7c     0D 76 06 36 |  if_ae	mov	result1, #13
0af80     10 04 90 3D |  if_ae	jmp	#LR__1749
0af84     30 AA 06 F1 | 	add	local03, #48
0af88     55 AF 02 FB | 	rdlong	local05, local03
0af8c     04 AA 06 F1 | 	add	local03, #4
0af90     55 91 02 F6 | 	mov	arg01, local03
0af94     34 AA 86 F1 | 	sub	local03, #52
0af98     0B 90 06 F1 | 	add	arg01, #11
0af9c                 | ' {
0af9c                 | ' 
0af9c                 | ' 	return *((WORD*)ptr);
0af9c     48 77 E2 FA | 	rdword	result1, arg01
0afa0     01 00 00 FF 
0afa4     00 76 0E F2 | 	cmp	result1, ##512 wz
0afa8     0D 76 06 56 |  if_ne	mov	result1, #13
0afac     E4 03 90 5D |  if_ne	jmp	#LR__1749
0afb0     55 91 02 F6 | 	mov	arg01, local03
0afb4     4A 90 06 F1 | 	add	arg01, #74
0afb8                 | ' {
0afb8                 | ' 
0afb8                 | ' 	return *((WORD*)ptr);
0afb8     48 77 E2 FA | 	rdword	result1, arg01
0afbc     3B B1 0A F6 | 	mov	local06, result1 wz
0afc0     55 91 02 A6 |  if_e	mov	arg01, local03
0afc4     58 90 06 A1 |  if_e	add	arg01, #88
0afc8                 | ' {
0afc8                 | ' 
0afc8                 | ' 	return *((DWORD*)ptr);
0afc8     48 77 02 AB |  if_e	rdlong	result1, arg01
0afcc     3B B1 02 A6 |  if_e	mov	local06, result1
0afd0     1C AA 06 F1 | 	add	local03, #28
0afd4     55 B1 62 FC | 	wrlong	local06, local03
0afd8     28 AA 06 F1 | 	add	local03, #40
0afdc     55 AD C2 FA | 	rdbyte	local04, local03
0afe0     42 AA 86 F1 | 	sub	local03, #66
0afe4     55 AD 42 FC | 	wrbyte	local04, local03
0afe8     56 AD E2 F8 | 	getbyte	local04, local04, #0
0afec     02 AA 86 F1 | 	sub	local03, #2
0aff0     01 AC 0E F2 | 	cmp	local04, #1 wz
0aff4     02 AA 06 51 |  if_ne	add	local03, #2
0aff8     55 AD C2 5A |  if_ne	rdbyte	local04, local03
0affc     02 AA 86 51 |  if_ne	sub	local03, #2
0b000     02 AC 0E 52 |  if_ne	cmp	local04, #2 wz
0b004     0D 76 06 56 |  if_ne	mov	result1, #13
0b008     88 03 90 5D |  if_ne	jmp	#LR__1749
0b00c     02 AA 06 F1 | 	add	local03, #2
0b010     55 AD C2 FA | 	rdbyte	local04, local03
0b014     56 B1 02 FD | 	qmul	local06, local04
0b018     3F AA 06 F1 | 	add	local03, #63
0b01c     55 AD C2 FA | 	rdbyte	local04, local03
0b020     37 AA 86 F1 | 	sub	local03, #55
0b024     55 AD 52 FC | 	wrword	local04, local03
0b028     56 AD 32 F9 | 	getword	local04, local04, #0
0b02c     0A AA 86 F1 | 	sub	local03, #10
0b030     0F AC 4E F7 | 	zerox	local04, #15 wz
0b034     18 B0 62 FD | 	getqx	local06
0b038     20 00 90 AD |  if_e	jmp	#LR__1742
0b03c     0A AA 06 F1 | 	add	local03, #10
0b040     55 AD E2 FA | 	rdword	local04, local03
0b044     56 A9 32 F9 | 	getword	local02, local04, #0
0b048     0A AA 86 F1 | 	sub	local03, #10
0b04c     56 AD 32 F9 | 	getword	local04, local04, #0
0b050     01 AC 86 F1 | 	sub	local04, #1
0b054     56 A9 CA F7 | 	test	local02, local04 wz
0b058     08 00 90 AD |  if_e	jmp	#LR__1743
0b05c                 | LR__1742
0b05c     0D 76 06 F6 | 	mov	result1, #13
0b060     30 03 90 FD | 	jmp	#LR__1749
0b064                 | LR__1743
0b064     34 AA 06 F1 | 	add	local03, #52
0b068     55 91 02 F6 | 	mov	arg01, local03
0b06c     11 90 06 F1 | 	add	arg01, #17
0b070                 | ' {
0b070                 | ' 
0b070                 | ' 	return *((WORD*)ptr);
0b070     48 77 E2 FA | 	rdword	result1, arg01
0b074     2C AA 86 F1 | 	sub	local03, #44
0b078     55 77 52 FC | 	wrword	result1, local03
0b07c     3B AD 32 F9 | 	getword	local04, result1, #0
0b080     08 AA 86 F1 | 	sub	local03, #8
0b084     56 91 52 F6 | 	abs	arg01, local04 wc
0b088     48 91 42 F8 | 	getnib	arg01, arg01, #0
0b08c     48 91 8A F6 | 	negc	arg01, arg01 wz
0b090     0D 76 06 56 |  if_ne	mov	result1, #13
0b094     FC 02 90 5D |  if_ne	jmp	#LR__1749
0b098     55 91 02 F6 | 	mov	arg01, local03
0b09c     47 90 06 F1 | 	add	arg01, #71
0b0a0                 | ' {
0b0a0                 | ' 
0b0a0                 | ' 	return *((WORD*)ptr);
0b0a0     48 77 E2 FA | 	rdword	result1, arg01
0b0a4     3B B3 0A F6 | 	mov	local07, result1 wz
0b0a8     55 91 02 A6 |  if_e	mov	arg01, local03
0b0ac     54 90 06 A1 |  if_e	add	arg01, #84
0b0b0                 | ' {
0b0b0                 | ' 
0b0b0                 | ' 	return *((DWORD*)ptr);
0b0b0     48 B3 02 AB |  if_e	rdlong	local07, arg01
0b0b4     55 91 02 F6 | 	mov	arg01, local03
0b0b8     42 90 06 F1 | 	add	arg01, #66
0b0bc                 | ' {
0b0bc                 | ' 
0b0bc                 | ' 	return *((WORD*)ptr);
0b0bc     48 77 E2 FA | 	rdword	result1, arg01
0b0c0     3B 91 02 F6 | 	mov	arg01, result1
0b0c4     48 AD 02 F6 | 	mov	local04, arg01
0b0c8     0F AC 4E F7 | 	zerox	local04, #15 wz
0b0cc     0D 76 06 A6 |  if_e	mov	result1, #13
0b0d0     C0 02 90 AD |  if_e	jmp	#LR__1749
0b0d4     48 B5 32 F9 | 	getword	local08, arg01, #0
0b0d8     58 B5 02 F1 | 	add	local08, local06
0b0dc     08 AA 06 F1 | 	add	local03, #8
0b0e0     55 AD E2 FA | 	rdword	local04, local03
0b0e4     08 AA 86 F1 | 	sub	local03, #8
0b0e8     56 AD 52 F6 | 	abs	local04, local04 wc
0b0ec     04 AC 46 F0 | 	shr	local04, #4
0b0f0     56 B5 82 F3 | 	sumc	local08, local04
0b0f4     5A B3 12 F2 | 	cmp	local07, local08 wc
0b0f8     0D 76 06 C6 |  if_b	mov	result1, #13
0b0fc     94 02 90 CD |  if_b	jmp	#LR__1749
0b100     5A B3 82 F1 | 	sub	local07, local08
0b104     0A AA 06 F1 | 	add	local03, #10
0b108     55 AD E2 FA | 	rdword	local04, local03
0b10c     56 B3 12 FD | 	qdiv	local07, local04
0b110     0A AA 86 F1 | 	sub	local03, #10
0b114     18 AC 62 FD | 	getqx	local04
0b118     00 AC 0E F2 | 	cmp	local04, #0 wz
0b11c     0D 76 06 A6 |  if_e	mov	result1, #13
0b120     70 02 90 AD |  if_e	jmp	#LR__1749
0b124     00 B6 06 F6 | 	mov	local09, #0
0b128     FF FF 07 FF 
0b12c     F6 AD 16 F2 | 	cmp	local04, ##268435446 wc
0b130     03 B6 06 C6 |  if_b	mov	local09, #3
0b134     7F 00 00 FF 
0b138     F6 AD 16 F2 | 	cmp	local04, ##65526 wc
0b13c     02 B6 06 C6 |  if_b	mov	local09, #2
0b140     07 00 00 FF 
0b144     F6 AD 16 F2 | 	cmp	local04, ##4086 wc
0b148     01 B6 06 C6 |  if_b	mov	local09, #1
0b14c     00 B6 0E F2 | 	cmp	local09, #0 wz
0b150     0D 76 06 A6 |  if_e	mov	result1, #13
0b154     3C 02 90 AD |  if_e	jmp	#LR__1749
0b158     02 AC 06 F1 | 	add	local04, #2
0b15c     18 AA 06 F1 | 	add	local03, #24
0b160     55 AD 62 FC | 	wrlong	local04, local03
0b164     08 AA 06 F1 | 	add	local03, #8
0b168     55 AF 62 FC | 	wrlong	local05, local03
0b16c     57 AD 02 F6 | 	mov	local04, local05
0b170     48 91 32 F9 | 	getword	arg01, arg01, #0
0b174     48 AD 02 F1 | 	add	local04, arg01
0b178     04 AA 06 F1 | 	add	local03, #4
0b17c     55 AD 62 FC | 	wrlong	local04, local03
0b180     57 AD 02 F6 | 	mov	local04, local05
0b184     5A AD 02 F1 | 	add	local04, local08
0b188     08 AA 06 F1 | 	add	local03, #8
0b18c     55 AD 62 FC | 	wrlong	local04, local03
0b190     2C AA 86 F1 | 	sub	local03, #44
0b194     03 B6 0E F2 | 	cmp	local09, #3 wz
0b198     54 00 90 5D |  if_ne	jmp	#LR__1744
0b19c     55 91 02 F6 | 	mov	arg01, local03
0b1a0     5E 90 06 F1 | 	add	arg01, #94
0b1a4                 | ' {
0b1a4                 | ' 
0b1a4                 | ' 	return *((WORD*)ptr);
0b1a4     48 77 EA FA | 	rdword	result1, arg01 wz
0b1a8     0D 76 06 56 |  if_ne	mov	result1, #13
0b1ac     E4 01 90 5D |  if_ne	jmp	#LR__1749
0b1b0     08 AA 06 F1 | 	add	local03, #8
0b1b4     55 AD EA FA | 	rdword	local04, local03 wz
0b1b8     08 AA 86 F1 | 	sub	local03, #8
0b1bc     0D 76 06 56 |  if_ne	mov	result1, #13
0b1c0     D0 01 90 5D |  if_ne	jmp	#LR__1749
0b1c4     34 AA 06 F1 | 	add	local03, #52
0b1c8     55 91 02 F6 | 	mov	arg01, local03
0b1cc     2C 90 06 F1 | 	add	arg01, #44
0b1d0                 | ' {
0b1d0                 | ' 
0b1d0                 | ' 	return *((DWORD*)ptr);
0b1d0     48 77 02 FB | 	rdlong	result1, arg01
0b1d4     0C AA 86 F1 | 	sub	local03, #12
0b1d8     55 77 62 FC | 	wrlong	result1, local03
0b1dc     10 AA 86 F1 | 	sub	local03, #16
0b1e0     55 B9 02 FB | 	rdlong	local10, local03
0b1e4     18 AA 86 F1 | 	sub	local03, #24
0b1e8     02 B8 66 F0 | 	shl	local10, #2
0b1ec     6C 00 90 FD | 	jmp	#LR__1746
0b1f0                 | LR__1744
0b1f0     08 AA 06 F1 | 	add	local03, #8
0b1f4     55 AD EA FA | 	rdword	local04, local03 wz
0b1f8     08 AA 86 F1 | 	sub	local03, #8
0b1fc     0D 76 06 A6 |  if_e	mov	result1, #13
0b200     90 01 90 AD |  if_e	jmp	#LR__1749
0b204     24 AA 06 F1 | 	add	local03, #36
0b208     55 AD 02 FB | 	rdlong	local04, local03
0b20c     58 AD 02 F1 | 	add	local04, local06
0b210     04 AA 06 F1 | 	add	local03, #4
0b214     55 AD 62 FC | 	wrlong	local04, local03
0b218     28 AA 86 F1 | 	sub	local03, #40
0b21c     02 B6 0E F2 | 	cmp	local09, #2 wz
0b220     18 AA 06 A1 |  if_e	add	local03, #24
0b224     55 AD 02 AB |  if_e	rdlong	local04, local03
0b228     18 AA 86 A1 |  if_e	sub	local03, #24
0b22c     01 AC 66 A0 |  if_e	shl	local04, #1
0b230     24 00 90 AD |  if_e	jmp	#LR__1745
0b234     18 AA 06 F1 | 	add	local03, #24
0b238     55 B9 02 FB | 	rdlong	local10, local03
0b23c     5C AD 02 F6 | 	mov	local04, local10
0b240     01 AC 66 F0 | 	shl	local04, #1
0b244     5C AD 02 F1 | 	add	local04, local10
0b248     01 AC 46 F0 | 	shr	local04, #1
0b24c     18 AA 86 F1 | 	sub	local03, #24
0b250     01 B8 06 F5 | 	and	local10, #1
0b254     5C AD 02 F1 | 	add	local04, local10
0b258                 | LR__1745
0b258     56 B9 02 F6 | 	mov	local10, local04
0b25c                 | LR__1746
0b25c     FF B9 06 F1 | 	add	local10, #511
0b260     09 B8 46 F0 | 	shr	local10, #9
0b264     1C AA 06 F1 | 	add	local03, #28
0b268     55 95 02 FB | 	rdlong	arg03, local03
0b26c     1C AA 86 F1 | 	sub	local03, #28
0b270     5C 95 12 F2 | 	cmp	arg03, local10 wc
0b274     0D 76 06 C6 |  if_b	mov	result1, #13
0b278     18 01 90 CD |  if_b	jmp	#LR__1749
0b27c     14 AA 06 F1 | 	add	local03, #20
0b280     FF FF FF FF 
0b284     55 FF 6B FC | 	wrlong	##-1, local03
0b288     04 AA 86 F1 | 	sub	local03, #4
0b28c     FF FF FF FF 
0b290     55 FF 6B FC | 	wrlong	##-1, local03
0b294     0C AA 86 F1 | 	sub	local03, #12
0b298     55 01 49 FC | 	wrbyte	#128, local03
0b29c     04 AA 86 F1 | 	sub	local03, #4
0b2a0     03 B6 0E F2 | 	cmp	local09, #3 wz
0b2a4     55 91 02 A6 |  if_e	mov	arg01, local03
0b2a8     64 90 06 A1 |  if_e	add	arg01, #100
0b2ac                 | ' {
0b2ac                 | ' 
0b2ac                 | ' 	return *((WORD*)ptr);
0b2ac     48 77 E2 AA |  if_e	rdword	result1, arg01
0b2b0     3B AD 32 A9 |  if_e	getword	local04, result1, #0
0b2b4     01 AC 0E A2 |  if_e	cmp	local04, #1 wz
0b2b8     A4 00 90 5D |  if_ne	jmp	#LR__1748
0b2bc     01 AE 06 F1 | 	add	local05, #1
0b2c0     55 91 02 F6 | 	mov	arg01, local03
0b2c4     57 93 02 F6 | 	mov	arg02, local05
0b2c8     E8 D4 BF FD | 	call	#_fatfs_cc_move_window
0b2cc     00 76 0E F2 | 	cmp	result1, #0 wz
0b2d0     8C 00 90 5D |  if_ne	jmp	#LR__1748
0b2d4     04 AA 06 F1 | 	add	local03, #4
0b2d8     55 01 48 FC | 	wrbyte	#0, local03
0b2dc     30 AA 06 F1 | 	add	local03, #48
0b2e0     55 91 02 F6 | 	mov	arg01, local03
0b2e4     34 AA 86 F1 | 	sub	local03, #52
0b2e8     FE 91 06 F1 | 	add	arg01, #510
0b2ec                 | ' {
0b2ec                 | ' 
0b2ec                 | ' 	return *((WORD*)ptr);
0b2ec     48 77 E2 FA | 	rdword	result1, arg01
0b2f0     3B AD 32 F9 | 	getword	local04, result1, #0
0b2f4     55 00 00 FF 
0b2f8     55 AC 0E F2 | 	cmp	local04, ##43605 wz
0b2fc     55 91 02 A6 |  if_e	mov	arg01, local03
0b300     34 90 06 A1 |  if_e	add	arg01, #52
0b304                 | ' {
0b304                 | ' 
0b304                 | ' 	return *((DWORD*)ptr);
0b304     48 77 02 AB |  if_e	rdlong	result1, arg01
0b308     A9 B0 20 AF 
0b30c     52 76 0E A2 |  if_e	cmp	result1, ##1096897106 wz
0b310     55 91 02 A6 |  if_e	mov	arg01, local03
0b314     01 00 00 AF 
0b318     18 90 06 A1 |  if_e	add	arg01, ##536
0b31c                 | ' {
0b31c                 | ' 
0b31c                 | ' 	return *((DWORD*)ptr);
0b31c     48 77 02 AB |  if_e	rdlong	result1, arg01
0b320     B9 A0 30 AF 
0b324     72 76 0E A2 |  if_e	cmp	result1, ##1631679090 wz
0b328     34 00 90 5D |  if_ne	jmp	#LR__1747
0b32c     34 AA 06 F1 | 	add	local03, #52
0b330     55 91 02 F6 | 	mov	arg01, local03
0b334     E8 91 06 F1 | 	add	arg01, #488
0b338                 | ' {
0b338                 | ' 
0b338                 | ' 	return *((DWORD*)ptr);
0b338     48 77 02 FB | 	rdlong	result1, arg01
0b33c     20 AA 86 F1 | 	sub	local03, #32
0b340     55 77 62 FC | 	wrlong	result1, local03
0b344     20 AA 06 F1 | 	add	local03, #32
0b348     55 91 02 F6 | 	mov	arg01, local03
0b34c     EC 91 06 F1 | 	add	arg01, #492
0b350                 | ' {
0b350                 | ' 
0b350                 | ' 	return *((DWORD*)ptr);
0b350     48 77 02 FB | 	rdlong	result1, arg01
0b354     24 AA 86 F1 | 	sub	local03, #36
0b358     55 77 62 FC | 	wrlong	result1, local03
0b35c     10 AA 86 F1 | 	sub	local03, #16
0b360                 | LR__1747
0b360                 | LR__1748
0b360     55 B7 42 FC | 	wrbyte	local09, local03
0b364     04 62 06 F1 | 	add	objptr, #4
0b368     31 AD E2 FA | 	rdword	local04, objptr
0b36c     01 AC 06 F1 | 	add	local04, #1
0b370     31 AD 52 FC | 	wrword	local04, objptr
0b374     56 B9 32 F9 | 	getword	local10, local04, #0
0b378     06 AA 06 F1 | 	add	local03, #6
0b37c     55 B9 52 FC | 	wrword	local10, local03
0b380     04 62 06 F1 | 	add	objptr, #4
0b384     06 AA 06 F1 | 	add	local03, #6
0b388     55 63 62 FC | 	wrlong	objptr, local03
0b38c                 | ' 				&& ld_dword(fs->win +  0 ) == 0x41615252
0b38c                 | ' 				&& ld_dword(fs->win +  484 ) == 0x61417272)
0b38c                 | ' 			{
0b38c                 | ' 
0b38c                 | ' 				fs->free_clst = ld_dword(fs->win +  488 );
0b38c                 | ' 
0b38c                 | ' 
0b38c                 | ' 				fs->last_clst = ld_dword(fs->win +  492 );
0b38c                 | ' 
0b38c                 | ' 			}
0b38c                 | ' 		}
0b38c                 | ' 
0b38c                 | ' 
0b38c                 | ' 	}
0b38c                 | ' 
0b38c                 | ' 	fs->fs_type = (BYTE)fmt;
0b38c                 | ' 	fs->id = ++Fsid;
0b38c                 | ' 
0b38c                 | ' 	fs->lfnbuf = LfnBuf;
0b38c                 | ' #line 3567 "ff.c"
0b38c                 | ' 	return FR_OK;
0b38c     00 76 06 F6 | 	mov	result1, #0
0b390     08 62 86 F1 | 	sub	objptr, #8
0b394                 | LR__1749
0b394     E7 F0 03 F6 | 	mov	ptra, fp
0b398     F2 00 A0 FD | 	call	#popregs_
0b39c                 | _fatfs_cc_mount_volume_ret
0b39c     2D 00 64 FD | 	ret
0b3a0                 | 
0b3a0                 | _fatfs_cc_validate
0b3a0     48 7D 0A F6 | 	mov	_var01, arg01 wz
0b3a4     09 7E 06 F6 | 	mov	_var02, #9
0b3a8     3E 81 0A 5B |  if_ne	rdlong	_var03, _var01 wz
0b3ac     40 83 CA 5A |  if_ne	rdbyte	_var04, _var03 wz
0b3b0     48 00 90 AD |  if_e	jmp	#LR__1750
0b3b4     04 7C 06 F1 | 	add	_var01, #4
0b3b8     3E 83 E2 FA | 	rdword	_var04, _var01
0b3bc     04 7C 86 F1 | 	sub	_var01, #4
0b3c0     3E 91 02 FB | 	rdlong	arg01, _var01
0b3c4     06 90 06 F1 | 	add	arg01, #6
0b3c8     48 77 E2 FA | 	rdword	result1, arg01
0b3cc     3B 83 0A F2 | 	cmp	_var04, result1 wz
0b3d0     28 00 90 5D |  if_ne	jmp	#LR__1750
0b3d4     01 00 00 FF 
0b3d8     10 62 06 F1 | 	add	objptr, ##528
0b3dc     31 83 0A FB | 	rdlong	_var04, objptr wz
0b3e0     01 00 00 FF 
0b3e4     10 62 86 F1 | 	sub	objptr, ##528
0b3e8                 | '         return RES_NOTRDY;
0b3e8     03 76 06 A6 |  if_e	mov	result1, #3
0b3ec                 | '     }
0b3ec                 | '     return RES_OK;
0b3ec     00 76 06 56 |  if_ne	mov	result1, #0
0b3f0     3B 81 E2 F8 | 	getbyte	_var03, result1, #0
0b3f4     01 80 CE F7 | 	test	_var03, #1 wz
0b3f8     00 7E 06 A6 |  if_e	mov	_var02, #0
0b3fc                 | LR__1750
0b3fc     00 7E 0E F2 | 	cmp	_var02, #0 wz
0b400     3E 81 02 AB |  if_e	rdlong	_var03, _var01
0b404     00 80 06 56 |  if_ne	mov	_var03, #0
0b408     49 81 62 FC | 	wrlong	_var03, arg02
0b40c                 | ' 			res = FR_OK;
0b40c                 | ' 		}
0b40c                 | ' 
0b40c                 | ' 	}
0b40c                 | ' 	*rfs = (res == FR_OK) ? obj->fs : 0;
0b40c                 | ' 	return res;
0b40c     3F 77 02 F6 | 	mov	result1, _var02
0b410                 | _fatfs_cc_validate_ret
0b410     2D 00 64 FD | 	ret
0b414                 | 
0b414                 | _fatfs_cc_f_mount
0b414     04 CA 05 F6 | 	mov	COUNT_, #4
0b418     E8 00 A0 FD | 	call	#pushregs_
0b41c     20 F0 07 F1 | 	add	ptra, #32
0b420     04 CE 05 F1 | 	add	fp, #4
0b424     E7 90 62 FC | 	wrlong	arg01, fp
0b428     04 CE 05 F1 | 	add	fp, #4
0b42c     E7 92 62 FC | 	wrlong	arg02, fp
0b430     4A A7 02 F6 | 	mov	local01, arg03
0b434     14 CE 05 F1 | 	add	fp, #20
0b438     E7 92 62 FC | 	wrlong	arg02, fp
0b43c     E7 90 02 F6 | 	mov	arg01, fp
0b440     1C CE 85 F1 | 	sub	fp, #28
0b444     EC F6 BF FD | 	call	#_fatfs_cc_get_ldnumber
0b448     3B A9 02 F6 | 	mov	local02, result1
0b44c     00 A8 56 F2 | 	cmps	local02, #0 wc
0b450     0B 76 06 C6 |  if_b	mov	result1, #11
0b454     84 00 90 CD |  if_b	jmp	#LR__1761
0b458     54 95 02 F6 | 	mov	arg03, local02
0b45c     02 94 66 F0 | 	shl	arg03, #2
0b460     31 95 02 F1 | 	add	arg03, objptr
0b464     4A AB 0A FB | 	rdlong	local03, arg03 wz
0b468     14 00 90 AD |  if_e	jmp	#LR__1760
0b46c     01 AA 06 F1 | 	add	local03, #1
0b470     55 91 C2 FA | 	rdbyte	arg01, local03
0b474     01 AA 86 F1 | 	sub	local03, #1
0b478     E0 2B B0 FD | 	call	#_fatfs_cc_disk_deinitialize
0b47c     55 01 48 FC | 	wrbyte	#0, local03
0b480                 | LR__1760
0b480     04 CE 05 F1 | 	add	fp, #4
0b484     E7 AC 0A FB | 	rdlong	local04, fp wz
0b488     04 CE 85 F1 | 	sub	fp, #4
0b48c     04 CE 05 51 |  if_ne	add	fp, #4
0b490     E7 AC 02 5B |  if_ne	rdlong	local04, fp
0b494     04 CE 85 51 |  if_ne	sub	fp, #4
0b498     56 01 48 5C |  if_ne	wrbyte	#0, local04
0b49c     02 A8 66 F0 | 	shl	local02, #2
0b4a0     31 A9 02 F1 | 	add	local02, objptr
0b4a4     04 CE 05 F1 | 	add	fp, #4
0b4a8     E7 AC 02 FB | 	rdlong	local04, fp
0b4ac     04 CE 85 F1 | 	sub	fp, #4
0b4b0     54 AD 62 FC | 	wrlong	local04, local02
0b4b4     07 A6 4E F7 | 	zerox	local01, #7 wz
0b4b8     00 76 06 A6 |  if_e	mov	result1, #0
0b4bc     1C 00 90 AD |  if_e	jmp	#LR__1761
0b4c0     08 CE 05 F1 | 	add	fp, #8
0b4c4     E7 90 02 F6 | 	mov	arg01, fp
0b4c8     04 CE 85 F1 | 	sub	fp, #4
0b4cc     E7 92 02 F6 | 	mov	arg02, fp
0b4d0     04 CE 85 F1 | 	sub	fp, #4
0b4d4     00 94 06 F6 | 	mov	arg03, #0
0b4d8     94 F9 BF FD | 	call	#_fatfs_cc_mount_volume
0b4dc                 | ' 
0b4dc                 | ' 	res = mount_volume(&path, &fs, 0);
0b4dc                 | ' 	return res ;
0b4dc                 | LR__1761
0b4dc     E7 F0 03 F6 | 	mov	ptra, fp
0b4e0     F2 00 A0 FD | 	call	#popregs_
0b4e4                 | _fatfs_cc_f_mount_ret
0b4e4     2D 00 64 FD | 	ret
0b4e8                 | 
0b4e8                 | _fatfs_cc_f_open
0b4e8     08 CA 05 F6 | 	mov	COUNT_, #8
0b4ec     E8 00 A0 FD | 	call	#pushregs_
0b4f0     60 F0 07 F1 | 	add	ptra, #96
0b4f4     48 A7 0A F6 | 	mov	local01, arg01 wz
0b4f8     08 CE 05 F1 | 	add	fp, #8
0b4fc     E7 92 62 FC | 	wrlong	arg02, fp
0b500     08 CE 85 F1 | 	sub	fp, #8
0b504     4A A9 02 F6 | 	mov	local02, arg03
0b508     09 76 06 A6 |  if_e	mov	result1, #9
0b50c     24 04 90 AD |  if_e	jmp	#LR__1787
0b510     54 A9 E2 F8 | 	getbyte	local02, local02, #0
0b514     3F A8 06 F5 | 	and	local02, #63
0b518     08 CE 05 F1 | 	add	fp, #8
0b51c     E7 90 02 F6 | 	mov	arg01, fp
0b520     3C CE 05 F1 | 	add	fp, #60
0b524     E7 92 02 F6 | 	mov	arg02, fp
0b528     44 CE 85 F1 | 	sub	fp, #68
0b52c     54 95 02 F6 | 	mov	arg03, local02
0b530     3C F9 BF FD | 	call	#_fatfs_cc_mount_volume
0b534     3B AB 0A F6 | 	mov	local03, result1 wz
0b538     EC 03 90 5D |  if_ne	jmp	#LR__1786
0b53c     44 CE 05 F1 | 	add	fp, #68
0b540     E7 AA 02 FB | 	rdlong	local03, fp
0b544     30 CE 85 F1 | 	sub	fp, #48
0b548     E7 AA 62 FC | 	wrlong	local03, fp
0b54c     E7 90 02 F6 | 	mov	arg01, fp
0b550     0C CE 85 F1 | 	sub	fp, #12
0b554     E7 AC 02 FB | 	rdlong	local04, fp
0b558     08 CE 85 F1 | 	sub	fp, #8
0b55c     56 93 02 F6 | 	mov	arg02, local04
0b560     70 F4 BF FD | 	call	#_fatfs_cc_follow_path
0b564     3B AB 0A F6 | 	mov	local03, result1 wz
0b568     18 00 90 5D |  if_ne	jmp	#LR__1770
0b56c     3F CE 05 F1 | 	add	fp, #63
0b570     E7 AC C2 FA | 	rdbyte	local04, fp
0b574     3F CE 85 F1 | 	sub	fp, #63
0b578     56 97 E2 F8 | 	getbyte	arg04, local04, #0
0b57c     80 96 CE F7 | 	test	arg04, #128 wz
0b580     06 AA 06 56 |  if_ne	mov	local03, #6
0b584                 | LR__1770
0b584     54 97 E2 F8 | 	getbyte	arg04, local02, #0
0b588     1C 96 CE F7 | 	test	arg04, #28 wz
0b58c     5C 01 90 AD |  if_e	jmp	#LR__1775
0b590     00 AA 0E F2 | 	cmp	local03, #0 wz
0b594     24 00 90 AD |  if_e	jmp	#LR__1772
0b598     04 AA 0E F2 | 	cmp	local03, #4 wz
0b59c     10 00 90 5D |  if_ne	jmp	#LR__1771
0b5a0     E7 90 02 F6 | 	mov	arg01, fp
0b5a4     14 90 06 F1 | 	add	arg01, #20
0b5a8     4C E8 BF FD | 	call	#_fatfs_cc_dir_register
0b5ac     3B AB 02 F6 | 	mov	local03, result1
0b5b0                 | LR__1771
0b5b0     54 A9 E2 F8 | 	getbyte	local02, local02, #0
0b5b4     08 A8 46 F5 | 	or	local02, #8
0b5b8     24 00 90 FD | 	jmp	#LR__1774
0b5bc                 | LR__1772
0b5bc     1A CE 05 F1 | 	add	fp, #26
0b5c0     E7 AC C2 FA | 	rdbyte	local04, fp
0b5c4     1A CE 85 F1 | 	sub	fp, #26
0b5c8     11 AC CE F7 | 	test	local04, #17 wz
0b5cc     07 AA 06 56 |  if_ne	mov	local03, #7
0b5d0     0C 00 90 5D |  if_ne	jmp	#LR__1773
0b5d4     54 AD E2 F8 | 	getbyte	local04, local02, #0
0b5d8     04 AC CE F7 | 	test	local04, #4 wz
0b5dc     08 AA 06 56 |  if_ne	mov	local03, #8
0b5e0                 | LR__1773
0b5e0                 | LR__1774
0b5e0     00 AA 0E F2 | 	cmp	local03, #0 wz
0b5e4     40 01 90 5D |  if_ne	jmp	#LR__1778
0b5e8     54 AD E2 F8 | 	getbyte	local04, local02, #0
0b5ec     08 AC CE F7 | 	test	local04, #8 wz
0b5f0     34 01 90 AD |  if_e	jmp	#LR__1778
0b5f4     C0 1B B0 FD | 	call	#_fatfs_cc__get_fattime
0b5f8     30 CE 05 F1 | 	add	fp, #48
0b5fc     E7 90 02 FB | 	rdlong	arg01, fp
0b600     0E 90 06 F1 | 	add	arg01, #14
0b604     48 77 62 FC | 	wrlong	result1, arg01
0b608     E7 90 02 FB | 	rdlong	arg01, fp
0b60c     16 90 06 F1 | 	add	arg01, #22
0b610     48 77 62 FC | 	wrlong	result1, arg01
0b614     14 CE 05 F1 | 	add	fp, #20
0b618     E7 90 02 FB | 	rdlong	arg01, fp
0b61c     14 CE 85 F1 | 	sub	fp, #20
0b620     E7 92 02 FB | 	rdlong	arg02, fp
0b624     30 CE 85 F1 | 	sub	fp, #48
0b628     C0 DE BF FD | 	call	#_fatfs_cc_ld_clust
0b62c     3B AD 02 F6 | 	mov	local04, result1
0b630     30 CE 05 F1 | 	add	fp, #48
0b634     E7 96 02 FB | 	rdlong	arg04, fp
0b638     0B 96 06 F1 | 	add	arg04, #11
0b63c     4B 41 48 FC | 	wrbyte	#32, arg04
0b640     14 CE 05 F1 | 	add	fp, #20
0b644     E7 90 02 FB | 	rdlong	arg01, fp
0b648     14 CE 85 F1 | 	sub	fp, #20
0b64c     E7 92 02 FB | 	rdlong	arg02, fp
0b650     30 CE 85 F1 | 	sub	fp, #48
0b654     00 94 06 F6 | 	mov	arg03, #0
0b658     C4 DE BF FD | 	call	#_fatfs_cc_st_clust
0b65c     30 CE 05 F1 | 	add	fp, #48
0b660     E7 90 02 FB | 	rdlong	arg01, fp
0b664     1C 90 06 F1 | 	add	arg01, #28
0b668     48 01 68 FC | 	wrlong	#0, arg01
0b66c     14 CE 05 F1 | 	add	fp, #20
0b670     E7 96 02 FB | 	rdlong	arg04, fp
0b674     44 CE 85 F1 | 	sub	fp, #68
0b678     03 96 06 F1 | 	add	arg04, #3
0b67c     4B 03 48 FC | 	wrbyte	#1, arg04
0b680     00 AC 0E F2 | 	cmp	local04, #0 wz
0b684     A0 00 90 AD |  if_e	jmp	#LR__1778
0b688     44 CE 05 F1 | 	add	fp, #68
0b68c     E7 AA 02 FB | 	rdlong	local03, fp
0b690     30 AA 06 F1 | 	add	local03, #48
0b694     55 AF 02 FB | 	rdlong	local05, local03
0b698     30 CE 85 F1 | 	sub	fp, #48
0b69c     E7 90 02 F6 | 	mov	arg01, fp
0b6a0     14 CE 85 F1 | 	sub	fp, #20
0b6a4     56 93 02 F6 | 	mov	arg02, local04
0b6a8     00 94 06 F6 | 	mov	arg03, #0
0b6ac     70 D6 BF FD | 	call	#_fatfs_cc_remove_chain
0b6b0     3B AB 0A F6 | 	mov	local03, result1 wz
0b6b4     70 00 90 5D |  if_ne	jmp	#LR__1778
0b6b8     44 CE 05 F1 | 	add	fp, #68
0b6bc     E7 90 02 FB | 	rdlong	arg01, fp
0b6c0     44 CE 85 F1 | 	sub	fp, #68
0b6c4     57 93 02 F6 | 	mov	arg02, local05
0b6c8     E8 D0 BF FD | 	call	#_fatfs_cc_move_window
0b6cc     3B AB 02 F6 | 	mov	local03, result1
0b6d0     44 CE 05 F1 | 	add	fp, #68
0b6d4     E7 AE 02 FB | 	rdlong	local05, fp
0b6d8     44 CE 85 F1 | 	sub	fp, #68
0b6dc     01 AC 86 F1 | 	sub	local04, #1
0b6e0     10 AE 06 F1 | 	add	local05, #16
0b6e4     57 AD 62 FC | 	wrlong	local04, local05
0b6e8     3C 00 90 FD | 	jmp	#LR__1778
0b6ec                 | LR__1775
0b6ec     00 AA 0E F2 | 	cmp	local03, #0 wz
0b6f0     34 00 90 5D |  if_ne	jmp	#LR__1777
0b6f4     1A CE 05 F1 | 	add	fp, #26
0b6f8     E7 AE C2 FA | 	rdbyte	local05, fp
0b6fc     1A CE 85 F1 | 	sub	fp, #26
0b700     10 AE CE F7 | 	test	local05, #16 wz
0b704     04 AA 06 56 |  if_ne	mov	local03, #4
0b708     1C 00 90 5D |  if_ne	jmp	#LR__1776
0b70c     54 AF E2 F8 | 	getbyte	local05, local02, #0
0b710     02 AE CE F7 | 	test	local05, #2 wz
0b714     1A CE 05 51 |  if_ne	add	fp, #26
0b718     E7 AC C2 5A |  if_ne	rdbyte	local04, fp
0b71c     1A CE 85 51 |  if_ne	sub	fp, #26
0b720     01 AC CE 57 |  if_ne	test	local04, #1 wz
0b724     07 AA 06 56 |  if_ne	mov	local03, #7
0b728                 | LR__1776
0b728                 | LR__1777
0b728                 | LR__1778
0b728     00 AA 0E F2 | 	cmp	local03, #0 wz
0b72c     40 00 90 5D |  if_ne	jmp	#LR__1779
0b730     54 AF E2 F8 | 	getbyte	local05, local02, #0
0b734     08 AE CE F7 | 	test	local05, #8 wz
0b738     54 A9 E2 58 |  if_ne	getbyte	local02, local02, #0
0b73c     40 A8 46 55 |  if_ne	or	local02, #64
0b740     44 CE 05 F1 | 	add	fp, #68
0b744     E7 AE 02 FB | 	rdlong	local05, fp
0b748     30 AE 06 F1 | 	add	local05, #48
0b74c     57 AF 02 FB | 	rdlong	local05, local05
0b750     20 A6 06 F1 | 	add	local01, #32
0b754     53 AF 62 FC | 	wrlong	local05, local01
0b758     14 CE 85 F1 | 	sub	fp, #20
0b75c     E7 AE 02 FB | 	rdlong	local05, fp
0b760     30 CE 85 F1 | 	sub	fp, #48
0b764     04 A6 06 F1 | 	add	local01, #4
0b768     53 AF 62 FC | 	wrlong	local05, local01
0b76c     24 A6 86 F1 | 	sub	local01, #36
0b770                 | LR__1779
0b770     00 AA 0E F2 | 	cmp	local03, #0 wz
0b774     B0 01 90 5D |  if_ne	jmp	#LR__1785
0b778     44 CE 05 F1 | 	add	fp, #68
0b77c     E7 90 02 FB | 	rdlong	arg01, fp
0b780     14 CE 85 F1 | 	sub	fp, #20
0b784     E7 92 02 FB | 	rdlong	arg02, fp
0b788     30 CE 85 F1 | 	sub	fp, #48
0b78c     5C DD BF FD | 	call	#_fatfs_cc_ld_clust
0b790     08 A6 06 F1 | 	add	local01, #8
0b794     53 77 62 FC | 	wrlong	result1, local01
0b798     30 CE 05 F1 | 	add	fp, #48
0b79c     E7 90 02 FB | 	rdlong	arg01, fp
0b7a0     1C 90 06 F1 | 	add	arg01, #28
0b7a4                 | ' {
0b7a4                 | ' 
0b7a4                 | ' 	return *((DWORD*)ptr);
0b7a4     48 77 02 FB | 	rdlong	result1, arg01
0b7a8     04 A6 06 F1 | 	add	local01, #4
0b7ac     53 77 62 FC | 	wrlong	result1, local01
0b7b0     0C A6 86 F1 | 	sub	local01, #12
0b7b4     14 CE 05 F1 | 	add	fp, #20
0b7b8     E7 AE 02 FB | 	rdlong	local05, fp
0b7bc     53 AF 62 FC | 	wrlong	local05, local01
0b7c0     E7 AE 02 FB | 	rdlong	local05, fp
0b7c4     44 CE 85 F1 | 	sub	fp, #68
0b7c8     06 AE 06 F1 | 	add	local05, #6
0b7cc     57 AD E2 FA | 	rdword	local04, local05
0b7d0     04 A6 06 F1 | 	add	local01, #4
0b7d4     53 AD 52 FC | 	wrword	local04, local01
0b7d8     0C A6 06 F1 | 	add	local01, #12
0b7dc     53 A9 42 FC | 	wrbyte	local02, local01
0b7e0     01 A6 06 F1 | 	add	local01, #1
0b7e4     53 01 48 FC | 	wrbyte	#0, local01
0b7e8     0B A6 06 F1 | 	add	local01, #11
0b7ec     53 01 68 FC | 	wrlong	#0, local01
0b7f0     08 A6 86 F1 | 	sub	local01, #8
0b7f4     53 01 68 FC | 	wrlong	#0, local01
0b7f8     14 A6 06 F1 | 	add	local01, #20
0b7fc     53 91 02 F6 | 	mov	arg01, local01
0b800     28 A6 86 F1 | 	sub	local01, #40
0b804     00 92 06 F6 | 	mov	arg02, #0
0b808     09 94 C6 F9 | 	decod	arg03, #9
0b80c     D8 00 A0 FD | 	call	#\builtin_bytefill_
0b810     54 A9 E2 F8 | 	getbyte	local02, local02, #0
0b814     20 A8 CE F7 | 	test	local02, #32 wz
0b818     0C 01 90 AD |  if_e	jmp	#LR__1784
0b81c     0C A6 06 F1 | 	add	local01, #12
0b820     53 AD 02 FB | 	rdlong	local04, local01
0b824     0C A6 86 F1 | 	sub	local01, #12
0b828     01 AC 16 F2 | 	cmp	local04, #1 wc
0b82c     F8 00 90 CD |  if_b	jmp	#LR__1784
0b830     0C A6 06 F1 | 	add	local01, #12
0b834     53 AD 02 FB | 	rdlong	local04, local01
0b838     08 A6 06 F1 | 	add	local01, #8
0b83c     53 AD 62 FC | 	wrlong	local04, local01
0b840     44 CE 05 F1 | 	add	fp, #68
0b844     E7 AC 02 FB | 	rdlong	local04, fp
0b848     44 CE 85 F1 | 	sub	fp, #68
0b84c     0A AC 06 F1 | 	add	local04, #10
0b850     56 B1 E2 FA | 	rdword	local06, local04
0b854     09 B0 66 F0 | 	shl	local06, #9
0b858     0C A6 86 F1 | 	sub	local01, #12
0b85c     53 B3 02 FB | 	rdlong	local07, local01
0b860                 | ' 				fp->fptr = fp->obj.objsize;
0b860                 | ' 				bcs = (DWORD)fs->csize *  ((UINT) 512 ) ;
0b860                 | ' 				clst = fp->obj.sclust;
0b860                 | ' 				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
0b860     04 A6 06 F1 | 	add	local01, #4
0b864     53 B5 02 FB | 	rdlong	local08, local01
0b868     0C A6 86 F1 | 	sub	local01, #12
0b86c                 | LR__1780
0b86c     00 AA 0E F2 | 	cmp	local03, #0 wz
0b870     34 00 90 5D |  if_ne	jmp	#LR__1781
0b874     58 B5 1A F2 | 	cmp	local08, local06 wcz
0b878     2C 00 90 ED |  if_be	jmp	#LR__1781
0b87c     53 91 02 F6 | 	mov	arg01, local01
0b880     59 93 02 F6 | 	mov	arg02, local07
0b884     E4 D0 BF FD | 	call	#_fatfs_cc_get_fat
0b888     3B B3 02 F6 | 	mov	local07, result1
0b88c     02 B2 16 F2 | 	cmp	local07, #2 wc
0b890     02 AA 06 C6 |  if_b	mov	local03, #2
0b894     FF FF 7F FF 
0b898     FF B3 0E F2 | 	cmp	local07, ##-1 wz
0b89c     01 AA 06 A6 |  if_e	mov	local03, #1
0b8a0     58 B5 82 F1 | 	sub	local08, local06
0b8a4     C4 FF 9F FD | 	jmp	#LR__1780
0b8a8                 | LR__1781
0b8a8     18 A6 06 F1 | 	add	local01, #24
0b8ac     53 B3 62 FC | 	wrlong	local07, local01
0b8b0     18 A6 86 F1 | 	sub	local01, #24
0b8b4     00 AA 0E F2 | 	cmp	local03, #0 wz
0b8b8     6C 00 90 5D |  if_ne	jmp	#LR__1783
0b8bc     FF B5 CE F7 | 	test	local08, #511 wz
0b8c0     64 00 90 AD |  if_e	jmp	#LR__1783
0b8c4     44 CE 05 F1 | 	add	fp, #68
0b8c8     E7 90 02 FB | 	rdlong	arg01, fp
0b8cc     44 CE 85 F1 | 	sub	fp, #68
0b8d0     59 93 02 F6 | 	mov	arg02, local07
0b8d4     54 D0 BF FD | 	call	#_fatfs_cc_clst2sect
0b8d8     3B AF 0A F6 | 	mov	local05, result1 wz
0b8dc     02 AA 06 A6 |  if_e	mov	local03, #2
0b8e0     44 00 90 AD |  if_e	jmp	#LR__1782
0b8e4     09 B4 46 F0 | 	shr	local08, #9
0b8e8     5A AF 02 F1 | 	add	local05, local08
0b8ec     1C A6 06 F1 | 	add	local01, #28
0b8f0     53 AF 62 FC | 	wrlong	local05, local01
0b8f4     44 CE 05 F1 | 	add	fp, #68
0b8f8     E7 AC 02 FB | 	rdlong	local04, fp
0b8fc     44 CE 85 F1 | 	sub	fp, #68
0b900     01 AC 06 F1 | 	add	local04, #1
0b904     56 91 C2 FA | 	rdbyte	arg01, local04
0b908     53 93 02 F6 | 	mov	arg02, local01
0b90c     0C 92 06 F1 | 	add	arg02, #12
0b910     57 95 02 F6 | 	mov	arg03, local05
0b914     1C A6 86 F1 | 	sub	local01, #28
0b918     01 96 06 F6 | 	mov	arg04, #1
0b91c     0C C8 BF FD | 	call	#_fatfs_cc_disk_read
0b920     00 76 0E F2 | 	cmp	result1, #0 wz
0b924     01 AA 06 56 |  if_ne	mov	local03, #1
0b928                 | LR__1782
0b928                 | LR__1783
0b928                 | LR__1784
0b928                 | LR__1785
0b928                 | LR__1786
0b928     00 AA 0E F2 | 	cmp	local03, #0 wz
0b92c     53 01 68 5C |  if_ne	wrlong	#0, local01
0b930                 | ' 
0b930                 | ' 	return res ;
0b930     55 77 02 F6 | 	mov	result1, local03
0b934                 | LR__1787
0b934     E7 F0 03 F6 | 	mov	ptra, fp
0b938     F2 00 A0 FD | 	call	#popregs_
0b93c                 | _fatfs_cc_f_open_ret
0b93c     2D 00 64 FD | 	ret
0b940                 | 
0b940                 | _fatfs_cc_f_read
0b940     0E CA 05 F6 | 	mov	COUNT_, #14
0b944     E8 00 A0 FD | 	call	#pushregs_
0b948     38 F0 07 F1 | 	add	ptra, #56
0b94c     48 A7 02 F6 | 	mov	local01, arg01
0b950     49 A9 02 F6 | 	mov	local02, arg02
0b954     4A AB 02 F6 | 	mov	local03, arg03
0b958     4B AD 02 F6 | 	mov	local04, arg04
0b95c     54 AF 02 F6 | 	mov	local05, local02
0b960     56 01 68 FC | 	wrlong	#0, local04
0b964     E7 92 02 F6 | 	mov	arg02, fp
0b968     18 92 06 F1 | 	add	arg02, #24
0b96c     53 91 02 F6 | 	mov	arg01, local01
0b970     2C FA BF FD | 	call	#_fatfs_cc_validate
0b974     3B B1 0A F6 | 	mov	local06, result1 wz
0b978     11 A6 06 A1 |  if_e	add	local01, #17
0b97c     53 B1 C2 AA |  if_e	rdbyte	local06, local01
0b980     11 A6 86 A1 |  if_e	sub	local01, #17
0b984     00 B0 4E A2 |  if_e	cmps	local06, #0 wz
0b988     58 77 02 56 |  if_ne	mov	result1, local06
0b98c     3C 03 90 5D |  if_ne	jmp	#LR__1801
0b990     10 A6 06 F1 | 	add	local01, #16
0b994     53 B3 C2 FA | 	rdbyte	local07, local01
0b998     10 A6 86 F1 | 	sub	local01, #16
0b99c     01 B2 CE F7 | 	test	local07, #1 wz
0b9a0     07 76 06 A6 |  if_e	mov	result1, #7
0b9a4     24 03 90 AD |  if_e	jmp	#LR__1801
0b9a8     0C A6 06 F1 | 	add	local01, #12
0b9ac     53 B5 02 FB | 	rdlong	local08, local01
0b9b0     08 A6 06 F1 | 	add	local01, #8
0b9b4     53 B7 02 FB | 	rdlong	local09, local01
0b9b8     14 A6 86 F1 | 	sub	local01, #20
0b9bc     5B B5 82 F1 | 	sub	local08, local09
0b9c0     5A AB 3A F3 | 	fle	local03, local08 wcz
0b9c4                 | ' 
0b9c4                 | ' 	for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
0b9c4                 | LR__1790
0b9c4     01 AA 16 F2 | 	cmp	local03, #1 wc
0b9c8     FC 02 90 CD |  if_b	jmp	#LR__1800
0b9cc     14 A6 06 F1 | 	add	local01, #20
0b9d0     53 B3 02 FB | 	rdlong	local07, local01
0b9d4     14 A6 86 F1 | 	sub	local01, #20
0b9d8     FF B3 CE F7 | 	test	local07, #511 wz
0b9dc     80 02 90 5D |  if_ne	jmp	#LR__1798
0b9e0     14 A6 06 F1 | 	add	local01, #20
0b9e4     53 B9 02 FB | 	rdlong	local10, local01
0b9e8     14 A6 86 F1 | 	sub	local01, #20
0b9ec     09 B8 46 F0 | 	shr	local10, #9
0b9f0     18 CE 05 F1 | 	add	fp, #24
0b9f4     E7 B2 02 FB | 	rdlong	local07, fp
0b9f8     18 CE 85 F1 | 	sub	fp, #24
0b9fc     0A B2 06 F1 | 	add	local07, #10
0ba00     59 B3 E2 FA | 	rdword	local07, local07
0ba04     01 B2 86 F1 | 	sub	local07, #1
0ba08     59 B9 0A F5 | 	and	local10, local07 wz
0ba0c     6C 00 90 5D |  if_ne	jmp	#LR__1792
0ba10     14 A6 06 F1 | 	add	local01, #20
0ba14     53 B3 0A FB | 	rdlong	local07, local01 wz
0ba18     14 A6 86 F1 | 	sub	local01, #20
0ba1c     08 A6 06 A1 |  if_e	add	local01, #8
0ba20     53 BB 02 AB |  if_e	rdlong	local11, local01
0ba24     08 A6 86 A1 |  if_e	sub	local01, #8
0ba28     18 00 90 AD |  if_e	jmp	#LR__1791
0ba2c     53 91 02 F6 | 	mov	arg01, local01
0ba30     18 A6 06 F1 | 	add	local01, #24
0ba34     53 93 02 FB | 	rdlong	arg02, local01
0ba38     18 A6 86 F1 | 	sub	local01, #24
0ba3c     2C CF BF FD | 	call	#_fatfs_cc_get_fat
0ba40     3B BB 02 F6 | 	mov	local11, result1
0ba44                 | LR__1791
0ba44     02 BA 16 F2 | 	cmp	local11, #2 wc
0ba48     11 A6 06 C1 |  if_b	add	local01, #17
0ba4c     53 05 48 CC |  if_b	wrbyte	#2, local01
0ba50     02 76 06 C6 |  if_b	mov	result1, #2
0ba54     74 02 90 CD |  if_b	jmp	#LR__1801
0ba58     FF FF 7F FF 
0ba5c     FF BB 0E F2 | 	cmp	local11, ##-1 wz
0ba60     11 A6 06 A1 |  if_e	add	local01, #17
0ba64     53 03 48 AC |  if_e	wrbyte	#1, local01
0ba68     01 76 06 A6 |  if_e	mov	result1, #1
0ba6c     5C 02 90 AD |  if_e	jmp	#LR__1801
0ba70     18 A6 06 F1 | 	add	local01, #24
0ba74     53 BB 62 FC | 	wrlong	local11, local01
0ba78     18 A6 86 F1 | 	sub	local01, #24
0ba7c                 | LR__1792
0ba7c     18 CE 05 F1 | 	add	fp, #24
0ba80     E7 90 02 FB | 	rdlong	arg01, fp
0ba84     18 CE 85 F1 | 	sub	fp, #24
0ba88     18 A6 06 F1 | 	add	local01, #24
0ba8c     53 93 02 FB | 	rdlong	arg02, local01
0ba90     18 A6 86 F1 | 	sub	local01, #24
0ba94     94 CE BF FD | 	call	#_fatfs_cc_clst2sect
0ba98     3B BD 0A F6 | 	mov	local12, result1 wz
0ba9c     11 A6 06 A1 |  if_e	add	local01, #17
0baa0     53 05 48 AC |  if_e	wrbyte	#2, local01
0baa4     02 76 06 A6 |  if_e	mov	result1, #2
0baa8     20 02 90 AD |  if_e	jmp	#LR__1801
0baac     5C BD 02 F1 | 	add	local12, local10
0bab0     55 BF 02 F6 | 	mov	local13, local03
0bab4     09 BE 46 F0 | 	shr	local13, #9
0bab8     01 BE 16 F2 | 	cmp	local13, #1 wc
0babc     D8 00 90 CD |  if_b	jmp	#LR__1795
0bac0     5C B3 02 F6 | 	mov	local07, local10
0bac4     5F B3 02 F1 | 	add	local07, local13
0bac8     18 CE 05 F1 | 	add	fp, #24
0bacc     E7 B6 02 FB | 	rdlong	local09, fp
0bad0     18 CE 85 F1 | 	sub	fp, #24
0bad4     0A B6 06 F1 | 	add	local09, #10
0bad8     5B 77 E2 FA | 	rdword	result1, local09
0badc     3B B3 1A F2 | 	cmp	local07, result1 wcz
0bae0     18 00 90 ED |  if_be	jmp	#LR__1793
0bae4     18 CE 05 F1 | 	add	fp, #24
0bae8     E7 BE 02 FB | 	rdlong	local13, fp
0baec     18 CE 85 F1 | 	sub	fp, #24
0baf0     0A BE 06 F1 | 	add	local13, #10
0baf4     5F BF E2 FA | 	rdword	local13, local13
0baf8     5C BF 82 F1 | 	sub	local13, local10
0bafc                 | LR__1793
0bafc     18 CE 05 F1 | 	add	fp, #24
0bb00     E7 B2 02 FB | 	rdlong	local07, fp
0bb04     18 CE 85 F1 | 	sub	fp, #24
0bb08     01 B2 06 F1 | 	add	local07, #1
0bb0c     59 91 C2 FA | 	rdbyte	arg01, local07
0bb10     57 93 02 F6 | 	mov	arg02, local05
0bb14     5F 97 02 F6 | 	mov	arg04, local13
0bb18     5E 95 02 F6 | 	mov	arg03, local12
0bb1c     0C C6 BF FD | 	call	#_fatfs_cc_disk_read
0bb20     00 76 0E F2 | 	cmp	result1, #0 wz
0bb24     11 A6 06 51 |  if_ne	add	local01, #17
0bb28     53 03 48 5C |  if_ne	wrbyte	#1, local01
0bb2c     01 76 06 56 |  if_ne	mov	result1, #1
0bb30     98 01 90 5D |  if_ne	jmp	#LR__1801
0bb34     10 A6 06 F1 | 	add	local01, #16
0bb38     53 B3 C2 FA | 	rdbyte	local07, local01
0bb3c     10 A6 86 F1 | 	sub	local01, #16
0bb40     80 B2 CE F7 | 	test	local07, #128 wz
0bb44     44 00 90 AD |  if_e	jmp	#LR__1794
0bb48     1C A6 06 F1 | 	add	local01, #28
0bb4c     53 B7 02 FB | 	rdlong	local09, local01
0bb50     1C A6 86 F1 | 	sub	local01, #28
0bb54     5E B7 82 F1 | 	sub	local09, local12
0bb58     5F B7 12 F2 | 	cmp	local09, local13 wc
0bb5c     2C 00 90 3D |  if_ae	jmp	#LR__1794
0bb60     57 91 02 F6 | 	mov	arg01, local05
0bb64     1C A6 06 F1 | 	add	local01, #28
0bb68     53 B9 02 FB | 	rdlong	local10, local01
0bb6c     5E B9 82 F1 | 	sub	local10, local12
0bb70     09 B8 66 F0 | 	shl	local10, #9
0bb74     5C 91 02 F1 | 	add	arg01, local10
0bb78     0C A6 06 F1 | 	add	local01, #12
0bb7c     53 93 02 F6 | 	mov	arg02, local01
0bb80     28 A6 86 F1 | 	sub	local01, #40
0bb84     09 94 C6 F9 | 	decod	arg03, #9
0bb88     30 75 BF FD | 	call	#__system____builtin_memmove
0bb8c                 | LR__1794
0bb8c     09 BE 66 F0 | 	shl	local13, #9
0bb90     5F C1 02 F6 | 	mov	local14, local13
0bb94                 | ' 					__builtin_memcpy(rbuff + ((fp->sect - sect) * ((UINT) 512 ) ), fp->buf, ((UINT) 512 ) ) ;
0bb94                 | ' 				}
0bb94                 | ' 
0bb94                 | ' 
0bb94                 | ' 				rcnt =  ((UINT) 512 )  * cc;
0bb94                 | ' 				continue;
0bb94     04 01 90 FD | 	jmp	#LR__1799
0bb98                 | LR__1795
0bb98     1C A6 06 F1 | 	add	local01, #28
0bb9c     53 B3 02 FB | 	rdlong	local07, local01
0bba0     1C A6 86 F1 | 	sub	local01, #28
0bba4     5E B3 0A F2 | 	cmp	local07, local12 wz
0bba8     A8 00 90 AD |  if_e	jmp	#LR__1797
0bbac     10 A6 06 F1 | 	add	local01, #16
0bbb0     53 B3 C2 FA | 	rdbyte	local07, local01
0bbb4     10 A6 86 F1 | 	sub	local01, #16
0bbb8     80 B2 CE F7 | 	test	local07, #128 wz
0bbbc     58 00 90 AD |  if_e	jmp	#LR__1796
0bbc0     18 CE 05 F1 | 	add	fp, #24
0bbc4     E7 C0 02 FB | 	rdlong	local14, fp
0bbc8     18 CE 85 F1 | 	sub	fp, #24
0bbcc     01 C0 06 F1 | 	add	local14, #1
0bbd0     60 91 C2 FA | 	rdbyte	arg01, local14
0bbd4     28 A6 06 F1 | 	add	local01, #40
0bbd8     53 93 02 F6 | 	mov	arg02, local01
0bbdc     0C A6 86 F1 | 	sub	local01, #12
0bbe0     53 95 02 FB | 	rdlong	arg03, local01
0bbe4     1C A6 86 F1 | 	sub	local01, #28
0bbe8     01 96 06 F6 | 	mov	arg04, #1
0bbec     78 C6 BF FD | 	call	#_fatfs_cc_disk_write
0bbf0     00 76 0E F2 | 	cmp	result1, #0 wz
0bbf4     11 A6 06 51 |  if_ne	add	local01, #17
0bbf8     53 03 48 5C |  if_ne	wrbyte	#1, local01
0bbfc     01 76 06 56 |  if_ne	mov	result1, #1
0bc00     C8 00 90 5D |  if_ne	jmp	#LR__1801
0bc04     10 A6 06 F1 | 	add	local01, #16
0bc08     53 B3 C2 FA | 	rdbyte	local07, local01
0bc0c     7F B2 06 F5 | 	and	local07, #127
0bc10     53 B3 42 FC | 	wrbyte	local07, local01
0bc14     10 A6 86 F1 | 	sub	local01, #16
0bc18                 | LR__1796
0bc18     18 CE 05 F1 | 	add	fp, #24
0bc1c     E7 C0 02 FB | 	rdlong	local14, fp
0bc20     18 CE 85 F1 | 	sub	fp, #24
0bc24     01 C0 06 F1 | 	add	local14, #1
0bc28     60 91 C2 FA | 	rdbyte	arg01, local14
0bc2c     53 93 02 F6 | 	mov	arg02, local01
0bc30     28 92 06 F1 | 	add	arg02, #40
0bc34     5E 95 02 F6 | 	mov	arg03, local12
0bc38     01 96 06 F6 | 	mov	arg04, #1
0bc3c     EC C4 BF FD | 	call	#_fatfs_cc_disk_read
0bc40     00 76 0E F2 | 	cmp	result1, #0 wz
0bc44     11 A6 06 51 |  if_ne	add	local01, #17
0bc48     53 03 48 5C |  if_ne	wrbyte	#1, local01
0bc4c     01 76 06 56 |  if_ne	mov	result1, #1
0bc50     78 00 90 5D |  if_ne	jmp	#LR__1801
0bc54                 | LR__1797
0bc54     1C A6 06 F1 | 	add	local01, #28
0bc58     53 BD 62 FC | 	wrlong	local12, local01
0bc5c     1C A6 86 F1 | 	sub	local01, #28
0bc60                 | LR__1798
0bc60     14 A6 06 F1 | 	add	local01, #20
0bc64     53 BF 02 FB | 	rdlong	local13, local01
0bc68     FF BF 06 F5 | 	and	local13, #511
0bc6c     09 C0 C6 F9 | 	decod	local14, #9
0bc70     5F C1 82 F1 | 	sub	local14, local13
0bc74     55 C1 3A F3 | 	fle	local14, local03 wcz
0bc78     53 93 02 F6 | 	mov	arg02, local01
0bc7c     14 92 06 F1 | 	add	arg02, #20
0bc80     53 BF 02 FB | 	rdlong	local13, local01
0bc84     14 A6 86 F1 | 	sub	local01, #20
0bc88     FF BF 06 F5 | 	and	local13, #511
0bc8c     5F 93 02 F1 | 	add	arg02, local13
0bc90     57 91 02 F6 | 	mov	arg01, local05
0bc94     60 95 02 F6 | 	mov	arg03, local14
0bc98     20 74 BF FD | 	call	#__system____builtin_memmove
0bc9c                 | LR__1799
0bc9c     60 AB 82 F1 | 	sub	local03, local14
0bca0     56 B3 02 FB | 	rdlong	local07, local04
0bca4     60 B3 02 F1 | 	add	local07, local14
0bca8     56 B3 62 FC | 	wrlong	local07, local04
0bcac     60 AF 02 F1 | 	add	local05, local14
0bcb0     14 A6 06 F1 | 	add	local01, #20
0bcb4     53 B3 02 FB | 	rdlong	local07, local01
0bcb8     60 B3 02 F1 | 	add	local07, local14
0bcbc     53 B3 62 FC | 	wrlong	local07, local01
0bcc0     14 A6 86 F1 | 	sub	local01, #20
0bcc4     FC FC 9F FD | 	jmp	#LR__1790
0bcc8                 | LR__1800
0bcc8                 | ' 
0bcc8                 | ' 
0bcc8                 | ' 
0bcc8                 | ' 
0bcc8                 | ' 		__builtin_memcpy(rbuff, fp->buf + fp->fptr % ((UINT) 512 ) , rcnt) ;
0bcc8                 | ' 
0bcc8                 | ' 	}
0bcc8                 | ' 
0bcc8                 | ' 	return FR_OK ;
0bcc8     00 76 06 F6 | 	mov	result1, #0
0bccc                 | LR__1801
0bccc     E7 F0 03 F6 | 	mov	ptra, fp
0bcd0     F2 00 A0 FD | 	call	#popregs_
0bcd4                 | _fatfs_cc_f_read_ret
0bcd4     2D 00 64 FD | 	ret
0bcd8                 | 
0bcd8                 | _fatfs_cc_f_write
0bcd8     12 CA 05 F6 | 	mov	COUNT_, #18
0bcdc     E8 00 A0 FD | 	call	#pushregs_
0bce0     34 F0 07 F1 | 	add	ptra, #52
0bce4     48 A7 02 F6 | 	mov	local01, arg01
0bce8     49 A9 02 F6 | 	mov	local02, arg02
0bcec     4A AB 02 F6 | 	mov	local03, arg03
0bcf0     4B AD 02 F6 | 	mov	local04, arg04
0bcf4     54 AF 02 F6 | 	mov	local05, local02
0bcf8     56 01 68 FC | 	wrlong	#0, local04
0bcfc     E7 92 02 F6 | 	mov	arg02, fp
0bd00     18 92 06 F1 | 	add	arg02, #24
0bd04     53 91 02 F6 | 	mov	arg01, local01
0bd08     94 F6 BF FD | 	call	#_fatfs_cc_validate
0bd0c     3B B1 0A F6 | 	mov	local06, result1 wz
0bd10     11 A6 06 A1 |  if_e	add	local01, #17
0bd14     53 B1 C2 AA |  if_e	rdbyte	local06, local01
0bd18     11 A6 86 A1 |  if_e	sub	local01, #17
0bd1c     00 B0 4E A2 |  if_e	cmps	local06, #0 wz
0bd20     58 77 02 56 |  if_ne	mov	result1, local06
0bd24     F4 03 90 5D |  if_ne	jmp	#LR__1822
0bd28     10 A6 06 F1 | 	add	local01, #16
0bd2c     53 B3 C2 FA | 	rdbyte	local07, local01
0bd30     10 A6 86 F1 | 	sub	local01, #16
0bd34     02 B2 CE F7 | 	test	local07, #2 wz
0bd38     07 76 06 A6 |  if_e	mov	result1, #7
0bd3c     DC 03 90 AD |  if_e	jmp	#LR__1822
0bd40     14 A6 06 F1 | 	add	local01, #20
0bd44     53 B5 02 FB | 	rdlong	local08, local01
0bd48     5A B7 02 F6 | 	mov	local09, local08
0bd4c     55 B7 02 F1 | 	add	local09, local03
0bd50     14 A6 86 F1 | 	sub	local01, #20
0bd54     5A B7 12 F2 | 	cmp	local09, local08 wc
0bd58     01 AA 66 C6 |  if_b	neg	local03, #1
0bd5c     14 A6 06 C1 |  if_b	add	local01, #20
0bd60     53 B9 02 CB |  if_b	rdlong	local10, local01
0bd64     14 A6 86 C1 |  if_b	sub	local01, #20
0bd68     5C AB 82 C1 |  if_b	sub	local03, local10
0bd6c                 | ' 		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
0bd6c                 | ' 	}
0bd6c                 | ' 
0bd6c                 | ' 	for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
0bd6c                 | LR__1810
0bd6c     01 AA 16 F2 | 	cmp	local03, #1 wc
0bd70     94 03 90 CD |  if_b	jmp	#LR__1821
0bd74     14 A6 06 F1 | 	add	local01, #20
0bd78     53 B3 02 FB | 	rdlong	local07, local01
0bd7c     14 A6 86 F1 | 	sub	local01, #20
0bd80     FF B3 CE F7 | 	test	local07, #511 wz
0bd84     D8 02 90 5D |  if_ne	jmp	#LR__1819
0bd88     14 A6 06 F1 | 	add	local01, #20
0bd8c     53 BB 02 FB | 	rdlong	local11, local01
0bd90     14 A6 86 F1 | 	sub	local01, #20
0bd94     09 BA 46 F0 | 	shr	local11, #9
0bd98     18 CE 05 F1 | 	add	fp, #24
0bd9c     E7 B4 02 FB | 	rdlong	local08, fp
0bda0     18 CE 85 F1 | 	sub	fp, #24
0bda4     5A BD 02 F6 | 	mov	local12, local08
0bda8     0A BC 06 F1 | 	add	local12, #10
0bdac     5E BF E2 FA | 	rdword	local13, local12
0bdb0     0A BC 86 F1 | 	sub	local12, #10
0bdb4     5F B7 32 F9 | 	getword	local09, local13, #0
0bdb8     01 B6 86 F1 | 	sub	local09, #1
0bdbc     5B BB 0A F5 | 	and	local11, local09 wz
0bdc0     A0 00 90 5D |  if_ne	jmp	#LR__1813
0bdc4     14 A6 06 F1 | 	add	local01, #20
0bdc8     53 B3 0A FB | 	rdlong	local07, local01 wz
0bdcc     14 A6 86 F1 | 	sub	local01, #20
0bdd0     24 00 90 5D |  if_ne	jmp	#LR__1811
0bdd4     08 A6 06 F1 | 	add	local01, #8
0bdd8     53 C1 0A FB | 	rdlong	local14, local01 wz
0bddc     08 A6 86 F1 | 	sub	local01, #8
0bde0     2C 00 90 5D |  if_ne	jmp	#LR__1812
0bde4     53 91 02 F6 | 	mov	arg01, local01
0bde8     00 92 06 F6 | 	mov	arg02, #0
0bdec     44 D0 BF FD | 	call	#_fatfs_cc_create_chain
0bdf0     3B C1 02 F6 | 	mov	local14, result1
0bdf4     18 00 90 FD | 	jmp	#LR__1812
0bdf8                 | LR__1811
0bdf8     53 91 02 F6 | 	mov	arg01, local01
0bdfc     18 A6 06 F1 | 	add	local01, #24
0be00     53 93 02 FB | 	rdlong	arg02, local01
0be04     18 A6 86 F1 | 	sub	local01, #24
0be08     28 D0 BF FD | 	call	#_fatfs_cc_create_chain
0be0c     3B C1 02 F6 | 	mov	local14, result1
0be10                 | LR__1812
0be10     00 C0 0E F2 | 	cmp	local14, #0 wz
0be14     F0 02 90 AD |  if_e	jmp	#LR__1821
0be18     01 C0 0E F2 | 	cmp	local14, #1 wz
0be1c     11 A6 06 A1 |  if_e	add	local01, #17
0be20     53 05 48 AC |  if_e	wrbyte	#2, local01
0be24     02 76 06 A6 |  if_e	mov	result1, #2
0be28     F0 02 90 AD |  if_e	jmp	#LR__1822
0be2c     FF FF 7F FF 
0be30     FF C1 0E F2 | 	cmp	local14, ##-1 wz
0be34     11 A6 06 A1 |  if_e	add	local01, #17
0be38     53 03 48 AC |  if_e	wrbyte	#1, local01
0be3c     01 76 06 A6 |  if_e	mov	result1, #1
0be40     D8 02 90 AD |  if_e	jmp	#LR__1822
0be44     18 A6 06 F1 | 	add	local01, #24
0be48     53 C1 62 FC | 	wrlong	local14, local01
0be4c     10 A6 86 F1 | 	sub	local01, #16
0be50     53 B3 0A FB | 	rdlong	local07, local01 wz
0be54     08 A6 86 F1 | 	sub	local01, #8
0be58     08 A6 06 A1 |  if_e	add	local01, #8
0be5c     53 C1 62 AC |  if_e	wrlong	local14, local01
0be60     08 A6 86 A1 |  if_e	sub	local01, #8
0be64                 | LR__1813
0be64     10 A6 06 F1 | 	add	local01, #16
0be68     53 B3 C2 FA | 	rdbyte	local07, local01
0be6c     10 A6 86 F1 | 	sub	local01, #16
0be70     80 B2 CE F7 | 	test	local07, #128 wz
0be74     58 00 90 AD |  if_e	jmp	#LR__1814
0be78     18 CE 05 F1 | 	add	fp, #24
0be7c     E7 B8 02 FB | 	rdlong	local10, fp
0be80     18 CE 85 F1 | 	sub	fp, #24
0be84     01 B8 06 F1 | 	add	local10, #1
0be88     5C 91 C2 FA | 	rdbyte	arg01, local10
0be8c     28 A6 06 F1 | 	add	local01, #40
0be90     53 93 02 F6 | 	mov	arg02, local01
0be94     0C A6 86 F1 | 	sub	local01, #12
0be98     53 95 02 FB | 	rdlong	arg03, local01
0be9c     1C A6 86 F1 | 	sub	local01, #28
0bea0     01 96 06 F6 | 	mov	arg04, #1
0bea4     C0 C3 BF FD | 	call	#_fatfs_cc_disk_write
0bea8     00 76 0E F2 | 	cmp	result1, #0 wz
0beac     11 A6 06 51 |  if_ne	add	local01, #17
0beb0     53 03 48 5C |  if_ne	wrbyte	#1, local01
0beb4     01 76 06 56 |  if_ne	mov	result1, #1
0beb8     60 02 90 5D |  if_ne	jmp	#LR__1822
0bebc     10 A6 06 F1 | 	add	local01, #16
0bec0     53 B3 C2 FA | 	rdbyte	local07, local01
0bec4     7F B2 06 F5 | 	and	local07, #127
0bec8     53 B3 42 FC | 	wrbyte	local07, local01
0becc     10 A6 86 F1 | 	sub	local01, #16
0bed0                 | LR__1814
0bed0     18 CE 05 F1 | 	add	fp, #24
0bed4     E7 90 02 FB | 	rdlong	arg01, fp
0bed8     18 CE 85 F1 | 	sub	fp, #24
0bedc     18 A6 06 F1 | 	add	local01, #24
0bee0     53 93 02 FB | 	rdlong	arg02, local01
0bee4     18 A6 86 F1 | 	sub	local01, #24
0bee8     40 CA BF FD | 	call	#_fatfs_cc_clst2sect
0beec     3B C3 0A F6 | 	mov	local15, result1 wz
0bef0     11 A6 06 A1 |  if_e	add	local01, #17
0bef4     53 05 48 AC |  if_e	wrbyte	#2, local01
0bef8     02 76 06 A6 |  if_e	mov	result1, #2
0befc     1C 02 90 AD |  if_e	jmp	#LR__1822
0bf00     5D C3 02 F1 | 	add	local15, local11
0bf04     55 C5 02 F6 | 	mov	local16, local03
0bf08     09 C4 46 F0 | 	shr	local16, #9
0bf0c     01 C4 16 F2 | 	cmp	local16, #1 wc
0bf10     D4 00 90 CD |  if_b	jmp	#LR__1817
0bf14     5D B3 02 F6 | 	mov	local07, local11
0bf18     62 B3 02 F1 | 	add	local07, local16
0bf1c     18 CE 05 F1 | 	add	fp, #24
0bf20     E7 C6 02 FB | 	rdlong	local17, fp
0bf24     18 CE 85 F1 | 	sub	fp, #24
0bf28     0A C6 06 F1 | 	add	local17, #10
0bf2c     63 B9 E2 FA | 	rdword	local10, local17
0bf30     5C B3 1A F2 | 	cmp	local07, local10 wcz
0bf34     18 00 90 ED |  if_be	jmp	#LR__1815
0bf38     18 CE 05 F1 | 	add	fp, #24
0bf3c     E7 B8 02 FB | 	rdlong	local10, fp
0bf40     18 CE 85 F1 | 	sub	fp, #24
0bf44     0A B8 06 F1 | 	add	local10, #10
0bf48     5C C5 E2 FA | 	rdword	local16, local10
0bf4c     5D C5 82 F1 | 	sub	local16, local11
0bf50                 | LR__1815
0bf50     18 CE 05 F1 | 	add	fp, #24
0bf54     E7 B8 02 FB | 	rdlong	local10, fp
0bf58     18 CE 85 F1 | 	sub	fp, #24
0bf5c     01 B8 06 F1 | 	add	local10, #1
0bf60     5C 91 C2 FA | 	rdbyte	arg01, local10
0bf64     57 93 02 F6 | 	mov	arg02, local05
0bf68     61 95 02 F6 | 	mov	arg03, local15
0bf6c     62 97 02 F6 | 	mov	arg04, local16
0bf70     F4 C2 BF FD | 	call	#_fatfs_cc_disk_write
0bf74     00 76 0E F2 | 	cmp	result1, #0 wz
0bf78     11 A6 06 51 |  if_ne	add	local01, #17
0bf7c     53 03 48 5C |  if_ne	wrbyte	#1, local01
0bf80     01 76 06 56 |  if_ne	mov	result1, #1
0bf84     94 01 90 5D |  if_ne	jmp	#LR__1822
0bf88     1C A6 06 F1 | 	add	local01, #28
0bf8c     53 B3 02 FB | 	rdlong	local07, local01
0bf90     1C A6 86 F1 | 	sub	local01, #28
0bf94     61 B3 82 F1 | 	sub	local07, local15
0bf98     62 B3 12 F2 | 	cmp	local07, local16 wc
0bf9c     3C 00 90 3D |  if_ae	jmp	#LR__1816
0bfa0     28 A6 06 F1 | 	add	local01, #40
0bfa4     53 91 02 F6 | 	mov	arg01, local01
0bfa8     57 93 02 F6 | 	mov	arg02, local05
0bfac     0C A6 86 F1 | 	sub	local01, #12
0bfb0     53 BF 02 FB | 	rdlong	local13, local01
0bfb4     61 BF 82 F1 | 	sub	local13, local15
0bfb8     09 BE 66 F0 | 	shl	local13, #9
0bfbc     5F 93 02 F1 | 	add	arg02, local13
0bfc0     09 94 C6 F9 | 	decod	arg03, #9
0bfc4     F4 70 BF FD | 	call	#__system____builtin_memmove
0bfc8     0C A6 86 F1 | 	sub	local01, #12
0bfcc     53 B3 C2 FA | 	rdbyte	local07, local01
0bfd0     7F B2 06 F5 | 	and	local07, #127
0bfd4     53 B3 42 FC | 	wrbyte	local07, local01
0bfd8     10 A6 86 F1 | 	sub	local01, #16
0bfdc                 | LR__1816
0bfdc     62 C9 02 F6 | 	mov	local18, local16
0bfe0     09 C8 66 F0 | 	shl	local18, #9
0bfe4                 | ' 					__builtin_memcpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT) 512 ) ), ((UINT) 512 ) ) ;
0bfe4                 | ' 					fp->flag &= (BYTE)~ 0x80 ;
0bfe4                 | ' 				}
0bfe4                 | ' 
0bfe4                 | ' 
0bfe4                 | ' 				wcnt =  ((UINT) 512 )  * cc;
0bfe4                 | ' 				continue;
0bfe4     C4 00 90 FD | 	jmp	#LR__1820
0bfe8                 | LR__1817
0bfe8     1C A6 06 F1 | 	add	local01, #28
0bfec     53 B3 02 FB | 	rdlong	local07, local01
0bff0     1C A6 86 F1 | 	sub	local01, #28
0bff4     61 B3 0A F2 | 	cmp	local07, local15 wz
0bff8     58 00 90 AD |  if_e	jmp	#LR__1818
0bffc     14 A6 06 F1 | 	add	local01, #20
0c000     53 C7 02 FB | 	rdlong	local17, local01
0c004     08 A6 86 F1 | 	sub	local01, #8
0c008     53 BD 02 FB | 	rdlong	local12, local01
0c00c     0C A6 86 F1 | 	sub	local01, #12
0c010     5E C7 12 F2 | 	cmp	local17, local12 wc
0c014     3C 00 90 3D |  if_ae	jmp	#LR__1818
0c018     18 CE 05 F1 | 	add	fp, #24
0c01c     E7 C8 02 FB | 	rdlong	local18, fp
0c020     18 CE 85 F1 | 	sub	fp, #24
0c024     01 C8 06 F1 | 	add	local18, #1
0c028     64 91 C2 FA | 	rdbyte	arg01, local18
0c02c     53 93 02 F6 | 	mov	arg02, local01
0c030     28 92 06 F1 | 	add	arg02, #40
0c034     61 95 02 F6 | 	mov	arg03, local15
0c038     01 96 06 F6 | 	mov	arg04, #1
0c03c     EC C0 BF FD | 	call	#_fatfs_cc_disk_read
0c040     00 76 0E F2 | 	cmp	result1, #0 wz
0c044     11 A6 06 51 |  if_ne	add	local01, #17
0c048     53 03 48 5C |  if_ne	wrbyte	#1, local01
0c04c                 | ' 				fp->fptr < fp->obj.objsize &&
0c04c                 | ' 				disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
0c04c                 | ' 					{ fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR ; } ;
0c04c     01 76 06 56 |  if_ne	mov	result1, #1
0c050     C8 00 90 5D |  if_ne	jmp	#LR__1822
0c054                 | LR__1818
0c054     1C A6 06 F1 | 	add	local01, #28
0c058     53 C3 62 FC | 	wrlong	local15, local01
0c05c     1C A6 86 F1 | 	sub	local01, #28
0c060                 | LR__1819
0c060     14 A6 06 F1 | 	add	local01, #20
0c064     53 B9 02 FB | 	rdlong	local10, local01
0c068     FF B9 06 F5 | 	and	local10, #511
0c06c     09 C8 C6 F9 | 	decod	local18, #9
0c070     5C C9 82 F1 | 	sub	local18, local10
0c074     55 C9 3A F3 | 	fle	local18, local03 wcz
0c078     53 91 02 F6 | 	mov	arg01, local01
0c07c     14 90 06 F1 | 	add	arg01, #20
0c080     53 BF 02 FB | 	rdlong	local13, local01
0c084     FF BF 06 F5 | 	and	local13, #511
0c088     5F 91 02 F1 | 	add	arg01, local13
0c08c     57 93 02 F6 | 	mov	arg02, local05
0c090     64 95 02 F6 | 	mov	arg03, local18
0c094     24 70 BF FD | 	call	#__system____builtin_memmove
0c098     04 A6 86 F1 | 	sub	local01, #4
0c09c     53 B3 C2 FA | 	rdbyte	local07, local01
0c0a0     80 B2 46 F5 | 	or	local07, #128
0c0a4     53 B3 42 FC | 	wrbyte	local07, local01
0c0a8     10 A6 86 F1 | 	sub	local01, #16
0c0ac                 | LR__1820
0c0ac     64 AB 82 F1 | 	sub	local03, local18
0c0b0     56 B3 02 FB | 	rdlong	local07, local04
0c0b4     64 B3 02 F1 | 	add	local07, local18
0c0b8     56 B3 62 FC | 	wrlong	local07, local04
0c0bc     64 AF 02 F1 | 	add	local05, local18
0c0c0     14 A6 06 F1 | 	add	local01, #20
0c0c4     53 B9 02 FB | 	rdlong	local10, local01
0c0c8     64 B9 02 F1 | 	add	local10, local18
0c0cc     53 B9 62 FC | 	wrlong	local10, local01
0c0d0     08 A6 86 F1 | 	sub	local01, #8
0c0d4     53 B7 02 FB | 	rdlong	local09, local01
0c0d8     0C A6 86 F1 | 	sub	local01, #12
0c0dc     5B B9 1A F2 | 	cmp	local10, local09 wcz
0c0e0     14 A6 06 11 |  if_a	add	local01, #20
0c0e4     53 B3 02 1B |  if_a	rdlong	local07, local01
0c0e8     14 A6 86 11 |  if_a	sub	local01, #20
0c0ec     0C A6 06 E1 |  if_be	add	local01, #12
0c0f0     53 B3 02 EB |  if_be	rdlong	local07, local01
0c0f4     0C A6 86 E1 |  if_be	sub	local01, #12
0c0f8     0C A6 06 F1 | 	add	local01, #12
0c0fc     53 B3 62 FC | 	wrlong	local07, local01
0c100     0C A6 86 F1 | 	sub	local01, #12
0c104     64 FC 9F FD | 	jmp	#LR__1810
0c108                 | LR__1821
0c108     10 A6 06 F1 | 	add	local01, #16
0c10c     53 B3 C2 FA | 	rdbyte	local07, local01
0c110     40 B2 46 F5 | 	or	local07, #64
0c114     53 B3 42 FC | 	wrbyte	local07, local01
0c118                 | ' 
0c118                 | ' 
0c118                 | ' 
0c118                 | ' 
0c118                 | ' 
0c118                 | ' 		__builtin_memcpy(fp->buf + fp->fptr % ((UINT) 512 ) , wbuff, wcnt) ;
0c118                 | ' 		fp->flag |=  0x80 ;
0c118                 | ' 
0c118                 | ' 	}
0c118                 | ' 
0c118                 | ' 	fp->flag |=  0x40 ;
0c118                 | ' 
0c118                 | ' 	return FR_OK ;
0c118     00 76 06 F6 | 	mov	result1, #0
0c11c                 | LR__1822
0c11c     E7 F0 03 F6 | 	mov	ptra, fp
0c120     F2 00 A0 FD | 	call	#popregs_
0c124                 | _fatfs_cc_f_write_ret
0c124     2D 00 64 FD | 	ret
0c128                 | 
0c128                 | _fatfs_cc_f_sync
0c128     03 CA 05 F6 | 	mov	COUNT_, #3
0c12c     E8 00 A0 FD | 	call	#pushregs_
0c130     18 F0 07 F1 | 	add	ptra, #24
0c134     48 A7 02 F6 | 	mov	local01, arg01
0c138     E7 92 02 F6 | 	mov	arg02, fp
0c13c     0C 92 06 F1 | 	add	arg02, #12
0c140     53 91 02 F6 | 	mov	arg01, local01
0c144     58 F2 BF FD | 	call	#_fatfs_cc_validate
0c148     3B A9 0A F6 | 	mov	local02, result1 wz
0c14c     30 01 90 5D |  if_ne	jmp	#LR__1833
0c150     10 A6 06 F1 | 	add	local01, #16
0c154     53 97 C2 FA | 	rdbyte	arg04, local01
0c158     10 A6 86 F1 | 	sub	local01, #16
0c15c     40 96 CE F7 | 	test	arg04, #64 wz
0c160     1C 01 90 AD |  if_e	jmp	#LR__1832
0c164     10 A6 06 F1 | 	add	local01, #16
0c168     53 A9 C2 FA | 	rdbyte	local02, local01
0c16c     10 A6 86 F1 | 	sub	local01, #16
0c170     80 A8 CE F7 | 	test	local02, #128 wz
0c174     50 00 90 AD |  if_e	jmp	#LR__1830
0c178     0C CE 05 F1 | 	add	fp, #12
0c17c     E7 A8 02 FB | 	rdlong	local02, fp
0c180     0C CE 85 F1 | 	sub	fp, #12
0c184     01 A8 06 F1 | 	add	local02, #1
0c188     54 91 C2 FA | 	rdbyte	arg01, local02
0c18c     28 A6 06 F1 | 	add	local01, #40
0c190     53 93 02 F6 | 	mov	arg02, local01
0c194     0C A6 86 F1 | 	sub	local01, #12
0c198     53 95 02 FB | 	rdlong	arg03, local01
0c19c     1C A6 86 F1 | 	sub	local01, #28
0c1a0     01 96 06 F6 | 	mov	arg04, #1
0c1a4     C0 C0 BF FD | 	call	#_fatfs_cc_disk_write
0c1a8     00 76 0E F2 | 	cmp	result1, #0 wz
0c1ac     01 76 06 56 |  if_ne	mov	result1, #1
0c1b0     D0 00 90 5D |  if_ne	jmp	#LR__1834
0c1b4     10 A6 06 F1 | 	add	local01, #16
0c1b8     53 A9 C2 FA | 	rdbyte	local02, local01
0c1bc     7F A8 06 F5 | 	and	local02, #127
0c1c0     53 A9 42 FC | 	wrbyte	local02, local01
0c1c4     10 A6 86 F1 | 	sub	local01, #16
0c1c8                 | LR__1830
0c1c8     EC 0F B0 FD | 	call	#_fatfs_cc__get_fattime
0c1cc     3B AB 02 F6 | 	mov	local03, result1
0c1d0     0C CE 05 F1 | 	add	fp, #12
0c1d4     E7 90 02 FB | 	rdlong	arg01, fp
0c1d8     0C CE 85 F1 | 	sub	fp, #12
0c1dc     20 A6 06 F1 | 	add	local01, #32
0c1e0     53 93 02 FB | 	rdlong	arg02, local01
0c1e4     20 A6 86 F1 | 	sub	local01, #32
0c1e8     C8 C5 BF FD | 	call	#_fatfs_cc_move_window
0c1ec     3B A9 0A F6 | 	mov	local02, result1 wz
0c1f0     8C 00 90 5D |  if_ne	jmp	#LR__1831
0c1f4     24 A6 06 F1 | 	add	local01, #36
0c1f8     53 A9 02 FB | 	rdlong	local02, local01
0c1fc     24 A6 86 F1 | 	sub	local01, #36
0c200     0B A8 06 F1 | 	add	local02, #11
0c204     54 97 C2 FA | 	rdbyte	arg04, local02
0c208     20 96 46 F5 | 	or	arg04, #32
0c20c     54 97 42 FC | 	wrbyte	arg04, local02
0c210     0B A8 86 F1 | 	sub	local02, #11
0c214     53 91 02 FB | 	rdlong	arg01, local01
0c218     08 A6 06 F1 | 	add	local01, #8
0c21c     53 95 02 FB | 	rdlong	arg03, local01
0c220     54 93 02 F6 | 	mov	arg02, local02
0c224     F8 D2 BF FD | 	call	#_fatfs_cc_st_clust
0c228     54 91 02 F6 | 	mov	arg01, local02
0c22c     1C 90 06 F1 | 	add	arg01, #28
0c230     04 A6 06 F1 | 	add	local01, #4
0c234     53 93 02 FB | 	rdlong	arg02, local01
0c238     48 93 62 FC | 	wrlong	arg02, arg01
0c23c     54 91 02 F6 | 	mov	arg01, local02
0c240     16 90 06 F1 | 	add	arg01, #22
0c244     48 AB 62 FC | 	wrlong	local03, arg01
0c248     12 A8 06 F1 | 	add	local02, #18
0c24c     54 01 58 FC | 	wrword	#0, local02
0c250     0C CE 05 F1 | 	add	fp, #12
0c254     E7 AA 02 FB | 	rdlong	local03, fp
0c258     03 AA 06 F1 | 	add	local03, #3
0c25c     55 03 48 FC | 	wrbyte	#1, local03
0c260     E7 90 02 FB | 	rdlong	arg01, fp
0c264     0C CE 85 F1 | 	sub	fp, #12
0c268     C0 C5 BF FD | 	call	#_fatfs_cc_sync_fs
0c26c     3B A9 02 F6 | 	mov	local02, result1
0c270     04 A6 06 F1 | 	add	local01, #4
0c274     53 AB C2 FA | 	rdbyte	local03, local01
0c278     BF AA 06 F5 | 	and	local03, #191
0c27c     53 AB 42 FC | 	wrbyte	local03, local01
0c280                 | LR__1831
0c280                 | LR__1832
0c280                 | LR__1833
0c280                 | ' 					dir = fp->dir_ptr;
0c280                 | ' 					dir[ 11 ] |=  0x20 ;
0c280                 | ' 					st_clust(fp->obj.fs, dir, fp->obj.sclust);
0c280                 | ' 					st_dword(dir +  28 , (DWORD)fp->obj.objsize);
0c280                 | ' 					st_dword(dir +  22 , tm);
0c280                 | ' 					st_word(dir +  18 , 0);
0c280                 | ' 					fs->wflag = 1;
0c280                 | ' 					res = sync_fs(fs);
0c280                 | ' 					fp->flag &= (BYTE)~ 0x40 ;
0c280                 | ' 				}
0c280                 | ' 			}
0c280                 | ' 		}
0c280                 | ' 	}
0c280                 | ' 
0c280                 | ' 	return res ;
0c280     54 77 02 F6 | 	mov	result1, local02
0c284                 | LR__1834
0c284     E7 F0 03 F6 | 	mov	ptra, fp
0c288     F2 00 A0 FD | 	call	#popregs_
0c28c                 | _fatfs_cc_f_sync_ret
0c28c     2D 00 64 FD | 	ret
0c290                 | 
0c290                 | _fatfs_cc_f_close
0c290     02 CA 05 F6 | 	mov	COUNT_, #2
0c294     E8 00 A0 FD | 	call	#pushregs_
0c298     10 F0 07 F1 | 	add	ptra, #16
0c29c     48 A7 02 F6 | 	mov	local01, arg01
0c2a0     84 FE BF FD | 	call	#_fatfs_cc_f_sync
0c2a4     3B A9 0A F6 | 	mov	local02, result1 wz
0c2a8     18 00 90 5D |  if_ne	jmp	#LR__1840
0c2ac     E7 92 02 F6 | 	mov	arg02, fp
0c2b0     0C 92 06 F1 | 	add	arg02, #12
0c2b4     53 91 02 F6 | 	mov	arg01, local01
0c2b8     E4 F0 BF FD | 	call	#_fatfs_cc_validate
0c2bc     3B A9 0A F6 | 	mov	local02, result1 wz
0c2c0     53 01 68 AC |  if_e	wrlong	#0, local01
0c2c4                 | LR__1840
0c2c4                 | ' 
0c2c4                 | ' 
0c2c4                 | ' 
0c2c4                 | ' 
0c2c4                 | ' 			fp->obj.fs = 0;
0c2c4                 | ' #line 4192 "ff.c"
0c2c4                 | ' 		}
0c2c4                 | ' 	}
0c2c4                 | ' 	return res;
0c2c4     54 77 02 F6 | 	mov	result1, local02
0c2c8     E7 F0 03 F6 | 	mov	ptra, fp
0c2cc     F2 00 A0 FD | 	call	#popregs_
0c2d0                 | _fatfs_cc_f_close_ret
0c2d0     2D 00 64 FD | 	ret
0c2d4                 | 
0c2d4                 | _fatfs_cc_f_lseek
0c2d4     0D CA 05 F6 | 	mov	COUNT_, #13
0c2d8     E8 00 A0 FD | 	call	#pushregs_
0c2dc     24 F0 07 F1 | 	add	ptra, #36
0c2e0     48 A7 02 F6 | 	mov	local01, arg01
0c2e4     49 A9 02 F6 | 	mov	local02, arg02
0c2e8     E7 92 02 F6 | 	mov	arg02, fp
0c2ec     10 92 06 F1 | 	add	arg02, #16
0c2f0     53 91 02 F6 | 	mov	arg01, local01
0c2f4     A8 F0 BF FD | 	call	#_fatfs_cc_validate
0c2f8     3B AB 0A F6 | 	mov	local03, result1 wz
0c2fc     11 A6 06 A1 |  if_e	add	local01, #17
0c300     53 AB C2 AA |  if_e	rdbyte	local03, local01
0c304     11 A6 86 A1 |  if_e	sub	local01, #17
0c308     00 AA 0E F2 | 	cmp	local03, #0 wz
0c30c     55 77 02 56 |  if_ne	mov	result1, local03
0c310     5C 03 90 5D |  if_ne	jmp	#LR__1866
0c314     0C A6 06 F1 | 	add	local01, #12
0c318     53 AD 02 FB | 	rdlong	local04, local01
0c31c     0C A6 86 F1 | 	sub	local01, #12
0c320     56 A9 1A F2 | 	cmp	local02, local04 wcz
0c324     20 00 90 ED |  if_be	jmp	#LR__1850
0c328     10 A6 06 F1 | 	add	local01, #16
0c32c     53 AF C2 FA | 	rdbyte	local05, local01
0c330     10 A6 86 F1 | 	sub	local01, #16
0c334     57 B1 E2 F8 | 	getbyte	local06, local05, #0
0c338     02 B0 CE F7 | 	test	local06, #2 wz
0c33c     0C A6 06 A1 |  if_e	add	local01, #12
0c340     53 A9 02 AB |  if_e	rdlong	local02, local01
0c344     0C A6 86 A1 |  if_e	sub	local01, #12
0c348                 | LR__1850
0c348     14 A6 06 F1 | 	add	local01, #20
0c34c     53 B3 02 FB | 	rdlong	local07, local01
0c350     00 B4 06 F6 | 	mov	local08, #0
0c354     53 01 68 FC | 	wrlong	#0, local01
0c358     14 A6 86 F1 | 	sub	local01, #20
0c35c     01 A8 16 F2 | 	cmp	local02, #1 wc
0c360     F4 01 90 CD |  if_b	jmp	#LR__1862
0c364     10 CE 05 F1 | 	add	fp, #16
0c368     E7 B6 02 FB | 	rdlong	local09, fp
0c36c     10 CE 85 F1 | 	sub	fp, #16
0c370     0A B6 06 F1 | 	add	local09, #10
0c374     5B AF E2 FA | 	rdword	local05, local09
0c378     57 B9 32 F9 | 	getword	local10, local05, #0
0c37c     09 B8 66 F0 | 	shl	local10, #9
0c380     5C BB 02 F6 | 	mov	local11, local10
0c384     01 B2 16 F2 | 	cmp	local07, #1 wc
0c388     5C 00 90 CD |  if_b	jmp	#LR__1851
0c38c     54 B7 02 F6 | 	mov	local09, local02
0c390     01 B6 86 F1 | 	sub	local09, #1
0c394     5D B7 12 FD | 	qdiv	local09, local11
0c398     59 AF 02 F6 | 	mov	local05, local07
0c39c     01 AE 86 F1 | 	sub	local05, #1
0c3a0     5D BD 02 F6 | 	mov	local12, local11
0c3a4     18 B6 62 FD | 	getqx	local09
0c3a8     5E AF 12 FD | 	qdiv	local05, local12
0c3ac     18 B8 62 FD | 	getqx	local10
0c3b0     5C B7 12 F2 | 	cmp	local09, local10 wc
0c3b4     30 00 90 CD |  if_b	jmp	#LR__1851
0c3b8     59 B1 02 F6 | 	mov	local06, local07
0c3bc     01 B0 86 F1 | 	sub	local06, #1
0c3c0     5D B7 02 F6 | 	mov	local09, local11
0c3c4     01 B6 86 F1 | 	sub	local09, #1
0c3c8     5B B1 22 F5 | 	andn	local06, local09
0c3cc     14 A6 06 F1 | 	add	local01, #20
0c3d0     53 B1 62 FC | 	wrlong	local06, local01
0c3d4     58 A9 82 F1 | 	sub	local02, local06
0c3d8     04 A6 06 F1 | 	add	local01, #4
0c3dc     53 BF 02 FB | 	rdlong	local13, local01
0c3e0     18 A6 86 F1 | 	sub	local01, #24
0c3e4     64 00 90 FD | 	jmp	#LR__1853
0c3e8                 | LR__1851
0c3e8     08 A6 06 F1 | 	add	local01, #8
0c3ec     53 BF 0A FB | 	rdlong	local13, local01 wz
0c3f0     08 A6 86 F1 | 	sub	local01, #8
0c3f4     48 00 90 5D |  if_ne	jmp	#LR__1852
0c3f8     53 91 02 F6 | 	mov	arg01, local01
0c3fc     00 92 06 F6 | 	mov	arg02, #0
0c400     30 CA BF FD | 	call	#_fatfs_cc_create_chain
0c404     3B BF 02 F6 | 	mov	local13, result1
0c408     01 BE 0E F2 | 	cmp	local13, #1 wz
0c40c     11 A6 06 A1 |  if_e	add	local01, #17
0c410     53 05 48 AC |  if_e	wrbyte	#2, local01
0c414     02 76 06 A6 |  if_e	mov	result1, #2
0c418     54 02 90 AD |  if_e	jmp	#LR__1866
0c41c     FF FF 7F FF 
0c420     FF BF 0E F2 | 	cmp	local13, ##-1 wz
0c424     11 A6 06 A1 |  if_e	add	local01, #17
0c428     53 03 48 AC |  if_e	wrbyte	#1, local01
0c42c     01 76 06 A6 |  if_e	mov	result1, #1
0c430     3C 02 90 AD |  if_e	jmp	#LR__1866
0c434     08 A6 06 F1 | 	add	local01, #8
0c438     53 BF 62 FC | 	wrlong	local13, local01
0c43c     08 A6 86 F1 | 	sub	local01, #8
0c440                 | LR__1852
0c440     18 A6 06 F1 | 	add	local01, #24
0c444     53 BF 62 FC | 	wrlong	local13, local01
0c448     18 A6 86 F1 | 	sub	local01, #24
0c44c                 | LR__1853
0c44c     00 BE 0E F2 | 	cmp	local13, #0 wz
0c450     04 01 90 AD |  if_e	jmp	#LR__1861
0c454                 | ' 				while (ofs > bcs) {
0c454                 | LR__1854
0c454     5D A9 1A F2 | 	cmp	local02, local11 wcz
0c458     B0 00 90 ED |  if_be	jmp	#LR__1859
0c45c     5D A9 82 F1 | 	sub	local02, local11
0c460     14 A6 06 F1 | 	add	local01, #20
0c464     53 AD 02 FB | 	rdlong	local04, local01
0c468     5D AD 02 F1 | 	add	local04, local11
0c46c     53 AD 62 FC | 	wrlong	local04, local01
0c470     04 A6 86 F1 | 	sub	local01, #4
0c474     53 AD C2 FA | 	rdbyte	local04, local01
0c478     10 A6 86 F1 | 	sub	local01, #16
0c47c     02 AC CE F7 | 	test	local04, #2 wz
0c480     1C 00 90 AD |  if_e	jmp	#LR__1855
0c484     53 91 02 F6 | 	mov	arg01, local01
0c488     5F 93 02 F6 | 	mov	arg02, local13
0c48c     A4 C9 BF FD | 	call	#_fatfs_cc_create_chain
0c490     3B BF 0A F6 | 	mov	local13, result1 wz
0c494     00 A8 06 A6 |  if_e	mov	local02, #0
0c498                 | ' 							ofs = 0; break;
0c498     70 00 90 AD |  if_e	jmp	#LR__1859
0c49c     10 00 90 FD | 	jmp	#LR__1856
0c4a0                 | LR__1855
0c4a0     53 91 02 F6 | 	mov	arg01, local01
0c4a4     5F 93 02 F6 | 	mov	arg02, local13
0c4a8     C0 C4 BF FD | 	call	#_fatfs_cc_get_fat
0c4ac     3B BF 02 F6 | 	mov	local13, result1
0c4b0                 | LR__1856
0c4b0     FF FF 7F FF 
0c4b4     FF BF 0E F2 | 	cmp	local13, ##-1 wz
0c4b8     11 A6 06 A1 |  if_e	add	local01, #17
0c4bc     53 03 48 AC |  if_e	wrbyte	#1, local01
0c4c0     01 76 06 A6 |  if_e	mov	result1, #1
0c4c4     A8 01 90 AD |  if_e	jmp	#LR__1866
0c4c8     02 BE 16 F2 | 	cmp	local13, #2 wc
0c4cc     1C 00 90 CD |  if_b	jmp	#LR__1857
0c4d0     10 CE 05 F1 | 	add	fp, #16
0c4d4     E7 AC 02 FB | 	rdlong	local04, fp
0c4d8     10 CE 85 F1 | 	sub	fp, #16
0c4dc     18 AC 06 F1 | 	add	local04, #24
0c4e0     56 AF 02 FB | 	rdlong	local05, local04
0c4e4     57 BF 12 F2 | 	cmp	local13, local05 wc
0c4e8     10 00 90 CD |  if_b	jmp	#LR__1858
0c4ec                 | LR__1857
0c4ec     11 A6 06 F1 | 	add	local01, #17
0c4f0     53 05 48 FC | 	wrbyte	#2, local01
0c4f4     02 76 06 F6 | 	mov	result1, #2
0c4f8     74 01 90 FD | 	jmp	#LR__1866
0c4fc                 | LR__1858
0c4fc     18 A6 06 F1 | 	add	local01, #24
0c500     53 BF 62 FC | 	wrlong	local13, local01
0c504     18 A6 86 F1 | 	sub	local01, #24
0c508     48 FF 9F FD | 	jmp	#LR__1854
0c50c                 | LR__1859
0c50c     14 A6 06 F1 | 	add	local01, #20
0c510     53 AD 02 FB | 	rdlong	local04, local01
0c514     54 AD 02 F1 | 	add	local04, local02
0c518     53 AD 62 FC | 	wrlong	local04, local01
0c51c     14 A6 86 F1 | 	sub	local01, #20
0c520     FF A9 CE F7 | 	test	local02, #511 wz
0c524     30 00 90 AD |  if_e	jmp	#LR__1860
0c528     10 CE 05 F1 | 	add	fp, #16
0c52c     E7 90 02 FB | 	rdlong	arg01, fp
0c530     10 CE 85 F1 | 	sub	fp, #16
0c534     5F 93 02 F6 | 	mov	arg02, local13
0c538     F0 C3 BF FD | 	call	#_fatfs_cc_clst2sect
0c53c     3B B5 0A F6 | 	mov	local08, result1 wz
0c540     11 A6 06 A1 |  if_e	add	local01, #17
0c544     53 05 48 AC |  if_e	wrbyte	#2, local01
0c548     02 76 06 A6 |  if_e	mov	result1, #2
0c54c     20 01 90 AD |  if_e	jmp	#LR__1866
0c550     09 A8 46 F0 | 	shr	local02, #9
0c554     54 B5 02 F1 | 	add	local08, local02
0c558                 | LR__1860
0c558                 | LR__1861
0c558                 | LR__1862
0c558     14 A6 06 F1 | 	add	local01, #20
0c55c     53 AD 02 FB | 	rdlong	local04, local01
0c560     08 A6 86 F1 | 	sub	local01, #8
0c564     53 B1 02 FB | 	rdlong	local06, local01
0c568     0C A6 86 F1 | 	sub	local01, #12
0c56c     58 AD 1A F2 | 	cmp	local04, local06 wcz
0c570     24 00 90 ED |  if_be	jmp	#LR__1863
0c574     14 A6 06 F1 | 	add	local01, #20
0c578     53 AD 02 FB | 	rdlong	local04, local01
0c57c     08 A6 86 F1 | 	sub	local01, #8
0c580     53 AD 62 FC | 	wrlong	local04, local01
0c584     04 A6 06 F1 | 	add	local01, #4
0c588     53 AD C2 FA | 	rdbyte	local04, local01
0c58c     40 AC 46 F5 | 	or	local04, #64
0c590     53 AD 42 FC | 	wrbyte	local04, local01
0c594     10 A6 86 F1 | 	sub	local01, #16
0c598                 | LR__1863
0c598     14 A6 06 F1 | 	add	local01, #20
0c59c     53 AD 02 FB | 	rdlong	local04, local01
0c5a0     14 A6 86 F1 | 	sub	local01, #20
0c5a4     FF AD CE F7 | 	test	local04, #511 wz
0c5a8     1C A6 06 51 |  if_ne	add	local01, #28
0c5ac     53 AF 02 5B |  if_ne	rdlong	local05, local01
0c5b0     1C A6 86 51 |  if_ne	sub	local01, #28
0c5b4     57 B5 0A 52 |  if_ne	cmp	local08, local05 wz
0c5b8     B0 00 90 AD |  if_e	jmp	#LR__1865
0c5bc     10 A6 06 F1 | 	add	local01, #16
0c5c0     53 AD C2 FA | 	rdbyte	local04, local01
0c5c4     10 A6 86 F1 | 	sub	local01, #16
0c5c8     80 AC CE F7 | 	test	local04, #128 wz
0c5cc     58 00 90 AD |  if_e	jmp	#LR__1864
0c5d0     10 CE 05 F1 | 	add	fp, #16
0c5d4     E7 B6 02 FB | 	rdlong	local09, fp
0c5d8     10 CE 85 F1 | 	sub	fp, #16
0c5dc     01 B6 06 F1 | 	add	local09, #1
0c5e0     5B 91 C2 FA | 	rdbyte	arg01, local09
0c5e4     28 A6 06 F1 | 	add	local01, #40
0c5e8     53 93 02 F6 | 	mov	arg02, local01
0c5ec     0C A6 86 F1 | 	sub	local01, #12
0c5f0     53 95 02 FB | 	rdlong	arg03, local01
0c5f4     1C A6 86 F1 | 	sub	local01, #28
0c5f8     01 96 06 F6 | 	mov	arg04, #1
0c5fc     68 BC BF FD | 	call	#_fatfs_cc_disk_write
0c600     00 76 0E F2 | 	cmp	result1, #0 wz
0c604     11 A6 06 51 |  if_ne	add	local01, #17
0c608     53 03 48 5C |  if_ne	wrbyte	#1, local01
0c60c     01 76 06 56 |  if_ne	mov	result1, #1
0c610     5C 00 90 5D |  if_ne	jmp	#LR__1866
0c614     10 A6 06 F1 | 	add	local01, #16
0c618     53 AD C2 FA | 	rdbyte	local04, local01
0c61c     7F AC 06 F5 | 	and	local04, #127
0c620     53 AD 42 FC | 	wrbyte	local04, local01
0c624     10 A6 86 F1 | 	sub	local01, #16
0c628                 | LR__1864
0c628     10 CE 05 F1 | 	add	fp, #16
0c62c     E7 B6 02 FB | 	rdlong	local09, fp
0c630     10 CE 85 F1 | 	sub	fp, #16
0c634     01 B6 06 F1 | 	add	local09, #1
0c638     5B 91 C2 FA | 	rdbyte	arg01, local09
0c63c     53 93 02 F6 | 	mov	arg02, local01
0c640     28 92 06 F1 | 	add	arg02, #40
0c644     5A 95 02 F6 | 	mov	arg03, local08
0c648     01 96 06 F6 | 	mov	arg04, #1
0c64c     DC BA BF FD | 	call	#_fatfs_cc_disk_read
0c650     00 76 0E F2 | 	cmp	result1, #0 wz
0c654     11 A6 06 51 |  if_ne	add	local01, #17
0c658     53 03 48 5C |  if_ne	wrbyte	#1, local01
0c65c     01 76 06 56 |  if_ne	mov	result1, #1
0c660     0C 00 90 5D |  if_ne	jmp	#LR__1866
0c664     1C A6 06 F1 | 	add	local01, #28
0c668     53 B5 62 FC | 	wrlong	local08, local01
0c66c                 | LR__1865
0c66c                 | ' 
0c66c                 | ' 			fp->sect = nsect;
0c66c                 | ' 		}
0c66c                 | ' 	}
0c66c                 | ' 
0c66c                 | ' 	return res ;
0c66c     55 77 02 F6 | 	mov	result1, local03
0c670                 | LR__1866
0c670     E7 F0 03 F6 | 	mov	ptra, fp
0c674     F2 00 A0 FD | 	call	#popregs_
0c678                 | _fatfs_cc_f_lseek_ret
0c678     2D 00 64 FD | 	ret
0c67c                 | 
0c67c                 | _fatfs_cc_f_opendir
0c67c     02 CA 05 F6 | 	mov	COUNT_, #2
0c680     E8 00 A0 FD | 	call	#pushregs_
0c684     14 F0 07 F1 | 	add	ptra, #20
0c688     48 A7 0A F6 | 	mov	local01, arg01 wz
0c68c     08 CE 05 F1 | 	add	fp, #8
0c690     E7 92 62 FC | 	wrlong	arg02, fp
0c694     08 CE 85 F1 | 	sub	fp, #8
0c698     09 76 06 A6 |  if_e	mov	result1, #9
0c69c     EC 00 90 AD |  if_e	jmp	#LR__1876
0c6a0     08 CE 05 F1 | 	add	fp, #8
0c6a4     E7 90 02 F6 | 	mov	arg01, fp
0c6a8     08 CE 05 F1 | 	add	fp, #8
0c6ac     E7 92 02 F6 | 	mov	arg02, fp
0c6b0     10 CE 85 F1 | 	sub	fp, #16
0c6b4     00 94 06 F6 | 	mov	arg03, #0
0c6b8     B4 E7 BF FD | 	call	#_fatfs_cc_mount_volume
0c6bc     3B A9 0A F6 | 	mov	local02, result1 wz
0c6c0     BC 00 90 5D |  if_ne	jmp	#LR__1875
0c6c4     10 CE 05 F1 | 	add	fp, #16
0c6c8     E7 A8 02 FB | 	rdlong	local02, fp
0c6cc     53 A9 62 FC | 	wrlong	local02, local01
0c6d0     08 CE 85 F1 | 	sub	fp, #8
0c6d4     E7 92 02 FB | 	rdlong	arg02, fp
0c6d8     08 CE 85 F1 | 	sub	fp, #8
0c6dc     53 91 02 F6 | 	mov	arg01, local01
0c6e0     F0 E2 BF FD | 	call	#_fatfs_cc_follow_path
0c6e4     3B A9 0A F6 | 	mov	local02, result1 wz
0c6e8     8C 00 90 5D |  if_ne	jmp	#LR__1874
0c6ec     2B A6 06 F1 | 	add	local01, #43
0c6f0     53 95 C2 FA | 	rdbyte	arg03, local01
0c6f4     2B A6 86 F1 | 	sub	local01, #43
0c6f8     80 94 CE F7 | 	test	arg03, #128 wz
0c6fc     40 00 90 5D |  if_ne	jmp	#LR__1872
0c700     06 A6 06 F1 | 	add	local01, #6
0c704     53 95 C2 FA | 	rdbyte	arg03, local01
0c708     06 A6 86 F1 | 	sub	local01, #6
0c70c     10 94 CE F7 | 	test	arg03, #16 wz
0c710     28 00 90 AD |  if_e	jmp	#LR__1870
0c714     10 CE 05 F1 | 	add	fp, #16
0c718     E7 90 02 FB | 	rdlong	arg01, fp
0c71c     10 CE 85 F1 | 	sub	fp, #16
0c720     1C A6 06 F1 | 	add	local01, #28
0c724     53 93 02 FB | 	rdlong	arg02, local01
0c728     C0 CD BF FD | 	call	#_fatfs_cc_ld_clust
0c72c     14 A6 86 F1 | 	sub	local01, #20
0c730     53 77 62 FC | 	wrlong	result1, local01
0c734     08 A6 86 F1 | 	sub	local01, #8
0c738     04 00 90 FD | 	jmp	#LR__1871
0c73c                 | LR__1870
0c73c     05 A8 06 F6 | 	mov	local02, #5
0c740                 | LR__1871
0c740                 | LR__1872
0c740     00 A8 0E F2 | 	cmp	local02, #0 wz
0c744     30 00 90 5D |  if_ne	jmp	#LR__1873
0c748     10 CE 05 F1 | 	add	fp, #16
0c74c     E7 A8 02 FB | 	rdlong	local02, fp
0c750     10 CE 85 F1 | 	sub	fp, #16
0c754     06 A8 06 F1 | 	add	local02, #6
0c758     54 A9 E2 FA | 	rdword	local02, local02
0c75c     04 A6 06 F1 | 	add	local01, #4
0c760     53 A9 52 FC | 	wrword	local02, local01
0c764     04 A6 86 F1 | 	sub	local01, #4
0c768     53 91 02 F6 | 	mov	arg01, local01
0c76c     00 92 06 F6 | 	mov	arg02, #0
0c770     A4 C9 BF FD | 	call	#_fatfs_cc_dir_sdi
0c774     3B A9 02 F6 | 	mov	local02, result1
0c778                 | LR__1873
0c778                 | LR__1874
0c778     04 A8 0E F2 | 	cmp	local02, #4 wz
0c77c     05 A8 06 A6 |  if_e	mov	local02, #5
0c780                 | LR__1875
0c780     00 A8 0E F2 | 	cmp	local02, #0 wz
0c784     53 01 68 5C |  if_ne	wrlong	#0, local01
0c788                 | ' 
0c788                 | ' 	return res ;
0c788     54 77 02 F6 | 	mov	result1, local02
0c78c                 | LR__1876
0c78c     E7 F0 03 F6 | 	mov	ptra, fp
0c790     F2 00 A0 FD | 	call	#popregs_
0c794                 | _fatfs_cc_f_opendir_ret
0c794     2D 00 64 FD | 	ret
0c798                 | 
0c798                 | _fatfs_cc_f_closedir
0c798     01 CA 05 F6 | 	mov	COUNT_, #1
0c79c     E8 00 A0 FD | 	call	#pushregs_
0c7a0     10 F0 07 F1 | 	add	ptra, #16
0c7a4     48 A7 02 F6 | 	mov	local01, arg01
0c7a8     E7 92 02 F6 | 	mov	arg02, fp
0c7ac     0C 92 06 F1 | 	add	arg02, #12
0c7b0     53 91 02 F6 | 	mov	arg01, local01
0c7b4     E8 EB BF FD | 	call	#_fatfs_cc_validate
0c7b8     00 76 4E F2 | 	cmps	result1, #0 wz
0c7bc     53 01 68 AC |  if_e	wrlong	#0, local01
0c7c0                 | ' 
0c7c0                 | ' 
0c7c0                 | ' 
0c7c0                 | ' 
0c7c0                 | ' 		dp->obj.fs = 0;
0c7c0                 | ' #line 4633 "ff.c"
0c7c0                 | ' 	}
0c7c0                 | ' 	return res;
0c7c0     E7 F0 03 F6 | 	mov	ptra, fp
0c7c4     F2 00 A0 FD | 	call	#popregs_
0c7c8                 | _fatfs_cc_f_closedir_ret
0c7c8     2D 00 64 FD | 	ret
0c7cc                 | 
0c7cc                 | _fatfs_cc_f_readdir
0c7cc     03 CA 05 F6 | 	mov	COUNT_, #3
0c7d0     E8 00 A0 FD | 	call	#pushregs_
0c7d4     14 F0 07 F1 | 	add	ptra, #20
0c7d8     48 A7 02 F6 | 	mov	local01, arg01
0c7dc     49 A9 02 F6 | 	mov	local02, arg02
0c7e0     E7 92 02 F6 | 	mov	arg02, fp
0c7e4     10 92 06 F1 | 	add	arg02, #16
0c7e8     53 91 02 F6 | 	mov	arg01, local01
0c7ec     B0 EB BF FD | 	call	#_fatfs_cc_validate
0c7f0     3B AB 0A F6 | 	mov	local03, result1 wz
0c7f4     60 00 90 5D |  if_ne	jmp	#LR__1883
0c7f8     00 A8 0E F2 | 	cmp	local02, #0 wz
0c7fc     14 00 90 5D |  if_ne	jmp	#LR__1880
0c800     53 91 02 F6 | 	mov	arg01, local01
0c804     00 92 06 F6 | 	mov	arg02, #0
0c808     0C C9 BF FD | 	call	#_fatfs_cc_dir_sdi
0c80c     3B AB 02 F6 | 	mov	local03, result1
0c810     44 00 90 FD | 	jmp	#LR__1882
0c814                 | LR__1880
0c814     53 91 02 F6 | 	mov	arg01, local01
0c818     00 92 06 F6 | 	mov	arg02, #0
0c81c     98 D1 BF FD | 	call	#_fatfs_cc_dir_read
0c820     3B AB 02 F6 | 	mov	local03, result1
0c824     04 AA 0E F2 | 	cmp	local03, #4 wz
0c828     00 AA 06 A6 |  if_e	mov	local03, #0
0c82c     00 AA 0E F2 | 	cmp	local03, #0 wz
0c830     24 00 90 5D |  if_ne	jmp	#LR__1881
0c834     53 91 02 F6 | 	mov	arg01, local01
0c838     54 93 02 F6 | 	mov	arg02, local02
0c83c     E4 D8 BF FD | 	call	#_fatfs_cc_get_fileinfo
0c840     53 91 02 F6 | 	mov	arg01, local01
0c844     00 92 06 F6 | 	mov	arg02, #0
0c848     34 CA BF FD | 	call	#_fatfs_cc_dir_next
0c84c     3B AB 02 F6 | 	mov	local03, result1
0c850     04 AA 0E F2 | 	cmp	local03, #4 wz
0c854     00 AA 06 A6 |  if_e	mov	local03, #0
0c858                 | LR__1881
0c858                 | LR__1882
0c858                 | LR__1883
0c858                 | ' 			}
0c858                 | ' 			;
0c858                 | ' 		}
0c858                 | ' 	}
0c858                 | ' 	return res ;
0c858     55 77 02 F6 | 	mov	result1, local03
0c85c     E7 F0 03 F6 | 	mov	ptra, fp
0c860     F2 00 A0 FD | 	call	#popregs_
0c864                 | _fatfs_cc_f_readdir_ret
0c864     2D 00 64 FD | 	ret
0c868                 | 
0c868                 | _fatfs_cc_f_stat
0c868     02 CA 05 F6 | 	mov	COUNT_, #2
0c86c     E8 00 A0 FD | 	call	#pushregs_
0c870     40 F0 07 F1 | 	add	ptra, #64
0c874     04 CE 05 F1 | 	add	fp, #4
0c878     E7 90 62 FC | 	wrlong	arg01, fp
0c87c     49 A7 02 F6 | 	mov	local01, arg02
0c880     E7 90 02 F6 | 	mov	arg01, fp
0c884     0C CE 05 F1 | 	add	fp, #12
0c888     E7 92 02 F6 | 	mov	arg02, fp
0c88c     10 CE 85 F1 | 	sub	fp, #16
0c890     00 94 06 F6 | 	mov	arg03, #0
0c894     D8 E5 BF FD | 	call	#_fatfs_cc_mount_volume
0c898     3B A9 0A F6 | 	mov	local02, result1 wz
0c89c     4C 00 90 5D |  if_ne	jmp	#LR__1892
0c8a0     10 CE 05 F1 | 	add	fp, #16
0c8a4     E7 90 02 F6 | 	mov	arg01, fp
0c8a8     0C CE 85 F1 | 	sub	fp, #12
0c8ac     E7 92 02 FB | 	rdlong	arg02, fp
0c8b0     04 CE 85 F1 | 	sub	fp, #4
0c8b4     1C E1 BF FD | 	call	#_fatfs_cc_follow_path
0c8b8     3B A9 0A F6 | 	mov	local02, result1 wz
0c8bc     2C 00 90 5D |  if_ne	jmp	#LR__1891
0c8c0     3B CE 05 F1 | 	add	fp, #59
0c8c4     E7 94 C2 FA | 	rdbyte	arg03, fp
0c8c8     3B CE 85 F1 | 	sub	fp, #59
0c8cc     80 94 CE F7 | 	test	arg03, #128 wz
0c8d0     06 A8 06 56 |  if_ne	mov	local02, #6
0c8d4     14 00 90 5D |  if_ne	jmp	#LR__1890
0c8d8     00 A6 0E F2 | 	cmp	local01, #0 wz
0c8dc     E7 90 02 56 |  if_ne	mov	arg01, fp
0c8e0     10 90 06 51 |  if_ne	add	arg01, #16
0c8e4     53 93 02 56 |  if_ne	mov	arg02, local01
0c8e8     38 D8 BF 5D |  if_ne	call	#_fatfs_cc_get_fileinfo
0c8ec                 | LR__1890
0c8ec                 | LR__1891
0c8ec                 | LR__1892
0c8ec                 | ' 			}
0c8ec                 | ' 		}
0c8ec                 | ' 		;
0c8ec                 | ' 	}
0c8ec                 | ' 
0c8ec                 | ' 	return res ;
0c8ec     54 77 02 F6 | 	mov	result1, local02
0c8f0     E7 F0 03 F6 | 	mov	ptra, fp
0c8f4     F2 00 A0 FD | 	call	#popregs_
0c8f8                 | _fatfs_cc_f_stat_ret
0c8f8     2D 00 64 FD | 	ret
0c8fc                 | 
0c8fc                 | _fatfs_cc_f_unlink
0c8fc     02 CA 05 F6 | 	mov	COUNT_, #2
0c900     E8 00 A0 FD | 	call	#pushregs_
0c904     74 F0 07 F1 | 	add	ptra, #116
0c908     04 CE 05 F1 | 	add	fp, #4
0c90c     E7 90 62 FC | 	wrlong	arg01, fp
0c910     00 A6 06 F6 | 	mov	local01, #0
0c914     E7 90 02 F6 | 	mov	arg01, fp
0c918     6C CE 05 F1 | 	add	fp, #108
0c91c     E7 92 02 F6 | 	mov	arg02, fp
0c920     70 CE 85 F1 | 	sub	fp, #112
0c924     02 94 06 F6 | 	mov	arg03, #2
0c928     44 E5 BF FD | 	call	#_fatfs_cc_mount_volume
0c92c     3B A9 0A F6 | 	mov	local02, result1 wz
0c930     3C 01 90 5D |  if_ne	jmp	#LR__1908
0c934     70 CE 05 F1 | 	add	fp, #112
0c938     E7 A8 02 FB | 	rdlong	local02, fp
0c93c     64 CE 85 F1 | 	sub	fp, #100
0c940     E7 A8 62 FC | 	wrlong	local02, fp
0c944     E7 90 02 F6 | 	mov	arg01, fp
0c948     08 CE 85 F1 | 	sub	fp, #8
0c94c     E7 92 02 FB | 	rdlong	arg02, fp
0c950     04 CE 85 F1 | 	sub	fp, #4
0c954     7C E0 BF FD | 	call	#_fatfs_cc_follow_path
0c958     3B A9 0A F6 | 	mov	local02, result1 wz
0c95c     10 01 90 5D |  if_ne	jmp	#LR__1907
0c960     37 CE 05 F1 | 	add	fp, #55
0c964     E7 76 C2 FA | 	rdbyte	result1, fp
0c968     37 CE 85 F1 | 	sub	fp, #55
0c96c     80 76 CE F7 | 	test	result1, #128 wz
0c970     06 A8 06 56 |  if_ne	mov	local02, #6
0c974     14 00 90 5D |  if_ne	jmp	#LR__1900
0c978     12 CE 05 F1 | 	add	fp, #18
0c97c     E7 76 C2 FA | 	rdbyte	result1, fp
0c980     12 CE 85 F1 | 	sub	fp, #18
0c984     01 76 CE F7 | 	test	result1, #1 wz
0c988     07 A8 06 56 |  if_ne	mov	local02, #7
0c98c                 | LR__1900
0c98c     00 A8 0E F2 | 	cmp	local02, #0 wz
0c990     84 00 90 5D |  if_ne	jmp	#LR__1903
0c994     70 CE 05 F1 | 	add	fp, #112
0c998     E7 90 02 FB | 	rdlong	arg01, fp
0c99c     48 CE 85 F1 | 	sub	fp, #72
0c9a0     E7 92 02 FB | 	rdlong	arg02, fp
0c9a4     28 CE 85 F1 | 	sub	fp, #40
0c9a8     40 CB BF FD | 	call	#_fatfs_cc_ld_clust
0c9ac     3B A7 02 F6 | 	mov	local01, result1
0c9b0     12 CE 05 F1 | 	add	fp, #18
0c9b4     E7 76 C2 FA | 	rdbyte	result1, fp
0c9b8     12 CE 85 F1 | 	sub	fp, #18
0c9bc     10 76 CE F7 | 	test	result1, #16 wz
0c9c0     54 00 90 AD |  if_e	jmp	#LR__1902
0c9c4     70 CE 05 F1 | 	add	fp, #112
0c9c8     E7 A8 02 FB | 	rdlong	local02, fp
0c9cc     34 CE 85 F1 | 	sub	fp, #52
0c9d0     E7 A8 62 FC | 	wrlong	local02, fp
0c9d4     08 CE 05 F1 | 	add	fp, #8
0c9d8     E7 A6 62 FC | 	wrlong	local01, fp
0c9dc     08 CE 85 F1 | 	sub	fp, #8
0c9e0     E7 90 02 F6 | 	mov	arg01, fp
0c9e4     3C CE 85 F1 | 	sub	fp, #60
0c9e8     00 92 06 F6 | 	mov	arg02, #0
0c9ec     28 C7 BF FD | 	call	#_fatfs_cc_dir_sdi
0c9f0     3B A9 0A F6 | 	mov	local02, result1 wz
0c9f4     20 00 90 5D |  if_ne	jmp	#LR__1901
0c9f8     E7 90 02 F6 | 	mov	arg01, fp
0c9fc     3C 90 06 F1 | 	add	arg01, #60
0ca00     00 92 06 F6 | 	mov	arg02, #0
0ca04     B0 CF BF FD | 	call	#_fatfs_cc_dir_read
0ca08     3B A9 0A F6 | 	mov	local02, result1 wz
0ca0c     07 A8 06 A6 |  if_e	mov	local02, #7
0ca10     04 A8 0E F2 | 	cmp	local02, #4 wz
0ca14     00 A8 06 A6 |  if_e	mov	local02, #0
0ca18                 | LR__1901
0ca18                 | LR__1902
0ca18                 | LR__1903
0ca18     00 A8 0E F2 | 	cmp	local02, #0 wz
0ca1c     50 00 90 5D |  if_ne	jmp	#LR__1906
0ca20     E7 90 02 F6 | 	mov	arg01, fp
0ca24     0C 90 06 F1 | 	add	arg01, #12
0ca28     30 D6 BF FD | 	call	#_fatfs_cc_dir_remove
0ca2c     3B A9 0A F6 | 	mov	local02, result1 wz
0ca30     20 00 90 5D |  if_ne	jmp	#LR__1904
0ca34     00 A6 0E F2 | 	cmp	local01, #0 wz
0ca38     18 00 90 AD |  if_e	jmp	#LR__1904
0ca3c     E7 90 02 F6 | 	mov	arg01, fp
0ca40     0C 90 06 F1 | 	add	arg01, #12
0ca44     53 93 02 F6 | 	mov	arg02, local01
0ca48     00 94 06 F6 | 	mov	arg03, #0
0ca4c     D0 C2 BF FD | 	call	#_fatfs_cc_remove_chain
0ca50     3B A9 02 F6 | 	mov	local02, result1
0ca54                 | LR__1904
0ca54     00 A8 0E F2 | 	cmp	local02, #0 wz
0ca58     14 00 90 5D |  if_ne	jmp	#LR__1905
0ca5c     70 CE 05 F1 | 	add	fp, #112
0ca60     E7 90 02 FB | 	rdlong	arg01, fp
0ca64     70 CE 85 F1 | 	sub	fp, #112
0ca68     C0 BD BF FD | 	call	#_fatfs_cc_sync_fs
0ca6c     3B A9 02 F6 | 	mov	local02, result1
0ca70                 | LR__1905
0ca70                 | LR__1906
0ca70                 | LR__1907
0ca70                 | LR__1908
0ca70                 | ' 			}
0ca70                 | ' 		}
0ca70                 | ' 		;
0ca70                 | ' 	}
0ca70                 | ' 
0ca70                 | ' 	return res ;
0ca70     54 77 02 F6 | 	mov	result1, local02
0ca74     E7 F0 03 F6 | 	mov	ptra, fp
0ca78     F2 00 A0 FD | 	call	#popregs_
0ca7c                 | _fatfs_cc_f_unlink_ret
0ca7c     2D 00 64 FD | 	ret
0ca80                 | 
0ca80                 | _fatfs_cc_f_mkdir
0ca80     03 CA 05 F6 | 	mov	COUNT_, #3
0ca84     E8 00 A0 FD | 	call	#pushregs_
0ca88     5C F0 07 F1 | 	add	ptra, #92
0ca8c     04 CE 05 F1 | 	add	fp, #4
0ca90     E7 90 62 FC | 	wrlong	arg01, fp
0ca94     E7 90 02 F6 | 	mov	arg01, fp
0ca98     48 CE 05 F1 | 	add	fp, #72
0ca9c     E7 92 02 F6 | 	mov	arg02, fp
0caa0     4C CE 85 F1 | 	sub	fp, #76
0caa4     02 94 06 F6 | 	mov	arg03, #2
0caa8     C4 E3 BF FD | 	call	#_fatfs_cc_mount_volume
0caac     3B A7 0A F6 | 	mov	local01, result1 wz
0cab0     FC 01 90 5D |  if_ne	jmp	#LR__1915
0cab4     4C CE 05 F1 | 	add	fp, #76
0cab8     E7 A6 02 FB | 	rdlong	local01, fp
0cabc     40 CE 85 F1 | 	sub	fp, #64
0cac0     E7 A6 62 FC | 	wrlong	local01, fp
0cac4     E7 90 02 F6 | 	mov	arg01, fp
0cac8     08 CE 85 F1 | 	sub	fp, #8
0cacc     E7 92 02 FB | 	rdlong	arg02, fp
0cad0     04 CE 85 F1 | 	sub	fp, #4
0cad4     FC DE BF FD | 	call	#_fatfs_cc_follow_path
0cad8     3B A7 0A F6 | 	mov	local01, result1 wz
0cadc     08 A6 06 A6 |  if_e	mov	local01, #8
0cae0     04 A6 0E F2 | 	cmp	local01, #4 wz
0cae4     C8 01 90 5D |  if_ne	jmp	#LR__1914
0cae8     4C CE 05 F1 | 	add	fp, #76
0caec     E7 A6 02 FB | 	rdlong	local01, fp
0caf0     10 CE 85 F1 | 	sub	fp, #16
0caf4     E7 A6 62 FC | 	wrlong	local01, fp
0caf8     E7 90 02 F6 | 	mov	arg01, fp
0cafc     3C CE 85 F1 | 	sub	fp, #60
0cb00     00 92 06 F6 | 	mov	arg02, #0
0cb04     2C C3 BF FD | 	call	#_fatfs_cc_create_chain
0cb08     3B A9 0A F6 | 	mov	local02, result1 wz
0cb0c     00 A6 06 F6 | 	mov	local01, #0
0cb10     07 A6 06 A6 |  if_e	mov	local01, #7
0cb14     01 A8 0E F2 | 	cmp	local02, #1 wz
0cb18     02 A6 06 A6 |  if_e	mov	local01, #2
0cb1c     FF FF 7F FF 
0cb20     FF A9 0E F2 | 	cmp	local02, ##-1 wz
0cb24     01 A6 06 A6 |  if_e	mov	local01, #1
0cb28     8C 06 B0 FD | 	call	#_fatfs_cc__get_fattime
0cb2c     3B AB 02 F6 | 	mov	local03, result1
0cb30     00 A6 0E F2 | 	cmp	local01, #0 wz
0cb34     EC 00 90 5D |  if_ne	jmp	#LR__1911
0cb38     4C CE 05 F1 | 	add	fp, #76
0cb3c     E7 90 02 FB | 	rdlong	arg01, fp
0cb40     4C CE 85 F1 | 	sub	fp, #76
0cb44     54 93 02 F6 | 	mov	arg02, local02
0cb48     0C C5 BF FD | 	call	#_fatfs_cc_dir_clear
0cb4c     3B A7 0A F6 | 	mov	local01, result1 wz
0cb50     D0 00 90 5D |  if_ne	jmp	#LR__1910
0cb54     4C CE 05 F1 | 	add	fp, #76
0cb58     E7 90 02 FB | 	rdlong	arg01, fp
0cb5c     4C CE 85 F1 | 	sub	fp, #76
0cb60     34 90 06 F1 | 	add	arg01, #52
0cb64     20 92 06 F6 | 	mov	arg02, #32
0cb68     0B 94 06 F6 | 	mov	arg03, #11
0cb6c     D8 00 A0 FD | 	call	#\builtin_bytefill_
0cb70     4C CE 05 F1 | 	add	fp, #76
0cb74     E7 A6 02 FB | 	rdlong	local01, fp
0cb78     34 A6 06 F1 | 	add	local01, #52
0cb7c     53 5D 48 FC | 	wrbyte	#46, local01
0cb80     E7 A6 02 FB | 	rdlong	local01, fp
0cb84     3F A6 06 F1 | 	add	local01, #63
0cb88     53 21 48 FC | 	wrbyte	#16, local01
0cb8c     E7 90 02 FB | 	rdlong	arg01, fp
0cb90     4A 90 06 F1 | 	add	arg01, #74
0cb94     48 AB 62 FC | 	wrlong	local03, arg01
0cb98     E7 92 02 FB | 	rdlong	arg02, fp
0cb9c     49 91 02 F6 | 	mov	arg01, arg02
0cba0     4C CE 85 F1 | 	sub	fp, #76
0cba4     34 92 06 F1 | 	add	arg02, #52
0cba8     54 95 02 F6 | 	mov	arg03, local02
0cbac     70 C9 BF FD | 	call	#_fatfs_cc_st_clust
0cbb0     4C CE 05 F1 | 	add	fp, #76
0cbb4     E7 92 02 FB | 	rdlong	arg02, fp
0cbb8     49 91 02 F6 | 	mov	arg01, arg02
0cbbc     54 90 06 F1 | 	add	arg01, #84
0cbc0     4C CE 85 F1 | 	sub	fp, #76
0cbc4     34 92 06 F1 | 	add	arg02, #52
0cbc8     20 94 06 F6 | 	mov	arg03, #32
0cbcc     EC 64 BF FD | 	call	#__system____builtin_memmove
0cbd0     4C CE 05 F1 | 	add	fp, #76
0cbd4     E7 A6 02 FB | 	rdlong	local01, fp
0cbd8     55 A6 06 F1 | 	add	local01, #85
0cbdc     53 5D 48 FC | 	wrbyte	#46, local01
0cbe0     38 CE 85 F1 | 	sub	fp, #56
0cbe4     E7 94 02 FB | 	rdlong	arg03, fp
0cbe8     38 CE 05 F1 | 	add	fp, #56
0cbec     E7 92 02 FB | 	rdlong	arg02, fp
0cbf0     49 91 02 F6 | 	mov	arg01, arg02
0cbf4     4C CE 85 F1 | 	sub	fp, #76
0cbf8     54 92 06 F1 | 	add	arg02, #84
0cbfc     20 C9 BF FD | 	call	#_fatfs_cc_st_clust
0cc00     4C CE 05 F1 | 	add	fp, #76
0cc04     E7 A6 02 FB | 	rdlong	local01, fp
0cc08     4C CE 85 F1 | 	sub	fp, #76
0cc0c     03 A6 06 F1 | 	add	local01, #3
0cc10     53 03 48 FC | 	wrbyte	#1, local01
0cc14     E7 90 02 F6 | 	mov	arg01, fp
0cc18     0C 90 06 F1 | 	add	arg01, #12
0cc1c     D8 D1 BF FD | 	call	#_fatfs_cc_dir_register
0cc20     3B A7 02 F6 | 	mov	local01, result1
0cc24                 | LR__1910
0cc24                 | LR__1911
0cc24     00 A6 0E F2 | 	cmp	local01, #0 wz
0cc28     70 00 90 5D |  if_ne	jmp	#LR__1912
0cc2c     28 CE 05 F1 | 	add	fp, #40
0cc30     E7 90 02 FB | 	rdlong	arg01, fp
0cc34     16 90 06 F1 | 	add	arg01, #22
0cc38     48 AB 62 FC | 	wrlong	local03, arg01
0cc3c     24 CE 05 F1 | 	add	fp, #36
0cc40     E7 90 02 FB | 	rdlong	arg01, fp
0cc44     24 CE 85 F1 | 	sub	fp, #36
0cc48     E7 92 02 FB | 	rdlong	arg02, fp
0cc4c     28 CE 85 F1 | 	sub	fp, #40
0cc50     54 95 02 F6 | 	mov	arg03, local02
0cc54     C8 C8 BF FD | 	call	#_fatfs_cc_st_clust
0cc58     28 CE 05 F1 | 	add	fp, #40
0cc5c     E7 AA 02 FB | 	rdlong	local03, fp
0cc60     0B AA 06 F1 | 	add	local03, #11
0cc64     55 21 48 FC | 	wrbyte	#16, local03
0cc68     24 CE 05 F1 | 	add	fp, #36
0cc6c     E7 AA 02 FB | 	rdlong	local03, fp
0cc70     4C CE 85 F1 | 	sub	fp, #76
0cc74     03 AA 06 F1 | 	add	local03, #3
0cc78     55 03 48 FC | 	wrbyte	#1, local03
0cc7c     00 A6 0E F2 | 	cmp	local01, #0 wz
0cc80     2C 00 90 5D |  if_ne	jmp	#LR__1913
0cc84     4C CE 05 F1 | 	add	fp, #76
0cc88     E7 90 02 FB | 	rdlong	arg01, fp
0cc8c     4C CE 85 F1 | 	sub	fp, #76
0cc90     98 BB BF FD | 	call	#_fatfs_cc_sync_fs
0cc94     3B A7 02 F6 | 	mov	local01, result1
0cc98     14 00 90 FD | 	jmp	#LR__1913
0cc9c                 | LR__1912
0cc9c     E7 90 02 F6 | 	mov	arg01, fp
0cca0     3C 90 06 F1 | 	add	arg01, #60
0cca4     54 93 02 F6 | 	mov	arg02, local02
0cca8     00 94 06 F6 | 	mov	arg03, #0
0ccac     70 C0 BF FD | 	call	#_fatfs_cc_remove_chain
0ccb0                 | LR__1913
0ccb0                 | LR__1914
0ccb0                 | LR__1915
0ccb0                 | ' 				remove_chain(&sobj, dcl, 0);
0ccb0                 | ' 			}
0ccb0                 | ' 		}
0ccb0                 | ' 		;
0ccb0                 | ' 	}
0ccb0                 | ' 
0ccb0                 | ' 	return res ;
0ccb0     53 77 02 F6 | 	mov	result1, local01
0ccb4     E7 F0 03 F6 | 	mov	ptra, fp
0ccb8     F2 00 A0 FD | 	call	#popregs_
0ccbc                 | _fatfs_cc_f_mkdir_ret
0ccbc     2D 00 64 FD | 	ret
0ccc0                 | 
0ccc0                 | _fatfs_cc_f_rename
0ccc0     03 CA 05 F6 | 	mov	COUNT_, #3
0ccc4     E8 00 A0 FD | 	call	#pushregs_
0ccc8     9C F0 07 F1 | 	add	ptra, #156
0cccc     04 CE 05 F1 | 	add	fp, #4
0ccd0     E7 90 62 FC | 	wrlong	arg01, fp
0ccd4     04 CE 05 F1 | 	add	fp, #4
0ccd8     E7 92 62 FC | 	wrlong	arg02, fp
0ccdc     E7 90 02 F6 | 	mov	arg01, fp
0cce0     08 CE 85 F1 | 	sub	fp, #8
0cce4     4C DE BF FD | 	call	#_fatfs_cc_get_ldnumber
0cce8     04 CE 05 F1 | 	add	fp, #4
0ccec     E7 90 02 F6 | 	mov	arg01, fp
0ccf0     6C CE 05 F1 | 	add	fp, #108
0ccf4     E7 92 02 F6 | 	mov	arg02, fp
0ccf8     70 CE 85 F1 | 	sub	fp, #112
0ccfc     02 94 06 F6 | 	mov	arg03, #2
0cd00     6C E1 BF FD | 	call	#_fatfs_cc_mount_volume
0cd04     3B A7 0A F6 | 	mov	local01, result1 wz
0cd08     68 02 90 5D |  if_ne	jmp	#LR__1932
0cd0c     70 CE 05 F1 | 	add	fp, #112
0cd10     E7 A8 02 FB | 	rdlong	local02, fp
0cd14     60 CE 85 F1 | 	sub	fp, #96
0cd18     E7 A8 62 FC | 	wrlong	local02, fp
0cd1c     E7 90 02 F6 | 	mov	arg01, fp
0cd20     0C CE 85 F1 | 	sub	fp, #12
0cd24     E7 92 02 FB | 	rdlong	arg02, fp
0cd28     04 CE 85 F1 | 	sub	fp, #4
0cd2c     A4 DC BF FD | 	call	#_fatfs_cc_follow_path
0cd30     3B A7 0A F6 | 	mov	local01, result1 wz
0cd34     14 00 90 5D |  if_ne	jmp	#LR__1920
0cd38     3B CE 05 F1 | 	add	fp, #59
0cd3c     E7 A8 C2 FA | 	rdbyte	local02, fp
0cd40     3B CE 85 F1 | 	sub	fp, #59
0cd44     A0 A8 CE F7 | 	test	local02, #160 wz
0cd48     06 A6 06 56 |  if_ne	mov	local01, #6
0cd4c                 | LR__1920
0cd4c     00 A6 0E F2 | 	cmp	local01, #0 wz
0cd50     20 02 90 5D |  if_ne	jmp	#LR__1931
0cd54     74 CE 05 F1 | 	add	fp, #116
0cd58     E7 90 02 F6 | 	mov	arg01, fp
0cd5c     48 CE 85 F1 | 	sub	fp, #72
0cd60     E7 92 02 FB | 	rdlong	arg02, fp
0cd64     2C CE 85 F1 | 	sub	fp, #44
0cd68     20 94 06 F6 | 	mov	arg03, #32
0cd6c     4C 63 BF FD | 	call	#__system____builtin_memmove
0cd70     40 CE 05 F1 | 	add	fp, #64
0cd74     E7 90 02 F6 | 	mov	arg01, fp
0cd78     30 CE 85 F1 | 	sub	fp, #48
0cd7c     E7 92 02 F6 | 	mov	arg02, fp
0cd80     10 CE 85 F1 | 	sub	fp, #16
0cd84     30 94 06 F6 | 	mov	arg03, #48
0cd88     30 63 BF FD | 	call	#__system____builtin_memmove
0cd8c     40 CE 05 F1 | 	add	fp, #64
0cd90     E7 90 02 F6 | 	mov	arg01, fp
0cd94     38 CE 85 F1 | 	sub	fp, #56
0cd98     E7 92 02 FB | 	rdlong	arg02, fp
0cd9c     08 CE 85 F1 | 	sub	fp, #8
0cda0     30 DC BF FD | 	call	#_fatfs_cc_follow_path
0cda4     3B A7 0A F6 | 	mov	local01, result1 wz
0cda8     44 00 90 5D |  if_ne	jmp	#LR__1923
0cdac     48 CE 05 F1 | 	add	fp, #72
0cdb0     E7 A6 02 FB | 	rdlong	local01, fp
0cdb4     30 CE 85 F1 | 	sub	fp, #48
0cdb8     E7 76 02 FB | 	rdlong	result1, fp
0cdbc     18 CE 85 F1 | 	sub	fp, #24
0cdc0     3B A7 0A F2 | 	cmp	local01, result1 wz
0cdc4     20 00 90 5D |  if_ne	jmp	#LR__1921
0cdc8     50 CE 05 F1 | 	add	fp, #80
0cdcc     E7 A6 02 FB | 	rdlong	local01, fp
0cdd0     30 CE 85 F1 | 	sub	fp, #48
0cdd4     E7 76 02 FB | 	rdlong	result1, fp
0cdd8     20 CE 85 F1 | 	sub	fp, #32
0cddc     3B A7 0A F2 | 	cmp	local01, result1 wz
0cde0     04 A8 06 A6 |  if_e	mov	local02, #4
0cde4     04 00 90 AD |  if_e	jmp	#LR__1922
0cde8                 | LR__1921
0cde8     08 A8 06 F6 | 	mov	local02, #8
0cdec                 | LR__1922
0cdec     54 A7 02 F6 | 	mov	local01, local02
0cdf0                 | LR__1923
0cdf0     04 A6 0E F2 | 	cmp	local01, #4 wz
0cdf4     4C 01 90 5D |  if_ne	jmp	#LR__1928
0cdf8     E7 90 02 F6 | 	mov	arg01, fp
0cdfc     40 90 06 F1 | 	add	arg01, #64
0ce00     F4 CF BF FD | 	call	#_fatfs_cc_dir_register
0ce04     3B A7 0A F6 | 	mov	local01, result1 wz
0ce08     38 01 90 5D |  if_ne	jmp	#LR__1927
0ce0c     5C CE 05 F1 | 	add	fp, #92
0ce10     E7 AA 02 FB | 	rdlong	local03, fp
0ce14     55 91 02 F6 | 	mov	arg01, local03
0ce18     0D 90 06 F1 | 	add	arg01, #13
0ce1c     18 CE 05 F1 | 	add	fp, #24
0ce20     E7 92 02 F6 | 	mov	arg02, fp
0ce24     74 CE 85 F1 | 	sub	fp, #116
0ce28     0D 92 06 F1 | 	add	arg02, #13
0ce2c     13 94 06 F6 | 	mov	arg03, #19
0ce30     88 62 BF FD | 	call	#__system____builtin_memmove
0ce34     7F CE 05 F1 | 	add	fp, #127
0ce38     E7 A8 C2 FA | 	rdbyte	local02, fp
0ce3c     0B AA 06 F1 | 	add	local03, #11
0ce40     55 A9 42 FC | 	wrbyte	local02, local03
0ce44     54 A9 E2 F8 | 	getbyte	local02, local02, #0
0ce48     0B AA 86 F1 | 	sub	local03, #11
0ce4c     10 A8 CE F7 | 	test	local02, #16 wz
0ce50     0B AA 06 A1 |  if_e	add	local03, #11
0ce54     55 A9 C2 AA |  if_e	rdbyte	local02, local03
0ce58     20 A8 46 A5 |  if_e	or	local02, #32
0ce5c     55 A9 42 AC |  if_e	wrbyte	local02, local03
0ce60     0B AA 86 A1 |  if_e	sub	local03, #11
0ce64     0F CE 85 F1 | 	sub	fp, #15
0ce68     E7 A8 02 FB | 	rdlong	local02, fp
0ce6c     70 CE 85 F1 | 	sub	fp, #112
0ce70     03 A8 06 F1 | 	add	local02, #3
0ce74     54 03 48 FC | 	wrbyte	#1, local02
0ce78     0B AA 06 F1 | 	add	local03, #11
0ce7c     55 A9 C2 FA | 	rdbyte	local02, local03
0ce80     0B AA 86 F1 | 	sub	local03, #11
0ce84     10 A8 CE F7 | 	test	local02, #16 wz
0ce88     B8 00 90 AD |  if_e	jmp	#LR__1926
0ce8c     18 CE 05 F1 | 	add	fp, #24
0ce90     E7 A8 02 FB | 	rdlong	local02, fp
0ce94     30 CE 05 F1 | 	add	fp, #48
0ce98     E7 94 02 FB | 	rdlong	arg03, fp
0ce9c     48 CE 85 F1 | 	sub	fp, #72
0cea0     4A A9 0A F2 | 	cmp	local02, arg03 wz
0cea4     9C 00 90 AD |  if_e	jmp	#LR__1926
0cea8     70 CE 05 F1 | 	add	fp, #112
0ceac     E7 90 02 FB | 	rdlong	arg01, fp
0ceb0     48 A9 02 F6 | 	mov	local02, arg01
0ceb4     70 CE 85 F1 | 	sub	fp, #112
0ceb8     55 93 02 F6 | 	mov	arg02, local03
0cebc     2C C6 BF FD | 	call	#_fatfs_cc_ld_clust
0cec0     3B 93 02 F6 | 	mov	arg02, result1
0cec4     54 91 02 F6 | 	mov	arg01, local02
0cec8     60 BA BF FD | 	call	#_fatfs_cc_clst2sect
0cecc     3B AB 0A F6 | 	mov	local03, result1 wz
0ced0     02 A6 06 A6 |  if_e	mov	local01, #2
0ced4     6C 00 90 AD |  if_e	jmp	#LR__1925
0ced8     70 CE 05 F1 | 	add	fp, #112
0cedc     E7 90 02 FB | 	rdlong	arg01, fp
0cee0     70 CE 85 F1 | 	sub	fp, #112
0cee4     55 93 02 F6 | 	mov	arg02, local03
0cee8     C8 B8 BF FD | 	call	#_fatfs_cc_move_window
0ceec     3B A7 0A F6 | 	mov	local01, result1 wz
0cef0     70 CE 05 F1 | 	add	fp, #112
0cef4     E7 AA 02 FB | 	rdlong	local03, fp
0cef8     70 CE 85 F1 | 	sub	fp, #112
0cefc     54 AA 06 F1 | 	add	local03, #84
0cf00     01 AA 06 A1 |  if_e	add	local03, #1
0cf04     55 A9 C2 AA |  if_e	rdbyte	local02, local03
0cf08     01 AA 86 A1 |  if_e	sub	local03, #1
0cf0c     2E A8 0E A2 |  if_e	cmp	local02, #46 wz
0cf10     30 00 90 5D |  if_ne	jmp	#LR__1924
0cf14     70 CE 05 F1 | 	add	fp, #112
0cf18     E7 90 02 FB | 	rdlong	arg01, fp
0cf1c     28 CE 85 F1 | 	sub	fp, #40
0cf20     E7 94 02 FB | 	rdlong	arg03, fp
0cf24     48 CE 85 F1 | 	sub	fp, #72
0cf28     55 93 02 F6 | 	mov	arg02, local03
0cf2c     F0 C5 BF FD | 	call	#_fatfs_cc_st_clust
0cf30     70 CE 05 F1 | 	add	fp, #112
0cf34     E7 A8 02 FB | 	rdlong	local02, fp
0cf38     70 CE 85 F1 | 	sub	fp, #112
0cf3c     03 A8 06 F1 | 	add	local02, #3
0cf40     54 03 48 FC | 	wrbyte	#1, local02
0cf44                 | LR__1924
0cf44                 | LR__1925
0cf44                 | LR__1926
0cf44                 | LR__1927
0cf44                 | LR__1928
0cf44     00 A6 0E F2 | 	cmp	local01, #0 wz
0cf48     28 00 90 5D |  if_ne	jmp	#LR__1930
0cf4c     E7 90 02 F6 | 	mov	arg01, fp
0cf50     10 90 06 F1 | 	add	arg01, #16
0cf54     04 D1 BF FD | 	call	#_fatfs_cc_dir_remove
0cf58     3B A7 0A F6 | 	mov	local01, result1 wz
0cf5c     14 00 90 5D |  if_ne	jmp	#LR__1929
0cf60     70 CE 05 F1 | 	add	fp, #112
0cf64     E7 90 02 FB | 	rdlong	arg01, fp
0cf68     70 CE 85 F1 | 	sub	fp, #112
0cf6c     BC B8 BF FD | 	call	#_fatfs_cc_sync_fs
0cf70     3B A7 02 F6 | 	mov	local01, result1
0cf74                 | LR__1929
0cf74                 | LR__1930
0cf74                 | LR__1931
0cf74                 | LR__1932
0cf74                 | ' 					res = sync_fs(fs);
0cf74                 | ' 				}
0cf74                 | ' 			}
0cf74                 | ' 
0cf74                 | ' 		}
0cf74                 | ' 		;
0cf74                 | ' 	}
0cf74                 | ' 
0cf74                 | ' 	return res ;
0cf74     53 77 02 F6 | 	mov	result1, local01
0cf78     E7 F0 03 F6 | 	mov	ptra, fp
0cf7c     F2 00 A0 FD | 	call	#popregs_
0cf80                 | _fatfs_cc_f_rename_ret
0cf80     2D 00 64 FD | 	ret
0cf84                 | 
0cf84                 | _fatfs_cc___default_flush
0cf84     07 CA 05 F6 | 	mov	COUNT_, #7
0cf88     E8 00 A0 FD | 	call	#pushregs_
0cf8c     48 A7 02 F6 | 	mov	local01, arg01
0cf90     53 A9 02 FB | 	rdlong	local02, local01
0cf94     54 AB 02 FB | 	rdlong	local03, local02
0cf98     08 A6 06 F1 | 	add	local01, #8
0cf9c     53 79 02 FB | 	rdlong	result2, local01
0cfa0     08 A6 86 F1 | 	sub	local01, #8
0cfa4     08 78 CE F7 | 	test	result2, #8 wz
0cfa8     D4 00 90 AD |  if_e	jmp	#LR__1942
0cfac     01 AA 56 F2 | 	cmps	local03, #1 wc
0cfb0     2C 01 90 CD |  if_b	jmp	#LR__1944
0cfb4     08 A6 06 F1 | 	add	local01, #8
0cfb8     53 79 02 FB | 	rdlong	result2, local01
0cfbc     08 A6 86 F1 | 	sub	local01, #8
0cfc0     80 78 CE F7 | 	test	result2, #128 wz
0cfc4     6C 00 90 AD |  if_e	jmp	#LR__1941
0cfc8     08 A6 06 F1 | 	add	local01, #8
0cfcc     53 95 02 FB | 	rdlong	arg03, local01
0cfd0     08 A6 86 F1 | 	sub	local01, #8
0cfd4     00 95 CE F7 | 	test	arg03, #256 wz
0cfd8     58 00 90 AD |  if_e	jmp	#LR__1940
0cfdc     30 A6 06 F1 | 	add	local01, #48
0cfe0     53 AD 02 FB | 	rdlong	local04, local01
0cfe4     56 AF 02 F6 | 	mov	local05, local04
0cfe8     30 A6 86 F1 | 	sub	local01, #48
0cfec     13 AE 46 F7 | 	zerox	local05, #19
0cff0     14 AC 46 F0 | 	shr	local04, #20
0cff4     02 AC 66 F0 | 	shl	local04, #2
0cff8     2D AD 02 F1 | 	add	local04, __methods__
0cffc     56 AD 02 FB | 	rdlong	local04, local04
0d000     53 91 02 F6 | 	mov	arg01, local01
0d004     00 92 06 F6 | 	mov	arg02, #0
0d008     00 94 06 F6 | 	mov	arg03, #0
0d00c     02 96 06 F6 | 	mov	arg04, #2
0d010     31 B1 02 F6 | 	mov	local06, objptr
0d014     57 63 02 F6 | 	mov	objptr, local05
0d018     2D AC 62 FD | 	call	local04
0d01c     58 63 02 F6 | 	mov	objptr, local06
0d020     08 A6 06 F1 | 	add	local01, #8
0d024     53 B1 02 FB | 	rdlong	local06, local01
0d028     00 B1 26 F5 | 	andn	local06, #256
0d02c     53 B1 62 FC | 	wrlong	local06, local01
0d030     08 A6 86 F1 | 	sub	local01, #8
0d034                 | LR__1940
0d034                 | LR__1941
0d034     18 A6 06 F1 | 	add	local01, #24
0d038     53 AD 02 FB | 	rdlong	local04, local01
0d03c     56 AF 02 F6 | 	mov	local05, local04
0d040     18 A6 86 F1 | 	sub	local01, #24
0d044     13 AE 46 F7 | 	zerox	local05, #19
0d048     14 AC 46 F0 | 	shr	local04, #20
0d04c     02 AC 66 F0 | 	shl	local04, #2
0d050     2D AD 02 F1 | 	add	local04, __methods__
0d054     56 AD 02 FB | 	rdlong	local04, local04
0d058     0C A8 06 F1 | 	add	local02, #12
0d05c     54 93 02 FB | 	rdlong	arg02, local02
0d060     0C A8 86 F1 | 	sub	local02, #12
0d064     53 91 02 F6 | 	mov	arg01, local01
0d068     55 95 02 F6 | 	mov	arg03, local03
0d06c     31 B1 02 F6 | 	mov	local06, objptr
0d070     57 63 02 F6 | 	mov	objptr, local05
0d074     2D AC 62 FD | 	call	local04
0d078     58 63 02 F6 | 	mov	objptr, local06
0d07c     60 00 90 FD | 	jmp	#LR__1944
0d080                 | LR__1942
0d080     08 A6 06 F1 | 	add	local01, #8
0d084     53 B1 02 FB | 	rdlong	local06, local01
0d088     08 A6 86 F1 | 	sub	local01, #8
0d08c     04 B0 CE F7 | 	test	local06, #4 wz
0d090     00 AA 0E 52 |  if_ne	cmp	local03, #0 wz
0d094     48 00 90 AD |  if_e	jmp	#LR__1943
0d098     55 93 62 F6 | 	neg	arg02, local03
0d09c     49 95 02 F6 | 	mov	arg03, arg02
0d0a0     1F 94 C6 F0 | 	sar	arg03, #31
0d0a4     30 A6 06 F1 | 	add	local01, #48
0d0a8     53 AD 02 FB | 	rdlong	local04, local01
0d0ac     56 AF 02 F6 | 	mov	local05, local04
0d0b0     30 A6 86 F1 | 	sub	local01, #48
0d0b4     13 AE 46 F7 | 	zerox	local05, #19
0d0b8     14 AC 46 F0 | 	shr	local04, #20
0d0bc     02 AC 66 F0 | 	shl	local04, #2
0d0c0     2D AD 02 F1 | 	add	local04, __methods__
0d0c4     56 AD 02 FB | 	rdlong	local04, local04
0d0c8     53 91 02 F6 | 	mov	arg01, local01
0d0cc     01 96 06 F6 | 	mov	arg04, #1
0d0d0     31 B1 02 F6 | 	mov	local06, objptr
0d0d4     57 63 02 F6 | 	mov	objptr, local05
0d0d8     2D AC 62 FD | 	call	local04
0d0dc     58 63 02 F6 | 	mov	objptr, local06
0d0e0                 | LR__1943
0d0e0                 | LR__1944
0d0e0     54 01 68 FC | 	wrlong	#0, local02
0d0e4     04 A8 06 F1 | 	add	local02, #4
0d0e8     54 01 68 FC | 	wrlong	#0, local02
0d0ec     08 A6 06 F1 | 	add	local01, #8
0d0f0     53 B3 02 FB | 	rdlong	local07, local01
0d0f4     0C B2 26 F5 | 	andn	local07, #12
0d0f8     53 B3 62 FC | 	wrlong	local07, local01
0d0fc                 | '     }
0d0fc                 | '     b->cnt = 0;
0d0fc                 | '     b->ptr = 0;
0d0fc                 | '     f->state &= ~( (0x08) | (0x04) );
0d0fc                 | '     return 0;
0d0fc     00 76 06 F6 | 	mov	result1, #0
0d100     E7 F0 03 F6 | 	mov	ptra, fp
0d104     F2 00 A0 FD | 	call	#popregs_
0d108                 | _fatfs_cc___default_flush_ret
0d108     2D 00 64 FD | 	ret
0d10c                 | 
0d10c                 | _fatfs_cc_getenv
0d10c     06 CA 05 F6 | 	mov	COUNT_, #6
0d110     E8 00 A0 FD | 	call	#pushregs_
0d114     48 A7 02 F6 | 	mov	local01, arg01
0d118     48 A9 02 F6 | 	mov	local02, arg01
0d11c     D7 06 48 FB | 	callpa	#(@LR__1951-@LR__1950)>>2,fcache_load_ptr_
0d120                 | LR__1950
0d120     54 77 CA FA | 	rdbyte	result1, local02 wz
0d124     01 A8 06 51 |  if_ne	add	local02, #1
0d128     F4 FF 9F 5D |  if_ne	jmp	#LR__1950
0d12c                 | LR__1951
0d12c     48 A9 82 F1 | 	sub	local02, arg01
0d130     54 77 02 F6 | 	mov	result1, local02
0d134     02 00 00 FF 
0d138     FC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1276
0d13c     35 95 0A FB | 	rdlong	arg03, ptr__fatfs_cc_dat__ wz
0d140     02 00 00 FF 
0d144     FC 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1276
0d148                 | '             return 0;
0d148     00 76 06 A6 |  if_e	mov	result1, #0
0d14c     5C 00 90 AD |  if_e	jmp	#LR__1954
0d150                 | ' 
0d150                 | ' 	for (var = _environ_ptr; (name = *var) != 0; var++) {
0d150     02 00 00 FF 
0d154     FC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1276
0d158     35 AB 02 FB | 	rdlong	local03, ptr__fatfs_cc_dat__
0d15c     02 00 00 FF 
0d160     FC 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1276
0d164                 | LR__1952
0d164     55 AD 0A FB | 	rdlong	local04, local03 wz
0d168     3C 00 90 AD |  if_e	jmp	#LR__1953
0d16c     56 91 02 F6 | 	mov	arg01, local04
0d170     53 93 02 F6 | 	mov	arg02, local01
0d174     54 95 02 F6 | 	mov	arg03, local02
0d178     24 AB BF FD | 	call	#_fatfs_cc_strncmp
0d17c     00 76 0E F2 | 	cmp	result1, #0 wz
0d180     54 AF 02 A6 |  if_e	mov	local05, local02
0d184     56 AF 02 A1 |  if_e	add	local05, local04
0d188     57 B1 C2 AA |  if_e	rdbyte	local06, local05
0d18c     3D B0 0E A2 |  if_e	cmp	local06, #61 wz
0d190                 | ' 			return name+len+1;
0d190     54 AD 02 A1 |  if_e	add	local04, local02
0d194     01 AC 06 A1 |  if_e	add	local04, #1
0d198     56 77 02 A6 |  if_e	mov	result1, local04
0d19c     0C 00 90 AD |  if_e	jmp	#LR__1954
0d1a0     04 AA 06 F1 | 	add	local03, #4
0d1a4     BC FF 9F FD | 	jmp	#LR__1952
0d1a8                 | LR__1953
0d1a8                 | ' 	}
0d1a8                 | ' 	return 0;
0d1a8     00 76 06 F6 | 	mov	result1, #0
0d1ac                 | LR__1954
0d1ac     E7 F0 03 F6 | 	mov	ptra, fp
0d1b0     F2 00 A0 FD | 	call	#popregs_
0d1b4                 | _fatfs_cc_getenv_ret
0d1b4     2D 00 64 FD | 	ret
0d1b8                 | 
0d1b8                 | _fatfs_cc__get_fattime
0d1b8     00 CA 05 F6 | 	mov	COUNT_, #0
0d1bc     E8 00 A0 FD | 	call	#pushregs_
0d1c0     34 F0 07 F1 | 	add	ptra, #52
0d1c4     00 90 06 F6 | 	mov	arg01, #0
0d1c8     A4 AB BF FD | 	call	#_fatfs_cc_time
0d1cc     04 CE 05 F1 | 	add	fp, #4
0d1d0     E7 76 62 FC | 	wrlong	result1, fp
0d1d4     E7 90 02 F6 | 	mov	arg01, fp
0d1d8     0C CE 05 F1 | 	add	fp, #12
0d1dc     E7 92 02 F6 | 	mov	arg02, fp
0d1e0     10 CE 85 F1 | 	sub	fp, #16
0d1e4     70 AD BF FD | 	call	#_fatfs_cc__gmtime_r
0d1e8     24 CE 05 F1 | 	add	fp, #36
0d1ec     E7 76 02 FB | 	rdlong	result1, fp
0d1f0     50 76 86 F1 | 	sub	result1, #80
0d1f4     09 76 66 F0 | 	shl	result1, #9
0d1f8     04 CE 85 F1 | 	sub	fp, #4
0d1fc     E7 92 02 FB | 	rdlong	arg02, fp
0d200     01 92 06 F1 | 	add	arg02, #1
0d204     05 92 66 F0 | 	shl	arg02, #5
0d208     49 77 42 F5 | 	or	result1, arg02
0d20c     04 CE 85 F1 | 	sub	fp, #4
0d210     E7 92 02 FB | 	rdlong	arg02, fp
0d214     49 77 42 F5 | 	or	result1, arg02
0d218     04 CE 85 F1 | 	sub	fp, #4
0d21c     E7 92 02 FB | 	rdlong	arg02, fp
0d220     0B 92 66 F0 | 	shl	arg02, #11
0d224     04 CE 85 F1 | 	sub	fp, #4
0d228     E7 90 02 FB | 	rdlong	arg01, fp
0d22c     05 90 66 F0 | 	shl	arg01, #5
0d230     48 93 42 F5 | 	or	arg02, arg01
0d234     04 CE 85 F1 | 	sub	fp, #4
0d238     E7 90 02 FB | 	rdlong	arg01, fp
0d23c     10 CE 85 F1 | 	sub	fp, #16
0d240     48 93 42 F5 | 	or	arg02, arg01
0d244                 | ' 
0d244                 | '     now = time(0);
0d244                 | '     _gmtime_r (&now, &date);
0d244                 | '     ffdate = ((date.tm_year - 80) << 9) | ((date.tm_mon + 1) << 5) | ((date.tm_mday));
0d244                 | '     fftime = (date.tm_hour << 11) | (date.tm_min << 5) | (date.tm_sec);
0d244                 | '     return (ffdate << 16) | fftime;
0d244     10 76 66 F0 | 	shl	result1, #16
0d248     49 77 42 F5 | 	or	result1, arg02
0d24c     E7 F0 03 F6 | 	mov	ptra, fp
0d250     F2 00 A0 FD | 	call	#popregs_
0d254                 | _fatfs_cc__get_fattime_ret
0d254     2D 00 64 FD | 	ret
0d258                 | 
0d258                 | _fatfs_cc_unixtime_0593
0d258     02 CA 05 F6 | 	mov	COUNT_, #2
0d25c     E8 00 A0 FD | 	call	#pushregs_
0d260     34 F0 07 F1 | 	add	ptra, #52
0d264     48 A7 02 F6 | 	mov	local01, arg01
0d268     09 A6 46 F0 | 	shr	local01, #9
0d26c     7F A6 06 F5 | 	and	local01, #127
0d270     50 A8 06 F6 | 	mov	local02, #80
0d274     53 A9 02 F1 | 	add	local02, local01
0d278     24 CE 05 F1 | 	add	fp, #36
0d27c     E7 A8 62 FC | 	wrlong	local02, fp
0d280     48 A9 02 F6 | 	mov	local02, arg01
0d284     05 A8 46 F0 | 	shr	local02, #5
0d288     54 A9 42 F8 | 	getnib	local02, local02, #0
0d28c     01 A8 86 F1 | 	sub	local02, #1
0d290     04 CE 85 F1 | 	sub	fp, #4
0d294     E7 A8 62 FC | 	wrlong	local02, fp
0d298     1F 90 06 F5 | 	and	arg01, #31
0d29c     04 CE 85 F1 | 	sub	fp, #4
0d2a0     E7 90 62 FC | 	wrlong	arg01, fp
0d2a4     49 A9 02 F6 | 	mov	local02, arg02
0d2a8     0B A8 46 F0 | 	shr	local02, #11
0d2ac     1F A8 06 F5 | 	and	local02, #31
0d2b0     04 CE 85 F1 | 	sub	fp, #4
0d2b4     E7 A8 62 FC | 	wrlong	local02, fp
0d2b8     49 A9 02 F6 | 	mov	local02, arg02
0d2bc     05 A8 46 F0 | 	shr	local02, #5
0d2c0     3F A8 06 F5 | 	and	local02, #63
0d2c4     04 CE 85 F1 | 	sub	fp, #4
0d2c8     E7 A8 62 FC | 	wrlong	local02, fp
0d2cc     1F 92 06 F5 | 	and	arg02, #31
0d2d0     01 92 66 F0 | 	shl	arg02, #1
0d2d4     04 CE 85 F1 | 	sub	fp, #4
0d2d8     E7 92 62 FC | 	wrlong	arg02, fp
0d2dc     E7 90 02 F6 | 	mov	arg01, fp
0d2e0     10 CE 85 F1 | 	sub	fp, #16
0d2e4     C8 AA BF FD | 	call	#_fatfs_cc_mktime
0d2e8                 | ' 
0d2e8                 | '     date.tm_year = 80 + ((dosdate >> 9) & 0x7f);
0d2e8                 | '     date.tm_mon = ((dosdate >> 5) & 0xf) - 1;
0d2e8                 | '     date.tm_mday = (dosdate & 0x1f);
0d2e8                 | '     date.tm_hour = (dostime >> 11) & 0x1f;
0d2e8                 | '     date.tm_min = (dostime >> 5) & 0x3f;
0d2e8                 | '     date.tm_sec = (dostime & 0x1f) << 1;
0d2e8                 | ' 
0d2e8                 | '     t = mktime(&date);
0d2e8                 | ' #line 66 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d2e8                 | '     return t;
0d2e8     E7 F0 03 F6 | 	mov	ptra, fp
0d2ec     F2 00 A0 FD | 	call	#popregs_
0d2f0                 | _fatfs_cc_unixtime_0593_ret
0d2f0     2D 00 64 FD | 	ret
0d2f4                 | 
0d2f4                 | _fatfs_cc__set_dos_error_0595
0d2f4     48 7D 02 F6 | 	mov	_var01, arg01
0d2f8                 | ' #line 82 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d2f8                 | '     switch (derr) {
0d2f8     14 7C 26 F3 | 	fle	_var01, #20
0d2fc     30 7C 62 FD | 	jmprel	_var01
0d300                 | LR__1960
0d300     50 00 90 FD | 	jmp	#LR__1961
0d304     84 00 90 FD | 	jmp	#LR__1975
0d308     80 00 90 FD | 	jmp	#LR__1976
0d30c     7C 00 90 FD | 	jmp	#LR__1977
0d310     48 00 90 FD | 	jmp	#LR__1962
0d314     44 00 90 FD | 	jmp	#LR__1963
0d318     40 00 90 FD | 	jmp	#LR__1964
0d31c     44 00 90 FD | 	jmp	#LR__1965
0d320     48 00 90 FD | 	jmp	#LR__1967
0d324     54 00 90 FD | 	jmp	#LR__1970
0d328     38 00 90 FD | 	jmp	#LR__1966
0d32c     4C 00 90 FD | 	jmp	#LR__1971
0d330     48 00 90 FD | 	jmp	#LR__1972
0d334     44 00 90 FD | 	jmp	#LR__1973
0d338     50 00 90 FD | 	jmp	#LR__1978
0d33c     4C 00 90 FD | 	jmp	#LR__1978
0d340     48 00 90 FD | 	jmp	#LR__1978
0d344     2C 00 90 FD | 	jmp	#LR__1968
0d348     38 00 90 FD | 	jmp	#LR__1974
0d34c     2C 00 90 FD | 	jmp	#LR__1969
0d350     38 00 90 FD | 	jmp	#LR__1978
0d354                 | LR__1961
0d354     00 7E 06 F6 | 	mov	_var02, #0
0d358                 | '         r = 0;
0d358                 | '         break;
0d358     34 00 90 FD | 	jmp	#LR__1979
0d35c                 | LR__1962
0d35c                 | LR__1963
0d35c                 | LR__1964
0d35c     04 7E 06 F6 | 	mov	_var02, #4
0d360                 | '         r =  4 ;
0d360                 | '         break;
0d360     2C 00 90 FD | 	jmp	#LR__1979
0d364                 | LR__1965
0d364                 | LR__1966
0d364     06 7E 06 F6 | 	mov	_var02, #6
0d368                 | '         r =  6 ;
0d368                 | '         break;
0d368     24 00 90 FD | 	jmp	#LR__1979
0d36c                 | LR__1967
0d36c     09 7E 06 F6 | 	mov	_var02, #9
0d370                 | '         r =  9 ;
0d370                 | '         break;
0d370     1C 00 90 FD | 	jmp	#LR__1979
0d374                 | LR__1968
0d374     07 7E 06 F6 | 	mov	_var02, #7
0d378                 | '         r =  7 ;
0d378                 | '         break;
0d378     14 00 90 FD | 	jmp	#LR__1979
0d37c                 | LR__1969
0d37c                 | LR__1970
0d37c                 | LR__1971
0d37c                 | LR__1972
0d37c                 | LR__1973
0d37c     0A 7E 06 F6 | 	mov	_var02, #10
0d380                 | '         r =  10 ;
0d380                 | '         break;
0d380     0C 00 90 FD | 	jmp	#LR__1979
0d384                 | LR__1974
0d384     0B 7E 06 F6 | 	mov	_var02, #11
0d388                 | '         r =  11 ;
0d388                 | '         break;
0d388     04 00 90 FD | 	jmp	#LR__1979
0d38c                 | LR__1975
0d38c                 | LR__1976
0d38c                 | LR__1977
0d38c                 | LR__1978
0d38c     0C 7E 06 F6 | 	mov	_var02, #12
0d390                 | '         r =  12 ;
0d390                 | '         break;
0d390                 | LR__1979
0d390                 | '     }
0d390                 | '     return _seterror(r);
0d390     00 7E 4E F2 | 	cmps	_var02, #0 wz
0d394     20 66 06 F1 | 	add	ptr___system__dat__, #32
0d398     33 7F 62 FC | 	wrlong	_var02, ptr___system__dat__
0d39c     20 66 86 F1 | 	sub	ptr___system__dat__, #32
0d3a0     01 76 66 56 |  if_ne	neg	result1, #1
0d3a4     00 76 06 A6 |  if_e	mov	result1, #0
0d3a8                 | _fatfs_cc__set_dos_error_0595_ret
0d3a8     2D 00 64 FD | 	ret
0d3ac                 | 
0d3ac                 | _fatfs_cc_v_creat
0d3ac     04 CA 05 F6 | 	mov	COUNT_, #4
0d3b0     E8 00 A0 FD | 	call	#pushregs_
0d3b4     48 A7 02 F6 | 	mov	local01, arg01
0d3b8     49 A9 02 F6 | 	mov	local02, arg02
0d3bc     03 00 00 FF 
0d3c0     38 90 06 F6 | 	mov	arg01, ##1592
0d3c4                 | '     return _gc_alloc(size);
0d3c4     10 92 06 F6 | 	mov	arg02, #16
0d3c8     20 7F BF FD | 	call	#__system___gc_doalloc
0d3cc     3B AB 0A F6 | 	mov	local03, result1 wz
0d3d0                 | '       return _seterror( 7 );
0d3d0     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d3d4     33 0F 68 AC |  if_e	wrlong	#7, ptr___system__dat__
0d3d8     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d3dc     01 76 66 A6 |  if_e	neg	result1, #1
0d3e0     50 00 90 AD |  if_e	jmp	#LR__1981
0d3e4     55 91 02 F6 | 	mov	arg01, local03
0d3e8     00 92 06 F6 | 	mov	arg02, #0
0d3ec     03 00 00 FF 
0d3f0     38 94 06 F6 | 	mov	arg03, ##1592
0d3f4     D8 00 A0 FD | 	call	#\builtin_bytefill_
0d3f8     55 91 02 F6 | 	mov	arg01, local03
0d3fc     02 00 00 FF 
0d400     10 90 06 F1 | 	add	arg01, ##1040
0d404     54 93 02 F6 | 	mov	arg02, local02
0d408     07 94 06 F6 | 	mov	arg03, #7
0d40c     D8 E0 BF FD | 	call	#_fatfs_cc_f_open
0d410     3B AD 0A F6 | 	mov	local04, result1 wz
0d414     14 00 90 AD |  if_e	jmp	#LR__1980
0d418     55 91 02 F6 | 	mov	arg01, local03
0d41c                 | '     return _gc_free(ptr);
0d41c     D0 7F BF FD | 	call	#__system___gc_free
0d420                 | '     free(f);
0d420                 | '     return _set_dos_error(r);
0d420     56 91 02 F6 | 	mov	arg01, local04
0d424     CC FE BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d428     08 00 90 FD | 	jmp	#LR__1981
0d42c                 | LR__1980
0d42c     53 AB 62 FC | 	wrlong	local03, local01
0d430                 | '   }
0d430                 | '   fil->vfsdata = f;
0d430                 | '   return 0;
0d430     00 76 06 F6 | 	mov	result1, #0
0d434                 | LR__1981
0d434     E7 F0 03 F6 | 	mov	ptra, fp
0d438     F2 00 A0 FD | 	call	#popregs_
0d43c                 | _fatfs_cc_v_creat_ret
0d43c     2D 00 64 FD | 	ret
0d440                 | 
0d440                 | _fatfs_cc_v_close
0d440     02 CA 05 F6 | 	mov	COUNT_, #2
0d444     E8 00 A0 FD | 	call	#pushregs_
0d448     48 A7 02 FB | 	rdlong	local01, arg01
0d44c     53 91 02 F6 | 	mov	arg01, local01
0d450     02 00 00 FF 
0d454     10 90 06 F1 | 	add	arg01, ##1040
0d458     34 EE BF FD | 	call	#_fatfs_cc_f_close
0d45c     3B A9 02 F6 | 	mov	local02, result1
0d460     53 91 02 F6 | 	mov	arg01, local01
0d464                 | '     return _gc_free(ptr);
0d464     88 7F BF FD | 	call	#__system___gc_free
0d468                 | '     FAT_FIL *f = fil->vfsdata;
0d468                 | '     r=f_close(&f->fil);
0d468                 | '     free(f);
0d468                 | '     return _set_dos_error(r);
0d468     54 91 02 F6 | 	mov	arg01, local02
0d46c     84 FE BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d470     E7 F0 03 F6 | 	mov	ptra, fp
0d474     F2 00 A0 FD | 	call	#popregs_
0d478                 | _fatfs_cc_v_close_ret
0d478     2D 00 64 FD | 	ret
0d47c                 | 
0d47c                 | _fatfs_cc_v_opendir
0d47c     04 CA 05 F6 | 	mov	COUNT_, #4
0d480     E8 00 A0 FD | 	call	#pushregs_
0d484     48 A7 02 F6 | 	mov	local01, arg01
0d488     49 A9 02 F6 | 	mov	local02, arg02
0d48c     30 90 06 F6 | 	mov	arg01, #48
0d490                 | '     return _gc_alloc(size);
0d490     10 92 06 F6 | 	mov	arg02, #16
0d494     54 7E BF FD | 	call	#__system___gc_doalloc
0d498     3B AB 0A F6 | 	mov	local03, result1 wz
0d49c                 | ' #line 166 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d49c                 | '       return _seterror( 7 );
0d49c     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d4a0     33 0F 68 AC |  if_e	wrlong	#7, ptr___system__dat__
0d4a4     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d4a8     01 76 66 A6 |  if_e	neg	result1, #1
0d4ac     34 00 90 AD |  if_e	jmp	#LR__1991
0d4b0     54 93 02 F6 | 	mov	arg02, local02
0d4b4     55 91 02 F6 | 	mov	arg01, local03
0d4b8     C0 F1 BF FD | 	call	#_fatfs_cc_f_opendir
0d4bc     3B AD 0A F6 | 	mov	local04, result1 wz
0d4c0     14 00 90 AD |  if_e	jmp	#LR__1990
0d4c4     55 91 02 F6 | 	mov	arg01, local03
0d4c8                 | '     return _gc_free(ptr);
0d4c8     24 7F BF FD | 	call	#__system___gc_free
0d4cc                 | '         free(f);
0d4cc                 | '         return _set_dos_error(r);
0d4cc     56 91 02 F6 | 	mov	arg01, local04
0d4d0     20 FE BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d4d4     0C 00 90 FD | 	jmp	#LR__1991
0d4d8                 | LR__1990
0d4d8     04 A6 06 F1 | 	add	local01, #4
0d4dc     53 AB 62 FC | 	wrlong	local03, local01
0d4e0                 | '     }
0d4e0                 | '     dir->vfsdata = f;
0d4e0                 | '     return 0;
0d4e0     00 76 06 F6 | 	mov	result1, #0
0d4e4                 | LR__1991
0d4e4     E7 F0 03 F6 | 	mov	ptra, fp
0d4e8     F2 00 A0 FD | 	call	#popregs_
0d4ec                 | _fatfs_cc_v_opendir_ret
0d4ec     2D 00 64 FD | 	ret
0d4f0                 | 
0d4f0                 | _fatfs_cc_v_closedir
0d4f0     02 CA 05 F6 | 	mov	COUNT_, #2
0d4f4     E8 00 A0 FD | 	call	#pushregs_
0d4f8     04 90 06 F1 | 	add	arg01, #4
0d4fc     48 A7 02 FB | 	rdlong	local01, arg01
0d500     53 91 02 F6 | 	mov	arg01, local01
0d504     90 F2 BF FD | 	call	#_fatfs_cc_f_closedir
0d508     3B A9 02 F6 | 	mov	local02, result1
0d50c     53 91 02 F6 | 	mov	arg01, local01
0d510                 | '     return _gc_free(ptr);
0d510     DC 7E BF FD | 	call	#__system___gc_free
0d514     00 A8 0E F2 | 	cmp	local02, #0 wz
0d518     54 91 02 56 |  if_ne	mov	arg01, local02
0d51c     D4 FD BF 5D |  if_ne	call	#_fatfs_cc__set_dos_error_0595
0d520                 | '     return r;
0d520     54 77 02 F6 | 	mov	result1, local02
0d524     E7 F0 03 F6 | 	mov	ptra, fp
0d528     F2 00 A0 FD | 	call	#popregs_
0d52c                 | _fatfs_cc_v_closedir_ret
0d52c     2D 00 64 FD | 	ret
0d530                 | 
0d530                 | _fatfs_cc_v_readdir
0d530     01 CA 05 F6 | 	mov	COUNT_, #1
0d534     E8 00 A0 FD | 	call	#pushregs_
0d538     2C F1 07 F1 | 	add	ptra, #300
0d53c     49 A7 02 F6 | 	mov	local01, arg02
0d540     04 90 06 F1 | 	add	arg01, #4
0d544     48 91 02 FB | 	rdlong	arg01, arg01
0d548     E7 92 02 F6 | 	mov	arg02, fp
0d54c     0C 92 06 F1 | 	add	arg02, #12
0d550     78 F2 BF FD | 	call	#_fatfs_cc_f_readdir
0d554     3B 95 0A F6 | 	mov	arg03, result1 wz
0d558     0C 00 90 AD |  if_e	jmp	#LR__2000
0d55c                 | '         return _set_dos_error(r);
0d55c     4A 91 02 F6 | 	mov	arg01, arg03
0d560     90 FD BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d564     88 00 90 FD | 	jmp	#LR__2001
0d568                 | LR__2000
0d568     28 CE 05 F1 | 	add	fp, #40
0d56c     E7 94 CA FA | 	rdbyte	arg03, fp wz
0d570     28 CE 85 F1 | 	sub	fp, #40
0d574                 | '         return -1;
0d574     01 76 66 A6 |  if_e	neg	result1, #1
0d578     74 00 90 AD |  if_e	jmp	#LR__2001
0d57c     E7 92 02 F6 | 	mov	arg02, fp
0d580     28 92 06 F1 | 	add	arg02, #40
0d584     53 91 02 F6 | 	mov	arg01, local01
0d588     3F 94 06 F6 | 	mov	arg03, #63
0d58c     7C A6 BF FD | 	call	#_fatfs_cc_strncpy
0d590     3F A6 06 F1 | 	add	local01, #63
0d594     53 01 48 FC | 	wrbyte	#0, local01
0d598     3F A6 86 F1 | 	sub	local01, #63
0d59c     14 CE 05 F1 | 	add	fp, #20
0d5a0     E7 94 C2 FA | 	rdbyte	arg03, fp
0d5a4     10 94 CE F7 | 	test	arg03, #16 wz
0d5a8     50 A6 06 51 |  if_ne	add	local01, #80
0d5ac     53 03 48 5C |  if_ne	wrbyte	#1, local01
0d5b0     50 A6 E6 F3 | 	sumnz	local01, #80
0d5b4     53 01 48 AC |  if_e	wrbyte	#0, local01
0d5b8     50 A6 86 A1 |  if_e	sub	local01, #80
0d5bc     08 CE 85 F1 | 	sub	fp, #8
0d5c0     E7 94 02 FB | 	rdlong	arg03, fp
0d5c4     48 A6 06 F1 | 	add	local01, #72
0d5c8     53 95 62 FC | 	wrlong	arg03, local01
0d5cc     04 CE 05 F1 | 	add	fp, #4
0d5d0     E7 90 E2 FA | 	rdword	arg01, fp
0d5d4     02 CE 05 F1 | 	add	fp, #2
0d5d8     E7 92 E2 FA | 	rdword	arg02, fp
0d5dc     12 CE 85 F1 | 	sub	fp, #18
0d5e0     74 FC BF FD | 	call	#_fatfs_cc_unixtime_0593
0d5e4     04 A6 06 F1 | 	add	local01, #4
0d5e8     53 77 62 FC | 	wrlong	result1, local01
0d5ec                 | '         ent->d_type =  (0) ;
0d5ec                 | '     }
0d5ec                 | '     ent->d_size = finfo.fsize;
0d5ec                 | '     ent->d_mtime = unixtime(finfo.fdate, finfo.ftime);
0d5ec                 | '     return 0;
0d5ec     00 76 06 F6 | 	mov	result1, #0
0d5f0                 | LR__2001
0d5f0     E7 F0 03 F6 | 	mov	ptra, fp
0d5f4     F2 00 A0 FD | 	call	#popregs_
0d5f8                 | _fatfs_cc_v_readdir_ret
0d5f8     2D 00 64 FD | 	ret
0d5fc                 | 
0d5fc                 | _fatfs_cc_v_stat
0d5fc     05 CA 05 F6 | 	mov	COUNT_, #5
0d600     E8 00 A0 FD | 	call	#pushregs_
0d604     30 F1 07 F1 | 	add	ptra, #304
0d608     48 A7 02 F6 | 	mov	local01, arg01
0d60c     49 A9 02 F6 | 	mov	local02, arg02
0d610     54 91 02 F6 | 	mov	arg01, local02
0d614     00 92 06 F6 | 	mov	arg02, #0
0d618     34 94 06 F6 | 	mov	arg03, #52
0d61c     D8 00 A0 FD | 	call	#\builtin_bytefill_
0d620     53 79 CA FA | 	rdbyte	result2, local01 wz
0d624     1C 00 90 AD |  if_e	jmp	#LR__2010
0d628     53 79 C2 FA | 	rdbyte	result2, local01
0d62c     2E 78 0E F2 | 	cmp	result2, #46 wz
0d630     01 A6 06 A1 |  if_e	add	local01, #1
0d634     53 AB C2 AA |  if_e	rdbyte	local03, local01
0d638     01 A6 86 A1 |  if_e	sub	local01, #1
0d63c     00 AA 4E A2 |  if_e	cmps	local03, #0 wz
0d640     14 00 90 5D |  if_ne	jmp	#LR__2011
0d644                 | LR__2010
0d644     18 CE 05 F1 | 	add	fp, #24
0d648     E7 20 48 FC | 	wrbyte	#16, fp
0d64c     18 CE 85 F1 | 	sub	fp, #24
0d650     00 AC 06 F6 | 	mov	local04, #0
0d654     14 00 90 FD | 	jmp	#LR__2012
0d658                 | LR__2011
0d658     E7 92 02 F6 | 	mov	arg02, fp
0d65c     10 92 06 F1 | 	add	arg02, #16
0d660     53 91 02 F6 | 	mov	arg01, local01
0d664     00 F2 BF FD | 	call	#_fatfs_cc_f_stat
0d668     3B AD 02 F6 | 	mov	local04, result1
0d66c                 | LR__2012
0d66c     00 AC 0E F2 | 	cmp	local04, #0 wz
0d670     0C 00 90 AD |  if_e	jmp	#LR__2013
0d674                 | '         return _set_dos_error(r);
0d674     56 91 02 F6 | 	mov	arg01, local04
0d678     78 FC BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d67c     9C 00 90 FD | 	jmp	#LR__2014
0d680                 | LR__2013
0d680     24 AF 06 F6 | 	mov	local05, #292
0d684     18 CE 05 F1 | 	add	fp, #24
0d688     E7 AA C2 FA | 	rdbyte	local03, fp
0d68c     01 AA CE F7 | 	test	local03, #1 wz
0d690     B6 AF 06 A6 |  if_e	mov	local05, #438
0d694     10 AA CE F7 | 	test	local03, #16 wz
0d698     08 00 00 5F 
0d69c     49 AE 46 55 |  if_ne	or	local05, ##4169
0d6a0     08 A8 06 F1 | 	add	local02, #8
0d6a4     54 AF 62 FC | 	wrlong	local05, local02
0d6a8     04 A8 06 F1 | 	add	local02, #4
0d6ac     54 03 68 FC | 	wrlong	#1, local02
0d6b0     08 CE 85 F1 | 	sub	fp, #8
0d6b4     E7 76 02 FB | 	rdlong	result1, fp
0d6b8     0C A8 06 F1 | 	add	local02, #12
0d6bc     54 77 62 FC | 	wrlong	result1, local02
0d6c0     04 A8 06 F1 | 	add	local02, #4
0d6c4     54 01 68 FC | 	wrlong	#0, local02
0d6c8     04 A8 06 F1 | 	add	local02, #4
0d6cc     01 00 80 FF 
0d6d0     54 01 68 FC | 	wrlong	##512, local02
0d6d4     E7 AA 02 FB | 	rdlong	local03, fp
0d6d8     FF AB 06 F1 | 	add	local03, #511
0d6dc     09 AA 46 F0 | 	shr	local03, #9
0d6e0     04 A8 06 F1 | 	add	local02, #4
0d6e4     54 AB 62 FC | 	wrlong	local03, local02
0d6e8     04 CE 05 F1 | 	add	fp, #4
0d6ec     E7 90 E2 FA | 	rdword	arg01, fp
0d6f0     02 CE 05 F1 | 	add	fp, #2
0d6f4     E7 92 E2 FA | 	rdword	arg02, fp
0d6f8     16 CE 85 F1 | 	sub	fp, #22
0d6fc     58 FB BF FD | 	call	#_fatfs_cc_unixtime_0593
0d700     0C A8 06 F1 | 	add	local02, #12
0d704     54 77 62 FC | 	wrlong	result1, local02
0d708     04 A8 86 F1 | 	sub	local02, #4
0d70c     54 77 62 FC | 	wrlong	result1, local02
0d710     04 A8 86 F1 | 	sub	local02, #4
0d714     54 77 62 FC | 	wrlong	result1, local02
0d718                 | '         mode |=  0010000  |  0100  |  0010  |  0001 ;
0d718                 | '     }
0d718                 | '     buf->st_mode = mode;
0d718                 | '     buf->st_nlink = 1;
0d718                 | '     buf->st_size = finfo.fsize;
0d718                 | '     buf->st_blksize = 512;
0d718                 | '     buf->st_blocks = (finfo.fsize + 511) / 512;
0d718                 | '     buf->st_atime = buf->st_mtime = buf->st_ctime = unixtime(finfo.fdate, finfo.ftime);
0d718                 | ' #line 257 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d718                 | '     return r;
0d718     56 77 02 F6 | 	mov	result1, local04
0d71c                 | LR__2014
0d71c     E7 F0 03 F6 | 	mov	ptra, fp
0d720     F2 00 A0 FD | 	call	#popregs_
0d724                 | _fatfs_cc_v_stat_ret
0d724     2D 00 64 FD | 	ret
0d728                 | 
0d728                 | _fatfs_cc_v_read
0d728     02 CA 05 F6 | 	mov	COUNT_, #2
0d72c     E8 00 A0 FD | 	call	#pushregs_
0d730     1C F0 07 F1 | 	add	ptra, #28
0d734     48 A7 02 F6 | 	mov	local01, arg01
0d738     53 91 0A FB | 	rdlong	arg01, local01 wz
0d73c                 | '         return _seterror( 5 );
0d73c     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d740     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
0d744     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d748     01 76 66 A6 |  if_e	neg	result1, #1
0d74c     58 00 90 AD |  if_e	jmp	#LR__2021
0d750     02 00 00 FF 
0d754     10 90 06 F1 | 	add	arg01, ##1040
0d758     E7 96 02 F6 | 	mov	arg04, fp
0d75c     18 96 06 F1 | 	add	arg04, #24
0d760     DC E1 BF FD | 	call	#_fatfs_cc_f_read
0d764     3B 97 0A F6 | 	mov	arg04, result1 wz
0d768     1C 00 90 AD |  if_e	jmp	#LR__2020
0d76c     08 A6 06 F1 | 	add	local01, #8
0d770     53 91 02 FB | 	rdlong	arg01, local01
0d774     20 90 46 F5 | 	or	arg01, #32
0d778     53 91 62 FC | 	wrlong	arg01, local01
0d77c                 | '         fil->state |=  (0x20) ;
0d77c                 | '         return _set_dos_error(r);
0d77c     4B 91 02 F6 | 	mov	arg01, arg04
0d780     70 FB BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d784     20 00 90 FD | 	jmp	#LR__2021
0d788                 | LR__2020
0d788     18 CE 05 F1 | 	add	fp, #24
0d78c     E7 A8 0A FB | 	rdlong	local02, fp wz
0d790     08 A6 06 A1 |  if_e	add	local01, #8
0d794     53 A9 02 AB |  if_e	rdlong	local02, local01
0d798     10 A8 46 A5 |  if_e	or	local02, #16
0d79c     53 A9 62 AC |  if_e	wrlong	local02, local01
0d7a0                 | '         fil->state |=  (0x10) ;
0d7a0                 | '     }
0d7a0                 | '     return x;
0d7a0     E7 76 02 FB | 	rdlong	result1, fp
0d7a4     18 CE 85 F1 | 	sub	fp, #24
0d7a8                 | LR__2021
0d7a8     E7 F0 03 F6 | 	mov	ptra, fp
0d7ac     F2 00 A0 FD | 	call	#popregs_
0d7b0                 | _fatfs_cc_v_read_ret
0d7b0     2D 00 64 FD | 	ret
0d7b4                 | 
0d7b4                 | _fatfs_cc_v_write
0d7b4     01 CA 05 F6 | 	mov	COUNT_, #1
0d7b8     E8 00 A0 FD | 	call	#pushregs_
0d7bc     1C F0 07 F1 | 	add	ptra, #28
0d7c0     48 A7 02 F6 | 	mov	local01, arg01
0d7c4     53 91 0A FB | 	rdlong	arg01, local01 wz
0d7c8                 | '         return _seterror( 5 );
0d7c8     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d7cc     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
0d7d0     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d7d4     01 76 66 A6 |  if_e	neg	result1, #1
0d7d8     44 00 90 AD |  if_e	jmp	#LR__2031
0d7dc     02 00 00 FF 
0d7e0     10 90 06 F1 | 	add	arg01, ##1040
0d7e4     E7 96 02 F6 | 	mov	arg04, fp
0d7e8     18 96 06 F1 | 	add	arg04, #24
0d7ec     E8 E4 BF FD | 	call	#_fatfs_cc_f_write
0d7f0     3B 97 0A F6 | 	mov	arg04, result1 wz
0d7f4     1C 00 90 AD |  if_e	jmp	#LR__2030
0d7f8     08 A6 06 F1 | 	add	local01, #8
0d7fc     53 91 02 FB | 	rdlong	arg01, local01
0d800     20 90 46 F5 | 	or	arg01, #32
0d804     53 91 62 FC | 	wrlong	arg01, local01
0d808                 | '         fil->state |=  (0x20) ;
0d808                 | '         return _set_dos_error(r);
0d808     4B 91 02 F6 | 	mov	arg01, arg04
0d80c     E4 FA BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d810     0C 00 90 FD | 	jmp	#LR__2031
0d814                 | LR__2030
0d814                 | '     }
0d814                 | '     return x;
0d814     18 CE 05 F1 | 	add	fp, #24
0d818     E7 76 02 FB | 	rdlong	result1, fp
0d81c     18 CE 85 F1 | 	sub	fp, #24
0d820                 | LR__2031
0d820     E7 F0 03 F6 | 	mov	ptra, fp
0d824     F2 00 A0 FD | 	call	#popregs_
0d828                 | _fatfs_cc_v_write_ret
0d828     2D 00 64 FD | 	ret
0d82c                 | 
0d82c                 | _fatfs_cc_v_lseek
0d82c     06 CA 05 F6 | 	mov	COUNT_, #6
0d830     E8 00 A0 FD | 	call	#pushregs_
0d834     49 AB 02 F6 | 	mov	local03, arg02
0d838     4B AD 02 F6 | 	mov	local04, arg04
0d83c     48 AF 02 FB | 	rdlong	local05, arg01
0d840     02 00 00 FF 
0d844     10 AE 0E F1 | 	add	local05, ##1040 wz
0d848     18 00 90 5D |  if_ne	jmp	#LR__2040
0d84c                 | '         return _seterror( 5 );
0d84c     20 66 06 F1 | 	add	ptr___system__dat__, #32
0d850     33 0B 68 FC | 	wrlong	#5, ptr___system__dat__
0d854     20 66 86 F1 | 	sub	ptr___system__dat__, #32
0d858     01 78 66 F6 | 	neg	result2, #1
0d85c     01 76 66 F6 | 	neg	result1, #1
0d860     58 00 90 FD | 	jmp	#LR__2043
0d864                 | LR__2040
0d864     00 AC 0E F2 | 	cmp	local04, #0 wz
0d868     24 00 90 AD |  if_e	jmp	#LR__2041
0d86c     01 AC 0E F2 | 	cmp	local04, #1 wz
0d870     14 AE 06 A1 |  if_e	add	local05, #20
0d874     57 B1 02 AB |  if_e	rdlong	local06, local05
0d878     14 AE 86 A1 |  if_e	sub	local05, #20
0d87c     58 AB 02 A1 |  if_e	add	local03, local06
0d880     0C AE 06 51 |  if_ne	add	local05, #12
0d884     57 B1 02 5B |  if_ne	rdlong	local06, local05
0d888     0C AE 86 51 |  if_ne	sub	local05, #12
0d88c     58 AB 02 51 |  if_ne	add	local03, local06
0d890                 | LR__2041
0d890     57 91 02 F6 | 	mov	arg01, local05
0d894     55 93 02 F6 | 	mov	arg02, local03
0d898     38 EA BF FD | 	call	#_fatfs_cc_f_lseek
0d89c     3B 91 0A F6 | 	mov	arg01, result1 wz
0d8a0     10 00 90 AD |  if_e	jmp	#LR__2042
0d8a4                 | '         return _set_dos_error(result);
0d8a4     4C FA BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d8a8     3B 79 02 F6 | 	mov	result2, result1
0d8ac     1F 78 C6 F0 | 	sar	result2, #31
0d8b0     08 00 90 FD | 	jmp	#LR__2043
0d8b4                 | LR__2042
0d8b4                 | '     }
0d8b4                 | '     return (off_t)offset;
0d8b4     55 77 02 F6 | 	mov	result1, local03
0d8b8     54 79 02 F6 | 	mov	result2, local02
0d8bc                 | LR__2043
0d8bc     E7 F0 03 F6 | 	mov	ptra, fp
0d8c0     F2 00 A0 FD | 	call	#popregs_
0d8c4                 | _fatfs_cc_v_lseek_ret
0d8c4     2D 00 64 FD | 	ret
0d8c8                 | 
0d8c8                 | _fatfs_cc_v_ioctl
0d8c8                 | ' {
0d8c8                 | '     return _seterror( 10 );
0d8c8     20 66 06 F1 | 	add	ptr___system__dat__, #32
0d8cc     33 15 68 FC | 	wrlong	#10, ptr___system__dat__
0d8d0     20 66 86 F1 | 	sub	ptr___system__dat__, #32
0d8d4     01 76 66 F6 | 	neg	result1, #1
0d8d8                 | _fatfs_cc_v_ioctl_ret
0d8d8     2D 00 64 FD | 	ret
0d8dc                 | 
0d8dc                 | _fatfs_cc_v_mkdir
0d8dc     A0 F1 BF FD | 	call	#_fatfs_cc_f_mkdir
0d8e0     3B 91 02 F6 | 	mov	arg01, result1
0d8e4                 | ' 
0d8e4                 | '     r = f_mkdir(name);
0d8e4                 | '     return _set_dos_error(r);
0d8e4     0C FA BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d8e8                 | _fatfs_cc_v_mkdir_ret
0d8e8     2D 00 64 FD | 	ret
0d8ec                 | 
0d8ec                 | _fatfs_cc_v_remove
0d8ec     0C F0 BF FD | 	call	#_fatfs_cc_f_unlink
0d8f0     3B 91 02 F6 | 	mov	arg01, result1
0d8f4                 | ' 
0d8f4                 | '     r = f_unlink(name);
0d8f4                 | '     return _set_dos_error(r);
0d8f4     FC F9 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d8f8                 | _fatfs_cc_v_remove_ret
0d8f8     2D 00 64 FD | 	ret
0d8fc                 | 
0d8fc                 | _fatfs_cc_v_rmdir
0d8fc     FC EF BF FD | 	call	#_fatfs_cc_f_unlink
0d900     3B 91 02 F6 | 	mov	arg01, result1
0d904                 | ' 
0d904                 | '     r = f_unlink(name);
0d904                 | '     return _set_dos_error(r);
0d904     EC F9 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d908                 | _fatfs_cc_v_rmdir_ret
0d908     2D 00 64 FD | 	ret
0d90c                 | 
0d90c                 | _fatfs_cc_v_rename
0d90c     B0 F3 BF FD | 	call	#_fatfs_cc_f_rename
0d910     3B 91 02 F6 | 	mov	arg01, result1
0d914                 | '     return _set_dos_error(r);
0d914     DC F9 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d918                 | _fatfs_cc_v_rename_ret
0d918     2D 00 64 FD | 	ret
0d91c                 | 
0d91c                 | _fatfs_cc_v_open
0d91c     07 CA 05 F6 | 	mov	COUNT_, #7
0d920     E8 00 A0 FD | 	call	#pushregs_
0d924     48 A7 02 F6 | 	mov	local01, arg01
0d928     49 A9 02 F6 | 	mov	local02, arg02
0d92c     4A AB 02 F6 | 	mov	local03, arg03
0d930     03 00 00 FF 
0d934     38 90 06 F6 | 	mov	arg01, ##1592
0d938                 | '     return _gc_alloc(size);
0d938     10 92 06 F6 | 	mov	arg02, #16
0d93c     AC 79 BF FD | 	call	#__system___gc_doalloc
0d940     3B AD 0A F6 | 	mov	local04, result1 wz
0d944                 | '       return _seterror( 7 );
0d944     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0d948     33 0F 68 AC |  if_e	wrlong	#7, ptr___system__dat__
0d94c     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0d950     01 76 66 A6 |  if_e	neg	result1, #1
0d954     90 00 90 AD |  if_e	jmp	#LR__2056
0d958     56 91 02 F6 | 	mov	arg01, local04
0d95c     00 92 06 F6 | 	mov	arg02, #0
0d960     03 00 00 FF 
0d964     38 94 06 F6 | 	mov	arg03, ##1592
0d968     D8 00 A0 FD | 	call	#\builtin_bytefill_
0d96c                 | '   switch (flags & 3) {
0d96c     55 AF 02 F6 | 	mov	local05, local03
0d970     03 AE 0E F5 | 	and	local05, #3 wz
0d974     0C 00 90 AD |  if_e	jmp	#LR__2050
0d978     01 AE 0E F2 | 	cmp	local05, #1 wz
0d97c     0C 00 90 AD |  if_e	jmp	#LR__2051
0d980     10 00 90 FD | 	jmp	#LR__2052
0d984                 | LR__2050
0d984     01 B0 06 F6 | 	mov	local06, #1
0d988                 | '       fs_flags =  0x01 ;
0d988                 | '       break;
0d988     0C 00 90 FD | 	jmp	#LR__2053
0d98c                 | LR__2051
0d98c     02 B0 06 F6 | 	mov	local06, #2
0d990                 | '       fs_flags =  0x02 ;
0d990                 | '       break;
0d990     04 00 90 FD | 	jmp	#LR__2053
0d994                 | LR__2052
0d994     03 B0 06 F6 | 	mov	local06, #3
0d998                 | '       fs_flags =  0x01  |  0x02 ;
0d998                 | '       break;
0d998                 | LR__2053
0d998     08 AA CE F7 | 	test	local03, #8 wz
0d99c     18 B0 46 55 |  if_ne	or	local06, #24
0d9a0     08 00 90 5D |  if_ne	jmp	#LR__2054
0d9a4     20 AA CE F7 | 	test	local03, #32 wz
0d9a8     30 B0 46 55 |  if_ne	or	local06, #48
0d9ac                 | LR__2054
0d9ac     56 91 02 F6 | 	mov	arg01, local04
0d9b0     02 00 00 FF 
0d9b4     10 90 06 F1 | 	add	arg01, ##1040
0d9b8     54 93 02 F6 | 	mov	arg02, local02
0d9bc     58 95 02 F6 | 	mov	arg03, local06
0d9c0     24 DB BF FD | 	call	#_fatfs_cc_f_open
0d9c4     3B B3 0A F6 | 	mov	local07, result1 wz
0d9c8     14 00 90 AD |  if_e	jmp	#LR__2055
0d9cc     56 91 02 F6 | 	mov	arg01, local04
0d9d0                 | '     return _gc_free(ptr);
0d9d0     1C 7A BF FD | 	call	#__system___gc_free
0d9d4                 | '     free(f);
0d9d4                 | ' #line 426 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0d9d4                 | '     return _set_dos_error(r);
0d9d4     59 91 02 F6 | 	mov	arg01, local07
0d9d8     18 F9 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0d9dc     08 00 90 FD | 	jmp	#LR__2056
0d9e0                 | LR__2055
0d9e0     53 AD 62 FC | 	wrlong	local04, local01
0d9e4                 | '   }
0d9e4                 | '   fil->vfsdata = f;
0d9e4                 | '   return 0;
0d9e4     00 76 06 F6 | 	mov	result1, #0
0d9e8                 | LR__2056
0d9e8     E7 F0 03 F6 | 	mov	ptra, fp
0d9ec     F2 00 A0 FD | 	call	#popregs_
0d9f0                 | _fatfs_cc_v_open_ret
0d9f0     2D 00 64 FD | 	ret
0d9f4                 | 
0d9f4                 | _fatfs_cc_v_flush
0d9f4     01 CA 05 F6 | 	mov	COUNT_, #1
0d9f8     E8 00 A0 FD | 	call	#pushregs_
0d9fc     48 A7 02 F6 | 	mov	local01, arg01
0da00     80 F5 BF FD | 	call	#_fatfs_cc___default_flush
0da04     53 A7 02 FB | 	rdlong	local01, local01
0da08     02 00 00 FF 
0da0c     10 A6 0E F1 | 	add	local01, ##1040 wz
0da10                 | '         return _seterror( 5 );
0da10     20 66 06 A1 |  if_e	add	ptr___system__dat__, #32
0da14     33 0B 68 AC |  if_e	wrlong	#5, ptr___system__dat__
0da18     20 66 86 A1 |  if_e	sub	ptr___system__dat__, #32
0da1c     01 76 66 A6 |  if_e	neg	result1, #1
0da20     10 00 90 AD |  if_e	jmp	#LR__2060
0da24     53 91 02 F6 | 	mov	arg01, local01
0da28     FC E6 BF FD | 	call	#_fatfs_cc_f_sync
0da2c     3B 91 02 F6 | 	mov	arg01, result1
0da30                 | '     }
0da30                 | ' #line 449 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0da30                 | '     result = f_sync(f);
0da30                 | ' #line 453 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0da30                 | '     return _set_dos_error(result);
0da30     C0 F8 BF FD | 	call	#_fatfs_cc__set_dos_error_0595
0da34                 | LR__2060
0da34     E7 F0 03 F6 | 	mov	ptra, fp
0da38     F2 00 A0 FD | 	call	#popregs_
0da3c                 | _fatfs_cc_v_flush_ret
0da3c     2D 00 64 FD | 	ret
0da40                 | 
0da40                 | _fatfs_cc_v_init
0da40                 | ' {
0da40                 | '     return 0;
0da40     00 76 06 F6 | 	mov	result1, #0
0da44                 | _fatfs_cc_v_init_ret
0da44     2D 00 64 FD | 	ret
0da48                 | 
0da48                 | _fatfs_cc_v_deinit
0da48     71 00 00 FF 
0da4c     3E 93 06 F6 | 	mov	arg02, ##@LR__2171
0da50     00 90 06 F6 | 	mov	arg01, #0
0da54     00 94 06 F6 | 	mov	arg03, #0
0da58     B8 D9 BF FD | 	call	#_fatfs_cc_f_mount
0da5c     01 00 00 FF 
0da60     08 62 06 F1 | 	add	objptr, ##520
0da64     31 91 02 FB | 	rdlong	arg01, objptr
0da68     04 62 06 F1 | 	add	objptr, #4
0da6c     31 93 02 FB | 	rdlong	arg02, objptr
0da70     01 00 00 FF 
0da74     0C 62 86 F1 | 	sub	objptr, ##524
0da78     0C 6B BF FD | 	call	#__system___freepins
0da7c                 | ' #line 474 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0da7c                 | '     _freepins(f_pinmask);
0da7c                 | '     return 0;
0da7c     00 76 06 F6 | 	mov	result1, #0
0da80                 | _fatfs_cc_v_deinit_ret
0da80     2D 00 64 FD | 	ret
0da84                 | 
0da84                 | _fatfs_cc_get_vfs
0da84     01 CA 05 F6 | 	mov	COUNT_, #1
0da88     E8 00 A0 FD | 	call	#pushregs_
0da8c     48 A7 02 F6 | 	mov	local01, arg01
0da90     58 90 06 F6 | 	mov	arg01, #88
0da94     24 78 BF FD | 	call	#__system___gc_alloc_managed
0da98     3B 91 02 F6 | 	mov	arg01, result1
0da9c     31 77 02 F6 | 	mov	result1, objptr
0daa0     74 76 26 F4 | 	bith	result1, #116
0daa4     48 77 62 FC | 	wrlong	result1, arg01
0daa8     31 77 02 F6 | 	mov	result1, objptr
0daac     18 76 26 F4 | 	bith	result1, #24
0dab0     04 90 06 F1 | 	add	arg01, #4
0dab4     48 77 62 FC | 	wrlong	result1, arg01
0dab8     31 77 02 F6 | 	mov	result1, objptr
0dabc     00 88 00 FF 
0dac0     00 76 46 F5 | 	or	result1, ##17825792
0dac4     04 90 06 F1 | 	add	arg01, #4
0dac8     48 77 62 FC | 	wrlong	result1, arg01
0dacc     31 77 02 F6 | 	mov	result1, objptr
0dad0     00 90 00 FF 
0dad4     00 76 46 F5 | 	or	result1, ##18874368
0dad8     04 90 06 F1 | 	add	arg01, #4
0dadc     48 77 62 FC | 	wrlong	result1, arg01
0dae0     31 77 02 F6 | 	mov	result1, objptr
0dae4     00 98 00 FF 
0dae8     00 76 46 F5 | 	or	result1, ##19922944
0daec     04 90 06 F1 | 	add	arg01, #4
0daf0     48 77 62 FC | 	wrlong	result1, arg01
0daf4     31 77 02 F6 | 	mov	result1, objptr
0daf8     00 A0 00 FF 
0dafc     00 76 46 F5 | 	or	result1, ##20971520
0db00     04 90 06 F1 | 	add	arg01, #4
0db04     48 77 62 FC | 	wrlong	result1, arg01
0db08     04 90 06 F1 | 	add	arg01, #4
0db0c     48 A7 62 FC | 	wrlong	local01, arg01
0db10     04 90 06 F1 | 	add	arg01, #4
0db14     48 01 68 FC | 	wrlong	#0, arg01
0db18     31 77 02 F6 | 	mov	result1, objptr
0db1c     00 A8 00 FF 
0db20     00 76 46 F5 | 	or	result1, ##22020096
0db24     04 90 06 F1 | 	add	arg01, #4
0db28     48 77 62 FC | 	wrlong	result1, arg01
0db2c     31 77 02 F6 | 	mov	result1, objptr
0db30     00 B0 00 FF 
0db34     00 76 46 F5 | 	or	result1, ##23068672
0db38     04 90 06 F1 | 	add	arg01, #4
0db3c     48 77 62 FC | 	wrlong	result1, arg01
0db40     31 77 02 F6 | 	mov	result1, objptr
0db44     00 B8 00 FF 
0db48     00 76 46 F5 | 	or	result1, ##24117248
0db4c     04 90 06 F1 | 	add	arg01, #4
0db50     48 77 62 FC | 	wrlong	result1, arg01
0db54     31 77 02 F6 | 	mov	result1, objptr
0db58     37 76 26 F4 | 	bith	result1, #55
0db5c     04 90 06 F1 | 	add	arg01, #4
0db60     48 77 62 FC | 	wrlong	result1, arg01
0db64     31 77 02 F6 | 	mov	result1, objptr
0db68     00 C8 00 FF 
0db6c     00 76 46 F5 | 	or	result1, ##26214400
0db70     04 90 06 F1 | 	add	arg01, #4
0db74     48 77 62 FC | 	wrlong	result1, arg01
0db78     31 77 02 F6 | 	mov	result1, objptr
0db7c     00 D0 00 FF 
0db80     00 76 46 F5 | 	or	result1, ##27262976
0db84     04 90 06 F1 | 	add	arg01, #4
0db88     48 77 62 FC | 	wrlong	result1, arg01
0db8c     31 77 02 F6 | 	mov	result1, objptr
0db90     00 D8 00 FF 
0db94     00 76 46 F5 | 	or	result1, ##28311552
0db98     04 90 06 F1 | 	add	arg01, #4
0db9c     48 77 62 FC | 	wrlong	result1, arg01
0dba0     31 77 02 F6 | 	mov	result1, objptr
0dba4     56 76 26 F4 | 	bith	result1, #86
0dba8     04 90 06 F1 | 	add	arg01, #4
0dbac     48 77 62 FC | 	wrlong	result1, arg01
0dbb0     31 77 02 F6 | 	mov	result1, objptr
0dbb4     00 E8 00 FF 
0dbb8     00 76 46 F5 | 	or	result1, ##30408704
0dbbc     04 90 06 F1 | 	add	arg01, #4
0dbc0     48 77 62 FC | 	wrlong	result1, arg01
0dbc4     31 77 02 F6 | 	mov	result1, objptr
0dbc8     75 76 26 F4 | 	bith	result1, #117
0dbcc     04 90 06 F1 | 	add	arg01, #4
0dbd0     48 77 62 FC | 	wrlong	result1, arg01
0dbd4     31 77 02 F6 | 	mov	result1, objptr
0dbd8     94 76 26 F4 | 	bith	result1, #148
0dbdc     04 90 06 F1 | 	add	arg01, #4
0dbe0     48 77 62 FC | 	wrlong	result1, arg01
0dbe4     31 77 02 F6 | 	mov	result1, objptr
0dbe8     19 76 26 F4 | 	bith	result1, #25
0dbec     04 90 06 F1 | 	add	arg01, #4
0dbf0     48 77 62 FC | 	wrlong	result1, arg01
0dbf4     04 90 06 F1 | 	add	arg01, #4
0dbf8     48 01 68 FC | 	wrlong	#0, arg01
0dbfc     04 90 06 F1 | 	add	arg01, #4
0dc00     48 01 68 FC | 	wrlong	#0, arg01
0dc04     54 90 86 F1 | 	sub	arg01, #84
0dc08                 | ' 
0dc08                 | '     v->close = &v_close;
0dc08                 | '     v->read = &v_read;
0dc08                 | '     v->write = &v_write;
0dc08                 | '     v->lseek = &v_lseek;
0dc08                 | '     v->ioctl = &v_ioctl;
0dc08                 | '     v->flush = &v_flush;
0dc08                 | '     v->vfs_data = ptr;
0dc08                 | '     v->reserved = 0;
0dc08                 | ' 
0dc08                 | '     v->open = &v_open;
0dc08                 | '     v->creat = &v_creat;
0dc08                 | '     v->opendir = &v_opendir;
0dc08                 | '     v->closedir = &v_closedir;
0dc08                 | '     v->readdir = &v_readdir;
0dc08                 | '     v->stat = &v_stat;
0dc08                 | ' 
0dc08                 | '     v->mkdir = &v_mkdir;
0dc08                 | '     v->rmdir = &v_rmdir;
0dc08                 | ' 
0dc08                 | '     v->remove = &v_remove;
0dc08                 | '     v->rename = &v_rename;
0dc08                 | ' 
0dc08                 | '     v->init = &v_init;
0dc08                 | '     v->deinit = &v_deinit;
0dc08                 | ' 
0dc08                 | ' 
0dc08                 | '     v->getcf = 0;
0dc08                 | '     v->putcf = 0;
0dc08                 | ' #line 532 "C:/Users/Piotr/Downloads/flexprop-7.0.0/flexprop/include/filesys/fatfs/fatfs.cc"
0dc08                 | '     return v;
0dc08     48 77 02 F6 | 	mov	result1, arg01
0dc0c     E7 F0 03 F6 | 	mov	ptra, fp
0dc10     F2 00 A0 FD | 	call	#popregs_
0dc14                 | _fatfs_cc_get_vfs_ret
0dc14     2D 00 64 FD | 	ret
0dc18                 | 
0dc18                 | _fatfs_cc_gettimeofday
0dc18     04 CA 05 F6 | 	mov	COUNT_, #4
0dc1c     E8 00 A0 FD | 	call	#pushregs_
0dc20     48 A7 02 F6 | 	mov	local01, arg01
0dc24     44 54 BF FD | 	call	#__system___getus
0dc28     3B 91 02 F6 | 	mov	arg01, result1
0dc2c     02 00 00 FF 
0dc30     08 6B 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1288
0dc34     35 A9 02 FB | 	rdlong	local02, ptr__fatfs_cc_dat__
0dc38     48 77 02 F6 | 	mov	result1, arg01
0dc3c     54 77 82 F1 | 	sub	result1, local02
0dc40     A1 07 00 FF 
0dc44     40 76 16 FD | 	qdiv	result1, ##1000000
0dc48     02 00 00 FF 
0dc4c     08 6B 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1288
0dc50     18 A8 62 FD | 	getqx	local02
0dc54     A1 07 00 FF 
0dc58     40 76 16 FD | 	qdiv	result1, ##1000000
0dc5c     00 A8 0E F2 | 	cmp	local02, #0 wz
0dc60     19 AA 62 FD | 	getqy	local03
0dc64     28 00 90 AD |  if_e	jmp	#LR__2070
0dc68     02 00 00 FF 
0dc6c     04 6B 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1284
0dc70     35 AD 02 FB | 	rdlong	local04, ptr__fatfs_cc_dat__
0dc74     54 AD 02 F1 | 	add	local04, local02
0dc78     35 AD 62 FC | 	wrlong	local04, ptr__fatfs_cc_dat__
0dc7c     55 91 82 F1 | 	sub	arg01, local03
0dc80     04 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, #4
0dc84     35 91 62 FC | 	wrlong	arg01, ptr__fatfs_cc_dat__
0dc88     02 00 00 FF 
0dc8c     08 6B 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1288
0dc90                 | LR__2070
0dc90     02 00 00 FF 
0dc94     04 6B 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1284
0dc98     35 AD 02 FB | 	rdlong	local04, ptr__fatfs_cc_dat__
0dc9c     02 00 00 FF 
0dca0     04 6B 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1284
0dca4     53 AD 62 FC | 	wrlong	local04, local01
0dca8     04 A6 06 F1 | 	add	local01, #4
0dcac     53 AB 62 FC | 	wrlong	local03, local01
0dcb0                 | '         lastsec += secs;
0dcb0                 | '         lastus = now - leftover;
0dcb0                 | '     }
0dcb0                 | '     tv->tv_sec = lastsec;
0dcb0                 | '     tv->tv_usec = leftover;
0dcb0                 | '     return 0;
0dcb0     00 76 06 F6 | 	mov	result1, #0
0dcb4     E7 F0 03 F6 | 	mov	ptra, fp
0dcb8     F2 00 A0 FD | 	call	#popregs_
0dcbc                 | _fatfs_cc_gettimeofday_ret
0dcbc     2D 00 64 FD | 	ret
0dcc0                 | 
0dcc0                 | _fatfs_cc__is_leap_year
0dcc0     48 77 52 F6 | 	abs	result1, arg01 wc
0dcc4     03 76 06 F5 | 	and	result1, #3
0dcc8     3B 77 8A F6 | 	negc	result1, result1 wz
0dccc     38 00 90 5D |  if_ne	jmp	#LR__2081
0dcd0     48 77 52 F6 | 	abs	result1, arg01 wc
0dcd4     64 76 16 FD | 	qdiv	result1, #100
0dcd8     19 76 62 FD | 	getqy	result1
0dcdc     3B 77 8A F6 | 	negc	result1, result1 wz
0dce0     1C 00 90 5D |  if_ne	jmp	#LR__2080
0dce4     48 77 52 F6 | 	abs	result1, arg01 wc
0dce8     90 77 16 FD | 	qdiv	result1, #400
0dcec                 | '       return (0 == y % 400);
0dcec     00 76 06 F6 | 	mov	result1, #0
0dcf0     19 7C 62 FD | 	getqy	_var01
0dcf4     3E 7D 8A F6 | 	negc	_var01, _var01 wz
0dcf8     01 76 06 A6 |  if_e	mov	result1, #1
0dcfc     0C 00 90 FD | 	jmp	#_fatfs_cc__is_leap_year_ret
0dd00                 | LR__2080
0dd00                 | '     return 1;
0dd00     01 76 06 F6 | 	mov	result1, #1
0dd04     04 00 90 FD | 	jmp	#_fatfs_cc__is_leap_year_ret
0dd08                 | LR__2081
0dd08                 | '   }
0dd08                 | '   return 0;
0dd08     00 76 06 F6 | 	mov	result1, #0
0dd0c                 | _fatfs_cc__is_leap_year_ret
0dd0c     2D 00 64 FD | 	ret
0dd10                 | 
0dd10                 | _fatfs_cc___tzoffset
0dd10     48 7D 0A F6 | 	mov	_var01, arg01 wz
0dd14     FF FF FF FF 
0dd18     49 FF 6B FC | 	wrlong	##-1, arg02
0dd1c     01 7E 06 F6 | 	mov	_var02, #1
0dd20     3E 81 CA 5A |  if_ne	rdbyte	_var03, _var01 wz
0dd24                 | '                 return 0;
0dd24     00 76 06 A6 |  if_e	mov	result1, #0
0dd28     7C 02 90 AD |  if_e	jmp	#LR__2107
0dd2c     49 01 68 FC | 	wrlong	#0, arg02
0dd30     35 83 02 F6 | 	mov	_var04, ptr__fatfs_cc_dat__
0dd34     02 00 00 FF 
0dd38     DC 82 06 F1 | 	add	_var04, ##1244
0dd3c     D7 26 48 FB | 	callpa	#(@LR__2091-@LR__2090)>>2,fcache_load_ptr_
0dd40                 | ' 
0dd40                 | '        *hasdst = 0;
0dd40                 | ' 
0dd40                 | ' 	n = stdname;
0dd40                 | '         while (*s && isalpha(*s)) {
0dd40                 | LR__2090
0dd40     3E 81 CA FA | 	rdbyte	_var03, _var01 wz
0dd44     44 00 90 AD |  if_e	jmp	#LR__2092
0dd48     3E 91 C2 FA | 	rdbyte	arg01, _var01
0dd4c                 | ' {
0dd4c                 | '   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
0dd4c     80 90 36 F3 | 	fle	arg01, #128 wc
0dd50                 | '     return __ctype[c];
0dd50     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0dd54     02 00 00 FF 
0dd58     0C 77 06 F1 | 	add	result1, ##1292
0dd5c     3B 91 02 F1 | 	add	arg01, result1
0dd60     48 77 C2 FA | 	rdbyte	result1, arg01
0dd64     0C 76 CE F7 | 	test	result1, #12 wz
0dd68     20 00 90 AD |  if_e	jmp	#LR__2092
0dd6c     3E 85 02 F6 | 	mov	_var05, _var01
0dd70     3E 87 02 F6 | 	mov	_var06, _var01
0dd74     01 86 06 F1 | 	add	_var06, #1
0dd78     42 89 C2 FA | 	rdbyte	_var07, _var05
0dd7c     43 7D 02 F6 | 	mov	_var01, _var06
0dd80     41 89 42 FC | 	wrbyte	_var07, _var04
0dd84     01 82 06 F1 | 	add	_var04, #1
0dd88     B4 FF 9F FD | 	jmp	#LR__2090
0dd8c                 | LR__2091
0dd8c                 | LR__2092
0dd8c     41 01 48 FC | 	wrbyte	#0, _var04
0dd90     00 8A 06 F6 | 	mov	_var08, #0
0dd94     3E 81 C2 FA | 	rdbyte	_var03, _var01
0dd98     2D 80 0E F2 | 	cmp	_var03, #45 wz
0dd9c     01 7E 66 A6 |  if_e	neg	_var02, #1
0dda0     01 7C 06 A1 |  if_e	add	_var01, #1
0dda4     D7 26 48 FB | 	callpa	#(@LR__2094-@LR__2093)>>2,fcache_load_ptr_
0dda8                 | '                 sgn = -1;
0dda8                 | '                 s++;
0dda8                 | '         }
0dda8                 | '         while (isdigit(*s)) {
0dda8                 | LR__2093
0dda8     3E 91 C2 FA | 	rdbyte	arg01, _var01
0ddac                 | ' {
0ddac                 | '   return  (__ctype_get(c) & 0x02 ) ;
0ddac     80 90 36 F3 | 	fle	arg01, #128 wc
0ddb0                 | '     return __ctype[c];
0ddb0     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0ddb4     02 00 00 FF 
0ddb8     0C 77 06 F1 | 	add	result1, ##1292
0ddbc     3B 91 02 F1 | 	add	arg01, result1
0ddc0     48 77 C2 FA | 	rdbyte	result1, arg01
0ddc4     02 76 CE F7 | 	test	result1, #2 wz
0ddc8     28 00 90 AD |  if_e	jmp	#LR__2095
0ddcc     45 81 02 F6 | 	mov	_var03, _var08
0ddd0     02 80 66 F0 | 	shl	_var03, #2
0ddd4     45 81 02 F1 | 	add	_var03, _var08
0ddd8     01 80 66 F0 | 	shl	_var03, #1
0dddc     3E 85 C2 FA | 	rdbyte	_var05, _var01
0dde0     30 84 86 F1 | 	sub	_var05, #48
0dde4     42 81 02 F1 | 	add	_var03, _var05
0dde8     40 8B 02 F6 | 	mov	_var08, _var03
0ddec     01 7C 06 F1 | 	add	_var01, #1
0ddf0     B4 FF 9F FD | 	jmp	#LR__2093
0ddf4                 | LR__2094
0ddf4                 | LR__2095
0ddf4     07 00 00 FF 
0ddf8     10 8A 06 FD | 	qmul	_var08, ##3600
0ddfc     3E 81 C2 FA | 	rdbyte	_var03, _var01
0de00     3A 80 0E F2 | 	cmp	_var03, #58 wz
0de04     18 8C 62 FD | 	getqx	_var09
0de08     6C 00 90 5D |  if_ne	jmp	#LR__2099
0de0c     00 8A 06 F6 | 	mov	_var08, #0
0de10     01 7C 06 F1 | 	add	_var01, #1
0de14     D7 26 48 FB | 	callpa	#(@LR__2097-@LR__2096)>>2,fcache_load_ptr_
0de18                 | '                 x = 0;
0de18                 | '                 s++;
0de18                 | '                 while (isdigit(*s)) {
0de18                 | LR__2096
0de18     3E 91 C2 FA | 	rdbyte	arg01, _var01
0de1c                 | ' {
0de1c                 | '   return  (__ctype_get(c) & 0x02 ) ;
0de1c     80 90 36 F3 | 	fle	arg01, #128 wc
0de20                 | '     return __ctype[c];
0de20     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0de24     02 00 00 FF 
0de28     0C 77 06 F1 | 	add	result1, ##1292
0de2c     3B 91 02 F1 | 	add	arg01, result1
0de30     48 77 C2 FA | 	rdbyte	result1, arg01
0de34     02 76 CE F7 | 	test	result1, #2 wz
0de38     28 00 90 AD |  if_e	jmp	#LR__2098
0de3c     45 81 02 F6 | 	mov	_var03, _var08
0de40     02 80 66 F0 | 	shl	_var03, #2
0de44     45 81 02 F1 | 	add	_var03, _var08
0de48     01 80 66 F0 | 	shl	_var03, #1
0de4c     3E 85 C2 FA | 	rdbyte	_var05, _var01
0de50     30 84 86 F1 | 	sub	_var05, #48
0de54     42 81 02 F1 | 	add	_var03, _var05
0de58     40 8B 02 F6 | 	mov	_var08, _var03
0de5c     01 7C 06 F1 | 	add	_var01, #1
0de60     B4 FF 9F FD | 	jmp	#LR__2096
0de64                 | LR__2097
0de64                 | LR__2098
0de64     45 89 02 F6 | 	mov	_var07, _var08
0de68     04 88 66 F0 | 	shl	_var07, #4
0de6c     45 89 82 F1 | 	sub	_var07, _var08
0de70     02 88 66 F0 | 	shl	_var07, #2
0de74     44 8D 02 F1 | 	add	_var09, _var07
0de78                 | LR__2099
0de78     35 83 02 F6 | 	mov	_var04, ptr__fatfs_cc_dat__
0de7c     02 00 00 FF 
0de80     E5 82 06 F1 | 	add	_var04, ##1253
0de84     3E 91 C2 FA | 	rdbyte	arg01, _var01
0de88                 | ' {
0de88                 | '   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
0de88     80 90 36 F3 | 	fle	arg01, #128 wc
0de8c                 | '     return __ctype[c];
0de8c     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0de90     02 00 00 FF 
0de94     0C 77 06 F1 | 	add	result1, ##1292
0de98     3B 91 02 F1 | 	add	arg01, result1
0de9c     48 77 C2 FA | 	rdbyte	result1, arg01
0dea0     0C 76 CE F7 | 	test	result1, #12 wz
0dea4     4C 00 90 AD |  if_e	jmp	#LR__2102
0dea8     49 03 68 FC | 	wrlong	#1, arg02
0deac                 | '                 *hasdst = 1;
0deac                 | ' 		while (*s && isalpha(*s)) *n++ = *s++;
0deac                 | LR__2100
0deac     3E 81 CA FA | 	rdbyte	_var03, _var01 wz
0deb0     40 00 90 AD |  if_e	jmp	#LR__2101
0deb4     3E 91 C2 FA | 	rdbyte	arg01, _var01
0deb8                 | ' {
0deb8                 | '   return  (__ctype_get(c) & ( 0x04 | 0x08 ) ) ;
0deb8     80 90 36 F3 | 	fle	arg01, #128 wc
0debc                 | '     return __ctype[c];
0debc     35 77 02 F6 | 	mov	result1, ptr__fatfs_cc_dat__
0dec0     02 00 00 FF 
0dec4     0C 77 06 F1 | 	add	result1, ##1292
0dec8     3B 91 02 F1 | 	add	arg01, result1
0decc     48 77 C2 FA | 	rdbyte	result1, arg01
0ded0     0C 76 CE F7 | 	test	result1, #12 wz
0ded4     1C 00 90 AD |  if_e	jmp	#LR__2101
0ded8     3E 87 02 F6 | 	mov	_var06, _var01
0dedc     01 86 06 F1 | 	add	_var06, #1
0dee0     3E 89 C2 FA | 	rdbyte	_var07, _var01
0dee4     43 7D 02 F6 | 	mov	_var01, _var06
0dee8     41 89 42 FC | 	wrbyte	_var07, _var04
0deec     01 82 06 F1 | 	add	_var04, #1
0def0     B8 FF 9F FD | 	jmp	#LR__2100
0def4                 | LR__2101
0def4                 | LR__2102
0def4     41 01 48 FC | 	wrbyte	#0, _var04
0def8     02 00 00 FF 
0defc     DC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1244
0df00     35 81 CA FA | 	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
0df04     02 00 00 FF 
0df08     DC 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1244
0df0c     20 00 90 AD |  if_e	jmp	#LR__2103
0df10     02 00 00 FF 
0df14     DC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1244
0df18     35 81 02 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
0df1c     08 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, #8
0df20     35 81 62 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
0df24     02 00 00 FF 
0df28     D4 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1236
0df2c     1C 00 90 FD | 	jmp	#LR__2104
0df30                 | LR__2103
0df30     02 00 00 FF 
0df34     EE 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1262
0df38     35 81 02 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
0df3c     1A 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, #26
0df40     35 81 62 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
0df44     02 00 00 FF 
0df48     D4 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1236
0df4c                 | LR__2104
0df4c     02 00 00 FF 
0df50     E5 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1253
0df54     35 81 CA FA | 	rdbyte	_var03, ptr__fatfs_cc_dat__ wz
0df58     02 00 00 FF 
0df5c     E5 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1253
0df60     20 00 90 AD |  if_e	jmp	#LR__2105
0df64     02 00 00 FF 
0df68     E5 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1253
0df6c     35 81 02 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
0df70     0D 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, #13
0df74     35 81 62 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
0df78     02 00 00 FF 
0df7c     D8 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1240
0df80     1C 00 90 FD | 	jmp	#LR__2106
0df84                 | LR__2105
0df84     02 00 00 FF 
0df88     DC 6A 06 F1 | 	add	ptr__fatfs_cc_dat__, ##1244
0df8c     35 81 02 F6 | 	mov	_var03, ptr__fatfs_cc_dat__
0df90     04 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, #4
0df94     35 81 62 FC | 	wrlong	_var03, ptr__fatfs_cc_dat__
0df98     02 00 00 FF 
0df9c     D8 6A 86 F1 | 	sub	ptr__fatfs_cc_dat__, ##1240
0dfa0                 | LR__2106
0dfa0     46 7F 02 FD | 	qmul	_var02, _var09
0dfa4                 | ' 		_tzname[1] = stdname;
0dfa4                 | ' 
0dfa4                 | '         return sgn * off;
0dfa4     18 76 62 FD | 	getqx	result1
0dfa8                 | LR__2107
0dfa8                 | _fatfs_cc___tzoffset_ret
0dfa8     2D 00 64 FD | 	ret
0dfac                 | 
0dfac                 | _fatfs_cc___indst
0dfac     10 90 06 F1 | 	add	arg01, #16
0dfb0     48 7D 02 FB | 	rdlong	_var01, arg01
0dfb4     10 90 86 F1 | 	sub	arg01, #16
0dfb8     02 7C 0E F2 | 	cmp	_var01, #2 wz
0dfbc     30 00 90 5D |  if_ne	jmp	#LR__2110
0dfc0     07 7C 06 F6 | 	mov	_var01, #7
0dfc4     18 90 06 F1 | 	add	arg01, #24
0dfc8     48 7F 02 FB | 	rdlong	_var02, arg01
0dfcc     3F 7D 02 F1 | 	add	_var01, _var02
0dfd0     0C 90 86 F1 | 	sub	arg01, #12
0dfd4     48 81 02 FB | 	rdlong	_var03, arg01
0dfd8     40 7D 82 F1 | 	sub	_var01, _var03
0dfdc     00 7C 56 F2 | 	cmps	_var01, #0 wc
0dfe0                 | '                         return 1;
0dfe0     01 76 06 C6 |  if_b	mov	result1, #1
0dfe4     70 00 90 CD |  if_b	jmp	#_fatfs_cc___indst_ret
0dfe8                 | '                 return 0;
0dfe8     00 76 06 F6 | 	mov	result1, #0
0dfec     68 00 90 FD | 	jmp	#_fatfs_cc___indst_ret
0dff0                 | LR__2110
0dff0     10 90 06 F1 | 	add	arg01, #16
0dff4     48 7D 02 FB | 	rdlong	_var01, arg01
0dff8     10 90 86 F1 | 	sub	arg01, #16
0dffc     0A 7C 0E F2 | 	cmp	_var01, #10 wz
0e000     28 00 90 5D |  if_ne	jmp	#LR__2111
0e004     18 90 06 F1 | 	add	arg01, #24
0e008     48 7D 02 FB | 	rdlong	_var01, arg01
0e00c     0C 90 86 F1 | 	sub	arg01, #12
0e010     48 83 02 FB | 	rdlong	_var04, arg01
0e014     41 7D 82 F1 | 	sub	_var01, _var04
0e018     00 7C 56 F2 | 	cmps	_var01, #0 wc
0e01c                 | '                         return 0;
0e01c     00 76 06 C6 |  if_b	mov	result1, #0
0e020     34 00 90 CD |  if_b	jmp	#_fatfs_cc___indst_ret
0e024                 | '                 return 1;
0e024     01 76 06 F6 | 	mov	result1, #1
0e028     2C 00 90 FD | 	jmp	#_fatfs_cc___indst_ret
0e02c                 | LR__2111
0e02c                 | '         }
0e02c                 | ' 
0e02c                 | '         return (t->tm_mon > 2 && t->tm_mon < 10);
0e02c     00 7C 06 F6 | 	mov	_var01, #0
0e030     10 90 06 F1 | 	add	arg01, #16
0e034     48 7F 02 FB | 	rdlong	_var02, arg01
0e038     10 90 86 F1 | 	sub	arg01, #16
0e03c     03 7E 56 F2 | 	cmps	_var02, #3 wc
0e040     10 00 90 CD |  if_b	jmp	#LR__2112
0e044     10 90 06 F1 | 	add	arg01, #16
0e048     48 81 02 FB | 	rdlong	_var03, arg01
0e04c     0A 80 56 F2 | 	cmps	_var03, #10 wc
0e050     01 7C 06 C6 |  if_b	mov	_var01, #1
0e054                 | LR__2112
0e054     3E 77 02 F6 | 	mov	result1, _var01
0e058                 | _fatfs_cc___indst_ret
0e058     2D 00 64 FD | 	ret
0e05c                 | 
0e05c                 | _fatfs_cc_disk_deinitialize
0e05c     03 CA 05 F6 | 	mov	COUNT_, #3
0e060     E8 00 A0 FD | 	call	#pushregs_
0e064     01 00 00 FF 
0e068     10 62 06 F1 | 	add	objptr, ##528
0e06c     31 91 0A FB | 	rdlong	arg01, objptr wz
0e070     01 00 00 FF 
0e074     10 62 86 F1 | 	sub	objptr, ##528
0e078                 | ' 
0e078                 | '         return RES_NOTRDY;
0e078     03 76 06 A6 |  if_e	mov	result1, #3
0e07c     4C 00 90 AD |  if_e	jmp	#LR__2120
0e080     01 00 00 FF 
0e084     10 62 06 F1 | 	add	objptr, ##528
0e088     31 91 02 FB | 	rdlong	arg01, objptr
0e08c     48 A7 02 F6 | 	mov	local01, arg01
0e090     24 A6 06 F1 | 	add	local01, #36
0e094     53 A7 02 FB | 	rdlong	local01, local01
0e098     53 A9 02 F6 | 	mov	local02, local01
0e09c     13 A6 46 F7 | 	zerox	local01, #19
0e0a0     14 A8 46 F0 | 	shr	local02, #20
0e0a4     02 A8 66 F0 | 	shl	local02, #2
0e0a8     2D A9 02 F1 | 	add	local02, __methods__
0e0ac     54 A9 02 FB | 	rdlong	local02, local02
0e0b0     01 00 00 FF 
0e0b4     10 62 86 F1 | 	sub	objptr, ##528
0e0b8     31 AB 02 F6 | 	mov	local03, objptr
0e0bc     53 63 02 F6 | 	mov	objptr, local01
0e0c0     2D A8 62 FD | 	call	local02
0e0c4     55 63 02 F6 | 	mov	objptr, local03
0e0c8                 | '     }
0e0c8                 | '     fh->close(fh);
0e0c8                 | '     return RES_OK;
0e0c8     00 76 06 F6 | 	mov	result1, #0
0e0cc                 | LR__2120
0e0cc     E7 F0 03 F6 | 	mov	ptra, fp
0e0d0     F2 00 A0 FD | 	call	#popregs_
0e0d4                 | _fatfs_cc_disk_deinitialize_ret
0e0d4     2D 00 64 FD | 	ret
0e0d8                 | 
0e0d8                 | ' 	
0e0d8                 | ' 	FUNCTION pfunc(c as integer) as integer
0e0d8                 | __system____strs_cl_pfunc_
0e0d8                 | ' 		if (i < 16) then
0e0d8     04 62 06 F1 | 	add	objptr, #4
0e0dc     31 77 02 FB | 	rdlong	result1, objptr
0e0e0     04 62 86 F1 | 	sub	objptr, #4
0e0e4     10 76 56 F2 | 	cmps	result1, #16 wc
0e0e8     2C 00 90 3D |  if_ae	jmp	#LR__2130
0e0ec     31 77 02 FB | 	rdlong	result1, objptr
0e0f0     04 62 06 F1 | 	add	objptr, #4
0e0f4     31 7D 02 FB | 	rdlong	_var01, objptr
0e0f8     3B 7D 02 F1 | 	add	_var01, result1
0e0fc     3E 91 42 FC | 	wrbyte	arg01, _var01
0e100     31 77 02 FB | 	rdlong	result1, objptr
0e104     01 76 06 F1 | 	add	result1, #1
0e108     31 77 62 FC | 	wrlong	result1, objptr
0e10c     04 62 86 F1 | 	sub	objptr, #4
0e110                 | ' 			p(i) = c
0e110                 | ' 			i = i+1
0e110                 | ' 			return 1
0e110     01 76 06 F6 | 	mov	result1, #1
0e114     04 00 90 FD | 	jmp	#__system____strs_cl_pfunc__ret
0e118                 | LR__2130
0e118                 | ' 			return -1
0e118     01 76 66 F6 | 	neg	result1, #1
0e11c                 | __system____strs_cl_pfunc__ret
0e11c     2D 00 64 FD | 	ret
0e120                 | 
0e120                 | __system___struct__s_vfs_file_t_putchar_
0e120     04 CA 05 F6 | 	mov	COUNT_, #4
0e124     E8 00 A0 FD | 	call	#pushregs_
0e128     1C 62 06 F1 | 	add	objptr, #28
0e12c     31 A7 0A FB | 	rdlong	local01, objptr wz
0e130     1C 62 86 F1 | 	sub	objptr, #28
0e134     00 76 06 A6 |  if_e	mov	result1, #0
0e138     48 00 90 AD |  if_e	jmp	#LR__2140
0e13c     1C 62 06 F1 | 	add	objptr, #28
0e140     31 A9 02 FB | 	rdlong	local02, objptr
0e144     54 AB 02 F6 | 	mov	local03, local02
0e148     1C 62 86 F1 | 	sub	objptr, #28
0e14c     13 AA 46 F7 | 	zerox	local03, #19
0e150     14 A8 46 F0 | 	shr	local02, #20
0e154     02 A8 66 F0 | 	shl	local02, #2
0e158     2D A9 02 F1 | 	add	local02, __methods__
0e15c     54 A9 02 FB | 	rdlong	local02, local02
0e160     31 93 02 F6 | 	mov	arg02, objptr
0e164     31 AD 02 F6 | 	mov	local04, objptr
0e168     55 63 02 F6 | 	mov	objptr, local03
0e16c     2D A8 62 FD | 	call	local02
0e170     56 63 02 F6 | 	mov	objptr, local04
0e174                 | '     return (i < 0) ? 0 : 1;
0e174     00 76 56 F2 | 	cmps	result1, #0 wc
0e178     00 A6 06 C6 |  if_b	mov	local01, #0
0e17c     01 A6 06 36 |  if_ae	mov	local01, #1
0e180     53 77 02 F6 | 	mov	result1, local01
0e184                 | LR__2140
0e184     E7 F0 03 F6 | 	mov	ptra, fp
0e188     F2 00 A0 FD | 	call	#popregs_
0e18c                 | __system___struct__s_vfs_file_t_putchar__ret
0e18c     2D 00 64 FD | 	ret
0e190                 | 
0e190                 | __system___struct__s_vfs_file_t_getchar_
0e190     03 CA 05 F6 | 	mov	COUNT_, #3
0e194     E8 00 A0 FD | 	call	#pushregs_
0e198     20 62 06 F1 | 	add	objptr, #32
0e19c     31 91 0A FB | 	rdlong	arg01, objptr wz
0e1a0     20 62 86 F1 | 	sub	objptr, #32
0e1a4     01 76 66 A6 |  if_e	neg	result1, #1
0e1a8     38 00 90 AD |  if_e	jmp	#LR__2150
0e1ac                 | '     return getcf(__this);
0e1ac     20 62 06 F1 | 	add	objptr, #32
0e1b0     31 A7 02 FB | 	rdlong	local01, objptr
0e1b4     53 A9 02 F6 | 	mov	local02, local01
0e1b8     20 62 86 F1 | 	sub	objptr, #32
0e1bc     13 A8 46 F7 | 	zerox	local02, #19
0e1c0     14 A6 46 F0 | 	shr	local01, #20
0e1c4     02 A6 66 F0 | 	shl	local01, #2
0e1c8     2D A7 02 F1 | 	add	local01, __methods__
0e1cc     53 A7 02 FB | 	rdlong	local01, local01
0e1d0     31 91 02 F6 | 	mov	arg01, objptr
0e1d4     31 AB 02 F6 | 	mov	local03, objptr
0e1d8     54 63 02 F6 | 	mov	objptr, local02
0e1dc     2D A6 62 FD | 	call	local01
0e1e0     55 63 02 F6 | 	mov	objptr, local03
0e1e4                 | LR__2150
0e1e4     E7 F0 03 F6 | 	mov	ptra, fp
0e1e8     F2 00 A0 FD | 	call	#popregs_
0e1ec                 | __system___struct__s_vfs_file_t_getchar__ret
0e1ec     2D 00 64 FD | 	ret
0e1f0                 | 
0e1f0                 | __system___struct___bas_wrap_sender_tx_
0e1f0     03 CA 05 F6 | 	mov	COUNT_, #3
0e1f4     E8 00 A0 FD | 	call	#pushregs_
0e1f8     31 A7 02 FB | 	rdlong	local01, objptr
0e1fc     53 A9 02 F6 | 	mov	local02, local01
0e200     13 A6 46 F7 | 	zerox	local01, #19
0e204     14 A8 46 F0 | 	shr	local02, #20
0e208     02 A8 66 F0 | 	shl	local02, #2
0e20c     2D A9 02 F1 | 	add	local02, __methods__
0e210     54 A9 02 FB | 	rdlong	local02, local02
0e214     31 AB 02 F6 | 	mov	local03, objptr
0e218     53 63 02 F6 | 	mov	objptr, local01
0e21c     2D A8 62 FD | 	call	local02
0e220     55 63 02 F6 | 	mov	objptr, local03
0e224     01 76 06 F6 | 	mov	result1, #1
0e228     E7 F0 03 F6 | 	mov	ptra, fp
0e22c     F2 00 A0 FD | 	call	#popregs_
0e230                 | __system___struct___bas_wrap_sender_tx__ret
0e230     2D 00 64 FD | 	ret
0e234                 | 
0e234                 | __system___struct___bas_wrap_sender_rx_
0e234     03 CA 05 F6 | 	mov	COUNT_, #3
0e238     E8 00 A0 FD | 	call	#pushregs_
0e23c     04 62 06 F1 | 	add	objptr, #4
0e240     31 A7 02 FB | 	rdlong	local01, objptr
0e244     53 A9 02 F6 | 	mov	local02, local01
0e248     04 62 86 F1 | 	sub	objptr, #4
0e24c     13 A8 46 F7 | 	zerox	local02, #19
0e250     14 A6 46 F0 | 	shr	local01, #20
0e254     02 A6 66 F0 | 	shl	local01, #2
0e258     2D A7 02 F1 | 	add	local01, __methods__
0e25c     53 A7 02 FB | 	rdlong	local01, local01
0e260     31 AB 02 F6 | 	mov	local03, objptr
0e264     54 63 02 F6 | 	mov	objptr, local02
0e268     2D A6 62 FD | 	call	local01
0e26c     55 63 02 F6 | 	mov	objptr, local03
0e270     E7 F0 03 F6 | 	mov	ptra, fp
0e274     F2 00 A0 FD | 	call	#popregs_
0e278                 | __system___struct___bas_wrap_sender_rx__ret
0e278     2D 00 64 FD | 	ret
0e27c                 | 
0e27c                 | __system___struct___bas_wrap_sender_close_
0e27c     03 CA 05 F6 | 	mov	COUNT_, #3
0e280     E8 00 A0 FD | 	call	#pushregs_
0e284     08 62 06 F1 | 	add	objptr, #8
0e288     31 A7 02 FB | 	rdlong	local01, objptr
0e28c     53 A9 02 F6 | 	mov	local02, local01
0e290     08 62 86 F1 | 	sub	objptr, #8
0e294     13 A8 46 F7 | 	zerox	local02, #19
0e298     14 A6 46 F0 | 	shr	local01, #20
0e29c     02 A6 66 F0 | 	shl	local01, #2
0e2a0     2D A7 02 F1 | 	add	local01, __methods__
0e2a4     53 A7 02 FB | 	rdlong	local01, local01
0e2a8     31 AB 02 F6 | 	mov	local03, objptr
0e2ac     54 63 02 F6 | 	mov	objptr, local02
0e2b0     2D A6 62 FD | 	call	local01
0e2b4     55 63 02 F6 | 	mov	objptr, local03
0e2b8     E7 F0 03 F6 | 	mov	ptra, fp
0e2bc     F2 00 A0 FD | 	call	#popregs_
0e2c0                 | __system___struct___bas_wrap_sender_close__ret
0e2c0     2D 00 64 FD | 	ret
0e2c4                 | 
0e2c4                 | LR__2160
0e2c4     2F          | 	byte	"/"
0e2c5     00          | 	byte	0
0e2c6                 | LR__2161
0e2c6     69 6E 66    | 	byte	"inf"
0e2c9     00          | 	byte	0
0e2ca                 | LR__2162
0e2ca     6E 61 6E    | 	byte	"nan"
0e2cd     00          | 	byte	0
0e2ce                 | LR__2163
0e2ce     20 21 21 21 
0e2d2     20 63 6F 72 
0e2d6     72 75 70 74 
0e2da     65 64 20 68 
0e2de     65 61 70 3F 
0e2e2     3F 3F 20 21 
0e2e6     21 21 20    | 	byte	" !!! corrupted heap??? !!! "
0e2e9     00          | 	byte	0
0e2ea                 | LR__2164
0e2ea     20 21 21 21 
0e2ee     20 6F 75 74 
0e2f2     20 6F 66 20 
0e2f6     68 65 61 70 
0e2fa     20 6D 65 6D 
0e2fe     6F 72 79 20 
0e302     21 21 21 20 | 	byte	" !!! out of heap memory !!! "
0e306     00          | 	byte	0
0e307                 | LR__2165
0e307     20 21 21 21 
0e30b     20 63 6F 72 
0e30f     72 75 70 74 
0e313     65 64 20 68 
0e317     65 61 70 20 
0e31b     21 21 21 20 | 	byte	" !!! corrupted heap !!! "
0e31f     00          | 	byte	0
0e320                 | LR__2166
0e320     00          | 	byte	0
0e321     00          | 	byte	0
0e322                 | LR__2167
0e322     54 5A       | 	byte	"TZ"
0e324     00          | 	byte	0
0e325                 | LR__2168
0e325     2A 3A 3C 3E 
0e329     7C 22 3F 7F | 	byte	"*:<>|",34,"?",127
0e32d     00          | 	byte	0
0e32e                 | LR__2169
0e32e     2B 2C 3B 3D 
0e332     5B 5D       | 	byte	"+,;=[]"
0e334     00          | 	byte	0
0e335                 | LR__2170
0e335     46 41 54 33 
0e339     32 20 20 20 | 	byte	"FAT32   "
0e33d     00          | 	byte	0
0e33e                 | LR__2171
0e33e     00          | 	byte	0
0e33f     00          | 	byte	0
0e340                 | LR__2172
0e340     2F 73 64    | 	byte	"/sd"
0e343     00          | 	byte	0
0e344                 | LR__2173
0e344     2F 73 64 2F 
0e348     62 61 73    | 	byte	"/sd/bas"
0e34b     00          | 	byte	0
0e34c                 | LR__2174
0e34c     2F 73 64 2F 
0e350     62 61 73    | 	byte	"/sd/bas"
0e353     00          | 	byte	0
0e354                 | LR__2175
0e354     6B 77 61 73 | 	byte	"kwas"
0e358     00          | 	byte	0
0e359                 | LR__2176
0e359                 | 	byte	
0e359     00          | 	byte	0
0e35a                 | LR__2177
0e35a     57 69 6E 64 
0e35e     6F 77 20 74 
0e362     65 73 74 20 
0e366     31 32 33 34 
0e36a     35 36 37 38 
0e36e     39 30       | 	byte	"Window test 1234567890"
0e370     00          | 	byte	0
0e371     00 00 00    | 	alignl
0e374                 | _dat_
0e374     00 00 00 00 
0e378     00 00 00 00 
0e37c     00 00 00 00 
0e380     00 00 00 00 | 	byte	$00[16]
0e384     61 41 17 0E 
0e388     62 42 00 00 
0e38c     63 43 19 10 
0e390     64 44 00 00 | 	byte	$61, $41, $17, $0e, $62, $42, $00, $00, $63, $43, $19, $10, $64, $44, $00, $00
0e394     65 45 18 0F 
0e398     66 46 00 00 
0e39c     67 47 00 00 
0e3a0     68 48 00 00 | 	byte	$65, $45, $18, $0f, $66, $46, $00, $00, $67, $47, $00, $00, $68, $48, $00, $00
0e3a4     69 49 00 00 
0e3a8     6A 4A 00 00 
0e3ac     6B 4B 00 00 
0e3b0     6C 4C 1F 16 | 	byte	$69, $49, $00, $00, $6a, $4a, $00, $00, $6b, $4b, $00, $00, $6c, $4c, $1f, $16
0e3b4     6D 4D 00 00 
0e3b8     6E 4E 1A 11 
0e3bc     6F 4F 1E 15 
0e3c0     70 50 00 00 | 	byte	$6d, $4d, $00, $00, $6e, $4e, $1a, $11, $6f, $4f, $1e, $15, $70, $50, $00, $00
0e3c4     71 51 00 00 
0e3c8     72 52 00 00 
0e3cc     73 53 1B 12 
0e3d0     74 54 00 00 | 	byte	$71, $51, $00, $00, $72, $52, $00, $00, $73, $53, $1b, $12, $74, $54, $00, $00
0e3d4     75 55 00 00 
0e3d8     76 56 00 00 
0e3dc     77 57 00 00 
0e3e0     78 58 1C 13 | 	byte	$75, $55, $00, $00, $76, $56, $00, $00, $77, $57, $00, $00, $78, $58, $1c, $13
0e3e4     79 59 00 00 
0e3e8     7A 5A 1D 14 
0e3ec     31 21 04 00 
0e3f0     32 40 05 00 | 	byte	$79, $59, $00, $00, $7a, $5a, $1d, $14, $31, $21, $04, $00, $32, $40, $05, $00
0e3f4     33 23 06 00 
0e3f8     34 24 07 00 
0e3fc     35 25 08 00 
0e400     36 5E 09 00 | 	byte	$33, $23, $06, $00, $34, $24, $07, $00, $35, $25, $08, $00, $36, $5e, $09, $00
0e404     37 26 0A 00 
0e408     38 2A 0B 00 
0e40c     39 28 0C 00 
0e410     30 29 0D 00 | 	byte	$37, $26, $0a, $00, $38, $2a, $0b, $00, $39, $28, $0c, $00, $30, $29, $0d, $00
0e414     8D 8D 00 00 
0e418     9B 9B 00 00 
0e41c     88 88 00 00 
0e420     89 89 00 00 | 	byte	$8d, $8d, $00, $00, $9b, $9b, $00, $00, $88, $88, $00, $00, $89, $89, $00, $00
0e424     20 20 00 00 
0e428     2D 5F 00 00 
0e42c     3D 2B 00 00 
0e430     5B 7B 00 00 | 	byte	$20, $20, $00, $00, $2d, $5f, $00, $00, $3d, $2b, $00, $00, $5b, $7b, $00, $00
0e434     5D 7D 00 00 
0e438     5C 7C 00 00 
0e43c     23 7E 00 00 
0e440     3B 3A 00 00 | 	byte	$5d, $7d, $00, $00, $5c, $7c, $00, $00, $23, $7e, $00, $00, $3b, $3a, $00, $00
0e444     27 22 00 00 
0e448     60 7E 03 00 
0e44c     2C 3C 00 00 
0e450     2E 3E 00 00 | 	byte	$27, $22, $00, $00, $60, $7e, $03, $00, $2c, $3c, $00, $00, $2e, $3e, $00, $00
0e454     2F 3F 00 00 
0e458     B9 B9 00 00 
0e45c     BA 00 00 00 
0e460     BB 00 00 00 | 	byte	$2f, $3f, $00, $00, $b9, $b9, $00, $00, $ba, $00, $00, $00, $bb, $00, $00, $00
0e464     BC 00 00 00 
0e468     BD 00 00 00 
0e46c     BE 00 00 00 
0e470     BF 00 00 00 | 	byte	$bc, $00, $00, $00, $bd, $00, $00, $00, $be, $00, $00, $00, $bf, $00, $00, $00
0e474     C0 00 00 00 
0e478     C1 00 00 00 
0e47c     C2 00 00 00 
0e480     C3 00 00 00 | 	byte	$c0, $00, $00, $00, $c1, $00, $00, $00, $c2, $00, $00, $00, $c3, $00, $00, $00
0e484     C4 00 00 00 
0e488     C5 00 00 00 
0e48c     C6 00 00 00 
0e490     C7 00 00 00 | 	byte	$c4, $00, $00, $00, $c5, $00, $00, $00, $c6, $00, $00, $00, $c7, $00, $00, $00
0e494     C8 00 00 00 
0e498     C9 00 00 00 
0e49c     CA 00 00 00 
0e4a0     CB 00 00 00 | 	byte	$c8, $00, $00, $00, $c9, $00, $00, $00, $ca, $00, $00, $00, $cb, $00, $00, $00
0e4a4     7F 7F 00 00 
0e4a8     CC 00 00 00 
0e4ac     CD 00 00 00 
0e4b0     CE 00 00 00 | 	byte	$7f, $7f, $00, $00, $cc, $00, $00, $00, $cd, $00, $00, $00, $ce, $00, $00, $00
0e4b4     CF 00 00 00 
0e4b8     D0 00 00 00 
0e4bc     D1 00 00 00 
0e4c0     D2 00 00 00 | 	byte	$cf, $00, $00, $00, $d0, $00, $00, $00, $d1, $00, $00, $00, $d2, $00, $00, $00
0e4c4     2F 2F 00 00 
0e4c8     2A 2A 00 00 
0e4cc     2D 2D 00 00 
0e4d0     2B 2B 00 00 | 	byte	$2f, $2f, $00, $00, $2a, $2a, $00, $00, $2d, $2d, $00, $00, $2b, $2b, $00, $00
0e4d4     8D 8D 00 00 
0e4d8     31 31 00 00 
0e4dc     32 32 00 00 
0e4e0     33 33 00 00 | 	byte	$8d, $8d, $00, $00, $31, $31, $00, $00, $32, $32, $00, $00, $33, $33, $00, $00
0e4e4     34 34 00 00 
0e4e8     35 35 00 00 
0e4ec     36 36 00 00 
0e4f0     37 37 00 00 | 	byte	$34, $34, $00, $00, $35, $35, $00, $00, $36, $36, $00, $00, $37, $37, $00, $00
0e4f4     38 38 00 00 
0e4f8     39 39 00 00 
0e4fc     30 30 00 00 
0e500     2E 7F 00 00 | 	byte	$38, $38, $00, $00, $39, $39, $00, $00, $30, $30, $00, $00, $2e, $7f, $00, $00
0e504     5C 7C 00 00 
0e508     00 00 00 00 
0e50c     00 00 00 00 
0e510     3D 3D 00 00 | 	byte	$5c, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3d, $3d, $00, $00
0e514     00 00 00 00 
      ...             
0e56c     00 00 00 00 
0e570     00 00 00 00 | 	byte	$00[96]
0e574     01 00 00 00 
0e578     00 00 00 00 
0e57c     00 00 00 00 
0e580     00 00 00 00 | mouse  file "mouse2.def"
0e584     00 00 00 00 
0e588     00 00 00 00 
0e58c     00 00 00 00 
0e590     00 00 00 00 | 	byte	$00[16]
0e594     01 01 00 00 
0e598     00 00 00 00 
0e59c     00 00 00 00 
0e5a0     00 00 00 00 | 	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e5a4     00 00 00 00 
0e5a8     00 00 00 00 
0e5ac     00 00 00 00 
0e5b0     00 00 00 00 | 	byte	$00[16]
0e5b4     01 0D 01 00 
0e5b8     00 00 00 00 
0e5bc     00 00 00 00 
0e5c0     00 00 00 00 | 	byte	$01, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e5c4     00 00 00 00 
0e5c8     00 00 00 00 
0e5cc     00 00 00 00 
0e5d0     00 00 00 00 | 	byte	$00[16]
0e5d4     01 0D 0D 01 
0e5d8     00 00 00 00 
0e5dc     00 00 00 00 
0e5e0     00 00 00 00 | 	byte	$01, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e5e4     00 00 00 00 
0e5e8     00 00 00 00 
0e5ec     00 00 00 00 
0e5f0     00 00 00 00 | 	byte	$00[16]
0e5f4     01 0D 0D 0D 
0e5f8     01 00 00 00 
0e5fc     00 00 00 00 
0e600     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e604     00 00 00 00 
0e608     00 00 00 00 
0e60c     00 00 00 00 
0e610     00 00 00 00 | 	byte	$00[16]
0e614     01 0D 0D 0D 
0e618     0D 01 00 00 
0e61c     00 00 00 00 
0e620     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e624     00 00 00 00 
0e628     00 00 00 00 
0e62c     00 00 00 00 
0e630     00 00 00 00 | 	byte	$00[16]
0e634     01 0D 0D 0D 
0e638     0D 0D 01 00 
0e63c     00 00 00 00 
0e640     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e644     00 00 00 00 
0e648     00 00 00 00 
0e64c     00 00 00 00 
0e650     00 00 00 00 | 	byte	$00[16]
0e654     01 0D 0D 0D 
0e658     0D 0D 0D 01 
0e65c     00 00 00 00 
0e660     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00
0e664     00 00 00 00 
0e668     00 00 00 00 
0e66c     00 00 00 00 
0e670     00 00 00 00 | 	byte	$00[16]
0e674     01 0D 0D 0D 
0e678     0D 0D 0D 0C 
0e67c     01 00 00 00 
0e680     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00, $00
0e684     00 00 00 00 
0e688     00 00 00 00 
0e68c     00 00 00 00 
0e690     00 00 00 00 | 	byte	$00[16]
0e694     01 0D 0D 0D 
0e698     0D 0D 0D 0D 
0e69c     0C 01 00 00 
0e6a0     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00, $00
0e6a4     00 00 00 00 
0e6a8     00 00 00 00 
0e6ac     00 00 00 00 
0e6b0     00 00 00 00 | 	byte	$00[16]
0e6b4     01 0D 0D 0D 
0e6b8     0D 0D 0D 0D 
0e6bc     0D 0C 01 00 
0e6c0     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0c, $01, $00, $00, $00, $00, $00
0e6c4     00 00 00 00 
0e6c8     00 00 00 00 
0e6cc     00 00 00 00 
0e6d0     00 00 00 00 | 	byte	$00[16]
0e6d4     01 0D 0D 0D 
0e6d8     0D 0D 0D 0D 
0e6dc     0D 0D 0B 01 
0e6e0     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0d, $0b, $01, $00, $00, $00, $00
0e6e4     00 00 00 00 
0e6e8     00 00 00 00 
0e6ec     00 00 00 00 
0e6f0     00 00 00 00 | 	byte	$00[16]
0e6f4     01 0D 0D 0D 
0e6f8     0C 0D 0D 03 
0e6fc     01 01 01 01 
0e700     00 00 00 00 | 	byte	$01, $0d, $0d, $0d, $0c, $0d, $0d, $03, $01, $01, $01, $01, $00, $00, $00, $00
0e704     00 00 00 00 
0e708     00 00 00 00 
0e70c     00 00 00 00 
0e710     00 00 00 00 | 	byte	$00[16]
0e714     01 0D 0D 0C 
0e718     01 09 0D 03 
0e71c     00 00 00 00 
0e720     00 00 00 00 | 	byte	$01, $0d, $0d, $0c, $01, $09, $0d, $03, $00, $00, $00, $00, $00, $00, $00, $00
0e724     00 00 00 00 
0e728     00 00 00 00 
0e72c     00 00 00 00 
0e730     00 00 00 00 | 	byte	$00[16]
0e734     01 0D 0C 01 
0e738     00 01 0D 0B 
0e73c     01 00 00 00 
0e740     00 00 00 00 | 	byte	$01, $0d, $0c, $01, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00, $00
0e744     00 00 00 00 
0e748     00 00 00 00 
0e74c     00 00 00 00 
0e750     00 00 00 00 | 	byte	$00[16]
0e754     01 0C 01 00 
0e758     00 01 0A 0D 
0e75c     01 00 00 00 
0e760     00 00 00 00 | 	byte	$01, $0c, $01, $00, $00, $01, $0a, $0d, $01, $00, $00, $00, $00, $00, $00, $00
0e764     00 00 00 00 
0e768     00 00 00 00 
0e76c     00 00 00 00 
0e770     00 00 00 00 | 	byte	$00[16]
0e774     01 01 00 00 
0e778     00 00 01 0D 
0e77c     0B 01 00 00 
0e780     00 00 00 00 | 	byte	$01, $01, $00, $00, $00, $00, $01, $0d, $0b, $01, $00, $00, $00, $00, $00, $00
0e784     00 00 00 00 
0e788     00 00 00 00 
0e78c     00 00 00 00 
0e790     00 00 00 00 
0e794     00 00 00 00 
0e798     00 00       | 	byte	$00[22]
0e79a     01 0B 0D 01 
0e79e     00 00 00 00 
0e7a2     00 00 00 00 
0e7a6     00 00 00 00 | 	byte	$01, $0b, $0d, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e7aa     00 00 00 00 
0e7ae     00 00 00 00 
0e7b2     00 00 00 00 
0e7b6     00 00 00 00 
0e7ba     00          | 	byte	$00[17]
0e7bb     01 01 00 00 
0e7bf     00 00 00 00 
0e7c3     00 00 00 00 
0e7c7     00 00 00 00 | 	byte	$01, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0e7cb     00 00 00 00 
      ...             
0e96f     00 00 00 00 
0e973     00          | 	byte	$00[425]
0e974                 | 	alignl
0e974                 | _hg010b_spin2_dat_
0e974                 | 
0e974     00 00 00 00 
0e978     00 00 00 00 
0e97c     00 00 00 00 
0e980     00 00 00 00 
0e984     00 00 00    | vga_font       file "vgafont.def"
0e987     7E 81 A5 81 
0e98b     81 BD 99 81 
0e98f     81 7E 00 00 
0e993     00 00 00 00 | 	byte	$7e, $81, $a5, $81, $81, $bd, $99, $81, $81, $7e, $00, $00, $00, $00, $00, $00
0e997     7E FF DB FF 
0e99b     FF C3 E7 FF 
0e99f     FF 7E 00 00 
0e9a3     00 00 00 00 | 	byte	$7e, $ff, $db, $ff, $ff, $c3, $e7, $ff, $ff, $7e, $00, $00, $00, $00, $00, $00
0e9a7     00 36 7F 7F 
0e9ab     7F 7F 3E 1C 
0e9af     08 00 00 00 
0e9b3     00 00 00 00 | 	byte	$00, $36, $7f, $7f, $7f, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00
0e9b7     00 08 1C 3E 
0e9bb     7F 3E 1C 08 
0e9bf     00 00 00 00 
0e9c3     00 00 00 00 | 	byte	$00, $08, $1c, $3e, $7f, $3e, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00
0e9c7     18 3C 3C E7 
0e9cb     E7 E7 18 18 
0e9cf     3C 00 00 00 
0e9d3     00 00 00 00 | 	byte	$18, $3c, $3c, $e7, $e7, $e7, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
0e9d7     18 3C 7E FF 
0e9db     FF 7E 18 18 
0e9df     3C 00 00 00 
0e9e3     00 00 00 00 | 	byte	$18, $3c, $7e, $ff, $ff, $7e, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
0e9e7     00 00 00 18 
0e9eb     3C 3C 18 00 
0e9ef     00 00 00 00 
0e9f3     00 FF FF FF | 	byte	$00, $00, $00, $18, $3c, $3c, $18, $00, $00, $00, $00, $00, $00, $ff, $ff, $ff
0e9f7     FF FF FF E7 
0e9fb     C3 C3 E7 FF 
0e9ff     FF FF FF FF 
0ea03     FF 00 00 00 | 	byte	$ff, $ff, $ff, $e7, $c3, $c3, $e7, $ff, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
0ea07     00 00 3C 66 
0ea0b     42 42 66 3C 
0ea0f     00 00 00 00 
0ea13     00 FF FF FF | 	byte	$00, $00, $3c, $66, $42, $42, $66, $3c, $00, $00, $00, $00, $00, $ff, $ff, $ff
0ea17     FF FF C3 99 
0ea1b     BD BD 99 C3 
0ea1f     FF FF FF FF 
0ea23     FF 00 00 00 | 	byte	$ff, $ff, $c3, $99, $bd, $bd, $99, $c3, $ff, $ff, $ff, $ff, $ff, $00, $00, $00
0ea27     78 70 58 4C 
0ea2b     1E 33 33 33 
0ea2f     33 1E 00 00 
0ea33     00 00 00 00 | 	byte	$78, $70, $58, $4c, $1e, $33, $33, $33, $33, $1e, $00, $00, $00, $00, $00, $00
0ea37     3C 66 66 66 
0ea3b     66 3C 18 7E 
0ea3f     18 18 00 00 
0ea43     00 00 00 00 | 	byte	$3c, $66, $66, $66, $66, $3c, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00
0ea47     FC CC FC 0C 
0ea4b     0C 0C 0C 0E 
0ea4f     0F 07 00 00 
0ea53     00 00 00 00 | 	byte	$fc, $cc, $fc, $0c, $0c, $0c, $0c, $0e, $0f, $07, $00, $00, $00, $00, $00, $00
0ea57     FE C6 FE C6 
0ea5b     C6 C6 C6 E6 
0ea5f     E7 67 03 00 
0ea63     00 00 00 00 | 	byte	$fe, $c6, $fe, $c6, $c6, $c6, $c6, $e6, $e7, $67, $03, $00, $00, $00, $00, $00
0ea67     18 18 DB 3C 
0ea6b     E7 3C DB 18 
0ea6f     18 00 00 00 
0ea73     00 00 00 01 | 	byte	$18, $18, $db, $3c, $e7, $3c, $db, $18, $18, $00, $00, $00, $00, $00, $00, $01
0ea77     03 07 0F 1F 
0ea7b     7F 1F 0F 07 
0ea7f     03 01 00 00 
0ea83     00 00 00 40 | 	byte	$03, $07, $0f, $1f, $7f, $1f, $0f, $07, $03, $01, $00, $00, $00, $00, $00, $40
0ea87     60 70 78 7C 
0ea8b     7F 7C 78 70 
0ea8f     60 40 00 00 
0ea93     00 00 00 00 | 	byte	$60, $70, $78, $7c, $7f, $7c, $78, $70, $60, $40, $00, $00, $00, $00, $00, $00
0ea97     18 3C 7E 18 
0ea9b     18 18 7E 3C 
0ea9f     18 00 00 00 
0eaa3     00 00 00 00 | 	byte	$18, $3c, $7e, $18, $18, $18, $7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00
0eaa7     66 66 66 66 
0eaab     66 66 66    | 	byte	$66[7]
0eaae     00 66 66 00 
0eab2     00 00 00 00 
0eab6     00 FE DB DB 
0eaba     DB DE D8 D8 | 	byte	$00, $66, $66, $00, $00, $00, $00, $00, $00, $fe, $db, $db, $db, $de, $d8, $d8
0eabe     D8 D8 D8 00 
0eac2     00 00 00 3E 
0eac6     63 06 1C 36 
0eaca     63 63 36 1C | 	byte	$d8, $d8, $d8, $00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c
0eace     30 63 3E 00 
0ead2     00 00 00 00 
0ead6     00 00 00 00 
0eada     00 00 00 7F | 	byte	$30, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
0eade     7F 7F 7F 00 
0eae2     00 00 00 00 
0eae6     00 18 3C 7E 
0eaea     18 18 18 7E | 	byte	$7f, $7f, $7f, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $7e
0eaee     3C 18 7E 00 
0eaf2     00 00 00 00 
0eaf6     00 18 3C 7E 
0eafa     18 18 18 18 | 	byte	$3c, $18, $7e, $00, $00, $00, $00, $00, $00, $18, $3c, $7e, $18, $18, $18, $18
0eafe     18 18 18 00 
0eb02     00 00 00 00 
0eb06     00 18 18 18 
0eb0a     18 18 18 18 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0eb0e     7E 3C 18 00 
0eb12     00 00 00 00 
0eb16     00 00 00 18 
0eb1a     30 7F 30 18 | 	byte	$7e, $3c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $18, $30, $7f, $30, $18
0eb1e     00 00 00 00 
0eb22     00 00 00 00 
0eb26     00 00 00    | 	byte	$00[11]
0eb29     0C 06 7F 06 
0eb2d     0C 00 00 00 
0eb31     00 00 00 00 
0eb35     00 00 00 00 | 	byte	$0c, $06, $7f, $06, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0eb39     00 03 03 03 
0eb3d     7F 00 00 00 
0eb41     00 00 00 00 
0eb45     00 00 00 00 | 	byte	$00, $03, $03, $03, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0eb49     14 36 7F 36 
0eb4d     14 00 00 00 
0eb51     00 00 00 00 
0eb55     00 00 00 08 | 	byte	$14, $36, $7f, $36, $14, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08
0eb59     1C 1C 3E 3E 
0eb5d     7F 7F 00 00 
0eb61     00 00 00 00 
0eb65     00 00 00 7F | 	byte	$1c, $1c, $3e, $3e, $7f, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f
0eb69     7F 3E 3E 1C 
0eb6d     1C 08 00 00 
0eb71     00 00 00 00 
0eb75     00 00 00 00 | 	byte	$7f, $3e, $3e, $1c, $1c, $08, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0eb79     00 00 00 00 
0eb7d     00 00 00 00 
0eb81     00 00 00 00 
0eb85     00 00       | 	byte	$00[14]
0eb87     18 3C 3C 3C 
0eb8b     18 18 18 00 
0eb8f     18 18 00 00 
0eb93     00 00 66 66 | 	byte	$18, $3c, $3c, $3c, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $66, $66
0eb97     66 24 00 00 
0eb9b     00 00 00 00 
0eb9f     00 00 00 00 
0eba3     00 00 00 00 | 	byte	$66, $24, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0eba7     00 36 36 7F 
0ebab     36 36 36 7F 
0ebaf     36 36 00 00 
0ebb3     00 00 18 18 | 	byte	$00, $36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $18, $18
0ebb7     3E 63 43 03 
0ebbb     3E 60 60 61 
0ebbf     63 3E 18 18 
0ebc3     00 00 00 00 | 	byte	$3e, $63, $43, $03, $3e, $60, $60, $61, $63, $3e, $18, $18, $00, $00, $00, $00
0ebc7     00 00 43 63 
0ebcb     30 18 0C 06 
0ebcf     63 61 00 00 
0ebd3     00 00 00 00 | 	byte	$00, $00, $43, $63, $30, $18, $0c, $06, $63, $61, $00, $00, $00, $00, $00, $00
0ebd7     1C 36 36 1C 
0ebdb     6E 3B 33 33 
0ebdf     33 6E 00 00 
0ebe3     00 00 00 00 | 	byte	$1c, $36, $36, $1c, $6e, $3b, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00
0ebe7     0C 0C 0C 06 
0ebeb     00 00 00 00 
0ebef     00 00 00 00 
0ebf3     00 00 00 00 | 	byte	$0c, $0c, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0ebf7     30 18 0C 0C 
0ebfb     0C 0C 0C 0C 
0ebff     18 30 00 00 
0ec03     00 00 00 00 | 	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00
0ec07     0C 18 30 30 
0ec0b     30 30 30 30 
0ec0f     18 0C 00 00 
0ec13     00 00 00 00 | 	byte	$0c, $18, $30, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00
0ec17     00 00 00 66 
0ec1b     3C FF 3C 66 
0ec1f     00 00 00 00 
0ec23     00 00 00 00 | 	byte	$00, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00
0ec27     00 00 00 18 
0ec2b     18 7E 18 18 
0ec2f     00 00 00 00 
0ec33     00 00 00 00 | 	byte	$00, $00, $00, $18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
0ec37     00 00 00 00 
0ec3b     00 00 00 00 | 	byte	$00[8]
0ec3f     18 18 18 0C 
0ec43     00 00 00 00 
0ec47     00 00 00 00 
0ec4b     00 7F 00 00 | 	byte	$18, $18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7f, $00, $00
0ec4f     00 00 00 00 
0ec53     00 00 00 00 
0ec57     00 00 00 00 
0ec5b     00 00 00 00 | 	byte	$00[16]
0ec5f     18 18 00 00 
0ec63     00 00 00 00 
0ec67     00 00 40 60 
0ec6b     30 18 0C 06 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $40, $60, $30, $18, $0c, $06
0ec6f     03 01 00 00 
0ec73     00 00 00 00 
0ec77     1C 36 63 63 
0ec7b     6B 6B 63 63 | 	byte	$03, $01, $00, $00, $00, $00, $00, $00, $1c, $36, $63, $63, $6b, $6b, $63, $63
0ec7f     36 1C 00 00 
0ec83     00 00 00 00 
0ec87     18 1C 1E 18 
0ec8b     18 18 18 18 | 	byte	$36, $1c, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18, $18
0ec8f     18 7E 00 00 
0ec93     00 00 00 00 
0ec97     3E 63 60 30 
0ec9b     18 0C 06 03 | 	byte	$18, $7e, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $30, $18, $0c, $06, $03
0ec9f     63 7F 00 00 
0eca3     00 00 00 00 
0eca7     3E 63 60 60 
0ecab     3C 60 60 60 | 	byte	$63, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $60, $60, $3c, $60, $60, $60
0ecaf     63 3E 00 00 
0ecb3     00 00 00 00 
0ecb7     30 38 3C 36 
0ecbb     33 7F 30 30 | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30, $30
0ecbf     30 78 00 00 
0ecc3     00 00 00 00 
0ecc7     7F 03 03 03 
0eccb     3F 60 60 60 | 	byte	$30, $78, $00, $00, $00, $00, $00, $00, $7f, $03, $03, $03, $3f, $60, $60, $60
0eccf     63 3E 00 00 
0ecd3     00 00 00 00 
0ecd7     1C 06 03 03 
0ecdb     3F 63 63 63 | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $1c, $06, $03, $03, $3f, $63, $63, $63
0ecdf     63 3E 00 00 
0ece3     00 00 00 00 
0ece7     7F 63 60 60 
0eceb     30 18 0C 0C | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $7f, $63, $60, $60, $30, $18, $0c, $0c
0ecef     0C 0C 00 00 
0ecf3     00 00 00 00 
0ecf7     3E 63 63 63 
0ecfb     3E 63 63 63 | 	byte	$0c, $0c, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $3e, $63, $63, $63
0ecff     63 3E 00 00 
0ed03     00 00 00 00 
0ed07     3E 63 63 63 
0ed0b     7E 60 60 60 | 	byte	$63, $3e, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $7e, $60, $60, $60
0ed0f     30 1E 00 00 
0ed13     00 00 00 00 
0ed17     00 00 00 18 
0ed1b     18 00 00 00 | 	byte	$30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
0ed1f     18 18 00 00 
0ed23     00 00 00 00 
0ed27     00 00 00 18 
0ed2b     18 00 00 00 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
0ed2f     18 18 0C 00 
0ed33     00 00 00 00 
0ed37     00 60 30 18 
0ed3b     0C 06 0C 18 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $60, $30, $18, $0c, $06, $0c, $18
0ed3f     30 60 00 00 
0ed43     00 00 00 00 
0ed47     00 00 00 7E 
0ed4b     00 00 7E 00 | 	byte	$30, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00, $7e, $00
0ed4f     00 00 00 00 
0ed53     00 00 00 00 
0ed57     00          | 	byte	$00[9]
0ed58     06 0C 18 30 
0ed5c     60 30 18 0C 
0ed60     06 00 00 00 
0ed64     00 00 00 3E | 	byte	$06, $0c, $18, $30, $60, $30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $3e
0ed68     63 63 30 18 
0ed6c     18 18 00 18 
0ed70     18 00 00 00 
0ed74     00 00 00 00 | 	byte	$63, $63, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00
0ed78     3E 63 63 7B 
0ed7c     7B 7B 3B 03 
0ed80     3E 00 00 00 
0ed84     00 00 00 08 | 	byte	$3e, $63, $63, $7b, $7b, $7b, $3b, $03, $3e, $00, $00, $00, $00, $00, $00, $08
0ed88     1C 36 63 63 
0ed8c     7F 63 63 63 
0ed90     63 00 00 00 
0ed94     00 00 00 3F | 	byte	$1c, $36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3f
0ed98     66 66 66 3E 
0ed9c     66 66 66 66 
0eda0     3F 00 00 00 
0eda4     00 00 00 3C | 	byte	$66, $66, $66, $3e, $66, $66, $66, $66, $3f, $00, $00, $00, $00, $00, $00, $3c
0eda8     66 43 03 03 
0edac     03 03 43 66 
0edb0     3C 00 00 00 
0edb4     00 00 00 1F | 	byte	$66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00, $00, $1f
0edb8     36 66 66 66 
0edbc     66 66 66 36 
0edc0     1F 00 00 00 
0edc4     00 00 00 7F | 	byte	$36, $66, $66, $66, $66, $66, $66, $36, $1f, $00, $00, $00, $00, $00, $00, $7f
0edc8     66 46 16 1E 
0edcc     16 06 46 66 
0edd0     7F 00 00 00 
0edd4     00 00 00 7F | 	byte	$66, $46, $16, $1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $7f
0edd8     66 46 16 1E 
0eddc     16 06 06 06 
0ede0     0F 00 00 00 
0ede4     00 00 00 3C | 	byte	$66, $46, $16, $1e, $16, $06, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $3c
0ede8     66 43 03 03 
0edec     7B 63 63 66 
0edf0     5C 00 00 00 
0edf4     00 00 00 63 | 	byte	$66, $43, $03, $03, $7b, $63, $63, $66, $5c, $00, $00, $00, $00, $00, $00, $63
0edf8     63 63 63 7F 
0edfc     63 63 63 63 
0ee00     63 00 00 00 
0ee04     00 00 00 3C | 	byte	$63, $63, $63, $7f, $63, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $3c
0ee08     18 18 18 18 
0ee0c     18 18 18 18 | 	byte	$18[8]
0ee10     3C 00 00 00 
0ee14     00 00 00 78 
0ee18     30 30 30 30 
0ee1c     30 33 33 33 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $78, $30, $30, $30, $30, $30, $33, $33, $33
0ee20     1E 00 00 00 
0ee24     00 00 00 67 
0ee28     66 66 36 1E 
0ee2c     1E 36 66 66 | 	byte	$1e, $00, $00, $00, $00, $00, $00, $67, $66, $66, $36, $1e, $1e, $36, $66, $66
0ee30     67 00 00 00 
0ee34     00 00 00 0F 
0ee38     06 06 06 06 
0ee3c     06 06 46 66 | 	byte	$67, $00, $00, $00, $00, $00, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
0ee40     7F 00 00 00 
0ee44     00 00 00 63 
0ee48     77 7F 7F 6B 
0ee4c     63 63 63 63 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $7f, $6b, $63, $63, $63, $63
0ee50     63 00 00 00 
0ee54     00 00 00 63 
0ee58     67 6F 7F 7B 
0ee5c     73 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63
0ee60     63 00 00 00 
0ee64     00 00 00 3E 
0ee68     63 63 63 63 
0ee6c     63 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
0ee70     3E 00 00 00 
0ee74     00 00 00 3F 
0ee78     66 66 66 3E 
0ee7c     06 06 06 06 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $06, $06, $06, $06
0ee80     0F 00 00 00 
0ee84     00 00 00 3E 
0ee88     63 63 63 63 
0ee8c     63 63 6B 7B | 	byte	$0f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $6b, $7b
0ee90     3E 30 70 00 
0ee94     00 00 00 3F 
0ee98     66 66 66 3E 
0ee9c     36 66 66 66 | 	byte	$3e, $30, $70, $00, $00, $00, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66
0eea0     67 00 00 00 
0eea4     00 00 00 3E 
0eea8     63 63 06 1C 
0eeac     30 60 63 63 | 	byte	$67, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
0eeb0     3E 00 00 00 
0eeb4     00 00 00 7E 
0eeb8     7E 5A 18 18 
0eebc     18 18 18 18 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
0eec0     3C 00 00 00 
0eec4     00 00 00 63 
0eec8     63 63 63 63 
0eecc     63 63 63 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
0eed0     3E 00 00 00 
0eed4     00 00 00 63 
0eed8     63 63 63 63 
0eedc     63 63 36 1C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $36, $1c
0eee0     08 00 00 00 
0eee4     00 00 00 63 
0eee8     63 63 63 6B 
0eeec     6B 6B 7F 77 | 	byte	$08, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $6b, $6b, $6b, $7f, $77
0eef0     36 00 00 00 
0eef4     00 00 00 63 
0eef8     63 36 3E 1C 
0eefc     1C 3E 36 63 | 	byte	$36, $00, $00, $00, $00, $00, $00, $63, $63, $36, $3e, $1c, $1c, $3e, $36, $63
0ef00     63 00 00 00 
0ef04     00 00 00 66 
0ef08     66 66 66 3C 
0ef0c     18 18 18 18 | 	byte	$63, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18
0ef10     3C 00 00 00 
0ef14     00 00 00 7F 
0ef18     63 61 30 18 
0ef1c     0C 06 43 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
0ef20     7F 00 00 00 
0ef24     00 00 00 3C 
0ef28     0C 0C 0C 0C 
0ef2c     0C 0C 0C 0C | 	byte	$7f, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
0ef30     3C 00 00 00 
0ef34     00 00 00 00 
0ef38     01 03 07 0E 
0ef3c     1C 38 70 60 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $01, $03, $07, $0e, $1c, $38, $70, $60
0ef40     40 00 00 00 
0ef44     00 00 00 3C 
0ef48     30 30 30 30 
0ef4c     30 30 30 30 | 	byte	$40, $00, $00, $00, $00, $00, $00, $3c, $30, $30, $30, $30, $30, $30, $30, $30
0ef50     3C 00 00 00 
0ef54     1C 36 00 00 
0ef58     00 00 00 00 
0ef5c     00 00 00 00 | 	byte	$3c, $00, $00, $00, $1c, $36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0ef60     00 00 00 00 
0ef64     00 00 00 00 
0ef68     00 00 00 00 
0ef6c     00 00 00 00 
0ef70     00          | 	byte	$00[17]
0ef71     FF 00 00 0C 
0ef75     18 00 00 00 
0ef79     00 00 00 00 
0ef7d     00 00 00 00 | 	byte	$ff, $00, $00, $0c, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0ef81     00 00 00 00 
0ef85     00 00 00 00 
0ef89     00          | 	byte	$00[9]
0ef8a     1E 30 3E 33 
0ef8e     33 33 6E 00 
0ef92     00 00 00 00 
0ef96     00 07 06 06 | 	byte	$1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $07, $06, $06
0ef9a     1E 36 66 66 
0ef9e     66 66 3E 00 
0efa2     00 00 00 00 
0efa6     00 00 00 00 | 	byte	$1e, $36, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
0efaa     3E 63 03 03 
0efae     03 63 3E 00 
0efb2     00 00 00 00 
0efb6     00 38 30 30 | 	byte	$3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $30, $30
0efba     3C 36 33 33 
0efbe     33 33 6E 00 
0efc2     00 00 00 00 
0efc6     00 00 00 00 | 	byte	$3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $00, $00, $00
0efca     3E 63 7F 03 
0efce     03 63 3E 00 
0efd2     00 00 00 00 
0efd6     00 38 6C 4C | 	byte	$3e, $63, $7f, $03, $03, $63, $3e, $00, $00, $00, $00, $00, $00, $38, $6c, $4c
0efda     0C 1E 0C 0C 
0efde     0C 0C 1E 00 
0efe2     00 00 00 00 
0efe6     00 00 00 00 | 	byte	$0c, $1e, $0c, $0c, $0c, $0c, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
0efea     6E 33 33 33 
0efee     33 33 3E 30 
0eff2     33 1E 00 00 
0eff6     00 07 06 06 | 	byte	$6e, $33, $33, $33, $33, $33, $3e, $30, $33, $1e, $00, $00, $00, $07, $06, $06
0effa     36 6E 66 66 
0effe     66 66 67 00 
0f002     00 00 00 00 
0f006     00 18 18 00 | 	byte	$36, $6e, $66, $66, $66, $66, $67, $00, $00, $00, $00, $00, $00, $18, $18, $00
0f00a     1C 18 18 18 
0f00e     18 18 3C 00 
0f012     00 00 00 00 
0f016     00 60 60 00 | 	byte	$1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $60, $60, $00
0f01a     70 60 60 60 
0f01e     60 60 60 66 
0f022     66 3C 00 00 
0f026     00 07 06 06 | 	byte	$70, $60, $60, $60, $60, $60, $60, $66, $66, $3c, $00, $00, $00, $07, $06, $06
0f02a     66 36 1E 1E 
0f02e     36 66 67 00 
0f032     00 00 00 00 
0f036     00 1C 18 18 | 	byte	$66, $36, $1e, $1e, $36, $66, $67, $00, $00, $00, $00, $00, $00, $1c, $18, $18
0f03a     18 18 18 18 
0f03e     18 18       | 	byte	$18[6]
0f040     3C 00 00 00 
0f044     00 00 00 00 
0f048     00 00 37 7F 
0f04c     6B 6B 6B 6B | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $6b, $6b, $6b
0f050     63 00 00 00 
0f054     00 00 00 00 
0f058     00 00 3B 66 
0f05c     66 66 66 66 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
0f060     66 00 00 00 
0f064     00 00 00 00 
0f068     00 00 3E 63 
0f06c     63 63 63 63 | 	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63
0f070     3E 00 00 00 
0f074     00 00 00 00 
0f078     00 00 3B 66 
0f07c     66 66 66 66 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3b, $66, $66, $66, $66, $66
0f080     3E 06 06 0F 
0f084     00 00 00 00 
0f088     00 00 6E 33 
0f08c     33 33 33 33 | 	byte	$3e, $06, $06, $0f, $00, $00, $00, $00, $00, $00, $6e, $33, $33, $33, $33, $33
0f090     3E 30 30 78 
0f094     00 00 00 00 
0f098     00 00 3B 6E 
0f09c     66 06 06 06 | 	byte	$3e, $30, $30, $78, $00, $00, $00, $00, $00, $00, $3b, $6e, $66, $06, $06, $06
0f0a0     0F 00 00 00 
0f0a4     00 00 00 00 
0f0a8     00 00 3E 63 
0f0ac     06 1C 30 63 | 	byte	$0f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63
0f0b0     3E 00 00 00 
0f0b4     00 00 00 08 
0f0b8     0C 0C 3F 0C 
0f0bc     0C 0C 0C 6C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
0f0c0     38 00 00 00 
0f0c4     00 00 00 00 
0f0c8     00 00 33 33 
0f0cc     33 33 33 33 | 	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $33, $33, $33, $33, $33, $33
0f0d0     6E 00 00 00 
0f0d4     00 00 00 00 
0f0d8     00 00 63 63 
0f0dc     63 63 63 36 | 	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36
0f0e0     1C 00 00 00 
0f0e4     00 00 00 00 
0f0e8     00 00 63 63 
0f0ec     6B 6B 6B 7F | 	byte	$1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $6b, $6b, $6b, $7f
0f0f0     36 00 00 00 
0f0f4     00 00 00 00 
0f0f8     00 00 63 36 
0f0fc     1C 1C 1C 36 | 	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $1c, $36
0f100     63 00 00 00 
0f104     00 00 00 00 
0f108     00 00 63 63 
0f10c     63 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63
0f110     7E 60 30 1F 
0f114     00 00 00 00 
0f118     00 00 7F 33 
0f11c     18 0C 06 63 | 	byte	$7e, $60, $30, $1f, $00, $00, $00, $00, $00, $00, $7f, $33, $18, $0c, $06, $63
0f120     7F 00 00 00 
0f124     00 00 00 70 
0f128     18 18 18 0E 
0f12c     18 18 18 18 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18, $18
0f130     70 00 00 00 
0f134     00 00 00 18 
0f138     18 18 18 18 
0f13c     18 18 18 18 | 	byte	$70, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f140     18 00 00 00 
0f144     00 00 00 0E 
0f148     18 18 18 70 
0f14c     18 18 18 18 | 	byte	$18, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18, $18
0f150     0E 00 00 00 
0f154     6E 3B 00 00 
0f158     00 00 00 00 
0f15c     00 00 00 00 | 	byte	$0e, $00, $00, $00, $6e, $3b, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f160     00 00 00 00 
0f164     00 00 00 00 
0f168     00 00       | 	byte	$00[10]
0f16a     08 1C 36 63 
0f16e     63 63 7F 00 
0f172     00 00 00 00 
0f176     00 3C 66 43 | 	byte	$08, $1c, $36, $63, $63, $63, $7f, $00, $00, $00, $00, $00, $00, $3c, $66, $43
0f17a     03 03 03 03 
0f17e     43 66 3C 18 
0f182     30 1E 00 00 
0f186     00 00 33 00 | 	byte	$03, $03, $03, $03, $43, $66, $3c, $18, $30, $1e, $00, $00, $00, $00, $33, $00
0f18a     33 33 33 33 
0f18e     33 33       | 	byte	$33[6]
0f190     6E 00 00 00 
0f194     00 00 60 30 
0f198     18 00 3E 63 
0f19c     7F 03 03 63 | 	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $7f, $03, $03, $63
0f1a0     3E 00 00 00 
0f1a4     00 00 08 1C 
0f1a8     36 00 1E 30 
0f1ac     3E 33 33 33 | 	byte	$3e, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $1e, $30, $3e, $33, $33, $33
0f1b0     6E 00 00 00 
0f1b4     00 00 00 00 
0f1b8     33 00 1E 30 
0f1bc     3E 33 33 33 | 	byte	$6e, $00, $00, $00, $00, $00, $00, $00, $33, $00, $1e, $30, $3e, $33, $33, $33
0f1c0     6E 00 00 00 
0f1c4     00 00 1C 36 
0f1c8     1C 00 33 33 
0f1cc     33 33 33 33 | 	byte	$6e, $00, $00, $00, $00, $00, $1c, $36, $1c, $00, $33, $33, $33, $33, $33, $33
0f1d0     6E 00 00 00 
0f1d4     00 00 60 30 
0f1d8     18 00 3E 63 
0f1dc     03 03 03 63 | 	byte	$6e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $03, $03, $03, $63
0f1e0     3E 00 00 00 
0f1e4     00 00 00 00 
0f1e8     00 00 3E 63 
0f1ec     03 03 03 63 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $03, $03, $03, $63
0f1f0     3E 18 30 1E 
0f1f4     00 00 00 1C 
0f1f8     58 78 38 18 
0f1fc     1C 1E 1A 18 | 	byte	$3e, $18, $30, $1e, $00, $00, $00, $1c, $58, $78, $38, $18, $1c, $1e, $1a, $18
0f200     3C 00 00 00 
0f204     00 00 00 00 
0f208     63 00 3E 63 
0f20c     7F 03 03 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $7f, $03, $03, $63
0f210     3E 00 00 00 
0f214     66 33 00 3E 
0f218     63 63 63 63 
0f21c     63 63 63 63 | 	byte	$3e, $00, $00, $00, $66, $33, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
0f220     3E 00 00 00 
0f224     00 00 CC 66 
0f228     33 00 3E 63 
0f22c     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $00, $cc, $66, $33, $00, $3e, $63, $63, $63, $63, $63
0f230     3E 00 00 00 
0f234     00 00 18 3C 
0f238     66 00 1C 18 
0f23c     18 18 18 18 | 	byte	$3e, $00, $00, $00, $00, $00, $18, $3c, $66, $00, $1c, $18, $18, $18, $18, $18
0f240     3C 00 00 00 
0f244     30 18 00 7F 
0f248     63 61 30 18 
0f24c     0C 06 43 63 | 	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63
0f250     7F 00 00 00 
0f254     00 63 00 08 
0f258     1C 36 63 63 
0f25c     7F 63 63 63 | 	byte	$7f, $00, $00, $00, $00, $63, $00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63
0f260     63 00 00 00 
0f264     30 18 00 3C 
0f268     66 43 03 03 
0f26c     03 03 43 66 | 	byte	$63, $00, $00, $00, $30, $18, $00, $3c, $66, $43, $03, $03, $03, $03, $43, $66
0f270     3C 00 00 00 
0f274     30 18 00 7F 
0f278     66 46 16 1E 
0f27c     16 06 46 66 | 	byte	$3c, $00, $00, $00, $30, $18, $00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66
0f280     7F 00 00 00 
0f284     0C 06 00 0F 
0f288     06 06 06 06 
0f28c     06 06 46 66 | 	byte	$7f, $00, $00, $00, $0c, $06, $00, $0f, $06, $06, $06, $06, $06, $06, $46, $66
0f290     7F 00 00 00 
0f294     30 18 00 1C 
0f298     18 18 18 18 
0f29c     18 18 18 18 | 	byte	$7f, $00, $00, $00, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $18, $18, $18
0f2a0     3C 00 00 00 
0f2a4     00 00 08 1C 
0f2a8     36 00 3E 63 
0f2ac     63 63 63 63 | 	byte	$3c, $00, $00, $00, $00, $00, $08, $1c, $36, $00, $3e, $63, $63, $63, $63, $63
0f2b0     3E 00 00 00 
0f2b4     00 00 00 00 
0f2b8     63 00 3E 63 
0f2bc     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63
0f2c0     3E 00 00 00 
0f2c4     00 00 00 6F 
0f2c8     46 26 06 06 
0f2cc     06 06 46 66 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $6f, $46, $26, $06, $06, $06, $06, $46, $66
0f2d0     7F 00 00 00 
0f2d4     00 00 00 6E 
0f2d8     4C 2C 0C 0C 
0f2dc     0C 0C 0C 0C | 	byte	$7f, $00, $00, $00, $00, $00, $00, $6e, $4c, $2c, $0c, $0c, $0c, $0c, $0c, $0c
0f2e0     1E 00 00 00 
0f2e4     30 18 00 3E 
0f2e8     63 63 06 1C 
0f2ec     30 60 63 63 | 	byte	$1e, $00, $00, $00, $30, $18, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63
0f2f0     3E 00 00 00 
0f2f4     00 00 60 30 
0f2f8     18 00 3E 63 
0f2fc     06 1C 30 63 | 	byte	$3e, $00, $00, $00, $00, $00, $60, $30, $18, $00, $3e, $63, $06, $1c, $30, $63
0f300     3E 00 00 00 
0f304     00 63 00 3E 
0f308     63 63 63 63 
0f30c     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $63, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63
0f310     3E 00 00 00 
0f314     00 63 00 63 
0f318     63 63 63 63 
0f31c     63 63 63 63 | 	byte	$3e, $00, $00, $00, $00, $63, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63
0f320     3E 00 00 00 
0f324     6C 38 00 7E 
0f328     7E 5A 18 18 
0f32c     18 18 18 18 | 	byte	$3e, $00, $00, $00, $6c, $38, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18
0f330     3C 00 00 00 
0f334     00 00 60 48 
0f338     2C 0C 3F 0C 
0f33c     0C 0C 0C 6C | 	byte	$3c, $00, $00, $00, $00, $00, $60, $48, $2c, $0c, $3f, $0c, $0c, $0c, $0c, $6c
0f340     38 00 00 00 
0f344     00 00 00 0F 
0f348     26 36 1E 0E 
0f34c     07 07 46 66 | 	byte	$38, $00, $00, $00, $00, $00, $00, $0f, $26, $36, $1e, $0e, $07, $07, $46, $66
0f350     7F 00 00 00 
0f354     00 00 00 00 
0f358     00 63 36 1C 
0f35c     1C 36 63 00 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36, $63, $00
0f360     00 00 00 00 
0f364     00 00       | 	byte	$00[6]
0f366     36 1C 08 00 
0f36a     3E 63 03 03 
0f36e     03 63 3E 00 
0f372     00 00 00 00 | 	byte	$36, $1c, $08, $00, $3e, $63, $03, $03, $03, $63, $3e, $00, $00, $00, $00, $00
0f376     30 18 0C 00 
0f37a     1E 30 3E 33 
0f37e     33 33 6E 00 
0f382     00 00 00 00 | 	byte	$30, $18, $0c, $00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $00, $00
0f386     60 30 18 00 
0f38a     1C 18 18 18 
0f38e     18 18 3C 00 
0f392     00 00 00 00 | 	byte	$60, $30, $18, $00, $1c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00
0f396     60 30 18 00 
0f39a     3E 63 63 63 
0f39e     63 63 3E 00 
0f3a2     00 00 00 00 | 	byte	$60, $30, $18, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00
0f3a6     30 18 0C 00 
0f3aa     33 33 33 33 
0f3ae     33 33 6E 00 
0f3b2     00 00 00 00 | 	byte	$30, $18, $0c, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00
0f3b6     00 08 1C 36 
0f3ba     63 63 7F 63 
0f3be     63 63 63 18 
0f3c2     0C 78 00 00 | 	byte	$00, $08, $1c, $36, $63, $63, $7f, $63, $63, $63, $63, $18, $0c, $78, $00, $00
0f3c6     00 00 00 00 
0f3ca     1E 30 3E 33 
0f3ce     33 33 6E 18 
0f3d2     0C 78 36 1C | 	byte	$00, $00, $00, $00, $1e, $30, $3e, $33, $33, $33, $6e, $18, $0c, $78, $36, $1c
0f3d6     00 7F 63 61 
0f3da     30 18 0C 06 
0f3de     43 63 7F 00 
0f3e2     00 00 00 00 | 	byte	$00, $7f, $63, $61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00
0f3e6     36 1C 08 00 
0f3ea     7F 33 18 0C 
0f3ee     06 63 7F 00 
0f3f2     00 00 00 00 | 	byte	$36, $1c, $08, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00
0f3f6     00 7F 66 46 
0f3fa     16 1E 16 06 
0f3fe     46 66 7F 18 
0f402     0C 78 00 00 | 	byte	$00, $7f, $66, $46, $16, $1e, $16, $06, $46, $66, $7f, $18, $0c, $78, $00, $00
0f406     00 00 00 00 
0f40a     3E 63 7F 03 
0f40e     03 63 3E 18 
0f412     0C 78 00 00 | 	byte	$00, $00, $00, $00, $3e, $63, $7f, $03, $03, $63, $3e, $18, $0c, $78, $00, $00
0f416     00 3C 66 03 
0f41a     1F 03 0F 03 
0f41e     03 66 3C 00 
0f422     00 00 00 00 | 	byte	$00, $3c, $66, $03, $1f, $03, $0f, $03, $03, $66, $3c, $00, $00, $00, $00, $00
0f426     60 30 18 00 
0f42a     7F 33 18 0C 
0f42e     06 63 7F 00 
0f432     00 00 6C 38 | 	byte	$60, $30, $18, $00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $6c, $38
0f436     00 3C 66 43 
0f43a     03 03 03 03 
0f43e     43 66 3C 00 
0f442     00 00 00 00 | 	byte	$00, $3c, $66, $43, $03, $03, $03, $03, $43, $66, $3c, $00, $00, $00, $00, $00
0f446     00 00 00 00 
0f44a     3E 63 06 1C 
0f44e     30 63 3E 18 
0f452     30 1E 00 00 | 	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $30, $63, $3e, $18, $30, $1e, $00, $00
0f456     00 00 00 00 
0f45a     00 00       | 	byte	$00[6]
0f45c     6C 36 1B 36 
0f460     6C 00 00 00 
0f464     00 00 00 00 
0f468     00 00 00 00 | 	byte	$6c, $36, $1b, $36, $6c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f46c     1B 36 6C 36 
0f470     1B 00 00 00 
0f474     88 22 88 22 
0f478     88 22 88 22 | 	byte	$1b, $36, $6c, $36, $1b, $00, $00, $00, $88, $22, $88, $22, $88, $22, $88, $22
0f47c     88 22 88 22 
0f480     88 22 88 22 
0f484     AA 55 AA 55 
0f488     AA 55 AA 55 | 	byte	$88, $22, $88, $22, $88, $22, $88, $22, $aa, $55, $aa, $55, $aa, $55, $aa, $55
0f48c     AA 55 AA 55 
0f490     AA 55 AA 55 
0f494     BB EE BB EE 
0f498     BB EE BB EE | 	byte	$aa, $55, $aa, $55, $aa, $55, $aa, $55, $bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee
0f49c     BB EE BB EE 
0f4a0     BB EE BB EE 
0f4a4     18 18 18 18 
0f4a8     18 18 18 18 | 	byte	$bb, $ee, $bb, $ee, $bb, $ee, $bb, $ee, $18, $18, $18, $18, $18, $18, $18, $18
0f4ac     18 18 18 18 
0f4b0     18 18 18 18 
0f4b4     18 18 18 18 
0f4b8     18 18 18    | 	byte	$18[15]
0f4bb     1F 18 18 18 
0f4bf     18 18 18 18 
0f4c3     18 30 18 00 
0f4c7     08 1C 36 63 | 	byte	$1f, $18, $18, $18, $18, $18, $18, $18, $18, $30, $18, $00, $08, $1c, $36, $63
0f4cb     63 7F 63 63 
0f4cf     63 63 00 00 
0f4d3     00 1C 36 00 
0f4d7     08 1C 36 63 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $1c, $36, $00, $08, $1c, $36, $63
0f4db     63 7F 63 63 
0f4df     63 63 00 00 
0f4e3     00 36 1C 00 
0f4e7     7F 66 46 16 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $36, $1c, $00, $7f, $66, $46, $16
0f4eb     1E 16 06 46 
0f4ef     66 7F 00 00 
0f4f3     00 00 00 00 
0f4f7     3E 63 63 06 | 	byte	$1e, $16, $06, $46, $66, $7f, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $06
0f4fb     1C 30 60 63 
0f4ff     63 3E 18 30 
0f503     1E 6C 6C 6C 
0f507     6C 6C 6F 60 | 	byte	$1c, $30, $60, $63, $63, $3e, $18, $30, $1e, $6c, $6c, $6c, $6c, $6c, $6f, $60
0f50b     6F 6C 6C 6C 
0f50f     6C 6C 6C 6C 
0f513     6C 6C 6C 6C 
0f517     6C 6C 6C 6C | 	byte	$6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
0f51b     6C 6C 6C 6C 
0f51f     6C 6C 6C 6C 
0f523     6C          | 	byte	$6c[9]
0f524     00 00 00 00 
0f528     00          | 	byte	$00[5]
0f529     7F 60 6F 6C 
0f52d     6C 6C 6C 6C 
0f531     6C 6C 6C 6C 
0f535     6C 6C 6C 6C | 	byte	$7f, $60, $6f, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
0f539     6F 60 7F 00 
0f53d     00 00 00 00 
0f541     00 00 00 18 
0f545     18 00 7F 63 | 	byte	$6f, $60, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $7f, $63
0f549     61 30 18 0C 
0f54d     06 43 63 7F 
0f551     00 00 00 00 
0f555     00 00 18 18 | 	byte	$61, $30, $18, $0c, $06, $43, $63, $7f, $00, $00, $00, $00, $00, $00, $18, $18
0f559     00 7F 33 18 
0f55d     0C 06 63 7F 
0f561     00 00 00 00 
0f565     00 00 00 00 | 	byte	$00, $7f, $33, $18, $0c, $06, $63, $7f, $00, $00, $00, $00, $00, $00, $00, $00
0f569     00 00 1F 18 
0f56d     18 18 18 18 
0f571     18 18 18 18 
0f575     18 18 18 18 | 	byte	$00, $00, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f579     18 18 F8 00 
0f57d     00 00 00 00 
0f581     00 00 00 18 
0f585     18 18 18 18 | 	byte	$18, $18, $f8, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
0f589     18 18 FF 00 
0f58d     00 00 00 00 
0f591     00 00 00 00 
0f595     00 00 00 00 | 	byte	$18, $18, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f599     00 00 FF 18 
0f59d     18 18 18 18 
0f5a1     18 18 18 18 
0f5a5     18 18 18 18 | 	byte	$00, $00, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f5a9     18 18 F8 18 
0f5ad     18 18 18 18 
0f5b1     18 18 18 00 
0f5b5     00 00 00 00 | 	byte	$18, $18, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
0f5b9     00 00 FF 00 
0f5bd     00 00 00 00 
0f5c1     00 00 00 18 
0f5c5     18 18 18 18 | 	byte	$00, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18
0f5c9     18 18 FF 18 
0f5cd     18 18 18 18 
0f5d1     18 18 18 63 
0f5d5     3E 00 08 1C | 	byte	$18, $18, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $63, $3e, $00, $08, $1c
0f5d9     36 63 63 7F 
0f5dd     63 63 63 63 
0f5e1     00 00 00 00 
0f5e5     00 00 63 3E | 	byte	$36, $63, $63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $63, $3e
0f5e9     00 1E 30 3E 
0f5ed     33 33 33 6E 
0f5f1     00 00 00 6C 
0f5f5     6C 6C 6C 6C | 	byte	$00, $1e, $30, $3e, $33, $33, $33, $6e, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
0f5f9     EC 0C FC 00 
0f5fd     00 00 00 00 
0f601     00 00 00 00 
0f605     00 00 00 00 | 	byte	$ec, $0c, $fc, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f609     FC 0C EC 6C 
0f60d     6C 6C 6C 6C 
0f611     6C 6C 6C 6C 
0f615     6C 6C 6C 6C | 	byte	$fc, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
0f619     EF 00 FF 00 
0f61d     00 00 00 00 
0f621     00 00 00 00 
0f625     00 00 00 00 | 	byte	$ef, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f629     FF 00 EF 6C 
0f62d     6C 6C 6C 6C 
0f631     6C 6C 6C 6C 
0f635     6C 6C 6C 6C | 	byte	$ff, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c
0f639     EC 0C EC 6C 
0f63d     6C 6C 6C 6C 
0f641     6C 6C 6C 00 
0f645     00 00 00 00 | 	byte	$ec, $0c, $ec, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
0f649     FF 00 FF 00 
0f64d     00 00 00 00 
0f651     00 00 00 6C 
0f655     6C 6C 6C 6C | 	byte	$ff, $00, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $6c, $6c, $6c, $6c, $6c
0f659     EF 00 EF 6C 
0f65d     6C 6C 6C 6C 
0f661     6C 6C 6C 00 
0f665     00 00 00 00 | 	byte	$ef, $00, $ef, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $6c, $00, $00, $00, $00, $00
0f669     63 3E 63 63 
0f66d     63 63 3E 63 
0f671     00 00 00 00 
0f675     00 00 30 7E | 	byte	$63, $3e, $63, $63, $63, $63, $3e, $63, $00, $00, $00, $00, $00, $00, $30, $7e
0f679     30 3C 36 33 
0f67d     33 33 33 6E 
0f681     00 00 00 00 
0f685     00 00 1F 36 | 	byte	$30, $3c, $36, $33, $33, $33, $33, $6e, $00, $00, $00, $00, $00, $00, $1f, $36
0f689     66 66 6F 66 
0f68d     66 66 36 1F 
0f691     00 00 00 36 
0f695     1C 00 1F 36 | 	byte	$66, $66, $6f, $66, $66, $66, $36, $1f, $00, $00, $00, $36, $1c, $00, $1f, $36
0f699     66 66 66 66 
0f69d     66 66       | 	byte	$66[6]
0f69f     36 1F 00 00 
0f6a3     00 00 63 00 
0f6a7     7F 66 46 16 
0f6ab     1E 16 06 46 | 	byte	$36, $1f, $00, $00, $00, $00, $63, $00, $7f, $66, $46, $16, $1e, $16, $06, $46
0f6af     66 7F 00 00 
0f6b3     00 6C 38 00 
0f6b7     38 30 30 3C 
0f6bb     36 33 33 33 | 	byte	$66, $7f, $00, $00, $00, $6c, $38, $00, $38, $30, $30, $3c, $36, $33, $33, $33
0f6bf     33 6E 00 00 
0f6c3     00 36 1C 00 
0f6c7     63 67 6F 7F 
0f6cb     7B 73 63 63 | 	byte	$33, $6e, $00, $00, $00, $36, $1c, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63
0f6cf     63 63 00 00 
0f6d3     00 30 18 00 
0f6d7     3C 18 18 18 
0f6db     18 18 18 18 | 	byte	$63, $63, $00, $00, $00, $30, $18, $00, $3c, $18, $18, $18, $18, $18, $18, $18
0f6df     18 3C 00 00 
0f6e3     00 3C 66 00 
0f6e7     3C 18 18 18 
0f6eb     18 18 18 18 | 	byte	$18, $3c, $00, $00, $00, $3c, $66, $00, $3c, $18, $18, $18, $18, $18, $18, $18
0f6ef     18 3C 00 00 
0f6f3     00 00 00 36 
0f6f7     1C 08 00 3E 
0f6fb     63 7F 03 03 | 	byte	$18, $3c, $00, $00, $00, $00, $00, $36, $1c, $08, $00, $3e, $63, $7f, $03, $03
0f6ff     63 3E 00 00 
0f703     00 18 18 18 
0f707     18 18 18 18 
0f70b     1F 00 00 00 | 	byte	$63, $3e, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $1f, $00, $00, $00
0f70f     00 00 00 00 
0f713     00 00 00 00 
0f717     00 00 00 00 | 	byte	$00[12]
0f71b     F8 18 18 18 
0f71f     18 18 18 18 
0f723     18 FF FF FF 
0f727     FF FF FF FF | 	byte	$f8, $18, $18, $18, $18, $18, $18, $18, $18, $ff, $ff, $ff, $ff, $ff, $ff, $ff
0f72b     FF FF FF FF 
0f72f     FF FF FF FF 
0f733     FF          | 	byte	$ff[9]
0f734     00 00 00 00 
0f738     00 00 00    | 	byte	$00[7]
0f73b     FF FF FF FF 
0f73f     FF FF FF FF 
0f743     FF          | 	byte	$ff[9]
0f744     00 00 00 7E 
0f748     7E 5A 18 18 
0f74c     18 18 18 18 
0f750     3C 18 30 1E | 	byte	$00, $00, $00, $7e, $7e, $5a, $18, $18, $18, $18, $18, $18, $3c, $18, $30, $1e
0f754     1C 36 1C 63 
0f758     63 63 63 63 
0f75c     63 63 63 63 
0f760     3E 00 00 00 | 	byte	$1c, $36, $1c, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f764     FF FF FF FF 
0f768     FF FF FF    | 	byte	$ff[7]
0f76b     00 00 00 00 
0f76f     00 00 00 00 
0f773     00          | 	byte	$00[9]
0f774     30 18 00 3E 
0f778     63 63 63 63 
0f77c     63 63 63 63 
0f780     3E 00 00 00 | 	byte	$30, $18, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f784     00 00 00 1E 
0f788     33 33 33 1B 
0f78c     33 63 63 63 
0f790     33 00 00 00 | 	byte	$00, $00, $00, $1e, $33, $33, $33, $1b, $33, $63, $63, $63, $33, $00, $00, $00
0f794     1C 36 00 3E 
0f798     63 63 63 63 
0f79c     63 63 63 63 
0f7a0     3E 00 00 00 | 	byte	$1c, $36, $00, $3e, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f7a4     30 18 00 63 
0f7a8     67 6F 7F 7B 
0f7ac     73 63 63 63 
0f7b0     63 00 00 00 | 	byte	$30, $18, $00, $63, $67, $6f, $7f, $7b, $73, $63, $63, $63, $63, $00, $00, $00
0f7b4     00 00 60 30 
0f7b8     18 00 3B 66 
0f7bc     66 66 66 66 
0f7c0     66 00 00 00 | 	byte	$00, $00, $60, $30, $18, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
0f7c4     00 00 36 1C 
0f7c8     08 00 3B 66 
0f7cc     66 66 66 66 
0f7d0     66 00 00 00 | 	byte	$00, $00, $36, $1c, $08, $00, $3b, $66, $66, $66, $66, $66, $66, $00, $00, $00
0f7d4     36 1C 00 3E 
0f7d8     63 63 06 1C 
0f7dc     30 60 63 63 
0f7e0     3E 00 00 00 | 	byte	$36, $1c, $00, $3e, $63, $63, $06, $1c, $30, $60, $63, $63, $3e, $00, $00, $00
0f7e4     00 00 36 1C 
0f7e8     08 00 3E 63 
0f7ec     06 1C 30 63 
0f7f0     3E 00 00 00 | 	byte	$00, $00, $36, $1c, $08, $00, $3e, $63, $06, $1c, $30, $63, $3e, $00, $00, $00
0f7f4     30 18 00 3F 
0f7f8     66 66 66 3E 
0f7fc     36 66 66 66 
0f800     6F 00 00 00 | 	byte	$30, $18, $00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00
0f804     30 18 00 63 
0f808     63 63 63 63 
0f80c     63 63 63 63 
0f810     3E 00 00 00 | 	byte	$30, $18, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f814     00 00 60 30 
0f818     18 00 3B 6E 
0f81c     66 06 06 06 
0f820     0F 00 00 00 | 	byte	$00, $00, $60, $30, $18, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00
0f824     66 33 00 63 
0f828     63 63 63 63 
0f82c     63 63 63 63 
0f830     3E 00 00 00 | 	byte	$66, $33, $00, $63, $63, $63, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00
0f834     00 00 60 30 
0f838     18 00 63 63 
0f83c     63 63 63 63 
0f840     7E 60 30 1F | 	byte	$00, $00, $60, $30, $18, $00, $63, $63, $63, $63, $63, $63, $7e, $60, $30, $1f
0f844     30 18 00 66 
0f848     66 66 66 3C 
0f84c     18 18 18 18 
0f850     3C 00 00 00 | 	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $18, $18, $18, $3c, $00, $00, $00
0f854     00 00 00 08 
0f858     0C 0C 3F 0C 
0f85c     0C 0C 0C 6C 
0f860     38 18 30 1E | 	byte	$00, $00, $00, $08, $0c, $0c, $3f, $0c, $0c, $0c, $0c, $6c, $38, $18, $30, $1e
0f864     30 18 00 00 
0f868     00 00 00 00 
0f86c     00 00 00 00 
0f870     00 00 00 00 | 	byte	$30, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f874     00 00 00 00 
0f878     00 00 00 00 | 	byte	$00[8]
0f87c     7F 00 00 00 
0f880     00 00 00 00 
0f884     66 33 00 00 
0f888     00 00 00 00 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $66, $33, $00, $00, $00, $00, $00, $00
0f88c     00 00 00 00 
0f890     00 00 00 00 
0f894     00 00 00 00 
0f898     00 00 00 00 
0f89c     00 00 00 00 
0f8a0     00          | 	byte	$00[21]
0f8a1     0C 06 3C 36 
0f8a5     1C 00 00 00 
0f8a9     00 00 00 00 
0f8ad     00 00 00 00 | 	byte	$0c, $06, $3c, $36, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f8b1     00 00 00 63 
0f8b5     3E 00 00 00 
0f8b9     00 00 00 00 
0f8bd     00 00 00 00 | 	byte	$00, $00, $00, $63, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f8c1     00 00 00 00 
0f8c5     3E 63 06 1C 
0f8c9     36 63 63 36 
0f8cd     1C 30 63 3E | 	byte	$00, $00, $00, $00, $3e, $63, $06, $1c, $36, $63, $63, $36, $1c, $30, $63, $3e
0f8d1     00 00 00 00 
0f8d5     00 00 00 00 | 	byte	$00[8]
0f8d9     18 00 7E 00 
0f8dd     18 00 00 00 
0f8e1     00 00 00 00 
0f8e5     00 00 00 00 | 	byte	$18, $00, $7e, $00, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f8e9     00 00 00 00 
0f8ed     00 00 00 00 | 	byte	$00[8]
0f8f1     18 30 1E 00 
0f8f5     00 00 1C 36 
0f8f9     36 1C 00 00 
0f8fd     00 00 00 00 | 	byte	$18, $30, $1e, $00, $00, $00, $1c, $36, $36, $1c, $00, $00, $00, $00, $00, $00
0f901     00 00 00 00 
0f905     63 00 00 00 
0f909     00 00 00 00 
0f90d     00 00 00 00 | 	byte	$00, $00, $00, $00, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f911     00 00 00 18 
0f915     18 00 00 00 
0f919     00 00 00 00 
0f91d     00 00 00 00 | 	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f921     00 00 00 00 
0f925     00          | 	byte	$00[5]
0f926     CC 66 33 00 
0f92a     33 33 33 33 
0f92e     33 33 6E 00 
0f932     00 00 36 1C | 	byte	$cc, $66, $33, $00, $33, $33, $33, $33, $33, $33, $6e, $00, $00, $00, $36, $1c
0f936     00 3F 66 66 
0f93a     66 3E 36 66 
0f93e     66 66 6F 00 
0f942     00 00 00 00 | 	byte	$00, $3f, $66, $66, $66, $3e, $36, $66, $66, $66, $6f, $00, $00, $00, $00, $00
0f946     36 1C 08 00 
0f94a     3B 6E 66 06 
0f94e     06 06 0F 00 
0f952     00 00 00 00 | 	byte	$36, $1c, $08, $00, $3b, $6e, $66, $06, $06, $06, $0f, $00, $00, $00, $00, $00
0f956     00 00 00 7E 
0f95a     7E 7E 7E 7E 
0f95e     7E 7E 00 00 
0f962     00 00 00 00 | 	byte	$00, $00, $00, $7e, $7e, $7e, $7e, $7e, $7e, $7e, $00, $00, $00, $00, $00, $00
0f966     00 00 00 00 
0f96a     00 00 00 00 
0f96e     00 00 00 00 
0f972     00 00       | 	byte	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0f974     00 00 00 00 
      ...             
0f9a4     00 00 00 00 
0f9a8     00 00 00    | st_font        file "st4font.def"
0f9ab     FF FF 00 00 
0f9af     00 00 00 00 
0f9b3     00 18 18 18 
0f9b7     18 18 18 18 | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0f9bb     18 18 18 18 
0f9bf     18 18 18 18 
0f9c3     18          | 	byte	$18[9]
0f9c4     00 00 00 00 
0f9c8     00 00 00    | 	byte	$00[7]
0f9cb     FF FF 18 18 
0f9cf     18 18 18 18 
0f9d3     18 18 18 18 
0f9d7     18 18 18 18 | 	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f9db     FF FF 00 00 
0f9df     00 00 00 00 
0f9e3     00 18 18 18 
0f9e7     18 18 18 18 | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0f9eb     1F 1F 18 18 
0f9ef     18 18 18 18 
0f9f3     18 18 18 18 
0f9f7     18 18 18 18 | 	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0f9fb     F8 F8 18 18 
0f9ff     18 18 18 18 
0fa03     18 00 00 00 
0fa07     00 00 00 00 | 	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0fa0b     1F 1F 18 18 
0fa0f     18 18 18 18 
0fa13     18 00 00 00 
0fa17     00 00 00 00 | 	byte	$1f, $1f, $18, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0fa1b     F8 F8 18 18 
0fa1f     18 18 18 18 
0fa23     18 18 18 18 
0fa27     18 18 18 18 | 	byte	$f8, $f8, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
0fa2b     1F 1F 00 00 
0fa2f     00 00 00 00 
0fa33     00 18 18 18 
0fa37     18 18 18 18 | 	byte	$1f, $1f, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0fa3b     F8 F8 00 00 
0fa3f     00 00 00 00 
0fa43     00 18 18 18 
0fa47     18 18 18 18 | 	byte	$f8, $f8, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18
0fa4b     FF FF 18 18 
0fa4f     18 18 18 18 
0fa53     18 00 00 18 
0fa57     3C 7E 66 66 | 	byte	$ff, $ff, $18, $18, $18, $18, $18, $18, $18, $00, $00, $18, $3c, $7e, $66, $66
0fa5b     66 7E 7E 66 
0fa5f     66 66 66 30 
0fa63     18 00 00 7E 
0fa67     7E 06 06 3E | 	byte	$66, $7e, $7e, $66, $66, $66, $66, $30, $18, $00, $00, $7e, $7e, $06, $06, $3e
0fa6b     3E 06 06 06 
0fa6f     06 7E 7E 18 
0fa73     0C 30 18 3C 
0fa77     7E 66 66 06 | 	byte	$3e, $06, $06, $06, $06, $7e, $7e, $18, $0c, $30, $18, $3c, $7e, $66, $66, $06
0fa7b     06 06 06 66 
0fa7f     66 7E 3C 00 
0fa83     00 30 18 66 
0fa87     66 66 6E 6E | 	byte	$06, $06, $06, $66, $66, $7e, $3c, $00, $00, $30, $18, $66, $66, $66, $6e, $6e
0fa8b     7E 7E 76 76 
0fa8f     66 66 66 00 
0fa93     00 30 18 7C 
0fa97     7E 06 06 0E | 	byte	$7e, $7e, $76, $76, $66, $66, $66, $00, $00, $30, $18, $7c, $7e, $06, $06, $0e
0fa9b     1C 38 70 60 
0fa9f     60 7E 3E 00 
0faa3     00 30 18 7E 
0faa7     7E 30 30 18 | 	byte	$1c, $38, $70, $60, $60, $7e, $3e, $00, $00, $30, $18, $7e, $7e, $30, $30, $18
0faab     18 0C 0C 06 
0faaf     06 7E 7E 00 
0fab3     00 18 18 00 
0fab7     7E 7E 30 30 | 	byte	$18, $0c, $0c, $06, $06, $7e, $7e, $00, $00, $18, $18, $00, $7e, $7e, $30, $30
0fabb     18 18 0C 0C 
0fabf     06 7E 7E 00 
0fac3     00 30 18 3C 
0fac7     7E 66 66 66 | 	byte	$18, $18, $0c, $0c, $06, $7e, $7e, $00, $00, $30, $18, $3c, $7e, $66, $66, $66
0facb     66 66 66 66 
0facf     66          | 	byte	$66[5]
0fad0     7E 3C 00 00 
0fad4     00 00 06 06 
0fad8     06 06 16 1E 
0fadc     0E 06 06 06 | 	byte	$7e, $3c, $00, $00, $00, $00, $06, $06, $06, $06, $16, $1e, $0e, $06, $06, $06
0fae0     7E 7E 00 00 
0fae4     00 00 00 00 
0fae8     00 3C 7C 60 
0faec     7C 7E 66 66 | 	byte	$7e, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $7c, $60, $7c, $7e, $66, $66
0faf0     7E 7C 30 18 
0faf4     00 00 00 00 
0faf8     00 3C 7E 66 
0fafc     66 7E 06 06 | 	byte	$7e, $7c, $30, $18, $00, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $06, $06
0fb00     7E 7C 18 0C 
0fb04     00 00 30 18 
0fb08     00 3C 3E 06 
0fb0c     06 06 06 06 | 	byte	$7e, $7c, $18, $0c, $00, $00, $30, $18, $00, $3c, $3e, $06, $06, $06, $06, $06
0fb10     7E 7C 00 00 
0fb14     00 00 30 18 
0fb18     00 3E 7E 66 
0fb1c     66 66 66 66 | 	byte	$7e, $7c, $00, $00, $00, $00, $30, $18, $00, $3e, $7e, $66, $66, $66, $66, $66
0fb20     66 66 00 00 
0fb24     00 00 30 18 
0fb28     00 7C 7E 06 
0fb2c     0E 3C 70 60 | 	byte	$66, $66, $00, $00, $00, $00, $30, $18, $00, $7c, $7e, $06, $0e, $3c, $70, $60
0fb30     7E 3E 00 00 
0fb34     00 00 30 18 
0fb38     00 7E 7E 30 
0fb3c     18 18 0C 0C | 	byte	$7e, $3e, $00, $00, $00, $00, $30, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
0fb40     7E 7E 00 00 
0fb44     00 00 18 18 
0fb48     00 7E 7E 30 
0fb4c     18 18 0C 0C | 	byte	$7e, $7e, $00, $00, $00, $00, $18, $18, $00, $7e, $7e, $30, $18, $18, $0c, $0c
0fb50     7E 7E 00 00 
0fb54     00 00 30 18 
0fb58     00 3C 7E 66 
0fb5c     66 66 66 66 | 	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $00, $3c, $7e, $66, $66, $66, $66, $66
0fb60     7E 3C 00 00 
0fb64     00 00 1C 1C 
0fb68     18 18 38 3C 
0fb6c     1C 18 18 18 | 	byte	$7e, $3c, $00, $00, $00, $00, $1c, $1c, $18, $18, $38, $3c, $1c, $18, $18, $18
0fb70     3C 3C 00 00 
0fb74     00 00 00 00 
0fb78     00 00 00 00 
0fb7c     00 00 00 00 | 	byte	$3c, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
0fb80     00 00 00 00 
0fb84     00 00       | 	byte	$00[6]
0fb86     18 18 18 18 
0fb8a     18 18 18 18 | 	byte	$18[8]
0fb8e     00 00 18 18 
0fb92     00 00 00 00 
0fb96     66 66 66 66 
0fb9a     00 00 00 00 | 	byte	$00, $00, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $00, $00, $00, $00
0fb9e     00 00 00 00 
0fba2     00 00 00 00 
0fba6     00          | 	byte	$00[9]
0fba7     66 66 FF FF 
0fbab     66 66 FF FF 
0fbaf     66 66 00 00 
0fbb3     00 00 18 18 | 	byte	$66, $66, $ff, $ff, $66, $66, $ff, $ff, $66, $66, $00, $00, $00, $00, $18, $18
0fbb7     7C 7E 06 06 
0fbbb     3E 7C 60 60 
0fbbf     7E 3E 18 18 
0fbc3     00 00 00 66 | 	byte	$7c, $7e, $06, $06, $3e, $7c, $60, $60, $7e, $3e, $18, $18, $00, $00, $00, $66
0fbc7     66 30 30 18 
0fbcb     18 0C 0C 66 
0fbcf     66 00 00 00 
0fbd3     00 00 3C 7E | 	byte	$66, $30, $30, $18, $18, $0c, $0c, $66, $66, $00, $00, $00, $00, $00, $3c, $7e
0fbd7     66 66 3C 1C 
0fbdb     1C FC FE 66 
0fbdf     66 FE FC 00 
0fbe3     00 00 00 18 | 	byte	$66, $66, $3c, $1c, $1c, $fc, $fe, $66, $66, $fe, $fc, $00, $00, $00, $00, $18
0fbe7     18 18 18 18 
0fbeb     00 00 00 00 
0fbef     00 00 00 00 
0fbf3     00 00 00 30 | 	byte	$18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $30
0fbf7     18 1C 0C 0C 
0fbfb     0C 0C 0C 0C 
0fbff     1C 18 30 00 
0fc03     00 00 00 0C | 	byte	$18, $1c, $0c, $0c, $0c, $0c, $0c, $0c, $1c, $18, $30, $00, $00, $00, $00, $0c
0fc07     18 38 30 30 
0fc0b     30 30 30 30 
0fc0f     38 18 0C 00 
0fc13     00 00 00 00 | 	byte	$18, $38, $30, $30, $30, $30, $30, $30, $38, $18, $0c, $00, $00, $00, $00, $00
0fc17     66 66 3C 3C 
0fc1b     FF FF 3C 3C 
0fc1f     66 66 00 00 
0fc23     00 00 00 00 | 	byte	$66, $66, $3c, $3c, $ff, $ff, $3c, $3c, $66, $66, $00, $00, $00, $00, $00, $00
0fc27     00 18 18 18 
0fc2b     7E 7E 18 18 
0fc2f     18 00 00 00 
0fc33     00 00 00 00 | 	byte	$00, $18, $18, $18, $7e, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0fc37     00 00 00 00 
0fc3b     00 00       | 	byte	$00[6]
0fc3d     18 18 18 18 
0fc41     18          | 	byte	$18[5]
0fc42     0C 04 00 00 
0fc46     00 00 00 00 
0fc4a     7E 7E 00 00 
0fc4e     00 00 00 00 | 	byte	$0c, $04, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $00, $00, $00, $00
0fc52     00 00 00 00 
0fc56     00 00 00 00 
0fc5a     00 00 00 00 
0fc5e     00          | 	byte	$00[13]
0fc5f     18 18 18 00 
0fc63     00 00 00 60 
0fc67     60 60 30 30 
0fc6b     18 18 0C 0C | 	byte	$18, $18, $18, $00, $00, $00, $00, $60, $60, $60, $30, $30, $18, $18, $0c, $0c
0fc6f     06 06 06 00 
0fc73     00 00 00 3C 
0fc77     7E 66 66 66 
0fc7b     76 6E 66 66 | 	byte	$06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $76, $6e, $66, $66
0fc7f     66 7E 3C 00 
0fc83     00 00 00 18 
0fc87     18 1C 1C 18 
0fc8b     18 18 18 18 | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $18, $18, $1c, $1c, $18, $18, $18, $18, $18
0fc8f     18 7E 7E 00 
0fc93     00 00 00 3C 
0fc97     7E 66 66 30 
0fc9b     30 18 18 0C | 	byte	$18, $7e, $7e, $00, $00, $00, $00, $3c, $7e, $66, $66, $30, $30, $18, $18, $0c
0fc9f     0C 7E 7E 00 
0fca3     00 00 00 7E 
0fca7     7E 30 30 18 
0fcab     18 30 30 66 | 	byte	$0c, $7e, $7e, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $30, $30, $66
0fcaf     66 7E 3C 00 
0fcb3     00 00 00 30 
0fcb7     30 38 38 3C 
0fcbb     3C 36 36 7E | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $30, $30, $38, $38, $3c, $3c, $36, $36, $7e
0fcbf     7E 30 30 00 
0fcc3     00 00 00 7E 
0fcc7     7E 06 06 3E 
0fccb     7E 60 60 60 | 	byte	$7e, $30, $30, $00, $00, $00, $00, $7e, $7e, $06, $06, $3e, $7e, $60, $60, $60
0fccf     66 7E 3C 00 
0fcd3     00 00 00 38 
0fcd7     3C 0E 06 06 
0fcdb     3E 7E 66 66 | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $38, $3c, $0e, $06, $06, $3e, $7e, $66, $66
0fcdf     66 7E 3C 00 
0fce3     00 00 00 7E 
0fce7     7E 60 60 30 
0fceb     30 18 18 0C | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $7e, $7e, $60, $60, $30, $30, $18, $18, $0c
0fcef     0C 0C 0C 00 
0fcf3     00 00 00 3C 
0fcf7     7E 66 66 3C 
0fcfb     3C 66 66 66 | 	byte	$0c, $0c, $0c, $00, $00, $00, $00, $3c, $7e, $66, $66, $3c, $3c, $66, $66, $66
0fcff     66 7E 3C 00 
0fd03     00 00 00 3C 
0fd07     7E 66 66 7E 
0fd0b     7C 60 60 60 | 	byte	$66, $7e, $3c, $00, $00, $00, $00, $3c, $7e, $66, $66, $7e, $7c, $60, $60, $60
0fd0f     70 3C 1C 00 
0fd13     00 00 00 00 
0fd17     00 00 18 18 
0fd1b     18 00 00 00 | 	byte	$70, $3c, $1c, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $00
0fd1f     18 18 18 00 
0fd23     00 00 00 00 
0fd27     00 00 18 18 
0fd2b     18 00 00 18 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $00, $00, $18
0fd2f     18 18 18 0C 
0fd33     04 00 00 00 
0fd37     70 38 1C 0E 
0fd3b     07 0E 1C 38 | 	byte	$18, $18, $18, $0c, $04, $00, $00, $00, $70, $38, $1c, $0e, $07, $0e, $1c, $38
0fd3f     70 00 00 00 
0fd43     00 00 00 00 
0fd47     00 00 7E 7E 
0fd4b     00 00 7E 7E | 	byte	$70, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $7e, $00, $00, $7e, $7e
0fd4f     00 00 00 00 
0fd53     00 00 00 00 | 	byte	$00[8]
0fd57     0E 1C 38 70 
0fd5b     E0 70 38 1C 
0fd5f     0E 00 00 00 
0fd63     00 00 00 3C | 	byte	$0e, $1c, $38, $70, $e0, $70, $38, $1c, $0e, $00, $00, $00, $00, $00, $00, $3c
0fd67     7E 66 66 30 
0fd6b     30 18 18 18 
0fd6f     00 18 18 00 
0fd73     00 00 00 3C | 	byte	$7e, $66, $66, $30, $30, $18, $18, $18, $00, $18, $18, $00, $00, $00, $00, $3c
0fd77     7E 66 66 66 
0fd7b     66 36 06 66 
0fd7f     66 7E 3C 00 
0fd83     00 00 00 18 | 	byte	$7e, $66, $66, $66, $66, $36, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $18
0fd87     3C 7E 66 66 
0fd8b     66 7E 7E 66 
0fd8f     66 66 66 00 
0fd93     00 00 00 3E | 	byte	$3c, $7e, $66, $66, $66, $7e, $7e, $66, $66, $66, $66, $00, $00, $00, $00, $3e
0fd97     7E 66 66 7E 
0fd9b     3E 66 66 66 
0fd9f     66 7E 3E 00 
0fda3     00 00 00 3C | 	byte	$7e, $66, $66, $7e, $3e, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $3c
0fda7     7E 66 66 06 
0fdab     06 06 06 66 
0fdaf     66 7E 3C 00 
0fdb3     00 00 00 3E | 	byte	$7e, $66, $66, $06, $06, $06, $06, $66, $66, $7e, $3c, $00, $00, $00, $00, $3e
0fdb7     7E 66 66 66 
0fdbb     66 66 66 66 
0fdbf     66 7E 3E 00 
0fdc3     00 00 00 7E | 	byte	$7e, $66, $66, $66, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $7e
0fdc7     7E 06 06 3E 
0fdcb     3E 06 06 06 
0fdcf     06 7E 7E 00 
0fdd3     00 00 00 7E | 	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $7e, $7e, $00, $00, $00, $00, $7e
0fdd7     7E 06 06 3E 
0fddb     3E 06 06 06 
0fddf     06 06 06 00 
0fde3     00 00 00 7C | 	byte	$7e, $06, $06, $3e, $3e, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $7c
0fde7     7E 06 06 76 
0fdeb     76 66 66 66 
0fdef     66 7E 3C 00 
0fdf3     00 00 00 66 | 	byte	$7e, $06, $06, $76, $76, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $66
0fdf7     66 66 66 7E 
0fdfb     7E 66 66 66 
0fdff     66 66 66 00 
0fe03     00 00 00 7E | 	byte	$66, $66, $66, $7e, $7e, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $7e
0fe07     7E 18 18 18 
0fe0b     18 18 18 18 
0fe0f     18 7E 7E 00 
0fe13     00 00 00 60 | 	byte	$7e, $18, $18, $18, $18, $18, $18, $18, $18, $7e, $7e, $00, $00, $00, $00, $60
0fe17     60 60 60 60 
0fe1b     60 60 60    | 	byte	$60[7]
0fe1e     66 66 7E 3C 
0fe22     00 00 00 00 
0fe26     66 66 36 36 
0fe2a     1E 1E 36 36 | 	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $36, $36, $1e, $1e, $36, $36
0fe2e     66 66 C6 C6 
0fe32     00 00 00 00 
0fe36     06 06 06 06 
0fe3a     06 06 06 06 | 	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $06, $06, $06, $06, $06, $06, $06, $06
0fe3e     06 06 7E 7E 
0fe42     00 00 00 00 
0fe46     C6 C6 EE EE 
0fe4a     FE D6 D6 C6 | 	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $c6, $c6, $ee, $ee, $fe, $d6, $d6, $c6
0fe4e     C6 C6 C6 C6 
0fe52     00 00 00 00 
0fe56     66 66 66 6E 
0fe5a     6E 7E 7E 76 | 	byte	$c6, $c6, $c6, $c6, $00, $00, $00, $00, $66, $66, $66, $6e, $6e, $7e, $7e, $76
0fe5e     76 66 66 66 
0fe62     00 00 00 00 
0fe66     3C 7E 66 66 
0fe6a     66 66 66 66 | 	byte	$76, $66, $66, $66, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
0fe6e     66 66 7E 3C 
0fe72     00 00 00 00 
0fe76     3E 7E 66 66 
0fe7a     66 66 7E 3E | 	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $66, $7e, $3e
0fe7e     06 06 06 06 
0fe82     00 00 00 00 
0fe86     3C 7E 66 66 
0fe8a     66 66 66 66 | 	byte	$06, $06, $06, $06, $00, $00, $00, $00, $3c, $7e, $66, $66, $66, $66, $66, $66
0fe8e     66 56 3E 6C 
0fe92     00 00 00 00 
0fe96     3E 7E 66 66 
0fe9a     66 7E 3E 36 | 	byte	$66, $56, $3e, $6c, $00, $00, $00, $00, $3e, $7e, $66, $66, $66, $7e, $3e, $36
0fe9e     66 66 C6 C6 
0fea2     00 00 00 00 
0fea6     7C 7E 06 06 
0feaa     0E 1C 38 70 | 	byte	$66, $66, $c6, $c6, $00, $00, $00, $00, $7c, $7e, $06, $06, $0e, $1c, $38, $70
0feae     60 60 7E 3E 
0feb2     00 00 00 00 
0feb6     7E 7E 18 18 
0feba     18 18 18 18 | 	byte	$60, $60, $7e, $3e, $00, $00, $00, $00, $7e, $7e, $18, $18, $18, $18, $18, $18
0febe     18 18 18 18 
0fec2     00 00 00 00 
0fec6     66 66 66 66 
0feca     66 66 66 66 | 	byte	$18, $18, $18, $18, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
0fece     66 66 7E 3C 
0fed2     00 00 00 00 
0fed6     66 66 66 66 
0feda     66 66 66 66 | 	byte	$66, $66, $7e, $3c, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $66, $66
0fede     3C 3C 18 18 
0fee2     00 00 00 00 
0fee6     C6 C6 C6 C6 
0feea     C6 D6 D6 FE | 	byte	$3c, $3c, $18, $18, $00, $00, $00, $00, $c6, $c6, $c6, $c6, $c6, $d6, $d6, $fe
0feee     FE EE C6 82 
0fef2     00 00 00 00 
0fef6     66 66 66 3C 
0fefa     3C 18 18 3C | 	byte	$fe, $ee, $c6, $82, $00, $00, $00, $00, $66, $66, $66, $3c, $3c, $18, $18, $3c
0fefe     3C 66 66 66 
0ff02     00 00 00 00 
0ff06     66 66 66 66 
0ff0a     66 3C 3C 18 | 	byte	$3c, $66, $66, $66, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c, $18
0ff0e     18 18 18 18 
0ff12     00 00 00 00 
0ff16     7E 7E 30 30 
0ff1a     18 18 0C 0C | 	byte	$18, $18, $18, $18, $00, $00, $00, $00, $7e, $7e, $30, $30, $18, $18, $0c, $0c
0ff1e     06 06 7E 7E 
0ff22     00 00 00 00 
0ff26     3C 3C 0C 0C 
0ff2a     0C 0C 0C 0C | 	byte	$06, $06, $7e, $7e, $00, $00, $00, $00, $3c, $3c, $0c, $0c, $0c, $0c, $0c, $0c
0ff2e     0C 0C 3C 3C 
0ff32     00 00 00 00 
0ff36     06 06 0C 0C 
0ff3a     18 18 30 30 | 	byte	$0c, $0c, $3c, $3c, $00, $00, $00, $00, $06, $06, $0c, $0c, $18, $18, $30, $30
0ff3e     60 60 C0 C0 
0ff42     00 00 00 00 
0ff46     3C 3C 30 30 
0ff4a     30 30 30 30 | 	byte	$60, $60, $c0, $c0, $00, $00, $00, $00, $3c, $3c, $30, $30, $30, $30, $30, $30
0ff4e     30 30 3C 3C 
0ff52     00 00 00 00 
0ff56     18 18 3C 3C 
0ff5a     66 66 00 00 | 	byte	$30, $30, $3c, $3c, $00, $00, $00, $00, $18, $18, $3c, $3c, $66, $66, $00, $00
0ff5e     00 00 00 00 
0ff62     00 00 00 00 
0ff66     00 00 00 00 
0ff6a     00 00 00 00 
0ff6e     00 00       | 	byte	$00[18]
0ff70     FE FE 00 00 
0ff74     00 00 0C 0C 
0ff78     18 18 00 00 
0ff7c     00 00 00 00 | 	byte	$fe, $fe, $00, $00, $00, $00, $0c, $0c, $18, $18, $00, $00, $00, $00, $00, $00
0ff80     00 00 00 00 
0ff84     00 00 00 00 
0ff88     00          | 	byte	$00[9]
0ff89     3C 7C 60 7C 
0ff8d     7E 66 66 7E 
0ff91     7C 00 00 00 
0ff95     00 06 06 06 | 	byte	$3c, $7c, $60, $7c, $7e, $66, $66, $7e, $7c, $00, $00, $00, $00, $06, $06, $06
0ff99     3E 7E 66 66 
0ff9d     66 66 66 7E 
0ffa1     3E 00 00 00 
0ffa5     00 00 00 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $00, $00, $00, $00, $00, $00, $00
0ffa9     3C 3E 06 06 
0ffad     06 06 06 7E 
0ffb1     7C 00 00 00 
0ffb5     00 60 60 60 | 	byte	$3c, $3e, $06, $06, $06, $06, $06, $7e, $7c, $00, $00, $00, $00, $60, $60, $60
0ffb9     7C 7E 66 66 
0ffbd     66 66 66 7E 
0ffc1     7C 00 00 00 
0ffc5     00 00 00 00 | 	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $00, $00, $00, $00, $00, $00, $00
0ffc9     3C 7E 66 66 
0ffcd     7E 06 06 7E 
0ffd1     7C 00 00 00 
0ffd5     00 70 78 18 | 	byte	$3c, $7e, $66, $66, $7e, $06, $06, $7e, $7c, $00, $00, $00, $00, $70, $78, $18
0ffd9     18 7E 7E 18 
0ffdd     18 18 18 18 
0ffe1     18 00 00 00 
0ffe5     00 00 00 00 | 	byte	$18, $7e, $7e, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
0ffe9     7C 7E 66 66 
0ffed     66 66 7E 7C 
0fff1     60 7E 3E 00 
0fff5     00 06 06 06 | 	byte	$7c, $7e, $66, $66, $66, $66, $7e, $7c, $60, $7e, $3e, $00, $00, $06, $06, $06
0fff9     3E 7E 66 66 
0fffd     66 66 66 66 
10001     66 00 00 00 
10005     00 18 18 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $18, $18, $00
10009     1C 1C 18 18 
1000d     18 18 18 3C 
10011     3C 00 00 00 
10015     00 30 30 00 | 	byte	$1c, $1c, $18, $18, $18, $18, $18, $3c, $3c, $00, $00, $00, $00, $30, $30, $00
10019     30 30 30 30 
1001d     30 30 30 30 
10021     30          | 	byte	$30[9]
10022     3E 1E 00 00 
10026     06 06 06 36 
1002a     36 1E 1E 1E 
1002e     36 36 66 66 | 	byte	$3e, $1e, $00, $00, $06, $06, $06, $36, $36, $1e, $1e, $1e, $36, $36, $66, $66
10032     00 00 00 00 
10036     1C 1C 18 18 
1003a     18 18 18 18 
1003e     18 18 3C 3C | 	byte	$00, $00, $00, $00, $1c, $1c, $18, $18, $18, $18, $18, $18, $18, $18, $3c, $3c
10042     00 00 00 00 
10046     00 00 00    | 	byte	$00[7]
10049     6C FE FE D6 
1004d     D6 C6 C6 C6 
10051     C6 00 00 00 
10055     00 00 00 00 | 	byte	$6c, $fe, $fe, $d6, $d6, $c6, $c6, $c6, $c6, $00, $00, $00, $00, $00, $00, $00
10059     3E 7E 66 66 
1005d     66 66 66 66 
10061     66 00 00 00 
10065     00 00 00 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
10069     3C 7E 66 66 
1006d     66 66 66 7E 
10071     3C 00 00 00 
10075     00 00 00 00 | 	byte	$3c, $7e, $66, $66, $66, $66, $66, $7e, $3c, $00, $00, $00, $00, $00, $00, $00
10079     3E 7E 66 66 
1007d     66 66 66 7E 
10081     3E 06 06 00 
10085     00 00 00 00 | 	byte	$3e, $7e, $66, $66, $66, $66, $66, $7e, $3e, $06, $06, $00, $00, $00, $00, $00
10089     7C 7E 66 66 
1008d     66 66 66 7E 
10091     7C 60 60 00 
10095     00 00 00 00 | 	byte	$7c, $7e, $66, $66, $66, $66, $66, $7e, $7c, $60, $60, $00, $00, $00, $00, $00
10099     3E 7E 66 06 
1009d     06 06 06 06 
100a1     06 00 00 00 
100a5     00 00 00 00 | 	byte	$3e, $7e, $66, $06, $06, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00
100a9     7C 7E 06 0E 
100ad     3C 70 60 7E 
100b1     3E 00 00 00 
100b5     00 00 18 18 | 	byte	$7c, $7e, $06, $0e, $3c, $70, $60, $7e, $3e, $00, $00, $00, $00, $00, $18, $18
100b9     7E 7E 18 18 
100bd     18 18 18 78 
100c1     70 00 00 00 
100c5     00 00 00 00 | 	byte	$7e, $7e, $18, $18, $18, $18, $18, $78, $70, $00, $00, $00, $00, $00, $00, $00
100c9     66 66 66 66 
100cd     66 66 66    | 	byte	$66[7]
100d0     7E 7C 00 00 
100d4     00 00 00 00 
100d8     00 66 66 66 
100dc     66 66 3C 3C | 	byte	$7e, $7c, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $3c, $3c
100e0     18 18 00 00 
100e4     00 00 00 00 
100e8     00 C6 C6 D6 
100ec     D6 FE FE EE | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $c6, $c6, $d6, $d6, $fe, $fe, $ee
100f0     C6 82 00 00 
100f4     00 00 00 00 
100f8     00 66 66 3C 
100fc     3C 18 3C 3C | 	byte	$c6, $82, $00, $00, $00, $00, $00, $00, $00, $66, $66, $3c, $3c, $18, $3c, $3c
10100     66 66 00 00 
10104     00 00 00 00 
10108     00 66 66 66 
1010c     66 66 66 7E | 	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66, $66, $7e
10110     7C 60 7E 3E 
10114     00 00 00 00 
10118     00 7E 7E 30 
1011c     18 18 0C 0C | 	byte	$7c, $60, $7e, $3e, $00, $00, $00, $00, $00, $7e, $7e, $30, $18, $18, $0c, $0c
10120     7E 7E 00 00 
10124     00 00 30 18 
10128     18 18 18 0C 
1012c     0C 18 18 18 | 	byte	$7e, $7e, $00, $00, $00, $00, $30, $18, $18, $18, $18, $0c, $0c, $18, $18, $18
10130     18 30 00 00 
10134     00 00 18 18 
10138     18 18 18 18 
1013c     18 18 18 18 | 	byte	$18, $30, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18, $18, $18
10140     18 18 00 00 
10144     00 00 0C 18 
10148     18 18 18 30 
1014c     30 18 18 18 | 	byte	$18, $18, $00, $00, $00, $00, $0c, $18, $18, $18, $18, $30, $30, $18, $18, $18
10150     18 0C 00 00 
10154     00 00 6C 7E 
10158     36 00 00 00 
1015c     00 00 00 00 | 	byte	$18, $0c, $00, $00, $00, $00, $6c, $7e, $36, $00, $00, $00, $00, $00, $00, $00
10160     00 00 00 00 
10164     00 00 00 00 
10168     00          | 	byte	$00[9]
10169     18 18 18 18 
1016d     18 18 00 00 
10171     00 00 00    | 	byte	$18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00
10174     00 6C FE FE 
10178     7C 38 10 00 
1017c     18 18 18 F8 
10180     F8 18 18 18 | a8_font        file "atari8.fnt"
10184     C0 C0 C0 C0 
10188     C0 C0 C0 C0 | 	byte	$c0[8]
1018c     18 18 18 1F 
10190     1F 00 00 00 
10194     18 18 18 1F 
10198     1F 18 18 18 | 	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
1019c     00 00 00 1F 
101a0     1F 18 18 18 
101a4     C0 E0 70 38 
101a8     1C 0E 07 03 | 	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
101ac     03 07 0E 1C 
101b0     38 70 E0 C0 
101b4     80 C0 E0 F0 
101b8     F8 FC FE FF | 	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
101bc     00 00 00 00 
101c0     F0 F0 F0 F0 
101c4     01 03 07 0F 
101c8     1F 3F 7F FF | 	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
101cc     F0 F0 F0 F0 
101d0     00 00 00 00 
101d4     0F 0F 0F 0F 
101d8     00 00 00 00 | 	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
101dc     FF FF 00 00 
101e0     00 00 00 00 
101e4     00 00 00 00 
101e8     00 00 FF FF | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
101ec     00 00 00 00 
101f0     0F 0F 0F 0F 
101f4     00 38 38 EE 
101f8     EE 10 38 00 | 	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
101fc     00 00 00 F8 
10200     F8 18 18 18 
10204     00 00 00 FF 
10208     FF 00 00 00 | 	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
1020c     18 18 18 FF 
10210     FF 18 18 18 
10214     00 00 3C 7E 
10218     7E 7E 3C 00 | 	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
1021c     00 00 00 00 
10220     FF FF FF FF 
10224     03 03 03 03 
10228     03 03 03 03 | 	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
1022c     00 00 00 FF 
10230     FF 18 18 18 
10234     18 18 18 FF 
10238     FF 00 00 00 | 	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
1023c     0F 0F 0F 0F 
10240     0F 0F 0F 0F | 	byte	$0f[8]
10244     18 18 18 F8 
10248     F8 00 00 00 
1024c     1E 06 1E 06 
10250     7E 18 78 00 | 	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
10254     00 18 3C 7E 
10258     18 18 18 00 
1025c     00 18 18 18 
10260     7E 3C 18 00 | 	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
10264     00 18 0C 7E 
10268     0C 18 00 00 
1026c     00 18 30 7E 
10270     30 18 00 00 | 	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
10274     00 00 00 00 
10278     00 00 00 00 
1027c     00          | 	byte	$00[9]
1027d     18 18 18 18 
10281     00 18 00 00 
10285     66 66 66 00 
10289     00 00 00 00 | 	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
1028d     66 FF 66 66 
10291     FF 66 00 18 
10295     7C 06 3C 60 
10299     3E 18 00 00 | 	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
1029d     66 36 18 0C 
102a1     66 62 00 38 
102a5     6C 38 1C F6 
102a9     66 DC 00 00 | 	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
102ad     18 18 18 00 
102b1     00 00 00 00 
102b5     70 38 18 18 
102b9     38 70 00 00 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
102bd     0E 1C 18 18 
102c1     1C 0E 00 00 
102c5     66 3C FF 3C 
102c9     66 00 00 00 | 	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
102cd     18 18 7E 18 
102d1     18 00 00 00 
102d5     00 00 00 00 
102d9     18 18 0C 00 | 	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
102dd     00 00 7E 00 
102e1     00 00 00 00 
102e5     00 00 00 00 
102e9     18 18 00 00 | 	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
102ed     60 30 18 0C 
102f1     06 02 00 00 
102f5     3C 66 76 6E 
102f9     66 3C 00 00 | 	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
102fd     18 1C 18 18 
10301     18 7E 00 00 
10305     3C 66 30 18 
10309     0C 7E 00 00 | 	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
1030d     7E 30 18 30 
10311     66 3C 00 00 
10315     30 38 3C 36 
10319     7E 30 00 00 | 	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
1031d     7E 06 3E 60 
10321     66 3C 00 00 
10325     3C 06 3E 66 
10329     66 3C 00 00 | 	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
1032d     7E 60 30 18 
10331     0C 0C 00 00 
10335     3C 66 3C 66 
10339     66 3C 00 00 | 	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
1033d     3C 66 7C 60 
10341     30 1C 00 00 
10345     00 18 18 00 
10349     18 18 00 00 | 	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
1034d     00 18 18 00 
10351     18 18 0C 60 
10355     30 18 0C 18 
10359     30 60 00 00 | 	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
1035d     00 7E 00 00 
10361     7E 00 00 06 
10365     0C 18 30 18 
10369     0C 06 00 00 | 	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
1036d     3C 66 30 18 
10371     00 18 00 00 
10375     3C 66 76 76 
10379     06 7C 00 00 | 	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
1037d     18 3C 66 66 
10381     7E 66 00 00 
10385     3E 66 3E 66 
10389     66 3E 00 00 | 	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
1038d     3C 66 06 06 
10391     66 3C 00 00 
10395     1E 36 66 66 
10399     36 1E 00 00 | 	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
1039d     7E 06 3E 06 
103a1     06 7E 00 00 
103a5     7E 06 3E 06 
103a9     06 06 00 00 | 	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
103ad     7C 06 06 76 
103b1     66 7C 00 00 
103b5     66 66 7E 66 
103b9     66 66 00 00 | 	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
103bd     7E 18 18 18 
103c1     18 7E 00 00 
103c5     60 60 60 60 
103c9     66 3C 00 00 | 	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
103cd     66 36 1E 1E 
103d1     36 66 00 00 
103d5     06 06 06 06 
103d9     06 7E 00 00 | 	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
103dd     C6 EE FE D6 
103e1     C6 C6 00 00 
103e5     66 6E 7E 7E 
103e9     76 66 00 00 | 	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
103ed     3C 66 66 66 
103f1     66 3C 00 00 
103f5     3E 66 66 3E 
103f9     06 06 00 00 | 	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
103fd     3C 66 66 66 
10401     36 6C 00 00 
10405     3E 66 66 3E 
10409     36 66 00 00 | 	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
1040d     3C 06 3C 60 
10411     60 3C 00 00 
10415     7E 18 18 18 
10419     18 18 00 00 | 	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
1041d     66 66 66 66 
10421     66          | 	byte	$66[5]
10422     7E 00 00 66 
10426     66 66 66 3C 
1042a     18 00 00 C6 
1042e     C6 D6 FE EE | 	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
10432     C6 00 00 66 
10436     66 3C 3C 66 
1043a     66 00 00 66 
1043e     66 3C 18 18 | 	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
10442     18 00 00 7E 
10446     30 18 0C 06 
1044a     7E 00 00 78 
1044e     18 18 18 18 | 	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
10452     78 00 00 02 
10456     06 0C 18 30 
1045a     60 00 00 1E 
1045e     18 18 18 18 | 	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
10462     1E 00 00 10 
10466     38 6C C6 00 
1046a     00 00 00 00 
1046e     00 00 00 00 | 	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
10472     FF 00 00 18 
10476     3C 7E 7E 3C 
1047a     18 00 00 00 
1047e     3C 60 7C 66 | 	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
10482     7C 00 00 06 
10486     06 3E 66 66 
1048a     3E 00 00 00 
1048e     3C 06 06 06 | 	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
10492     3C 00 00 60 
10496     60 7C 66 66 
1049a     7C 00 00 00 
1049e     3C 66 7E 06 | 	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
104a2     3C 00 00 70 
104a6     18 7C 18 18 
104aa     18 00 00 00 
104ae     7C 66 66 7C | 	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
104b2     60 3E 00 06 
104b6     06 3E 66 66 
104ba     66 00 00 18 
104be     00 1C 18 18 | 	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
104c2     3C 00 00 60 
104c6     00 60 60 60 
104ca     60 3C 00 06 
104ce     06 36 1E 36 | 	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
104d2     66 00 00 1C 
104d6     18 18 18 18 
104da     3C 00 00 00 
104de     66 FE FE D6 | 	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
104e2     C6 00 00 00 
104e6     3E 66 66 66 
104ea     66 00 00 00 
104ee     3C 66 66 66 | 	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
104f2     3C 00 00 00 
104f6     3E 66 66 3E 
104fa     06 06 00 00 
104fe     7C 66 66 7C | 	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
10502     60 60 00 00 
10506     3E 66 06 06 
1050a     06 00 00 00 
1050e     7C 06 3C 60 | 	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
10512     3E 00 00 18 
10516     7E 18 18 18 
1051a     70 00 00 00 
1051e     66 66 66 66 | 	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
10522     7C 00 00 00 
10526     66 66 66 3C 
1052a     18 00 00 00 
1052e     C6 D6 FE 7C | 	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
10532     6C 00 00 00 
10536     66 3C 18 3C 
1053a     66 00 00 00 
1053e     66 66 66 7C | 	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
10542     30 1E 00 00 
10546     7E 30 18 0C 
1054a     7E 00 00 18 
1054e     3C 7E 7E 18 | 	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
10552     3C 00 18 18 
10556     18 18 18 18 
1055a     18 18 00 7E 
1055e     1E 3E 76 66 | 	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
10562     60 00 10 18 
10566     1C 1E 1C 18 
1056a     10 00 08 18 
1056e     38 78 38 18 | 	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
10572     08 00       | 	byte	$08, $00
10574     00 6C FE FE 
10578     7C 38 10 00 
1057c     18 18 18 F8 
10580     F8 18 18 18 | a8_font2       file "atari8.fnt"
10584     C0 C0 C0 C0 
10588     C0 C0 C0 C0 | 	byte	$c0[8]
1058c     18 18 18 1F 
10590     1F 00 00 00 
10594     18 18 18 1F 
10598     1F 18 18 18 | 	byte	$18, $18, $18, $1f, $1f, $00, $00, $00, $18, $18, $18, $1f, $1f, $18, $18, $18
1059c     00 00 00 1F 
105a0     1F 18 18 18 
105a4     C0 E0 70 38 
105a8     1C 0E 07 03 | 	byte	$00, $00, $00, $1f, $1f, $18, $18, $18, $c0, $e0, $70, $38, $1c, $0e, $07, $03
105ac     03 07 0E 1C 
105b0     38 70 E0 C0 
105b4     80 C0 E0 F0 
105b8     F8 FC FE FF | 	byte	$03, $07, $0e, $1c, $38, $70, $e0, $c0, $80, $c0, $e0, $f0, $f8, $fc, $fe, $ff
105bc     00 00 00 00 
105c0     F0 F0 F0 F0 
105c4     01 03 07 0F 
105c8     1F 3F 7F FF | 	byte	$00, $00, $00, $00, $f0, $f0, $f0, $f0, $01, $03, $07, $0f, $1f, $3f, $7f, $ff
105cc     F0 F0 F0 F0 
105d0     00 00 00 00 
105d4     0F 0F 0F 0F 
105d8     00 00 00 00 | 	byte	$f0, $f0, $f0, $f0, $00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $00, $00, $00
105dc     FF FF 00 00 
105e0     00 00 00 00 
105e4     00 00 00 00 
105e8     00 00 FF FF | 	byte	$ff, $ff, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $ff, $ff
105ec     00 00 00 00 
105f0     0F 0F 0F 0F 
105f4     00 38 38 EE 
105f8     EE 10 38 00 | 	byte	$00, $00, $00, $00, $0f, $0f, $0f, $0f, $00, $38, $38, $ee, $ee, $10, $38, $00
105fc     00 00 00 F8 
10600     F8 18 18 18 
10604     00 00 00 FF 
10608     FF 00 00 00 | 	byte	$00, $00, $00, $f8, $f8, $18, $18, $18, $00, $00, $00, $ff, $ff, $00, $00, $00
1060c     18 18 18 FF 
10610     FF 18 18 18 
10614     00 00 3C 7E 
10618     7E 7E 3C 00 | 	byte	$18, $18, $18, $ff, $ff, $18, $18, $18, $00, $00, $3c, $7e, $7e, $7e, $3c, $00
1061c     00 00 00 00 
10620     FF FF FF FF 
10624     03 03 03 03 
10628     03 03 03 03 | 	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $03, $03, $03, $03, $03, $03, $03, $03
1062c     00 00 00 FF 
10630     FF 18 18 18 
10634     18 18 18 FF 
10638     FF 00 00 00 | 	byte	$00, $00, $00, $ff, $ff, $18, $18, $18, $18, $18, $18, $ff, $ff, $00, $00, $00
1063c     0F 0F 0F 0F 
10640     0F 0F 0F 0F | 	byte	$0f[8]
10644     18 18 18 F8 
10648     F8 00 00 00 
1064c     1E 06 1E 06 
10650     7E 18 78 00 | 	byte	$18, $18, $18, $f8, $f8, $00, $00, $00, $1e, $06, $1e, $06, $7e, $18, $78, $00
10654     00 18 3C 7E 
10658     18 18 18 00 
1065c     00 18 18 18 
10660     7E 3C 18 00 | 	byte	$00, $18, $3c, $7e, $18, $18, $18, $00, $00, $18, $18, $18, $7e, $3c, $18, $00
10664     00 18 0C 7E 
10668     0C 18 00 00 
1066c     00 18 30 7E 
10670     30 18 00 00 | 	byte	$00, $18, $0c, $7e, $0c, $18, $00, $00, $00, $18, $30, $7e, $30, $18, $00, $00
10674     00 00 00 00 
10678     00 00 00 00 
1067c     00          | 	byte	$00[9]
1067d     18 18 18 18 
10681     00 18 00 00 
10685     66 66 66 00 
10689     00 00 00 00 | 	byte	$18, $18, $18, $18, $00, $18, $00, $00, $66, $66, $66, $00, $00, $00, $00, $00
1068d     66 FF 66 66 
10691     FF 66 00 18 
10695     7C 06 3C 60 
10699     3E 18 00 00 | 	byte	$66, $ff, $66, $66, $ff, $66, $00, $18, $7c, $06, $3c, $60, $3e, $18, $00, $00
1069d     66 36 18 0C 
106a1     66 62 00 38 
106a5     6C 38 1C F6 
106a9     66 DC 00 00 | 	byte	$66, $36, $18, $0c, $66, $62, $00, $38, $6c, $38, $1c, $f6, $66, $dc, $00, $00
106ad     18 18 18 00 
106b1     00 00 00 00 
106b5     70 38 18 18 
106b9     38 70 00 00 | 	byte	$18, $18, $18, $00, $00, $00, $00, $00, $70, $38, $18, $18, $38, $70, $00, $00
106bd     0E 1C 18 18 
106c1     1C 0E 00 00 
106c5     66 3C FF 3C 
106c9     66 00 00 00 | 	byte	$0e, $1c, $18, $18, $1c, $0e, $00, $00, $66, $3c, $ff, $3c, $66, $00, $00, $00
106cd     18 18 7E 18 
106d1     18 00 00 00 
106d5     00 00 00 00 
106d9     18 18 0C 00 | 	byte	$18, $18, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $18, $18, $0c, $00
106dd     00 00 7E 00 
106e1     00 00 00 00 
106e5     00 00 00 00 
106e9     18 18 00 00 | 	byte	$00, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00
106ed     60 30 18 0C 
106f1     06 02 00 00 
106f5     3C 66 76 6E 
106f9     66 3C 00 00 | 	byte	$60, $30, $18, $0c, $06, $02, $00, $00, $3c, $66, $76, $6e, $66, $3c, $00, $00
106fd     18 1C 18 18 
10701     18 7E 00 00 
10705     3C 66 30 18 
10709     0C 7E 00 00 | 	byte	$18, $1c, $18, $18, $18, $7e, $00, $00, $3c, $66, $30, $18, $0c, $7e, $00, $00
1070d     7E 30 18 30 
10711     66 3C 00 00 
10715     30 38 3C 36 
10719     7E 30 00 00 | 	byte	$7e, $30, $18, $30, $66, $3c, $00, $00, $30, $38, $3c, $36, $7e, $30, $00, $00
1071d     7E 06 3E 60 
10721     66 3C 00 00 
10725     3C 06 3E 66 
10729     66 3C 00 00 | 	byte	$7e, $06, $3e, $60, $66, $3c, $00, $00, $3c, $06, $3e, $66, $66, $3c, $00, $00
1072d     7E 60 30 18 
10731     0C 0C 00 00 
10735     3C 66 3C 66 
10739     66 3C 00 00 | 	byte	$7e, $60, $30, $18, $0c, $0c, $00, $00, $3c, $66, $3c, $66, $66, $3c, $00, $00
1073d     3C 66 7C 60 
10741     30 1C 00 00 
10745     00 18 18 00 
10749     18 18 00 00 | 	byte	$3c, $66, $7c, $60, $30, $1c, $00, $00, $00, $18, $18, $00, $18, $18, $00, $00
1074d     00 18 18 00 
10751     18 18 0C 60 
10755     30 18 0C 18 
10759     30 60 00 00 | 	byte	$00, $18, $18, $00, $18, $18, $0c, $60, $30, $18, $0c, $18, $30, $60, $00, $00
1075d     00 7E 00 00 
10761     7E 00 00 06 
10765     0C 18 30 18 
10769     0C 06 00 00 | 	byte	$00, $7e, $00, $00, $7e, $00, $00, $06, $0c, $18, $30, $18, $0c, $06, $00, $00
1076d     3C 66 30 18 
10771     00 18 00 00 
10775     3C 66 76 76 
10779     06 7C 00 00 | 	byte	$3c, $66, $30, $18, $00, $18, $00, $00, $3c, $66, $76, $76, $06, $7c, $00, $00
1077d     18 3C 66 66 
10781     7E 66 00 00 
10785     3E 66 3E 66 
10789     66 3E 00 00 | 	byte	$18, $3c, $66, $66, $7e, $66, $00, $00, $3e, $66, $3e, $66, $66, $3e, $00, $00
1078d     3C 66 06 06 
10791     66 3C 00 00 
10795     1E 36 66 66 
10799     36 1E 00 00 | 	byte	$3c, $66, $06, $06, $66, $3c, $00, $00, $1e, $36, $66, $66, $36, $1e, $00, $00
1079d     7E 06 3E 06 
107a1     06 7E 00 00 
107a5     7E 06 3E 06 
107a9     06 06 00 00 | 	byte	$7e, $06, $3e, $06, $06, $7e, $00, $00, $7e, $06, $3e, $06, $06, $06, $00, $00
107ad     7C 06 06 76 
107b1     66 7C 00 00 
107b5     66 66 7E 66 
107b9     66 66 00 00 | 	byte	$7c, $06, $06, $76, $66, $7c, $00, $00, $66, $66, $7e, $66, $66, $66, $00, $00
107bd     7E 18 18 18 
107c1     18 7E 00 00 
107c5     60 60 60 60 
107c9     66 3C 00 00 | 	byte	$7e, $18, $18, $18, $18, $7e, $00, $00, $60, $60, $60, $60, $66, $3c, $00, $00
107cd     66 36 1E 1E 
107d1     36 66 00 00 
107d5     06 06 06 06 
107d9     06 7E 00 00 | 	byte	$66, $36, $1e, $1e, $36, $66, $00, $00, $06, $06, $06, $06, $06, $7e, $00, $00
107dd     C6 EE FE D6 
107e1     C6 C6 00 00 
107e5     66 6E 7E 7E 
107e9     76 66 00 00 | 	byte	$c6, $ee, $fe, $d6, $c6, $c6, $00, $00, $66, $6e, $7e, $7e, $76, $66, $00, $00
107ed     3C 66 66 66 
107f1     66 3C 00 00 
107f5     3E 66 66 3E 
107f9     06 06 00 00 | 	byte	$3c, $66, $66, $66, $66, $3c, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00
107fd     3C 66 66 66 
10801     36 6C 00 00 
10805     3E 66 66 3E 
10809     36 66 00 00 | 	byte	$3c, $66, $66, $66, $36, $6c, $00, $00, $3e, $66, $66, $3e, $36, $66, $00, $00
1080d     3C 06 3C 60 
10811     60 3C 00 00 
10815     7E 18 18 18 
10819     18 18 00 00 | 	byte	$3c, $06, $3c, $60, $60, $3c, $00, $00, $7e, $18, $18, $18, $18, $18, $00, $00
1081d     66 66 66 66 
10821     66          | 	byte	$66[5]
10822     7E 00 00 66 
10826     66 66 66 3C 
1082a     18 00 00 C6 
1082e     C6 D6 FE EE | 	byte	$7e, $00, $00, $66, $66, $66, $66, $3c, $18, $00, $00, $c6, $c6, $d6, $fe, $ee
10832     C6 00 00 66 
10836     66 3C 3C 66 
1083a     66 00 00 66 
1083e     66 3C 18 18 | 	byte	$c6, $00, $00, $66, $66, $3c, $3c, $66, $66, $00, $00, $66, $66, $3c, $18, $18
10842     18 00 00 7E 
10846     30 18 0C 06 
1084a     7E 00 00 78 
1084e     18 18 18 18 | 	byte	$18, $00, $00, $7e, $30, $18, $0c, $06, $7e, $00, $00, $78, $18, $18, $18, $18
10852     78 00 00 02 
10856     06 0C 18 30 
1085a     60 00 00 1E 
1085e     18 18 18 18 | 	byte	$78, $00, $00, $02, $06, $0c, $18, $30, $60, $00, $00, $1e, $18, $18, $18, $18
10862     1E 00 00 10 
10866     38 6C C6 00 
1086a     00 00 00 00 
1086e     00 00 00 00 | 	byte	$1e, $00, $00, $10, $38, $6c, $c6, $00, $00, $00, $00, $00, $00, $00, $00, $00
10872     FF 00 00 18 
10876     3C 7E 7E 3C 
1087a     18 00 00 00 
1087e     3C 60 7C 66 | 	byte	$ff, $00, $00, $18, $3c, $7e, $7e, $3c, $18, $00, $00, $00, $3c, $60, $7c, $66
10882     7C 00 00 06 
10886     06 3E 66 66 
1088a     3E 00 00 00 
1088e     3C 06 06 06 | 	byte	$7c, $00, $00, $06, $06, $3e, $66, $66, $3e, $00, $00, $00, $3c, $06, $06, $06
10892     3C 00 00 60 
10896     60 7C 66 66 
1089a     7C 00 00 00 
1089e     3C 66 7E 06 | 	byte	$3c, $00, $00, $60, $60, $7c, $66, $66, $7c, $00, $00, $00, $3c, $66, $7e, $06
108a2     3C 00 00 70 
108a6     18 7C 18 18 
108aa     18 00 00 00 
108ae     7C 66 66 7C | 	byte	$3c, $00, $00, $70, $18, $7c, $18, $18, $18, $00, $00, $00, $7c, $66, $66, $7c
108b2     60 3E 00 06 
108b6     06 3E 66 66 
108ba     66 00 00 18 
108be     00 1C 18 18 | 	byte	$60, $3e, $00, $06, $06, $3e, $66, $66, $66, $00, $00, $18, $00, $1c, $18, $18
108c2     3C 00 00 60 
108c6     00 60 60 60 
108ca     60 3C 00 06 
108ce     06 36 1E 36 | 	byte	$3c, $00, $00, $60, $00, $60, $60, $60, $60, $3c, $00, $06, $06, $36, $1e, $36
108d2     66 00 00 1C 
108d6     18 18 18 18 
108da     3C 00 00 00 
108de     66 FE FE D6 | 	byte	$66, $00, $00, $1c, $18, $18, $18, $18, $3c, $00, $00, $00, $66, $fe, $fe, $d6
108e2     C6 00 00 00 
108e6     3E 66 66 66 
108ea     66 00 00 00 
108ee     3C 66 66 66 | 	byte	$c6, $00, $00, $00, $3e, $66, $66, $66, $66, $00, $00, $00, $3c, $66, $66, $66
108f2     3C 00 00 00 
108f6     3E 66 66 3E 
108fa     06 06 00 00 
108fe     7C 66 66 7C | 	byte	$3c, $00, $00, $00, $3e, $66, $66, $3e, $06, $06, $00, $00, $7c, $66, $66, $7c
10902     60 60 00 00 
10906     3E 66 06 06 
1090a     06 00 00 00 
1090e     7C 06 3C 60 | 	byte	$60, $60, $00, $00, $3e, $66, $06, $06, $06, $00, $00, $00, $7c, $06, $3c, $60
10912     3E 00 00 18 
10916     7E 18 18 18 
1091a     70 00 00 00 
1091e     66 66 66 66 | 	byte	$3e, $00, $00, $18, $7e, $18, $18, $18, $70, $00, $00, $00, $66, $66, $66, $66
10922     7C 00 00 00 
10926     66 66 66 3C 
1092a     18 00 00 00 
1092e     C6 D6 FE 7C | 	byte	$7c, $00, $00, $00, $66, $66, $66, $3c, $18, $00, $00, $00, $c6, $d6, $fe, $7c
10932     6C 00 00 00 
10936     66 3C 18 3C 
1093a     66 00 00 00 
1093e     66 66 66 7C | 	byte	$6c, $00, $00, $00, $66, $3c, $18, $3c, $66, $00, $00, $00, $66, $66, $66, $7c
10942     30 1E 00 00 
10946     7E 30 18 0C 
1094a     7E 00 00 18 
1094e     3C 7E 7E 18 | 	byte	$30, $1e, $00, $00, $7e, $30, $18, $0c, $7e, $00, $00, $18, $3c, $7e, $7e, $18
10952     3C 00 18 18 
10956     18 18 18 18 
1095a     18 18 00 7E 
1095e     1E 3E 76 66 | 	byte	$3c, $00, $18, $18, $18, $18, $18, $18, $18, $18, $00, $7e, $1e, $3e, $76, $66
10962     60 00 10 18 
10966     1C 1E 1C 18 
1096a     10 00 08 18 
1096e     38 78 38 18 | 	byte	$60, $00, $10, $18, $1c, $1e, $1c, $18, $10, $00, $08, $18, $38, $78, $38, $18
10972     08 00       | 	byte	$08, $00
10974     00 00 00 00 
      ...             
10b80     00 00 00 00 
10b84     00 00       | amiga_font     file "amigafont.def"
10b86     18 18 18 18 
10b8a     18 18       | 	byte	$18[6]
10b8c     00 18 18 00 
10b90     00 00 00 00 
10b94     00 00 66 66 
10b98     66 00 00 00 | 	byte	$00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $00, $00, $00
10b9c     00 00 00 00 
10ba0     00 00 00 00 
10ba4     00 00       | 	byte	$00[10]
10ba6     36 36 7F 36 
10baa     36 36 7F 36 
10bae     36 00 00 00 
10bb2     00 00 00 00 | 	byte	$36, $36, $7f, $36, $36, $36, $7f, $36, $36, $00, $00, $00, $00, $00, $00, $00
10bb6     18 7C 06 06 
10bba     3C 60 60 3E 
10bbe     18 00 00 00 
10bc2     00 00 00 00 | 	byte	$18, $7c, $06, $06, $3c, $60, $60, $3e, $18, $00, $00, $00, $00, $00, $00, $00
10bc6     00 00 C6 69 
10bca     36 18 6C 96 
10bce     63 00 00 00 
10bd2     00 00 00 00 | 	byte	$00, $00, $c6, $69, $36, $18, $6c, $96, $63, $00, $00, $00, $00, $00, $00, $00
10bd6     1C 36 36 1E 
10bda     6E 3B 33 73 
10bde     DE 00 00 00 
10be2     00 00 00 00 | 	byte	$1c, $36, $36, $1e, $6e, $3b, $33, $73, $de, $00, $00, $00, $00, $00, $00, $00
10be6     18 18 0C 00 
10bea     00 00 00 00 
10bee     00 00 00 00 
10bf2     00 00 00 00 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10bf6     30 18 0C 0C 
10bfa     0C 0C 0C 18 
10bfe     30 00 00 00 
10c02     00 00 00 00 | 	byte	$30, $18, $0c, $0c, $0c, $0c, $0c, $18, $30, $00, $00, $00, $00, $00, $00, $00
10c06     0C 18 30 30 
10c0a     30 30 30 18 
10c0e     0C 00 00 00 
10c12     00 00 00 00 | 	byte	$0c, $18, $30, $30, $30, $30, $30, $18, $0c, $00, $00, $00, $00, $00, $00, $00
10c16     00 66 66 3C 
10c1a     FF 3C 66 66 
10c1e     00 00 00 00 
10c22     00 00 00 00 | 	byte	$00, $66, $66, $3c, $ff, $3c, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00
10c26     00 18 18 18 
10c2a     7E 18 18 18 
10c2e     00 00 00 00 
10c32     00 00 00 00 | 	byte	$00, $18, $18, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
10c36     00 00 00 00 
10c3a     00 00 00    | 	byte	$00[7]
10c3d     18 18 0C 00 
10c41     00 00 00 00 
10c45     00 00 00 00 
10c49     00 7E 00 00 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $00, $00
10c4d     00 00 00 00 
10c51     00 00 00 00 
10c55     00 00 00 00 
10c59     00 00 00 00 | 	byte	$00[16]
10c5d     18 18 00 00 
10c61     00 00 00 00 
10c65     00 00 C0 60 
10c69     30 18 0C 06 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $c0, $60, $30, $18, $0c, $06
10c6d     03 00 00 00 
10c71     00 00 00 00 
10c75     00 3C 66 66 
10c79     76 7E 6E 66 | 	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $76, $7e, $6e, $66
10c7d     66 3C 00 00 
10c81     00 00 00 00 
10c85     00 18 1C 1E 
10c89     18 18 18 18 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $18, $1c, $1e, $18, $18, $18, $18
10c8d     18 18 00 00 
10c91     00 00 00 00 
10c95     00 3C 66 60 
10c99     60 30 18 0C | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $30, $18, $0c
10c9d     06 7E 00 00 
10ca1     00 00 00 00 
10ca5     00 3C 66 60 
10ca9     60 38 60 60 | 	byte	$06, $7e, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60, $60, $38, $60, $60
10cad     66 3C 00 00 
10cb1     00 00 00 00 
10cb5     00 30 38 3C 
10cb9     36 33 7F 30 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $30, $38, $3c, $36, $33, $7f, $30
10cbd     30 30 00 00 
10cc1     00 00 00 00 
10cc5     00 7E 06 06 
10cc9     3E 60 60 60 | 	byte	$30, $30, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06, $3e, $60, $60, $60
10ccd     66 3C 00 00 
10cd1     00 00 00 00 
10cd5     00 38 0C 06 
10cd9     06 3E 66 66 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $06, $06, $3e, $66, $66
10cdd     66 3C 00 00 
10ce1     00 00 00 00 
10ce5     00 7E 60 60 
10ce9     60 30 18 18 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $7e, $60, $60, $60, $30, $18, $18
10ced     18 18 00 00 
10cf1     00 00 00 00 
10cf5     00 3C 66 66 
10cf9     66 3C 66 66 | 	byte	$18, $18, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $3c, $66, $66
10cfd     66 3C 00 00 
10d01     00 00 00 00 
10d05     00 3C 66 66 
10d09     66 7C 60 60 | 	byte	$66, $3c, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $7c, $60, $60
10d0d     30 1C 00 00 
10d11     00 00 00 00 
10d15     00 00 00 18 
10d19     18 00 00 18 | 	byte	$30, $1c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $18
10d1d     18 00 00 00 
10d21     00 00 00 00 
10d25     00 00 00 18 
10d29     18 00 00 00 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $18, $18, $00, $00, $00
10d2d     18 18 0C 00 
10d31     00 00 00 00 
10d35     00 00 00 60 
10d39     18 06 18 60 | 	byte	$18, $18, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $60, $18, $06, $18, $60
10d3d     00 00 00 00 
10d41     00 00 00 00 
10d45     00 00 00 00 | 	byte	$00[12]
10d49     7E 00 7E 00 
10d4d     00 00 00 00 
10d51     00 00 00 00 
10d55     00 00 00 06 | 	byte	$7e, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06
10d59     18 60 18 06 
10d5d     00 00 00 00 
10d61     00 00 00 00 
10d65     00 3C 66 60 | 	byte	$18, $60, $18, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $60
10d69     60 30 18 00 
10d6d     18 18 00 00 
10d71     00 00 00 00 
10d75     00 3E 63 63 | 	byte	$60, $30, $18, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
10d79     7B 6B 7B 03 
10d7d     03 1E 00 00 
10d81     00 00 00 00 
10d85     00 3E 63 63 | 	byte	$7b, $6b, $7b, $03, $03, $1e, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63
10d89     63 7F 63 63 
10d8d     63 63 00 00 
10d91     00 00 00 00 
10d95     00 3E 66 66 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66
10d99     66 3E 66 66 
10d9d     66 3E 00 00 
10da1     00 00 00 00 
10da5     00 78 0C 06 | 	byte	$66, $3e, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $78, $0c, $06
10da9     06 06 06 06 
10dad     0C 78 00 00 
10db1     00 00 00 00 
10db5     00 1F 33 63 | 	byte	$06, $06, $06, $06, $0c, $78, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $63
10db9     63 63 63 63 
10dbd     33 1F 00 00 
10dc1     00 00 00 00 
10dc5     00 7E 06 06 | 	byte	$63, $63, $63, $63, $33, $1f, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
10dc9     06 1E 06 06 
10dcd     06 7E 00 00 
10dd1     00 00 00 00 
10dd5     00 7E 06 06 | 	byte	$06, $1e, $06, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00, $7e, $06, $06
10dd9     06 1E 06 06 
10ddd     06 06 00 00 
10de1     00 00 00 00 
10de5     00 3C 66 06 | 	byte	$06, $1e, $06, $06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06
10de9     06 76 66 66 
10ded     66 7C 00 00 
10df1     00 00 00 00 
10df5     00 63 63 63 | 	byte	$06, $76, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63
10df9     63 7F 63 63 
10dfd     63 63 00 00 
10e01     00 00 00 00 
10e05     00 3C 18 18 | 	byte	$63, $7f, $63, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00, $3c, $18, $18
10e09     18 18 18 18 
10e0d     18          | 	byte	$18[5]
10e0e     3C 00 00 00 
10e12     00 00 00 00 
10e16     60 60 60 60 
10e1a     60 60 60 63 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60, $60, $60, $60, $60, $63
10e1e     3E 00 00 00 
10e22     00 00 00 00 
10e26     C3 63 33 1B 
10e2a     0F 1B 33 63 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $c3, $63, $33, $1b, $0f, $1b, $33, $63
10e2e     C3 00 00 00 
10e32     00 00 00 00 
10e36     03 03 03 03 
10e3a     03 03 03 03 | 	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $03, $03, $03, $03, $03, $03, $03, $03
10e3e     7F 00 00 00 
10e42     00 00 00 00 
10e46     63 77 7F 6B 
10e4a     63 63 63 63 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $63, $77, $7f, $6b, $63, $63, $63, $63
10e4e     63 00 00 00 
10e52     00 00 00 00 
10e56     63 67 6F 7B 
10e5a     73 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $63, $67, $6f, $7b, $73, $63, $63, $63
10e5e     63 00 00 00 
10e62     00 00 00 00 
10e66     3E 63 63 63 
10e6a     63 63 63 63 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $63
10e6e     3E 00 00 00 
10e72     00 00 00 00 
10e76     3E 66 66 66 
10e7a     3E 06 06 06 | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e, $06, $06, $06
10e7e     06 00 00 00 
10e82     00 00 00 00 
10e86     3E 63 63 63 
10e8a     63 63 63 7B | 	byte	$06, $00, $00, $00, $00, $00, $00, $00, $3e, $63, $63, $63, $63, $63, $63, $7b
10e8e     FE 00 00 00 
10e92     00 00 00 00 
10e96     1F 33 33 33 
10e9a     1F 1B 33 63 | 	byte	$fe, $00, $00, $00, $00, $00, $00, $00, $1f, $33, $33, $33, $1f, $1b, $33, $63
10e9e     63 00 00 00 
10ea2     00 00 00 00 
10ea6     3C 66 06 0C 
10eaa     18 30 60 66 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $06, $0c, $18, $30, $60, $66
10eae     3C 00 00 00 
10eb2     00 00 00 00 
10eb6     7E 18 18 18 
10eba     18 18 18 18 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $7e, $18, $18, $18, $18, $18, $18, $18
10ebe     18 00 00 00 
10ec2     00 00 00 00 
10ec6     63 63 63 63 
10eca     63 63 63 63 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $63, $63, $63
10ece     3E 00 00 00 
10ed2     00 00 00 00 
10ed6     63 63 63 63 
10eda     63 36 36 1C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $63, $63, $36, $36, $1c
10ede     08 00 00 00 
10ee2     00 00 00 00 
10ee6     C3 C3 C3 C3 
10eea     C3 DB FF E7 | 	byte	$08, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $c3, $c3, $c3, $db, $ff, $e7
10eee     C3 00 00 00 
10ef2     00 00 00 00 
10ef6     C3 C3 66 3C 
10efa     18 3C 66 C3 | 	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $3c, $66, $c3
10efe     C3 00 00 00 
10f02     00 00 00 00 
10f06     C3 C3 66 3C 
10f0a     18 18 18 18 | 	byte	$c3, $00, $00, $00, $00, $00, $00, $00, $c3, $c3, $66, $3c, $18, $18, $18, $18
10f0e     18 00 00 00 
10f12     00 00 00 00 
10f16     7F 60 60 30 
10f1a     18 0C 06 03 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $7f, $60, $60, $30, $18, $0c, $06, $03
10f1e     7F 00 00 00 
10f22     00 00 00 00 
10f26     3C 0C 0C 0C 
10f2a     0C 0C 0C 0C | 	byte	$7f, $00, $00, $00, $00, $00, $00, $00, $3c, $0c, $0c, $0c, $0c, $0c, $0c, $0c
10f2e     3C 00 00 00 
10f32     00 00 00 00 
10f36     00 03 06 0C 
10f3a     18 30 60 C0 | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $03, $06, $0c, $18, $30, $60, $c0
10f3e     00 00 00 00 
10f42     00 00 00 00 | 	byte	$00[8]
10f46     3C 30 30 30 
10f4a     30 30 30 30 
10f4e     3C 00 00 00 
10f52     00 00 00 00 | 	byte	$3c, $30, $30, $30, $30, $30, $30, $30, $3c, $00, $00, $00, $00, $00, $00, $00
10f56     08 1C 36 63 
10f5a     00 00 00 00 
10f5e     00 00 00 00 
10f62     00 00 00 00 | 	byte	$08, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10f66     00 00 00 00 
10f6a     00 00 00 00 
10f6e     00          | 	byte	$00[9]
10f6f     7F 00 00 00 
10f73     00 00 00 18 
10f77     18 30 00 00 
10f7b     00 00 00 00 | 	byte	$7f, $00, $00, $00, $00, $00, $00, $18, $18, $30, $00, $00, $00, $00, $00, $00
10f7f     00 00 00 00 
10f83     00 00 00 00 
10f87     00 00       | 	byte	$00[10]
10f89     3C 60 7C 66 
10f8d     66 7C 00 00 
10f91     00 00 00 00 
10f95     00 06 06 06 | 	byte	$3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $06, $06, $06
10f99     3E 66 66 66 
10f9d     66 3E 00 00 
10fa1     00 00 00 00 
10fa5     00 00 00 00 | 	byte	$3e, $66, $66, $66, $66, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10fa9     3C 06 06 06 
10fad     06 3C 00 00 
10fb1     00 00 00 00 
10fb5     00 60 60 60 | 	byte	$3c, $06, $06, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $60, $60, $60
10fb9     7C 66 66 66 
10fbd     66 7C 00 00 
10fc1     00 00 00 00 
10fc5     00 00 00 00 | 	byte	$7c, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10fc9     3C 66 7E 06 
10fcd     06 3C 00 00 
10fd1     00 00 00 00 
10fd5     00 38 0C 0C | 	byte	$3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00, $38, $0c, $0c
10fd9     3E 0C 0C 0C 
10fdd     0C 0C 00 00 
10fe1     00 00 00 00 
10fe5     00 00 00 00 | 	byte	$3e, $0c, $0c, $0c, $0c, $0c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
10fe9     7C 66 66 66 
10fed     7C 60 60 3C 
10ff1     00 00 00 00 
10ff5     00 06 06 06 | 	byte	$7c, $66, $66, $66, $7c, $60, $60, $3c, $00, $00, $00, $00, $00, $06, $06, $06
10ff9     3E 66 66 66 
10ffd     66 66 00 00 
11001     00 00 00 00 
11005     00 00 18 00 | 	byte	$3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $18, $00
11009     18 18 18 18 
1100d     18          | 	byte	$18[5]
1100e     30 00 00 00 
11012     00 00 00 00 
11016     00 30 00 30 
1101a     30 30 30 30 | 	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $30, $00, $30, $30, $30, $30, $30
1101e     30 30 1E 00 
11022     00 00 00 00 
11026     03 03 03 33 
1102a     1B 0F 1B 33 | 	byte	$30, $30, $1e, $00, $00, $00, $00, $00, $03, $03, $03, $33, $1b, $0f, $1b, $33
1102e     63 00 00 00 
11032     00 00 00 00 
11036     18 18 18 18 
1103a     18 18 18 18 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
1103e     30 00 00 00 
11042     00 00 00 00 
11046     00 00 00 37 
1104a     7F 6B 63 63 | 	byte	$30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $37, $7f, $6b, $63, $63
1104e     63 00 00 00 
11052     00 00 00 00 
11056     00 00 00 3E 
1105a     66 66 66 66 | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $66
1105e     66 00 00 00 
11062     00 00 00 00 
11066     00 00 00 3C 
1106a     66 66 66 66 | 	byte	$66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $66, $66, $66, $66
1106e     3C 00 00 00 
11072     00 00 00 00 
11076     00 00 00 3E 
1107a     66 66 66 3E | 	byte	$3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $66, $66, $3e
1107e     06 06 06 00 
11082     00 00 00 00 
11086     00 00 00 7C 
1108a     66 66 66 7C | 	byte	$06, $06, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7c, $66, $66, $66, $7c
1108e     60 60 60 00 
11092     00 00 00 00 
11096     00 00 00 3E 
1109a     66 06 06 06 | 	byte	$60, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $3e, $66, $06, $06, $06
1109e     06 00 00 00 
110a2     00 00 00 00 
110a6     00 00 00 3C 
110aa     06 0C 30 60 | 	byte	$06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $3c, $06, $0c, $30, $60
110ae     3E 00 00 00 
110b2     00 00 00 00 
110b6     00 0C 0C 3E 
110ba     0C 0C 0C 0C | 	byte	$3e, $00, $00, $00, $00, $00, $00, $00, $00, $0c, $0c, $3e, $0c, $0c, $0c, $0c
110be     38 00 00 00 
110c2     00 00 00 00 
110c6     00 00 00 66 
110ca     66 66 66 66 | 	byte	$38, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $66
110ce     7C 00 00 00 
110d2     00 00 00 00 
110d6     00 00 00 66 
110da     66 66 66 3C | 	byte	$7c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
110de     18 00 00 00 
110e2     00 00 00 00 
110e6     00 00 00 63 
110ea     63 63 6B 3E | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $63, $63, $6b, $3e
110ee     36 00 00 00 
110f2     00 00 00 00 
110f6     00 00 00 63 
110fa     36 1C 1C 36 | 	byte	$36, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $63, $36, $1c, $1c, $36
110fe     63 00 00 00 
11102     00 00 00 00 
11106     00 00 00 66 
1110a     66 66 66 3C | 	byte	$63, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $66, $66, $66, $66, $3c
1110e     18 0C 06 00 
11112     00 00 00 00 
11116     00 00 00 7E 
1111a     30 18 0C 06 | 	byte	$18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $7e, $30, $18, $0c, $06
1111e     7E 00 00 00 
11122     00 00 00 00 
11126     70 18 18 18 
1112a     0E 18 18 18 | 	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $70, $18, $18, $18, $0e, $18, $18, $18
1112e     70 00 00 00 
11132     00 00 00 00 
11136     18 18 18 18 
1113a     18 18 18 18 | 	byte	$70, $00, $00, $00, $00, $00, $00, $00, $18, $18, $18, $18, $18, $18, $18, $18
1113e     18 00 00 00 
11142     00 00 00 00 
11146     0E 18 18 18 
1114a     70 18 18 18 | 	byte	$18, $00, $00, $00, $00, $00, $00, $00, $0e, $18, $18, $18, $70, $18, $18, $18
1114e     0E 00 00 00 
11152     00 00 00 00 
11156     46 5D 31 00 
1115a     00 00 00 00 | 	byte	$0e, $00, $00, $00, $00, $00, $00, $00, $46, $5d, $31, $00, $00, $00, $00, $00
1115e     00 00 00 00 
11162     00 00 00 00 | 	byte	$00[8]
11166     C0 F0 3C 0F 
1116a     C3 F0 3C 0F 
1116e     03 00 00 00 
11172     00 00 00 00 | 	byte	$c0, $f0, $3c, $0f, $c3, $f0, $3c, $0f, $03, $00, $00, $00, $00, $00, $00, $00
11176     18 18 00 18 
1117a     18 18 18 18 
1117e     18 00 00 00 
11182     00 00 00 00 | 	byte	$18, $18, $00, $18, $18, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
11186     18 18 7E 1B 
1118a     1B 7E 18 18 
1118e     00 00 00 00 
11192     00 00 00 00 | 	byte	$18, $18, $7e, $1b, $1b, $7e, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
11196     78 CC 0C 0C 
1119a     1E 0C 0C 06 
1119e     7F 00 00 00 
111a2     00 00 00 00 | 	byte	$78, $cc, $0c, $0c, $1e, $0c, $0c, $06, $7f, $00, $00, $00, $00, $00, $00, $00
111a6     66 3C 66 66 
111aa     3C 66 00 00 
111ae     00 00 00 00 
111b2     00 00 00 00 | 	byte	$66, $3c, $66, $66, $3c, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
111b6     C3 C3 66 3C 
111ba     18 7E 18 18 
111be     18 00 00 00 
111c2     00 00 00 00 | 	byte	$c3, $c3, $66, $3c, $18, $7e, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
111c6     18 18 18 18 
111ca     00 18 18 18 
111ce     18 00 00 00 
111d2     00 00 00 00 | 	byte	$18, $18, $18, $18, $00, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
111d6     3C 06 06 3C 
111da     66 66 66 3C 
111de     60 60 3C 00 
111e2     00 00 00 00 | 	byte	$3c, $06, $06, $3c, $66, $66, $66, $3c, $60, $60, $3c, $00, $00, $00, $00, $00
111e6     66 66 00 00 
111ea     00 00 00 00 
111ee     00 00 00 00 
111f2     00 00 00 00 | 	byte	$66, $66, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
111f6     7E 81 B9 85 
111fa     85 B9 81 7E 
111fe     00 00 00 00 
11202     00 00 00 00 | 	byte	$7e, $81, $b9, $85, $85, $b9, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
11206     3C 33 33 7E 
1120a     00 7F 00 00 
1120e     00 00 00 00 
11212     00 00 00 00 | 	byte	$3c, $33, $33, $7e, $00, $7f, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
11216     00 00 CC 66 
1121a     33 66 CC 00 
1121e     00 00 00 00 
11222     00 00 00 00 | 	byte	$00, $00, $cc, $66, $33, $66, $cc, $00, $00, $00, $00, $00, $00, $00, $00, $00
11226     7E 60 60 00 
1122a     00 00 00 00 
1122e     00 00 00 00 
11232     00 00 00 00 | 	byte	$7e, $60, $60, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
11236     7E 81 9D A5 
1123a     9D A5 81 7E 
1123e     00 00 00 00 
11242     00 00 00 00 | 	byte	$7e, $81, $9d, $a5, $9d, $a5, $81, $7e, $00, $00, $00, $00, $00, $00, $00, $00
11246     7E 00 00 00 
1124a     00 00 00 00 
1124e     00 00 00 00 
11252     00 00 00 00 | 	byte	$7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
11256     3C 66 66 3C 
1125a     00 00 00 00 
1125e     00 00 00 00 
11262     00 00 00 00 | 	byte	$3c, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
11266     18 18 18 7E 
1126a     18 18 18 00 
1126e     7E 00 00 00 
11272     00 00 00 00 | 	byte	$18, $18, $18, $7e, $18, $18, $18, $00, $7e, $00, $00, $00, $00, $00, $00, $00
11276     1E 30 30 18 
1127a     0C 06 3E 00 
1127e     00 00 00 00 
11282     00 00 00 00 | 	byte	$1e, $30, $30, $18, $0c, $06, $3e, $00, $00, $00, $00, $00, $00, $00, $00, $00
11286     1E 30 30 1C 
1128a     30 30 1E 00 
1128e     00 00 00 00 
11292     00 00 00 00 | 	byte	$1e, $30, $30, $1c, $30, $30, $1e, $00, $00, $00, $00, $00, $00, $00, $00, $00
11296     30 18 0C 06 
1129a     00 00 00 00 
1129e     00 00 00 00 
112a2     00 00 00 00 | 	byte	$30, $18, $0c, $06, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
112a6     00 00 00 66 
112aa     66 66 66 66 
112ae     FE 06 06 00 
112b2     00 00 00 00 | 	byte	$00, $00, $00, $66, $66, $66, $66, $66, $fe, $06, $06, $00, $00, $00, $00, $00
112b6     7C 5E 5E 5E 
112ba     5C 50 50 50 
112be     50 50 00 00 
112c2     00 00 00 00 | 	byte	$7c, $5e, $5e, $5e, $5c, $50, $50, $50, $50, $50, $00, $00, $00, $00, $00, $00
112c6     00 00 00 18 
112ca     18 00 00 00 
112ce     00 00 00 00 
112d2     00 00 00 00 | 	byte	$00, $00, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
112d6     00 00 00 00 
112da     00 00 00 00 
112de     00          | 	byte	$00[9]
112df     30 18 00 00 
112e3     00 00 00 18 
112e7     1C 18 18 18 
112eb     18 18 00 00 | 	byte	$30, $18, $00, $00, $00, $00, $00, $18, $1c, $18, $18, $18, $18, $18, $00, $00
112ef     00 00 00 00 
112f3     00 00 00    | 	byte	$00[7]
112f6     3C 66 66 3C 
112fa     00 7E 00 00 
112fe     00 00 00 00 
11302     00 00 00 00 | 	byte	$3c, $66, $66, $3c, $00, $7e, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
11306     00 00 33 66 
1130a     CC 66 33 00 
1130e     00 00 00 00 
11312     00 00 00 00 | 	byte	$00, $00, $33, $66, $cc, $66, $33, $00, $00, $00, $00, $00, $00, $00, $00, $00
11316     02 63 32 1A 
1131a     4E 66 F3 40 
1131e     40 00 00 00 
11322     00 00 00 00 | 	byte	$02, $63, $32, $1a, $4e, $66, $f3, $40, $40, $00, $00, $00, $00, $00, $00, $00
11326     04 C6 64 34 
1132a     7C 8C 46 23 
1132e     F0 00 00 00 
11332     00 00 00 00 | 	byte	$04, $c6, $64, $34, $7c, $8c, $46, $23, $f0, $00, $00, $00, $00, $00, $00, $00
11336     03 C4 66 34 
1133a     5B 6C F6 43 
1133e     40 00 00 00 
11342     00 00 00 00 | 	byte	$03, $c4, $66, $34, $5b, $6c, $f6, $43, $40, $00, $00, $00, $00, $00, $00, $00
11346     18 18 00 18 
1134a     0C 06 06 66 
1134e     3C 00 00 00 
11352     00 00 00 00 | 	byte	$18, $18, $00, $18, $0c, $06, $06, $66, $3c, $00, $00, $00, $00, $00, $00, $00
11356     06 0C 3E 63 
1135a     63 7F 63 63 
1135e     63 00 00 00 
11362     00 00 00 00 | 	byte	$06, $0c, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
11366     30 18 3E 63 
1136a     63 7F 63 63 
1136e     63 00 00 00 
11372     00 00 00 00 | 	byte	$30, $18, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
11376     0C 33 3E 63 
1137a     63 63 7F 63 
1137e     63 00 00 00 
11382     00 00 00 00 | 	byte	$0c, $33, $3e, $63, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
11386     4E 39 3E 63 
1138a     63 7F 63 63 
1138e     63 00 00 00 
11392     00 00 00 00 | 	byte	$4e, $39, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
11396     63 00 3E 63 
1139a     63 7F 63 63 
1139e     63 00 00 00 
113a2     00 00 00 00 | 	byte	$63, $00, $3e, $63, $63, $7f, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
113a6     1C 22 1C 36 
113aa     63 63 7F 63 
113ae     63 00 00 00 
113b2     00 00 00 00 | 	byte	$1c, $22, $1c, $36, $63, $63, $7f, $63, $63, $00, $00, $00, $00, $00, $00, $00
113b6     F8 3C 3C 36 
113ba     F6 3F 33 33 
113be     F3 00 00 00 
113c2     00 00 00 00 | 	byte	$f8, $3c, $3c, $36, $f6, $3f, $33, $33, $f3, $00, $00, $00, $00, $00, $00, $00
113c6     78 0C 06 06 
113ca     06 06 06 0C 
113ce     78 30 18 00 
113d2     00 00 00 00 | 	byte	$78, $0c, $06, $06, $06, $06, $06, $0c, $78, $30, $18, $00, $00, $00, $00, $00
113d6     0C 18 7E 06 
113da     06 3E 06 06 
113de     7E 00 00 00 
113e2     00 00 00 00 | 	byte	$0c, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
113e6     30 18 7E 06 
113ea     06 3E 06 06 
113ee     7E 00 00 00 
113f2     00 00 00 00 | 	byte	$30, $18, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
113f6     18 66 7E 06 
113fa     06 3E 06 06 
113fe     7E 00 00 00 
11402     00 00 00 00 | 	byte	$18, $66, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
11406     66 00 7E 06 
1140a     06 3E 06 06 
1140e     7E 00 00 00 
11412     00 00 00 00 | 	byte	$66, $00, $7e, $06, $06, $3e, $06, $06, $7e, $00, $00, $00, $00, $00, $00, $00
11416     0C 18 3C 18 
1141a     18 18 18 18 
1141e     3C 00 00 00 
11422     00 00 00 00 | 	byte	$0c, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
11426     30 18 3C 18 
1142a     18 18 18 18 
1142e     3C 00 00 00 
11432     00 00 00 00 | 	byte	$30, $18, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
11436     18 66 3C 18 
1143a     18 18 18 18 
1143e     3C 00 00 00 
11442     00 00 00 00 | 	byte	$18, $66, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
11446     66 00 3C 18 
1144a     18 18 18 18 
1144e     3C 00 00 00 
11452     00 00 00 00 | 	byte	$66, $00, $3c, $18, $18, $18, $18, $18, $3c, $00, $00, $00, $00, $00, $00, $00
11456     1E 36 66 66 
1145a     6F 66 66 36 
1145e     1E 00 00 00 
11462     00 00 00 00 | 	byte	$1e, $36, $66, $66, $6f, $66, $66, $36, $1e, $00, $00, $00, $00, $00, $00, $00
11466     8E 73 67 6F 
1146a     7B 73 63 63 
1146e     63 00 00 00 
11472     00 00 00 00 | 	byte	$8e, $73, $67, $6f, $7b, $73, $63, $63, $63, $00, $00, $00, $00, $00, $00, $00
11476     06 0C 3E 63 
1147a     63 63 63 63 
1147e     3E 00 00 00 
11482     00 00 00 00 | 	byte	$06, $0c, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
11486     30 18 3E 63 
1148a     63 63 63 63 
1148e     3E 00 00 00 
11492     00 00 00 00 | 	byte	$30, $18, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
11496     0C 33 3E 63 
1149a     63 63 63 63 
1149e     3E 00 00 00 
114a2     00 00 00 00 | 	byte	$0c, $33, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
114a6     8E 71 3E 63 
114aa     63 63 63 63 
114ae     3E 00 00 00 
114b2     00 00 00 00 | 	byte	$8e, $71, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
114b6     63 00 3E 63 
114ba     63 63 63 63 
114be     3E 00 00 00 
114c2     00 00 00 00 | 	byte	$63, $00, $3e, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
114c6     00 00 63 36 
114ca     1C 1C 36 63 
114ce     00 00 00 00 
114d2     00 00 00 00 | 	byte	$00, $00, $63, $36, $1c, $1c, $36, $63, $00, $00, $00, $00, $00, $00, $00, $00
114d6     BE 63 73 7B 
114da     6B 6F 67 63 
114de     3F 00 00 00 
114e2     00 00 00 00 | 	byte	$be, $63, $73, $7b, $6b, $6f, $67, $63, $3f, $00, $00, $00, $00, $00, $00, $00
114e6     0C 18 63 63 
114ea     63 63 63 63 
114ee     3E 00 00 00 
114f2     00 00 00 00 | 	byte	$0c, $18, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
114f6     18 0C 63 63 
114fa     63 63 63 63 
114fe     3E 00 00 00 
11502     00 00 00 00 | 	byte	$18, $0c, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
11506     08 36 63 63 
1150a     63 63 63 63 
1150e     3E 00 00 00 
11512     00 00 00 00 | 	byte	$08, $36, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
11516     63 00 63 63 
1151a     63 63 63 63 
1151e     3E 00 00 00 
11522     00 00 00 00 | 	byte	$63, $00, $63, $63, $63, $63, $63, $63, $3e, $00, $00, $00, $00, $00, $00, $00
11526     30 18 C3 66 
1152a     3C 18 18 18 
1152e     18 00 00 00 
11532     00 00 00 00 | 	byte	$30, $18, $c3, $66, $3c, $18, $18, $18, $18, $00, $00, $00, $00, $00, $00, $00
11536     03 03 3F 63 
1153a     63 3F 03 03 
1153e     03 00 00 00 
11542     00 00 00 00 | 	byte	$03, $03, $3f, $63, $63, $3f, $03, $03, $03, $00, $00, $00, $00, $00, $00, $00
11546     3C 66 66 66 
1154a     36 66 66 66 
1154e     36 06 06 00 
11552     00 00 00 00 | 	byte	$3c, $66, $66, $66, $36, $66, $66, $66, $36, $06, $06, $00, $00, $00, $00, $00
11556     06 0C 00 3C 
1155a     60 7C 66 66 
1155e     7C 00 00 00 
11562     00 00 00 00 | 	byte	$06, $0c, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
11566     60 30 00 3C 
1156a     60 7C 66 66 
1156e     7C 00 00 00 
11572     00 00 00 00 | 	byte	$60, $30, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
11576     18 66 00 3C 
1157a     60 7C 66 66 
1157e     7C 00 00 00 
11582     00 00 00 00 | 	byte	$18, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
11586     8E 71 00 3C 
1158a     60 7C 66 66 
1158e     7C 00 00 00 
11592     00 00 00 00 | 	byte	$8e, $71, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
11596     00 66 00 3C 
1159a     60 7C 66 66 
1159e     7C 00 00 00 
115a2     00 00 00 00 | 	byte	$00, $66, $00, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
115a6     18 24 18 3C 
115aa     60 7C 66 66 
115ae     7C 00 00 00 
115b2     00 00 00 00 | 	byte	$18, $24, $18, $3c, $60, $7c, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
115b6     00 00 00 7E 
115ba     D8 FE 1B 1B 
115be     EE 00 00 00 
115c2     00 00 00 00 | 	byte	$00, $00, $00, $7e, $d8, $fe, $1b, $1b, $ee, $00, $00, $00, $00, $00, $00, $00
115c6     00 00 00 3C 
115ca     06 06 06 06 
115ce     3C 18 0C 00 
115d2     00 00 00 00 | 	byte	$00, $00, $00, $3c, $06, $06, $06, $06, $3c, $18, $0c, $00, $00, $00, $00, $00
115d6     06 0C 00 3C 
115da     66 7E 06 06 
115de     3C 00 00 00 
115e2     00 00 00 00 | 	byte	$06, $0c, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
115e6     60 30 00 3C 
115ea     66 7E 06 06 
115ee     3C 00 00 00 
115f2     00 00 00 00 | 	byte	$60, $30, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
115f6     18 66 00 3C 
115fa     66 7E 06 06 
115fe     3C 00 00 00 
11602     00 00 00 00 | 	byte	$18, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
11606     00 66 00 3C 
1160a     66 7E 06 06 
1160e     3C 00 00 00 
11612     00 00 00 00 | 	byte	$00, $66, $00, $3c, $66, $7e, $06, $06, $3c, $00, $00, $00, $00, $00, $00, $00
11616     0C 18 00 18 
1161a     18 18 18 18 
1161e     30 00 00 00 
11622     00 00 00 00 | 	byte	$0c, $18, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
11626     18 0C 00 0C 
1162a     0C 0C 0C 0C 
1162e     18 00 00 00 
11632     00 00 00 00 | 	byte	$18, $0c, $00, $0c, $0c, $0c, $0c, $0c, $18, $00, $00, $00, $00, $00, $00, $00
11636     18 66 00 18 
1163a     18 18 18 18 
1163e     30 00 00 00 
11642     00 00 00 00 | 	byte	$18, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
11646     00 66 00 18 
1164a     18 18 18 18 
1164e     30 00 00 00 
11652     00 00 00 00 | 	byte	$00, $66, $00, $18, $18, $18, $18, $18, $30, $00, $00, $00, $00, $00, $00, $00
11656     03 06 3F 18 
1165a     3C 66 66 66 
1165e     3C 00 00 00 
11662     00 00 00 00 | 	byte	$03, $06, $3f, $18, $3c, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
11666     8E 71 00 3E 
1166a     66 66 66 66 
1166e     66 00 00 00 
11672     00 00 00 00 | 	byte	$8e, $71, $00, $3e, $66, $66, $66, $66, $66, $00, $00, $00, $00, $00, $00, $00
11676     06 0C 00 3C 
1167a     66 66 66 66 
1167e     3C 00 00 00 
11682     00 00 00 00 | 	byte	$06, $0c, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
11686     60 30 00 3C 
1168a     66 66 66 66 
1168e     3C 00 00 00 
11692     00 00 00 00 | 	byte	$60, $30, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
11696     18 66 00 3C 
1169a     66 66 66 66 
1169e     3C 00 00 00 
116a2     00 00 00 00 | 	byte	$18, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
116a6     8E 71 00 3C 
116aa     66 66 66 66 
116ae     3C 00 00 00 
116b2     00 00 00 00 | 	byte	$8e, $71, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
116b6     00 66 00 3C 
116ba     66 66 66 66 
116be     3C 00 00 00 
116c2     00 00 00 00 | 	byte	$00, $66, $00, $3c, $66, $66, $66, $66, $3c, $00, $00, $00, $00, $00, $00, $00
116c6     00 18 18 00 
116ca     7E 00 18 18 
116ce     00 00 00 00 
116d2     00 00 00 00 | 	byte	$00, $18, $18, $00, $7e, $00, $18, $18, $00, $00, $00, $00, $00, $00, $00, $00
116d6     00 00 00 7E 
116da     73 7B 6F 67 
116de     3F 00 00 00 
116e2     00 00 00 00 | 	byte	$00, $00, $00, $7e, $73, $7b, $6f, $67, $3f, $00, $00, $00, $00, $00, $00, $00
116e6     0C 18 00 66 
116ea     66 66 66 66 
116ee     7C 00 00 00 
116f2     00 00 00 00 | 	byte	$0c, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
116f6     30 18 00 66 
116fa     66 66 66 66 
116fe     7C 00 00 00 
11702     00 00 00 00 | 	byte	$30, $18, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
11706     18 66 00 66 
1170a     66 66 66 66 
1170e     7C 00 00 00 
11712     00 00 00 00 | 	byte	$18, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
11716     00 66 00 66 
1171a     66 66 66 66 
1171e     7C 00 00 00 
11722     00 00 00 00 | 	byte	$00, $66, $00, $66, $66, $66, $66, $66, $7c, $00, $00, $00, $00, $00, $00, $00
11726     30 18 00 66 
1172a     66 66 66 3C 
1172e     18 0C 06 00 
11732     00 00 00 00 | 	byte	$30, $18, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
11736     06 06 06 3E 
1173a     66 66 66 3E 
1173e     06 06 06 00 
11742     00 00 00 00 | 	byte	$06, $06, $06, $3e, $66, $66, $66, $3e, $06, $06, $06, $00, $00, $00, $00, $00
11746     00 66 00 66 
1174a     66 66 66 3C 
1174e     18 0C 06 00 
11752     00 00 00 00 | 	byte	$00, $66, $00, $66, $66, $66, $66, $3c, $18, $0c, $06, $00, $00, $00, $00, $00
11756     00 7E 66 66 
1175a     66 66 66 66 
1175e     66 7E 00 00 
11762     00 00 00 00 | 	byte	$00, $7e, $66, $66, $66, $66, $66, $66, $66, $7e, $00, $00, $00, $00, $00, $00
11766     00 00 00 00 
      ...             
1196e     00 00 00 00 
11972     00 00       | 	byte	$00[526]
11974     00 00 00 00 
11978     00          | vga16          long  $00000000,$00008000,$00800000,$00808000,$80000000,$80008000,$80400000,$AAAAAA00,$55555500,$0000FF00,$00FF0000,$00FFFF00,$FF000000,$FF00FF00,$FFFF0000,$FFFFFF00
11979     80 00 00 00 
1197d     00 80 00 00 
11981     80 80 00 00 
11985     00 00 80 00 | 	byte	$80, $00, $00, $00, $00, $80, $00, $00, $80, $80, $00, $00, $00, $00, $80, $00
11989     80 00 80 00 
1198d     00 40 80 00 
11991     AA AA AA 00 
11995     55 55 55 00 | 	byte	$80, $00, $80, $00, $00, $40, $80, $00, $aa, $aa, $aa, $00, $55, $55, $55, $00
11999     FF 00 00 00 
1199d     00 FF 00 00 
119a1     FF FF 00 00 
119a5     00 00 FF 00 | 	byte	$ff, $00, $00, $00, $00, $ff, $00, $00, $ff, $ff, $00, $00, $00, $00, $ff, $00
119a9     FF 00 FF 00 
119ad     00 FF FF 00 
119b1     FF FF FF    | 	byte	$ff, $00, $ff, $00, $00, $ff, $ff, $00, $ff, $ff, $ff
119b4     00 00 00 00 
119b8     00          | ataripalette   file "ataripalettep2.def"
119b9     11 11 11 00 
119bd     22 22 22 00 
119c1     33 33 33 00 
119c5     44 44 44 00 | 	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
119c9     55 55 55 00 
119cd     66 66 66 00 
119d1     77 77 77 00 
119d5     88 88 88 00 | 	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
119d9     99 99 99 00 
119dd     AA AA AA 00 
119e1     BB BB BB 00 
119e5     CC CC CC 00 | 	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
119e9     DD DD DD 00 
119ed     EE EE EE 00 
119f1     FF FF FF 00 
119f5     00 0A 20 00 | 	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
119f9     00 14 40 00 
119fd     00 1E 60 00 
11a01     00 28 80 00 
11a05     00 32 9F 00 | 	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
11a09     00 3C BF 00 
11a0d     00 46 DF 00 
11a11     00 50 FF 00 
11a15     1C 63 FF 00 | 	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
11a19     39 77 FF 00 
11a1d     55 8A FF 00 
11a21     71 9E FF 00 
11a25     8E B1 FF 00 | 	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
11a29     AA C5 FF 00 
11a2d     C6 D8 FF 00 
11a31     E3 EC FF 00 
11a35     00 00 20 00 | 	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
11a39     00 00 40 00 
11a3d     00 00 60 00 
11a41     00 00 80 00 
11a45     00 00 9F 00 | 	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
11a49     00 00 BF 00 
11a4d     00 00 DF 00 
11a51     00 00 FF 00 
11a55     1C 1C FF 00 | 	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
11a59     39 39 FF 00 
11a5d     55 55 FF 00 
11a61     71 71 FF 00 
11a65     8E 8E FF 00 | 	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
11a69     AA AA FF 00 
11a6d     C6 C6 FF 00 
11a71     E3 E3 FF 00 
11a75     10 00 20 00 | 	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
11a79     20 00 40 00 
11a7d     30 00 60 00 
11a81     40 00 80 00 
11a85     50 00 9F 00 | 	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
11a89     60 00 BF 00 
11a8d     70 00 DF 00 
11a91     80 00 FF 00 
11a95     8E 1C FF 00 | 	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
11a99     9C 39 FF 00 
11a9d     AA 55 FF 00 
11aa1     B8 71 FF 00 
11aa5     C7 8E FF 00 | 	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
11aa9     D5 AA FF 00 
11aad     E3 C6 FF 00 
11ab1     F1 E3 FF 00 
11ab5     20 00 20 00 | 	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
11ab9     40 00 40 00 
11abd     60 00 60 00 
11ac1     80 00 80 00 
11ac5     9F 00 9F 00 | 	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
11ac9     BF 00 BF 00 
11acd     DF 00 DF 00 
11ad1     FF 00 FF 00 
11ad5     FF 1C FF 00 | 	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
11ad9     FF 39 FF 00 
11add     FF 55 FF 00 
11ae1     FF 71 FF 00 
11ae5     FF 8E FF 00 | 	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
11ae9     FF AA FF 00 
11aed     FF C6 FF 00 
11af1     FF E3 FF 00 
11af5     20 00 10 00 | 	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
11af9     40 00 20 00 
11afd     60 00 30 00 
11b01     80 00 40 00 
11b05     9F 00 50 00 | 	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
11b09     BF 00 60 00 
11b0d     DF 00 70 00 
11b11     FF 00 80 00 
11b15     FF 1C 8E 00 | 	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
11b19     FF 39 9C 00 
11b1d     FF 55 AA 00 
11b21     FF 71 B8 00 
11b25     FF 8E C7 00 | 	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
11b29     FF AA D5 00 
11b2d     FF C6 E3 00 
11b31     FF E3 F1 00 
11b35     20 00 00 00 | 	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
11b39     40 00 00 00 
11b3d     60 00 00 00 
11b41     80 00 00 00 
11b45     9F 00 00 00 | 	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
11b49     BF 00 00 00 
11b4d     DF 00 00 00 
11b51     FF 00 00 00 
11b55     FF 1C 1C 00 | 	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
11b59     FF 39 39 00 
11b5d     FF 55 55 00 
11b61     FF 71 71 00 
11b65     FF 8E 8E 00 | 	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
11b69     FF AA AA 00 
11b6d     FF C6 C6 00 
11b71     FF E3 E3 00 
11b75     20 08 00 00 | 	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
11b79     40 10 00 00 
11b7d     60 18 00 00 
11b81     80 20 00 00 
11b85     9F 28 00 00 | 	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
11b89     BF 30 00 00 
11b8d     DF 38 00 00 
11b91     FF 40 00 00 
11b95     FF 55 1C 00 | 	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
11b99     FF 6A 39 00 
11b9d     FF 80 55 00 
11ba1     FF 95 71 00 
11ba5     FF AA 8E 00 | 	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
11ba9     FF BF AA 00 
11bad     FF D5 C6 00 
11bb1     FF EA E3 00 
11bb5     20 10 00 00 | 	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
11bb9     40 20 00 00 
11bbd     60 30 00 00 
11bc1     80 40 00 00 
11bc5     9F 50 00 00 | 	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
11bc9     BF 60 00 00 
11bcd     DF 70 00 00 
11bd1     FF 80 00 00 
11bd5     FF 8E 1C 00 | 	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
11bd9     FF 9C 39 00 
11bdd     FF AA 55 00 
11be1     FF B8 71 00 
11be5     FF C7 8E 00 | 	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
11be9     FF D5 AA 00 
11bed     FF E3 C6 00 
11bf1     FF F1 E3 00 
11bf5     20 18 00 00 | 	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
11bf9     40 30 00 00 
11bfd     60 48 00 00 
11c01     80 60 00 00 
11c05     9F 78 00 00 | 	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
11c09     BF 90 00 00 
11c0d     DF A8 00 00 
11c11     FF C0 00 00 
11c15     FF C7 1C 00 | 	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
11c19     FF CE 39 00 
11c1d     FF D5 55 00 
11c21     FF DC 71 00 
11c25     FF E3 8E 00 | 	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
11c29     FF EA AA 00 
11c2d     FF F1 C6 00 
11c31     FF F8 E3 00 
11c35     18 20 00 00 | 	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
11c39     30 40 00 00 
11c3d     48 60 00 00 
11c41     60 80 00 00 
11c45     78 9F 00 00 | 	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
11c49     90 BF 00 00 
11c4d     A8 DF 00 00 
11c51     C0 FF 00 00 
11c55     C7 FF 1C 00 | 	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
11c59     CE FF 39 00 
11c5d     D5 FF 55 00 
11c61     DC FF 71 00 
11c65     E3 FF 8E 00 | 	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
11c69     EA FF AA 00 
11c6d     F1 FF C6 00 
11c71     F8 FF E3 00 
11c75     00 20 00 00 | 	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
11c79     00 40 00 00 
11c7d     00 60 00 00 
11c81     00 80 00 00 
11c85     00 9F 00 00 | 	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
11c89     00 BF 00 00 
11c8d     00 DF 00 00 
11c91     00 FF 00 00 
11c95     1C FF 1C 00 | 	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
11c99     39 FF 39 00 
11c9d     55 FF 55 00 
11ca1     71 FF 71 00 
11ca5     8E FF 8E 00 | 	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
11ca9     AA FF AA 00 
11cad     C6 FF C6 00 
11cb1     E3 FF E3 00 
11cb5     00 20 0A 00 | 	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
11cb9     00 40 14 00 
11cbd     00 60 1E 00 
11cc1     00 80 28 00 
11cc5     00 9F 32 00 | 	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
11cc9     00 BF 3C 00 
11ccd     00 DF 46 00 
11cd1     00 FF 50 00 
11cd5     1C FF 63 00 | 	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
11cd9     39 FF 77 00 
11cdd     55 FF 8A 00 
11ce1     71 FF 9E 00 
11ce5     8E FF B1 00 | 	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
11ce9     AA FF C5 00 
11ced     C6 FF D8 00 
11cf1     E3 FF EC 00 
11cf5     00 20 14 00 | 	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
11cf9     00 40 28 00 
11cfd     00 60 3C 00 
11d01     00 80 50 00 
11d05     00 9F 64 00 | 	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
11d09     00 BF 78 00 
11d0d     00 DF 8C 00 
11d11     00 FF A0 00 
11d15     1C FF AB 00 | 	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
11d19     39 FF B5 00 
11d1d     55 FF C0 00 
11d21     71 FF CA 00 
11d25     8E FF D5 00 | 	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
11d29     AA FF DF 00 
11d2d     C6 FF EA 00 
11d31     E3 FF F4 00 
11d35     00 20 20 00 | 	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
11d39     00 40 40 00 
11d3d     00 60 60 00 
11d41     00 80 80 00 
11d45     00 9F 9F 00 | 	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
11d49     00 BF BF 00 
11d4d     00 DF DF 00 
11d51     00 FF FF 00 
11d55     1C FF FF 00 | 	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
11d59     39 FF FF 00 
11d5d     55 FF FF 00 
11d61     71 FF FF 00 
11d65     8E FF FF 00 | 	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
11d69     AA FF FF 00 
11d6d     C6 FF FF 00 
11d71     E3 FF FF 00 
11d75     00 14 20 00 | 	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
11d79     00 28 40 00 
11d7d     00 3C 60 00 
11d81     00 50 80 00 
11d85     00 64 9F 00 | 	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
11d89     00 78 BF 00 
11d8d     00 8C DF 00 
11d91     00 A0 FF 00 
11d95     1C AB FF 00 | 	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
11d99     39 B5 FF 00 
11d9d     55 C0 FF 00 
11da1     71 CA FF 00 
11da5     8E D5 FF 00 | 	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
11da9     AA DF FF 00 
11dad     C6 EA FF 00 
11db1     E3 F4 FF    | 	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
11db4     00 00 00 00 
11db8     00          | ataripalette2  file "ataripalettep2.def"
11db9     11 11 11 00 
11dbd     22 22 22 00 
11dc1     33 33 33 00 
11dc5     44 44 44 00 | 	byte	$11, $11, $11, $00, $22, $22, $22, $00, $33, $33, $33, $00, $44, $44, $44, $00
11dc9     55 55 55 00 
11dcd     66 66 66 00 
11dd1     77 77 77 00 
11dd5     88 88 88 00 | 	byte	$55, $55, $55, $00, $66, $66, $66, $00, $77, $77, $77, $00, $88, $88, $88, $00
11dd9     99 99 99 00 
11ddd     AA AA AA 00 
11de1     BB BB BB 00 
11de5     CC CC CC 00 | 	byte	$99, $99, $99, $00, $aa, $aa, $aa, $00, $bb, $bb, $bb, $00, $cc, $cc, $cc, $00
11de9     DD DD DD 00 
11ded     EE EE EE 00 
11df1     FF FF FF 00 
11df5     00 0A 20 00 | 	byte	$dd, $dd, $dd, $00, $ee, $ee, $ee, $00, $ff, $ff, $ff, $00, $00, $0a, $20, $00
11df9     00 14 40 00 
11dfd     00 1E 60 00 
11e01     00 28 80 00 
11e05     00 32 9F 00 | 	byte	$00, $14, $40, $00, $00, $1e, $60, $00, $00, $28, $80, $00, $00, $32, $9f, $00
11e09     00 3C BF 00 
11e0d     00 46 DF 00 
11e11     00 50 FF 00 
11e15     1C 63 FF 00 | 	byte	$00, $3c, $bf, $00, $00, $46, $df, $00, $00, $50, $ff, $00, $1c, $63, $ff, $00
11e19     39 77 FF 00 
11e1d     55 8A FF 00 
11e21     71 9E FF 00 
11e25     8E B1 FF 00 | 	byte	$39, $77, $ff, $00, $55, $8a, $ff, $00, $71, $9e, $ff, $00, $8e, $b1, $ff, $00
11e29     AA C5 FF 00 
11e2d     C6 D8 FF 00 
11e31     E3 EC FF 00 
11e35     00 00 20 00 | 	byte	$aa, $c5, $ff, $00, $c6, $d8, $ff, $00, $e3, $ec, $ff, $00, $00, $00, $20, $00
11e39     00 00 40 00 
11e3d     00 00 60 00 
11e41     00 00 80 00 
11e45     00 00 9F 00 | 	byte	$00, $00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00
11e49     00 00 BF 00 
11e4d     00 00 DF 00 
11e51     00 00 FF 00 
11e55     1C 1C FF 00 | 	byte	$00, $00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $1c, $1c, $ff, $00
11e59     39 39 FF 00 
11e5d     55 55 FF 00 
11e61     71 71 FF 00 
11e65     8E 8E FF 00 | 	byte	$39, $39, $ff, $00, $55, $55, $ff, $00, $71, $71, $ff, $00, $8e, $8e, $ff, $00
11e69     AA AA FF 00 
11e6d     C6 C6 FF 00 
11e71     E3 E3 FF 00 
11e75     10 00 20 00 | 	byte	$aa, $aa, $ff, $00, $c6, $c6, $ff, $00, $e3, $e3, $ff, $00, $10, $00, $20, $00
11e79     20 00 40 00 
11e7d     30 00 60 00 
11e81     40 00 80 00 
11e85     50 00 9F 00 | 	byte	$20, $00, $40, $00, $30, $00, $60, $00, $40, $00, $80, $00, $50, $00, $9f, $00
11e89     60 00 BF 00 
11e8d     70 00 DF 00 
11e91     80 00 FF 00 
11e95     8E 1C FF 00 | 	byte	$60, $00, $bf, $00, $70, $00, $df, $00, $80, $00, $ff, $00, $8e, $1c, $ff, $00
11e99     9C 39 FF 00 
11e9d     AA 55 FF 00 
11ea1     B8 71 FF 00 
11ea5     C7 8E FF 00 | 	byte	$9c, $39, $ff, $00, $aa, $55, $ff, $00, $b8, $71, $ff, $00, $c7, $8e, $ff, $00
11ea9     D5 AA FF 00 
11ead     E3 C6 FF 00 
11eb1     F1 E3 FF 00 
11eb5     20 00 20 00 | 	byte	$d5, $aa, $ff, $00, $e3, $c6, $ff, $00, $f1, $e3, $ff, $00, $20, $00, $20, $00
11eb9     40 00 40 00 
11ebd     60 00 60 00 
11ec1     80 00 80 00 
11ec5     9F 00 9F 00 | 	byte	$40, $00, $40, $00, $60, $00, $60, $00, $80, $00, $80, $00, $9f, $00, $9f, $00
11ec9     BF 00 BF 00 
11ecd     DF 00 DF 00 
11ed1     FF 00 FF 00 
11ed5     FF 1C FF 00 | 	byte	$bf, $00, $bf, $00, $df, $00, $df, $00, $ff, $00, $ff, $00, $ff, $1c, $ff, $00
11ed9     FF 39 FF 00 
11edd     FF 55 FF 00 
11ee1     FF 71 FF 00 
11ee5     FF 8E FF 00 | 	byte	$ff, $39, $ff, $00, $ff, $55, $ff, $00, $ff, $71, $ff, $00, $ff, $8e, $ff, $00
11ee9     FF AA FF 00 
11eed     FF C6 FF 00 
11ef1     FF E3 FF 00 
11ef5     20 00 10 00 | 	byte	$ff, $aa, $ff, $00, $ff, $c6, $ff, $00, $ff, $e3, $ff, $00, $20, $00, $10, $00
11ef9     40 00 20 00 
11efd     60 00 30 00 
11f01     80 00 40 00 
11f05     9F 00 50 00 | 	byte	$40, $00, $20, $00, $60, $00, $30, $00, $80, $00, $40, $00, $9f, $00, $50, $00
11f09     BF 00 60 00 
11f0d     DF 00 70 00 
11f11     FF 00 80 00 
11f15     FF 1C 8E 00 | 	byte	$bf, $00, $60, $00, $df, $00, $70, $00, $ff, $00, $80, $00, $ff, $1c, $8e, $00
11f19     FF 39 9C 00 
11f1d     FF 55 AA 00 
11f21     FF 71 B8 00 
11f25     FF 8E C7 00 | 	byte	$ff, $39, $9c, $00, $ff, $55, $aa, $00, $ff, $71, $b8, $00, $ff, $8e, $c7, $00
11f29     FF AA D5 00 
11f2d     FF C6 E3 00 
11f31     FF E3 F1 00 
11f35     20 00 00 00 | 	byte	$ff, $aa, $d5, $00, $ff, $c6, $e3, $00, $ff, $e3, $f1, $00, $20, $00, $00, $00
11f39     40 00 00 00 
11f3d     60 00 00 00 
11f41     80 00 00 00 
11f45     9F 00 00 00 | 	byte	$40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00, $00
11f49     BF 00 00 00 
11f4d     DF 00 00 00 
11f51     FF 00 00 00 
11f55     FF 1C 1C 00 | 	byte	$bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $00, $ff, $1c, $1c, $00
11f59     FF 39 39 00 
11f5d     FF 55 55 00 
11f61     FF 71 71 00 
11f65     FF 8E 8E 00 | 	byte	$ff, $39, $39, $00, $ff, $55, $55, $00, $ff, $71, $71, $00, $ff, $8e, $8e, $00
11f69     FF AA AA 00 
11f6d     FF C6 C6 00 
11f71     FF E3 E3 00 
11f75     20 08 00 00 | 	byte	$ff, $aa, $aa, $00, $ff, $c6, $c6, $00, $ff, $e3, $e3, $00, $20, $08, $00, $00
11f79     40 10 00 00 
11f7d     60 18 00 00 
11f81     80 20 00 00 
11f85     9F 28 00 00 | 	byte	$40, $10, $00, $00, $60, $18, $00, $00, $80, $20, $00, $00, $9f, $28, $00, $00
11f89     BF 30 00 00 
11f8d     DF 38 00 00 
11f91     FF 40 00 00 
11f95     FF 55 1C 00 | 	byte	$bf, $30, $00, $00, $df, $38, $00, $00, $ff, $40, $00, $00, $ff, $55, $1c, $00
11f99     FF 6A 39 00 
11f9d     FF 80 55 00 
11fa1     FF 95 71 00 
11fa5     FF AA 8E 00 | 	byte	$ff, $6a, $39, $00, $ff, $80, $55, $00, $ff, $95, $71, $00, $ff, $aa, $8e, $00
11fa9     FF BF AA 00 
11fad     FF D5 C6 00 
11fb1     FF EA E3 00 
11fb5     20 10 00 00 | 	byte	$ff, $bf, $aa, $00, $ff, $d5, $c6, $00, $ff, $ea, $e3, $00, $20, $10, $00, $00
11fb9     40 20 00 00 
11fbd     60 30 00 00 
11fc1     80 40 00 00 
11fc5     9F 50 00 00 | 	byte	$40, $20, $00, $00, $60, $30, $00, $00, $80, $40, $00, $00, $9f, $50, $00, $00
11fc9     BF 60 00 00 
11fcd     DF 70 00 00 
11fd1     FF 80 00 00 
11fd5     FF 8E 1C 00 | 	byte	$bf, $60, $00, $00, $df, $70, $00, $00, $ff, $80, $00, $00, $ff, $8e, $1c, $00
11fd9     FF 9C 39 00 
11fdd     FF AA 55 00 
11fe1     FF B8 71 00 
11fe5     FF C7 8E 00 | 	byte	$ff, $9c, $39, $00, $ff, $aa, $55, $00, $ff, $b8, $71, $00, $ff, $c7, $8e, $00
11fe9     FF D5 AA 00 
11fed     FF E3 C6 00 
11ff1     FF F1 E3 00 
11ff5     20 18 00 00 | 	byte	$ff, $d5, $aa, $00, $ff, $e3, $c6, $00, $ff, $f1, $e3, $00, $20, $18, $00, $00
11ff9     40 30 00 00 
11ffd     60 48 00 00 
12001     80 60 00 00 
12005     9F 78 00 00 | 	byte	$40, $30, $00, $00, $60, $48, $00, $00, $80, $60, $00, $00, $9f, $78, $00, $00
12009     BF 90 00 00 
1200d     DF A8 00 00 
12011     FF C0 00 00 
12015     FF C7 1C 00 | 	byte	$bf, $90, $00, $00, $df, $a8, $00, $00, $ff, $c0, $00, $00, $ff, $c7, $1c, $00
12019     FF CE 39 00 
1201d     FF D5 55 00 
12021     FF DC 71 00 
12025     FF E3 8E 00 | 	byte	$ff, $ce, $39, $00, $ff, $d5, $55, $00, $ff, $dc, $71, $00, $ff, $e3, $8e, $00
12029     FF EA AA 00 
1202d     FF F1 C6 00 
12031     FF F8 E3 00 
12035     18 20 00 00 | 	byte	$ff, $ea, $aa, $00, $ff, $f1, $c6, $00, $ff, $f8, $e3, $00, $18, $20, $00, $00
12039     30 40 00 00 
1203d     48 60 00 00 
12041     60 80 00 00 
12045     78 9F 00 00 | 	byte	$30, $40, $00, $00, $48, $60, $00, $00, $60, $80, $00, $00, $78, $9f, $00, $00
12049     90 BF 00 00 
1204d     A8 DF 00 00 
12051     C0 FF 00 00 
12055     C7 FF 1C 00 | 	byte	$90, $bf, $00, $00, $a8, $df, $00, $00, $c0, $ff, $00, $00, $c7, $ff, $1c, $00
12059     CE FF 39 00 
1205d     D5 FF 55 00 
12061     DC FF 71 00 
12065     E3 FF 8E 00 | 	byte	$ce, $ff, $39, $00, $d5, $ff, $55, $00, $dc, $ff, $71, $00, $e3, $ff, $8e, $00
12069     EA FF AA 00 
1206d     F1 FF C6 00 
12071     F8 FF E3 00 
12075     00 20 00 00 | 	byte	$ea, $ff, $aa, $00, $f1, $ff, $c6, $00, $f8, $ff, $e3, $00, $00, $20, $00, $00
12079     00 40 00 00 
1207d     00 60 00 00 
12081     00 80 00 00 
12085     00 9F 00 00 | 	byte	$00, $40, $00, $00, $00, $60, $00, $00, $00, $80, $00, $00, $00, $9f, $00, $00
12089     00 BF 00 00 
1208d     00 DF 00 00 
12091     00 FF 00 00 
12095     1C FF 1C 00 | 	byte	$00, $bf, $00, $00, $00, $df, $00, $00, $00, $ff, $00, $00, $1c, $ff, $1c, $00
12099     39 FF 39 00 
1209d     55 FF 55 00 
120a1     71 FF 71 00 
120a5     8E FF 8E 00 | 	byte	$39, $ff, $39, $00, $55, $ff, $55, $00, $71, $ff, $71, $00, $8e, $ff, $8e, $00
120a9     AA FF AA 00 
120ad     C6 FF C6 00 
120b1     E3 FF E3 00 
120b5     00 20 0A 00 | 	byte	$aa, $ff, $aa, $00, $c6, $ff, $c6, $00, $e3, $ff, $e3, $00, $00, $20, $0a, $00
120b9     00 40 14 00 
120bd     00 60 1E 00 
120c1     00 80 28 00 
120c5     00 9F 32 00 | 	byte	$00, $40, $14, $00, $00, $60, $1e, $00, $00, $80, $28, $00, $00, $9f, $32, $00
120c9     00 BF 3C 00 
120cd     00 DF 46 00 
120d1     00 FF 50 00 
120d5     1C FF 63 00 | 	byte	$00, $bf, $3c, $00, $00, $df, $46, $00, $00, $ff, $50, $00, $1c, $ff, $63, $00
120d9     39 FF 77 00 
120dd     55 FF 8A 00 
120e1     71 FF 9E 00 
120e5     8E FF B1 00 | 	byte	$39, $ff, $77, $00, $55, $ff, $8a, $00, $71, $ff, $9e, $00, $8e, $ff, $b1, $00
120e9     AA FF C5 00 
120ed     C6 FF D8 00 
120f1     E3 FF EC 00 
120f5     00 20 14 00 | 	byte	$aa, $ff, $c5, $00, $c6, $ff, $d8, $00, $e3, $ff, $ec, $00, $00, $20, $14, $00
120f9     00 40 28 00 
120fd     00 60 3C 00 
12101     00 80 50 00 
12105     00 9F 64 00 | 	byte	$00, $40, $28, $00, $00, $60, $3c, $00, $00, $80, $50, $00, $00, $9f, $64, $00
12109     00 BF 78 00 
1210d     00 DF 8C 00 
12111     00 FF A0 00 
12115     1C FF AB 00 | 	byte	$00, $bf, $78, $00, $00, $df, $8c, $00, $00, $ff, $a0, $00, $1c, $ff, $ab, $00
12119     39 FF B5 00 
1211d     55 FF C0 00 
12121     71 FF CA 00 
12125     8E FF D5 00 | 	byte	$39, $ff, $b5, $00, $55, $ff, $c0, $00, $71, $ff, $ca, $00, $8e, $ff, $d5, $00
12129     AA FF DF 00 
1212d     C6 FF EA 00 
12131     E3 FF F4 00 
12135     00 20 20 00 | 	byte	$aa, $ff, $df, $00, $c6, $ff, $ea, $00, $e3, $ff, $f4, $00, $00, $20, $20, $00
12139     00 40 40 00 
1213d     00 60 60 00 
12141     00 80 80 00 
12145     00 9F 9F 00 | 	byte	$00, $40, $40, $00, $00, $60, $60, $00, $00, $80, $80, $00, $00, $9f, $9f, $00
12149     00 BF BF 00 
1214d     00 DF DF 00 
12151     00 FF FF 00 
12155     1C FF FF 00 | 	byte	$00, $bf, $bf, $00, $00, $df, $df, $00, $00, $ff, $ff, $00, $1c, $ff, $ff, $00
12159     39 FF FF 00 
1215d     55 FF FF 00 
12161     71 FF FF 00 
12165     8E FF FF 00 | 	byte	$39, $ff, $ff, $00, $55, $ff, $ff, $00, $71, $ff, $ff, $00, $8e, $ff, $ff, $00
12169     AA FF FF 00 
1216d     C6 FF FF 00 
12171     E3 FF FF 00 
12175     00 14 20 00 | 	byte	$aa, $ff, $ff, $00, $c6, $ff, $ff, $00, $e3, $ff, $ff, $00, $00, $14, $20, $00
12179     00 28 40 00 
1217d     00 3C 60 00 
12181     00 50 80 00 
12185     00 64 9F 00 | 	byte	$00, $28, $40, $00, $00, $3c, $60, $00, $00, $50, $80, $00, $00, $64, $9f, $00
12189     00 78 BF 00 
1218d     00 8C DF 00 
12191     00 A0 FF 00 
12195     1C AB FF 00 | 	byte	$00, $78, $bf, $00, $00, $8c, $df, $00, $00, $a0, $ff, $00, $1c, $ab, $ff, $00
12199     39 B5 FF 00 
1219d     55 C0 FF 00 
121a1     71 CA FF 00 
121a5     8E D5 FF 00 | 	byte	$39, $b5, $ff, $00, $55, $c0, $ff, $00, $71, $ca, $ff, $00, $8e, $d5, $ff, $00
121a9     AA DF FF 00 
121ad     C6 EA FF 00 
121b1     E3 F4 FF    | 	byte	$aa, $df, $ff, $00, $c6, $ea, $ff, $00, $e3, $f4, $ff
121b4                 | 
121b4                 | '**********************************************************************************
121b4                 | '
121b4                 | '        Timings and colors definitions
121b4                 | '
121b4                 | '**********************************************************************************
121b4                 | 
121b4                 | '                      bf.hs, hs,  bf.vis  visible, up p., vsync, down p.,  cpl, total lines, clock,       hubset                                scanlines  ud bord mode reserved
121b4     08 00 00 00 
121b8     3C 00 00 00 
121bc     08 00 00 00 
121c0     00 04 00 00 | timings         long   8,     60,  8,       1024,   7,     4,     1,        128, 600,         340500000,   %1_100111__10_1010_1000__1111_1011,   600,        0,     192, 0, 0
121c4     07 00 00 00 
121c8     04 00 00 00 
121cc     01 00 00 00 
121d0     80 00 00 00 | 	byte	$07, $00, $00, $00, $04, $00, $00, $00, $01, $00, $00, $00, $80, $00, $00, $00
121d4     58 02 00 00 
121d8     20 9E 4B 14 
121dc     FB A8 9E 01 
121e0     58 02 00 00 | 	byte	$58, $02, $00, $00, $20, $9e, $4b, $14, $fb, $a8, $9e, $01, $58, $02, $00, $00
121e4     00 00 00 00 
121e8     C0 00 00 00 
121ec     00 00 00 00 
121f0     00 00 00 00 | 	byte	$00, $00, $00, $00, $c0, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
121f4                 | 'timings        long   16,    80,  12,      1024,   8,     4,     8,        128, 576,         336956522,   %1_101101__11_0000_0110__1111_1011,   576,        0,     192, 0, 0
121f4     00 75 C7 97 
121f8     27 47 F6 0A 
121fc     05 79 CB 9B 
12200     2B 4B EA 0F | vgacolors       byte   0, 117, 199, 151, 39, 71, 246, 10, 5, 121, 203, 155, 43, 75, 234, 15
12204                 | 
12204                 | ''--------  Initialization  ----------------------------------------------------------------
12204                 | 
12204     28 0C 64 FD | hdmi            setq    #6
12208     00 A5 05 FB |                 rdlong  vblankptr,  ptra                   ' read pointers
1220c     28 10 64 FD |                 setq    #8
12210     D3 8A 01 FB |                 rdlong  m_bs,modeptr                       ' read timings
12214                 | 
12214     1F AC 1D F4 |                 bitl    hbase, #31 wcz                     ' if pin 31 is set, use full strength for Adafruit Pico HDMI board
12218     3C 00 66 FD |                 setcmod #$100                              ' enable HDMI mode
1221c     C0 C7 05 F6 |                 mov     t1,#448                            ' 7 << 6          
12220     D6 C6 01 F1 |                 add     t1,hbase
12224     58 C6 61 FD |                 drvl    t1                                 ' #7<<6 + hdmi_base      ' enable HDMI pins
12228     E3 00 08 AC |         if_z    wrpin   #0, t1  '#7<<6 + hdmi_base         ' for Adafruit breakout board - full logic as in Pico, the board has 220 Ohm resistors on it
1222c     7B 0B 80 5F 
12230     E3 00 0B 5C | 	if_nz   wrpin   ##%10110_1111_0111_10_00000_0, t1  ' #7<<6 + hdmi_base      ' a '123 ohm BITDAC for Parallax breakout board
12234     66 66 86 FF 
12238     1D 9A 65 FD |                 setxfrq ##$0CCCCCCC+1                      ' set streamer freq to 1/10th clk
1223c                 | '
1223c     D6 C6 01 F6 |                 mov 	t1,hbase			   '
12240     11 C6 65 F0 |                 shl 	t1,#17                             '
12244     E3 A2 01 F1 |                 add 	lutg8,t1                           ' add the pin base to he streamer constant
12248     02 92 85 F1 |                 sub 	i_upporch,#2			   ' the driver will call 2 blank lines itself to preload the buffer, so sub #2 from up porch time
1224c                 | 
1224c     01 C6 61 FD |                 cogid   t1              		   ' get a cogid
12250     0C C6 05 FA |                 mul     t1, #12                            ' compute the offset to PSRAM mailbox 
12254     E3 AE 01 F1 |                 add     mailbox, t1                        ' add offset to find this COG's mailbox
12258                 | 
12258                 | ''--------  frame rendering main loop  ---------------------------------------------------
12258                 | 
12258     28 06 64 FD | p101            setq 	#3
1225c     00 A5 05 FB | 		rdlong  vblankptr,ptra
12260     28 6A 64 FD |                 setq    #47+6				   ' read sprite data
12264     D8 DC 01 FB | 	 	rdlong  sprite1pointer,spriteptr
12268     00 4A 06 F6 | 		mov     spriteline,#0                      ' init the sprite line variable
1226c     00 A0 05 F6 |                 mov     dlinum, #0
12270     01 9E 05 F1 |                 add     frames,#1			   ' increment the frame counter
12274     D5 B8 01 F6 |                 mov     dlptr2,dlptr			   ' init the temporary DL pointer
12278                 | 
12278                 | 
12278     00 9C 05 F6 |                 mov     linenum,#0			   ' init the current line #
1227c     00 CE 05 F6 |                 mov     rcnt,#0			   	   ' init the DL repeat counter
12280     ED D2 01 F6 |                 mov     rcnt2a,affffffff 		   ' why?!                
12284                 |                 
12284                 | 
12284                 | 
12284                 | '' ------- reload the palette. If bit31 set, don't reload, to prevent blinking while modifying the palette
12284                 |   
12284     1F A8 15 F4 |                 testb   paletteptr,#31 wc
12288     29 FE 65 3D |          if_nc  setq2   #255
1228c     D4 00 00 3B |          if_nc  rdlong  $000, paletteptr                   'read palette
12290                 | 
12290                 | '' -----   up porch (before the picture)
12290                 | 
12290     C0 C2 01 F6 |                 mov     hsync0,sync_000      	           ' init constants for sync
12294     C1 C4 01 F6 |                 mov     hsync1,sync_001	
12298     40 92 45 FB |                 callpa  i_upporch ,#blank                  ' call the porch line i_upporch (-2) times
1229c     D2 00 68 FC |                 wrlong  #0,vblankptr                       ' the vblank time ends here
122a0                 |  
122a0                 |    
122a0                 |  
122a0     E1 8A C1 FC |                 xcont   m_bs,hsync0                        ' horizontal sync
122a4     E2 8C B1 FC |                 xzero   m_sn,hsync1
122a8     60 00 B0 FD |          	     call    #dli	                  ' call DL interpreter for line #0 at line #(-2) - 2 lines earlier, so it can start preloading data from PSRAM
122ac     E1 8E C1 FC |                 xcont   m_bv,hsync0     
122b0     E1 90 C1 FC |                 xcont   m_vi,hsync0
122b4     DF 80 78 FC |                          rdfast  #64,buf1d                          ' prepare the HUB buffer for 4 scanlines
122b8                 | 
122b8     E1 8A C1 FC |                 xcont   m_bs,hsync0                        ' horizontal sync
122bc     E2 8C B1 FC |                 xzero   m_sn,hsync1
122c0     48 00 B0 FD | 		call    #dli
122c4     E1 8E C1 FC |                 xcont   m_bv,hsync0     
122c8     E1 90 C1 FC |                 xcont   m_vi,hsync0
122cc     20 01 B0 FD |                  call    #sprite				   ' sprites for line #0
122d0                 |                 	
122d0                 |                 
122d0                 | 
122d0                 |  
122d0                 | '' ------- the main screen drawing starts here
122d0                 | 
122d0     E1 8A C1 FC | p301            xcont   m_bs,hsync0   			  ' make a right porch
122d4     E2 8C B1 FC |                 xzero   m_sn,hsync1                       ' make hsync
122d8     30 00 B0 FD |                 call    #dli                              ' process the DL for line+2                
122dc     E1 8E C1 FC |                 xcont   m_bv,hsync0
122e0     00 A2 C5 FC |                 xcont   lutg8,#0			  ' display the line 
122e4     01 9C 05 F1 |                  add     linenum,#1                        ' increment the current line number 
122e8     04 01 B0 FD |                  call    #sprite                           ' process sprites for line+1             
122ec                 |               
122ec                 | 
122ec     CD 9C 09 F2 |                 cmp     linenum,i_totalvis  wz            ' check if all lines displayed
122f0     DC FF 9F 5D |     if_nz       jmp     #p301                             ' if not, display the next line
122f4                 | 
122f4                 | ' ---------------- All visible lines displayed now, start vblank  
122f4                 | 
122f4     D2 02 68 FC | p112            wrlong  #1,vblankptr                       ' tell the system that the vblank started
122f8     28 96 45 FB |                 callpa  i_downporch ,#blank                ' bottom blanks
122fc     C2 C2 01 F6 |                 mov     hsync0,sync_222                    ' vsync on
12300     C3 C4 01 F6 |                 mov     hsync1,sync_223
12304     25 94 45 FB |                 callpa  i_vsync,#blank                     ' vertical sync blanks
12308     4C FF 9F FD |                 jmp     #p101                              ' return to the main loop
1230c                 | 
1230c                 | '' --------------- END of frame rendering loop ---------------------------------------------------------------------------
1230c                 | 
1230c                 | '' --------------- Display list interpreter ---------------------------------------------------------------------------
1230c                 | 
1230c     00 CE 0D F2 | dli             cmp     rcnt,#0 wz			   ' check the DL repeat counter 
12310                 | 
12310     DC BA 01 AB |     if_z        rdlong  dl,dlptr2				
12314     04 B8 05 A1 |     if_z        add     dlptr2,#4
12318     14 00 90 AD |     if_z        jmp     #p307                              ' no repeat, goto read and interpret the next DL entry
1231c                 | 
1231c     01 CE 8D F1 |                 sub     rcnt,#1 wz                         ' decrement the repeat counter
12320     EB BA 01 56 |     if_nz       mov     dl,rdl                             ' restore repeating DL entry from temporary buffer
12324     E8 D2 19 F7 |                 incmod  rcnt2a,rcnt2 wcz                   ' address update counter
12328     EA BA 01 C1 |     if_c        add     dl,roffset                         ' if it rollovers, add the offset to the data address
1232c     DD D6 01 F6 |                 mov     rdl,dl                             ' save the result
12330                 | 
12330     DD C0 19 F6 | p307	        mov     framebuf2,dl wcz                   ' move this to framebuf2. If normal DL entry, the frame buffer start will be extracted from this
12334     DD C6 41 F8 |                 getnib  t1,dl,#0
12338     02 C6 0D F2 |                 cmp     t1,#%0010 wz			   ' 0010 - display a normal graphics line, preload it from the PSRAM
1233c     70 00 90 AD |     if_z        jmp     #preload
12340     00 C6 0D F2 |     		cmp     t1,#%0000 wz			   ' 0000 - display a line from a PSRAM list
12344     94 00 90 AD |     if_z        jmp     #preload2
12348     01 C6 0D F2 |                 cmp     t1,#%0001 wz			   ' 0001 - repeat
1234c     0C 00 90 AD |     if_z        jmp     #p390
12350     03 C6 0D F2 |                 cmp     t1,#%0011 wz			   ' 0011 - palette reload
12354     28 00 90 AD |     if_z        jmp     #p391  
12358                 | 
12358     2D 00 64 FD | p308            ret
1235c                 |    
1235c     DC D6 01 FB | p390            rdlong  rdl,dlptr2                         ' read the next DL entry to repeat
12360     E0 CE 39 F9 |                 getword rcnt,framebuf2,#1                  ' read the repeat count
12364     04 CE 45 F0 |                 shr     rcnt,#4                            ' from 12 upper bits
12368     ED D2 01 F6 |                 mov     rcnt2a,affffffff                   ' I still don't know why?
1236c     E0 D0 61 F8 |                 getnib  rcnt2,framebuf2,#4                 ' read the pointer update counter
12370     E0 D4 31 F9 |                 getword roffset,framebuf2,#0               ' read the offset to add
12374     04 D4 45 F0 |                 shr     roffset,#4                         ' clean the command field from offset
12378     04 D4 65 F0 |                 shl     roffset,#4                         ' and make it ready to add to the DL entry (address=20 upper bits)
1237c     8C FF 9F FD |                 jmp     #dli                               ' now start repeating 
12380                 |  
12380                 | '' --------  Reload palette. To do 
12380                 | 
12380     E0 C6 51 F8 | p391           	getnib  t1,framebuf2,#2			   ' get a bank (0..15) of 16 colors
12384     04 C6 65 F0 |          	shl     t1,#4				   ' compute the LUT address
12388     0C C0 45 F0 |         	shr     framebuf2,#12			   ' compute the HUB address of 16 new colors
1238c     29 1E 64 FD |          	setq2   #15				   ' load 16 entries
12390     00 C6 8D F9 |          	altd    t1                                 ' from t1 LUT address
12394     E0 00 00 FB |         	rdlong  $000, framebuf2         	
12398     70 FF 9F FD |         	jmp     #dli                
1239c                 |       
1239c                 | '' --------------- A display list interpreter end ------------------------------------------------------------------------    
1239c                 | 
1239c                 | 
1239c                 | '' --------------- Blank and vsync procedures called via callpa have to be in the middle of the code ---------------------
1239c                 | 
1239c     E1 8A C1 FC | blank           xcont   m_bs,hsync0                        ' horizontal sync
123a0     E2 8C B1 FC |                 xzero   m_sn,hsync1
123a4     E1 8E C1 FC |                 xcont   m_bv,hsync0     
123a8     E1 90 C1 FC |                 xcont   m_vi,hsync0
123ac     FB ED 6F 0B |         _ret_   djnz    pa,#blank
123b0                 |         
123b0                 | '' -------------- Preload a line from PSRAM        
123b0                 |         
123b0     D0 BC 01 F6 | preload         mov     buf1c,dlinum			   ' preload a line buffer #dlinum (0..3)
123b4     0A BC 65 F0 |                 shl     buf1c,#10		           ' 1024 bytes per line
123b8     DF BC 01 F1 |                 add     buf1c,buf1d			   ' add the start address (himem-debug-4096) : Todo: debug variable!
123bc     DE B4 01 F6 |                 mov     buf1,buf1c
123c0     03 A0 05 F7 |                 incmod  dlinum,#3
123c4                 | 
123c4     04 C0 45 F0 |                 shr     framebuf2,#4                      ' get the PSRAM start address from DL - Todo: use new DL format
123c8     32 B7 01 F6 |                 mov     buf2,a1024
123cc     E0 B2 01 F6 |                 mov     cmd,framebuf2                      ' set the address
123d0     0B B2 3D F8 |                 setnib  cmd, #%1011, #7                    ' attach the command - read burst from the external memory
123d4     28 04 64 FD |                 setq    #2				   ' write 3 longs to the mailbox
123d8     D7 B2 61 0C |     _ret_       wrlong  cmd,mailbox			   ' read the PSRAM
123dc                 |  
123dc                 |  
123dc                 | preload2      '  incmod  dlinum,#3
123dc     04 C0 45 F0 |                 shr 	framebuf2,#4
123e0     ED B2 01 F6 |                 mov 	cmd,affffffff
123e4     E0 B4 01 F6 |                 mov 	buf1,framebuf2
123e8     28 02 64 FD |                 setq	#1
123ec     D7 B2 61 0C |     _ret_	wrlong  cmd,mailbox
123f0                 |                 
123f0                 | 
123f0                 | '' -------------- Draw sprites
123f0                 | 
123f0     CF 5C 02 F6 | sprite          mov t8,frames
123f4     10 5C 0E F5 | 		and t8,#16 wz
123f8     11 48 06 F6 |                 mov spritenum, #17			' 16 +2 sprites. Todo: this should be a parameter
123fc     10 48 06 A6 | 	if_z    mov spritenum, #16	
12400                 | 		
12400                 | 
12400     24 57 02 F6 | p802            mov     t5,spritenum		   	' prepare a pointer to load sprite data
12404     03 56 06 FA |                 mul     t5,#3          			' one sprite data set needs 3 longs
12408     EF 56 96 F9 |                 alts    t5,#sprite1xy
1240c     00 4E 3A F9 |                 getword sprite_y,0-0,#1		        ' get a sprite y
12410     0F 4E 66 F7 |                 signx	sprite_y,#15			' they can be negative
12414     EF 56 96 F9 |                 alts    t5,#sprite1xy
12418     00 4C 32 F9 |                 getword sprite_x,0-0,#0                 ' and x
1241c     0F 4C 66 F7 |                 signx	sprite_x,#15
12420     F0 56 96 F9 |                 alts    t5,#sprite1wh
12424     00 52 3A F9 |                 getword sprite_h,0-0,#1		       	' get a sprite height
12428     01 52 86 F1 |                 sub     sprite_h,#1
1242c     F0 56 96 F9 |                 alts    t5,#sprite1wh
12430     00 50 32 F9 |                 getword sprite_w,0-0,#0                 ' and width
12434                 | 
12434                 | 
12434     32 4D 5A F2 |                	cmps	sprite_x,a1024 wcz	         
12438     BC 00 90 3D |      if_ge	jmp 	#p801                           ' go out if >1023
1243c     00 50 5E F2 |               	cmps	sprite_w,#0 wcz	         
12440     B4 00 90 AD |      if_e	jmp 	#p801                           ' go out if w=0
12444     00 52 5E F2 |               	cmps	sprite_h,#0 wcz	         
12448     AC 00 90 AD |      if_e	jmp 	#p801                           ' go out if h=0
1244c     00 5E 06 F6 |                 mov 	t9,#0
12450     28 5F 82 F1 |                 sub 	t9,sprite_w                      	
12454     2F 4D 5A F2 |      		cmps  	sprite_x,t9 wcz   		'
12458     9C 00 90 ED |      if_le	jmp 	#p801	                        ' go out if sprite out of screen at right
1245c                 |      
1245c     CE C8 01 F6 |   		mov     t2,linenum			' display line # to check if sprite has to be displayed
12460     27 C9 D9 F1 |   		subs    t2,sprite_y wcz                 ' check if the sprite has to be displayed
12464     90 00 90 CD |      if_c       jmp     #p801				' if not, go out
12468     29 C9 19 F2 |                 cmp     t2,sprite_h wcz		    	' we have now the sprite line #, check, if it is not >= sprite height
1246c     88 00 90 1D |      if_gt      jmp     #p801				' if yes, go out
12470                 |                 
12470     25 CB 01 F6 |                 mov     t3,spriteline			' compute the line buffer addres where to put the sprite line
12474     0A CA 65 F0 |                 shl     t3,#10			       	' =1024*spriteline where spriteline=0..3		' 
12478     DF CA 01 F1 |                 add     t3,buf1d			' line buffer addr
1247c                 |   		
1247c     1F 4C 16 F4 |   		testb	sprite_x,#31 wc 		' check if sprite pos <0
12480     26 CB 01 31 |      if_nc      add     t3,sprite_x   			' if >=0 add xpos. If <0, the address is the start of the line  - now we have the address to where wmlong the sprite
12484                 | 
12484     28 C9 01 FA |                 mul 	t2,sprite_w			' compute the offset to the sprite line data
12488     26 51 02 C1 |      if_c	add     sprite_w,sprite_x		' if sprite_x negative, shorten the width
1248c     26 C9 81 C1 |      if_c	sub 	t2,sprite_x			' and add the offset (sub negative) to the sprite data offset
12490                 |  
12490     EE 56 96 F9 |                 alts    t5,#sprite1pointer		' get the pointer to the sprite (3 longs per sprite data)
12494     00 C8 01 F1 |                 add     t2,0-0				' then add the offset
12498     10 00 90 CD |      if_c 	jmp     #p899		
1249c                 | 	
1249c                 | 	
1249c     26 CD 01 F6 | 		mov 	t4,sprite_x	'
124a0     28 CD 01 F1 | 		add	t4,sprite_w
124a4     32 CD 99 F1 | 		sub     t4,a1024 wcz			' check if the sprite goes right off the screen
124a8                 | 
124a8     E6 50 82 31 | 	if_nc	sub	sprite_w,t4			' if yes, make it narrower
124ac                 | 
124ac     28 59 02 F6 | p899		mov 	t6,sprite_w
124b0     01 58 86 F1 | 	 	sub     t6,#1
124b4     02 58 46 F0 | 	 	shr	t6,#2				' bytes to longs
124b8                 | 
124b8     28 58 62 FD |                 setq   	t6
124bc     E4 E0 02 FB |                 rdlong 368,t2				' read sprite data to the cog
124c0     28 5D 02 F6 |                 mov t8,sprite_w
124c4     03 5C 0E F5 |                 and t8,#3 wz				' if width mod 4=0 we have full longs, nothing to do
124c8     24 00 90 AD |         if_z    jmp #p898
124cc                 |          
124cc                 |         
124cc     70 5F 06 F6 |                 mov  t9,#368
124d0     2C 5F 02 F1 |                 add t9,t6				' find the last long of the sprite
124d4                 | 
124d4     04 5C C6 F2 |                 subr t8,#4				' if modulo4=1, mask 3 bytes, if 2, mask 2, if 1, mask 3
124d8     08 5C 06 FA |                 mul t8,#8				' bits to shr
124dc     FF FF 7F FF 
124e0     FF 5B 06 F6 |                 mov t7,##-1				' full of 1s
124e4     2E 5B 42 F0 |                 shr t7,t8				' SHR to make 0s for masking
124e8     00 5E 8E F9 |                 altd t9,#0				' and mask 
124ec     2D 01 00 F5 |                 and 0-0, t7
124f0                 |                
124f0                 | 
124f0     28 58 62 FD | p898            setq   t6				' write the sprite data to the line buffer
124f4     E5 E0 7A FA |                 wmlong 368,t3				
124f8                 |                 
124f8     C1 49 7E FB | p801            djnf spritenum,#p802			' get the next sprite
124fc     03 4A 06 F7 |                 incmod spriteline,#3			' prepare to fill the next line
12500     2D 00 64 FD |                 ret
12504                 | 	
12504                 | 	
12504                 |                
12504                 |  
12504                 | '' -------------- Graphics line ------------------------------------------------------------
12504                 |  
12504                 | 
12504                 | '' consts and vars
12504                 | 
12504     52 4D 35 D5 | sync_000        long    %1101010100_1101010100_1101010100_10    '
12508     AE 42 35 D5 | sync_001        long    %1101010100_1101010100_0010101011_10    '        hsync
1250c     52 45 15 55 | sync_222        long    %0101010100_0101010100_0101010100_10    'vsync
12510     AE 4A 15 55 | sync_223        long    %0101010100_0101010100_1010101011_10    'vsync + hsync
12514                 | 
12514     00 2C 1A 00 | border          long    %00000000_00011010_00101100_00000000
12518                 | 
12518                 | '------ these longs will be set by setmode function
12518                 | 
12518     00 00 00 00 | m_bs            long    0        'blanks before sync
1251c     00 00 00 00 | m_sn            long    0        'sync
12520     00 00 00 00 | m_bv            long    0        'blanks before visible
12524     00 00 00 00 | m_vi            long    0        'visible pixels #
12528                 | 'm_border        long    0        'left/right borders
12528     00 00 00 00 | i_upporch       long    0        'up porch lines
1252c     00 00 00 00 | i_vsync         long    0        'vsync lines
12530     00 00 00 00 | i_downporch     long    0        'down porch lines
12534     00 00 00 00 | i_cpl           long    0        'chars/longs per line
12538     00 00 00 00 | i_totalvis      long    0
1253c                 | 
1253c                 | '-------------------------------------
1253c                 |  
1253c     00 00 00 00 | linenum         long    0
12540     00 00 00 00 | frames          long    0
12544     00 00 00 00 | dlinum long 0
12548     00 04 88 70 | lutg8           long    $70880400 ' 0111_0000_1000_1000
1254c                 | 
1254c     00 00 00 00 | vblankptr       long    0
12550     00 00 00 00 | modeptr         long    0
12554     00 00 00 00 | paletteptr      long    0
12558     00 00 00 00 | dlptr           long    0
1255c     01 00 00 00 | hbase           long    1
12560     00 00 00 00 | mailbox         long    0
12564     00 00 00 00 | spriteptr          long 0
12568                 | 
12568     00 00 00 00 | cmd             long    0
1256c     00 EC 07 00 | buf1            long    $80000-1024-4096
12570     00 04 00 00 | buf2            long    1024
12574     01 00 00 00 | dlptr2          long    1
12578     01 00 00 00 | dl              long    1
1257c                 | 
1257c     00 00 00 00 | buf1c long 0
12580     00 EC 07 00 | buf1d            long    $80000-1024-4096
12584     01 00 00 00 | framebuf2       long    1
12588     01 00 00 00 | hsync0          long    1
1258c     01 00 00 00 | hsync1          long    1
12590                 | 
12590     01 00 00 00 | t1              long    1
12594     00 00 00 00 | t2 long 0
12598     00 00 00 00 | t3 long 0
1259c     00 00 00 00 | t4 long 0
125a0                 | 
125a0     00 00 00 00 | rcnt            long    0  'dl repeat count
125a4     00 00 00 00 | rcnt2           long    0
125a8     00 00 00 00 | rcnt2a          long    0
125ac     00 00 00 00 | roffset         long    0
125b0     00 00 00 00 | rdl             long    0  'dl repeat line
125b4     00 00 00 00 | dlc             long    0  'dl command
125b8                 | 
125b8     FF FF FF FF | affffffff       long    $ffffffff
125bc     00 00 00 00 | sprite1pointer long 0
125c0     00 00 00 00 | sprite1xy      long 0
125c4     00 00 00 00 | sprite1wh      long 0
125c8     00 00 00 00 | sprite2pointer long 0
125cc     00 00 00 00 | sprite2xy      long 0
125d0     00 00 00 00 | sprite2wh      long 0
125d4     00 00 00 00 | sprite3pointer long 0
125d8     00 00 00 00 | sprite3xy      long 0
125dc     00 00 00 00 | sprite3wh      long 0
125e0     00 00 00 00 | sprite4pointer long 0
125e4     00 00 00 00 | sprite4xy      long 0
125e8     00 00 00 00 | sprite4wh      long 0
125ec     00 00 00 00 | sprite5pointer long 0
125f0     00 00 00 00 | sprite5xy      long 0
125f4     00 00 00 00 | sprite5wh      long 0
125f8     00 00 00 00 | sprite6pointer long 0
125fc     00 00 00 00 | sprite6xy      long 0
12600     00 00 00 00 | sprite6wh      long 0
12604     00 00 00 00 | sprite7pointer long 0
12608     00 00 00 00 | sprite7xy      long 0
1260c     00 00 00 00 | sprite7wh      long 0
12610     00 00 00 00 | sprite8pointer long 0
12614     00 00 00 00 | sprite8xy      long 0
12618     00 00 00 00 | sprite8wh      long 0
1261c     00 00 00 00 | sprite9pointer long 0
12620     00 00 00 00 | sprite9xy      long 0
12624     00 00 00 00 | sprite9wh      long 0
12628     00 00 00 00 | sprite10pointer long 0
1262c     00 00 00 00 | sprite10xy      long 0
12630     00 00 00 00 | sprite10wh      long 0
12634     00 00 00 00 | sprite11pointer long 0
12638     00 00 00 00 | sprite11xy      long 0
1263c     00 00 00 00 | sprite11wh      long 0
12640     00 00 00 00 | sprite12pointer long 0
12644     00 00 00 00 | sprite12xy      long 0
12648     00 00 00 00 | sprite12wh      long 0
1264c     00 00 00 00 | sprite13pointer long 0
12650     00 00 00 00 | sprite13xy      long 0
12654     00 00 00 00 | sprite13wh      long 0
12658     00 00 00 00 | sprite14pointer long 0
1265c     00 00 00 00 | sprite14xy      long 0
12660     00 00 00 00 | sprite14wh      long 0
12664     00 00 00 00 | sprite15pointer long 0
12668     00 00 00 00 | sprite15xy      long 0
1266c     00 00 00 00 | sprite15wh      long 0
12670     00 00 00 00 | sprite16pointer long 0
12674     00 00 00 00 | sprite16xy      long 0
12678     00 00 00 00 | sprite16wh      long 0
1267c     00 00 00 00 | sprite17pointer long 0
12680     00 00 00 00 | sprite17xy      long 0
12684     00 00 00 00 | sprite17wh      long 0
12688     00 00 00 00 | sprite18pointer long 0
1268c     00 00 00 00 | sprite18xy      long 0
12690     00 00 00 00 | sprite18wh      long 0
12694     00 00 00 00 | spritenum long 0
12698                 | 
12698     00 00 00 00 | spriteline long 0
1269c     84 03 00 00 | sprite_x long 900
126a0     00 00 00 00 | sprite_y long 0
126a4     10 00 00 00 | sprite_w long 16
126a8     40 00 00 00 | sprite_h long 64
126ac     00 00 00 00 | l2 long 0
126b0     00 00 00 00 | t5 long 0
126b4     00 00 00 00 | t6 long 0
126b8     00 00 00 00 | t7 long 0
126bc     00 00 00 00 | t8 long 0
126c0     00 00 00 00 | t9 long 0
126c4     00 00 00 00 | preloadaddr long 0
126c8     00 00 00 00 | preloadlineaddr long 0
126cc     00 04 00 00 | a1024 long 1024
126d0                 | 
126d0     E0 03 00 00 | aa long 992
126d4     FF 03 00 00 | a1023 long 1023
126d8     00 10 00 00 | a4096 long 4096
126dc                 |  fit 368
126dc                 |  fit 368
126dc                 | _psram_spin2_dat_
126dc     00 00 00 00 
      ...             
127d4     00 00 00 00 
127d8     00 00 00 00 |     listdata long 0[8*8]
127dc                 |             orgh
127dc                 | 
127dc                 | ' driver state
127dc     FF FF FF FF | drivercog   long    -1  ' COG id of driver
127e0     FF FF FF FF | driverlock  long    -1  ' LOCK id of driver
127e4                 | 
127e4                 | ' delay profile
127e4     07 00 00 00 
127e8     00 CF 7B 05 
127ec     80 D1 F0 08 
127f0     80 4F 47 0C | delayTable  long    7,92_000000,150_000000,206_000000,258_000000,310_000000,333_000000,0
127f4     80 C4 60 0F 
127f8     80 39 7A 12 
127fc     40 2D D9 13 
12800     00 00 00 00 | 	byte	$80, $c4, $60, $0f, $80, $39, $7a, $12, $40, $2d, $d9, $13, $00, $00, $00, $00
12804                 | 
12804                 | ' data to be passed to driver when starting it
12804                 | startupData
12804     00 00 00 00 |     long    0           ' current frequency
12808     00 00 00 00 |     long    FLAGS       ' optional flags for driver
1280c     00 00 00 00 |     long    0           ' reset pin mask on port A for PSRAM (none)
12810     00 00 00 00 |     long    0           ' reset pin mask on port B for PSRAM (none)
12814     28 00 00 00 |     long    DATABUS     ' PSRAM data bus start pin
12818     24 28 01 00 |     long    deviceData  ' address of devices data structure in HUBRAM
1281c     A4 28 01 00 |     long    qosData     ' address of QoS data structure in HUBRAM
12820     C4 28 01 00 |     long    mailboxes   ' address of mailbox structure in HUBRAM
12824                 | 
12824                 | ' data for memory
12824                 | deviceData
12824                 |     ' 16 bank parameters follow (16MB per bank)
12824     00 00 00 00 
      ...             
1285c     00 00 00 00 
12860     00 00 00 00 |     long    0[16]                               ' banks 0-15
12864                 |     ' 16 banks of pin parameters follow
12864     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 0 
12868     39 38 00 00 |     long    (CLK_PIN << 8) | CE_PIN             ' bank 1 
1286c     FF FF FF FF 
      ...             
1289c     FF FF FF FF 
128a0     FF FF FF FF |     long    -1[14]                              ' banks 2-15
128a4                 | 
128a4                 | ' data for COG polling
128a4                 | qosData 
128a4     00 00 FF FF 
128a8     00 00 FF FF 
128ac     00 00 FF FF 
128b0     00 00 FF FF |     long    $FFFF0000[8]    ' cog 0-7 default QoS parameters
128b4     00 00 FF FF 
128b8     00 00 FF FF 
128bc     00 00 FF FF 
128c0     00 00 FF FF | 	byte	$00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff, $00, $00, $ff, $ff
128c4                 |     
128c4                 | ' mailbox storage
128c4                 | 
128c4                 | mailboxes
128c4     00 00 00 00 
      ...             
1291c     00 00 00 00 
12920     00 00 00 00 |     long    0[8*3]          ' 3 longs per mailbox per COG
12924                 | 	alignl
12924                 | _psram16drv_spin2_dat_
12924                 |                             orgh
12924     00 00 00 00 
      ...             
1293c     00 00 00 00 
12940     00 00 00 00 | scratch_buffer              long    0[8]    ' 8 scratch longs in hub (one per possible driver COG id)
12944                 | 
12944                 | driver_start
12944                 |                             org
12944 000             | '..................................................................................................
12944 000             | ' Memory layout for COG RAM once operational:
12944 000             | '
12944 000             | '  COG RAM address      Usage
12944 000             | '  ---------------      ----
12944 000             | '    $00-$17            Mailbox data area (3 longs x 8 COGs) (24)
12944 000             | '    $18-$1F            Mailbox HUB parameter addresses per COG (8)
12944 000             | '    $20-$7F            COG service handlers (8 COGs x 12 longs per COG) (96)
12944 000             | '    $80-$FF            EXECF vector storage (8 requests x 16 banks) (128)
12944 000             | '   $100-$197           Mailbox poller, error handlers, and all driver management code
12944 000             | '  ~$198-$1F3           State and register variables
12944 000             | '
12944 000             | ' Also during driver COG startup:
12944 000             | '  $00-$17  is init as temporary init code - stage 2 (EXECF vector table init)
12944 000             | ' $100-$1FF is uses as temporary init code - stage 1 (does HW setup & majority of driver init)
12944 000             | '..................................................................................................
12944 000             |                             
12944 000             | ' Mailbox storage after vector initialization
12944 000             | 
12944 000 FC 01 B0 FD | req0                        call    #init                   'do HW setup/initialization
12948 001 F0 E3 AB FA | data0                       rdlut   c, b wz                 'read bank info          
1294c 002 F0 DF 03 F6 | count0                      mov     a, b                    'set COGRAM address low nibble
12950 003 68 F0 07 A6 | req1        if_z            mov     ptra, #(no_vect & $1ff) 'set pointer to invalid vectors
12954 004 0A E2 17 F4 | data1                       testb   c, #FLASH_BIT wc        'check type: R/O PSRAM (1) or R/W PSRAM (0)
12958 005 50 F0 07 16 | count1      if_nc_and_nz    mov     ptra, #(rw_vect & $1ff) 'set pointer to R/W PSRAM vectors
1295c 006 58 F0 07 46 | req2        if_c_and_nz     mov     ptra, #(ro_vect & $1ff) 'set pointer to R/O PSRAM vectors
12960 007 08 E2 07 F6 | data2                       mov     c, #$8                  'setup vector base to $80
12964 008 F1 DF 0B F8 | count2                      setnib  a, c, #1                'prepare vector base address for bank
12968 009 00 DE 8F F9 | req3                        altd    a, #0                   'prepare COG destination read address
1296c 00a 61 01 A4 FA | data3                       rdlut   0-0, ptra++             'read vector into table in COG RAM
12970 00b 0F E2 0F F7 | count3                      incmod  c, #15 wz               'next vector
12974 00c EC FF 9F 5D | req4        if_nz           jmp     #count2                 'repeat
12978 00d 0F E0 0F F7 | data4                       incmod  b, #15 wz               'next bank
1297c 00e C8 FF 9F 5D | count4      if_nz           jmp     #data0                  'repeat
12980 00f 20 F0 07 F6 | req5                        mov     ptra, #$20              'setup base LUT address to clear
12984 010 50 0A DC FC | data5                       rep     #5, #80                 'update next 80 longs      
12988 011 E2 F1 13 F2 | count5                      cmp     ptra, header wc         'check if LUT address range 
1298c 012 E3 F1 93 32 | req6        if_nc           cmpr    ptra, trailer wc        '...falls in/outside control region
12990 013 61 01 3C CC | data6       if_c            wrlut   #0, ptra++              'if outside, clear LUT RAM      
12994 014 61 B1 37 3C | count6      if_nc           wrlut   addr1, ptra++           'copy control vector table into LUT
12998 015 A5 29 00 31 | req7        if_nc           add     $-1, const512           'increment source of LUT write data
1299c 016 FF C0 03 F6 | data7                       mov     burstwrite, 255-0       'save real bank 15 burst write vector
129a0 017 26 FF 05 06 | count7      _ret_           mov     255, #dolist            'setup list address, return to notify
129a4 018             | 
129a4 018             | ' Mailbox parameter addresses per COG once patched
129a4 018             |                             
129a4 018 04 00 00 00 | cog0mboxdata                long    0*12+4                  'address offset for cog0 mbox data
129a8 019 10 00 00 00 | cog1mboxdata                long    1*12+4                  'address offset for cog1 mbox data
129ac 01a 1C 00 00 00 | cog2mboxdata                long    2*12+4                  '...
129b0 01b 28 00 00 00 | cog3mboxdata                long    3*12+4
129b4 01c 34 00 00 00 | cog4mboxdata                long    4*12+4
129b8 01d 40 00 00 00 | cog5mboxdata                long    5*12+4
129bc 01e 4C 00 00 00 | cog6mboxdata                long    6*12+4
129c0 01f 58 00 00 00 | cog7mboxdata                long    7*12+4                  'address offset for cog7 mbox data
129c4 020             | 
129c4 020             | '..................................................................................................
129c4 020             | ' Per COG request and state setup and service branching
129c4 020             |         
129c4 020             | cog0                 
129c4 020 20 F0 07 F6 |                             mov     ptra, #$20+0*10         'determine COG0 parameter save address
129c8 021 18 F2 03 F6 |                             mov     ptrb, cog0mboxdata      'determine COG0 mailbox data address
129cc 022 D0 C3 03 F6 |                             mov     id, id0                 'get COG0 state
129d0 023 E1 47 3B F9 |                             getword limit, id, #1           'get COG0 burst limit
129d4 024 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
129d8 025 30 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
129dc 026 00 B0 03 F6 |                             mov     addr1, req0             'get mailbox request parameter for COG0
129e0 027 01 B2 03 F6 |                             mov     hubdata, data0          'get COG0 mailbox data parameter
129e4 028 02 B4 03 F6 |                             mov     count, count0           'get COG0 mailbox count parameter
129e8 029 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
129ec 02a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
129f0 02b 33 CA 63 FD |                             execf   request-0               'jump to service
129f4 02c             | cog1                        
129f4 02c 2A F0 07 F6 |                             mov     ptra, #$20+1*10         'determine COG1 parameter save address
129f8 02d 19 F2 03 F6 |                             mov     ptrb, cog1mboxdata      'determine COG1 mailbox data address
129fc 02e D1 C3 03 F6 |                             mov     id, id1                 'get COG1 state
12a00 02f E1 47 3B F9 |                             getword limit, id, #1           'get COG1 burst limit
12a04 030 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
12a08 031 00 04 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12a0c 032 03 B0 03 F6 |                             mov     addr1, req1             'get mailbox request parameter for COG1
12a10 033 04 B2 03 F6 |                             mov     hubdata, data1          'get COG1 mailbox data parameter
12a14 034 05 B4 03 F6 |                             mov     count, count1           'get COG1 mailbox count parameter
12a18 035 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12a1c 036 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12a20 037 33 CA 63 FD |                             execf   request-0               'jump to service
12a24 038             | cog2                         
12a24 038 34 F0 07 F6 |                             mov     ptra, #$20+2*10         'determine COG2 parameter save address
12a28 039 1A F2 03 F6 |                             mov     ptrb, cog2mboxdata      'determine COG2 mailbox data address
12a2c 03a D2 C3 03 F6 |                             mov     id, id2                 'get COG2 state
12a30 03b E1 47 3B F9 |                             getword limit, id, #1           'get COG2 burst limit
12a34 03c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
12a38 03d D0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12a3c 03e 06 B0 03 F6 |                             mov     addr1, req2             'get mailbox request parameter for COG2
12a40 03f 07 B2 03 F6 |                             mov     hubdata, data2          'get COG2 mailbox data parameter
12a44 040 08 B4 03 F6 |                             mov     count, count2           'get COG2 mailbox count parameter
12a48 041 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12a4c 042 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12a50 043 33 CA 63 FD |                             execf   request-0               'jump to service
12a54 044             | cog3                        
12a54 044 3E F0 07 F6 |                             mov     ptra, #$20+3*10         'determine COG3 parameter save address
12a58 045 1B F2 03 F6 |                             mov     ptrb, cog3mboxdata      'determine COG3 mailbox data address
12a5c 046 D3 C3 03 F6 |                             mov     id, id3                 'get COG3 state
12a60 047 E1 47 3B F9 |                             getword limit, id, #1           'get COG3 burst limit
12a64 048 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
12a68 049 A0 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12a6c 04a 09 B0 03 F6 |                             mov     addr1, req3             'get mailbox request parameter for COG3
12a70 04b 0A B2 03 F6 |                             mov     hubdata, data3          'get COG3 mailbox data parameter
12a74 04c 0B B4 03 F6 |                             mov     count, count3           'get COG3 mailbox count parameter
12a78 04d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12a7c 04e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12a80 04f 33 CA 63 FD |                             execf   request-0               'jump to service
12a84 050             | cog4                        
12a84 050 48 F0 07 F6 |                             mov     ptra, #$20+4*10         'determine COG4 parameter save address
12a88 051 1C F2 03 F6 |                             mov     ptrb, cog4mboxdata      'determine COG4 mailbox data address
12a8c 052 D4 C3 03 F6 |                             mov     id, id4                 'get COG4 state
12a90 053 E1 47 3B F9 |                             getword limit, id, #1           'get COG4 burst limit
12a94 054 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
12a98 055 70 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12a9c 056 0C B0 03 F6 |                             mov     addr1, req4             'get mailbox request parameter for COG4
12aa0 057 0D B2 03 F6 |                             mov     hubdata, data4          'get COG4 mailbox data parameter
12aa4 058 0E B4 03 F6 |                             mov     count, count4           'get COG4 mailbox count parameter
12aa8 059 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12aac 05a 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12ab0 05b 33 CA 63 FD |                             execf   request-0               'jump to service
12ab4 05c             | cog5                        
12ab4 05c 52 F0 07 F6 |                             mov     ptra, #$20+5*10         'determine COG5 parameter save address
12ab8 05d 1D F2 03 F6 |                             mov     ptrb, cog5mboxdata      'determine COG5 mailbox data address
12abc 05e D5 C3 03 F6 |                             mov     id, id5                 'get COG5 state
12ac0 05f E1 47 3B F9 |                             getword limit, id, #1           'get COG5 burst limit
12ac4 060 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
12ac8 061 40 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12acc 062 0F B0 03 F6 |                             mov     addr1, req5             'get mailbox request parameter for COG5
12ad0 063 10 B2 03 F6 |                             mov     hubdata, data5          'get COG5 mailbox data parameter
12ad4 064 11 B4 03 F6 |                             mov     count, count5           'get COG5 mailbox count parameter
12ad8 065 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12adc 066 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12ae0 067 33 CA 63 FD |                             execf   request-0               'jump to service
12ae4 068             | cog6                        
12ae4 068 5C F0 07 F6 |                             mov     ptra, #$20+6*10         'determine COG6 parameter save address
12ae8 069 1E F2 03 F6 |                             mov     ptrb, cog6mboxdata      'determine COG6 mailbox data address
12aec 06a D6 C3 03 F6 |                             mov     id, id6                 'get COG6 state
12af0 06b E1 47 3B F9 |                             getword limit, id, #1           'get COG6 burst limit
12af4 06c 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
12af8 06d 10 03 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12afc 06e 12 B0 03 F6 |                             mov     addr1, req6             'get mailbox request parameter for COG6
12b00 06f 13 B2 03 F6 |                             mov     hubdata, data6          'get COG6 mailbox data parameter
12b04 070 14 B4 03 F6 |                             mov     count, count6           'get COG6 mailbox count parameter
12b08 071 D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12b0c 072 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12b10 073 33 CA 63 FD |                             execf   request-0               'jump to service
12b14 074             | cog7                        
12b14 074 66 F0 07 F6 |                             mov     ptra, #$20+7*10         'determine COG7 parameter save address
12b18 075 1F F2 03 F6 |                             mov     ptrb, cog7mboxdata      'determine COG7 mailbox data address
12b1c 076 D7 C3 03 F6 |                             mov     id, id7                 'get COG7 state
12b20 077 E1 47 3B F9 |                             getword limit, id, #1           'get COG7 burst limit
12b24 078 08 D3 AF FA |                             rdlut   resume, ptra[8] wz      'check if we are in the middle of something
12b28 079 E0 02 90 5D |             if_nz           jmp     #restore                'if so restore state and resume
12b2c 07a 15 B0 03 F6 |                             mov     addr1, req7             'get mailbox request parameter for COG7
12b30 07b 16 B2 03 F6 |                             mov     hubdata, data7          'get COG7 mailbox data parameter
12b34 07c 17 B4 03 F6 |                             mov     count, count7           'get COG7 mailbox count parameter
12b38 07d D8 CB FB F8 |                             getbyte request, addr1, #3      'get request + bank info
12b3c 07e 00 CA 8F F9 |                             altd    request, #0             'lookup jump vector service table 
12b40 07f 33 CA 63 FD |                             execf   request-0               'jump to service
12b44 080             | 
12b44 080             |                             fit     128
12b44 080             |                             fit     128
12b44 080             | pad                         long    0[128-$]                'align init code to $80
12b44 080             | 
12b44 080             | '..................................................................................................
12b44 080             | 
12b44 080             | ' This initialization code ($80-$FF) gets reused as the main service EXECF jump table later (128 longs)
12b44 080             | 
12b44 080             | init                        
12b44 080             |                             ' get driver scratch long address in hub
12b44 080 01 DA 63 FD |                             cogid   hubscratch              'get cogid
12b48 081 01 DA 07 F1 |                             add     hubscratch, #1          'increase by 1 from 1-8
12b4c 082 04 DA 07 FA |                             mul     hubscratch, #4          'multiply by 4 to get 4-32
12b50 083 F9 DB C3 F2 |                             subr    hubscratch, ptrb        'get scratch area as one of 8 longs before driver
12b54 084             |                     
12b54 084             |                             ' read in the additional LUT RAM code
12b54 084 F9 41 03 F1 |                             add     lutcodeaddr, ptrb       'determine hub address of LUT code   
12b58 085 29 9E 67 FD |                             setq2   #511-(hwinit & $1ff)    'read the remaining instructions 
12b5c 086 A0 61 00 FB |                             rdlong  hwinit & $1ff, lutcodeaddr  '...and load into LUT RAM address $240
12b60 087             | 
12b60 087             |                             ' read the startup parameters
12b60 087 28 0E 64 FD |                             setq    #8-1                    'read 8 longs from hub
12b64 088 00 41 07 FB |                             rdlong  startupparams, ptra     '.. as the startup parameters 
12b68 089             | 
12b68 089             |                             ' setup some of the config flag dependent state and patch LUTRAM
12b68 089 1C 42 0F F4 |                             testb   flags, #EXPANSION_BIT wz'test for graphics expansion enabled
12b6c 08a             | 
12b6c 08a F9 71 03 A1 |             if_z            add     expansion, ptrb         'compensate for HUB address
12b70 08b 01 00 00 5F 
12b74 08c FB 70 07 56 |             if_nz           mov     expansion, ##donerepeats'disable expansion when flag bit clear
12b78 08d 1D 42 17 F4 |                             testb   flags, #UNREGCLK_BIT wc 'check if we have registered clks
12b7c 08e AA 57 43 35 |             if_nc           or      clkconfig, registered   'enable this if so
12b80 08f 00 58 07 36 |             if_nc           mov     clkdelay, #0            'remove clk delay if registered clock
12b84 090             | 
12b84 090             |                             ' setup data pin modes and data bus pin group in streamer commands
12b84 090 38 48 07 F5 |                             and     datapins, #%111000      'compute base pin
12b88 091 01 00 00 FF 
12b8c 092 C0 49 47 F5 |                             or      datapins, ##(15<<6)     'configure 16 pins total
12b90 093 A4 DF 03 F6 |                             mov     a, datapins             'get data pin base
12b94 094 A4 55 03 FC |                             wrpin   registered, datapins    'prepare data pins for address phase transfer
12b98 095 03 DE 47 F0 |                             shr     a, #3                   'determine data pin group
12b9c 096 07 DE 07 F5 |                             and     a, #7                   'ignore the unwanted bits
12ba0 097 08 DE 47 F5 |                             or      a, #8
12ba4 098 EF 2F 2B F8 |                             setnib  ximm8lut, a, #5         'setup bus group in streamer
12ba8 099 EF 31 2B F8 |                             setnib  xrecvlo8, a, #5
12bac 09a EF 35 2B F8 |                             setnib  xrecvdata, a, #5
12bb0 09b EF 37 2B F8 |                             setnib  xsenddata, a, #5
12bb4 09c EF 39 2B F8 |                             setnib  xsendimm, a, #5
12bb8 09d 01 DE 07 F1 |                             add     a, #1
12bbc 09e EF 33 2B F8 |                             setnib  xrecvhi8, a, #5         ' increase port by one
12bc0 09f             |  
12bc0 09f             |                             ' setup device control pin states
12bc0 09f 29 3E 64 FD |                             setq2   #32-1                   'read 32 longs to LUTRAM
12bc4 0a0 A5 01 00 FB |                             rdlong  $000, devicelist        'read bank/pin data for all banks    
12bc8 0a1 01 00 00 FF 
12bcc 0a2 00 4A 07 F6 |                             mov     const512, ##512         'prepare constant
12bd0 0a3             | 
12bd0 0a3 10 F2 07 F6 |                             mov     ptrb, #16               'point to bank pin config data
12bd4 0a4 10 14 DC FC |                             rep     @pinloop, #16           'iterate through 16 banks
12bd8 0a5 E1 CF B7 FA |                             rdlut   pinconfig, ptrb++ wc    'invalid if pin config bit 31 is one
12bdc 0a6 AF CF 03 F5 |                             and     pinconfig, pinmask      'save us from invalid bits in args
12be0 0a7 E7 53 E3 38 |             if_nc           getbyte cspin, pinconfig, #0    'read CS pin number
12be4 0a8 A9 01 08 3C |             if_nc           wrpin   #0, cspin               'clear smart pin mode
12be8 0a9 59 52 63 3D |             if_nc           drvh    cspin                   'setup pins for all banks
12bec 0aa E7 51 EB 38 |             if_nc           getbyte clkpin, pinconfig, #1   'read CLK pin number
12bf0 0ab 50 50 63 3D |             if_nc           fltl    clkpin                  'disable Smartpin clock output mode
12bf4 0ac A8 57 03 3C |             if_nc           wrpin   clkconfig, clkpin       'set clk to Smartpin transition output
12bf8 0ad A8 03 18 3C |             if_nc           wxpin   #1, clkpin              'configure for 1 clocks between transitions
12bfc 0ae 58 50 63 3D |             if_nc           drvl    clkpin                  'set clk state low
12c00 0af             | pinloop
12c00 0af             |                             ' generate minimum CE high time before access
12c00 0af A1 07 00 FF 
12c04 0b0 40 40 17 FD |                             qdiv    frequency, ##1000000    'convert from Hz to MHz
12c08 0b1 18 E2 63 FD |                             getqx   c                       'get P2 clocks per microsecond
12c0c 0b2 96 DE 07 F6 |                             mov     a, #MIN_CS_DELAY_US     'get time before active delay in microseconds 
12c10 0b3 F1 DF 03 FA |                             mul     a, c                    'convert microseconds to clocks
12c14 0b4 1F DE 63 FD |                             waitx   a                       'delay
12c18 0b5 E8 05 B0 FD |                             call    #hwinit                 'setup HW into QSPI mode
12c1c 0b6             | 
12c1c 0b6             |                             ' setup the COG mailboxes and addresses 
12c1c 0b6 08 04 DC FC |                             rep     #2, #8                  'setup loop to patch mailbox addresses
12c20 0b7 38 70 A5 F9 |                             alti    $+1, #%111_000          'increase D field
12c24 0b8 A7 31 00 F1 |                             add     cog0mboxdata, mbox      'apply base offset to mailbox data
12c28 0b9             | 
12c28 0b9 28 2E 64 FD |                             setq    #24-1
12c2c 0ba A7 01 68 FC |                             wrlong  #0, mbox                'clear out mailboxes ????
12c30 0bb             | 
12c30 0bb             |                             ' setup the polling loop for active COGs 
12c30 0bb 01 C2 63 FD |                             cogid   id
12c34 0bc D0 C3 97 F9 |                             alts    id, #id0                'determine id register of control COG
12c38 0bd 00 90 B6 F9 |                             setd    patchid, #0             'patch into destination address
12c3c 0be 2A F0 63 FD |                             push    ptra                    'save ptra before we lose it
12c40 0bf 0A F0 07 F6 |                             mov     ptra, #10
12c44 0c0 E1 F1 03 FA |                             mul     ptra, id
12c48 0c1 20 F0 07 F1 |                             add     ptra, #$20              'prep ptra for reloadcogs
12c4c 0c2 B0 C3 97 F9 |                             alts    id, #cog0_handler       'add to handler base
12c50 0c3 00 48 BE F9 |                             sets    ctrlpollinst, #0-0      'patch into jump instruction
12c54 0c4 03 C2 07 FA |                             mul     id, #3
12c58 0c5 E1 49 B2 F9 |                             setd    ctrlpollinst, id
12c5c 0c6 09 C3 A7 FA |                             rdlut   id, ptra[9]             'save original value
12c60 0c7 09 C1 37 FC |                             wrlut   initctrl, ptra[9]       'prep LUT data for reloadcogs
12c64 0c8 D8 01 B0 FD |                             call    #reloadcogs
12c68 0c9 09 C3 37 FC |                             wrlut   id, ptra[9]             'restore original value
12c6c 0ca 2B F0 63 FD |                             pop     ptra                    'restore original ptra
12c70 0cb             |                             ' move LUT control vectors into temporary location to avoid clobbering them later
12c70 0cb D8 E5 B7 F9 |                             setd    d, #addr1
12c74 0cc 60 E4 BF F9 |                             sets    d, #(ctrl_vect & $1ff)
12c78 0cd 08 04 DC FC |                             rep     #2, #8
12c7c 0ce 3F E4 A7 F9 |                             alti    d, #%111_111            'patch & increment d/s fields in next instr.
12c80 0cf 60 B0 A7 FA |                             rdlut   addr1-0, #$60-0
12c84 0d0             | 
12c84 0d0             |                             'setup control COG service handling, we need to patch 5 instructions
12c84 0d0             |                             'one existing instruction is moved earlier and four instructions get replaced
12c84 0d0 01 C2 63 FD |                             cogid   id
12c88 0d1 0C DE 07 F6 |                             mov     a, #(cog1-cog0)         'get code separation of handlers
12c8c 0d2 E1 DF 03 FA |                             mul     a, id                   'scale ID by separation
12c90 0d3 24 DE 07 F1 |                             add     a, #cog0+4              'add to base for COG0 and offset
12c94 0d4 EF E5 B3 F9 |                             setd    d, a                    'set this as the destination
12c98 0d5 02 DE 07 F1 |                             add     a, #2                   'increment COG address
12c9c 0d6 EF E5 BB F9 |                             sets    d, a                    'set this as the source
12ca0 0d7 3C E4 A7 F9 |                             alti    d, #%111_100             
12ca4 0d8 00 00 00 F6 |                             mov     0-0, 0-0                'move instruction
12ca8 0d9 EE E4 BF F9 |                             sets    d, #controlpatch        'set source of patched instructions
12cac 0da 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
12cb0 0db 3F E4 A7 F9 |                             alti    d, #%111_111
12cb4 0dc 00 00 00 F6 |                             mov     0-0, 0-0
12cb8 0dd A5 E5 03 F1 |                             add     d, const512             'skip two instructions
12cbc 0de A5 E5 03 F1 |                             add     d, const512
12cc0 0df 02 04 DC FC |                             rep     #2, #2                  'patch two instructions
12cc4 0e0 3F E4 A7 F9 |                             alti    d, #%111_111
12cc8 0e1 00 00 00 F6 |                             mov     0-0, 0-0
12ccc 0e2             |                             
12ccc 0e2             |                             ' setup register values for control vector loop setup after we return
12ccc 0e2 E1 C5 03 F6 |                             mov     header, id              'get cog ID
12cd0 0e3 0A C4 07 FA |                             mul     header, #10             'multiply by size of state memory per COG
12cd4 0e4 20 C4 07 F1 |                             add     header, #$20            'add to COG state base address in LUT
12cd8 0e5 E2 C7 03 F6 |                             mov     trailer, header         'determine start/end LUT address
12cdc 0e6 09 C6 07 F1 |                             add     trailer, #9             '...for control region
12ce0 0e7 E0 C3 43 F5 |                             or      id, initctrl            'set id field for control COG
12ce4 0e8 D0 C3 8F F9 |                             altd    id, #id0
12ce8 0e9 E1 01 00 F6 |                             mov     0-0, id                 'setup id field for notification
12cec 0ea F8 F3 03 F6 |                             mov     ptrb, ptra              'get startup parameter address
12cf0 0eb 04 F2 07 F1 |                             add     ptrb, #4                'ptrb[-1] will be cleared at notify
12cf4 0ec 00 E0 07 F6 |                             mov     b, #0                   'prepare b for upcoming loop
12cf8 0ed 2A 14 66 0D |                 _ret_       push    #notify                 'continue init in mailbox area
12cfc 0ee             |  
12cfc 0ee D8 CB 7B F8 | controlpatch                getnib  request, addr1, #7      'instructions to patch for control COG
12d00 0ef 07 CA 07 F5 |                             and     request, #7
12d04 0f0 F8 CB 03 F1 |                             add     request, ptra           'add request vector offset
12d08 0f1 E5 CB A3 FA |                             rdlut   request, request        'lookup jump vector service table 
12d0c 0f2             | 
12d0c 0f2             |                             fit     $100                    'ensure all init code fits this space
12d0c 0f2             |                             fit     $100                    'ensure all init code fits this space
12d0c 0f2             | 
12d0c 0f2 00 00 00 00 
      ...             
12d3c 0fe 00 00 00 00 
12d40 0ff 00 00 00 00 |                             long    0[$100-$]               'pad more if required until table ends
12d44 100             | 
12d44 100             | '..................................................................................................
12d44 100             | ' Error result handling and COG notification of request completion
12d44 100             | 
12d44 100 04 04 4C FB | unsupported                 callpa  #-ERR_UNSUPPORTED, #err 'operation not supported
12d48 101 03 02 4C FB | invalidbank                 callpa  #-ERR_INVALID_BANK, #err'bank accessed has no devices mapped
12d4c 102 02 06 4C FB | invalidlist                 callpa  #-ERR_INVALID_LIST, #err'invalid list item request
12d50 103 01 08 4C FB | alignmenterror              callpa  #-ERR_ALIGNMENT, #err   'flash alignment error
12d54 104 05 EC 07 F6 | busyerror                   mov     pa, #-ERR_BUSY          'flash busy, falls through...
12d58 105 D0 C3 8F F9 | err                         altd    id, #id0                'adjust for the running COG
12d5c 106 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          'cancel any list in progress by this COG
12d60 107 08 01 3C FC |                             wrlut   #0, ptra[8]             'cancel any resume state
12d64 108 32 04 64 FD |                             skipf   #%10                    'dont notify with success code 0 below
12d68 109 BF ED 67 FC |                             wrlong  pa, ptrb[-1]            'set error code in mailbox response
12d6c 10a BF 01 6C FC | notify                      wrlong  #0, ptrb[-1]            'if no error, clear mailbox request
12d70 10b 0B C2 0F F4 |                             testb   id, #NOTIFY_BIT wz      'check if COG also wants ATN notification
12d74 10c E1 DF C3 F9 |                             decod   a, id                   'convert COG ID to bitmask
12d78 10d 3F DE 63 AD |             if_z            cogatn  a                       'notify COG via ATN
12d7c 10e             | ' Poller re-starts here after a COG is serviced
12d7c 10e 0F C2 0F F4 | poller                      testb   id, #PRIORITY_BIT wz    'check what type of COG was serviced
12d80 10f E6 5F 03 57 |             if_nz           incmod  rrcounter, rrlimit      'cycle the round-robin (RR) counter
12d84 110 AF 45 CB F9 |                             bmask   mask, rrcounter         'generate a RR skip mask from the count
12d88 111             | ' Main dynamic polling loop repeats until a request arrives
12d88 111 00 00 DC FC | polling_loop                rep     #0-0, #0                'repeat until we get a request for something
12d8c 112 28 2E 64 FD |                             setq    #24-1                   'read 24 longs
12d90 113 A7 01 00 FB |                             rdlong  req0, mbox              'get all mailbox requests and data longs
12d94 114             | 
12d94 114 B0 01 B0 FB | polling_code                tjs     req0, cog0_handler      ']A control handler executes before skipf &
12d98 115 32 44 63 FD |                             skipf   mask                    ']after all priority COG handlers if present
12d9c 116 B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Initially this is just a dummy placeholder
12da0 117 B2 0D B0 FB |                             tjs     req2, cog2_handler      ']loop taking up the most space assuming 
12da4 118 B3 13 B0 FB |                             tjs     req3, cog3_handler      ']a polling loop with all round robin COGs 
12da8 119 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']from COG1-7 and one control COG, COG0.
12dac 11a B5 1F B0 FB |                             tjs     req5, cog5_handler      ']This loop is recreated at init time 
12db0 11b B6 25 B0 FB |                             tjs     req6, cog6_handler      ']based on the active COGs being polled
12db4 11c B7 2B B0 FB |                             tjs     req7, cog7_handler      ']and whether priority or round robin.
12db8 11d B1 07 B0 FB |                             tjs     req1, cog1_handler      ']Any update of COG parameters would also
12dbc 11e B2 0D B0 FB |                             tjs     req2, cog2_handler      ']regenerate this code, in case priorities
12dc0 11f B3 13 B0 FB |                             tjs     req3, cog3_handler      ']have changed.
12dc4 120 B4 19 B0 FB |                             tjs     req4, cog4_handler      ']A skip pattern that is continually 
12dc8 121 B5 1F B0 FB |                             tjs     req5, cog5_handler      ']changed selects which RR COG is the
12dcc 122 B6 25 B0 FB |                             tjs     req6, cog6_handler      ']first to be polled in the seqeuence.
12dd0 123 B7 2B B0 FB | pollinst                    tjs     req7, cog7_handler      'instruction template for RR COGs
12dd4 124             | 
12dd4 124 B0 01 B0 FB | ctrlpollinst                tjs     req0, cog0_handler      'instruction template for control
12dd8 125 32 44 63 FD | skipfinst                   skipf   mask                    'instruction template for skipf
12ddc 126             |  
12ddc 126             | '..................................................................................................
12ddc 126             | ' List handler                               
12ddc 126             | 
12ddc 126 01 B0 A7 FB | dolist                      tjf     addr1, #real_list       'if addr1 is all ones this is a real list
12de0 127 33 C0 63 FD |                             execf   burstwrite              'otherwise do a burst write to this bank
12de4 128 28 0E 64 FD | real_list                   setq    #8-1                    'read 8 longs (largest request size)
12de8 129 D9 B1 03 FB |                             rdlong  addr1, hubdata          '..to update the request state
12dec 12a D7 B1 BF FB |                             tjns    addr1, #invalidlist     'error if request list item not valid
12df0 12b D0 C3 8F F9 |                             altd    id, #id0                'get COG state
12df4 12c 09 00 3C F4 |                             bith    0-0, #LIST_BIT wcz      'retain fact that we are in a list
12df8 12d 09 C2 27 F4 |                             bith    id, #LIST_BIT           'retain fact that we are in a list
12dfc 12e 44 FF 9F AD |             if_z            jmp     #unsupported            'no list recursion is allowed!
12e00 12f D8 CB FB F8 |                             getbyte request, addr1, #3      'get upper byte of this request
12e04 130 00 CA 8F F9 | service_request             altd    request, #0             'get request address in COG RAM
12e08 131 33 00 60 FD |                             execf   0-0                     'process the request 
12e0c 132             | 
12e0c 132             | '..................................................................................................
12e0c 132             | ' Restoring per COG state and resuming where we left off
12e0c 132             | 
12e0c 132 00 B1 A7 FA | restore                     rdlut   addr1, ptra[0]          'restore then continue with working state
12e10 133 01 B3 A7 FA |                             rdlut   hubdata, ptra[1]
12e14 134 02 B5 A7 FA |                             rdlut   count, ptra[2]
12e18 135 03 B7 B7 FA |                             rdlut   addr2, ptra[3] wc       'C=1 indicates an extended request size
12e1c 136 D8 CB FB F8 |                             getbyte request, addr1, #3
12e20 137 33 D2 63 3D |             if_nc           execf   resume                  'if not extended then resume immediately
12e24 138 04 B9 A7 FA |                             rdlut   total, ptra[4]          'we need to read the extended parameters
12e28 139 05 BB A7 FA |                             rdlut   offset1, ptra[5]
12e2c 13a 06 BD A7 FA |                             rdlut   offset2, ptra[6]
12e30 13b 07 BF A7 FA |                             rdlut   link, ptra[7]
12e34 13c 09 D5 A7 FA |                             rdlut   orighubsize, ptra[9]
12e38 13d 33 D2 63 FD |                             execf   resume                  'then resume what we were doing last time
12e3c 13e             |                    
12e3c 13e             | '..................................................................................................
12e3c 13e             | ' Re-configuration of QoS settings and custom polling loop sequence generator
12e3c 13e             | 
12e3c 13e 2A 14 66 FD | reconfig                    push    #notify                 'setup return addr, then reload 
12e40 13f 28 0E 64 FD | reloadcogs                  setq    #8-1                    'reload all per COG QoS params
12e44 140 A6 B1 03 FB |                             rdlong  addr1, coglist          'use addr1+ as 8 long scratch area
12e48 141 D0 DF B7 F9 |                             setd    a, #id0
12e4c 142 D8 DF BF F9 |                             sets    a, #addr1
12e50 143 FE FF FF FF 
12e54 144 28 00 66 FD |                             setq    ##!($FF + (1<<LIST_BIT))'preserve list flag and COG ID state 
12e58 145 08 04 DC FC |                             rep     #2, #8                  'repeat for 8 COGs
12e5c 146 3F DE A7 F9 |                             alti    a, #%111_111 
12e60 147 00 00 F0 F9 |                             muxq    0-0, 0-0
12e64 148 09 01 A4 FA | patchid                     rdlut   0-0, ptra[9]            'restore static control COG ID information
12e68 149 01 E2 63 FD |                             cogid   c
12e6c 14a F1 41 C3 F9 |                             decod   excludedcogs, c         'exclude driver cog initially
12e70 14b 08 DE 07 F6 |                             mov     a, #$8                  'a iterates through prio levels 8=lowest
12e74 14c 01 EC 67 F6 |                             neg     pa, #1                  'start with all ones
12e78 14d 07 E2 07 F6 | fillprio                    mov     c, #7                   'c iterates through cogs
12e7c 14e D0 E3 97 F9 | prioloop                    alts    c, #id0
12e80 14f 00 E0 03 F6 |                             mov     b, 0-0
12e84 150 F0 E5 3B F9 |                             getword d, b, #1                'get burst field
12e88 151 F2 E5 CB F7 |                             test    d wz                    'if burst=0 
12e8c 152 F1 41 23 A4 |             if_z            bith    excludedcogs, c         '...then exclude this COG from polling
12e90 153 0C 00 90 AD |             if_z            jmp     #excluded               
12e94 154 F0 E5 5B F8 |                             getnib  d, b, #3                'get RR/PRI flag & priority
12e98 155 EF E5 0B F2 |                             cmp     d, a wz                 'compare against current priority level
12e9c 156 F1 ED 83 A8 |             if_z            rolnib  pa, c, #0               'if matches include COG at this level
12ea0 157 F6 E3 7F FB | excluded                    djnf    c, #prioloop            'repeat for all 8 COGs
12ea4 158 0F DE 0F F7 |                             incmod  a, #15 wz               'next level
12ea8 159 CC FF 9F 5D |             if_nz           jmp     #fillprio 
12eac 15a             | 
12eac 15a             | 'determine priority cogs and build instructions for the polling sequence
12eac 15a 00 EE 07 F6 |                             mov     pb, #0                  'clear out set of priority COGs
12eb0 15b 03 DE 07 F6 |                             mov     a, #3                   'start with no COGs being polled + 3 instructions
12eb4 15c 14 E5 B7 F9 |                             setd    d, #polling_code        'initialize COGRAM write position
12eb8 15d             | 
12eb8 15d 08 18 DC FC |                             rep     @endprioloop, #8        'test all 8 priority slots
12ebc 15e 03 EC 17 F4 |                             testb   pa, #3 wc               'test validity bit, c=1 if invalid
12ec0 15f F6 E3 43 F8 |                             getnib  c, pa, #0               'get cogid ID at this priority level
12ec4 160 F1 EF 0B 34 |             if_nc           testb   pb, c wz                'check if already exists as priority COG
12ec8 161 F1 EF 23 14 |             if_nc_and_nz    bith    pb, c                   'and only add if it doesn't
12ecc 162 01 DE 07 11 |             if_nc_and_nz    add     a, #1                   'add another COG to poll 
12ed0 163 B0 E3 97 19 |             if_nc_and_nz    alts    c, #cog0_handler        'determine jump address per COG
12ed4 164 00 46 BE 19 |             if_nc_and_nz    sets    pollinst, #0-0          'patch jump handler in instruction
12ed8 165 03 E2 07 1A |             if_nc_and_nz    mul     c, #3
12edc 166 F1 47 B2 19 |             if_nc_and_nz    setd    pollinst, c             'patch REQ slot to poll in instruction
12ee0 167 38 E4 A7 19 |             if_nc_and_nz    alti    d, #%111_000            'generate new COG RAM write address
12ee4 168 23 01 00 16 |             if_nc_and_nz    mov     0-0, pollinst           'move the instruction to COG RAM
12ee8 169 04 EC 07 F0 |                             ror     pa, #4                  'advance to next priority
12eec 16a             | endprioloop
12eec 16a FF EE 67 F5 |                             xor     pb, #$ff                'invert to find all the non-priority COGs
12ef0 16b A0 EF 23 F5 |                             andn    pb, excludedcogs        'and remove any other excluded COGs
12ef4 16c F7 CD AB F7 |                             ones    rrlimit, pb wz          'count the number of RR COGs
12ef8 16d E6 DF 03 F1 |                             add     a, rrlimit              'account for this number of RR COGs to poll
12efc 16e 01 CC 87 F1 |                             sub     rrlimit, #1             'setup last RR count value for incmod
12f00 16f 38 E4 A7 F9 |                             alti    d, #%111_000            'generate the control polling instruction
12f04 170 24 01 00 F6 |                             mov     0-0, ctrlpollinst       'write the instruction
12f08 171 38 E4 A7 59 |             if_nz           alti    d, #%111_000            'if RR COG count not zero we need a skipf
12f0c 172 25 01 00 56 |             if_nz           mov     0-0, skipfinst          'add the skipf instruction
12f10 173 02 DE 07 51 |             if_nz           add     a, #2                   'account for the extra skipf overhead instructions
12f14 174 EF 23 B2 F9 |                             setd    polling_loop, a         'save it as the repeat count
12f18 175 2D 00 64 AD |             if_z            ret                             'we are done now, if no round robin COGs
12f1c 176             | 
12f1c 176             | ' populate the round robin COG polling instructions
12f1c 176 02 5E 07 F6 |                             mov     rrcounter, #2           'fill the RR poll instruction list twice
12f20 177 F7 E1 03 F6 | rrloop                      mov     b, pb                   'get the set of RR COGs
12f24 178 00 E2 07 F6 |                             mov     c, #0                   'start at COG ID = 0
12f28 179 00 DE 07 F6 |                             mov     a, #0                   'req mailbox COGRAM address for COG 0
12f2c 17a 01 E0 5F F0 | nextrrcog                   shr     b, #1 wcz               'test for COG ID in RR COG set, set C=1
12f30 17b EF 47 B2 C9 |             if_c            setd    pollinst, a             'patch REQ slot to poll in instruction
12f34 17c B0 E3 97 C9 |             if_c            alts    c, #cog0_handler        'determine jump address
12f38 17d 00 46 BE C9 |             if_c            sets    pollinst, #0-0          'patch jump handler in instruction
12f3c 17e 38 E4 A7 C9 |             if_c            alti    d, #%111_000            'generate new COG RAM write address
12f40 17f 23 01 00 C6 |             if_c            mov     0-0, pollinst           'move the instruction to COG RAM
12f44 180 01 E2 07 F1 |                             add     c, #1                   'increment the COG ID
12f48 181 03 DE 07 F1 |                             add     a, #3                   'increase the request address
12f4c 182 DC FF 9F 5D |             if_nz           jmp     #nextrrcog              'repeat for all COG IDs
12f50 183 F3 5F 6F 0B |             _ret_           djnz    rrcounter, #rrloop      'repeat twice, leave rrcounter zeroed
12f54 184             | '..................................................................................................
12f54 184             | ' Code to get/set driver settings per bank or to dump COG/LUT state
12f54 184             | 
12f54 184             | set_latency                                                 '            (a) set latency
12f54 184             | get_latency                                                 '            (b) get latency
12f54 184             | set_burst                                                   '            (c) set burst size of bank
12f54 184             | get_burst                                                   '            (d) get burst size of bank
12f54 184             |                                                             '            (e) dump state
12f54 184 D8 E1 73 F8 |                             getnib  b, addr1, #6            ' a b c d    get bank address
12f58 185 28 FE 67 FD | dump_state                  setq    #511                    ' | | | | e  prepare burst write
12f5c 186 D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write COG RAM to HUB
12f60 187             |                                                             ' | | | | e  account for following AUGS
12f60 187 04 00 00 FF 
12f64 188 00 B2 07 F1 |                             add     hubdata, ##2048         ' | | | | e  advance by 2k bytes
12f68 189 29 FE 67 FD |                             setq2   #511                    ' | | | | e  prepare burst write
12f6c 18a D9 01 60 FC |                             wrlong  0, hubdata              ' | | | | e  write LUT RAM to HUB
12f70 18b 10 E0 07 F1 |                             add     b, #16                  ' a b | | |  point to latency params
12f74 18c F0 DF A3 FA |                             rdlut   a, b                    ' a b c d |  read data for bank
12f78 18d D9 DF DB F8 |                             setbyte a, hubdata, #3          ' a | | | |  patch latency
12f7c 18e D9 DF 03 F6 |                             mov     a, hubdata              ' | | c | |  patch burst/delay etc
12f80 18f F0 DF 33 FC |                             wrlut   a, b                    ' a | c | |  if setting, save bank data
12f84 190 EF DF FB F8 |                             getbyte a, a, #3                ' | b | | |  extract latency field only
12f88 191 80 DF 67 FC |                             wrlong  a, ptrb                 ' | b | d |  write result          
12f8c 192 DC FD 9F FD |                             jmp     #notify                 ' a b c d e  return success
12f90 193             | 
12f90 193             | '..................................................................................................
12f90 193             | ' Misc EXECF code
12f90 193             | 
12f90 193 33 72 63 FD | start_read_exec             execf   newburstr
12f94 194 33 7C 63 FD | start_write_exec            execf   resumewrites
12f98 195 33 78 63 FD | continue_read_exec          execf   lockedreads
12f9c 196 33 7A 63 FD | continue_write_exec         execf   lockedwrites
12fa0 197             | 
12fa0 197             | '..................................................................................................
12fa0 197             | ' Variables
12fa0 197             | 
12fa0 197 08 00 CF 20 | ximm8lut        long    $20CF_0008              '8 nibble transfers via LUT to pins
12fa4 198 01 00 C6 E0 | xrecvlo8        long    $E0C6_0001              '1 byte read from lo bus pins
12fa8 199 01 00 C6 E0 | xrecvhi8        long    $E0C6_0001              '1 byte read from hi bus pins
12fac 19a 00 00 C0 F0 | xrecvdata       long    $F0C0_0000              'arbitrary 16 bit reads from 16 bit bus pins
12fb0 19b 00 00 C0 B0 | xsenddata       long    $B0C0_0000              'arbitrary 16 bit writes from hub to pins
12fb4 19c 02 00 C0 70 | xsendimm        long    $70C0_0002              'arbitrary 2x16 bit immediate writes from imm to pins
12fb8 19d             | 
12fb8 19d 00 00 00 80 | xfreq1          long    $80000000
12fbc 19e 00 00 00 40 | xfreq2          long    $40000000
12fc0 19f 03 00 00 00 | delay           long    3
12fc4 1a0             | 
12fc4 1a0             | lutcodeaddr                 
12fc4 1a0             | startupparams
12fc4 1a0             | excludedcogs                                    'careful: shared register use!
12fc4 1a0 CC 07 00 00 | frequency       long    lut_code - driver_start 'determine offset of LUT code from base
12fc8 1a1 00 00 00 00 | flags           long    0
12fcc 1a2             | mask                                            'careful: shared register use!
12fcc 1a2 00 00 00 00 | resetmaskA      long    0
12fd0 1a3             | limit                                           'careful: shared register use!
12fd0 1a3 00 00 00 00 | resetmaskB      long    0
12fd4 1a4 00 00 00 00 | datapins        long    0
12fd8 1a5             | const512                                        'careful: shared register use!
12fd8 1a5 00 00 00 00 | devicelist      long    0
12fdc 1a6 00 00 00 00 | coglist         long    0
12fe0 1a7 00 00 00 00 | mbox            long    0 
12fe4 1a8             | 
12fe4 1a8             | clkpin                                          'shared with code patched during init
12fe4 1a8 A8 03 18 FC | clockpatch      wxpin   #1, clkpin              'adjust transition delay to # clocks
12fe8 1a9             | cspin                                           'shared with code patched during init
12fe8 1a9 1D 3A 63 FD | speedpatch      setxfrq xfreq1                  'instruction to set read speed to sysclk/1
12fec 1aa 00 00 01 00 | registered      long    %100_000_000_00_00000_0 'config pin for clocked input
12ff0 1ab 4A 00 00 00 | clkconfig       long    %1_00101_0              'config for Smartpin transition output mode
12ff4 1ac 01 00 00 00 | clkdelay        long    1
12ff8 1ad 00 00 00 00 | regdatabus      long    0
12ffc 1ae             | 
12ffc 1ae 10 00 00 00 | deviceaddr      long    $10
13000 1af             | rrcounter
13000 1af 7F 7F 3F FF | pinmask         long    $ff3f7f7f
13004 1b0             | 
13004 1b0             | ' jump addresses for the per COG handlers
13004 1b0 20 00 00 00 | cog0_handler    long    cog0
13008 1b1 2C 00 00 00 | cog1_handler    long    cog1
1300c 1b2 38 00 00 00 | cog2_handler    long    cog2
13010 1b3 44 00 00 00 | cog3_handler    long    cog3
13014 1b4 50 00 00 00 | cog4_handler    long    cog4
13018 1b5 5C 00 00 00 | cog5_handler    long    cog5
1301c 1b6 68 00 00 00 | cog6_handler    long    cog6
13020 1b7 74 00 00 00 | cog7_handler    long    cog7
13024 1b8 0C 0F 00 00 | expansion       long    gfxexpansion - driver_start
13028 1b9             | 
13028 1b9             | ' EXECF sequences
13028 1b9 70 7A 80 22 | newburstr       long    (%0010001010000000011110 << 10) + r_burst
1302c 1ba 48 9B EF 00 | lockedfill      long    (%0000000011101111100110 << 10) + w_locked_fill
13030 1bb 41 F3 05 74 | restorefill     long    (%0111010000000101111100 << 10) + w_fill_cont
13034 1bc 80 22 3F 00 | lockedreads     long    (%0000000000111111001000 << 10) + r_locked_burst
13038 1bd 4B F3 E0 0F | lockedwrites    long    (%0000111111100000111100 << 10) + w_resume_burst
1303c 1be 4B 03 E0 0F | resumewrites    long    (%0000111111100000000000 << 10) + w_resume_burst
13040 1bf 76 02 8A 84 | resumereads     long    (%1000010010001010000000 << 10) + r_resume_burst
13044 1c0             | 'singlewrites    long    (%0000000010011111101000 << 10) + single_write
13044 1c0             | 
13044 1c0             | 
13044 1c0             | ' SKIPF sequences
13044 1c0             | skiptable
13044 1c0 7E 30 0C 00 |                 long    %11000011000001111110  ' read modify write byte
13048 1c1 0E 37 03 00 |                 long    %110011011100001110    ' read modify write word
1304c 1c2 00 00 00 00 |                 long    0                      ' read modify write long
13050 1c3 7E 00 00 00 |                 long    %1111110               ' single byte read
13054 1c4 8E 07 00 00 |                 long    %11110001110           ' single word read
13058 1c5 00 00 00 00 | pattern2        long    0
1305c 1c6 00 00 00 00 | pattern3        long    0
13060 1c7 77 02 00 00 | singlelong      long    %1001110111  
13064 1c8 FD 10 80 6F | skipcase_a      long    %01101111100000000001000011111101
13068 1c9 10 18 50 00 | skipcase_b      long    %00000000010100000001100000010000
1306c 1ca 11 3E 60 00 | skipcase_c      long    %00000000011000000011111000010001
13070 1cb 02 0F 00 00 | skipseq_write   long    %00000000000000000000111100000010
13074 1cc             | 
13074 1cc             | ' LUT RAM address values
13074 1cc FF 02 00 00 | complete_rw     long    complete_rw_lut
13078 1cd DD 02 00 00 | continue_read   long    continue_read_lut
1307c 1ce DB 02 00 00 | continue_write  long    continue_write_lut
13080 1cf F6 02 00 00 | noread          long    noread_lut
13084 1d0             | 
13084 1d0 00 00 00 00 | id0             long    0
13088 1d1 01 00 00 00 | id1             long    1
1308c 1d2 02 00 00 00 | id2             long    2
13090 1d3 03 00 00 00 | id3             long    3
13094 1d4 04 00 00 00 | id4             long    4
13098 1d5 05 00 00 00 | id5             long    5
1309c 1d6 06 00 00 00 | id6             long    6
130a0 1d7 07 00 00 00 | id7             long    7
130a4 1d8             | 
130a4 1d8             | 'These next 10 request registers below are also temporarily reused during init 
130a4 1d8             | 'and COG updates and need to follow immediately after id0-id7
130a4 1d8 00 00 00 00 | addr1           long    0
130a8 1d9 00 00 00 00 | hubdata         long    0
130ac 1da 00 00 00 00 | count           long    0
130b0 1db 00 00 00 00 | addr2           long    0
130b4 1dc 00 00 00 00 | total           long    0
130b8 1dd 00 00 00 00 | offset1         long    0
130bc 1de 00 00 00 00 | offset2         long    0
130c0 1df 00 00 00 00 | link            long    0
130c4 1e0             | 
130c4 1e0             | burstwrite                                      'note shared register use during init
130c4 1e0 00 10 F0 FE | initctrl        long    $FEF01000               'round robin, burst=$fff0, no ATN, ERR on busy
130c8 1e1 00 00 00 00 | id              long    0
130cc 1e2             | 
130cc 1e2 00 00 00 00 | header          long    0
130d0 1e3 00 00 00 00 | trailer         long    0
130d4 1e4 00 00 00 00 | cmdaddr         long    0
130d8 1e5 00 00 00 00 | request         long    0
130dc 1e6 00 00 00 00 | rrlimit         long    0
130e0 1e7 00 00 00 00 | pinconfig       long    0
130e4 1e8 00 00 00 00 | clks            long    0
130e8 1e9 00 00 00 00 | resume          long    0
130ec 1ea 00 00 00 00 | orighubsize     long    0
130f0 1eb 00 00 00 00 | wrclks          long    0
130f4 1ec             | 
130f4 1ec 00 00 00 00 | pattern         long    0
130f8 1ed 00 00 00 00 | hubscratch      long    0
130fc 1ee 00 10 00 00 | val4k           long    4096
13100 1ef             | 
13100 1ef             | ' temporary general purpose regs
13100 1ef 00 00 00 00 | a               long    0
13104 1f0 00 00 00 00 | b               long    0
13108 1f1 00 00 00 00 | c               long    0
1310c 1f2 00 00 00 00 | d               long    0
13110 1f3             | 
13110 1f3             |                 fit     502
13110 1f3             |                 fit     502
13110 1f3             | 
13110 1f3             | '..................................................................................................
13110 1f3             | 
13110 1f3             |             orgh
13110                 | 
13110                 | lut_code
13110                 | 'HW init code up to 80 longs
13110                 | 
13110                 | '..................................................................................................
13110                 | ' Memory layout for LUT RAM once operational:
13110                 | '
13110                 | '  LUT RAM address      Usage
13110                 | '  ---------------      ----
13110                 | '    $200-$20F          Bank parameters: burst + type + size per bank (16)
13110                 | '    $210-$21F          Pin parameters : latency + control pins per bank (16)
13110                 | '    $220-$26F          COG state storage (8 COGs x 10 longs per COG)
13110                 | '    $270-$3FF          Main PSRAM access code in LUTRAM 
13110                 | '
13110                 | ' Also during driver COG startup:
13110                 | ' $230-$24F is used for HW init setup
13110                 | ' $250-$26F is used as temporary vector storage 
13110                 | '..................................................................................................
13110                 | 
13110                 |                 org $230    
13110 230             | 
13110 230             | ' routines to (re-)initialize PSRAM chip into QSPI mode from whatever it was before
13110 230 1D 3C 63 FD | hwinit                      setxfrq xfreq2
13114 231 24 16 60 FD |                             pollxfi
13118 232 FF AA 2A FF 
1311c 233 FF ED 07 F6 |                             mov     pa, ##$5555FFFF         '$F5 - exit QSPI mode if we were in this mode
13120 234 28 00 B0 FD |                             call    #sendqspi
13124 235 07 F8 07 FF 
13128 236 F0 ED 07 F6 |                             mov     pa, ##$0FF00FF0         '$66 - reset enable
1312c 237 28 00 B0 FD |                             call    #sendspi
13130 238 F8 07 78 FF 
13134 239 0F EC 07 F6 |                             mov     pa, ##$F00FF00F         '$99 - reset
13138 23a 1C 00 B0 FD |                             call    #sendspi
1313c 23b 7F 78 78 FF 
13140 23c 00 ED 07 F6 |                             mov     pa, ##$F0F0FF00         '$35 - enter quad spi mode
13144 23d 10 00 B0 FD |                             call    #sendspi 
13148 23e 2D 00 64 FD |                             ret
1314c 23f             | 
1314c 23f 04 D0 07 F6 | sendqspi                    mov     clks,#4
13150 240 32 0C 64 FD |                             skipf   #%110
13154 241 9C EF 03 F6 |                             mov     pb, xsendimm
13158 242             | 
13158 242 10 D0 07 F6 | sendspi                     mov     clks, #16
1315c 243 97 EF 03 F6 |                             mov     pb, ximm8lut
13160 244 58 52 63 FD |                             drvl    cspin                   'active low chip select
13164 245 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
13168 246 F6 EF A3 FC |                             xinit   pb, pa                  'send 32 bit immediate data
1316c 247 A8 D1 23 FC |                             wypin   clks, clkpin            'start memory clock output 
13170 248 24 36 60 FD |                             waitxfi                         'wait for the completion
13174 249 50 48 63 FD |                             fltl    datapins                'float data bus
13178 24a 59 52 63 FD |                             drvh    cspin                   'raise chip select
1317c 24b 1F 90 65 0D |             _ret_           waitx   #200                    'delay before return to ensure CS delay
13180 24c             | 
13180 24c 00 00 00 00 
13184 24d 00 00 00 00 
13188 24e 00 00 00 00 
1318c 24f 00 00 00 00 |                 long    0[$270-32-$]
13190 250             |     
13190 250             |                 fit     $270-32  ' keep room for 32 vector longs
13190 250             |                 fit     $270-32  ' keep room for 32 vector longs
13190 250             | ' EXECF vectors only used during bank initialization at startup time, reclaimed later for COG state
13190 250             | rw_vect ' PSRAM jump vectors
13190 250 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
13194 251 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
13198 252 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
1319c 253 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
131a0 254 41 E3 00 74 |                 long    (%0111010000000000111000 << 10) + w_single
131a4 255 41 93 00 74 |                 long    (%0111010000000000100100 << 10) + w_single
131a8 256 41 73 00 74 |                 long    (%0111010000000000011100 << 10) + w_single
131ac 257 47 1B 00 FE |                 long    (%1111111000000000000110 << 10) + w_burst
131b0 258             | ro_vect ' R/O PSRAM jump vectors
131b0 258 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
131b4 259 71 52 5A EE |                 long    (%1110111001011010010100 << 10) + r_single
131b8 25a 71 42 5A AE |                 long    (%1010111001011010010000 << 10) + r_single
131bc 25b 70 7A 80 22 |                 long    (%0010001010000000011110 << 10) + r_burst
131c0 25c 00 01 00 00 |                 long    unsupported
131c4 25d 00 01 00 00 |                 long    unsupported
131c8 25e 00 01 00 00 |                 long    unsupported
131cc 25f 00 01 00 00 |                 long    unsupported
131d0 260             | ctrl_vect ' Control jump vectors
131d0 260 84 F9 39 00 |                 long    (%0000000000111001111110 << 10) + get_latency
131d4 261 00 01 00 00 |                 long    unsupported
131d8 262 84 F9 7B 00 |                 long    (%0000000001111011111110 << 10) + get_burst
131dc 263 85 01 7F 00 |                 long    (%0000000001111111000000 << 10) + dump_state
131e0 264 84 F9 D1 00 |                 long    (%0000000011010001111110 << 10) + set_latency
131e4 265 00 01 00 00 |                 long    unsupported
131e8 266 84 F9 CB 00 |                 long    (%0000000011001011111110 << 10) + set_burst
131ec 267 3E 01 00 00 |                 long    reconfig 
131f0 268             | no_vect ' Invalid bank jump vectors
131f0 268 01 01 00 00 |                 long    invalidbank
131f4 269 01 01 00 00 |                 long    invalidbank
131f8 26a 01 01 00 00 |                 long    invalidbank
131fc 26b 01 01 00 00 |                 long    invalidbank
13200 26c 01 01 00 00 |                 long    invalidbank
13204 26d 01 01 00 00 |                 long    invalidbank
13208 26e 01 01 00 00 |                 long    invalidbank
1320c 26f 01 01 00 00 |                 long    invalidbank
13210 270             | 
13210 270             |                 fit     $270
13210 270             |                 fit     $270
13210 270             | '..................................................................................................
13210 270             | ' PSRAM READS
13210 270             |                                                             ' a b c d e f
13210 270             |                                                             ' B W L B R L  (a) byte read
13210 270             |                                                             ' Y O O U E O  (b) word read
13210 270             |                                                             ' T R N R S C  (c) long read
13210 270             |                                                             ' E D G S U K  (d) new burst read
13210 270             |                                                             '       T M E  (e) resumed sub-burst
13210 270             |                                                             '         E D  (f) locked sub-burst
13210 270             | 
13210 270             | 
13210 270 DA D5 03 F6 | r_burst                     mov     orighubsize, count      '       d      preserve the original transfer count
13214 271 DA B5 CB F7 | r_single                    test    count wz                ' a b c |      test for RMW (z=1 if not RMW)
13218 272 36 D9 07 F6 |                             mov     pattern, #%100110110    ' a b c |      setup future skip pattern
1321c 273 20 D9 27 A5 |             if_z            andn    pattern, #%100100000    ' | | c |      no need to rearrange long data
13220 274 02 34 27 F9 |                             setword xrecvdata, #2, #0       ' a b c |      2x16 bit transfers to read a long
13224 275 80 B4 97 FB |                             tjz     count, #noread_lut      ' | | | d      check for any bytes to send
13228 276 E5 E1 43 F8 | r_resume_burst              getnib  b, request, #0          ' a b c d e    get bank parameter LUT address
1322c 277 F0 E1 A3 FA |                             rdlut   b, b                    ' a b c d e    get bank limit/mask
13230 278 F0 45 CB F9 |                             bmask   mask, b                 ' | | | d e    build mask for addr
13234 279 F0 3F EB F8 |                             getbyte delay, b, #1            ' a b c d e    get input delay of bank + flags
13238 27a 11 E0 47 F0 | p0                          shr     b, #17                  ' | | | d e    scale burst size based on bus rate
1323c 27b F0 47 23 F3 |                             fle     limit, b                ' | | | d e    apply any per bank limit to cog limit
13240 27c 05 3E 57 F0 |                             shr     delay, #5 wc            ' a b c d e    prep delay and test for registered inputs
13244 27d 10 5A 67 04 |             _ret_           bitnc   regdatabus, #16         ' | | | | |    setup if data bus is registered or not
13248 27e 10 5A 67 F4 |                             bitnc   regdatabus, #16         ' a b c d e    setup if data bus is registered or not
1324c 27f F9 3B 83 FC |                             wrfast  xfreq1, ptrb            ' a b c | |    setup streamer hub address for singles
13250 280 D9 3B 83 FC | r_locked_burst              wrfast  xfreq1, hubdata         ' | | | d e f  setup streamer hub address for bursts
13254 281 DA E3 03 F6 |                             mov     c, count                ' | | | d e f  get count of bytes left to read
13258 282 A3 E3 33 F3 |                             fle     c, limit wc             ' | | | d e f  enforce the burst limit
1325c 283 20 D0 17 F6 |                             mov     clks, #32 wc            ' a b c | | |  16 clock transitions to read a single long
13260 284 CD D3 03 C6 |             if_c            mov     resume, continue_read   ' | | | d e f  burst read will continue
13264 285 CC D3 03 36 |             if_nc           mov     resume, complete_rw     ' | | c d e f  burst/long read will complete
13268 286 32 20 64 FD |                             skipf   #%10000                 ' | | | d | |  extend skipf sequence for burst
1326c 287 E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 ' a b c d e |  get the bank's pin config address
13270 288 AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   ' a b c d e |  get the pin config for this bank
13274 289 E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    ' a b c d e |  byte 0 holds CS pin
13278 28a E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   ' a b c d e |  byte 1 holds CLK pin
1327c 28b 54 00 90 FD |                             jmp     #readcommon             ' a b c | | |  skip burst transfer setup for single reads
13280 28c             | 
13280 28c             |                             ' fall through to read bursts
13280 28c             |                         
13280 28c             | burst_read                  ' handle the 4k page boundary by splitting any read bursts that cross it 
13280 28c D8 E5 03 F6 |                             mov     d, addr1                'get start address
13284 28d 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
13288 28e EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
1328c 28f F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
13290 290 CD D3 03 C6 |             if_c            mov     resume, continue_read   'and we will continue with a sub-burst again
13294 291 00 D8 07 F6 |                             mov     pattern, #0             'enable all by default
13298 292 01 B0 17 F4 |                             testb   addr1, #1 wc            'test if start addr starts in second word
1329c 293 01 D8 67 F4 |                             bitnc   pattern, #1             'enable delay cycle if so
132a0 294 6C D0 63 FD |                             wrc     clks                    'and account for its clock cycle
132a4 295 00 B0 17 F4 |                             testb   addr1, #0 wc            'test if start addr starts on odd byte
132a8 296 02 D8 67 F4 |                             bitnc   pattern, #2             'add hi 8 transfer initially
132ac 297 F1 E5 03 F6 |                             mov     d, c                    'get count of bytes to be read into HUB
132b0 298 01 E4 87 C1 |             if_c            sub     d, #1                   'minus 1 if start addr was odd
132b4 299 01 E4 4F F0 |                             shr     d, #1 wz                'divide by two bytes to work out 16 bit transfers
132b8 29a F2 D1 23 F1 |                             addx    clks, d                 'account for this in the clock (with extra 8 bit cycle)
132bc 29b F2 35 23 F9 |                             setword xrecvdata, d, #0        'set the word transfer clocks needed in streamer
132c0 29c 03 D8 87 F4 |                             bitz    pattern, #3             'adjust the pattern to include this
132c4 29d 00 E2 D7 F4 |                             testb   c, #0 xorc              'test for end address
132c8 29e 04 D8 67 F4 |                             bitnc   pattern, #4             'include low 8 bit transfer if required
132cc 29f 0E D0 27 F1 |                             addx    clks, #14               'account for 14 address+delay clocks + and low 8 bit transfer
132d0 2a0 E8 D1 03 F1 |                             add     clks, clks
132d4 2a1             | readcommon
132d4 2a1 D8 C9 03 F6 |                             mov     cmdaddr, addr1          'get start address of transfer
132d8 2a2 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
132dc 2a3 EB C8 DF F8 |                             setbyte cmdaddr, #$EB, #3       'add quad read command
132e0 2a4             | 
132e0 2a4 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
132e4 2a5 69 C8 63 FD |                             rev     cmdaddr
132e8 2a6 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
132ec 2a7 61 C8 63 FD |                             mergeb  cmdaddr
132f0 2a8             | 
132f0 2a8 58 52 63 FD |                             drvl    cspin                   'activate chip select
132f4 2a9 58 48 63 FD |                             drvl    datapins                'enable data bus
132f8 2aa             |             '               setxfrq xfreq2                  'setup streamer frequency (sysclk/2)
132f8 2aa E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'stream out command+address
132fc 2ab A8 D1 23 FC |                             wypin   clks, clkpin            'start clock output
13300 2ac 00 00 CC FC |                             xcont   #0,#0                   '1 dummy transfer to resync to the streamer for timely tri-stating
13304 2ad 00 0C CC FC |                             xcont   #6,#0                   '6 clock transfers for bus turnaround delay
13308 2ae             |                           '  drvh    datapins                'enable this only if validating actual tri-state time on a scope
13308 2ae 50 48 63 FD |                             fltl    datapins                'safe to float the data bus, address has been sent by now
1330c 2af A4 5B 03 FC |                             wrpin   regdatabus, datapins    'setup data bus inputs as registered or not for read timing control
13310 2b0 28 3A 63 FD |                             setq    xfreq1                  'reconfigure with single cycle xfreq (sysclk/1)
13314 2b1 00 3E C7 FC |                             xcont   delay, #0               'configurable fine input delay per P2 clock cycle
13318 2b2 00 0C CC FC |                             xcont   #6, #0                  'fixed delay offset to expand delay range
1331c 2b3 32 D8 63 FD |                             skipf   pattern                 'choose path below
13320 2b4             |                                                             'Bursts Bytes Words Longs  RMW FromWrites
13320 2b4 28 3C 63 FD |                             setq    xfreq2                  '   a     b     c     d     e    f  restore sysclk/2 operation
13324 2b5 00 02 CC FC |                             xcont   #1, #0                  '   ?     |     |     |     |    |  skips over LSW
13328 2b6 00 32 C7 FC |                             xcont   xrecvhi8, #0            '   ?     |     |     |     |    |  1x8 bits on high 8 bit bus
1332c 2b7 00 34 C7 FC |                             xcont   xrecvdata, #0           '   ?     b     c     d     e    f  nx16 bits on 16 bit bus
13330 2b8 00 30 C7 FC |                             xcont   xrecvlo8, #0            '   ?     |     |     |     |    |  1x8 bits on low 8 bit bus
13334 2b9 2D D2 63 FD |                             call    resume                  '   a     |     |     d     |    |  chooses what to do next
13338 2ba 24 36 60 FD |                             waitxfi                         '   a     b     c     d     e    f  wait for streaming to finish
1333c 2bb A4 55 03 FC |                             wrpin   registered, datapins    '   a     b     c     d     e    f  restore data pins for next transfer
13340 2bc 59 52 63 0D |             _ret_           drvh    cspin                   '   a     |     |     d     |    f  de-assert chip select and return
13344 2bd 59 52 63 FD |                             drvh    cspin                   '         b     c           e       deassert chip select and continue
13348 2be E5 E5 4B F8 |                             getnib  d, request, #1          'get request code value
1334c 2bf 03 E4 87 51 |             if_nz           sub     d, #3                   'offset for table if RMW
13350 2c0 BB E5 8F F9 |                             altd    d, #skiptable-5         'patch next instruction
13354 2c1 32 00 60 FD |                             skipf   0-0                     'generate skip sequence
13358 2c2             |                                                             ' B   W  RMWB RMWW RMLL 
13358 2c2 80 DF 07 FB |                             rdlong  a, ptrb                 ' a   b   c    d    e   read back data written to mailbox
1335c 2c3 28 B4 63 FD |                             setq    count                   ' |   |   |    |    e   setup bit mux mask
13360 2c4 D9 DF F3 F9 |                             muxq    a, hubdata              ' |   |   |    |    e   apply bit mux
13364 2c5 40 00 90 FD |                             jmp     #writeback              ' |   |   |    |    e   write back to external memory
13368 2c6 01 B0 17 F4 |                             testb   addr1, #1 wc            ' |   b   |    d        test for odd word address read case
1336c 2c7 EF EF 3B C9 |             if_c            getword pb, a, #1               ' |   b   |    d        select hi word in long
13370 2c8 EF EF 33 39 |             if_nc           getword pb, a, #0               ' |   b   |    d        select lo word in long
13374 2c9 D8 E5 03 F6 |                             mov     d, addr1                ' a   |   c    d
13378 2ca 03 E4 07 F5 |                             and     d, #3                   ' a   |   c    |        get LSBs of address
1337c 2cb EF E5 6F F9 |                             altgb   d, #a                   ' a   |   c    |        index into long
13380 2cc 00 EE E3 F8 |                             getbyte pb                      ' a   |   c    |        and extract the byte
13384 2cd 80 EF 67 FC |                             wrlong  pb, ptrb                ' a   b   c    d        write data back now zeroed and aligned
13388 2ce C0 00 B0 FD |                             call    #complete_rw_lut        ' a   b   |    |        process any list setup first
1338c 2cf 2D 00 64 FD |                             ret                             ' a   b   |    |        then return
13390 2d0 28 B4 63 FD |                             setq    count                   '         c    d        setup bit mux mask
13394 2d1 D9 EF F3 F9 |                             muxq    pb, hubdata             '         c    d        apply bit mux
13398 2d2 EF E5 67 F9 |                             altsb   d, #a                   '         c    |
1339c 2d3 F7 01 C0 F8 |                             setbyte 0-0, pb, #0             '         c    |
133a0 2d4 F7 DF 2B C9 |             if_c            setword a, pb, #1               '         |    d
133a4 2d5 F7 DF 23 39 |             if_nc           setword a, pb, #0               '         |    d
133a8 2d6 37 8A 07 F6 | writeback                   mov     pattern2, #%110111      'setup next skip pattern to send a single long and resume
133ac 2d7 EF B3 03 F6 |                             mov     hubdata, a              'write a to PSRAM
133b0 2d8 14 D6 07 F6 |                             mov     wrclks, #20             '20 clocks to write a long
133b4 2d9 CC D3 03 F6 |                             mov     resume, complete_rw     'we'll complete the operation after this
133b8 2da 10 03 90 FD |                             jmp     #writecommon
133bc 2db             | 
133bc 2db             | '..................................................................................................
133bc 2db             | ' Burst continuation testing
133bc 2db             | 
133bc 2db 32 96 63 FD | continue_write_lut          skipf   skipseq_write           'customize executed code below for write case
133c0 2dc BE D3 03 F6 |                             mov     resume, resumewrites    ' a (a=skipf sequence for writes)
133c4 2dd             | continue_read_lut          
133c4 2dd BF D3 03 F6 |                             mov     resume, resumereads     ' | setup resume address to execf
133c8 2de F1 B3 03 F1 |                             add     hubdata, c              ' a compute the next hub addr to use
133cc 2df F1 B5 83 F1 |                             sub     count, c                ' a account for the bytes already sent
133d0 2e0 D8 E3 03 F1 |                             add     c, addr1                ' a compute next external mem address
133d4 2e1 28 44 63 FD |                             setq    mask                    ' a configure mask for bit muxing
133d8 2e2 F1 B1 F3 F9 |                             muxq    addr1, c                ' a perform address bit muxing
133dc 2e3 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      ' a check if we can keep sending or need to yield
133e0 2e4 14 00 90 5D |             if_nz           jmp     #yield                  ' | we have to yield now to other COGs
133e4 2e5 E1 47 3B F9 |                             getword limit, id, #1           ' | restore per COG limit for continuing flash reads
133e8 2e6 F0 47 23 F3 |                             fle     limit, b                ' | also re-apply per bank limit
133ec 2e7 2A 2A 67 0D |             _ret_           push    #continue_read_exec     ' | 
133f0 2e8 04 00 90 5D |             if_nz           jmp     #yield                  ' a
133f4 2e9 2A 2C 67 0D |             _ret_           push    #continue_write_exec    ' a
133f8 2ea             | 
133f8 2ea 04 B9 37 FC | yield                       wrlut   total, ptra[4]          'save context for next time
133fc 2eb 05 BB 37 FC |                             wrlut   offset1, ptra[5]        'save context for next time
13400 2ec 06 BD 37 FC |                             wrlut   offset2, ptra[6]        'save context for next time
13404 2ed 07 BF 37 FC |                             wrlut   link, ptra[7]           'save context for next time
13408 2ee 00 B1 37 FC | yieldfill                   wrlut   addr1, ptra[0]          'save context for next time
1340c 2ef 01 B3 37 FC |                             wrlut   hubdata, ptra[1]        'save context for next time
13410 2f0 02 B5 37 FC |                             wrlut   count, ptra[2]          'save context for next time
13414 2f1 03 B7 37 FC |                             wrlut   addr2, ptra[3]          'save context for next time
13418 2f2 08 D3 37 FC |                             wrlut   resume, ptra[8]         'save next resume address
1341c 2f3 09 D5 37 FC |                             wrlut   orighubsize, ptra[9]    'save original hub size
13420 2f4 2A 1C 66 0D |             _ret_           push    #poller
13424 2f5             | 
13424 2f5             | 
13424 2f5 32 BE 65 FD | notransfer_lut              skipf   #%11011111              'cancel old skipping, start new sequence
13428 2f6             | nowrite_lut                                                 '  (a) new skip sequence 
13428 2f6 32 00 64 FD | noread_lut                  skipf   #0                      ' | cancel skipping
1342c 2f7 08 01 3C FC |                             wrlut   #0, ptra[8]             ' | clear resume
13430 2f8 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        ' | test for running from a request list   
13434 2f9 40 F8 9F 5D |             if_nz           jmp     #notify                 ' | if not a request list then we are done
13438 2fa 1F B6 0F F4 |                             testb   addr2, #31 wz           ' | check if extended list item
1343c 2fb DF B7 03 A6 | donerepeats if_z            mov     addr2, link             ' a if so take addr2 from link field
13440 2fc 1C 00 B0 FD | checklist                   call    #checknext              ' | handle running from list
13444 2fd 2D 00 64 FD |                             ret                             ' | continue processing
13448 2fe 2A 9E 63 0D |             _ret_           push    noread                  'continue end of transfer
1344c 2ff             | '..................................................................................................
1344c 2ff             | ' Completion of requests
1344c 2ff             | 
1344c 2ff             | complete_rw_lut             
1344c 2ff 09 C2 0F F4 |                             testb   id, #LIST_BIT wz        'test for running from a request list   
13450 300 32 04 64 AD |             if_z            skipf   #%10                    'if a request list then skip notification
13454 301 08 01 3C FC |                             wrlut   #0, ptra[8]             ' a   default is not to resume
13458 302 2A 14 66 0D |             _ret_           push    #notify                 ' |   if not a request list then we are done
1345c 303 0D B6 B7 FB |                             tjs     addr2, #extendedreq     '     test for special extended request  
13460 304 07 B6 97 FB | checknext                   tjz     addr2, #listcomplete    'not special, check if the list is complete
13464 305 BF ED 07 FB |                             rdlong  pa, ptrb[-1]            'check if list has been aborted by client
13468 306 05 EC BF FB |                             tjns    pa, #listcomplete       'exit if it has
1346c 307 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz
13470 308 DB B3 03 A6 |             if_z            mov     hubdata, addr2
13474 309 32 62 64 AD |             if_z            skipf   #%110001
13478 30a 32 10 64 5D |             if_nz           skipf   #%1000                  'do not notify if list is continuing
1347c 30b 80 B7 67 FC |                             wrlong  addr2, ptrb             ' a  write back next list address
13480 30c D0 C3 8F F9 | listcomplete                altd    id, #id0                ' a  compute COG's state address
13484 30d 09 00 04 F4 |                             bitl    0-0, #LIST_BIT          ' a  clear list flag for this COG
13488 30e 2A 14 66 0D |             _ret_           push    #notify                 ' |  we are done with the list
1348c 30f 2A 1C 66 0D |             _ret_           push    #poller                 ' a  we are still continuing the list
13490 310 2A 50 66 0D |             _ret_           push    #real_list              ' a  we are still continuing the list
13494 311 E3 B5 97 FB | extendedreq                 tjz     count, #notransfer_lut  'test for single transfers, do nothing if extd *** 
13498 312 DB DF 7B F8 |                             getnib  a, addr2, #7            'check the request type
1349c 313 0F DE 0F F2 |                             cmp     a, #$F wz               'write burst $F = bank to bank cases (b) or (c)
134a0 314 D8 DF 73 F8 |                             getnib  a, addr1, #6            'get the bank for next operation (assuming case (a))
134a4 315 32 90 63 5D |             if_nz           skipf   skipcase_a              'all other values are hub memory only copies
134a8 316             |                                                             ' skipcase (a) gfx copy to/from hub
134a8 316             |                                                             ' skipcase (b) gfx copy extmem bank to bank
134a8 316             |                                                             ' skipcase (c) linear copy extmem bank to bank
134a8 316 DB DF 73 F8 |                             getnib  a, addr2, #6            ' |      get the bank for next operation (cases b,c)
134ac 317 EF E5 AB FA |                             rdlut   d, a wz                 ' a      load bank information and check if valid
134b0 318 31 02 64 5D |             if_nz           skip    #%1                     ' |      if valid then skip past next instruction
134b4 319 2A 02 66 0D |             _ret_           push    #invalidbank            ' |      otherwise bail out after this
134b8 31a DD BB CB F7 |                             test    offset1 wz              ' |      check for first offset being zero
134bc 31b DE BD CB A7 |             if_z            test    offset2 wz              ' |      ..and the other offset is also zero
134c0 31c 32 94 63 AD |             if_z            skipf   skipcase_c              ' |      ..if so, do bank-to-bank copy transfer
134c4 31d 32 92 63 FD |                             skipf   skipcase_b              ' |   |  otherwise a graphics copy between banks
134c8 31e F1 B3 03 F1 |                             add     hubdata, c              ' a b c  add bytes just sent to hub address
134cc 31f EA B3 83 F1 |                             sub     hubdata, orighubsize    ' a b c  rewind by orig hub buffer size
134d0 320 D8 E3 03 F1 |                             add     c, addr1                ' a b c  compute next address to use
134d4 321 DC B9 CB F7 |                             test    total wz                ' a b |  check for zero tranfers
134d8 322 DC D5 2B F3 |                             fle     orighubsize, total wz   ' | | c  ensure we don't overwrite
134dc 323 44 FF 9F AD |             if_z            jmp     #notransfer_lut         ' a b c  handle the zero length case
134e0 324 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a b c  check if reading/writing
134e4 325 EA B5 03 F6 |                             mov     count, orighubsize      ' a b c  reset count to hub buffer size
134e8 326 EA E3 83 F1 |                             sub     c, orighubsize          ' a b |  rewind to original position
134ec 327 DD E3 03 A1 |             if_z            add     c, offset1              ' a b |  add any dst scanline offset
134f0 328 DE E3 03 51 |             if_nz           add     c, offset2              ' a b |  add any src scanline offset
134f4 329 DE B3 03 A1 |             if_z            add     hubdata, offset2        ' a | |  add any src scanline offset
134f8 32a DD B3 03 51 |             if_nz           add     hubdata, offset1        ' a | |  add any dst scanline offset
134fc 32b 28 44 63 FD |                             setq    mask                    ' a b c  configure mask for bit muxing
13500 32c F1 B1 F3 F9 |                             muxq    addr1, c                ' a b c  perform address bit muxing
13504 32d D8 DF 03 F6 |                             mov     a, addr1                ' | b c  ]
13508 32e DB B1 03 F6 |                             mov     addr1, addr2            ' | b c  ]swap read/write addresses
1350c 32f EF B7 03 F6 |                             mov     addr2, a                ' | b c  ]
13510 330 1E B0 A7 F4 |                             bitnz   addr1, #30              ' | b c  alternate read/write bursts
13514 331 0F B6 3F F8 |                             setnib  addr2, #$F, #7          ' | b c  preserve bank to bank copy
13518 332 01 B8 8F F1 |                             sub     total, #1 wz            ' a | |  decrement scanline count
1351c 333 01 B8 8F A1 |             if_z            sub     total, #1 wz            ' | b |  decrement scanline count after write
13520 334 EA B9 8B A1 |             if_z            sub     total, orighubsize wz   ' | | c  decrement bytes sent after write
13524 335 DF B7 03 A6 |             if_z            mov     addr2, link
13528 336 34 FF 9F AD |             if_z            jmp     #checknext
1352c 337 D8 CB FB F8 | moretransfers               getbyte request, addr1, #3      'prepare next request
13530 338 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
13534 339 32 1C 64 AD |             if_z            skipf   #%1110                  '     skip some code if we are locked
13538 33a 1E B0 0F F4 |                             testb   addr1, #30 wz           ' a   test if will be reading or writing
1353c 33b BE D3 03 A6 |             if_z            mov     resume, resumewrites    ' |   resume burst writing
13540 33c B9 D3 03 56 |             if_nz           mov     resume, newburstr       ' |   resume burst reading
13544 33d B0 FE 9F FD |                             jmp     #yield                  ' |   yield to poller
13548 33e 31 02 64 AD |             if_z            skip    #%1                     '     skip next instruction for writing case
1354c 33f 2A 26 67 0D |             _ret_           push    #start_read_exec        '(|)  do new read burst next 
13550 340 2A 28 67 0D |             _ret_           push    #start_write_exec       'do new write burst next
13554 341             | 
13554 341             | '..................................................................................................
13554 341             | ' PSRAM WRITES
13554 341             |                                                             '  a b c d e f g h
13554 341             | 
13554 341             |                                                             '  B W L F B R L L (a) byte write(s)
13554 341             |                                                             '  Y O O I U E O O (b) word write(s)
13554 341             |                                                             '  T R N L R S C C (c) long write(s)
13554 341             |                                                             '  E D G L S U K K (d) resumed fill
13554 341             |                                                             '          T M E E (e) new burst write
13554 341             |                                                             '            E D D (f) resumed burst
13554 341             |                                                             '              F B (g) locked fill
13554 341             |                                                             '              I U (h) locked burst write
13554 341             |                                                             '              L R 
13554 341             |                                                             '              L S 
13554 341             |                                                             '                T 
13554 341             | 
13554 341             | w_single                   
13554 341             | w_fill_cont           
13554 341 D8 DF 7B F8 |                             getnib  a, addr1, #7            '  a b c d          obtain request
13558 342 03 DE 07 F5 |                             and     a, #3                   '  a b c d          extract encoded size (0=B,1=W,2=L)
1355c 343 00 B2 FF F9 |                             movbyts hubdata, #0             '  a | | |          replicate byte across long
13560 344 44 B2 FF F9 |                             movbyts hubdata, #%01000100     '  | b | |          replicate word across long
13564 345 01 B0 27 F5 |                             andn    addr1, #1               '  | b | |          align word addresses
13568 346 03 B0 27 F5 |                             andn    addr1, #3               '  | | c |          align long addresses
1356c 347 DA D5 03 F6 | w_burst                     mov     orighubsize, count      '  a b c | e        save original hub size
13570 348 01 B4 0F F2 | w_locked_fill               cmp     count, #1 wz            '  a b c d |   g    optimization for single transfers
13574 349 EF B5 63 F0 |                             shl     count, a                '  a b c | |   |    scale into bytes
13578 34a AB B5 97 FB |                             tjz     count, #nowrite_lut     '  a b c d e   |    check for any bytes to write
1357c 34b DA E3 03 F6 | w_resume_burst              mov     c, count                '  a b c d e f g h  get the number of bytes to write
13580 34c 76 02 A0 FD |                             call    #\r_resume_burst        '  a b c d e f g h  get per bank limit and read delay info
13584 34d             |                ' disable call to r_resume_burst for single longs when z=0
13584 34d E5 5D 03 F8 |                             setnib  deviceaddr, request, #0 '  a b c d e f | |  get the pin/configuration lut address
13588 34e AE CF A3 FA |                             rdlut   pinconfig, deviceaddr   '  a b c d e f | |  get the pin config for this bank
1358c 34f E7 53 E3 F8 |                             getbyte cspin, pinconfig, #0    '  a b c d e f | |  byte 0 holds CS pin
13590 350 E7 51 EB F8 |                             getbyte clkpin, pinconfig, #1   '  a b c d e f | |  byte 1 holds CLK pin
13594 351 3F 8A 0F F6 |                             mov     pattern2, #%111111 wz   '  | | | | e f | h  setup base skip pattern for bursts
13598 352 A3 E3 33 F3 |                             fle     c, limit wc             '  a b c d e f g h  enforce the burst limit
1359c 353 CE D3 03 C6 |             if_c            mov     resume, continue_write  '  | | | | e f | h  this burst write will continue
135a0 354 CC D3 03 36 |             if_nc           mov     resume, complete_rw     '  | | | | e f | h  this burst write will complete
135a4 355 D9 DF 03 F6 |                             mov     a, hubdata              '  | | | | e f | h  save streamer hub addr
135a8 356 14 D6 07 F6 |                             mov     wrclks, #20             '  a b c d | | g |  prepare base clocks
135ac 357 01 DE 17 F4 |                             testb   a, #1 wc                '  a b c d | | g |  check if longs (c=1) or bytes/words (c=0)
135b0 358 C7 8B 03 F6 |                             mov     pattern2, singlelong    '  a b c d | | g |  setup skip pattern for single long write
135b4 359 14 01 90 8D |             if_z_and_c      jmp     #writecommon            '  a b c d | | g |  optimized single long write
135b8 35a 09 8A 67 25 |             if_z_and_nc     xor     pattern2, #%1001        '  a b c d | | g |  modify pattern for single byte/word write
135bc 35b 5C 00 90 2D |             if_z_and_nc     jmp     #single_write           '  a b c d | | g |  optimized single byte/word write
135c0 35c 0F 8A 07 F6 |                             mov     pattern2, #%1111        '  a b c d | | g |  setup pattern for fills
135c4 35d             |         
135c4 35d             |             'PSRAM write data logic gets rather complex/messy here unfortunately, and multiple cases need to be handled:
135c4 35d             |             '
135c4 35d             |             '  At least one of these 3 optional components will be sent
135c4 35d             |             '     header - first partial long of data, gets aligned to PSRAM long boundary
135c4 35d             |             '     body - N x full longs of data
135c4 35d             |             '     trailer - last partial long of data
135c4 35d             |             '
135c4 35d             |             '  Both the header and trailer need to first read a long from PSRAM first then mask with new data
135c4 35d             |             '
135c4 35d             |             'Case    Type                           Sends
135c4 35d             |             ' 1)     Single byte/word write         header only (takes its own optimized path)
135c4 35d             |             ' 2)     Single long write              body only (takes its own optimized path)
135c4 35d             |             ' 3)     Multiple byte/word fill        optional header, optional body, optional trailer
135c4 35d             |             ' 4)     Multiple long fill             body only
135c4 35d             |             ' 5)     Burst write                    optional header, optional body, optional trailer
135c4 35d             | 
135c4 35d             |                             'if not just a single transfer we need to work out how many bytes are left to the 4kB page boundary
135c4 35d D8 E5 03 F6 |                             mov     d, addr1                'get start address
135c8 35e 0B E4 47 F7 |                             zerox   d, #11                  'only keep 12 LSBs
135cc 35f EE E5 C3 F2 |                             subr    d, val4k                'figure out how many bytes remain before we hit the boundary
135d0 360 F2 E3 33 F3 |                             fle     c, d wc                 'compare this size to our transfer size and limit it
135d4 361 CE D3 03 C6 |             if_c            mov     resume, continue_write  'and we will continue with a sub-burst again (harmless for fills)
135d8 362 13 8C 07 F6 |                             mov     pattern3, #%10011
135dc 363 D8 E5 03 F6 |                             mov     d, addr1                'get start address position 
135e0 364 03 E4 0F F5 |                             and     d, #3 wz                'get alignment
135e4 365 04 E2 17 F2 |                             cmp     c, #4 wc                'test if we have at least 4 bytes to send
135e8 366 10 D6 07 F6 |                             mov     wrclks, #16             'clocks needed for address phase
135ec 367 F1 EF 03 F6 |                             mov     pb, c                   'get number of bytes to send
135f0 368 F2 EF 03 F1 |                             add     pb, d                   'and increase total to send, including initial re-alignment
135f4 369 40 00 90 2D |             if_z_and_nc     jmp     #header_done            'if aligned and at least 4 bytes, no header to send
135f8 36a             |                             
135f8 36a F0 CA 17 F2 |                             cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
135fc 36b 32 3C 64 CD |             if_c            skipf   #%11110                 'if fill skip burst write stuff
13600 36c 04 D6 07 F1 |                             add     wrclks, #4              'we need to include 4 clock transitions for 2x16 bits
13604 36d F2 DF 83 F1 |                             sub     a, d                    ' |  (bursts only) subtract start address by offset to realign long
13608 36e EF E5 03 FB |                             rdlong  d, a                    ' |  (bursts only) read first long in HUB RAM at this addr
1360c 36f 04 DE 07 F1 |                             add     a, #4                   ' |  (bursts only) increase source address by a long for later
13610 370 32 08 64 FD |                             skipf   #%100                   ' |  (bursts only) prevent d clobber below
13614 371 04 EE 9F F1 |                             sub     pb, #4 wcz              ' subtract a long from the total
13618 372 00 8A 07 F4 |                             bitl    pattern2, #0            ' enable transfer of header portion in skip pattern
1361c 373 D9 E5 03 F6 | single_write                mov     d, hubdata              ' (for single/fills only) get fill data 
13620 374 88 01 B0 FD |                             call    #readlong               ' go get the first aligned long from PSRAM into hub RAM
13624 375 5A B0 47 FB |                             callpa  addr1, #getmask         ' compute a suitable mux mask for pa into pa
13628 376 ED C5 03 FB |                             rdlong  header, hubscratch      ' read original external RAM data from hub RAM
1362c 377 28 EC 63 FD |                             setq    pa                      ' setup byte mux mask
13630 378 F2 C5 F3 F9 |                             muxq    header, d               ' copy bytes into long
13634 379 94 00 90 ED |             if_c_or_z       jmp     #writecommon            ' if underflowed or emptied or single transfer we are done
13638 37a             | 
13638 37a F0 CA 17 F2 | header_done                 cmp     request, #%11110000 wc  'test for fill/burst (c=1 if fill, c=0 if burst)
1363c 37b F7 E5 03 F6 |                             mov     d, pb                   'preserve the count
13640 37c 03 EE 2F F5 |                             andn    pb, #3 wz               'determine the number of full long bytes left to send
13644 37d 07 EE 97 FB |                             tjz     pb, #body_done          'if no full longs, go send the trailing portion
13648 37e             |                  
13648 37e F7 D7 03 F1 |                             add     wrclks, pb              'include this number of bytes as more clock transitions
1364c 37f 32 14 64 CD |             if_c            skipf   #%1010                 'for fills we can skip burst stuff
13650 380 0C 8A 27 C5 |             if_c            andn    pattern2, #$C           'enable rep loop instructions for fills in write pattern
13654 381 01 8A 07 F4 |                             bitl    pattern2, #1            ' |  |  enable streamer instruction for bursts in write pattern
13658 382 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute word count for bursts
1365c 383 F7 37 23 F9 |                             setword xsenddata, pb, #0       ' |  |  setup streamer count for bursts
13660 384 01 EE 47 F0 |                             shr     pb, #1                  ' |  b  compute how many long transfer repeats this is
13664 385             | 
13664 385 03 E4 07 F5 | body_done                   and     d, #3                   'determine if any residual trailing bytes to send (0-3)
13668 386 17 E4 97 FB |                             tjz     d, #trailer_done        'no trailer to send, we exit now
1366c 387 DA E3 0B C2 |             if_c            cmp     c, count wz             'if a fill, check if fill will be completing
13670 388 CC D3 0B 32 |             if_nc           cmp     resume, complete_rw wz  'if a burst, check if this burst is completing
13674 389 F2 E3 83 51 |             if_nz           sub     c, d                    'we won't send this trailer if the burst/fill continues
13678 38a 4C 00 90 5D |             if_nz           jmp     #trailer_done           '..so the next transfer will become aligned and efficent
1367c 38b             | 
1367c 38b             |                             'we have 1-3 more aligned residual bytes left to send as the trailer
1367c 38b F0 E5 47 F5 |                             or      d, #$1f0                'setup mux mask address
13680 38c F2 ED A3 FA |                             rdlut   pa, d                   'read mux mask for this length at offset 0
13684 38d 2A B0 63 FD |                             push    addr1                   'save address
13688 38e             | 
13688 38e             | ' use this code (note: foldover can occur here in PSRAM bank)
13688 38e F1 B1 03 F1 |                             add     addr1, c                'find last long address in PSRAM
1368c 38f 01 B0 87 F1 |                             sub     addr1, #1               '..to be rewritten
13690 390 18 01 B0 FD |                             call    #readlong               'read data from this external address
13694 391             |             
13694 391 D9 E5 03 C6 |             if_c            mov     d, hubdata              'get data to be sent for fills
13698 392 32 3C 64 CD |             if_c            skipf   #%11110                 'skip burst code for fills
1369c 393 2B B0 63 FD |                             pop     addr1                   'restore address
136a0 394 F7 E5 03 F6 |                             mov     d, pb                   ' | get number of full longs that were sent
136a4 395 02 E4 67 F0 |                             shl     d, #2                   ' | convert to bytes
136a8 396 EF E5 03 F1 |                             add     d, a                    ' | add to start adress of longs to stream
136ac 397 F2 E5 03 FB |                             rdlong  d, d                    ' | read this last long from HUB RAM
136b0 398             | 
136b0 398 ED C7 03 FB |                             rdlong  trailer, hubscratch     'read external RAM data value
136b4 399 28 EC 63 FD |                             setq    pa                      'setup byte mask
136b8 39a F2 C7 F3 F9 |                             muxq    trailer, d              'apply byte mask to data via muxq
136bc 39b 04 D6 07 F1 |                             add     wrclks, #4              'increase by 4 more clocks
136c0 39c 05 8A 07 F4 |                             bitl    pattern2, #5            'enable trailing bytes to be written (bursts)
136c4 39d 00 8C 07 F4 |                             bitl    pattern3, #0            'enable trailing bytes to be written (fills)
136c8 39e             | 
136c8 39e             |                             'trailer is done
136c8 39e EF 3B 73 FC | trailer_done                rdfast  xfreq1, a               '(bursts, but harmless for fills) setup streamer source address
136cc 39f             | 
136cc 39f D8 C9 03 F6 | writecommon                 mov     cmdaddr, addr1          'get start address of transfer
136d0 3a0 02 C8 47 F0 |                             shr     cmdaddr, #2             'align to 32 bit boundary
136d4 3a1 02 C8 DF F8 |                             setbyte cmdaddr, #$02, #3       'add quad write command
136d8 3a2             | 
136d8 3a2 60 C8 63 FD |                             splitb  cmdaddr                 'reverse nibbles in address to match bus order
136dc 3a3 69 C8 63 FD |                             rev     cmdaddr                 
136e0 3a4 1B C8 FF F9 |                             movbyts cmdaddr, #%%0123
136e4 3a5 61 C8 63 FD |                             mergeb  cmdaddr
136e8 3a6             |                             
136e8 3a6 58 52 63 FD |                             drvl    cspin                   'activate chip select
136ec 3a7 58 48 63 FD |                             drvl    datapins                'enable the DATA bus
136f0 3a8 E4 2F A3 FC |                             xinit   ximm8lut, cmdaddr       'send 8 nibbles of address and command via LUT translation
136f4 3a9 A8 D7 23 FC |                             wypin   wrclks, clkpin          'start memory clock output 
136f8 3aa             |                                                          
136f8 3aa 32 8A 63 FD |                             skipf   pattern2                '   B W L Burst FB FW FL RMW
136fc 3ab E2 39 C3 FC |                             xcont   xsendimm, header        '   a b |   ?    ?  ?  ?  | ' send 32 bit immediate data as 2x16 bits 
13700 3ac 00 36 C7 FC |                             xcont   xsenddata, #0           '   | | |   ?    |  |  |  | ' send data from hub for bursts as 2nx16 bits
13704 3ad F7 03 D8 FC |                             rep     #1, pb                  '   | | |   |    ?  ?  ?  | ' repeat for bursts
13708 3ae D9 39 C3 FC |                             xcont   xsendimm, hubdata       '   | | c   |    ?  ?  ?  h ' send 32 bit fill data as 2x16 bits
1370c 3af 32 8C 63 FD |                             skipf   pattern3 '%10011/%10010 '   | | |   |    e  f  g  | ' determine if trailer to be sent
13710 3b0 E3 39 C3 FC |                             xcont   xsendimm, trailer       '   | | |   ?    ?  ?  ?  | ' send 32 bit immediate last data as 2x16 bits
13714 3b1 2D D2 63 FD |                             call    resume                  '   | | |   d    |  |  |  h ' bursts check what to do next while streaming
13718 3b2 24 36 60 FD |                             waitxfi                         '   a b c   d    e  f  g  h ' wait for streamer to end
1371c 3b3 50 48 63 FD |                             fltl    datapins                '   a b c   d    e  f  g  h ' tri-state DATA bus
13720 3b4 59 52 63 0D |             _ret_           drvh    cspin                   '   | | |   d    |  |  |  h ' de-assert chip select or fall through
13724 3b5             |  
13724 3b5 59 52 63 FD |                             drvh    cspin
13728 3b6 09 C2 17 F4 | check_fill_lut              testb   id, #LIST_BIT wc        'test for running from a request list   
1372c 3b7 F1 B5 8B F1 |                             sub     count, c wz             'account for bytes written
13730 3b8 34 00 90 5D |             if_nz           jmp     #continue_fill          'if more filling to go, setup next fill
13734 3b9 08 01 3C FC |                             wrlut   #0, ptra[8]             'default is not to resume
13738 3ba 3C F5 9F 3D |             if_nc           jmp     #notify                 'if not a request list then we are done
1373c 3bb 40 B7 BF FB |                             tjns    addr2, #checklist       'if not extended, check next list entry
13740 3bc 3E B9 67 FB |                             djz     total, #donerepeats     'check for repeats remaining
13744 3bd B8 B9 B3 FB |                             tjs     total, expansion        'check if started with zero repeats (treated as 1)
13748 3be EA E5 03 F6 |                             mov     d, orighubsize
1374c 3bf EF E5 63 F0 |                             shl     d, a
13750 3c0 F2 E3 83 F1 |                             sub     c, d
13754 3c1 DD E3 03 F1 |                             add     c, offset1
13758 3c2 F2 B5 03 F6 |                             mov     count, d                'restore original count
1375c 3c3 E5 E1 43 F8 | readmask                    getnib  b, request, #0          'get bank parameter LUT address
13760 3c4 F0 E1 A3 FA |                             rdlut   b, b                    'get bank limit/mask (in case count=1 above)
13764 3c5 F0 45 CB F9 |                             bmask   mask, b                 'build mask for addr (in case count=1)
13768 3c6 D8 E3 03 F1 | continue_fill               add     c, addr1                'add bytes to destination address
1376c 3c7 28 44 63 FD |                             setq    mask                    'setup bit mask
13770 3c8 F1 B1 F3 F9 |                             muxq    addr1, c                'setup new external memory address
13774 3c9 0A C2 0F F4 |                             testb   id, #LOCKED_BIT wz      'check if we can keep sending or need to yield
13778 3ca 33 74 63 AD |             if_z            execf   lockedfill              'continue next fill operation
1377c 3cb BB D3 03 F6 |                             mov     resume, restorefill
13780 3cc 00 B6 07 36 |             if_nc           mov     addr2, #0               'clear any left over garbage for non-list requests
13784 3cd 80 FC BF 3D |             if_nc           call    #yieldfill              'we have to yield now to other COGs
13788 3ce 6C FC BF CD |             if_c            call    #yield
1378c 3cf 2D 00 64 FD |                             ret
13790 3d0             |                            
13790 3d0             | getmask               '     rczr    c wcz                   'get 2 LSBs of count in W&C
13790 3d0             |                       '     rczl    pa                      'rotate left into address offset
13790 3d0             |                       '     rczl    c wcz                   'restore count and flags
13790 3d0 03 E2 EF F7 |                             testn   c, #3 wz                'set z=1 if less than 4 bytes being sent, z=0 if 4 or more
13794 3d1 02 EC 67 F0 |                             shl     pa, #2
13798 3d2 28 06 64 AD |             if_z            setq    #3
1379c 3d3 F1 ED F3 A9 |             if_z            muxq    pa, c
137a0 3d4 F0 ED 47 F5 |                             or      pa, #$1f0               'setup LUT address offset
137a4 3d5 F6 ED A3 FA |            {_ret_}          rdlut   pa, pa                  'lookup MUX MASK in LUT
137a8 3d6 2D 00 7C FD |                             ret     wcz ' would prefer my earlier _ret_ approach if possible somehow, to save a cycle
137ac 3d7             | 
137ac 3d7 ED 3B 83 FC | readlong                    wrfast  xfreq1, hubscratch      'setup read to hub scratch
137b0 3d8 02 34 27 F9 |                             setword xrecvdata, #2, #0       'read 2x16 words
137b4 3d9 20 D0 07 F6 |                             mov     clks, #32               '32 read clock transitions
137b8 3da 36 D8 07 F6 |                             mov     pattern, #%110110       'setup read skip pattern
137bc 3db 14 FB 9F FD |                             jmp     #readcommon             'read then return directly to caller
137c0 3dc             |         
137c0 3dc             | 
137c0 3dc             | '..................................................................................................
137c0 3dc             | 
137c0 3dc             |                 fit 1024-32
137c0 3dc             |                 fit 1024-32
137c0 3dc 00 00 00 00 
137c4 3dd 00 00 00 00 
137c8 3de 00 00 00 00 
137cc 3df 00 00 00 00 |                 long    0[1024-32-$]                'align position to last 32 long boundary in LUTRAM
137d0 3e0             |                 org 1024-32
137d0 000             | 
137d0 000             | ' mapping table from 0-F into 0000-FFFF on output bus (nibble replication)
137d0 000 00 00 00 00 |                 long $0000
137d4 001 11 11 00 00 |                 long $1111
137d8 002 22 22 00 00 |                 long $2222
137dc 003 33 33 00 00 |                 long $3333
137e0 004 44 44 00 00 |                 long $4444
137e4 005 55 55 00 00 |                 long $5555
137e8 006 66 66 00 00 |                 long $6666
137ec 007 77 77 00 00 |                 long $7777
137f0 008 88 88 00 00 |                 long $8888
137f4 009 99 99 00 00 |                 long $9999
137f8 00a AA AA 00 00 |                 long $aaaa
137fc 00b BB BB 00 00 |                 long $bbbb
13800 00c CC CC 00 00 |                 long $cccc
13804 00d DD DD 00 00 |                 long $dddd
13808 00e EE EE 00 00 |                 long $eeee
1380c 00f FF FF 00 00 |                 long $ffff
13810 010             | 
13810 010             | 'masks
13810 010 FF FF FF FF |                 long $ffffffff ' 00 aligned 0/4 length
13814 011 FF 00 00 00 |                 long $000000ff ' 00 aligned 1 length
13818 012 FF FF 00 00 |                 long $0000ffff ' 00 aligned 2 length
1381c 013 FF FF FF 00 |                 long $00ffffff ' 00 aligned 3 length
13820 014             | 
13820 014 00 FF FF FF |                 long $ffffff00 ' 01 aligned 0/4 length
13824 015 00 FF 00 00 |                 long $0000ff00 ' 01 aligned 1 length
13828 016 00 FF FF 00 |                 long $00ffff00 ' 01 aligned 2 length
1382c 017 00 FF FF FF |                 long $ffffff00 ' 01 aligned 3 length
13830 018             | 
13830 018 00 00 FF FF |                 long $ffff0000 ' 10 aligned 0/4 length
13834 019 00 00 FF 00 |                 long $00ff0000 ' 10 aligned 1 length
13838 01a 00 00 FF FF |                 long $ffff0000 ' 10 aligned 2 length
1383c 01b 00 00 FF FF |                 long $ffff0000 ' 10 aligned 3 length
13840 01c             | 
13840 01c 00 00 00 FF |                 long $ff000000 ' 11 aligned 0/4 length
13844 01d 00 00 00 FF |                 long $ff000000 ' 11 aligned 1 length
13848 01e 00 00 00 FF |                 long $ff000000 ' 11 aligned 2 length
1384c 01f 00 00 00 FF |                 long $ff000000 ' 11 aligned 3 length
13850 020             | 
13850 020             |         fit 1024
13850 020             |         fit 1024
13850 020             | 
13850 020             | '--------------------------------------------------------------------------------------------------
13850 020             |         orgh
13850                 | 
13850                 | gfxexpansion
13850                 |                             'simple line drawing graphics expansion of memory driver
13850                 |                             'jmp     #donerepeats                'just return for now
13850                 | 
13850     DB B1 0B F2 |                             cmp     addr1, addr2 wz         'see if we've reached the end
13854     FB 02 80 AD |             if_z            jmp     #donerepeats            'nothing more to draw
13858     01 B8 07 F1 |                             add     total, #1               'restore total after decrement
1385c     DD E1 03 F6 |                             mov     b, offset1              'get error term
13860     01 E0 67 F0 |                             shl     b, #1                   'compute e2 = 2 x error
13864     DE E5 33 F9 |                             getword d, offset2, #0          'get dx = abs(x0-x1)
13868     10 BC C7 F0 |                             sar     offset2, #16            'get dy = -abs(y0-y1)
1386c     DE E1 53 F2 |                             cmps    b, offset2 wc           'compare if e2 >= dy
13870     00 E2 07 F6 |                             mov     c, #0                   'clear accumulator reg
13874     31 1C 64 CD |             if_c            skip    #%1110                  'if not, skip
13878     EF DF C3 F9 |                             decod   a                       'decode as 1,2,or 4 byte size
1387c     DE BB 03 F1 |                             add     offset1, offset2        'err+=dy 
13880     10 B8 0F F4 |                             testb   total, #16 wz           'check sign sx   
13884     EF E3 C3 F3 |                             sumz    c, a                    'accumulator +/- size a (x0+=sx)
13888     F0 E5 53 F2 |                             cmps    d, b wc                 'compare if e2 <= dx
1388c     31 3C 64 CD |             if_c            skip    #%11110                 'if not, skip
13890     F2 BD 43 F9 |                             rolword offset2, d, #0          'restore offset
13894     F2 BB 03 F1 |                             add     offset1, d              'err+=dx
13898     11 B8 0F F4 |                             testb   total, #17 wz           'check sign sy
1389c     DC E5 33 F9 |                             getword d, total, #0            'get line width
138a0     F2 E3 C3 F3 |                             sumz    c, d                    'accumulator +/- linewidth (y0+=sy)
138a4     EF DF 93 F7 |                             encod   a wc                    'restore size and set carry
138a8     EA B5 03 F6 |                             mov     count, orighubsize      'reset the fill width
138ac     EF B5 63 F0 |                             shl     count, a                '..for the type of transfer
138b0     C3 03 80 FD |                             jmp     #readmask               'continue filling
138b4                 | 	alignl
138b4                 | _usbnew_spin2_dat_
138b4                 |                 org     $000
138b4 000             | 
138b4 000             | usb_host_start
138b4 000 F9 8F 02 F6 |                 mov     hcog_base_addr, ptrb
138b8 001             | 
138b8 001 03 00 00 FF 
138bc 002 D0 72 07 F6 |                 mov     htmp, ##@hlut_end - 4 - @hlut_start ' Dealing with hub addresses
138c0 003 02 72 47 F0 |                 shr     htmp, #2                        ' so byte->long for the lut cell count
138c4 004 B4 04 A0 FE |                 loc     pb, #@hlut_start - @usb_host_start
138c8 005 47 EF 03 F1 |                 add     pb, hcog_base_addr
138cc 006 29 72 63 FD |                 setq2   htmp
138d0 007 F7 01 00 FB |                 rdlong  0, pb                           ' Do the hub->lut copy
138d4 008             | 
138d4 008 88 0B A0 FE |                 loc     pb, #@usb_host_init - @usb_host_start
138d8 009 47 EF 03 F1 |                 add     pb, hcog_base_addr
138dc 00a 2C EE 63 FD |                 jmp     pb                              ' Initialize host and enter main processing loop
138e0 00b             | 
138e0 00b             | '------------------------------------------------------------------------------
138e0 00b             | ' SETUP transaction. The mechanics of SETUP are identical to OUT, but it's
138e0 00b             | ' special because the receiving function must not respond with either STALL or
138e0 00b             | ' NAK, and must accept the DATAx packet that follows the SETUP token. If a
138e0 00b             | ' non-control endpoint receives a SETUP token, or the function receives a
138e0 00b             | ' corrupt packet, it must ignore the transaction
138e0 00b             | '------------------------------------------------------------------------------
138e0 00b             | ' On entry:
138e0 00b             | '   PTRA - start address of the SETUP data struct.
138e0 00b             | ' On exit:
138e0 00b             | '   retval - PID_ACK on success, otherwise error code.
138e0 00b             | '------------------------------------------------------------------------------
138e0 00b             | txn_setup
138e0 00b 2D BC C6 F8 |                 setbyte ep_addr_pid, #PID_SETUP, #0
138e4 00c 08 B0 06 F6 |                 mov     pkt_data, #SETUP_TXN_LEN        ' SETUP is single fixed size DATAx packet
138e8 00d 03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB            ' And always uses DATA0 packet
138ec 00e 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Retries possible as function will ignore a corrupt packet
138f0 00f F8 ED 03 F6 |                 mov     pa, ptra                        ' Save SETUP struct pointer in case of retry
138f4 010             | .setup
138f4 010 24 01 B0 FD |                 call    #txn_out                        ' SETUP/OUT are the same transaction type, just different PIDs
138f8 011 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
138fc 012 2D 00 64 AD |         if_z    ret
13900 013 7C 0B B0 FD |                 call    #retry_wait
13904 014 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
13908 015 2D 00 64 AD |         if_z    ret
1390c 016 F6 F1 03 F6 |                 mov     ptra, pa                        ' Restore SETUP's DATAx pointer
13910 017 E0 FF 9F FD |                 jmp     #.setup
13914 018             | 
13914 018             | '------------------------------------------------------------------------------
13914 018             | ' IN/INTERRUPT transaction.
13914 018             | ' Possible function response: STALL or NAK handshake, or DATAx packet.
13914 018             | '------------------------------------------------------------------------------
13914 018             | ' On entry:
13914 018             | '   ep_addr_pid - PID_IN(b0..7), address(b8..b14), endpoint(b15..18) and
13914 018             | '     CRC(b19..23).
13914 018             | ' On exit:
13914 018             | '------------------------------------------------------------------------------
13914 018             | txn_in
13914 018 90 03 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
13918 019 69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
1391c 01a BC 00 B0 FD |                 call    #utx_token                      ' Put IN request on the bus
13920 01b             | 
13920 01b             |                 ' Fall through to urx_packet
13920 01b             | 
13920 01b             | '------------------------------------------------------------------------------
13920 01b             | ' Wait for a packet from a device/function. As host, the only two packet types
13920 01b             | ' received are handshakes and IN DATAx.
13920 01b             | '------------------------------------------------------------------------------
13920 01b             | ' On entry:
13920 01b             | ' On exit:
13920 01b             | '   retval - the ID of the packet. If a PID fails validation, ERR_PACKET is
13920 01b             | '     returned.
13920 01b             | '------------------------------------------------------------------------------
13920 01b             | urx_packet
13920 01b 22 A7 82 FA |                 rqpin   urx, dm                         ' Wait until start-of-packet signal appears on the USB.
13924 01c 04 A6 16 F4 |                 testb   urx, #SOPB              wc
13928 01d F4 FF 9F CD |         if_c    jmp     #urx_packet
1392c 01e 1A 94 63 FD |                 getct   hct2
13930 01f 4E 95 6B FA |                 addct2  hct2, tat_wait                  ' Start the response turn-around timer
13934 020 05 96 06 F4 |                 bitl    hstatus, #EOPB                  ' Make sure sticky EOP flag is clear
13938 021 00 A8 06 F6 |                 mov     newb_flg, #0                    ' Initialize for multi-byte read
1393c 022             | .wait_sop
1393c 022 22 A7 8A FA |                 rdpin   urx, dm
13940 023 04 A6 16 F4 |                 testb   urx, #SOPB              wc
13944 024 08 00 90 CD |         if_c    jmp     #.get_pid
13948 025 FC 25 CC FB |                 jnct2   #.wait_sop
1394c 026 05 BE 06 06 |         _ret_   mov     retval, #ERR_TAT
13950 027             | .get_pid
13950 027 28 02 B0 FD |                 call    #urx_next
13954 028 06 A6 16 F4 |                 testb   urx, #BUS_ERRB          wc
13958 029 04 00 90 3D |         if_nc   jmp     #.chk_pid
1395c 02a 02 BE 06 06 |         _ret_   mov     retval, #ERR_URX
13960 02b             | .chk_pid
13960 02b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13964 02c 5A BE 0E 52 |         if_nz   cmp     retval, #PID_NAK        wz
13968 02d 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz
1396c 02e 38 00 90 AD |         if_z    jmp     #.chk_eop                       ' Handshake, so check that packet is single byte
13970 02f 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Get low/full speed even/odd DATAx sequence to look for
13974 030 C3 BE 0E F2 |                 cmp     retval, #PID_DATA0      wz
13978 031 28 01 90 2D |    if_z_and_nc  jmp     #urx_data                       ' DATA0 and sequence match
1397c 032 10 00 90 8D |    if_z_and_c   jmp     #.ack_resend                    ' Sequence error. Ignore data, resend the ACK that the device must have missed
13980 033 4B BE 0E F2 |                 cmp     retval, #PID_DATA1      wz
13984 034 1C 01 90 8D |    if_z_and_c   jmp     #urx_data                       ' DATA1 and sequence match
13988 035 04 00 90 2D |    if_z_and_nc  jmp     #.ack_resend
1398c 036 04 BE 06 06 |         _ret_   mov     retval, #ERR_PACKET             ' Some other bus error...
13990 037             | .ack_resend
13990 037 22 A7 82 FA |                 rqpin   urx, dm
13994 038 05 A6 16 F4 |                 testb   urx, #EOPB              wc
13998 039 F4 FF 9F 3D |         if_nc   jmp     #.ack_resend
1399c 03a D2 BE 06 F6 |                 mov     retval, #PID_ACK
139a0 03b 98 01 B0 FD |                 call    #utx_handshake                  ' Send handshake PID and return to caller
139a4 03c 09 BE 06 06 |         _ret_   mov     retval, #ERR_DATAX_SYNC
139a8 03d             | .chk_eop
139a8 03d 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
139ac 03e 1C 00 90 3D |         if_nc   jmp     #.idle                          ' Full-speed doesn't need an additional read to get EOP status
139b0 03f C8 01 B0 FD |                 call    #urx_next                       ' Low-speed requires an additional read to get EOP status
139b4 040 05 96 16 F4 |                 testb   hstatus, #EOPB          wc
139b8 041 10 00 90 CD |         if_c    jmp     #.idle                          ' Low-speed EOP seen
139bc 042 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
139c0 043 04 BE 06 36 |         if_nc   mov     retval, #ERR_PACKET             ' No EOP where one was expected
139c4 044 02 BE 06 A6 |         if_z    mov     retval, #ERR_URX                ' Bit unstuff error, EOP SE0 > 3 bits or SE1, so we're hosed
139c8 045 2D 00 64 FD |                 ret
139cc 046             | .idle
139cc 046 22 A7 82 FA |                 rqpin   urx, dm
139d0 047 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
139d4 048 F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for bus IDLE before returning handshake result
139d8 049 2D 00 64 FD |                 ret
139dc 04a             | 
139dc 04a             | '------------------------------------------------------------------------------
139dc 04a             | ' Send a token packet with CRC5 checksum of address and endpoint. It is the
139dc 04a             | ' responsibility of the caller to append the appropriate inter-packet delay,
139dc 04a             | ' if one is required.
139dc 04a             | '------------------------------------------------------------------------------
139dc 04a             | ' On entry:
139dc 04a             | '   ep_addr_pid - packed with the PID, address and endpoint.
139dc 04a             | ' On exit:
139dc 04a             | '------------------------------------------------------------------------------
139dc 04a             | utx_token
139dc 04a 22 A7 82 FA |                 rqpin   urx, dm
139e0 04b 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
139e4 04c F4 FF 9F 3D |         if_nc   jmp     #utx_token
139e8 04d 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
139ec 04e 34 0D B0 CD |         if_c    call    #utx_pre
139f0 04f 80 A4 06 F6 |                 mov     utx, #OUT_SOP
139f4 050 70 01 B0 FD |                 call    #utx_byte                       ' Send sync byte
139f8 051 5E 73 03 F6 |                 mov     htmp, ep_addr_pid               ' Preserve the PID and destination
139fc 052 03 B8 06 F6 |                 mov     pkt_cnt, #3
13a00 053             | .next_byte
13a00 053 B9 A5 E2 F8 |                 getbyte utx, htmp, #0                   ' Bytes on the bus LSB->MSB
13a04 054 08 72 47 F0 |                 shr     htmp, #8                        ' Shift to next byte to send
13a08 055             | .wait
13a08 055 40 46 72 FD |                 testp   dp                      wc
13a0c 056 F8 FF 9F 3D |         if_nc   jmp     #.wait
13a10 057 23 03 08 FC |                 akpin   dp
13a14 058 22 A5 22 FC |                 wypin   utx, dm
13a18 059 F9 B9 6E 0B |         _ret_   djnz    pkt_cnt, #.next_byte
13a1c 05a             | 
13a1c 05a             | '------------------------------------------------------------------------------
13a1c 05a             | ' SETUP/OUT/INTERRUPT transaction.
13a1c 05a             | ' Possible function response in order of precedence: STALL, ACK, NAK.
13a1c 05a             | '------------------------------------------------------------------------------
13a1c 05a             | ' On entry:
13a1c 05a             | '   ep_addr_pid - PID_OUT(b0..7), address(b8..b14), endpoint(b15..18) and
13a1c 05a             | '     CRC(b19..23).
13a1c 05a             | '   PTRA - start address of the data buff/struct that has the bytes to send.
13a1c 05a             | '   pkt_data - count of DATAx payload bytes to send.
13a1c 05a             | ' On exit:
13a1c 05a             | '------------------------------------------------------------------------------
13a1c 05a             | txn_out
13a1c 05a 88 02 B0 FD |                 call    #wait_txn_ok                    ' ISR: ensure txn doesn't cross frame boundary
13a20 05b B8 FF BF FD |                 call    #utx_token                      ' Put SETUP/OUT token on the bus
13a24 05c 00 00 C0 FF 
13a28 05d F8 01 78 FC |                 rdfast  ##$80000000, ptra               ' Use hub RAM FIFO interface to read the tx buffer
13a2c 05e 58 B9 02 F6 |                 mov     pkt_cnt, pkt_data
13a30 05f             | 
13a30 05f             |                 ' Fall through to utx_data
13a30 05f             | 
13a30 05f             | '------------------------------------------------------------------------------
13a30 05f             | ' Transmit a DATAx packet with USB-16 checksum of payload. The payload CRC is
13a30 05f             | ' calculated while the data byte is being shifted out. Since data stage
13a30 05f             | ' success/fail is not determined until the status stage of the transaction,
13a30 05f             | ' this routine is only concerned about the current DATAx packet.
13a30 05f             | '------------------------------------------------------------------------------
13a30 05f             | ' On entry:
13a30 05f             | '   PTRA - hub start address of the data to read.
13a30 05f             | '   pkt_cnt - data payload size.
13a30 05f             | ' On exit:
13a30 05f             | '------------------------------------------------------------------------------
13a30 05f             | utx_data
13a30 05f 22 A7 82 FA |                 rqpin   urx, dm
13a34 060 04 A6 16 F4 |                 testb   urx, #SOPB              wc
13a38 061 F4 FF 9F CD |         if_c    jmp     #utx_data
13a3c 062 4D 99 02 F6 |                 mov     hctwait, ip_delay
13a40 063 2C 0A B0 FD |                 call    #poll_waitx                     ' SETUP/OUT token always precedes tx DATAx so insert IP delay
13a44 064 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
13a48 065 D8 0C B0 CD |         if_c    call    #utx_pre
13a4c 066 80 A4 06 F6 |                 mov     utx, #OUT_SOP
13a50 067 14 01 B0 FD |                 call    #utx_byte                       ' Send sync
13a54 068 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
13a58 069 03 96 16 F4 |                 testb   hstatus, #DATAx_TGLB    wc      ' Set the requested DATAx PID
13a5c 06a C3 A4 06 36 |         if_nc   mov     utx, #PID_DATA0
13a60 06b 4B A4 06 C6 |         if_c    mov     utx, #PID_DATA1
13a64 06c 00 01 B0 FD |                 call    #utx_byte                       ' No CRC calc done on PID
13a68 06d 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Check if sending a zero length payload
13a6c 06e 1C 00 90 AD |         if_z    jmp     #.send_crc                      ' If so, only the CRC goes out
13a70 06f             | .read_byte
13a70 06f 10 A4 62 FD |                 rfbyte  utx                             ' Fetch data byte
13a74 070 F0 00 B0 FD |                 call    #utx_byte
13a78 071 69 A4 62 FD |                 rev     utx                             ' Calculate CRC while the data is shifting out
13a7c 072 28 A4 62 FD |                 setq    utx                             ' SETQ left-justifies the reflected data byte
13a80 073 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
13a84 074 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
13a88 075 F9 B9 6E FB |                 djnz    pkt_cnt, #.read_byte
13a8c 076             | .send_crc
13a8c 076 E0 BB E6 F4 |                 bitnot  crc,#0 addbits 15               ' Final XOR, and send the calculated CRC16
13a90 077 5D A5 E2 F8 |                 getbyte utx, crc, #0
13a94 078 D0 00 B0 FD |                 call    #utx_byte
13a98 079 5D A5 EA F8 |                 getbyte utx, crc, #1
13a9c 07a C8 00 B0 FD |                 call    #utx_byte                       ' Last CRC byte out
13aa0 07b 7C FE 9F FD |                 jmp     #urx_packet                     ' Handle function response/error and back to caller
13aa4 07c             | 
13aa4 07c             | '------------------------------------------------------------------------------
13aa4 07c             | ' Receive a DATAx_ payload with USB-16 checksum. The CRC is calculated as the
13aa4 07c             | ' payload bytes are received. The routine reads bytes until EOP is detected and
13aa4 07c             | ' expects that the packet includes at least the CRC word.
13aa4 07c             | '
13aa4 07c             | ' In control transfers, it's possible to recieve fewer data bytes than what
13aa4 07c             | ' was requested, which makes it difficult to determine where the data stops
13aa4 07c             | ' and the CRC word begins. So the CRC calculation is done on every byte of the
13aa4 07c             | ' packet, including the CRC word. The CRC value should then be equal to the
13aa4 07c             | ' USB-16 expected residual value of 0xB001.
13aa4 07c             | '
13aa4 07c             | ' The routine writes the IN packet data to a static max_packet_size buffer
13aa4 07c             | ' so the caller can verify IN success before writing the data to its final
13aa4 07c             | ' destination.
13aa4 07c             | '------------------------------------------------------------------------------
13aa4 07c             | ' On entry:
13aa4 07c             | '   pkt_data - max byte count expected to be in the packet.
13aa4 07c             | '   newb_flg - signals new byte ready when toggled.
13aa4 07c             | ' On exit:
13aa4 07c             | '   pkt_cnt - actual number of bytes read.
13aa4 07c             | '------------------------------------------------------------------------------
13aa4 07c             | urx_data
13aa4 07c F7 77 03 F6 |                 mov     htmp2, pb
13aa8 07d 27 EF 03 F6 |                 mov     pb, urx_buff_p
13aac 07e 00 00 C0 FF 
13ab0 07f F7 01 88 FC |                 wrfast  ##$80000000, pb                 ' Use hub RAM FIFO interface to buffer bytes received
13ab4 080 BB EF 03 F6 |                 mov     pb, htmp2
13ab8 081 0F BA CE F9 |                 bmask   crc, #15                        ' Prime the CRC16 pump
13abc 082 00 B8 06 F6 |                 mov     pkt_cnt, #0                     ' Keep track of payload bytes received
13ac0 083 58 85 03 F6 |                 mov     pkt_tmp, pkt_data
13ac4 084 02 84 07 F1 |                 add     pkt_tmp, #2                     ' Tweak payload byte count to include CRC word
13ac8 085             | .wait_byte
13ac8 085             | ' In-line rx for max speed
13ac8 085 22 A7 82 FA |                 rqpin   urx, dm
13acc 086 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
13ad0 087 53 A5 02 F5 |                 and     utx, urx
13ad4 088 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
13ad8 089 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
13adc 08a 0C 00 90 5D |         if_nz   jmp     #.get_byte                      ' New byte!
13ae0 08b 05 A6 16 F4 |                 testb   urx, #EOPB              wc
13ae4 08c 38 00 90 CD |         if_c    jmp     #.chk_crc                       ' At end-of-packet
13ae8 08d DC FF 9F FD |                 jmp     #.wait_byte
13aec 08e             | .get_byte
13aec 08e 53 BF EA F8 |                 getbyte retval, urx, #1                 ' New byte from smart pins
13af0 08f 15 BE 62 FD |                 wfbyte  retval                          ' Add it to the data buffer
13af4 090 69 BE 62 FD |                 rev     retval                          ' Calculate CRC while next byte is shifting in
13af8 091 28 BE 62 FD |                 setq    retval                          ' SETQ left-justifies the reflected data byte
13afc 092 1F BB DA F9 |                 crcnib  crc, usb16_poly_r               ' Run CRC calc on the data nibs
13b00 093 1F BB DA F9 |                 crcnib  crc, usb16_poly_r
13b04 094             | .end_crc
13b04 094 01 B8 06 F1 |                 add     pkt_cnt, #1
13b08 095 C2 B9 1A F2 |                 cmp     pkt_cnt, pkt_tmp        wcz
13b0c 096 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET             ' Error if payload > expected size
13b10 097 2D 00 64 1D |         if_a    ret
13b14 098             | ' For full-speed at 80MHz, the time it takes to do the final byte write and
13b14 098             | ' CRC verify has likely put us into the EOP zone. The P2 smart pins keep the
13b14 098             | ' EOP flag "sticky" for 7-bits of J, but at 80MHz, it still could be possible
13b14 098             | ' to miss it, so cheat a bit and look for SOP clear here.
13b14 098 22 A7 82 FA |                 rqpin   urx, dm
13b18 099 05 A6 16 F4 |                 testb   urx, #EOPB              wc      ' FIXME: checking for EOP set should work when > 80MHz
13b1c 09a A8 FF 9F 3D |         if_nc   jmp     #.wait_byte                     ' Next read will catch EOP at low-speed
13b20 09b             | ' CRC OK = Payload CRC calc ^ packet's CRC bytes = $B001 (the USB-16 expected residual)
13b20 09b             | .chk_crc
13b20 09b 02 B8 86 F1 |                 sub     pkt_cnt, #2                     ' Adjust payload count to exclude the CRC bytes read
13b24 09c 58 00 00 FF 
13b28 09d 01 BA 6E F5 |                 xor     crc, ##USB16_RESIDUAL   wz      ' CRC of (data + transmitted CRC) XOR residual should equal zero
13b2c 09e F0 FD 9F 5D |         if_nz   jmp     #urx_packet                     ' CRC fail; discard data and wait until data re-sent or transfer timeout
13b30 09f D2 BE 06 F6 |                 mov     retval, #PID_ACK
13b34 0a0 4D 99 02 F6 |                 mov     hctwait, ip_delay
13b38 0a1 34 09 B0 FD |                 call    #poll_waitx
13b3c 0a2             | 
13b3c 0a2             |                 ' Fall through to utx_handshake
13b3c 0a2             | 
13b3c 0a2             | '------------------------------------------------------------------------------
13b3c 0a2             | ' Transmit a handshake PID. The routine assumes that the bus is IDLE and
13b3c 0a2             | ' the appropriate IP delay has been inserted.
13b3c 0a2             | '------------------------------------------------------------------------------
13b3c 0a2             | ' On entry:
13b3c 0a2             | '   retval - handshake PID to send.
13b3c 0a2             | ' On exit:
13b3c 0a2             | '   retval unchanged.
13b3c 0a2             | '------------------------------------------------------------------------------
13b3c 0a2             | utx_handshake
13b3c 0a2 07 96 16 F4 |                 testb   hstatus, #DWNSTRM_HUBB  wc
13b40 0a3 E0 0B B0 CD |         if_c    call    #utx_pre
13b44 0a4 80 A4 06 F6 |                 mov     utx, #OUT_SOP
13b48 0a5 1C 00 B0 FD |                 call    #utx_byte                       ' Send sync
13b4c 0a6 5F A5 02 F6 |                 mov     utx, retval
13b50 0a7 14 00 B0 FD |                 call    #utx_byte                       ' Send handshake PID
13b54 0a8             | .idle
13b54 0a8 22 A7 82 FA |                 rqpin   urx, dm
13b58 0a9 00 A6 16 F4 |                 testb   urx, #J_IDLEB           wc
13b5c 0aa F4 FF 9F 3D |         if_nc   jmp     #.idle                          ' Wait for IDLE to ensure the PID tx is complete
13b60 0ab 4E 99 02 F6 |                 mov     hctwait, tat_wait               ' Ensure one turn-around time before next transaction
13b64 0ac 08 09 90 FD |                 jmp     #poll_waitx
13b68 0ad             | 
13b68 0ad             | '------------------------------------------------------------------------------
13b68 0ad             | ' Wait for the USB tx buffer to empty and feed it a new byte.
13b68 0ad             | '------------------------------------------------------------------------------
13b68 0ad             | ' On entry:
13b68 0ad             | '   utx - byte to transmit.
13b68 0ad             | ' On exit:
13b68 0ad             | '------------------------------------------------------------------------------
13b68 0ad             | utx_byte
13b68 0ad 40 46 72 FD |                 testp   dp                      wc
13b6c 0ae F8 FF 9F 3D |         if_nc   jmp     #utx_byte
13b70 0af 23 03 08 FC |                 akpin   dp
13b74 0b0 1F 94 62 FD |                 waitx   utx_tweak       ' Wait #0 '#3 if < 180MHz, wait #3 '#20 if 180MHz+
13b78 0b1 22 A5 22 0C |         _ret_   wypin   utx, dm
13b7c 0b2             | 
13b7c 0b2             | '------------------------------------------------------------------------------
13b7c 0b2             | ' Fetch the next data byte of a packet. Always check receiver status for EOP.
13b7c 0b2             | '------------------------------------------------------------------------------
13b7c 0b2             | ' On entry:
13b7c 0b2             | ' On exit:
13b7c 0b2             | '   retval - the byte read.
13b7c 0b2             | '   urx - the receiver status. The caller must check the hstatus reg EOP flag
13b7c 0b2             | '     on return. If EOP is set, the byte in reg retval remains as the last byte
13b7c 0b2             | '     received.
13b7c 0b2             | '------------------------------------------------------------------------------
13b7c 0b2             | urx_next
13b7c 0b2 22 A7 8A FA |                 rdpin   urx, dm
13b80 0b3 80 A4 06 F6 |                 mov     utx, #BYTE_TGLF                 ' Reg utx free in this context
13b84 0b4 53 A5 02 F5 |                 and     utx, urx
13b88 0b5 52 A9 0A F2 |                 cmp     newb_flg, utx           wz      ' Fetch a byte whenever the flags differ
13b8c 0b6 80 A8 66 55 |         if_nz   xor     newb_flg, #BYTE_TGLF            ' Synchronize flags
13b90 0b7 53 BF EA 58 |         if_nz   getbyte retval, urx, #1                 ' Fetch the new byte
13b94 0b8 2D 00 64 5D |         if_nz   ret                                     ' New byte is priority, so return now
13b98 0b9 04 A6 16 F4 |                 testb   urx, #SOPB              wc
13b9c 0ba 06 A6 0E F4 |                 testb   urx, #BUS_ERRB          wz
13ba0 0bb D8 FF 9F 4D |    if_c_and_nz  jmp     #urx_next                       ' If SOP still raised and !BUS_ERRB a new byte should be coming
13ba4 0bc 05 96 26 34 |         if_nc   bith    hstatus, #EOPB                  ' If EOP make it sticky, otherwise it's a bus error
13ba8 0bd 2D 00 64 FD |                 ret
13bac 0be             | 
13bac 0be             | '------------------------------------------------------------------------------
13bac 0be             | ' Calculate USB-5 CRC. The upper word of the CRC pre-calc table in LUT contains
13bac 0be             | ' the data used for the USB-5 CRC lookups. The token packet is three bytes in
13bac 0be             | ' length, and the PID is not included in the CRC calculation:
13bac 0be             | '  CRC5  FRAME_NUMBER SOF (full-speed)
13bac 0be             | '  CRC5  ENDP ADDRESS PID
13bac 0be             | ' %00000_1111_1111111_xxxxxxxx
13bac 0be             | '------------------------------------------------------------------------------
13bac 0be             | ' On entry:
13bac 0be             | '   ep_addr_pid - stuffed with the function endpoint, address and
13bac 0be             | '     SETUP/IN/OUT/SOF PID according to the USB standard.
13bac 0be             | ' On exit:
13bac 0be             | '   ep_addr_pid - CRC value appended to the packet.
13bac 0be             | '------------------------------------------------------------------------------
13bac 0be             | calc_crc5
13bac 0be FF 03 00 FF 
13bb0 0bf FF BD 06 F5 |                 and     ep_addr_pid, ##EP_ADDR_MASK     ' Clear existing CRC, if any
13bb4 0c0 5E 73 03 F6 |                 mov     htmp, ep_addr_pid
13bb8 0c1 08 72 47 F0 |                 shr     htmp, #8                        ' PID not included in CRC calc
13bbc 0c2 1F BA 06 F6 |                 mov     crc, #$1f                       ' Initial CRC5 value
13bc0 0c3 69 72 63 FD |                 rev     htmp                            ' Input data reflected
13bc4 0c4 28 72 63 FD |                 setq    htmp                            ' CRCNIB setup for data bits 0..7
13bc8 0c5 14 BA DE F9 |                 crcnib  crc, #USB5_POLY
13bcc 0c6 14 BA DE F9 |                 crcnib  crc, #USB5_POLY                 ' Data bits 0..7 calculated
13bd0 0c7 09 72 77 F0 |                 shl     htmp, #9                wc      ' Shift out processed bits + 1 to set up CRC of remaining bits 8..10
13bd4 0c8 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY                 ' Inline instead of REP as we're in hubexec
13bd8 0c9 01 72 77 F0 |                 shl     htmp, #1                wc
13bdc 0ca 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
13be0 0cb 01 72 77 F0 |                 shl     htmp, #1                wc
13be4 0cc 14 BA D6 F9 |                 crcbit  crc, #USB5_POLY
13be8 0cd 1F BA 66 F5 |                 xor     crc, #$1f                       ' Final XOR value
13bec 0ce 13 BA 66 F0 |                 shl     crc, #8 + 11                    ' CRC to bits 23..19 of the token packet
13bf0 0cf 5D BD 42 05 |         _ret_   or      ep_addr_pid, crc                ' Put the CRC in its new home
13bf4 0d0             | 
13bf4 0d0             | '------------------------------------------------------------------------------
13bf4 0d0             | ' Full-speed/low-speed frame timing interrupt service routine.
13bf4 0d0             | '------------------------------------------------------------------------------
13bf4 0d0             | isr1_fsframe
13bf4 0d0 1A 92 62 FD |                 getct   iframe_ct_base
13bf8 0d1 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
13bfc 0d2 B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
13c00 0d3 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
13c04 0d4             | .wait
13c04 0d4 40 46 72 FD |                 testp   dp                      wc
13c08 0d5 F8 FF 9F 3D |         if_nc   jmp     #.wait
13c0c 0d6 23 03 08 FC |                 akpin   dp
13c10 0d7 A5 A4 06 F6 |                 mov     utx, #PID_SOF
13c14 0d8 22 01 29 FC |                 wypin   #OUT_SOP, dm                    ' Put start-of-packet SYNC field on the USB
13c18 0d9 4C FF BF FD |                 call    #utx_byte                       ' Send token PID byte
13c1c 0da 1F B6 06 F6 |                 mov     icrc, #$1f                      ' Prime the CRC5 pump
13c20 0db 59 B5 02 F6 |                 mov     sof_pkt, frame                  ' CRC5 calculation done on the 11-bit frame number value
13c24 0dc 69 B4 62 FD |                 rev     sof_pkt                         ' Input data reflected
13c28 0dd 28 B4 62 FD |                 setq    sof_pkt                         ' CRCNIB setup for data bits 0..7
13c2c 0de 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY
13c30 0df 14 B6 DE F9 |                 crcnib  icrc, #USB5_POLY                ' Data bits 0..7 calculated
13c34 0e0 59 A5 E2 F8 |                 getbyte utx, frame, #0                  ' Send the low byte of the frame number
13c38 0e1 2C FF BF FD |                 call    #utx_byte
13c3c 0e2 08 B4 66 F0 |                 shl     sof_pkt, #8                     ' Shift out processed bits to set up CRCBIT * 3
13c40 0e3 03 04 DC FC |                 rep     #2, #3                          ' Three data bits left to process
13c44 0e4 01 B4 76 F0 |                 shl     sof_pkt, #1             wc
13c48 0e5 14 B6 D6 F9 |                 crcbit  icrc, #USB5_POLY                ' Data bits 8..10 calculated
13c4c 0e6 1F B6 66 F5 |                 xor     icrc, #$1f                      ' Final XOR value
13c50 0e7 59 A5 EA F8 |                 getbyte utx, frame, #1                  ' Send remaining frame number bits
13c54 0e8 03 B6 66 F0 |                 shl     icrc, #3                        ' Merge CRC to bits 7..3 of the final token byte
13c58 0e9 5B A5 42 F5 |                 or      utx, icrc
13c5c 0ea 08 FF BF FD |                 call    #utx_byte                       ' Last start-of-frame byte is on the wire
13c60 0eb A4 83 03 F6 |                 mov     isrtmp1, _ip_delay_fs_          ' Use normal inter-packet delay when full-speed
13c64 0ec 20 00 90 FD |                 jmp     #isr1_wait
13c68 0ed             | isr1_lsframe
13c68 0ed 1A 92 62 FD |                 getct   iframe_ct_base
13c6c 0ee 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
13c70 0ef B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
13c74 0f0             | .wait
13c74 0f0 40 46 72 FD |                 testp   dp                      wc
13c78 0f1 F8 FF 9F 3D |         if_nc   jmp     #.wait
13c7c 0f2 23 03 08 FC |                 akpin   dp
13c80 0f3 22 09 28 FC |                 wypin   #OUT_EOP, dm                    ' EOP is the low-speed keep-alive strobe
13c84 0f4 A3 83 03 F6 |                 mov     isrtmp1, _ip_delay_ls_          ' Normal inter-packet delay works when low-speed
13c88 0f5             | isr1_wait
13c88 0f5 22 A5 82 FA |                 rqpin   utx, dm
13c8c 0f6 04 A4 16 F4 |                 testb   utx, #SOPB                 wc
13c90 0f7 F4 FF 9F CD |         if_c    jmp     #isr1_wait
13c94 0f8 01 B2 06 F1 |                 add     frame, #1                       ' Next frame# and check for wrap around
13c98 0f9 03 00 00 FF 
13c9c 0fa FF B3 06 F5 |                 and     frame, ##$7ff
13ca0 0fb 1F 82 63 FD |                 waitx   isrtmp1                         ' Make sure bus is idle
13ca4 0fc F5 FF 3B FB |                 reti1
13ca8 0fd             | 
13ca8 0fd             | '------------------------------------------------------------------------------
13ca8 0fd             | ' Wait for a window within the 1ms frame boundary that will ensure that a
13ca8 0fd             | ' transaction will complete before the next frame is triggered.
13ca8 0fd             | '------------------------------------------------------------------------------
13ca8 0fd             | ' On entry:
13ca8 0fd             | ' On exit:
13ca8 0fd             | '------------------------------------------------------------------------------
13ca8 0fd             | wait_txn_ok
13ca8 0fd 1A 76 63 FD |                 getct   htmp2
13cac 0fe 49 77 83 F1 |                 sub     htmp2, iframe_ct_base
13cb0 0ff 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
13cb4 100 A1 77 1B C2 |         if_c    cmp     htmp2, _txn_ok_ls_      wcz
13cb8 101 A2 77 1B 32 |         if_nc   cmp     htmp2, _txn_ok_fs_      wcz
13cbc 102 E8 FF 9F 1D |         if_a    jmp     #wait_txn_ok                    ' Not enough time, so wait until next frame
13cc0 103 2D 00 64 FD |                 ret
13cc4 104             | 
13cc4 104             | '------------------------------------------------------------------------------
13cc4 104             | ' A device connection was detected, or a bus reset was requested by the USB
13cc4 104             | ' client. Set the appropriate smart pin FS/LS speed mode to match the device
13cc4 104             | ' and perform a reset sequence prior to device enumeration.
13cc4 104             | '------------------------------------------------------------------------------
13cc4 104             | dev_reset
13cc4 104 22 A7 82 FA |                 rqpin   urx, dm
13cc8 105 01 A6 16 F4 |                 testb   urx, #K_RESUMEB         wc      ' K differential "1" in FS mode signals low-speed
13ccc 106 F4 03 B0 CD |         if_c    call    #set_speed_low                  ' The speed config subroutines must restore the caller C flag
13cd0 107 E0 03 B0 3D |         if_nc   call    #set_speed_full                 ' state on return if it writes the C flag.
13cd4 108             | reset
13cd4 108 25 00 64 FD |                 setint1 #0                              ' Don't want frame interrupt while in reset
13cd8 109 22 03 28 FC |                 wypin   #OUT_SE0, dm                    ' Assert bus reset
13cdc 10a 1F 5C 63 FD |                 waitx   _reset_hold_                    ' Spec is >= 10ms
13ce0 10b 22 01 28 FC |                 wypin   #OUT_IDLE, dm
13ce4 10c 00 B2 06 F6 |                 mov     frame, #0                       ' Reset the frame timespan count
13ce8 10d 1A 92 62 FD |                 getct   iframe_ct_base
13cec 10e 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
13cf0 10f B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
13cf4 110 59 73 03 F6 |                 mov     htmp, frame                     ' Allow reset recovery time (Section 9.2.6.2)
13cf8 111 24 72 07 F1 |                 add     htmp, #36
13cfc 112 25 02 64 FD |                 setint1 #1                              ' Set ISR event trigger to CT-passed-CT1
13d00 113             | .framewait
13d00 113 B9 B3 1A F2 |                 cmp     frame, htmp             wcz
13d04 114 F8 FF 9F CD |         if_b    jmp     #.framewait
13d08 115 2D 00 64 FD |                 ret
13d0c 116             | 
13d0c 116             | '------------------------------------------------------------------------------
13d0c 116             | ' Bulk hub<->hub byte copy. Does not check for src/dest buffer overlap.
13d0c 116             | '------------------------------------------------------------------------------
13d0c 116             | ' On entry:
13d0c 116             | '   PTRA - source address.
13d0c 116             | '   PB - destination address.
13d0c 116             | '   hr0 - length of copy, in bytes.
13d0c 116             | ' On exit:
13d0c 116             | '------------------------------------------------------------------------------
13d0c 116             | hmemcpy
13d0c 116 61 73 C7 FA |                 rdbyte  htmp, ptra++
13d10 117 F7 73 43 FC |                 wrbyte  htmp, pb
13d14 118 01 EE 07 F1 |                 add     pb, #1
13d18 119 FC 87 6F 0B |         _ret_   djnz    hr0, #hmemcpy
13d1c 11a             | 
13d1c 11a             | '------------------------------------------------------------------------------
13d1c 11a             | ' A fatal USB error has occured. Notify the client and spin in a pseudo-idle
13d1c 11a             | ' loop until the errant device is disconnected.
13d1c 11a             | '------------------------------------------------------------------------------
13d1c 11a             | ' On entry:
13d1c 11a             | ' On exit:
13d1c 11a             | '------------------------------------------------------------------------------
13d1c 11a             | host_error
13d1c 11a             |           if ERROR_LED >= 0
13d1c 11a             |           end
13d1c 11a A0 07 90 FD |                 jmp     #host_reset                     ' See if it works...
13d20 11b             | 
13d20 11b             | '------------------------------------------------------------------------------
13d20 11b             | ' Get HID descriptor buffer for current port
13d20 11b             | '------------------------------------------------------------------------------
13d20 11b             | ' On entry:
13d20 11b             | ' On exit:
13d20 11b             | '   PB - HID descriptor buffer pointer
13d20 11b             | '------------------------------------------------------------------------------
13d20 11b             | get_hid_descr_buffer
13d20 11b 2D EF 03 F6 |                 mov     pb, hdev_port
13d24 11c 01 EE E7 F2 |                 cmpsub  pb, #1
13d28 11d 00 EF 07 FA |                 mul     pb, #HID_DESCR_LEN
13d2c 11e 25 EF 03 01 |         _ret_   add     pb, hid_descr_p
13d30 11f             | 
13d30 11f             | 
13d30 11f 01 A0 00 00 | usb16_poly_r    long    USB16_POLY
13d34 120             | 
13d34 120             | ' USB commands and error codes
13d34 120 00 00 00 00 | cmd_data        long    0
13d38 121 00 00 00 00 | usb_err_code    long    ERR_NONE
13d3c 122             | 
13d3c 122             | ' Parameters block assigned at cog startup
13d3c 122 12 00 00 00 | dm              long    USB_BASE_PIN + USB_DMINUS_OFFSET ' Client defines the basepin for four consecutive USB port pins
13d40 123 13 00 00 00 | dp              long    USB_BASE_PIN + USB_DMINUS_OFFSET + 1
13d44 124 11 00 00 00 | usb_enable_pin  long    USB_ENABLE_OFFSET < 0 ? -1 : USB_BASE_PIN + USB_ENABLE_OFFSET
13d48 125             | if ACTIVITY_LED >= 0
13d48 125             | host_active_led long    ACTIVITY_LED        ' Client defines the LED pin# for host bus activity
13d48 125             | end
13d48 125             | if ERROR_LED >= 0
13d48 125             | host_error_led  long    ERROR_LED           ' Client defines the LED pin# to light on error
13d48 125             | end
13d48 125 00 00 00 00 | hid_descr_p     long    0
13d4c 126             | 'hid_report_p    long    0, 0[MAX_DEVICES]
13d4c 126             | 'hkbd_report_p   long    0
13d4c 126 00 00 00 00 | hub_descr_p     long    0
13d50 127 00 00 00 00 | urx_buff_p      long    0
13d54 128 00 00 00 00 | dev_desc_buff_p long    0
13d58 129 00 00 00 00 | con_desc_buff_p long    0
13d5c 12a 00 00 00 00 | cache_start_p   long    0
13d60 12b 00 00 00 00 | cache_end_p     long    0
13d64 12c             | if EMUPAD_MAX_PLAYER > 0
13d64 12c             | emupad_out_ptr  long    0
13d64 12c             | end
13d64 12c 00 00 00 00 | save_sysclk     long    0         ' Save the current sysclock as the client may change it
13d68 12d             | 
13d68 12d             | hdev_init_start
13d68 12d             | hdev_port       res     1
13d68 12d             | hdev_next_datax res     ((1+MAX_DEVICES)+3)/4 ' 1+7 byte
13d68 12d             | kbm_next_datax  res     1
13d68 12d             | hub_intf_num    res     1
13d68 12d             | hub_next_datax  res     1
13d68 12d             | hub_status_chg  res     1
13d68 12d             | hub_port_status res     1
13d68 12d             | if HAVE_MOUSE
13d68 12d             | ms_intf_num     res     1
13d68 12d             | ms_in_max_pkt   res     1
13d68 12d             | end
13d68 12d             | kb_intf_num     res     1
13d68 12d             | kb_interval     res     1
13d68 12d             | kb_in_max_pkt   res     1
13d68 12d             | kb_max_index    res     1
13d68 12d             | kb_led_states   res     1
13d68 12d             | gp_intf_num     res     1
13d68 12d             | gp_interval     res     1
13d68 12d             | gp_max_index    res     1
13d68 12d             | gp_descr_len    res     1+MAX_DEVICES
13d68 12d             | hdev_init_end
13d68 12d             | 
13d68 12d             | ' Initialized at cog startup:
13d68 12d             | hcog_base_addr  res     1         ' This object's start address in hub, read from PTRB at cog creation
13d68 12d             | iframe_ct_new   res     1
13d68 12d             | iframe_ct_base  res     1
13d68 12d             | utx_tweak       res     1         ' Sysclock speeds above ~120MHz need some fairy dust for USB tx
13d68 12d             | 
13d68 12d             | ' This register block is reset to zero when a USB device connects
13d68 12d             | hreg_init_start
13d68 12d             | hstatus         res     1         ' Host status flags
13d68 12d             | hctwait         res     1         ' Poll-based wait clocks
13d68 12d             | ip_delay        res     1         ' Inter-packet delay in bit periods for connected device speed
13d68 12d             | tat_wait        res     1         ' Maximum bus turn-around time in bit periods for connected device speed
13d68 12d             | nak_retry       res     1         ' NAK retry count, unlimited retries if zero
13d68 12d             | xfer_retry      res     1         ' Control transfer retry count
13d68 12d             | retry           res     1         ' Transaction retry count
13d68 12d             | utx             res     1         ' Byte to transmit on USB
13d68 12d             | urx             res     1         ' LSByte receiver status flags, MSByte received data
13d68 12d             | newb_flg        res     1         ' Receive "new byte" bit toggle detector
13d68 12d             | max_pkt_size    res     1         ' Maximum payload bytes allowed, likely to change on device connect.
13d68 12d             | total_data      res     1         ' Total bytes to tx/rx in a transfer data stage
13d68 12d             | stage_data      res     1         ' Count of bytes sent/received so far during a data stage.
13d68 12d             | pkt_data        res     1         ' Payload size of an OUT packet or bytes received on IN
13d68 12d             | frame           res     1         ' USB 1ms frame counter value
13d68 12d             | sof_pkt         res     1         ' ISR frame# packet and CRC5
13d68 12d             | icrc            res     1         ' Only used by the 1ms frame output ISR routine
13d68 12d             | pkt_cnt         res     1         ' Count of DATAx packet payload bytes
13d68 12d             | crc             res     1         ' Used for CRC16 calculation
13d68 12d             | ep_addr_pid     res     1         ' Endpoint and device addresses for connected device
13d68 12d             | retval          res     1         ' Global success/fail return parameter
13d68 12d             | context_retval  res     1         ' Operation contextual return parameter
13d68 12d             | ' Device stuff
13d68 12d             | hdev_id         res     1+MAX_DEVICES
13d68 12d             | hdev_bcd        res     1
13d68 12d             | hdev_type       res     ((1+MAX_DEVICES)+3)/4 ' Configured device indicator
13d68 12d             | ' Keyboard/mouse stuff
13d68 12d             | hctrl_ep_addr   res     1
13d68 12d             | hctrl_max_pkt   res     1
13d68 12d             | hconfig_base    res     1
13d68 12d             | hcon_tot_len    res     1         ' Size of the complete config descriptor chain
13d68 12d             | hdev_intf_idx   res     1         ' Used during verbose descriptor terminal output
13d68 12d             | hdev_class      res     1
13d68 12d             | hdev_subclass   res     1
13d68 12d             | hdev_protocol   res     1
13d68 12d             | hsearch_key     res     1         ' Descriptor type to search for in the config chain
13d68 12d             | hnext_desc      res     1         ' Offset from the config descriptor start address to the next descriptor in the chain
13d68 12d             | hhub_ctrl_ep    res     1         ' Hub control endpoint address
13d68 12d             | hhub_ep_addr    res     1         ' Hub interface endpoint address
13d68 12d             | hkbd_ctrl_ep    res     1         ' Keyboard control endpoint address
13d68 12d             | hkbd_ep_addr    res     1         ' Keyboard interface endpoint address
13d68 12d             | if HAVE_MOUSE
13d68 12d             | hmouse_ep_addr  res     1 ' Mouse interface endpoint address
13d68 12d             | end
13d68 12d             | hkbd_poll_cnt   res     1         ' Poll interval counter used for key auto-repeat
13d68 12d             | hkbd_ledstates  res     1         ' Off/on state of keyboard LEDs
13d68 12d             | hdev_ep_addr    res     1+MAX_DEVICES
13d68 12d             | hdev_out_addr   res     1
13d68 12d             | 
13d68 12d             | if EMUPAD_MAX_PLAYER > 0
13d68 12d             | hkbd_emupad_buffer res EMUPAD_MAX_PLAYER
13d68 12d             | hpad_emupad_buffer res EMUPAD_MAX_PLAYER
13d68 12d             | hpad_emupad_rule   res 1+MAX_DEVICES ' This is PER REAL DEVICE
13d68 12d             | end
13d68 12d             | 
13d68 12d             | hreg_init_end
13d68 12d             | 
13d68 12d             | hidr_start
13d68 12d             | hidr_usage      res     1 ' <- can get trashed after parsing
13d68 12d             | hidr_flags      res     1
13d68 12d             | hidr_axis       res     4
13d68 12d             | hidr_buttons    res     1
13d68 12d             | hidr_hats       res     1
13d68 12d             | '' Above are actually useful values, 6 longs
13d68 12d             | hidr_type       res     1
13d68 12d             | hidr_id         res     1
13d68 12d             | hidr_offset     res     1
13d68 12d             | hidr_usage_idx  res     1
13d68 12d             | ' below need to be push/pop'd
13d68 12d             | hidr_state      res     1
13d68 12d             | hidr_size       res     1
13d68 12d             | hidr_count      res     1
13d68 12d             | hidr_lminmax    res     1
13d68 12d             | hidr_pminmax    res     1
13d68 12d             | hidr_end
13d68 12d             | 
13d68 12d             | ' Variables dependent on the system freqency
13d68 12d             | _var_64_lower_  res     1
13d68 12d             | _var_64_upper_  res     1
13d68 12d             | _12Mbps_        res     1
13d68 12d             | _1_5Mbps_       res     1
13d68 12d             | _1ns16fp_       res     1         ' 1ns as 32,16 fixed point
13d68 12d             | _1us_           res     1         ' 1us
13d68 12d             | _10us_          res     1         ' 10us
13d68 12d             | _33us_          res     1         ' 33us
13d68 12d             | _txn_err_       res     1         ' 250us
13d68 12d             | _500us_         res     1         ' 500us
13d68 12d             | _txn_ok_ls_     res     1         ' 666us timespan for LS transaction OK window
13d68 12d             | _txn_ok_fs_     res     1         ' 850us timespan for FS transaction OK window
13d68 12d             | _ip_delay_ls_   res     1         ' Low-Speed inter-packet 4 bit-time delay
13d68 12d             | _ip_delay_fs_   res     1         ' Full-Speed inter-packet 4 bit-time delay
13d68 12d             | _tat_wait_ls_   res     1         ' Low-Speed turnaround 22 bit-time wait
13d68 12d             | _tat_wait_fs_   res     1         ' Full-Speed turnaround 28 bit-time wait
13d68 12d             | _preamble_wait_ res     1
13d68 12d             | _1ms_           res     1         ' 1ms
13d68 12d             | _2ms_           res     1         ' 2ms
13d68 12d             | _suspend_wait_  res     1         ' 3ms
13d68 12d             | _4ms_           res     1         ' 4ms
13d68 12d             | _xfer_wait_     res     1         ' 5ms
13d68 12d             | _8ms_           res     1         ' 8ms timespan for keyboard/mouse interrupt IN transactions
13d68 12d             | _reset_hold_    res     1         ' 15ms
13d68 12d             | _resume_hold_   res     1         ' Hold K-state for 20ms to signal device(s) to resume
13d68 12d             | _21ms_          res     1         ' 21ms
13d68 12d             | _100ms_         res     1         ' 100ms
13d68 12d             | _500ms_         res     1         ' 500ms
13d68 12d             | _pulse_time_    res     1         ' Activity LED toggle interval, one sec connect wait, _500ms_ when connected
13d68 12d             | _frame1ms_clks_ res     1         '_1ms +/- n clocks: calculated based on the current sysclock
13d68 12d             | '------------------------------------------------------------------------------
13d68 12d             | _usb_h_ls_nco_  res     1         ' USB smart pin modes dependent on sysclock
13d68 12d             | _usb_d_ls_nco_  res     1
13d68 12d             | _usb_h_fs_nco_  res     1
13d68 12d             | _usb_d_fs_nco_  res     1
13d68 12d             | '------------------------------------------------------------------------------
13d68 12d             | ' Scratch registers
13d68 12d             | htmp            res     1         ' Scratch registers whose context remains within the same code block
13d68 12d             | htmp1           res     1
13d68 12d             | htmp2           res     1
13d68 12d             | htmp3           res     1
13d68 12d             | hrep            res     1         ' Repeat count
13d68 12d             | hsave0          res     1         ' Subroutine parameter saves
13d68 12d             | hsave1          res     1
13d68 12d             | hsave2          res     1
13d68 12d             | isrtmp1         res     1
13d68 12d             | pkt_tmp         res     1         ' Tmp storage for routines that deal with datax packets
13d68 12d             | hr0             res     1         ' Multi-purpose registers
13d68 12d             | hr1             res     1
13d68 12d             | hr2             res     1
13d68 12d             | hr3             res     1
13d68 12d             | hpar1           res     1         ' Routine entry/exit parameters
13d68 12d             | hpar2           res     1
13d68 12d             | hpar3           res     1
13d68 12d             | hct2            res     1         ' Function response bus turn-around timer
13d68 12d             | hct3            res     1         ' Keyboard/mouse poll timer
13d68 12d             | mod_cnt         res     1         ' Used in idle loops
13d68 12d             | 
13d68 12d             |                 fit     $1F0
13d68 12d             |                 fit     $1F0
13d68 12d             |                 org     $200
13d68 200             | hlut_start
13d68 200             | 
13d68 200             | '------------------------------------------------------------------------------
13d68 200             | ' Full-speed is the host's native speed, so all that is needed is to set the FS
13d68 200             | ' settings to startup defaults.
13d68 200             | '------------------------------------------------------------------------------
13d68 200             | ' On entry:
13d68 200             | ' On exit: Save/restore caller C flag state if C is changed in this routine!
13d68 200             | '------------------------------------------------------------------------------
13d68 200             | set_speed_full
13d68 200 D0 E8 07 F6 |                 mov     ijmp1, #isr1_fsframe            ' Set the USB 1ms frame handler ISR routine
13d6c 201 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
13d70 202 A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in full-speed bit periods
13d74 203 A4 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in full-speed bit periods
13d78 204             | '                ret                             wcz     ' Restore caller flags on exit
13d78 204             | 
13d78 204             | '------------------------------------------------------------------------------
13d78 204             | ' When a low-speed device connects, the D-/D+ signaling is inverted. If there
13d78 204             | ' is a downstream hub connected (not yet implemented), the baud generator
13d78 204             | ' remains set at the full-speed rate, but signaling is switched to low-speed,
13d78 204             | ' which reverses the D-/D+ polarity. The polarity can be changed without
13d78 204             | ' putting the smart pins into reset.
13d78 204             | '------------------------------------------------------------------------------
13d78 204             | ' On entry:
13d78 204             | ' On exit: CZ flags restored to caller states
13d78 204             | '------------------------------------------------------------------------------
13d78 204             | set_speed_low
13d78 204 80 96 CE F7 |                 test    hstatus, #DWNSTRM_HUBF  wz      ' If no downstream hub connected, set low-speed baud
13d7c 205 ED E8 07 A6 |         if_z    mov     ijmp1, #isr1_lsframe            ' Set the USB 1ms frame handler ISR routine
13d80 206 22 6B 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud if no downstream hub
13d84 207 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
13d88 208 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
13d8c 209 A3 9B 02 F6 |                 mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
13d90 20a 02 96 26 F4 |                 bith    hstatus, #LOW_SPEEDB            ' D- pulled high, so it's a Low-Speed device
13d94 20b 2D 00 7C FD |                 ret                             wcz     ' Restore caller flags on exit
13d98 20c             | 
13d98 20c             | '------------------------------------------------------------------------------
13d98 20c             | ' Perform configuration stuff required when a device intitially connects.
13d98 20c             | '------------------------------------------------------------------------------
13d98 20c             | ' On entry:
13d98 20c             | ' On exit:
13d98 20c             | '------------------------------------------------------------------------------
13d98 20c             | on_connect
13d98 20c 02 86 07 F6 |                 mov     hr0, #2                         ' FIXME: need to determine a reasonable limit for reset & retry
13d9c 20d D8 FB BF FD |                 call    #dev_reset                      ' Reset device prior to Get Device Descriptor request
13da0 20e             | .retry
13da0 20e 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
13da4 20f 01 8E 07 C6 |         if_c    mov     hpar1, #USB_SPEED_LOW           ' Also the connect speed
13da8 210 02 8E 07 36 |         if_nc   mov     hpar1, #USB_SPEED_FULL
13dac 211 00 08 00 FF 
13db0 212 00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
13db4 213 20 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Hub start address of GetDeviceDescriptor SETUP struct
13db8 214 47 F1 03 F1 |                 add     ptra, hcog_base_addr
13dbc 215 03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
13dc0 216 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
13dc4 217 F4 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
13dc8 218 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13dcc 219 18 00 90 AD |         if_z    jmp     #.get_dev_desc
13dd0 21a B2 99 02 F6 |                 mov     hctwait, _500ms_                ' If the first GetDescriptor() fails, reset and try again
13dd4 21b 4C 03 B0 FD |                 call    #poll_waitx
13dd8 21c 01 86 8F F1 |                 sub     hr0, #1         wz              ' FIXME: need to determine a reasonable limit for reset & retry
13ddc 21d F0 FB 9F AD |         if_z    jmp     #host_error                     ' Post error and spin until the errant device is disconnected
13de0 21e A4 FB BF FD |                 call    #reset                          ' Try another reset to see if the device responds
13de4 21f B8 FF 9F FD |                 jmp     #.retry
13de8 220             | .get_dev_desc
13de8 220 28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
13dec 221 07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
13df0 222 F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
13df4 223 A8 99 02 F6 |                 mov     hctwait, _1ms_
13df8 224 28 03 B0 FD |                 call    #poll_waitx                     ' Do a reset before SetAddress(), but wait a bit first
13dfc 225 88 FB BF FD |                 call    #reset
13e00 226 38 1E C0 FE |                 loc     ptra, #@set_address - @usb_host_start ' Hub start address of SetAddress SETUP struct
13e04 227 47 F1 03 F1 |                 add     ptra, hcog_base_addr
13e08 228 01 11 5C FC |                 wrword  #8, ptra[wValue]                ' Only support one device port at this time
13e0c 229 D8 01 B0 FD |                 call    #control_write                  ' Execute SetAddress()
13e10 22a D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13e14 22b 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
13e18 22c AD 99 02 F6 |                 mov     hctwait, _8ms_
13e1c 22d 04 03 B0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
13e20 22e 04 00 00 FF 
13e24 22f 00 BC 06 F6 |                 mov     ep_addr_pid, ##8 << 8           ' Device ep/addr now #8 and endpoint zero
13e28 230 34 FA BF FD |                 call    #calc_crc5
13e2c 231 20 1E C0 FE |                 loc     ptra, #@get_dev_desc - @usb_host_start ' Repeat SETUP for GetDeviceDescriptor()
13e30 232 47 F1 03 F1 |                 add     ptra, hcog_base_addr
13e34 233 28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
13e38 234 F7 AD C2 FA |                 rdbyte  total_data, pb
13e3c 235 03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
13e40 236 78 00 B0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
13e44 237 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13e48 238 2D 00 64 5D |         if_nz   ret                                     ' Back to idle if not ACK
13e4c 239 5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
13e50 23a 28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
13e54 23b 07 DB C6 FA |                 rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
13e58 23c A0 99 02 F6 |                 mov     hctwait, _500us_
13e5c 23d C4 02 B0 FD |                 call    #poll_waitx
13e60 23e 28 1E C0 FE |                 loc     ptra, #@get_config_desc - @usb_host_start ' Hub start address of GetConfigurationDescriptor SETUP struct
13e64 23f 47 F1 03 F1 |                 add     ptra, hcog_base_addr
13e68 240 03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
13e6c 241 29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
13e70 242 48 00 B0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
13e74 243 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13e78 244 2D 00 64 5D |         if_nz   ret
13e7c 245 29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
13e80 246 F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
13e84 247 61 87 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
13e88 248 61 89 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
13e8c 249 00 73 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
13e90 24a 09 86 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
13e94 24b 02 88 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
13e98 24c 56 73 1B A2 |         if_z    cmp     htmp, total_data        wcz
13e9c 24d 0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
13ea0 24e 2C FB 9F CD |         if_b    jmp     #host_error
13ea4 24f 24 13 80 FE |                 loc     pa, #@init_kbdm_data - @usb_host_start
13ea8 250 47 ED 03 F1 |                 add     pa, hcog_base_addr
13eac 251 2D EC 63 FD |                 call    pa
13eb0 252 B8 0D 80 FE |                 loc     pa, #@hparse_con_desc - @usb_host_start
13eb4 253 47 ED 03 F1 |                 add     pa, hcog_base_addr
13eb8 254 2C EC 63 FD |                 jmp     pa
13ebc 255             | 
13ebc 255             | '------------------------------------------------------------------------------
13ebc 255             | ' Perform a control read transaction (Section 8.5.3, Figure 8-37).
13ebc 255             | ' Status reporting is always in the function-to-host direction.
13ebc 255             | '------------------------------------------------------------------------------
13ebc 255             | ' On entry:
13ebc 255             | '   PTRA - start address of the SETUP data in hub.
13ebc 255             | '   PB - start address of the buffer/struct to be written to during the IN data
13ebc 255             | '     stage.
13ebc 255             | '   ep_addr_pid - device address, endpoint and CRC5.
13ebc 255             | ' On exit:
13ebc 255             | '   retval - PID_ACK on success, otherwise error. If successful, reg total_data
13ebc 255             | '     contains the count of data stage bytes actually received, which must
13ebc 255             | '     always be <= the count requested.
13ebc 255             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
13ebc 255             | '     more specific USB operation error code.
13ebc 255             | '------------------------------------------------------------------------------
13ebc 255             | control_read
13ebc 255 5E 8F 03 F6 |                 mov     hpar1, ep_addr_pid
13ec0 256 F8 91 03 F6 |                 mov     hpar2, ptra
13ec4 257 F7 93 03 F6 |                 mov     hpar3, pb                       ' Save dest buffer pointer
13ec8 258 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
13ecc 259             | .xfer_start
13ecc 259 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
13ed0 25a C0 F6 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
13ed4 25b D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13ed8 25c 2D 00 64 5D |         if_nz   ret                                     ' Back to caller to handle error
13edc 25d 00 AC 0E F2 |                 cmp     total_data, #0          wz
13ee0 25e 90 01 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
13ee4 25f 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
13ee8 260 61 00 00 FF 
13eec 261 50 9F 06 F6 |                 mov     nak_retry, ##IN_NAK_RETRIES
13ef0 262 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
13ef4 263             | .data
13ef4 263 56 B1 02 F6 |                 mov     pkt_data, total_data
13ef8 264 57 B1 82 F1 |                 sub     pkt_data, stage_data
13efc 265 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
13f00 266 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Have a full packet with more data left
13f04 267             | .nak_retry
13f04 267 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset bus error retry limit
13f08 268             | .in_retry
13f08 268 BC F6 BF FD |                 call    #txn_in
13f0c 269 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Commit on ACK
13f10 26a 28 00 90 AD |         if_z    jmp     #.commit
13f14 26b 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
13f18 26c A8 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
13f1c 26d 14 02 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
13f20 26e 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
13f24 26f DC FF 9F AD |         if_z    jmp     #.nak_retry                     ' Function not ready to send data
13f28 270 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
13f2c 271 94 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
13f30 272 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
13f34 273 D0 FF 9F 5D |         if_nz   jmp     #.in_retry                      ' Bus error retry
13f38 274 2D 00 64 FD |                 ret                                     ' The transfer has failed
13f3c 275             | .commit
13f3c 275 00 B8 0E F2 |                 cmp     pkt_cnt, #0             wz      ' Empty pkt means previous pkt was max_pkt_len
13f40 276 38 00 90 AD |         if_z    jmp     #.pre_status                    ' and also end-of-data
13f44 277 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy DATAx in rx buffer to dest struct
13f48 278 5C 87 03 F6 |                 mov     hr0, pkt_cnt
13f4c 279 F7 F1 0B F2 |                 cmp     ptra, pb                wz
13f50 27a 6C FA BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
13f54 27b 5C AF 02 F1 |                 add     stage_data, pkt_cnt             ' Update bytes received on commit
13f58 27c 56 AF 0A F2 |                 cmp     stage_data, total_data  wz      ' Have all asked-for bytes?
13f5c 27d 1C 00 90 AD |         if_z    jmp     #.pre_status                    ' Have all the data that's coming, so done
13f60 27e 58 B9 1A F2 |                 cmp     pkt_cnt, pkt_data       wcz     ' Check for short packet
13f64 27f 14 00 90 CD |         if_b    jmp     #.pre_status                    ' Actual payload < expected means end of data stage
13f68 280 04 BE 06 16 |         if_a    mov     retval, #ERR_PACKET
13f6c 281 5F C1 02 16 |         if_a    mov     context_retval, retval          ' In this case overall and context are the same
13f70 282 2D 00 64 1D |         if_a    ret                                     ' Caller must handle ERR_PACKET
13f74 283 03 96 E6 F4 |                 bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
13f78 284 78 FF 9F FD |                 jmp     #.data                          ' Start next IN transaction
13f7c 285             | .pre_status
13f7c 285 57 AD 02 F6 |                 mov     total_data, stage_data          ' Replace the asked-for byte count with the bytes actually received
13f80 286 E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0
13f84 287 00 B0 06 F6 |                 mov     pkt_data, #0
13f88 288 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage starts with DATA1 PID
13f8c 289 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
13f90 28a 61 00 00 FF 
13f94 28b 50 9F 06 F6 |                 mov     nak_retry, ##OUT_NAK_RETRIES
13f98 28c             | .out_retry
13f98 28c 34 F7 BF FD |                 call    #txn_out                        ' Send empty OUT DATAx packet to confirm IN data received OK
13f9c 28d D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
13fa0 28e 2D 00 64 AD |         if_z    ret                                     ' All is good when ACK
13fa4 28f 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
13fa8 290 18 00 90 AD |         if_z    jmp     #.xfer_retry                    ' STALL triggers a transfer retry
13fac 291 84 01 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
13fb0 292 08 BE 0E F2 |                 cmp     retval, #ERR_NAK        wz
13fb4 293 0C 00 90 AD |         if_z    jmp     #.xfer_retry                    ' NAK limit exceeded triggers a transfer retry
13fb8 294 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
13fbc 295 D8 FF 9F 5D |         if_nz   jmp     #.out_retry                     ' Retry due to bus error or OUT-NAK retry limit not reached
13fc0 296 2D 00 64 FD |                 ret                                     ' Caller must handle transfer retirement
13fc4 297             | ' I've encountered transfer STALL, even though the data looks correct, and
13fc4 297             | ' instances of getting stuck in an endless OUT-NAK loop. Repeating the entire
13fc4 297             | ' ControlRead() transfer gets things unstuck most of the time...
13fc4 297             | .xfer_retry
13fc4 297 AC 99 02 F6 |                 mov     hctwait, _xfer_wait_
13fc8 298 58 01 B0 FD |                 call    #poll_waitx
13fcc 299 8C F9 BF FD |                 call    #wait_txn_ok
13fd0 29a C7 BD 02 F6 |                 mov     ep_addr_pid, hpar1
13fd4 29b C8 F1 03 F6 |                 mov     ptra, hpar2
13fd8 29c C9 EF 03 F6 |                 mov     pb, hpar3
13fdc 29d BB A1 6E FB |                 djnz    xfer_retry, #.xfer_start
13fe0 29e 5F C1 02 F6 |                 mov     context_retval, retval          ' Preserve the USB error code
13fe4 29f 07 BE 06 06 |         _ret_   mov     retval, #ERR_XFER_RETRY
13fe8 2a0             | 
13fe8 2a0             | '------------------------------------------------------------------------------
13fe8 2a0             | ' Perform a control write transaction (Section 8.5.3, Figure 8-37). Status
13fe8 2a0             | ' reporting is always in the function-to-host direction. It is assumed that
13fe8 2a0             | ' the SETUP data struct is filled with the required values.
13fe8 2a0             | '------------------------------------------------------------------------------
13fe8 2a0             | ' On entry:
13fe8 2a0             | '   PTRA - points to the start of the struct for the SETUP data.
13fe8 2a0             | '   PB - the start address of the struct/buffer to be read for the OUT data
13fe8 2a0             | '     stage.
13fe8 2a0             | '   ep_addr_pid - the proper CRC'd address and endpoint to use.
13fe8 2a0             | ' On exit:
13fe8 2a0             | '   retval - used to convey the success/failure of each stage.
13fe8 2a0             | '   context_retval - ERR_NONE if the overall transfer succeeds, otherwise a
13fe8 2a0             | '     more specific USB operation error code.
13fe8 2a0             | '------------------------------------------------------------------------------
13fe8 2a0             | control_write
13fe8 2a0 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
13fec 2a1 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
13ff0 2a2 0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
13ff4 2a3             | 
13ff4 2a3 5E 8F 03 F6 |                 mov     hpar1, ep_addr_pid
13ff8 2a4 F8 91 03 F6 |                 mov     hpar2, ptra
13ffc 2a5 F7 93 03 F6 |                 mov     hpar3, pb
14000 2a6 0C A0 06 F6 |                 mov     xfer_retry, #XFER_RETRIES
14004 2a7             | .xfer_start
14004 2a7 00 9E 06 F6 |                 mov     nak_retry, #NAK_NOLIMIT         ' Unlimited NAK retries the default
14008 2a8 03 AD E6 FA |                 rdword  total_data, ptra[wLength]       ' Get the size of the data stage from the SETUP struct
1400c 2a9 84 F5 BF FD |                 call    #txn_setup                      ' SETUP logic is the same for both control reads and writes
14010 2aa D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14014 2ab EC 00 90 5D |         if_nz   jmp     #dwnstream_reset                ' Back to caller to handle error
14018 2ac 00 AC 0E F2 |                 cmp     total_data, #0          wz
1401c 2ad 54 00 90 AD |         if_z    jmp     #pre_status_in                  ' No data, so directly to status stage
14020 2ae 00 AE 06 F6 |                 mov     stage_data, #0                  ' Prepare for data stage
14024 2af E1 BC C6 F8 |                 setbyte ep_addr_pid, #PID_OUT, #0       ' PID isn't part of the CRC calc
14028 2b0 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Data stage starts with DATA1 PID
1402c 2b1 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
14030 2b2             | .data
14030 2b2 56 B1 02 F6 |                 mov     pkt_data, total_data
14034 2b3 57 B1 82 F1 |                 sub     pkt_data, stage_data
14038 2b4 55 B1 1A F2 |                 cmp     pkt_data, max_pkt_size  wcz
1403c 2b5 55 B1 02 16 |         if_a    mov     pkt_data, max_pkt_size          ' Data remaining is > max_pkt, so cap at max_pkt
14040 2b6             | .out_retry
14040 2b6 F7 F1 03 F6 |                 mov     ptra, pb                        ' Set current location in the OUT data buffer/struct
14044 2b7 88 F6 BF FD |                 call    #txn_out
14048 2b8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
1404c 2b9 10 00 90 AD |         if_z    jmp     #.commit                        ' Function got the data
14050 2ba E0 00 B0 FD |                 call    #retry_wait                     ' Wait a bit before retry
14054 2bb 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz      ' Out of !NAK retries?
14058 2bc E4 FF 9F 5D |         if_nz   jmp     #.out_retry
1405c 2bd A4 00 90 FD |                 jmp     #dwnstream_reset                ' Caller must handle transfer retirement
14060 2be             | .commit
14060 2be F8 EF 03 F6 |                 mov     pb, ptra                        ' Save the current buffer/struct location
14064 2bf 58 AF 02 F1 |                 add     stage_data, pkt_data
14068 2c0 56 AF 0A F2 |                 cmp     stage_data, total_data  wz
1406c 2c1 03 96 E6 54 |         if_nz   bitnot  hstatus, #DATAx_TGLB            ' Toggle DATAx sync bit
14070 2c2 BC FF 9F 5D |         if_nz   jmp     #.data                          ' More data to send
14074 2c3             | pre_status_in
14074 2c3 03 96 26 F4 |                 bith    hstatus, #DATAx_TGLB            ' Status stage expects IN to be an empty DATA1 packet
14078 2c4 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES             ' Reset txn retry limit
1407c 2c5             | .status_retry
1407c 2c5 00 B0 06 F6 |                 mov     pkt_data, #0
14080 2c6 44 F5 BF FD |                 call    #txn_in
14084 2c7 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK says a DATA1 packet was received
14088 2c8 00 B0 0E A2 |         if_z    cmp     pkt_data, #0            wz      ' DEBUG: should never fail if the function is USB compliant?
1408c 2c9 74 00 90 AD |         if_z    jmp     #dwnstream_reset                ' Control Write finished
14090 2ca 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz      ' STALL needs to go to the caller for resolution
14094 2cb 2D 00 64 AD |         if_z    ret
14098 2cc 98 00 B0 FD |                 call    #retry_wait                     ' NAK or bus error, so delay a bit
1409c 2cd 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
140a0 2ce D8 FF 9F 5D |         if_nz   jmp     #.status_retry
140a4 2cf             | '               ret                                     ' Caller must handle transfer retirement
140a4 2cf             | 
140a4 2cf             | '------------------------------------------------------------------------------
140a4 2cf             | ' Execute an IN interrupt transaction.
140a4 2cf             | '------------------------------------------------------------------------------
140a4 2cf             | ' On entry:
140a4 2cf             | '   ep_addr_pid - The function address and endpoint for the IN request.
140a4 2cf             | '   hpar2 - Address of the IN data buffer
140a4 2cf             | '   hpar3 - Word1 has max data packet size, word0 has the DATAx to expect.
140a4 2cf             | ' On exit:
140a4 2cf             | '   retval - the result of the operation.
140a4 2cf             | '   hpar3 - the count of IN data bytes actually received.
140a4 2cf             | '------------------------------------------------------------------------------
140a4 2cf             | do_int_in
140a4 2cf 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
140a8 2d0 07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
140ac 2d1 0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
140b0 2d2             | 
140b0 2d2 C9 73 33 F9 |                 getword htmp, hpar3, #0
140b4 2d3 C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz
140b8 2d4 03 96 A6 F4 |                 bitnz   hstatus, #DATAx_TGLB            ' Set/reset flag for DATAx to expect
140bc 2d5 0C A2 06 F6 |                 mov     retry, #TXN_RETRIES
140c0 2d6             | .retry
140c0 2d6 C9 B1 3A F9 |                 getword pkt_data, hpar3, #1             ' IN max packet length
140c4 2d7 00 F5 BF FD |                 call    #txn_in
140c8 2d8 D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' ACK if data received
140cc 2d9 1C 00 90 AD |         if_z    jmp     #.commit
140d0 2da 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz      ' NAK if no data available (common)
140d4 2db 1E BE 0E 52 |         if_nz   cmp     retval, #PID_STALL      wz      ' STALL if the endpoint has a transfer issue and must be reset (rare)
140d8 2dc 24 00 90 AD |         if_z    jmp     #.post_ret                      ' The caller must handle either
140dc 2dd 54 00 B0 FD |                 call    #retry_wait
140e0 2de 06 BE 0E F2 |                 cmp     retval, #ERR_TXN_RETRY  wz
140e4 2df 18 00 90 AD |         if_z    jmp     #.post_ret
140e8 2e0 D4 FF 9F FD |                 jmp     #.retry
140ec 2e1             | .commit
140ec 2e1 27 F1 03 F6 |                 mov     ptra, urx_buff_p                ' Copy the rx buffer
140f0 2e2 C8 EF 03 F6 |                 mov     pb, hpar2                       ' to the destination buffer
140f4 2e3 5C 87 0B F6 |                 mov     hr0, pkt_cnt            wz      ' Skip copy if it's an empty packet
140f8 2e4 F7 F1 0B 52 |         if_nz   cmp     ptra, pb                wz
140fc 2e5 C0 F8 BF 5D |         if_nz   call    #hmemcpy                        ' hmemcpy(PTRA, PB, hr0)
14100 2e6             | .post_ret
14100 2e6 5C 93 03 F6 |                 mov     hpar3, pkt_cnt                  ' IN bytes actually received
14104 2e7             | 
14104 2e7             | 
14104 2e7             | '------------------------------------------------------------------------------
14104 2e7             | ' Resets the downstream hub port to FS
14104 2e7             | '------------------------------------------------------------------------------
14104 2e7             | dwnstream_reset
14104 2e7 1F BC 16 F4 |                 testb   ep_addr_pid, #31        wc
14108 2e8 2D 00 64 3D |         if_nc   ret                                     ' No LS device, reset not needed
1410c 2e9             | 
1410c 2e9 0E 6A 07 F4 |                 bitl    _usb_h_ls_nco_, #14
14110 2ea 07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
14114 2eb 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
14118 2ec 40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set FS control read/write DATAx packet size
1411c 2ed A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
14120 2ee A4 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
14124 2ef             | 
14124 2ef             | '------------------------------------------------------------------------------
14124 2ef             | ' The one millisecond frame timer is implemented as an interrupt service
14124 2ef             | ' routine. Since this timing is critical, care must be taken to avoid any
14124 2ef             | ' instructions that can delay the interrupt branch, which will likely upset
14124 2ef             | ' the timer. WAITX is among those instructions, so any time you're inside
14124 2ef             | ' an IN/OUT/SETUP transaction, use this routine instead of WAITX.
14124 2ef             | '------------------------------------------------------------------------------
14124 2ef             | ' On entry:
14124 2ef             | '   hctwait - wait interval in sysclocks.
14124 2ef             | ' On exit:
14124 2ef             | '------------------------------------------------------------------------------
14124 2ef             | poll_waitx
14124 2ef 1A 94 63 FD |                 getct   hct2
14128 2f0 4C 95 6B FA |                 addct2  hct2, hctwait
1412c 2f1             | .wait
1412c 2f1 FF 25 CC FB |                 jnct2   #.wait
14130 2f2 2D 00 64 FD |                 ret
14134 2f3             | 
14134 2f3             | '------------------------------------------------------------------------------
14134 2f3             | ' Transaction retry handling for NAK/STALL or bus error.
14134 2f3             | '------------------------------------------------------------------------------
14134 2f3             | ' On entry:
14134 2f3             | '   retval - transaction response PID or error code.
14134 2f3             | ' On exit:
14134 2f3             | '------------------------------------------------------------------------------
14134 2f3             | retry_wait
14134 2f3 1E BE 0E F2 |                 cmp     retval, #PID_STALL      wz
14138 2f4 2D 00 64 AD |         if_z    ret                                     ' STALL is special case
1413c 2f5 5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
14140 2f6 14 00 90 AD |         if_z    jmp     #.nak
14144 2f7 9F 99 02 F6 |                 mov     hctwait, _txn_err_              ' Transaction error wait...
14148 2f8 D8 FF BF FD |                 call    #poll_waitx
1414c 2f9             | .dec
1414c 2f9 01 A2 8E F1 |                 sub     retry, #1               wz
14150 2fa 06 BE 06 A6 |         if_z    mov     retval, #ERR_TXN_RETRY          ' Only set error code if no retries left
14154 2fb 2D 00 64 FD |                 ret                                     ' Retry result to caller
14158 2fc             | .nak
14158 2fc 9E 99 02 F6 |                 mov     hctwait, _33us_                 ' Seems to be a reasonable NAK delay
1415c 2fd C4 FF BF FD |                 call    #poll_waitx
14160 2fe 00 9E 0E F2 |                 cmp     nak_retry, #NAK_NOLIMIT wz
14164 2ff 2D 00 64 AD |         if_z    ret                                     ' Indefinite NAK retries
14168 300 01 9E 8E F1 |                 sub     nak_retry, #1           wz
1416c 301 08 BE 06 A6 |         if_z    mov     retval, #ERR_NAK
14170 302 2D 00 64 FD |                 ret
14174 303             | 
14174 303             | host_reset
14174 303 25 00 64 FD |                 setint1 #0                              ' Ensure 1ms frame strobe interrupt is off
14178 304 14 72 07 FB |                 rdlong   htmp, #CLKFREQ_PTR             ' Get current sysclock setting
1417c 305             | ' FIXME: kludge to set a USB tx byte write ACKPIN<->WRPIN delay.
1417c 305 BD 01 05 FF 
14180 306 00 72 1F F2 |                 cmp     htmp, ##168_000_000     wcz
14184 307 00 94 06 E6 |         if_be   mov     utx_tweak, #0
14188 308 03 94 06 16 |         if_a    mov     utx_tweak, #3   '#20
1418c 309             | ' Check to see if the system clock has been changed.
1418c 309 2C 73 0B F2 |                 cmp     htmp, save_sysclk       wz
14190 30a C4 0B A0 5E |         if_nz   loc     pb, #@hinit_usb_timings - @usb_host_start
14194 30b 47 EF 03 51 |         if_nz   add     pb, hcog_base_addr
14198 30c 2D EE 63 5D |         if_nz   call    pb                              ' Recalculate sysclk dependent timing values
1419c 30d 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
141a0 30e 40 46 62 FD |                 dirl    dp
141a4 30f             | 
141a4 30f 28 02 64 FD |                 setq    #1
141a8 310 80 00 80 FF 
141ac 311 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
141b0 312 22 6F 13 FC |                 wxpin   _usb_h_fs_nco_, dm              ' Set host mode and full-speed NCO
141b4 313             | .enable
141b4 313 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
141b8 314 41 46 62 FD |                 dirh    dp
141bc 315 1F 38 63 FD |                 waitx   _1us_
141c0 316 22 01 28 FC |                 wypin   #OUT_IDLE, dm
141c4 317             | 
141c4 317             |                 ' Handle Port protection enable and startup delay
141c4 317 00 48 56 F2 |                 cmps    usb_enable_pin, #0      wc
141c8 318 58 48 62 3D |         if_ae   drvl    usb_enable_pin                 ' disable port
141cc 319 1F 60 63 FD |                 waitx   _21ms_                          ' Wait a while for everything to turn off
141d0 31a 59 48 62 3D |         if_ae   drvh    usb_enable_pin                  ' Enable the port
141d4 31b 1F 60 63 FD |                 waitx   _21ms_                          ' Hold to let the idle state get settled
141d8 31c             | 
141d8 31c             |                 'call #dev_reset ' TODO THINK ABOUT THIS
141d8 31c             | 
141d8 31c             | discon_entry
141d8 31c 03 98 07 F6 |                 mov     mod_cnt, #3                     ' Make the first heartbeat pulse a short one
141dc 31d             | 
141dc 31d 4B ED B7 F9 |                 setd    pa, #hreg_init_start            ' Reset all host common registers to startup values
141e0 31e 3B 04 DC FC |                 rep     @.regloop,#hreg_init_end - hreg_init_start
141e4 31f 38 EC A7 F9 |                 alti    pa, #%000_111_000
141e8 320 00 00 04 F6 |                 mov     0-0, #0
141ec 321             | .regloop
141ec 321             |               
141ec 321             |         if HAVE_HIDPAD
141ec 321 F8 27 A0 FE |                 loc     pb, #@hidpad_report - @usb_host_start
141f0 322 47 EF 03 F1 |                 add     pb, hcog_base_addr
141f4 323 28 6E 64 FD |                 setq    #(HIDPAD_REPORT_SIZE/4)*MAX_DEVICES - 1
141f8 324 F7 01 68 FC |                 wrlong  #0,pb
141fc 325             |         end
141fc 325             |         if EMUPAD_MAX_PLAYER > 0
141fc 325             |         end
141fc 325             | 
141fc 325             |                 ' Fall through to disconnected loop
141fc 325             | 
141fc 325             | '-----------------------------------------------------------------------------------------------------------------
141fc 325             | ' Device connect handling (Section 7.1.7.3).
141fc 325             | '-----------------------------------------------------------------------------------------------------------------
141fc 325             | ' The 15K pull-down resistors on D+ and D- allow the host to passively monitor the bus lines while waiting for a
141fc 325             | ' device to connect (Section 7.1.7.3).
141fc 325             | '-----------------------------------------------------------------------------------------------------------------
141fc 325             | disconnected
141fc 325 14 88 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Check to see if the system frequency has changed
14200 326 2C 89 0B F2 |                 cmp     hr1, save_sysclk        wz
14204 327 6C FF 9F 5D |         if_nz   jmp     #host_reset                     ' host_reset will apply the new USB bus NCO calculation
14208 328 03 88 47 F0 |                 shr     hr1, #3                         ' Pulse the activity LED every two seconds but break
1420c 329 1F 88 63 FD |                 waitx   hr1                             ' it down to smaller wait chunks
14210 32a             |         if ACTIVITY_LED >= 0
14210 32a             |         end
14210 32a 22 A7 82 FA |                 rqpin   urx, dm
14214 32b 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz   ' Wait for rise of J or K, mutually exclusive
14218 32c E0 FF 9F AD |         if_z    jmp     #disconnected                   ' J and K still low, so keep waiting for connect
1421c 32d 28 00 90 5D |         if_ne   jmp     #.connect_test                  ' J or K is high, so test for connect
14220 32e             | .se1_test
14220 32e B1 99 02 F6 |                 mov     hctwait, _100ms_                ' J and K high is illegal SE1 state, so wait and retest
14224 32f FC FE BF FD |                 call    #poll_waitx
14228 330 22 A7 82 FA |                 rqpin   urx, dm
1422c 331 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
14230 332 00 BE 06 56 |         if_ne   mov     retval, #ERR_NONE               ' SE0 or idle state resets any previous error
14234 333 A0 FF 9F 5D |         if_ne   jmp     #discon_entry                   ' Back to connect detection loop
14238 334             | .se1            'SE1 is a fatal error condition
14238 334 B1 99 02 F6 |                 mov     hctwait, _100ms_
1423c 335 E4 FE BF FD |                 call    #poll_waitx
14240 336 03 BE 06 F6 |                 mov     retval, #ERR_SE1
14244 337 88 F7 BF FD |                 call    #host_error                     ' Seeing SE1 for any length of time is not good...
14248 338             | .connect_test                                           ' Test lines until stable J/K state seen
14248 338 1F 62 63 FD |                 waitx   _100ms_                         ' Total of 100ms debounce interval (Section 7.1.7.3)
1424c 339 22 A7 82 FA |                 rqpin   urx, dm
14250 33a 03 A6 1E F5 |                 and     urx, #J_IDLEF | K_RESUMEF wcz
14254 33b 80 FF 9F AD |         if_z    jmp     #discon_entry                   ' D+ and D- low
14258 33c C4 FF 9F AD |         if_e    jmp     #.se1_test                      ' D+ and D- high
1425c 33d             | connected
1425c 33d 01 96 26 F4 |                 bith    hstatus, #CONNECTEDB            ' Device plugged in
14260 33e 34 FB BF FD |                 call    #on_connect                     ' Initial device configuration
14264 33f D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz      ' Anything other than ACK means the device is unusable
14268 340 6C FF 9F 5D |         if_nz   jmp     #discon_entry
1426c 341             | .set_pulse
1426c 341 1A 66 63 FD |                 getct   _pulse_time_
14270 342 B2 67 03 F1 |                 add     _pulse_time_, _500ms_           ' Set activity LED pulse to the bus idle toggle rate
14274 343             | ' Sample the USB 1ms frame delta register to see how close it is to the ideal frame interval
14274 343             | ' of 1ms and make a correction, if necessary.
14274 343             | '                mov     htmp, _1ms_
14274 343             | '                subs    htmp, iframe_delta
14274 343             | '                adds    _frame1ms_clks_, htmp
14274 343             | '                debug(udec(_frame1ms_clks_))
14274 343             | 
14274 343             |                 ' Fall through to idle/processing loop
14274 343 07 5A 1E F2 |                 cmp     hdev_port, #MAX_DEVICES wcz
14278 344 00 5A 06 16 |         if_a    mov     hdev_port, #0 
1427c 345             | 
1427c 345             | hidle
1427c 345 22 A7 82 FA |                 rqpin   urx, dm
14280 346 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
14284 347 98 00 90 CD |         if_c    jmp     #.se0_test
14288 348 24 06 70 FD |                 pollct3                         wc
1428c 349 68 00 90 3D |         if_nc   jmp     #.nopoll
14290 34a 1A 96 63 FD |                 getct   hct3
14294 34b A8 97 73 FA |                 addct3  hct3, _1ms_                     ' Set the timer for next poll interval
14298 34c             | 
14298 34c 6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
1429c 34d 00 72 E3 F8 |                 getbyte htmp
142a0 34e             | 
142a0 34e 09 72 0F F2 |                 cmp     htmp, #HUB_READY        wz
142a4 34f 8C 1B 80 AE |         if_z    loc     pa, #@hget_hub_status - @usb_host_start
142a8 350 40 00 90 AD |         if_z    jmp     #.poll
142ac 351             | 
142ac 351             |         if _HAVE_GAMEPAD
142ac 351 06 72 0F F2 |                 cmp     htmp, #HID_READY        wz
142b0 352 08 72 0F 52 |         if_nz   cmp     htmp, #PS3_READY        wz
142b4 353 07 72 0F 52 |         if_nz   cmp     htmp, #XINPUT_READY     wz
142b8 354 F4 15 80 AE |         if_z    loc     pa, #@hget_gp_in_report - @usb_host_start
142bc 355 2C 00 90 AD |         if_z    jmp     #.poll
142c0 356             |         end
142c0 356             | 
142c0 356             |         if HAVE_MOUSE
142c0 356 04 72 0F F2 |                 cmp     htmp, #M_READY          wz
142c4 357 44 15 80 AE |         if_z    loc     pa, #@hget_mouse_in_report - @usb_host_start
142c8 358 20 00 90 AD |         if_z    jmp     #.poll
142cc 359             |         end
142cc 359             | 
142cc 359 03 72 0F F2 |                 cmp     htmp, #KB_READY         wz
142d0 35a AC 13 80 AE |         if_z    loc     pa, #@hget_kbd_in_report - @usb_host_start
142d4 35b 14 00 90 AD |         if_z    jmp     #.poll
142d8 35c             | 
142d8 35c 05 72 0F F2 |                 cmp     htmp, #KBM_READY        wz
142dc 35d 14 00 90 5D |         if_nz   jmp     #.skip_poll
142e0 35e 09 96 FE F4 |                 bitnot  hstatus, #KBM_TOGGLEB   wcz
142e4 35f AC 13 80 3E |         if_nc   loc     pa, #@hget_kbd_in_report - @usb_host_start
142e8 360             |         if HAVE_MOUSE
142e8 360 44 15 80 CE |         if_c    loc     pa, #@hget_mouse_in_report - @usb_host_start
142ec 361             |         else
142ec 361             |         end
142ec 361             | 
142ec 361             | .poll
142ec 361 47 ED 03 F1 |                 add     pa, hcog_base_addr
142f0 362 2D EC 63 FD |                 call    pa
142f4 363             | .skip_poll
142f4 363             | 
142f4 363 07 5A 06 F7 |                 incmod  hdev_port, #MAX_DEVICES
142f8 364             | 
142f8 364             | .nopoll
142f8 364 0E 40 0E F2 |                 cmp     cmd_data, #CMD_SUSPEND  wz
142fc 365 44 00 90 AD |         if_z    jmp     #hsuspend
14300 366 10 40 0E F2 |                 cmp     cmd_data, #CMD_RESET    wz
14304 367 00 40 06 A6 |         if_z    mov     cmd_data, #ERR_NONE             ' Acknowledge client reset cmd received
14308 368 68 FE 9F AD |         if_z    jmp     #host_reset                     ' See if it works...
1430c 369 1A 86 63 FD |                 getct   hr0
14310 36a B3 87 1B F2 |                 cmp     hr0, _pulse_time_       wcz     ' Connected "heartbeat"
14314 36b             |         if ACTIVITY_LED >= 0
14314 36b             |         end
14314 36b 1A 66 63 3D |         if_ae   getct   _pulse_time_
14318 36c B2 67 03 31 |         if_ae   add     _pulse_time_, _500ms_
1431c 36d 5C FF 9F FD |                 jmp     #hidle
14320 36e             | ' Check for extended SE0 state on the bus
14320 36e             | .se0_test
14320 36e A8 99 02 F6 |                 mov     hctwait, _1ms_
14324 36f FC FD BF FD |                 call    #poll_waitx                     ' Wait a bit and test for SE0 again
14328 370 22 A7 82 FA |                 rqpin   urx, dm
1432c 371 02 A6 16 F4 |                 testb   urx, #SE0_RESETB        wc
14330 372 48 FF 9F 3D |         if_nc   jmp     #hidle                          ' Bus still IDLE
14334 373 24 F6 BF FD |                 call    #wait_txn_ok
14338 374 00 00 80 FF 
1433c 375 22 01 28 FC |                 wypin   ##OUT_IDLE, dm                  ' Float USB
14340 376             |                 'wxpin  #DEV_DISCONNECT, usb_event_pin  ' Notify client of disconnect
14340 376 94 FE 9F FD |                 jmp     #discon_entry                   ' Device disconnected
14344 377             | 
14344 377             | hsuspend
14344 377 14 F6 BF FD |                 call    #wait_txn_ok                    ' Avoid a potential collision with an active frame isr
14348 378 25 00 64 FD |                 setint1 #0                              ' Stopping the 1ms frame packets signals suspend
1434c 379 1F 54 63 FD |                 waitx   _suspend_wait_                  ' The device enters suspend state when the bus is idle and
14350 37a 22 01 28 FC |                 wypin   #OUT_IDLE, dm                   ' no frame SOPs are received for three consecutive frames
14354 37b 00 40 06 F6 |                 mov     cmd_data, #ERR_NONE             ' Clear the cmd from the event queue
14358 37c 00 98 07 F6 |                 mov     mod_cnt, #0
1435c 37d             | 
1435c 37d             |                 ' Fall through to resume wait loop
1435c 37d             | 
1435c 37d             | hwait_resume
1435c 37d 14 88 07 FB |                 rdlong  hr1, #CLKFREQ_PTR               ' Use the CLKFREQ value, as the sysclock may change
14360 37e 02 88 47 F0 |                 shr     hr1, #2
14364 37f 1F 88 63 FD |                 waitx   hr1                             ' Pulse the activity LED every two seconds but break
14368 380             |         if ACTIVITY_LED >= 0
14368 380             |         end
14368 380 0F 40 0E F2 |                 cmp     cmd_data, #CMD_RESUME   wz
1436c 381 EC FF 9F 5D |         if_nz   jmp     #hwait_resume
14370 382 14 72 07 FB |                 rdlong  htmp, #CLKFREQ_PTR              ' Check to see if the system frequency has changed
14374 383 2C 73 0B F2 |                 cmp     htmp, save_sysclk       wz
14378 384 18 00 90 AD |         if_z    jmp     #.resume
1437c 385 C4 0B A0 FE |                 loc     pb, #@hinit_usb_timings - @usb_host_start
14380 386 47 EF 03 F1 |                 add     pb, hcog_base_addr
14384 387 2D EE 63 FD |                 call    pb                              ' Recalculate sysclk dependent timing values
14388 388 02 96 16 F4 |                 testb   hstatus, #LOW_SPEEDB    wc
1438c 389 22 6F 13 3C |         if_nc   wxpin   _usb_h_fs_nco_, dm              ' Write the new NCO calculation for the current bus speed
14390 38a 22 6B 13 CC |         if_c    wxpin   _usb_h_ls_nco_, dm
14394 38b             | .resume
14394 38b 22 05 28 FC |                 wypin   #OUT_K, dm
14398 38c 1F 5E 63 FD |                 waitx   _resume_hold_                   ' Hold K-state for 20ms to signal device(s) to resume
1439c 38d 22 03 28 FC |                 wypin   #OUT_SE0, dm
143a0 38e A3 73 03 F6 |                 mov     htmp, _ip_delay_ls_
143a4 38f 01 72 47 F0 |                 shr     htmp, #1                        ' Delay two LS bit times for K to J (idle) transition
143a8 390 1F 72 63 FD |                 waitx   htmp
143ac 391 22 07 28 FC |                 wypin   #OUT_J, dm
143b0 392 01 72 47 F0 |                 shr     htmp, #1
143b4 393 1F 72 63 FD |                 waitx   htmp
143b8 394 22 01 28 FC |                 wypin   #OUT_IDLE, dm
143bc 395 1A 92 62 FD |                 getct   iframe_ct_base
143c0 396 49 91 02 F6 |                 mov     iframe_ct_new, iframe_ct_base
143c4 397 B4 91 62 FA |                 addct1  iframe_ct_new, _frame1ms_clks_
143c8 398 25 02 64 FD |                 setint1 #1                              ' Enable the 1ms frame ISR
143cc 399 AB 99 02 F6 |                 mov     hctwait, _4ms_
143d0 39a 50 FD BF FD |                 call    #poll_waitx                     ' Delay until at least three 1ms frames transmitted
143d4 39b 00 40 06 06 |         _ret_   mov     cmd_data, #ERR_NONE             ' Acknowledge resume cmd complete
143d8 39c             | 
143d8 39c             | '------------------------------------------------------------------------------
143d8 39c             | ' Send preamble to enable low-speed HUB ports
143d8 39c             | '------------------------------------------------------------------------------
143d8 39c             | ' On entry:
143d8 39c             | ' On exit:
143d8 39c             | '   USB baud rate set to low-speed
143d8 39c             | '------------------------------------------------------------------------------
143d8 39c             | utx_pre
143d8 39c 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
143dc 39d 40 46 62 FD |                 dirl    dp
143e0 39e 28 02 64 FD |                 setq    #1
143e4 39f 22 01 08 FC |                 wrpin   #0, dm                          ' Disable smartpin mode
143e8 3a0 58 44 62 FD |                 drvl    dm
143ec 3a1 59 46 62 FD |                 drvh    dp
143f0 3a2             | 
143f0 3a2 1E 00 00 FF 
143f4 3a3 80 72 07 F6 |                 mov     htmp, ##OUT_SOP | (PID_PRE << 8)
143f8 3a4             | 
143f8 3a4 11 08 DC FC |                 rep     @.l1, #16 + 1
143fc 3a5 01 72 57 F0 |                 shr     htmp, #1        wc
14400 3a6 28 02 64 3D |         if_nc   setq    #1
14404 3a7 4F 44 62 3D |         if_nc   outnot  dm                              ' Bit-bang sync+preamble+idle
14408 3a8 1F 4E 63 FD |                 waitx   _preamble_wait_
1440c 3a9             | .l1
1440c 3a9             | 
1440c 3a9 40 44 62 FD |                 dirl    dm                              ' Put smart pins into reset
14410 3aa 40 46 62 FD |                 dirl    dp
14414 3ab 28 02 64 FD |                 setq    #1
14418 3ac 80 00 80 FF 
1441c 3ad 22 ED 08 FC |                 wrpin   ##USB_V2_DRVOUT, dm             ' The same USB smart pin mode for D- and D+ pins
14420 3ae 22 6B 13 FC |                 wxpin   _usb_h_ls_nco_, dm              ' Host mode and 1.5Mbs baud
14424 3af 41 44 62 FD |                 dirh    dm                              ' Crank them smart pins up
14428 3b0 41 46 62 FD |                 dirh    dp
1442c 3b1 22 01 28 FC |                 wypin   #OUT_IDLE, dm
14430 3b2             | 
14430 3b2 08 AA 06 F6 |                 mov     max_pkt_size, #8                ' Set LS control read/write DATAx packet size
14434 3b3 A5 9D 02 F6 |                 mov     tat_wait, _tat_wait_ls_         ' Bus turn-around time in low-speed bit periods
14438 3b4 A3 9B 02 06 |         _ret_   mov     ip_delay, _ip_delay_ls_         ' Inter-packet delay in low-speed bit periods
1443c 3b5             | 
1443c 3b5             | hlut_end
1443c 3b5             |                 fit     $400
1443c 3b5             |                 fit     $400
1443c 3b5             |                 orgh
1443c                 | if OVERLAP_MEMORY
1443c                 |                 byte    $A5[((@usb_host_start+HID_DESCR_LEN*MAX_DEVICES)-$) #> 0] ' Make sure we don't run into the hubexec area
1443c                 | end
1443c                 | '------------------------------------------------------------------------------
1443c                 | ' Routines called from cog space.
1443c                 | '------------------------------------------------------------------------------
1443c                 | ' usb_host_init, hget_kbd_in_report, hget_mouse_in_report, hparse_con_desc
1443c                 | '------------------------------------------------------------------------------
1443c                 | 
1443c                 | '------------------------------------------------------------------------------
1443c                 | ' USB host cog initialization.
1443c                 | '------------------------------------------------------------------------------
1443c                 | usb_host_init
1443c                 |                 ' Initialize buffer pointers
1443c                 |         if OVERLAP_MEMORY
1443c                 |         else
1443c     4C 15 B0 FE |                 loc     pb, #hid_descr
14440                 |         end
14440     F7 4B 02 F6 |                 mov     hid_descr_p, pb
14444                 |                 'add    pb, #HID_DESCR_LEN ' WE SHARE THIS
14444                 |                 {
14444                 |                 }
14444                 |         
14444                 |                 {
14444                 |                 }
14444                 |                 'loc     pb,#hkbd_report
14444                 |                 'mov     hkbd_report_p,pb
14444                 | 
14444     44 1D B0 FE |                 loc     pb, #hub_descr
14448     F7 4D 02 F6 |                 mov     hub_descr_p, pb
1444c     59 1D B0 FE |                 loc     pb, #urx_buff
14450     F7 4F 02 F6 |                 mov     urx_buff_p, pb
14454     D1 1D B0 FE |                 loc     pb, #dev_desc_buff
14458     F7 51 02 F6 |                 mov     dev_desc_buff_p, pb
1445c     DB 1D B0 FE |                 loc     pb, #con_desc_buff
14460     F7 53 02 F6 |                 mov     con_desc_buff_p, pb
14464     24 15 B0 FE |                 loc     pb, #usb_cache_start
14468     F7 55 02 F6 |                 mov     cache_start_p, pb
1446c     25 1D B0 FE |                 loc     pb, #usb_cache_end
14470     F7 57 02 F6 |                 mov     cache_end_p, pb
14474                 | 
14474                 |         if ERROR_LED >= 0
14474                 |         end
14474                 | 
14474                 |                 'dirl   usb_event_pin                   ' Configure the USB event mailbox smart pin
14474                 |                 'wrpin  ##SP_REPO1_MODE, usb_event_pin  ' Mailbox smart pin output is enabled, so this pin# will raise
14474                 |                 'dirh   usb_event_pin                   ' IN at event post and OUT drives the Serial Host activity LED.
14474                 | ' Configure and enable the Serial Host USB port.
14474     03 03 80 FD |                 jmp     #host_reset                     ' Initialize host and enter main processing loop
14478                 | 
14478                 | '------------------------------------------------------------------------------
14478                 | ' Timing calculations happen before any interrupt(s) are enabled.
14478                 | '------------------------------------------------------------------------------
14478                 | ' On entry:
14478                 | '   htmp - current CLKFREQ value.
14478                 | '------------------------------------------------------------------------------
14478                 | hinit_usb_timings
14478                 | '                getct   htmp2
14478     B9 59 02 F6 |                 mov     save_sysclk, htmp
1447c     8D 5B 80 FF 
14480     2C 01 2A FD |                 qfrac   ##_12m, save_sysclk             ' CORDIC calculation for FS & LS baud
14484     18 32 63 FD |                 getqx   _12Mbps_
14488     10 32 57 F0 |                 shr     _12Mbps_, #16           wc
1448c     00 32 27 F1 |                 addx    _12Mbps_, #0                    ' _12Mbps = round(12_000_000 / CLKFREQ * 2^16)
14490     03 6E 07 F6 |                 mov     _usb_h_fs_nco_, #%11            ' Host mode at FS NCO baud
14494     0E 6E 67 F0 |                 shl     _usb_h_fs_nco_, #14
14498     99 6F 03 F1 |                 add     _usb_h_fs_nco_, _12Mbps_
1449c     01 70 07 F6 |                 mov     _usb_d_fs_nco_, #%01            ' Device mode at FS NCO baud
144a0     0E 70 67 F0 |                 shl     _usb_d_fs_nco_, #14
144a4     99 71 03 F1 |                 add     _usb_d_fs_nco_, _12Mbps_
144a8     99 35 03 F6 |                 mov     _1_5Mbps_, _12Mbps_
144ac     03 34 47 F0 |                 shr     _1_5Mbps_, #3                   ' _1_5Mbps_ = _12Mbps / 8
144b0     02 6A 07 F6 |                 mov     _usb_h_ls_nco_, #%10            ' Host mode at LS NCO baud
144b4     0E 6A 67 F0 |                 shl     _usb_h_ls_nco_, #14
144b8     9A 6B 03 F1 |                 add     _usb_h_ls_nco_, _1_5Mbps_
144bc     9A 6D 03 F6 |                 mov     _usb_d_ls_nco_, _1_5Mbps_       ' Device mode at FS NCO baud
144c0     80 00 00 FF 
144c4     00 58 06 FD |                 qmul    save_sysclk, ##1 << 16          ' CORDIC calc for 1ns as 32,16 fixed point
144c8     18 2E 63 FD |                 getqx   _var_64_lower_
144cc     19 30 63 FD |                 getqy   _var_64_upper_
144d0     28 2E 63 FD |                 setq    _var_64_lower_
144d4     65 CD 1D FF 
144d8     00 30 27 FD |                 qfrac   _var_64_upper_, ##_1b
144dc     18 36 63 FD |                 getqx   _1ns16fp_                       ' 1ns as 32,16 fixed point
144e0     01 00 00 FF 
144e4     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1us as 32,9 fixed point
144e8     18 2E 63 FD |                 getqx   _var_64_lower_
144ec     19 30 63 FD |                 getqy   _var_64_upper_
144f0     28 2E 63 FD |                 setq    _var_64_lower_
144f4     A1 07 00 FF 
144f8     40 30 27 FD |                 qfrac   _var_64_upper_, ##_1m
144fc     18 38 63 FD |                 getqx   _1us_                           ' 1us as 32,9 fixed point
14500     9C 7D 03 F6 |                 mov     hsave0, _1us_                   ' Save it to compute other us values
14504     09 38 57 F0 |                 shr     _1us_, #9               wc
14508     00 38 27 F1 |                 addx    _1us_, #0                       ' Round to final value
1450c     0A 7C 07 FD |                 qmul    hsave0, #10                     ' Calc 10us
14510     18 3A 63 FD |                 getqx   _10us_
14514     09 3A 57 F0 |                 shr     _10us_, #9              wc
14518     00 3A 27 F1 |                 addx    _10us_, #0                      ' 10us
1451c     21 7C 07 FD |                 qmul    hsave0, #33                     ' Calc 33us: 'Seems to be a reasonable NAK delay'
14520     18 3C 63 FD |                 getqx   _33us_
14524     09 3C 57 F0 |                 shr     _33us_, #9              wc
14528     00 3C 27 F1 |                 addx    _33us_, #0                      ' 33us
1452c     FA 7C 07 FD |                 qmul    hsave0, #250                    ' Calc 250us
14530     18 3E 63 FD |                 getqx   _txn_err_
14534     09 3E 57 F0 |                 shr     _txn_err_, #9           wc
14538     00 3E 27 F1 |                 addx    _txn_err_, #0                   ' 250us
1453c     F4 7D 07 FD |                 qmul    hsave0, #500                    ' Calc 500us
14540     18 40 63 FD |                 getqx   _500us_
14544     09 40 57 F0 |                 shr     _500us_, #9             wc
14548     00 40 27 F1 |                 addx    _500us_, #0                     ' 500us
1454c     01 00 00 FF 
14550     9A 7C 07 FD |                 qmul    hsave0, ##666                   ' 666us timespan for LS transaction OK window
14554     18 42 63 FD |                 getqx   _txn_ok_ls_
14558     09 42 57 F0 |                 shr     _txn_ok_ls_, #9         wc
1455c     00 42 27 F1 |                 addx    _txn_ok_ls_, #0                 ' 666us
14560     01 00 00 FF 
14564     52 7D 07 FD |                 qmul    hsave0, ##850                   ' 850us timespan for FS transaction OK window
14568     18 44 63 FD |                 getqx   _txn_ok_fs_
1456c     09 44 57 F0 |                 shr     _txn_ok_fs_, #9         wc
14570     00 44 27 F1 |                 addx    _txn_ok_fs_, #0                 ' 850us
14574     9B 47 03 F6 |                 mov     _ip_delay_ls_, _1ns16fp_
14578     05 00 00 FF 
1457c     80 46 07 FA |                 mul     _ip_delay_ls_, ##LSBTns4        ' Low-Speed inter-packet 4 bit-time delay
14580     10 46 57 F0 |                 shr     _ip_delay_ls_, #16      wc
14584     00 46 27 F1 |                 addx    _ip_delay_ls_, #0
14588     9B 4B 03 F6 |                 mov     _tat_wait_ls_, _1ns16fp_
1458c     1C 00 00 FF 
14590     C0 4B 07 FA |                 mul     _tat_wait_ls_, ##LSBTns22       ' Low-Speed turnaround 22 bit-time wait
14594     10 4A 57 F0 |                 shr     _tat_wait_ls_, #16      wc
14598     00 4A 27 F1 |                 addx    _tat_wait_ls_, #0
1459c     9B 49 03 F6 |                 mov     _ip_delay_fs_, _1ns16fp_
145a0     00 00 00 FF 
145a4     4E 49 07 FA |                 mul     _ip_delay_fs_, ##FSBTns4        ' Full-Speed inter-packet 4 bit-time delay
145a8     10 48 57 F0 |                 shr     _ip_delay_fs_, #16      wc
145ac     00 48 27 F1 |                 addx    _ip_delay_fs_, #0
145b0     9B 4D 03 F6 |                 mov     _tat_wait_fs_, _1ns16fp_
145b4     04 00 00 FF 
145b8     23 4D 07 FA |                 mul     _tat_wait_fs_, ##FSBTns28       ' Full-Speed turnaround 28 bit-time wait
145bc     10 4C 57 F0 |                 shr     _tat_wait_fs_, #16      wc
145c0     00 4C 27 F1 |                 addx    _tat_wait_fs_, #0
145c4     8D 5B 00 FF 
145c8     00 59 16 FD |                 qdiv    save_sysclk,##_12m              ' Funny timing value for utx_pre
145cc     18 4E 63 FD |                 getqx   _preamble_wait_
145d0     08 4E 87 F1 |                 sub     _preamble_wait_,# 9 - 1
145d4     01 00 00 FF 
145d8     00 58 06 FD |                 qmul    save_sysclk, ##1 << 9           ' CORDIC calc for 1ms as 32,9 fixed point
145dc     18 2E 63 FD |                 getqx   _var_64_lower_
145e0     19 30 63 FD |                 getqy   _var_64_upper_
145e4     28 2E 63 FD |                 setq    _var_64_lower_
145e8     01 00 00 FF 
145ec     E8 31 27 FD |                 qfrac   _var_64_upper_, ##_1thou
145f0     18 50 63 FD |                 getqx   _1ms_                           ' 1ms as 32,9 fixed point
145f4     09 50 57 F0 |                 shr     _1ms_, #9               wc
145f8     00 50 27 F1 |                 addx    _1ms_, #0                       ' 1ms
145fc     FF FF 7F FF 
14600     F2 69 07 F6 |                 mov     _frame1ms_clks_, ##-14
14604     A8 69 43 F1 |                 adds    _frame1ms_clks_, _1ms_
14608     A8 53 03 F6 |                 mov     _2ms_, _1ms_
1460c     01 52 67 F0 |                 shl     _2ms_, #1                       ' 2ms
14610     A8 55 03 F6 |                 mov     _suspend_wait_, _1ms_
14614     A8 55 03 F1 |                 add     _suspend_wait_, _1ms_           ' 3ms delay to signal connected devices to enter suspended mode
14618     A8 57 03 F6 |                 mov     _4ms_, _1ms_
1461c     02 56 67 F0 |                 shl     _4ms_, #2                       ' 4ms
14620     AB 59 03 F6 |                 mov     _xfer_wait_, _4ms_
14624     A8 59 03 F1 |                 add     _xfer_wait_, _1ms_              ' 5ms
14628     AC 5D 03 F6 |                 mov     _reset_hold_, _xfer_wait_       ' 5ms
1462c     AE 5F 03 F6 |                 mov     _resume_hold_, _reset_hold_
14630     02 5E 67 F0 |                 shl     _resume_hold_, #2               ' 20ms timespan to hold the K-state that signals devices to resume
14634     AF 63 03 F6 |                 mov     _100ms_, _resume_hold_          ' 20ms
14638     01 62 67 F0 |                 shl     _100ms_, #1                     ' 40ms
1463c     A8 5B 03 F6 |                 mov     _8ms_, _1ms_
14640     03 5A 67 F0 |                 shl     _8ms_, #3                       ' 8ms
14644     01 5C 67 F0 |                 shl     _reset_hold_, #1                ' 10ms
14648     AE 63 03 F1 |                 add     _100ms_, _reset_hold_           ' 50ms
1464c     AC 5D 03 F1 |                 add     _reset_hold_, _xfer_wait_       ' 15ms
14650     AC 61 03 F6 |                 mov     _21ms_, _xfer_wait_             ' 5ms
14654     02 60 67 F0 |                 shl     _21ms_, #2                      ' 20ms
14658     A8 61 03 F1 |                 add     _21ms_, _1ms_                   ' 21ms
1465c     B1 65 03 F6 |                 mov     _500ms_, _100ms_                ' 50ms
14660     01 62 67 F0 |                 shl     _100ms_, #1                     ' 100ms
14664     03 64 67 F0 |                 shl     _500ms_, #3                     ' 400ms
14668     B1 65 03 01 |         _ret_   add     _500ms_, _100ms_                ' 500ms
1466c                 | '        _ret_   mov     _1sec_, save_sysclk
1466c                 | '        debug(udec(_1sec_), udec(_500ms_), udec(_100ms_))
1466c                 | '                ret
1466c                 | {
1466c                 | }
1466c                 | 
1466c                 | '------------------------------------------------------------------------------
1466c                 | ' Parse a configuration descriptor chain to see if the device is a recognized
1466c                 | ' one. If it is, start the task progression that will configure the device for
1466c                 | ' use.
1466c                 | '------------------------------------------------------------------------------
1466c                 | ' On entry:
1466c                 | '   hconfig_base - start address of the cached config descriptor chain.
1466c                 | ' On exit:
1466c                 | '------------------------------------------------------------------------------
1466c                 | hparse_con_desc
1466c     28 F3 03 F6 |                 mov     ptrb, dev_desc_buff_p
14670     82 73 07 FB |                 rdlong  htmp,ptrb[2] ' idVendor and idProduct
14674     61 5B 86 F9 |                 altr    hdev_port,#hdev_id
14678     4E 72 FF F9 |                 movbyts htmp,#%%1032
1467c     86 D3 E6 FA |                 rdword  hdev_bcd, ptrb[6]   ' bcdDevice
14680                 |                 debug(udec(hdev_port),uhex_reg_array(#hdev_id,#5), uhex_word(hdev_bcd))
14680                 | 
14680     02 EC 07 F6 |                 mov     pa, #CON_wTotalLen
14684     6E ED 03 F1 |                 add     pa, hconfig_base
14688     F6 DF E2 FA |                 rdword  hcon_tot_len, pa                ' Keep config chain size handy
1468c                 |                 debug(uhex_byte_array(hconfig_base, hcon_tot_len))
1468c                 | ' Search the configuration descriptor for the Class/Subclass/Protocol "triad"
1468c                 | ' that defines a keyboard and/or mouse.
1468c     6E EB C2 FA |                 rdbyte  hnext_desc, hconfig_base        ' Config desc size is offset to first desc in chain
14690                 | .next_intf
14690     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
14694     B8 01 90 3D |         if_ae   jmp     #hset_config
14698     6E F3 03 F6 |                 mov     ptrb, hconfig_base
1469c     75 F3 03 F1 |                 add     ptrb, hnext_desc
146a0     81 73 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
146a4     04 72 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
146a8     0C 00 90 AD |         if_z    jmp     #.intf
146ac     80 73 C7 FA |                 rdbyte  htmp, ptrb
146b0     B9 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
146b4     D8 FF 9F FD |                 jmp     #.next_intf
146b8                 | .intf
146b8     00 90 07 F6 |                 mov     hpar2, #0                       ' Reset IN/OUT endpoint holders
146bc     00 92 07 F6 |                 mov     hpar3, #0
146c0     82 E1 C6 FA |                 rdbyte  hdev_intf_idx, ptrb[INTF_bIntfNum]
146c4     85 E3 C6 FA |                 rdbyte  hdev_class, ptrb[INTF_bIntfClass]
146c8     86 E5 C6 FA |                 rdbyte  hdev_subclass, ptrb[INTF_bSubClass]
146cc     87 E7 C6 FA |                 rdbyte  hdev_protocol, ptrb[INTF_bProtocol]
146d0                 |                 debug(udec(hdev_intf_idx),uhex_byte(hdev_class,hdev_subclass,hdev_protocol))
146d0                 | 
146d0                 | .endp
146d0     80 73 C7 FA |                 rdbyte  htmp, ptrb
146d4     B9 EB 02 F1 |                 add     hnext_desc, htmp                ' Get offset of next desc to check
146d8     6F EB 1A F2 |                 cmp     hnext_desc, hcon_tot_len wcz
146dc     78 00 90 3D |         if_ae   jmp     #.get_device
146e0     6E F3 03 F6 |                 mov     ptrb, hconfig_base
146e4     75 F3 03 F1 |                 add     ptrb, hnext_desc
146e8     81 73 C7 FA |                 rdbyte  htmp, ptrb[DESC_bDescType]
146ec     04 72 0F F2 |                 cmp     htmp, #TYPE_INTERFACE   wz
146f0     64 00 90 AD |         if_z    jmp     #.get_device
146f4     05 72 0F F2 |                 cmp     htmp, #TYPE_ENDPOINT    wz
146f8     04 00 90 AD |         if_z    jmp     #.get_ep
146fc     D0 FF 9F FD |                 jmp     #.endp
14700                 | .get_ep
14700     82 89 C7 FA |                 rdbyte  hr1, ptrb[ENDP_bAddress]
14704     07 88 17 F4 |                 testb   hr1, #7                 wc      ' FIXME: define constant for endpoint IN/OUT bit
14708     0F 88 67 F0 |                 shl     hr1, #8 + 7
1470c     6C 73 03 F6 |                 mov     htmp, hctrl_ep_addr
14710     3F 00 00 FF 
14714     00 73 07 F5 |                 and     htmp, ##ADDR_MASK
14718     C4 73 43 F5 |                 or      htmp, hr1                       ' endpoint address
1471c     00 90 0F F2 |                 cmp     hpar2, #0               wz
14720     0C 00 90 8D |  if_z_and_c     jmp     #.in_ep
14724     00 92 0F F2 |                 cmp     hpar3, #0               wz
14728     18 00 90 2D |  if_z_and_nc    jmp     #.out_ep
1472c     A0 FF 9F FD |                 jmp     #.endp
14730                 | .in_ep
14730     B9 91 03 F6 |                 mov     hpar2, htmp                     ' IN endpoint
14734     84 8B C7 FA |                 rdbyte  hr2, ptrb[ENDP_wMaxPktSize]
14738                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
14738     86 87 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
1473c     C3 8B DB F8 |                 setbyte hr2, hr0, #3
14740     8C FF 9F FD |                 jmp     #.endp
14744                 | .out_ep
14744     B9 93 03 F6 |                 mov     hpar3, htmp                     ' OUT endpoint
14748     84 8D C7 FA |                 rdbyte  hr3, ptrb[ENDP_wMaxPktSize]
1474c                 |                 'and     hr2, ##$7ff                     ' Bits 10..0 define the max packet size
1474c     86 87 C7 FA |                 rdbyte  hr0, ptrb[ENDP_bInterval]       ' Fetch the bInterval member (min poll interval, in milliseconds)
14750     C3 8D DB F8 |                 setbyte hr3, hr0, #3
14754     78 FF 9F FD |                 jmp     #.endp
14758                 | 
14758                 | .get_device
14758     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput class/subclass/protocol
1475c     5D E4 0E A2 |         if_z    cmp     hdev_subclass, #$5D     wz
14760     01 E6 0E A2 |         if_z    cmp     hdev_protocol, #$01     wz
14764     64 00 90 AD |         if_z    jmp     #.gamepad
14768     09 E2 0E F2 |                 cmp     hdev_class, #CLASS_HUB  wz
1476c     A8 00 90 AD |         if_z    jmp     #.hub
14770     03 E2 0E F2 |                 cmp     hdev_class, #CLASS_HID              wz
14774     18 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No HID class, ignore
14778     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
1477c     4C 00 90 AD |         if_z    jmp     #.gamepad
14780     01 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_BOOT  wz
14784     08 FF 9F 5D |         if_nz   jmp     #.next_intf                     ' No BOOT subclass, ignore
14788                 | .keyboard
14788     01 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_KBD      wz
1478c                 |         if HAVE_MOUSE
1478c     1C 00 90 5D |         if_nz  jmp      #.mouse                         ' No Keyboard
14790                 |         else
14790                 |         end
14790     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0    wz
14794     F8 FE 9F 5D |         if_nz   jmp     #.next_intf
14798     70 6F E2 F8 |                 getbyte kb_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
1479c     C5 71 FA F8 |                 getbyte kb_interval, hr2, #3
147a0     C5 73 E2 F8 |                 getbyte kb_in_max_pkt, hr2, #0
147a4     C8 F3 02 F6 |                 mov     hkbd_ep_addr, hpar2             ' IN endpoint address
147a8                 |                 'debug(udec(kb_intf_num))
147a8                 |                 debug(uhex_long(hkbd_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
147a8     E4 FE 9F FD |                 jmp     #.next_intf
147ac                 | if HAVE_MOUSE
147ac                 | .mouse
147ac     02 E6 0E F2 |                 cmp    hdev_protocol, #INTF_PROTO_MOUSE    wz
147b0     DC FE 9F 5D |         if_nz   jmp     #.next_intf                     ' No Mouse
147b4     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0      wz
147b8     D4 FE 9F 5D |         if_nz   jmp     #.next_intf
147bc     70 6B E2 F8 |                 getbyte ms_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
147c0                 |                 'getbyte ms_interval, hr2, #3
147c0     C5 6D E2 F8 |                 getbyte ms_in_max_pkt, hr2, #0
147c4     C8 F5 02 F6 |                 mov     hmouse_ep_addr, hpar2           ' IN endpoint address
147c8                 |                 'debug(udec(kb_intf_num))
147c8                 |                 debug(uhex_long(hmouse_ep_addr,hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(kb_in_max_pkt,kb_interval))
147c8     C4 FE 9F FD |                 jmp     #.next_intf
147cc                 | end
147cc                 | .gamepad
147cc     79 73 03 F6 |                 mov     htmp, hkbd_ep_addr
147d0     C8 73 63 F5 |                 xor     htmp, hpar2
147d4     3F 00 00 FF 
147d8     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
147dc     B0 FE 9F AD |         if_z    jmp     #.next_intf
147e0                 |         if HAVE_MOUSE
147e0     7A 73 03 F6 |                 mov     htmp, hmouse_ep_addr
147e4     C8 73 63 F5 |                 xor     htmp, hpar2
147e8     3F 00 00 FF 
147ec     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
147f0     9C FE 9F AD |         if_z    jmp     #.next_intf
147f4                 |         end
147f4     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr        ' Skip if already set
147f8     00 00 0C F2 |                 cmp     0-0, #0                 wz      ' |
147fc     90 FE 9F 5D |         if_nz   jmp     #.next_intf
14800                 | 
14800     70 79 E2 F8 |                 getbyte gp_intf_num, hdev_intf_idx, #0  ' Save interface index and poll interval values
14804     C5 7B FA F8 |                 getbyte gp_interval, hr2, #3
14808     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
1480c     C8 01 00 F6 |                 mov     0-0, hpar2                      ' IN endpoint address
14810     C9 0B 03 F6 |                 mov     hdev_out_addr, hpar3            ' OUT endpoint address
14814                 |                 'debug(udec(gp_intf_num))
14814                 |                 debug(uhex_long(hdev_ep_addr,hdev_ep_addr+1,hdev_ep_addr+2,hdev_ep_addr+3,hdev_ep_addr+4,hdev_ep_addr+5,hdev_ep_addr+6,hdev_ep_addr+7),udec(gp_interval),uhex_long(hdev_out_addr))
14814     78 FE 9F FD |                 jmp     #.next_intf
14818                 | .hub
14818     00 E4 0E F2 |                 cmp     hdev_subclass, #SUBCLASS_INTF_NONE  wz
1481c     70 FE 9F 5D |         if_nz   jmp     #.next_intf
14820     00 E6 0E F2 |                 cmp     hdev_protocol, #INTF_PROTO_NONE     wz
14824     02 E6 0E 52 |         if_nz   cmp     hdev_protocol, #2                   wz
14828     64 FE 9F 5D |         if_nz   jmp     #.next_intf
1482c     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
14830     5C FE 9F 5D |         if_nz   jmp     #.next_intf
14834     70 63 E2 F8 |                 getbyte hub_intf_num, hdev_intf_idx, #0 ' Save interface index and poll interval values
14838     6C ED 02 F6 |                 mov     hhub_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
1483c     C8 BD 02 F6 |                 mov     ep_addr_pid, hpar2              ' IN endpoint address
14840     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
14844     5E EF 02 F6 |                 mov     hhub_ep_addr, ep_addr_pid
14848     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr
1484c                 |                 debug(uhex_long(hhub_ctrl_ep,hhub_ep_addr))
1484c     40 FE 9F FD |                 jmp     #.next_intf
14850                 | 
14850                 | '------------------------------------------------------------------------------
14850                 | ' If a newly-connected device is recognized, do whatever is needed to configure
14850                 | ' it according to its function, or functions. In the case of this boot protocol
14850                 | ' keyboard/mouse class driver:
14850                 | ' - SetConfiguration(config_num)
14850                 | ' - SetProtocol(boot)
14850                 | ' - SetIdle(indefinite)
14850                 | ' - Enter the device interrupt IN polling task stage.
14850                 | '------------------------------------------------------------------------------
14850                 | ' On entry:
14850                 | ' On exit:
14850                 | '------------------------------------------------------------------------------
14850                 | hset_config
14850                 | '                mov     hkbd_ep_addr, #0                ' DEBUG
14850                 | '                mov     hmouse_ep_addr, #0              ' DEBUG
14850     02 76 07 F6 |                 mov     htmp2, #DEV_UNKNOWN
14854     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
14858     00 00 0C F2 |                 cmp     0-0, #0                 wz
1485c     00 F2 0E A2 |         if_z    cmp     hkbd_ep_addr, #0        wz
14860                 |         if HAVE_MOUSE
14860     00 F4 0E A2 |         if_z    cmp     hmouse_ep_addr, #0      wz
14864                 |         end
14864     00 EE 0E A2 |         if_z    cmp     hhub_ep_addr, #0        wz
14868     60 03 90 AD |         if_z    jmp     #.notify_client                 ' No known device
1486c                 | .set_config
1486c     74 0E D0 FE |                 loc     ptra, #set_config
14870     05 EC 07 F6 |                 mov     pa, #CON_bConfigVal             ' Get configuration value to set (always the default config in our case)
14874     6E ED 03 F1 |                 add     pa, hconfig_base
14878     F6 8F C3 FA |                 rdbyte  hpar1, pa
1487c                 |                 debug("SetConfiguration: ",udec_(hpar1))
1487c     01 8F 57 FC |                 wrword  hpar1, ptra[wValue]             ' Write the config value to the config SETUP struct
14880     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' All configuration transactions use the control endpoint
14884     00 EE 07 F6 |                 mov     pb, #0                          ' SetConfiguration() has no data stage
14888     A0 02 A0 FD |                 call    #control_write
1488c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14890     2D 00 64 5D |         if_nz   ret
14894                 | .kbd_config
14894     00 F2 0E F2 |                 cmp     hkbd_ep_addr, #0        wz
14898     98 00 90 AD |         if_z    jmp     #.mouse_config                  ' No keyboard
1489c                 | 
1489c     79 73 03 F6 |                 mov     htmp, hkbd_ep_addr
148a0     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
148a4     3F 00 00 FF 
148a8     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
148ac     84 00 90 5D |         if_nz   jmp     #.mouse_config                  ' No keyboard
148b0                 | 
148b0     37 73 E3 F8 |                 getbyte htmp, kb_intf_num, #0
148b4     3C 0E D0 FE |                 loc     ptra, #set_protocol
148b8     01 01 5C FC |                 wrword  #BOOT_PROTOCOL, ptra[wValue]
148bc     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
148c0     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
148c4     A0 02 A0 FD |                 call    #control_write
148c8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
148cc     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
148d0     F8 02 90 5D |         if_nz   jmp     #.notify_client
148d4     00 8E 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
148d8     37 91 E3 F8 |                 getbyte hpar2, kb_intf_num, #0
148dc     44 03 B0 FD |                 call    #hset_idle
148e0                 |                 'cmp     retval, #PID_ACK        wz
148e0                 |         'if_nz   mov     hkbd_ep_addr, #0
148e0                 |         'if_nz   jmp     #.notify_client
148e0     A9 99 02 F6 |                 mov     hctwait, _2ms_
148e4     EF 02 A0 FD |                 call    #poll_waitx
148e8     00 76 06 F6 |                 mov     kb_led_states, #NUMLOCK_DEFAULT_STATE ? LED_NUMLKF : 0
148ec                 |         if NUMLOCK_DEFAULT_STATE && RPI_KEYBOARD_NUMLOCK_HACK
148ec                 |         end
148ec     3B F9 02 F6 |                 mov     hkbd_ledstates, kb_led_states
148f0     A0 17 90 FE |                 loc     pa, #hkbd_led_rep
148f4     F6 F9 42 FC |                 wrbyte  hkbd_ledstates,pa
148f8     40 03 B0 FD |                 call    #hset_kbdled_report
148fc     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14900     00 F2 06 56 |         if_nz   mov     hkbd_ep_addr, #0
14904     C4 02 90 5D |         if_nz   jmp     #.notify_client
14908     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
1490c     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
14910     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
14914     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
14918     5E F3 02 F6 |                 mov     hkbd_ep_addr, ep_addr_pid
1491c     6C F1 02 F6 |                 mov     hkbd_ctrl_ep, hctrl_ep_addr     ' CONTROL endpoint address
14920     1F F0 46 F4 |                 bitc    hkbd_ctrl_ep, #31
14924     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
14928     00 F6 06 F6 |                 mov     hkbd_poll_cnt, #0               ' Initialize key auto-repeat counters
1492c     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0  ' Reset interrupt IN datax sequence PIDs
14930     03 76 07 F6 |                 mov     htmp2, #KB_READY                ' Only the keyboard interface configured
14934                 |         if !!HAVE_MOUSE
14934                 |         end
14934                 | 
14934                 | .mouse_config
14934                 | if HAVE_MOUSE
14934     00 F4 0E F2 |                 cmp     hmouse_ep_addr, #0        wz
14938     AC 00 90 AD |         if_z    jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
1493c     7A 73 03 F6 |                 mov     htmp, hmouse_ep_addr
14940     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
14944     3F 00 00 FF 
14948     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
1494c     98 00 90 5D |         if_nz   jmp     #.gamepad_config                ' No mouse, setup gamepad, if detected
14950                 | 
14950                 |                 debug("mouse passed addr check")
14950                 | 
14950     B8 0D D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
14954     00 00 80 FF 
14958     03 01 5E FC |                 wrword  ##HID_DESCR_LEN, ptra[wLength]
1495c     02 6B 56 FC |                 wrword  ms_intf_num,ptra[wIndex]
14960     1B 01 A0 FD |                 call    #get_hid_descr_buffer
14964     55 02 A0 FD |                 call    #control_read
14968     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
1496c     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
14970     58 02 90 5D |         if_nz   jmp     #.notify_client
14974     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
14978     56 01 00 F6 |                 mov     0-0, total_data
1497c     1B 01 A0 FD |                 call    #get_hid_descr_buffer
14980                 |                 debug(uhex(pb),uhex_byte_array(pb,total_data))
14980                 | 
14980     35 73 E3 F8 |                 getbyte htmp, ms_intf_num, #0
14984     6C 0D D0 FE |                 loc     ptra, #set_protocol
14988     01 03 5C FC |                 wrword  #MOUSE_FULL_PROTOCOL ? REPORT_PROTOCOL : BOOT_PROTOCOL, ptra[wValue]
1498c     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
14990     00 EE 07 F6 |                 mov     pb, #0                          ' SetProtocol() has no data stage
14994     A0 02 A0 FD |                 call    #control_write
14998     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
1499c     00 F4 06 56 |         if_nz   mov     hmouse_ep_addr, #0
149a0     28 02 90 5D |         if_nz   jmp     #.notify_client
149a4                 |                 debug("mouse passed SetProtocol")
149a4     00 8E 07 F6 |                 mov     hpar1, #0                       ' SetIdle() duration 0 = indefinite
149a8     35 91 E3 F8 |                 getbyte hpar2, ms_intf_num, #0
149ac     74 02 B0 FD |                 call    #hset_idle
149b0                 |                 'cmp     retval, #PID_ACK        wz
149b0                 |         'if_nz   mov     hmouse_ep_addr, #0
149b0                 |         'if_nz   jmp     #.notify_client
149b0                 |                 debug("mouse passed SetIdle")
149b0     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
149b4     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
149b8     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
149bc     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
149c0     5E F5 02 F6 |                 mov     hmouse_ep_addr, ep_addr_pid
149c4     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
149c8     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1  ' Reset interrupt IN datax sequence PIDs
149cc     79 77 03 F6 |                 mov     htmp2, hkbd_ep_addr
149d0     7A 77 63 F5 |                 xor     htmp2, hmouse_ep_addr
149d4     3F 00 00 FF 
149d8     00 77 0F F5 |                 and     htmp2, ##ADDR_MASK              wz
149dc     05 76 07 A6 |         if_z    mov     htmp2, #KBM_READY               ' Both keyboard and mouse interfaces were configured
149e0     04 76 07 56 |         if_nz   mov     htmp2, #M_READY                 ' Only the mouse interface configured
149e4     E4 01 90 FD |                 jmp     #.notify_client
149e8                 | end
149e8                 | .gamepad_config
149e8                 | if _HAVE_GAMEPAD
149e8     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
149ec     00 00 0C F2 |                 cmp     0-0, #0                 wz
149f0     6C 01 90 AD |         if_z    jmp     #.hub_config                    ' No gamepad
149f4     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
149f8     00 72 03 F6 |                 mov     htmp, 0-0
149fc     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
14a00     3F 00 00 FF 
14a04     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
14a08     54 01 90 5D |         if_nz   jmp     #.hub_config                    ' No gamepad
14a0c                 | 
14a0c     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
14a10     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
14a14     69 BC C6 F8 |                 setbyte ep_addr_pid, #PID_IN, #0
14a18     BE 00 A0 FD |                 call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
14a1c     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
14a20     1F BC 46 F4 |                 bitc    ep_addr_pid, #31
14a24     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
14a28     5E 01 00 F6 |                 mov     0-0, ep_addr_pid
14a2c     85 BD 0A F6 |                 mov     ep_addr_pid, hdev_out_addr  wz
14a30     E1 BC C6 58 |         if_nz   setbyte ep_addr_pid, #PID_OUT, #0
14a34     BE 00 A0 5D |         if_nz   call    #calc_crc5                      ' One-time calculation of the ep/addr/pid crc
14a38     09 68 16 54 |         if_nz   testb   hub_port_status, #HUB_PORT_LOWSPEED wc
14a3c     1F BC 46 54 |         if_nz   bitc    ep_addr_pid, #31
14a40     5E 0B 03 56 |         if_nz   mov     hdev_out_addr, ep_addr_pid
14a44     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr      ' Restore the control ep addr for mouse configuration
14a48                 | 
14a48                 |                 if EMUPAD_MAX_PLAYER > 0
14a48                 |                 
14a48                 | .rule_loop           
14a48                 |                 end
14a48                 | 
14a48     FF E2 0E F2 |                 cmp     hdev_class, #$FF        wz      ' XInput vendor class
14a4c     5C 00 90 AD |         if_e    jmp     #.xinput
14a50     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
14a54     00 72 03 F6 |                 mov     htmp,0-0
14a58     01 A6 02 FF 
14a5c     68 72 0F F2 |                 cmp     htmp, ##$054C_0268       wz      ' PS3 vendor/product
14a60     8C 00 90 AD |         if_e    jmp     #.ps3
14a64                 | 
14a64     A4 0C D0 FE |                 loc     ptra, #get_desc                 ' Get HID descriptor
14a68     00 5A 0E F2 |                 cmp     hdev_port,#0            wz
14a6c     00 00 80 5F 
14a70     03 01 5E 5C |         if_nz   wrword  ##HID_DESCR_LEN, ptra[wLength]
14a74     03 00 80 AF 
14a78     03 01 5E AC |         if_z    wrword  ##HID_DESCR_LEN*MAX_DEVICES, ptra[wLength] ' Hack: allow longer descriptor if on root port.
14a7c     02 01 5C FC |                 wrword  #0,ptra[wIndex] ' this breaks if not zero?
14a80     1B 01 A0 FD |                 call    #get_hid_descr_buffer
14a84     55 02 A0 FD |                 call    #control_read
14a88     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14a8c     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
14a90     00 00 04 56 |         if_nz   mov     0-0, #0
14a94     34 01 90 5D |         if_nz   jmp     #.notify_client
14a98     3F 5B 8E F9 |                 altd    hdev_port, #gp_descr_len
14a9c     56 01 00 F6 |                 mov     0-0, total_data
14aa0     1B 01 A0 FD |                 call    #get_hid_descr_buffer
14aa4                 |                 debug(uhex(pb),udec(total_data),uhex_byte_array(pb,total_data))
14aa4                 | 
14aa4     06 76 07 F6 |                 mov     htmp2, #HID_READY               ' Standard gamepad
14aa8     20 01 90 FD |                 jmp     #.notify_client
14aac                 | .xinput
14aac     B8 0C D0 FE |                 loc     ptra, #xinp_led_cmd             ' Turn on LED
14ab0     2D EF 03 F6 |                 mov     pb,hdev_port
14ab4     01 EE E7 F2 |                 cmpsub  pb,#1 ' root device is also player 1
14ab8     03 EE 27 F3 |                 fle     pb,#3
14abc     06 EE 07 F1 |                 add     pb,#$06 ' LED patterns 06..09 for players 1..4
14ac0     02 EF 47 FC |                 wrbyte  pb, ptra[2]
14ac4                 | 
14ac4     03 B0 06 F6 |                 mov     pkt_data, #3
14ac8     03 96 06 F4 |                 bitl    hstatus, #DATAx_TGLB
14acc     85 BD 02 F6 |                 mov     ep_addr_pid, hdev_out_addr
14ad0                 |                 debug("XInput LED set ",uhex_long(ep_addr_pid),uhex_byte(pb))
14ad0     5A 00 A0 FD |                 call    #txn_out
14ad4     6C BD 02 F6 |                 mov     ep_addr_pid, hctrl_ep_addr
14ad8                 | 
14ad8     97 0C D0 FE |                 loc     ptra, #xinp_fix_8bitdo
14adc     27 EF 03 F6 |                 mov     pb, urx_buff_p          ' We don't actually care where it goes
14ae0     55 02 A0 FD |                 call    #control_read           ' Execute GetDeviceDescriptor()
14ae4                 |                 debug("8bitdo weird fix... ",uhex(retval))
14ae4     D2 BE 06 F6 |                 mov retval,#PID_ACK             ' If we don't do this something else becomes sad (TODO fix?)
14ae8                 | 
14ae8                 | 
14ae8     07 76 07 F6 |                 mov     htmp2, #XINPUT_READY
14aec     DC 00 90 FD |                 jmp     #.notify_client
14af0                 | .ps3
14af0     44 0C D0 FE |                 loc     ptra, #ps3_command_buff         ' Turn on LED
14af4     2D EF 03 F6 |                 mov     pb,hdev_port
14af8     01 EE 07 F3 |                 fge     pb,#1 ' root device is also player 1
14afc     04 EE 27 F3 |                 fle     pb,#4
14b00     F7 EF C3 F9 |                 decod   pb
14b04     09 EF 47 FC |                 wrbyte  pb, ptra[9]
14b08                 | 
14b08     3C 73 E3 F8 |                 getbyte htmp, gp_intf_num, #0
14b0c     F4 0B D0 FE |                 loc     ptra, #set_report
14b10     01 00 80 FF 
14b14     01 03 5C FC |                 wrword  ##(TYPE_OUTPUT << 8) | $01, ptra[wValue]
14b18     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
14b1c     03 61 5C FC |                 wrword  #48, ptra[wLength]
14b20     14 0C B0 FE |                 loc     pb, #ps3_command_buff
14b24     A0 02 A0 FD |                 call    #control_write
14b28                 | 
14b28     3C 73 E3 F8 |                 getbyte htmp, gp_intf_num, #0
14b2c     D4 0B D0 FE |                 loc     ptra, #set_report
14b30     01 00 80 FF 
14b34     01 E9 5F FC |                 wrword  ##(TYPE_FEATURE << 8) | $F4, ptra[wValue]
14b38     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
14b3c     03 09 5C FC |                 wrword  #4, ptra[wLength]
14b40     F0 0B B0 FE |                 loc     pb, #ps3_enable_cmd             ' Enable PS3
14b44     A0 02 A0 FD |                 call    #control_write
14b48     D2 BE 0E F2 |                 cmp     retval, #PID_ACK    wz
14b4c     7D 5B 8E 59 |         if_nz   altd    hdev_port, #hdev_ep_addr
14b50     00 00 04 56 |         if_nz   mov     0-0, #0
14b54     74 00 90 5D |         if_nz   jmp     #.notify_client
14b58                 | 
14b58     08 76 07 F6 |                 mov     htmp2, #PS3_READY               ' PS3 gamepad ready
14b5c     6C 00 90 FD |                 jmp     #.notify_client
14b60                 | end
14b60                 | 
14b60                 | .hub_config
14b60     00 EE 0E F2 |                 cmp     hhub_ep_addr, #0    wz
14b64     64 00 90 AD |         if_z    jmp     #.notify_client                 ' No HUB
14b68     77 73 03 F6 |                 mov     htmp, hhub_ep_addr
14b6c     5E 73 63 F5 |                 xor     htmp, ep_addr_pid
14b70     3F 00 00 FF 
14b74     00 73 0F F5 |                 and     htmp, ##ADDR_MASK       wz
14b78     50 00 90 5D |         if_nz   jmp     #.notify_client                 ' No HUB
14b7c                 | 
14b7c     94 0B D0 FE |                 loc     ptra, #get_hub_desc             ' Get HUB descriptor
14b80     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]
14b84     26 EF 03 F6 |                 mov     pb, hub_descr_p
14b88     55 02 A0 FD |                 call    #control_read
14b8c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14b90     00 EE 06 56 |         if_nz   mov     hhub_ep_addr, #0
14b94     34 00 90 5D |         if_nz   jmp     #.notify_client
14b98                 |                 debug(uhex_byte_array(hub_descr_p,total_data))
14b98                 | 
14b98     26 F1 03 F6 |                 mov     ptra, hub_descr_p
14b9c     02 79 C7 FA |                 rdbyte  htmp3, ptra[2]                  ' bNbrPorts
14ba0     07 78 27 F3 |                 fle     htmp3, #MAX_DEVICES             ' Max. 7 ports supported
14ba4                 |                 debug(uhex_byte_array(hub_descr_p,total_data),", bNbrPorts = ", udec_(htmp3))
14ba4                 | .pwr_loop
14ba4     74 0B D0 FE |                 loc     ptra, #set_port_feat            ' Power on ports
14ba8     01 11 5C FC |                 wrword  #HUB_PORT_POWER, ptra[wValue]
14bac     02 79 57 FC |                 wrword  htmp3, ptra[wIndex]
14bb0     A0 02 A0 FD |                 call    #control_write
14bb4     FB 79 6F FB |                 djnz    htmp3, #.pwr_loop
14bb8                 | 
14bb8     B2 99 02 F6 |                 mov     hctwait, _500ms_
14bbc     B1 99 02 F1 |                 add     hctwait, _100ms_
14bc0     EF 02 A0 FD |                 call    #poll_waitx
14bc4                 | 
14bc4     09 76 07 F6 |                 mov     htmp2, #HUB_READY               ' Hub ready
14bc8     00 00 90 FD |                 jmp     #.notify_client
14bcc                 | 
14bcc                 | .notify_client
14bcc     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
14bd0     BB 01 C0 F8 |                 setbyte htmp2                           ' Save device ready
14bd4                 |                 debug(uhex_long(hdev_type,hdev_type+1))
14bd4                 |         '_ret_  wxpin   htmp2, usb_event_pin            ' Notify the client keyboard and/or mouse configured
14bd4     2D 00 64 FD |                 ret
14bd8                 | 
14bd8                 | '------------------------------------------------------------------------------
14bd8                 | ' Initialize the keyboard/mouse data area to start-up values.
14bd8                 | '------------------------------------------------------------------------------
14bd8                 | ' On entry:
14bd8                 | ' On exit:
14bd8                 | '------------------------------------------------------------------------------
14bd8                 | init_kbdm_data
14bd8     00 F2 06 F6 |                 mov     hkbd_ep_addr, #0
14bdc     00 FA 06 F6 |                 mov     hdev_ep_addr, #0
14be0                 | 
14be0     2A F1 03 F6 |                 mov     ptra, cache_start_p         ' Clear cached data buffers
14be4     2B ED 03 F6 |                 mov     pa, cache_end_p
14be8                 | .loop
14be8     61 01 4C FC |                 wrbyte  #0, ptra++
14bec     F6 F1 1B F2 |                 cmp     ptra, pa                wcz
14bf0     F4 FF 9F CD |         if_b    jmp     #.loop
14bf4                 |         
14bf4                 |         if EMUPAD_MAX_PLAYER > 0
14bf4                 |         end
14bf4                 | 
14bf4                 | 
14bf4     2D ED 07 F6 |                 mov     pa, #hdev_init_start        ' Clear device data registers
14bf8                 | .regloop
14bf8     00 EC 8F F9 |                 altd    pa
14bfc     00 00 04 F6 |                 mov     0-0, #0
14c00     01 EC 07 F1 |                 add     pa, #1
14c04     47 ED 0F F2 |                 cmp     pa, #hdev_init_end      wz
14c08     EC FF 9F 5D |         if_nz   jmp     #.regloop
14c0c                 | 
14c0c     E1 E1 61 FF 
14c10     C3 5D 06 F6 |                 mov     hdev_next_datax,##PID_DATA0 * $01010101 ' Reset interrupt IN datax sequence PIDs
14c14     2E 5F 02 F6 |                 mov     hdev_next_datax + 1,hdev_next_datax
14c18     C3 60 C6 F8 |                 setbyte kbm_next_datax, #PID_DATA0, #0
14c1c     C3 60 CE F8 |                 setbyte kbm_next_datax, #PID_DATA0, #1
14c20                 | 
14c20     C3 64 06 06 |         _ret_   mov     hub_next_datax, #PID_DATA0
14c24                 | 
14c24                 | '------------------------------------------------------------------------------
14c24                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_IDLE
14c24                 | ' function.
14c24                 | '------------------------------------------------------------------------------
14c24                 | ' On entry:
14c24                 | '   hpar1 - Byte1 duration, byte0 reportID (HID 1.11, section 7.2.4).
14c24                 | '   hpar2 - index number of the target interface.
14c24                 | ' On exit:
14c24                 | '------------------------------------------------------------------------------
14c24                 | hset_idle
14c24     A9 99 02 F6 |                 mov     hctwait, _2ms_
14c28     EF 02 A0 FD |                 call    #poll_waitx
14c2c     CC 0A D0 FE |                 loc     ptra, #set_idle
14c30     01 8F 57 FC |                 wrword  hpar1, ptra[wValue]
14c34     02 91 57 FC |                 wrword  hpar2, ptra[wIndex]
14c38     A0 02 80 FD |                 jmp     #control_write
14c3c                 | 
14c3c                 | '------------------------------------------------------------------------------
14c3c                 | ' Execute a ControlWrite() that will perform the HID-specific HID_SET_REPORT
14c3c                 | ' function to set keyboard CapsLk, ScrLk and NumLk indicators.
14c3c                 | '------------------------------------------------------------------------------
14c3c                 | ' On entry:
14c3c                 | '   ep_addr_pid - device address and enpoint for the request.
14c3c                 | ' On exit:
14c3c                 | '   retval - transaction result.
14c3c                 | '------------------------------------------------------------------------------
14c3c                 | hset_kbdled_report
14c3c     37 73 E3 F8 |                 getbyte htmp, kb_intf_num, #0
14c40     C0 0A D0 FE |                 loc     ptra, #set_report
14c44     01 00 80 FF 
14c48     01 01 5C FC |                 wrword  ##(TYPE_OUTPUT << 8), ptra[wValue] ' Byte1 report type, byte0 reportID (0)
14c4c     02 73 57 FC |                 wrword  htmp, ptra[wIndex]
14c50     03 03 5C FC |                 wrword  #KBD_OUT_RPT_LEN, ptra[wLength]
14c54     27 EF 03 F6 |                 mov     pb, urx_buff_p
14c58     F7 77 42 FC |                 wrbyte  kb_led_states, pb
14c5c     A0 02 80 FD |                 jmp     #control_write                  ' Execute ControlWrite(SET_REPORT) and back to caller
14c60                 | 
14c60                 | '------------------------------------------------------------------------------
14c60                 | ' Execute an IN interrupt transaction to poll for keyboard activity.
14c60                 | '------------------------------------------------------------------------------
14c60                 | ' On entry:
14c60                 | ' On exit:
14c60                 | '------------------------------------------------------------------------------
14c60                 | hget_kbd_in_report
14c60     79 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ep_addr
14c64     27 91 03 F6 |                 mov     hpar2, urx_buff_p
14c68     30 93 E3 F8 |                 getbyte hpar3, kbm_next_datax, #0
14c6c     39 93 2B F9 |                 setword hpar3, kb_in_max_pkt, #1        ' Always ask for max report size
14c70     CF 02 A0 FD |                 call    #do_int_in
14c74     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14c78     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
14c7c                 | 
14c7c     00 92 0F F2 |                 cmp     hpar3, #0               wz
14c80     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
14c84                 | 
14c84     30 73 E3 F8 |                 getbyte htmp, kbm_next_datax, #0        ' Txn success, so toggle DATAx
14c88     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
14c8c     4B 60 C6 A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #0  ' |
14c90     C3 60 C6 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #0  ' |
14c94                 | 
14c94     C9 75 02 F6 |                 mov     kb_max_index, hpar3             ' Save actual bytes read
14c98     18 00 B0 FD |                 call    #hkbd_compare
14c9c                 |         if EMUPAD_MAX_PLAYER > 0
14c9c                 |         end
14c9c                 | 
14c9c                 | .led_check
14c9c     3B 73 03 F6 |                 mov     htmp, kb_led_states
14ca0     B9 F9 0A F2 |                 cmp     hkbd_ledstates, htmp    wz
14ca4     2D 00 64 AD |         if_z    ret                                     ' No toggle key indicator changes, so we're done
14ca8     7C 77 02 F6 |                 mov     kb_led_states, hkbd_ledstates   ' Update toggle key indicator states
14cac     78 BD 02 F6 |                 mov     ep_addr_pid, hkbd_ctrl_ep
14cb0     88 FF 9F FD |                 jmp     #hset_kbdled_report             ' Set report and ignore errors
14cb4                 | 
14cb4                 | '------------------------------------------------------------------------------
14cb4                 | ' Compare current and previous keyboard data buffers for keypress changes.
14cb4                 | '------------------------------------------------------------------------------
14cb4                 | hkbd_compare
14cb4     27 F1 03 F6 |                 mov     ptra, urx_buff_p
14cb8     D0 13 F0 FE |                 loc     ptrb, #hkbd_report
14cbc     61 75 07 FB |                 rdlong  htmp1, ptra++
14cc0     E1 77 07 FB |                 rdlong  htmp2, ptrb++
14cc4     BB 75 0B F2 |                 cmp     htmp1, htmp2    wz
14cc8     61 75 07 FB |                 rdlong  htmp1, ptra++
14ccc     E1 77 07 FB |                 rdlong  htmp2, ptrb++
14cd0     BB 75 0B A2 |         if_z    cmp     htmp1, htmp2    wz
14cd4     2D 00 64 AD |         if_z    ret
14cd8                 | 
14cd8     B0 13 D0 FE |                 loc     ptra, #hkbd_report
14cdc                 | 
14cdc                 |                 ' Handle modifiers
14cdc     27 91 C3 FA |                 rdbyte  hpar2, urx_buff_p
14ce0     00 89 C7 FA |                 rdbyte  hr1, ptra
14ce4     C8 89 43 F9 |                 rolword hr1,hpar2,#0
14ce8     63 88 63 FD |                 mergew  hr1
14cec     08 EC 07 F6 |                 mov     pa,#8
14cf0                 | .modloop
14cf0     6A 88 7B FD |                 rczr    hr1     wcz ' New value in C, old value in Z
14cf4     E8 8E 07 F6 |                 mov     hpar1,#$E8
14cf8     F6 8F 83 F1 |                 sub     hpar1,pa
14cfc     A0 00 B0 6D |       if_c_ne_z call    #hkbd_translate
14d00     FB ED 6F FB |                 djnz    pa,#.modloop
14d04                 | 
14d04     6F E0 75 FD | .release        modc    _set    wc
14d08                 |                 'alts    hdev_port, #hid_report_p
14d08                 |                 'mov     ptra, hid_report_p
14d08     02 F0 07 F1 |                 add     ptra, #2
14d0c     06 EC 07 F6 |                 mov     pa, #6
14d10     61 8F CF FA | .rl1            rdbyte  hpar1, ptra++   wz
14d14     20 00 90 AD |         if_z    jmp     #.rl3
14d18     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
14d1c     02 F2 07 F1 |                 add     ptrb, #2
14d20     06 EE 07 F6 |                 mov     pb, #6
14d24     E1 73 C7 FA | .rl2            rdbyte  htmp, ptrb++
14d28     B9 8F 0B F2 |                 cmp     hpar1, htmp     wz
14d2c     08 00 90 AD |         if_z    jmp     #.rl3
14d30     FC EF 6F FB |                 djnz    pb, #.rl2
14d34     68 00 B0 FD |                 call    #hkbd_translate
14d38     F5 ED 6F FB | .rl3            djnz    pa, #.rl1
14d3c                 | 
14d3c     00 92 07 F6 |                 mov     hpar3, #0
14d40     1F 92 27 F4 |                 bith    hpar3, #31
14d44                 | 
14d44     6F 00 74 FD | .press          modc    _clr    wc
14d48     27 F1 03 F6 |                 mov     ptra, urx_buff_p
14d4c     02 F0 07 F1 |                 add     ptra, #2
14d50     06 EC 07 F6 |                 mov     pa, #6
14d54     61 8F CF FA | .pl1            rdbyte  hpar1, ptra++   wz
14d58     20 00 90 AD |         if_z    jmp     #.pl3
14d5c     2C 13 F0 FE |                 loc     ptrb, #hkbd_report
14d60     02 F2 07 F1 |                 add     ptrb, #2
14d64     06 EE 07 F6 |                 mov     pb, #6
14d68     E1 73 C7 FA | .pl2            rdbyte  htmp, ptrb++
14d6c     B9 8F 0B F2 |                 cmp     hpar1, htmp     wz
14d70     08 00 90 AD |         if_z    jmp     #.pl3
14d74     FC EF 6F FB |                 djnz    pb, #.pl2
14d78     24 00 B0 FD |                 call    #hkbd_translate
14d7c     F5 ED 6F FB | .pl3            djnz    pa, #.pl1
14d80                 | 
14d80     27 F1 03 F6 | .copy           mov     ptra, urx_buff_p
14d84     04 13 F0 FE |                 loc     ptrb, #hkbd_report
14d88     28 02 64 FD |                 setq #1
14d8c     61 75 07 FB |                 rdlong  htmp1, ptra++
14d90     28 02 64 FD |                 setq #1
14d94     E1 75 67 FC |                 wrlong  htmp1, ptrb++
14d98     E1 F9 46 FC |                 wrbyte  hkbd_ledstates,ptrb++
14d9c                 | 
14d9c     2D 00 64 FD |                 ret
14da0                 | 
14da0                 | '------------------------------------------------------------------------------
14da0                 | ' Translate keyboard scancode to ASCII
14da0                 | '------------------------------------------------------------------------------
14da0                 | ' On entry:
14da0                 | '   hpar1 - scancode
14da0                 | '   hpar2 - key modifiers state
14da0                 | '       c - pressed (0) or released (1) flag
14da0                 | ' On exit:
14da0                 | '   hpar1 - bit     31 = 0 pressed, 1 released
14da0                 | '               30..17 = unused
14da0                 | '                   18 = scroll-lock state 
14da0                 | '                   17 = caps-lock state
14da0                 | '                   16 = num-lock state 
14da0                 | '                15..8 = key modifiers state
14da0                 | '                 7..0 = scancode
14da0                 | '------------------------------------------------------------------------------
14da0                 | hkbd_translate
14da0     39 8E 0F F2 |                 cmp     hpar1, #KEY_CAPSLOCK    wz
14da4     01 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_CAPSLKB
14da8     53 8E 0F F2 |                 cmp     hpar1, #KEY_NUMLOCK     wz
14dac     00 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_NUMLKB
14db0     47 8E 0F F2 |                 cmp     hpar1, #KEY_SCROLLLOCK  wz
14db4     02 F8 E6 24 |   if_z_and_nc   bitnot  hkbd_ledstates, #LED_SCRLKB
14db8                 | 
14db8                 |         if EMUPAD_MAX_PLAYER > 0
14db8                 | 
14db8                 |         if EMUPAD_BT0_BIT >= 0
14db8                 |         end
14db8                 |         if EMUPAD_BT1_BIT >= 0
14db8                 |         end
14db8                 |         if EMUPAD_BT2_BIT >= 0
14db8                 |         end
14db8                 |         if EMUPAD_BT3_BIT >= 0
14db8                 |         end
14db8                 |         if EMUPAD_BT4_BIT >= 0
14db8                 |         end
14db8                 |         if EMUPAD_BT5_BIT >= 0
14db8                 |         end
14db8                 |         if EMUPAD_BT6_BIT >= 0
14db8                 |         end
14db8                 |         if EMUPAD_BT7_BIT >= 0
14db8                 |         end
14db8                 |         if EMUPAD_BT8_BIT >= 0
14db8                 |         end
14db8                 |         if EMUPAD_BT9_BIT >= 0
14db8                 |         end
14db8                 | 
14db8                 |         end
14db8     C8 8F CB F8 |                 setbyte hpar1, hpar2, #1
14dbc     7C 8F D3 F8 |                 setbyte hpar1, hkbd_ledstates,#2
14dc0     1F 8E 47 F4 |                 bitc    hpar1, #31
14dc4                 |         if KEYQUEUE_SIZE > 0
14dc4     C0 09 B0 FE |                 loc pb,#keyq_head
14dc8     F7 73 E3 FA |                 rdword htmp,pb
14dcc     B9 75 EB F8 |                 getbyte htmp1,htmp,#1 ' tail
14dd0     B9 73 E3 F8 |                 getbyte htmp,htmp,#0 ' head
14dd4     B9 77 03 F6 |                 mov htmp2,htmp
14dd8     04 76 07 FA |                 mul htmp2,#4
14ddc     F7 77 03 F1 |                 add htmp2,pb
14de0     02 76 07 F1 |                 add htmp2,#2
14de4     7F 72 07 F7 |                 incmod htmp,#KEYQUEUE_SIZE - 1
14de8     B9 75 0B F2 |                 cmp htmp1,htmp wz ' check buffer overflow
14dec     BB 8F 63 5C |         if_nz   wrlong hpar1,htmp2
14df0     F7 73 43 5C |         if_nz   wrbyte htmp,pb
14df4                 |         end
14df4     2D 00 7C FD |                 ret wcz
14df8                 | 
14df8                 | if HAVE_MOUSE
14df8                 | '------------------------------------------------------------------------------
14df8                 | ' Execute an IN interrupt transaction to poll for mouse activity.
14df8                 | '------------------------------------------------------------------------------
14df8                 | ' On entry:
14df8                 | ' On exit:
14df8                 | '------------------------------------------------------------------------------
14df8                 | hget_mouse_in_report
14df8     7A BD 02 F6 |                 mov     ep_addr_pid, hmouse_ep_addr
14dfc     27 91 03 F6 |                 mov     hpar2, urx_buff_p
14e00     30 93 EB F8 |                 getbyte hpar3, kbm_next_datax, #1
14e04     36 93 2B F9 |                 setword hpar3, ms_in_max_pkt, #1        ' Always ask for max report size
14e08     CF 02 A0 FD |                 call    #do_int_in
14e0c     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14e10     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
14e14                 | 
14e14     00 92 0F F2 |                 cmp     hpar3, #0               wz
14e18     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
14e1c                 | 
14e1c     30 73 EB F8 |                 getbyte htmp, kbm_next_datax, #1        ' Txn success, so toggle DATAx
14e20     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
14e24     4B 60 CE A8 |         if_z    setbyte kbm_next_datax, #PID_DATA1, #1  ' |
14e28     C3 60 CE 58 |         if_nz   setbyte kbm_next_datax, #PID_DATA0, #1  ' |
14e2c                 | 
14e2c                 |         'debug(uhex_byte_array(urx_buff_p,hpar3))
14e2c                 | 
14e2c                 |         if MOUSE_FULL_PROTOCOL
14e2c     C8 00 B0 FD |                 call #hid_decode
14e30                 |         else
14e30                 |         end
14e30                 | 
14e30     48 09 90 FE |                 loc     pa, #mouse_limits
14e34     5D 13 F0 FE |                 loc     ptrb, #mouse_xacc
14e38                 | 
14e38                 |                 ' load xacc,yacc,zacc
14e38     28 04 64 FD |                 setq    #3-1
14e3c     80 89 07 FB |                 rdlong  hr1,ptrb
14e40                 |                 ' load limits and outptr
14e40     28 04 64 FD |                 setq    #3-1
14e44     F6 75 03 FB |                 rdlong  htmp1,pa
14e48                 | 
14e48                 |         if MOUSE_FULL_PROTOCOL
14e48     8C 19 47 FC |                 wrbyte  hidr_buttons, ptrb[12]
14e4c                 |         else
14e4c                 |                 { ' Currently not used
14e4c                 |                 '}
14e4c                 |         end
14e4c                 | 
14e4c                 |         if MOUSE_FULL_PROTOCOL
14e4c     88 73 33 F9 |                 getword htmp, hidr_axis+0, #0
14e50     0F 72 67 F7 |                 signx   htmp, #15
14e54                 |         else
14e54                 |         end
14e54     B9 89 03 F1 |                 add     hr1,htmp
14e58     00 74 0F F2 |                 cmp     htmp1,#0 wz
14e5c     BA 89 63 53 |         if_ne   fles    hr1,htmp1
14e60     00 88 47 53 |         if_ne   fges    hr1,#0
14e64                 | 
14e64                 |         if MOUSE_FULL_PROTOCOL
14e64     88 73 3B F9 |                 getword htmp, hidr_axis+0, #1
14e68     0F 72 67 F7 |                 signx   htmp, #15
14e6c                 |         else
14e6c                 |         end
14e6c     B9 8B 03 F1 |                 add     hr2,htmp
14e70     00 76 0F F2 |                 cmp     htmp2,#0 wz
14e74     BB 8B 63 53 |         if_ne   fles    hr2,htmp2
14e78     00 8A 47 53 |         if_ne   fges    hr2,#0
14e7c                 |                 
14e7c                 |         if MOUSE_FULL_PROTOCOL
14e7c     8B 73 3B F9 |                 getword htmp, hidr_axis+3, #1           ' Mouse wheel is actually on the "wheel axis"
14e80     0F 72 67 F7 |                 signx   htmp, #15
14e84     B9 8D 03 F1 |                 add     hr3, htmp
14e88                 |         else    
14e88                 |         end
14e88                 | 
14e88     90 73 CF FA |                 rdbyte  htmp,ptrb[16]           wz      ' Is lock flag set?
14e8c     2D 00 64 5D |         if_nz   ret                                     ' If so, don't write results
14e90                 | 
14e90                 |                 ' write back accumulators
14e90     28 04 64 FD |                 setq    #3-1
14e94     80 89 67 FC |                 wrlong  hr1,ptrb
14e98                 |                 ' if outptr set, write X/Y words
14e98     00 78 0F F2 |                 cmp htmp3,#0                    wz
14e9c     C5 89 2B 59 |         if_nz   setword hr1,hr2,#1
14ea0     BC 89 63 5C |         if_nz   wrlong hr1,htmp3
14ea4     2D 00 64 FD |                 ret
14ea8                 | end
14ea8                 | 
14ea8                 | '------------------------------------------------------------------------------
14ea8                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
14ea8                 | '------------------------------------------------------------------------------
14ea8                 | ' On entry:
14ea8                 | ' On exit:
14ea8                 | '------------------------------------------------------------------------------
14ea8                 | if _HAVE_GAMEPAD
14ea8                 | hget_gp_in_report
14ea8     7D 5B 96 F9 |                 alts    hdev_port, #hdev_ep_addr
14eac     00 BC 02 F6 |                 mov     ep_addr_pid, 0-0
14eb0                 | 
14eb0     27 91 03 F6 |                 mov     hpar2, urx_buff_p
14eb4     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax
14eb8     00 92 E3 F8 |                 getbyte hpar3
14ebc     FF 92 2F F9 |                 setword hpar3, #255, #1                 ' Always ask for max report size
14ec0     CF 02 A0 FD |                 call    #do_int_in
14ec4     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
14ec8     2D 00 64 5D |         if_nz   ret                                     ' No ACK, ignore
14ecc                 | 
14ecc     00 92 0F F2 |                 cmp     hpar3, #0               wz
14ed0     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
14ed4                 |                 'debug(udec(hdev_port)," RAW REPORT: ",uhex_byte_array(urx_buff_p,hpar3))
14ed4                 | 
14ed4     2E 5B 6E F9 |                 altgb   hdev_port, #hdev_next_datax     ' Txn success, so toggle DATAx
14ed8     00 72 E3 F8 |                 getbyte htmp                            ' |
14edc     C3 72 0F F2 |                 cmp     htmp, #PID_DATA0        wz      ' |
14ee0     4B 72 07 A6 |         if_z    mov     htmp, #PID_DATA1                ' |
14ee4     C3 72 07 56 |         if_nz   mov     htmp, #PID_DATA0                ' |
14ee8     2E 5B 66 F9 |                 altsb   hdev_port, #hdev_next_datax     ' |
14eec     B9 01 C0 F8 |                 setbyte htmp                            ' |
14ef0                 | 
14ef0                 | ' Note: the following code compares the current and previous reports
14ef0                 | ' and process the data if there are changes to ease the debug output.
14ef0                 | ' Actual implementations should remove this block, along with hid_pre_rpt_p and
14ef0                 | ' gpPreReport buffer.
14ef0                 | 
14ef0                 |                 ' ----- start of block to remove
14ef0                 |                 {
14ef0                 |                 }
14ef0                 |                 ' ----- end of block to remove
14ef0     14 05 90 FE |                 loc pa,#hpad_translate
14ef4     2A EC 63 FD |                 push pa
14ef8                 | 
14ef8                 |                 ' FALL THROUGH !!!!
14ef8                 | end
14ef8                 | if _HAVE_GAMEPAD || MOUSE_FULL_PROTOCOL
14ef8                 | '------------------------------------------------------------------------------
14ef8                 | ' Decode controller report
14ef8                 | '------------------------------------------------------------------------------
14ef8                 | hid_decode
14ef8                 |                 ' clear all hid report registers (WILL NOT WORK IF MORE THAN 512K RAM)
14ef8     28 20 64 FD |                 setq #(hidr_end-hidr_start)-1
14efc     00 04 00 FF 
14f00     00 0C 07 FB |                 rdlong  hidr_start,##$8_0000
14f04                 | 
14f04     27 F3 03 F6 |                 mov     ptrb, urx_buff_p
14f08                 | 
14f08     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
14f0c     00 1C E3 F8 |                 getbyte hidr_type
14f10                 |         if _HAVE_GAMEPAD
14f10     07 1C 0F F2 |                 cmp     hidr_type, #XINPUT_READY        wz
14f14     08 03 90 AD |         if_z    jmp     #hpad_xinput
14f18     08 1C 0F F2 |                 cmp     hidr_type, #PS3_READY           wz
14f1c     EC 03 90 AD |         if_z    jmp     #hpad_ps3
14f20                 |         end
14f20     05 1C 0F F2 |                 cmp     hidr_type, #KBM_READY           wz
14f24     04 1C 07 A6 |         if_z    mov     hidr_type,#M_READY
14f28     04 1C 0F F2 |                 cmp     hidr_type, #M_READY             wz
14f2c                 |                 
14f2c                 | 
14f2c                 | '------------------------------------------------------------------------------
14f2c                 | ' Handle HID controller (or mouse now
14f2c                 | ' On entry:
14f2c                 | '   ptrb - controller report
14f2c                 | '------------------------------------------------------------------------------
14f2c                 | hpad_hid
14f2c     1B 01 A0 FD |                 call    #get_hid_descr_buffer
14f30     F7 F1 03 F6 |                 mov     ptra, pb
14f34     3F 5B 96 F9 |                 alts    hdev_port, #gp_descr_len
14f38     00 EC 03 F6 |                 mov     pa, 0-0
14f3c                 |                 'debug(udec(hdev_port), " HID ", uhex_long(ep_addr_pid),uhex_long(ptra),udec(pa))
14f3c     19 2A 3B FF 
14f40     10 0C 07 F6 |                 mov     hidr_usage, ##$76543210
14f44                 | 
14f44                 | .next
14f44     00 EC 5F F2 |                 cmps    pa, #0      wcz
14f48     2D 00 7C ED |         if_be   ret     wcz
14f4c                 | 
14f4c     61 8F C7 FA |                 rdbyte  hpar1, ptra++
14f50     01 EC 87 F1 |                 sub     pa, #1
14f54     00 90 07 F6 |                 mov     hpar2, #0
14f58                 | 
14f58     C7 73 03 F6 |                 mov     htmp, hpar1
14f5c     03 72 07 F5 |                 and     htmp, #$03
14f60     01 72 0F F2 |                 cmp     htmp, #1    wz
14f64     61 91 C7 AA |         if_z    rdbyte  hpar2, ptra++
14f68     07 90 67 A7 |         if_z    signx   hpar2,#7
14f6c     01 EC 87 A1 |         if_z    sub     pa, #1
14f70     02 72 0F F2 |                 cmp     htmp, #2    wz
14f74     61 91 E7 AA |         if_z    rdword  hpar2, ptra++
14f78     0F 90 67 A7 |         if_z    signx   hpar2,#15
14f7c     02 EC 87 A1 |         if_z    sub     pa, #2
14f80     03 72 0F F2 |                 cmp     htmp, #3    wz
14f84     61 91 07 AB |         if_z    rdlong  hpar2, ptra++
14f88     04 EC 87 A1 |         if_z    sub     pa, #4
14f8c                 | 
14f8c     FC 8E 07 F5 |                 and     hpar1, #$FC
14f90                 |                 'debug(uhex_byte(hpar1),uhex_long(hpar2))
14f90                 | 
14f90     84 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_ID   wz
14f94     18 01 90 AD |         if_z    jmp     #.report_id
14f98     04 8E 0F F2 |                 cmp     hpar1, #HID_USAGE_PAGE  wz
14f9c     30 01 90 AD |         if_z    jmp     #.usage_page
14fa0     08 8E 0F F2 |                 cmp     hpar1, #HID_USAGE       wz
14fa4     38 01 90 AD |         if_z    jmp     #.usage
14fa8     14 8E 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MIN wz
14fac     C8 2B 2B A9 |         if_z    setword hidr_lminmax, hpar2, #1
14fb0     24 8E 0F F2 |                 cmp     hpar1, #HID_LOGICAL_MAX wz
14fb4     C8 2B 23 A9 |         if_z    setword hidr_lminmax, hpar2, #0
14fb8     34 8E 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MIN wz
14fbc     C8 2D 2B A9 |         if_z    setword hidr_pminmax, hpar2, #1
14fc0     44 8E 0F F2 |                 cmp     hpar1, #HID_PHYSICAL_MAX wz
14fc4     C8 2D 23 A9 |         if_z    setword hidr_pminmax, hpar2, #0
14fc8     74 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_SIZE wz
14fcc     C8 27 03 A6 |         if_z    mov     hidr_size, hpar2
14fd0     94 8E 0F F2 |                 cmp     hpar1, #HID_REPORT_COUNT wz
14fd4     C8 29 03 A6 |         if_z    mov     hidr_count, hpar2
14fd8     B4 8E 1F F2 |                 cmp     hpar1, #HID_POP wcz
14fdc     A4 8E 0F 52 |         if_nz   cmp     hpar1, #HID_PUSH wz
14fe0     64 01 90 AD |         if_z    jmp     #.pushpop ' Entering with C set if PUSH  
14fe4     80 8E 0F F2 |                 cmp     hpar1, #HID_INPUT       wz
14fe8     58 FF 9F 5D |         if_nz   jmp     #.next
14fec                 | 
14fec     D5 25 A7 FB |                 tjf     hidr_state,#.next
14ff0                 | 
14ff0     03 90 07 F5 |                 and     hpar2, #$03
14ff4     02 90 0F F2 |                 cmp     hpar2, #HID_ITEM_VARIABLE   wz
14ff8     18 00 90 5D |         if_nz   jmp     #.skip
14ffc                 | 
14ffc     02 24 0F F2 |                 cmp     hidr_state, #2  wz
15000     20 00 90 AD |         if_z    jmp     #.axes
15004     03 24 0F F2 |                 cmp     hidr_state, #3  wz
15008     5C 00 90 AD |         if_z    jmp     #.hats
1500c     04 24 0F F2 |                 cmp     hidr_state, #4  wz
15010     70 00 90 AD |         if_z    jmp     #.buttons
15014                 | .skip
15014     93 73 03 F6 |                 mov     htmp, hidr_size
15018     94 73 03 FA |                 mul     htmp, hidr_count
1501c     B9 21 03 F1 |                 add     hidr_offset, htmp
15020     20 FF 9F FD |                 jmp     #.next
15024                 | .axes
15024                 |                 'debug(".axes ", udec(hidr_offset,hidr_size,hidr_count),uhex_long(hidr_flags))
15024     87 87 53 F8 |                 getnib  hr0, hidr_flags, #2
15028     94 89 03 F6 |                 mov     hr1, hidr_count
1502c                 | .l1
1502c     90 8F 03 F6 |                 mov     hpar1, hidr_offset
15030     93 91 03 F6 |                 mov     hpar2, hidr_size
15034     28 01 B0 FD |                 call    #hpad_getbits
15038     88 01 B0 FD |                 call    #hpad_normalize
1503c     08 86 1F F2 |                 cmp     hr0, #8         wcz
15040     86 87 5F C9 |         if_b    altgn   hr0, #hidr_usage
15044     00 8A 43 C8 |         if_b    getnib  hr2
15048     88 8B 77 C9 |         if_b    altsw   hr2, #hidr_axis
1504c     5F 01 20 C9 |         if_b    setword retval
15050     01 86 07 C1 |         if_b    add     hr0, #1
15054     93 21 03 F1 |                 add     hidr_offset, hidr_size
15058     F4 89 6F FB |                 djnz    hr1, #.l1
1505c                 | 
1505c     C3 0F 13 F8 |                 setnib  hidr_flags, hr0, #2
15060     01 24 07 F6 |                 mov     hidr_state, #1
15064     DC FE 9F FD |                 jmp     #.next
15068                 | .hats
15068                 |                 'debug(".hats ", udec(hidr_offset,hidr_size,hidr_count))
15068     90 8F 03 F6 |                 mov     hpar1, hidr_offset
1506c     93 91 03 F6 |                 mov     hpar2, hidr_size
15070     EC 00 B0 FD |                 call    #hpad_getbits
15074     5F 1B C3 F8 |                 setbyte hidr_hats, retval, #0
15078     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
1507c     01 24 07 F6 |                 mov     hidr_state, #1
15080     90 FF 9F FD |                 jmp     #.skip
15084                 | .buttons
15084                 |                 'debug(".buttons ", udec(hidr_offset,hidr_size,hidr_count))
15084     90 8F 03 F6 |                 mov     hpar1, hidr_offset
15088     93 91 03 F6 |                 mov     hpar2, hidr_size
1508c     94 91 03 FA |                 mul     hpar2, hidr_count
15090     CC 00 B0 FD |                 call    #hpad_getbits
15094     87 73 E3 F8 |                 getbyte htmp, hidr_flags, #0
15098     B9 BF 62 F0 |                 shl     retval, htmp
1509c     5F 19 43 F5 |                 or      hidr_buttons, retval
150a0     94 73 03 F1 |                 add     htmp, hidr_count
150a4     B9 0F C3 F8 |                 setbyte hidr_flags, htmp, #0
150a8     01 24 07 F6 |                 mov     hidr_state, #1
150ac     64 FF 9F FD |                 jmp     #.skip
150b0                 | .report_id
150b0     00 1E 0F F2 |                 cmp     hidr_id, #0     wz
150b4     2D 00 7C 5D |         if_nz   ret     wcz
150b8     E1 73 C7 FA |                 rdbyte  htmp, ptrb++
150bc                 |                 'debug(".report_id",udec(htmp,hpar2))
150bc     C8 73 0B F2 |                 cmp     htmp, hpar2     wz
150c0     B9 1F 03 A6 |         if_z    mov     hidr_id, htmp
150c4     01 24 67 56 |         if_nz   neg     hidr_state,#1
150c8     01 F2 87 51 |         if_nz   sub     ptrb,#1
150cc     74 FE 9F FD |                 jmp     #.next
150d0                 | .usage_page
150d0     09 90 0F F2 |                 cmp     hpar2, #HID_USAGE_PAGE_BUTTONS  wz
150d4     01 24 0F A2 |         if_z    cmp     hidr_state, #1  wz
150d8     04 24 07 A6 |         if_z    mov     hidr_state, #4
150dc     64 FE 9F FD |                 jmp     #.next
150e0                 | .usage
150e0     04 90 0F F2 |                 cmp     hpar2, #HID_USAGE_JOYSTICK  wz
150e4     05 90 0F 52 |         if_nz   cmp     hpar2, #HID_USAGE_GAMEPAD   wz
150e8     06 1C 0F A2 |         if_z    cmp     hidr_type,#HID_READY        wz
150ec     01 24 07 A6 |         if_z    mov     hidr_state, #1
150f0     50 FE 9F AD |         if_z    jmp     #.next
150f4     02 90 0F F2 |                 cmp     hpar2, #HID_USAGE_MOUSE     wz
150f8     04 1C 0F A2 |         if_z    cmp     hidr_type,#M_READY          wz
150fc     01 24 07 A6 |         if_z    mov     hidr_state, #1
15100     40 FE 9F AD |         if_z    jmp     #.next
15104     30 90 17 F2 |                 cmp     hpar2, #HID_USAGE_X     wc
15108     38 90 97 32 |         if_nc   cmpr    hpar2, #HID_USAGE_WHEEL wc   
1510c     10 00 90 3D |         if_nc   jmp     #.usage_axis
15110     39 90 0F F2 |                 cmp     hpar2, #HID_USAGE_HATSWITCH wz
15114     01 24 0F A2 |         if_z    cmp     hidr_state, #1      wz
15118     03 24 07 A6 |         if_z    mov     hidr_state, #3
1511c     24 FE 9F FD |                 jmp     #.next
15120                 | .usage_axis
15120     01 24 57 F2 |                 cmps    hidr_state, #1          wc
15124     1C FE 9F CD |         if_b    jmp     #.next
15128     37 90 27 F3 |                 fle     hpar2, #HID_USAGE_DIAL   ' Let's just say wheel and dial are the same to keep sane
1512c     86 23 57 F9 |                 altsn   hidr_usage_idx, #hidr_usage
15130     C8 01 00 F8 |                 setnib  hpar2
15134                 | 
15134     20 90 87 F1 |                 sub     hpar2, #HID_USAGE_X - 16
15138     C8 0F 23 F4 |                 bith    hidr_flags, hpar2
1513c                 | 
1513c     01 22 07 F1 |                 add     hidr_usage_idx, #1
15140     02 24 07 F6 |                 mov     hidr_state, #2
15144     FC FD 9F FD |                 jmp     #.next
15148                 | .pushpop
15148                 |                 ' Entering with C set if PUSH  
15148     4C 0F B0 FE |                 loc     pb, #hid_stack
1514c     28 08 64 CD |         if_c    setq    #(hidr_end-hidr_state)-1
15150     F7 25 63 CC |         if_c    wrlong  hidr_state, pb
15154     28 08 64 3D |         if_nc   setq    #(hidr_end-hidr_state)-1
15158     F7 25 03 3B |         if_nc   rdlong  hidr_state, pb
1515c     E4 FD 9F FD |                 jmp     #.next
15160                 | 
15160                 | '------------------------------------------------------------------------------
15160                 | ' Read bits from report data buffer
15160                 | '------------------------------------------------------------------------------
15160                 | ' On entry:
15160                 | '   PTRB - report buffer
15160                 | '   hpar1 - start bit
15160                 | '   hpar2 - number of bits
15160                 | ' On exit:
15160                 | '   retval - bits
15160                 | '------------------------------------------------------------------------------
15160                 | hpad_getbits
15160     C7 73 03 F6 |                 mov     htmp, hpar1
15164     03 72 47 F0 |                 shr     htmp, #3        ' byte offset
15168     F9 73 03 F1 |                 add     htmp, ptrb
1516c     B9 BF 02 FB |                 rdlong  retval, htmp
15170                 | 
15170     C7 75 03 F6 |                 mov     htmp1, hpar1
15174     07 74 07 F5 |                 and     htmp1, #$07     ' shift
15178     BA BF 42 F0 |                 shr     retval, htmp1
1517c                 | 
1517c     18 90 1F F2 |                 cmp     hpar2, #24      wcz
15180     10 00 90 1D |         if_a    jmp     #.l1
15184                 | 
15184     C8 91 C3 F9 |                 decod   hpar2
15188     01 90 87 F1 |                 sub     hpar2, #1
1518c     C8 BF 02 F5 |                 and     retval, hpar2
15190     2D 00 64 FD |                 ret
15194                 | .l1
15194     FF 7F 00 FF 
15198     FF BF 06 F5 |                 and     retval, ##$00_FFFFFF
1519c     03 72 07 F1 |                 add     htmp, #3
151a0     B9 77 03 FB |                 rdlong  htmp2, htmp
151a4     18 90 87 F1 |                 sub     hpar2, #24
151a8     C8 91 C3 F9 |                 decod   hpar2
151ac     01 90 87 F1 |                 sub     hpar2, #1
151b0     BA 77 43 F0 |                 shr     htmp2, htmp1
151b4     C8 77 03 F5 |                 and     htmp2, hpar2
151b8     18 76 67 F0 |                 shl     htmp2, #24
151bc     BB BF 42 F5 |                 or      retval, htmp2
151c0     2D 00 64 FD |                 ret
151c4                 | 
151c4                 | '------------------------------------------------------------------------------
151c4                 | ' Normalize value to signed word (-32768 / 32767)
151c4                 | '------------------------------------------------------------------------------
151c4                 | ' On entry:
151c4                 | '   retval - value to normalize
151c4                 | '   hidr_lminmax - min (word 1) max (word 0) value range
151c4                 | '   - or -
151c4                 | '   hidr_pminmax - min (word 1) max (word 0) value range
151c4                 | '   hidr_size - value bits length
151c4                 | ' On exit:
151c4                 | '   retval - normalized value
151c4                 | '------------------------------------------------------------------------------
151c4                 | hpad_normalize
151c4     95 73 0B F6 |                 mov     htmp, hidr_lminmax  wz
151c8     96 73 0B A6 |         if_z    mov     htmp, hidr_pminmax  wz
151cc     2D 00 64 AD |         if_z    ret
151d0     B9 75 3B F9 |                 getword htmp1, htmp, #1     ' htmp1 = min
151d4     B9 73 33 F9 |                 getword htmp, htmp, #0      ' htmp = max
151d8     0F 74 77 F7 |                 signx   htmp1, #15      wc
151dc     FF 27 97 C9 |         if_c    alts    hidr_size, #511
151e0     00 BE 66 C7 |         if_c    signx   retval, #0-0
151e4                 |                 ' slightly crappy hack: if in mouse mode, don't normalize
151e4     04 1C 0F F2 |                 cmp     hidr_type, #M_READY wz
151e8     2D 00 64 AD |         if_z    ret
151ec     BA 73 C3 F1 |                 subs    htmp, htmp1         ' htmp = (max - min)
151f0     BA BF C2 F1 |                 subs    retval, htmp1       ' retval = (retval - min)
151f4     10 BE 66 F0 |                 shl     retval, #16         ' retval = (retval - min) << 16
151f8     01 BE C6 F1 |                 subs    retval, #1          ' retval = ((retval - min) << 16) - 1
151fc     B9 73 53 F6 |                 abs     htmp            wc
15200     1F BE 0E F4 |                 testb   retval, #31     wz
15204     5F BF 42 F6 |                 abs     retval
15208     B9 BF 12 FD |                 qdiv    retval, htmp
1520c     18 BE 62 FD |                 getqx   retval
15210     5F BF 62 66 |     if_c_ne_z   neg     retval              ' retval = (((retval - min) << 16) - 1) / (max - min)
15214     C0 FF 7F FF 
15218     00 BE 46 F1 |                 adds    retval, ##$8000 signx 15
1521c     2D 00 64 FD |                 ret
15220                 | end
15220                 | 
15220                 | if _HAVE_GAMEPAD
15220                 | '------------------------------------------------------------------------------
15220                 | ' Handle XInput controller
15220                 | ' On entry:
15220                 | '   ptrb - controller report
15220                 | '------------------------------------------------------------------------------
15220                 | '   Default implementation translates the report to a pseudo-defacto hid
15220                 | '   standard and jumps to hpad_translate for actions.
15220                 | '   Implementors may take specific actions for this kind of controller.
15220                 | '------------------------------------------------------------------------------
15220                 | hpad_xinput
15220     80 73 CF FA |                 rdbyte  htmp, ptrb      wz
15224     2D 00 64 5D |         if_nz   ret                         ' Ignore message type <> $00
15228     81 73 C7 FA |                 rdbyte  htmp, ptrb[1]
1522c     14 72 0F F2 |                 cmp     htmp, #$14      wz
15230     2D 00 64 5D |         if_nz   ret                         ' Ignore report length <> $14 (20)
15234                 | 
15234                 |                 'debug(udec(hdev_port), " XINPUT ", uhex_long(ep_addr_pid),uhex_long(ptrb))
15234                 | 
15234     B0 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
15238     06 0E 17 F8 |                 setnib  hidr_flags, #6, #2
1523c                 | 
1523c     83 11 E7 FA |                 rdword  hidr_axis, ptrb[3]  ' X = left stick X
15240     84 BF E6 FA |                 rdword  retval, ptrb[4]     ' Y = left stick Y (inverted)
15244     5F BF 22 F6 |                 not     retval
15248     5F 11 2B F9 |                 setword hidr_axis, retval, #1
1524c     85 13 E7 FA |                 rdword  hidr_axis+1, ptrb[5]' Z = right stick X
15250     86 BF E6 FA |                 rdword  retval, ptrb[6]     ' RZ = right stick Y (inverted)
15254     5F BF 22 F6 |                 not     retval
15258     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
1525c                 | 
1525c     FF 2A 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
15260     84 BF C6 FA |                 rdbyte  retval, ptrb[4]     ' left analog trigger
15264     C0 BE 1E F2 |                 cmp     retval, #192    wcz
15268     06 18 27 34 |         if_ae   bith    hidr_buttons, #6    ' left analog trigger (button)
1526c     54 FF BF FD |                 call    #hpad_normalize
15270     5F 13 2B F9 |                 setword hidr_axis+1, retval, #1
15274     85 BF C6 FA |                 rdbyte  retval, ptrb[5]     ' right analog trigger
15278     C0 BE 1E F2 |                 cmp     retval, #192    wcz
1527c     07 18 27 34 |         if_ae   bith    hidr_buttons, #7    ' right analog trigger (button)
15280     40 FF BF FD |                 call    #hpad_normalize
15284     5F 15 23 F9 |                 setword hidr_axis+2, retval, #0
15288                 | 
15288     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
1528c     81 BF E6 FA |                 rdword  retval, ptrb[1]
15290     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
15294     00 18 47 F4 |                 bitc    hidr_buttons, #0
15298     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
1529c     01 18 47 F4 |                 bitc    hidr_buttons, #1
152a0     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
152a4     02 18 47 F4 |                 bitc    hidr_buttons, #2
152a8     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
152ac     03 18 47 F4 |                 bitc    hidr_buttons, #3
152b0     08 BE 16 F4 |                 testb   retval, #8      wc  ' LB
152b4     04 18 47 F4 |                 bitc    hidr_buttons, #4
152b8     09 BE 16 F4 |                 testb   retval, #9      wc  ' RB
152bc     05 18 47 F4 |                 bitc    hidr_buttons, #5
152c0     05 BE 16 F4 |                 testb   retval, #5      wc  ' SELECT
152c4     08 18 47 F4 |                 bitc    hidr_buttons, #8
152c8     04 BE 16 F4 |                 testb   retval, #4      wc  ' START
152cc     09 18 47 F4 |                 bitc    hidr_buttons, #9
152d0     06 BE 16 F4 |                 testb   retval, #6      wc  ' L3
152d4     0A 18 47 F4 |                 bitc    hidr_buttons, #10
152d8     07 BE 16 F4 |                 testb   retval, #7      wc  ' R3
152dc     0B 18 47 F4 |                 bitc    hidr_buttons, #11
152e0     0A BE 16 F4 |                 testb   retval, #10     wc  ' XBOX
152e4     0C 18 47 F4 |                 bitc    hidr_buttons, #12
152e8                 | 
152e8     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
152ec     5F 73 43 F8 |                 getnib  htmp, retval, #0    ' map dpad buttons to hat direction
152f0     7A BB 7A FF 
152f4     0F 74 07 F6 |                 mov     htmp1, ##$F576_F40F
152f8     F9 FF 7F FF 
152fc     12 77 07 F6 |                 mov     htmp2, ##$FFFF_F312
15300     BA 73 5F F9 |                 altgn   htmp, #htmp1
15304     00 72 43 F8 |                 getnib  htmp
15308     B9 1B C3 08 |         _ret_   setbyte hidr_hats, htmp, #0
1530c                 | 
1530c                 | '------------------------------------------------------------------------------
1530c                 | ' Handle PS3 controller
1530c                 | ' On entry:
1530c                 | '   ptrb - controller report
1530c                 | '------------------------------------------------------------------------------
1530c                 | '   Default implementation translates the report to a pseudo-defacto hid
1530c                 | '   standard and jumps to hpad_translate for actions.
1530c                 | '   Implementors may take specific actions for this kind of controller.
1530c                 | '------------------------------------------------------------------------------
1530c                 | hpad_ps3
1530c     E1 73 C7 FA |                 rdbyte  htmp, ptrb++
15310     01 72 0F F2 |                 cmp     htmp, #$01      wz
15314     2D 00 64 5D |         if_nz   ret                         ' Ignore report ID <> $01
15318                 | 
15318                 |                 debug(udec(hdev_port), " PS3 ", uhex_long(ep_addr_pid),uhex_long(ptrb))
15318                 | 
15318     B0 0E 27 F4 |                 bith    hidr_flags, #HID_AXIS_X addbits 5 ' Have all axes
1531c     06 0E 17 F8 |                 setnib  hidr_flags, #6, #2
15320                 | 
15320     FF 2A 07 F6 |                 mov     hidr_lminmax, #$0000_00FF
15324     85 BF C6 FA |                 rdbyte  retval, ptrb[5]         ' X = left stick X
15328     98 FE BF FD |                 call    #hpad_normalize
1532c     5F 11 23 F9 |                 setword hidr_axis, retval, #0
15330     86 BF C6 FA |                 rdbyte  retval, ptrb[6]         ' Y = left stick Y
15334     8C FE BF FD |                 call    #hpad_normalize
15338     5F 11 2B F9 |                 setword hidr_axis, retval, #1
1533c     87 BF C6 FA |                 rdbyte  retval, ptrb[7]         ' Z = right stick X
15340     80 FE BF FD |                 call    #hpad_normalize
15344     5F 13 23 F9 |                 setword hidr_axis+1, retval, #0
15348     88 BF C6 FA |                 rdbyte  retval, ptrb[8]         ' RZ = right stick Y
1534c     74 FE BF FD |                 call    #hpad_normalize
15350     5F 15 2B F9 |                 setword hidr_axis+2, retval, #1
15354     91 BF C6 FA |                 rdbyte  retval, ptrb[17]        ' RX = L2 analog
15358     68 FE BF FD |                 call    #hpad_normalize
1535c     5F 13 2B F9 |                 setword hidr_axis+1, retval, #1
15360     92 BF C6 FA |                 rdbyte  retval, ptrb[18]        ' RY = R2 analog
15364     5C FE BF FD |                 call    #hpad_normalize
15368     5F 15 23 F9 |                 setword hidr_axis+2, retval, #0
1536c                 | 
1536c     08 8E 07 F6 |                 mov     hpar1, #8
15370     13 90 07 F6 |                 mov     hpar2, #19
15374     E8 FD BF FD |                 call    #hpad_getbits
15378                 | 
15378     0D 0E C7 F8 |                 setbyte hidr_flags,#13,#0
1537c     0C BE 16 F4 |                 testb   retval, #12     wc  ' A
15380     00 18 47 F4 |                 bitc    hidr_buttons, #0
15384     0D BE 16 F4 |                 testb   retval, #13     wc  ' B
15388     01 18 47 F4 |                 bitc    hidr_buttons, #1
1538c     0E BE 16 F4 |                 testb   retval, #14     wc  ' X
15390     02 18 47 F4 |                 bitc    hidr_buttons, #2
15394     0F BE 16 F4 |                 testb   retval, #15     wc  ' Y
15398     03 18 47 F4 |                 bitc    hidr_buttons, #3
1539c     0A BE 16 F4 |                 testb   retval, #10     wc  ' L1
153a0     04 18 47 F4 |                 bitc    hidr_buttons, #4
153a4     0B BE 16 F4 |                 testb   retval, #11     wc  ' R1
153a8     05 18 47 F4 |                 bitc    hidr_buttons, #5
153ac     08 BE 16 F4 |                 testb   retval, #8      wc  ' L2
153b0     06 18 47 F4 |                 bitc    hidr_buttons, #6
153b4     09 BE 16 F4 |                 testb   retval, #9      wc  ' R2
153b8     07 18 47 F4 |                 bitc    hidr_buttons, #7
153bc     00 BE 16 F4 |                 testb   retval, #0      wc  ' SELECT
153c0     08 18 47 F4 |                 bitc    hidr_buttons, #8
153c4     03 BE 16 F4 |                 testb   retval, #3      wc  ' START
153c8     09 18 47 F4 |                 bitc    hidr_buttons, #9
153cc     01 BE 16 F4 |                 testb   retval, #1      wc  ' LEFT STICK
153d0     0A 18 47 F4 |                 bitc    hidr_buttons, #10
153d4     02 BE 16 F4 |                 testb   retval, #2      wc  ' RIGHT STICK
153d8     0B 18 47 F4 |                 bitc    hidr_buttons, #11
153dc     10 BE 16 F4 |                 testb   retval, #16     wc  ' HOME
153e0     0C 18 47 F4 |                 bitc    hidr_buttons, #12
153e4                 | 
153e4     01 0E 1F F8 |                 setnib  hidr_flags, #1, #3
153e8     5F 73 4B F8 |                 getnib  htmp, retval, #1    ' map dpad buttons to hat direction
153ec     09 FA 79 FF 
153f0     0F 74 07 F6 |                 mov     htmp1, ##$F3F4_120F
153f4     FF FA 7F FF 
153f8     76 77 07 F6 |                 mov     htmp2, ##$FFF5_FF76
153fc     BA 73 5F F9 |                 altgn   htmp, #htmp1
15400     00 72 43 F8 |                 getnib  htmp
15404     B9 1B C3 08 |         _ret_   setbyte hidr_hats, htmp, #0
15408                 | 
15408                 | 
15408                 | '------------------------------------------------------------------------------
15408                 | ' Perform controller actions
15408                 | ' On entry:
15408                 | '    hidr_id        report id
15408                 | '    hidr_axis      axis value (signed word, 2 axes per long)
15408                 | '                      X = hidr_axis+0, #0
15408                 | '                      Y = hidr_axis+0, #1
15408                 | '                      Z = hidr_axis+1, #0
15408                 | '                     RX = hidr_axis+1, #1
15408                 | '                     RY = hidr_axis+2, #0
15408                 | '                     RZ = hidr_axis+2, #1
15408                 | '                     Sl = hidr_axis+3, #0
15408                 | '                     Wh = hidr_axis+3, #1
15408                 | '    hidr_buttons   buttons state (bits 0 to 31)
15408                 | '    hidr_hats      hats state (byte 0, 1, 2, 3)
15408                 | '
15408                 | '                     -------3 -------2 -------1 -------0 byte
15408                 | '                     ---7---6 ---5---4 ---3---2 ---1---0 nibble
15408                 | '    hidr_flags       xxxxxxxx_wsrrrzyx_hhhhaaaa_bbbbbbbb
15408                 | '                              hlzyx||| |||||||| ++++++++ n. buttons
15408                 | '                              |||||||| ||||++++--------- n. axes
15408                 | '                              |||||||| ++++------------- n. hats
15408                 | '                              ++++++++------------------ valid axes
15408                 | '------------------------------------------------------------------------------
15408                 | hpad_translate
15408                 | 
15408                 | 
15408                 |         if HAVE_HIDPAD
15408     A0 0C F0 FE |                 loc     ptrb,#hidpad_report
1540c     2D 73 0B F6 |                 mov     htmp,hdev_port          wz
15410     8F 73 03 A6 |         if_z    mov     htmp,hidr_id
15414     01 72 E7 F2 |                 cmpsub  htmp,#1
15418     07 1E 17 A2 |         if_z    cmp     hidr_id, #MAX_DEVICES   wc
1541c     02 1E 17 52 |         if_nz   cmp     hidr_id, #2             wc
15420     2D 00 7C 3D |         if_ae   ret     wcz
15424     20 72 07 FA |                 mul     htmp, #HIDPAD_REPORT_SIZE
15428     B9 F3 03 F1 |                 add     ptrb,htmp
1542c     61 5B 96 F9 |                 alts    hdev_port,#hdev_id
15430     00 0C 03 F6 |                 mov     hidr_usage,0-0 ' We can trash hidr_usage with the ID so we can do one atomic block write
15434     28 0E 64 FD |                 setq    #8-1
15438     80 0D 67 FC |                 wrlong  hidr_usage,ptrb
1543c                 |         end
1543c                 | 
1543c                 | 
1543c                 |         if EMUPAD_MAX_PLAYER > 0
1543c                 | .emupad_no_hat
1543c                 |         if EMUPAD_BT0_BIT >= 0
1543c                 |         end
1543c                 |         if EMUPAD_BT1_BIT >= 0
1543c                 |         end
1543c                 |         if EMUPAD_BT2_BIT >= 0
1543c                 |         end
1543c                 |         if EMUPAD_BT3_BIT >= 0
1543c                 |         end
1543c                 |         if EMUPAD_BT4_BIT >= 0
1543c                 |         end
1543c                 |         if EMUPAD_BT5_BIT >= 0
1543c                 |         end
1543c                 |         if EMUPAD_BT6_BIT >= 0
1543c                 |         end
1543c                 |         if EMUPAD_BT7_BIT >= 0
1543c                 |         end
1543c                 |         if EMUPAD_BT8_BIT >= 0
1543c                 |         end
1543c                 |         if EMUPAD_BT9_BIT >= 0
1543c                 |         end
1543c                 | .emupad_slot_over
1543c                 |         end
1543c                 | 
1543c                 |         if 0
1543c                 |                 debug(if(htmp), "    hat: ", uhex_byte_(htmp1))
1543c                 | 
1543c                 |                 debug("    btn: ", ubin_long_(hidr_buttons))
1543c                 | 
1543c                 |         end
1543c     2D 00 64 FD |                 ret
15440                 | end
15440                 | 
15440                 | if EMUPAD_MAX_PLAYER > 0
15440                 | '------------------------------------------------------------------------------
15440                 | ' Clear EmuPad state
15440                 | '------------------------------------------------------------------------------
15440                 | emupad_reset
15440                 | 
15440                 | '------------------------------------------------------------------------------
15440                 | ' Get EmuPad Player number for current device (into retval)
15440                 | ' Z flag is also set if current device is valid
15440                 | ' (Value may be larger than EMUPAD_MAX_PLAYER !)
15440                 | '------------------------------------------------------------------------------
15440                 | emupad_getnum
15440                 | .loop
15440                 | '------------------------------------------------------------------------------
15440                 | ' Handle disconnect of device (call after emupad_getnum returns with Z set)
15440                 | '------------------------------------------------------------------------------
15440                 | emupad_discon
15440                 | .loop         
15440                 |         
15440                 |         ' FALL THROUGH!!!
15440                 | 
15440                 | '------------------------------------------------------------------------------
15440                 | ' Update EmuPad reports (all of them...)
15440                 | '------------------------------------------------------------------------------
15440                 | emupad_write_reports
15440                 | .devloop
15440                 | 
15440                 | end
15440                 | 
15440                 | 
15440                 | '------------------------------------------------------------------------------
15440                 | ' Execute an IN interrupt transaction to poll for gamepad activity.
15440                 | '------------------------------------------------------------------------------
15440                 | ' On entry:
15440                 | ' On exit:
15440                 | '------------------------------------------------------------------------------
15440                 | hget_hub_status
15440     77 BD 02 F6 |                 mov     ep_addr_pid, hhub_ep_addr
15444     27 91 03 F6 |                 mov     hpar2, urx_buff_p
15448     32 93 23 F9 |                 setword hpar3, hub_next_datax, #0
1544c     01 92 2F F9 |                 setword hpar3, #1, #1
15450     CF 02 A0 FD |                 call    #do_int_in
15454     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15458     0C 00 90 AD |         if_z    jmp     #.data
1545c     5A BE 0E F2 |                 cmp     retval, #PID_NAK        wz
15460     1A 01 80 5D |         if_nz   jmp     #host_error                     ' Something other than ACK/NAK, so likely fatal
15464     2D 00 64 FD |                 ret
15468                 | .data
15468     00 92 0F F2 |                 cmp     hpar3, #0               wz
1546c     2D 00 64 AD |         if_z    ret                                     ' Ignore an empty DATAx packet
15470                 | 
15470     C3 64 0E F2 |                 cmp     hub_next_datax, #PID_DATA0  wz
15474     4B 64 06 A6 |         if_z    mov     hub_next_datax, #PID_DATA1      ' Txn success, so toggle DATAx
15478     C3 64 06 56 |         if_nz   mov     hub_next_datax, #PID_DATA0
1547c     27 67 02 FB |                 rdlong  hub_status_chg, urx_buff_p
15480                 |                 debug(ubin_long(hub_status_chg))
15480                 | 
15480     01 5A 06 F6 |                 mov     hdev_port, #1
15484                 | .loop
15484     2D 67 0A F4 |                 testb   hub_status_chg, hdev_port wz
15488     0C 00 B0 AD |         if_x1   call    #hub_port_handler
1548c     07 5A 1E F7 |                 incmod  hdev_port, #7           wcz
15490     F0 FF 9F 3D |         if_nc   jmp     #.loop
15494     2D 00 64 FD |                 ret
15498                 | 
15498                 | hub_port_handler
15498     76 BD 02 F6 |                 mov     ep_addr_pid, hhub_ctrl_ep
1549c     8C 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
154a0     27 EF 03 F6 |                 mov     pb, urx_buff_p
154a4     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
154a8     55 02 A0 FD |                 call    #control_read
154ac     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
154b0                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
154b0                 | 
154b0     10 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_CONNECTION wz ' Connection change bit
154b4     50 01 90 5D |         if_x0   jmp     #.other
154b8     68 02 D0 FE |                 loc     ptra, #clr_port_feat
154bc     01 21 5C FC |                 wrword  #HUB_C_PORT_CONNECTION, ptra[wValue]
154c0     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
154c4     A0 02 A0 FD |                 call    #control_write
154c8     00 68 0E F4 |                 testb   hub_port_status, #HUB_PORT_CONNECTION wz ' Connection bit
154cc     7C 01 90 5D |         if_x0   jmp     #.disconnect
154d0     B1 99 02 F6 |                 mov     hctwait, _100ms_
154d4     EF 02 A0 FD |                 call    #poll_waitx
154d8                 | 
154d8     40 02 D0 FE |                 loc     ptra, #set_port_feat            ' reset port
154dc     01 09 5C FC |                 wrword  #HUB_PORT_RESET, ptra[wValue]
154e0     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
154e4     A0 02 A0 FD |                 call    #control_write
154e8                 | 
154e8     02 78 07 F6 |                 mov     htmp3, #2
154ec                 | .wait_reset
154ec     AD 99 02 F6 |                 mov     hctwait, _8ms_
154f0     EF 02 A0 FD |                 call    #poll_waitx
154f4     34 02 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
154f8     27 EF 03 F6 |                 mov     pb, urx_buff_p
154fc     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
15500     55 02 A0 FD |                 call    #control_read
15504     27 69 02 FB |                 rdlong  hub_port_status, urx_buff_p
15508     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz ' Reset change bit
1550c     F7 79 6F 5B |         if_x0   djnz    htmp3, #.wait_reset
15510                 | 
15510     10 02 D0 FE |                 loc     ptra, #clr_port_feat
15514     01 29 5C FC |                 wrword  #HUB_C_PORT_RESET, ptra[wValue]
15518     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
1551c     A0 02 A0 FD |                 call    #control_write
15520                 | 
15520     24 72 07 F6 |                 mov     htmp, #36                 ' Allow reset recovery time (Section 9.2.6.2)
15524                 | .wait_recover
15524     A8 99 02 F6 |                 mov     hctwait, _1ms_
15528     EF 02 A0 FD |                 call    #poll_waitx
1552c     FD 73 6F FB |                 djnz    htmp,#.wait_recover
15530                 | 
15530     09 68 16 F4 |                 testb   hub_port_status, #HUB_PORT_LOWSPEED wc
15534     07 96 26 C4 |         if_c    bith    hstatus, #DWNSTRM_HUBB
15538     0E 6A 27 C4 |         if_c    bith    _usb_h_ls_nco_, #14
1553c                 | 
1553c     00 08 00 FF 
15540     00 BC 06 F6 |                 mov     ep_addr_pid, ##EP_ADDR_ZERO     ' New connect, use pre-calc CRC for ep/addr zero
15544     8C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Hub start address of GetDeviceDescriptor SETUP struct
15548     03 11 5C FC |                 wrword  #8, ptra[wLength]               ' Request IN data stage max of 8 bytes will test actual < requested logic
1554c     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct for IN data
15550     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor()
15554     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
15558     48 01 90 5D |         if_nz   jmp     #.done
1555c                 | .get_dev_desc
1555c     28 ED 03 F6 |                 mov     pa, dev_desc_buff_p             ' Fetch the max packet size for control transactions from the
15560     07 EC 07 F1 |                 add     pa, #DEV_bMaxPktSize0           ' appropriate Device Descriptor struct member offset
15564     F6 AB C2 FA |                 rdbyte  max_pkt_size, pa
15568     80 01 D0 FE |                 loc     ptra, #set_address              ' Hub start address of SetAddress SETUP struct
1556c     2D 73 03 F6 |                 mov     htmp, hdev_port             ' Address is hub port number
15570     01 73 57 FC |                 wrword  htmp, ptra[wValue]
15574     A0 02 A0 FD |                 call    #control_write                  ' Execute SetAddress()
15578     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
1557c     24 01 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
15580     AD 99 02 F6 |                 mov     hctwait, _8ms_
15584     EF 02 A0 FD |                 call    #poll_waitx                     ' Allow SetAddress() a minimum 2ms recovery interval
15588     2D BD 02 F6 |                 mov     ep_addr_pid, hdev_port
1558c     08 BC 66 F0 |                 shl     ep_addr_pid, #8                 ' Device ep/addr now hub port number and endpoint zero
15590     BE 00 A0 FD |                 call    #calc_crc5
15594     3C 01 D0 FE |                 loc     ptra, #get_dev_desc             ' Repeat SETUP for GetDeviceDescriptor()
15598     28 EF 03 F6 |                 mov     pb, dev_desc_buff_p             ' Start address of DeviceDescriptor struct has exact descriptor length
1559c     F7 AD C2 FA |                 rdbyte  total_data, pb
155a0     03 AD 56 FC |                 wrword  total_data, ptra[wLength]       ' Assign it to the SETUP wLength struct member
155a4     55 02 A0 FD |                 call    #control_read                   ' Execute GetDeviceDescriptor() again, but with updated data length
155a8     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
155ac     F4 00 90 5D |         if_nz   jmp     #.done                          ' Back to idle if not ACK
155b0     5E D9 02 F6 |                 mov     hctrl_ep_addr, ep_addr_pid      ' Make the device control address and endpoint official
155b4     28 F1 03 F6 |                 mov     ptra, dev_desc_buff_p           ' Do the same with the control max packet size
155b8                 |                 'rdbyte  hctrl_max_pkt, ptra[DEV_bMaxPktSize0]
155b8     A0 99 02 F6 |                 mov     hctwait, _500us_
155bc     EF 02 A0 FD |                 call    #poll_waitx
155c0     18 01 D0 FE |                 loc     ptra, #get_config_desc          ' Hub start address of GetConfigurationDescriptor SETUP struct
155c4     03 FF 5D FC |                 wrword  #$FF, ptra[wLength]             ' Maximum DATAx bytes for receive to the SETUP struct
155c8     29 EF 03 F6 |                 mov     pb, con_desc_buff_p             ' Hub start address of ConfigurationDescriptor structure
155cc     55 02 A0 FD |                 call    #control_read                   ' Execute GetConfigurationDescriptor()
155d0     D2 BE 0E F2 |                 cmp     retval, #PID_ACK        wz
155d4     CC 00 90 5D |         if_nz   jmp     #.done
155d8     29 F1 03 F6 |                 mov     ptra, con_desc_buff_p           ' Check the config descriptor struct for expected data
155dc     F8 DD 02 F6 |                 mov     hconfig_base, ptra              ' Will need this for configuration
155e0     61 87 C7 FA |                 rdbyte  hr0, ptra++                     ' Config.bLength is at offset zero, expect >= CON_DESC_LEN
155e4     61 89 C7 FA |                 rdbyte  hr1, ptra++                     ' Config.bDescType is next member, expect = TYPE_CONFIG constant
155e8     00 73 E7 FA |                 rdword  htmp, ptra                      ' Config.wTotalLen is next member, expect >= bytes actually received
155ec     09 86 1F F2 |                 cmp     hr0, #CON_DESC_LEN      wcz
155f0     02 88 1F 32 |         if_ae   cmp     hr1, #TYPE_CONFIG       wcz
155f4     56 73 1B A2 |         if_z    cmp     htmp, total_data        wcz
155f8     0A BE 06 C6 |         if_b    mov     retval, #ERR_CONFIG_FAIL
155fc     A4 00 90 CD |         if_b    jmp     #.done
15600     68 F0 BF FD |                 call    #hparse_con_desc
15604     9C 00 90 FD |                 jmp     #.done
15608                 | 
15608                 | .other
15608     14 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_RESET wz
1560c     01 29 5C AC |         if_x1   wrword  #HUB_C_PORT_RESET, ptra[wValue]
15610     28 00 90 AD |         if_x1   jmp     #.reset_feature
15614     11 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_ENABLE wz
15618     01 23 5C AC |         if_x1   wrword  #HUB_C_PORT_ENABLE, ptra[wValue]
1561c     1C 00 90 AD |         if_x1   jmp     #.reset_feature
15620     12 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_SUSPEND wz
15624     01 25 5C AC |         if_x1   wrword  #HUB_C_PORT_SUSPEND, ptra[wValue]
15628     10 00 90 AD |         if_x1   jmp     #.reset_feature
1562c     13 68 0E F4 |                 testb   hub_port_status, #HUB_C_PORT_OVERCURRENT wz
15630     01 27 5C AC |         if_x1   wrword  #HUB_C_PORT_OVERCURRENT, ptra[wValue]
15634     04 00 90 AD |         if_x1   jmp     #.reset_feature
15638     68 00 90 FD |                 jmp     #.done
1563c                 | .reset_feature
1563c     E4 00 D0 FE |                 loc     ptra, #clr_port_feat
15640     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
15644     A0 02 A0 FD |                 call    #control_write
15648     58 00 90 FD |                 jmp     #.done
1564c                 | .disconnect
1564c                 | 
1564c     6A 5B 6E F9 |                 altgb   hdev_port, #hdev_type
15650     00 72 E3 F8 |                 getbyte htmp
15654     03 72 0F F2 |                 cmp     htmp,#KB_READY wz
15658     05 72 0F 52 |         if_nz   cmp     htmp,#KBM_READY wz
1565c     00 F2 06 A6 |         if_z    mov     hkbd_ep_addr, #0
15660     00 F0 06 A6 |         if_z    mov     hkbd_ctrl_ep, #0
15664     00 76 06 A6 |         if_z    mov     kb_led_states, #0
15668     3B F9 02 A6 |         if_z    mov     hkbd_ledstates, kb_led_states
1566c                 |         if EMUPAD_MAX_PLAYER > 0
1566c                 |         end
1566c                 |         if HAVE_MOUSE
1566c     04 72 0F F2 |                 cmp     htmp, #M_READY          wz
15670     05 72 0F 52 |         if_nz   cmp     htmp, #KBM_READY        wz
15674     00 F4 06 A6 |         if_z    mov     hmouse_ep_addr, #0
15678                 |         end
15678                 |         if HAVE_HIDPAD
15678     30 0A F0 FE |                 loc ptrb,#hidpad_report
1567c     2D 73 03 F6 |                 mov htmp,hdev_port
15680     01 72 E7 F2 |                 cmpsub htmp,#1
15684     20 72 07 FA |                 mul htmp,#HIDPAD_REPORT_SIZE
15688     B9 F3 03 F1 |                 add ptrb,htmp
1568c     28 0E 64 FD |                 setq #(HIDPAD_REPORT_SIZE)/4 - 1
15690     80 01 6C FC |                 wrlong #0,ptrb
15694                 |         end
15694                 | 
15694     6A 5B 66 F9 |                 altsb   hdev_port, #hdev_type
15698     00 00 C4 F8 |                 setbyte #0
1569c     7D 5B 8E F9 |                 altd    hdev_port, #hdev_ep_addr
156a0     00 00 04 F6 |                 mov     0-0, #0
156a4                 | 
156a4                 | .done
156a4     0E 6A 1F F4 |                 bitl    _usb_h_ls_nco_, #14     wcz
156a8     07 96 06 F4 |                 bitl    hstatus, #DWNSTRM_HUBB
156ac     22 6F 13 CC |         if_c    wxpin   _usb_h_fs_nco_, dm              ' Restore host mode and 12Mbs baud
156b0     40 AA 06 F6 |                 mov     max_pkt_size, #64               ' Set LS control read/write DATAx packet size
156b4     A6 9D 02 F6 |                 mov     tat_wait, _tat_wait_fs_         ' Bus turn-around time in low-speed bit periods
156b8     A4 9B 02 F6 |                 mov     ip_delay, _ip_delay_fs_         ' Inter-packet delay in low-speed bit periods
156bc                 | 
156bc     6C 00 D0 FE |                 loc     ptra, #get_port_status          ' Get HUB port status
156c0     27 EF 03 F6 |                 mov     pb, urx_buff_p
156c4     02 5B 56 FC |                 wrword  hdev_port, ptra[wIndex]
156c8     55 02 A0 FD |                 call    #control_read
156cc     00 69 06 FB |                 rdlong  hub_port_status, ptra
156d0                 |                 debug(udec(hdev_port), ubin_long(hub_port_status))
156d0     2D 00 64 FD |                 ret
156d4                 | 
156d4                 | '------------------------------------------------------------------------------
156d4                 | ' Partially populated SETUP packets
156d4                 | '------------------------------------------------------------------------------
156d4     80          | get_dev_desc    byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
156d5     06          |                 byte    REQ_GET_DESC
156d6     00 01       |                 word    TYPE_DEVICE << 8
156d8     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
156da     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
156dc     80          | get_config_desc byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
156dd     06          |                 byte    REQ_GET_DESC
156de     00 02       |                 word    TYPE_CONFIG << 8
156e0     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
156e2     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
156e4     00          | set_config      byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
156e5     09          |                 byte    REQ_SET_CONFIG
156e6     00 00       |                 word    0       ' Configuration value
156e8     00 00       |                 word    0       ' Zero
156ea     00 00       |                 word    0       ' Zero, as REQ_SET_CONFIG has no data stage
156ec     00          | set_address     byte    (DIR_HOST_TO_DEV | TYPE_STANDARD | RECIP_DEVICE)
156ed     05          |                 byte    REQ_SET_ADDR
156ee     00 00       |                 word    0       ' Zero
156f0     00 00       |                 word    0       ' Zero
156f2     00 00       |                 word    0       ' Zero, as REQ_SET_ADDR has no data stage
156f4                 | '------------------------------------------------------------------------------
156f4                 | ' The SET_PROTOCOL request is supported by devices in the "Boot" subclass. The
156f4                 | ' wValue field dictates which protocol should be used.
156f4                 | '
156f4                 | ' When initialized, all devices default to report protocol. However the host
156f4                 | ' should not make any assumptions about the device state and should set the
156f4                 | ' desired protocol whenever initializing a device.
156f4                 | '------------------------------------------------------------------------------
156f4     21          | set_protocol    byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
156f5     0B          |                 byte    HID_SET_PROTO
156f6     00 00       |                 word    BOOT_PROTOCOL   ' 0 = Boot Protocol, 1 = Report Protocol
156f8                 |                                                 ' (HID 1.11 Section 7.2.6).
156f8     00 00       |                 word    0               ' Interface index number.
156fa     00 00       |                 word    0               ' Zero, as HID_SET_PROTO has no data stage.
156fc                 | '------------------------------------------------------------------------------
156fc     21          | set_idle        byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
156fd     0A          |                 byte    HID_SET_IDLE
156fe     00 00       |                 word    0       ' Byte1 = duration, byte0 = ReportID. A duration of zero inhibits
15700                 |                                         ' reporting until a change is detected in the report data
15700                 | 
15700                 |                                         ' (HID 1.11 Section 7.2.4).
15700     00 00       |                 word    0       ' Interface index number.
15702     00 00       |                 word    0       ' Zero, as HID_SET_IDLE has no data stage.
15704     21          | set_report      byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_INTERFACE)
15705     09          |                 byte    HID_SET_REPORT
15706     00 00       |                 word    0       ' Byte1 = report type, byte0 = ReportID.
15708                 |                                         ' (HID 1.11 Section 7.2.2).
15708     00 00       |                 word    0       ' Interface index number.
1570a     00 00       |                 word    0       ' Size of the report, in bytes.
1570c     81          | get_desc        byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_INTERFACE)
1570d     06          |                 byte    REQ_GET_DESC
1570e     00 22       |                 word    TYPE_REPORT << 8
15710     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
15712     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
15714                 | '------------------------------------------------------------------------------
15714     A0          | get_hub_desc    byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_DEVICE)
15715     06          |                 byte    REQ_GET_DESC
15716     00 29       |                 word    TYPE_HUB << 8
15718     00 00       |                 word    0       ' Zero or Language ID (Section 9.6.7)
1571a     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
1571c     23          | set_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
1571d     03          |                 byte    REQ_SET_FEATURE
1571e     00 00       |                 word    0       ' port power
15720     01 00       |                 word    1       ' Port index number (1+)
15722     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
15724     23          | clr_port_feat   byte    (DIR_HOST_TO_DEV | TYPE_CLASS | RECIP_OTHER)
15725     01          |                 byte    REQ_CLEAR_FEATURE
15726     00 00       |                 word    0       ' port power
15728     01 00       |                 word    1       ' Port index number (1+)
1572a     00 00       |                 word    0       ' Number of bytes to transfer if there is a data stage
1572c     A3          | get_port_status byte    (DIR_DEV_TO_HOST | TYPE_CLASS | RECIP_OTHER)
1572d     00          |                 byte    REQ_GET_STATUS
1572e     00 00       |                 word    0
15730     01 00       |                 word    1       ' Port index number (1+)
15732     04 00       |                 word    4       ' Number of bytes to transfer if there is a data stage
15734                 | '------------------------------------------------------------------------------
15734                 | if _HAVE_GAMEPAD
15734     42 0C 00 00 | ps3_enable_cmd  byte    $42, $0C, $00, $00
15738                 | ps3_command_buff
15738     00 00 00 00 
1573c     00          |                 byte    $00, $00, $00, $00, $00
1573d     00 00 00 00 
15741     02          |                 byte    $00, $00, $00, $00, $00 | (%0001 << 1) ' TODO led(s) to turn on
15742     FF 27 10 00 
15746     32          |                 byte    $FF, $27, $10, $00, $32
15747     FF 27 10 00 
1574b     32          |                 byte    $FF, $27, $10, $00, $32
1574c     FF 27 10 00 
15750     32          |                 byte    $FF, $27, $10, $00, $32
15751     FF 27 10 00 
15755     32          |                 byte    $FF, $27, $10, $00, $32
15756     00 00 00 00 
1575a     00          |                 byte    $00, $00, $00, $00, $00
1575b     00 00 00 00 
1575f     00          |                 byte    $00, $00, $00, $00, $00
15760     00 00 00 00 
15764     00          |                 byte    $00, $00, $00, $00, $00
15765     00 00 00    |                 byte    $00, $00, $00
15768                 | '------------------------------------------------------------------------------
15768     01 03 06    | xinp_led_cmd    byte    $01, $03, $06   ' 0x00 All off
1576b                 |                                         ' 0x01 All blinking
1576b                 |                                         ' 0x02 1 flashes, then on
1576b                 |                                         ' 0x03 2 flashes, then on
1576b                 |                                         ' 0x04 3 flashes, then on
1576b                 |                                         ' 0x05 4 flashes, then on
1576b                 |                                         ' 0x06 1 on
1576b                 |                                         ' 0x07 2 on
1576b                 |                                         ' 0x08 3 on
1576b                 |                                         ' 0x09 4 on
1576b                 |                                         ' 0x0A Rotating (e.g. 1-2-4-3)
1576b                 |                                         ' 0x0B Blinking*
1576b                 |                                         ' 0x0C Slow blinking*
1576b                 |                                         ' 0x0D Alternating (e.g. 1+4-2+3), then back to previous*
1576b     00 08 00    | xinp_rumble_cmd byte    $00, $08, $00
1576e     00          |                 byte    $00             ' Left rumble
1576f     00          |                 byte    $00             ' Right rumble
15770     00 00 00    |                 byte    $00, $00, $00
15773                 | 
15773                 | xinp_fix_8bitdo '' This inexplicable String request (that WILL fail) somehow un-bugs the terrible firmware
15773                 |                 '' of certain wired 8bitdo gamepads.
15773     80          |                 byte    (DIR_DEV_TO_HOST | TYPE_STANDARD | RECIP_DEVICE)
15774     06          |                 byte    REQ_GET_DESC
15775     04 03       |                 word    TYPE_STRING << 8 + 4
15777     09 04       |                 word    $0409   ' Zero or Language ID (Section 9.6.7)
15779     02 00       |                 word    2       ' Number of bytes to transfer if there is a data stage
1577b     00          | end
1577c                 | alignl
1577c                 | 
1577c                 | if HAVE_MOUSE
1577c     00 00 00 00 
15780     00 00 00 00 | mouse_limits long 0[2]
15784     00 00 00 00 | mouse_outptr long 0
15788                 | end
15788                 | 
15788                 | if KEYQUEUE_SIZE > 0
15788     00          | keyq_head byte 0
15789     00          | keyq_tail byte 0
1578a     00 00 00 00 
      ...             
15986     00 00 00 00 
1598a     00 00       | keyq_data long 0[KEYQUEUE_SIZE]
1598c                 | alignl
1598c                 | end
1598c                 | 
1598c                 | if EMUPAD_MAX_PLAYER > 0
1598c                 | emupad_rule_buffer
1598c                 | if EMUPAD_BUILTIN_RULES
1598c                 | file "padmap_builtin.dat"
1598c                 | end
1598c                 | byte 0[@emupad_rule_buffer + EMUPAD_MAX_RULES*_EMUPAD_RULE_SIZE - $]
1598c                 | '' Default rule directly follows!
1598c                 | byte long -1, 255, 1,2,3,4,5,6,7,8,9,10
1598c                 | end
1598c                 | 
1598c                 | '------------------------------------------------------------------------------
1598c                 | ' The USB data cache area gets zero-filled at every device disconnect
1598c                 | '------------------------------------------------------------------------------
1598c                 | usb_cache_start
1598c                 | 
1598c                 | ' HID descriptor and report buffers
1598c                 | if !!OVERLAP_MEMORY
1598c     00 00 00 00 
      ...             
16084     00 00 00 00 
16088     00 00 00 00 | hid_descr       byte    0[HID_DESCR_LEN * MAX_DEVICES]
1608c                 | end
1608c     00 00 00 00 
16090     00 00 00 00 | hkbd_report     byte    0[8]
16094     00 00 00 00 | hkbd_led_rep    byte    0
16098                 | alignl
16098                 | 
16098     00 00 00 00 
1609c     00 00 00 00 
160a0     00 00 00 00 
160a4     00 00 00 00 
160a8     00 00 00 00 | hid_stack       long 0[(hidr_end - hidr_state) * 1]
160ac                 | 
160ac                 | if HAVE_HIDPAD
160ac     00 00 00 00 
      ...             
16184     00 00 00 00 
16188     00 00 00 00 | hidpad_report   byte    0[MAX_DEVICES*HIDPAD_REPORT_SIZE]
1618c                 | end
1618c                 | 
1618c                 | ' HUB descriptor
1618c     00          | hub_descr       byte    0   ' bDescLength
1618d     00          |                 byte    0   ' bDescriptorType
1618e     00          |                 byte    0   ' bNbrPorts
1618f     00 00       |                 word    0   ' wHubCharacteristics
16191     00          |                 byte    0   ' bPwrOn2PwrGood
16192     00          |                 byte    0   ' bHubContrCurrent
16193     00          |                 byte    0   ' DeviceRemoveable
16194     00          |                 byte    0   ' PortPwrCtrlMask
16195                 | 
16195                 | usb_cache_end
16195                 | 
16195                 | if HAVE_MOUSE
16195     00 00 00 00 | mouse_xacc      long 0
16199     00 00 00 00 | mouse_yacc      long 0
1619d     00 00 00 00 | mouse_zacc      long 0
161a1     00          | mouse_bstate    byte 0
161a2     00          | mouse_lpending  byte 0
161a3     00          | mouse_rpending  byte 0
161a4     00          | mouse_mpending  byte 0
161a5     00          | mouse_lock      byte 0
161a6     00 00 00    |                 byte 0[3] ' padding
161a9                 | end
161a9                 | 
161a9     00 00 00 00 
      ...             
16221     00 00 00 00 
16225     00 00 00 00 | urx_buff        byte    0[URX_BUFF_LEN]         ' USB IN DATAx scratch buffer
16229     00 00 00 00 
1622d     00 00 00 00 
16231     00 00 00 00 
16235     00 00 00 00 
16239     00 00       | dev_desc_buff   byte    0[DEV_DESC_LEN]         ' Device descriptor
1623b     00 00 00 00 
      ...             
16333     00 00 00 00 
16337     00 00 00 00 | con_desc_buff   byte    0[CON_BUFF_LEN]         ' Configuration descriptor chain
1633b                 | 
1633b     00          | driver_cog      byte    0                       ' Current driver cog + 1
1633c                 | 	alignl
1633c                 | _Audio2_004_spin2_dat_
1633c                 | 
1633c                 | audio       	org     0
1633c                 | 
1633c     61 79 05 FB |             	rdlong  mailbox2, ptra++     	' get start address of all mailboxes
16340     61 B1 05 FB |             	rdlong  scbase, ptra++       	' get start address of scope buffer
16344     61 BD 05 FB |             	rdlong  hubptr, ptra++       	' get start address of PSRAM cache
16348                 | 
16348     01 EC 63 FD |             	cogid   pa                   	' compute cogid
1634c     0C EC 07 FA |             	mul     pa, #12              	' and mailbox spacing
16350     F6 79 01 F1 |             	add     mailbox2, pa         	' add offset to find this COG's mailbox
16354     BC 76 01 F6 |             	mov     mailbox, mailbox2     	' we need 2 copies of this to enable switching between hub and psram
16358                 | 
16358     0E BA 05 FC |             	wrpin   dac2,#left           	' PWM DACs at 44100@339 MHz
1635c     0E BE 15 FC |             	wxpin   sr44100,#left      	' 30*256
16360     0F BA 05 FC |             	wrpin   dac2,#right
16364     0F BE 15 FC |             	wxpin   sr44100,#right    
16368     41 9C 64 FD |             	dirh    #left addpins 1
1636c     20 9C 64 FD |             	setse1  #%001<<6 + left      	' Set the event - DAC empty
16370                 |   'debug(uhex(mailbox))
16370                 |             
16370                 | '---------------------------------------------------------------------------------        
16370                 | '----------------- The main loop -------------------------------------------------
16370                 | '---------------------------------------------------------------------------------
16370                 | 
16370     0F A8 05 F6 | loop       	mov 	    cn,#15 '7
16374                 |               					'   waitx ##3300000  		'for debug
16374                 |             
16374                 | '----------------------------------------------------------------------------------
16374                 | '------------- Get parameters and execute commands if any -------------------------
16374                 | '----------------------------------------------------------------------------------
16374                 | 
16374                 | 
16374     1A F6 61 FD | p401        	getct ct1
16378     D4 70 01 F6 |                 mov     channeladd,cn             	' compute the pointer to channel parameters block
1637c     06 70 65 F0 |             	shl     channeladd,#6
16380     B8 F0 03 F1 |             	add     ptra,channeladd
16384                 | 
16384     28 1A 64 FD |             	setq    #13                       	' read parameters
16388     00 7F 05 FB |             	rdlong  pointer0,ptra
1638c     1F 92 1D F4 | p408        	bitl    command0,#31 wcz	      	' bit #31 command - set the DAC sample rate
16390     2C 00 90 3D |     	if_nc   jmp     #p404                     	' if not set, proceed
16394     C9 72 01 F6 |             	mov     qq,command0             	' get the new rate
16398     4E 72 15 FC |             	wxpin   qq,#left addpins 1        	' and program the pins
1639c     B9 72 E1 F8 |             	getbyte qq,qq,#0 		      	' check if the rate is n*256
163a0     00 72 0D F2 |             	cmp     qq,#0 wz                         
163a4     4E BA 05 AC |     	if_z    wrpin   dac2,#left addpins 1      	' if yes, set PWM DAC mode
163a8     4E B8 05 5C |     	if_nz   wrpin   dac,#left addpins 1       	' else set noise DAC mode
163ac                 |                 
163ac     1E 88 1D F4 |                	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
163b0     00 7E 05 A6 |     	if_z    mov     pointer0, #0  
163b4     00 80 05 A6 |     	if_z    mov     pointer0h, #0  
163b8     00 86 05 A6 |     	if_z    mov     envph0, #0  
163bc     05 89 65 AC |     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
163c0                 |     	
163c0     C4 72 01 F6 | p404        	mov     qq,sstart0		     	' check if start>$80000
163c4     FF FF 03 FF 
163c8     FF 73 05 F5 | 		and 	qq,##$7FFFFFF 
163cc     00 04 00 FF 
163d0     00 72 1D F2 |                 cmp 	qq,##$80000 wcz
163d4     BC 76 01 36 |     	if_ge   mov     mailbox,mailbox2          	' if yes, use PSRAM
163d8     00 76 05 C6 |     	if_lt   mov     mailbox,#0                	' if not, use HUB 
163dc                 |  ''debug(uhex(sstart0,mailbox))
163dc     C7 A4 39 F9 | p405           	getword apan0,volpan0,#1          	' extract vol,pan from longs 
163e0     C7 A2 31 F9 |     	    	getword avol0,volpan0,#0
163e4                 |     	'   debug(uhex(pointer0,pointer0h,sstart0)) 	
163e4                 | '----------------------------------------------------------------------------------
163e4                 | '------------- Compute the envelope, if exists ------------------------------------
163e4                 | '----------------------------------------------------------------------------------
163e4                 |             
163e4     00 94 1D F2 |             	cmp     envptr0,#0 wcz     		' read the pointer
163e8     20 00 00 AF 
163ec     00 F0 05 A6 |     	if_z    mov     envs1,##$4000			' if 0, no envelope, load $4000=1 for scas
163f0     54 00 90 AD |     	if_z    jmp     #p410				' and run away	
163f4                 | 
163f4     CB 86 01 F1 |            	add     envph0,envspd0			' envelope PA update
163f8                 |            	           
163f8     C3 EC 01 F6 |       	    	mov     envhi, envph0			' move phase acc to high part of env pointer
163fc     06 EC 45 F0 | 		shr     envhi,#6			' leave 10 bits in hi
16400     F6 EE 31 F9 | 	   	getword envlo,envhi,#0              	' and 16 bit in lo
16404     10 EC 45 F0 | 	    	shr     envhi,#16			' move 10 bits of hi to the lower word
16408     CC EC 19 F2 | 	    	cmp     envhi,envlen0 wcz		' compare this to envelope length
1640c                 | 	    											'debug(udec(envhi,envlen0))
1640c     CC EC 01 36 |     	if_ge  	mov     envhi,envlen0			' if greater than, set it at envlen
16410     00 EE 05 36 |     	if_ge   mov     envlo,#0
16414     CC 86 01 36 |     	if_ge   mov     envph0,envlen0             	' and set envph0 at the end of the envelope
16418     16 86 65 30 |     	if_ge   shl     envph0,#22
1641c                 | 
1641c     F6 F0 01 F6 |             	mov 	envs1,envhi			' 10 high bits of PA is the offset to the envelope entry
16420     01 F0 65 F0 |             	shl 	envs1,#1                        ' these entries are 16 bit so multiply the offset by 2
16424     CA F0 01 F1 |             	add 	envs1,envptr0                   ' and add it to the pointer
16428     F8 F0 01 FB |             	rdlong 	envs1,envs1			' and then read 2 entries in one rdlong
1642c     F8 F2 39 F9 |             	getword envs2,envs1,#1			' then separate them		
16430     F8 F0 31 F9 |            	getword envs1,envs1,#0
16434     F7 F2 01 FA |             	mul     envs2,envlo                     ' and do linear interpolation based on lower bits of the offset
16438     F7 EE 21 F6 |             	not     envlo
1643c     F7 F0 01 FA |             	mul     envs1,envlo
16440     F9 F0 01 F1 |             	add     envs1,envs2
16444     12 F0 45 F0 |             	shr     envs1,#18			' we need only 14 bits for scas
16448                 |               
16448                 | '----------------------------------------------------------------------------------
16448                 | '------------- Generate the noise if bit 27 of the pointer is set -----------------
16448                 | '----------------------------------------------------------------------------------
16448                 | 
16448                 | 
16448                 |     	
16448                 | '----------------------------------------------------------------------------------
16448                 | '------------- Get the sample -----------------------------------------------------
16448                 | '----------------------------------------------------------------------------------    	
16448                 |  
16448     C0 A6 01 F6 | p410  		mov	oldptrh,pointer0h
1644c     C8 A0 F9 F8 |            	getbyte	afreq0,freqskip0,#3         	' the frequency is in 8:24 format, so get integer in afreq0
16450     08 90 65 F0 |            	shl	freqskip0,#8                	' and keep the fractional in freqskip0
16454     C8 7E 19 F1 |            	add     pointer0,freqskip0 wcz      	' compute the pointer to the next sample   
16458     D0 80 21 F1 |            	addx	pointer0h,afreq0  
1645c                 |           	
1645c     1B 88 0D F4 |    	   	testb   sstart0, #27 wz
16460     10 00 90 5D |     	if_nz	jmp #p412   	
16464     1B 74 61 CD |    	if_c  	getrnd  spl
16468     BA 84 41 C9 |    	if_c	rolword rawspl0,spl,#0	
1646c     C2 74 31 F9 |    		getword spl,rawspl0,#0
16470     90 00 90 FD |       	        jmp     #p406          	
16474                 |            	
16474                 |            	
16474     D3 80 19 F2 | p412 		cmp	pointer0h,oldptrh wcz
16478     58 00 90 AD |  	if_e 	jmp 	#p411				' if the pointer didn't change, no sample has to be read
1647c                 |      	
1647c     1F 88 0D F4 |             	testb   sstart0,#31 wz       	   	' bit 31 : 16 bit sample  
16480     01 80 65 A0 |      	if_z    shl     pointer0h,#1        
16484     1C 88 0D F4 |             	testb   sstart0,#28 wz  		' bit 28 : interleaved sample         
16488     01 80 65 A0 |      	if_z    shl     pointer0h,#1        
1648c                 | 												
1648c     C6 80 19 F2 |             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
16490     C6 80 81 31 |    	if_ge   sub     pointer0h,lend0       
16494     C5 80 01 31 |         if_ge   add     pointer0h,lstart0
16498     C6 80 19 F2 |             	cmp     pointer0h,lend0 wcz		' check if end of the loop reached
1649c     C6 80 01 36 |         if_ge   mov	pointer0h,lend0	
164a0                 |  
164a0     C0 72 01 F6 |              	mov     qq,pointer0h              	' compute place in the memory from where the sample will be loaded
164a4     C4 72 01 F1 |            	add     qq,sstart0            
164a8     FF FF 00 FF 
164ac     FF 73 05 F5 |            	and  	qq,##$1FF_FFFF
164b0     FF 77 5D F2 |            	cmps    mailbox,#$1FF wcz          	' the mailbox has to point somewhere not at the start of HUB RAM
164b4     B9 74 E1 EA |     	if_le   rdword  spl,qq                      	' if not, use HUB RAM for samples
164b8     00 01 B0 1D |     	if_gt   call    #cache_read
164bc     1F 88 0D F4 |                 testb   sstart0,#31 wz 
164c0     08 74 65 50 |     	if_nz   shl     spl,#8				' convert 8 to 16 bit if needed
164c4     01 80 45 A0 |         if_z    shr     pointer0h,#1
164c8     1C 88 0D F4 |                 testb   sstart0,#28 wz            
164cc     01 80 45 A0 |     	if_z    shr     pointer0h,#1    
164d0     BA 84 41 F9 |                 rolword rawspl0,spl,#0			' now rawspl0 has oldsample:newsample in it
164d4                 |               
164d4     C2 74 31 F9 | p411	      	getword spl,rawspl0,#0
164d8     C2 9E 39 F9 | 		getword oldspl,rawspl0,#1		' then separate them		
164dc                 | 
164dc                 |           '  debug(uhex(pointer0h,pointer0,spl,oldspl))
164dc                 | 
164dc                 | 
164dc     BF EE 01 F6 | 		mov	envlo,pointer0
164e0     12 EE 45 F0 | 		shr 	envlo,#18
164e4                 | 	
164e4     F7 74 31 FA |             	scas    spl,envlo                   	' and do linear interpolation
164e8     00 74 01 F6 |             	mov 	spl,0-0
164ec     F7 EE 21 F6 |             	not     envlo
164f0     1F 00 00 FF 
164f4     FF EF 05 F5 |           	and     envlo,##$3FFF
164f8     F7 9E 31 FA |            	scas    oldspl,envlo
164fc     00 9E 01 F6 |             	mov     oldspl,0-0
16500     CF 74 01 F1 |                 add     spl, oldspl
16504                 | 	 
16504     F8 74 31 FA | p406        	scas    spl, envs1
16508     00 74 01 F6 |             	mov     spl,0-0
1650c     D1 74 31 FA |             	scas    spl,avol0                 	' apply volume
16510     00 74 01 F6 |             	mov     spl,0-0
16514                 |  
16514     D2 74 31 FA |             	scas    spl,apan0                 	' apply pan
16518     00 AA 01 F6 |             	mov     ls0,0-0
1651c     20 00 00 FF 
16520     00 72 05 F6 |             	mov     qq,##16384
16524     D2 72 81 F1 |             	sub     qq,apan0
16528     B9 74 31 FA |             	scas    spl,qq
1652c     00 AC 01 F6 |             	mov     rs0, 0-0
16530                 |       
16530     D6 82 29 F9 |                 setword sample0,rs0,#1           	' pack samples into long
16534     D5 82 21 F9 |                 setword sample0,ls0,#0
16538                 |                 
16538     D5 7A 01 F1 |                 add  lsample,ls0
1653c     D6 7C 01 F1 |                 add  rsample,rs0
16540                 |              
16540     1E 88 1D F4 |             	bitl    sstart0, #30 wcz          	' if bit #30 of start pointer is set, the current pointers needs resetting  
16544     00 7E 05 A6 |     	if_z    mov     pointer0, #0  
16548     00 80 05 A6 |     	if_z    mov     pointer0h, #0  
1654c     00 86 05 A6 |     	if_z    mov     envph0, #0  
16550     05 89 65 AC |     	if_z    wrlong  sstart0, ptra[5]          	' reset bit #30 in hub
16554                 |             
16554     28 08 64 FD | p403        	setq #4                          	' write new pointer, sample values and env pointer to the hub
16558     00 7F 65 FC | 	       	wrlong  pointer0,ptra
1655c     B8 F0 83 F1 |             	sub     ptra, channeladd         	' reset the pointer to channel parameters
16560                 | 
16560     84 A9 7D FB |             	djnf    cn, #p401
16564                 | 
16564     0F 7C E5 F4 |             	bitnot rsample, #15
16568     0F 7A E5 F4 |             	bitnot lsample, #15
1656c     1A F8 61 FD |   							           	getct ct2  	'debug
16570     FB F8 81 F1 |   							          	sub ct2,ct1
16574                 |   							          	debug(udec(ct2))
16574     24 28 60 FD |             	waitse1
16578                 |           
16578     0E 7A 25 FC |            	wypin   lsample, #left              
1657c     0F 7C 25 FC |                 wypin   rsample, #right        
16580                 | 
16580     BD AE 21 F9 | 		setword oldsample, lsample,#0		' for oscilloscope
16584     BE AE 29 F9 | 		setword oldsample, rsample,#1
16588                 | 		
16588     00 7C 05 F6 |             	mov rsample, #0
1658c     00 7A 05 F6 |             	mov lsample, #0
16590                 | 
16590                 | '----------------------------------------------------------------------------------
16590                 | '------------- Oscilloscope  -----------------------------------------------------
16590                 | '----------------------------------------------------------------------------------   
16590                 | 		
16590     00 B0 0D F2 | 	    	cmp     scbase,#0 wz
16594     20 00 90 AD |     	if_z    jmp #p302	   
16598                 |  
16598     01 B6 15 F7 |             	incmod  scope,#1 wc            		'  todo: scope speed instead of const  
1659c     D9 B4 01 C6 |     	if_c    mov scptr2,scptr
165a0     02 B4 65 C0 |     	if_c    shl scptr2,#2
165a4     D8 B4 01 C1 |     	if_c    add scptr2,scbase     
165a8     60 B4 65 FC |             	wrlong scptr2,#$60
165ac     DA AE 61 CC |     	if_c    wrlong oldsample,scptr2
165b0     01 00 00 CF 
165b4     7F B2 05 C7 |     	if_c    incmod scptr,##639
165b8                 |             
165b8     B4 FD 9F FD |  p302           jmp     #loop            'loop
165bc                 | 
165bc                 | '----------------------------------------------------------------------------------
165bc                 | '------------- This is the end of the main loop -----------------------------------
165bc                 | '----------------------------------------------------------------------------------
165bc                 | 
165bc                 | '----------------------------------------------------------------------------------
165bc                 | '------------- PSRAM cache ----------- --------------------------------------------
165bc                 | '----------------------------------------------------------------------------------
165bc                 | 
165bc                 | ' There are 16 cache pointers for 16 channels
165bc                 | ' if 24 higher bits of address=cache, then get a word from the cache
165bc                 | ' else load the cache from PSRAM, update the pointer, then read a sample
165bc                 | 
165bc                 | 
165bc     B9 E6 E1 F8 | cache_read  	getbyte addrlo,qq,#0 			' when this is called, qq is the addres of the sample			
165c0                 |          '   debug ("cache")
165c0     B9 E8 01 F6 | 	   	mov     addrhi,qq		
165c4     08 E8 45 F0 | 	    	shr     addrhi,#8		        ' get 24 upper bits
165c8     E0 A8 95 F9 | 	    	alts    cn,#cache1            
165cc     00 E8 09 F2 | 	    	cmp	addrhi,0-0 wz               	' and compare with the cache pointer for the channel
165d0     34 00 90 AD |    	if_z    jmp     #p701	    			' if equal, cache hit, read the sample from it
165d4                 | 
165d4     E0 A8 8D F9 | p702	    	altd    cn,#cache1			' cache miss. 
165d8     F4 00 00 F6 | 	    	mov     0-0,addrhi                  	' update the pointer
165dc                 | 	    ''	 debug(uhex(addrhi))
165dc     F4 E0 01 F6 | 	    	mov     cmd,addrhi			' prepare the mailbox
165e0     08 E0 65 F0 | 	    	shl     cmd,#8
165e4     0B E0 3D F8 |             	setnib  cmd, #%1011, #7             	' read burst from the external memory
165e8     D4 E2 01 F6 |             	mov     hubaddr,cn                  	' to the channel cache
165ec     08 E2 65 F0 |             	shl     hubaddr,#8                  	'
165f0     DE E2 01 F1 |             	add     hubaddr,hubptr 
165f4     00 E5 05 F6 |             	mov     count,#256                  	' 256 bytes
165f8     28 04 64 FD |             	setq    #2                          	' write 3 longs
165fc     BB E0 61 FC |             	wrlong  cmd, mailbox                	' run it
16600     BB E0 01 FB | poll1       	rdlong  cmd, mailbox                	' poll mailbox for result
16604     FE E1 B5 FB |             	tjs     cmd, #poll1                 	' retry until valid 
16608                 |             
16608                 | 	
16608     D4 72 01 F6 | p701	    	mov     qq,cn				' cache hit
1660c     08 72 65 F0 | 	    	shl     qq,#8				' compute the cache start
16610     DE 72 01 F1 | 	    	add     qq,hubptr
16614     F3 72 01 F1 | 	    	add	qq,addrlo			' add 8 lower bits to the cache addredd
16618     B9 74 E1 0A |     	_ret_   rdword  spl,qq                      	' read a long from the cache
1661c                 |           
1661c                 |   
1661c                 | 
1661c                 | 
1661c                 | '---------------------------------------------------------------------------
1661c                 | '------- Variables ---------------------------------------------------------
1661c                 | '---------------------------------------------------------------------------
1661c                 | 
1661c                 | ' constants
1661c                 | 
1661c     00 00 00 00 | channeladd 	long 0
16620                 | 
16620                 | ' temporary variables 
16620                 | 
16620     00 00 00 00 | qq          	long 0
16624     00 00 00 00 | spl         	long 0
16628     00 00 00 00 | mailbox     	long 0
1662c     00 00 00 00 | mailbox2    	long 0
16630     00 00 00 00 | lsample     	long 0
16634     00 00 00 00 | rsample     	long 0
16638                 | 
16638                 | ' channel parameter block
16638                 | 
16638     00 00 00 00 | pointer0    	long 0   
1663c     00 00 00 00 | pointer0h   	long 0  
16640     00 00 00 00 | sample0     	long 0
16644     00 00 00 00 | rawspl0	    	long 0
16648     00 00 00 00 | envph0	    	long 0
1664c     00 00 00 00 | sstart0     	long 0     ' start pointer and type at bit 31
16650     00 00 00 00 | lstart0     	long 0
16654     00 00 00 00 | lend0       	long 0
16658     00 00 00 00 | volpan0     	long 0
1665c     00 00 00 00 | freqskip0   	long 0
16660     00 00 00 00 | command0    	long 0
16664     00 00 00 00 | envptr0	    	long 0
16668     00 00 00 00 | envspd0	    	long 0
1666c     00 00 00 00 | envlen0	    	long 0
16670     00 00 00 00 | res5	    	long 0
16674     00 00 00 00 | res6	    	long 0
16678                 | 
16678     00 00 00 00 | oldspl		long 0
1667c     00 00 00 00 | afreq0      	long 0
16680                 | 
16680     00 00 00 00 | avol0       	long 0
16684     00 00 00 00 | apan0       	long 0
16688     00 00 00 00 | oldptrh	    	long 0
1668c     00 00 00 00 | cn          	long 0
16690                 | 
16690                 | ' Samples
16690                 | 
16690     00 00 00 00 | ls0         	long 0
16694     00 00 00 00 | rs0         	long 0
16698                 | 
16698     00 00 00 00 | oldsample   	long 0
1669c                 | 
1669c     00 00 00 00 | scbase 		long 0
166a0     00 00 00 00 | scptr 		long 0
166a4     00 00 00 00 | scptr2		long 0
166a8     00 00 00 00 | scope 		long 0
166ac                 | 
166ac     44 00 17 00 | dac         	long %10111_00000000_01_00010_0     	'random dither
166b0     46 00 17 00 | dac2        	long %10111_00000000_01_00011_0     	'pwm
166b4                 | 
166b4     00 18 07 00 | hubptr      	long $71800
166b8     00 1E 00 00 | sr44100     	long 30*256
166bc                 | 
166bc     00 00 00 00 | cache1      	long 0
166c0     00 00 00 00 | cache2      	long 0
166c4     00 00 00 00 | cache3      	long 0
166c8     00 00 00 00 | cache4      	long 0
166cc     00 00 00 00 | cache5      	long 0
166d0     00 00 00 00 | cache6      	long 0
166d4     00 00 00 00 | cache7      	long 0
166d8     00 00 00 00 | cache8      	long 0
166dc     00 00 00 00 | cache9      	long 0
166e0     00 00 00 00 | cachea      	long 0
166e4     00 00 00 00 | cacheb      	long 0
166e8     00 00 00 00 | cachec      	long 0
166ec     00 00 00 00 | cached      	long 0
166f0     00 00 00 00 | cachee      	long 0
166f4     00 00 00 00 | cachef      	long 0
166f8     00 00 00 00 | cache0      	long 0
166fc                 | 
166fc     00 00 00 00 | cmd         	long 0
16700     00 00 00 00 | hubaddr    	long 0
16704     00 01 00 00 | count       	long 256
16708                 | 
16708     00 00 00 00 | addrlo 		long 0
1670c     00 00 00 00 | addrhi 		long 0
16710     00 00 00 00 | pointer00 	long 0
16714     00 00 00 00 | envhi 		long 0
16718     00 00 00 00 | envlo 		long 0
1671c     00 00 00 00 | envs1 		long 0
16720     00 00 00 00 | envs2 		long 0
16724     00 00 00 00 | noise0 		long 0
16728                 | 
16728     00 00 00 00 |  ct1 		long 0
1672c     00 00 00 00 |  ct2 		long 0
16730                 | 
16730                 | 		fit 256		'todo: maybe the better interpolation. Or all params in cog
16730                 | 		fit 256		'todo: maybe the better interpolation. Or all params in cog
16730     00 00 00 00 
16734     00 00 00 00 | null  			long 	0,0           ' for channel reset
16738                 | 	alignl
16738                 | __system__dat_
16738     00 00 00 00 
1673c     00 00 00 00 | 	byte	$00[8]
16740     03 00 00 00 
16744     00 00 00 00 
16748     00 00 00 00 
1674c     00 00 00 00 | 	byte	$03, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
16750     00 00 00 00 
      ...             
169dc     00 00 00 00 
169e0     00 00 00 00 | 	byte	$00[660]
169e4     00 00 80 00 | 	long	(8 {__system____root_opendir})<<20
169e8     00 00 90 00 | 	long	(9 {__system____root_closedir})<<20
169ec     00 00 A0 00 | 	long	(10 {__system____root_readdir})<<20
169f0     00 00 B0 00 | 	long	(11 {__system____root_stat})<<20
169f4     00 00 00 00 
      ...             
16a18     00 00 00 00 
16a1c     00 00 00 00 | 	byte	$00[44]
16a20     01 80 00 00 
16a24     00 00 00 00 
16a28     00 00 00 00 
16a2c     00 00 00 00 | 	byte	$01, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
16a30     00 00 00 00 | 	byte	$00, $00, $00, $00
16a34     00 00 90 02 | 	long	(41 {__system___tx})<<20
16a38     00 00 A0 02 | 	long	(42 {__system___rx})<<20
16a3c     00 00 00 00 | 	byte	$00, $00, $00, $00
16a40     00 00 B0 02 | 	long	(43 {__system___rxtxioctl_0227})<<20
16a44     00 00 C0 02 | 	long	(44 {__system____dummy_flush_0228})<<20
16a48     00 00 00 00 
16a4c     00 00 00 00 | 	byte	$00[8]
16a50     01 00 00 00 
16a54     02 80 00 00 
16a58     00 00 00 00 
16a5c     00 00 00 00 | 	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
16a60     00 00 00 00 
16a64     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
16a68     00 00 90 02 | 	long	(41 {__system___tx})<<20
16a6c     00 00 A0 02 | 	long	(42 {__system___rx})<<20
16a70     00 00 00 00 | 	byte	$00, $00, $00, $00
16a74     00 00 B0 02 | 	long	(43 {__system___rxtxioctl_0227})<<20
16a78     00 00 C0 02 | 	long	(44 {__system____dummy_flush_0228})<<20
16a7c     00 00 00 00 
16a80     00 00 00 00 | 	byte	$00[8]
16a84     01 00 00 00 
16a88     02 80 00 00 
16a8c     00 00 00 00 
16a90     00 00 00 00 | 	byte	$01, $00, $00, $00, $02, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
16a94     00 00 00 00 
16a98     00 00 00 00 | 	byte	$00, $00, $00, $00, $00, $00, $00, $00
16a9c     00 00 90 02 | 	long	(41 {__system___tx})<<20
16aa0     00 00 A0 02 | 	long	(42 {__system___rx})<<20
16aa4     00 00 00 00 | 	byte	$00, $00, $00, $00
16aa8     00 00 B0 02 | 	long	(43 {__system___rxtxioctl_0227})<<20
16aac     00 00 C0 02 | 	long	(44 {__system____dummy_flush_0228})<<20
16ab0     00 00 00 00 
      ...             
16c1c     00 00 00 00 
16c20     00 00 00 00 | 	byte	$00[372]
16c24                 | 	alignl
16c24                 | _fatfs_cc_dat_
16c24     C7 00 FC 00 
16c28     E9 00 E2 00 
16c2c     E4 00 E0 00 
16c30     E5 00 E7 00 | 	byte	$c7, $00, $fc, $00, $e9, $00, $e2, $00, $e4, $00, $e0, $00, $e5, $00, $e7, $00
16c34     EA 00 EB 00 
16c38     E8 00 EF 00 
16c3c     EE 00 EC 00 
16c40     C4 00 C5 00 | 	byte	$ea, $00, $eb, $00, $e8, $00, $ef, $00, $ee, $00, $ec, $00, $c4, $00, $c5, $00
16c44     C9 00 E6 00 
16c48     C6 00 F4 00 
16c4c     F6 00 F2 00 
16c50     FB 00 F9 00 | 	byte	$c9, $00, $e6, $00, $c6, $00, $f4, $00, $f6, $00, $f2, $00, $fb, $00, $f9, $00
16c54     FF 00 D6 00 
16c58     DC 00 F8 00 
16c5c     A3 00 D8 00 
16c60     D7 00 92 01 | 	byte	$ff, $00, $d6, $00, $dc, $00, $f8, $00, $a3, $00, $d8, $00, $d7, $00, $92, $01
16c64     E1 00 ED 00 
16c68     F3 00 FA 00 
16c6c     F1 00 D1 00 
16c70     AA 00 BA 00 | 	byte	$e1, $00, $ed, $00, $f3, $00, $fa, $00, $f1, $00, $d1, $00, $aa, $00, $ba, $00
16c74     BF 00 AE 00 
16c78     AC 00 BD 00 
16c7c     BC 00 A1 00 
16c80     AB 00 BB 00 | 	byte	$bf, $00, $ae, $00, $ac, $00, $bd, $00, $bc, $00, $a1, $00, $ab, $00, $bb, $00
16c84     91 25 92 25 
16c88     93 25 02 25 
16c8c     24 25 C1 00 
16c90     C2 00 C0 00 | 	byte	$91, $25, $92, $25, $93, $25, $02, $25, $24, $25, $c1, $00, $c2, $00, $c0, $00
16c94     A9 00 63 25 
16c98     51 25 57 25 
16c9c     5D 25 A2 00 
16ca0     A5 00 10 25 | 	byte	$a9, $00, $63, $25, $51, $25, $57, $25, $5d, $25, $a2, $00, $a5, $00, $10, $25
16ca4     14 25 34 25 
16ca8     2C 25 1C 25 
16cac     00 25 3C 25 
16cb0     E3 00 C3 00 | 	byte	$14, $25, $34, $25, $2c, $25, $1c, $25, $00, $25, $3c, $25, $e3, $00, $c3, $00
16cb4     5A 25 54 25 
16cb8     69 25 66 25 
16cbc     60 25 50 25 
16cc0     6C 25 A4 00 | 	byte	$5a, $25, $54, $25, $69, $25, $66, $25, $60, $25, $50, $25, $6c, $25, $a4, $00
16cc4     F0 00 D0 00 
16cc8     CA 00 CB 00 
16ccc     C8 00 31 01 
16cd0     CD 00 CE 00 | 	byte	$f0, $00, $d0, $00, $ca, $00, $cb, $00, $c8, $00, $31, $01, $cd, $00, $ce, $00
16cd4     CF 00 18 25 
16cd8     0C 25 88 25 
16cdc     84 25 A6 00 
16ce0     CC 00 80 25 | 	byte	$cf, $00, $18, $25, $0c, $25, $88, $25, $84, $25, $a6, $00, $cc, $00, $80, $25
16ce4     D3 00 DF 00 
16ce8     D4 00 D2 00 
16cec     F5 00 D5 00 
16cf0     B5 00 FE 00 | 	byte	$d3, $00, $df, $00, $d4, $00, $d2, $00, $f5, $00, $d5, $00, $b5, $00, $fe, $00
16cf4     DE 00 DA 00 
16cf8     DB 00 D9 00 
16cfc     FD 00 DD 00 
16d00     AF 00 B4 00 | 	byte	$de, $00, $da, $00, $db, $00, $d9, $00, $fd, $00, $dd, $00, $af, $00, $b4, $00
16d04     AD 00 B1 00 
16d08     17 20 BE 00 
16d0c     B6 00 A7 00 
16d10     F7 00 B8 00 | 	byte	$ad, $00, $b1, $00, $17, $20, $be, $00, $b6, $00, $a7, $00, $f7, $00, $b8, $00
16d14     B0 00 A8 00 
16d18     B7 00 B9 00 
16d1c     B3 00 B2 00 
16d20     A0 25 A0 00 | 	byte	$b0, $00, $a8, $00, $b7, $00, $b9, $00, $b3, $00, $b2, $00, $a0, $25, $a0, $00
16d24     61 00 1A 03 
16d28     E0 00 17 03 
16d2c     F8 00 07 03 
16d30     FF 00 01 00 | 	byte	$61, $00, $1a, $03, $e0, $00, $17, $03, $f8, $00, $07, $03, $ff, $00, $01, $00
16d34     78 01 00 01 
16d38     30 01 32 01 
16d3c     06 01 39 01 
16d40     10 01 4A 01 | 	byte	$78, $01, $00, $01, $30, $01, $32, $01, $06, $01, $39, $01, $10, $01, $4a, $01
16d44     2E 01 79 01 
16d48     06 01 80 01 
16d4c     4D 00 43 02 
16d50     81 01 82 01 | 	byte	$2e, $01, $79, $01, $06, $01, $80, $01, $4d, $00, $43, $02, $81, $01, $82, $01
16d54     82 01 84 01 
16d58     84 01 86 01 
16d5c     87 01 87 01 
16d60     89 01 8A 01 | 	byte	$82, $01, $84, $01, $84, $01, $86, $01, $87, $01, $87, $01, $89, $01, $8a, $01
16d64     8B 01 8B 01 
16d68     8D 01 8E 01 
16d6c     8F 01 90 01 
16d70     91 01 91 01 | 	byte	$8b, $01, $8b, $01, $8d, $01, $8e, $01, $8f, $01, $90, $01, $91, $01, $91, $01
16d74     93 01 94 01 
16d78     F6 01 96 01 
16d7c     97 01 98 01 
16d80     98 01 3D 02 | 	byte	$93, $01, $94, $01, $f6, $01, $96, $01, $97, $01, $98, $01, $98, $01, $3d, $02
16d84     9B 01 9C 01 
16d88     9D 01 20 02 
16d8c     9F 01 A0 01 
16d90     A0 01 A2 01 | 	byte	$9b, $01, $9c, $01, $9d, $01, $20, $02, $9f, $01, $a0, $01, $a0, $01, $a2, $01
16d94     A2 01 A4 01 
16d98     A4 01 A6 01 
16d9c     A7 01 A7 01 
16da0     A9 01 AA 01 | 	byte	$a2, $01, $a4, $01, $a4, $01, $a6, $01, $a7, $01, $a7, $01, $a9, $01, $aa, $01
16da4     AB 01 AC 01 
16da8     AC 01 AE 01 
16dac     AF 01 AF 01 
16db0     B1 01 B2 01 | 	byte	$ab, $01, $ac, $01, $ac, $01, $ae, $01, $af, $01, $af, $01, $b1, $01, $b2, $01
16db4     B3 01 B3 01 
16db8     B5 01 B5 01 
16dbc     B7 01 B8 01 
16dc0     B8 01 BA 01 | 	byte	$b3, $01, $b3, $01, $b5, $01, $b5, $01, $b7, $01, $b8, $01, $b8, $01, $ba, $01
16dc4     BB 01 BC 01 
16dc8     BC 01 BE 01 
16dcc     F7 01 C0 01 
16dd0     C1 01 C2 01 | 	byte	$bb, $01, $bc, $01, $bc, $01, $be, $01, $f7, $01, $c0, $01, $c1, $01, $c2, $01
16dd4     C3 01 C4 01 
16dd8     C5 01 C4 01 
16ddc     C7 01 C8 01 
16de0     C7 01 CA 01 | 	byte	$c3, $01, $c4, $01, $c5, $01, $c4, $01, $c7, $01, $c8, $01, $c7, $01, $ca, $01
16de4     CB 01 CA 01 
16de8     CD 01 10 01 
16dec     DD 01 01 00 
16df0     8E 01 DE 01 | 	byte	$cb, $01, $ca, $01, $cd, $01, $10, $01, $dd, $01, $01, $00, $8e, $01, $de, $01
16df4     12 01 F3 01 
16df8     03 00 F1 01 
16dfc     F4 01 F4 01 
16e00     F8 01 28 01 | 	byte	$12, $01, $f3, $01, $03, $00, $f1, $01, $f4, $01, $f4, $01, $f8, $01, $28, $01
16e04     22 02 12 01 
16e08     3A 02 09 00 
16e0c     65 2C 3B 02 
16e10     3B 02 3D 02 | 	byte	$22, $02, $12, $01, $3a, $02, $09, $00, $65, $2c, $3b, $02, $3b, $02, $3d, $02
16e14     66 2C 3F 02 
16e18     40 02 41 02 
16e1c     41 02 46 02 
16e20     0A 01 53 02 | 	byte	$66, $2c, $3f, $02, $40, $02, $41, $02, $41, $02, $46, $02, $0a, $01, $53, $02
16e24     40 00 81 01 
16e28     86 01 55 02 
16e2c     89 01 8A 01 
16e30     58 02 8F 01 | 	byte	$40, $00, $81, $01, $86, $01, $55, $02, $89, $01, $8a, $01, $58, $02, $8f, $01
16e34     5A 02 90 01 
16e38     5C 02 5D 02 
16e3c     5E 02 5F 02 
16e40     93 01 61 02 | 	byte	$5a, $02, $90, $01, $5c, $02, $5d, $02, $5e, $02, $5f, $02, $93, $01, $61, $02
16e44     62 02 94 01 
16e48     64 02 65 02 
16e4c     66 02 67 02 
16e50     97 01 96 01 | 	byte	$62, $02, $94, $01, $64, $02, $65, $02, $66, $02, $67, $02, $97, $01, $96, $01
16e54     6A 02 62 2C 
16e58     6C 02 6D 02 
16e5c     6E 02 9C 01 
16e60     70 02 71 02 | 	byte	$6a, $02, $62, $2c, $6c, $02, $6d, $02, $6e, $02, $9c, $01, $70, $02, $71, $02
16e64     9D 01 73 02 
16e68     74 02 9F 01 
16e6c     76 02 77 02 
16e70     78 02 79 02 | 	byte	$9d, $01, $73, $02, $74, $02, $9f, $01, $76, $02, $77, $02, $78, $02, $79, $02
16e74     7A 02 7B 02 
16e78     7C 02 64 2C 
16e7c     7E 02 7F 02 
16e80     A6 01 81 02 | 	byte	$7a, $02, $7b, $02, $7c, $02, $64, $2c, $7e, $02, $7f, $02, $a6, $01, $81, $02
16e84     82 02 A9 01 
16e88     84 02 85 02 
16e8c     86 02 87 02 
16e90     AE 01 44 02 | 	byte	$82, $02, $a9, $01, $84, $02, $85, $02, $86, $02, $87, $02, $ae, $01, $44, $02
16e94     B1 01 B2 01 
16e98     45 02 8D 02 
16e9c     8E 02 8F 02 
16ea0     90 02 91 02 | 	byte	$b1, $01, $b2, $01, $45, $02, $8d, $02, $8e, $02, $8f, $02, $90, $02, $91, $02
16ea4     B7 01 7B 03 
16ea8     03 00 FD 03 
16eac     FE 03 FF 03 
16eb0     AC 03 04 00 | 	byte	$b7, $01, $7b, $03, $03, $00, $fd, $03, $fe, $03, $ff, $03, $ac, $03, $04, $00
16eb4     86 03 88 03 
16eb8     89 03 8A 03 
16ebc     B1 03 11 03 
16ec0     C2 03 02 00 | 	byte	$86, $03, $88, $03, $89, $03, $8a, $03, $b1, $03, $11, $03, $c2, $03, $02, $00
16ec4     A3 03 A3 03 
16ec8     C4 03 08 03 
16ecc     CC 03 03 00 
16ed0     8C 03 8E 03 | 	byte	$a3, $03, $a3, $03, $c4, $03, $08, $03, $cc, $03, $03, $00, $8c, $03, $8e, $03
16ed4     8F 03 D8 03 
16ed8     18 01 F2 03 
16edc     0A 00 F9 03 
16ee0     F3 03 F4 03 | 	byte	$8f, $03, $d8, $03, $18, $01, $f2, $03, $0a, $00, $f9, $03, $f3, $03, $f4, $03
16ee4     F5 03 F6 03 
16ee8     F7 03 F7 03 
16eec     F9 03 FA 03 
16ef0     FA 03 30 04 | 	byte	$f5, $03, $f6, $03, $f7, $03, $f7, $03, $f9, $03, $fa, $03, $fa, $03, $30, $04
16ef4     20 03 50 04 
16ef8     10 07 60 04 
16efc     22 01 8A 04 
16f00     36 01 C1 04 | 	byte	$20, $03, $50, $04, $10, $07, $60, $04, $22, $01, $8a, $04, $36, $01, $c1, $04
16f04     0E 01 CF 04 
16f08     01 00 C0 04 
16f0c     D0 04 44 01 
16f10     61 05 26 04 | 	byte	$0e, $01, $cf, $04, $01, $00, $c0, $04, $d0, $04, $44, $01, $61, $05, $26, $04
16f14     00 00 7D 1D 
16f18     01 00 63 2C 
16f1c     00 1E 96 01 
16f20     A0 1E 5A 01 | 	byte	$00, $00, $7d, $1d, $01, $00, $63, $2c, $00, $1e, $96, $01, $a0, $1e, $5a, $01
16f24     00 1F 08 06 
16f28     10 1F 06 06 
16f2c     20 1F 08 06 
16f30     30 1F 08 06 | 	byte	$00, $1f, $08, $06, $10, $1f, $06, $06, $20, $1f, $08, $06, $30, $1f, $08, $06
16f34     40 1F 06 06 
16f38     51 1F 07 00 
16f3c     59 1F 52 1F 
16f40     5B 1F 54 1F | 	byte	$40, $1f, $06, $06, $51, $1f, $07, $00, $59, $1f, $52, $1f, $5b, $1f, $54, $1f
16f44     5D 1F 56 1F 
16f48     5F 1F 60 1F 
16f4c     08 06 70 1F 
16f50     0E 00 BA 1F | 	byte	$5d, $1f, $56, $1f, $5f, $1f, $60, $1f, $08, $06, $70, $1f, $0e, $00, $ba, $1f
16f54     BB 1F C8 1F 
16f58     C9 1F CA 1F 
16f5c     CB 1F DA 1F 
16f60     DB 1F F8 1F | 	byte	$bb, $1f, $c8, $1f, $c9, $1f, $ca, $1f, $cb, $1f, $da, $1f, $db, $1f, $f8, $1f
16f64     F9 1F EA 1F 
16f68     EB 1F FA 1F 
16f6c     FB 1F 80 1F 
16f70     08 06 90 1F | 	byte	$f9, $1f, $ea, $1f, $eb, $1f, $fa, $1f, $fb, $1f, $80, $1f, $08, $06, $90, $1f
16f74     08 06 A0 1F 
16f78     08 06 B0 1F 
16f7c     04 00 B8 1F 
16f80     B9 1F B2 1F | 	byte	$08, $06, $a0, $1f, $08, $06, $b0, $1f, $04, $00, $b8, $1f, $b9, $1f, $b2, $1f
16f84     BC 1F CC 1F 
16f88     01 00 C3 1F 
16f8c     D0 1F 02 06 
16f90     E0 1F 02 06 | 	byte	$bc, $1f, $cc, $1f, $01, $00, $c3, $1f, $d0, $1f, $02, $06, $e0, $1f, $02, $06
16f94     E5 1F 01 00 
16f98     EC 1F F3 1F 
16f9c     01 00 FC 1F 
16fa0     4E 21 01 00 | 	byte	$e5, $1f, $01, $00, $ec, $1f, $f3, $1f, $01, $00, $fc, $1f, $4e, $21, $01, $00
16fa4     32 21 70 21 
16fa8     10 02 84 21 
16fac     01 00 83 21 
16fb0     D0 24 1A 05 | 	byte	$32, $21, $70, $21, $10, $02, $84, $21, $01, $00, $83, $21, $d0, $24, $1a, $05
16fb4     30 2C 2F 04 
16fb8     60 2C 02 01 
16fbc     67 2C 06 01 
16fc0     75 2C 02 01 | 	byte	$30, $2c, $2f, $04, $60, $2c, $02, $01, $67, $2c, $06, $01, $75, $2c, $02, $01
16fc4     80 2C 64 01 
16fc8     00 2D 26 08 
16fcc     41 FF 1A 03 
16fd0     00 00 01 03 | 	byte	$80, $2c, $64, $01, $00, $2d, $26, $08, $41, $ff, $1a, $03, $00, $00, $01, $03
16fd4     05 07 09 0E 
16fd8     10 12 14 16 
16fdc     18 1C 1E 43 
16fe0     55 45 41 41 | 	byte	$05, $07, $09, $0e, $10, $12, $14, $16, $18, $1c, $1e, $43, $55, $45, $41, $41
16fe4     41 41 43 45 
16fe8     45 45 49 49 
16fec     49 41 41 45 
16ff0     92 92 4F 4F | 	byte	$41, $41, $43, $45, $45, $45, $49, $49, $49, $41, $41, $45, $92, $92, $4f, $4f
16ff4     4F 55 55 59 
16ff8     4F 55 4F 9C 
16ffc     4F 9E 9F 41 
17000     49 4F 55 A5 | 	byte	$4f, $55, $55, $59, $4f, $55, $4f, $9c, $4f, $9e, $9f, $41, $49, $4f, $55, $a5
17004     A5 A6 A7 A8 
17008     A9 AA AB AC 
1700c     AD AE AF B0 
17010     B1 B2 B3 B4 | 	byte	$a5, $a6, $a7, $a8, $a9, $aa, $ab, $ac, $ad, $ae, $af, $b0, $b1, $b2, $b3, $b4
17014     41 41 41 B8 
17018     B9 BA BB BC 
1701c     BD BE BF C0 
17020     C1 C2 C3 C4 | 	byte	$41, $41, $41, $b8, $b9, $ba, $bb, $bc, $bd, $be, $bf, $c0, $c1, $c2, $c3, $c4
17024     C5 41 41 C8 
17028     C9 CA CB CC 
1702c     CD CE CF D1 
17030     D1 45 45 45 | 	byte	$c5, $41, $41, $c8, $c9, $ca, $cb, $cc, $cd, $ce, $cf, $d1, $d1, $45, $45, $45
17034     49 49 49 49 
17038     D9 DA DB DC 
1703c     DD 49 DF 4F 
17040     E1 4F 4F 4F | 	byte	$49, $49, $49, $49, $d9, $da, $db, $dc, $dd, $49, $df, $4f, $e1, $4f, $4f, $4f
17044     4F E6 E8 E8 
17048     55 55 55 59 
1704c     59 EE EF F0 
17050     F1 F2 F3 F4 | 	byte	$4f, $e6, $e8, $e8, $55, $55, $55, $59, $59, $ee, $ef, $f0, $f1, $f2, $f3, $f4
17054     F5 F6 F7 F8 
17058     F9 FA FB FC 
1705c     FD FE FF 00 
17060     00 00 00 00 | 	byte	$f5, $f6, $f7, $f8, $f9, $fa, $fb, $fc, $fd, $fe, $ff, $00, $00, $00, $00, $00
17064     00 00 00 00 
17068     FF FF FF FF 
1706c     1F 00 00 00 
17070     1C 00 00 00 | 	byte	$00, $00, $00, $00, $ff, $ff, $ff, $ff, $1f, $00, $00, $00, $1c, $00, $00, $00
17074     1F 00 00 00 
17078     1E 00 00 00 
1707c     1F 00 00 00 
17080     1E 00 00 00 | 	byte	$1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00
17084     1F 00 00 00 
17088     1F 00 00 00 
1708c     1E 00 00 00 
17090     1F 00 00 00 | 	byte	$1f, $00, $00, $00, $1f, $00, $00, $00, $1e, $00, $00, $00, $1f, $00, $00, $00
17094     1E 00 00 00 
17098     1F 00 00 00 
1709c     00 00 00 00 
170a0     1F 00 00 00 | 	byte	$1e, $00, $00, $00, $1f, $00, $00, $00, $00, $00, $00, $00, $1f, $00, $00, $00
170a4     3B 00 00 00 
170a8     5A 00 00 00 
170ac     78 00 00 00 
170b0     97 00 00 00 | 	byte	$3b, $00, $00, $00, $5a, $00, $00, $00, $78, $00, $00, $00, $97, $00, $00, $00
170b4     B5 00 00 00 
170b8     D4 00 00 00 
170bc     F3 00 00 00 
170c0     11 01 00 00 | 	byte	$b5, $00, $00, $00, $d4, $00, $00, $00, $f3, $00, $00, $00, $11, $01, $00, $00
170c4     30 01 00 00 
170c8     4E 01 00 00 
170cc     6D 01 00 00 
170d0     FF FF FF FF | 	byte	$30, $01, $00, $00, $4e, $01, $00, $00, $6d, $01, $00, $00, $ff, $ff, $ff, $ff
170d4     00 00 00 00 
      ...             
170f0     00 00 00 00 
170f4     00 00 00 00 | 	byte	$00[36]
170f8     16 71 01 00 | 	long	@@@_fatfs_cc_dat_ + 1266
170fc     1A 71 01 00 | 	long	@@@_fatfs_cc_dat_ + 1270
17100     00 00 00 00 
17104     00 00 00 00 
17108     00 00 00 00 
1710c     00 00 00 00 
17110     00 00       | 	byte	$00[18]
17112     3F 3F 3F 00 
17116     55 43 54 00 
1711a     55 43 54 00 
1711e     00 00 00 00 | 	byte	$3f, $3f, $3f, $00, $55, $43, $54, $00, $55, $43, $54, $00, $00, $00, $00, $00
17122     00 00 00 00 
17126     00 00 00    | 	byte	$00[7]
17129     CA 9A 3B 00 
1712d     00 00 00 01 
17131     01 01 01 01 
17135     01 01 01 01 | 	byte	$ca, $9a, $3b, $00, $00, $00, $00, $01, $01, $01, $01, $01, $01, $01, $01, $01
17139     91 11 11 11 
1713d     11 01 01 01 
17141     01 01 01 01 
17145     01 01 01 01 | 	byte	$91, $11, $11, $11, $11, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01, $01
17149     01 01 01 01 
1714d     01 01 01    | 	byte	$01[7]
17150     90 20 20 20 
17154     20 20 20 20 
17158     20 20 20 20 
1715c     20 20 20 20 | 	byte	$90, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
17160     42 42 42 42 
17164     42 42 42 42 
17168     42 42       | 	byte	$42[10]
1716a     20 20 20 20 
1716e     20 20 20    | 	byte	$20[7]
17171     44 44 44 44 
17175     44 44       | 	byte	$44[6]
17177     04 04 04 04 
1717b     04 04 04 04 
1717f     04 04 04 04 
17183     04 04 04 04 
17187     04 04 04 04 | 	byte	$04[20]
1718b     20 20 20 20 
1718f     20 20       | 	byte	$20[6]
17191     48 48 48 48 
17195     48 48       | 	byte	$48[6]
17197     08 08 08 08 
1719b     08 08 08 08 
1719f     08 08 08 08 
171a3     08 08 08 08 
171a7     08 08 08 08 | 	byte	$08[20]
171ab     20 20 20 20 
171af     01 00 00 00 
171b3     00          | 	byte	$20, $20, $20, $20, $01, $00, $00, $00, $00
171b4                 | __methodtable__
171b4     00 00 00 00 | 	long	0
171b8     9C 1A 00 00 | 	long	@_hg010b_spin2_putchar
171bc     F0 E1 00 00 | 	long	@__system___struct___bas_wrap_sender_tx_
171c0     34 E2 00 00 | 	long	@__system___struct___bas_wrap_sender_rx_
171c4     7C E2 00 00 | 	long	@__system___struct___bas_wrap_sender_close_
171c8     20 E1 00 00 | 	long	@__system___struct__s_vfs_file_t_putchar_
171cc     90 E1 00 00 | 	long	@__system___struct__s_vfs_file_t_getchar_
171d0     D8 E0 00 00 | 	long	@__system____strs_cl_pfunc_
171d4     EC 5F 00 00 | 	long	@__system____root_opendir
171d8     88 60 00 00 | 	long	@__system____root_closedir
171dc     04 60 00 00 | 	long	@__system____root_readdir
171e0     90 60 00 00 | 	long	@__system____root_stat
171e4     80 5B 00 00 | 	long	@__system____default_putc
171e8     FC 5A 00 00 | 	long	@__system____default_getc
171ec     2C 5C 00 00 | 	long	@__system____default_flush
171f0     40 D4 00 00 | 	long	@_fatfs_cc_v_close
171f4     28 D7 00 00 | 	long	@_fatfs_cc_v_read
171f8     B4 D7 00 00 | 	long	@_fatfs_cc_v_write
171fc     2C D8 00 00 | 	long	@_fatfs_cc_v_lseek
17200     C8 D8 00 00 | 	long	@_fatfs_cc_v_ioctl
17204     F4 D9 00 00 | 	long	@_fatfs_cc_v_flush
17208     1C D9 00 00 | 	long	@_fatfs_cc_v_open
1720c     AC D3 00 00 | 	long	@_fatfs_cc_v_creat
17210     7C D4 00 00 | 	long	@_fatfs_cc_v_opendir
17214     F0 D4 00 00 | 	long	@_fatfs_cc_v_closedir
17218     30 D5 00 00 | 	long	@_fatfs_cc_v_readdir
1721c     FC D5 00 00 | 	long	@_fatfs_cc_v_stat
17220     DC D8 00 00 | 	long	@_fatfs_cc_v_mkdir
17224     FC D8 00 00 | 	long	@_fatfs_cc_v_rmdir
17228     EC D8 00 00 | 	long	@_fatfs_cc_v_remove
1722c     0C D9 00 00 | 	long	@_fatfs_cc_v_rename
17230     40 DA 00 00 | 	long	@_fatfs_cc_v_init
17234     48 DA 00 00 | 	long	@_fatfs_cc_v_deinit
17238     40 78 00 00 | 	long	@_sdmm_cc_v_read
1723c     4C 78 00 00 | 	long	@_sdmm_cc_v_write
17240     28 79 00 00 | 	long	@_sdmm_cc_v_close
17244     58 78 00 00 | 	long	@_sdmm_cc_v_ioctl
17248     20 79 00 00 | 	long	@_sdmm_cc_v_flush
1724c     7C 78 00 00 | 	long	@_sdmm_cc_v_lseek
17250     50 79 00 00 | 	long	@_sdmm_cc_v_putc
17254     9C 79 00 00 | 	long	@_sdmm_cc_v_getc
17258     C4 31 00 00 | 	long	@__system___tx
1725c     04 32 00 00 | 	long	@__system___rx
17260     70 67 00 00 | 	long	@__system___rxtxioctl_0227
17264     C8 67 00 00 | 	long	@__system____dummy_flush_0228
17268                 | __heap_base
17268     00 00 00 00 
      ...             
2e968     00 00 00 00 
2e96c     00 00 00 00 | 	long	0[24002]
2e970                 | objmem
2e970     00 00 00 00 
      ...             
333cc     00 00 00 00 
333d0     00 00 00 00 | 	long	0[4761]
333d4                 | stackspace
333d4     00 00 00 00 | 	long	0[1]
333d8 13e             | 	org	COG_BSS_START
333d8 13e             | _var01
333d8 13e             | 	res	1
333d8 13f             | _var02
333d8 13f             | 	res	1
333d8 140             | _var03
333d8 140             | 	res	1
333d8 141             | _var04
333d8 141             | 	res	1
333d8 142             | _var05
333d8 142             | 	res	1
333d8 143             | _var06
333d8 143             | 	res	1
333d8 144             | _var07
333d8 144             | 	res	1
333d8 145             | _var08
333d8 145             | 	res	1
333d8 146             | _var09
333d8 146             | 	res	1
333d8 147             | _var10
333d8 147             | 	res	1
333d8 148             | arg01
333d8 148             | 	res	1
333d8 149             | arg02
333d8 149             | 	res	1
333d8 14a             | arg03
333d8 14a             | 	res	1
333d8 14b             | arg04
333d8 14b             | 	res	1
333d8 14c             | arg05
333d8 14c             | 	res	1
333d8 14d             | arg06
333d8 14d             | 	res	1
333d8 14e             | arg07
333d8 14e             | 	res	1
333d8 14f             | arg08
333d8 14f             | 	res	1
333d8 150             | arg09
333d8 150             | 	res	1
333d8 151             | arg10
333d8 151             | 	res	1
333d8 152             | arg11
333d8 152             | 	res	1
333d8 153             | local01
333d8 153             | 	res	1
333d8 154             | local02
333d8 154             | 	res	1
333d8 155             | local03
333d8 155             | 	res	1
333d8 156             | local04
333d8 156             | 	res	1
333d8 157             | local05
333d8 157             | 	res	1
333d8 158             | local06
333d8 158             | 	res	1
333d8 159             | local07
333d8 159             | 	res	1
333d8 15a             | local08
333d8 15a             | 	res	1
333d8 15b             | local09
333d8 15b             | 	res	1
333d8 15c             | local10
333d8 15c             | 	res	1
333d8 15d             | local11
333d8 15d             | 	res	1
333d8 15e             | local12
333d8 15e             | 	res	1
333d8 15f             | local13
333d8 15f             | 	res	1
333d8 160             | local14
333d8 160             | 	res	1
333d8 161             | local15
333d8 161             | 	res	1
333d8 162             | local16
333d8 162             | 	res	1
333d8 163             | local17
333d8 163             | 	res	1
333d8 164             | local18
333d8 164             | 	res	1
333d8 165             | local19
333d8 165             | 	res	1
333d8 166             | local20
333d8 166             | 	res	1
333d8 167             | local21
333d8 167             | 	res	1
333d8 168             | local22
333d8 168             | 	res	1
333d8 169             | local23
333d8 169             | 	res	1
333d8 16a             | local24
333d8 16a             | 	res	1
333d8 16b             | local25
333d8 16b             | 	res	1
333d8 16c             | local26
333d8 16c             | 	res	1
333d8 16d             | local27
333d8 16d             | 	res	1
333d8 16e             | local28
333d8 16e             | 	res	1
333d8 16f             | local29
333d8 16f             | 	res	1
333d8 170             | local30
333d8 170             | 	res	1
333d8 171             | local31
333d8 171             | 	res	1
333d8 172             | local32
333d8 172             | 	res	1
333d8 173             | local33
333d8 173             | 	res	1
333d8 174             | local34
333d8 174             | 	res	1
333d8 175             | local35
333d8 175             | 	res	1
333d8 176             | local36
333d8 176             | 	res	1
333d8 177             | local37
333d8 177             | 	res	1
333d8 178             | local38
333d8 178             | 	res	1
333d8 179             | local39
333d8 179             | 	res	1
333d8 17a             | local40
333d8 17a             | 	res	1
333d8 17b             | local41
333d8 17b             | 	res	1
333d8 17c             | muldiva_
333d8 17c             | 	res	1
333d8 17d             | muldivb_
333d8 17d             | 	res	1
333d8 17e             | 	fit	480
333d8 17e             | 
